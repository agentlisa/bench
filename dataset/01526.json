{
  "Title": "M-1: setVoteFactor() does not change existing supply of votes. As a result, some may be unable to withdraw.",
  "Content": "# Issue M-1: setVoteFactor() does not change existing supply of votes. As a result, some may be unable to withdraw. \n\nSource: https://github.com/sherlock-audit/2023-06-tokensoft-judging/issues/55 \n\n## Found by \n0xDjango, 0xbranded, AkshaySrivastav, BenRai, Czar102, Yuki, auditsea, caventa, jkoppel, mau, p12473, pengun, r0bert\n## Summary\n\n`AdvancedDistributor.setVoteFactor()` does not change existing supply of vote tokens. If it is called before all distribution records have been initialized, there will be a skew between those who initialized before and those who initialized after. Further, if it is increased, those who initialized before will not have enough vote tokens to withdraw.\n\n## Vulnerability Detail\n\nIncrease scenario (very bad):\n\n1. Owner makes airdrop and sets vote factor to 1.  Many people get a claim to 1000 airdrop tokens.\n2. People initialize their distribution records.  They are minted 1000 vote tokens.\n3. Owner sets vote factor to 2\n4. The airdrop tokens vest\n5. No-one who already initialized their distribution record can withdraw anything because they don't have enough vote tokens. (Vote tokens are burned when executing a claim.)\n\nDecrease scenario (less bad):\n\n1. Owner makes an airdrop for 1000 people managed by a CrosschainMerkleDistribution and sets vote factor to 1000\n8. User Speedy Gonzalez calls initializeDistributionRecord() for himself\n9. Owner decides to change the vote factor to 1 instead\n10. All other users only get 1 voting token, but Speedy still has 1000\n\n## Impact\n\n### Increase scenario\n\nIf the vote factor is increased after deploying the contract, some people will not be able to withdraw, period.\n\nIt is still possible, however, for the owner of the contract to sweep the contract and manually give people their airdrop.\n\n### Decrease scenario\n\nCannot change vote factor after deploying contract without skewing existing votes.\n\nNote there is no other mechanism to mint or burn vote tokens to correct this.\n\nThere is no code that currently uses voting, so this is potentially of no consequence.\n\nHowever, presumably the voting functionality exists for a reason, and will be used by other code. In particular, the implementation of adjust() takes care to preserve people's number of voting tokens. As the distributor contracts are not upgradeable, this means no fair elections can be run atop airdrops deployed with the current code after setVoteFactor is called.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-tokensoft/blob/main/contracts/contracts/claim/abstract/AdvancedDistributor.sol#L181\n\n```solidity\nfunction setVoteFactor(uint256 _voteFactor) external onlyOwner {\n    voteFactor = _voteFactor;\n    emit SetVoteFactor(voteFactor);\n  }\n```\n\nsetVoteFactor does not change supply\n\nhttps://github.com/sherlock-audit/2023-06-tokensoft/blob/main/contracts/contracts/claim/abstract/AdvancedDistributor.sol#L77\n\n```solidity\n function _initializeDistributionRecord(\n    address beneficiary,\n    uint256 totalAmount\n  ) internal virtual override {\n    super._initializeDistributionRecord(beneficiary, totalAmount);\n\n    // add voting power through ERC20Votes extension\n    _mint(beneficiary, tokensToVotes(totalAmount));\n  }\n```\n\nVoting tokens are minted at distribution record initialization time. \n\nhttps://github.com/sherlock-audit/2023-06-tokensoft/blob/main/contracts/contracts/claim/abstract/AdvancedDistributor.sol#L87\n\n```solidity\n    function _executeClaim(\n    address beneficiary,\n    uint256 totalAmount\n  ) internal virtual override returns (uint256 _claimed) {\n    _claimed = super._executeClaim(beneficiary, totalAmount);\n\n    // reduce voting power through ERC20Votes extension\n    _burn(beneficiary, tokensToVotes(_claimed));\n  }\n```\n\n`tokensToVotes` uses the current voteFactor. If it has increased since someone's vote tokens were minted, they will not have enough tokens to burn, and so `executeClaim` will revert.\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nDo not use separate voting tokens for votes; just use the amount of unclaimed token\n\n\n\n## Discussion\n\n**cr-walker**\n\nThis is a valid issue.\n\nThe admin functions like `setVoteFactor()` should only be called by admins who know what they are doing, but I agree that this would result in unexpected behavior like locking funds due to burning too many vote tokens.\n\nProposed solution:\n* The reason we are using an internal votes token is to allow delegation, but I agree that using the unclaimed token would be simpler and generally better\n* we will either remove the `setVoteFactor` method or allow users to reset their voting power, e.g. using something like the solution to: https://github.com/sherlock-audit/2023-06-tokensoft-judging/issues/188\n\n**cr-walker**\n\nFixed by https://github.com/SoftDAO/contracts/pull/10\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/100",
  "Code": [
    {
      "filename": "contracts/contracts/claim/abstract/AdvancedDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport { ERC20Votes, ERC20Permit, ERC20 } from '@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol';\nimport { SafeERC20 } from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport { Distributor, DistributionRecord, IERC20 } from './Distributor.sol';\nimport { IAdjustable } from '../../interfaces/IAdjustable.sol';\nimport { IVoting } from '../../interfaces/IVoting.sol';\nimport { Sweepable } from '../../utilities/Sweepable.sol';\nimport { FairQueue } from '../../utilities/FairQueue.sol';\n\n/**\n * @title AdvancedDistributor\n * @notice Distributes tokens to beneficiaries with voting-while-vesting and administrative controls.\n * The contract owner can control these distribution parameters:\n * - the merkle root determining all distribution details\n * - adjustments to specific distributions\n * - the token being distributed\n * - the total amount to distribute\n * - the metadata URI\n * - the voting power of undistributed tokens\n * - the recipient of swept funds\n *\n * This contract also allows owners to perform several other admin functions\n * - updating the contract owner\n * - sweeping tokens and native currency to a recipient\n *\n * This contract tracks beneficiary voting power through an internal ERC20Votes token that cannot be transferred. The\n * beneficiary must delegate to an address to use this voting power. Their voting power decreases when the token is claimed.\n *\n * @dev Updates to the contract must follow these constraints:\n * - If a merkle root update alters the total token quantity to distribute across all users, also adjust the total value.\n *   The DistributionRecord for each beneficiary updated in the merkle root will be incorrect until a claim is executed.\n * - If the total changes, make sure to add or withdraw tokens being distributed to match the new total.\n */\nabstract contract AdvancedDistributor is\n  Ownable,\n  Sweepable,\n  ERC20Votes,\n  Distributor,\n  IAdjustable,\n  IVoting,\n  FairQueue\n{\n  using SafeERC20 for IERC20;\n\n  uint256 private voteFactor;\n\n  constructor(\n    IERC20 _token,\n    uint256 _total,\n    string memory _uri,\n    uint256 _voteFactor,\n    uint256 _fractionDenominator,\n    uint160 maxDelayTime,\n    uint160 salt\n  )\n    Distributor(_token, _total, _uri, _fractionDenominator)\n    ERC20Permit('Internal vote tracker')\n    ERC20('Internal vote tracker', 'IVT')\n    Sweepable(payable(msg.sender))\n    FairQueue(maxDelayTime, salt)\n  {\n    voteFactor = _voteFactor;\n    emit SetVoteFactor(voteFactor);\n  }\n\n  /**\n   * convert a token quantity to a vote quantity\n   */\n  function tokensToVotes(uint256 tokenAmount) private view returns (uint256) {\n    return (tokenAmount * voteFactor) / fractionDenominator;\n  }\n\n  function _initializeDistributionRecord(\n    address beneficiary,\n    uint256 totalAmount\n  ) internal virtual override {\n    super._initializeDistributionRecord(beneficiary, totalAmount);\n\n    // add voting power through ERC20Votes extension\n    _mint(beneficiary, tokensToVotes(totalAmount));\n  }\n\n  function _executeClaim(\n    address beneficiary,\n    uint256 totalAmount\n  ) internal virtual override returns (uint256 _claimed) {\n    _claimed = super._executeClaim(beneficiary, totalAmount);\n\n    // reduce voting power through ERC20Votes extension\n    _burn(beneficiary, tokensToVotes(_claimed));\n  }\n\n  /**\n   * @dev Adjust the quantity claimable by a user, overriding the value in the distribution record.\n   *\n   * Note: If used in combination with merkle proofs, adjustments to a beneficiary's total could be\n   * reset by anyone to the value in the merkle leaf at any time. Update the merkle root instead.\n   *\n   * Amount is limited to type(uint120).max to allow each DistributionRecord to be packed into a single storage slot.\n   */\n  function adjust(address beneficiary, int256 amount) external onlyOwner {\n    DistributionRecord memory distributionRecord = records[beneficiary];\n    require(distributionRecord.initialized, 'must initialize before adjusting');\n\n    uint256 diff = uint256(amount > 0 ? amount : -amount);\n    require(diff < type(uint120).max, 'adjustment > max uint120');\n\n    if (amount < 0) {\n      // decreasing claimable tokens\n      require(total >= diff, 'decrease greater than distributor total');\n      require(distributionRecord.total >= diff, 'decrease greater than distributionRecord total');\n      total -= diff;\n      records[beneficiary].total -= uint120(diff);\n      token.safeTransfer(owner(), diff);\n      // reduce voting power\n      _burn(beneficiary, tokensToVotes(diff));\n    } else {\n      // increasing claimable tokens\n      total += diff;\n      records[beneficiary].total += uint120(diff);\n      // increase voting pwoer\n      _mint(beneficiary, tokensToVotes(diff));\n    }\n\n    emit Adjust(beneficiary, amount);\n  }\n\n\n  function _setToken(IERC20 _token) internal virtual {\n    require(address(_token) != address(0), 'token is address(0)');\n    token = _token;\n    emit SetToken(token);\n  }\n\n  // Set the token being distributed\n  function setToken(IERC20 _token) external virtual onlyOwner {\n    _setToken(_token);\n  }\n\n  function _setTotal(uint256 _total) internal virtual {\n    total = _total;\n    emit SetTotal(total);\n  }\n\n  // Set the total to distribute\n  function setTotal(uint256 _total) external virtual onlyOwner {\n    _setTotal(_total);\n  }\n\n  // Set the distributor metadata URI\n  function setUri(string memory _uri) external onlyOwner {\n    uri = _uri;\n    emit SetUri(uri);\n  }\n\n  // set the recipient of swept funds\n  function setSweepRecipient(address payable _recipient) external onlyOwner {\n    _setSweepRecipient(_recipient);\n  }\n\n  function getTotalVotes() external view returns (uint256) {\n    // supply of internal token used to track voting power\n    return totalSupply();\n  }\n\n  function getVoteFactor(address) external view returns (uint256) {\n    return voteFactor;\n  }\n\n  /**\n\t* @notice Set the voting power of undistributed tokens\n\t* @param _voteFactor The voting power multiplier as a fraction of fractionDenominator\n\t* @dev The vote factor can be any integer. If voteFactor / fractionDenominator == 1,\n\t* one unclaimed token provides one vote. If voteFactor / fractionDenominator == 2, one\n\t* unclaimed token counts as two votes.\n\t*/\n  function setVoteFactor(uint256 _voteFactor) external onlyOwner {\n    voteFactor = _voteFactor;\n    emit SetVoteFactor(voteFactor);\n  }\n\n  /**\n   * @dev the internal token used only for tracking voting power cannot be transferred\n   */\n  function _approve(address, address, uint256) internal pure override {\n    revert('disabled for voting power');\n  }\n\n  /**\n   * @dev the internal token used only f\tor tracking voting power cannot be transferred\n   */\n  function _transfer(address, address, uint256) internal pure override {\n    revert('disabled for voting power');\n  }\n}"
    },
    {
      "filename": "contracts/contracts/claim/abstract/AdvancedDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport { ERC20Votes, ERC20Permit, ERC20 } from '@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol';\nimport { SafeERC20 } from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport { Distributor, DistributionRecord, IERC20 } from './Distributor.sol';\nimport { IAdjustable } from '../../interfaces/IAdjustable.sol';\nimport { IVoting } from '../../interfaces/IVoting.sol';\nimport { Sweepable } from '../../utilities/Sweepable.sol';\nimport { FairQueue } from '../../utilities/FairQueue.sol';\n\n/**\n * @title AdvancedDistributor\n * @notice Distributes tokens to beneficiaries with voting-while-vesting and administrative controls.\n * The contract owner can control these distribution parameters:\n * - the merkle root determining all distribution details\n * - adjustments to specific distributions\n * - the token being distributed\n * - the total amount to distribute\n * - the metadata URI\n * - the voting power of undistributed tokens\n * - the recipient of swept funds\n *\n * This contract also allows owners to perform several other admin functions\n * - updating the contract owner\n * - sweeping tokens and native currency to a recipient\n *\n * This contract tracks beneficiary voting power through an internal ERC20Votes token that cannot be transferred. The\n * beneficiary must delegate to an address to use this voting power. Their voting power decreases when the token is claimed.\n *\n * @dev Updates to the contract must follow these constraints:\n * - If a merkle root update alters the total token quantity to distribute across all users, also adjust the total value.\n *   The DistributionRecord for each beneficiary updated in the merkle root will be incorrect until a claim is executed.\n * - If the total changes, make sure to add or withdraw tokens being distributed to match the new total.\n */\nabstract contract AdvancedDistributor is\n  Ownable,\n  Sweepable,\n  ERC20Votes,\n  Distributor,\n  IAdjustable,\n  IVoting,\n  FairQueue\n{\n  using SafeERC20 for IERC20;\n\n  uint256 private voteFactor;\n\n  constructor(\n    IERC20 _token,\n    uint256 _total,\n    string memory _uri,\n    uint256 _voteFactor,\n    uint256 _fractionDenominator,\n    uint160 maxDelayTime,\n    uint160 salt\n  )\n    Distributor(_token, _total, _uri, _fractionDenominator)\n    ERC20Permit('Internal vote tracker')\n    ERC20('Internal vote tracker', 'IVT')\n    Sweepable(payable(msg.sender))\n    FairQueue(maxDelayTime, salt)\n  {\n    voteFactor = _voteFactor;\n    emit SetVoteFactor(voteFactor);\n  }\n\n  /**\n   * convert a token quantity to a vote quantity\n   */\n  function tokensToVotes(uint256 tokenAmount) private view returns (uint256) {\n    return (tokenAmount * voteFactor) / fractionDenominator;\n  }\n\n  function _initializeDistributionRecord(\n    address beneficiary,\n    uint256 totalAmount\n  ) internal virtual override {\n    super._initializeDistributionRecord(beneficiary, totalAmount);\n\n    // add voting power through ERC20Votes extension\n    _mint(beneficiary, tokensToVotes(totalAmount));\n  }\n\n  function _executeClaim(\n    address beneficiary,\n    uint256 totalAmount\n  ) internal virtual override returns (uint256 _claimed) {\n    _claimed = super._executeClaim(beneficiary, totalAmount);\n\n    // reduce voting power through ERC20Votes extension\n    _burn(beneficiary, tokensToVotes(_claimed));\n  }\n\n  /**\n   * @dev Adjust the quantity claimable by a user, overriding the value in the distribution record.\n   *\n   * Note: If used in combination with merkle proofs, adjustments to a beneficiary's total could be\n   * reset by anyone to the value in the merkle leaf at any time. Update the merkle root instead.\n   *\n   * Amount is limited to type(uint120).max to allow each DistributionRecord to be packed into a single storage slot.\n   */\n  function adjust(address beneficiary, int256 amount) external onlyOwner {\n    DistributionRecord memory distributionRecord = records[beneficiary];\n    require(distributionRecord.initialized, 'must initialize before adjusting');\n\n    uint256 diff = uint256(amount > 0 ? amount : -amount);\n    require(diff < type(uint120).max, 'adjustment > max uint120');\n\n    if (amount < 0) {\n      // decreasing claimable tokens\n      require(total >= diff, 'decrease greater than distributor total');\n      require(distributionRecord.total >= diff, 'decrease greater than distributionRecord total');\n      total -= diff;\n      records[beneficiary].total -= uint120(diff);\n      token.safeTransfer(owner(), diff);\n      // reduce voting power\n      _burn(beneficiary, tokensToVotes(diff));\n    } else {\n      // increasing claimable tokens\n      total += diff;\n      records[beneficiary].total += uint120(diff);\n      // increase voting pwoer\n      _mint(beneficiary, tokensToVotes(diff));\n    }\n\n    emit Adjust(beneficiary, amount);\n  }\n\n\n  function _setToken(IERC20 _token) internal virtual {\n    require(address(_token) != address(0), 'token is address(0)');\n    token = _token;\n    emit SetToken(token);\n  }\n\n  // Set the token being distributed\n  function setToken(IERC20 _token) external virtual onlyOwner {\n    _setToken(_token);\n  }\n\n  function _setTotal(uint256 _total) internal virtual {\n    total = _total;\n    emit SetTotal(total);\n  }\n\n  // Set the total to distribute\n  function setTotal(uint256 _total) external virtual onlyOwner {\n    _setTotal(_total);\n  }\n\n  // Set the distributor metadata URI\n  function setUri(string memory _uri) external onlyOwner {\n    uri = _uri;\n    emit SetUri(uri);\n  }\n\n  // set the recipient of swept funds\n  function setSweepRecipient(address payable _recipient) external onlyOwner {\n    _setSweepRecipient(_recipient);\n  }\n\n  function getTotalVotes() external view returns (uint256) {\n    // supply of internal token used to track voting power\n    return totalSupply();\n  }\n\n  function getVoteFactor(address) external view returns (uint256) {\n    return voteFactor;\n  }\n\n  /**\n\t* @notice Set the voting power of undistributed tokens\n\t* @param _voteFactor The voting power multiplier as a fraction of fractionDenominator\n\t* @dev The vote factor can be any integer. If voteFactor / fractionDenominator == 1,\n\t* one unclaimed token provides one vote. If voteFactor / fractionDenominator == 2, one\n\t* unclaimed token counts as two votes.\n\t*/\n  function setVoteFactor(uint256 _voteFactor) external onlyOwner {\n    voteFactor = _voteFactor;\n    emit SetVoteFactor(voteFactor);\n  }\n\n  /**\n   * @dev the internal token used only for tracking voting power cannot be transferred\n   */\n  function _approve(address, address, uint256) internal pure override {\n    revert('disabled for voting power');\n  }\n\n  /**\n   * @dev the internal token used only f\tor tracking voting power cannot be transferred\n   */\n  function _transfer(address, address, uint256) internal pure override {\n    revert('disabled for voting power');\n  }\n}"
    },
    {
      "filename": "contracts/contracts/claim/abstract/AdvancedDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport { ERC20Votes, ERC20Permit, ERC20 } from '@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol';\nimport { SafeERC20 } from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport { Distributor, DistributionRecord, IERC20 } from './Distributor.sol';\nimport { IAdjustable } from '../../interfaces/IAdjustable.sol';\nimport { IVoting } from '../../interfaces/IVoting.sol';\nimport { Sweepable } from '../../utilities/Sweepable.sol';\nimport { FairQueue } from '../../utilities/FairQueue.sol';\n\n/**\n * @title AdvancedDistributor\n * @notice Distributes tokens to beneficiaries with voting-while-vesting and administrative controls.\n * The contract owner can control these distribution parameters:\n * - the merkle root determining all distribution details\n * - adjustments to specific distributions\n * - the token being distributed\n * - the total amount to distribute\n * - the metadata URI\n * - the voting power of undistributed tokens\n * - the recipient of swept funds\n *\n * This contract also allows owners to perform several other admin functions\n * - updating the contract owner\n * - sweeping tokens and native currency to a recipient\n *\n * This contract tracks beneficiary voting power through an internal ERC20Votes token that cannot be transferred. The\n * beneficiary must delegate to an address to use this voting power. Their voting power decreases when the token is claimed.\n *\n * @dev Updates to the contract must follow these constraints:\n * - If a merkle root update alters the total token quantity to distribute across all users, also adjust the total value.\n *   The DistributionRecord for each beneficiary updated in the merkle root will be incorrect until a claim is executed.\n * - If the total changes, make sure to add or withdraw tokens being distributed to match the new total.\n */\nabstract contract AdvancedDistributor is\n  Ownable,\n  Sweepable,\n  ERC20Votes,\n  Distributor,\n  IAdjustable,\n  IVoting,\n  FairQueue\n{\n  using SafeERC20 for IERC20;\n\n  uint256 private voteFactor;\n\n  constructor(\n    IERC20 _token,\n    uint256 _total,\n    string memory _uri,\n    uint256 _voteFactor,\n    uint256 _fractionDenominator,\n    uint160 maxDelayTime,\n    uint160 salt\n  )\n    Distributor(_token, _total, _uri, _fractionDenominator)\n    ERC20Permit('Internal vote tracker')\n    ERC20('Internal vote tracker', 'IVT')\n    Sweepable(payable(msg.sender))\n    FairQueue(maxDelayTime, salt)\n  {\n    voteFactor = _voteFactor;\n    emit SetVoteFactor(voteFactor);\n  }\n\n  /**\n   * convert a token quantity to a vote quantity\n   */\n  function tokensToVotes(uint256 tokenAmount) private view returns (uint256) {\n    return (tokenAmount * voteFactor) / fractionDenominator;\n  }\n\n  function _initializeDistributionRecord(\n    address beneficiary,\n    uint256 totalAmount\n  ) internal virtual override {\n    super._initializeDistributionRecord(beneficiary, totalAmount);\n\n    // add voting power through ERC20Votes extension\n    _mint(beneficiary, tokensToVotes(totalAmount));\n  }\n\n  function _executeClaim(\n    address beneficiary,\n    uint256 totalAmount\n  ) internal virtual override returns (uint256 _claimed) {\n    _claimed = super._executeClaim(beneficiary, totalAmount);\n\n    // reduce voting power through ERC20Votes extension\n    _burn(beneficiary, tokensToVotes(_claimed));\n  }\n\n  /**\n   * @dev Adjust the quantity claimable by a user, overriding the value in the distribution record.\n   *\n   * Note: If used in combination with merkle proofs, adjustments to a beneficiary's total could be\n   * reset by anyone to the value in the merkle leaf at any time. Update the merkle root instead.\n   *\n   * Amount is limited to type(uint120).max to allow each DistributionRecord to be packed into a single storage slot.\n   */\n  function adjust(address beneficiary, int256 amount) external onlyOwner {\n    DistributionRecord memory distributionRecord = records[beneficiary];\n    require(distributionRecord.initialized, 'must initialize before adjusting');\n\n    uint256 diff = uint256(amount > 0 ? amount : -amount);\n    require(diff < type(uint120).max, 'adjustment > max uint120');\n\n    if (amount < 0) {\n      // decreasing claimable tokens\n      require(total >= diff, 'decrease greater than distributor total');\n      require(distributionRecord.total >= diff, 'decrease greater than distributionRecord total');\n      total -= diff;\n      records[beneficiary].total -= uint120(diff);\n      token.safeTransfer(owner(), diff);\n      // reduce voting power\n      _burn(beneficiary, tokensToVotes(diff));\n    } else {\n      // increasing claimable tokens\n      total += diff;\n      records[beneficiary].total += uint120(diff);\n      // increase voting pwoer\n      _mint(beneficiary, tokensToVotes(diff));\n    }\n\n    emit Adjust(beneficiary, amount);\n  }\n\n\n  function _setToken(IERC20 _token) internal virtual {\n    require(address(_token) != address(0), 'token is address(0)');\n    token = _token;\n    emit SetToken(token);\n  }\n\n  // Set the token being distributed\n  function setToken(IERC20 _token) external virtual onlyOwner {\n    _setToken(_token);\n  }\n\n  function _setTotal(uint256 _total) internal virtual {\n    total = _total;\n    emit SetTotal(total);\n  }\n\n  // Set the total to distribute\n  function setTotal(uint256 _total) external virtual onlyOwner {\n    _setTotal(_total);\n  }\n\n  // Set the distributor metadata URI\n  function setUri(string memory _uri) external onlyOwner {\n    uri = _uri;\n    emit SetUri(uri);\n  }\n\n  // set the recipient of swept funds\n  function setSweepRecipient(address payable _recipient) external onlyOwner {\n    _setSweepRecipient(_recipient);\n  }\n\n  function getTotalVotes() external view returns (uint256) {\n    // supply of internal token used to track voting power\n    return totalSupply();\n  }\n\n  function getVoteFactor(address) external view returns (uint256) {\n    return voteFactor;\n  }\n\n  /**\n\t* @notice Set the voting power of undistributed tokens\n\t* @param _voteFactor The voting power multiplier as a fraction of fractionDenominator\n\t* @dev The vote factor can be any integer. If voteFactor / fractionDenominator == 1,\n\t* one unclaimed token provides one vote. If voteFactor / fractionDenominator == 2, one\n\t* unclaimed token counts as two votes.\n\t*/\n  function setVoteFactor(uint256 _voteFactor) external onlyOwner {\n    voteFactor = _voteFactor;\n    emit SetVoteFactor(voteFactor);\n  }\n\n  /**\n   * @dev the internal token used only for tracking voting power cannot be transferred\n   */\n  function _approve(address, address, uint256) internal pure override {\n    revert('disabled for voting power');\n  }\n\n  /**\n   * @dev the internal token used only f\tor tracking voting power cannot be transferred\n   */\n  function _transfer(address, address, uint256) internal pure override {\n    revert('disabled for voting power');\n  }\n}"
    }
  ]
}