{
  "Title": "`Sun::setSoilAbovePeg` considers intervals for `caseId` larger than intended",
  "Content": "As is [commented](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/sun/SeasonFacet/Sun.sol#L219) in the NatSpec of [`Sun::setSoilAbovePeg`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/sun/SeasonFacet/Sun.sol#L226-L234), Beanstalk wants to gauge demand for Soil _when above peg_. As such, based on the implementation of [`InitBip13`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/init/InitBip13.sol#L18-L30), the following modifications should be made:\n\n```diff\n-   if (caseId >= 24) {\n+   if (caseId >= 28) {\n         newSoil = newSoil.mul(SOIL_COEFFICIENT_HIGH).div(C.PRECISION); // high podrate\n-   } else if (caseId < 8) {\n+   } else if (4 <= caseId < 8) {\n         newSoil = newSoil.mul(SOIL_COEFFICIENT_LOW).div(C.PRECISION); // low podrate\n    }\n```\n\nThis does not affect the Soil mechanism because the `caseId` [passed](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/sun/SeasonFacet/SeasonFacet.sol#L58) to [`Sun::stepSun`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/sun/SeasonFacet/Sun.sol#L66-L83) when called in [`SeasonFacet::gm`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/sun/SeasonFacet/SeasonFacet.sol#L47-L62) has already been correctly calculated from within [`Weather::stepWeather`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/sun/SeasonFacet/Weather.sol#L100-L172); however, it is recommended to modify the logic so that its implementation strictly conforms to its intention.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/beanstalk/sun/SeasonFacet/Sun.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"contracts/libraries/Decimal.sol\";\nimport \"contracts/libraries/LibSafeMath32.sol\";\nimport \"contracts/libraries/LibFertilizer.sol\";\nimport \"contracts/libraries/LibSafeMath128.sol\";\nimport \"contracts/libraries/LibPRBMath.sol\";\nimport \"contracts/C.sol\";\nimport \"./Oracle.sol\";\n\n/**\n * @title Sun\n * @author Publius\n * @notice Sun controls the minting of new Beans to Fertilizer, the Field, and the Silo.\n */\ncontract Sun is Oracle {\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n    using LibPRBMath for uint256;\n    using LibSafeMath32 for uint32;\n    using LibSafeMath128 for uint128;\n    using Decimal for Decimal.D256;\n\n    /// @dev When Fertilizer is Active, it receives 1/3 of new Bean mints.\n    uint256 private constant FERTILIZER_DENOMINATOR = 3;\n\n    /// @dev After Fertilizer, Harvestable Pods receive 1/2 of new Bean mints. \n    uint256 private constant HARVEST_DENOMINATOR = 2;\n\n    /// @dev When the Pod Rate is high, issue less Soil.\n    uint256 private constant SOIL_COEFFICIENT_HIGH = 0.5e18;\n    \n    /// @dev When the Pod Rate is low, issue more Soil.\n    uint256 private constant SOIL_COEFFICIENT_LOW = 1.5e18;\n\n    /**\n     * @notice Emitted during Sunrise when Beans are distributed to the Field, the Silo, and Fertilizer.\n     * @param season The Season in which Beans were distributed.\n     * @param toField The number of Beans distributed to the Field.\n     * @param toSilo The number of Beans distributed to the Silo.\n     * @param toFertilizer The number of Beans distributed to Fertilizer.\n     */\n    event Reward(\n        uint32 indexed season,\n        uint256 toField,\n        uint256 toSilo,\n        uint256 toFertilizer\n    );\n\n    /**\n     * @notice Emitted during Sunrise when Beanstalk adjusts the amount of available Soil.\n     * @param season The Season in which Soil was adjusted.\n     * @param soil The new amount of Soil available.\n     */\n    event Soil(\n        uint32 indexed season,\n        uint256 soil\n    );\n\n    //////////////////// SUN INTERNAL ////////////////////\n    \n    /**\n     * @param deltaB Pre-calculated deltaB from {Oracle.stepOracle}.\n     * @param caseId Pre-calculated Weather case from {Weather.stepWeather}.\n     */\n    function stepSun(int256 deltaB, uint256 caseId) internal {\n        // Above peg\n        if (deltaB > 0) {\n            uint256 newHarvestable = rewardBeans(uint256(deltaB));\n            setSoilAbovePeg(newHarvestable, caseId);\n            s.season.abovePeg = true;\n        } \n\n        // Below peg\n        else {\n            setSoil(uint256(-deltaB));\n            s.season.abovePeg = false;\n        }\n    }\n\n    //////////////////// REWARD BEANS ////////////////////\n\n    /**\n     * @dev Mints and distributes Beans to Fertilizer, the Field, and the Silo.\n     */\n    function rewardBeans(uint256 newSupply) internal returns (uint256 newHarvestable) {\n        uint256 newFertilized;\n        \n        C.bean().mint(address(this), newSupply);\n\n        // Distribute first to Fertilizer if some Fertilizer are active\n        if (s.season.fertilizing) {\n            newFertilized = rewardToFertilizer(newSupply);\n            newSupply = newSupply.sub(newFertilized);\n        }\n\n        // Distribute next to the Field if some Pods are still outstanding\n        if (s.f.harvestable < s.f.pods) {\n            newHarvestable = rewardToHarvestable(newSupply);\n            newSupply = newSupply.sub(newHarvestable);\n        }\n\n        // Distribute remainder to the Silo\n        rewardToSilo(newSupply);\n\n        emit Reward(s.season.current, newHarvestable, newSupply, newFertilized);\n    }\n\n    /**\n     * @dev Distributes Beans to Fertilizer.\n     */\n    function rewardToFertilizer(uint256 amount)\n        internal\n        returns (uint256 newFertilized)\n    {\n        // 1/3 of new Beans being minted\n        uint256 maxNewFertilized = amount.div(FERTILIZER_DENOMINATOR);\n\n        // Get the new Beans per Fertilizer and the total new Beans per Fertilizer\n        uint256 newBpf = maxNewFertilized.div(s.activeFertilizer);\n        uint256 oldTotalBpf = s.bpf;\n        uint256 newTotalBpf = oldTotalBpf.add(newBpf);\n\n        // Get the end Beans per Fertilizer of the first Fertilizer to run out.\n        uint256 firstEndBpf = s.fFirst;\n\n        // If the next fertilizer is going to run out, then step BPF according\n        while(newTotalBpf >= firstEndBpf) {\n            // Calculate BPF and new Fertilized when the next Fertilizer ID ends\n            newBpf = firstEndBpf.sub(oldTotalBpf);\n            newFertilized = newFertilized.add(newBpf.mul(s.activeFertilizer));\n\n            // If there is no more fertilizer, end\n            if (!LibFertilizer.pop()) {\n                s.bpf = uint128(firstEndBpf); // SafeCast unnecessary here.\n                s.fertilizedIndex = s.fertilizedIndex.add(newFertilized);\n                require(s.fertilizedIndex == s.unfertilizedIndex, \"Paid != owed\");\n                return newFertilized;\n            }\n\n            // Calculate new Beans per Fertilizer values\n            newBpf = maxNewFertilized.sub(newFertilized).div(s.activeFertilizer);\n            oldTotalBpf = firstEndBpf;\n            newTotalBpf = oldTotalBpf.add(newBpf);\n            firstEndBpf = s.fFirst;\n        }\n\n        // Distribute the rest of the Fertilized Beans\n        s.bpf = uint128(newTotalBpf); // SafeCast unnecessary here.\n        newFertilized = newFertilized.add(newBpf.mul(s.activeFertilizer));\n        s.fertilizedIndex = s.fertilizedIndex.add(newFertilized);\n    }\n\n    /**\n     * @dev Distributes Beans to the Field. The next `amount` Pods in the Pod Line\n     * become Harvestable.\n     */\n    function rewardToHarvestable(uint256 amount)\n        internal    \n        returns (uint256 newHarvestable)\n    {\n        uint256 notHarvestable = s.f.pods - s.f.harvestable; // Note: SafeMath is redundant here.\n        newHarvestable = amount.div(HARVEST_DENOMINATOR);\n        newHarvestable = newHarvestable > notHarvestable\n            ? notHarvestable\n            : newHarvestable;\n        s.f.harvestable = s.f.harvestable.add(newHarvestable);\n    }\n\n    /**\n     * @dev Distribute Beans to the Silo. Stalk & Earned Beans are created here;\n     * Farmers can claim them through {SiloFacet.plant}.\n     */\n    function rewardToSilo(uint256 amount) internal {\n        // NOTE that the Beans have already been minted (see {rewardBeans}).\n        //\n        // `s.earnedBeans` is an accounting mechanism that tracks the total number\n        // of Earned Beans that are claimable by Stalkholders. When claimed via `plant()`,\n        // it is decremented. See {Silo.sol:_plant} for more details.\n        // SafeCast not necessary as `seasonStalk.toUint128();` will fail if amount > type(uint128).max.\n        s.earnedBeans = s.earnedBeans.add(uint128(amount));\n\n        // Mint Stalk (as Earned Stalk). Farmers can claim their Earned Stalk via {SiloFacet.sol:plant}.\n        //\n        // Stalk is created here, rather than in {rewardBeans}, because only\n        // Beans that are allocated to the Silo will receive Stalk.\n        // Constant is used here rather than s.ss[BEAN].stalkIssuedPerBdv\n        // for gas savings.\n        uint256 seasonStalk = amount.mul(C.STALK_PER_BEAN);\n        s.s.stalk = s.s.stalk.add(seasonStalk);\n        // `s.newEarnedStalk` is an accounting mechanism that tracks the  number\n        // of Earned stalk that is allocated during the season. \n        // This is used in _balanceOfEarnedBeans() to linearly distrubute \n        // beans over the course of the season.\n        s.newEarnedStalk = seasonStalk.toUint128();\n        s.vestingPeriodRoots = 0;\n\n        // SafeCast not necessary as `seasonStalk.toUint128();` will fail if amount > type(uint128).max.\n        s.siloBalances[C.BEAN].deposited = s\n            .siloBalances[C.BEAN]\n            .deposited\n            .add(uint128(amount));\n\n        s.siloBalances[C.BEAN].depositedBdv = s\n            .siloBalances[C.BEAN]\n            .depositedBdv\n            .add(uint128(amount));\n    }\n\n    //////////////////// SET SOIL ////////////////////\n\n    /**\n     * @param newHarvestable The number of Beans that were minted to the Field.\n     * @param caseId The current Weather Case.\n     * @dev When above peg, Beanstalk wants to gauge demand for Soil. Here it\n     * issues the amount of Soil that would result in the same number of Pods\n     * as became Harvestable during the last Season.\n     * \n     * When the Pod Rate is high, Beanstalk issues less Soil.\n     * When the Pod Rate is low, Beanstalk issues more Soil.\n     */\n    function setSoilAbovePeg(uint256 newHarvestable, uint256 caseId) internal {\n        uint256 newSoil = newHarvestable.mul(100).div(100 + s.w.t);\n        if (caseId >= 24) {\n            newSoil = newSoil.mul(SOIL_COEFFICIENT_HIGH).div(C.PRECISION); // high podrate\n        } else if (caseId < 8) {\n            newSoil = newSoil.mul(SOIL_COEFFICIENT_LOW).div(C.PRECISION); // low podrate\n        }\n        setSoil(newSoil);\n    }\n\n    \n    function setSoil(uint256 amount) internal {\n        s.f.soil = amount.toUint128();\n        emit Soil(s.season.current, amount.toUint128());\n    }\n}"
    },
    {
      "filename": "protocol/contracts/beanstalk/sun/SeasonFacet/SeasonFacet.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"contracts/libraries/Token/LibTransfer.sol\";\nimport \"contracts/libraries/LibIncentive.sol\";\nimport \"./Weather.sol\";\n\n/**\n * @title SeasonFacet\n * @author Publius, Chaikitty\n * @notice Holds the Sunrise function and handles all logic for Season changes.\n */\ncontract SeasonFacet is Weather {\n    using SafeMath for uint256;\n\n    /**\n     * @notice Emitted when the Season changes.\n     * @param season The new Season number\n     */\n    event Sunrise(uint256 indexed season);\n\n    /**\n     * @notice Emitted when Beanstalk pays `beans` to `account` as a reward for calling `sunrise()`.\n     * @param account The address to which the reward Beans were sent\n     * @param beans The amount of Beans paid as a reward\n     */\n    event Incentivization(address indexed account, uint256 beans);\n\n    //////////////////// SUNRISE ////////////////////\n\n    /**\n     * @notice Advances Beanstalk to the next Season, sending reward Beans to the caller's circulating balance.\n     * @return reward The number of beans minted to the caller.\n     */\n    function sunrise() external payable returns (uint256) {\n        return gm(msg.sender, LibTransfer.To.EXTERNAL);\n    }\n\n    /**\n     * @notice Advances Beanstalk to the next Season, sending reward Beans to a specified address & balance.\n     * @param account Indicates to which address reward Beans should be sent\n     * @param mode Indicates whether the reward beans are sent to internal or circulating balance\n     * @return reward The number of Beans minted to the caller.\n     */\n    function gm(\n        address account,\n        LibTransfer.To mode\n    ) public payable returns (uint256) {\n        uint256 initialGasLeft = gasleft();\n\n        require(!paused(), \"Season: Paused.\");\n        require(seasonTime() > season(), \"Season: Still current Season.\");\n\n        stepSeason();\n        int256 deltaB = stepOracle();\n        uint256 caseId = stepWeather(deltaB);\n        stepSun(deltaB, caseId);\n\n        return incentivize(account, initialGasLeft, mode);\n    }\n\n    //////////////////// SEASON GETTERS ////////////////////\n\n    /**\n     * @notice Returns the current Season number.\n     */\n    function season() public view returns (uint32) {\n        return s.season.current;\n    }\n\n    /**\n     * @notice Returns whether Beanstalk is Paused. When Paused, the `sunrise()` function cannot be called.\n     */\n    function paused() public view returns (bool) {\n        return s.paused;\n    }\n\n    /**\n     * @notice Returns the Season struct. See {Storage.Season}.\n     */\n    function time() external view returns (Storage.Season memory) {\n        return s.season;\n    }\n\n    /**\n     * @notice Returns whether Beanstalk started this Season above or below peg.\n     */\n    function abovePeg() external view returns (bool) {\n        return s.season.abovePeg;\n    }\n\n    /**\n     * @notice Returns the block during which the current Season started.\n     */\n    function sunriseBlock() external view returns (uint32){\n        return s.season.sunriseBlock;\n    }\n\n    /**\n     * @notice Returns the expected Season number given the current block timestamp.\n     * {sunrise} can be called when `seasonTime() > season()`.\n     */\n    function seasonTime() public view virtual returns (uint32) {\n        if (block.timestamp < s.season.start) return 0;\n        if (s.season.period == 0) return type(uint32).max;\n        return uint32((block.timestamp - s.season.start) / s.season.period); // Note: SafeMath is redundant here.\n    }\n\n    //////////////////// SEASON INTERNAL ////////////////////\n\n    /**\n     * @dev Moves the Season forward by 1.\n     */\n    function stepSeason() private {\n        s.season.current += 1;\n        s.season.sunriseBlock = uint32(block.number); // Note: Will overflow in the year 3650.\n        emit Sunrise(season());\n    }\n\n    /**\n     * @param account The address to which the reward beans are sent, may or may not\n     * be the same as the caller of `sunrise()`\n     * @param initialGasLeft The amount of gas left at the start of the transaction\n     * @param mode Send reward beans to Internal or Circulating balance\n     * @dev Mints Beans to `account` as a reward for calling {sunrise()}.\n     */\n    function incentivize(\n        address account,\n        uint256 initialGasLeft,\n        LibTransfer.To mode\n    ) private returns (uint256) {\n        // Number of blocks the sunrise is late by\n        // Assumes that each block timestamp is exactly `C.BLOCK_LENGTH_SECONDS` apart.\n        uint256 blocksLate = block.timestamp.sub(\n            s.season.start.add(s.season.period.mul(season()))\n        )\n        .div(C.BLOCK_LENGTH_SECONDS);\n        \n        uint256 incentiveAmount = LibIncentive.determineReward(initialGasLeft, blocksLate);\n\n        LibTransfer.mintToken(C.bean(), incentiveAmount, account, mode);\n        \n        emit Incentivization(account, incentiveAmount);\n        return incentiveAmount;\n    }\n\n\n}"
    }
  ]
}