{
  "Title": "[L-02] If `setRewards` will be called for same epochs, then `cantoPerBlock` will be rewritten",
  "Content": "\n### Description\n\n`LendingLedger.setRewards` accepts `_fromEpoch` and `_toEpoch` params. The only check that function does is if epoch [are set as weeks](https://github.com/code-423n4/2024-01-canto/blob/main/src/LendingLedger.sol#L128). It allows to provide epochs that were already set before. In case if this will happen, which is likely not the case as sponsor claimed, then [`cantoPerBlock` will be rewritten](https://github.com/code-423n4/2024-01-canto/blob/main/src/LendingLedger.sol#L130) for the epoch.\n\n### Recommendation\n\nIncrease `cantoPerBlock` for the epoch.\n`cantoPerBlock[i] += _amountPerBlock;`\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-01-canto",
  "Code": [
    {
      "filename": "src/LendingLedger.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.16;\n\nimport {VotingEscrow} from \"./VotingEscrow.sol\";\nimport {GaugeController} from \"./GaugeController.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IERC20, SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract LendingLedger {\n    // Constants\n    uint256 public constant BLOCK_EPOCH = 100_000; // 100000 blocks, roughly 1 week\n\n    // State\n    address public governance;\n    GaugeController public gaugeController;\n    mapping(address => bool) public lendingMarketWhitelist;\n\n    /// @dev Info for each user.\n    struct UserInfo {\n        uint256 amount; // Amount of cNOTE that the user has provided.\n        int256 rewardDebt; // Amount of CANTO entitled to the user.\n        int256 secRewardDebt; // Amount of secondary rewards entitled to the user.\n    }\n\n    /// @dev Info of each lending market.\n    struct MarketInfo {\n        uint128 accCantoPerShare;\n        uint128 secRewardsPerShare;\n        uint64 lastRewardBlock;\n    }\n\n    mapping(address => mapping(address => UserInfo)) public userInfo; // Info of each user for the different lending markets\n    mapping(address => MarketInfo) public marketInfo; // Info of each lending market\n\n    mapping(uint256 => uint256) public cantoPerBlock; // CANTO per block for each epoch\n\n    /// @dev Lending Market => Epoch => Balance\n    mapping(address => uint256) public lendingMarketTotalBalance; // Total balance locked within the market\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance);\n        _;\n    }\n\n    constructor(address _gaugeController, address _governance) {\n        gaugeController = GaugeController(_gaugeController);\n        governance = _governance;\n    }\n\n    /// @notice Set governance address\n    /// @param _governance New governance address\n    function setGovernance(address _governance) external onlyGovernance {\n        governance = _governance;\n    }\n\n    function update_market(address _market) public {\n        require(lendingMarketWhitelist[_market], \"Market not whitelisted\");\n        MarketInfo storage market = marketInfo[_market];\n        if (block.number > market.lastRewardBlock) {\n            uint256 marketSupply = lendingMarketTotalBalance[_market];\n            if (marketSupply > 0) {\n                uint256 i = market.lastRewardBlock;\n                while (i < block.number) {\n                    uint256 epoch = (i / BLOCK_EPOCH) * BLOCK_EPOCH; // Rewards and voting weights are aligned on a weekly basis\n                    uint256 nextEpoch = i + BLOCK_EPOCH;\n                    uint256 blockDelta = Math.min(nextEpoch, block.number) - i;\n                    uint256 cantoReward = (blockDelta *\n                        cantoPerBlock[epoch] *\n                        gaugeController.gauge_relative_weight_write(_market, epoch)) / 1e18;\n                    market.accCantoPerShare += uint128((cantoReward * 1e18) / marketSupply);\n                    market.secRewardsPerShare += uint128((blockDelta * 1e18) / marketSupply); // TODO: Scaling\n                    i += blockDelta;\n                }\n            }\n            market.lastRewardBlock = uint64(block.number);\n        }\n    }\n\n    /// @notice Function that is called by the lending market on cNOTE deposits / withdrawals\n    /// @param _lender The address of the lender\n    /// @param _delta The amount of cNote deposited (positive) or withdrawn (negative)\n    function sync_ledger(address _lender, int256 _delta) external {\n        address lendingMarket = msg.sender;\n        update_market(lendingMarket); // Checks if the market is whitelisted\n        MarketInfo storage market = marketInfo[lendingMarket];\n        UserInfo storage user = userInfo[lendingMarket][_lender];\n\n        if (_delta >= 0) {\n            user.amount += uint256(_delta);\n            user.rewardDebt += int256((uint256(_delta) * market.accCantoPerShare) / 1e18);\n            user.secRewardDebt += int256((uint256(_delta) * market.secRewardsPerShare) / 1e18);\n        } else {\n            user.amount -= uint256(-_delta);\n            user.rewardDebt -= int256((uint256(-_delta) * market.accCantoPerShare) / 1e18);\n            user.secRewardDebt -= int256((uint256(-_delta) * market.secRewardsPerShare) / 1e18);\n        }\n        int256 updatedMarketBalance = int256(lendingMarketTotalBalance[lendingMarket]) + _delta;\n        require(updatedMarketBalance >= 0, \"Market balance underflow\"); // Sanity check performed here, but the market should ensure that this never happens\n        lendingMarketTotalBalance[lendingMarket] = uint256(updatedMarketBalance);\n    }\n\n    /// @notice Claim the CANTO for a given market. Can only be performed for prior (i.e. finished) epochs, not the current one\n    /// @param _market Address of the market\n    function claim(address _market) external {\n        update_market(_market); // Checks if the market is whitelisted\n        MarketInfo storage market = marketInfo[_market];\n        UserInfo storage user = userInfo[_market][msg.sender];\n        int256 accumulatedCanto = int256((uint256(user.amount) * market.accCantoPerShare) / 1e18);\n        int256 cantoToSend = accumulatedCanto - user.rewardDebt;\n\n        user.rewardDebt = accumulatedCanto;\n\n        if (cantoToSend > 0) {\n            (bool success, ) = msg.sender.call{value: uint256(cantoToSend)}(\"\");\n            require(success, \"Failed to send CANTO\");\n        }\n    }\n\n    /// @notice Used by governance to set the overall CANTO rewards per epoch\n    /// @param _fromEpoch From which epoch (provided as block number) to set the rewards from\n    /// @param _toEpoch Until which epoch (provided as block number) to set the rewards to\n    /// @param _amountPerBlock The amount per block\n    function setRewards(\n        uint256 _fromEpoch,\n        uint256 _toEpoch,\n        uint256 _amountPerBlock\n    ) external onlyGovernance {\n        require(_fromEpoch % BLOCK_EPOCH == 0 && _toEpoch % BLOCK_EPOCH == 0, \"Invalid block number\");\n        for (uint256 i = _fromEpoch; i <= _toEpoch; i += BLOCK_EPOCH) {\n            cantoPerBlock[i] = _amountPerBlock;\n        }\n    }\n\n    /// @notice Used by governance to whitelist a lending market\n    /// @param _market Address of the market to whitelist\n    /// @param _isWhiteListed Whether the market is whitelisted or not\n    function whiteListLendingMarket(address _market, bool _isWhiteListed) external onlyGovernance {\n        require(lendingMarketWhitelist[_market] != _isWhiteListed, \"No change\");\n        lendingMarketWhitelist[_market] = _isWhiteListed;\n        if (_isWhiteListed) {\n            marketInfo[_market].lastRewardBlock = uint64(block.number);\n        }\n    }\n\n    receive() external payable {}\n}"
    }
  ]
}