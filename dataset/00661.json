{
  "Title": "LpToken taint griefing",
  "Content": "##### Description\n\nThe [LpToken](https://github.com/ConicFinance/protocol/blob/7a66d26ef84f93059a811a189655e17c11d95f5c/contracts/LpToken.sol) cannot be minted or burned by a user if someone has transferred an amount of LpToken to them greater than `controller.getMinimumTaintedTransferAmount(token)`:\n```\nfunction _ensureSingleEvent(address ubo, uint256 amount) internal {\n    if(\n        !controller.isAllowedMultipleDepositsWithdraws(ubo) &&\n        amount > controller.getMinimumTaintedTransferAmount(address(this))\n    ) {\n        require(\n            _lastEvent[ubo] != block.number,\n            \"cannot mint/burn twice in a block\");\n        ...\n```\nhttps://github.com/ConicFinance/protocol/blob/7a66d26ef84f93059a811a189655e17c11d95f5c/contracts/LpToken.sol#L81\n\nThis means a malicious actor could send a minimum number of tokens to any \"whale\" (a user with a large balance) trying to make a large deposit or withdraw, thereby blocking their operation. \n\nFor example, this could be used to attack users who want to urgently burn their LP tokens to repay an overcollateralized debt and avoid liquidation. This can also be used to block MEV bots that utilize mint or burn lp tokens in their path strategies. It also removes the ability to buy LP tokens on an exchange and burn them in a single transaction.\n\nIt's worth noting that by default, `controller.getMinimumTaintedTransferAmount(token)` equals zero, so the attacker would only need to pay for the gas to block a specific user's operations.\n\n##### Recommendation\n\nWe recommended allowing users to burn LP tokens received before the current taint.\n\nFor instance, if in the first block a user mints 1000 tokens for themselves, and then in the second block they receive another token, it would be desirable in the second block to still allow them to burn the initial 1000 tokens. However, it should revert if they try to burn more than that amount.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/LpToken.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/pools/ILpToken.sol\";\n\ncontract LpToken is ILpToken, ERC20 {\n    IController public immutable controller;\n\n    address public immutable minter;\n\n    modifier onlyMinter() {\n        require(msg.sender == minter, \"not authorized\");\n        _;\n    }\n\n    mapping(address => uint256) internal _lastEvent;\n\n    uint8 private __decimals;\n\n    constructor(\n        address _controller,\n        address _minter,\n        uint8 _decimals,\n        string memory name,\n        string memory symbol\n    ) ERC20(name, symbol) {\n        controller = IController(_controller);\n        minter = _minter;\n        __decimals = _decimals;\n    }\n\n    function decimals() public view virtual override(ERC20, IERC20Metadata) returns (uint8) {\n        return __decimals;\n    }\n\n    function mint(\n        address _account,\n        uint256 _amount,\n        address ubo\n    ) external override onlyMinter returns (uint256) {\n        _ensureSingleEvent(ubo, _amount);\n        _mint(_account, _amount);\n        return _amount;\n    }\n\n    function burn(\n        address _owner,\n        uint256 _amount,\n        address ubo\n    ) external override onlyMinter returns (uint256) {\n        _ensureSingleEvent(ubo, _amount);\n        _burn(_owner, _amount);\n        return _amount;\n    }\n\n    function taint(address from, address to) external {\n        require(msg.sender == address(controller.lpTokenStaker()), \"not authorized\");\n        _taint(from, to);\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {\n        // mint/burn are handled in their respective functions\n        if (from == address(0) || to == address(0)) return;\n\n        // lpTokenStaker calls `taint` as needed\n        address lpTokenStaker = address(controller.lpTokenStaker());\n        if (from == lpTokenStaker || to == lpTokenStaker) return;\n\n        // taint any other type of transfer\n        if (amount > controller.getMinimumTaintedTransferAmount(address(this))) {\n            _taint(from, to);\n        }\n    }\n\n    function _ensureSingleEvent(address ubo, uint256 amount) internal {\n        if (\n            !controller.isAllowedMultipleDepositsWithdraws(ubo) &&\n            amount > controller.getMinimumTaintedTransferAmount(address(this))\n        ) {\n            require(_lastEvent[ubo] != block.number, \"cannot mint/burn twice in a block\");\n            _lastEvent[ubo] = block.number;\n        }\n    }\n\n    function _taint(address from, address to) internal {\n        if (from == to) return;\n        if (_lastEvent[from] == block.number) {\n            _lastEvent[to] = block.number;\n        }\n    }\n}"
    }
  ]
}