{
  "Title": "[G-01] Emitting two duplicated events might be unnecessary and wasteful",
  "Content": "\n### Instances(2)\n\n**Total Gas Saved: 2250**\n\nBoth ThrusterPool.sol and ThrusterPair.sol's swap function emit duplicated events - once locally from the pool/pair contract, once from the factory contract. Emit the same event twice is wasteful and might also be unnecessary for the use case.\n\nAccording to readme, the protocol would prefer to have swap event centrally emitted from factory contracts for tracking. This is fine, then it could be argued that the local swap emit from the pool/pair contract is unnecessary. If the individual pool deployer needs to track swap events, they can subscribe to the factory contract's event which contains the origin pool address as an indexed field.\n\n```solidity\n//thruster-protocol/thruster-cfmm/contracts/ThrusterPair.sol\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external lock {\n...\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n        IThrusterFactory(factory).emitSwap(\n            msg.sender,\n            amount0In,\n            amount1In,\n            amount0Out,\n            amount1Out,\n            to\n        );\n```\n(https://github.com/code-423n4/2024-02-thruster/blob/3896779349f90a44b46f2646094cb34fffd7f66e/thruster-protocol/thruster-cfmm/contracts/ThrusterPair.sol#L222-L223)\n\n```solidity\n//thruster-protocol/thruster-clmm/contracts/ThrusterPool.sol\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    )\n        external\n        override\n        noDelegateCall\n        returns (int256 amount0, int256 amount1)\n    {\n...\n        emit Swap(\n            msg.sender,\n            recipient,\n            amount0,\n            amount1,\n            state.sqrtPriceX96,\n            state.liquidity,\n            state.tick\n        );\n        IThrusterPoolFactory(factory).emitSwap(\n            msg.sender,\n            recipient,\n            amount0,\n            amount1,\n            state.sqrtPriceX96,\n            state.liquidity,\n            state.tick\n        );\n        slot0.unlocked = true;\n```\n(https://github.com/code-423n4/2024-02-thruster/blob/3896779349f90a44b46f2646094cb34fffd7f66e/thruster-protocol/thruster-clmm/contracts/ThrusterPool.sol#L756-L759)\n\nNote for each emit log, there is at least 375 static gas cost + 375 gas per topic + other dynamic cost.\n\n### Recommendations\n\nSave users's runtime gas cost by only emitting swap event in the factory contract.\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-02-thruster",
  "Code": [
    {
      "filename": "thruster-protocol/thruster-cfmm/contracts/ThrusterPair.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.5.16;\n\nimport \"interfaces/IERC20.sol\";\nimport \"interfaces/IThrusterCallee.sol\";\nimport \"interfaces/IThrusterFactory.sol\";\nimport \"interfaces/IThrusterPair.sol\";\nimport \"interfaces/IThrusterERC20.sol\";\n\nimport \"contracts/ThrusterYield.sol\";\nimport \"contracts/libraries/Math.sol\";\nimport \"contracts/libraries/SafeMath.sol\";\nimport \"contracts/libraries/UQ112x112.sol\";\n\ncontract ThrusterPair is IThrusterPair, IThrusterERC20, ThrusterYield {\n    using SafeMath for uint256;\n    using UQ112x112 for uint224;\n\n    uint256 public constant MINIMUM_LIQUIDITY = 10 ** 3;\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n    string public constant name = \"Thruster LP\";\n    string public constant symbol = \"T-LP\";\n    uint8 public constant decimals = 18;\n    bytes32 public DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint256) public nonces;\n\n    address public factory;\n    address public token0;\n    address public token1;\n    uint256 public totalSupply;\n\n    uint112 private reserve0; // uses single storage slot, accessible via getReserves\n    uint112 private reserve1; // uses single storage slot, accessible via getReserves\n    uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n    uint256 public price0CumulativeLast;\n    uint256 public price1CumulativeLast;\n    uint256 public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\n\n    uint256 private unlocked = 1;\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    modifier lock() {\n        require(unlocked == 1, \"ThrusterPair: LOCKED\");\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n    function _safeTransfer(address token, address to, uint256 value) private {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"ThrusterPair: TRANSFER_FAILED\");\n    }\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor() public ThrusterYield(IThrusterFactory(msg.sender).yieldToSetter()) {\n        factory = msg.sender;\n        uint256 chainId;\n        assembly {\n            chainId := chainid\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(address _token0, address _token1) external {\n        require(msg.sender == factory, \"ThrusterPair: FORBIDDEN\"); // sufficient check\n        token0 = _token0;\n        token1 = _token1;\n    }\n\n    // update reserves and, on the first call per block, price accumulators\n    function _update(uint256 balance0, uint256 balance1, uint112 _reserve0, uint112 _reserve1) private {\n        require(balance0 <= uint112(-1) && balance1 <= uint112(-1), \"ThrusterPair: OVERFLOW\");\n        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n            // * never overflows, and + overflow is desired\n            price0CumulativeLast += uint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\n            price1CumulativeLast += uint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\n        }\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n        blockTimestampLast = blockTimestamp;\n        emit Sync(reserve0, reserve1);\n        IThrusterFactory(factory).emitSync(reserve0, reserve1);\n    }\n\n    // if yieldCut is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)\n    function _mintYieldCut(uint112 _reserve0, uint112 _reserve1) private returns (bool yieldCutOn) {\n        address yieldTo = IThrusterFactory(factory).yieldTo();\n        yieldCutOn = yieldTo != address(0);\n        uint256 _kLast = kLast; // gas savings\n        if (yieldCutOn) {\n            if (_kLast != 0) {\n                uint256 rootK = Math.sqrt(uint256(_reserve0).mul(_reserve1));\n                uint256 rootKLast = Math.sqrt(_kLast);\n                if (rootK > rootKLast) {\n                    uint256 numerator = totalSupply.mul(rootK.sub(rootKLast));\n                    uint256 denominator = rootK.mul(IThrusterFactory(factory).yieldCut()).add(rootKLast);\n                    uint256 liquidity = numerator / denominator;\n                    if (liquidity > 0) _mint(yieldTo, liquidity);\n                }\n            }\n        } else if (_kLast != 0) {\n            kLast = 0;\n        }\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function mint(address to) external lock returns (uint256 liquidity) {\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\n        uint256 amount0 = balance0.sub(_reserve0);\n        uint256 amount1 = balance1.sub(_reserve1);\n\n        bool yieldCutOn = _mintYieldCut(_reserve0, _reserve1);\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintYieldCut\n        if (_totalSupply == 0) {\n            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\n            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n        } else {\n            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\n        }\n        require(liquidity > 0, \"ThrusterPair: INSUFFICIENT_LIQUIDITY_MINTED\");\n        _mint(to, liquidity);\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (yieldCutOn) kLast = uint256(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Mint(msg.sender, amount0, amount1);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function burn(address to) external lock returns (uint256 amount0, uint256 amount1) {\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        uint256 balance0 = IERC20(_token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(_token1).balanceOf(address(this));\n        uint256 liquidity = balanceOf[address(this)];\n\n        bool yieldCutOn = _mintYieldCut(_reserve0, _reserve1);\n        amount0 = liquidity.mul(balance0) / totalSupply; // using balances ensures pro-rata distribution\n        amount1 = liquidity.mul(balance1) / totalSupply; // using balances ensures pro-rata distribution\n        require(amount0 > 0 && amount1 > 0, \"ThrusterPair: INSUFFICIENT_LIQUIDITY_BURNED\");\n        _burn(address(this), liquidity);\n        _safeTransfer(_token0, to, amount0);\n        _safeTransfer(_token1, to, amount1);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (yieldCutOn) kLast = uint256(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Burn(msg.sender, amount0, amount1, to);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external lock {\n        require(amount0Out > 0 || amount1Out > 0, \"ThrusterPair: INSUFFICIENT_OUTPUT_AMOUNT\");\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, \"ThrusterPair: INSUFFICIENT_LIQUIDITY\");\n\n        uint256 balance0;\n        uint256 balance1;\n        {\n            // scope for _token{0,1}, avoids stack too deep errors\n            address _token0 = token0;\n            address _token1 = token1;\n            require(to != _token0 && to != _token1, \"ThrusterPair: INVALID_TO\");\n            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n            if (data.length > 0) IThrusterCallee(to).thrusterCall(msg.sender, amount0Out, amount1Out, data);\n            balance0 = IERC20(_token0).balanceOf(address(this));\n            balance1 = IERC20(_token1).balanceOf(address(this));\n        }\n        uint256 amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\n        uint256 amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\n        require(amount0In > 0 || amount1In > 0, \"ThrusterPair: INSUFFICIENT_INPUT_AMOUNT\");\n        {\n            // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n            uint256 balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));\n            uint256 balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));\n            require(\n                balance0Adjusted.mul(balance1Adjusted) >= uint256(_reserve0).mul(_reserve1).mul(1000 ** 2),\n                \"ThrusterPair: K\"\n            );\n        }\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n        IThrusterFactory(factory).emitSwap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    }\n\n    // force balances to match reserves\n    function skim(address to) external lock {\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));\n        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));\n    }\n\n    // force reserves to match balances\n    function sync() external lock {\n        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);\n    }\n\n    // Moving all ThrusterERC20 functions into ThrusterPair contract\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n        IThrusterFactory(factory).emitTransfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n        IThrusterFactory(factory).emitTransfer(from, address(0), value);\n    }\n\n    function _approve(address owner, address spender, uint256 value) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(address from, address to, uint256 value) private {\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n        IThrusterFactory(factory).emitTransfer(from, to, value);\n    }\n\n    function approve(address spender, uint256 value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint256 value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool) {\n        if (allowance[from][msg.sender] != uint256(-1)) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        external\n    {\n        require(deadline >= block.timestamp, \"ThrusterERC20: EXPIRED\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && recoveredAddress == owner, \"ThrusterERC20: INVALID_SIGNATURE\");\n        _approve(owner, spender, value);\n    }\n\n    function blastPointsAdmin() external view returns (address) {\n        return IThrusterFactory(factory).pointsAdmin();\n    }\n}"
    },
    {
      "filename": "thruster-protocol/thruster-clmm/contracts/ThrusterPool.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.7.6;\n\nimport \"interfaces/IERC20Minimal.sol\";\nimport \"interfaces/IThrusterPoolFactory.sol\";\nimport \"interfaces/IThrusterGauge.sol\";\nimport \"interfaces/IThrusterPool.sol\";\nimport \"interfaces/IThrusterPoolDeployer.sol\";\nimport \"interfaces/callback/IThrusterMintCallback.sol\";\nimport \"interfaces/callback/IThrusterSwapCallback.sol\";\nimport \"interfaces/callback/IThrusterFlashCallback.sol\";\n\nimport \"interfaces/IBlast.sol\";\nimport \"interfaces/IERC20Rebasing.sol\";\n\nimport \"contracts/NoDelegateCall.sol\";\nimport \"contracts/libraries/FixedPoint128.sol\";\nimport \"contracts/libraries/FullMath.sol\";\nimport \"contracts/libraries/LiquidityMath.sol\";\nimport \"contracts/libraries/LowGasSafeMath.sol\";\nimport \"contracts/libraries/Oracle.sol\";\nimport \"contracts/libraries/Position.sol\";\nimport \"contracts/libraries/SafeCast.sol\";\nimport \"contracts/libraries/SqrtPriceMath.sol\";\nimport \"contracts/libraries/SwapMath.sol\";\nimport \"contracts/libraries/Tick.sol\";\nimport \"contracts/libraries/TickMath.sol\";\nimport \"contracts/libraries/TickBitmap.sol\";\nimport \"contracts/libraries/TransferHelper.sol\";\n\ncontract ThrusterPool is IThrusterPool, NoDelegateCall {\n    using LowGasSafeMath for uint256;\n    using LowGasSafeMath for int256;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using Tick for mapping(int24 => Tick.Info);\n    using TickBitmap for mapping(int16 => uint256);\n    using Position for mapping(bytes32 => Position.Info);\n    using Position for Position.Info;\n    using Oracle for Oracle.Observation[65535];\n\n    IBlast public constant BLAST = IBlast(0x4300000000000000000000000000000000000002);\n    IERC20Rebasing public constant USDB = IERC20Rebasing(0x4200000000000000000000000000000000000022);\n    IERC20Rebasing public constant WETHB = IERC20Rebasing(0x4200000000000000000000000000000000000023);\n\n    /// @inheritdoc IThrusterPoolImmutables\n    address public immutable override factory;\n    /// @inheritdoc IThrusterPoolImmutables\n    address public immutable override token0;\n    /// @inheritdoc IThrusterPoolImmutables\n    address public immutable override token1;\n    /// @inheritdoc IThrusterPoolImmutables\n    uint24 public immutable override fee;\n\n    /// @inheritdoc IThrusterPoolImmutables\n    int24 public immutable override tickSpacing;\n\n    /// @inheritdoc IThrusterPoolImmutables\n    uint128 public immutable override maxLiquidityPerTick;\n\n    struct Slot0 {\n        // the current price\n        uint160 sqrtPriceX96;\n        // the current tick\n        int24 tick;\n        // the most-recently updated index of the observations array\n        uint16 observationIndex;\n        // the current maximum number of observations that are being stored\n        uint16 observationCardinality;\n        // the next maximum number of observations to store, triggered in observations.write\n        uint16 observationCardinalityNext;\n        // the current protocol fee as a percentage of the swap fee taken on withdrawal\n        // represented as an integer denominator (1/x)%\n        uint8 feeProtocol;\n        // whether the pool is locked\n        bool unlocked;\n    }\n    /// @inheritdoc IThrusterPoolState\n\n    Slot0 public override slot0;\n\n    /// @inheritdoc IThrusterPoolState\n    uint256 public override feeGrowthGlobal0X128;\n    /// @inheritdoc IThrusterPoolState\n    uint256 public override feeGrowthGlobal1X128;\n\n    // accumulated protocol fees in token0/token1 units\n    struct ProtocolFees {\n        uint128 token0;\n        uint128 token1;\n    }\n    /// @inheritdoc IThrusterPoolState\n\n    ProtocolFees public override protocolFees;\n\n    /// @inheritdoc IThrusterPoolState\n    uint128 public override liquidity;\n\n    /// @inheritdoc IThrusterPoolState\n    mapping(int24 => Tick.Info) public override ticks;\n    /// @inheritdoc IThrusterPoolState\n    mapping(int16 => uint256) public override tickBitmap;\n    /// @inheritdoc IThrusterPoolState\n    mapping(bytes32 => Position.Info) public override positions;\n    /// @inheritdoc IThrusterPoolState\n    Oracle.Observation[65535] public override observations;\n\n    // Gauges\n    address public gauge;\n\n    /// @dev Mutually exclusive reentrancy protection into the pool to/from a method. This method also prevents entrance\n    /// to a function before the pool is initialized. The reentrancy guard is required throughout the contract because\n    /// we use balance checks to determine the payment status of interactions such as mint, swap and flash.\n    modifier lock() {\n        require(slot0.unlocked, \"LOK\");\n        slot0.unlocked = false;\n        _;\n        slot0.unlocked = true;\n    }\n\n    /// @dev Prevents calling a function from anyone except the address returned by IThrusterPoolFactory#owner()\n    modifier onlyFactoryOwner() {\n        require(msg.sender == IThrusterPoolFactory(factory).owner());\n        _;\n    }\n\n    constructor() {\n        int24 _tickSpacing;\n        BLAST.configureClaimableGas();\n        BLAST.configureClaimableYield();\n        USDB.configure(YieldMode.CLAIMABLE);\n        WETHB.configure(YieldMode.CLAIMABLE);\n        (factory, token0, token1, fee, _tickSpacing) = IThrusterPoolDeployer(msg.sender).parameters();\n        tickSpacing = _tickSpacing;\n\n        maxLiquidityPerTick = Tick.tickSpacingToMaxLiquidityPerTick(_tickSpacing);\n    }\n\n    /// @dev Common checks for valid tick inputs.\n    function checkTicks(int24 tickLower, int24 tickUpper) private pure {\n        require(tickLower < tickUpper, \"TLU\");\n        require(tickLower >= TickMath.MIN_TICK, \"TLM\");\n        require(tickUpper <= TickMath.MAX_TICK, \"TUM\");\n    }\n\n    /// @dev Get the pool's balance of token0\n    /// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize\n    /// check\n    function balance0() private view returns (uint256) {\n        (bool success, bytes memory data) =\n            token0.staticcall(abi.encodeWithSelector(IERC20Minimal.balanceOf.selector, address(this)));\n        require(success && data.length >= 32);\n        return abi.decode(data, (uint256));\n    }\n\n    /// @dev Get the pool's balance of token1\n    /// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize\n    /// check\n    function balance1() private view returns (uint256) {\n        (bool success, bytes memory data) =\n            token1.staticcall(abi.encodeWithSelector(IERC20Minimal.balanceOf.selector, address(this)));\n        require(success && data.length >= 32);\n        return abi.decode(data, (uint256));\n    }\n\n    /// @inheritdoc IThrusterPoolDerivedState\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        override\n        noDelegateCall\n        returns (int56 tickCumulativeInside, uint160 secondsPerLiquidityInsideX128, uint32 secondsInside)\n    {\n        checkTicks(tickLower, tickUpper);\n\n        int56 tickCumulativeLower;\n        int56 tickCumulativeUpper;\n        uint160 secondsPerLiquidityOutsideLowerX128;\n        uint160 secondsPerLiquidityOutsideUpperX128;\n        uint32 secondsOutsideLower;\n        uint32 secondsOutsideUpper;\n\n        {\n            Tick.Info storage lower = ticks[tickLower];\n            Tick.Info storage upper = ticks[tickUpper];\n            bool initializedLower;\n            (tickCumulativeLower, secondsPerLiquidityOutsideLowerX128, secondsOutsideLower, initializedLower) = (\n                lower.tickCumulativeOutside,\n                lower.secondsPerLiquidityOutsideX128,\n                lower.secondsOutside,\n                lower.initialized\n            );\n            require(initializedLower);\n\n            bool initializedUpper;\n            (tickCumulativeUpper, secondsPerLiquidityOutsideUpperX128, secondsOutsideUpper, initializedUpper) = (\n                upper.tickCumulativeOutside,\n                upper.secondsPerLiquidityOutsideX128,\n                upper.secondsOutside,\n                upper.initialized\n            );\n            require(initializedUpper);\n        }\n\n        Slot0 memory _slot0 = slot0;\n\n        if (_slot0.tick < tickLower) {\n            return (\n                tickCumulativeLower - tickCumulativeUpper,\n                secondsPerLiquidityOutsideLowerX128 - secondsPerLiquidityOutsideUpperX128,\n                secondsOutsideLower - secondsOutsideUpper\n            );\n        } else if (_slot0.tick < tickUpper) {\n            uint32 time = uint32(block.timestamp);\n            (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) = observations.observeSingle(\n                time, 0, _slot0.tick, _slot0.observationIndex, liquidity, _slot0.observationCardinality\n            );\n            return (\n                tickCumulative - tickCumulativeLower - tickCumulativeUpper,\n                secondsPerLiquidityCumulativeX128 - secondsPerLiquidityOutsideLowerX128\n                    - secondsPerLiquidityOutsideUpperX128,\n                time - secondsOutsideLower - secondsOutsideUpper\n            );\n        } else {\n            return (\n                tickCumulativeUpper - tickCumulativeLower,\n                secondsPerLiquidityOutsideUpperX128 - secondsPerLiquidityOutsideLowerX128,\n                secondsOutsideUpper - secondsOutsideLower\n            );\n        }\n    }\n\n    /// @inheritdoc IThrusterPoolDerivedState\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        override\n        noDelegateCall\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s)\n    {\n        return observations.observe(\n            uint32(block.timestamp),\n            secondsAgos,\n            slot0.tick,\n            slot0.observationIndex,\n            liquidity,\n            slot0.observationCardinality\n        );\n    }\n\n    /// @inheritdoc IThrusterPoolActions\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext)\n        external\n        override\n        lock\n        noDelegateCall\n    {\n        uint16 observationCardinalityNextOld = slot0.observationCardinalityNext; // for the event\n        uint16 observationCardinalityNextNew =\n            observations.grow(observationCardinalityNextOld, observationCardinalityNext);\n        slot0.observationCardinalityNext = observationCardinalityNextNew;\n        if (observationCardinalityNextOld != observationCardinalityNextNew) {\n            emit IncreaseObservationCardinalityNext(observationCardinalityNextOld, observationCardinalityNextNew);\n        }\n    }\n\n    /// @inheritdoc IThrusterPoolActions\n    /// @dev not locked because it initializes unlocked\n    function initialize(uint160 sqrtPriceX96) external override {\n        require(slot0.sqrtPriceX96 == 0, \"AI\");\n\n        int24 tick = TickMath.getTickAtSqrtRatio(sqrtPriceX96);\n\n        (uint16 cardinality, uint16 cardinalityNext) = observations.initialize(uint32(block.timestamp));\n\n        slot0 = Slot0({\n            sqrtPriceX96: sqrtPriceX96,\n            tick: tick,\n            observationIndex: 0,\n            observationCardinality: cardinality,\n            observationCardinalityNext: cardinalityNext,\n            feeProtocol: 0,\n            unlocked: true\n        });\n\n        emit Initialize(sqrtPriceX96, tick);\n    }\n\n    struct ModifyPositionParams {\n        // the address that owns the position\n        address owner;\n        // the lower and upper tick of the position\n        int24 tickLower;\n        int24 tickUpper;\n        // any change in liquidity\n        int128 liquidityDelta;\n    }\n\n    /// @dev Effect some changes to a position\n    /// @param params the position details and the change to the position's liquidity to effect\n    /// @return position a storage pointer referencing the position with the given owner and tick range\n    /// @return amount0 the amount of token0 owed to the pool, negative if the pool should pay the recipient\n    /// @return amount1 the amount of token1 owed to the pool, negative if the pool should pay the recipient\n    function _modifyPosition(ModifyPositionParams memory params)\n        private\n        noDelegateCall\n        returns (Position.Info storage position, int256 amount0, int256 amount1)\n    {\n        checkTicks(params.tickLower, params.tickUpper);\n\n        Slot0 memory _slot0 = slot0; // SLOAD for gas optimization\n\n        position = _updatePosition(params.owner, params.tickLower, params.tickUpper, params.liquidityDelta, _slot0.tick);\n\n        if (params.liquidityDelta != 0) {\n            if (_slot0.tick < params.tickLower) {\n                // current tick is below the passed range; liquidity can only become in range by crossing from left to\n                // right, when we'll need _more_ token0 (it's becoming more valuable) so user must provide it\n                amount0 = SqrtPriceMath.getAmount0Delta(\n                    TickMath.getSqrtRatioAtTick(params.tickLower),\n                    TickMath.getSqrtRatioAtTick(params.tickUpper),\n                    params.liquidityDelta\n                );\n            } else if (_slot0.tick < params.tickUpper) {\n                // current tick is inside the passed range\n                uint128 liquidityBefore = liquidity; // SLOAD for gas optimization\n\n                // write an oracle entry\n                (slot0.observationIndex, slot0.observationCardinality) = observations.write(\n                    _slot0.observationIndex,\n                    uint32(block.timestamp),\n                    _slot0.tick,\n                    liquidityBefore,\n                    _slot0.observationCardinality,\n                    _slot0.observationCardinalityNext\n                );\n\n                amount0 = SqrtPriceMath.getAmount0Delta(\n                    _slot0.sqrtPriceX96, TickMath.getSqrtRatioAtTick(params.tickUpper), params.liquidityDelta\n                );\n                amount1 = SqrtPriceMath.getAmount1Delta(\n                    TickMath.getSqrtRatioAtTick(params.tickLower), _slot0.sqrtPriceX96, params.liquidityDelta\n                );\n\n                liquidity = LiquidityMath.addDelta(liquidityBefore, params.liquidityDelta);\n            } else {\n                // current tick is above the passed range; liquidity can only become in range by crossing from right to\n                // left, when we'll need _more_ token1 (it's becoming more valuable) so user must provide it\n                amount1 = SqrtPriceMath.getAmount1Delta(\n                    TickMath.getSqrtRatioAtTick(params.tickLower),\n                    TickMath.getSqrtRatioAtTick(params.tickUpper),\n                    params.liquidityDelta\n                );\n            }\n        }\n    }\n\n    /// @dev Gets and updates a position with the given liquidity delta\n    /// @param owner the owner of the position\n    /// @param tickLower the lower tick of the position's tick range\n    /// @param tickUpper the upper tick of the position's tick range\n    /// @param tick the current tick, passed to avoid sloads\n    function _updatePosition(address owner, int24 tickLower, int24 tickUpper, int128 liquidityDelta, int24 tick)\n        private\n        returns (Position.Info storage position)\n    {\n        position = positions.get(owner, tickLower, tickUpper);\n\n        uint256 _feeGrowthGlobal0X128 = feeGrowthGlobal0X128; // SLOAD for gas optimization\n        uint256 _feeGrowthGlobal1X128 = feeGrowthGlobal1X128; // SLOAD for gas optimization\n\n        // if we need to update the ticks, do it\n        bool flippedLower;\n        bool flippedUpper;\n        if (liquidityDelta != 0) {\n            uint32 time = uint32(block.timestamp);\n            (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) = observations.observeSingle(\n                time, 0, slot0.tick, slot0.observationIndex, liquidity, slot0.observationCardinality\n            );\n\n            flippedLower = ticks.update(\n                tickLower,\n                tick,\n                liquidityDelta,\n                _feeGrowthGlobal0X128,\n                _feeGrowthGlobal1X128,\n                secondsPerLiquidityCumulativeX128,\n                tickCumulative,\n                time,\n                false,\n                maxLiquidityPerTick\n            );\n            flippedUpper = ticks.update(\n                tickUpper,\n                tick,\n                liquidityDelta,\n                _feeGrowthGlobal0X128,\n                _feeGrowthGlobal1X128,\n                secondsPerLiquidityCumulativeX128,\n                tickCumulative,\n                time,\n                true,\n                maxLiquidityPerTick\n            );\n\n            if (flippedLower) {\n                tickBitmap.flipTick(tickLower, tickSpacing);\n            }\n            if (flippedUpper) {\n                tickBitmap.flipTick(tickUpper, tickSpacing);\n            }\n        }\n\n        (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) =\n            ticks.getFeeGrowthInside(tickLower, tickUpper, tick, _feeGrowthGlobal0X128, _feeGrowthGlobal1X128);\n\n        position.update(liquidityDelta, feeGrowthInside0X128, feeGrowthInside1X128);\n\n        // clear any tick data that is no longer needed\n        if (liquidityDelta < 0) {\n            if (flippedLower) {\n                ticks.clear(tickLower);\n            }\n            if (flippedUpper) {\n                ticks.clear(tickUpper);\n            }\n        }\n    }\n\n    /// @inheritdoc IThrusterPoolActions\n    /// @dev noDelegateCall is applied indirectly via _modifyPosition\n    function mint(address recipient, int24 tickLower, int24 tickUpper, uint128 amount, bytes calldata data)\n        external\n        override\n        lock\n        returns (uint256 amount0, uint256 amount1)\n    {\n        require(amount > 0);\n        (, int256 amount0Int, int256 amount1Int) = _modifyPosition(\n            ModifyPositionParams({\n                owner: recipient,\n                tickLower: tickLower,\n                tickUpper: tickUpper,\n                liquidityDelta: int256(amount).toInt128()\n            })\n        );\n\n        amount0 = uint256(amount0Int);\n        amount1 = uint256(amount1Int);\n\n        uint256 balance0Before;\n        uint256 balance1Before;\n        if (amount0 > 0) balance0Before = balance0();\n        if (amount1 > 0) balance1Before = balance1();\n        IThrusterMintCallback(msg.sender).thrusterMintCallback(amount0, amount1, data);\n        if (amount0 > 0) require(balance0Before.add(amount0) <= balance0(), \"M0\");\n        if (amount1 > 0) require(balance1Before.add(amount1) <= balance1(), \"M1\");\n\n        emit Mint(msg.sender, recipient, tickLower, tickUpper, amount, amount0, amount1);"
    }
  ]
}