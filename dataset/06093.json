{
  "Title": "[H-01] Reentrancy issue with the `withdraw` method of USDC. All tokens could be drained.",
  "Content": "\n<https://github.com/code-423n4/2023-07-amphora/blob/daae020331404647c661ab534d20093c875483e1/core/solidity/contracts/core/USDA.sol#L147-L157><br>\n<https://github.com/code-423n4/2023-07-amphora/blob/daae020331404647c661ab534d20093c875483e1/core/solidity/contracts/core/USDA.sol#L114>\n\n### Impact\n\nHigh: All USDC tokens could be drained from the protocol.\n\n### Proof of Concept\n\nThere is a reentrancy issue with the 'withdraw' methods of USDC.\n\nA user could call either of the external withdraw functions: `withdraw` or `withdrawTo`.\n\nWhich further calls `_withdraw();` which basically burns the user's token and transfers user the `_susdAmount`. The exchange is 1 to 1.\n\n```solidity\nfunction withdraw(uint256 _susdAmount) external override {\n    _withdraw(_susdAmount, _msgSender());\n}\n```\n\n```solidity\n  function _withdraw(uint256 _susdAmount, address _target) internal paysInterest whenNotPaused {\n    if (reserveAmount == 0) revert USDA_EmptyReserve();\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    if (_susdAmount > this.balanceOf(_msgSender())) revert USDA_InsufficientFunds();\n    // Account for the susd withdrawn\n    reserveAmount -= _susdAmount;\n    sUSD.transfer(_target, _susdAmount);\n    _burn(_msgSender(), _susdAmount);\n\n    emit Withdraw(_target, _susdAmount);\n  }\n```\n\nThe issue is that the `_withdraw()` function does not follow the CEI pattern and fails to update the state (burning token in this case) before the token transfer.\n\n```solidity\nsUSD.transfer(_target   , _susdAmount);\n_burn(_msgSender(), _susdAmount);\n```\n\nIt is possible to re-enter the function `USDC.withdraw()` from the malicious attack contract's fallback function as soon as it recieves the transfered amount.\n\nThis will again hit the attacker contract's fallback function (with the withdrawn token amount) and repeat the flow until USDA tokens from contract are completely drained.\n\n<https://github.com/code-423n4/2023-07-amphora/blob/daae020331404647c661ab534d20093c875483e1/core/solidity/contracts/core/USDA.sol#L147-L157>\n\n### Recommended Mitigation Steps\n\nThis could be prevented by first burning the user's tokens or using a Mutex / Re-entrancy guard from OpenZeppelin lib.\n\n### Assessed type\n\nReentrancy\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-07-amphora",
  "Code": [
    {
      "filename": "core/solidity/contracts/core/USDA.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {ExponentialNoError} from '@contracts/utils/ExponentialNoError.sol';\nimport {Roles} from '@contracts/utils/Roles.sol';\nimport {UFragments} from '@contracts/utils/UFragments.sol';\n\nimport {IUSDA} from '@interfaces/core/IUSDA.sol';\nimport {IVaultController} from '@interfaces/core/IVaultController.sol';\n\nimport {IERC20Metadata, IERC20} from '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\nimport {Pausable} from '@openzeppelin/contracts/security/Pausable.sol';\nimport {Context} from '@openzeppelin/contracts/utils/Context.sol';\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\n\n/// @notice USDA token contract, handles all minting/burning of usda\n/// @dev extends UFragments\ncontract USDA is Pausable, UFragments, IUSDA, ExponentialNoError, Roles {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  bytes32 public constant VAULT_CONTROLLER_ROLE = keccak256('VAULT_CONTROLLER');\n\n  EnumerableSet.AddressSet internal _vaultControllers;\n\n  /// @dev The reserve token\n  IERC20 public sUSD;\n\n  /// @dev The address of the pauser\n  address public pauser;\n\n  /// @dev The reserve amount\n  uint256 public reserveAmount;\n\n  /// @notice Checks if _msgSender() is a valid VaultController\n  modifier onlyVaultController() {\n    _checkRole(VAULT_CONTROLLER_ROLE, _msgSender());\n    _;\n  }\n\n  /// @notice Checks if _msgSender() is pauser\n  modifier onlyPauser() {\n    if (_msgSender() != address(pauser)) revert USDA_OnlyPauser();\n    _;\n  }\n\n  /// @notice Any function with this modifier will call the pay_interest() function before any function logic is called\n  modifier paysInterest() {\n    for (uint256 _i; _i < _vaultControllers.length();) {\n      IVaultController(_vaultControllers.at(_i)).calculateInterest();\n      unchecked {\n        _i++;\n      }\n    }\n    _;\n  }\n\n  constructor(IERC20 _sUSDAddr) UFragments('USDA Token', 'USDA') {\n    sUSD = _sUSDAddr;\n  }\n\n  /// @notice Sets the pauser for both USDA and VaultController\n  /// @dev The pauser is a separate role from the owner\n  function setPauser(address _pauser) external override onlyOwner {\n    pauser = _pauser;\n\n    emit PauserSet(_pauser);\n  }\n\n  /// @notice Pause contract\n  /// @dev Can only be called by the pauser\n  function pause() external override onlyPauser {\n    _pause();\n  }\n\n  /// @notice Unpause contract, pauser only\n  /// @dev Can only be called by the pauser\n  function unpause() external override onlyPauser {\n    _unpause();\n  }\n\n  /// @notice Deposit sUSD to mint USDA\n  /// @dev Caller should obtain 1 USDA for each sUSD\n  /// the calculations for deposit mimic the calculations done by mint in the ampleforth contract, simply with the susd transfer\n  /// 'fragments' are the units that we see, so 1000 fragments == 1000 USDA\n  /// 'gons' are the internal accounting unit, used to keep scale.\n  /// We use the variable _gonsPerFragment in order to convert between the two\n  /// try dimensional analysis when doing the math in order to verify units are correct\n  /// @param _susdAmount The amount of sUSD to deposit\n  function deposit(uint256 _susdAmount) external override {\n    _deposit(_susdAmount, _msgSender());\n  }\n\n  /// @notice Deposits sUSD to mint USDA and transfer to a different address\n  /// @param _susdAmount The amount of sUSD to deposit\n  /// @param _target The address to receive the USDA tokens\n  function depositTo(uint256 _susdAmount, address _target) external override {\n    _deposit(_susdAmount, _target);\n  }\n\n  /// @notice Business logic to deposit sUSD and mint USDA for the caller\n  function _deposit(uint256 _susdAmount, address _target) internal paysInterest whenNotPaused {\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    sUSD.transferFrom(_msgSender(), address(this), _susdAmount);\n    _mint(_target, _susdAmount);\n    // Account for the susd received\n    reserveAmount += _susdAmount;\n\n    emit Deposit(_target, _susdAmount);\n  }\n\n  /// @notice Withdraw sUSD by burning USDA\n  /// @dev The caller should obtain 1 sUSD for every 1 USDA\n  /// @param _susdAmount The amount of sUSD to withdraw\n  function withdraw(uint256 _susdAmount) external override {\n    _withdraw(_susdAmount, _msgSender());\n  }\n\n  /// @notice Withdraw sUSD to a specific address by burning USDA from the caller\n  /// @dev The _target address should obtain 1 sUSD for every 1 USDA burned from the caller\n  /// @param _susdAmount amount of sUSD to withdraw\n  /// @param _target address to receive the sUSD\n  function withdrawTo(uint256 _susdAmount, address _target) external override {\n    _withdraw(_susdAmount, _target);\n  }\n\n  /// @notice Withdraw sUSD by burning USDA\n  /// @dev The caller should obtain 1 sUSD for every 1 USDA\n  /// @dev This function is effectively just withdraw, but we calculate the amount for the sender\n  /// @param _susdWithdrawn The amount os sUSD withdrawn\n  function withdrawAll() external override returns (uint256 _susdWithdrawn) {\n    uint256 _balance = this.balanceOf(_msgSender());\n    _susdWithdrawn = _balance > reserveAmount ? reserveAmount : _balance;\n    _withdraw(_susdWithdrawn, _msgSender());\n  }\n\n  /// @notice Withdraw sUSD by burning USDA\n  /// @dev This function is effectively just withdraw, but we calculate the amount for the _target\n  /// @param _target should obtain 1 sUSD for every 1 USDA burned from caller\n  /// @param _susdWithdrawn The amount os sUSD withdrawn\n  function withdrawAllTo(address _target) external override returns (uint256 _susdWithdrawn) {\n    uint256 _balance = this.balanceOf(_msgSender());\n    _susdWithdrawn = _balance > reserveAmount ? reserveAmount : _balance;\n    _withdraw(_susdWithdrawn, _target);\n  }\n\n  /// @notice business logic to withdraw sUSD and burn USDA from the caller\n  function _withdraw(uint256 _susdAmount, address _target) internal paysInterest whenNotPaused {\n    if (reserveAmount == 0) revert USDA_EmptyReserve();\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    if (_susdAmount > this.balanceOf(_msgSender())) revert USDA_InsufficientFunds();\n    // Account for the susd withdrawn\n    reserveAmount -= _susdAmount;\n    sUSD.transfer(_target, _susdAmount);\n    _burn(_msgSender(), _susdAmount);\n\n    emit Withdraw(_target, _susdAmount);\n  }\n\n  /// @notice Admin function to mint USDA\n  /// @param _susdAmount The amount of USDA to mint, denominated in sUSD\n  function mint(uint256 _susdAmount) external override paysInterest onlyOwner {\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    _mint(_msgSender(), _susdAmount);\n  }\n\n  /// @dev mint a specific `amount` of tokens to the `target`\n  function _mint(address _target, uint256 _amount) internal {\n    uint256 __gonsPerFragment = _gonsPerFragment;\n    // the gonbalances of the sender is in gons, therefore we must multiply the deposit amount, which is in fragments, by gonsperfragment\n    _gonBalances[_target] += _amount * __gonsPerFragment;\n    // total supply is in fragments, and so we add amount\n    _totalSupply += _amount;\n    // and totalgons of course is in gons, and so we multiply amount by gonsperfragment to get the amount of gons we must add to totalGons\n    _totalGons += _amount * __gonsPerFragment;\n    // emit both a mint and transfer event\n    emit Transfer(address(0), _target, _amount);\n    emit Mint(_target, _amount);\n  }\n\n  /// @notice Admin function to burn USDA\n  /// @param _susdAmount The amount of USDA to burn, denominated in sUSD\n  function burn(uint256 _susdAmount) external override paysInterest onlyOwner {\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    _burn(_msgSender(), _susdAmount);\n  }\n\n  /// @dev burn a specific `amount` of tokens from the `target`\n  function _burn(address _target, uint256 _amount) internal {\n    uint256 __gonsPerFragment = _gonsPerFragment;\n    // modify the gonbalances of the sender, subtracting the amount of gons, therefore amount * gonsperfragment\n    _gonBalances[_target] -= (_amount * __gonsPerFragment);\n    // modify totalSupply and totalGons\n    _totalSupply -= _amount;\n    _totalGons -= (_amount * __gonsPerFragment);\n    // emit both a burn and transfer event\n    emit Transfer(_target, address(0), _amount);\n    emit Burn(_target, _amount);\n  }\n\n  /// @notice Donates susd to the protocol reserve\n  /// @param _susdAmount The amount of sUSD to donate\n  function donate(uint256 _susdAmount) external override paysInterest whenNotPaused {\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    // Account for the susd received\n    reserveAmount += _susdAmount;\n    sUSD.transferFrom(_msgSender(), address(this), _susdAmount);\n    _donation(_susdAmount);\n  }\n\n  /// @notice Recovers accidentally sent sUSD to this contract\n  /// @param _to The receiver of the dust\n  function recoverDust(address _to) external onlyOwner {\n    // All sUSD sent directly to the contract is not accounted into the reserveAmount\n    // This function allows governance to recover it\n    uint256 _amount = sUSD.balanceOf(address(this)) - reserveAmount;\n    sUSD.transfer(_to, _amount);\n\n    emit RecoveredDust(owner(), _amount);\n  }\n\n  /// @notice Function for the vaultController to mint\n  /// @param _target The address to mint the USDA to\n  /// @param _amount The amount of USDA to mint\n  function vaultControllerMint(address _target, uint256 _amount) external override onlyVaultController whenNotPaused {\n    _mint(_target, _amount);\n  }\n\n  /// @notice Function for the vaultController to burn\n  /// @param _target The address to burn the USDA from\n  /// @param _amount The amount of USDA to burn\n  function vaultControllerBurn(address _target, uint256 _amount) external override onlyVaultController {\n    if (_gonBalances[_target] < (_amount * _gonsPerFragment)) revert USDA_NotEnoughBalance();\n    _burn(_target, _amount);\n  }\n\n  /// @notice Allows VaultController to send sUSD from the reserve\n  /// @param _target The address to receive the sUSD from reserve\n  /// @param _susdAmount The amount of sUSD to send\n  function vaultControllerTransfer(\n    address _target,\n    uint256 _susdAmount\n  ) external override onlyVaultController whenNotPaused {\n    // Account for the susd withdrawn\n    reserveAmount -= _susdAmount;\n    // ensure transfer success\n    sUSD.transfer(_target, _susdAmount);\n\n    emit VaultControllerTransfer(_target, _susdAmount);\n  }\n\n  /// @notice Function for the vaultController to scale all USDA balances\n  /// @param _amount The amount of USDA (e18) to donate\n  function vaultControllerDonate(uint256 _amount) external override onlyVaultController {\n    _donation(_amount);\n  }\n\n  /// @notice Function for distributing the donation to all USDA holders\n  /// @param _amount The amount of USDA to donate\n  function _donation(uint256 _amount) internal {\n    _totalSupply += _amount;\n    if (_totalSupply > MAX_SUPPLY) _totalSupply = MAX_SUPPLY;\n    _gonsPerFragment = _totalGons / _totalSupply;\n    emit Donation(_msgSender(), _amount, _totalSupply);\n  }\n\n  /// @notice Returns the reserve ratio\n  /// @return _e18reserveRatio The USDA reserve ratio\n  function reserveRatio() external view override returns (uint192 _e18reserveRatio) {\n    _e18reserveRatio = _safeu192((reserveAmount * EXP_SCALE) / _totalSupply);\n  }\n\n  /*///////////////////////////////////////////////////////////////\n                                ROLES\n    //////////////////////////////////////////////////////////////*/\n\n  /// @notice Adds a new vault controller\n  /// @param _vaultController The new vault controller to add\n  function addVaultController(address _vaultController) external onlyOwner {\n    _vaultControllers.add(_vaultController);\n    _grantRole(VAULT_CONTROLLER_ROLE, _vaultController);\n\n    emit VaultControllerAdded(_vaultController);\n  }\n\n  /// @notice Removes a vault controller\n  /// @param _vaultController The vault controller to remove\n  function removeVaultController(address _vaultController) external onlyOwner {\n    _vaultControllers.remove(_vaultController);\n    _revokeRole(VAULT_CONTROLLER_ROLE, _vaultController);\n\n    emit VaultControllerRemoved(_vaultController);\n  }\n\n  /// @notice Removes a vault controller from the list\n  /// @param _vaultController The vault controller to remove\n  /// @dev The vault controller is removed from the list but keeps the role as to not brick it\n  function removeVaultControllerFromList(address _vaultController) external onlyOwner {\n    _vaultControllers.remove(_vaultController);\n\n    emit VaultControllerRemovedFromList(_vaultController);\n  }\n}"
    },
    {
      "filename": "core/solidity/contracts/core/USDA.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {ExponentialNoError} from '@contracts/utils/ExponentialNoError.sol';\nimport {Roles} from '@contracts/utils/Roles.sol';\nimport {UFragments} from '@contracts/utils/UFragments.sol';\n\nimport {IUSDA} from '@interfaces/core/IUSDA.sol';\nimport {IVaultController} from '@interfaces/core/IVaultController.sol';\n\nimport {IERC20Metadata, IERC20} from '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\nimport {Pausable} from '@openzeppelin/contracts/security/Pausable.sol';\nimport {Context} from '@openzeppelin/contracts/utils/Context.sol';\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\n\n/// @notice USDA token contract, handles all minting/burning of usda\n/// @dev extends UFragments\ncontract USDA is Pausable, UFragments, IUSDA, ExponentialNoError, Roles {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  bytes32 public constant VAULT_CONTROLLER_ROLE = keccak256('VAULT_CONTROLLER');\n\n  EnumerableSet.AddressSet internal _vaultControllers;\n\n  /// @dev The reserve token\n  IERC20 public sUSD;\n\n  /// @dev The address of the pauser\n  address public pauser;\n\n  /// @dev The reserve amount\n  uint256 public reserveAmount;\n\n  /// @notice Checks if _msgSender() is a valid VaultController\n  modifier onlyVaultController() {\n    _checkRole(VAULT_CONTROLLER_ROLE, _msgSender());\n    _;\n  }\n\n  /// @notice Checks if _msgSender() is pauser\n  modifier onlyPauser() {\n    if (_msgSender() != address(pauser)) revert USDA_OnlyPauser();\n    _;\n  }\n\n  /// @notice Any function with this modifier will call the pay_interest() function before any function logic is called\n  modifier paysInterest() {\n    for (uint256 _i; _i < _vaultControllers.length();) {\n      IVaultController(_vaultControllers.at(_i)).calculateInterest();\n      unchecked {\n        _i++;\n      }\n    }\n    _;\n  }\n\n  constructor(IERC20 _sUSDAddr) UFragments('USDA Token', 'USDA') {\n    sUSD = _sUSDAddr;\n  }\n\n  /// @notice Sets the pauser for both USDA and VaultController\n  /// @dev The pauser is a separate role from the owner\n  function setPauser(address _pauser) external override onlyOwner {\n    pauser = _pauser;\n\n    emit PauserSet(_pauser);\n  }\n\n  /// @notice Pause contract\n  /// @dev Can only be called by the pauser\n  function pause() external override onlyPauser {\n    _pause();\n  }\n\n  /// @notice Unpause contract, pauser only\n  /// @dev Can only be called by the pauser\n  function unpause() external override onlyPauser {\n    _unpause();\n  }\n\n  /// @notice Deposit sUSD to mint USDA\n  /// @dev Caller should obtain 1 USDA for each sUSD\n  /// the calculations for deposit mimic the calculations done by mint in the ampleforth contract, simply with the susd transfer\n  /// 'fragments' are the units that we see, so 1000 fragments == 1000 USDA\n  /// 'gons' are the internal accounting unit, used to keep scale.\n  /// We use the variable _gonsPerFragment in order to convert between the two\n  /// try dimensional analysis when doing the math in order to verify units are correct\n  /// @param _susdAmount The amount of sUSD to deposit\n  function deposit(uint256 _susdAmount) external override {\n    _deposit(_susdAmount, _msgSender());\n  }\n\n  /// @notice Deposits sUSD to mint USDA and transfer to a different address\n  /// @param _susdAmount The amount of sUSD to deposit\n  /// @param _target The address to receive the USDA tokens\n  function depositTo(uint256 _susdAmount, address _target) external override {\n    _deposit(_susdAmount, _target);\n  }\n\n  /// @notice Business logic to deposit sUSD and mint USDA for the caller\n  function _deposit(uint256 _susdAmount, address _target) internal paysInterest whenNotPaused {\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    sUSD.transferFrom(_msgSender(), address(this), _susdAmount);\n    _mint(_target, _susdAmount);\n    // Account for the susd received\n    reserveAmount += _susdAmount;\n\n    emit Deposit(_target, _susdAmount);\n  }\n\n  /// @notice Withdraw sUSD by burning USDA\n  /// @dev The caller should obtain 1 sUSD for every 1 USDA\n  /// @param _susdAmount The amount of sUSD to withdraw\n  function withdraw(uint256 _susdAmount) external override {\n    _withdraw(_susdAmount, _msgSender());\n  }\n\n  /// @notice Withdraw sUSD to a specific address by burning USDA from the caller\n  /// @dev The _target address should obtain 1 sUSD for every 1 USDA burned from the caller\n  /// @param _susdAmount amount of sUSD to withdraw\n  /// @param _target address to receive the sUSD\n  function withdrawTo(uint256 _susdAmount, address _target) external override {\n    _withdraw(_susdAmount, _target);\n  }\n\n  /// @notice Withdraw sUSD by burning USDA\n  /// @dev The caller should obtain 1 sUSD for every 1 USDA\n  /// @dev This function is effectively just withdraw, but we calculate the amount for the sender\n  /// @param _susdWithdrawn The amount os sUSD withdrawn\n  function withdrawAll() external override returns (uint256 _susdWithdrawn) {\n    uint256 _balance = this.balanceOf(_msgSender());\n    _susdWithdrawn = _balance > reserveAmount ? reserveAmount : _balance;\n    _withdraw(_susdWithdrawn, _msgSender());\n  }\n\n  /// @notice Withdraw sUSD by burning USDA\n  /// @dev This function is effectively just withdraw, but we calculate the amount for the _target\n  /// @param _target should obtain 1 sUSD for every 1 USDA burned from caller\n  /// @param _susdWithdrawn The amount os sUSD withdrawn\n  function withdrawAllTo(address _target) external override returns (uint256 _susdWithdrawn) {\n    uint256 _balance = this.balanceOf(_msgSender());\n    _susdWithdrawn = _balance > reserveAmount ? reserveAmount : _balance;\n    _withdraw(_susdWithdrawn, _target);\n  }\n\n  /// @notice business logic to withdraw sUSD and burn USDA from the caller\n  function _withdraw(uint256 _susdAmount, address _target) internal paysInterest whenNotPaused {\n    if (reserveAmount == 0) revert USDA_EmptyReserve();\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    if (_susdAmount > this.balanceOf(_msgSender())) revert USDA_InsufficientFunds();\n    // Account for the susd withdrawn\n    reserveAmount -= _susdAmount;\n    sUSD.transfer(_target, _susdAmount);\n    _burn(_msgSender(), _susdAmount);\n\n    emit Withdraw(_target, _susdAmount);\n  }\n\n  /// @notice Admin function to mint USDA\n  /// @param _susdAmount The amount of USDA to mint, denominated in sUSD\n  function mint(uint256 _susdAmount) external override paysInterest onlyOwner {\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    _mint(_msgSender(), _susdAmount);\n  }\n\n  /// @dev mint a specific `amount` of tokens to the `target`\n  function _mint(address _target, uint256 _amount) internal {\n    uint256 __gonsPerFragment = _gonsPerFragment;\n    // the gonbalances of the sender is in gons, therefore we must multiply the deposit amount, which is in fragments, by gonsperfragment\n    _gonBalances[_target] += _amount * __gonsPerFragment;\n    // total supply is in fragments, and so we add amount\n    _totalSupply += _amount;\n    // and totalgons of course is in gons, and so we multiply amount by gonsperfragment to get the amount of gons we must add to totalGons\n    _totalGons += _amount * __gonsPerFragment;\n    // emit both a mint and transfer event\n    emit Transfer(address(0), _target, _amount);\n    emit Mint(_target, _amount);\n  }\n\n  /// @notice Admin function to burn USDA\n  /// @param _susdAmount The amount of USDA to burn, denominated in sUSD\n  function burn(uint256 _susdAmount) external override paysInterest onlyOwner {\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    _burn(_msgSender(), _susdAmount);\n  }\n\n  /// @dev burn a specific `amount` of tokens from the `target`\n  function _burn(address _target, uint256 _amount) internal {\n    uint256 __gonsPerFragment = _gonsPerFragment;\n    // modify the gonbalances of the sender, subtracting the amount of gons, therefore amount * gonsperfragment\n    _gonBalances[_target] -= (_amount * __gonsPerFragment);\n    // modify totalSupply and totalGons\n    _totalSupply -= _amount;\n    _totalGons -= (_amount * __gonsPerFragment);\n    // emit both a burn and transfer event\n    emit Transfer(_target, address(0), _amount);\n    emit Burn(_target, _amount);\n  }\n\n  /// @notice Donates susd to the protocol reserve\n  /// @param _susdAmount The amount of sUSD to donate\n  function donate(uint256 _susdAmount) external override paysInterest whenNotPaused {\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    // Account for the susd received\n    reserveAmount += _susdAmount;\n    sUSD.transferFrom(_msgSender(), address(this), _susdAmount);\n    _donation(_susdAmount);\n  }\n\n  /// @notice Recovers accidentally sent sUSD to this contract\n  /// @param _to The receiver of the dust\n  function recoverDust(address _to) external onlyOwner {\n    // All sUSD sent directly to the contract is not accounted into the reserveAmount\n    // This function allows governance to recover it\n    uint256 _amount = sUSD.balanceOf(address(this)) - reserveAmount;\n    sUSD.transfer(_to, _amount);\n\n    emit RecoveredDust(owner(), _amount);\n  }\n\n  /// @notice Function for the vaultController to mint\n  /// @param _target The address to mint the USDA to\n  /// @param _amount The amount of USDA to mint\n  function vaultControllerMint(address _target, uint256 _amount) external override onlyVaultController whenNotPaused {\n    _mint(_target, _amount);\n  }\n\n  /// @notice Function for the vaultController to burn\n  /// @param _target The address to burn the USDA from\n  /// @param _amount The amount of USDA to burn\n  function vaultControllerBurn(address _target, uint256 _amount) external override onlyVaultController {\n    if (_gonBalances[_target] < (_amount * _gonsPerFragment)) revert USDA_NotEnoughBalance();\n    _burn(_target, _amount);\n  }\n\n  /// @notice Allows VaultController to send sUSD from the reserve\n  /// @param _target The address to receive the sUSD from reserve\n  /// @param _susdAmount The amount of sUSD to send\n  function vaultControllerTransfer(\n    address _target,\n    uint256 _susdAmount\n  ) external override onlyVaultController whenNotPaused {\n    // Account for the susd withdrawn\n    reserveAmount -= _susdAmount;\n    // ensure transfer success\n    sUSD.transfer(_target, _susdAmount);\n\n    emit VaultControllerTransfer(_target, _susdAmount);\n  }\n\n  /// @notice Function for the vaultController to scale all USDA balances\n  /// @param _amount The amount of USDA (e18) to donate\n  function vaultControllerDonate(uint256 _amount) external override onlyVaultController {\n    _donation(_amount);\n  }\n\n  /// @notice Function for distributing the donation to all USDA holders\n  /// @param _amount The amount of USDA to donate\n  function _donation(uint256 _amount) internal {\n    _totalSupply += _amount;\n    if (_totalSupply > MAX_SUPPLY) _totalSupply = MAX_SUPPLY;\n    _gonsPerFragment = _totalGons / _totalSupply;\n    emit Donation(_msgSender(), _amount, _totalSupply);\n  }\n\n  /// @notice Returns the reserve ratio\n  /// @return _e18reserveRatio The USDA reserve ratio\n  function reserveRatio() external view override returns (uint192 _e18reserveRatio) {\n    _e18reserveRatio = _safeu192((reserveAmount * EXP_SCALE) / _totalSupply);\n  }\n\n  /*///////////////////////////////////////////////////////////////\n                                ROLES\n    //////////////////////////////////////////////////////////////*/\n\n  /// @notice Adds a new vault controller\n  /// @param _vaultController The new vault controller to add\n  function addVaultController(address _vaultController) external onlyOwner {\n    _vaultControllers.add(_vaultController);\n    _grantRole(VAULT_CONTROLLER_ROLE, _vaultController);\n\n    emit VaultControllerAdded(_vaultController);\n  }\n\n  /// @notice Removes a vault controller\n  /// @param _vaultController The vault controller to remove\n  function removeVaultController(address _vaultController) external onlyOwner {\n    _vaultControllers.remove(_vaultController);\n    _revokeRole(VAULT_CONTROLLER_ROLE, _vaultController);\n\n    emit VaultControllerRemoved(_vaultController);\n  }\n\n  /// @notice Removes a vault controller from the list\n  /// @param _vaultController The vault controller to remove\n  /// @dev The vault controller is removed from the list but keeps the role as to not brick it\n  function removeVaultControllerFromList(address _vaultController) external onlyOwner {\n    _vaultControllers.remove(_vaultController);\n\n    emit VaultControllerRemovedFromList(_vaultController);\n  }\n}"
    },
    {
      "filename": "core/solidity/contracts/core/USDA.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {ExponentialNoError} from '@contracts/utils/ExponentialNoError.sol';\nimport {Roles} from '@contracts/utils/Roles.sol';\nimport {UFragments} from '@contracts/utils/UFragments.sol';\n\nimport {IUSDA} from '@interfaces/core/IUSDA.sol';\nimport {IVaultController} from '@interfaces/core/IVaultController.sol';\n\nimport {IERC20Metadata, IERC20} from '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\nimport {Pausable} from '@openzeppelin/contracts/security/Pausable.sol';\nimport {Context} from '@openzeppelin/contracts/utils/Context.sol';\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\n\n/// @notice USDA token contract, handles all minting/burning of usda\n/// @dev extends UFragments\ncontract USDA is Pausable, UFragments, IUSDA, ExponentialNoError, Roles {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  bytes32 public constant VAULT_CONTROLLER_ROLE = keccak256('VAULT_CONTROLLER');\n\n  EnumerableSet.AddressSet internal _vaultControllers;\n\n  /// @dev The reserve token\n  IERC20 public sUSD;\n\n  /// @dev The address of the pauser\n  address public pauser;\n\n  /// @dev The reserve amount\n  uint256 public reserveAmount;\n\n  /// @notice Checks if _msgSender() is a valid VaultController\n  modifier onlyVaultController() {\n    _checkRole(VAULT_CONTROLLER_ROLE, _msgSender());\n    _;\n  }\n\n  /// @notice Checks if _msgSender() is pauser\n  modifier onlyPauser() {\n    if (_msgSender() != address(pauser)) revert USDA_OnlyPauser();\n    _;\n  }\n\n  /// @notice Any function with this modifier will call the pay_interest() function before any function logic is called\n  modifier paysInterest() {\n    for (uint256 _i; _i < _vaultControllers.length();) {\n      IVaultController(_vaultControllers.at(_i)).calculateInterest();\n      unchecked {\n        _i++;\n      }\n    }\n    _;\n  }\n\n  constructor(IERC20 _sUSDAddr) UFragments('USDA Token', 'USDA') {\n    sUSD = _sUSDAddr;\n  }\n\n  /// @notice Sets the pauser for both USDA and VaultController\n  /// @dev The pauser is a separate role from the owner\n  function setPauser(address _pauser) external override onlyOwner {\n    pauser = _pauser;\n\n    emit PauserSet(_pauser);\n  }\n\n  /// @notice Pause contract\n  /// @dev Can only be called by the pauser\n  function pause() external override onlyPauser {\n    _pause();\n  }\n\n  /// @notice Unpause contract, pauser only\n  /// @dev Can only be called by the pauser\n  function unpause() external override onlyPauser {\n    _unpause();\n  }\n\n  /// @notice Deposit sUSD to mint USDA\n  /// @dev Caller should obtain 1 USDA for each sUSD\n  /// the calculations for deposit mimic the calculations done by mint in the ampleforth contract, simply with the susd transfer\n  /// 'fragments' are the units that we see, so 1000 fragments == 1000 USDA\n  /// 'gons' are the internal accounting unit, used to keep scale.\n  /// We use the variable _gonsPerFragment in order to convert between the two\n  /// try dimensional analysis when doing the math in order to verify units are correct\n  /// @param _susdAmount The amount of sUSD to deposit\n  function deposit(uint256 _susdAmount) external override {\n    _deposit(_susdAmount, _msgSender());\n  }\n\n  /// @notice Deposits sUSD to mint USDA and transfer to a different address\n  /// @param _susdAmount The amount of sUSD to deposit\n  /// @param _target The address to receive the USDA tokens\n  function depositTo(uint256 _susdAmount, address _target) external override {\n    _deposit(_susdAmount, _target);\n  }\n\n  /// @notice Business logic to deposit sUSD and mint USDA for the caller\n  function _deposit(uint256 _susdAmount, address _target) internal paysInterest whenNotPaused {\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    sUSD.transferFrom(_msgSender(), address(this), _susdAmount);\n    _mint(_target, _susdAmount);\n    // Account for the susd received\n    reserveAmount += _susdAmount;\n\n    emit Deposit(_target, _susdAmount);\n  }\n\n  /// @notice Withdraw sUSD by burning USDA\n  /// @dev The caller should obtain 1 sUSD for every 1 USDA\n  /// @param _susdAmount The amount of sUSD to withdraw\n  function withdraw(uint256 _susdAmount) external override {\n    _withdraw(_susdAmount, _msgSender());\n  }\n\n  /// @notice Withdraw sUSD to a specific address by burning USDA from the caller\n  /// @dev The _target address should obtain 1 sUSD for every 1 USDA burned from the caller\n  /// @param _susdAmount amount of sUSD to withdraw\n  /// @param _target address to receive the sUSD\n  function withdrawTo(uint256 _susdAmount, address _target) external override {\n    _withdraw(_susdAmount, _target);\n  }\n\n  /// @notice Withdraw sUSD by burning USDA\n  /// @dev The caller should obtain 1 sUSD for every 1 USDA\n  /// @dev This function is effectively just withdraw, but we calculate the amount for the sender\n  /// @param _susdWithdrawn The amount os sUSD withdrawn\n  function withdrawAll() external override returns (uint256 _susdWithdrawn) {\n    uint256 _balance = this.balanceOf(_msgSender());\n    _susdWithdrawn = _balance > reserveAmount ? reserveAmount : _balance;\n    _withdraw(_susdWithdrawn, _msgSender());\n  }\n\n  /// @notice Withdraw sUSD by burning USDA\n  /// @dev This function is effectively just withdraw, but we calculate the amount for the _target\n  /// @param _target should obtain 1 sUSD for every 1 USDA burned from caller\n  /// @param _susdWithdrawn The amount os sUSD withdrawn\n  function withdrawAllTo(address _target) external override returns (uint256 _susdWithdrawn) {\n    uint256 _balance = this.balanceOf(_msgSender());\n    _susdWithdrawn = _balance > reserveAmount ? reserveAmount : _balance;\n    _withdraw(_susdWithdrawn, _target);\n  }\n\n  /// @notice business logic to withdraw sUSD and burn USDA from the caller\n  function _withdraw(uint256 _susdAmount, address _target) internal paysInterest whenNotPaused {\n    if (reserveAmount == 0) revert USDA_EmptyReserve();\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    if (_susdAmount > this.balanceOf(_msgSender())) revert USDA_InsufficientFunds();\n    // Account for the susd withdrawn\n    reserveAmount -= _susdAmount;\n    sUSD.transfer(_target, _susdAmount);\n    _burn(_msgSender(), _susdAmount);\n\n    emit Withdraw(_target, _susdAmount);\n  }\n\n  /// @notice Admin function to mint USDA\n  /// @param _susdAmount The amount of USDA to mint, denominated in sUSD\n  function mint(uint256 _susdAmount) external override paysInterest onlyOwner {\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    _mint(_msgSender(), _susdAmount);\n  }\n\n  /// @dev mint a specific `amount` of tokens to the `target`\n  function _mint(address _target, uint256 _amount) internal {\n    uint256 __gonsPerFragment = _gonsPerFragment;\n    // the gonbalances of the sender is in gons, therefore we must multiply the deposit amount, which is in fragments, by gonsperfragment\n    _gonBalances[_target] += _amount * __gonsPerFragment;\n    // total supply is in fragments, and so we add amount\n    _totalSupply += _amount;\n    // and totalgons of course is in gons, and so we multiply amount by gonsperfragment to get the amount of gons we must add to totalGons\n    _totalGons += _amount * __gonsPerFragment;\n    // emit both a mint and transfer event\n    emit Transfer(address(0), _target, _amount);\n    emit Mint(_target, _amount);\n  }\n\n  /// @notice Admin function to burn USDA\n  /// @param _susdAmount The amount of USDA to burn, denominated in sUSD\n  function burn(uint256 _susdAmount) external override paysInterest onlyOwner {\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    _burn(_msgSender(), _susdAmount);\n  }\n\n  /// @dev burn a specific `amount` of tokens from the `target`\n  function _burn(address _ta"
    }
  ]
}