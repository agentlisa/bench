{
  "Title": "Potential for hash collisions with frontrun protection",
  "Content": "Within `AgentRegistryCore.sol`, calls to the [`frontrunProtected` modifier](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/agents/AgentRegistryCore.sol#L38) utilize `abi.encodePacked` to create a “unique” hash of some commited data.\n\n\nHowever, by using two dynamic parameters next to each other (both in [`createAgent`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/agents/AgentRegistryCore.sol#L38) and in [`updateAgent`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/agents/AgentRegistryCore.sol#L54)), hashes can be easily forged simply by adjusting `metadata` and `chainIds`, such that an agent may be created or updated incorrectly.\n\n\nBy simply using `abi.encode` rather than `abi.encodePacked`, such collisions from dynamic parameters being adjacent can be avoided. Consider using `abi.encode` here instead.\n\n\n***Update:** Fixed on [commit `2a7391dff896384174ca49ff960d889120961a4e` in pull request 57](https://github.com/forta-protocol/forta-token/pull/57/commits/2a7391dff896384174ca49ff960d889120961a4e).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/components/agents/AgentRegistryCore.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\n\nimport \"../BaseComponentUpgradeable.sol\";\nimport \"../../tools/FrontRunningProtection.sol\";\n\nabstract contract AgentRegistryCore is\n    BaseComponentUpgradeable,\n    FrontRunningProtection,\n    ERC721Upgradeable\n{\n    event AgentCommitted(bytes32 indexed commit);\n    event AgentUpdated(uint256 indexed agentId, address indexed by, string metadata, uint256[] chainIds);\n\n    modifier onlyOwnerOf(uint256 agentId) {\n        require(_msgSender() == ownerOf(agentId), \"AgentRegistryCore: Restricted to agent owner\");\n        _;\n    }\n\n    modifier onlySorted(uint256[] memory array) {\n        require(array.length > 0, \"AgentRegistryCore: At least one chain id required\");\n        for (uint256 i = 1; i < array.length; ++i ) {\n            require(array[i] > array[i-1], \"AgentRegistryCore: Values must be sorted\");\n        }\n        _;\n    }\n\n    function prepareAgent(bytes32 commit) public {\n        _frontrunCommit(commit);\n        emit AgentCommitted(commit);\n    }\n\n    function createAgent(uint256 agentId, address owner, string calldata metadata, uint256[] calldata chainIds)\n    public\n        onlySorted(chainIds)\n        frontrunProtected(keccak256(abi.encodePacked(agentId, owner, metadata, chainIds)), 0 minutes) // TODO: 0 disables the check\n    {\n        _mint(owner, agentId);\n        _beforeAgentUpdate(agentId, metadata, chainIds);\n        _agentUpdate(agentId, metadata, chainIds);\n        _afterAgentUpdate(agentId, metadata, chainIds);\n    }\n\n    function isCreated(uint256 agentId) public view returns(bool) {\n        return _exists(agentId);\n    }\n\n    function updateAgent(uint256 agentId, string calldata metadata, uint256[] calldata chainIds)\n    public\n        onlyOwnerOf(agentId)\n        onlySorted(chainIds)\n        frontrunProtected(keccak256(abi.encodePacked(agentId, metadata, chainIds)), 0 minutes) // TODO: 0 disables the check\n    {\n        _beforeAgentUpdate(agentId, metadata, chainIds);\n        _agentUpdate(agentId, metadata, chainIds);\n        _afterAgentUpdate(agentId, metadata, chainIds);\n    }\n\n    /**\n     * Hook: Agent metadata change (create/update)\n     */\n    function _beforeAgentUpdate(uint256 agentId, string memory newMetadata, uint256[] calldata newChainIds) internal virtual {\n    }\n\n    function _agentUpdate(uint256 agentId, string memory newMetadata, uint256[] calldata newChainIds) internal virtual {\n        emit AgentUpdated(agentId, _msgSender(), newMetadata, newChainIds);\n    }\n\n    function _afterAgentUpdate(uint256 agentId, string memory newMetadata, uint256[] calldata newChainIds) internal virtual {\n        _emitHook(abi.encodeWithSignature(\"hook_afterAgentUpdate(uint256)\", agentId));\n    }\n\n    function _msgSender() internal view virtual override(ContextUpgradeable, BaseComponentUpgradeable) returns (address sender) {\n        return super._msgSender();\n    }\n\n    function _msgData() internal view virtual override(ContextUpgradeable, BaseComponentUpgradeable) returns (bytes calldata) {\n        return super._msgData();\n    }\n\n    uint256[45] private __gap;\n}"
    },
    {
      "filename": "contracts/components/agents/AgentRegistryCore.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\n\nimport \"../BaseComponentUpgradeable.sol\";\nimport \"../../tools/FrontRunningProtection.sol\";\n\nabstract contract AgentRegistryCore is\n    BaseComponentUpgradeable,\n    FrontRunningProtection,\n    ERC721Upgradeable\n{\n    event AgentCommitted(bytes32 indexed commit);\n    event AgentUpdated(uint256 indexed agentId, address indexed by, string metadata, uint256[] chainIds);\n\n    modifier onlyOwnerOf(uint256 agentId) {\n        require(_msgSender() == ownerOf(agentId), \"AgentRegistryCore: Restricted to agent owner\");\n        _;\n    }\n\n    modifier onlySorted(uint256[] memory array) {\n        require(array.length > 0, \"AgentRegistryCore: At least one chain id required\");\n        for (uint256 i = 1; i < array.length; ++i ) {\n            require(array[i] > array[i-1], \"AgentRegistryCore: Values must be sorted\");\n        }\n        _;\n    }\n\n    function prepareAgent(bytes32 commit) public {\n        _frontrunCommit(commit);\n        emit AgentCommitted(commit);\n    }\n\n    function createAgent(uint256 agentId, address owner, string calldata metadata, uint256[] calldata chainIds)\n    public\n        onlySorted(chainIds)\n        frontrunProtected(keccak256(abi.encodePacked(agentId, owner, metadata, chainIds)), 0 minutes) // TODO: 0 disables the check\n    {\n        _mint(owner, agentId);\n        _beforeAgentUpdate(agentId, metadata, chainIds);\n        _agentUpdate(agentId, metadata, chainIds);\n        _afterAgentUpdate(agentId, metadata, chainIds);\n    }\n\n    function isCreated(uint256 agentId) public view returns(bool) {\n        return _exists(agentId);\n    }\n\n    function updateAgent(uint256 agentId, string calldata metadata, uint256[] calldata chainIds)\n    public\n        onlyOwnerOf(agentId)\n        onlySorted(chainIds)\n        frontrunProtected(keccak256(abi.encodePacked(agentId, metadata, chainIds)), 0 minutes) // TODO: 0 disables the check\n    {\n        _beforeAgentUpdate(agentId, metadata, chainIds);\n        _agentUpdate(agentId, metadata, chainIds);\n        _afterAgentUpdate(agentId, metadata, chainIds);\n    }\n\n    /**\n     * Hook: Agent metadata change (create/update)\n     */\n    function _beforeAgentUpdate(uint256 agentId, string memory newMetadata, uint256[] calldata newChainIds) internal virtual {\n    }\n\n    function _agentUpdate(uint256 agentId, string memory newMetadata, uint256[] calldata newChainIds) internal virtual {\n        emit AgentUpdated(agentId, _msgSender(), newMetadata, newChainIds);\n    }\n\n    function _afterAgentUpdate(uint256 agentId, string memory newMetadata, uint256[] calldata newChainIds) internal virtual {\n        _emitHook(abi.encodeWithSignature(\"hook_afterAgentUpdate(uint256)\", agentId));\n    }\n\n    function _msgSender() internal view virtual override(ContextUpgradeable, BaseComponentUpgradeable) returns (address sender) {\n        return super._msgSender();\n    }\n\n    function _msgData() internal view virtual override(ContextUpgradeable, BaseComponentUpgradeable) returns (bytes calldata) {\n        return super._msgData();\n    }\n\n    uint256[45] private __gap;\n}"
    }
  ]
}