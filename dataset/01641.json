{
  "Title": "H-6: vault balance not updated in withdrawReserves()",
  "Content": "# Issue H-6: vault balance not updated in withdrawReserves() \n\nSource: https://github.com/sherlock-audit/2023-06-dodo-judging/issues/247 \n\n## Found by \nProtocol Team\n\n## Vulnerability Detail\nhttps://github.com/sherlock-audit/2023-06-dodo/blob/a8d30e611acc9762029f8756d6a5b81825faf348/new-dodo-v3/contracts/DODOV3MM/D3Vault/D3Vault.sol#L178-L186\n\n\n## Impact\nThis is a critical bug, will cause wrong exchange rate calculation, which will impact almost all the funding related functions.\n\n## Tool Used\nManual Review\n\n## Recommandation\nupdate vault balance in withdrawReserves()\n \n\n\n\n## Discussion\n\n**hrishibhat**\n\nPlease note: This issue is not part of the contest submissions and is not eligible for contest rewards. \n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/89",
  "Code": [
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/D3Vault/D3Vault.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport \"./D3VaultFunding.sol\";\nimport \"./D3VaultLiquidation.sol\";\n\ncontract D3Vault is D3VaultFunding, D3VaultLiquidation {\n    using SafeERC20 for IERC20;\n    using DecimalMath for uint256;\n\n    // ---------- Setting ----------\n\n    function addD3PoolByFactory(address pool) external onlyFactory {\n        require(allPoolAddrMap[pool] == false, Errors.POOL_ALREADY_ADDED);\n        allPoolAddrMap[pool] = true;\n        address creator = ID3MM(pool)._CREATOR_();\n        creatorPoolMap[creator].push(pool);\n        emit AddPool(pool);\n    }\n\n    function addD3Pool(address pool) external onlyOwner {\n        require(allPoolAddrMap[pool] == false, Errors.POOL_ALREADY_ADDED);\n        allPoolAddrMap[pool] = true;\n        address creator = ID3MM(pool)._CREATOR_();\n        creatorPoolMap[creator].push(pool);\n        emit AddPool(pool);\n    }\n\n    // ================= Remove Pool Steps ===================\n\n    /// @notice When removing a pool\n    /// @notice if the pool has enough assets to repay all borrows, we can just repay:\n    /// @notice removeD3Pool() -> pendingRemovePoolRepayAll() -> finishPoolRemove()\n    /// @notice if not, should go through liquidation process by DODO:\n    /// @notice removeD3Pool() -> liquidateByDODO() -> finishPoolRemove()\n    function removeD3Pool(address pool) external onlyOwner {\n        require(allPoolAddrMap[pool] == true, Errors.POOL_NOT_ADDED);\n        ID3MM(pool).startLiquidation();\n\n        allPoolAddrMap[pool] = false;\n        _PENDING_REMOVE_POOL_ = pool;\n        address creator = ID3MM(pool)._CREATOR_();\n        address[] memory poolList = creatorPoolMap[creator];\n        for (uint256 i = 0; i < poolList.length; i++) {\n            if (poolList[i] == pool) {\n                poolList[i] == poolList[poolList.length - 1];\n                creatorPoolMap[creator] = poolList;\n                creatorPoolMap[creator].pop();\n                emit RemovePool(pool);\n                break;\n            }\n        }\n    }\n\n    function pendingRemovePoolRepayAll(address token) external onlyOwner {\n        _poolRepayAll(_PENDING_REMOVE_POOL_, token);\n        ID3MM(_PENDING_REMOVE_POOL_).updateReserveByVault(token);\n    }\n\n    function finishPoolRemove() external onlyOwner {\n        ID3MM(_PENDING_REMOVE_POOL_).finishLiquidation();\n        _PENDING_REMOVE_POOL_ = address(0);\n        emit RemovePool(_PENDING_REMOVE_POOL_);\n    }\n\n    // ====================================================\n\n    function setCloneFactory(address cloneFactory) external onlyOwner {\n        _CLONE_FACTORY_ = cloneFactory;\n    }\n\n    function setNewD3Factory(address newFactory) external onlyOwner {\n        _D3_FACTORY_ = newFactory;\n    }\n\n    function setNewD3UserQuota(address newQuota) external onlyOwner {\n        _USER_QUOTA_ = newQuota;\n    }\n\n    function setNewD3PoolQuota(address newQuota) external onlyOwner {\n        _POOL_QUOTA_ = newQuota;\n    }\n\n    function setNewOracle(address newOracle) external onlyOwner {\n        _ORACLE_ = newOracle;\n    }\n\n    function setNewRateManager(address newRateManager) external onlyOwner {\n        _RATE_MANAGER_ = newRateManager;\n    }\n\n    function setMaintainer(address maintainer) external onlyOwner {\n        _MAINTAINER_ = maintainer;\n    }\n\n    function setIM(uint256 newIM) external onlyOwner {\n        IM = newIM;\n    }\n\n    function setMM(uint256 newMM) external onlyOwner {\n        MM = newMM;\n    }\n\n    function setDiscount(uint256 discount) external onlyOwner {\n        DISCOUNT = discount;\n    }\n\n    function setDTokenTemplate(address dTokenTemplate) external onlyOwner {\n        _D3TOKEN_LOGIC_ = dTokenTemplate;\n    }\n\n    function addRouter(address router) external onlyOwner {\n        allowedRouter[router] = true;\n    }\n\n    function removeRouter(address router) external onlyOwner {\n        allowedRouter[router] = false;\n    }\n\n    function addLiquidator(address liquidator) external onlyOwner {\n        allowedLiquidator[liquidator] = true;\n    }\n\n    function removeLiquidator(address liquidator) external onlyOwner {\n        allowedLiquidator[liquidator] = false;\n    }\n\n    function addNewToken(\n        address token,\n        uint256 maxDeposit,\n        uint256 maxCollateral,\n        uint256 collateralWeight,\n        uint256 debtWeight,\n        uint256 reserveFactor\n    ) external onlyOwner {\n        require(!tokens[token], Errors.TOKEN_ALREADY_EXIST);\n        require(collateralWeight < 1e18 && debtWeight > 1e18, Errors.WRONG_WEIGHT);\n        require(reserveFactor < 1e18, Errors.WRONG_RESERVE_FACTOR);\n        tokens[token] = true;\n        tokenList.push(token);\n        address dToken = createDToken(token);\n        AssetInfo storage info = assetInfo[token];\n        info.dToken = dToken;\n        info.reserveFactor = reserveFactor;\n        info.borrowIndex = 1e18;\n        info.accrualTime = block.timestamp;\n        info.maxDepositAmount = maxDeposit;\n        info.maxCollateralAmount = maxCollateral;\n        info.collateralWeight = collateralWeight;\n        info.debtWeight = debtWeight;\n    }\n\n    function createDToken(address token) public returns (address) {\n        address d3Token = ICloneFactory(_CLONE_FACTORY_).clone(_D3TOKEN_LOGIC_);\n        IDToken(d3Token).init(token, address(this));\n        return d3Token;\n    }\n\n    function setToken(\n        address token,\n        uint256 maxDeposit,\n        uint256 maxCollateral,\n        uint256 collateralWeight,\n        uint256 debtWeight,\n        uint256 reserveFactor\n    ) external onlyOwner {\n        require(tokens[token], Errors.TOKEN_NOT_EXIST);\n        require(collateralWeight < 1e18 && debtWeight > 1e18, Errors.WRONG_WEIGHT);\n        require(reserveFactor < 1e18, Errors.WRONG_RESERVE_FACTOR);\n        AssetInfo storage info = assetInfo[token];\n        info.maxDepositAmount = maxDeposit;\n        info.maxCollateralAmount = maxCollateral;\n        info.collateralWeight = collateralWeight;\n        info.debtWeight = debtWeight;\n        info.reserveFactor = reserveFactor;\n    }\n\n    function withdrawReserves(address token, uint256 amount) external nonReentrant allowedToken(token) onlyOwner {\n        accrueInterest(token);\n        AssetInfo storage info = assetInfo[token];\n        uint256 totalReserves = info.totalReserves;\n        uint256 withdrawnReserves = info.withdrawnReserves;\n        require(amount <= totalReserves - withdrawnReserves, Errors.WITHDRAW_AMOUNT_EXCEED);\n        info.withdrawnReserves = info.withdrawnReserves + amount;\n        IERC20(token).safeTransfer(_MAINTAINER_, amount);\n    }\n\n    // ---------- View ----------\n\n    function getAssetInfo(address token)\n        external\n        view\n        returns (\n            address dToken,\n            uint256 totalBorrows,\n            uint256 totalReserves,\n            uint256 reserveFactor,\n            uint256 borrowIndex,\n            uint256 accrualTime,\n            uint256 maxDepositAmount,\n            uint256 collateralWeight,\n            uint256 debtWeight,\n            uint256 withdrawnReserves,\n            uint256 balance\n        )\n    {\n        AssetInfo storage info = assetInfo[token];\n        balance = info.balance;\n        dToken = info.dToken;\n        totalBorrows = info.totalBorrows;\n        totalReserves = info.totalReserves;\n        reserveFactor = info.reserveFactor;\n        borrowIndex = info.borrowIndex;\n        accrualTime = info.accrualTime;\n        maxDepositAmount = info.maxDepositAmount;\n        collateralWeight = info.collateralWeight;\n        debtWeight = info.debtWeight;\n        withdrawnReserves = info.withdrawnReserves;\n    }\n\n    function getIMMM() external view returns (uint256, uint256) {\n        return (IM, MM);\n    }\n\n    function getTokenList() external view returns (address[] memory) {\n        return tokenList;\n    }\n}"
    }
  ]
}