{
  "Title": "[04] `TwTAP` position not burnt on exit",
  "Content": "\nWhen exiting a position in `TapiocaOptionBroker`, the users `oTAP` position [is burned](https://github.com/Tapioca-DAO/tap-token/blob/20a83b1d2d5577653610a6c3879dff9df4968345/contracts/options/TapiocaOptionBroker.sol#L353).\n\nThis is not done when exiting a `TwTAP` position, however. This will leave a worthless NFT in the users account.\n\n### Recommendation\n\nConsider burning the `TwTAP` position when exiting.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-02-tapioca",
  "Code": [
    {
      "filename": "contracts/options/TapiocaOptionBroker.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {TapiocaOptionLiquidityProvision, LockPosition, SingularityPool} from \"./TapiocaOptionLiquidityProvision.sol\";\nimport {IPearlmit, PearlmitHandler} from \"tapioca-periph/pearlmit/PearlmitHandler.sol\";\nimport {ITapiocaOracle} from \"tapioca-periph/interfaces/periph/ITapiocaOracle.sol\";\nimport {TapToken} from \"tap-token/tokens/TapToken.sol\";\nimport {OTAP, TapOption} from \"./oTAP.sol\";\nimport {TWAML} from \"./twAML.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\nstruct Participation {\n    bool hasVotingPower;\n    bool divergenceForce; // 0 negative, 1 positive\n    uint256 averageMagnitude;\n}\n\nstruct TWAMLPool {\n    uint256 totalParticipants;\n    uint256 averageMagnitude;\n    uint256 totalDeposited;\n    uint256 cumulative;\n}\n\nstruct PaymentTokenOracle {\n    ITapiocaOracle oracle;\n    bytes oracleData;\n}\n\ncontract TapiocaOptionBroker is Pausable, Ownable, PearlmitHandler, IERC721Receiver, TWAML, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    TapiocaOptionLiquidityProvision public immutable tOLP;\n    bytes public tapOracleData;\n    TapToken public immutable tapOFT;\n    OTAP public immutable oTAP;\n    ITapiocaOracle public tapOracle;\n\n    uint256 public epochTAPValuation; // TAP price for the current epoch\n    uint256 public epoch; // Represents the number of weeks since the start of the contract\n\n    mapping(uint256 => Participation) public participants; // tOLPTokenID => Participation\n    mapping(uint256 => mapping(uint256 => uint256)) public oTAPCalls; // oTAPTokenID => epoch => amountExercised\n\n    mapping(uint256 => mapping(uint256 => uint256)) public singularityGauges; // epoch => sglAssetId => availableTAP\n\n    mapping(ERC20 => PaymentTokenOracle) public paymentTokens; // Token address => PaymentTokenOracle\n    address public paymentTokenBeneficiary; // Where to collect the payment tokens\n\n    /// ===== TWAML ======\n    mapping(uint256 => TWAMLPool) public twAML; // sglAssetId => twAMLPool\n\n    /// @dev Virtual total amount to add to the total when computing twAML participation right. Default 10_000 * 1e18.\n    uint256 private VIRTUAL_TOTAL_AMOUNT = 10_000 ether;\n\n    uint256 public MIN_WEIGHT_FACTOR = 1000; // In BPS, default 10%\n    uint256 constant dMAX = 500_000; // 50 * 1e4; 0% - 50% discount\n    uint256 constant dMIN = 0;\n    uint256 public immutable EPOCH_DURATION; // 7 days = 604800\n\n    /// @notice starts time for emissions\n    /// @dev initialized in the constructor with block.timestamp\n    uint256 public immutable emissionsStartTime;\n\n    /// @notice Total amount of participation per epoch\n    mapping(uint256 epoch => mapping(uint256 sglAssetID => int256 netAmount)) public netDepositedForEpoch;\n    /// =====-------======\n\n    error NotEqualDurations();\n    error NotAuthorized();\n    error NoActiveSingularities();\n    error NoLiquidity();\n    error OptionExpired();\n    error PaymentTokenNotSupported();\n    error OneEpochCooldown();\n    error TooHigh();\n    error TooLong();\n    error TooLow();\n    error DurationTooShort();\n    error PositionNotValid();\n    error LockNotExpired();\n    error TooSoon();\n    error Failed();\n    error TransferFailed();\n    error SingularityInRescueMode();\n    error PaymentTokenValuationNotValid();\n    error LockExpired();\n    error AdvanceEpochFirst();\n\n    constructor(\n        address _tOLP,\n        address _oTAP,\n        address payable _tapOFT,\n        address _paymentTokenBeneficiary,\n        uint256 _epochDuration,\n        IPearlmit _pearlmit,\n        address _owner\n    ) PearlmitHandler(_pearlmit) {\n        paymentTokenBeneficiary = _paymentTokenBeneficiary;\n        tOLP = TapiocaOptionLiquidityProvision(_tOLP);\n\n        if (_epochDuration != TapiocaOptionLiquidityProvision(_tOLP).EPOCH_DURATION()) revert NotEqualDurations();\n\n        tapOFT = TapToken(_tapOFT);\n        oTAP = OTAP(_oTAP);\n        EPOCH_DURATION = _epochDuration;\n        emissionsStartTime = block.timestamp;\n\n        _transferOwnership(_owner);\n    }\n\n    // ==========\n    //   EVENTS\n    // ==========\n    event Participate(\n        uint256 indexed epoch, uint256 indexed sglAssetID, uint256 totalDeposited, uint256 tokenId, uint256 discount\n    );\n    event AMLDivergence(uint256 indexed epoch, uint256 cumulative, uint256 averageMagnitude, uint256 totalParticipants);\n    event ExerciseOption(\n        uint256 indexed epoch, address indexed to, ERC20 indexed paymentToken, uint256 oTapTokenID, uint256 amount\n    );\n    event NewEpoch(uint256 indexed epoch, uint256 extractedTAP, uint256 epochTAPValuation);\n    event ExitPosition(uint256 indexed epoch, uint256 tolpTokenId, uint256 amount);\n    event SetPaymentToken(ERC20 indexed paymentToken, ITapiocaOracle oracle, bytes oracleData);\n    event SetTapOracle(ITapiocaOracle indexed oracle, bytes indexed oracleData);\n\n    // ==========\n    //    READ\n    // ==========\n    /// @notice Returns the current week given a timestamp\n    function timestampToWeek(uint256 timestamp) external view returns (uint256) {\n        if (timestamp == 0) {\n            timestamp = block.timestamp;\n        }\n        if (timestamp < emissionsStartTime) return 0;\n\n        return _timestampToWeek(timestamp);\n    }\n\n    /// @notice Returns the current week\n    function getCurrentWeek() external view returns (uint256) {\n        return _timestampToWeek(block.timestamp);\n    }\n\n    /// @notice Returns the details of an OTC deal for a given oTAP token ID and a payment token.\n    ///         The oracle uses the last peeked value, and not the latest one, so the payment amount may be different.\n    /// @param _oTAPTokenID The oTAP token ID\n    /// @param _paymentToken The payment token\n    /// @param _tapAmount The amount of TAP to be exchanged. If 0 it will use the full amount of TAP eligible for the deal\n    /// @return eligibleTapAmount The amount of TAP eligible for the deal\n    /// @return paymentTokenAmount The amount of payment tokens required for the deal\n    /// @return tapAmount The amount of TAP to be exchanged\n    function getOTCDealDetails(uint256 _oTAPTokenID, ERC20 _paymentToken, uint256 _tapAmount)\n        external\n        view\n        returns (uint256 eligibleTapAmount, uint256 paymentTokenAmount, uint256 tapAmount)\n    {\n        // Load data\n        (, TapOption memory oTAPPosition) = oTAP.attributes(_oTAPTokenID);\n        LockPosition memory tOLPLockPosition = tOLP.getLock(oTAPPosition.tOLP);\n\n        {\n            if (!_isPositionActive(tOLPLockPosition)) revert OptionExpired();\n        }\n\n        uint256 cachedEpoch = epoch;\n\n        PaymentTokenOracle memory paymentTokenOracle = paymentTokens[_paymentToken];\n\n        // Check requirements\n        if (paymentTokenOracle.oracle == ITapiocaOracle(address(0))) {\n            revert PaymentTokenNotSupported();\n        }\n        if (block.timestamp < tOLPLockPosition.lockTime + EPOCH_DURATION) {\n            revert OneEpochCooldown();\n        } // Can only exercise after 1 epoch duration\n\n        // Get eligible OTC amount\n        {\n            uint256 gaugeTotalForEpoch = singularityGauges[cachedEpoch][tOLPLockPosition.sglAssetID];\n            uint256 netAmount = uint256(netDepositedForEpoch[cachedEpoch][tOLPLockPosition.sglAssetID]);\n            if (netAmount == 0) revert NoLiquidity();\n\n            eligibleTapAmount = muldiv(tOLPLockPosition.ybShares, gaugeTotalForEpoch, netAmount);\n            eligibleTapAmount -= oTAPCalls[_oTAPTokenID][cachedEpoch]; // Subtract already exercised amount\n            if (eligibleTapAmount < _tapAmount) revert TooHigh();\n        }\n\n        tapAmount = _tapAmount == 0 ? eligibleTapAmount : _tapAmount;\n        if (tapAmount < 1e18) revert TooLow();\n        // Get TAP valuation\n        uint256 otcAmountInUSD = tapAmount * epochTAPValuation; // Divided by TAP decimals\n        // Get payment token valuation\n        (, uint256 paymentTokenValuation) = paymentTokenOracle.oracle.peek(paymentTokenOracle.oracleData);\n        // Get payment token amount\n        paymentTokenAmount = _getDiscountedPaymentAmount(\n            otcAmountInUSD, paymentTokenValuation, oTAPPosition.discount, _paymentToken.decimals()\n        );\n    }\n\n    // ===========\n    //    WRITE\n    // ===========\n\n    /// @notice Participate in twAMl voting and mint an oTAP position.\n    ///         Exercising the option is not possible on participation week.\n    /// @param _tOLPTokenID The tokenId of the tOLP position\n    function participate(uint256 _tOLPTokenID) external whenNotPaused nonReentrant returns (uint256 oTAPTokenID) {\n        // Compute option parameters\n        LockPosition memory lock = tOLP.getLock(_tOLPTokenID);\n        uint128 lockExpiry = lock.lockTime + lock.lockDuration;\n\n        if (block.timestamp >= lockExpiry) revert LockExpired();\n        if (_timestampToWeek(block.timestamp) > epoch) revert AdvanceEpochFirst();\n\n        bool isPositionActive = _isPositionActive(lock);\n        if (!isPositionActive) revert OptionExpired();\n\n        if (lock.lockDuration < EPOCH_DURATION) revert DurationTooShort();\n\n        TWAMLPool memory pool = twAML[lock.sglAssetID];\n        if (pool.cumulative == 0) {\n            pool.cumulative = EPOCH_DURATION;\n        }\n\n        if (!tOLP.isApprovedOrOwner(msg.sender, _tOLPTokenID)) {\n            revert NotAuthorized();\n        }\n\n        // Transfer tOLP position to this contract\n        // tOLP.transferFrom(msg.sender, address(this), _tOLPTokenID);\n        {\n            bool isErr = pearlmit.transferFromERC721(msg.sender, address(this), address(tOLP), _tOLPTokenID);\n            if (isErr) revert TransferFailed();\n        }\n\n        uint256 magnitude = computeMagnitude(uint256(lock.lockDuration), pool.cumulative);\n        uint256 target = computeTarget(dMIN, dMAX, magnitude, pool.cumulative);\n\n        // Revert if the lock 4x the cumulative\n        if (magnitude > pool.cumulative * 4) revert TooLong();\n\n        bool divergenceForce;\n        // Participate in twAMl voting\n        bool hasVotingPower =\n            lock.ybShares >= computeMinWeight(pool.totalDeposited + VIRTUAL_TOTAL_AMOUNT, MIN_WEIGHT_FACTOR);\n        if (hasVotingPower) {\n            pool.totalParticipants++; // Save participation\n            pool.averageMagnitude = (pool.averageMagnitude + magnitude) / pool.totalParticipants; // compute new average magnitude\n\n            // Compute and save new cumulative\n            divergenceForce = lock.lockDuration >= pool.cumulative;\n            if (divergenceForce) {\n                pool.cumulative += pool.averageMagnitude;\n            } else {\n                if (pool.cumulative > pool.averageMagnitude) {\n                    pool.cumulative -= pool.averageMagnitude;\n                } else {\n                    pool.cumulative = 0;\n                }\n            }\n\n            // Save new weight\n            pool.totalDeposited += lock.ybShares;\n\n            twAML[lock.sglAssetID] = pool; // Save twAML participation\n            emit AMLDivergence(epoch, pool.cumulative, pool.averageMagnitude, pool.totalParticipants); // Register new voting power event\n        }\n        // Save twAML participation\n        participants[_tOLPTokenID] = Participation(hasVotingPower, divergenceForce, pool.averageMagnitude);\n\n        // Record amount for next epoch exercise\n        netDepositedForEpoch[epoch + 1][lock.sglAssetID] += int256(uint256(lock.ybShares));\n\n        uint256 lastEpoch = _timestampToWeek(lockExpiry);\n        // And remove it from last epoch\n        // Math is safe, check `_emitToGauges()`\n        netDepositedForEpoch[lastEpoch + 1][lock.sglAssetID] -= int256(uint256(lock.ybShares));\n\n        // Mint oTAP position\n        oTAPTokenID = oTAP.mint(msg.sender, lockExpiry, uint128(target), _tOLPTokenID);\n        emit Participate(epoch, lock.sglAssetID, pool.totalDeposited, oTAPTokenID, target);\n    }\n\n    /// @notice Exit a twAML participation and delete the voting power if existing\n    /// @param _oTAPTokenID The tokenId of the oTAP position\n    function exitPosition(uint256 _oTAPTokenID) external whenNotPaused {\n        if (!oTAP.exists(_oTAPTokenID)) revert PositionNotValid();\n\n        // Load data\n        (, TapOption memory oTAPPosition) = oTAP.attributes(_oTAPTokenID);\n        LockPosition memory lock = tOLP.getLock(oTAPPosition.tOLP);\n\n        bool isSGLInRescueMode = _isSGLInRescueMode(lock);\n\n        // If SGL is in rescue, bypass the lock expiration\n        if (!isSGLInRescueMode) {\n            if (block.timestamp < lock.lockTime + lock.lockDuration) {\n                revert LockNotExpired();\n            }\n        }\n\n        Participation memory participation = participants[oTAPPosition.tOLP];\n\n        // Remove participation\n        // If the SGL is in rescue mode, bypass the voting power removal\n        if (!isSGLInRescueMode && participation.hasVotingPower) {\n            TWAMLPool memory pool = twAML[lock.sglAssetID];\n\n            if (participation.divergenceForce) {\n                if (pool.cumulative > participation.averageMagnitude) {\n                    pool.cumulative -= participation.averageMagnitude;\n                } else {\n                    pool.cumulative = 0;\n                }\n            } else {\n                pool.cumulative += participation.averageMagnitude;\n            }\n\n            pool.totalDeposited -= lock.ybShares;\n\n            unchecked {\n                --pool.totalParticipants;\n            }\n\n            twAML[lock.sglAssetID] = pool; // Save twAML exit\n            emit AMLDivergence(epoch, pool.cumulative, pool.averageMagnitude, pool.totalParticipants); // Register new voting power event\n        }\n\n        // Delete participation and burn oTAP position\n        address otapOwner = oTAP.ownerOf(_oTAPTokenID);\n        delete participants[oTAPPosition.tOLP];\n        oTAP.burn(_oTAPTokenID);\n\n        // Transfer position back to oTAP owner\n        tOLP.transferFrom(address(this), otapOwner, oTAPPosition.tOLP);\n\n        emit ExitPosition(epoch, oTAPPosition.tOLP, lock.ybShares);\n    }\n\n    /// @notice Exercise an oTAP position\n    /// @param _oTAPTokenID tokenId of the oTAP position, position must be active\n    /// @param _paymentToken Address of the payment token to use, must be whitelisted\n    /// @param _tapAmount Amount of TAP to exercise. If 0, the full amount is exercised\n    function exerciseOption(uint256 _oTAPTokenID, ERC20 _paymentToken, uint256 _tapAmount) external whenNotPaused {\n        // Load data\n        (, TapOption memory oTAPPosition) = oTAP.attributes(_oTAPTokenID);\n        LockPosition memory tOLPLockPosition = tOLP.getLock(oTAPPosition.tOLP);\n        bool isPositionActive = _isPositionActive(tOLPLockPosition);\n        if (!isPositionActive) revert OptionExpired();\n\n        uint256 cachedEpoch = epoch;\n\n        PaymentTokenOracle memory paymentTokenOracle = paymentTokens[_paymentToken];\n\n        // Check requirements\n        if (paymentTokenOracle.oracle == ITapiocaOracle(address(0))) {\n            revert PaymentTokenNotSupported();\n        }\n        if (!oTAP.isApprovedOrOwner(msg.sender, _oTAPTokenID)) {\n            revert NotAuthorized();\n        }\n        if (block.timestamp < oTAPPosition.entry + EPOCH_DURATION) {\n            revert OneEpochCooldown();\n        } // Can only exercise after 1 epoch duration\n\n        // Get eligible OTC amount\n        uint256 gaugeTotalForEpoch = singularityGauges[cachedEpoch][tOLPLockPosition.sglAssetID];\n        uint256 netAmount = uint256(netDepositedForEpoch[cachedEpoch][tOLPLockPosition.sglAssetID]);\n        if (netAmount == 0) revert NoLiquidity();\n        uint256 eligibleTapAmount = muldiv(tOLPLockPosition.ybShares, gaugeTotalForEpoch, netAmount);\n        eligibleTapAmount -= oTAPCalls[_oTAPTokenID][cachedEpoch]; // Subtract already exercised amount\n        if (eligibleTapAmount < _tapAmount) revert TooHigh();\n\n        uint256 chosenAmount = _tapAmount == 0 ? eligibleTapAmount : _tapAmount;\n        if (chosenAmount < 1e18) revert TooLow();\n        oTAPCalls[_oTAPTokenID][cachedEpoch] += chosenAmount; // Adds up exercised amount to current epoch\n\n        // Finalize the deal\n        _processOTCDeal(_paymentToken, paymentTokenOracle, chosenAmount, oTAPPosition.discount);\n\n        emit ExerciseOption(cachedEpoch, msg.sender, _paymentToken, _oTAPTokenID, chosenAmount);\n    }\n\n    // TODO Check at how many SGls this function breaks. Do we need to split calls into 2+ Txs?\n    /// @notice Start a new epoch, extract TAP from the TapOFT contract,\n    ///         emit it to the active singularities and get the price of TAP for the epoch.\n    function newEpoch() external {\n        if (_timestampToWeek(block.timestamp) <= epoch) revert TooSoon();\n\n        uint256[] memory singularities = tOLP.getSingularities();\n        if (singularities.length == 0) revert NoActiveSingularities();\n\n        epoch++;\n\n        // Extract TAP + emit to gauges\n        uint256 epochTAP = tapOFT.emitForWeek();\n        _emitToGauges(epochTAP);\n\n        // Get epoch TAP valuation\n        bool success;\n        (success, epochTAPValuation) = tapOracle.get(tapOracleData);\n        if (!success) revert Failed();\n        emit NewEpoch(epoch, epochTAP, epochTAPValuation);\n    }\n\n    /// @notice Claim the Broker role of the oTAP contract\n    function oTAPBrokerClaim() external {\n        oTAP.brokerClaim();\n    }\n\n    // =========\n    //   OWNER\n    // =========\n\n    /**\n     * @notice Set the `VIRTUAL_TOTAL_AMOUNT` state variable.\n     * @param _virtualTotalAmount The new state variable value.\n     */\n    function setVirtualTotalAmount(uint256 _virtualTotalAmount) external onlyOwner {\n        VIRTUAL_TOTAL_AMOUNT = _virtualTotalAmount;\n    }\n\n    /**\n     * @notice Set the minimum weight factor.\n     * @param _minWeightFactor The new minimum weight factor.\n     */\n    function setMinWeightFactor(uint256 _minWeightFactor) external onlyOwner {\n        MIN_WEIGHT_FACTOR = _minWeightFactor;\n    }\n\n    /// @notice Set the TapOFT Oracle address and data\n    /// @param _tapOracle The new TapOFT Oracle address\n    /// @param _tapOracleData The new TapOFT Oracle data\n    function setTapOracle(ITapiocaOracle _tapOracle, bytes calldata _tapOracleData) external onlyOwner {\n        tapOracle = _tapOracle;\n        tapOracleData = _tapOracleData;\n\n        emit SetTapOracle(_tapOracle, _tapOracleData);\n    }\n\n    /// @notice Activate or deactivate a payment token\n    /// @dev set the oracle to address(0) to deactivate, expect the same decimal precision as TAP oracle\n    function setPaymentToken(ERC20 _paymentToken, ITapiocaOracle _oracle, bytes calldata _oracleData)\n        external\n        onlyOwner\n    {\n        paymentTokens[_paymentToken].oracle = _oracle;\n        paymentTokens[_paymentToken].oracleData = _oracleData;\n\n        emit SetPaymentToken(_paymentToken, _oracle, _oracleData);\n    }\n\n    /// @notice Set the payment token beneficiary\n    /// @param _paymentTokenBeneficiary The new payment token beneficiary\n    function setPaymentTokenBeneficiary(address _paymentTokenBeneficiary) external onlyOwner {\n        paymentTokenBeneficiary = _paymentTokenBeneficiary;\n    }\n\n    /// @notice Collect the payment tokens from the OTC deals\n    /// @param _paymentTokens The payment tokens to collect\n    function collectPaymentTokens(address[] calldata _paymentTokens) external onlyOwner nonReentrant {\n        address _paymentTokenBeneficiary = paymentTokenBeneficiary;\n        if (_paymentTokenBeneficiary == address(0)) {\n            revert PaymentTokenNotSupported();\n        }\n        uint256 len = _paymentTokens.length;\n\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                IERC20 paymentToken = IERC20(_paymentTokens[i]);\n                paymentToken.safeTransfer(_paymentTokenBeneficiary, paymentToken.balanceOf(address(this)));\n            }\n        }\n    }\n\n    /**\n     * @notice Un/Pauses this contract.\n     */\n    function setPause(bool _pauseState) external onlyOwner {\n        if (_pauseState) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    // ============\n    //   INTERNAL\n    // ============\n    /// @notice returns week for timestamp\n    function _timestampToWeek(uint256 timestamp) internal view returns (uint256) {\n        return ((timestamp - emissionsStartTime) / EPOCH_DURATION);\n    }\n\n    /// @notice Check if a singularity is in rescue mode\n    /// @param _lock The lock position\n    function _isSGLInRescueMode(LockPosition memory _lock) internal view returns (bool) {\n        (,,, bool rescue) = tOLP.activeSingularities(tOLP.sglAssetIDToAddress(_lock.sglAssetID));\n        return rescue;\n    }\n\n    /// @notice Check if a position is active, whether it is expired or SGL is in rescue mode\n    /// @dev Check if the current week is less than or equal the expiry week\n    /// @param _lock The lock position\n    /// @return isPositionActive True if the position is active\n    function _isPositionActive(LockPosition memory _lock) internal view returns (bool isPositionActive) {\n        if (_lock.lockTime == 0) revert PositionNotValid();\n        if (_isSGLInRescueMode(_lock)) revert SingularityInRescueMode();\n\n        uint256 expiryWeek = _timestampToWeek(_lock.lockTime + _lock.lockDuration);\n\n        isPositionActive = epoch <= expiryWeek;\n    }\n\n    /// @notice Process the OTC deal, transfer the payment token to the broker and the TAP amount to the user\n    /// @param _paymentToken The payment token\n    /// @param _paymentTokenOracle The oracle of the payment token\n    /// @param tapAmount The amount of TAP that the user has to receive\n    /// @param discount The discount that the user has to apply to the OTC deal\n    function _processOTCDeal(\n        ERC20 _paymentToken,\n        PaymentTokenOracle memory _paymentTokenOracle,\n        uint256 tapAmount,\n        uint256 discount\n    ) internal {\n        // Get TAP valuation\n        uint256 otcAmountInUSD = tapAmount * epochTAPValuation;\n\n        // Get payment token valuation\n        (bool success, uint256 paymentTokenValuation) = _paymentTokenOracle.oracle.get(_paymentTokenOracle.oracleData);\n        if (!success) revert Failed();\n\n        // Calculate payment amount and initiate the transfers\n        uint256 discountedPaymentAmount =\n            _getDiscountedPaymentAmount(otcAmountInUSD, paymentTokenValuation, discount, _paymentToken.decimals());\n\n        uint256 balBefore = _paymentToken.balanceOf(address(this));\n        // IERC20(address(_paymentToken)).safeTransferFrom(msg.sender, address(this), discountedPaymentAmount);\n        {\n            bool isErr =\n                pearlmit.transferFromERC20(msg.sender, address(this), address(_paymentToken), discountedPaymentAmount);\n            if (isErr) revert TransferFailed();\n        }\n        uint256 balAfter = _paymentToken.balanceOf(address(this));\n        if (balAfter - balBefore != discountedPaymentAmount) {\n            revert TransferFailed();\n        }\n\n        tapOFT.extractTAP(msg.sender, tapAmount);\n    }\n\n    /// @notice Computes the discounted payment amount for a given OTC amount in USD\n    /// @param _otcAmountInUSD The OTC amount in USD, 18 decimals\n    /// @param _paymentTokenValuation The payment token valuation in USD, 18 decimals\n    /// @param _discount The discount in BPS\n    /// @param _paymentTokenDecimals The payment token decimals\n    /// @return paymentAmount The discounted payment amount\n    function _getDiscountedPaymentAmount(\n        uint256 _otcAmountInUSD,\n        uint256 _paymentTokenValuation,\n        uint256 _discount,\n        uint256 _paymentTokenDecimals\n    ) internal pure returns (uint256 paymentAmount) {\n        if (_paymentTokenValuation == 0) revert PaymentTokenValuationNotValid();\n\n        uint256 discountedOTCAmountInUSD = _otcAmountInUSD - muldiv(_otcAmountInUSD, _discount, 100e4); // 1e4 is discount decimals, 100 is discount percentage\n\n        // Calculate payment amount\n        paymentAmount = discountedOTCAmountInUSD / _paymentTokenValuation;\n\n        if (_paymentTokenDecimals <= 18) {\n            paymentAmount = paymentAmount / (10 ** (18 - _paymentTokenDecimals));\n        } else {\n            paymentAmount = paymentAmount * (10 ** (_paymentTokenDecimals - 18));\n        }\n    }\n\n    /// @notice Emit TAP to the gauges equitably and update the net deposited amounts for each pool\n    /// @dev Assume the epoch has been updated\n    function _emitToGauges(uint256 _epochTAP) internal {\n        SingularityPool[] memory sglPools = tOLP.getSingularityPools();\n        uint256 totalWeights = tOLP.totalSingularityPoolWeights();\n\n        uint256 len = sglPools.length;\n        unchecked {\n            // For each pool\n            for (uint256 i; i < len; ++i) {\n                uint256 currentPoolWeight = sglPools[i].poolWeight;\n                uint256 quotaPerSingularity = muldiv(currentPoolWeight, _epochTAP, totalWeights);\n                uint256 sglAssetID = sglPools[i].sglAssetID;\n                // Emit weekly TAP to the pool\n                singularityGauges[epoch][sglAssetID] = quotaPerSingularity;\n\n                // Update net deposited amounts\n                mapping(uint256 sglAssetID => int256 netAmount) storage prev = netDepositedForEpoch[epoch - 1];\n                mapping(uint256 sglAssetID => int256 netAmount) storage curr = netDepositedForEpoch[epoch];\n\n                // Pass previous epoch net amount to the next epoch\n                // Expired positions are offset, check `participate()`\n                curr[sglAssetID] += prev[sglAssetID];\n            }\n        }\n    }\n\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data)\n        external\n        returns (bytes4)\n    {\n        return this.onERC721Received.selector;\n    }\n}"
    }
  ]
}