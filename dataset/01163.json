{
  "Title": "Unpinned Compiler Version",
  "Content": "Valid compiler versions are set via the `pragma solidity` tag at the top of Solidity files. Most of the codebase provides [`pragma solidity ^0.8.0`](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/rollup/ScrollChain.sol#L3) as the compiler pragma. This pragma requires the compiler used to be at least 0.8.0 and lower than 0.9.0.\n\n\nSince the compiler is not pinned to a specific version, it is possible that tests will target a different version than the one deployed, rendering the test suite inadequate. It also allows new, unreleased compilers to be valid. Although unlikely, new compilers may not support all the code written for current compilers.\n\n\nCompiler bugs are most commonly found within one to two versions of their introduction. This means the safest, most up-to-date compiler version is a few versions behind the latest unless the code is affected by a bug that was recently fixed. For example, Solidity version 0.8.13 was found to suffer from [a bug](https://blog.soliditylang.org/2022/06/15/inline-assembly-memory-side-effects-bug/) where under certain conditions some assembly instructions are ignored by the compiler. While the codebase in its current state does not seem to be affected by this specific bug, pinning the version reduces the odds of such vulnerabilities affecting it in the future.\n\n\nMoreover, the [`RollupVerifier` library](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/libraries/verifier/RollupVerifier.sol#L2) makes use of a different pragma (`>=0.4.16 <0.9.0`), which is inconsistent with the one used in the rest of the codebase.\n\n\nTo ensure the released version matches the tested version, consider pining the Solidity compiler of the entire codebase to a specific version, preferably slightly behind the most up-to-date version (currently 0.8.20).\n\n\n***Update:** Resolved in [pull request #636](https://github.com/scroll-tech/scroll/pull/636) at commit [6d88f92](https://github.com/scroll-tech/scroll/pull/636/commits/6d88f92931dd55cc6b9230f0f433f5686b6fce85). The Scroll team stated:*\n\n\n\n> *The version of all deployable contracts is pinned with `=0.8.16`. For interfaces, libraries, and abstract contracts, `^0.8.16` is used.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/L1/rollup/ScrollChain.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport {IL1MessageQueue} from \"./IL1MessageQueue.sol\";\nimport {IScrollChain} from \"./IScrollChain.sol\";\nimport {BatchHeaderV0Codec} from \"../../libraries/codec/BatchHeaderV0Codec.sol\";\nimport {ChunkCodec} from \"../../libraries/codec/ChunkCodec.sol\";\nimport {IRollupVerifier} from \"../../libraries/verifier/IRollupVerifier.sol\";\n\n// solhint-disable reason-string\n\n/// @title ScrollChain\n/// @notice This contract maintains data for the Scroll rollup.\ncontract ScrollChain is OwnableUpgradeable, IScrollChain {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when owner updates the status of sequencer.\n    /// @param account The address of account updated.\n    /// @param status The status of the account updated.\n    event UpdateSequencer(address indexed account, bool status);\n\n    /// @notice Emitted when the address of rollup verifier is updated.\n    /// @param oldVerifier The address of old rollup verifier.\n    /// @param newVerifier The address of new rollup verifier.\n    event UpdateVerifier(address oldVerifier, address newVerifier);\n\n    /// @notice Emitted when the value of `maxNumL2TxInChunk` is updated.\n    /// @param oldMaxNumL2TxInChunk The old value of `maxNumL2TxInChunk`.\n    /// @param newMaxNumL2TxInChunk The new value of `maxNumL2TxInChunk`.\n    event UpdateMaxNumL2TxInChunk(uint256 oldMaxNumL2TxInChunk, uint256 newMaxNumL2TxInChunk);\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The chain id of the corresponding layer 2 chain.\n    uint256 public immutable layer2ChainId;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The maximum number of transactions allowed in each chunk.\n    uint256 public maxNumL2TxInChunk;\n\n    /// @notice The address of L1MessageQueue.\n    address public messageQueue;\n\n    /// @notice The address of RollupVerifier.\n    address public verifier;\n\n    /// @notice Whether an account is a sequencer.\n    mapping(address => bool) public isSequencer;\n\n    /// @notice The latest finalized batch index.\n    uint256 public lastFinalizedBatchIndex;\n\n    /// @inheritdoc IScrollChain\n    mapping(uint256 => bytes32) public override committedBatches;\n\n    /// @inheritdoc IScrollChain\n    mapping(uint256 => bytes32) public override finalizedStateRoots;\n\n    /// @inheritdoc IScrollChain\n    mapping(uint256 => bytes32) public override withdrawRoots;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier OnlySequencer() {\n        // @note In the decentralized mode, it should be only called by a list of validator.\n        require(isSequencer[msg.sender], \"caller not sequencer\");\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(uint256 _chainId) {\n        layer2ChainId = _chainId;\n    }\n\n    function initialize(\n        address _messageQueue,\n        address _verifier,\n        uint256 _maxNumL2TxInChunk\n    ) public initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        messageQueue = _messageQueue;\n        verifier = _verifier;\n        maxNumL2TxInChunk = _maxNumL2TxInChunk;\n\n        emit UpdateVerifier(address(0), _verifier);\n        emit UpdateMaxNumL2TxInChunk(0, _maxNumL2TxInChunk);\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IScrollChain\n    function isBatchFinalized(uint256 _batchIndex) external view override returns (bool) {\n        return _batchIndex <= lastFinalizedBatchIndex;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Import layer 2 genesis block\n    /// @dev Although `_withdrawRoot` is always zero, we add this parameter for the convenience of unit testing.\n    function importGenesisBatch(\n        bytes calldata _batchHeader,\n        bytes32 _stateRoot,\n        bytes32 _withdrawRoot\n    ) external {\n        // check genesis batch header length\n        require(_stateRoot != bytes32(0), \"zero state root\");\n\n        // check whether the genesis batch is imported\n        require(finalizedStateRoots[0] == bytes32(0), \"Genesis batch imported\");\n\n        (uint256 memPtr, bytes32 _batchHash) = _loadBatchHeader(_batchHeader);\n\n        // check all fields except `dataHash` and `lastBlockHash` are zero\n        unchecked {\n            uint256 sum = BatchHeaderV0Codec.version(memPtr) +\n                BatchHeaderV0Codec.batchIndex(memPtr) +\n                BatchHeaderV0Codec.l1MessagePopped(memPtr) +\n                BatchHeaderV0Codec.totalL1MessagePopped(memPtr);\n            require(sum == 0, \"not all fields are zero\");\n        }\n        require(BatchHeaderV0Codec.dataHash(memPtr) != bytes32(0), \"zero data hash\");\n        require(BatchHeaderV0Codec.parentBatchHash(memPtr) == bytes32(0), \"nonzero parent batch hash\");\n\n        committedBatches[0] = _batchHash;\n        finalizedStateRoots[0] = _stateRoot;\n        withdrawRoots[0] = _withdrawRoot;\n\n        emit CommitBatch(_batchHash);\n        emit FinalizeBatch(_batchHash, _stateRoot, _withdrawRoot);\n    }\n\n    /// @inheritdoc IScrollChain\n    function commitBatch(\n        uint8 _version,\n        bytes calldata _parentBatchHeader,\n        bytes[] memory _chunks,\n        bytes calldata _skippedL1MessageBitmap\n    ) external override OnlySequencer {\n        require(_version == 0, \"invalid version\");\n\n        // check whether the batch is empty\n        uint256 _chunksLength = _chunks.length;\n        require(_chunksLength > 0, \"batch is empty\");\n\n        // The overall memory layout in this function is organized as follows\n        // +---------------------+-------------------+------------------+\n        // | parent batch header | chunk data hashes | new batch header |\n        // +---------------------+-------------------+------------------+\n        // ^                     ^                   ^\n        // batchPtr              dataPtr             newBatchPtr (re-use var batchPtr)\n        //\n        // 1. We copy the parent batch header from calldata to memory starting at batchPtr\n        // 2. We store `_chunksLength` number of Keccak hashes starting at `dataPtr`. Each Keccak\n        //    hash corresponds to the data hash of a chunk. So we reserve the memory region from\n        //    `dataPtr` to `dataPtr + _chunkLength * 32` for the chunk data hashes.\n        // 3. The memory starting at `newBatchPtr` is used to store the new batch header and compute\n        //    the batch hash.\n\n        // the variable `batchPtr` will be reused later for the current batch\n        (uint256 batchPtr, bytes32 _parentBatchHash) = _loadBatchHeader(_parentBatchHeader);\n\n        uint256 _batchIndex = BatchHeaderV0Codec.batchIndex(batchPtr);\n        uint256 _totalL1MessagesPoppedOverall = BatchHeaderV0Codec.totalL1MessagePopped(batchPtr);\n        require(committedBatches[_batchIndex] == _parentBatchHash, \"incorrect parent batch hash\");\n        require(committedBatches[_batchIndex + 1] == 0, \"batch already committed\");\n\n        // load `dataPtr` and reserve the memory region for chunk data hashes\n        uint256 dataPtr;\n        assembly {\n            dataPtr := mload(0x40)\n            mstore(0x40, add(dataPtr, mul(_chunksLength, 32)))\n        }\n\n        // compute the data hash for each chunk\n        uint256 _totalL1MessagesPoppedInBatch;\n        for (uint256 i = 0; i < _chunksLength; i++) {\n            uint256 _totalNumL1MessagesInChunk = _commitChunk(\n                dataPtr,\n                _chunks[i],\n                _totalL1MessagesPoppedInBatch,\n                _totalL1MessagesPoppedOverall,\n                _skippedL1MessageBitmap\n            );\n\n            unchecked {\n                _totalL1MessagesPoppedInBatch += _totalNumL1MessagesInChunk;\n                _totalL1MessagesPoppedOverall += _totalNumL1MessagesInChunk;\n                dataPtr += 32;\n            }\n        }\n\n        // check the length of bitmap\n        unchecked {\n            require(\n                ((_totalL1MessagesPoppedInBatch + 255) / 256) * 32 == _skippedL1MessageBitmap.length,\n                \"wrong bitmap length\"\n            );\n        }\n\n        // compute the data hash for current batch\n        bytes32 _dataHash;\n        assembly {\n            let dataLen := mul(_chunksLength, 0x20)\n            _dataHash := keccak256(sub(dataPtr, dataLen), dataLen)\n\n            batchPtr := mload(0x40) // reset batchPtr\n            _batchIndex := add(_batchIndex, 1) // increase batch index\n        }\n\n        // store entries, the order matters\n        BatchHeaderV0Codec.storeVersion(batchPtr, _version);\n        BatchHeaderV0Codec.storeBatchIndex(batchPtr, _batchIndex);\n        BatchHeaderV0Codec.storeL1MessagePopped(batchPtr, _totalL1MessagesPoppedInBatch);\n        BatchHeaderV0Codec.storeTotalL1MessagePopped(batchPtr, _totalL1MessagesPoppedOverall);\n        BatchHeaderV0Codec.storeDataHash(batchPtr, _dataHash);\n        BatchHeaderV0Codec.storeParentBatchHash(batchPtr, _parentBatchHash);\n        BatchHeaderV0Codec.storeSkippedBitmap(batchPtr, _skippedL1MessageBitmap);\n\n        // compute batch hash\n        bytes32 _batchHash = BatchHeaderV0Codec.computeBatchHash(batchPtr, 89 + _skippedL1MessageBitmap.length);\n\n        committedBatches[_batchIndex] = _batchHash;\n        emit CommitBatch(_batchHash);\n    }\n\n    /// @inheritdoc IScrollChain\n    function revertBatch(bytes calldata _batchHeader, uint256 _count) external onlyOwner {\n        require(_count > 0, \"count must be nonzero\");\n\n        (uint256 memPtr, bytes32 _batchHash) = _loadBatchHeader(_batchHeader);\n\n        // check batch hash\n        uint256 _batchIndex = BatchHeaderV0Codec.batchIndex(memPtr);\n        require(committedBatches[_batchIndex] == _batchHash, \"incorrect batch hash\");\n\n        // check finalization\n        require(_batchIndex > lastFinalizedBatchIndex, \"can only revert unfinalized batch\");\n\n        while (_count > 0) {\n            committedBatches[_batchIndex] = bytes32(0);\n            unchecked {\n                _batchIndex += 1;\n                _count -= 1;\n            }\n\n            emit RevertBatch(_batchHash);\n\n            _batchHash = committedBatches[_batchIndex];\n            if (_batchHash == bytes32(0)) break;\n        }\n    }\n\n    /// @inheritdoc IScrollChain\n    function finalizeBatchWithProof(\n        bytes calldata _batchHeader,\n        bytes32 _prevStateRoot,\n        bytes32 _postStateRoot,\n        bytes32 _withdrawRoot,\n        bytes calldata _aggrProof\n    ) external override OnlySequencer {\n        require(_prevStateRoot != bytes32(0), \"previous state root is zero\");\n        require(_postStateRoot != bytes32(0), \"new state root is zero\");\n\n        // compute batch hash and verify\n        (uint256 memPtr, bytes32 _batchHash) = _loadBatchHeader(_batchHeader);\n\n        bytes32 _dataHash = BatchHeaderV0Codec.dataHash(memPtr);\n        uint256 _batchIndex = BatchHeaderV0Codec.batchIndex(memPtr);\n        require(committedBatches[_batchIndex] == _batchHash, \"incorrect batch hash\");\n\n        // verify previous state root.\n        require(finalizedStateRoots[_batchIndex - 1] == _prevStateRoot, \"incorrect previous state root\");\n\n        // avoid duplicated verification\n        require(finalizedStateRoots[_batchIndex] == bytes32(0), \"batch already verified\");\n\n        // compute public input hash\n        bytes32 _publicInputHash = keccak256(abi.encode(_prevStateRoot, _postStateRoot, _withdrawRoot, _dataHash));\n\n        // verify batch\n        IRollupVerifier(verifier).verifyAggregateProof(_aggrProof, _publicInputHash);\n\n        // check and update lastFinalizedBatchIndex\n        unchecked {\n            require(lastFinalizedBatchIndex + 1 == _batchIndex, \"incorrect batch index\");\n            lastFinalizedBatchIndex = _batchIndex;\n        }\n\n        // record state root and withdraw root\n        finalizedStateRoots[_batchIndex] = _postStateRoot;\n        withdrawRoots[_batchIndex] = _withdrawRoot;\n\n        // Pop finalized and non-skipped message from L1MessageQueue.\n        uint256 _l1MessagePopped = BatchHeaderV0Codec.l1MessagePopped(memPtr);\n        if (_l1MessagePopped > 0) {\n            IL1MessageQueue _queue = IL1MessageQueue(messageQueue);\n\n            unchecked {\n                uint256 _startIndex = BatchHeaderV0Codec.totalL1MessagePopped(memPtr) - _l1MessagePopped;\n\n                for (uint256 i = 0; i < _l1MessagePopped; i += 256) {\n                    uint256 _count = 256;\n                    if (_l1MessagePopped - i < _count) {\n                        _count = _l1MessagePopped - i;\n                    }\n                    uint256 _skippedBitmap = BatchHeaderV0Codec.skippedBitmap(memPtr, i / 256);\n\n                    _queue.popCrossDomainMessage(_startIndex, _count, _skippedBitmap);\n\n                    _startIndex += 256;\n                }\n            }\n        }\n\n        emit FinalizeBatch(_batchHash, _postStateRoot, _withdrawRoot);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update the status of sequencer.\n    /// @dev This function can only called by contract owner.\n    /// @param _account The address of account to update.\n    /// @param _status The status of the account to update.\n    function updateSequencer(address _account, bool _status) external onlyOwner {\n        isSequencer[_account] = _status;\n\n        emit UpdateSequencer(_account, _status);\n    }\n\n    /// @notice Update the address verifier contract.\n    /// @param _newVerifier The address of new verifier contract.\n    function updateVerifier(address _newVerifier) external onlyOwner {\n        address _oldVerifier = verifier;\n        verifier = _newVerifier;\n\n        emit UpdateVerifier(_oldVerifier, _newVerifier);\n    }\n\n    /// @notice Update the value of `maxNumL2TxInChunk`.\n    /// @param _maxNumL2TxInChunk The new value of `maxNumL2TxInChunk`.\n    function updateMaxNumL2TxInChunk(uint256 _maxNumL2TxInChunk) external onlyOwner {\n        uint256 _oldMaxNumL2TxInChunk = maxNumL2TxInChunk;\n        maxNumL2TxInChunk = _maxNumL2TxInChunk;\n\n        emit UpdateMaxNumL2TxInChunk(_oldMaxNumL2TxInChunk, _maxNumL2TxInChunk);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to load batch header from calldata to memory.\n    /// @param _batchHeader The batch header in calldata.\n    /// @return memPtr The start memory offset of loaded batch header.\n    /// @return _batchHash The hash of the loaded batch header.\n    function _loadBatchHeader(bytes calldata _batchHeader) internal pure returns (uint256 memPtr, bytes32 _batchHash) {\n        // load to memory\n        uint256 _length;\n        (memPtr, _length) = BatchHeaderV0Codec.loadAndValidate(_batchHeader);\n\n        // compute batch hash\n        _batchHash = BatchHeaderV0Codec.computeBatchHash(memPtr, _length);\n    }\n\n    /// @dev Internal function to commit a chunk.\n    /// @param memPtr The start memory offset to store list of `dataHash`.\n    /// @param _chunk The encoded chunk to commit.\n    /// @param _totalL1MessagesPoppedInBatch The total number of L1 messages popped in current batch.\n    /// @param _totalL1MessagesPoppedOverall The total number of L1 messages popped in all batches including current batch.\n    /// @param _skippedL1MessageBitmap The bitmap indicates whether each L1 message is skipped or not.\n    /// @return _totalNumL1MessagesInChunk The total number of L1 message popped in current chunk\n    function _commitChunk(\n        uint256 memPtr,\n        bytes memory _chunk,\n        uint256 _totalL1MessagesPoppedInBatch,\n        uint256 _totalL1MessagesPoppedOverall,\n        bytes calldata _skippedL1MessageBitmap\n    ) internal view returns (uint256 _totalNumL1MessagesInChunk) {\n        uint256 chunkPtr;\n        uint256 dataPtr;\n        uint256 blockPtr;\n\n        assembly {\n            dataPtr := mload(0x40)\n            chunkPtr := add(_chunk, 0x20) // skip chunkLength\n            blockPtr := add(chunkPtr, 1) // skip numBlocks\n        }\n\n        uint256 _numBlocks = ChunkCodec.validateChunkLength(chunkPtr, _chunk.length);\n\n        // concatenate block contexts\n        for (uint256 i = 0; i < _numBlocks; i++) {\n            dataPtr = ChunkCodec.copyBlockContext(chunkPtr, dataPtr, i);\n        }\n\n        // concatenate tx hashes\n        uint256 l2TxPtr = ChunkCodec.l2TxPtr(chunkPtr, _numBlocks);\n\n        // avoid stack too deep on forge coverage\n        uint256 _totalTransactionsInChunk;\n        while (_numBlocks > 0) {\n            // concatenate l1 message hashes\n            uint256 _numL1MessagesInBlock = ChunkCodec.numL1Messages(blockPtr);\n            dataPtr = _loadL1MessageHashes(\n                dataPtr,\n                _numL1MessagesInBlock,\n                _totalL1MessagesPoppedInBatch,\n                _totalL1MessagesPoppedOverall,\n                _skippedL1MessageBitmap\n            );\n\n            // concatenate l2 transaction hashes\n            uint256 _numTransactionsInBlock = ChunkCodec.numTransactions(blockPtr);\n            for (uint256 j = _numL1MessagesInBlock; j < _numTransactionsInBlock; j++) {\n                bytes32 txHash;\n                (txHash, l2TxPtr) = ChunkCodec.loadL2TxHash(l2TxPtr);\n                assembly {\n                    mstore(dataPtr, txHash)\n                    dataPtr := add(dataPtr, 0x20)\n                }\n            }\n\n            unchecked {\n                _totalTransactionsInChunk += _numTransactionsInBlock;\n                _totalNumL1MessagesInChunk += _numL1MessagesInBlock;\n                _totalL1MessagesPoppedInBatch += _numL1MessagesInBlock;\n                _totalL1MessagesPoppedOverall += _numL1MessagesInBlock;\n\n                _numBlocks -= 1;\n                blockPtr += ChunkCodec.BLOCK_CONTEXT_LENGTH;\n            }\n        }\n\n        // check the number of L2 transactions in the chunk\n        require(\n            _totalTransactionsInChunk - _totalNumL1MessagesInChunk <= maxNumL2TxInChunk,\n            \"too many L2 txs in one chunk\"\n        );\n\n        // check chunk has correct length\n        require(l2TxPtr - chunkPtr == _chunk.length, \"incomplete l2 transaction data\");\n\n        // compute data hash and store to memory\n        assembly {\n            let startPtr := mload(0x40)\n            let dataHash := keccak256(startPtr, sub(dataPtr, startPtr))\n\n            mstore(memPtr, dataHash)\n        }\n\n        return _totalNumL1MessagesInChunk;\n    }\n\n    /// @dev Internal function to load L1 message hashes from the message queue.\n    /// @param _ptr The memory offset to store the transaction hash.\n    /// @param _numL1Messages The number of L1 messages to load.\n    /// @param _totalL1MessagesPoppedInBatch The total number of L1 messages popped in current batch.\n    /// @param _totalL1MessagesPoppedOverall The total number of L1 messages popped in all batches including current batch.\n    /// @param _skippedL1MessageBitmap The bitmap indicates whether each L1 message is skipped or not.\n    /// @return uint256 The new memory offset after loading.\n    function _loadL1MessageHashes(\n        uint256 _ptr,\n        uint256 _numL1Messages,\n        uint256 _totalL1MessagesPoppedInBatch,\n        uint256 _totalL1MessagesPoppedOverall,\n        bytes calldata _skippedL1MessageBitmap\n    ) internal view returns (uint256) {\n        if (_numL1Messages == 0) return _ptr;\n        IL1MessageQueue _messageQueue = IL1MessageQueue(messageQueue);\n\n        unchecked {\n            uint256 _bitmap;\n            for (uint256 i = 0; i < _numL1Messages; i++) {\n                uint256 quo = _totalL1MessagesPoppedInBatch >> 8;\n                uint256 rem = _totalL1MessagesPoppedInBatch & 0xff;\n\n                // load bitmap every 256 bits\n                if (i == 0 || rem == 0) {\n                    assembly {\n                        _bitmap := calldataload(add(_skippedL1MessageBitmap.offset, mul(0x20, quo)))\n                    }\n                }\n                if (((_bitmap >> rem) & 1) == 0) {\n                    // message not skipped\n                    bytes32 _hash = _messageQueue.getCrossDomainMessage(_totalL1MessagesPoppedOverall);\n                    assembly {\n                        mstore(_ptr, _hash)\n                        _ptr := add(_ptr, 0x20)\n                    }\n                }\n\n                _totalL1MessagesPoppedInBatch += 1;\n                _totalL1MessagesPoppedOverall += 1;\n            }\n        }\n\n        return _ptr;\n    }\n}"
    },
    {
      "filename": "contracts/src/libraries/verifier/RollupVerifier.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.16 <0.9.0;\n\nlibrary RollupVerifier {\n    function pairing(G1Point[] memory p1, G2Point[] memory p2) internal view returns (bool) {\n        uint256 length = p1.length * 6;\n        uint256[] memory input = new uint256[](length);\n        uint256[1] memory result;\n        bool ret;\n\n        require(p1.length == p2.length);\n\n        for (uint256 i = 0; i < p1.length; i++) {\n            input[0 + i * 6] = p1[i].x;\n            input[1 + i * 6] = p1[i].y;\n            input[2 + i * 6] = p2[i].x[0];\n            input[3 + i * 6] = p2[i].x[1];\n            input[4 + i * 6] = p2[i].y[0];\n            input[5 + i * 6] = p2[i].y[1];\n        }\n\n        assembly {\n            ret := staticcall(gas(), 8, add(input, 0x20), mul(length, 0x20), result, 0x20)\n        }\n        require(ret);\n        return result[0] != 0;\n    }\n\n    uint256 constant q_mod = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n    function fr_invert(uint256 a) internal view returns (uint256) {\n        return fr_pow(a, q_mod - 2);\n    }\n\n    function fr_pow(uint256 a, uint256 power) internal view returns (uint256) {\n        uint256[6] memory input;\n        uint256[1] memory result;\n        bool ret;\n\n        input[0] = 32;\n        input[1] = 32;\n        input[2] = 32;\n        input[3] = a;\n        input[4] = power;\n        input[5] = q_mod;\n\n        assembly {\n            ret := staticcall(gas(), 0x05, input, 0xc0, result, 0x20)\n        }\n        require(ret);\n\n        return result[0];\n    }\n\n    function fr_div(uint256 a, uint256 b) internal view returns (uint256) {\n        require(b != 0);\n        return mulmod(a, fr_invert(b), q_mod);\n    }\n\n    function fr_mul_add(\n        uint256 a,\n        uint256 b,\n        uint256 c\n    ) internal pure returns (uint256) {\n        return addmod(mulmod(a, b, q_mod), c, q_mod);\n    }\n\n    function fr_mul_add_pm(\n        uint256[84] memory m,\n        uint256[] calldata proof,\n        uint256 opcode,\n        uint256 t\n    ) internal pure returns (uint256) {\n        for (uint256 i = 0; i < 32; i += 2) {\n            uint256 a = opcode & 0xff;\n            if (a != 0xff) {\n                opcode >>= 8;\n                uint256 b = opcode & 0xff;\n                opcode >>= 8;\n                t = addmod(mulmod(proof[a], m[b], q_mod), t, q_mod);\n            } else {\n                break;\n            }\n        }\n\n        return t;\n    }\n\n    function fr_mul_add_mt(\n        uint256[84] memory m,\n        uint256 base,\n        uint256 opcode,\n        uint256 t\n    ) internal pure returns (uint256) {\n        for (uint256 i = 0; i < 32; i += 1) {\n            uint256 a = opcode & 0xff;\n            if (a != 0xff) {\n                opcode >>= 8;\n                t = addmod(mulmod(base, t, q_mod), m[a], q_mod);\n            } else {\n                break;\n            }\n        }\n\n        return t;\n    }\n\n    function fr_reverse(uint256 input) internal pure returns (uint256 v) {\n        v = input;\n\n        // swap bytes\n        v =\n            ((v & 0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >> 8) |\n            ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\n\n        // swap 2-byte long pairs\n        v =\n            ((v & 0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >> 16) |\n            ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\n\n        // swap 4-byte long pairs\n        v =\n            ((v & 0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >> 32) |\n            ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\n\n        // swap 8-byte long pairs\n        v =\n            ((v & 0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >> 64) |\n            ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\n\n        // swap 16-byte long pairs\n        v = (v >> 128) | (v << 128);\n    }\n\n    uint256 constant p_mod = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    struct G1Point {\n        uint256 x;\n        uint256 y;\n    }\n\n    struct G2Point {\n        uint256[2] x;\n        uint256[2] y;\n    }\n\n    function ecc_from(uint256 x, uint256 y) internal pure returns (G1Point memory r) {\n        r.x = x;\n        r.y = y;\n    }\n\n    function ecc_add(\n        uint256 ax,\n        uint256 ay,\n        uint256 bx,\n        uint256 by\n    ) internal view returns (uint256, uint256) {\n        bool ret = false;\n        G1Point memory r;\n        uint256[4] memory input_points;\n\n        input_points[0] = ax;\n        input_points[1] = ay;\n        input_points[2] = bx;\n        input_points[3] = by;\n\n        assembly {\n            ret := staticcall(gas(), 6, input_points, 0x80, r, 0x40)\n        }\n        require(ret);\n\n        return (r.x, r.y);\n    }\n\n    function ecc_sub(\n        uint256 ax,\n        uint256 ay,\n        uint256 bx,\n        uint256 by\n    ) internal view returns (uint256, uint256) {\n        return ecc_add(ax, ay, bx, p_mod - by);\n    }\n\n    function ecc_mul(\n        uint256 px,\n        uint256 py,\n        uint256 s\n    ) internal view returns (uint256, uint256) {\n        uint256[3] memory input;\n        bool ret = false;\n        G1Point memory r;\n\n        input[0] = px;\n        input[1] = py;\n        input[2] = s;\n\n        assembly {\n            ret := staticcall(gas(), 7, input, 0x60, r, 0x40)\n        }\n        require(ret);\n\n        return (r.x, r.y);\n    }\n\n    function _ecc_mul_add(uint256[5] memory input) internal view {\n        bool ret = false;\n\n        assembly {\n            ret := staticcall(gas(), 7, input, 0x60, add(input, 0x20), 0x40)\n        }\n        require(ret);\n\n        assembly {\n            ret := staticcall(gas(), 6, add(input, 0x20), 0x80, add(input, 0x60), 0x40)\n        }\n        require(ret);\n    }\n\n    function ecc_mul_add(\n        uint256 px,\n        uint256 py,\n        uint256 s,\n        uint256 qx,\n        uint256 qy\n    ) internal view returns (uint256, uint256) {\n        uint256[5] memory input;\n        input[0] = px;\n        input[1] = py;\n        input[2] = s;\n        input[3] = qx;\n        input[4] = qy;\n\n        _ecc_mul_add(input);\n\n        return (input[3], input[4]);\n    }\n\n    function ecc_mul_add_pm(\n        uint256[84] memory m,\n        uint256[] calldata proof,\n        uint256 opcode,\n        uint256 t0,\n        uint256 t1\n    ) internal view returns (uint256, uint256) {\n        uint256[5] memory input;\n        input[3] = t0;\n        input[4] = t1;\n        for (uint256 i = 0; i < 32; i += 2) {\n            uint256 a = opcode & 0xff;\n            if (a != 0xff) {\n                opcode >>= 8;\n                uint256 b = opcode & 0xff;\n                opcode >>= 8;\n                input[0] = proof[a];\n                input[1] = proof[a + 1];\n                input[2] = m[b];\n                _ecc_mul_add(input);\n            } else {\n                break;\n            }\n        }\n\n        return (input[3], input[4]);\n    }\n\n    function update_hash_scalar(\n        uint256 v,\n        uint256[144] memory absorbing,\n        uint256 pos\n    ) internal pure {\n        absorbing[pos++] = 0x02;\n        absorbing[pos++] = v;\n    }\n\n    function update_hash_point(\n        uint256 x,\n        uint256 y,\n        uint256[144] memory absorbing,\n        uint256 pos\n    ) internal pure {\n        absorbing[pos++] = 0x01;\n        absorbing[pos++] = x;\n        absorbing[pos++] = y;\n    }\n\n    function to_scalar(bytes32 r) private pure returns (uint256 v) {\n        uint256 tmp = uint256(r);\n        tmp = fr_reverse(tmp);\n        v = tmp % 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001;\n    }\n\n    function hash(uint256[144] memory absorbing, uint256 length) private view returns (bytes32[1] memory v) {\n        bool success;\n        assembly {\n            success := staticcall(sub(gas(), 2000), 2, absorbing, length, v, 32)\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n        assert(success);\n    }\n\n    function squeeze_challenge(uint256[144] memory absorbing, uint32 length) internal view returns (uint256 v) {\n        absorbing[length] = 0;\n        bytes32 res = hash(absorbing, length * 32 + 1)[0];\n        v = to_scalar(res);\n        absorbing[0] = uint256(res);\n        length = 1;\n    }\n\n    function get_verify_circuit_g2_s() internal pure returns (G2Point memory s) {\n        s.x[0] = uint256(19996377281670978687180986182441301914718493784645870391946826878753710639456);\n        s.x[1] = uint256(4287478848095488335912479212753150961411468232106701703291869721868407715111);\n        s.y[0] = uint256(6995741485533723263267942814565501722132921805029874890336635619836737653877);\n        s.y[1] = uint256(11126659726611658836425410744462014686753643655648740844565393330984713428953);\n    }\n\n    function get_verify_circuit_g2_n() internal pure returns (G2Point memory n) {\n        n.x[0] = uint256(11559732032986387107991004021392285783925812861821192530917403151452391805634);\n        n.x[1] = uint256(10857046999023057135944570762232829481370756359578518086990519993285655852781);\n        n.y[0] = uint256(17805874995975841540914202342111839520379459829704422454583296818431106115052);\n        n.y[1] = uint256(13392588948715843804641432497768002650278120570034223513918757245338268106653);\n    }\n\n    function get_target_circuit_g2_s() internal pure returns (G2Point memory s) {\n        s.x[0] = uint256(19996377281670978687180986182441301914718493784645870391946826878753710639456);\n        s.x[1] = uint256(4287478848095488335912479212753150961411468232106701703291869721868407715111);\n        s.y[0] = uint256(6995741485533723263267942814565501722132921805029874890336635619836737653877);\n        s.y[1] = uint256(11126659726611658836425410744462014686753643655648740844565393330984713428953);\n    }\n\n    function get_target_circuit_g2_n() internal pure returns (G2Point memory n) {\n        n.x[0] = uint256(11559732032986387107991004021392285783925812861821192530917403151452391805634);\n        n.x[1] = uint256(10857046999023057135944570762232829481370756359578518086990519993285655852781);\n        n.y[0] = uint256(17805874995975841540914202342111839520379459829704422454583296818431106115052);\n        n.y[1] = uint256(13392588948715843804641432497768002650278120570034223513918757245338268106653);\n    }\n\n    function get_wx_wg(uint256[] calldata proof, uint256[6] memory instances)\n        internal\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        uint256[84] memory m;\n        uint256[144] memory absorbing;\n        uint256 t0 = 0;\n        uint256 t1 = 0;\n\n        (t0, t1) = (\n            ecc_mul(\n                16273630658577275004922498653030603356133576819117084202553121866583118864964,\n                6490159372778831696763963776713702553449715395136256408127406430701013586737,\n                instances[0]\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                21465583338900056601761668793508143213048509206826828900542864688378093593107,\n                18916078441896187703473496284050716429170517783995157941513585201547834049281,\n                instances[1],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                6343857336395576108841088300387244434710621968858839561085778033655098739860,\n                8647137667680968494319179221347060255241434220013711910139382436020093396308,\n                instances[2],\n                t0,\n                t1\n            )\n        );\n        (t0, t1) = (\n            ecc_mul_add(\n                17609998990685530094209191702545036897101285294398654477281719279316619940710,\n                7891327626892441842954365090016786852185025910332850053066512639794082797200,\n                instances[3],\n                t0,\n                t1"
    }
  ]
}