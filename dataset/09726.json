{
  "Title": "[M-04] SingleStrategyController doesn't verify that new strategy uses the same base token",
  "Content": "_Submitted by Ruhum_\n\nWhen migrating from one strategy to another, the controller pulls out the funds of the old strategy and deposits them into the new one. But, it doesn't verify that both strategies use the same base token. If the new one uses a different base token, it won't \"know\" about the tokens it received on migration. It won't be able to deposit and transfer them. Effectively they would be lost.\n\nThe migration is done by the owner. So the owner must make a mistake and migrate to the wrong strategy by accident. In a basic protocol with 1 controller and a single active strategy managing that should be straightforward. There shouldn't be a real risk of that mistake happening. But, if you have multiple controllers running at the same time each with a different base token, it gets increasingly likelier.\n\nAccording to the `IStrategy` interface, there is a function to retrieve the strategy's base token: `getBaseToken()`. I'd recommend adding a check in the `migrate()` function to verify that the new strategy uses the correct base token to prevent this issue from being possible.\n\n### Proof of Concept\n\n[SingleStrategyController.sol#L51-L72](https://github.com/code-423n4/2022-03-prepo/blob/main/contracts/core/SingleStrategyController.sol#L51-L72)<br>\n\n[IStrategy.sol#L52](https://github.com/code-423n4/2022-03-prepo/blob/main/contracts/core/interfaces/IStrategy.sol#L52)<br>\n\n### Recommended Mitigation Steps\n\nAdd  `require(_baseToken == _newStrategy.getBaseToken());` to the beginning of `migrate()`.\n\n**[ramenforbreakfast (prePO) confirmed and commented](https://github.com/code-423n4/2022-03-prepo-findings/issues/62#issuecomment-1075799363):**\n > Valid claim, in addition to H-02, illustrates why we should probably not have a fixed migration function due to the complexity of such an operation.\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-03-prepo-findings/issues/62#issuecomment-1086869134):**\n > Agree with sponsor.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-03-prepo-contest",
  "Code": [
    {
      "filename": "contracts/core/SingleStrategyController.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.7;\n\nimport \"./interfaces/IStrategy.sol\";\nimport \"./interfaces/IStrategyController.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract SingleStrategyController is\n    IStrategyController,\n    Ownable,\n    ReentrancyGuard\n{\n    using SafeERC20 for IERC20;\n\n    address private _vault;\n    IStrategy private _strategy;\n    IERC20 private immutable _baseToken;\n\n    modifier onlyVault() {\n        require(msg.sender == _vault, \"Caller is not the vault\");\n        _;\n    }\n\n    constructor(IERC20 _token) {\n        require(address(_token) != address(0), \"Zero address\");\n        _baseToken = _token;\n    }\n\n    // Assumes approval to take `_amount` has already been given by vault\n    function deposit(uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _baseToken.safeTransferFrom(_vault, address(this), _amount);\n        _strategy.deposit(_baseToken.balanceOf(address(this)));\n    }\n\n    function withdraw(address _recipient, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        _strategy.withdraw(_recipient, _amount);\n    }\n\n    function migrate(IStrategy _newStrategy)\n        external\n        override\n        onlyOwner\n        nonReentrant\n    {\n        uint256 _oldStrategyBalance;\n        IStrategy _oldStrategy = _strategy;\n        _strategy = _newStrategy;\n        _baseToken.approve(address(_newStrategy), type(uint256).max);\n        if (address(_oldStrategy) != address(0)) {\n            _baseToken.approve(address(_oldStrategy), 0);\n            _oldStrategyBalance = _oldStrategy.totalValue();\n            _oldStrategy.withdraw(address(this), _oldStrategyBalance);\n            _newStrategy.deposit(_baseToken.balanceOf(address(this)));\n        }\n        emit StrategyMigrated(\n            address(_oldStrategy),\n            address(_newStrategy),\n            _oldStrategyBalance\n        );\n    }\n\n    function setVault(address _newVault) external override onlyOwner {\n        _vault = _newVault;\n        emit VaultChanged(_newVault);\n    }\n\n    function totalValue() external view override returns (uint256) {\n        return _baseToken.balanceOf(address(this)) + _strategy.totalValue();\n    }\n\n    function getVault() external view override returns (address) {\n        return _vault;\n    }\n\n    function getStrategy() external view override returns (IStrategy) {\n        return _strategy;\n    }\n\n    function getBaseToken() external view override returns (IERC20) {\n        return _baseToken;\n    }\n}"
    },
    {
      "filename": "contracts/core/interfaces/IStrategy.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.7;\n\nimport \"../interfaces/IStrategyController.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @notice Strategy that deploys Base Token to earn yield denominated in Base\n * Token.\n * @dev `owner()` can call emergency functions and setters, only controller\n * can call deposit/withdraw.\n */\ninterface IStrategy {\n    /**\n     * @notice Deposits `amount` Base Token into the strategy.\n     * @dev Assumes the StrategyController has given infinite spend approval\n     * to the strategy.\n     * @param amount Amount of Base Token to deposit\n     */\n    function deposit(uint256 amount) external;\n\n    /**\n     * @notice Withdraws `amount` Base Token from the strategy to `recipient`.\n     * @dev This withdrawal is optimistic, returned amount might be less than\n     * the amount specified.\n     * @param recipient Address to receive the Base Token\n     * @param amount Amount of Base Token to withdraw\n     */\n    function withdraw(address recipient, uint256 amount) external;\n\n    /**\n     * @notice Returns the Base Token balance of this contract and\n     * the estimated value of deployed assets.\n     * @return Total value of assets within the strategy\n     */\n    function totalValue() external view returns (uint256);\n\n    /**\n     * @notice Returns the Strategy Controller that intermediates interactions\n     * between a vault and this strategy.\n     * @dev Functions with the `onlyController` modifier can only be called by\n     * this Strategy Controller.\n     * @return The Strategy Controller address\n     */\n    function getController() external view returns (IStrategyController);\n\n    /**\n     * @notice The ERC20 asset that this strategy utilizes to earn yield and\n     * return profits with.\n     * @return The Base Token address\n     */\n    function getBaseToken() external view returns (IERC20);\n}"
    }
  ]
}