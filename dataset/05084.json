{
  "Title": "[09] Necessary changes to `foundry.toml`",
  "Content": "\nWe had to introduce a few changes to `foundry.toml`. On the one hand, a couple of dependencies were missing, so we've introduced them for the project to compile. On the other hand, the fuzzing/invariant test settings have been in our opinion very low, so we increased the number or the depth of the runs in order to increase the coverage. \n\n```diff\ndiff --git a/foundry.toml b/foundry.toml\nindex a3031f2..64d0f63 100644\n--- a/foundry.toml\n+++ b/foundry.toml\n@@ -2,17 +2,23 @@\n   evm_version = \"paris\"\n   optimizer = true\n   optimizer_runs = 10_000_000\n-  remappings = [\"openzeppelin/=lib/openzeppelin-contracts/contracts\"]\n+  remappings = [\n+    \"openzeppelin/=lib/openzeppelin-contracts/contracts\",\n+    \"uniswap-periphery/=lib/v3-periphery/contracts\",\n+    \"@uniswap/v3-core=lib/v3-core\",\n+  ]\n   solc_version = \"0.8.23\"\n   verbosity = 3\n+  fuzz = { runs = 500 }\n+  invariant = { runs = 100, depth = 100 }\n \n [profile.ci]\n   fuzz = { runs = 5000 }\n-  invariant = { runs = 1000 }\n+  invariant = { runs = 1000, depth = 100 }\n \n [profile.lite]\n   fuzz = { runs = 50 }\n-  invariant = { runs = 10 }\n+  invariant = { runs = 10, depth = 100 }\n   # Speed up compilation and tests during development.\n   optimizer = false\n```\n\nIncreasing the fuzz/invariant bounds allowed us in particular to observe the following failing test\n\n```sh\n[FAIL. Reason: assertion failed; counterexample: calldata=0xc1e611e700000000000000000000000000000000000000000000000000000000000029fa00000000000000000000000000000000000000000000000000000000000004d3000000000000000000000000aa10a84ce7d9ae517a52c6d5ca153b369af99ecf0000000000000000000000000000000000000000000000000000000000002d6900000000000000000000000000000000000000000000000000000000000000970000000000000000000000000000000000000000000000000000000000000631 args=[0x00000000000000000000000000000000000029fa, 1235, 0xaA10a84CE7d9AE517a52c6d5cA153b369Af99ecF, 11625 [1.162e4], 0x0000000000000000000000000000000000000097, 0x0000000000000000000000000000000000000631]] testFuzz_DeploysAndTransfersTokenToTwoSurrogatesWhenAccountsStakesToDifferentDelegatees(address,uint256,address,uint256,address,address) (runs: 370, Î¼: 803661, ~: 816488)\nLogs:\n  Bound Result 1235\n  Bound Result 11625\n  Error: a == b not satisfied [uint]\n        Left: 1000000000000000000000000000\n       Right: 0\n```\n\nThe reason for the test failure was that due to an increased number of alternatives tried, Foundry's fuzz testing engine picked admin's address to mint to, and thus [this assertion](https://github.com/code-423n4/2024-02-uniswap-foundation/blob/5a2761c8277541a24bc551fbd624413b384bea94/test/UniStaker.t.sol#L414) failed as a result. We have repaired the failing test by disallowing to mint governance tokens to admin's address.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-02-uniswap-foundation",
  "Code": [
    {
      "filename": "test/UniStaker.t.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.23;\n\nimport {Vm, Test, stdStorage, StdStorage, console2} from \"forge-std/Test.sol\";\nimport {UniStaker, DelegationSurrogate, IERC20, IERC20Delegates} from \"src/UniStaker.sol\";\nimport {UniStakerHarness} from \"test/harnesses/UniStakerHarness.sol\";\nimport {ERC20VotesMock, ERC20Permit} from \"test/mocks/MockERC20Votes.sol\";\nimport {ERC20Fake} from \"test/fakes/ERC20Fake.sol\";\nimport {PercentAssertions} from \"test/helpers/PercentAssertions.sol\";\n\ncontract UniStakerTest is Test, PercentAssertions {\n  ERC20Fake rewardToken;\n  ERC20VotesMock govToken;\n  address admin;\n  address rewardNotifier;\n  UniStakerHarness uniStaker;\n  uint256 SCALE_FACTOR;\n  // console2.log(uint(_domainSeparatorV4()))\n  bytes32 EIP712_DOMAIN_SEPARATOR = bytes32(\n    uint256(\n      108_300_748_413_663_721_746_865_897_746_851_483_791_898_864_552_448_882_835_473_754_343_054_398_579_494\n    )\n  );\n\n  bytes32 constant PERMIT_TYPEHASH =\n    keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n  event RewardNotifierSet(address indexed account, bool isEnabled);\n  event AdminSet(address indexed oldAdmin, address indexed newAdmin);\n\n  function setUp() public {\n    // Set the block timestamp to an arbitrary value to avoid introducing assumptions into tests\n    // based on a starting timestamp of 0, which is the default.\n    _jumpAhead(1234);\n\n    rewardToken = new ERC20Fake();\n    vm.label(address(rewardToken), \"Reward Token\");\n\n    govToken = new ERC20VotesMock();\n    vm.label(address(govToken), \"Governance Token\");\n\n    rewardNotifier = address(0xaffab1ebeef);\n    vm.label(rewardNotifier, \"Reward Notifier\");\n\n    admin = makeAddr(\"admin\");\n\n    uniStaker = new UniStakerHarness(rewardToken, govToken, admin);\n    vm.label(address(uniStaker), \"UniStaker\");\n\n    vm.prank(admin);\n    uniStaker.setRewardNotifier(rewardNotifier, true);\n\n    // Convenience for use in tests\n    SCALE_FACTOR = uniStaker.SCALE_FACTOR();\n  }\n\n  function _jumpAhead(uint256 _seconds) public {\n    vm.warp(block.timestamp + _seconds);\n  }\n\n  function _boundMintAmount(uint256 _amount) internal pure returns (uint256) {\n    return bound(_amount, 0, 100_000_000_000e18);\n  }\n\n  function _mintGovToken(address _to, uint256 _amount) internal {\n    vm.assume(_to != address(0));\n    govToken.mint(_to, _amount);\n  }\n\n  function _boundToRealisticStake(uint256 _stakeAmount)\n    public\n    pure\n    returns (uint256 _boundedStakeAmount)\n  {\n    _boundedStakeAmount = bound(_stakeAmount, 0.1e18, 25_000_000e18);\n  }\n\n  function _stake(address _depositor, uint256 _amount, address _delegatee)\n    internal\n    returns (UniStaker.DepositIdentifier _depositId)\n  {\n    vm.assume(_delegatee != address(0));\n\n    vm.startPrank(_depositor);\n    govToken.approve(address(uniStaker), _amount);\n    _depositId = uniStaker.stake(_amount, _delegatee);\n    vm.stopPrank();\n  }\n\n  function _stake(address _depositor, uint256 _amount, address _delegatee, address _beneficiary)\n    internal\n    returns (UniStaker.DepositIdentifier _depositId)\n  {\n    vm.assume(_delegatee != address(0) && _beneficiary != address(0));\n\n    vm.startPrank(_depositor);\n    govToken.approve(address(uniStaker), _amount);\n    _depositId = uniStaker.stake(_amount, _delegatee, _beneficiary);\n    vm.stopPrank();\n  }\n\n  function _fetchDeposit(UniStaker.DepositIdentifier _depositId)\n    internal\n    view\n    returns (UniStaker.Deposit memory)\n  {\n    (uint256 _balance, address _owner, address _delegatee, address _beneficiary) =\n      uniStaker.deposits(_depositId);\n    return UniStaker.Deposit({\n      balance: _balance,\n      owner: _owner,\n      delegatee: _delegatee,\n      beneficiary: _beneficiary\n    });\n  }\n\n  function _boundMintAndStake(address _depositor, uint256 _amount, address _delegatee)\n    internal\n    returns (uint256 _boundedAmount, UniStaker.DepositIdentifier _depositId)\n  {\n    _boundedAmount = _boundMintAmount(_amount);\n    _mintGovToken(_depositor, _boundedAmount);\n    _depositId = _stake(_depositor, _boundedAmount, _delegatee);\n  }\n\n  function _boundMintAndStake(\n    address _depositor,\n    uint256 _amount,\n    address _delegatee,\n    address _beneficiary\n  ) internal returns (uint256 _boundedAmount, UniStaker.DepositIdentifier _depositId) {\n    _boundedAmount = _boundMintAmount(_amount);\n    _mintGovToken(_depositor, _boundedAmount);\n    _depositId = _stake(_depositor, _boundedAmount, _delegatee, _beneficiary);\n  }\n\n  // Scales first param and divides it by second\n  function _scaledDiv(uint256 _x, uint256 _y) public view returns (uint256) {\n    return (_x * SCALE_FACTOR) / _y;\n  }\n\n  function _sign(uint256 _privateKey, bytes32 _messageHash) internal pure returns (bytes memory) {\n    (uint8 _v, bytes32 _r, bytes32 _s) = vm.sign(_privateKey, _messageHash);\n    return abi.encodePacked(_r, _s, _v);\n  }\n\n  function _modifyMessage(bytes32 _message, uint256 _index) internal pure returns (bytes32) {\n    _index = bound(_index, 0, 31);\n    bytes memory _messageBytes = abi.encodePacked(_message);\n    // zero out the byte at the given index, or set it to 1 if it's already zero\n    if (_messageBytes[_index] == 0) _messageBytes[_index] = bytes1(uint8(1));\n    else _messageBytes[_index] = bytes1(uint8(0));\n    return bytes32(_messageBytes);\n  }\n\n  function _modifySignature(bytes memory _signature, uint256 _index)\n    internal\n    pure\n    returns (bytes memory)\n  {\n    _index = bound(_index, 0, _signature.length - 1);\n    // zero out the byte at the given index, or set it to 1 if it's already zero\n    if (_signature[_index] == 0) _signature[_index] = bytes1(uint8(1));\n    else _signature[_index] = bytes1(uint8(0));\n    return _signature;\n  }\n}\n\ncontract Constructor is UniStakerTest {\n  function test_SetsTheRewardTokenStakeTokenAndRewardNotifier() public {\n    assertEq(address(uniStaker.REWARD_TOKEN()), address(rewardToken));\n    assertEq(address(uniStaker.STAKE_TOKEN()), address(govToken));\n    assertEq(uniStaker.admin(), admin);\n  }\n\n  function testFuzz_SetsTheRewardTokenStakeTokenAndOwnerToArbitraryAddresses(\n    address _rewardToken,\n    address _stakeToken,\n    address _admin\n  ) public {\n    vm.assume(_admin != address(0));\n    UniStaker _uniStaker = new UniStaker(IERC20(_rewardToken), IERC20Delegates(_stakeToken), _admin);\n    assertEq(address(_uniStaker.REWARD_TOKEN()), address(_rewardToken));\n    assertEq(address(_uniStaker.STAKE_TOKEN()), address(_stakeToken));\n    assertEq(_uniStaker.admin(), _admin);\n  }\n}\n\ncontract Stake is UniStakerTest {\n  function testFuzz_DeploysAndTransfersTokensToANewSurrogateWhenAnAccountStakes(\n    address _depositor,\n    uint256 _amount,\n    address _delegatee\n  ) public {\n    _amount = bound(_amount, 1, type(uint224).max);\n    _mintGovToken(_depositor, _amount);\n    _stake(_depositor, _amount, _delegatee);\n\n    DelegationSurrogate _surrogate = uniStaker.surrogates(_delegatee);\n\n    assertEq(govToken.balanceOf(address(_surrogate)), _amount);\n    assertEq(govToken.delegates(address(_surrogate)), _delegatee);\n    assertEq(govToken.balanceOf(_depositor), 0);\n  }\n\n  function testFuzz_EmitsAStakingDepositEventWhenStakingWithoutASpecifiedBeneficiary(\n    address _depositor,\n    uint256 _amount,\n    address _delegatee\n  ) public {\n    _amount = bound(_amount, 1, type(uint224).max);\n    _mintGovToken(_depositor, _amount);\n    UniStaker.DepositIdentifier depositId = uniStaker.exposed_useDepositId();\n\n    vm.assume(_delegatee != address(0));\n\n    vm.startPrank(_depositor);\n    govToken.approve(address(uniStaker), _amount);\n    vm.expectEmit();\n    emit UniStaker.StakeDeposited(\n      _depositor,\n      UniStaker.DepositIdentifier.wrap(UniStaker.DepositIdentifier.unwrap(depositId) + 1),\n      _amount,\n      _amount\n    );\n\n    uniStaker.stake(_amount, _delegatee);\n    vm.stopPrank();\n  }\n\n  function testFuzz_EmitsABeneficiaryAlteredEventWhenStakingWithoutASpecifiedBeneficiary(\n    address _depositor,\n    uint256 _amount,\n    address _delegatee\n  ) public {\n    _amount = bound(_amount, 1, type(uint224).max);\n    _mintGovToken(_depositor, _amount);\n    UniStaker.DepositIdentifier depositId = uniStaker.exposed_useDepositId();\n\n    vm.assume(_delegatee != address(0));\n\n    vm.startPrank(_depositor);\n    govToken.approve(address(uniStaker), _amount);\n    vm.expectEmit();\n    emit UniStaker.BeneficiaryAltered(\n      UniStaker.DepositIdentifier.wrap(UniStaker.DepositIdentifier.unwrap(depositId) + 1),\n      address(0),\n      _depositor\n    );\n\n    uniStaker.stake(_amount, _delegatee);\n    vm.stopPrank();\n  }\n\n  function testFuzz_EmitsADelegateeAlteredEventWhenStakingWithoutASpecifiedBeneficiary(\n    address _depositor,\n    uint256 _amount,\n    address _delegatee\n  ) public {\n    _amount = bound(_amount, 1, type(uint224).max);\n    _mintGovToken(_depositor, _amount);\n    UniStaker.DepositIdentifier depositId = uniStaker.exposed_useDepositId();\n\n    vm.assume(_delegatee != address(0));\n\n    vm.startPrank(_depositor);\n    govToken.approve(address(uniStaker), _amount);\n    vm.expectEmit();\n    emit UniStaker.DelegateeAltered(\n      UniStaker.DepositIdentifier.wrap(UniStaker.DepositIdentifier.unwrap(depositId) + 1),\n      address(0),\n      _delegatee\n    );\n\n    uniStaker.stake(_amount, _delegatee);\n    vm.stopPrank();\n  }\n\n  function testFuzz_EmitsAStakingDepositEventWhenStakingWithASpecifiedBeneficiary(\n    address _depositor,\n    uint256 _amount,\n    address _delegatee,\n    address _beneficiary\n  ) public {\n    _amount = bound(_amount, 1, type(uint224).max);\n    _mintGovToken(_depositor, _amount);\n    UniStaker.DepositIdentifier depositId = uniStaker.exposed_useDepositId();\n\n    vm.assume(_delegatee != address(0) && _beneficiary != address(0));\n\n    vm.startPrank(_depositor);\n    govToken.approve(address(uniStaker), _amount);\n    vm.expectEmit();\n    emit UniStaker.StakeDeposited(\n      _depositor,\n      UniStaker.DepositIdentifier.wrap(UniStaker.DepositIdentifier.unwrap(depositId) + 1),\n      _amount,\n      _amount\n    );\n\n    uniStaker.stake(_amount, _delegatee, _beneficiary);\n    vm.stopPrank();\n  }\n\n  function testFuzz_EmitsABeneficiaryAlteredEventWhenStakingWithASpecifiedBeneficiary(\n    address _depositor,\n    uint256 _amount,\n    address _delegatee,\n    address _beneficiary\n  ) public {\n    _amount = bound(_amount, 1, type(uint224).max);\n    _mintGovToken(_depositor, _amount);\n    UniStaker.DepositIdentifier depositId = uniStaker.exposed_useDepositId();\n\n    vm.assume(_delegatee != address(0) && _beneficiary != address(0));\n\n    vm.startPrank(_depositor);\n    govToken.approve(address(uniStaker), _amount);\n    vm.expectEmit();\n    emit UniStaker.BeneficiaryAltered(\n      UniStaker.DepositIdentifier.wrap(UniStaker.DepositIdentifier.unwrap(depositId) + 1),\n      address(0),\n      _beneficiary\n    );\n\n    uniStaker.stake(_amount, _delegatee, _beneficiary);\n    vm.stopPrank();\n  }\n\n  function testFuzz_EmitsADelegateeAlteredEventWhenStakingWithASpecifiedBeneficiary(\n    address _depositor,\n    uint256 _amount,\n    address _delegatee,\n    address _beneficiary\n  ) public {\n    _amount = bound(_amount, 1, type(uint224).max);\n    _mintGovToken(_depositor, _amount);\n    UniStaker.DepositIdentifier depositId = uniStaker.exposed_useDepositId();\n\n    vm.assume(_delegatee != address(0) && _beneficiary != address(0));\n\n    vm.startPrank(_depositor);\n    govToken.approve(address(uniStaker), _amount);\n    vm.expectEmit();\n    emit UniStaker.DelegateeAltered(\n      UniStaker.DepositIdentifier.wrap(UniStaker.DepositIdentifier.unwrap(depositId) + 1),\n      address(0),\n      _delegatee\n    );\n\n    uniStaker.stake(_amount, _delegatee, _beneficiary);\n    vm.stopPrank();\n  }\n\n  function testFuzz_TransfersToAnExistingSurrogateWhenStakedToTheSameDelegatee(\n    address _depositor1,\n    uint256 _amount1,\n    address _depositor2,\n    uint256 _amount2,\n    address _delegatee\n  ) public {\n    _amount1 = _boundMintAmount(_amount1);\n    _amount2 = _boundMintAmount(_amount2);\n    _mintGovToken(_depositor1, _amount1);\n    _mintGovToken(_depositor2, _amount2);\n\n    // Perform first stake with this delegatee\n    _stake(_depositor1, _amount1, _delegatee);\n    // Remember the surrogate which was deployed for this delegatee\n    DelegationSurrogate _surrogate = uniStaker.surrogates(_delegatee);\n\n    // Perform the second stake with this delegatee\n    _stake(_depositor2, _amount2, _delegatee);\n\n    // Ensure surrogate for this delegatee hasn't changed and has summed stake balance\n    assertEq(address(uniStaker.surrogates(_delegatee)), address(_surrogate));\n    assertEq(govToken.delegates(address(_surrogate)), _delegatee);\n    assertEq(govToken.balanceOf(address(_surrogate)), _amount1 + _amount2);\n    assertEq(govToken.balanceOf(_depositor1), 0);\n    assertEq(govToken.balanceOf(_depositor2), 0);\n  }\n\n  function testFuzz_DeploysAndTransfersTokenToTwoSurrogatesWhenAccountsStakesToDifferentDelegatees(\n    address _depositor1,\n    uint256 _amount1,\n    address _depositor2,\n    uint256 _amount2,\n    address _delegatee1,\n    address _delegatee2\n  ) public {\n    vm.assume(_delegatee1 != _delegatee2);\n    _amount1 = _boundMintAmount(_amount1);\n    _amount2 = _boundMintAmount(_amount2);\n    _mintGovToken(_depositor1, _amount1);\n    _mintGovToken(_depositor2, _amount2);\n\n    // Perform first stake with first delegatee\n    _stake(_depositor1, _amount1, _delegatee1);\n    // Remember the surrogate which was deployed for first delegatee\n    DelegationSurrogate _surrogate1 = uniStaker.surrogates(_delegatee1);\n\n    // Perform second stake with second delegatee\n    _stake(_depositor2, _amount2, _delegatee2);\n    // Remember the surrogate which was deployed for first delegatee\n    DelegationSurrogate _surrogate2 = uniStaker.surrogates(_delegatee2);\n\n    // Ensure surrogates are different with discreet delegation & balances\n    assertTrue(_surrogate1 != _surrogate2);\n    assertEq(govToken.delegates(address(_surrogate1)), _delegatee1);\n    assertEq(govToken.balanceOf(address(_surrogate1)), _amount1);\n    assertEq(govToken.delegates(address(_surrogate2)), _delegatee2);\n    assertEq(govToken.balanceOf(address(_surrogate2)), _amount2);\n    assertEq(govToken.balanceOf(_depositor1), 0);\n    assertEq(govToken.balanceOf(_depositor2), 0);\n  }\n\n  function testFuzz_UpdatesTheTotalStakedWhenAnAccountStakes(\n    address _depositor,\n    uint256 _amount,\n    address _delegatee\n  ) public {\n    _amount = _boundMintAmount(_amount);\n    _mintGovToken(_depositor, _amount);\n\n    _stake(_depositor, _amount, _delegatee);\n\n    assertEq(uniStaker.totalStaked(), _amount);\n  }\n\n  function testFuzz_UpdatesTheTotalStakedWhenTwoAccountsStake(\n    address _depositor1,\n    uint256 _amount1,\n    address _depositor2,\n    uint256 _amount2,\n    address _delegatee1,\n    address _delegatee2\n  ) public {\n    _amount1 = _boundMintAmount(_amount1);\n    _amount2 = _boundMintAmount(_amount2);\n    _mintGovToken(_depositor1, _amount1);\n    _mintGovToken(_depositor2, _amount2);\n\n    _stake(_depositor1, _amount1, _delegatee1);\n    assertEq(uniStaker.totalStaked(), _amount1);\n\n    _stake(_depositor2, _amount2, _delegatee2);\n    assertEq(uniStaker.totalStaked(), _amount1 + _amount2);\n  }\n\n  function testFuzz_UpdatesAnAccountsTotalStakedAccounting(\n    address _depositor,\n    uint256 _amount1,\n    uint256 _amount2,\n    address _delegatee1,\n    address _delegatee2\n  ) public {\n    _amount1 = _boundMintAmount(_amount1);\n    _amount2 = _boundMintAmount(_amount2);\n    _mintGovToken(_depositor, _amount1 + _amount2);\n\n    // First stake + check total\n    _stake(_depositor, _amount1, _delegatee1);\n    assertEq(uniStaker.depositorTotalStaked(_depositor), _amount1);\n\n    // Second stake + check total\n    _stake(_depositor, _amount2, _delegatee2);\n    assertEq(uniStaker.depositorTotalStaked(_depositor), _amount1 + _amount2);\n  }\n\n  function testFuzz_UpdatesDifferentAccountsTotalStakedAccountingIndependently(\n    address _depositor1,\n    uint256 _amount1,\n    address _depositor2,\n    uint256 _amount2,\n    address _delegatee1,\n    address _delegatee2\n  ) public {\n    vm.assume(_depositor1 != _depositor2);\n    _amount1 = _boundMintAmount(_amount1);\n    _amount2 = _boundMintAmount(_amount2);\n    _mintGovToken(_depositor1, _amount1);\n    _mintGovToken(_depositor2, _amount2);\n\n    _stake(_depositor1, _amount1, _delegatee1);\n    assertEq(uniStaker.depositorTotalStaked(_depositor1), _amount1);\n\n    _stake(_depositor2, _amount2, _delegatee2);\n    assertEq(uniStaker.depositorTotalStaked(_depositor2), _amount2);\n  }\n\n  function testFuzz_TracksTheBalanceForASpecificDeposit(\n    address _depositor,\n    uint256 _amount,\n    address _delegatee\n  ) public {\n    _amount = _boundMintAmount(_amount);\n    _mintGovToken(_depositor, _amount);\n\n    UniStaker.DepositIdentifier _depositId = _stake(_depositor, _amount, _delegatee);\n    UniStaker.Deposit memory _deposit = _fetchDeposit(_depositId);\n    assertEq(_deposit.balance, _amount);\n    assertEq(_deposit.owner, _depositor);\n    assertEq(_deposit.delegatee, _delegatee);\n  }\n\n  function testFuzz_TracksTheBalanceForDifferentDepositsFromTheSameAccountIndependently(\n    address _depositor,\n    uint256 _amount1,\n    uint256 _amount2,\n    address _delegatee1,\n    address _delegatee2\n  ) public {\n    _amount1 = _boundMintAmount(_amount1);\n    _amount2 = _boundMintAmount(_amount2);\n    _mintGovToken(_depositor, _amount1 + _amount2);\n\n    // Perform both deposits and track their identifiers separately\n    UniStaker.DepositIdentifier _depositId1 = _stake(_depositor, _amount1, _delegatee1);\n    UniStaker.DepositIdentifier _depositId2 = _stake(_depositor, _amount2, _delegatee2);\n    UniStaker.Deposit memory _deposit1 = _fetchDeposit(_depositId1);\n    UniStaker.Deposit memory _deposit2 = _fetchDeposit(_depositId2);\n\n    // Check that the deposits have been recorded independently\n    assertEq(_deposit1.balance, _amount1);\n    assertEq(_deposit1.owner, _depositor);\n    assertEq(_deposit1.delegatee, _delegatee1);\n    assertEq(_deposit2.balance, _amount2);\n    assertEq(_deposit2.owner, _depositor);\n    assertEq(_deposit2.delegatee, _delegatee2);\n  }\n\n  function testFuzz_TracksTheBalanceForDepositsFromDifferentAccountsIndependently(\n    address _depositor1,\n    address _depositor2,\n    uint256 _amount1,\n    uint256 _amount2,\n    address _delegatee1,\n    address _delegatee2\n  ) public {\n    _amount1 = _boundMintAmount(_amount1);\n    _amount2 = _boundMintAmount(_amount2);\n    _mintGovToken(_depositor1, _amount1);\n    _mintGovToken(_depositor2, _amount2);\n\n    // Perform both deposits and track their identifiers separately\n    UniStaker.DepositIdentifier _depositId1 = _stake(_depositor1, _amount1, _delegatee1);\n    UniStaker.DepositIdentifier _depositId2 = _stake(_depositor2, _amount2, _delegatee2);\n    UniStaker.Deposit memory _deposit1 = _fetchDeposit(_depositId1);\n    UniStaker.Deposit memory _deposit2 = _fetchDeposit(_depositId2);\n\n    // Check that the deposits have been recorded independently\n    assertEq(_deposit1.balance, _amount1);\n    assertEq(_deposit1.owner, _depositor1);\n    assertEq(_deposit1.delegatee, _delegatee1);\n    assertEq(_deposit2.balance, _amount2);\n    assertEq(_deposit2.owner, _depositor2);\n    assertEq(_deposit2.delegatee, _delegatee2);\n  }\n\n  function testFuzz_AssignsEarningPowerToDepositorIfNoBeneficiaryIsSpecified(\n    address _depositor,\n    uint256 _amount,\n    address _delegatee\n  ) public {\n    _amount = _boundMintAmount(_amount);\n    _mintGovToken(_depositor, _amount);\n\n    UniStaker.DepositIdentifier _depositId = _stake(_depositor, _amount, _delegatee);\n    UniStaker.Deposit memory _deposit = _fetchDeposit(_depositId);\n\n    assertEq(uniStaker.earningPower(_depositor), _amount);\n    assertEq(_deposit.beneficiary, _depositor);\n  }\n\n  function testFuzz_AssignsEarningPowerToTheBeneficiaryProvided(\n    address _depositor,\n    uint256 _amount,\n    address _delegatee,\n    address _beneficiary\n  ) public {\n    _amount = _boundMintAmount(_amount);\n    _mintGovToken(_depositor, _amount);\n\n    UniStaker.DepositIdentifier _depositId = _stake(_depositor, _amount, _delegatee, _beneficiary);\n    UniStaker.Deposit memory _deposit = _fetchDeposit(_depositId);\n\n    assertEq(uniStaker.earningPower(_beneficiary), _amount);\n    assertEq(_deposit.beneficiary, _beneficiary);\n  }\n\n  function testFuzz_AssignsEarningPowerToDifferentBeneficiariesForDifferentDepositsFromTheSameDepositor(\n    address _depositor,\n    uint256 _amount1,\n    uint256 _amount2,\n    address _delegatee,\n    address _beneficiary1,\n    address _beneficiary2\n  ) public {\n    vm.assume(_beneficiary1 != _beneficiary2);\n    _amount1 = _boundMintAmount(_amount1);\n    _amount2 = _boundMintAmount(_amount2);\n    _mintGovToken(_depositor, _amount1 + _amount2);\n\n    // Perform both deposits and track their identifiers separately\n    UniStaker.DepositIdentifier _depositId1 =\n      _stake(_depositor, _amount1, _delegatee, _beneficiary1);\n    UniStaker.DepositIdentifier _depositId2 =\n      _stake(_depositor, _amount2, _delegatee, _beneficiary2);\n    UniStaker.Deposit memory _deposit1 = _fetchDeposit(_depositId1);\n    UniStaker.Deposit memory _deposit2 = _fetchDeposit(_depositId2);\n\n    // Check that the earning power has been recorded independently\n    assertEq(_deposit1.beneficiary, _beneficiary1);\n    assertEq(uniStaker.earningPower(_beneficiary1), _amount1);\n    assertEq(_deposit2.beneficiary, _beneficiary2);\n    assertEq(uniStaker.earningPower(_beneficiary2), _amount2);\n  }\n\n  function testFuzz_AssignsEarningPowerToTheSameBeneficiarySpecifiedByTwoDifferentDepositors(\n    address _depositor1,\n    address _depositor2,\n    uint256 _amount1,\n    uint256 _amount2,\n    address _delegatee,\n    address _beneficiary\n  ) public {\n    _amount1 = _boundMintAmount(_amount1);\n    _amount2 = _boundMintAmount(_amount2);\n    _mintGovToken(_depositor1, _amount1);\n    _mintGovToken(_depositor2, _amount2);\n\n    // Perform both deposits and track their identifiers separately\n    UniStaker.DepositIdentifier _depositId1 =\n      _stake(_depositor1, _amount1, _delegatee, _beneficiary);\n    UniStaker.DepositIdentifier _depositId2 =\n      _stake(_depositor2, _amount2, _delegatee, _beneficiary);\n    UniStaker.Deposit memory _deposit1 = _fetchDeposit(_depositId1);\n    UniStaker.Deposit memory _deposit2 = _fetchDeposit(_depositId2);\n\n    assertEq(_deposit1.beneficiary, _beneficiary);\n    assertEq(_deposit2.beneficiary, _beneficiary);\n    assertEq(uniStaker.earningPower(_beneficiary), _amount1 + _amount2);\n  }\n\n  mapping(UniStaker.DepositIdentifier depositId => bool isUsed) isIdUsed;\n\n  function test_NeverReusesADepositIdentifier() public {\n    address _depositor = address(0xdeadbeef);\n    uint256 _amount = 116;\n    address _delegatee = address(0xaceface);\n\n    UniStaker.DepositIdentifier _depositId;\n\n    // Repeat the deposit over and over ensuring a new DepositIdentifier is assigned each time.\n    for (uint256 _i; _i < 5000; _i++) {\n      // Perform the stake and save the deposit identifier\n      _mintGovToken(_depositor, _amount);\n      _depositId = _stake(_depositor, _amount, _delegatee);\n\n      // Ensure the identifier hasn't yet been used\n      assertFalse(isIdUsed[_depositId]);\n      // Record the fact this deposit Id has been used\n      isIdUsed[_depositId] = true;\n    }\n\n    // Now make a bunch more deposits with different depositors and parameters, continuing to check\n    // that the DepositIdentifier is never reused.\n    for (uint256 _i; _i < 5000; _i++) {\n      // Perform the stake and save the deposit identifier\n      _amount = _bound(_amount, 0, 100_000_000_000e18);\n      _mintGovToken(_depositor, _amount);\n      _depositId = _stake(_depositor, _amount, _delegatee);\n\n      // Ensure the identifier hasn't yet been used\n      assertFalse(isIdUsed[_depositId]);\n      // Record the fact this deposit Id has been used\n      isIdUsed[_depositId] = true;\n\n      // Assign new inputs for the next deposit by hashing the last inputs\n      _depositor = address(uint160(uint256(keccak256(abi.encode(_depositor)))));\n      _amount = uint256(keccak256(abi.encode(_amount)));\n      _delegatee = address(uint160(uint256(keccak256(abi.encode(_delegatee)))));\n    }\n  }\n\n  function testFuzz_RevertIf_DelegateeIsTheZeroAddress(address _depositor, uint256 _amount) public {\n    _amount = _boundMintAmount(_amount);\n    _mintGovToken(_depositor, _amount);\n    govToken.approve(address(uniStaker), _amount);\n\n    vm.prank(_depositor);\n    vm.expectRevert(UniStaker.UniStaker__InvalidAddress.selector);\n    uniStaker.stake(_amount, address(0));\n  }\n\n  function testFuzz_RevertIf_BeneficiaryIsTheZeroAddress(\n    address _depositor,\n    uint256 _amount,\n    address _delegatee\n  ) public {\n    vm.assume(_delegatee != address(0));\n\n    _amount = _boundMintAmount(_amount);\n    _mintGovToken(_depositor, _amount);\n    govToken.approve(address(uniStaker), _amount);\n\n    vm.prank(_depositor);\n    vm.expectRevert(UniStaker.UniStaker__InvalidAddress.selector);\n    uniStaker.stake(_amount, _delegatee, address(0));\n  }\n}\n\ncontract PermitAndStake is UniStakerTest {\n  using stdStorage for StdStorage;\n\n  function testFuzz_PerformsTheApprovalByCallingPermitThenPerformsStake(\n    uint256 _depositorPrivateKey,\n    uint256 _depositAmount,\n    address _delegatee,\n    address _beneficiary,\n    uint256 _deadline,\n    uint256 _currentNonce\n  ) public {\n    vm.assume(_delegatee != address(0) && _beneficiary != address(0));\n    _deadline = bound(_deadline, block.timestamp + 1, type(uint256).max);\n    _depositorPrivateKey = bound(_depositorPrivateKey, 1, 100e18);\n    address _depositor = vm.addr(_depositorPrivateKey);\n    _depositAmount = _boundMintAmount(_depositAmount);\n    _mintGovToken(_depositor, _depositAmount);\n\n    stdstore.target(address(govToken)).sig(\"nonces(address)\").with_key(_depositor).checked_write(\n      _currentNonce\n    );\n\n    bytes32 _message = keccak256(\n      abi.encode(\n        PERMIT_TYPEHASH,\n        _depositor,\n        address(uniStaker),\n        _depositAmount,\n        govToken.nonces(_depositor),\n        _deadline\n      )\n    );\n\n    bytes32 _messageHash =\n      keccak256(abi.encodePacked(\"\\x19\\x01\", govToken.DOMAIN_SEPARATOR(), _message));\n    (uint8 _v, bytes32 _r, bytes32 _s) = vm.sign(_depositorPrivateKey, _messageHash);\n\n    vm.prank(_depositor);\n    UniStaker.DepositIdentifier _depositId =\n      uniStaker.permitAndStake(_depositAmount, _delegatee, _beneficiary, _deadline, _v, _r, _s);\n    UniStaker.Deposit memory _deposit = _fetchDeposit(_depositId);\n\n    assertEq(_deposit.balance, _depositAmount);\n    assertEq(_deposit.owner, _depositor);\n    assertEq(_deposit.delegatee, _delegatee);\n    assertEq(_deposit.beneficiary, _beneficiary);\n  }\n\n  function testFuzz_RevertIf_ThePermitSignatureIsInvalid(\n    address _notDepositor,\n    uint256 _depositorPrivateKey,\n    uint256 _depositAmount,\n    address _delegatee,\n    address _beneficiary,\n    uint256 _deadline\n  ) public {\n    vm.assume(_delegatee != address(0) && _beneficiary != address(0));\n    _deadline = bound(_deadline, block.timestamp + 1, type(uint256).max);\n    _depositorPrivateKey = bound(_depositorPrivateKey, 1, 100e18);\n    address _depositor = vm.addr(_depositorPrivateKey);\n    vm.assume(_notDepositor != _depositor);\n    _depositAmount = _boundMintAmount(_depositAmount);\n    _mintGovToken(_depositor, _depositAmount);\n\n    bytes32 _message = keccak256(\n      abi.encode(\n        PERMIT_TYPEHASH,\n        _notDepositor,\n        address(uniStaker),\n        _depositAmount,\n        govToken.nonces(_depositor),\n        _deadline\n      )\n    );\n\n    bytes32 _messageHash =\n      keccak256(abi.encodePacked(\"\\x19\\x01\", govToken.DOMAIN_SEPARATOR(), _message));\n    (uint8 _v, bytes32 _r, bytes32 _s) = vm.sign(_depositorPrivateKey, _messageHash);\n\n    vm.prank(_notDepositor);\n    vm.expectRevert(\n      abi.encodeWithSelector(ERC20Permit.ERC2612InvalidSigner.selector, _depositor, _notDepositor)\n    );\n    uniStaker.permitAndStake(_depositAmount, _delegatee, _beneficiary, _deadline, _v, _r, _s);\n  }\n}\n\ncontract StakeOnBehalf is UniStakerTest {\n  using stdStorage for StdStorage;\n\n  function testFuzz_StakesOnBehalfOfAnotherAccount(\n    uint256 _depositorPrivateKey,\n    address _sender,\n    uint256 _depositAmount,\n    address _delegatee,\n    address _beneficiary,\n    uint256 _currentNonce\n  ) public {\n    vm.assume(_delegatee != address(0) && _beneficiary != address(0) && _sender != address(0));\n    _depositorPrivateKey = bound(_depositorPrivateKey, 1, 100e18);\n    address _depositor = vm.addr(_depositorPrivateKey);\n    _depositAmount = _boundMintAmount(_depositAmount);\n    _mintGovToken(_depositor, _depositAmount);\n\n    stdstore.target(address(uniStaker)).sig(\"nonces(address)\").with_key(_depositor).checked_write(\n      _currentNonce\n    );\n\n    vm.prank(_depositor);\n    govToken.approve(address(uniStaker), _depositAmount);\n\n    bytes32 _message = keccak256(\n      abi.encode(\n        uniStaker.STAKE_TYPEHASH(),\n        _depositAmount,\n        _delegatee,\n        _beneficiary,\n        _depositor,\n        uniStaker.nonces(_depositor)\n      )\n    );\n\n    bytes32 _messageHash =\n      keccak256(abi.encodePacked(\"\\x19\\x01\", EIP712_DOMAIN_SEPARATOR, _message));\n    bytes memory _signature = _sign(_depositorPrivateKey, _messageHash);\n\n    vm.prank(_sender);\n    UniStaker.DepositIdentifier _depositId =\n      uniStaker.stakeOnBehalf(_depositAmount, _delegatee, _beneficiary, _depositor, _signature);\n\n    UniStaker.Deposit memory _deposit = _fetchDeposit(_depositId);\n\n    assertEq(_deposit.balance, _depositAmount);\n    assertEq(_deposit.owner, _depositor);\n    assertEq(_deposit.delegatee, _delegatee);\n    assertEq(_deposit.beneficiary, _beneficiary);\n  }\n\n  function testFuzz_RevertIf_WrongNonceIsUsed(\n    uint256 _depositorPrivateKey,\n    address _sender,\n    uint256 _depositAmount,\n    address _delegatee,\n    address _beneficiary,\n    uint256 _currentNonce,\n    uint256 _suppliedNonce\n  ) public {\n    vm.assume(_currentNonce != _suppliedNonce);\n    vm.assume(_delegatee != address(0) && _beneficiary != address(0) && _sender != address(0));\n    _depositorPrivateKey = bound(_depositorPrivateKey, 1, 100e18);\n    address _depositor = vm.addr(_depositorPrivateKey);\n    _depositAmount = _boundMintAmount(_depositAmount);\n    _mintGovToken(_depositor, _depositAmount);\n\n    stdstore.target(address(uniStaker)).sig(\"nonces(address)\").with_key(_depositor).checked_write(\n      _currentNonce\n    );\n\n    vm.prank(_depositor);\n    govToken.approve(address(uniStaker), _depositAmount);\n\n    bytes32 _message = keccak256(\n      abi.encode(\n        uniStaker.STAKE_TYPEHASH(),\n        _depositAmount,\n        _delegatee,\n        _beneficiary,\n        _depositor,\n        _suppliedNonce\n      )\n    );\n\n    bytes32 _messageHash =\n      keccak256(abi.encodePacked(\"\\x19\\x01\", EIP712_DOMAIN_SEPARATOR, _message));\n    bytes memory _signature = _sign(_depositorPrivateKey, _messageHash);\n\n    vm.expectRevert(UniStaker.UniStaker__InvalidSignature.selector);\n    vm.prank(_sender);\n    uniStaker.stakeOnBehalf(_depositAmount, _delegatee, _beneficiary, _depositor, _signature);\n  }\n\n  function testFuzz_RevertIf_InvalidSignatureIsPassed(\n    uint256 _depositorPrivateKey,\n    address _sender,\n    uint256 _depositAmount,\n    address _delegatee,\n    address _beneficiary,\n    uint256 _currentNonce,\n    uint256 _randomSeed\n  ) public {\n    vm.assume(_delegatee != address(0) && _beneficiary != address(0));\n    _depositorPrivateKey = bound(_depositorPrivateKey, 1, 100e18);\n    address _depositor = vm.addr(_depositorPrivateKey);\n    stdstore.target(address(uniStaker)).sig(\"nonces(address)\").with_key(_depositor).checked_write(\n      _currentNonce\n    );\n    _depositAmount = _boundMintAmount(_depositAmount);\n    _mintGovToken(_depositor, _depositAmount);\n\n    vm.prank(_depositor);\n    govToken.approve(address(uniStaker), _depositAmount);\n\n    bytes32 _message = keccak256(\n      abi.encode(\n        uniStaker.STAKE_TYPEHASH(),\n        _depositAmount,\n        _delegatee,\n        _beneficiary,\n        _depositor,\n        uniStaker.nonces(_depositor)\n      )\n    );\n\n    bytes32 _messageHash =\n      keccak256(abi.encodePacked(\"\\x19\\x01\", EIP712_DOMAIN_SEPARATOR, _message));\n\n    // Here we use `_randomSeed` as an arbitrary source of randomness to replace a legit parameter\n    // with an attack-like one.\n    if (_randomSeed % 5 == 0) {\n      _depositAmount = uint256(keccak256(abi.encode(_depositAmount)));\n    } else if (_randomSeed % 5 == 1) {\n      _delegatee = address(uint160(uint256(keccak256(abi.encode(_delegatee)))));\n    } else if (_randomSeed % 5 == 2) {\n      _depositor = address(uint160(uint256(keccak256(abi.encode(_depositor)))));\n    } else if (_randomSeed % 5 == 3) {\n      _messageHash = _modifyMessage(_messageHash, uint256(k"
    }
  ]
}