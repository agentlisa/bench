{
  "Title": "[M-09] User collateral NFT open auctions would be sold as min price immediately next time user health factor gets below the liquidation threshold, protocol should check health factor and set auctionValidityTime value anytime a valid action happens to user account to invalidate old open auctions",
  "Content": "\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/pool/DefaultReserveAuctionStrategy.sol#L90-L135><br>\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/tokenization/libraries/MintableERC721Logic.sol#L424-L434>\n\nAttacker can liquidate users NFT collaterals with min price immediately after user health factor gets below the liquidation threshold for NFT collaterals that have old open auctions and `setAuctionValidityTime()` is not get called for the user. Whenever user's account health factor gets below the NFT liquidation threshold attacker can start auction for all of users NFTs in the protocol. User needs to call `setAuctionValidityTime()` to invalidated all of those open auctions whenever his/her account health factor is good, but if user doesn't call this and doesn't close those auctions then next time user's accounts health factor gets below the threshold, attacker would liquidate all of those NFTs with minimum price immediately.\n\n### Proof of Concept\n\nThis is `calculateAuctionPriceMultiplier()` code in DefaultReserveAuctionStrategy:\n\n        function calculateAuctionPriceMultiplier(\n            uint256 auctionStartTimestamp,\n            uint256 currentTimestamp\n        ) external view override returns (uint256) {\n            uint256 ticks = PRBMathUD60x18.div(\n                currentTimestamp - auctionStartTimestamp,\n                _tickLength\n            );\n            return _calculateAuctionPriceMultiplierByTicks(ticks);\n        }\n\n        function _calculateAuctionPriceMultiplierByTicks(uint256 ticks)\n            internal\n            view\n            returns (uint256)\n        {\n            if (ticks < PRBMath.SCALE) {\n                return _maxPriceMultiplier;\n            }\n\n            uint256 ticksMinExp = PRBMathUD60x18.div(\n                (PRBMathUD60x18.ln(_maxPriceMultiplier) -\n                    PRBMathUD60x18.ln(_minExpPriceMultiplier)),\n                _stepExp\n            );\n            if (ticks <= ticksMinExp) {\n                return\n                    PRBMathUD60x18.div(\n                        _maxPriceMultiplier,\n                        PRBMathUD60x18.exp(_stepExp.mul(ticks))\n                    );\n            }\n\n            uint256 priceMinExpEffective = PRBMathUD60x18.div(\n                _maxPriceMultiplier,\n                PRBMathUD60x18.exp(_stepExp.mul(ticksMinExp))\n            );\n            uint256 ticksMin = ticksMinExp +\n                (priceMinExpEffective - _minPriceMultiplier).div(_stepLinear);\n\n            if (ticks <= ticksMin) {\n                return priceMinExpEffective - _stepLinear.mul(ticks - ticksMinExp);\n            }\n\n            return _minPriceMultiplier;\n        }\n\nAs you can see when long times passed from auction start time the price of auction would be minimum.<br>\nThis is `isAuctioned()` code in MintableERC721Data contract:\n\n```\n\n    function isAuctioned(\n        MintableERC721Data storage erc721Data,\n        IPool POOL,\n        uint256 tokenId\n    ) public view returns (bool) {\n        return\n            erc721Data.auctions[tokenId].startTime >\n            POOL\n                .getUserConfiguration(erc721Data.owners[tokenId])\n                .auctionValidityTime;\n    }\n```\n\nAs you can see auction is valid if startTime is bigger than user's `auctionValidityTime`. but the value of `auctionValidityTime` should be set manually by calling `PoolParameters.setAuctionValidityTime()`, so by default auction would stay open. imagine this scenario:\n\n1.  user NFT health factor gets under the liquidation threshold.\n2.  attacker calls `startAuction()` for all user collateral NFT tokens.\n3.  user supply some collateral and his health factor become good.\n4.  some time passes and user NFT health factor gets under the liquidation threshold.\n5.  attacker can liquidate all of user NFT collateral with minimum price of auction immediately.\n6.  user would lose his NFTs without proper auction.\n\nThis scenario can be common because liquidation and health factor changes happens on-chain and most of the user isn't always watches his account health factor and he wouldn't know when his account health factor gets below the liquidation threshold and when it's needed for him to call `setAuctionValidityTime()`. so over time this would happen to more users.\n\n### Tools Used\n\nVIM\n\n### Recommended Mitigation Steps\n\nContract should check and set the value of `auctionValidityTime` for user whenever an action happens to user account.<br>\nAlso there should be some incentive mechanism for anyone starting or ending an auction.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-11-paraspace-contest",
  "Code": [
    {
      "filename": "paraspace-core/contracts/protocol/pool/DefaultReserveAuctionStrategy.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {IERC20} from \"../../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport {WadRayMath} from \"../libraries/math/WadRayMath.sol\";\nimport {PercentageMath} from \"../libraries/math/PercentageMath.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {IReserveAuctionStrategy} from \"../../interfaces/IReserveAuctionStrategy.sol\";\nimport {IPoolAddressesProvider} from \"../../interfaces/IPoolAddressesProvider.sol\";\nimport {IToken} from \"../../interfaces/IToken.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {PRBMathUD60x18} from \"../../dependencies/math/PRBMathUD60x18.sol\";\nimport {PRBMath} from \"../../dependencies/math/PRBMath.sol\";\n\n/**\n * @title DefaultReserveAuctionStrategy contract\n *\n * @notice Implements the calculation of the current dutch auction price\n **/\ncontract DefaultReserveAuctionStrategy is IReserveAuctionStrategy {\n    using PRBMathUD60x18 for uint256;\n\n    /**\n     * Expressed in PRBMath.SCALE\n     **/\n    uint256 internal immutable _maxPriceMultiplier;\n\n    /**\n     * Expressed in PRBMath.SCALE\n     **/\n    uint256 internal immutable _minExpPriceMultiplier;\n\n    /**\n     * Expressed in PRBMath.SCALE\n     **/\n    uint256 internal immutable _minPriceMultiplier;\n\n    /**\n     * Expressed in PRBMath.SCALE\n     **/\n    uint256 internal immutable _stepLinear;\n\n    /**\n     * Expressed in PRBMath.SCALE\n     **/\n    uint256 internal immutable _stepExp;\n\n    uint256 internal immutable _tickLength;\n\n    constructor(\n        uint256 maxPriceMultiplier,\n        uint256 minExpPriceMultiplier,\n        uint256 minPriceMultiplier,\n        uint256 stepLinear,\n        uint256 stepExp,\n        uint256 tickLength\n    ) {\n        _maxPriceMultiplier = maxPriceMultiplier;\n        _minExpPriceMultiplier = minExpPriceMultiplier;\n        _minPriceMultiplier = minPriceMultiplier;\n        _stepLinear = stepLinear;\n        _stepExp = stepExp;\n        _tickLength = tickLength;\n    }\n\n    function getMaxPriceMultiplier() external view returns (uint256) {\n        return _maxPriceMultiplier;\n    }\n\n    function getMinExpPriceMultiplier() external view returns (uint256) {\n        return _minExpPriceMultiplier;\n    }\n\n    function getMinPriceMultiplier() external view returns (uint256) {\n        return _minPriceMultiplier;\n    }\n\n    function getStepLinear() external view returns (uint256) {\n        return _stepLinear;\n    }\n\n    function getStepExp() external view returns (uint256) {\n        return _stepExp;\n    }\n\n    function getTickLength() external view returns (uint256) {\n        return _tickLength;\n    }\n\n    function calculateAuctionPriceMultiplier(\n        uint256 auctionStartTimestamp,\n        uint256 currentTimestamp\n    ) external view override returns (uint256) {\n        uint256 ticks = PRBMathUD60x18.div(\n            currentTimestamp - auctionStartTimestamp,\n            _tickLength\n        );\n        return _calculateAuctionPriceMultiplierByTicks(ticks);\n    }\n\n    function _calculateAuctionPriceMultiplierByTicks(uint256 ticks)\n        internal\n        view\n        returns (uint256)\n    {\n        if (ticks < PRBMath.SCALE) {\n            return _maxPriceMultiplier;\n        }\n\n        uint256 ticksMinExp = PRBMathUD60x18.div(\n            (PRBMathUD60x18.ln(_maxPriceMultiplier) -\n                PRBMathUD60x18.ln(_minExpPriceMultiplier)),\n            _stepExp\n        );\n        if (ticks <= ticksMinExp) {\n            return\n                PRBMathUD60x18.div(\n                    _maxPriceMultiplier,\n                    PRBMathUD60x18.exp(_stepExp.mul(ticks))\n                );\n        }\n\n        uint256 priceMinExpEffective = PRBMathUD60x18.div(\n            _maxPriceMultiplier,\n            PRBMathUD60x18.exp(_stepExp.mul(ticksMinExp))\n        );\n        uint256 ticksMin = ticksMinExp +\n            (priceMinExpEffective - _minPriceMultiplier).div(_stepLinear);\n\n        if (ticks <= ticksMin) {\n            return priceMinExpEffective - _stepLinear.mul(ticks - ticksMinExp);\n        }\n\n        return _minPriceMultiplier;\n    }\n}"
    },
    {
      "filename": "paraspace-core/contracts/protocol/tokenization/libraries/MintableERC721Logic.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\nimport {ApeCoinStaking} from \"../../../dependencies/yoga-labs/ApeCoinStaking.sol\";\nimport {IERC721} from \"../../../dependencies/openzeppelin/contracts/IERC721.sol\";\nimport {SafeERC20} from \"../../../dependencies/openzeppelin/contracts/SafeERC20.sol\";\nimport {IERC20} from \"../../../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport \"../../../interfaces/IRewardController.sol\";\nimport \"../../libraries/types/DataTypes.sol\";\nimport \"../../../interfaces/IPool.sol\";\nimport {Errors} from \"../../libraries/helpers/Errors.sol\";\n\nstruct UserState {\n    uint64 balance;\n    uint64 collateralizedBalance;\n    uint128 additionalData;\n}\n\nstruct MintableERC721Data {\n    // Token name\n    string name;\n    // Token symbol\n    string symbol;\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) owners;\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) ownedTokens;\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) ownedTokensIndex;\n    // Array with all token ids, used for enumeration\n    uint256[] allTokens;\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) allTokensIndex;\n    // Map of users address and their state data (userAddress => userStateData)\n    mapping(address => UserState) userState;\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) tokenApprovals;\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) operatorApprovals;\n    // Map of allowances (delegator => delegatee => allowanceAmount)\n    mapping(address => mapping(address => uint256)) allowances;\n    IRewardController rewardController;\n    uint64 balanceLimit;\n    mapping(uint256 => bool) isUsedAsCollateral;\n    mapping(uint256 => DataTypes.Auction) auctions;\n}\n\n/**\n * @title MintableERC721 library\n *\n * @notice Implements the base logic for MintableERC721\n */\nlibrary MintableERC721Logic {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    function executeTransfer(\n        MintableERC721Data storage erc721Data,\n        IPool POOL,\n        bool ATOMIC_PRICING,\n        address from,\n        address to,\n        uint256 tokenId\n    ) public {\n        require(\n            erc721Data.owners[tokenId] == from,\n            \"ERC721: transfer from incorrect owner\"\n        );\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n        require(\n            !isAuctioned(erc721Data, POOL, tokenId),\n            Errors.TOKEN_IN_AUCTION\n        );\n\n        _beforeTokenTransfer(erc721Data, from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(erc721Data, address(0), tokenId);\n\n        uint64 oldSenderBalance = erc721Data.userState[from].balance;\n        erc721Data.userState[from].balance = oldSenderBalance - 1;\n        uint64 oldRecipientBalance = erc721Data.userState[to].balance;\n        uint64 newRecipientBalance = oldRecipientBalance + 1;\n        _checkBalanceLimit(erc721Data, ATOMIC_PRICING, newRecipientBalance);\n        erc721Data.userState[to].balance = newRecipientBalance;\n        erc721Data.owners[tokenId] = to;\n\n        if (from != to && erc721Data.auctions[tokenId].startTime > 0) {\n            delete erc721Data.auctions[tokenId];\n        }\n\n        IRewardController rewardControllerLocal = erc721Data.rewardController;\n        if (address(rewardControllerLocal) != address(0)) {\n            uint256 oldTotalSupply = erc721Data.allTokens.length;\n            rewardControllerLocal.handleAction(\n                from,\n                oldTotalSupply,\n                oldSenderBalance\n            );\n            if (from != to) {\n                rewardControllerLocal.handleAction(\n                    to,\n                    oldTotalSupply,\n                    oldRecipientBalance\n                );\n            }\n        }\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    function executeTransferCollateralizable(\n        MintableERC721Data storage erc721Data,\n        IPool POOL,\n        bool ATOMIC_PRICING,\n        address from,\n        address to,\n        uint256 tokenId\n    ) external returns (bool isUsedAsCollateral_) {\n        isUsedAsCollateral_ = erc721Data.isUsedAsCollateral[tokenId];\n\n        if (from != to && isUsedAsCollateral_) {\n            erc721Data.userState[from].collateralizedBalance -= 1;\n            delete erc721Data.isUsedAsCollateral[tokenId];\n        }\n\n        executeTransfer(erc721Data, POOL, ATOMIC_PRICING, from, to, tokenId);\n    }\n\n    function executeSetIsUsedAsCollateral(\n        MintableERC721Data storage erc721Data,\n        IPool POOL,\n        uint256 tokenId,\n        bool useAsCollateral,\n        address sender\n    ) internal returns (bool) {\n        if (erc721Data.isUsedAsCollateral[tokenId] == useAsCollateral)\n            return false;\n\n        address owner = erc721Data.owners[tokenId];\n        require(owner == sender, \"not owner\");\n\n        if (!useAsCollateral) {\n            require(\n                !isAuctioned(erc721Data, POOL, tokenId),\n                Errors.TOKEN_IN_AUCTION\n            );\n        }\n\n        uint64 collateralizedBalance = erc721Data\n            .userState[owner]\n            .collateralizedBalance;\n        erc721Data.isUsedAsCollateral[tokenId] = useAsCollateral;\n        collateralizedBalance = useAsCollateral\n            ? collateralizedBalance + 1\n            : collateralizedBalance - 1;\n        erc721Data\n            .userState[owner]\n            .collateralizedBalance = collateralizedBalance;\n\n        return true;\n    }\n\n    function executeMintMultiple(\n        MintableERC721Data storage erc721Data,\n        bool ATOMIC_PRICING,\n        address to,\n        DataTypes.ERC721SupplyParams[] calldata tokenData\n    )\n        external\n        returns (\n            uint64 oldCollateralizedBalance,\n            uint64 newCollateralizedBalance\n        )\n    {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        uint64 oldBalance = erc721Data.userState[to].balance;\n        oldCollateralizedBalance = erc721Data\n            .userState[to]\n            .collateralizedBalance;\n        uint256 oldTotalSupply = erc721Data.allTokens.length;\n        uint64 collateralizedTokens = 0;\n\n        for (uint256 index = 0; index < tokenData.length; index++) {\n            uint256 tokenId = tokenData[index].tokenId;\n\n            require(\n                !_exists(erc721Data, tokenId),\n                \"ERC721: token already minted\"\n            );\n\n            _addTokenToAllTokensEnumeration(\n                erc721Data,\n                tokenId,\n                oldTotalSupply + index\n            );\n            _addTokenToOwnerEnumeration(\n                erc721Data,\n                to,\n                tokenId,\n                oldBalance + index\n            );\n\n            erc721Data.owners[tokenId] = to;\n\n            if (\n                tokenData[index].useAsCollateral &&\n                !erc721Data.isUsedAsCollateral[tokenId]\n            ) {\n                erc721Data.isUsedAsCollateral[tokenId] = true;\n                collateralizedTokens++;\n            }\n\n            emit Transfer(address(0), to, tokenId);\n        }\n\n        newCollateralizedBalance =\n            oldCollateralizedBalance +\n            collateralizedTokens;\n        erc721Data\n            .userState[to]\n            .collateralizedBalance = newCollateralizedBalance;\n\n        uint64 newBalance = oldBalance + uint64(tokenData.length);\n        _checkBalanceLimit(erc721Data, ATOMIC_PRICING, newBalance);\n        erc721Data.userState[to].balance = newBalance;\n\n        // calculate incentives\n        IRewardController rewardControllerLocal = erc721Data.rewardController;\n        if (address(rewardControllerLocal) != address(0)) {\n            rewardControllerLocal.handleAction(to, oldTotalSupply, oldBalance);\n        }\n\n        return (oldCollateralizedBalance, newCollateralizedBalance);\n    }\n\n    function executeBurnMultiple(\n        MintableERC721Data storage erc721Data,\n        IPool POOL,\n        address user,\n        uint256[] calldata tokenIds\n    )\n        external\n        returns (\n            uint64 oldCollateralizedBalance,\n            uint64 newCollateralizedBalance\n        )\n    {\n        uint64 burntCollateralizedTokens = 0;\n        uint64 balanceToBurn;\n        uint256 oldTotalSupply = erc721Data.allTokens.length;\n        uint256 oldBalance = erc721Data.userState[user].balance;\n        oldCollateralizedBalance = erc721Data\n            .userState[user]\n            .collateralizedBalance;\n\n        for (uint256 index = 0; index < tokenIds.length; index++) {\n            uint256 tokenId = tokenIds[index];\n            address owner = erc721Data.owners[tokenId];\n            require(owner == user, \"not the owner of Ntoken\");\n            require(\n                !isAuctioned(erc721Data, POOL, tokenId),\n                Errors.TOKEN_IN_AUCTION\n            );\n\n            _removeTokenFromAllTokensEnumeration(\n                erc721Data,\n                tokenId,\n                oldTotalSupply - index\n            );\n            _removeTokenFromOwnerEnumeration(\n                erc721Data,\n                user,\n                tokenId,\n                oldBalance - index\n            );\n\n            // Clear approvals\n            _approve(erc721Data, address(0), tokenId);\n\n            balanceToBurn++;\n            delete erc721Data.owners[tokenId];\n\n            if (erc721Data.auctions[tokenId].startTime > 0) {\n                delete erc721Data.auctions[tokenId];\n            }\n\n            if (erc721Data.isUsedAsCollateral[tokenId]) {\n                delete erc721Data.isUsedAsCollateral[tokenId];\n                burntCollateralizedTokens++;\n            }\n            emit Transfer(owner, address(0), tokenId);\n        }\n\n        erc721Data.userState[user].balance -= balanceToBurn;\n        newCollateralizedBalance =\n            oldCollateralizedBalance -\n            burntCollateralizedTokens;\n        erc721Data\n            .userState[user]\n            .collateralizedBalance = newCollateralizedBalance;\n\n        // calculate incentives\n        IRewardController rewardControllerLocal = erc721Data.rewardController;\n\n        if (address(rewardControllerLocal) != address(0)) {\n            rewardControllerLocal.handleAction(\n                user,\n                oldTotalSupply,\n                oldBalance\n            );\n        }\n\n        return (oldCollateralizedBalance, newCollateralizedBalance);\n    }\n\n    function executeApprove(\n        MintableERC721Data storage erc721Data,\n        address to,\n        uint256 tokenId\n    ) external {\n        _approve(erc721Data, to, tokenId);\n    }\n\n    function _approve(\n        MintableERC721Data storage erc721Data,\n        address to,\n        uint256 tokenId\n    ) private {\n        erc721Data.tokenApprovals[tokenId] = to;\n        emit Approval(erc721Data.owners[tokenId], to, tokenId);\n    }\n\n    function executeApprovalForAll(\n        MintableERC721Data storage erc721Data,\n        address owner,\n        address operator,\n        bool approved\n    ) external {\n        require(owner != operator, \"ERC721: approve to caller\");\n        erc721Data.operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    function executeStartAuction(\n        MintableERC721Data storage erc721Data,\n        IPool POOL,\n        uint256 tokenId\n    ) external {\n        require(\n            !isAuctioned(erc721Data, POOL, tokenId),\n            Errors.AUCTION_ALREADY_STARTED\n        );\n        require(\n            _exists(erc721Data, tokenId),\n            \"ERC721: startAuction for nonexistent token\"\n        );\n        erc721Data.auctions[tokenId] = DataTypes.Auction({\n            startTime: block.timestamp\n        });\n    }\n\n    function executeEndAuction(\n        MintableERC721Data storage erc721Data,\n        IPool POOL,\n        uint256 tokenId\n    ) external {\n        require(\n            isAuctioned(erc721Data, POOL, tokenId),\n            Errors.AUCTION_NOT_STARTED\n        );\n        require(\n            _exists(erc721Data, tokenId),\n            \"ERC721: endAuction for nonexistent token\"\n        );\n        delete erc721Data.auctions[tokenId];\n    }\n\n    function _checkBalanceLimit(\n        MintableERC721Data storage erc721Data,\n        bool ATOMIC_PRICING,\n        uint64 balance\n    ) private view {\n        if (ATOMIC_PRICING) {\n            uint64 balanceLimit = erc721Data.balanceLimit;\n            require(\n                balanceLimit == 0 || balance <= balanceLimit,\n                Errors.NTOKEN_BALANCE_EXCEEDED\n            );\n        }\n    }\n\n    function _exists(MintableERC721Data storage erc721Data, uint256 tokenId)\n        private\n        view\n        returns (bool)\n    {\n        return erc721Data.owners[tokenId] != address(0);\n    }\n\n    function isAuctioned(\n        MintableERC721Data storage erc721Data,\n        IPool POOL,\n        uint256 tokenId\n    ) public view returns (bool) {\n        return\n            erc721Data.auctions[tokenId].startTime >\n            POOL\n                .getUserConfiguration(erc721Data.owners[tokenId])\n                .auctionValidityTime;\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        MintableERC721Data storage erc721Data,\n        address from,\n        address to,\n        uint256 tokenId\n    ) private {\n        if (from == address(0)) {\n            uint256 length = erc721Data.allTokens.length;\n            _addTokenToAllTokensEnumeration(erc721Data, tokenId, length);\n        } else if (from != to) {\n            uint256 userBalance = erc721Data.userState[from].balance;\n            _removeTokenFromOwnerEnumeration(\n                erc721Data,\n                from,\n                tokenId,\n                userBalance\n            );\n        }\n        if (to == address(0)) {\n            uint256 length = erc721Data.allTokens.length;\n            _removeTokenFromAllTokensEnumeration(erc721Data, tokenId, length);\n        } else if (to != from) {\n            uint256 length = erc721Data.userState[to].balance;\n            _addTokenToOwnerEnumeration(erc721Data, to, tokenId, length);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(\n        MintableERC721Data storage erc721Data,\n        address to,\n        uint256 tokenId,\n        uint256 length\n    ) private {\n        erc721Data.ownedTokens[to][length] = tokenId;\n        erc721Data.ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(\n        MintableERC721Data storage erc721Data,\n        uint256 tokenId,\n        uint256 length\n    ) private {\n        erc721Data.allTokensIndex[tokenId] = length;\n        erc721Data.allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(\n        MintableERC721Data storage erc721Data,\n        address from,\n        uint256 tokenId,\n        uint256 userBalance\n    ) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = userBalance - 1;\n        uint256 tokenIndex = erc721Data.ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = erc721Data.ownedTokens[from][lastTokenIndex];\n\n            erc721Data.ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            erc721Data.ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete erc721Data.ownedTokensIndex[tokenId];\n        delete erc721Data.ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(\n        MintableERC721Data storage erc721Data,\n        uint256 tokenId,\n        uint256 length\n    ) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = length - 1;\n        uint256 tokenIndex = erc721Data.allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = erc721Data.allTokens[lastTokenIndex];\n\n        erc721Data.allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        erc721Data.allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete erc721Data.allTokensIndex[tokenId];\n        erc721Data.allTokens.pop();\n    }\n}"
    }
  ]
}