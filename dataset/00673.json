{
  "Title": "Multiple CNCMintingRebalancingRewardsHandler can break the targeted CNC TotalSupply distribution",
  "Content": "##### Description\n\nThe TotalSupply is strictly capped with 10 mln tokens with zero mints if trying to mint above this value.\n- https://github.com/ConicFinance/protocol/blob/7a66d26ef84f93059a811a189655e17c11d95f5c/contracts/tokenomics/CNCToken.sol#L30\n\nBut `InflationManager` does not control the whole inflation.\nIn fact, there can be many `CNCMintingRebalancingRewardsHandler` contracts, each with custom `_MAX_REBALANCING_REWARDS`.\n\nThere are a few evidences that there can be many `CNCMintingRebalancingRewardsHandler` contracts:\n- https://github.com/ConicFinance/protocol/blob/7a66d26ef84f93059a811a189655e17c11d95f5c/contracts/tokenomics/InflationManager.sol#L126\n- https://github.com/ConicFinance/protocol/blob/7a66d26ef84f93059a811a189655e17c11d95f5c/contracts/tokenomics/InflationManager.sol#L162-L167\n\nAs a result, it is a risk that some new `CNCMintingRebalancingRewardsHandler` can break the targeted total supply structure.\n\nIn addition, all current minters sum up to 100%:\n1) 25% InflationManager (LPTokenStaker)\nhttps://github.com/ConicFinance/protocol/blob/7a66d26ef84f93059a811a189655e17c11d95f5c/contracts/tokenomics/InflationManager.sol#L24-L26\n2) 56% PreMint, Treasury, Airdrop\nhttps://github.com/ConicFinance/protocol/blob/7a66d26ef84f93059a811a189655e17c11d95f5c/contracts/tokenomics/CNCToken.sol#L18-L22\n3) 19% one RebalancingHandler\nhttps://github.com/ConicFinance/protocol/blob/7a66d26ef84f93059a811a189655e17c11d95f5c/contracts/tokenomics/CNCMintingRebalancingRewardsHandler.sol#L28\n\nSo, there is no place for additional RebalancingHandlers.\n\n##### Recommendation\n\nWe recommend removing the logic allowing multiple RebalancingHandlers.\nIf it is necessary, we recommend using `CNCToken.inflationMintedRatio()` as a limitation and an estimation for a correct minting amount allowed to all RebalancingHandlers.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/tokenomics/CNCToken.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport \"../../libraries/ScaledMath.sol\";\nimport \"../../interfaces/tokenomics/ICNCToken.sol\";\n\n/// @notice the deployer will initially have minting rights\n/// The process will be to premint `PRE_MINT_RATIO` of `MAX_TOTAL_SUPPLY`\n/// to the initial distribution address, grant the minting rights to the inflation manager\n/// and renounce its minting rights\ncontract CNCToken is ICNCToken, ERC20 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using ScaledMath for uint256;\n\n    uint256 public constant PRE_MINT_RATIO = 0.3e18;\n    uint256 public constant AIRDROP_MINT_RATIO = 0.1e18;\n    uint256 public constant AMM_REWARDS_RATIO = 0.1e18;\n    uint256 public constant TREASURY_REWARDS_RATIO = 0.05e18;\n    uint256 public constant TREASURY_SEED_RATIO = 0.01e18;\n    uint256 public constant INFLATION_RATIO =\n        1e18 -\n            AMM_REWARDS_RATIO -\n            AIRDROP_MINT_RATIO -\n            PRE_MINT_RATIO -\n            TREASURY_REWARDS_RATIO -\n            TREASURY_SEED_RATIO;\n    uint256 public constant MAX_TOTAL_SUPPLY = 10_000_000e18;\n\n    EnumerableSet.AddressSet internal authorizedMinters;\n\n    bool public initialDistributionMintDone;\n    bool public airdropMintDone;\n    bool public ammGaugeMintDone;\n    bool public treasuryMintDone;\n    bool public seedShareMintDone;\n\n    modifier onlyMinter() {\n        require(authorizedMinters.contains(msg.sender), \"not authorized\");\n        _;\n    }\n\n    constructor() ERC20(\"Conic Finance Token\", \"CNC\") {\n        authorizedMinters.add(msg.sender);\n        emit MinterAdded(msg.sender);\n    }\n\n    function addMinter(address newMinter) external onlyMinter {\n        if (authorizedMinters.add(newMinter)) {\n            emit MinterAdded(newMinter);\n        }\n    }\n\n    function renounceMinterRights() external onlyMinter {\n        authorizedMinters.remove(msg.sender);\n        emit MinterRemoved(msg.sender);\n    }\n\n    function mintInitialDistribution(address distribution) external onlyMinter {\n        require(!initialDistributionMintDone, \"premint already done\");\n        uint256 mintAmount = MAX_TOTAL_SUPPLY.mulDown(PRE_MINT_RATIO);\n        _mint(distribution, mintAmount);\n        initialDistributionMintDone = true;\n        emit InitialDistributionMinted(mintAmount);\n    }\n\n    function mintAirdrop(address airdropHandler) external onlyMinter {\n        require(!airdropMintDone, \"airdrop already done\");\n        uint256 mintAmount = MAX_TOTAL_SUPPLY.mulDown(AIRDROP_MINT_RATIO);\n        _mint(airdropHandler, mintAmount);\n        airdropMintDone = true;\n        emit AirdropMinted(mintAmount);\n    }\n\n    function mintAMMRewards(address ammGauge) external onlyMinter {\n        require(!ammGaugeMintDone, \"amm rewards already minted\");\n        uint256 mintAmount = MAX_TOTAL_SUPPLY.mulDown(AMM_REWARDS_RATIO);\n        _mint(ammGauge, mintAmount);\n        ammGaugeMintDone = true;\n        emit AMMRewardsMinted(mintAmount);\n    }\n\n    function mintTreasuryShare(address treasuryEscrow) external onlyMinter {\n        require(!treasuryMintDone, \"treasury rewards already minted\");\n        uint256 mintAmount = MAX_TOTAL_SUPPLY.mulDown(TREASURY_REWARDS_RATIO);\n        _mint(treasuryEscrow, mintAmount);\n        treasuryMintDone = true;\n        emit TreasuryRewardsMinted(mintAmount);\n    }\n\n    function mintSeedShare(address treasury) external onlyMinter {\n        require(!seedShareMintDone, \"seed share already minted\");\n        uint256 mintAmount = MAX_TOTAL_SUPPLY.mulDown(TREASURY_SEED_RATIO);\n        _mint(treasury, mintAmount);\n        seedShareMintDone = true;\n        emit SeedShareMinted(mintAmount);\n    }\n\n    function mint(address account, uint256 amount) external onlyMinter returns (uint256) {\n        uint256 currentSupply = totalSupply();\n        if (amount + currentSupply > MAX_TOTAL_SUPPLY) {\n            amount = MAX_TOTAL_SUPPLY - currentSupply;\n        }\n        if (amount > 0) {\n            _mint(account, amount);\n        }\n        return amount;\n    }\n\n    /// @dev this assumes that all the pre-mint events occured\n    function inflationMintedRatio() external view returns (uint256) {\n        uint256 currentSupply = totalSupply();\n        uint256 totalToMint = MAX_TOTAL_SUPPLY.mulDown(INFLATION_RATIO);\n        uint256 totalPreMinted = MAX_TOTAL_SUPPLY - totalToMint;\n        uint256 totalInflationMinted = currentSupply - totalPreMinted;\n        return totalInflationMinted.divDown(totalToMint);\n    }\n\n    function listMinters() external view returns (address[] memory) {\n        return authorizedMinters.values();\n    }\n}"
    },
    {
      "filename": "contracts/tokenomics/InflationManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport \"../../interfaces/tokenomics/IRebalancingRewardsHandler.sol\";\nimport \"../../interfaces/tokenomics/IInflationManager.sol\";\nimport \"../../interfaces/IController.sol\";\nimport \"../../interfaces/tokenomics/ICNCToken.sol\";\nimport \"../../interfaces/pools/IConicPool.sol\";\nimport \"../../interfaces/pools/ILpToken.sol\";\n\nimport \"../../libraries/ScaledMath.sol\";\n\ncontract InflationManager is IInflationManager, Ownable {\n    using ScaledMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    ICNCToken public constant CNC = ICNCToken(0x9aE380F0272E2162340a5bB646c354271c0F5cFC);\n\n    IController public immutable controller;\n\n    uint256 internal constant _INITIAL_INFLATION_RATE = 1_500_000 * 1e18;\n    uint256 internal constant _INFLATION_RATE_DECAY = 0.3999999 * 1e18;\n    uint256 internal constant _INFLATION_RATE_PERIOD = 365 days;\n\n    /// @dev mapping from conic pool to their rebalancing reward handlers\n    mapping(address => EnumerableSet.AddressSet) internal _rebalancingRewardHandlers;\n\n    uint256 public override currentInflationRate;\n    uint256 public lastInflationRateDecay;\n    uint256 public lastUpdate;\n    uint256 public totalLpInflationMinted;\n\n    mapping(address => uint256) public currentPoolWeights;\n\n    constructor(address _controller) Ownable() {\n        require(_controller != address(0), \"Cannot use zero address for controller\");\n        controller = IController(_controller);\n\n        currentInflationRate = _INITIAL_INFLATION_RATE / _INFLATION_RATE_PERIOD;\n        lastUpdate = block.timestamp;\n        lastInflationRateDecay = block.timestamp;\n    }\n\n    /// @notice returns the weights of the Conic pools to know how much inflation\n    /// each of them will receive. totalUSDValue only accounts for funds in active pools\n    function computePoolWeights()\n        public\n        view\n        override\n        returns (address[] memory pools, uint256[] memory poolWeights, uint256 totalUSDValue)\n    {\n        IOracle oracle = controller.priceOracle();\n        pools = controller.listPools();\n        uint256[] memory poolUSDValues = new uint256[](pools.length);\n        for (uint256 i; i < pools.length; i++) {\n            if (controller.isActivePool(pools[i])) {\n                IConicPool pool = IConicPool(pools[i]);\n                IERC20Metadata underlying = pool.underlying();\n                uint256 price = oracle.getUSDPrice(address(underlying));\n                uint256 poolUSDValue = pool\n                    .cachedTotalUnderlying()\n                    .convertScale(underlying.decimals(), 18)\n                    .mulDown(price);\n                poolUSDValues[i] = poolUSDValue;\n                totalUSDValue += poolUSDValue;\n            }\n        }\n\n        poolWeights = new uint256[](pools.length);\n\n        if (totalUSDValue == 0) {\n            for (uint256 i; i < pools.length; i++) {\n                poolWeights[i] = ScaledMath.ONE / pools.length;\n            }\n        } else {\n            for (uint256 i; i < pools.length; i++) {\n                poolWeights[i] = poolUSDValues[i].divDown(totalUSDValue);\n            }\n        }\n    }\n\n    /// @notice Same as `computePoolWeights` but only returns the value for a single pool\n    /// totalUSDValue only accounts for funds in active pools\n    function computePoolWeight(\n        address pool\n    ) public view returns (uint256 poolWeight, uint256 totalUSDValue) {\n        require(controller.isPool(pool), \"pool not found\");\n        IOracle oracle = controller.priceOracle();\n        address[] memory pools = controller.listPools();\n        uint256 poolUSDValue;\n        for (uint256 i; i < pools.length; i++) {\n            if (controller.isActivePool(pools[i])) {\n                IConicPool currentPool = IConicPool(pools[i]);\n                IERC20Metadata underlying = currentPool.underlying();\n                uint256 price = oracle.getUSDPrice(address(underlying));\n                uint256 usdValue = currentPool\n                    .cachedTotalUnderlying()\n                    .convertScale(underlying.decimals(), 18)\n                    .mulDown(price);\n                totalUSDValue += usdValue;\n                if (address(currentPool) == pool) poolUSDValue = usdValue;\n            }\n        }\n\n        if (!controller.isActivePool(pool)) {\n            return (0, totalUSDValue);\n        }\n        poolWeight = totalUSDValue == 0\n            ? ScaledMath.ONE / pools.length\n            : poolUSDValue.divDown(totalUSDValue);\n    }\n\n    function executeInflationRateUpdate() external override {\n        _executeInflationRateUpdate();\n    }\n\n    function handleRebalancingRewards(\n        address account,\n        uint256 deviationBefore,\n        uint256 deviationAfter\n    ) external {\n        require(controller.isPool(msg.sender), \"only pools can call this function\");\n        for (uint256 i; i < _rebalancingRewardHandlers[msg.sender].length(); i++) {\n            address handler = _rebalancingRewardHandlers[msg.sender].at(i);\n            IRebalancingRewardsHandler(handler).handleRebalancingRewards(\n                IConicPool(msg.sender),\n                account,\n                deviationBefore,\n                deviationAfter\n            );\n        }\n    }\n\n    function addPoolRebalancingRewardHandler(\n        address poolAddress,\n        address rebalancingRewardHandler\n    ) external override onlyOwner {\n        require(controller.isPool(poolAddress), \"invalid pool\");\n        require(\n            _rebalancingRewardHandlers[poolAddress].add(rebalancingRewardHandler),\n            \"handler already set\"\n        );\n\n        emit RebalancingRewardHandlerAdded(poolAddress, rebalancingRewardHandler);\n    }\n\n    function removePoolRebalancingRewardHandler(\n        address poolAddress,\n        address rebalancingRewardHandler\n    ) external override onlyOwner {\n        require(controller.isPool(poolAddress), \"invalid pool\");\n        require(\n            _rebalancingRewardHandlers[poolAddress].remove(rebalancingRewardHandler),\n            \"handler not set\"\n        );\n        emit RebalancingRewardHandlerRemoved(poolAddress, rebalancingRewardHandler);\n    }\n\n    function hasPoolRebalancingRewardHandlers(\n        address poolAddress,\n        address handler\n    ) external view returns (bool) {\n        return _rebalancingRewardHandlers[poolAddress].contains(handler);\n    }\n\n    function rebalancingRewardHandlers(\n        address poolAddress\n    ) external view returns (address[] memory) {\n        return _rebalancingRewardHandlers[poolAddress].values();\n    }\n\n    function updatePoolWeights() public override {\n        (address[] memory _pools, uint256[] memory poolWeights, ) = computePoolWeights();\n        uint256 numPools = _pools.length;\n        ILpTokenStaker lpTokenStaker = controller.lpTokenStaker();\n        for (uint256 i; i < numPools; i++) {\n            address curPool = _pools[i];\n            IRewardManager(IConicPool(curPool).rewardManager()).poolCheckpoint();\n            lpTokenStaker.checkpoint(curPool);\n            currentPoolWeights[curPool] = poolWeights[i];\n        }\n        emit PoolWeightsUpdated();\n    }\n\n    /// @dev Pool weights will be updated periodically\n    function getCurrentPoolInflationRate(address pool) external view override returns (uint256) {\n        return currentInflationRate.mulDown(currentPoolWeights[pool]);\n    }\n\n    function _executeInflationRateUpdate() internal {\n        if (block.timestamp >= lastInflationRateDecay + _INFLATION_RATE_PERIOD) {\n            updatePoolWeights();\n            currentInflationRate = currentInflationRate.mulDown(_INFLATION_RATE_DECAY);\n            lastInflationRateDecay = block.timestamp;\n        }\n    }\n}"
    },
    {
      "filename": "contracts/tokenomics/InflationManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport \"../../interfaces/tokenomics/IRebalancingRewardsHandler.sol\";\nimport \"../../interfaces/tokenomics/IInflationManager.sol\";\nimport \"../../interfaces/IController.sol\";\nimport \"../../interfaces/tokenomics/ICNCToken.sol\";\nimport \"../../interfaces/pools/IConicPool.sol\";\nimport \"../../interfaces/pools/ILpToken.sol\";\n\nimport \"../../libraries/ScaledMath.sol\";\n\ncontract InflationManager is IInflationManager, Ownable {\n    using ScaledMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    ICNCToken public constant CNC = ICNCToken(0x9aE380F0272E2162340a5bB646c354271c0F5cFC);\n\n    IController public immutable controller;\n\n    uint256 internal constant _INITIAL_INFLATION_RATE = 1_500_000 * 1e18;\n    uint256 internal constant _INFLATION_RATE_DECAY = 0.3999999 * 1e18;\n    uint256 internal constant _INFLATION_RATE_PERIOD = 365 days;\n\n    /// @dev mapping from conic pool to their rebalancing reward handlers\n    mapping(address => EnumerableSet.AddressSet) internal _rebalancingRewardHandlers;\n\n    uint256 public override currentInflationRate;\n    uint256 public lastInflationRateDecay;\n    uint256 public lastUpdate;\n    uint256 public totalLpInflationMinted;\n\n    mapping(address => uint256) public currentPoolWeights;\n\n    constructor(address _controller) Ownable() {\n        require(_controller != address(0), \"Cannot use zero address for controller\");\n        controller = IController(_controller);\n\n        currentInflationRate = _INITIAL_INFLATION_RATE / _INFLATION_RATE_PERIOD;\n        lastUpdate = block.timestamp;\n        lastInflationRateDecay = block.timestamp;\n    }\n\n    /// @notice returns the weights of the Conic pools to know how much inflation\n    /// each of them will receive. totalUSDValue only accounts for funds in active pools\n    function computePoolWeights()\n        public\n        view\n        override\n        returns (address[] memory pools, uint256[] memory poolWeights, uint256 totalUSDValue)\n    {\n        IOracle oracle = controller.priceOracle();\n        pools = controller.listPools();\n        uint256[] memory poolUSDValues = new uint256[](pools.length);\n        for (uint256 i; i < pools.length; i++) {\n            if (controller.isActivePool(pools[i])) {\n                IConicPool pool = IConicPool(pools[i]);\n                IERC20Metadata underlying = pool.underlying();\n                uint256 price = oracle.getUSDPrice(address(underlying));\n                uint256 poolUSDValue = pool\n                    .cachedTotalUnderlying()\n                    .convertScale(underlying.decimals(), 18)\n                    .mulDown(price);\n                poolUSDValues[i] = poolUSDValue;\n                totalUSDValue += poolUSDValue;\n            }\n        }\n\n        poolWeights = new uint256[](pools.length);\n\n        if (totalUSDValue == 0) {\n            for (uint256 i; i < pools.length; i++) {\n                poolWeights[i] = ScaledMath.ONE / pools.length;\n            }\n        } else {\n            for (uint256 i; i < pools.length; i++) {\n                poolWeights[i] = poolUSDValues[i].divDown(totalUSDValue);\n            }\n        }\n    }\n\n    /// @notice Same as `computePoolWeights` but only returns the value for a single pool\n    /// totalUSDValue only accounts for funds in active pools\n    function computePoolWeight(\n        address pool\n    ) public view returns (uint256 poolWeight, uint256 totalUSDValue) {\n        require(controller.isPool(pool), \"pool not found\");\n        IOracle oracle = controller.priceOracle();\n        address[] memory pools = controller.listPools();\n        uint256 poolUSDValue;\n        for (uint256 i; i < pools.length; i++) {\n            if (controller.isActivePool(pools[i])) {\n                IConicPool currentPool = IConicPool(pools[i]);\n                IERC20Metadata underlying = currentPool.underlying();\n                uint256 price = oracle.getUSDPrice(address(underlying));\n                uint256 usdValue = currentPool\n                    .cachedTotalUnderlying()\n                    .convertScale(underlying.decimals(), 18)\n                    .mulDown(price);\n                totalUSDValue += usdValue;\n                if (address(currentPool) == pool) poolUSDValue = usdValue;\n            }\n        }\n\n        if (!controller.isActivePool(pool)) {\n            return (0, totalUSDValue);\n        }\n        poolWeight = totalUSDValue == 0\n            ? ScaledMath.ONE / pools.length\n            : poolUSDValue.divDown(totalUSDValue);\n    }\n\n    function executeInflationRateUpdate() external override {\n        _executeInflationRateUpdate();\n    }\n\n    function handleRebalancingRewards(\n        address account,\n        uint256 deviationBefore,\n        uint256 deviationAfter\n    ) external {\n        require(controller.isPool(msg.sender), \"only pools can call this function\");\n        for (uint256 i; i < _rebalancingRewardHandlers[msg.sender].length(); i++) {\n            address handler = _rebalancingRewardHandlers[msg.sender].at(i);\n            IRebalancingRewardsHandler(handler).handleRebalancingRewards(\n                IConicPool(msg.sender),\n                account,\n                deviationBefore,\n                deviationAfter\n            );\n        }\n    }\n\n    function addPoolRebalancingRewardHandler(\n        address poolAddress,\n        address rebalancingRewardHandler\n    ) external override onlyOwner {\n        require(controller.isPool(poolAddress), \"invalid pool\");\n        require(\n            _rebalancingRewardHandlers[poolAddress].add(rebalancingRewardHandler),\n            \"handler already set\"\n        );\n\n        emit RebalancingRewardHandlerAdded(poolAddress, rebalancingRewardHandler);\n    }\n\n    function removePoolRebalancingRewardHandler(\n        address poolAddress,\n        address rebalancingRewardHandler\n    ) external override onlyOwner {\n        require(controller.isPool(poolAddress), \"invalid pool\");\n        require(\n            _rebalancingRewardHandlers[poolAddress].remove(rebalancingRewardHandler),\n            \"handler not set\"\n        );\n        emit RebalancingRewardHandlerRemoved(poolAddress, rebalancingRewardHandler);\n    }\n\n    function hasPoolRebalancingRewardHandlers(\n        address poolAddress,\n        address handler\n    ) external view returns (bool) {\n        return _rebalancingRewardHandlers[poolAddress].contains(handler);\n    }\n\n    function rebalancingRewardHandlers(\n        address poolAddress\n    ) external view returns (address[] memory) {\n        return _rebalancingRewardHandlers[poolAddress].values();\n    }\n\n    function updatePoolWeights() public override {\n        (address[] memory _pools, uint256[] memory poolWeights, ) = computePoolWeights();\n        uint256 numPools = _pools.length;\n        ILpTokenStaker lpTokenStaker = controller.lpTokenStaker();\n        for (uint256 i; i < numPools; i++) {\n            address curPool = _pools[i];\n            IRewardManager(IConicPool(curPool).rewardManager()).poolCheckpoint();\n            lpTokenStaker.checkpoint(curPool);\n            currentPoolWeights[curPool] = poolWeights[i];\n        }\n        emit PoolWeightsUpdated();\n    }\n\n    /// @dev Pool weights will be updated periodically\n    function getCurrentPoolInflationRate(address pool) external view override returns (uint256) {\n        return currentInflationRate.mulDown(currentPoolWeights[pool]);\n    }\n\n    function _executeInflationRateUpdate() internal {\n        if (block.timestamp >= lastInflationRateDecay + _INFLATION_RATE_PERIOD) {\n            updatePoolWeights();\n            currentInflationRate = currentInflationRate.mulDown(_INFLATION_RATE_DECAY);\n            lastInflationRateDecay = block.timestamp;\n        }\n    }\n}"
    },
    {
      "filename": "contracts/tokenomics/InflationManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport \"../../interfaces/tokenomics/IRebalancingRewardsHandler.sol\";\nimport \"../../interfaces/tokenomics/IInflationManager.sol\";\nimport \"../../interfaces/IController.sol\";\nimport \"../../interfaces/tokenomics/ICNCToken.sol\";\nimport \"../../interfaces/pools/IConicPool.sol\";\nimport \"../../interfaces/pools/ILpToken.sol\";\n\nimport \"../../libraries/ScaledMath.sol\";\n\ncontract InflationManager is IInflationManager, Ownable {\n    using ScaledMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    ICNCToken public constant CNC = ICNCToken(0x9aE380F0272E2162340a5bB646c354271c0F5cFC);\n\n    IController public immutable controller;\n\n    uint256 internal constant _INITIAL_INFLATION_RATE = 1_500_000 * 1e18;\n    uint256 internal constant _INFLATION_RATE_DECAY = 0.3999999 * 1e18;\n    uint256 internal constant _INFLATION_RATE_PERIOD = 365 days;\n\n    /// @dev mapping from conic pool to their rebalancing reward handlers\n    mapping(address => EnumerableSet.AddressSet) internal _rebalancingRewardHandlers;\n\n    uint256 public override currentInflationRate;\n    uint256 public lastInflationRateDecay;\n    uint256 public lastUpdate;\n    uint256 public totalLpInflationMinted;\n\n    mapping(address => uint256) public currentPoolWeights;\n\n    constructor(address _controller) Ownable() {\n        require(_controller != address(0), \"Cannot use zero address for controller\");\n        controller = IController(_controller);\n\n        currentInflationRate = _INITIAL_INFLATION_RATE / _INFLATION_RATE_PERIOD;\n        lastUpdate = block.timestamp;\n        lastInflationRateDecay = block.timestamp;\n    }\n\n    /// @notice returns the weights of the Conic pools to know how much inflation\n    /// each of them will receive. totalUSDValue only accounts for funds in active pools\n    function computePoolWeights()\n        public\n        view\n        override\n        returns (address[] memory pools, uint256[] memory poolWeights, uint256 totalUSDValue)\n    {\n        IOracle oracle = controller.priceOracle();\n        pools = controller.listPools();\n        uint256[] memory poolUSDValues = new uint256[](pools.length);\n        for (uint256 i; i < pools.length; i++) {\n            if (controller.isActivePool(pools[i])) {\n                IConicPool pool = IConicPool(pools[i]);\n                IERC20Metadata underlying = pool.underlying();\n                uint256 price = oracle.getUSDPrice(address(underlying));\n                uint256 poolUSDValue = pool\n                    .cachedTotalUnderlying()\n                    .convertScale(underlying.decimals(), 18)\n                    .mulDown(price);\n                poolUSDValues[i] = poolUSDValue;\n                totalUSDValue += poolUSDValue;\n            }\n        }\n\n        poolWeights = new uint256[](pools.length);\n\n        if (totalUSDValue == 0) {\n            for (uint256 i; i < pools.length; i++) {\n                poolWeights[i] = ScaledMath.ONE / pools.length;\n            }\n        } else {\n            for (uint256 i; i < pools.length; i++) {\n                poolWeights[i] = poolUSDValues[i].divDown(totalUSDValue);\n            }\n        }\n    }\n\n    /// @notice Same as `computePoolWeights` but only returns the value for a single pool\n    /// totalUSDValue only accounts for funds in active pools\n    function computePoolWeight(\n        address pool\n    ) public view returns (uint256 poolWeight, uint256 totalUSDValue) {\n        require(controller.isPool(pool), \"pool not found\");\n        IOracle oracle = controller.priceOracle();\n        address[] memory pools = controller.listPools();\n        uint256 poolUSDValue;\n        for (uint256 i; i < pools.length; i++) {\n            if (controller.isActivePool(pools[i])) {\n                IConicPool currentPool = IConicPool(pools[i]);\n                IERC20Metadata underlying = currentPool.underlying();\n                uint256 price = oracle.getUSDPrice(address(underlying));\n                uint256 usdValue = currentPool\n                    .cachedTotalUnderlying()\n                    .convertScale(underlying.decimals(), 18)\n                    .mulDown(price);\n                totalUSDValue += usdValue;\n                if (address(currentPool) == pool) poolUSDValue = usdValue;\n            }\n        }\n\n        if (!controller.isActivePool(pool)) {\n            return (0, totalUSDValue);\n        }\n        poolWeight = totalUSDValue == 0\n            ? ScaledMath.ONE / pools.length\n            : poolUSDValue.divDown(totalUSDValue);\n    }\n\n    function executeInflationRateUpdate() external override {\n        _executeInflationRateUpdate();\n    }\n\n    function handleRebalancingRewards(\n        address account,\n        uint256 deviationBefore,\n        uint256 deviationAfter\n    ) external {\n        require(controller.isPool(msg.sender), \"only pools can call this function\");\n        for (uint256 i; i < _rebalancingRewardHandlers[msg.sender].length(); i++) {\n            address handler = _rebalancingRewardHandlers[msg.sender].at(i);\n            IRebalancingRewardsHandler(handler).handleRebalancingRewards(\n                IConicPool(msg.sender),\n                account,\n                deviationBefore,\n                deviationAfter\n            );\n        }\n    }\n\n    function addPoolRebalancingRewardHandler(\n        address poolAddress,\n        address rebalancingRewardHandler\n    ) external override onlyOwner {\n        require(controller.isPool(poolAddress), \"invalid pool\");\n        require(\n            _rebalancingRewardHandlers[poolAddress].add(rebalancingRewardHandler),\n            \"handler already set\"\n        );\n\n        emit RebalancingRewardHandlerAdded(poolAddress, rebalancingRewardHandler);\n    }\n\n    function removePoolRebalancingRewardHandler(\n        address poolAddress,\n        address rebalancingRewardHandler\n    ) external override onlyOwner {\n        require(controller.isPool(poolAddress), \"invalid pool\");\n        require(\n            _rebalancingRewardHandlers[poolAddress].remove(rebalancingRewardHandler),\n            \"handler not set\"\n        );\n        emit RebalancingRewardHandlerRemoved(poolAddress, rebalancingRewardHandler);\n    }\n\n    function hasPoolRebalancingRewardHandlers(\n        address poolAddress,\n        address handler\n    ) external view returns (bool) {\n        return _rebalancingRewardHandlers[poolAddress].contains(handler);\n    }\n\n    function rebalancingRewardHandlers(\n        address poolAddress\n    ) external view returns (address[] memory) {\n        return _rebalancingRewardHandlers[poolAddress].values();\n    }\n\n    function updatePoolWeights() public override {\n        (address[] memory _pools, uint256[] memory poolWeights, ) = computePoolWeights();\n        uint256 numPools = _pools.length;\n        ILpTokenStaker lpTokenStaker = controller.lpTokenStaker();\n        for (uint256 i; i < numPools; i++) {\n            address curPool = _pools[i];\n            IRewardManager(IConicPool(curPool).rewardManager()).poolCheckpoint();\n            lpTokenStaker.checkpoint(curPool);\n            currentPoolWeights[curPool] = poolWeights[i];\n        }\n        emit PoolWeightsUpdated();\n    }\n\n    /// @dev Pool weights will be updated periodically\n    function getCurrentPoolInflationRate(address pool) external view override returns (uint256) {\n        return currentInflationRate.mulDown(currentPoolWeights[pool]);\n    }\n\n    function _executeInflationRateUpdate() internal {\n        if (block.timestamp >= lastInflationRateDecay + _INFLATION_RATE_PERIOD) {\n            updatePoolWeights();\n            currentInflationRate = currentInflationRate.mulDown(_INFLATION_RATE_DECAY);\n            lastInflationRateDecay = block.timestamp;\n        }\n    }\n}"
    },
    {
      "filename": "contracts/tokenomics/CNCToken.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport \"../../libraries/ScaledMath.sol\";\nimport \"../../interfaces/tokenomics/ICNCToken.sol\";\n\n/// @notice the deployer will initially have minting rights\n/// The process will be to premint `PRE_MINT_RATIO` of `MAX_TOTAL_SUPPLY`\n/// to the initial distribution address, grant the minting rights to the inflation manager\n/// and renounce its minting rights\ncontract CNCToken is ICNCToken, ERC20 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using ScaledMath for uint256;\n\n    uint256 public constant PRE_MINT_RATIO = 0.3e18;\n    uint256 public constant AIRDROP_MINT_RATIO = 0.1e18;\n    uint256 public constant AMM_REWARDS_RATIO = 0.1e18;\n    uint256 public constant TREASURY_REWARDS_RATIO = 0.05e18;\n    uint256 public constant TREASURY_SEED_RATIO = 0.01e18;\n    uint256 public constant INFLATION_RATIO =\n        1e18 -\n            AMM_REWARDS_RATIO -\n            AIRDROP_MINT_RATIO -\n            PRE_MINT_RATIO -\n            TREASURY_REWARDS_RATIO -\n            TREASURY_SEED_RATIO;\n    uint256 public constant MAX_TOTAL_SUPPLY = 10_000_000e18;\n\n    EnumerableSet.AddressSet internal authorizedMinters;\n\n    bool public initialDistributionMintDone;\n    bool public airdropMintDone;\n    bool public ammGaugeMintDone;\n    bool public treasuryMintDone;\n    bool public seedShareMintDone;\n\n    modifier onlyMinter() {\n        require(authorizedMinters.contains(msg.sender), \"not authorized\");\n        _;\n    }\n\n    constructor() ERC20(\"Conic Finance Token\", \"CNC\") {\n        authorizedMinters.add(msg.sender);\n        emit MinterAdded(msg.sender);\n    }\n\n    function addMinter(address newMinter) external onlyMinter {\n        if (authorizedMinters.add(newMinter)) {\n            emit MinterAdded(newMinter);\n        }\n    }\n\n    function renounceMinterRights() external onlyMinter {\n        authorizedMinters.remove(msg.sender);\n        emit MinterRemoved(msg.sender);\n    }\n\n    function mintInitialDistribution(address distribution) external onlyMinter {\n        require(!initialDistributionMintDone, \"premint already done\");\n        uint256 mintAmount = MAX_TOTAL_SUPPLY.mulDown(PRE_MINT_RATIO);\n        _mint(distribution, mintAmount);\n        initialDistributionMintDone = true;\n        emit InitialDistributionMinted(mintAmount);\n    }\n\n    function mintAirdrop(address airdropHandler) external onlyMinter {\n        require(!airdropMintDone, \"airdrop already done\");\n        uint256 mintAmount = MAX_TOTAL_SUPPLY.mulDown(AIRDROP_MINT_RATIO);\n        _mint(airdropHandler, mintAmount);\n        airdropMintDone = true;\n        emit AirdropMinted(mintAmount);\n    }\n\n    function mintAMMRewards(address ammGauge) external onlyMinter {\n        require(!ammGaugeMintDone, \"amm rewards already minted\");\n        uint256 mintAmount = MAX_TOTAL_SUPPLY.mulDown(AMM_REWARDS_RATIO);\n        _mint(ammGauge, mintAmount);\n        ammGaugeMintDone = true;\n        emit AMMRewardsMinted(mintAmount);\n    }\n\n    function mintTreasuryShare(address treasuryEscrow) external onlyMinter {\n        require(!treasuryMintDone, \"treasury rewards already minted\");\n        uint256 mintAmount = MAX_TOTAL_SUPPLY.mulDown(TREASURY_REWARDS_RATIO);\n        _mint(treasuryEscrow, mintAmount);\n        treasuryMintDone = true;\n        emit TreasuryRewardsMinted(mintAmount);\n    }\n\n    function mintSeedShare(address treasury) external onlyMinter {\n        require(!seedShareMintDone, \"seed share already minted\");\n        uint256 mintAmount = MAX_TOTAL_SUPPLY.mulDown(TREASURY_SEED_RATIO);\n        _mint(treasury, mintAmount);\n        seedShareMintDone = true;\n        emit SeedShareMinted(mintAmount);\n    }\n\n    function mint(address account, uint256 amount) external onlyMinter returns (uint256) {\n        uint256 currentSupply = totalSupply();\n        if (amount + currentSupply > MAX_TOTAL_SUPPLY) {\n            amount = MAX_TOTAL_SUPPLY - currentSupply;\n        }\n        if (amount > 0) {\n            _mint(account, amount);\n        }\n        return amount;\n    }\n\n    /// @dev this assumes that all the pre-mint events occured\n    function inflationMintedRatio() external view returns (uint256) {\n        ui"
    }
  ]
}