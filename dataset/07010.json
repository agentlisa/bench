{
  "Title": "[M-08] `LinearDistributor.declareReward()` might revert after changing `vestingDistributor`.",
  "Content": "\n<https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/LinearDistributor.sol#L114> \n\n<https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/LinearDistributor.sol#L227>\n\n### Impact\n\n`LinearDistributor.declareReward()` might revert after changing `vestingDistributor` due to uint underflow.\n\n### Proof of Concept\n\nIn `LinearDistributor.sol`, there is a [setVestingDistributor()](https://github.com/code-423n4/2023-02-malt/blob/main/contracts/RewardSystem/LinearDistributor.sol#L222-L228) function to update `vestingDistributor`.\n\nAnd in `declareReward()`, it calculates the `netVest` and `netTime` by subtracting the previous amount and time.\n\n```solidity\nFile: 2023-02-malt\\contracts\\RewardSystem\\LinearDistributor.sol\n112:     uint256 currentlyVested = vestingDistributor.getCurrentlyVested();\n113: \n114:     uint256 netVest = currentlyVested - previouslyVested; //@audit revert after change vestingDistributor\n115:     uint256 netTime = block.timestamp - previouslyVestedTimestamp;\n116: \n```\n\nBut there is no guarantee that the vested amount of the new `vestingDistributor` is greater than the previously saved amount after changing the distributor.\n\nFurthermore, there is no option to change `previouslyVested` beside this declareReward() function and it will keep reverting unless the admin change back the distributor.\n\n### Recommended Mitigation Steps\n\nI think it would resolve the above problem if we change the previous amounts as well while updating the distributor.\n\n```solidity\n  function setVestingDistributor(address _vestingDistributor, uint _previouslyVested, uint _previouslyVestedTimestamp)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_vestingDistributor != address(0), \"SetVestDist: No addr(0)\");\n    vestingDistributor = IVestingDistributor(_vestingDistributor);\n\n    previouslyVested = _previouslyVested;\n    previouslyVestedTimestamp = _previouslyVestedTimestamp;\n  }\n```\n\n**[0xScotch (Malt) confirmed and commented](https://github.com/code-423n4/2023-02-malt-findings/issues/28#issuecomment-1447006469):**\n > Setting `previouslyVested` during the `setVestingDistributor` call seems like a sufficient solution to this.\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-02-malt-protocol-versus-contest",
  "Code": [
    {
      "filename": "contracts/RewardSystem/LinearDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport \"openzeppelin/token/ERC20/ERC20.sol\";\nimport \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../StabilizedPoolExtensions/StabilizedPoolUnit.sol\";\nimport \"../StabilizedPoolExtensions/RewardThrottleExtension.sol\";\nimport \"../interfaces/IForfeit.sol\";\nimport \"../interfaces/IRewardMine.sol\";\nimport \"../interfaces/IDistributor.sol\";\n\n/// @title Linear Distributor\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The contract in charge of implementing the linear distribution of rewards in line with the vesting APR\ncontract LinearDistributor is\n  StabilizedPoolUnit,\n  IDistributor,\n  RewardThrottleExtension\n{\n  using SafeERC20 for ERC20;\n\n  bytes32 public immutable REWARDER_ROLE;\n  bytes32 public immutable REWARD_MINE_ROLE;\n\n  IRewardMine public rewardMine;\n  IForfeit public forfeitor;\n  IVestingDistributor public vestingDistributor;\n\n  uint256 public bufferTime = 1 days;\n\n  uint256 internal previouslyVested;\n  uint256 internal previouslyVestedTimestamp;\n\n  uint256 internal declaredBalance;\n\n  event DeclareReward(\n    uint256 totalAmount,\n    uint256 usedAmount,\n    address collateralToken\n  );\n  event Forfeit(uint256 forfeited);\n\n  constructor(\n    address timelock,\n    address repository,\n    address poolFactory\n  ) StabilizedPoolUnit(timelock, repository, poolFactory) {\n    REWARDER_ROLE = 0xbeec13769b5f410b0584f69811bfd923818456d5edcf426b0e31cf90eed7a3f6;\n    REWARD_MINE_ROLE = 0x9afd8e1abbfc72925a0e12f641b707c835ffa0861d61e98c38d65713ba5e2aff;\n  }\n\n  function setupContracts(\n    address _collateralToken,\n    address _rewardMine,\n    address _rewardThrottle,\n    address _forfeitor,\n    address _vestingDistributor,\n    address pool\n  ) external onlyRoleMalt(POOL_FACTORY_ROLE, \"Only pool factory role\") {\n    require(!contractActive, \"Distributor: Setup already done\");\n    require(_collateralToken != address(0), \"Distributor: Col addr(0)\");\n    require(_rewardMine != address(0), \"Distributor: RewardMine addr(0)\");\n    require(_rewardThrottle != address(0), \"Distributor: Throttler addr(0)\");\n    require(_forfeitor != address(0), \"Distributor: Forfeitor addr(0)\");\n    require(\n      _vestingDistributor != address(0),\n      \"Distributor: VestingDist addr(0)\"\n    );\n\n    contractActive = true;\n\n    _roleSetup(REWARDER_ROLE, _rewardThrottle);\n    _roleSetup(REWARD_MINE_ROLE, _rewardMine);\n\n    collateralToken = ERC20(_collateralToken);\n    rewardMine = IRewardMine(_rewardMine);\n    rewardThrottle = IRewardThrottle(_rewardThrottle);\n    forfeitor = IForfeit(_forfeitor);\n    vestingDistributor = IVestingDistributor(_vestingDistributor);\n\n    (, address updater, ) = poolFactory.getPool(pool);\n    _setPoolUpdater(updater);\n  }\n\n  /* PUBLIC VIEW FUNCTIONS */\n  function totalDeclaredReward() public view returns (uint256) {\n    return declaredBalance;\n  }\n\n  function bondedValue() public view returns (uint256) {\n    return rewardMine.valueOfBonded();\n  }\n\n  /*\n   * PRIVILEDGED METHODS\n   */\n  function declareReward(uint256 amount)\n    external\n    onlyRoleMalt(REWARDER_ROLE, \"Only rewarder role\")\n    onlyActive\n  {\n    _rewardCheck(amount);\n\n    if (rewardMine.totalBonded() == 0) {\n      // There is no accounts to distribute the rewards to so forfeit it\n      _forfeit(amount);\n      return;\n    }\n\n    uint256 vestingBondedValue = vestingDistributor.bondedValue();\n    uint256 currentlyVested = vestingDistributor.getCurrentlyVested();\n\n    uint256 netVest = currentlyVested - previouslyVested;\n    uint256 netTime = block.timestamp - previouslyVestedTimestamp;\n\n    if (netVest == 0 || vestingBondedValue == 0) {\n      return;\n    }\n\n    uint256 linearBondedValue = rewardMine.valueOfBonded();\n\n    uint256 distributed = (linearBondedValue * netVest) / vestingBondedValue;\n    uint256 balance = collateralToken.balanceOf(address(this));\n\n    if (distributed > balance) {\n      distributed = balance;\n    }\n\n    if (distributed > 0) {\n      // Send vested amount to liquidity mine\n      collateralToken.safeTransfer(address(rewardMine), distributed);\n      rewardMine.releaseReward(distributed);\n    }\n\n    balance = collateralToken.balanceOf(address(this));\n\n    uint256 buf = bufferTime; // gas\n    uint256 bufferRequirement;\n\n    if (netTime < buf) {\n      bufferRequirement = (distributed * buf * 10000) / netTime / 10000;\n    } else {\n      bufferRequirement = distributed;\n    }\n\n    if (balance > bufferRequirement) {\n      // We have more than the buffer required. Forfeit the rest\n      uint256 net = balance - bufferRequirement;\n      _forfeit(net);\n    }\n\n    previouslyVested = currentlyVested;\n    previouslyVestedTimestamp = block.timestamp;\n\n    emit DeclareReward(amount, distributed, address(collateralToken));\n  }\n\n  function decrementRewards(uint256 amount)\n    external\n    onlyRoleMalt(REWARD_MINE_ROLE, \"Only reward mine\")\n  {\n    require(\n      amount <= declaredBalance,\n      \"Can't decrement more than total reward balance\"\n    );\n\n    if (amount > 0) {\n      declaredBalance = declaredBalance - amount;\n    }\n  }\n\n  /* INTERNAL FUNCTIONS */\n  function _rewardCheck(uint256 reward) internal {\n    require(reward > 0, \"Cannot declare 0 reward\");\n\n    declaredBalance = declaredBalance + reward;\n\n    uint256 totalReward = collateralToken.balanceOf(address(this)) +\n      rewardMine.totalReleasedReward();\n\n    require(declaredBalance <= totalReward, \"Insufficient balance\");\n  }\n\n  function _forfeit(uint256 forfeited) internal {\n    require(forfeited <= declaredBalance, \"Cannot forfeit more than declared\");\n\n    declaredBalance = declaredBalance - forfeited;\n\n    collateralToken.safeTransfer(address(forfeitor), forfeited);\n    forfeitor.handleForfeit();\n\n    uint256 totalReward = collateralToken.balanceOf(address(this)) +\n      rewardMine.totalReleasedReward();\n\n    require(declaredBalance <= totalReward, \"Insufficient balance\");\n\n    emit Forfeit(forfeited);\n  }\n\n  function _beforeSetRewardThrottle(address _rewardThrottle) internal override {\n    _transferRole(_rewardThrottle, address(rewardThrottle), REWARDER_ROLE);\n  }\n\n  function setRewardMine(address _rewardMine)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_rewardMine != address(0), \"Cannot set 0 address as rewardMine\");\n    _transferRole(_rewardMine, address(rewardMine), REWARD_MINE_ROLE);\n    rewardMine = IRewardMine(_rewardMine);\n  }\n\n  function setForfeitor(address _forfeitor)\n    external\n    onlyRoleMalt(POOL_UPDATER_ROLE, \"Must have pool updater privs\")\n  {\n    require(_forfeitor != address(0), \"Cannot set 0 address as forfeitor\");\n    forfeitor = IForfeit(_forfeitor);\n  }\n\n  function setVestingDistributor(address _vestingDistributor)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_vestingDistributor != address(0), \"SetVestDist: No addr(0)\");\n    vestingDistributor = IVestingDistributor(_vestingDistributor);\n  }\n\n  function setBufferTime(uint256 _bufferTime)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    bufferTime = _bufferTime;\n  }\n\n  function _accessControl() internal override(RewardThrottleExtension) {\n    _onlyRoleMalt(POOL_UPDATER_ROLE, \"Must have pool updater role\");\n  }\n}"
    },
    {
      "filename": "contracts/RewardSystem/LinearDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport \"openzeppelin/token/ERC20/ERC20.sol\";\nimport \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../StabilizedPoolExtensions/StabilizedPoolUnit.sol\";\nimport \"../StabilizedPoolExtensions/RewardThrottleExtension.sol\";\nimport \"../interfaces/IForfeit.sol\";\nimport \"../interfaces/IRewardMine.sol\";\nimport \"../interfaces/IDistributor.sol\";\n\n/// @title Linear Distributor\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The contract in charge of implementing the linear distribution of rewards in line with the vesting APR\ncontract LinearDistributor is\n  StabilizedPoolUnit,\n  IDistributor,\n  RewardThrottleExtension\n{\n  using SafeERC20 for ERC20;\n\n  bytes32 public immutable REWARDER_ROLE;\n  bytes32 public immutable REWARD_MINE_ROLE;\n\n  IRewardMine public rewardMine;\n  IForfeit public forfeitor;\n  IVestingDistributor public vestingDistributor;\n\n  uint256 public bufferTime = 1 days;\n\n  uint256 internal previouslyVested;\n  uint256 internal previouslyVestedTimestamp;\n\n  uint256 internal declaredBalance;\n\n  event DeclareReward(\n    uint256 totalAmount,\n    uint256 usedAmount,\n    address collateralToken\n  );\n  event Forfeit(uint256 forfeited);\n\n  constructor(\n    address timelock,\n    address repository,\n    address poolFactory\n  ) StabilizedPoolUnit(timelock, repository, poolFactory) {\n    REWARDER_ROLE = 0xbeec13769b5f410b0584f69811bfd923818456d5edcf426b0e31cf90eed7a3f6;\n    REWARD_MINE_ROLE = 0x9afd8e1abbfc72925a0e12f641b707c835ffa0861d61e98c38d65713ba5e2aff;\n  }\n\n  function setupContracts(\n    address _collateralToken,\n    address _rewardMine,\n    address _rewardThrottle,\n    address _forfeitor,\n    address _vestingDistributor,\n    address pool\n  ) external onlyRoleMalt(POOL_FACTORY_ROLE, \"Only pool factory role\") {\n    require(!contractActive, \"Distributor: Setup already done\");\n    require(_collateralToken != address(0), \"Distributor: Col addr(0)\");\n    require(_rewardMine != address(0), \"Distributor: RewardMine addr(0)\");\n    require(_rewardThrottle != address(0), \"Distributor: Throttler addr(0)\");\n    require(_forfeitor != address(0), \"Distributor: Forfeitor addr(0)\");\n    require(\n      _vestingDistributor != address(0),\n      \"Distributor: VestingDist addr(0)\"\n    );\n\n    contractActive = true;\n\n    _roleSetup(REWARDER_ROLE, _rewardThrottle);\n    _roleSetup(REWARD_MINE_ROLE, _rewardMine);\n\n    collateralToken = ERC20(_collateralToken);\n    rewardMine = IRewardMine(_rewardMine);\n    rewardThrottle = IRewardThrottle(_rewardThrottle);\n    forfeitor = IForfeit(_forfeitor);\n    vestingDistributor = IVestingDistributor(_vestingDistributor);\n\n    (, address updater, ) = poolFactory.getPool(pool);\n    _setPoolUpdater(updater);\n  }\n\n  /* PUBLIC VIEW FUNCTIONS */\n  function totalDeclaredReward() public view returns (uint256) {\n    return declaredBalance;\n  }\n\n  function bondedValue() public view returns (uint256) {\n    return rewardMine.valueOfBonded();\n  }\n\n  /*\n   * PRIVILEDGED METHODS\n   */\n  function declareReward(uint256 amount)\n    external\n    onlyRoleMalt(REWARDER_ROLE, \"Only rewarder role\")\n    onlyActive\n  {\n    _rewardCheck(amount);\n\n    if (rewardMine.totalBonded() == 0) {\n      // There is no accounts to distribute the rewards to so forfeit it\n      _forfeit(amount);\n      return;\n    }\n\n    uint256 vestingBondedValue = vestingDistributor.bondedValue();\n    uint256 currentlyVested = vestingDistributor.getCurrentlyVested();\n\n    uint256 netVest = currentlyVested - previouslyVested;\n    uint256 netTime = block.timestamp - previouslyVestedTimestamp;\n\n    if (netVest == 0 || vestingBondedValue == 0) {\n      return;\n    }\n\n    uint256 linearBondedValue = rewardMine.valueOfBonded();\n\n    uint256 distributed = (linearBondedValue * netVest) / vestingBondedValue;\n    uint256 balance = collateralToken.balanceOf(address(this));\n\n    if (distributed > balance) {\n      distributed = balance;\n    }\n\n    if (distributed > 0) {\n      // Send vested amount to liquidity mine\n      collateralToken.safeTransfer(address(rewardMine), distributed);\n      rewardMine.releaseReward(distributed);\n    }\n\n    balance = collateralToken.balanceOf(address(this));\n\n    uint256 buf = bufferTime; // gas\n    uint256 bufferRequirement;\n\n    if (netTime < buf) {\n      bufferRequirement = (distributed * buf * 10000) / netTime / 10000;\n    } else {\n      bufferRequirement = distributed;\n    }\n\n    if (balance > bufferRequirement) {\n      // We have more than the buffer required. Forfeit the rest\n      uint256 net = balance - bufferRequirement;\n      _forfeit(net);\n    }\n\n    previouslyVested = currentlyVested;\n    previouslyVestedTimestamp = block.timestamp;\n\n    emit DeclareReward(amount, distributed, address(collateralToken));\n  }\n\n  function decrementRewards(uint256 amount)\n    external\n    onlyRoleMalt(REWARD_MINE_ROLE, \"Only reward mine\")\n  {\n    require(\n      amount <= declaredBalance,\n      \"Can't decrement more than total reward balance\"\n    );\n\n    if (amount > 0) {\n      declaredBalance = declaredBalance - amount;\n    }\n  }\n\n  /* INTERNAL FUNCTIONS */\n  function _rewardCheck(uint256 reward) internal {\n    require(reward > 0, \"Cannot declare 0 reward\");\n\n    declaredBalance = declaredBalance + reward;\n\n    uint256 totalReward = collateralToken.balanceOf(address(this)) +\n      rewardMine.totalReleasedReward();\n\n    require(declaredBalance <= totalReward, \"Insufficient balance\");\n  }\n\n  function _forfeit(uint256 forfeited) internal {\n    require(forfeited <= declaredBalance, \"Cannot forfeit more than declared\");\n\n    declaredBalance = declaredBalance - forfeited;\n\n    collateralToken.safeTransfer(address(forfeitor), forfeited);\n    forfeitor.handleForfeit();\n\n    uint256 totalReward = collateralToken.balanceOf(address(this)) +\n      rewardMine.totalReleasedReward();\n\n    require(declaredBalance <= totalReward, \"Insufficient balance\");\n\n    emit Forfeit(forfeited);\n  }\n\n  function _beforeSetRewardThrottle(address _rewardThrottle) internal override {\n    _transferRole(_rewardThrottle, address(rewardThrottle), REWARDER_ROLE);\n  }\n\n  function setRewardMine(address _rewardMine)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_rewardMine != address(0), \"Cannot set 0 address as rewardMine\");\n    _transferRole(_rewardMine, address(rewardMine), REWARD_MINE_ROLE);\n    rewardMine = IRewardMine(_rewardMine);\n  }\n\n  function setForfeitor(address _forfeitor)\n    external\n    onlyRoleMalt(POOL_UPDATER_ROLE, \"Must have pool updater privs\")\n  {\n    require(_forfeitor != address(0), \"Cannot set 0 address as forfeitor\");\n    forfeitor = IForfeit(_forfeitor);\n  }\n\n  function setVestingDistributor(address _vestingDistributor)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_vestingDistributor != address(0), \"SetVestDist: No addr(0)\");\n    vestingDistributor = IVestingDistributor(_vestingDistributor);\n  }\n\n  function setBufferTime(uint256 _bufferTime)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    bufferTime = _bufferTime;\n  }\n\n  function _accessControl() internal override(RewardThrottleExtension) {\n    _onlyRoleMalt(POOL_UPDATER_ROLE, \"Must have pool updater role\");\n  }\n}"
    },
    {
      "filename": "contracts/RewardSystem/LinearDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport \"openzeppelin/token/ERC20/ERC20.sol\";\nimport \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../StabilizedPoolExtensions/StabilizedPoolUnit.sol\";\nimport \"../StabilizedPoolExtensions/RewardThrottleExtension.sol\";\nimport \"../interfaces/IForfeit.sol\";\nimport \"../interfaces/IRewardMine.sol\";\nimport \"../interfaces/IDistributor.sol\";\n\n/// @title Linear Distributor\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The contract in charge of implementing the linear distribution of rewards in line with the vesting APR\ncontract LinearDistributor is\n  StabilizedPoolUnit,\n  IDistributor,\n  RewardThrottleExtension\n{\n  using SafeERC20 for ERC20;\n\n  bytes32 public immutable REWARDER_ROLE;\n  bytes32 public immutable REWARD_MINE_ROLE;\n\n  IRewardMine public rewardMine;\n  IForfeit public forfeitor;\n  IVestingDistributor public vestingDistributor;\n\n  uint256 public bufferTime = 1 days;\n\n  uint256 internal previouslyVested;\n  uint256 internal previouslyVestedTimestamp;\n\n  uint256 internal declaredBalance;\n\n  event DeclareReward(\n    uint256 totalAmount,\n    uint256 usedAmount,\n    address collateralToken\n  );\n  event Forfeit(uint256 forfeited);\n\n  constructor(\n    address timelock,\n    address repository,\n    address poolFactory\n  ) StabilizedPoolUnit(timelock, repository, poolFactory) {\n    REWARDER_ROLE = 0xbeec13769b5f410b0584f69811bfd923818456d5edcf426b0e31cf90eed7a3f6;\n    REWARD_MINE_ROLE = 0x9afd8e1abbfc72925a0e12f641b707c835ffa0861d61e98c38d65713ba5e2aff;\n  }\n\n  function setupContracts(\n    address _collateralToken,\n    address _rewardMine,\n    address _rewardThrottle,\n    address _forfeitor,\n    address _vestingDistributor,\n    address pool\n  ) external onlyRoleMalt(POOL_FACTORY_ROLE, \"Only pool factory role\") {\n    require(!contractActive, \"Distributor: Setup already done\");\n    require(_collateralToken != address(0), \"Distributor: Col addr(0)\");\n    require(_rewardMine != address(0), \"Distributor: RewardMine addr(0)\");\n    require(_rewardThrottle != address(0), \"Distributor: Throttler addr(0)\");\n    require(_forfeitor != address(0), \"Distributor: Forfeitor addr(0)\");\n    require(\n      _vestingDistributor != address(0),\n      \"Distributor: VestingDist addr(0)\"\n    );\n\n    contractActive = true;\n\n    _roleSetup(REWARDER_ROLE, _rewardThrottle);\n    _roleSetup(REWARD_MINE_ROLE, _rewardMine);\n\n    collateralToken = ERC20(_collateralToken);\n    rewardMine = IRewardMine(_rewardMine);\n    rewardThrottle = IRewardThrottle(_rewardThrottle);\n    forfeitor = IForfeit(_forfeitor);\n    vestingDistributor = IVestingDistributor(_vestingDistributor);\n\n    (, address updater, ) = poolFactory.getPool(pool);\n    _setPoolUpdater(updater);\n  }\n\n  /* PUBLIC VIEW FUNCTIONS */\n  function totalDeclaredReward() public view returns (uint256) {\n    return declaredBalance;\n  }\n\n  function bondedValue() public view returns (uint256) {\n    return rewardMine.valueOfBonded();\n  }\n\n  /*\n   * PRIVILEDGED METHODS\n   */\n  function declareReward(uint256 amount)\n    external\n    onlyRoleMalt(REWARDER_ROLE, \"Only rewarder role\")\n    onlyActive\n  {\n    _rewardCheck(amount);\n\n    if (rewardMine.totalBonded() == 0) {\n      // There is no accounts to distribute the rewards to so forfeit it\n      _forfeit(amount);\n      return;\n    }\n\n    uint256 vestingBondedValue = vestingDistributor.bondedValue();\n    uint256 currentlyVested = vestingDistributor.getCurrentlyVested();\n\n    uint256 netVest = currentlyVested - previouslyVested;\n    uint256 netTime = block.timestamp - previouslyVestedTimestamp;\n\n    if (netVest == 0 || vestingBondedValue == 0) {\n      return;\n    }\n\n    uint256 linearBondedValue = rewardMine.valueOfBonded();\n\n    uint256 distributed = (linearBondedValue * netVest) / vestingBondedValue;\n    uint256 balance = collateralToken.balanceOf(address(this));\n\n    if (distributed > balance) {\n      distributed = balance;\n    }\n\n    if (distributed > 0) {\n      // Send vested amount to liquidity mine\n      collateralToken.safeTransfer(address(rewardMine), distributed);\n      rewardMine.releaseReward(distributed);\n    }\n\n    balance = collateralToken.balanceOf(address(this));\n\n    uint256 buf = bufferTime; // gas\n    uint256 bufferRequirement;\n\n    if (netTime < buf) {\n      bufferRequirement = (distributed * buf * 10000) / netTime / 10000;\n    } else {\n      bufferRequirement = distributed;\n    }\n\n    if (balance > bufferRequirement) {\n      // We have more than the buffer required. Forfeit the rest\n      uint256 net = balance - bufferRequirement;\n      _forfeit(net);\n    }\n\n    previouslyVested = currentlyVested;\n    previouslyVestedTimestamp = block.timestamp;\n\n    emit DeclareReward(amount, distributed, address(collateralToken));\n  }\n\n  function decrementRewards(uint256 amount)\n    external\n    onlyRoleMalt(REWARD_MINE_ROLE, \"Only reward mine\")\n  {\n    require(\n      amount <= declaredBalance,\n      \"Can't decrement more than total reward balance\"\n    );\n\n    if (amount > 0) {\n      declaredBalance = declaredBalance - amount;\n    }\n  }\n\n  /* INTERNAL FUNCTIONS */\n  function _rewardCheck(uint256 reward) internal {\n    require(reward > 0, \"Cannot declare 0 reward\");\n\n    declaredBalance = declaredBalance + reward;\n\n    uint256 totalReward = collateralToken.balanceOf(address(this)) +\n      rewardMine.totalReleasedReward();\n\n    require(declaredBalance <= totalReward, \"Insufficient balance\");\n  }\n\n  function _forfeit(uint256 forfeited) internal {\n    require(forfeited <= declaredBalance, \"Cannot forfeit more than declared\");\n\n    declaredBalance = declaredBalance - forfeited;\n\n    collateralToken.safeTransfer(address(forfeitor), forfeited);\n    forfeitor.handleForfeit();\n\n    uint256 totalReward = collateralToken.balanceOf(address(this)) +\n      rewardMine.totalReleasedReward();\n\n    require(declaredBalance <= totalReward, \"Insufficient balance\");\n\n    emit Forfeit(forfeited);\n  }\n\n  function _beforeSetRewardThrottle(address _rewardThrottle) internal override {\n    _transferRole(_rewardThrottle, address(rewardThrottle), REWARDER_ROLE);\n  }\n\n  function setRewardMine(address _rewardMine)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_rewardMine != address(0), \"Cannot set 0 address as rewardMine\");\n    _transferRole(_rewardMine, address(rewardMine), REWARD_MINE_ROLE);\n    rewardMine = IRewardMine(_rewardMine);\n  }\n\n  function setForfeitor(address _forfeitor)\n    external\n    onlyRoleMalt(POOL_UPDATER_ROLE, \"Must have pool updater privs\")\n  {\n    require(_forfeitor != address(0), \"Cannot set 0 address as forfeitor\");\n    forfeitor = IForfeit(_forfeitor);\n  }\n\n  function setVestingDistributor(address _vestingDistributor)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_vestingDistributor != address(0), \"SetVestDist: No addr(0)\");\n    vestingDistributor = IVestingDistributor(_vestingDistributor);\n  }\n\n  function setBufferTime(uint256 _bufferTime)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    bufferTime = _bufferTime;\n  }\n\n  function _accessControl() internal override(RewardThrottleExtension) {\n    _onlyRoleMalt(POOL_UPDATER_ROLE, \"Must have pool updater role\");\n  }\n}"
    }
  ]
}