{
  "Title": "M-18: vault stakers and game players share the same reward pool",
  "Content": "# Issue M-18: vault stakers and game players share the same reward pool \n\nSource: https://github.com/sherlock-audit/2023-01-derby-judging/issues/269 \n\n## Found by \nimmeas, rvierdiiev\n\n## Summary\nBoth vault stakers earning yield and game players are taking rewards from the same reward pool. One will take rewards from the other when withdrawing/redeeming.\n\n## Vulnerability Detail\nLets simplify the whole setup a bit to show the issue here. Imagine one vault on one chain with one provider. Alice plays the game and deposits 10 `DRB` all allocated to the provider. Bob deposits 10k `USDC` to the vault.\n\nTime passes the provider has a 10% increase. The funds are now 11k.\n\nBoth Bob and Alice are happy with this and want to collect their rewards. Alice redeems her rewards and Bob registers for a withdraw (or just withdraws).\n\nThe issue here is that both have claim to the same 1k rewards. Bob who staked should get them as yield for staking and Alice should get them as rewards for playing.\n\nIf both manage to withdraw/redeem in the same cycle this is where it will break down:\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XChainController.sol#L303\n\nAs the `totalWithdrawalRequests` (Bobs withdraw of all his shares and Alice redeeming of rewards) will be larger than `getTotalUnderlyingVault`.\n\nThe issue is not with this line of code though, its with the design of the rewards as game players and vault stakers both have a claim on the same rewards. \n\n## Impact\nIf a staker in the vault withdraws they will take rewards from game players and if a game player they will take yield from someone staking. If both at the same time, they will take rewards from user still staking. Resulting in the \"last\" user possibly not being able to withdraw due to not enough funds.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XChainController.sol#L303\n\n## Tool used\nManual Review, hardhat\n\n## Recommendation\nHonestly I don't see an easy way out of this:\nYou could split the pools, but why would anyone stake in the vault then? Since that is just staking with less yield compared to staking in the underlying protocols directly.\n\nYou could limit staking to game players, and then make them only split the funds they actually stake. That's a large change to the protocol though and would remove the use for Derby tokens.\n\nYou could also limit rewards to only Derby tokens, but that only works as long as there is `DRB` to hand out. It would also require some change to the way the rewards are reserved as currently you can create a reserved rewards greater than underlying thus underflowing in stage 3.\n\n\n\n## Discussion\n\n**sjoerdsommen**\n\nImplicitly the rewards that have been paid out are accounted for in the exchangerate. However, there are some situations, like in this example, where this does not work anymore. Fixing it will be very gas intensive so we would have to see how to do it.  \n\n**sjoerdsommen**\n\nDuplicate with #143\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/13",
  "Code": [
    {
      "filename": "derby-yield-optimiser/contracts/XChainController.sol",
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\nimport \"./Interfaces/IXProvider.sol\";\r\n\r\ncontract XChainController {\r\n  using SafeERC20 for IERC20;\r\n\r\n  struct vaultInfo {\r\n    int256 totalCurrentAllocation;\r\n    uint256 totalUnderlying;\r\n    uint256 totalSupply;\r\n    uint256 totalWithdrawalRequests;\r\n    // (chainId => bool): true == off // false == on\r\n    mapping(uint32 => bool) chainIdOff;\r\n    // (chainId => currentAllocation)\r\n    mapping(uint32 => int256) currentAllocationPerChain;\r\n    // (chainId => totalUnderlying)\r\n    mapping(uint32 => uint256) totalUnderlyingPerChain;\r\n    // (chainId => vaultAddress)\r\n    mapping(uint32 => address) vaultChainAddress;\r\n    // (chainId => underlyingAddress): e.g USDC\r\n    mapping(uint32 => address) vaultUnderlyingAddress;\r\n    // (chainId => totalWithdrawalRequests): total withdrawal requests in LP Token\r\n    mapping(uint32 => uint256) withdrawalRequests;\r\n    // (chainId => amountToDeposit)\r\n    mapping(uint32 => uint256) amountToDepositPerChain;\r\n  }\r\n\r\n  // activeVaults; number of active vaults for vaultNumber, set in XChainRebalance\r\n  // stage 0 Ready; waiting for game to send allocations\r\n  // stage 1 AllocationsReceived; allocations received from game, ready to rebalance XChain and set activeVaults\r\n  // stage 2 UnderlyingReceived; underlyings received from all active vault contracts\r\n  // stage 3 FundsReceived; funds received from all active vault contracts\r\n  struct vaultStages {\r\n    uint256 activeVaults;\r\n    bool ready; // stage 0\r\n    bool allocationsReceived; // stage 1\r\n    uint256 underlyingReceived; // stage 2\r\n    uint256 fundsReceived; // stage 3\r\n    uint256 fundsSent; // stage 4\r\n  }\r\n\r\n  address private dao;\r\n  address private guardian;\r\n  address public game;\r\n  address public xProviderAddr;\r\n  IXProvider public xProvider;\r\n\r\n  uint32[] public chainIds;\r\n  uint32 public homeChain;\r\n  int256 public minimumAmount;\r\n\r\n  // (vaultNumber => vaultInfo struct)\r\n  mapping(uint256 => vaultInfo) internal vaults;\r\n  // (vaultNumber => vaultStages struct)\r\n  mapping(uint256 => vaultStages) public vaultStage;\r\n\r\n  event SendXChainAmount(\r\n    address _vault,\r\n    uint32 _chainId,\r\n    uint256 _amountToSendXChain,\r\n    uint256 _exchangeRate,\r\n    bool _receivingFunds\r\n  );\r\n\r\n  event SentFundsToVault(address _vault, uint32 _chainId, uint256 _amount, address _asset);\r\n\r\n  modifier onlyGame() {\r\n    require(msg.sender == game, \"xController: only Game\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyDao() {\r\n    require(msg.sender == dao, \"xController: only DAO\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyGuardian() {\r\n    require(msg.sender == guardian, \"xController: only Guardian\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyXProvider() {\r\n    require(msg.sender == address(xProvider), \"xController: only xProviderAddr\");\r\n    _;\r\n  }\r\n\r\n  // vaultStage 0\r\n  modifier onlyWhenReady(uint256 _vaultNumber) {\r\n    require(vaultStage[_vaultNumber].ready, \"Not all vaults are ready\");\r\n    _;\r\n  }\r\n\r\n  // vaultStage 1\r\n  modifier onlyWhenAllocationsReceived(uint256 _vaultNumber) {\r\n    require(vaultStage[_vaultNumber].allocationsReceived, \"Allocations not received from game\");\r\n    _;\r\n  }\r\n\r\n  // vaultStage 2\r\n  modifier onlyWhenUnderlyingsReceived(uint256 _vaultNumber) {\r\n    require(\r\n      vaultStage[_vaultNumber].underlyingReceived == vaultStage[_vaultNumber].activeVaults,\r\n      \"Not all underlyings received\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  // vaultStage 3\r\n  modifier onlyWhenFundsReceived(uint256 _vaultNumber) {\r\n    require(\r\n      vaultStage[_vaultNumber].fundsReceived == vaultStage[_vaultNumber].activeVaults,\r\n      \"Not all funds received\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  constructor(address _game, address _dao, address _guardian, uint32 _homeChain) {\r\n    game = _game;\r\n    dao = _dao;\r\n    guardian = _guardian;\r\n    homeChain = _homeChain;\r\n    minimumAmount = 1000e6;\r\n  }\r\n\r\n  /// @notice Setter for number of active vaults for vaultNumber, set in xChainRebalance\r\n  /// @param _vaultNumber Number of the vault\r\n  /// @param _activeVaults Number active vaults, calculated in xChainRebalance\r\n  function setActiveVaults(uint256 _vaultNumber, uint256 _activeVaults) internal {\r\n    vaultStage[_vaultNumber].activeVaults = _activeVaults;\r\n  }\r\n\r\n  /// @notice Setter for stage 0:\r\n  /// @notice Ready; waiting for game to send allocations\r\n  function setReady(uint256 _vaultNumber, bool _state) internal {\r\n    vaultStage[_vaultNumber].ready = _state;\r\n  }\r\n\r\n  /// @notice Setter for stage 1:\r\n  /// @notice AllocationsReceived; allocations received from game, ready to rebalance XChain and set activeVaults\r\n  function setAllocationsReceived(\r\n    uint256 _vaultNumber,\r\n    bool _state\r\n  ) internal onlyWhenReady(_vaultNumber) {\r\n    vaultStage[_vaultNumber].allocationsReceived = _state;\r\n  }\r\n\r\n  /// @notice Setter to tick up stage 2:\r\n  /// @notice UnderlyingReceived; underlyings received from all active vault contracts\r\n  function upUnderlyingReceived(\r\n    uint256 _vaultNumber\r\n  ) internal onlyWhenAllocationsReceived(_vaultNumber) {\r\n    vaultStage[_vaultNumber].underlyingReceived++;\r\n  }\r\n\r\n  /// @notice Step 4 end; Push funds from vaults to xChainController\r\n  /// @notice FundsReceived; funds received from all active vault contracts\r\n  function upFundsReceived(\r\n    uint256 _vaultNumber\r\n  ) external onlyXProvider onlyWhenUnderlyingsReceived(_vaultNumber) {\r\n    vaultStage[_vaultNumber].fundsReceived++;\r\n  }\r\n\r\n  /// @notice Resets all stages in vaultStage struct for a vaultNumber\r\n  function resetVaultStages(uint256 _vaultNumber) internal {\r\n    vaultStage[_vaultNumber].ready = true;\r\n    vaultStage[_vaultNumber].allocationsReceived = false;\r\n    vaultStage[_vaultNumber].underlyingReceived = 0;\r\n    vaultStage[_vaultNumber].fundsReceived = 0;\r\n    vaultStage[_vaultNumber].fundsSent = 0;\r\n  }\r\n\r\n  /// @notice Resets underlying for a vaultNumber at the start of a rebalancing period\r\n  function resetVaultUnderlying(uint256 _vaultNumber) internal {\r\n    vaults[_vaultNumber].totalUnderlying = 0;\r\n    vaultStage[_vaultNumber].underlyingReceived = 0;\r\n    vaults[_vaultNumber].totalSupply = 0;\r\n  }\r\n\r\n  /// @notice Resets underlying for a vaultNumber per chainId at the start of a rebalancing period\r\n  function resetVaultUnderlyingForChain(uint256 _vaultNumber, uint32 _chainId) internal {\r\n    vaults[_vaultNumber].totalUnderlyingPerChain[_chainId] = 0;\r\n  }\r\n\r\n  /// @notice Step 1 end; Game pushes totalDeltaAllocations to xChainController\r\n  /// @param _vaultNumber Number of Vault\r\n  /// @param _deltas Delta allocations array received from game, indexes match chainIds[] set in this contract\r\n  function receiveAllocationsFromGame(\r\n    uint256 _vaultNumber,\r\n    int256[] memory _deltas\r\n  ) external onlyXProvider onlyWhenReady(_vaultNumber) {\r\n    return receiveAllocationsFromGameInt(_vaultNumber, _deltas);\r\n  }\r\n\r\n  /// @notice Step 1 end; Game pushes totalDeltaAllocations to xChainController\r\n  /// @param _vaultNumber Number of Vault\r\n  /// @param _deltas Delta allocations array received from game, indexes match chainIds[] set in this contract\r\n  function receiveAllocationsFromGameInt(uint256 _vaultNumber, int256[] memory _deltas) internal {\r\n    uint256 activeVaults;\r\n\r\n    for (uint256 i = 0; i < chainIds.length; i++) {\r\n      uint32 chain = chainIds[i];\r\n      activeVaults += settleCurrentAllocation(_vaultNumber, chain, _deltas[i]);\r\n      resetVaultUnderlyingForChain(_vaultNumber, chain);\r\n    }\r\n\r\n    resetVaultUnderlying(_vaultNumber);\r\n    setActiveVaults(_vaultNumber, activeVaults);\r\n    setAllocationsReceived(_vaultNumber, true);\r\n    setReady(_vaultNumber, false);\r\n  }\r\n\r\n  /// @notice Helper to settle the total current allocation with the delta allocations received from Game\r\n  /// @notice Will set a chainId on/off depending on the currentAllocation and incoming deltaAllocation\r\n  /// @dev if currentAllocation = 0 and deltaAllocation = 0, chainId will be set to Off and feedback will be send to vault\r\n  /// @param _vaultNumber Number of Vault\r\n  /// @param _chainId Number of chain used\r\n  /// @param _deltas Delta allocations array received from game, indexes match chainIds[] set in this contract\r\n  function settleCurrentAllocation(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId,\r\n    int256 _deltas\r\n  ) internal returns (uint256 activeVault) {\r\n    if (getCurrentAllocation(_vaultNumber, _chainId) == 0 && _deltas == 0) {\r\n      vaults[_vaultNumber].chainIdOff[_chainId] = true;\r\n      activeVault = 0;\r\n    } else {\r\n      vaults[_vaultNumber].chainIdOff[_chainId] = false;\r\n      activeVault = 1;\r\n    }\r\n\r\n    vaults[_vaultNumber].totalCurrentAllocation += _deltas;\r\n    vaults[_vaultNumber].currentAllocationPerChain[_chainId] += _deltas;\r\n\r\n    require(vaults[_vaultNumber].totalCurrentAllocation >= 0, \"Allocation underflow\");\r\n  }\r\n\r\n  /// @notice Will send feedback to the vault if it is turned on or off by settleCurrentAllocation\r\n  /// @notice Step 1.5, toggle vault on or off\r\n  /// @param _vaultNumber Number of vault\r\n  /// @param _chainId Chain id of the vault where the funds need to be sent\r\n  function sendFeedbackToVault(uint256 _vaultNumber, uint32 _chainId) external payable {\r\n    address vault = getVaultAddress(_vaultNumber, _chainId);\r\n    require(vault != address(0), \"xChainController: not a valid vaultnumber\");\r\n    xProvider.pushStateFeedbackToVault{value: msg.value}(\r\n      vault,\r\n      _chainId,\r\n      vaults[_vaultNumber].chainIdOff[_chainId]\r\n    );\r\n  }\r\n\r\n  /// @notice See setTotalUnderlyingInt below\r\n  function setTotalUnderlying(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId,\r\n    uint256 _underlying,\r\n    uint256 _totalSupply,\r\n    uint256 _withdrawalRequests\r\n  ) external onlyXProvider onlyWhenAllocationsReceived(_vaultNumber) {\r\n    require(getTotalUnderlyingOnChain(_vaultNumber, _chainId) == 0, \"TotalUnderlying already set\");\r\n    setTotalUnderlyingInt(_vaultNumber, _chainId, _underlying, _totalSupply, _withdrawalRequests);\r\n  }\r\n\r\n  /// @notice Step 2 end; Vaults push totalUnderlying, totalSupply and totalWithdrawalRequests to xChainController\r\n  /// @notice Receive and set totalUnderlyings from the vaults for every chainId\r\n  /// @param _vaultNumber number of the vault\r\n  /// @param _chainId Number of chain used\r\n  /// @param _underlying totalUnderling plus vault balance in vaultcurrency e.g USDC\r\n  /// @param _totalSupply Supply of the LP token of the vault on given chainId\r\n  /// @param _withdrawalRequests Total amount of withdrawal requests from the vault in LP Tokens\r\n  function setTotalUnderlyingInt(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId,\r\n    uint256 _underlying,\r\n    uint256 _totalSupply,\r\n    uint256 _withdrawalRequests\r\n  ) internal {\r\n    vaults[_vaultNumber].totalUnderlyingPerChain[_chainId] = _underlying;\r\n    vaults[_vaultNumber].withdrawalRequests[_chainId] = _withdrawalRequests;\r\n    vaults[_vaultNumber].totalSupply += _totalSupply;\r\n    vaults[_vaultNumber].totalUnderlying += _underlying;\r\n    vaults[_vaultNumber].totalWithdrawalRequests += _withdrawalRequests;\r\n    vaultStage[_vaultNumber].underlyingReceived++;\r\n  }\r\n\r\n  /// @notice Step 3 trigger; xChainController pushes exchangeRate and amount the vaults have to send back to all vaults\r\n  /// @notice Calculates the amounts the vaults on each chainId have to send or receive\r\n  /// @param _vaultNumber Number of vault\r\n  /// @param _chain Chain id of the vault where the funds need to be sent\r\n  function pushVaultAmounts(\r\n    uint256 _vaultNumber,\r\n    uint16 _chain\r\n  ) external payable onlyWhenUnderlyingsReceived(_vaultNumber) {\r\n    address vault = getVaultAddress(_vaultNumber, _chain);\r\n    require(vault != address(0), \"xChainController: not a valid vaultnumber\");\r\n    int256 totalAllocation = getCurrentTotalAllocation(_vaultNumber);\r\n    uint256 totalWithdrawalRequests = getTotalWithdrawalRequests(_vaultNumber);\r\n    uint256 totalUnderlying = getTotalUnderlyingVault(_vaultNumber) - totalWithdrawalRequests;\r\n    uint256 totalSupply = getTotalSupply(_vaultNumber);\r\n\r\n    uint256 decimals = xProvider.getDecimals(vault);\r\n    uint256 newExchangeRate = (totalUnderlying * (10 ** decimals)) / totalSupply;\r\n\r\n    if (!getVaultChainIdOff(_vaultNumber, _chain)) {\r\n      int256 amountToChain = calcAmountToChain(\r\n        _vaultNumber,\r\n        _chain,\r\n        totalUnderlying,\r\n        totalAllocation\r\n      );\r\n      (int256 amountToDeposit, uint256 amountToWithdraw) = calcDepositWithdraw(\r\n        _vaultNumber,\r\n        _chain,\r\n        amountToChain\r\n      );\r\n\r\n      sendXChainAmount(_vaultNumber, _chain, amountToDeposit, amountToWithdraw, newExchangeRate);\r\n    }\r\n  }\r\n\r\n  /// @notice Calculates the amounts the vaults on each chainId have to send or receive\r\n  /// @param _vaultNumber number of the vault\r\n  /// @param _chainId Number of chain used\r\n  /// @param _amountToChain Amount in vaultcurrency that should be on given chainId\r\n  function calcDepositWithdraw(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId,\r\n    int256 _amountToChain\r\n  ) internal view returns (int256, uint256) {\r\n    uint256 currentUnderlying = getTotalUnderlyingOnChain(_vaultNumber, _chainId);\r\n\r\n    int256 amountToDeposit = _amountToChain - int256(currentUnderlying);\r\n    uint256 amountToWithdraw = amountToDeposit < 0\r\n      ? currentUnderlying - uint256(_amountToChain)\r\n      : 0;\r\n\r\n    return (amountToDeposit, amountToWithdraw);\r\n  }\r\n\r\n  /// @notice Calculates the amounts the vaults has to send back to the xChainController\r\n  /// @param _totalUnderlying Total underlying on all chains for given vaultNumber\r\n  /// @param _totalAllocation Total allocation on all chains for given vaultNumber\r\n  function calcAmountToChain(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId,\r\n    uint256 _totalUnderlying,\r\n    int256 _totalAllocation\r\n  ) internal view returns (int256) {\r\n    int256 allocation = getCurrentAllocation(_vaultNumber, _chainId);\r\n    uint256 withdrawalRequests = getWithdrawalRequests(_vaultNumber, _chainId);\r\n\r\n    int256 amountToChain = (int(_totalUnderlying) * allocation) / _totalAllocation;\r\n    amountToChain += int(withdrawalRequests);\r\n\r\n    return amountToChain;\r\n  }\r\n\r\n  /// @notice Sends out cross-chain messages to vaults with the amount the vault has to send back\r\n  /// @dev if the xChainController needs to deposit, the amount will be 0 so the vault knows it will receive currency\r\n  /// @param _amountDeposit Amount the vault will receive from the xChainController\r\n  /// @param _amountToWithdraw Amount the vault will have to send back to the xChainController\r\n  /// @param _exchangeRate New exchangerate for vaults\r\n  function sendXChainAmount(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId,\r\n    int256 _amountDeposit,\r\n    uint256 _amountToWithdraw,\r\n    uint256 _exchangeRate\r\n  ) internal {\r\n    address vault = getVaultAddress(_vaultNumber, _chainId);\r\n    bool receivingFunds;\r\n    uint256 amountToSend = 0;\r\n\r\n    if (_amountDeposit > 0 && _amountDeposit < minimumAmount) {\r\n      vaultStage[_vaultNumber].fundsReceived++;\r\n    } else if (_amountDeposit >= minimumAmount) {\r\n      receivingFunds = true;\r\n      setAmountToDeposit(_vaultNumber, _chainId, _amountDeposit);\r\n      vaultStage[_vaultNumber].fundsReceived++;\r\n    }\r\n\r\n    if (_amountToWithdraw > 0 && _amountToWithdraw < uint(minimumAmount)) {\r\n      vaultStage[_vaultNumber].fundsReceived++;\r\n    } else if (_amountToWithdraw >= uint(minimumAmount)) {\r\n      amountToSend = _amountToWithdraw;\r\n    }\r\n\r\n    xProvider.pushSetXChainAllocation{value: msg.value}(\r\n      vault,\r\n      _chainId,\r\n      amountToSend,\r\n      _exchangeRate,\r\n      receivingFunds\r\n    );\r\n    emit SendXChainAmount(vault, _chainId, amountToSend, _exchangeRate, receivingFunds);\r\n  }\r\n\r\n  /// @notice Step 5 trigger; Push funds from xChainController to vaults\r\n  /// @notice Send amount to deposit from xController to vault and reset all stages for the vault\r\n  /// @param _vaultNumber Number of vault\r\n  /// @param _slippage Slippage tollerance for xChain swap, in BPS (i.e. 30 = 0.3%)\r\n  /// @param _chain Chain id of the vault where the funds need to be sent\r\n  /// @param _relayerFee The fee offered to the relayers\r\n  function sendFundsToVault(\r\n    uint256 _vaultNumber,\r\n    uint256 _slippage,\r\n    uint32 _chain,\r\n    uint256 _relayerFee\r\n  ) external payable onlyWhenFundsReceived(_vaultNumber) {\r\n    address vault = getVaultAddress(_vaultNumber, _chain);\r\n    require(vault != address(0), \"xChainController: not a valid vaultnumber\");\r\n    if (!getVaultChainIdOff(_vaultNumber, _chain)) {\r\n      uint256 amountToDeposit = getAmountToDeposit(_vaultNumber, _chain);\r\n\r\n      if (amountToDeposit > 0) {\r\n        address underlying = getUnderlyingAddress(_vaultNumber, _chain);\r\n\r\n        uint256 balance = IERC20(underlying).balanceOf(address(this));\r\n        if (amountToDeposit > balance) amountToDeposit = balance;\r\n\r\n        IERC20(underlying).safeIncreaseAllowance(address(xProvider), amountToDeposit);\r\n        xProvider.xTransferToVaults{value: msg.value}(\r\n          vault,\r\n          _chain,\r\n          amountToDeposit,\r\n          underlying,\r\n          _slippage,\r\n          _relayerFee\r\n        );\r\n        setAmountToDeposit(_vaultNumber, _chain, 0);\r\n        emit SentFundsToVault(vault, _chain, amountToDeposit, underlying);\r\n      }\r\n    }\r\n    vaultStage[_vaultNumber].fundsSent++;\r\n    if (vaultStage[_vaultNumber].fundsSent == chainIds.length) resetVaultStages(_vaultNumber);\r\n  }\r\n\r\n  /// @notice Helper to get total current allocation of vaultNumber\r\n  function getTotalUnderlyingOnChain(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId\r\n  ) internal view returns (uint256) {\r\n    return vaults[_vaultNumber].totalUnderlyingPerChain[_chainId];\r\n  }\r\n\r\n  /// @notice Gets saved totalUnderlying for vaultNumber\r\n  function getTotalUnderlyingVault(\r\n    uint256 _vaultNumber\r\n  ) internal view onlyWhenUnderlyingsReceived(_vaultNumber) returns (uint256) {\r\n    return vaults[_vaultNumber].totalUnderlying;\r\n  }\r\n\r\n  /// @notice Helper to get vault address of vaultNumber with given chainID\r\n  function getVaultAddress(uint256 _vaultNumber, uint32 _chainId) internal view returns (address) {\r\n    return vaults[_vaultNumber].vaultChainAddress[_chainId];\r\n  }\r\n\r\n  /// @notice Helper to get underyling address of vaultNumber with given chainID eg USDC\r\n  function getUnderlyingAddress(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId\r\n  ) internal view returns (address) {\r\n    return vaults[_vaultNumber].vaultUnderlyingAddress[_chainId];\r\n  }\r\n\r\n  /// @notice Helper to get current allocation per chain of vaultNumber with given chainID\r\n  function getCurrentAllocation(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId\r\n  ) internal view returns (int256) {\r\n    return vaults[_vaultNumber].currentAllocationPerChain[_chainId];\r\n  }\r\n\r\n  /// @notice Helper to get total current allocation of vaultNumber\r\n  function getCurrentTotalAllocation(uint256 _vaultNumber) internal view returns (int256) {\r\n    return vaults[_vaultNumber].totalCurrentAllocation;\r\n  }\r\n\r\n  /// @notice Helper to get if vault is active or not\r\n  function getVaultChainIdOff(uint256 _vaultNumber, uint32 _chainId) public view returns (bool) {\r\n    return vaults[_vaultNumber].chainIdOff[_chainId];\r\n  }\r\n\r\n  /// @notice Helper to set the amount to deposit in a chain vault\r\n  function setAmountToDeposit(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId,\r\n    int256 _amountToDeposit\r\n  ) internal {\r\n    vaults[_vaultNumber].amountToDepositPerChain[_chainId] = uint256(_amountToDeposit);\r\n  }\r\n\r\n  /// @notice Helper to get the amount to deposit in a chain vault\r\n  function getAmountToDeposit(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId\r\n  ) internal view returns (uint256) {\r\n    return vaults[_vaultNumber].amountToDepositPerChain[_chainId];\r\n  }\r\n\r\n  /// @notice Helper to get total supply from the vault on given chainId\r\n  function getTotalSupply(uint256 _vaultNumber) internal view returns (uint256) {\r\n    return vaults[_vaultNumber].totalSupply;\r\n  }\r\n\r\n  /// @notice Helper to get withdrawal requests from the vault on given chainId\r\n  function getWithdrawalRequests(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId\r\n  ) internal view returns (uint256) {\r\n    return vaults[_vaultNumber].withdrawalRequests[_chainId];\r\n  }\r\n\r\n  /// @notice Helper to get total withdrawal requests from the vault on given chainId\r\n  function getTotalWithdrawalRequests(uint256 _vaultNumber) internal view returns (uint256) {\r\n    return vaults[_vaultNumber].totalWithdrawalRequests;\r\n  }\r\n\r\n  /// @notice Getter for chainId array\r\n  function getChainIds() public view returns (uint32[] memory) {\r\n    return chainIds;\r\n  }\r\n\r\n  /// @notice Getter for dao address\r\n  function getDao() public view returns (address) {\r\n    return dao;\r\n  }\r\n\r\n  /// @notice Getter for guardian address\r\n  function getGuardian() public view returns (address) {\r\n    return guardian;\r\n  }\r\n\r\n  /*\r\n  Only Dao functions\r\n  */\r\n\r\n  /// @notice Set Vault address and underlying for a particulair chainId\r\n  /// @param _vaultNumber number of Vault\r\n  /// @param _chainId Number of chain used\r\n  /// @param _address address of the Vault\r\n  /// @param _underlying underlying of the Vault eg USDC\r\n  function setVaultChainAddress(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId,\r\n    address _address,\r\n    address _underlying\r\n  ) external onlyDao {\r\n    vaults[_vaultNumber].vaultChainAddress[_chainId] = _address;\r\n    vaults[_vaultNumber].vaultUnderlyingAddress[_chainId] = _underlying;\r\n  }\r\n\r\n  /// @notice Setter for xProvider address\r\n  /// @param _xProvider new address of xProvider on this chain\r\n  function setHomeXProvider(address _xProvider) external onlyDao {\r\n    xProvider = IXProvider(_xProvider);\r\n  }\r\n\r\n  /// @notice Setter for homeChain Id\r\n  /// @param _homeChainId New home chainId\r\n  function setHomeChainId(uint32 _homeChainId) external onlyDao {\r\n    homeChain = _homeChainId;\r\n  }\r\n\r\n  /// @notice Setter for DAO address\r\n  /// @param _dao DAO address\r\n  function setDao(address _dao) external onlyDao {\r\n    dao = _dao;\r\n  }\r\n\r\n  /// @notice Setter for guardian address\r\n  /// @param _guardian new address of the guardian\r\n  function setGuardian(address _guardian) external onlyDao {\r\n    guardian = _guardian;\r\n  }\r\n\r\n  /// @notice Setter for new game address\r\n  /// @param _game New address of the game\r\n  function setGame(address _game) external onlyDao {\r\n    game = _game;\r\n  }\r\n\r\n  /// @notice Setter for minumum amount to send xchain\r\n  /// @param _amount New minimum amount\r\n  function setMinimumAmount(int256 _amount) external onlyDao {\r\n    minimumAmount = _amount;\r\n  }\r\n\r\n  /*\r\n  Only Guardian functions\r\n  */\r\n\r\n  /// @notice Setter for chainId array\r\n  /// @param _chainIds array of all the used chainIds\r\n  function setChainIds(uint32[] memory _chainIds) external onlyGuardian {\r\n    chainIds = _chainIds;\r\n  }\r\n\r\n  /// @notice Resets all stages in vaultStage struct for a vaultNumber\r\n  /// @notice Must be run when a new vaultNumber is deployed\r\n  /// @dev onlyGuardian modifier so the dao can reset all stages for a vaultNumber incase something goes wrong\r\n  function resetVaultStagesDao(uint256 _vaultNumber) external onlyGuardian {\r\n    return resetVaultStages(_vaultNumber);\r\n  }\r\n\r\n  /// @notice Step 1: Guardian function\r\n  function receiveAllocationsFromGameGuard(\r\n    uint256 _vaultNumber,\r\n    int256[] memory _deltas\r\n  ) external onlyGuardian {\r\n    return receiveAllocationsFromGameInt(_vaultNumber, _deltas);\r\n  }\r\n\r\n  /// @notice Step 2: Guardian function\r\n  function setTotalUnderlyingGuard(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId,\r\n    uint256 _underlying,\r\n    uint256 _totalSupply,\r\n    uint256 _withdrawalRequests\r\n  ) external onlyGuardian {\r\n    return\r\n      setTotalUnderlyingInt(_vaultNumber, _chainId, _underlying, _totalSupply, _withdrawalRequests);\r\n  }\r\n\r\n  /// @notice Step 4: Guardian function\r\n  function setFundsReceivedGuard(\r\n    uint256 _vaultNumber,\r\n    uint256 _fundsReceived\r\n  ) external onlyGuardian {\r\n    vaultStage[_vaultNumber].fundsReceived = _fundsReceived;\r\n  }\r\n\r\n  /// @notice Guardian setter for number of active vaults for vaultNumber, set in xChainRebalance\r\n  function setActiveVaultsGuard(uint256 _vaultNumber, uint256 _activeVaults) external onlyGuardian {\r\n    vaultStage[_vaultNumber].activeVaults = _activeVaults;\r\n  }\r\n\r\n  /// @notice Guardian setter for stage 0:\r\n  function setReadyGuard(uint256 _vaultNumber, bool _state) external onlyGuardian {\r\n    vaultStage[_vaultNumber].ready = _state;\r\n  }\r\n\r\n  /// @notice Guardian setter for stage 1:\r\n  function setAllocationsReceivedGuard(uint256 _vaultNumber, bool _state) external onlyGuardian {\r\n    vaultStage[_vaultNumber].allocationsReceived = _state;\r\n  }\r\n\r\n  /// @notice Guardian setter to tick up stage 2:\r\n  function setUnderlyingReceivedGuard(\r\n    uint256 _vaultNumber,\r\n    uint256 _underlyingReceived\r\n  ) external onlyGuardian {\r\n    vaultStage[_vaultNumber].underlyingReceived = _underlyingReceived;\r\n  }\r\n}"
    },
    {
      "filename": "derby-yield-optimiser/contracts/XChainController.sol",
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\nimport \"./Interfaces/IXProvider.sol\";\r\n\r\ncontract XChainController {\r\n  using SafeERC20 for IERC20;\r\n\r\n  struct vaultInfo {\r\n    int256 totalCurrentAllocation;\r\n    uint256 totalUnderlying;\r\n    uint256 totalSupply;\r\n    uint256 totalWithdrawalRequests;\r\n    // (chainId => bool): true == off // false == on\r\n    mapping(uint32 => bool) chainIdOff;\r\n    // (chainId => currentAllocation)\r\n    mapping(uint32 => int256) currentAllocationPerChain;\r\n    // (chainId => totalUnderlying)\r\n    mapping(uint32 => uint256) totalUnderlyingPerChain;\r\n    // (chainId => vaultAddress)\r\n    mapping(uint32 => address) vaultChainAddress;\r\n    // (chainId => underlyingAddress): e.g USDC\r\n    mapping(uint32 => address) vaultUnderlyingAddress;\r\n    // (chainId => totalWithdrawalRequests): total withdrawal requests in LP Token\r\n    mapping(uint32 => uint256) withdrawalRequests;\r\n    // (chainId => amountToDeposit)\r\n    mapping(uint32 => uint256) amountToDepositPerChain;\r\n  }\r\n\r\n  // activeVaults; number of active vaults for vaultNumber, set in XChainRebalance\r\n  // stage 0 Ready; waiting for game to send allocations\r\n  // stage 1 AllocationsReceived; allocations received from game, ready to rebalance XChain and set activeVaults\r\n  // stage 2 UnderlyingReceived; underlyings received from all active vault contracts\r\n  // stage 3 FundsReceived; funds received from all active vault contracts\r\n  struct vaultStages {\r\n    uint256 activeVaults;\r\n    bool ready; // stage 0\r\n    bool allocationsReceived; // stage 1\r\n    uint256 underlyingReceived; // stage 2\r\n    uint256 fundsReceived; // stage 3\r\n    uint256 fundsSent; // stage 4\r\n  }\r\n\r\n  address private dao;\r\n  address private guardian;\r\n  address public game;\r\n  address public xProviderAddr;\r\n  IXProvider public xProvider;\r\n\r\n  uint32[] public chainIds;\r\n  uint32 public homeChain;\r\n  int256 public minimumAmount;\r\n\r\n  // (vaultNumber => vaultInfo struct)\r\n  mapping(uint256 => vaultInfo) internal vaults;\r\n  // (vaultNumber => vaultStages struct)\r\n  mapping(uint256 => vaultStages) public vaultStage;\r\n\r\n  event SendXChainAmount(\r\n    address _vault,\r\n    uint32 _chainId,\r\n    uint256 _amountToSendXChain,\r\n    uint256 _exchangeRate,\r\n    bool _receivingFunds\r\n  );\r\n\r\n  event SentFundsToVault(address _vault, uint32 _chainId, uint256 _amount, address _asset);\r\n\r\n  modifier onlyGame() {\r\n    require(msg.sender == game, \"xController: only Game\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyDao() {\r\n    require(msg.sender == dao, \"xController: only DAO\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyGuardian() {\r\n    require(msg.sender == guardian, \"xController: only Guardian\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyXProvider() {\r\n    require(msg.sender == address(xProvider), \"xController: only xProviderAddr\");\r\n    _;\r\n  }\r\n\r\n  // vaultStage 0\r\n  modifier onlyWhenReady(uint256 _vaultNumber) {\r\n    require(vaultStage[_vaultNumber].ready, \"Not all vaults are ready\");\r\n    _;\r\n  }\r\n\r\n  // vaultStage 1\r\n  modifier onlyWhenAllocationsReceived(uint256 _vaultNumber) {\r\n    require(vaultStage[_vaultNumber].allocationsReceived, \"Allocations not received from game\");\r\n    _;\r\n  }\r\n\r\n  // vaultStage 2\r\n  modifier onlyWhenUnderlyingsReceived(uint256 _vaultNumber) {\r\n    require(\r\n      vaultStage[_vaultNumber].underlyingReceived == vaultStage[_vaultNumber].activeVaults,\r\n      \"Not all underlyings received\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  // vaultStage 3\r\n  modifier onlyWhenFundsReceived(uint256 _vaultNumber) {\r\n    require(\r\n      vaultStage[_vaultNumber].fundsReceived == vaultStage[_vaultNumber].activeVaults,\r\n      \"Not all funds received\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  constructor(address _game, address _dao, address _guardian, uint32 _homeChain) {\r\n    game = _game;\r\n    dao = _dao;\r\n    guardian = _guardian;\r\n    homeChain = _homeChain;\r\n    minimumAmount = 1000e6;\r\n  }\r\n\r\n  /// @notice Setter for number of active vaults for vaultNumber, set in xChainRebalance\r\n  /// @param _vaultNumber Number of the vault\r\n  /// @param _activeVaults Number active vaults, calculated in xChainRebalance\r\n  function setActiveVaults(uint256 _vaultNumber, uint256 _activeVaults) internal {\r\n    vaultStage[_vaultNumber].activeVaults = _activeVaults;\r\n  }\r\n\r\n  /// @notice Setter for stage 0:\r\n  /// @notice Ready; waiting for game to send allocations\r\n  function setReady(uint256 _vaultNumber, bool _state) internal {\r\n    vaultStage[_vaultNumber].ready = _state;\r\n  }\r\n\r\n  /// @notice Setter for stage 1:\r\n  /// @notice AllocationsReceived; allocations received from game, ready to rebalance XChain and set activeVaults\r\n  function setAllocationsReceived(\r\n    uint256 _vaultNumber,\r\n    bool _state\r\n  ) internal onlyWhenReady(_vaultNumber) {\r\n    vaultStage[_vaultNumber].allocationsReceived = _state;\r\n  }\r\n\r\n  /// @notice Setter to tick up stage 2:\r\n  /// @notice UnderlyingReceived; underlyings received from all active vault contracts\r\n  function upUnderlyingReceived(\r\n    uint256 _vaultNumber\r\n  ) internal onlyWhenAllocationsReceived(_vaultNumber) {\r\n    vaultStage[_vaultNumber].underlyingReceived++;\r\n  }\r\n\r\n  /// @notice Step 4 end; Push funds from vaults to xChainController\r\n  /// @notice FundsReceived; funds received from all active vault contracts\r\n  function upFundsReceived(\r\n    uint256 _vaultNumber\r\n  ) external onlyXProvider onlyWhenUnderlyingsReceived(_vaultNumber) {\r\n    vaultStage[_vaultNumber].fundsReceived++;\r\n  }\r\n\r\n  /// @notice Resets all stages in vaultStage struct for a vaultNumber\r\n  function resetVaultStages(uint256 _vaultNumber) internal {\r\n    vaultStage[_vaultNumber].ready = true;\r\n    vaultStage[_vaultNumber].allocationsReceived = false;\r\n    vaultStage[_vaultNumber].underlyingReceived = 0;\r\n    vaultStage[_vaultNumber].fundsReceived = 0;\r\n    vaultStage[_vaultNumber].fundsSent = 0;\r\n  }\r\n\r\n  /// @notice Resets underlying for a vaultNumber at the start of a rebalancing period\r\n  function resetVaultUnderlying(uint256 _vaultNumber) internal {\r\n    vaults[_vaultNumber].totalUnderlying = 0;\r\n    vaultStage[_vaultNumber].underlyingReceived = 0;\r\n    vaults[_vaultNumber].totalSupply = 0;\r\n  }\r\n\r\n  /// @notice Resets underlying for a vaultNumber per chainId at the start of a rebalancing period\r\n  function resetVaultUnderlyingForChain(uint256 _vaultNumber, uint32 _chainId) internal {\r\n    vaults[_vaultNumber].totalUnderlyingPerChain[_chainId] = 0;\r\n  }\r\n\r\n  /// @notice Step 1 end; Game pushes totalDeltaAllocations to xChainController\r\n  /// @param _vaultNumber Number of Vault\r\n  /// @param _deltas Delta allocations array received from game, indexes match chainIds[] set in this contract\r\n  function receiveAllocationsFromGame(\r\n    uint256 _vaultNumber,\r\n    int256[] memory _deltas\r\n  ) external onlyXProvider onlyWhenReady(_vaultNumber) {\r\n    return receiveAllocationsFromGameInt(_vaultNumber, _deltas);\r\n  }\r\n\r\n  /// @notice Step 1 end; Game pushes totalDeltaAllocations to xChainController\r\n  /// @param _vaultNumber Number of Vault\r\n  /// @param _deltas Delta allocations array received from game, indexes match chainIds[] set in this contract\r\n  function receiveAllocationsFromGameInt(uint256 _vaultNumber, int256[] memory _deltas) internal {\r\n    uint256 activeVaults;\r\n\r\n    for (uint256 i = 0; i < chainIds.length; i++) {\r\n      uint32 chain = chainIds[i];\r\n      activeVaults += settleCurrentAllocation(_vaultNumbe"
    }
  ]
}