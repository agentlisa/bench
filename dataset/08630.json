{
  "Title": "[M-10] Reentrancy bug in Basketâ€™s withdraw multiple tokens function which gives attacker ability to transfer basket ownership and spend it but withdraw all the tokens out of basket",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L41-L47\nhttps://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L68-L75\nhttps://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L91-L97\n\n\n# Vulnerability details\n\n## Impact\n`Basket` is used for keep multiple tokens in contract and mint one `NFT` token to represent their ownership. `Basket` only allows for owner of `NFT(id=0)` to withdraw tokens from `Basket` address. users can deposit multiple tokens in one `Basket` and then create a `NibbVault` based on that `Basket NFT`. but due to reentrancy vulnerability in `Basket` it's possible to call the multiple-token-withdraw functions (`withdrawMultipleERC721()`, `withdrawMultipleERC1155()`, `withdrawMultipleERC721()` and `withdrawMultipleERC20()`) and in the middle their external calls, spend `Basket NFT` (transfer ownership of `id=0` to other contract, for example `createVault()`) and receive some fund from other, then in the rest of the multiple-token-withdraw function withdraw all the basket tokens. `Basket` shouldn't allow transferring ownership of `id=0` in the middle of multiple token withdraws.\n\n## Proof of Concept\nThis is `withdrawMultipleERC721()` code:\n```\n    function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC721(_tokens[i]).safeTransferFrom(address(this), _to, _tokenId[i]);\n            emit WithdrawERC721(_tokens[i], _tokenId[i], _to);\n        }\n    }\n```\nAs you can see, contract only checks the ownership of `id=0` in the beginning of the function to see that user allowed to perform this action or not. then it iterates through user specified addresses and call `safeTransferFrom()` function in those address by user specified values. the bug is that in the middle of the external calls attacker can spend `Basket NFT id=0` (give ownership of that basket to other contracts and receive fund from them, for example attacker can call `createVault` in `NibblVaultFactory` and create a vault and call other contracts to invest in that vault) then in the rest of the iterations in `withdrawMultipleERC721()` attacker can withdraw `Basket` tokens. so even so the ownership of the `Basket` has been transferred and attacker received funds for it, attacker withdraw `Basket` tokens too.\nThis is the steps attacker would perform:\n1. create a `Basket` with well known `NFT` token list. let's assume the `Basket` name is `Basket_M`\n2. give approve permission to `NibblVaultFactory` for `Basket_M id=0` token.\n3. call `Basket_M.withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to)` with list of all the tokens in basket to withdraw all of them, but the first address in the `_tokens` list is the address that attacker controls.\n4. `Basket_M` would check that attacker is owner of the basket (owner of the `id = 0`) and in first iteration of the `for` it would call attacker controlled address which is a contract that attacker wrote its code.\n5. attacker contract would call `NibblVaultFactory.createVault()` with `Basket_M` address and `id=0` to create a vault which then transfer the ownership of `Basket_M id=0` to the vault address. let's assume it's `Vault_M`.\n6. attacker contract would buy some fraction of `Vault_M` by calling `buy()` function.\n7. let's assume there are other contracts(call it `Invest_Contract`) that would want to buy fraction of the well known `NFT`s in the basket and `Invest_Contract` invest some fund in vault having those `NFT` in vault's address or vault's basket just by calling `Invest_Contract`. attacker contract would call `Invest_Contract`  to invest in `Vault_M` and `Invest_Contract` would check that well known `NFT` is in `Basket_M id=0` which belongs to `Vault_M` to it would invest money on it by calling `initiateBuyout()`\n8. attacker contract then withdraw his money from `Vault_M` .\n9. the rest of `Basket_M.withdrawMultipleERC721()` for iterations performs and all the `NFT` tokens of the `Basket_M` would be send to attacker and `Basket_M` would have nothing.\n\nsteps 5 to 8 can be other things, the point is in those steps attacker would spent `Basket_M` and receive some fund from other contract while those other contracts checks that they are owner of the `Basket_M` which has well known `NFT` tokens, but in fact attacker withdraw those well known `NFT` tokens from `Basket_M` after spending it in the rest of the `withdrawMultipleERC721()` iterations. (those above step 5-8 is just a sample case)\n\nSo `Basket` shouldn't allow ownership transfer in the middle of the `Basket_M.withdrawMultipleERC721()` and similar multiple-token-withdraw functions or it should check the ownership in every iteration.\n\n## Tools Used\nVIM\n\n## Recommended Mitigation Steps\ncheck ownership of `id=0` in every iteration or don't allow ownership transfer in the multiple-token-transfer functions\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-06-nibbl-contest",
  "Code": [
    {
      "filename": "contracts/Basket.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport { ERC721, IERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { IERC165, ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport { IBasket } from \"./Interfaces/IBasket.sol\";\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n/**\n * Mint a single ERC721 which can hold NFTs\n */\ncontract Basket is IBasket, ERC721(\"NFT Basket\", \"NFTB\"), Initializable {\n\n    event DepositERC721(address indexed token, uint256 tokenId, address indexed from);\n    event WithdrawERC721(address indexed token, uint256 tokenId, address indexed to);\n    event DepositERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n    event DepositERC1155Bulk(address indexed token, uint256[] tokenId, uint256[] amount, address indexed from);\n    event WithdrawERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n    event WithdrawETH(address indexed who);\n    event WithdrawERC20(address indexed token, address indexed who);\n\n    function initialise(address _curator) external override initializer {\n        _mint(_curator, 0);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, IERC165) returns (bool) {\n        return\n            super.supportsInterface(interfaceId) || interfaceId == type(IBasket).interfaceId;\n    }\n\n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC721(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC721(_token).safeTransferFrom(address(this), _to, _tokenId);\n        emit WithdrawERC721(_token, _tokenId, _to);\n    }\n\n    function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC721(_tokens[i]).safeTransferFrom(address(this), _to, _tokenId[i]);\n            emit WithdrawERC721(_tokens[i], _tokenId[i], _to);\n        }\n    }\n    \n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC721Unsafe(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC721(_token).transferFrom(address(this), _to, _tokenId);\n        emit WithdrawERC721(_token, _tokenId, _to);\n    }\n    \n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC1155(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        uint256 _balance = IERC1155(_token).balanceOf(address(this),  _tokenId);\n        IERC1155(_token).safeTransferFrom(address(this), _to, _tokenId, _balance, \"0\");\n        emit WithdrawERC1155(_token, _tokenId, _balance, _to);\n    }\n\n    function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            uint256 _balance = IERC1155(_tokens[i]).balanceOf(address(this),  _tokenIds[i]);\n            IERC1155(_tokens[i]).safeTransferFrom(address(this), _to, _tokenIds[i], _balance, \"0\");\n            emit WithdrawERC1155(_tokens[i], _tokenIds[i], _balance, _to);\n        }\n    }\n\n    /// @notice withdraw ETH in the case a held NFT earned ETH (ie. euler beats)\n    function withdrawETH(address payable _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        _to.transfer(address(this).balance);\n        emit WithdrawETH(_to);\n    }\n\n    /// @notice withdraw ERC20 in the case a held NFT earned ERC20\n    function withdrawERC20(address _token) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC20(_token).transfer(msg.sender, IERC20(_token).balanceOf(address(this)));\n        emit WithdrawERC20(_token, msg.sender);\n    }\n\n    function withdrawMultipleERC20(address[] memory _tokens) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC20(_tokens[i]).transfer(msg.sender, IERC20(_tokens[i]).balanceOf(address(this)));\n            emit WithdrawERC20(_tokens[i], msg.sender);\n        }\n    }\n\n    function onERC721Received(address, address from, uint256 id, bytes memory) external override returns(bytes4) {\n        emit DepositERC721(msg.sender, id, from);\n        return this.onERC721Received.selector;\n    }\n\n    function onERC1155Received(address, address from, uint256 id, uint256 amount, bytes memory) external virtual override returns (bytes4) {\n        emit DepositERC1155(msg.sender, id, amount, from);\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) {\n        emit DepositERC1155Bulk(msg.sender, ids, amounts, from);\n        return this.onERC1155BatchReceived.selector;\n    }\n    \n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/Basket.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport { ERC721, IERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { IERC165, ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport { IBasket } from \"./Interfaces/IBasket.sol\";\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n/**\n * Mint a single ERC721 which can hold NFTs\n */\ncontract Basket is IBasket, ERC721(\"NFT Basket\", \"NFTB\"), Initializable {\n\n    event DepositERC721(address indexed token, uint256 tokenId, address indexed from);\n    event WithdrawERC721(address indexed token, uint256 tokenId, address indexed to);\n    event DepositERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n    event DepositERC1155Bulk(address indexed token, uint256[] tokenId, uint256[] amount, address indexed from);\n    event WithdrawERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n    event WithdrawETH(address indexed who);\n    event WithdrawERC20(address indexed token, address indexed who);\n\n    function initialise(address _curator) external override initializer {\n        _mint(_curator, 0);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, IERC165) returns (bool) {\n        return\n            super.supportsInterface(interfaceId) || interfaceId == type(IBasket).interfaceId;\n    }\n\n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC721(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC721(_token).safeTransferFrom(address(this), _to, _tokenId);\n        emit WithdrawERC721(_token, _tokenId, _to);\n    }\n\n    function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC721(_tokens[i]).safeTransferFrom(address(this), _to, _tokenId[i]);\n            emit WithdrawERC721(_tokens[i], _tokenId[i], _to);\n        }\n    }\n    \n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC721Unsafe(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC721(_token).transferFrom(address(this), _to, _tokenId);\n        emit WithdrawERC721(_token, _tokenId, _to);\n    }\n    \n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC1155(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        uint256 _balance = IERC1155(_token).balanceOf(address(this),  _tokenId);\n        IERC1155(_token).safeTransferFrom(address(this), _to, _tokenId, _balance, \"0\");\n        emit WithdrawERC1155(_token, _tokenId, _balance, _to);\n    }\n\n    function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            uint256 _balance = IERC1155(_tokens[i]).balanceOf(address(this),  _tokenIds[i]);\n            IERC1155(_tokens[i]).safeTransferFrom(address(this), _to, _tokenIds[i], _balance, \"0\");\n            emit WithdrawERC1155(_tokens[i], _tokenIds[i], _balance, _to);\n        }\n    }\n\n    /// @notice withdraw ETH in the case a held NFT earned ETH (ie. euler beats)\n    function withdrawETH(address payable _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        _to.transfer(address(this).balance);\n        emit WithdrawETH(_to);\n    }\n\n    /// @notice withdraw ERC20 in the case a held NFT earned ERC20\n    function withdrawERC20(address _token) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC20(_token).transfer(msg.sender, IERC20(_token).balanceOf(address(this)));\n        emit WithdrawERC20(_token, msg.sender);\n    }\n\n    function withdrawMultipleERC20(address[] memory _tokens) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC20(_tokens[i]).transfer(msg.sender, IERC20(_tokens[i]).balanceOf(address(this)));\n            emit WithdrawERC20(_tokens[i], msg.sender);\n        }\n    }\n\n    function onERC721Received(address, address from, uint256 id, bytes memory) external override returns(bytes4) {\n        emit DepositERC721(msg.sender, id, from);\n        return this.onERC721Received.selector;\n    }\n\n    function onERC1155Received(address, address from, uint256 id, uint256 amount, bytes memory) external virtual override returns (bytes4) {\n        emit DepositERC1155(msg.sender, id, amount, from);\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) {\n        emit DepositERC1155Bulk(msg.sender, ids, amounts, from);\n        return this.onERC1155BatchReceived.selector;\n    }\n    \n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/Basket.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport { ERC721, IERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { IERC165, ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport { IBasket } from \"./Interfaces/IBasket.sol\";\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n/**\n * Mint a single ERC721 which can hold NFTs\n */\ncontract Basket is IBasket, ERC721(\"NFT Basket\", \"NFTB\"), Initializable {\n\n    event DepositERC721(address indexed token, uint256 tokenId, address indexed from);\n    event WithdrawERC721(address indexed token, uint256 tokenId, address indexed to);\n    event DepositERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n    event DepositERC1155Bulk(address indexed token, uint256[] tokenId, uint256[] amount, address indexed from);\n    event WithdrawERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n    event WithdrawETH(address indexed who);\n    event WithdrawERC20(address indexed token, address indexed who);\n\n    function initialise(address _curator) external override initializer {\n        _mint(_curator, 0);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, IERC165) returns (bool) {\n        return\n            super.supportsInterface(interfaceId) || interfaceId == type(IBasket).interfaceId;\n    }\n\n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC721(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC721(_token).safeTransferFrom(address(this), _to, _tokenId);\n        emit WithdrawERC721(_token, _tokenId, _to);\n    }\n\n    function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC721(_tokens[i]).safeTransferFrom(address(this), _to, _tokenId[i]);\n            emit WithdrawERC721(_tokens[i], _tokenId[i], _to);\n        }\n    }\n    \n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC721Unsafe(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC721(_token).transferFrom(address(this), _to, _tokenId);\n        emit WithdrawERC721(_token, _tokenId, _to);\n    }\n    \n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC1155(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        uint256 _balance = IERC1155(_token).balanceOf(address(this),  _tokenId);\n        IERC1155(_token).safeTransferFrom(address(this), _to, _tokenId, _balance, \"0\");\n        emit WithdrawERC1155(_token, _tokenId, _balance, _to);\n    }\n\n    function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            uint256 _balance = IERC1155(_tokens[i]).balanceOf(address(this),  _tokenIds[i]);\n            IERC1155(_tokens[i]).safeTransferFrom(address(this), _to, _tokenIds[i], _balance, \"0\");\n            emit WithdrawERC1155(_tokens[i], _tokenIds[i], _balance, _to);\n        }\n    }\n\n    /// @notice withdraw ETH in the case a held NFT earned ETH (ie. euler beats)\n    function withdrawETH(address payable _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        _to.transfer(address(this).balance);\n        emit WithdrawETH(_to);\n    }\n\n    /// @notice withdraw ERC20 in the case a held NFT earned ERC20\n    function withdrawERC20(address _token) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC20(_token).transfer(msg.sender, IERC20(_token).balanceOf(address(this)));\n        emit WithdrawERC20(_token, msg.sender);\n    }\n\n    function withdrawMultipleERC20(address[] memory _tokens) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC20(_tokens[i]).transfer(msg.sender, IERC20(_tokens[i]).balanceOf(address(this)));\n            emit WithdrawERC20(_tokens[i], msg.sender);\n        }\n    }\n\n    function onERC721Received(address, address from, uint256 id, bytes memory) external override returns(bytes4) {\n        emit DepositERC721(msg.sender, id, from);\n        return this.onERC721Received.selector;\n    }\n\n    function onERC1155Received(address, address from, uint256 id, uint256 amount, bytes memory) external virtual override returns (bytes4) {\n        emit DepositERC1155(msg.sender, id, amount, from);\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) {\n        emit DepositERC1155Bulk(msg.sender, ids, amounts, from);\n        return this.onERC1155BatchReceived.selector;\n    }\n    \n    receive() external payable {}\n}"
    }
  ]
}