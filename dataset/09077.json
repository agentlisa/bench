{
  "Title": "[M-06] Yield can be unfairly divided because of MEV/Just-in-time stablecoin deposits",
  "Content": "_Submitted by mtz, also found by 0x52, hyh, jonah1005, leastwood, and sorrynotsorry_\n\n[YieldManager.sol#L129-L134](https://github.com/code-423n4/2022-05-sturdy/blob/main/smart-contracts/YieldManager.sol#L129-L134)<br>\n[YieldManager.sol#L160-L161](https://github.com/code-423n4/2022-05-sturdy/blob/main/smart-contracts/YieldManager.sol#L160-L161)<br>\n\nAn attacker can use MEV (via gas auction or Flashbots or control of miners) to cause an unfair division of yield. By providing a very large (relative to the size of all other stablecoin deposits combined) stablecoin deposit Just-in-Time before an admin's call to [distributeYield](https://github.com/code-423n4/2022-05-sturdy/blob/main/smart-contracts/YieldManager.sol#L118) the stablecoin deposited by the attacker will receive a very large amount of the yield and the attacker can immediately withdraw their deposit after yield is distributed. We assume this allows an attacker to get a lot of the yield reward even though they haven't provided any deposit that has been borrowed. However, the exact mechanism for how yield is distributed to lenders of a particular stablecoin is in LendingPool.sol, which is out of scope. However it is implied in [the documentation of this repo](https://github.com/code-423n4/2022-05-sturdy/blob/main/README.md?plain=1#L52) that it is based on the balance of that asset the lender has provided. We have confirmed that [in LendingPool.sol the yield is distributed based on the proportion of the asset provided](https://github.com/sturdyfi/code4rena-may-2022/blob/d53f4f5f0b7b33a66e0081294be6117f6d6e17b4/contracts/protocol/lendingpool/LendingPool.sol#L182). However, even ignoring this, MEV can still be used to unfairly hurt lenders of other stablecoins.\n\n### Proof of Concept\n\n1.  An attacker watches the mempool for calls to [distributeYield](https://github.com/code-423n4/2022-05-sturdy/blob/main/smart-contracts/YieldManager.sol#L118) by the admin.\n2.  The attacker orders the block's transactions (most easily using a flashbots bundle) in the following order:<br>\n    i. Attacker deposits stablecoins to lend (ideally the stablecoin will be the one with the least volume).<br>\n    ii. admin's call to distributeYield happens.<br>\n    iii. Attacker withdraws their deposit.<br>\n\nThe attacker has thus made the asset they deposited (and thus themselves) receive much of the yield even though they provide no value to Sturdy since none of their deposit is ever borrowed so the never do anything to earn yield for sturdy.\nThis attack can be done by a whale or by borrowing (even from sturdy) assets and converting them to a stablecoins accepted by sturdy before i. and returning them after iii. This will essentially be cost free for the attacker, none of their capital will ever be tied up by borrowers.\n\n### Recommended Mitigation Steps\n\nThe simplest way to mitigate this is for the admin to use flashbots or some other means of submitting the distributeYield call that skips the mempool. This is only a partial mitigation since attackers can still withdraw right after yield is distributed and get lucky by depositing soon before the distribution thus still capture more yield than they should have.<br>\nA better mitigation could use something like snapshotting who has deposited since the last yield distribution and only give these depositers yield based on the size of their deposits the next time yield is distributed.\n\n**[sforman2000 (Sturdy) confirmed and commented](https://github.com/code-423n4/2022-05-sturdy-findings/issues/61#issuecomment-1129546404):**\n > We will use flashbots and vary when/how often yield is harvested to mitigate this.\n\n**[hickuphh3 (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-05-sturdy-findings/issues/61#issuecomment-1145681249):**\n > I take reference to discussions on Discord and in a thread below:\n> https://github.com/code-423n4/2022-03-biconomy-findings/issues/135\n> \n> To quote from 0xleastwood: \"Protocol leaked value in has a broad context but I think most judges can agree that it would pertain to rewards being paid out a lower rate than expected. Or, users can extract small amounts (up to debate on what is considered to be small) from the protocol under certain assumptions.\" \n> \n> Hence, as per the TLDR risk assessment: <br>\n> `2 â€” Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.`\n> \n> I would downgrade this to a medium severity.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-sturdy-contest",
  "Code": [
    {
      "filename": "smart-contracts/YieldManager.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {Errors} from '../libraries/helpers/Errors.sol';\nimport {VersionedInitializable} from '../../protocol/libraries/sturdy-upgradeability/VersionedInitializable.sol';\nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol';\nimport {ILendingPool} from '../../interfaces/ILendingPool.sol';\nimport {IPriceOracleGetter} from '../../interfaces/IPriceOracleGetter.sol';\nimport {ISwapRouter} from '../../interfaces/ISwapRouter.sol';\nimport {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {IERC20Detailed} from '../../dependencies/openzeppelin/contracts/IERC20Detailed.sol';\nimport {Ownable} from '../../dependencies/openzeppelin/contracts/Ownable.sol';\nimport {PercentageMath} from '../libraries/math/PercentageMath.sol';\nimport {SafeMath} from '../../dependencies/openzeppelin/contracts/SafeMath.sol';\nimport {TransferHelper} from '../libraries/helpers/TransferHelper.sol';\nimport {UniswapAdapter} from '../libraries/swap/UniswapAdapter.sol';\nimport {CurveswapAdapter} from '../libraries/swap/CurveswapAdapter.sol';\n\n/**\n * @title YieldManager\n * @notice yield distributor by swapping from assets to stable coin\n * @author Sturdy\n **/\n\ncontract YieldManager is VersionedInitializable, Ownable {\n  using SafeMath for uint256;\n  using PercentageMath for uint256;\n\n  struct AssetYield {\n    address asset;\n    uint256 amount;\n  }\n\n  // the list of the available reserves, structured as a mapping for gas savings reasons\n  mapping(uint256 => address) internal _assetsList;\n  uint256 internal _assetsCount;\n\n  ILendingPoolAddressesProvider internal _addressesProvider;\n\n  uint256 public constant VAULT_REVISION = 0x1;\n\n  address public _exchangeToken;\n\n  // tokenIn -> tokenOut -> Curve Pool Address\n  mapping(address => mapping(address => address)) internal _curvePools;\n\n  uint256 public constant UNISWAP_FEE = 10000; // 1%\n  uint256 public constant SLIPPAGE = 500; // 5%\n\n  modifier onlyAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  /**\n   * @dev Function is invoked by the proxy contract when the Vault contract is deployed.\n   * @param _provider The address of the provider\n   **/\n  function initialize(ILendingPoolAddressesProvider _provider) public initializer {\n    _addressesProvider = _provider;\n  }\n\n  function setExchangeToken(address _token) external onlyAdmin {\n    require(_token != address(0), Errors.VT_INVALID_CONFIGURATION);\n    _exchangeToken = _token;\n  }\n\n  function getRevision() internal pure override returns (uint256) {\n    return VAULT_REVISION;\n  }\n\n  function registerAsset(address _asset) external onlyAdmin {\n    _assetsList[_assetsCount] = _asset;\n    _assetsCount = _assetsCount + 1;\n  }\n\n  function getAssetCount() external view returns (uint256) {\n    return _assetsCount;\n  }\n\n  function getAssetInfo(uint256 _index) external view returns (address) {\n    return _assetsList[_index];\n  }\n\n  /**\n   * @dev Function to set Curve Pool address for the swap\n   * @param _tokenIn The address of token being exchanged\n   * @param _tokenOut The address of token being received\n   * @param _pool The address of the Curve pool to use for the swap\n   */\n  function setCurvePool(\n    address _tokenIn,\n    address _tokenOut,\n    address _pool\n  ) external onlyAdmin {\n    require(_pool != address(0), Errors.VT_INVALID_CONFIGURATION);\n    _curvePools[_tokenIn][_tokenOut] = _pool;\n  }\n\n  /**\n   * @dev Function to get Curve Pool address for the swap\n   * @param _tokenIn The address of token being sent\n   * @param _tokenOut The address of token being received\n   */\n  function getCurvePool(address _tokenIn, address _tokenOut) external view returns (address) {\n    return _curvePools[_tokenIn][_tokenOut];\n  }\n\n  /**\n   * @dev Distribute the yield of assets to suppliers.\n   *      1. convert asset to exchange token(for now it's USDC) via Uniswap\n   *      2. convert exchange token to other stables via Curve\n   *      3. deposit to pool for suppliers\n   * @param _offset assets array's start offset.\n   * @param _count assets array's count when perform distribution.\n   **/\n  function distributeYield(uint256 _offset, uint256 _count) external onlyAdmin {\n    // 1. convert from asset to exchange token via uniswap\n    for (uint256 i = 0; i < _count; i++) {\n      address asset = _assetsList[_offset + i];\n      require(asset != address(0), Errors.UL_INVALID_INDEX);\n      uint256 _amount = IERC20Detailed(asset).balanceOf(address(this));\n      _convertAssetToExchangeToken(asset, _amount);\n    }\n    uint256 exchangedAmount = IERC20Detailed(_exchangeToken).balanceOf(address(this));\n\n    // 2. convert from exchange token to other stable assets via curve swap\n    AssetYield[] memory assetYields = _getAssetYields(exchangedAmount);\n    for (uint256 i = 0; i < assetYields.length; i++) {\n      if (assetYields[i].amount > 0) {\n        uint256 _amount = _convertToStableCoin(assetYields[i].asset, assetYields[i].amount);\n        // 3. deposit Yield to pool for suppliers\n        _depositYield(assetYields[i].asset, _amount);\n      }\n    }\n  }\n\n  /**\n   * @dev Get the list of asset and asset's yield amount\n   **/\n  function _getAssetYields(uint256 _totalYieldAmount) internal view returns (AssetYield[] memory) {\n    // Get total borrowing asset volume and volumes and assets\n    (\n      uint256 totalVolume,\n      uint256[] memory volumes,\n      address[] memory assets,\n      uint256 length\n    ) = ILendingPool(_addressesProvider.getLendingPool()).getBorrowingAssetAndVolumes();\n\n    if (totalVolume == 0) return new AssetYield[](0);\n\n    AssetYield[] memory assetYields = new AssetYield[](length);\n    uint256 extraYieldAmount = _totalYieldAmount;\n\n    for (uint256 i = 0; i < length; i++) {\n      assetYields[i].asset = assets[i];\n      if (i != length - 1) {\n        // Distribute yieldAmount based on percent of asset volume\n        assetYields[i].amount = _totalYieldAmount.percentMul(\n          volumes[i].mul(PercentageMath.PERCENTAGE_FACTOR).div(totalVolume)\n        );\n        extraYieldAmount = extraYieldAmount.sub(assetYields[i].amount);\n      } else {\n        // without calculation, set remained extra amount\n        assetYields[i].amount = extraYieldAmount;\n      }\n    }\n\n    return assetYields;\n  }\n\n  /**\n   * @dev Convert asset to exchange token via Uniswap\n   * @param asset The address of asset being exchanged\n   * @param amount The amount of asset being exchanged\n   */\n  function _convertAssetToExchangeToken(address asset, uint256 amount) internal {\n    UniswapAdapter.swapExactTokensForTokens(\n      _addressesProvider,\n      asset,\n      _exchangeToken,\n      amount,\n      UNISWAP_FEE,\n      SLIPPAGE\n    );\n  }\n\n  /**\n   * @dev The function to convert from exchange token to stable coin via Curve\n   * @param _tokenOut The address of stable coin\n   * @param _amount The amount of exchange token being sent\n   * @return receivedAmount The amount of stable coin converted\n   */\n  function _convertToStableCoin(address _tokenOut, uint256 _amount)\n    internal\n    returns (uint256 receivedAmount)\n  {\n    if (_tokenOut == _exchangeToken) {\n      return _amount;\n    }\n    address _pool = _curvePools[_exchangeToken][_tokenOut];\n    require(_pool != address(0), Errors.VT_INVALID_CONFIGURATION);\n    receivedAmount = CurveswapAdapter.swapExactTokensForTokens(\n      _addressesProvider,\n      _pool,\n      _exchangeToken,\n      _tokenOut,\n      _amount,\n      SLIPPAGE\n    );\n  }\n\n  /**\n   * @dev The function to deposit yield to pool for suppliers\n   * @param _asset The address of yield asset\n   * @param _amount The mount of asset\n   */\n  function _depositYield(address _asset, uint256 _amount) internal {\n    address _lendingPool = _addressesProvider.getLendingPool();\n    IERC20(_asset).approve(_lendingPool, _amount);\n    ILendingPool(_lendingPool).depositYield(_asset, _amount);\n  }\n}"
    },
    {
      "filename": "smart-contracts/YieldManager.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {Errors} from '../libraries/helpers/Errors.sol';\nimport {VersionedInitializable} from '../../protocol/libraries/sturdy-upgradeability/VersionedInitializable.sol';\nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol';\nimport {ILendingPool} from '../../interfaces/ILendingPool.sol';\nimport {IPriceOracleGetter} from '../../interfaces/IPriceOracleGetter.sol';\nimport {ISwapRouter} from '../../interfaces/ISwapRouter.sol';\nimport {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {IERC20Detailed} from '../../dependencies/openzeppelin/contracts/IERC20Detailed.sol';\nimport {Ownable} from '../../dependencies/openzeppelin/contracts/Ownable.sol';\nimport {PercentageMath} from '../libraries/math/PercentageMath.sol';\nimport {SafeMath} from '../../dependencies/openzeppelin/contracts/SafeMath.sol';\nimport {TransferHelper} from '../libraries/helpers/TransferHelper.sol';\nimport {UniswapAdapter} from '../libraries/swap/UniswapAdapter.sol';\nimport {CurveswapAdapter} from '../libraries/swap/CurveswapAdapter.sol';\n\n/**\n * @title YieldManager\n * @notice yield distributor by swapping from assets to stable coin\n * @author Sturdy\n **/\n\ncontract YieldManager is VersionedInitializable, Ownable {\n  using SafeMath for uint256;\n  using PercentageMath for uint256;\n\n  struct AssetYield {\n    address asset;\n    uint256 amount;\n  }\n\n  // the list of the available reserves, structured as a mapping for gas savings reasons\n  mapping(uint256 => address) internal _assetsList;\n  uint256 internal _assetsCount;\n\n  ILendingPoolAddressesProvider internal _addressesProvider;\n\n  uint256 public constant VAULT_REVISION = 0x1;\n\n  address public _exchangeToken;\n\n  // tokenIn -> tokenOut -> Curve Pool Address\n  mapping(address => mapping(address => address)) internal _curvePools;\n\n  uint256 public constant UNISWAP_FEE = 10000; // 1%\n  uint256 public constant SLIPPAGE = 500; // 5%\n\n  modifier onlyAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  /**\n   * @dev Function is invoked by the proxy contract when the Vault contract is deployed.\n   * @param _provider The address of the provider\n   **/\n  function initialize(ILendingPoolAddressesProvider _provider) public initializer {\n    _addressesProvider = _provider;\n  }\n\n  function setExchangeToken(address _token) external onlyAdmin {\n    require(_token != address(0), Errors.VT_INVALID_CONFIGURATION);\n    _exchangeToken = _token;\n  }\n\n  function getRevision() internal pure override returns (uint256) {\n    return VAULT_REVISION;\n  }\n\n  function registerAsset(address _asset) external onlyAdmin {\n    _assetsList[_assetsCount] = _asset;\n    _assetsCount = _assetsCount + 1;\n  }\n\n  function getAssetCount() external view returns (uint256) {\n    return _assetsCount;\n  }\n\n  function getAssetInfo(uint256 _index) external view returns (address) {\n    return _assetsList[_index];\n  }\n\n  /**\n   * @dev Function to set Curve Pool address for the swap\n   * @param _tokenIn The address of token being exchanged\n   * @param _tokenOut The address of token being received\n   * @param _pool The address of the Curve pool to use for the swap\n   */\n  function setCurvePool(\n    address _tokenIn,\n    address _tokenOut,\n    address _pool\n  ) external onlyAdmin {\n    require(_pool != address(0), Errors.VT_INVALID_CONFIGURATION);\n    _curvePools[_tokenIn][_tokenOut] = _pool;\n  }\n\n  /**\n   * @dev Function to get Curve Pool address for the swap\n   * @param _tokenIn The address of token being sent\n   * @param _tokenOut The address of token being received\n   */\n  function getCurvePool(address _tokenIn, address _tokenOut) external view returns (address) {\n    return _curvePools[_tokenIn][_tokenOut];\n  }\n\n  /**\n   * @dev Distribute the yield of assets to suppliers.\n   *      1. convert asset to exchange token(for now it's USDC) via Uniswap\n   *      2. convert exchange token to other stables via Curve\n   *      3. deposit to pool for suppliers\n   * @param _offset assets array's start offset.\n   * @param _count assets array's count when perform distribution.\n   **/\n  function distributeYield(uint256 _offset, uint256 _count) external onlyAdmin {\n    // 1. convert from asset to exchange token via uniswap\n    for (uint256 i = 0; i < _count; i++) {\n      address asset = _assetsList[_offset + i];\n      require(asset != address(0), Errors.UL_INVALID_INDEX);\n      uint256 _amount = IERC20Detailed(asset).balanceOf(address(this));\n      _convertAssetToExchangeToken(asset, _amount);\n    }\n    uint256 exchangedAmount = IERC20Detailed(_exchangeToken).balanceOf(address(this));\n\n    // 2. convert from exchange token to other stable assets via curve swap\n    AssetYield[] memory assetYields = _getAssetYields(exchangedAmount);\n    for (uint256 i = 0; i < assetYields.length; i++) {\n      if (assetYields[i].amount > 0) {\n        uint256 _amount = _convertToStableCoin(assetYields[i].asset, assetYields[i].amount);\n        // 3. deposit Yield to pool for suppliers\n        _depositYield(assetYields[i].asset, _amount);\n      }\n    }\n  }\n\n  /**\n   * @dev Get the list of asset and asset's yield amount\n   **/\n  function _getAssetYields(uint256 _totalYieldAmount) internal view returns (AssetYield[] memory) {\n    // Get total borrowing asset volume and volumes and assets\n    (\n      uint256 totalVolume,\n      uint256[] memory volumes,\n      address[] memory assets,\n      uint256 length\n    ) = ILendingPool(_addressesProvider.getLendingPool()).getBorrowingAssetAndVolumes();\n\n    if (totalVolume == 0) return new AssetYield[](0);\n\n    AssetYield[] memory assetYields = new AssetYield[](length);\n    uint256 extraYieldAmount = _totalYieldAmount;\n\n    for (uint256 i = 0; i < length; i++) {\n      assetYields[i].asset = assets[i];\n      if (i != length - 1) {\n        // Distribute yieldAmount based on percent of asset volume\n        assetYields[i].amount = _totalYieldAmount.percentMul(\n          volumes[i].mul(PercentageMath.PERCENTAGE_FACTOR).div(totalVolume)\n        );\n        extraYieldAmount = extraYieldAmount.sub(assetYields[i].amount);\n      } else {\n        // without calculation, set remained extra amount\n        assetYields[i].amount = extraYieldAmount;\n      }\n    }\n\n    return assetYields;\n  }\n\n  /**\n   * @dev Convert asset to exchange token via Uniswap\n   * @param asset The address of asset being exchanged\n   * @param amount The amount of asset being exchanged\n   */\n  function _convertAssetToExchangeToken(address asset, uint256 amount) internal {\n    UniswapAdapter.swapExactTokensForTokens(\n      _addressesProvider,\n      asset,\n      _exchangeToken,\n      amount,\n      UNISWAP_FEE,\n      SLIPPAGE\n    );\n  }\n\n  /**\n   * @dev The function to convert from exchange token to stable coin via Curve\n   * @param _tokenOut The address of stable coin\n   * @param _amount The amount of exchange token being sent\n   * @return receivedAmount The amount of stable coin converted\n   */\n  function _convertToStableCoin(address _tokenOut, uint256 _amount)\n    internal\n    returns (uint256 receivedAmount)\n  {\n    if (_tokenOut == _exchangeToken) {\n      return _amount;\n    }\n    address _pool = _curvePools[_exchangeToken][_tokenOut];\n    require(_pool != address(0), Errors.VT_INVALID_CONFIGURATION);\n    receivedAmount = CurveswapAdapter.swapExactTokensForTokens(\n      _addressesProvider,\n      _pool,\n      _exchangeToken,\n      _tokenOut,\n      _amount,\n      SLIPPAGE\n    );\n  }\n\n  /**\n   * @dev The function to deposit yield to pool for suppliers\n   * @param _asset The address of yield asset\n   * @param _amount The mount of asset\n   */\n  function _depositYield(address _asset, uint256 _amount) internal {\n    address _lendingPool = _addressesProvider.getLendingPool();\n    IERC20(_asset).approve(_lendingPool, _amount);\n    ILendingPool(_lendingPool).depositYield(_asset, _amount);\n  }\n}"
    },
    {
      "filename": "smart-contracts/YieldManager.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {Errors} from '../libraries/helpers/Errors.sol';\nimport {VersionedInitializable} from '../../protocol/libraries/sturdy-upgradeability/VersionedInitializable.sol';\nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol';\nimport {ILendingPool} from '../../interfaces/ILendingPool.sol';\nimport {IPriceOracleGetter} from '../../interfaces/IPriceOracleGetter.sol';\nimport {ISwapRouter} from '../../interfaces/ISwapRouter.sol';\nimport {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {IERC20Detailed} from '../../dependencies/openzeppelin/contracts/IERC20Detailed.sol';\nimport {Ownable} from '../../dependencies/openzeppelin/contracts/Ownable.sol';\nimport {PercentageMath} from '../libraries/math/PercentageMath.sol';\nimport {SafeMath} from '../../dependencies/openzeppelin/contracts/SafeMath.sol';\nimport {TransferHelper} from '../libraries/helpers/TransferHelper.sol';\nimport {UniswapAdapter} from '../libraries/swap/UniswapAdapter.sol';\nimport {CurveswapAdapter} from '../libraries/swap/CurveswapAdapter.sol';\n\n/**\n * @title YieldManager\n * @notice yield distributor by swapping from assets to stable coin\n * @author Sturdy\n **/\n\ncontract YieldManager is VersionedInitializable, Ownable {\n  using SafeMath for uint256;\n  using PercentageMath for uint256;\n\n  struct AssetYield {\n    address asset;\n    uint256 amount;\n  }\n\n  // the list of the available reserves, structured as a mapping for gas savings reasons\n  mapping(uint256 => address) internal _assetsList;\n  uint256 internal _assetsCount;\n\n  ILendingPoolAddressesProvider internal _addressesProvider;\n\n  uint256 public constant VAULT_REVISION = 0x1;\n\n  address public _exchangeToken;\n\n  // tokenIn -> tokenOut -> Curve Pool Address\n  mapping(address => mapping(address => address)) internal _curvePools;\n\n  uint256 public constant UNISWAP_FEE = 10000; // 1%\n  uint256 public constant SLIPPAGE = 500; // 5%\n\n  modifier onlyAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  /**\n   * @dev Function is invoked by the proxy contract when the Vault contract is deployed.\n   * @param _provider The address of the provider\n   **/\n  function initialize(ILendingPoolAddressesProvider _provider) public initializer {\n    _addressesProvider = _provider;\n  }\n\n  function setExchangeToken(address _token) external onlyAdmin {\n    require(_token != address(0), Errors.VT_INVALID_CONFIGURATION);\n    _exchangeToken = _token;\n  }\n\n  function getRevision() internal pure override returns (uint256) {\n    return VAULT_REVISION;\n  }\n\n  function registerAsset(address _asset) external onlyAdmin {\n    _assetsList[_assetsCount] = _asset;\n    _assetsCount = _assetsCount + 1;\n  }\n\n  function getAssetCount() external view returns (uint256) {\n    return _assetsCount;\n  }\n\n  function getAssetInfo(uint256 _index) external view returns (address) {\n    return _assetsList[_index];\n  }\n\n  /**\n   * @dev Function to set Curve Pool address for the swap\n   * @param _tokenIn The address of token being exchanged\n   * @param _tokenOut The address of token being received\n   * @param _pool The address of the Curve pool to use for the swap\n   */\n  function setCurvePool(\n    address _tokenIn,\n    address _tokenOut,\n    address _pool\n  ) external onlyAdmin {\n    require(_pool != address(0), Errors.VT_INVALID_CONFIGURATION);\n    _curvePools[_tokenIn][_tokenOut] = _pool;\n  }\n\n  /**\n   * @dev Function to get Curve Pool address for the swap\n   * @param _tokenIn The address of token being sent\n   * @param _tokenOut The address of token being received\n   */\n  function getCurvePool(address _tokenIn, address _tokenOut) external view returns (address) {\n    return _curvePools[_tokenIn][_tokenOut];\n  }\n\n  /**\n   * @dev Distribute the yield of assets to suppliers.\n   *      1. convert asset to exchange token(for now it's USDC) via Uniswap\n   *      2. convert exchange token to other stables via Curve\n   *      3. deposit to pool for suppliers\n   * @param _offset assets array's start offset.\n   * @param _count assets array's count when perform distribution.\n   **/\n  function distributeYield(uint256 _offset, uint256 _count) external onlyAdmin {\n    // 1. convert from asset to exchange token via uniswap\n    for (uint256 i = 0; i < _count; i++) {\n      address asset = _assetsList[_offset + i];\n      require(asset != address(0), Errors.UL_INVALID_INDEX);\n      uint256 _amount = IERC20Detailed(asset).balanceOf(address(this));\n      _convertAssetToExchangeToken(asset, _amount);\n    }\n    uint256 exchangedAmount = IERC20Detailed(_exchangeToken).balanceOf(address(this));\n\n    // 2. convert from exchange token to other stable assets via curve swap\n    AssetYield[] memory assetYields = _getAssetYields(exchangedAmount);\n    for (uint256 i = 0; i < assetYields.length; i++) {\n      if (assetYields[i].amount > 0) {\n        uint256 _amount = _convertToStableCoin(assetYields[i].asset, assetYields[i].amount);\n        // 3. deposit Yield to pool for suppliers\n        _depositYield(assetYields[i].asset, _amount);\n      }\n    }\n  }\n\n  /**\n   * @dev Get the list of asset and asset's yield amount\n   **/\n  function _getAssetYields(uint256 _totalYieldAmount) internal view returns (AssetYield[] memory) {\n    // Get total borrowing asset volume and volumes and assets\n    (\n      uint256 totalVolume,\n      uint256[] memory volumes,\n      address[] memory assets,\n      uint256 length\n    ) = ILendingPool(_addressesProvider.getLendingPool()).getBorrowingAssetAndVolumes();\n\n    if (totalVolume == 0) return new AssetYield[](0);\n\n    AssetYield[] memory assetYields = new AssetYield[](length);\n    uint256 extraYieldAmount = _totalYieldAmount;\n\n    for (uint256 i = 0; i < length; i++) {\n      assetYields[i].asset = assets[i];\n      if (i != length - 1) {\n        // Distribute yieldAmount based on percent of asset volume\n        assetYields[i].amount = _totalYieldAmount.percentMul(\n          volumes[i].mul(PercentageMath.PERCENTAGE_FACTOR).div(totalVolume)\n        );\n        extraYieldAmount = extraYieldAmount.sub(assetYields[i].amount);\n      } else {\n        // without calculation, set remained extra amount\n        assetYields[i].amount = extraYieldAmount;\n      }\n    }\n\n    return assetYields;\n  }\n\n  /**\n   * @dev Convert asset to exchange token via Uniswap\n   * @param asset The address of asset being exchanged\n   * @param amount The amount of asset being exchanged\n   */\n  function _convertAssetToExchangeToken(address asset, uint256 amount) internal {\n    UniswapAdapter.swapExactTokensForTokens(\n      _addressesProvider,\n      asset,\n      _exchangeToken,\n      amount,\n      UNISWAP_FEE,\n      SLIPPAGE\n    );\n  }\n\n  /**\n   * @dev The function to convert from exchange token to stable coin via Curve\n   * @param _tokenOut The address of stable coin\n   * @param _amount The amount of exchange token being sent\n   * @return receivedAmount The amount of stable coin converted\n   */\n  function _convertToStableCoin(address _tokenOut, uint256 _amount)\n    internal\n    returns (uint256 receivedAmount)\n  {\n    if (_tokenOut == _exchangeToken) {\n      return _amount;\n    }\n    address _pool = _curvePools[_exchangeToken][_tokenOut];\n    require(_pool != address(0), Errors.VT_INVALID_CONFIGURATION);\n    receivedAmount = CurveswapAdapter.swapExactTokensForTokens(\n      _addressesProvider,\n      _pool,\n      _exchangeToken,\n      _tokenOut,\n      _amount,\n      SLIPPAGE\n    );\n  }\n\n  /**\n   * @dev The function to deposit yield to pool for suppliers\n   * @param _asset The address of yield asset\n   * @param _amount The mount of asset\n   */\n  function _depositYield(address _asset, uint256 _amount) internal {\n    address _lendingPool = _addressesProvider.getLendingPool();\n    IERC20(_asset).approve(_lendingPool, _amount);\n    ILendingPool(_lendingPool).depositYield(_asset, _amount);\n  }\n}"
    },
    {
      "filename": "smart-contracts/YieldManager.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {Errors} from '../libraries/helpers/Errors.sol';\nimport {VersionedInitializable} from '../../protocol/libraries/sturdy-upgradeability/VersionedInitializable.sol';\nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol';\nimport {ILendingPool} from '../../interfaces/ILendingPool.sol';\nimport {IPriceOracleGetter} from '../../interfaces/IPriceOracleGetter.sol';\nimport {ISwapRouter} from '../../interfaces/ISwapRouter.sol';\nimport {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {IERC20Detailed} from '../../dependencies/openzeppelin/contracts/IERC20Detailed.sol';\nimport {Ownable} from '../../dependencies/openzeppelin/contracts/Ownable.sol';\nimport {PercentageMath} from '../libraries/math/PercentageMath.sol';\nimport {SafeMath} from '../../dependencies/openzeppelin/contracts/SafeMath.sol';\nimport {TransferHelper} from '../libraries/helpers/TransferHelper.sol';\nimport {UniswapAdapter} from '../libraries/swap/UniswapAdapter.sol';\nimport {CurveswapAdapter} from '../libraries/swap/CurveswapAdapter.sol';\n\n/**\n * @title YieldManager\n * @notice yield distributor by swapping from assets to stable coin\n * @author Sturdy\n **/\n\ncontract YieldManager is VersionedInitializable, Ownable {\n  using SafeMath for uint256;\n  using PercentageMath for uint256;\n\n  struct AssetYield {\n    address asset;\n    uint256 amount;\n  }\n\n  // the list of the available reserves, structured as a mapping for gas savings reasons\n  mapping(uint256 => address) internal _assetsList;\n  uint256 internal _assetsCount;\n\n  ILendingPoolAddressesProvider internal _addressesProvider;\n\n  uint256 public constant VAULT_REVISION = 0x1;\n\n  address public _exchangeToken;\n\n  // tokenIn -> tokenOut -> Curve Pool Address\n  mapping(address => mapping(address => address)) internal _curvePools;\n\n  uint256 public constant UNISWAP_FEE = 10000; // 1%\n  uint256 public constant SLIPPAGE = 500; // 5%\n\n  modifier onlyAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  /**\n   * @dev Function is invoked by the proxy contract when the Vault contract is deployed.\n   * @param _provider The address of the provider\n   **/\n  function initialize(ILendingPoolAddressesProvider _provider) public initializer {\n    _addressesProvider = _provider;\n  }\n\n  function setExchangeToken(address _token) external onlyAdmin {\n    require(_token != address(0), Errors.VT_INVALID_CONFIGURATION);\n    _exchangeToken = _token;\n  }\n\n  function getRevision() internal pure override returns (uint256) {\n    return VAULT_REVISION;\n  }\n\n  function registerAsset(address _asset) external onlyAdmin {\n    _assetsList[_assetsCount] = _asset;\n    _assetsCount = _assetsCount + 1;\n  }\n\n  function getAssetCount() external view returns (uint256) {\n    return _assetsCount;\n  }\n\n  function getAssetInfo(uint256 _index) external view returns (address) {\n    return _assetsList[_index];\n  }\n\n  /**\n   * @dev Function to set Curve Pool address for the swap\n   * @param _tokenIn The address of token being exchanged\n   * @param _tokenOut The address of token being received\n   * @param _pool The address of the Curve pool to use for the swap\n   */\n  function setCurvePool(\n    address _tokenIn,\n    address _tokenOut,\n    address _pool\n  ) external onlyAdmin {\n    require(_pool != address(0), Errors.VT_INVALID_CONFIGURATION);\n    _curvePools[_tokenIn][_tokenOut] = _pool;\n  }\n\n  /**\n   * @dev Function to get Curve Pool address for the swap\n   * @param _tokenIn The address of token being sent\n   * @param _tokenOut The address of token being received\n   */\n  function getCurvePool(address _tokenIn, address _tokenOut) external view returns (address) {\n    return _curvePools[_tokenIn][_tokenOut];\n  }\n\n  /**\n   * @dev Distribute the yield of assets to suppliers.\n   *      1. convert asset to exchange token(for now it's USDC) via Uniswap\n   *      2. convert exchange token to other stables via Curve\n   *      3. deposit to pool for suppliers\n   * @param _offset assets array's start offset.\n   * @param _count assets array's count when perform distribution.\n   **/\n  function distributeYield(uint256 _offset, uint256 _count) external onlyAdmin {\n    // 1. convert from asset to exchange token via uniswap\n    for (uint256 i = 0; i < _count; i++) {\n      address asset = _assetsList[_offset + i];\n      require(asset != address(0), Errors.UL_INVALID_INDEX);\n      uint256 _amount = IERC20Detailed(asset).balanceOf(address(this));\n      _convertAssetToExchangeToken(asset, _amount);\n    }\n    uint256 exchangedAmount = IERC20Detailed(_exchangeToken).balanceOf(address(this));\n\n    // 2. convert from exchange token to other stable assets via curve swap\n    AssetYield[] memory assetYields = _getAssetYields(exchangedAmount);\n    for (uint256 i = 0; i < assetYields.length; i++) {\n      if (assetYields[i].amount > 0) {\n        uint256 _amount = _convertToStableCoin(assetYields[i].asset, assetYields[i].amount);\n        // 3. deposit Yield to pool for suppliers\n        _depositYield(assetYields[i].asset, _amount);\n      }\n    }\n  }\n\n  /**\n   * @dev Get the list of asset and asset's yield amount\n   **/\n  function _getAssetYields(uint256 _totalYieldAmount) internal view returns (AssetYield[] memory) {\n    // Get total borrowing asset volume and volumes and assets\n    (\n      uint256 totalVolume,\n      uint256[] memory volumes,\n      address[] memory assets,\n      uint256 length\n    ) = ILendingPool(_addressesProvider.getLendingPool()).getBorrowingAssetAndVolumes();\n\n    if (totalVolume == 0) return new AssetYield[](0);\n\n    AssetYield[] memory assetYields = new AssetYield[](length);\n    uint256 extraYieldAmount = _totalYieldAmount;\n\n    for (uint256 i = 0; i < length; i++) {\n      assetYields[i].asset = assets[i];\n      if (i != length - 1) {\n        // Distribute yieldAmount based on percent of asset volume\n        assetYields[i].amount = _totalYieldAmount.percentMul(\n          volumes[i].mul(PercentageMath.PERCENTAGE_FACTOR).div(totalVolume)\n        );\n        extraYieldAmount = extraYieldAmount.sub(assetYields[i].amount);\n      } else {\n        // without calculation, set remained extra amount\n        assetYields[i].amount = extraYieldAmount;\n      }\n    }\n\n    return assetYields;\n  }\n\n  /**\n   * @dev Convert asset to exchange token via Uniswap\n   * @param asset The address of asset being exchanged\n   * @param amount The amount of asset being exchanged\n   */\n  function _convertAssetToExchangeToken(address asset, uint256 amount) internal {\n    UniswapAdapter.swapExactTokensForTokens(\n      _addressesProvider,\n      asset,\n      _exchangeToken,\n      amount,\n      UNISWAP_FEE,\n      SLIPPAGE\n    );\n  }\n\n  /**\n   * @dev The function to convert from exchange token to stable coin via Curve\n   * @param _tokenOut The address of stable coin\n   * @param _amount The amount of exchange token being sent\n   * @return receivedAmount The amount of stable coin converted\n   */\n  function _convertToStableCoin(address _tokenOut, uint256 _amount)\n    internal\n    returns (uint256 receivedAmount)\n  {\n    if (_tokenOut == _exchangeToken) {\n      return _amount;\n    }\n    address _pool = _curvePools[_exchangeToken][_tokenOut];\n    require(_pool != address(0), Errors.VT_INVALID_CONFIGURATION);\n    receivedAmount = CurveswapAdapter.swapExactTokensForTokens(\n      _addressesProvider,\n      _pool,\n      _exchangeToken,\n      _tokenOut,\n      _amount,\n      SLIPPAGE\n    );\n  }\n\n  /**\n   * @dev The function to deposit yield to pool for suppliers\n   * @param _asset The address of yield asset\n   * @param _amount The mount of asset\n   */\n  function _depositYield(address _asset, uint256 _amount) internal {\n    address _lendingPool = _addressesProvider.getLendingPool();\n    IERC20(_asset).approve(_lendingPool, _amount);\n    ILendingPool(_lendingPool).depositYield(_asset, _amount);\n  }\n}"
    }
  ]
}