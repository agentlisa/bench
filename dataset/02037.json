{
  "Title": "Incomplete Docstrings",
  "Content": "Although docstrings are present above the [`_countVoteNominal`](https://github.com/ScopeLift/flexible-voting/blob/ef950394f5e560ec438890d07e60d40ab399c81a/src/GovernorCountingFractional.sol#L124-L127) and [`_countVoteFractional`](https://github.com/ScopeLift/flexible-voting/blob/ef950394f5e560ec438890d07e60d40ab399c81a/src/GovernorCountingFractional.sol#L151-L156) functions, they do not provide complete information about the purpose of these functions and the parameters passed to them.\n\n\nSince the `GovernorCountingFractional` contract supports rolling votes, once an address has cast a portion of its votes using the `_countVoteFractional` function, the subsequent votes should be cast by calling the `_countVoteFractional` function again, even if the votes are in favor of only one option.\n\n\nConsider adding proper docstrings to the functions, following the NatSpec format, stating the scenarios in which these functions should be called, and mentioning their limitations.\n\n\n***Update**: Resolved in [pull request #42](https://github.com/ScopeLift/flexible-voting/pull/42) at commit [c19467a](https://github.com/ScopeLift/flexible-voting/pull/42/commits/c19467a81255a7d1e9f262a41bd526905c453d4f).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/GovernorCountingFractional.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.X.X (governance/extensions/GovernorCountingFractional.sol)\n\npragma solidity ^0.8.0;\n\n// Disabling forgefmt to stay consistent with OZ's style.\n// forgefmt: disable-start\n\nimport {Governor} from \"openzeppelin-contracts/governance/Governor.sol\";\nimport {GovernorCompatibilityBravo} from \"openzeppelin-contracts/governance/compatibility/GovernorCompatibilityBravo.sol\";\nimport {SafeCast} from \"openzeppelin-contracts/utils/math/SafeCast.sol\";\n\n/**\n * @notice Extension of {Governor} for 3 option fractional vote counting. When voting, a delegate may split their vote\n * weight between For/Against/Abstain. This is most useful when the delegate is itself a contract, implementing its own\n * rules for voting. By allowing a contract-delegate to split its vote weight, the voting preferences of many disparate\n * token holders can be rolled up into a single vote to the Governor itself. Some example use cases include voting with\n * tokens that are held by a DeFi pool, voting from L2 with tokens held by a bridge, or voting privately from a\n * shielded pool using zero knowledge proofs.\n */\nabstract contract GovernorCountingFractional is Governor {\n\n    struct ProposalVote {\n        uint128 againstVotes;\n        uint128 forVotes;\n        uint128 abstainVotes;\n    }\n\n    /**\n     * @dev Mapping from proposal ID to vote tallies for that proposal.\n     */\n    mapping(uint256 => ProposalVote) private _proposalVotes;\n\n    /**\n     * @dev Mapping from proposal ID and address to the weight the address\n     * has cast on that proposal, e.g. _proposalVotersWeightCast[42][0xBEEF]\n     * would tell you the number of votes that 0xBEEF has cast on proposal 42.\n     */\n    mapping(uint256 => mapping(address => uint128)) private _proposalVotersWeightCast;\n\n    /**\n     * @dev See {IGovernor-COUNTING_MODE}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE() public pure virtual override returns (string memory) {\n        return \"support=bravo&quorum=bravo&params=fractional\";\n    }\n\n    /**\n     * @dev See {IGovernor-hasVoted}.\n     */\n    function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n        return _proposalVotersWeightCast[proposalId][account] > 0;\n    }\n\n    /**\n     * @dev Accessor to the internal vote counts.\n     */\n    function proposalVotes(uint256 proposalId)\n        public\n        view\n        virtual\n        returns (\n            uint256 againstVotes,\n            uint256 forVotes,\n            uint256 abstainVotes\n        )\n    {\n        ProposalVote storage proposalVote = _proposalVotes[proposalId];\n        return (proposalVote.againstVotes, proposalVote.forVotes, proposalVote.abstainVotes);\n    }\n\n    /**\n     * @dev See {Governor-_quorumReached}.\n     */\n    function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n\n        return quorum(proposalSnapshot(proposalId)) <= proposalvote.forVotes;\n    }\n\n    /**\n     * @dev See {Governor-_voteSucceeded}. In this module, forVotes must be > againstVotes.\n     */\n    function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n\n        return proposalvote.forVotes > proposalvote.againstVotes;\n    }\n\n    /**\n     * @notice See {Governor-_countVote}.\n     *\n     * If the `voteData` bytes parameter is empty, then this module behaves\n     * identically to GovernorBravo. That is, it assigns the full weight of the delegate to the `support` parameter,\n     * which follows the `VoteType` enum from Governor Bravo.\n     *\n     * If the `voteData` bytes parameter is not zero, then it _must_ be three packed uint128s, totaling 48 bytes,\n     * representing the weight the delegate assigns to For, Against, and Abstain respectively, i.e.\n     * encodePacked(forVotes, againstVotes, abstainVotes). The sum total of the three decoded vote weights _must_ be\n     * less than or equal to the delegate's total weight as check-pointed for the proposal being voted on.\n     */\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 weight,\n        bytes memory voteData\n    ) internal virtual override {\n        require(weight > 0, \"GovernorCountingFractional: no weight\");\n        if (_proposalVotersWeightCast[proposalId][account] >= weight) {\n          revert(\"GovernorCountingFractional: all weight cast\");\n        }\n\n        uint128 safeWeight = SafeCast.toUint128(weight);\n\n        if (voteData.length == 0) {\n            _countVoteNominal(proposalId, account, safeWeight, support);\n        } else {\n            _countVoteFractional(proposalId, account, safeWeight, voteData);\n        }\n    }\n\n    /**\n     * @dev Count votes with full weight\n     */\n    function _countVoteNominal(\n        uint256 proposalId,\n        address account,\n        uint128 weight,\n        uint8 support\n    ) internal {\n        require(\n            _proposalVotersWeightCast[proposalId][account] == 0,\n            \"GovernorCountingFractional: vote would exceed weight\"\n        );\n\n        _proposalVotersWeightCast[proposalId][account] = weight;\n\n        if (support == uint8(GovernorCompatibilityBravo.VoteType.Against)) {\n            _proposalVotes[proposalId].againstVotes += weight;\n        } else if (support == uint8(GovernorCompatibilityBravo.VoteType.For)) {\n            _proposalVotes[proposalId].forVotes += weight;\n        } else if (support == uint8(GovernorCompatibilityBravo.VoteType.Abstain)) {\n            _proposalVotes[proposalId].abstainVotes += weight;\n        } else {\n            revert(\"GovernorCountingFractional: invalid support value, must be included in VoteType enum\");\n        }\n    }\n\n    /**\n     * @dev Count votes with fractional weight.\n     *\n     * We expect `voteData` to be three packed uint128s, i.e. encodePacked(forVotes, againstVotes, abstainVotes)\n     */\n    function _countVoteFractional(\n        uint256 proposalId,\n        address account,\n        uint128 weight,\n        bytes memory voteData\n    ) internal {\n        require(voteData.length == 48, \"GovernorCountingFractional: invalid voteData\");\n\n        (uint128 _forVotes, uint128 _againstVotes, uint128 _abstainVotes) = _decodePackedVotes(voteData);\n\n        uint128 _existingWeight = _proposalVotersWeightCast[proposalId][account];\n        uint256 _newWeight = uint256(_forVotes) + _againstVotes + _abstainVotes + _existingWeight;\n\n        require(_newWeight <= weight, \"GovernorCountingFractional: vote would exceed weight\");\n\n        // It's safe to downcast here because we've just confirmed that\n        // _newWeight < weight, and we know that weight is <= uint128.max.\n        _proposalVotersWeightCast[proposalId][account] = uint128(_newWeight);\n\n        ProposalVote memory _proposalVote = _proposalVotes[proposalId];\n        _proposalVote = ProposalVote(\n            _proposalVote.againstVotes + _againstVotes,\n            _proposalVote.forVotes + _forVotes,\n            _proposalVote.abstainVotes + _abstainVotes\n        );\n\n        _proposalVotes[proposalId] = _proposalVote;\n    }\n\n    uint256 constant internal _VOTEMASK = 0xffffffffffffffffffffffffffffffff; // 128 bits of 0's, 128 bits of 1's\n\n    /**\n     * @dev Decodes three packed uint128's. Uses assembly because of Solidity language limitation which prevents\n     * slicing bytes stored in memory, rather than calldata.\n     */\n    function _decodePackedVotes(bytes memory voteData)\n        internal\n        pure\n        returns (\n            uint128 forVotes,\n            uint128 againstVotes,\n            uint128 abstainVotes\n        )\n    {\n        assembly {\n            forVotes := shr(128, mload(add(voteData, 0x20)))\n            againstVotes := and(_VOTEMASK, mload(add(voteData, 0x20)))\n            abstainVotes := shr(128, mload(add(voteData, 0x40)))\n        }\n    }\n}\n// forgefmt: disable-end"
    }
  ]
}