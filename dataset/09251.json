{
  "Title": "[M-04] Merkle leaves are the same length as the parents that are hashed",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/MerkleLib.sol#L36-L42\nhttps://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/MerkleDropFactory.sol#L94\n\n\n# Vulnerability details\n\n## Impact\n\nThe size of a `leaf` is the same size of the parent data that is hashed, both are 64 bytes. As a result it is possible to have a hash collision between a leaf and any node in the tree. This allows for proofs to be repeated multiple times by taking subtrees as leaves.\n\nFraudulent proofs will disrupt the airdrop and transfer funds to invalid addresses.\n\n## Proof of Concept\n\nFor example consider the following binary tree which has 4 leaves d,e,f,g\n\na->b\na->c\n\nb->d\nb->e\n\nc->f\nc->g\n\nTo calculate the parent hash for c it is `keccak(f || g)` and the parent hash for a is `keccak(b || c)` as seen in the `parentHash()` function below.\n\n```solidity\n    function parentHash(bytes32 a, bytes32 b) public pure returns (bytes32) {\n        if (a < b) {\n            return keccak256(abi.encode(a, b));\n        } else {\n            return keccak256(abi.encode(b, a));\n        }\n    }\n```\n\nA leaf is calculated as \n```solidity\nbytes32 leaf = keccak256(abi.encode(destination, value));\n```\n\n`abi.encode(address,uint)` will output 64 bytes. Since `abi.encode(bytes32,bytes32)` will also be 64 bytes it is possible to have a hash collision between a leaf and a parent node.\n\nTaking the example above if we now set `destination = keccak(e || d)` and `value = keccak(f || g)` and provide the proof as an empty array since we are already at `a`, the root `[]`. This proof will verify for `destination` and `value` set to the hash of each child node.\n\nThis issue is rated as medium as there are some drawbacks to the attack that will make it challenging to pull off in practice. The first is that `destination` is a 20 bytes address and thus will require the node in the tree to have 12 leading zero bytes which may not occur. Second is the `value` is transferred to the user and so it is likely that the balance of the contract will not be sufficient for this transfer to succeed.\n\n## Recommended Mitigation Steps\n\nConsider using `leaf = keccak(abi.encodePacked(destination, value))` in `withdraw()` as this will reduce the size of the leaf data being hashed to 52 bytes.\n\nSince `keccak256` prevents length extension attacks a different length of data to be hashed can be assumed to give different hashes and prevent a collision between a leaf and other nodes in the tree.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-factorydao-contest",
  "Code": [
    {
      "filename": "contracts/MerkleLib.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.9;\n\n/// @title A library for merkle trees\n/// @author metapriest\n/// @notice This library is used to check merkle proofs very efficiently.\n/// @dev Each additional proof element adds ~1000 gas\nlibrary MerkleLib {\n\n    /// @notice Check the merkle proof to determine whether leaf data was included in dataset represented by merkle root\n    /// @dev Leaf is pre-hashed to allow calling contract to implement whatever hashing scheme they want\n    /// @param root root hash of merkle tree that is the destination of the hash chain\n    /// @param leaf the pre-hashed leaf data, the starting point of the proof\n    /// @param proof the array of hashes forming a hash chain from leaf to root\n    /// @return true if proof is correct, else false\n    function verifyProof(bytes32 root, bytes32 leaf, bytes32[] memory proof) public pure returns (bool) {\n        bytes32 currentHash = leaf;\n\n        // the proof is all siblings of the ancestors of the leaf (including the sibling of the leaf itself)\n        // each iteration of this loop steps one layer higher in the merkle tree\n        for (uint i = 0; i < proof.length; i += 1) {\n            currentHash = parentHash(currentHash, proof[i]);\n        }\n\n        // does the result match the expected root? if so this leaf was committed to when the root was posted\n        // else we must assume the data was not included\n        return currentHash == root;\n    }\n\n    /// @notice Compute the hash of the parent node in the merkle tree\n    /// @dev The arguments are sorted to remove ambiguity about tree definition\n    /// @param a hash of left child node\n    /// @param b hash of right child node\n    /// @return hash of sorted arguments\n    function parentHash(bytes32 a, bytes32 b) public pure returns (bytes32) {\n        if (a < b) {\n            return keccak256(abi.encode(a, b));\n        } else {\n            return keccak256(abi.encode(b, a));\n        }\n    }\n\n}"
    },
    {
      "filename": "contracts/MerkleDropFactory.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.9;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"./MerkleLib.sol\";\n\n/// @title A factory pattern for merkledrops, that is, airdrops using merkleproofs to compute eligibility\n/// @author metapriest, adrian.wachel, marek.babiarz, radoslaw.gorecki\n/// @notice This contract is permissionless and public facing. Any fees must be included in the data of the merkle tree.\n/// @dev The contract cannot introspect into the contents of the merkle tree, except when provided a merkle proof,\n/// @dev therefore the total liabilities of the merkle tree are untrusted and tree balances must be managed separately\ncontract MerkleDropFactory {\n    using MerkleLib for bytes32;\n\n    // the number of airdrops in this contract\n    uint public numTrees = 0;\n\n    // this represents a single airdrop\n    struct MerkleTree {\n        bytes32 merkleRoot;  // merkleroot of tree whose leaves are (address,uint) pairs representing amount owed to user\n        bytes32 ipfsHash; // ipfs hash of entire dataset, as backup in case our servers turn off...\n        address tokenAddress; // address of token that is being airdropped\n        uint tokenBalance; // amount of tokens allocated for this tree\n        uint spentTokens; // amount of tokens dispensed from this tree\n    }\n\n    // withdrawn[recipient][treeIndex] = hasUserWithdrawnAirdrop\n    mapping (address => mapping (uint => bool)) public withdrawn;\n\n    // array-like map for all ze merkle trees (airdrops)\n    mapping (uint => MerkleTree) public merkleTrees;\n\n    // every time there's a withdraw\n    event WithdrawalOccurred(uint indexed treeIndex, address indexed destination, uint value);\n\n    // every time a tree is added\n    event MerkleTreeAdded(uint indexed treeIndex, address indexed tokenAddress, bytes32 newRoot, bytes32 ipfsHash);\n\n    // every time a tree is topped up\n    event TokensDeposited(uint indexed treeIndex, address indexed tokenAddress, uint amount);\n\n    /// @notice Add a new merkle tree to the contract, creating a new merkle-drop\n    /// @dev Anyone may call this function, therefore we must make sure trees cannot affect each other\n    /// @param newRoot root hash of merkle tree representing liabilities == (destination, value) pairs\n    /// @param ipfsHash the ipfs hash of the entire dataset, used for redundance so that creator can ensure merkleproof are always computable\n    /// @param tokenAddress the address of the token contract that is being distributed\n    /// @param tokenBalance the amount of tokens user wishes to use to fund the airdrop, note trees can be under/overfunded\n    function addMerkleTree(bytes32 newRoot, bytes32 ipfsHash, address tokenAddress, uint tokenBalance) public {\n        // prefix operator ++ increments then evaluates\n        merkleTrees[++numTrees] = MerkleTree(\n            newRoot,\n            ipfsHash,\n            tokenAddress,\n            0,  // ain't no tokens in here yet\n            0   // ain't nobody claimed no tokens yet either\n        );\n        // you don't get to add a tree without funding it\n        depositTokens(numTrees, tokenBalance);\n        // I guess we should tell people (interfaces) what happened\n        emit MerkleTreeAdded(numTrees, tokenAddress, newRoot, ipfsHash);\n    }\n\n    /// @notice Add funds to an existing merkle-drop\n    /// @dev Anyone may call this function, the only risk here is that the token contract is malicious, rendering the tree malicious\n    /// @param treeIndex index into array-like map of merkleTrees\n    /// @param value the amount of tokens user wishes to use to fund the airdrop, note trees can be under/overfunded\n    function depositTokens(uint treeIndex, uint value) public {\n        // storage since we are editing\n        MerkleTree storage merkleTree = merkleTrees[treeIndex];\n\n        // bookkeeping to make sure trees don't share tokens\n        merkleTree.tokenBalance += value;\n\n        // transfer tokens, if this is a malicious token, then this whole tree is malicious\n        // but it does not effect the other trees\n        require(IERC20(merkleTree.tokenAddress).transferFrom(msg.sender, address(this), value), \"ERC20 transfer failed\");\n        emit TokensDeposited(treeIndex, merkleTree.tokenAddress, value);\n    }\n\n    /// @notice Claim funds as a recipient in the merkle-drop\n    /// @dev Anyone may call this function for anyone else, funds go to destination regardless, it's just a question of\n    /// @dev who provides the proof and pays the gas, msg.sender is not used in this function\n    /// @param treeIndex index into array-like map of merkleTrees, which tree should we apply the proof to?\n    /// @param destination recipient of tokens\n    /// @param value amount of tokens that will be sent to destination\n    /// @param proof array of hashes bridging from leaf (hash of destination | value) to merkle root\n    function withdraw(uint treeIndex, address destination, uint value, bytes32[] memory proof) public {\n        // no withdrawing from uninitialized merkle trees\n        require(treeIndex <= numTrees, \"Provided merkle index doesn't exist\");\n        // no withdrawing same airdrop twice\n        require(!withdrawn[destination][treeIndex], \"You have already withdrawn your entitled token.\");\n        // compute merkle leaf, this is first element of proof\n        bytes32 leaf = keccak256(abi.encode(destination, value));\n        // storage because we edit\n        MerkleTree storage tree = merkleTrees[treeIndex];\n        // this calls to MerkleLib, will return false if recursive hashes do not end in merkle root\n        require(tree.merkleRoot.verifyProof(leaf, proof), \"The proof could not be verified.\");\n        // close re-entrance gate, prevent double claims\n        withdrawn[destination][treeIndex] = true;\n        // update struct\n        tree.tokenBalance -= value;\n        tree.spentTokens += value;\n        // transfer the tokens\n        // NOTE: if the token contract is malicious this call could re-enter this function\n        // which will fail because withdrawn will be set to true\n        require(IERC20(tree.tokenAddress).transfer(destination, value), \"ERC20 transfer failed\");\n        emit WithdrawalOccurred(treeIndex, destination, value);\n    }\n\n}"
    }
  ]
}