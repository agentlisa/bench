{
  "Title": "[M-26] If `HERMES` gauge rewards are not queued for distribution every week, they are slashed",
  "Content": "\nIn order to queue weekly `HERMES` rewards for distribution, `FlywheelGaugeRewards::queueRewardsForCycle` must be called during the next cycle (week). If a cycle has passed and no one calls `queueRewardsForCycle` to queue rewards, cycle gauge rewards are lost as the internal accounting does not take into consideration time passing, only the last processed cycle.\n\n### Issue details\n\nThe minter kicks off a new epoch via calling `BaseV2Minter::updatePeriod`. The execution flow goes to `FlywheelGaugeRewards::queueRewardsForCycle` -> `FlywheelGaugeRewards::_queueRewards` where after several checks, the [rewards are queued](https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/rewards/FlywheelGaugeRewards.sol#L189-L193) in order for them to be retrieved via a call to [`FlywheelGaugeRewards::getAccruedRewards`](https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/rewards/FlywheelGaugeRewards.sol#L200) from [`BaseV2Gauge::newEpoch`](https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/BaseV2Gauge.sol#L89).\n\nReward queuing logic revolves around the [current and previously saved gauge cycle](https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/rewards/FlywheelGaugeRewards.sol#L78-L80):\n\n```Solidity\n        // next cycle is always the next even divisor of the cycle length above current block timestamp.\n        uint32 currentCycle = (block.timestamp.toUint32() / gaugeCycleLength) * gaugeCycleLength;\n        uint32 lastCycle = gaugeCycle;\n```\n\nThis way of noting cycles ([and further checks done](https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/rewards/FlywheelGaugeRewards.sol#L82-L85)) does not take into consideration any intermediary cycles; only that a new cycle is after an old cycle. If `queueRewardsForCycle` is not called for a number of cycles, then rewards will be lost for those cycles.\n\n### Proof of Concept\n\nRewards are calculated for the current cycle and last stored cycle only, with no intermediary accounting: \n\n<https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/rewards/FlywheelGaugeRewards.sol#L78-L80>\n\nVisual example:\n\n     0 1 2 3 4 5 6  (epoch/cycle)\n    +-+-+-+-+-+-+-+\n    |Q|Q|Q| | |Q|Q|\n    +-+-+-+-+-+-+-+\n\nUp until epoch 2 `queueRewardsForCycle` (Q) was called, for cycle 3 and 4 nobody calls, on cycle 5 `queueRewardsForCycle` is called again, but cycle 3 and 4 rewards are not taken into consideration.\n\n### Recommended Mitigation Steps\n\nBecause of the way the entire `MaiaDAO` ecosystem is set up, the premise is that someone will call `BaseV2Minter::updatePeriod` (which calls `FlywheelGaugeRewards::queueRewardsForCycle`), as there is an incentive for users (or projects) to do so. Realistically, this *should* always happen, but unforeseen events may lead to this event.\n\nIt is difficult from an architectural point of view, regarding how `MaiaDAO` is constructed, to offer a solution. A generic suggestion would be to implement a snapshot mechanism or dynamic accounting of each cycle, but then the issue would be who triggers that snapshot event?\n\nThis issue is real, but mitigating it is not straightforward or evident in web3 context. One workaround is to use proper on-chain automation such as [Chainlink Automation](https://docs.chain.link/chainlink-automation/introduction).\n\n**[0xLightt (Maia) acknowledged](https://github.com/code-423n4/2023-05-maia-findings/issues/411#issuecomment-1631677415)**\n\n**[alexxander (warden) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/411#issuecomment-1653412426):**\n > It is unrealistic to believe that no one will call `queueRewardsForCycle` for a whole week. Especially considering it is an external function, with no access control, and users are incentivized to call it (as they will get rewards by doing so).\n\n**[Trust (judge) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/411#issuecomment-1653449309):**\n > If the docs cover this skipped week issue, this would be a fair observation. Otherwise, users may not feel the urge to call the function and subsequently lose rewards. \n\n**[0xLightt (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/411#issuecomment-1653898511):**\n > Just want to add, that it is true that we need to call this every week. Distribution of rewards for each gauge that uses the `UniswapV3Staker` even has a tighter window, [needs to be queued during the first 12h](https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/UniswapV3Gauge.sol#L50-L51).\n> \n> If only `BaseV2Minter::updatePeriod` is called, no rewards will be lost; but they won't be distributed in this epoch, only the next.\n> \n> Every week there is a 12 hour period for everyone to call the minter, `flywheelGaugeRewards`, and then every gauge to distribute rewards properly. Because of the large time window, a simple in-house script works and possibly only using chainlink automation as a last resort, as it is more expensive.\n> \n> Note: Anyone can call these functions and while they are not rewarded by doing so, they are also not rewarded if they don't and would lead to worst issues; like no LPs being rewarded and loosing all of the platforms liquidity during the week in which nothing is called.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/rewards/rewards/FlywheelGaugeRewards.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Rewards logic inspired by Tribe DAO Contracts (flywheel-v2/src/rewards/FlywheelGaugeRewards.sol)\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {ERC20Gauges} from \"@ERC20/ERC20Gauges.sol\";\n\nimport {IFlywheelGaugeRewards} from \"../interfaces/IFlywheelGaugeRewards.sol\";\n\nimport {IBaseV2Minter} from \"@hermes/interfaces/IBaseV2Minter.sol\";\n\n/// @title Flywheel Gauge Reward Stream\ncontract FlywheelGaugeRewards is Ownable, IFlywheelGaugeRewards {\n    using SafeTransferLib for address;\n    using SafeCastLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                        REWARDS CONTRACT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    ERC20Gauges public immutable override gaugeToken;\n\n    /// @notice the minter contract, is a rewardsStream to collect rewards from\n    IBaseV2Minter public immutable minter;\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    address public immutable override rewardToken;\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    uint32 public override gaugeCycle;\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    uint32 public immutable override gaugeCycleLength;\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    mapping(ERC20 => QueuedRewards) public override gaugeQueuedRewards;\n\n    /// @notice the start of the next cycle being partially queued\n    uint32 internal nextCycle;\n\n    // rewards that made it into a partial queue but didn't get completed\n    uint112 internal nextCycleQueuedRewards;\n\n    // the offset during pagination of the queue\n    uint32 internal paginationOffset;\n\n    constructor(address _rewardToken, address _owner, ERC20Gauges _gaugeToken, IBaseV2Minter _minter) {\n        _initializeOwner(_owner);\n        rewardToken = _rewardToken;\n\n        gaugeCycleLength = _gaugeToken.gaugeCycleLength();\n\n        // seed initial gaugeCycle\n        gaugeCycle = (block.timestamp.toUint32() / gaugeCycleLength) * gaugeCycleLength;\n\n        gaugeToken = _gaugeToken;\n\n        minter = _minter;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GAUGE REWARDS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    function queueRewardsForCycle() external returns (uint256 totalQueuedForCycle) {\n        /// @dev Update minter cycle and queue rewars if needed.\n        /// This will make this call fail if it is a new epoch, because the minter calls this function, the first call would fail with \"CycleError()\".\n        /// Should be called through Minter to kickoff new epoch.\n        minter.updatePeriod();\n\n        // next cycle is always the next even divisor of the cycle length above current block timestamp.\n        uint32 currentCycle = (block.timestamp.toUint32() / gaugeCycleLength) * gaugeCycleLength;\n        uint32 lastCycle = gaugeCycle;\n\n        // ensure new cycle has begun\n        if (currentCycle <= lastCycle) revert CycleError();\n\n        gaugeCycle = currentCycle;\n\n        // queue the rewards stream and sanity check the tokens were received\n        uint256 balanceBefore = rewardToken.balanceOf(address(this));\n        totalQueuedForCycle = minter.getRewards();\n        require(rewardToken.balanceOf(address(this)) - balanceBefore >= totalQueuedForCycle);\n\n        // include uncompleted cycle\n        totalQueuedForCycle += nextCycleQueuedRewards;\n\n        // iterate over all gauges and update the rewards allocations\n        address[] memory gauges = gaugeToken.gauges();\n\n        _queueRewards(gauges, currentCycle, lastCycle, totalQueuedForCycle);\n\n        nextCycleQueuedRewards = 0;\n        paginationOffset = 0;\n\n        emit CycleStart(currentCycle, totalQueuedForCycle);\n    }\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    function queueRewardsForCyclePaginated(uint256 numRewards) external {\n        /// @dev Update minter cycle and queue rewars if needed.\n        /// This will make this call fail if it is a new epoch, because the minter calls this function, the first call would fail with \"CycleError()\".\n        /// Should be called through Minter to kickoff new epoch.\n        minter.updatePeriod();\n\n        // next cycle is always the next even divisor of the cycle length above current block timestamp.\n        uint32 currentCycle = (block.timestamp.toUint32() / gaugeCycleLength) * gaugeCycleLength;\n        uint32 lastCycle = gaugeCycle;\n\n        // ensure new cycle has begun\n        if (currentCycle <= lastCycle) revert CycleError();\n\n        if (currentCycle > nextCycle) {\n            nextCycle = currentCycle;\n            paginationOffset = 0;\n        }\n\n        uint32 offset = paginationOffset;\n\n        // important to only calculate the reward amount once to prevent each page from having a different reward amount\n        if (offset == 0) {\n            // queue the rewards stream and sanity check the tokens were received\n            uint256 balanceBefore = rewardToken.balanceOf(address(this));\n            uint256 newRewards = minter.getRewards();\n            require(rewardToken.balanceOf(address(this)) - balanceBefore >= newRewards);\n            require(newRewards <= type(uint112).max); // safe cast\n            nextCycleQueuedRewards += uint112(newRewards); // in case a previous incomplete cycle had rewards, add on\n        }\n\n        uint112 queued = nextCycleQueuedRewards;\n\n        uint256 remaining = gaugeToken.numGauges() - offset;\n\n        // Important to do non-strict inequality to include the case where the numRewards is just enough to complete the cycle\n        if (remaining <= numRewards) {\n            numRewards = remaining;\n            gaugeCycle = currentCycle;\n            nextCycleQueuedRewards = 0;\n            paginationOffset = 0;\n            emit CycleStart(currentCycle, queued);\n        } else {\n            paginationOffset = offset + numRewards.toUint32();\n        }\n\n        // iterate over all gauges and update the rewards allocations\n        address[] memory gauges = gaugeToken.gauges(offset, numRewards);\n\n        _queueRewards(gauges, currentCycle, lastCycle, queued);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        FLYWHEEL CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Queues the rewards for the next cycle for each given gauge.\n     * @param gauges array of gauges addresses to queue rewards for.\n     * @param currentCycle timestamp representing the beginning of the new cycle.\n     * @param lastCycle timestamp representing the end of the of the last cycle.\n     * @param totalQueuedForCycle total number of rewards queued for the next cycle.\n     */\n    function _queueRewards(address[] memory gauges, uint32 currentCycle, uint32 lastCycle, uint256 totalQueuedForCycle)\n        internal\n    {\n        uint256 size = gauges.length;\n\n        if (size == 0) revert EmptyGaugesError();\n\n        for (uint256 i = 0; i < size; i++) {\n            ERC20 gauge = ERC20(gauges[i]);\n\n            QueuedRewards memory queuedRewards = gaugeQueuedRewards[gauge];\n\n            // Cycle queue already started\n            require(queuedRewards.storedCycle < currentCycle);\n            assert(queuedRewards.storedCycle == 0 || queuedRewards.storedCycle >= lastCycle);\n\n            uint112 completedRewards = queuedRewards.storedCycle == lastCycle ? queuedRewards.cycleRewards : 0;\n            uint256 nextRewards = gaugeToken.calculateGaugeAllocation(address(gauge), totalQueuedForCycle);\n            require(nextRewards <= type(uint112).max); // safe cast\n\n            gaugeQueuedRewards[gauge] = QueuedRewards({\n                priorCycleRewards: queuedRewards.priorCycleRewards + completedRewards,\n                cycleRewards: uint112(nextRewards),\n                storedCycle: currentCycle\n            });\n\n            emit QueueRewards(address(gauge), currentCycle, nextRewards);\n        }\n    }\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    function getAccruedRewards() external returns (uint256 accruedRewards) {\n        /// @dev Update minter cycle and queue rewars if needed.\n        minter.updatePeriod();\n\n        QueuedRewards memory queuedRewards = gaugeQueuedRewards[ERC20(msg.sender)];\n\n        uint32 cycle = gaugeCycle;\n        bool incompleteCycle = queuedRewards.storedCycle > cycle;\n\n        // no rewards\n        if (queuedRewards.priorCycleRewards == 0 && (queuedRewards.cycleRewards == 0 || incompleteCycle)) {\n            return 0;\n        }\n\n        // if stored cycle != 0 it must be >= the last queued cycle\n        assert(queuedRewards.storedCycle >= cycle);\n\n        // always accrue prior rewards\n        accruedRewards = queuedRewards.priorCycleRewards;\n        uint112 cycleRewardsNext = queuedRewards.cycleRewards;\n\n        if (incompleteCycle) {\n            // If current cycle queue incomplete, do nothing to current cycle rewards or accrued\n        } else {\n            accruedRewards += cycleRewardsNext;\n            cycleRewardsNext = 0;\n        }\n\n        gaugeQueuedRewards[ERC20(msg.sender)] = QueuedRewards({\n            priorCycleRewards: 0,\n            cycleRewards: cycleRewardsNext,\n            storedCycle: queuedRewards.storedCycle\n        });\n\n        if (accruedRewards > 0) rewardToken.safeTransfer(msg.sender, accruedRewards);\n    }\n}"
    },
    {
      "filename": "src/rewards/rewards/FlywheelGaugeRewards.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Rewards logic inspired by Tribe DAO Contracts (flywheel-v2/src/rewards/FlywheelGaugeRewards.sol)\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {ERC20Gauges} from \"@ERC20/ERC20Gauges.sol\";\n\nimport {IFlywheelGaugeRewards} from \"../interfaces/IFlywheelGaugeRewards.sol\";\n\nimport {IBaseV2Minter} from \"@hermes/interfaces/IBaseV2Minter.sol\";\n\n/// @title Flywheel Gauge Reward Stream\ncontract FlywheelGaugeRewards is Ownable, IFlywheelGaugeRewards {\n    using SafeTransferLib for address;\n    using SafeCastLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                        REWARDS CONTRACT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    ERC20Gauges public immutable override gaugeToken;\n\n    /// @notice the minter contract, is a rewardsStream to collect rewards from\n    IBaseV2Minter public immutable minter;\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    address public immutable override rewardToken;\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    uint32 public override gaugeCycle;\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    uint32 public immutable override gaugeCycleLength;\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    mapping(ERC20 => QueuedRewards) public override gaugeQueuedRewards;\n\n    /// @notice the start of the next cycle being partially queued\n    uint32 internal nextCycle;\n\n    // rewards that made it into a partial queue but didn't get completed\n    uint112 internal nextCycleQueuedRewards;\n\n    // the offset during pagination of the queue\n    uint32 internal paginationOffset;\n\n    constructor(address _rewardToken, address _owner, ERC20Gauges _gaugeToken, IBaseV2Minter _minter) {\n        _initializeOwner(_owner);\n        rewardToken = _rewardToken;\n\n        gaugeCycleLength = _gaugeToken.gaugeCycleLength();\n\n        // seed initial gaugeCycle\n        gaugeCycle = (block.timestamp.toUint32() / gaugeCycleLength) * gaugeCycleLength;\n\n        gaugeToken = _gaugeToken;\n\n        minter = _minter;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GAUGE REWARDS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    function queueRewardsForCycle() external returns (uint256 totalQueuedForCycle) {\n        /// @dev Update minter cycle and queue rewars if needed.\n        /// This will make this call fail if it is a new epoch, because the minter calls this function, the first call would fail with \"CycleError()\".\n        /// Should be called through Minter to kickoff new epoch.\n        minter.updatePeriod();\n\n        // next cycle is always the next even divisor of the cycle length above current block timestamp.\n        uint32 currentCycle = (block.timestamp.toUint32() / gaugeCycleLength) * gaugeCycleLength;\n        uint32 lastCycle = gaugeCycle;\n\n        // ensure new cycle has begun\n        if (currentCycle <= lastCycle) revert CycleError();\n\n        gaugeCycle = currentCycle;\n\n        // queue the rewards stream and sanity check the tokens were received\n        uint256 balanceBefore = rewardToken.balanceOf(address(this));\n        totalQueuedForCycle = minter.getRewards();\n        require(rewardToken.balanceOf(address(this)) - balanceBefore >= totalQueuedForCycle);\n\n        // include uncompleted cycle\n        totalQueuedForCycle += nextCycleQueuedRewards;\n\n        // iterate over all gauges and update the rewards allocations\n        address[] memory gauges = gaugeToken.gauges();\n\n        _queueRewards(gauges, currentCycle, lastCycle, totalQueuedForCycle);\n\n        nextCycleQueuedRewards = 0;\n        paginationOffset = 0;\n\n        emit CycleStart(currentCycle, totalQueuedForCycle);\n    }\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    function queueRewardsForCyclePaginated(uint256 numRewards) external {\n        /// @dev Update minter cycle and queue rewars if needed.\n        /// This will make this call fail if it is a new epoch, because the minter calls this function, the first call would fail with \"CycleError()\".\n        /// Should be called through Minter to kickoff new epoch.\n        minter.updatePeriod();\n\n        // next cycle is always the next even divisor of the cycle length above current block timestamp.\n        uint32 currentCycle = (block.timestamp.toUint32() / gaugeCycleLength) * gaugeCycleLength;\n        uint32 lastCycle = gaugeCycle;\n\n        // ensure new cycle has begun\n        if (currentCycle <= lastCycle) revert CycleError();\n\n        if (currentCycle > nextCycle) {\n            nextCycle = currentCycle;\n            paginationOffset = 0;\n        }\n\n        uint32 offset = paginationOffset;\n\n        // important to only calculate the reward amount once to prevent each page from having a different reward amount\n        if (offset == 0) {\n            // queue the rewards stream and sanity check the tokens were received\n            uint256 balanceBefore = rewardToken.balanceOf(address(this));\n            uint256 newRewards = minter.getRewards();\n            require(rewardToken.balanceOf(address(this)) - balanceBefore >= newRewards);\n            require(newRewards <= type(uint112).max); // safe cast\n            nextCycleQueuedRewards += uint112(newRewards); // in case a previous incomplete cycle had rewards, add on\n        }\n\n        uint112 queued = nextCycleQueuedRewards;\n\n        uint256 remaining = gaugeToken.numGauges() - offset;\n\n        // Important to do non-strict inequality to include the case where the numRewards is just enough to complete the cycle\n        if (remaining <= numRewards) {\n            numRewards = remaining;\n            gaugeCycle = currentCycle;\n            nextCycleQueuedRewards = 0;\n            paginationOffset = 0;\n            emit CycleStart(currentCycle, queued);\n        } else {\n            paginationOffset = offset + numRewards.toUint32();\n        }\n\n        // iterate over all gauges and update the rewards allocations\n        address[] memory gauges = gaugeToken.gauges(offset, numRewards);\n\n        _queueRewards(gauges, currentCycle, lastCycle, queued);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        FLYWHEEL CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Queues the rewards for the next cycle for each given gauge.\n     * @param gauges array of gauges addresses to queue rewards for.\n     * @param currentCycle timestamp representing the beginning of the new cycle.\n     * @param lastCycle timestamp representing the end of the of the last cycle.\n     * @param totalQueuedForCycle total number of rewards queued for the next cycle.\n     */\n    function _queueRewards(address[] memory gauges, uint32 currentCycle, uint32 lastCycle, uint256 totalQueuedForCycle)\n        internal\n    {\n        uint256 size = gauges.length;\n\n        if (size == 0) revert EmptyGaugesError();\n\n        for (uint256 i = 0; i < size; i++) {\n            ERC20 gauge = ERC20(gauges[i]);\n\n            QueuedRewards memory queuedRewards = gaugeQueuedRewards[gauge];\n\n            // Cycle queue already started\n            require(queuedRewards.storedCycle < currentCycle);\n            assert(queuedRewards.storedCycle == 0 || queuedRewards.storedCycle >= lastCycle);\n\n            uint112 completedRewards = queuedRewards.storedCycle == lastCycle ? queuedRewards.cycleRewards : 0;\n            uint256 nextRewards = gaugeToken.calculateGaugeAllocation(address(gauge), totalQueuedForCycle);\n            require(nextRewards <= type(uint112).max); // safe cast\n\n            gaugeQueuedRewards[gauge] = QueuedRewards({\n                priorCycleRewards: queuedRewards.priorCycleRewards + completedRewards,\n                cycleRewards: uint112(nextRewards),\n                storedCycle: currentCycle\n            });\n\n            emit QueueRewards(address(gauge), currentCycle, nextRewards);\n        }\n    }\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    function getAccruedRewards() external returns (uint256 accruedRewards) {\n        /// @dev Update minter cycle and queue rewars if needed.\n        minter.updatePeriod();\n\n        QueuedRewards memory queuedRewards = gaugeQueuedRewards[ERC20(msg.sender)];\n\n        uint32 cycle = gaugeCycle;\n        bool incompleteCycle = queuedRewards.storedCycle > cycle;\n\n        // no rewards\n        if (queuedRewards.priorCycleRewards == 0 && (queuedRewards.cycleRewards == 0 || incompleteCycle)) {\n            return 0;\n        }\n\n        // if stored cycle != 0 it must be >= the last queued cycle\n        assert(queuedRewards.storedCycle >= cycle);\n\n        // always accrue prior rewards\n        accruedRewards = queuedRewards.priorCycleRewards;\n        uint112 cycleRewardsNext = queuedRewards.cycleRewards;\n\n        if (incompleteCycle) {\n            // If current cycle queue incomplete, do nothing to current cycle rewards or accrued\n        } else {\n            accruedRewards += cycleRewardsNext;\n            cycleRewardsNext = 0;\n        }\n\n        gaugeQueuedRewards[ERC20(msg.sender)] = QueuedRewards({\n            priorCycleRewards: 0,\n            cycleRewards: cycleRewardsNext,\n            storedCycle: queuedRewards.storedCycle\n        });\n\n        if (accruedRewards > 0) rewardToken.safeTransfer(msg.sender, accruedRewards);\n    }\n}"
    },
    {
      "filename": "src/rewards/rewards/FlywheelGaugeRewards.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Rewards logic inspired by Tribe DAO Contracts (flywheel-v2/src/rewards/FlywheelGaugeRewards.sol)\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {ERC20Gauges} from \"@ERC20/ERC20Gauges.sol\";\n\nimport {IFlywheelGaugeRewards} from \"../interfaces/IFlywheelGaugeRewards.sol\";\n\nimport {IBaseV2Minter} from \"@hermes/interfaces/IBaseV2Minter.sol\";\n\n/// @title Flywheel Gauge Reward Stream\ncontract FlywheelGaugeRewards is Ownable, IFlywheelGaugeRewards {\n    using SafeTransferLib for address;\n    using SafeCastLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                        REWARDS CONTRACT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    ERC20Gauges public immutable override gaugeToken;\n\n    /// @notice the minter contract, is a rewardsStream to collect rewards from\n    IBaseV2Minter public immutable minter;\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    address public immutable override rewardToken;\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    uint32 public override gaugeCycle;\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    uint32 public immutable override gaugeCycleLength;\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    mapping(ERC20 => QueuedRewards) public override gaugeQueuedRewards;\n\n    /// @notice the start of the next cycle being partially queued\n    uint32 internal nextCycle;\n\n    // rewards that made it into a partial queue but didn't get completed\n    uint112 internal nextCycleQueuedRewards;\n\n    // the offset during pagination of the queue\n    uint32 internal paginationOffset;\n\n    constructor(address _rewardToken, address _owner, ERC20Gauges _gaugeToken, IBaseV2Minter _minter) {\n        _initializeOwner(_owner);\n        rewardToken = _rewardToken;\n\n        gaugeCycleLength = _gaugeToken.gaugeCycleLength();\n\n        // seed initial gaugeCycle\n        gaugeCycle = (block.timestamp.toUint32() / gaugeCycleLength) * gaugeCycleLength;\n\n        gaugeToken = _gaugeToken;\n\n        minter = _minter;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GAUGE REWARDS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    function queueRewardsForCycle() external returns (uint256 totalQueuedForCycle) {\n        /// @dev Update minter cycle and queue rewars if needed.\n        /// This will make this call fail if it is a new epoch, because the minter calls this function, the first call would fail with \"CycleError()\".\n        /// Should be called through Minter to kickoff new epoch.\n        minter.updatePeriod();\n\n        // next cycle is always the next even divisor of the cycle length above current block timestamp.\n        uint32 currentCycle = (block.timestamp.toUint32() / gaugeCycleLength) * gaugeCycleLength;\n        uint32 lastCycle = gaugeCycle;\n\n        // ensure new cycle has begun\n        if (currentCycle <= lastCycle) revert CycleError();\n\n        gaugeCycle = currentCycle;\n\n        // queue the rewards stream and sanity check the tokens were received\n        uint256 balanceBefore = rewardToken.balanceOf(address(this));\n        totalQueuedForCycle = minter.getRewards();\n        require(rewardToken.balanceOf(address(this)) - balanceBefore >= totalQueuedForCycle);\n\n        // include uncompleted cycle\n        totalQueuedForCycle += nextCycleQueuedRewards;\n\n        // iterate over all gauges and update the rewards allocations\n        address[] memory gauges = gaugeToken.gauges();\n\n        _queueRewards(gauges, currentCycle, lastCycle, totalQueuedForCycle);\n\n        nextCycleQueuedRewards = 0;\n        paginationOffset = 0;\n\n        emit CycleStart(currentCycle, totalQueuedForCycle);\n    }\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    function queueRewardsForCyclePaginated(uint256 numRewards) external {\n        /// @dev Update minter cycle and queue rewars if needed.\n        /// This will make this call fail if it is a new epoch, because the minter calls this function, the first call would fail with \"CycleError()\".\n        /// Should be called through Minter to kickoff new epoch.\n        minter.updatePeriod();\n\n        // next cycle is always the next even divisor of the cycle length above current block timestamp.\n        uint32 currentCycle = (block.timestamp.toUint32() / gaugeCycleLength) * gaugeCycleLength;\n        uint32 lastCycle = gaugeCycle;\n\n        // ensure new cycle has begun\n        if (currentCycle <= lastCycle) revert CycleError();\n\n        if (currentCycle > nextCycle) {\n            nextCycle = currentCycle;\n            paginationOffset = 0;\n        }\n\n        uint32 offset = paginationOffset;\n\n        // important to only calculate the reward amount once to prevent each page from having a different reward amount\n        if (offset == 0) {\n            // queue the rewards stream and sanity check the tokens were received\n            uint256 balanceBefore = rewardToken.balanceOf(address(this));\n            uint256 newRewards = minter.getRewards();\n            require(rewardToken.balanceOf(address(this)) - balanceBefore >= newRewards);\n            require(newRewards <= type(uint112).max); // safe cast\n            nextCycleQueuedRewards += uint112(newRewards); // in case a previous incomplete cycle had rewards, add on\n        }\n\n        uint112 queued = nextCycleQueuedRewards;\n\n        uint256 remaining = gaugeToken.numGauges() - offset;\n\n        // Important to do non-strict inequality to include the case where the numRewards is just enough to complete the cycle\n        if (remaining <= numRewards) {\n            numRewards = remaining;\n            gaugeCycle = currentCycle;\n            nextCycleQueuedRewards = 0;\n            paginationOffset = 0;\n            emit CycleStart(currentCycle, queued);\n        } else {\n            paginationOffset = offset + numRewards.toUint32();\n        }\n\n        // iterate over all gauges and update the rewards allocations\n        address[] memory gauges = gaugeToken.gauges(offset, numRewards);\n\n        _queueRewards(gauges, currentCycle, lastCycle, queued);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        FLYWHEEL CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Queues the rewards for the next cycle for each given gauge.\n     * @param gauges array of gauges addresses to queue rewards for.\n     * @param currentCycle timestamp representing the beginning of the new cycle.\n     * @param lastCycle timestamp representing the end of the of the last cycle.\n     * @param totalQueuedForCycle total number of rewards queued for the next cycle.\n     */\n    function _queueRewards(address[] memory gauges, uint32 currentCycle, uint32 lastCycle, uint256 totalQueuedForCycle)\n        internal\n    {\n        uint256 size = gauges.length;\n\n        if (size == 0) revert EmptyGaugesError();\n\n        for (uint256 i = 0; i < size; i++) {\n            ERC20 gauge = ERC20(gauges[i]);\n\n            QueuedRewards memory queuedRewards = gaugeQueuedRewards[gauge];\n\n            // Cycle queue already started\n            require(queuedRewards.storedCycle < currentCycle);\n            assert(queuedRewards.storedCycle == 0 || queuedRewards.storedCycle >= lastCycle);\n\n            uint112 completedRewards = queuedRewards.storedCycle == lastCycle ? queuedRewards.cycleRewards : 0;\n            uint256 nextRewards = gaugeToken.calculateGaugeAllocation(address(gauge), totalQueuedForCycle);\n            require(nextRewards <= type(uint112).max); // safe cast\n\n            gaugeQueuedRewards[gauge] = QueuedRewards({\n                priorCycleRewards: queuedRewards.priorCycleRewards + completedRewards,\n                cycleRewards: uint112(nextRewards),\n                storedCycle: currentCycle\n            });\n\n            emit QueueRewards(address(gauge), currentCycle, nextRewards);\n        }\n    }\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    function getAccruedRewards() external returns (uint256 accruedRewards) {\n        /// @dev Update minter cycle and queue rewars if needed.\n        minter.updatePeriod();\n\n        QueuedRewards memory queuedRewards = gaugeQueuedRewards[ERC20(msg.sender)];\n\n        uint32 cycle = gaugeCycle;\n        bool incompleteCycle = queuedRewards.storedCycle > cycle;\n\n        // no rewards\n        if (queuedRewards.priorCycleRewards == 0 && (queuedRewards.cycleRewards == 0 || incompleteCycle)) {\n            return 0;\n        }\n\n        // if stored cycle != 0 it must be >= the last queued cycle\n        assert(queuedRewards.storedCycle >= cycle);\n\n        // always accrue prior rewards\n        accruedRewards = queuedRewards.priorCycleRewards;\n        uint112 cycleRewardsNext = queuedRewards.cycleRewards;\n\n        if (incompleteCycle) {\n            // If current cycle queue incomplete, do nothing to current cycle rewards or accrued\n        } else {\n            accruedRewards += cycleRewardsNext;\n            cycleRewardsNext = 0;\n        }\n\n        gaugeQueuedRewards[ERC20(msg.sender)] = QueuedRewards({\n            priorCycleRewards: 0,\n            cycleRewards: cycleRewardsNext,\n            storedCycle: queuedRewards.storedCycle\n        });\n\n        if (accruedRewards > 0) rewardToken.safeTransfer(msg.sender, accruedRewards);\n    }\n}"
    },
    {
      "filename": "src/rewards/rewards/FlywheelGaugeRewards.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Rewards logic inspired by Tribe DAO Contracts (flywheel-v2/src/rewards/FlywheelGaugeRewards.sol)\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {ERC20Gauges} from \"@ERC20/ERC20Gauges.sol\";\n\nimport {IFlywheelGaugeRewards} from \"../interfaces/IFlywheelGaugeRewards.sol\";\n\nimport {IBaseV2Minter} from \"@hermes/interfaces/IBaseV2Minter.sol\";\n\n/// @title Flywheel Gauge Reward Stream\ncontract FlywheelGaugeRewards is Ownable, IFlywheelGaugeRewards {\n    using SafeTransferLib for address;\n    using SafeCastLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                        REWARDS CONTRACT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    ERC20Gauges public immutable override gaugeToken;\n\n    /// @notice the minter contract, is a rewardsStream to collect rewards from\n    IBaseV2Minter public immutable minter;\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    address public immutable override rewardToken;\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    uint32 public override gaugeCycle;\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    uint32 public immutable override gaugeCycleLength;\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    mapping(ERC20 => QueuedRewards) public override gaugeQueuedRewards;\n\n    /// @notice the start of the next cycle being partially queued\n    uint32 internal nextCycle;\n\n    // rewards that made it into a partial queue but didn't get completed\n    uint112 internal nextCycleQueuedRewards;\n\n    // the offset during pagination of the queue\n    uint32 internal paginationOffset;\n\n    constructor(address _rewardToken, address _owner, ERC20Gauges _gaugeToken, IBaseV2Minter _minter) {\n        _initializeOwner(_owner);\n        rewardToken = _rewardToken;\n\n        gaugeCycleLength = _gaugeToken.gaugeCycleLength();\n\n        // seed initial gaugeCycle\n        gaugeCycle = (block.timestamp.toUint32() / gaugeCycleLength) * gaugeCycleLength;\n\n        gaugeToken = _gaugeToken;\n\n        minter = _minter;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GAUGE REWARDS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IFlywheelGaugeRewards\n    function queueRewardsForCycle() external returns (uint256 totalQueuedForCycle) {\n        /// @dev Update minter cycle and queue rewars if needed.\n        /// This will make this call fail if it is a new epoch, because the minter calls this function, the first call would fail with \"CycleError()\".\n        /// Should be called through Minter to kickoff new epoch.\n        minter.updatePeriod();\n\n        // next cycle is always the next even divisor of the cycle length above current block timestamp.\n        uint32 currentCycle = (block.timestamp.toUint32() / gaugeCycleLength) * gaugeCycleLength;\n        uint32 lastCycle = gaugeCycle;\n\n        // ensure new cycle has begun\n        if (currentCycle <= lastCycle) revert CycleError();\n\n        gaugeCycle = currentCycle;\n\n        // queue the rewards stream and sanity check the tokens were received\n        uint256 balanceBefore = rewardToken.balanceOf(address(this));\n        totalQueuedForCycle = minter.getRewards();\n        require(rewardToken.balanceOf(address(this)) - balanceBefore >= totalQueuedForCycle);\n\n        // include uncompleted cycle\n        totalQueuedForCycle += nextCycleQueuedRewards;\n\n        // iterate over all gauges and update the rewards alloca"
    }
  ]
}