{
  "Title": "[G-19]  Storage cheaper than memory",
  "Content": "\nReference types cached in memory cost more gas than using storage, as new memory is allocated for these variables, copying data from storage to memory.\n\n### Proof of Concept\n\nInstances:\n\n##### src/VaultRegistry.sol\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L40>\n\n```cpp\n40:         VaultInfo memory info = vaultToToken[msg.sender];\n```\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L118>\n\n```cpp\n118:         VaultInfo memory info = vaultToToken[msg.sender];\n```\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L128>\n\n```cpp\n128:         VaultInfo memory info = vaultToToken[_vault];\n```\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L136>\n\n```cpp\n136:         VaultInfo memory info = vaultToToken[_vault];\n```\n\n*   original gas costs with these `VaultInfo memory info`\n\n╭────────────────────────┬─────────────────┬────────┬────────┬────────┬─────────╮\n│ VaultRegistry contract ┆                 ┆        ┆        ┆        ┆         │\n╞════════════════════════╪═════════════════╪════════╪════════╪════════╪═════════╡\n│ Deployment Cost        ┆ Deployment Size ┆        ┆        ┆        ┆         │\n├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤\n│ 3898606                ┆ 19409           ┆        ┆        ┆        ┆         │\n├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤\n│ Function Name          ┆ min             ┆ avg    ┆ median ┆ max    ┆ # calls │\n├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤\n│ burn                   ┆ 2349            ┆ 4218   ┆ 4255   ┆ 4255   ┆ 52      │\n├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤\n│ mint                   ┆ 51597           ┆ 54389  ┆ 54845  ┆ 54845  ┆ 107     │\n├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤\n│ totalSupply            ┆ 1878            ┆ 1878   ┆ 1878   ┆ 1878   ┆ 203     |\\\n╰────────────────────────┴─────────────────┴────────┴────────┴────────┴─────────╯\n\n*   new gas costs with these four instances as `VaultInfo storage info`\n\n╭────────────────────────┬─────────────────┬────────┬────────┬────────┬─────────╮\n│ VaultRegistry contract ┆                 ┆        ┆        ┆        ┆         │\n╞════════════════════════╪═════════════════╪════════╪════════╪════════╪═════════╡\n│ Deployment Cost        ┆ Deployment Size ┆        ┆        ┆        ┆         │\n├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤\n│ 3881997                ┆ 19326           ┆        ┆        ┆        ┆         │\n├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤\n│ Function Name          ┆ min             ┆ avg    ┆ median ┆ max    ┆ # calls │\n├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤\n│ burn                   ┆ 2268            ┆ 4153   ┆ 4190   ┆ 4190   ┆ 52      │\n├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤\n│ mint                   ┆ 51516           ┆ 54308  ┆ 54764  ┆ 54764  ┆ 107     │\n├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤\n│ totalSupply            ┆ 1833            ┆ 1833   ┆ 1833   ┆ 1833   ┆ 203     |\\\n╰────────────────────────┴─────────────────┴────────┴────────┴────────┴─────────╯\n\n*   `16,609` gas is saved upon deployment\n*   `80` gas is saved per `mint` call on average\n*   `65` gas is saved per `burn` call on average\n*   `45` gas is saved per `totalSupply` call.\n\n### Recommended Mitigation Steps\n\nUse `storage` instead of `memory`.\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-07-fractional-v2-contest",
  "Code": [
    {
      "filename": "src/VaultRegistry.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {ClonesWithImmutableArgs} from \"clones-with-immutable-args/src/ClonesWithImmutableArgs.sol\";\nimport {FERC1155} from \"./FERC1155.sol\";\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {IVaultRegistry, VaultInfo} from \"./interfaces/IVaultRegistry.sol\";\nimport {VaultFactory} from \"./VaultFactory.sol\";\n\n/// @title Vault Registry\n/// @author Fractional Art\n/// @notice Registry contract for tracking all fractional vaults\ncontract VaultRegistry is IVaultRegistry {\n    /// @dev Use clones library with address types\n    using ClonesWithImmutableArgs for address;\n    /// @notice Address of VaultFactory contract\n    address public immutable factory;\n    /// @notice Address of FERC1155 token contract\n    address public immutable fNFT;\n    /// @notice Address of Implementation for FERC1155 token contract\n    address public immutable fNFTImplementation;\n    /// @notice Mapping of collection address to next token ID type\n    mapping(address => uint256) public nextId;\n    /// @notice Mapping of vault address to vault information\n    mapping(address => VaultInfo) public vaultToToken;\n\n    /// @notice Initializes factory, implementation, and token contracts\n    constructor() {\n        factory = address(new VaultFactory());\n        fNFTImplementation = address(new FERC1155());\n        fNFT = fNFTImplementation.clone(\n            abi.encodePacked(msg.sender, address(this))\n        );\n    }\n\n    /// @notice Burns vault tokens\n    /// @param _from Source address\n    /// @param _value Amount of tokens\n    function burn(address _from, uint256 _value) external {\n        VaultInfo memory info = vaultToToken[msg.sender];\n        uint256 id = info.id;\n        if (id == 0) revert UnregisteredVault(msg.sender);\n        FERC1155(info.token).burn(_from, id, _value);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    function create(\n        bytes32 _merkleRoot,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault) {\n        vault = _deployVault(_merkleRoot, address(fNFT), _plugins, _selectors);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins, and transfers ownership to a given owner\n    /// @dev This should only be done in limited cases i.e. if you're okay with a trusted individual(s)\n    /// having control over the vault. Ideally, execution would be locked behind a Multisig wallet.\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _owner Address of the vault owner\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    function createFor(\n        bytes32 _merkleRoot,\n        address _owner,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault) {\n        vault = _deployVault(_merkleRoot, address(fNFT), _plugins, _selectors);\n        IVault(vault).transferOwnership(_owner);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins for the message sender\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    /// @return token Address of FERC1155 contract\n    function createCollection(\n        bytes32 _merkleRoot,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault, address token) {\n        (vault, token) = createCollectionFor(\n            _merkleRoot,\n            msg.sender,\n            _plugins,\n            _selectors\n        );\n    }\n\n    /// @notice Creates a new vault with permissions and plugins for an existing collection\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _token Address of FERC1155 contract\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    function createInCollection(\n        bytes32 _merkleRoot,\n        address _token,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault) {\n        address controller = FERC1155(_token).controller();\n        if (controller != msg.sender)\n            revert InvalidController(controller, msg.sender);\n        vault = _deployVault(_merkleRoot, _token, _plugins, _selectors);\n    }\n\n    /// @notice Mints vault tokens\n    /// @param _to Target address\n    /// @param _value Amount of tokens\n    function mint(address _to, uint256 _value) external {\n        VaultInfo memory info = vaultToToken[msg.sender];\n        uint256 id = info.id;\n        if (id == 0) revert UnregisteredVault(msg.sender);\n        FERC1155(info.token).mint(_to, id, _value, \"\");\n    }\n\n    /// @notice Gets the total supply for a token and ID associated with a vault\n    /// @param _vault Address of the vault\n    /// @return Total supply\n    function totalSupply(address _vault) external view returns (uint256) {\n        VaultInfo memory info = vaultToToken[_vault];\n        return FERC1155(info.token).totalSupply(info.id);\n    }\n\n    /// @notice Gets the uri for a given token and ID associated with a vault\n    /// @param _vault Address of the vault\n    /// @return URI of token\n    function uri(address _vault) external view returns (string memory) {\n        VaultInfo memory info = vaultToToken[_vault];\n        return FERC1155(info.token).uri(info.id);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins for a given controller\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _controller Address of token controller\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    /// @return token Address of FERC1155 contract\n    function createCollectionFor(\n        bytes32 _merkleRoot,\n        address _controller,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) public returns (address vault, address token) {\n        token = fNFTImplementation.clone(\n            abi.encodePacked(_controller, address(this))\n        );\n        vault = _deployVault(_merkleRoot, token, _plugins, _selectors);\n    }\n\n    /// @dev Deploys new vault for specified token, sets merkle root, and installs plugins\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _token Address of FERC1155 contract\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    function _deployVault(\n        bytes32 _merkleRoot,\n        address _token,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) private returns (address vault) {\n        vault = VaultFactory(factory).deploy();\n        vaultToToken[vault] = VaultInfo(_token, ++nextId[_token]);\n        IVault(vault).setMerkleRoot(_merkleRoot);\n        IVault(vault).install(_selectors, _plugins);\n\n        emit VaultDeployed(vault, _token, nextId[_token]);\n    }\n}"
    },
    {
      "filename": "src/VaultRegistry.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {ClonesWithImmutableArgs} from \"clones-with-immutable-args/src/ClonesWithImmutableArgs.sol\";\nimport {FERC1155} from \"./FERC1155.sol\";\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {IVaultRegistry, VaultInfo} from \"./interfaces/IVaultRegistry.sol\";\nimport {VaultFactory} from \"./VaultFactory.sol\";\n\n/// @title Vault Registry\n/// @author Fractional Art\n/// @notice Registry contract for tracking all fractional vaults\ncontract VaultRegistry is IVaultRegistry {\n    /// @dev Use clones library with address types\n    using ClonesWithImmutableArgs for address;\n    /// @notice Address of VaultFactory contract\n    address public immutable factory;\n    /// @notice Address of FERC1155 token contract\n    address public immutable fNFT;\n    /// @notice Address of Implementation for FERC1155 token contract\n    address public immutable fNFTImplementation;\n    /// @notice Mapping of collection address to next token ID type\n    mapping(address => uint256) public nextId;\n    /// @notice Mapping of vault address to vault information\n    mapping(address => VaultInfo) public vaultToToken;\n\n    /// @notice Initializes factory, implementation, and token contracts\n    constructor() {\n        factory = address(new VaultFactory());\n        fNFTImplementation = address(new FERC1155());\n        fNFT = fNFTImplementation.clone(\n            abi.encodePacked(msg.sender, address(this))\n        );\n    }\n\n    /// @notice Burns vault tokens\n    /// @param _from Source address\n    /// @param _value Amount of tokens\n    function burn(address _from, uint256 _value) external {\n        VaultInfo memory info = vaultToToken[msg.sender];\n        uint256 id = info.id;\n        if (id == 0) revert UnregisteredVault(msg.sender);\n        FERC1155(info.token).burn(_from, id, _value);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    function create(\n        bytes32 _merkleRoot,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault) {\n        vault = _deployVault(_merkleRoot, address(fNFT), _plugins, _selectors);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins, and transfers ownership to a given owner\n    /// @dev This should only be done in limited cases i.e. if you're okay with a trusted individual(s)\n    /// having control over the vault. Ideally, execution would be locked behind a Multisig wallet.\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _owner Address of the vault owner\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    function createFor(\n        bytes32 _merkleRoot,\n        address _owner,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault) {\n        vault = _deployVault(_merkleRoot, address(fNFT), _plugins, _selectors);\n        IVault(vault).transferOwnership(_owner);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins for the message sender\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    /// @return token Address of FERC1155 contract\n    function createCollection(\n        bytes32 _merkleRoot,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault, address token) {\n        (vault, token) = createCollectionFor(\n            _merkleRoot,\n            msg.sender,\n            _plugins,\n            _selectors\n        );\n    }\n\n    /// @notice Creates a new vault with permissions and plugins for an existing collection\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _token Address of FERC1155 contract\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    function createInCollection(\n        bytes32 _merkleRoot,\n        address _token,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault) {\n        address controller = FERC1155(_token).controller();\n        if (controller != msg.sender)\n            revert InvalidController(controller, msg.sender);\n        vault = _deployVault(_merkleRoot, _token, _plugins, _selectors);\n    }\n\n    /// @notice Mints vault tokens\n    /// @param _to Target address\n    /// @param _value Amount of tokens\n    function mint(address _to, uint256 _value) external {\n        VaultInfo memory info = vaultToToken[msg.sender];\n        uint256 id = info.id;\n        if (id == 0) revert UnregisteredVault(msg.sender);\n        FERC1155(info.token).mint(_to, id, _value, \"\");\n    }\n\n    /// @notice Gets the total supply for a token and ID associated with a vault\n    /// @param _vault Address of the vault\n    /// @return Total supply\n    function totalSupply(address _vault) external view returns (uint256) {\n        VaultInfo memory info = vaultToToken[_vault];\n        return FERC1155(info.token).totalSupply(info.id);\n    }\n\n    /// @notice Gets the uri for a given token and ID associated with a vault\n    /// @param _vault Address of the vault\n    /// @return URI of token\n    function uri(address _vault) external view returns (string memory) {\n        VaultInfo memory info = vaultToToken[_vault];\n        return FERC1155(info.token).uri(info.id);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins for a given controller\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _controller Address of token controller\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    /// @return token Address of FERC1155 contract\n    function createCollectionFor(\n        bytes32 _merkleRoot,\n        address _controller,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) public returns (address vault, address token) {\n        token = fNFTImplementation.clone(\n            abi.encodePacked(_controller, address(this))\n        );\n        vault = _deployVault(_merkleRoot, token, _plugins, _selectors);\n    }\n\n    /// @dev Deploys new vault for specified token, sets merkle root, and installs plugins\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _token Address of FERC1155 contract\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    function _deployVault(\n        bytes32 _merkleRoot,\n        address _token,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) private returns (address vault) {\n        vault = VaultFactory(factory).deploy();\n        vaultToToken[vault] = VaultInfo(_token, ++nextId[_token]);\n        IVault(vault).setMerkleRoot(_merkleRoot);\n        IVault(vault).install(_selectors, _plugins);\n\n        emit VaultDeployed(vault, _token, nextId[_token]);\n    }\n}"
    },
    {
      "filename": "src/VaultRegistry.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {ClonesWithImmutableArgs} from \"clones-with-immutable-args/src/ClonesWithImmutableArgs.sol\";\nimport {FERC1155} from \"./FERC1155.sol\";\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {IVaultRegistry, VaultInfo} from \"./interfaces/IVaultRegistry.sol\";\nimport {VaultFactory} from \"./VaultFactory.sol\";\n\n/// @title Vault Registry\n/// @author Fractional Art\n/// @notice Registry contract for tracking all fractional vaults\ncontract VaultRegistry is IVaultRegistry {\n    /// @dev Use clones library with address types\n    using ClonesWithImmutableArgs for address;\n    /// @notice Address of VaultFactory contract\n    address public immutable factory;\n    /// @notice Address of FERC1155 token contract\n    address public immutable fNFT;\n    /// @notice Address of Implementation for FERC1155 token contract\n    address public immutable fNFTImplementation;\n    /// @notice Mapping of collection address to next token ID type\n    mapping(address => uint256) public nextId;\n    /// @notice Mapping of vault address to vault information\n    mapping(address => VaultInfo) public vaultToToken;\n\n    /// @notice Initializes factory, implementation, and token contracts\n    constructor() {\n        factory = address(new VaultFactory());\n        fNFTImplementation = address(new FERC1155());\n        fNFT = fNFTImplementation.clone(\n            abi.encodePacked(msg.sender, address(this))\n        );\n    }\n\n    /// @notice Burns vault tokens\n    /// @param _from Source address\n    /// @param _value Amount of tokens\n    function burn(address _from, uint256 _value) external {\n        VaultInfo memory info = vaultToToken[msg.sender];\n        uint256 id = info.id;\n        if (id == 0) revert UnregisteredVault(msg.sender);\n        FERC1155(info.token).burn(_from, id, _value);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    function create(\n        bytes32 _merkleRoot,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault) {\n        vault = _deployVault(_merkleRoot, address(fNFT), _plugins, _selectors);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins, and transfers ownership to a given owner\n    /// @dev This should only be done in limited cases i.e. if you're okay with a trusted individual(s)\n    /// having control over the vault. Ideally, execution would be locked behind a Multisig wallet.\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _owner Address of the vault owner\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    function createFor(\n        bytes32 _merkleRoot,\n        address _owner,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault) {\n        vault = _deployVault(_merkleRoot, address(fNFT), _plugins, _selectors);\n        IVault(vault).transferOwnership(_owner);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins for the message sender\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    /// @return token Address of FERC1155 contract\n    function createCollection(\n        bytes32 _merkleRoot,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault, address token) {\n        (vault, token) = createCollectionFor(\n            _merkleRoot,\n            msg.sender,\n            _plugins,\n            _selectors\n        );\n    }\n\n    /// @notice Creates a new vault with permissions and plugins for an existing collection\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _token Address of FERC1155 contract\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    function createInCollection(\n        bytes32 _merkleRoot,\n        address _token,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault) {\n        address controller = FERC1155(_token).controller();\n        if (controller != msg.sender)\n            revert InvalidController(controller, msg.sender);\n        vault = _deployVault(_merkleRoot, _token, _plugins, _selectors);\n    }\n\n    /// @notice Mints vault tokens\n    /// @param _to Target address\n    /// @param _value Amount of tokens\n    function mint(address _to, uint256 _value) external {\n        VaultInfo memory info = vaultToToken[msg.sender];\n        uint256 id = info.id;\n        if (id == 0) revert UnregisteredVault(msg.sender);\n        FERC1155(info.token).mint(_to, id, _value, \"\");\n    }\n\n    /// @notice Gets the total supply for a token and ID associated with a vault\n    /// @param _vault Address of the vault\n    /// @return Total supply\n    function totalSupply(address _vault) external view returns (uint256) {\n        VaultInfo memory info = vaultToToken[_vault];\n        return FERC1155(info.token).totalSupply(info.id);\n    }\n\n    /// @notice Gets the uri for a given token and ID associated with a vault\n    /// @param _vault Address of the vault\n    /// @return URI of token\n    function uri(address _vault) external view returns (string memory) {\n        VaultInfo memory info = vaultToToken[_vault];\n        return FERC1155(info.token).uri(info.id);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins for a given controller\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _controller Address of token controller\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    /// @return token Address of FERC1155 contract\n    function createCollectionFor(\n        bytes32 _merkleRoot,\n        address _controller,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) public returns (address vault, address token) {\n        token = fNFTImplementation.clone(\n            abi.encodePacked(_controller, address(this))\n        );\n        vault = _deployVault(_merkleRoot, token, _plugins, _selectors);\n    }\n\n    /// @dev Deploys new vault for specified token, sets merkle root, and installs plugins\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _token Address of FERC1155 contract\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    function _deployVault(\n        bytes32 _merkleRoot,\n        address _token,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) private returns (address vault) {\n        vault = VaultFactory(factory).deploy();\n        vaultToToken[vault] = VaultInfo(_token, ++nextId[_token]);\n        IVault(vault).setMerkleRoot(_merkleRoot);\n        IVault(vault).install(_selectors, _plugins);\n\n        emit VaultDeployed(vault, _token, nextId[_token]);\n    }\n}"
    },
    {
      "filename": "src/VaultRegistry.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {ClonesWithImmutableArgs} from \"clones-with-immutable-args/src/ClonesWithImmutableArgs.sol\";\nimport {FERC1155} from \"./FERC1155.sol\";\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {IVaultRegistry, VaultInfo} from \"./interfaces/IVaultRegistry.sol\";\nimport {VaultFactory} from \"./VaultFactory.sol\";\n\n/// @title Vault Registry\n/// @author Fractional Art\n/// @notice Registry contract for tracking all fractional vaults\ncontract VaultRegistry is IVaultRegistry {\n    /// @dev Use clones library with address types\n    using ClonesWithImmutableArgs for address;\n    /// @notice Address of VaultFactory contract\n    address public immutable factory;\n    /// @notice Address of FERC1155 token contract\n    address public immutable fNFT;\n    /// @notice Address of Implementation for FERC1155 token contract\n    address public immutable fNFTImplementation;\n    /// @notice Mapping of collection address to next token ID type\n    mapping(address => uint256) public nextId;\n    /// @notice Mapping of vault address to vault information\n    mapping(address => VaultInfo) public vaultToToken;\n\n    /// @notice Initializes factory, implementation, and token contracts\n    constructor() {\n        factory = address(new VaultFactory());\n        fNFTImplementation = address(new FERC1155());\n        fNFT = fNFTImplementation.clone(\n            abi.encodePacked(msg.sender, address(this))\n        );\n    }\n\n    /// @notice Burns vault tokens\n    /// @param _from Source address\n    /// @param _value Amount of tokens\n    function burn(address _from, uint256 _value) external {\n        VaultInfo memory info = vaultToToken[msg.sender];\n        uint256 id = info.id;\n        if (id == 0) revert UnregisteredVault(msg.sender);\n        FERC1155(info.token).burn(_from, id, _value);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    function create(\n        bytes32 _merkleRoot,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault) {\n        vault = _deployVault(_merkleRoot, address(fNFT), _plugins, _selectors);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins, and transfers ownership to a given owner\n    /// @dev This should only be done in limited cases i.e. if you're okay with a trusted individual(s)\n    /// having control over the vault. Ideally, execution would be locked behind a Multisig wallet.\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _owner Address of the vault owner\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    function createFor(\n        bytes32 _merkleRoot,\n        address _owner,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault) {\n        vault = _deployVault(_merkleRoot, address(fNFT), _plugins, _selectors);\n        IVault(vault).transferOwnership(_owner);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins for the message sender\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    /// @return token Address of FERC1155 contract\n    function createCollection(\n        bytes32 _merkleRoot,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault, address token) {\n        (vault, token) = createCollectionFor(\n            _merkleRoot,\n            msg.sender,\n            _plugins,\n            _selectors\n        );\n    }\n\n    /// @notice Creates a new vault with permissions and plugins for an existing collection\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _token Address of FERC1155 contract\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    function createInCollection(\n        bytes32 _merkleRoot,\n        address _token,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault) {\n        address controller = FERC1155(_token).controller();\n        if (controller != msg.sender)\n            revert InvalidController(controller, msg.sender);\n        vault = _deployVault(_merkleRoot, _token, _plugins, _selectors);\n    }\n\n    /// @notice Mints vault tokens\n    /// @param _to Target address\n    /// @param _value Amount of tokens\n    function mint(address _to, uint256 _value) external {\n        VaultInfo memory info = vaultToToken[msg.sender];\n        uint256 id = info.id;\n        if (id == 0) revert UnregisteredVault(msg.sender);\n        FERC1155(info.token).mint(_to, id, _value, \"\");\n    }\n\n    /// @notice Gets the total supply for a token and ID associated with a vault\n    /// @param _vault Address of the vault\n    /// @return Total supply\n    function totalSupply(address _vault) external view returns (uint256) {\n        VaultInfo memory info = vaultToToken[_vault];\n        return FERC1155(info.token).totalSupply(info.id);\n    }\n\n    /// @notice Gets the uri for a given token and ID associated with a vault\n    /// @param _vault Address of the vault\n    /// @return URI of token\n    function uri(address _vault) external view returns (string memory) {\n        VaultInfo memory info = vaultToToken[_vault];\n        return FERC1155(info.token).uri(info.id);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins for a given controller\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _controller Address of token controller\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    /// @return token Address of FERC1155 contract\n    function createCollectionFor(\n        bytes32 _merkleRoot,\n        address _controller,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) public returns (address vault, address token) {\n        token = fNFTImplementation.clone(\n            abi.encodePacked(_controller, address(this))\n        );\n        vault = _deployVault(_merkleRoot, token, _plugins, _selectors);\n    }\n\n    /// @dev Deploys new vault for specified token, sets merkle root, and installs plugins\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _token Address of FERC1155 contract\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    function _deployVault(\n        bytes32 _merkleRoot,\n        address _token,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) private returns (address vault) {\n        vault = VaultFactory(factory).deploy();\n        vaultToToken[vault] = VaultInfo(_token, ++nextId[_token]);\n        IVault(vault).setMerkleRoot(_merkleRoot);\n        IVault(vault).install(_selectors, _plugins);\n\n        emit VaultDeployed(vault, _token, nextId[_token]);\n    }\n}"
    }
  ]
}