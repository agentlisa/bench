{
  "Title": "[H-56] Tokens can be stolen from other users who have approved Magnetar",
  "Content": "\n<https://github.com/Tapioca-DAO/tapioca-periph-audit/blob/023751a4e987cf7c203ab25d3abba58f7344f213/contracts/Magnetar/MagnetarV2.sol#L622-L635> \n\n<https://github.com/Tapioca-DAO/tapioca-periph-audit/blob/023751a4e987cf7c203ab25d3abba58f7344f213/contracts/Magnetar/MagnetarV2Storage.sol#L336-L338> \n\n<https://github.com/Tapioca-DAO/tapioca-periph-audit/blob/023751a4e987cf7c203ab25d3abba58f7344f213/contracts/Magnetar/modules/MagnetarMarketModule.sol#L70> \n\n<https://github.com/Tapioca-DAO/tapioca-periph-audit/blob/023751a4e987cf7c203ab25d3abba58f7344f213/contracts/Magnetar/modules/MagnetarMarketModule.sol#L212-L241> \n\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/MarketERC20.sol#L84-L91>\n\nThe `MagnetarV2.sol` contract is a helper contract that allows users to interact with other parts of the Tapioca ecosystem. In order for Magnetar to be able to perform actions on behalf of a user, the user has to approve the contract as an approved spender (or equivalent) of the relevant tokens in the part of the Tapioca ecosystem the user wants to interact with.\n\nIn order to avoid abuse, many of the actions that Magnetar can perform are protected by a check that the owner of the position/token needs to be the `msg.sender` of the user interacting with Magnetar. However, there are some methods that are callable through Magnetar that don't have this check. This allows a malicious user to use approvals other users have made to Magnetar to steal their underlying tokens.\n\n### Proof of Concept\n\nAs I mentioned above, many of the Magnetar methods have a check to ensure that the `msg.sender` is the \"from\" address for the subsequent interactions with other parts of the Tapioca ecosystem. This check is performed by the `_checkSender` method:\n\n        function _checkSender(address _from) internal view {\n            require(_from == msg.sender, \"MagnetarV2: operator not approved\");\n        }\n\nThis function does what it is designed to do, however there are some methods that don't include this protection when they should.\n\nOne example is the `MARKET_BUY_COLLATERAL` action that allows a user to buy collateral in a market:\n\n                else if (_action.id == MARKET_BUY_COLLATERAL) {\n                    HelperBuyCollateral memory data = abi.decode(\n                        _action.call[4:],\n                        (HelperBuyCollateral)\n                    );\n\n                    IMarket(data.market).buyCollateral(\n                        data.from,\n                        data.borrowAmount,\n                        data.supplyAmount,\n                        data.minAmountOut,\n                        address(data.swapper),\n                        data.dexData\n                    );\n                }\n\nIn the market contract there is an underlying call to check whether the sender has the allowance to buy collateral:\n\n        function _allowedBorrow(address from, uint share) internal {\n            if (from != msg.sender) {\n                if (allowanceBorrow[from][msg.sender] < share) {\n                    revert NotApproved(from, msg.sender);\n                }\n                allowanceBorrow[from][msg.sender] -= share;\n            }\n        }\n\nSince the `msg.sender` from the perspective of the market is Magnetar, the user would need to provide a borrow allowance to Magnetar to perform this action through Magnetar.\n\nHowever, you can see above in the `MARKET_BUY_COLLATERAL` code snippet that there is no call to `_checkSender`. As a result, a malicious user can now pass in an arbitrary `data.from` address to use the allowance provided by another user to perform an unauthorised action. In this case, the malicious user could lever up the user's position to increase the user's LTV and therefore push the user closer to insolvency; at which point the user can be liquidated for a profit.\n\nAnother example of this issue is with the `depositRepayAndRemoveCollateralFromMarket` method in `MagnetarMarketModule.sol`. In this instance a malicious user can drain approved tokens from any other user by depositing into the Magnetar yield box:\n\n            // deposit to YieldBox\n            if (depositAmount > 0) {\n                _extractTokens(\n                    extractFromSender ? msg.sender : user,\n                    assetAddress,\n                    depositAmount\n                );\n                IERC20(assetAddress).approve(address(yieldBox), depositAmount);\n                yieldBox.depositAsset(\n                    assetId,\n                    address(this),\n                    address(this),\n                    depositAmount,\n                    0\n                );\n            }\n\nThis is a small snippet from the underlying `_depositRepayAndRemoveCollateralFromMarket` method that doesn't include a call to `_checkSender` and therefore the malicious user can simply set `extractFromSender` to false and specify an arbitrary user address.\n\n### Recommended Mitigation Steps\n\nThe `_checkSender` method should be used in every method in `MagnetarV2.sol` and `MagnetarMarketModule.sol` if it isn't already.\n\n**[0xRektora (Tapioca) confirmed via duplicate issue 106](https://github.com/code-423n4/2023-07-tapioca-findings/issues/106)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-07-tapioca",
  "Code": [
    {
      "filename": "contracts/Magnetar/MagnetarV2.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\n//OZ\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n//TAPIOCA\nimport \"./MagnetarV2Storage.sol\";\nimport \"./modules/MagnetarMarketModule.sol\";\n\n/*\n\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\_______/\\\\\\\\\\_____________/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\____        \n _\\///////\\\\\\/////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\/////////\\\\\\_\\/////\\\\\\///______/\\\\\\///\\\\\\________/\\\\\\////////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__       \n  _______\\/\\\\\\________/\\\\\\/////////\\\\\\_\\/\\\\\\_______\\/\\\\\\_____\\/\\\\\\_______/\\\\\\/__\\///\\\\\\____/\\\\\\/____________/\\\\\\/////////\\\\\\_      \n   _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\/\\\\\\______/\\\\\\______\\//\\\\\\__/\\\\\\_____________\\/\\\\\\_______\\/\\\\\\_     \n    _______\\/\\\\\\_______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\/////////________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_____________\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_    \n     _______\\/\\\\\\_______\\/\\\\\\/////////\\\\\\_\\/\\\\\\_________________\\/\\\\\\_____\\//\\\\\\______/\\\\\\__\\//\\\\\\____________\\/\\\\\\/////////\\\\\\_   \n      _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_________________\\/\\\\\\______\\///\\\\\\__/\\\\\\_____\\///\\\\\\__________\\/\\\\\\_______\\/\\\\\\_  \n       _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\______________/\\\\\\\\\\\\\\\\\\\\\\____\\///\\\\\\\\\\/________\\////\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_ \n        _______\\///________\\///________\\///__\\///______________\\///////////_______\\/////_____________\\/////////__\\///________\\///__\n\n*/\n\n/// @title Magnetar contract\n/// @notice Generic helper contract\n/// @dev can execute individual or combined actions on BigBang/Market/tOFT and USDO\n///      -  the `burst` method allows combining multiple calls into 1 transaction\ncontract MagnetarV2 is Ownable, MagnetarV2Storage {\n    using SafeERC20 for IERC20;\n    using RebaseLibrary for Rebase;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    enum Module {\n        Market\n    }\n\n    /// @notice returns the Market module\n    MagnetarMarketModule public marketModule;\n\n    constructor(address _owner, address payable _marketModule) {\n        transferOwnership(_owner);\n        marketModule = MagnetarMarketModule(_marketModule);\n    }\n\n    // ******************** //\n    // *** VIEW METHODS *** //\n    // ******************** //\n    /// @notice returns Singularity markets' information\n    /// @param who user to return for\n    /// @param markets the list of Singularity markets to query for\n    function singularityMarketInfo(\n        address who,\n        ISingularity[] calldata markets\n    ) external view returns (SingularityInfo[] memory) {\n        return _singularityMarketInfo(who, markets);\n    }\n\n    /// @notice returns BigBang markets' information\n    /// @param who user to return for\n    /// @param markets the list of BigBang markets to query for\n    function bigBangMarketInfo(\n        address who,\n        IBigBang[] calldata markets\n    ) external view returns (BigBangInfo[] memory) {\n        return _bigBangMarketInfo(who, markets);\n    }\n\n    /// @notice Calculate the collateral amount off the shares.\n    /// @param market the Singularity or BigBang address\n    /// @param share The shares.\n    /// @return amount The amount.\n    function getCollateralAmountForShare(\n        IMarket market,\n        uint256 share\n    ) public view returns (uint256 amount) {\n        IYieldBoxBase yieldBox = IYieldBoxBase(market.yieldBox());\n        return yieldBox.toAmount(market.collateralId(), share, false);\n    }\n\n    /// @notice Calculate the collateral shares that are needed for `borrowPart`,\n    /// taking the current exchange rate into account.\n    /// @param market the Singularity or BigBang address\n    /// @param borrowPart The borrow part.\n    /// @return collateralShares The collateral shares.\n    function getCollateralSharesForBorrowPart(\n        IMarket market,\n        uint256 borrowPart,\n        uint256 liquidationMultiplierPrecision,\n        uint256 exchangeRatePrecision\n    ) public view returns (uint256 collateralShares) {\n        Rebase memory _totalBorrowed;\n        (uint128 totalBorrowElastic, uint128 totalBorrowBase) = market\n            .totalBorrow();\n        _totalBorrowed = Rebase(totalBorrowElastic, totalBorrowBase);\n\n        IYieldBoxBase yieldBox = IYieldBoxBase(market.yieldBox());\n        uint256 borrowAmount = _totalBorrowed.toElastic(borrowPart, false);\n        return\n            yieldBox.toShare(\n                market.collateralId(),\n                (borrowAmount *\n                    market.liquidationMultiplier() *\n                    market.exchangeRate()) /\n                    (liquidationMultiplierPrecision * exchangeRatePrecision),\n                false\n            );\n    }\n\n    /// @notice Return the equivalent of borrow part in asset amount.\n    /// @param market the Singularity or BigBang address\n    /// @param borrowPart The amount of borrow part to convert.\n    /// @return amount The equivalent of borrow part in asset amount.\n    function getAmountForBorrowPart(\n        IMarket market,\n        uint256 borrowPart\n    ) public view returns (uint256 amount) {\n        Rebase memory _totalBorrowed;\n        (uint128 totalBorrowElastic, uint128 totalBorrowBase) = market\n            .totalBorrow();\n        _totalBorrowed = Rebase(totalBorrowElastic, totalBorrowBase);\n\n        return _totalBorrowed.toElastic(borrowPart, false);\n    }\n\n    /// @notice Return the equivalent of amount in borrow part.\n    /// @param market the Singularity or BigBang address\n    /// @param amount The amount to convert.\n    /// @return part The equivalent of amount in borrow part.\n    function getBorrowPartForAmount(\n        IMarket market,\n        uint256 amount\n    ) public view returns (uint256 part) {\n        Rebase memory _totalBorrowed;\n        (uint128 totalBorrowElastic, uint128 totalBorrowBase) = market\n            .totalBorrow();\n        _totalBorrowed = Rebase(totalBorrowElastic, totalBorrowBase);\n\n        return _totalBorrowed.toBase(amount, false);\n    }\n\n    /// @notice Compute the amount of `singularity.assetId` from `fraction`\n    /// `fraction` can be `singularity.accrueInfo.feeFraction` or `singularity.balanceOf`\n    /// @param singularity the singularity address\n    /// @param fraction The fraction.\n    /// @return amount The amount.\n    function getAmountForAssetFraction(\n        ISingularity singularity,\n        uint256 fraction\n    ) public view returns (uint256 amount) {\n        (uint128 totalAssetElastic, uint128 totalAssetBase) = singularity\n            .totalAsset();\n\n        IYieldBoxBase yieldBox = IYieldBoxBase(singularity.yieldBox());\n        return\n            yieldBox.toAmount(\n                singularity.assetId(),\n                (fraction * totalAssetElastic) / totalAssetBase,\n                false\n            );\n    }\n\n    /// @notice Compute the fraction of `singularity.assetId` from `amount`\n    /// `fraction` can be `singularity.accrueInfo.feeFraction` or `singularity.balanceOf`\n    /// @param singularity the singularity address\n    /// @param amount The amount.\n    /// @return fraction The fraction.\n    function getFractionForAmount(\n        ISingularity singularity,\n        uint256 amount\n    ) public view returns (uint256 fraction) {\n        (uint128 totalAssetShare, uint128 totalAssetBase) = singularity\n            .totalAsset();\n        (uint128 totalBorrowElastic, ) = singularity.totalBorrow();\n        uint256 assetId = singularity.assetId();\n\n        IYieldBoxBase yieldBox = IYieldBoxBase(singularity.yieldBox());\n\n        uint256 share = yieldBox.toShare(assetId, amount, false);\n        uint256 allShare = totalAssetShare +\n            yieldBox.toShare(assetId, totalBorrowElastic, true);\n\n        fraction = allShare == 0 ? share : (share * totalAssetBase) / allShare;\n    }\n\n    // ********************** //\n    // *** PUBLIC METHODS *** //\n    // ********************** //\n    /// @notice Batch multiple calls together\n    /// @param calls The list of actions to perform\n    function burst(\n        Call[] calldata calls\n    ) external payable returns (Result[] memory returnData) {\n        uint256 valAccumulator;\n\n        uint256 length = calls.length;\n        returnData = new Result[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            Call calldata _action = calls[i];\n            if (!_action.allowFailure) {\n                require(\n                    _action.call.length > 0,\n                    string.concat(\n                        \"MagnetarV2: Missing call for action with index\",\n                        string(abi.encode(i))\n                    )\n                );\n            }\n\n            unchecked {\n                valAccumulator += _action.value;\n            }\n\n            if (_action.id == PERMIT_ALL) {\n                _permit(\n                    _action.target,\n                    _action.call,\n                    true,\n                    _action.allowFailure\n                );\n            } else if (_action.id == PERMIT) {\n                _permit(\n                    _action.target,\n                    _action.call,\n                    false,\n                    _action.allowFailure\n                );\n            } else if (_action.id == TOFT_WRAP) {\n                WrapData memory data = abi.decode(_action.call[4:], (WrapData));\n                _checkSender(data.from);\n                if (_action.value > 0) {\n                    unchecked {\n                        valAccumulator += _action.value;\n                    }\n                    ITapiocaOFT(_action.target).wrapNative{\n                        value: _action.value\n                    }(data.to);\n                } else {\n                    ITapiocaOFT(_action.target).wrap(\n                        msg.sender,\n                        data.to,\n                        data.amount\n                    );\n                }\n            } else if (_action.id == TOFT_SEND_FROM) {\n                (\n                    address from,\n                    uint16 dstChainId,\n                    bytes32 to,\n                    uint256 amount,\n                    ISendFrom.LzCallParams memory lzCallParams\n                ) = abi.decode(\n                        _action.call[4:],\n                        (\n                            address,\n                            uint16,\n                            bytes32,\n                            uint256,\n                            (ISendFrom.LzCallParams)\n                        )\n                    );\n                _checkSender(from);\n\n                ISendFrom(_action.target).sendFrom{value: _action.value}(\n                    msg.sender,\n                    dstChainId,\n                    to,\n                    amount,\n                    lzCallParams\n                );\n            } else if (_action.id == YB_DEPOSIT_ASSET) {\n                YieldBoxDepositData memory data = abi.decode(\n                    _action.call[4:],\n                    (YieldBoxDepositData)\n                );\n                _checkSender(data.from);\n\n                (uint256 amountOut, uint256 shareOut) = IYieldBoxBase(\n                    _action.target\n                ).depositAsset(\n                        data.assetId,\n                        msg.sender,\n                        data.to,\n                        data.amount,\n                        data.share\n                    );\n                returnData[i] = Result({\n                    success: true,\n                    returnData: abi.encode(amountOut, shareOut)\n                });\n            } else if (_action.id == MARKET_ADD_COLLATERAL) {\n                SGLAddCollateralData memory data = abi.decode(\n                    _action.call[4:],\n                    (SGLAddCollateralData)\n                );\n                _checkSender(data.from);\n\n                IMarket(_action.target).addCollateral(\n                    msg.sender,\n                    data.to,\n                    data.skim,\n                    data.amount,\n                    data.share\n                );\n            } else if (_action.id == MARKET_BORROW) {\n                SGLBorrowData memory data = abi.decode(\n                    _action.call[4:],\n                    (SGLBorrowData)\n                );\n                _checkSender(data.from);\n\n                (uint256 part, uint256 share) = IMarket(_action.target).borrow(\n                    msg.sender,\n                    data.to,\n                    data.amount\n                );\n                returnData[i] = Result({\n                    success: true,\n                    returnData: abi.encode(part, share)\n                });\n            } else if (_action.id == YB_WITHDRAW_TO) {\n                (\n                    address yieldBox,\n                    address from,\n                    uint256 assetId,\n                    uint16 dstChainId,\n                    bytes32 receiver,\n                    uint256 amount,\n                    uint256 share,\n                    bytes memory adapterParams,\n                    address payable refundAddress\n                ) = abi.decode(\n                        _action.call[4:],\n                        (\n                            address,\n                            address,\n                            uint256,\n                            uint16,\n                            bytes32,\n                            uint256,\n                            uint256,\n                            bytes,\n                            address\n                        )\n                    );\n\n                _executeModule(\n                    Module.Market,\n                    abi.encodeWithSelector(\n                        MagnetarMarketModule.withdrawToChain.selector,\n                        yieldBox,\n                        from,\n                        assetId,\n                        dstChainId,\n                        receiver,\n                        amount,\n                        share,\n                        adapterParams,\n                        refundAddress,\n                        _action.value\n                    )\n                );\n            } else if (_action.id == MARKET_LEND) {\n                SGLLendData memory data = abi.decode(\n                    _action.call[4:],\n                    (SGLLendData)\n                );\n                _checkSender(data.from);\n\n                uint256 fraction = IMarket(_action.target).addAsset(\n                    msg.sender,\n                    data.to,\n                    data.skim,\n                    data.share\n                );\n                returnData[i] = Result({\n                    success: true,\n                    returnData: abi.encode(fraction)\n                });\n            } else if (_action.id == MARKET_REPAY) {\n                SGLRepayData memory data = abi.decode(\n                    _action.call[4:],\n                    (SGLRepayData)\n                );\n                _checkSender(data.from);\n\n                uint256 amount = IMarket(_action.target).repay(\n                    msg.sender,\n                    data.to,\n                    data.skim,\n                    data.part\n                );\n                returnData[i] = Result({\n                    success: true,\n                    returnData: abi.encode(amount)\n                });\n            } else if (_action.id == TOFT_SEND_AND_BORROW) {\n                (\n                    address from,\n                    address to,\n                    uint16 lzDstChainId,\n                    bytes memory airdropAdapterParams,\n                    ITapiocaOFT.IBorrowParams memory borrowParams,\n                    ICommonData.IWithdrawParams memory withdrawParams,\n                    ICommonData.ISendOptions memory options,\n                    ICommonData.IApproval[] memory approvals\n                ) = abi.decode(\n                        _action.call[4:],\n                        (\n                            address,\n                            address,\n                            uint16,\n                            bytes,\n                            ITapiocaOFT.IBorrowParams,\n                            ICommonData.IWithdrawParams,\n                            ICommonData.ISendOptions,\n                            ICommonData.IApproval[]\n                        )\n                    );\n                _checkSender(from);\n\n                ITapiocaOFT(_action.target).sendToYBAndBorrow{\n                    value: _action.value\n                }(\n                    msg.sender,\n                    to,\n                    lzDstChainId,\n                    airdropAdapterParams,\n                    borrowParams,\n                    withdrawParams,\n                    options,\n                    approvals\n                );\n            } else if (_action.id == TOFT_SEND_AND_LEND) {\n                (\n                    address from,\n                    address to,\n                    uint16 dstChainId,\n                    address zroPaymentAddress,\n                    IUSDOBase.ILendOrRepayParams memory lendParams,\n                    ICommonData.IApproval[] memory approvals,\n                    ICommonData.IWithdrawParams memory withdrawParams,\n                    bytes memory adapterParams\n                ) = abi.decode(\n                        _action.call[4:],\n                        (\n                            address,\n                            address,\n                            uint16,\n                            address,\n                            (IUSDOBase.ILendOrRepayParams),\n                            (ICommonData.IApproval[]),\n                            (ICommonData.IWithdrawParams),\n                            bytes\n                        )\n                    );\n                _checkSender(from);\n\n                IUSDOBase(_action.target).sendAndLendOrRepay{\n                    value: _action.value\n                }(\n                    msg.sender,\n                    to,\n                    dstChainId,\n                    zroPaymentAddress,\n                    lendParams,\n                    approvals,\n                    withdrawParams,\n                    adapterParams\n                );\n            } else if (_action.id == TOFT_DEPOSIT_TO_STRATEGY) {\n                TOFTSendToStrategyData memory data = abi.decode(\n                    _action.call[4:],\n                    (TOFTSendToStrategyData)\n                );\n                _checkSender(data.from);\n\n                ITapiocaOFT(_action.target).sendToStrategy{\n                    value: _action.value\n                }(\n                    msg.sender,\n                    data.to,\n                    data.amount,\n                    data.share,\n                    data.assetId,\n                    data.lzDstChainId,\n                    data.options\n                );\n            } else if (_action.id == TOFT_RETRIEVE_FROM_STRATEGY) {\n                (\n                    address from,\n                    uint256 amount,\n                    uint256 share,\n                    uint256 assetId,\n                    uint16 lzDstChainId,\n                    address zroPaymentAddress,\n                    bytes memory airdropAdapterParam\n                ) = abi.decode(\n                        _action.call[4:],\n                        (\n                            address,\n                            uint256,\n                            uint256,\n                            uint256,\n                            uint16,\n                            address,\n                            bytes\n                        )\n                    );\n\n                _checkSender(from);\n\n                ITapiocaOFT(_action.target).retrieveFromStrategy{\n                    value: _action.value\n                }(\n                    msg.sender,\n                    amount,\n                    share,\n                    assetId,\n                    lzDstChainId,\n                    zroPaymentAddress,\n                    airdropAdapterParam\n                );\n            } else if (_action.id == MARKET_YBDEPOSIT_AND_LEND) {\n                HelperLendData memory data = abi.decode(\n                    _action.call[4:],\n                    (HelperLendData)\n                );\n\n                _executeModule(\n                    Module.Market,\n                    abi.encodeWithSelector(\n                        MagnetarMarketModule.mintFromBBAndLendOnSGL.selector,\n                        data.user,\n                        data.lendAmount,\n                        data.mintData,\n                        data.depositData,\n                        data.lockData,\n                        data.participateData,\n                        data.externalContracts\n                    )\n                );\n            } else if (_action.id == MARKET_YBDEPOSIT_COLLATERAL_AND_BORROW) {\n                (\n                    address market,\n                    address user,\n                    uint256 collateralAmount,\n                    uint256 borrowAmount,\n                    ,\n                    bool deposit,\n                    ICommonData.IWithdrawParams memory withdrawParams\n                ) = abi.decode(\n                        _action.call[4:],\n                        (\n                            address,\n                            address,\n                            uint256,\n                            uint256,\n                            bool,\n                            bool,\n                            ICommonData.IWithdrawParams\n                        )\n                    );\n\n                _executeModule(\n                    Module.Market,\n                    abi.encodeWithSelector(\n                        MagnetarMarketModule\n                            .depositAddCollateralAndBorrowFromMarket\n                            .selector,\n                        market,\n                        user,\n                        collateralAmount,\n                        borrowAmount,\n                        false,\n                        deposit,\n                        withdrawParams\n                    )\n                );\n            } else if (_action.id == MARKET_REMOVE_ASSET) {\n                HelperMarketRemoveAndRepayAsset memory data = abi.decode(\n                    _action.call[4:],\n                    (HelperMarketRemoveAndRepayAsset)\n                );\n\n                _executeModule(\n                    Module.Market,\n                    abi.encodeWithSelector(\n                        MagnetarMarketModule\n                            .exitPositionAndRemoveCollateral\n                            .selector,\n                        data.user,\n                        data.externalData,\n                        data.removeAndRepayData\n                    )\n                );\n            } else if (_action.id == MARKET_DEPOSIT_REPAY_REMOVE_COLLATERAL) {\n                HelperDepositRepayRemoveCollateral memory data = abi.decode(\n                    _action.call[4:],\n                    (HelperDepositRepayRemoveCollateral)\n                );\n\n                _executeModule(\n                    Module.Market,\n                    abi.encodeWithSelector(\n                        MagnetarMarketModule\n                            .depositRepayAndRemoveCollateralFromMarket\n                            .selector,\n                        data.market,\n                        data.user,\n                        data.depositAmount,\n                        data.repayAmount,\n                        data.collateralAmount,\n                        data.extractFromSender,\n                        data.withdrawCollateralParams\n                    )\n                );\n            } else if (_action.id == MARKET_BUY_COLLATERAL) {\n                HelperBuyCollateral memory data = abi.decode(\n                    _action.call[4:],\n                    (HelperBuyCollateral)\n                );\n\n                IMarket(data.market).buyCollateral(\n                    data.from,\n                    data.borrowAmount,\n                    data.supplyAmount,\n                    data.minAmountOut,\n                    address(data.swapper),\n                    data.dexData\n                );\n            } else if (_action.id == MARKET_SELL_COLLATERAL) {\n                HelperSellCollateral memory data = abi.decode(\n                    _action.call[4:],\n                    (HelperSellCollateral)\n                );\n\n                IMarket(data.market).sellCollateral(\n                    data.from,\n                    data.share,\n                    data.minAmountOut,\n                    address(data.swapper),\n                    data.dexData\n                );\n            } else if (_action.id == TAP_EXERCISE_OPTION) {\n                HelperExerciseOption memory data = abi.decode(\n                    _action.call[4:],\n                    (HelperExerciseOption)\n                );\n\n                ITapiocaOptionsBrokerCrossChain(_action.target).exerciseOption(\n                    data.optionsData,\n                    data.lzData,\n                    data.tapSendData,\n                    data.approvals\n                );\n            } else if (_action.id == MARKET_MULTIHOP_BUY) {\n                HelperMultiHopBuy memory data = abi.decode(\n                    _action.call[4:],\n                    (HelperMultiHopBuy)\n                );\n\n                IUSDOBase(_action.target).initMultiHopBuy(\n                    data.from,\n                    data.collateralAmount,\n                    data.borrowAmount,\n                    data.swapData,\n                    data.lzData,\n                    data.externalData,\n                    data.airdropAdapterParams,\n                    data.approvals\n                );\n            } else if (_action.id == MARKET_MULTIHOP_BUY) {\n                HelperMultiHopBuy memory data = abi.decode(\n                    _action.call[4:],\n                    (HelperMultiHopBuy)\n                );\n\n                IUSDOBase(_action.target).initMultiHopBuy(\n                    data.from,\n                    data.collateralAmount,\n                    data.borrowAmount,\n                    data.swapData,\n                    data.lzData,\n                    data.externalData,\n                    data.airdropAdapterParams,\n                    data.approvals\n                );\n            } else if (_action.id == TOFT_REMOVE_AND_REPAY) {\n                HelperTOFTRemoveAndRepayAsset memory data = abi.decode(\n                    _action.call[4:],\n                    (HelperTOFTRemoveAndRepayAsset)\n                );\n\n                IUSDOBase(_action.target).removeAsset(\n                    data.from,\n                    data.to,\n                    data.lzDstChainId,\n                    data.zroPaymentAddress,\n                    data.adapterParams,\n                    data.externalData,\n                    data.removeAndRepayData,\n                    data.approvals\n                );\n            } else {\n                revert(\"MagnetarV2: action not valid\");\n            }\n        }\n\n        require(msg.value == valAccumulator, \"MagnetarV2: value mismatch\");\n    }\n\n    /// @notice performs a withdraw operation\n    /// @dev it can withdraw on the current chain or it can send it to another one\n    ///     - if `dstChainId` is 0 performs a same-chain withdrawal\n    ///          - all parameters except `yieldBox`, `from`, `assetId` and `amount` or `share` are ignored\n    ///     - if `dstChainId` is NOT 0, the method requires gas for the `sendFrom` operation\n    /// @param yieldBox the YieldBox address\n    /// @param from user to withdraw from\n    /// @param assetId the YieldBox asset id to withdraw\n    /// @param dstChainId LZ chain id to withdraw to\n    /// @param receiver the receiver on the destination chain\n    /// @param amount the amount to withdraw\n    /// @param share the share to withdraw\n    /// @param adapterParams LZ adapter params\n    /// @param refundAddress the LZ refund address which receives the gas not used in the process\n    /// @param gas the amount of gas to use for sending the asset to another layer\n    function withdrawToChain(\n        IYieldBoxBase yieldBox,\n        address from,\n        uint256 assetId,\n        uint16 dstChainId,\n        bytes32 receiver,\n        uint256 amount,\n        uint256 share,\n        bytes memory adapterParams,\n        address payable refundAddress,\n        uint256 gas\n    ) external payable {\n        _executeModule(\n            Module.Market,\n            abi.encodeWithSelector(\n                MagnetarMarketModule.withdrawToChain.selector,\n                yieldBox,\n                from,\n                assetId,\n                dstChainId,\n                receiver,\n                amount,\n                share,\n                adapterParams,\n                refundAddress,\n                gas\n            )\n        );\n    }\n\n    /// @notice helper for deposit to YieldBox, add collateral to a market, borrom from the same market and withdraw\n    /// @dev all operations are optional:\n    ///         - if `deposit` is false it will skip the deposit to YieldBox step\n    ///         - if `withdraw` is false it will skip the withdraw step\n    ///         - if `collateralAmount == 0` it will skip the add collateral step\n    ///         - if `borrowAmount == 0` it will skip the borrow step\n    ///     - the amount deposited to YieldBox is `collateralAmount`\n    /// @param market the SGL/BigBang market\n    /// @param user the user to perform the action for\n    /// @param collateralAmount the collateral amount to add\n    /// @param borrowAmount the borrow amount\n    /// @param extractFromSender extracts collateral tokens from sender or from the user\n    /// @param deposit true/false flag for the deposit to YieldBox step\n    /// @param withdrawParams necessary data for the same chain or the cross-chain withdrawal\n    function depositAddCollateralAndBorrowFromMarket(\n        IMarket market,\n        address user,\n        uint256 collateralAmount,\n        uint256 borrowAmount,\n        bool extractFromSender,\n        bool deposit,\n        ICommonData.IWithdrawParams calldata withdrawParams\n    ) external payable {\n        _executeModule(\n            Module.Market,\n            abi.encodeWithSelector(\n                MagnetarMarketModule\n                    .depositAddCollateralAndBorrowFromMarket\n                    .selector,\n                market,\n                user,\n                collateralAmount,\n                borrowAmount,\n                extractFromSender,\n                deposit,\n                withdrawParams\n            )\n        );\n    }\n\n    /// @notice helper for deposit asset to YieldBox, repay on a market, remove collateral and withdraw\n    /// @dev all steps are optional:\n    ///         - if `depositAmount` is 0, the deposit to YieldBox step is skipped\n    ///         - if `repayAmount` is 0, the repay step is skipped\n    ///         - if `collateralAmount` is 0, the add collateral step is skipped\n    /// @param market the SGL/BigBang market\n    /// @param user the user to perform the action for\n    /// @param depositAmount the amount to deposit to YieldBox\n    /// @param repayAmount the amount to repay to the market\n    /// @param collateralAmount the amount to withdraw from the market\n    /// @param extractFromSender extracts collateral tokens from sender or from the user\n    /// @param withdrawCollateralParams withdraw specific params\n    function depositRepayAndRemoveCollateralFromMarket(\n        address market,\n        address user,\n        uint256 depositAmount,\n        uint256 repayAmount,\n        uint256 collateralAmount,\n        bool extractFromSender,\n        ICommonData.IWithdrawParams calldata withdrawCollateralParams\n    ) external payable {\n        _executeModule(\n            Module.Market,\n            abi.encodeWithSelector(\n                MagnetarMarketModule\n                    .depositRepayAndRemoveCollateralFromMarket\n                    .selector,\n                market,\n                user,\n                depositAmount,\n                repayAmount,\n                collateralAmount,\n                extractFromSender,\n                withdrawCollateralParams\n            )\n        );\n    }\n\n    /// @notice helper to deposit mint from BB, lend on SGL, lock on tOLP and participate on tOB\n    /// @dev all steps are optional:\n    ///         - if `mintData.mint` is false, the mint operation on BB is skipped\n    ///             - add BB collateral to YB, add collateral on BB and borrow from BB are part of the mint operation\n    ///         - if `depositData.deposit` is false, the asset deposit to YB is skipped\n    ///         - if `lendAmount == 0` the addAsset operation on SGL is skipped\n    ///             - if `mintData.mint` is tru"
    }
  ]
}