{
  "Title": "Fees Should Be Distributed Before Change of the Fee Configuration",
  "Content": "The [`convertFees`](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/EVault/modules/Governance.sol#L140-L172) function facilitates the distribution of accumulated fees between the protocol and the governor. This distribution is determined by the [protocol's fee configuration](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/EVault/modules/Governance.sol#L145) and the address of the [governor receiver](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/EVault/modules/Governance.sol#L146). Consequently, any alterations to the fee configuration or the governor receiver address will have a direct impact on the distribution of fees.\n\n\nConsider triggering `convertFees` function prior to making any changes to the fee distribution configuration or adjusting the governor receiver address to ensure that the accumulated fees are distributed according to the previous configuration.\n\n\n***Update:** Acknowledged, not resolved. The Euler team stated:*\n\n\n\n> *We acknowledge the issue. The roles of the governor, the fee receiver, and the DAO are not expected to be adversarial towards each other. So, we expect them to not abuse the current fee distribution logic intentionally, but rather cooperate to make sure the interests are aligned.*\n> \n> \n> *In the event that any party feels that it may be abused by a change to the settings, they are free to call the `convertFees` function more frequently to lock in the fee distribution more granularly. On the technical side, while a change to governor receiver could be easily handled by the vault, it would be challenging to do the same for the protocolâ€™s fee share, which is configured in a different contract.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/EVault/modules/Governance.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {IGovernance} from \"../IEVault.sol\";\nimport {IPriceOracle} from \"../../interfaces/IPriceOracle.sol\";\nimport {Base} from \"../shared/Base.sol\";\nimport {BalanceUtils} from \"../shared/BalanceUtils.sol\";\nimport {LTVUtils} from \"../shared/LTVUtils.sol\";\nimport {BorrowUtils} from \"../shared/BorrowUtils.sol\";\nimport {ProxyUtils} from \"../shared/lib/ProxyUtils.sol\";\n\nimport \"../shared/types/Types.sol\";\n\n/// @title GovernanceModule\n/// @author Euler Labs (https://www.eulerlabs.com/)\n/// @notice An EVault module handling governance, including configuration and fees\nabstract contract GovernanceModule is IGovernance, Base, BalanceUtils, BorrowUtils, LTVUtils {\n    using TypesLib for uint16;\n\n    // Protocol guarantees\n    uint16 constant MAX_PROTOCOL_FEE_SHARE = 0.5e4;\n    uint16 constant GUARANTEED_INTEREST_FEE_MIN = 0.1e4;\n    uint16 constant GUARANTEED_INTEREST_FEE_MAX = 1e4;\n\n    event GovSetName(string newName);\n    event GovSetSymbol(string newSymbol);\n    event GovSetGovernorAdmin(address indexed newGovernorAdmin);\n    event GovSetFeeReceiver(address indexed newFeeReceiver);\n    event GovSetLTV(\n        address indexed collateral, uint48 targetTimestamp, uint16 targetLTV, uint32 rampDuration, uint16 originalLTV\n    );\n    event GovSetInterestRateModel(address interestRateModel);\n    event GovSetHookConfig(address indexed newHookTarget, uint32 newHookedOps);\n    event GovSetConfigFlags(uint32 newConfigFlags);\n    event GovSetCaps(uint16 newSupplyCap, uint16 newBorrowCap);\n    event GovSetInterestFee(uint16 newFee);\n\n    modifier governorOnly() {\n        if (msg.sender != vaultStorage.governorAdmin) revert E_Unauthorized();\n        _;\n    }\n\n    /// @inheritdoc IGovernance\n    function governorAdmin() public view virtual reentrantOK returns (address) {\n        return vaultStorage.governorAdmin;\n    }\n\n    /// @inheritdoc IGovernance\n    function feeReceiver() public view virtual reentrantOK returns (address) {\n        return vaultStorage.feeReceiver;\n    }\n\n    /// @inheritdoc IGovernance\n    function interestFee() public view virtual reentrantOK returns (uint16) {\n        return vaultStorage.interestFee.toUint16();\n    }\n\n    /// @inheritdoc IGovernance\n    function interestRateModel() public view virtual reentrantOK returns (address) {\n        return vaultStorage.interestRateModel;\n    }\n\n    /// @inheritdoc IGovernance\n    function protocolConfigAddress() public view virtual reentrantOK returns (address) {\n        return address(protocolConfig);\n    }\n\n    /// @inheritdoc IGovernance\n    function protocolFeeShare() public view virtual reentrantOK returns (uint256) {\n        (, uint256 protocolShare) = protocolConfig.protocolFeeConfig(address(this));\n        return protocolShare;\n    }\n\n    /// @inheritdoc IGovernance\n    function protocolFeeReceiver() public view virtual reentrantOK returns (address) {\n        (address protocolReceiver,) = protocolConfig.protocolFeeConfig(address(this));\n        return protocolReceiver;\n    }\n\n    /// @inheritdoc IGovernance\n    function caps() public view virtual reentrantOK returns (uint16, uint16) {\n        return (vaultStorage.supplyCap.toRawUint16(), vaultStorage.borrowCap.toRawUint16());\n    }\n\n    /// @inheritdoc IGovernance\n    function borrowingLTV(address collateral) public view virtual reentrantOK returns (uint16) {\n        return getLTV(collateral, LTVType.BORROWING).toUint16();\n    }\n\n    /// @inheritdoc IGovernance\n    function liquidationLTV(address collateral) public view virtual reentrantOK returns (uint16) {\n        return getLTV(collateral, LTVType.LIQUIDATION).toUint16();\n    }\n\n    /// @inheritdoc IGovernance\n    function LTVFull(address collateral) public view virtual reentrantOK returns (uint48, uint16, uint32, uint16) {\n        LTVConfig memory ltv = vaultStorage.ltvLookup[collateral];\n        return (ltv.targetTimestamp, ltv.targetLTV.toUint16(), ltv.rampDuration, ltv.originalLTV.toUint16());\n    }\n\n    /// @inheritdoc IGovernance\n    function LTVList() public view virtual reentrantOK returns (address[] memory) {\n        return vaultStorage.ltvList;\n    }\n\n    /// @inheritdoc IGovernance\n    function hookConfig() public view virtual reentrantOK returns (address, uint32) {\n        return (vaultStorage.hookTarget, vaultStorage.hookedOps.toUint32());\n    }\n\n    /// @inheritdoc IGovernance\n    function configFlags() public view virtual reentrantOK returns (uint32) {\n        return (vaultStorage.configFlags.toUint32());\n    }\n\n    /// @inheritdoc IGovernance\n    function EVC() public view virtual reentrantOK returns (address) {\n        return address(evc);\n    }\n\n    /// @inheritdoc IGovernance\n    function unitOfAccount() public view virtual reentrantOK returns (address) {\n        (,, address _unitOfAccount) = ProxyUtils.metadata();\n        return _unitOfAccount;\n    }\n\n    /// @inheritdoc IGovernance\n    function oracle() public view virtual reentrantOK returns (address) {\n        (, IPriceOracle _oracle,) = ProxyUtils.metadata();\n        return address(_oracle);\n    }\n\n    /// @inheritdoc IGovernance\n    function permit2Address() public view virtual reentrantOK returns (address) {\n        return permit2;\n    }\n\n    /// @inheritdoc IGovernance\n    function convertFees() public virtual nonReentrant {\n        (VaultCache memory vaultCache, address account) = initOperation(OP_CONVERT_FEES, CHECKACCOUNT_NONE);\n\n        if (vaultCache.accumulatedFees.isZero()) return;\n\n        (address protocolReceiver, uint16 protocolFee) = protocolConfig.protocolFeeConfig(address(this));\n        address governorReceiver = vaultStorage.feeReceiver;\n\n        if (governorReceiver == address(0)) {\n            protocolFee = 1e4; // governor forfeits fees\n        } else if (protocolFee > MAX_PROTOCOL_FEE_SHARE) {\n            protocolFee = MAX_PROTOCOL_FEE_SHARE;\n        }\n\n        Shares governorShares = vaultCache.accumulatedFees.mulDiv(1e4 - protocolFee, 1e4);\n        Shares protocolShares = vaultCache.accumulatedFees - governorShares;\n\n        // Decrease totalShares because increaseBalance will increase it by that total amount\n        vaultStorage.totalShares = vaultCache.totalShares = vaultCache.totalShares - vaultCache.accumulatedFees;\n\n        vaultStorage.accumulatedFees = vaultCache.accumulatedFees = Shares.wrap(0);\n\n        // For the Deposit events in increaseBalance the assets amount is zero - the shares are covered with the accrued interest\n        if (!governorShares.isZero()) {\n            increaseBalance(vaultCache, governorReceiver, address(0), governorShares, Assets.wrap(0));\n        }\n\n        if (!protocolShares.isZero()) {\n            increaseBalance(vaultCache, protocolReceiver, address(0), protocolShares, Assets.wrap(0));\n        }\n\n        emit ConvertFees(account, protocolReceiver, governorReceiver, protocolShares.toUint(), governorShares.toUint());\n    }\n\n    /// @inheritdoc IGovernance\n    function setName(string calldata newName) public virtual nonReentrant governorOnly {\n        vaultStorage.name = newName;\n        emit GovSetName(newName);\n    }\n\n    /// @inheritdoc IGovernance\n    function setSymbol(string calldata newSymbol) public virtual nonReentrant governorOnly {\n        vaultStorage.symbol = newSymbol;\n        emit GovSetSymbol(newSymbol);\n    }\n\n    /// @inheritdoc IGovernance\n    function setGovernorAdmin(address newGovernorAdmin) public virtual nonReentrant governorOnly {\n        vaultStorage.governorAdmin = newGovernorAdmin;\n        emit GovSetGovernorAdmin(newGovernorAdmin);\n    }\n\n    /// @inheritdoc IGovernance\n    function setFeeReceiver(address newFeeReceiver) public virtual nonReentrant governorOnly {\n        vaultStorage.feeReceiver = newFeeReceiver;\n        emit GovSetFeeReceiver(newFeeReceiver);\n    }\n\n    /// @inheritdoc IGovernance\n    function setLTV(address collateral, uint16 ltv, uint32 rampDuration) public virtual nonReentrant governorOnly {\n        // self-collateralization is not allowed\n        if (collateral == address(this)) revert E_InvalidLTVAsset();\n\n        ConfigAmount newLTVAmount = ltv.toConfigAmount();\n        LTVConfig memory origLTV = vaultStorage.ltvLookup[collateral];\n\n        // If new LTV is higher than the previous, or the same, it should take effect immediately\n        if (newLTVAmount >= origLTV.getLTV(LTVType.LIQUIDATION) && rampDuration > 0) revert E_LTVRamp();\n\n        LTVConfig memory newLTV = origLTV.setLTV(newLTVAmount, rampDuration);\n\n        vaultStorage.ltvLookup[collateral] = newLTV;\n\n        if (!origLTV.initialized) vaultStorage.ltvList.push(collateral);\n\n        emit GovSetLTV(\n            collateral,\n            newLTV.targetTimestamp,\n            newLTV.targetLTV.toUint16(),\n            newLTV.rampDuration,\n            newLTV.originalLTV.toUint16()\n        );\n    }\n\n    /// @inheritdoc IGovernance\n    function clearLTV(address collateral) public virtual nonReentrant governorOnly {\n        uint16 originalLTV = getLTV(collateral, LTVType.LIQUIDATION).toUint16();\n        vaultStorage.ltvLookup[collateral].clear();\n\n        emit GovSetLTV(collateral, 0, 0, 0, originalLTV);\n    }\n\n    /// @inheritdoc IGovernance\n    function setInterestRateModel(address newModel) public virtual nonReentrant governorOnly {\n        VaultCache memory vaultCache = updateVault();\n\n        vaultStorage.interestRateModel = newModel;\n        vaultStorage.interestRate = 0;\n\n        uint256 newInterestRate = computeInterestRate(vaultCache);\n\n        logVaultStatus(vaultCache, newInterestRate);\n\n        emit GovSetInterestRateModel(newModel);\n    }\n\n    /// @inheritdoc IGovernance\n    function setHookConfig(address newHookTarget, uint32 newHookedOps) public virtual nonReentrant governorOnly {\n        vaultStorage.hookTarget = newHookTarget;\n        vaultStorage.hookedOps = Flags.wrap(newHookedOps);\n        emit GovSetHookConfig(newHookTarget, newHookedOps);\n    }\n\n    /// @inheritdoc IGovernance\n    function setConfigFlags(uint32 newConfigFlags) public virtual nonReentrant governorOnly {\n        vaultStorage.configFlags = Flags.wrap(newConfigFlags);\n        emit GovSetConfigFlags(newConfigFlags);\n    }\n\n    /// @inheritdoc IGovernance\n    function setCaps(uint16 supplyCap, uint16 borrowCap) public virtual nonReentrant governorOnly {\n        AmountCap _supplyCap = AmountCap.wrap(supplyCap);\n        // Max total assets is a sum of max cash size and max total debt, both Assets type\n        if (supplyCap > 0 && _supplyCap.resolve() > 2 * MAX_SANE_AMOUNT) revert E_BadSupplyCap();\n\n        AmountCap _borrowCap = AmountCap.wrap(borrowCap);\n        if (borrowCap > 0 && _borrowCap.resolve() > MAX_SANE_AMOUNT) revert E_BadBorrowCap();\n\n        vaultStorage.supplyCap = _supplyCap;\n        vaultStorage.borrowCap = _borrowCap;\n\n        emit GovSetCaps(supplyCap, borrowCap);\n    }\n\n    /// @inheritdoc IGovernance\n    function setInterestFee(uint16 newInterestFee) public virtual nonReentrant governorOnly {\n        // Update vault to apply the current interest fee to the pending interest\n        VaultCache memory vaultCache = updateVault();\n        logVaultStatus(vaultCache, vaultStorage.interestRate);\n\n        // Interest fees in guaranteed range are always allowed, otherwise ask protocolConfig\n        if (newInterestFee < GUARANTEED_INTEREST_FEE_MIN || newInterestFee > GUARANTEED_INTEREST_FEE_MAX) {\n            if (!protocolConfig.isValidInterestFee(address(this), newInterestFee)) revert E_BadFee();\n        }\n\n        vaultStorage.interestFee = newInterestFee.toConfigAmount();\n\n        emit GovSetInterestFee(newInterestFee);\n    }\n}\n\n/// @dev Deployable module contract\ncontract Governance is GovernanceModule {\n    constructor(Integrations memory integrations) Base(integrations) {}\n}"
    }
  ]
}