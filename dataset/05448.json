{
  "Title": "[09] Credit rewards accrue for slashed users",
  "Content": "\n*Note: At the judge’s request [here](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/1061#issuecomment-1919014163), this downgraded issue from the same warden has been included in this report for completeness.*\n\n### Lines of code\n\nhttps://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/loan/SurplusGuildMinter.sol#L216-L290\n\n### Impact\n\nSlashed stakers will lose their `GUILD` tokens but will still receive `CREDIT` tokens once more because `creditReward` is not zeroed like `guildReward` in `SurplusGuildMinter::getRewards()`. That will eventually create bad debt in the system as all the stakers for this term will be slashed and their rewards have to be lost, but this is not the case for the `CREDIT` tokens.\n\n### Proof of Concept\n\nWe can see in the `getRewards()` function that `_profitIndex` is updated in [`ProfitManager.claimRewards()`](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/governance/ProfitManager.sol#L409-L436) which will increase `deltaIndex` and despite the user being slashed he will still receive the `CREDIT` tokens that he would have if he hadn’t been slashed:\n\n[SurplusGuildMinter#L244-L264](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/loan/SurplusGuildMinter.sol#L244-L264)\n\n```solidity\nfunction getRewards(address user, address term)\n    public\n    returns (\n        uint256 lastGaugeLoss, // GuildToken.lastGaugeLoss(term)\n        UserStake memory userStake, // stake state after execution of getRewards()\n        bool slashed // true if the user has been slashed\n    )\n{\n    bool updateState;\n    lastGaugeLoss = GuildToken(guild).lastGaugeLoss(term);\n    if (lastGaugeLoss > uint256(userStake.lastGaugeLoss)) {\n        slashed = true;\n    }\n\n    // if the user is not staking, do nothing\n    userStake = _stakes[user][term];\n    if (userStake.stakeTime == 0)\n        return (lastGaugeLoss, userStake, slashed);\n\n    // compute CREDIT rewards\n    ProfitManager(profitManager).claimRewards(address(this)); // this will update profit indexes\n    uint256 _profitIndex = ProfitManager(profitManager).userGaugeProfitIndex(address(this), term);\n    uint256 _userProfitIndex = uint256(userStake.profitIndex);\n    if (_profitIndex == 0) _profitIndex = 1e18;\n    if (_userProfitIndex == 0) _userProfitIndex = 1e18;\n\n    uint256 deltaIndex = _profitIndex - _userProfitIndex;\n\n    if (deltaIndex != 0) {\n        uint256 creditReward = (uint256(userStake.guild) * deltaIndex) / 1e18;\n        uint256 guildReward = (creditReward * rewardRatio) / 1e18;\n        if (slashed) {\n            guildReward = 0;\n            //@audit creditRewards = 0 is missing\n        }\n\n        // forward rewards to user\n        if (guildReward != 0) {\n            RateLimitedMinter(rlgm).mint(user, guildReward);\n            emit GuildReward(block.timestamp, user, guildReward);\n        }\n        if (creditReward != 0) {\n            //@audit will receive them despite being slashed\n            CreditToken(credit).transfer(user, creditReward);\n        }\n... More code\n    }\n```\n\n### Recommended Mitigation Steps\n\nConsider setting `creditReward` to `0` when user passed is staked in order to not transfer any `CREDIT` tokens to him when he is slashed:\n\n```diff\nfunction getRewards(address user, address term)\n        public\n        returns (\n            uint256 lastGaugeLoss, // GuildToken.lastGaugeLoss(term)\n            UserStake memory userStake, // stake state after execution of getRewards()\n            bool slashed // true if the user has been slashed\n        )\n    {\n... More code\n        uint256 _profitIndex = ProfitManager(profitManager).userGaugeProfitIndex(address(this), term);\n        uint256 _userProfitIndex = uint256(userStake.profitIndex);\n        if (_profitIndex == 0) _profitIndex = 1e18;\n        if (_userProfitIndex == 0) _userProfitIndex = 1e18;\n\n        uint256 deltaIndex = _profitIndex - _userProfitIndex;\n\n        if (deltaIndex != 0) {\n            uint256 creditReward = (uint256(userStake.guild) * deltaIndex) / 1e18;\n            uint256 guildReward = (creditReward * rewardRatio) / 1e18;\n            if (slashed) {\n                guildReward = 0;\n+               creditReward = 0\n            }\n\n            // forward rewards to user\n            if (guildReward != 0) {\n                RateLimitedMinter(rlgm).mint(user, guildReward);\n                emit GuildReward(block.timestamp, user, guildReward);\n            }\n            if (creditReward != 0) {\n                //@audit will receive them despite being slashed\n                CreditToken(credit).transfer(user, creditReward);\n            }\n... More code\n        }\n```\n\n### Assessed type\n\nContext\n\n**[TrungOre (judge) decreased severity to Low](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/1037#issuecomment-1913555661)**\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-12-ethereumcreditguild",
  "Code": [
    {
      "filename": "src/loan/SurplusGuildMinter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {SafeCastLib} from \"@src/external/solmate/SafeCastLib.sol\";\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {GuildToken} from \"@src/tokens/GuildToken.sol\";\nimport {CreditToken} from \"@src/tokens/CreditToken.sol\";\nimport {ProfitManager} from \"@src/governance/ProfitManager.sol\";\nimport {RateLimitedMinter} from \"@src/rate-limits/RateLimitedMinter.sol\";\n\n/// @notice SurplusGuildMinter allows GUILD to be minted from CREDIT collateral.\n/// In this contract, CREDIT tokens can be provided as first-loss capital to\n/// the surplus buffer of chosen terms, and in exchange, users can participate in the\n/// gauge voting system at a reduced capital cost & without exposure to GUILD\n/// token's price fluctuations. GUILD minted through this contract can only\n/// participate in the gauge system to increase debt ceiling and earn fees\n/// from selected lending terms.\n/// @dev note that any update to the `rewardRatio` (through `setRewardRatio`) will\n/// change the rewards of all pending unclaimed rewards. Before a proposal to update\n/// the reward ratio execute, this contract should be pinged with `getRewards` for\n/// all users that have pending rewards.\ncontract SurplusGuildMinter is CoreRef {\n    /// @notice minimum number of CREDIT to stake\n    uint256 public constant MIN_STAKE = 1e18;\n\n    /// @notice reference number of seconds in 1 year\n    uint256 public constant YEAR = 31557600;\n\n    /// @notice emitted when a user stakes CREDIT on a target lending term\n    event Stake(\n        uint256 indexed timestamp,\n        address indexed term,\n        uint256 amount\n    );\n    /// @notice emitted when a user unstakes CREDIT on a target lending term\n    event Unstake(\n        uint256 indexed timestamp,\n        address indexed term,\n        uint256 amount\n    );\n    /// @notice emitted when a user is rewarded GUILD from non-zero interest\n    /// rate and closing their position without loss.\n    event GuildReward(\n        uint256 indexed timestamp,\n        address indexed user,\n        uint256 amount\n    );\n    /// @notice emitted when the mintRatio is updated\n    event MintRatioUpdate(uint256 indexed timestamp, uint256 ratio);\n    /// @notice emitted when the rewardRatio is updated\n    event RewardRatioUpdate(uint256 indexed timestamp, uint256 ratio);\n\n    /// @notice reference to the ProfitManager\n    address public immutable profitManager;\n\n    /// @notice reference to the CREDIT token\n    address public immutable credit;\n\n    /// @notice reference to the GUILD token\n    address public immutable guild;\n\n    /// @notice reference to the RateLimitedGuildMinter\n    address public immutable rlgm;\n\n    /// @notice ratio of GUILD tokens minted per CREDIT tokens staked.\n    /// expressed with 18 decimals, e.g. a ratio of 2e18 would provide 2e18\n    /// GUILD tokens to a user that stakes 1e18 CREDIT tokens.\n    uint256 public mintRatio;\n\n    /// @notice ratio of GUILD tokens earned per CREDIT tokens earned.\n    /// expressed with 18 decimals, e.g. a ratio of 2e18 would provide 2e18\n    /// GUILD tokens to a user that stakes earned 1e18 CREDIT tokens.\n    uint256 public rewardRatio;\n\n    struct UserStake {\n        uint48 stakeTime;\n        uint48 lastGaugeLoss;\n        uint160 profitIndex;\n        uint128 credit;\n        uint128 guild;\n    }\n\n    /// @notice list of user stakes (stakes[user][term]=UserStake)\n    mapping(address => mapping(address => UserStake)) internal _stakes;\n\n    constructor(\n        address _core,\n        address _profitManager,\n        address _credit,\n        address _guild,\n        address _rlgm,\n        uint256 _mintRatio,\n        uint256 _rewardRatio\n    ) CoreRef(_core) {\n        profitManager = _profitManager;\n        credit = _credit;\n        guild = _guild;\n        rlgm = _rlgm;\n        mintRatio = _mintRatio;\n        rewardRatio = _rewardRatio;\n    }\n\n    /// @notice get a given user stake\n    function getUserStake(\n        address user,\n        address term\n    ) external view returns (UserStake memory) {\n        return _stakes[user][term];\n    }\n\n    /// @notice stake CREDIT tokens to start voting in a gauge.\n    function stake(address term, uint256 amount) external whenNotPaused {\n        // apply pending rewards\n        (uint256 lastGaugeLoss, UserStake memory userStake, ) = getRewards(\n            msg.sender,\n            term\n        );\n\n        require(\n            lastGaugeLoss != block.timestamp,\n            \"SurplusGuildMinter: loss in block\"\n        );\n        require(amount >= MIN_STAKE, \"SurplusGuildMinter: min stake\");\n\n        // pull CREDIT from user & transfer it to surplus buffer\n        CreditToken(credit).transferFrom(msg.sender, address(this), amount);\n        CreditToken(credit).approve(address(profitManager), amount);\n        ProfitManager(profitManager).donateToTermSurplusBuffer(term, amount);\n\n        // self-mint GUILD tokens\n        uint256 _mintRatio = mintRatio;\n        uint256 guildAmount = (_mintRatio * amount) / 1e18;\n        RateLimitedMinter(rlgm).mint(address(this), guildAmount);\n        GuildToken(guild).incrementGauge(term, guildAmount);\n\n        // update state\n        userStake = UserStake({\n            stakeTime: SafeCastLib.safeCastTo48(block.timestamp),\n            lastGaugeLoss: SafeCastLib.safeCastTo48(lastGaugeLoss),\n            profitIndex: SafeCastLib.safeCastTo160(\n                ProfitManager(profitManager).userGaugeProfitIndex(\n                    address(this),\n                    term\n                )\n            ),\n            credit: userStake.credit + SafeCastLib.safeCastTo128(amount),\n            guild: userStake.guild + SafeCastLib.safeCastTo128(guildAmount)\n        });\n        _stakes[msg.sender][term] = userStake;\n\n        // emit event\n        emit Stake(block.timestamp, term, amount);\n    }\n\n    /// @notice unstake CREDIT tokens and stop voting in a gauge.\n    function unstake(address term, uint256 amount) external {\n        // apply pending rewards\n        (, UserStake memory userStake, bool slashed) = getRewards(\n            msg.sender,\n            term\n        );\n\n        // if the user has been slashed, there is nothing to do\n        if (slashed) return;\n\n        // check that the user is at least staking `amount` CREDIT\n        require(\n            amount != 0 && userStake.credit >= amount,\n            \"SurplusGuildMinter: invalid amount\"\n        );\n\n        // update stake\n        uint256 userMintRatio = (uint256(userStake.guild) * 1e18) /\n            userStake.credit; /// upcast guild to prevent overflow\n        uint256 guildAmount = (userMintRatio * amount) / 1e18;\n\n        if (amount == userStake.credit) guildAmount = userStake.guild;\n\n        userStake.credit -= SafeCastLib.safeCastTo128(amount);\n        userStake.guild -= SafeCastLib.safeCastTo128(guildAmount);\n\n        if (userStake.credit == 0) {\n            userStake.stakeTime = 0;\n            userStake.lastGaugeLoss = 0;\n            userStake.profitIndex = 0;\n        } else {\n            // if not unstaking all, make sure the stake remains\n            // greater than the minimum stake\n            require(\n                userStake.credit >= MIN_STAKE,\n                \"SurplusGuildMinter: remaining stake below min\"\n            );\n        }\n        _stakes[msg.sender][term] = userStake;\n\n        // withdraw & transfer CREDIT\n        ProfitManager(profitManager).withdrawFromTermSurplusBuffer(\n            term,\n            msg.sender,\n            amount\n        );\n\n        // burn GUILD\n        GuildToken(guild).decrementGauge(term, guildAmount);\n        RateLimitedMinter(rlgm).replenishBuffer(guildAmount);\n        GuildToken(guild).burn(guildAmount);\n\n        // emit event\n        emit Unstake(block.timestamp, term, amount);\n    }\n\n    /// @notice get rewards from a staking position without unstaking.\n    /// This can be used to slash users that have an outstanding unapplied loss.\n    function getRewards(\n        address user,\n        address term\n    )\n        public\n        returns (\n            uint256 lastGaugeLoss, // GuildToken.lastGaugeLoss(term)\n            UserStake memory userStake, // stake state after execution of getRewards()\n            bool slashed // true if the user has been slashed\n        )\n    {\n        bool updateState;\n        lastGaugeLoss = GuildToken(guild).lastGaugeLoss(term);\n        if (lastGaugeLoss > uint256(userStake.lastGaugeLoss)) {\n            slashed = true;\n        }\n\n        // if the user is not staking, do nothing\n        userStake = _stakes[user][term];\n        if (userStake.stakeTime == 0)\n            return (lastGaugeLoss, userStake, slashed);\n\n        // compute CREDIT rewards\n        ProfitManager(profitManager).claimRewards(address(this)); // this will update profit indexes\n        uint256 _profitIndex = ProfitManager(profitManager)\n            .userGaugeProfitIndex(address(this), term);\n        uint256 _userProfitIndex = uint256(userStake.profitIndex);\n\n        if (_profitIndex == 0) _profitIndex = 1e18;\n        if (_userProfitIndex == 0) _userProfitIndex = 1e18;\n\n        uint256 deltaIndex = _profitIndex - _userProfitIndex;\n\n        if (deltaIndex != 0) {\n            uint256 creditReward = (uint256(userStake.guild) * deltaIndex) /\n                1e18;\n            uint256 guildReward = (creditReward * rewardRatio) / 1e18;\n            if (slashed) {\n                guildReward = 0;\n            }\n\n            // forward rewards to user\n            if (guildReward != 0) {\n                RateLimitedMinter(rlgm).mint(user, guildReward);\n                emit GuildReward(block.timestamp, user, guildReward);\n            }\n            if (creditReward != 0) {\n                CreditToken(credit).transfer(user, creditReward);\n            }\n\n            // save the updated profitIndex\n            userStake.profitIndex = SafeCastLib.safeCastTo160(_profitIndex);\n            updateState = true;\n        }\n\n        // if a loss occurred while the user was staking, the GuildToken.applyGaugeLoss(address(this))\n        // can be called by anyone to slash address(this) and decrement gauge weight etc.\n        // The contribution to the surplus buffer is also forfeited.\n        if (slashed) {\n            emit Unstake(block.timestamp, term, uint256(userStake.credit));\n            userStake = UserStake({\n                stakeTime: uint48(0),\n                lastGaugeLoss: uint48(0),\n                profitIndex: uint160(0),\n                credit: uint128(0),\n                guild: uint128(0)\n            });\n            updateState = true;\n        }\n\n        // store the updated stake, if needed\n        if (updateState) {\n            _stakes[user][term] = userStake;\n        }\n    }\n\n    /// @notice update the mint ratio for a given user.\n    function updateMintRatio(address user, address term) external {\n        // apply pending rewards\n        (, UserStake memory userStake, bool slashed) = getRewards(user, term);\n\n        // if the user has been slashed or isnt staking, there is nothing to do\n        if (userStake.stakeTime == 0 || slashed) return;\n\n        // update amount of GUILD tokens staked\n        uint256 guildBefore = uint256(userStake.guild);\n        uint256 guildAfter = (mintRatio * uint256(userStake.credit)) / 1e18;\n        if (guildAfter > guildBefore) {\n            uint256 guildAmount = guildAfter - guildBefore;\n            RateLimitedMinter(rlgm).mint(address(this), guildAmount);\n            GuildToken(guild).incrementGauge(term, guildAmount);\n            _stakes[user][term].guild = SafeCastLib.safeCastTo128(guildAfter);\n        } else if (guildAfter < guildBefore) {\n            uint256 guildAmount = guildBefore - guildAfter;\n            GuildToken(guild).decrementGauge(term, guildAmount);\n            RateLimitedMinter(rlgm).replenishBuffer(guildAmount);\n            GuildToken(guild).burn(guildAmount);\n            _stakes[user][term].guild = SafeCastLib.safeCastTo128(guildAfter);\n        }\n    }\n\n    /// @notice governor-only function to set the ratio of GUILD tokens minted\n    /// per CREDIT tokens contributed to the surplus buffer.\n    function setMintRatio(\n        uint256 _mintRatio\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        mintRatio = _mintRatio;\n        emit MintRatioUpdate(block.timestamp, _mintRatio);\n    }\n\n    /// @notice governor-only function to set the ratio of GUILD tokens rewarded\n    /// per CREDIT tokens earned from GUILD staking.\n    function setRewardRatio(\n        uint256 _rewardRatio\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        rewardRatio = _rewardRatio;\n        emit RewardRatioUpdate(block.timestamp, _rewardRatio);\n    }\n}"
    },
    {
      "filename": "src/governance/ProfitManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {SimplePSM} from \"@src/loan/SimplePSM.sol\";\nimport {GuildToken} from \"@src/tokens/GuildToken.sol\";\nimport {CreditToken} from \"@src/tokens/CreditToken.sol\";\n\n/** \n@title ProfitManager\n@author eswak\n@notice This contract manages profits generated in the system and how it is distributed\n    between the various stakeholders.\n\n    This contract also manages a surplus buffer, which acts as first-loss capital in case of\n    bad debt. When bad debt is created beyond the surplus buffer, this contract decrements\n    the `creditMultiplier` value held in its storage, which has the effect of reducing the\n    value of CREDIT everywhere in the system.\n\n    When a loan generates profit (interests), the profit is traced back to users voting for\n    this lending term (gauge), which subsequently allows pro-rata distribution of profits to\n    GUILD holders that vote for the most productive gauges.\n\n    Seniority stack of the debt, in case of losses :\n    - per term surplus buffer (donated to global surplus buffer when loss is reported)\n    - global surplus buffer\n    - finally, credit holders (by updating down the creditMultiplier)\n*/\ncontract ProfitManager is CoreRef {\n    /// @notice reference to GUILD token.\n    address public guild;\n\n    /// @notice reference to CREDIT token.\n    address public credit;\n\n    /// @notice reference to CREDIT token PSM.\n    address public psm;\n\n    /// @notice profit index of a given gauge\n    mapping(address => uint256) public gaugeProfitIndex;\n\n    /// @notice profit index of a given user in a given gauge\n    mapping(address => mapping(address => uint256)) public userGaugeProfitIndex;\n\n    /// @dev internal structure used to optimize storage read, public functions use\n    /// uint256 numbers with 18 decimals.\n    struct ProfitSharingConfig {\n        uint32 surplusBufferSplit; // percentage, with 9 decimals (!) that go to surplus buffer\n        uint32 guildSplit; // percentage, with 9 decimals (!) that go to GUILD holders\n        uint32 otherSplit; // percentage, with 9 decimals (!) that go to other address if != address(0)\n        address otherRecipient; // address receiving `otherSplit`\n    }\n\n    /// @notice configuration of profit sharing.\n    /// `surplusBufferSplit`, `guildSplit`, and `otherSplit` are expressed as percentages with 9 decimals,\n    /// so a value of 1e9 would direct 100% of profits. The sum should be <= 1e9.\n    /// The rest (if the sum of `guildSplit` + `otherSplit` is < 1e9) is distributed to lenders of the\n    /// system, CREDIT holders, through the rebasing mechanism (`CreditToken.distribute()`).\n    /// If `otherRecipient` is set to address(0), `otherSplit` must equal 0.\n    /// The share of profit to `otherRecipient` is sent through a regular ERC20.transfer().\n    /// This structure is optimized for storage packing, all external interfaces reference\n    /// percentages encoded as uint256 with 18 decimals.\n    ProfitSharingConfig internal profitSharingConfig;\n\n    /// @notice amount of first-loss capital in the system.\n    /// This is a number of CREDIT token held on this contract that can be used to absorb losses in\n    /// cases where a loss is reported through `notifyPnL`. The surplus buffer is depleted first, and\n    /// if the loss is greater than the surplus buffer, the `creditMultiplier` is updated down.\n    uint256 public surplusBuffer;\n\n    /// @notice amount of first-loss capital for a given term.\n    /// This is a number of CREDIT token held on this contract that can be used to absorb losses in\n    /// cases where a loss is reported through `notifyPnL` in a given term.\n    /// When a loss is reported in a given term, its termSuplusBuffer is donated to the general\n    /// surplusBuffer before calculating the loss.\n    mapping(address => uint256) public termSurplusBuffer;\n\n    /// @notice multiplier for CREDIT value in the system.\n    /// e.g. a value of 0.7e18 would mean that CREDIT has been discounted by 30% so far in the system,\n    /// and that all lending terms will allow 1/0.7=1.42 times more CREDIT to be borrowed per collateral\n    /// tokens, and all active debts are also affected by this multiplier during the update (e.g. if an\n    /// address owed 1000 CREDIT in an active loan, they now owe 1428 CREDIT).\n    /// The CREDIT multiplier can only go down (CREDIT can only lose value over time, when bad debt\n    /// is created in the system). To make CREDIT a valuable asset to hold, profits generated by the system\n    /// shall be redistributed to holders through a savings rate or another mechanism.\n    uint256 public creditMultiplier = 1e18;\n\n    /// @notice minimum size of CREDIT loans.\n    /// this parameter is here to ensure that the gas costs of liquidation do not\n    /// outsize minimum overcollateralization (which could result in bad debt\n    /// on otherwise sound loans).\n    /// This value is adjusted up when the creditMultiplier goes down.\n    uint256 internal _minBorrow = 100e18;\n\n    /// @notice tolerance on new borrows regarding gauge weights.\n    /// For a total supply or 100 credit, and 2 gauges each at 50% weight,\n    /// the ideal borrow amount for each gauge is 50 credit. To facilitate\n    /// growth of the protocol, a tolerance is allowed compared to the ideal\n    /// gauge weights.\n    /// This tolerance is expressed as a percentage with 18 decimals.\n    /// A tolerance of 1e18 (100% - or 0% deviation compared to ideal weights)\n    /// can result in a deadlock situation where no new borrows are allowed.\n    uint256 public gaugeWeightTolerance = 1.2e18; // 120%\n\n    constructor(address _core) CoreRef(_core) {\n        emit MinBorrowUpdate(block.timestamp, 100e18);\n    }\n\n    /// @notice emitted when a profit or loss in a gauge is notified.\n    event GaugePnL(address indexed gauge, uint256 indexed when, int256 pnl);\n\n    /// @notice emitted when surplus buffer is updated.\n    event SurplusBufferUpdate(uint256 indexed when, uint256 newValue);\n\n    /// @notice emitted when surplus buffer of a given term is updated.\n    event TermSurplusBufferUpdate(\n        uint256 indexed when,\n        address indexed term,\n        uint256 newValue\n    );\n\n    /// @notice emitted when CREDIT multiplier is updated.\n    event CreditMultiplierUpdate(uint256 indexed when, uint256 newValue);\n\n    /// @notice emitted when GUILD profit sharing is updated.\n    event ProfitSharingConfigUpdate(\n        uint256 indexed when,\n        uint256 surplusBufferSplit,\n        uint256 creditSplit,\n        uint256 guildSplit,\n        uint256 otherSplit,\n        address otherRecipient\n    );\n\n    /// @notice emitted when a GUILD member claims their CREDIT rewards.\n    event ClaimRewards(\n        uint256 indexed when,\n        address indexed user,\n        address indexed gauge,\n        uint256 amount\n    );\n\n    /// @notice emitted when minBorrow is updated\n    event MinBorrowUpdate(uint256 indexed when, uint256 newValue);\n\n    /// @notice emitted when gaugeWeightTolerance is updated\n    event GaugeWeightToleranceUpdate(uint256 indexed when, uint256 newValue);\n\n    /// @notice get the minimum borrow amount\n    function minBorrow() external view returns (uint256) {\n        return (_minBorrow * 1e18) / creditMultiplier;\n    }\n\n    /// @notice initialize references to GUILD & CREDIT tokens.\n    function initializeReferences(\n        address _credit,\n        address _guild,\n        address _psm\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        assert(\n            credit == address(0) && guild == address(0) && psm == address(0)\n        );\n        credit = _credit;\n        guild = _guild;\n        psm = _psm;\n    }\n\n    /// @notice returns the sum of all borrowed CREDIT, not including unpaid interests\n    /// and creditMultiplier changes that could make debt amounts higher than the initial\n    /// borrowed CREDIT amounts.\n    function totalBorrowedCredit() external view returns (uint256) {\n        return\n            CreditToken(credit).targetTotalSupply() -\n            SimplePSM(psm).redeemableCredit();\n    }\n\n    /// @notice set the minimum borrow amount\n    function setMinBorrow(\n        uint256 newValue\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        _minBorrow = newValue;\n        emit MinBorrowUpdate(block.timestamp, newValue);\n    }\n\n    /// @notice set the gauge weight tolerance\n    function setGaugeWeightTolerance(\n        uint256 newValue\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        gaugeWeightTolerance = newValue;\n        emit GaugeWeightToleranceUpdate(block.timestamp, newValue);\n    }\n\n    /// @notice set the profit sharing config.\n    function setProfitSharingConfig(\n        uint256 surplusBufferSplit,\n        uint256 creditSplit,\n        uint256 guildSplit,\n        uint256 otherSplit,\n        address otherRecipient\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        if (otherRecipient == address(0)) {\n            require(otherSplit == 0, \"GuildToken: invalid config\");\n        } else {\n            require(otherSplit != 0, \"GuildToken: invalid config\");\n        }\n        require(\n            surplusBufferSplit + otherSplit + guildSplit + creditSplit == 1e18,\n            \"GuildToken: invalid config\"\n        );\n\n        profitSharingConfig = ProfitSharingConfig({\n            surplusBufferSplit: uint32(surplusBufferSplit / 1e9),\n            guildSplit: uint32(guildSplit / 1e9),\n            otherSplit: uint32(otherSplit / 1e9),\n            otherRecipient: otherRecipient\n        });\n\n        emit ProfitSharingConfigUpdate(\n            block.timestamp,\n            surplusBufferSplit,\n            creditSplit,\n            guildSplit,\n            otherSplit,\n            otherRecipient\n        );\n    }\n\n    /// @notice get the profit sharing config.\n    function getProfitSharingConfig()\n        external\n        view\n        returns (\n            uint256 surplusBufferSplit,\n            uint256 creditSplit,\n            uint256 guildSplit,\n            uint256 otherSplit,\n            address otherRecipient\n        )\n    {\n        surplusBufferSplit =\n            uint256(profitSharingConfig.surplusBufferSplit) *\n            1e9;\n        guildSplit = uint256(profitSharingConfig.guildSplit) * 1e9;\n        otherSplit = uint256(profitSharingConfig.otherSplit) * 1e9;\n        creditSplit = 1e18 - surplusBufferSplit - guildSplit - otherSplit;\n        otherRecipient = profitSharingConfig.otherRecipient;\n    }\n\n    /// @notice donate to surplus buffer\n    function donateToSurplusBuffer(uint256 amount) external {\n        CreditToken(credit).transferFrom(msg.sender, address(this), amount);\n        uint256 newSurplusBuffer = surplusBuffer + amount;\n        surplusBuffer = newSurplusBuffer;\n        emit SurplusBufferUpdate(block.timestamp, newSurplusBuffer);\n    }\n\n    /// @notice donate to surplus buffer of a given term\n    function donateToTermSurplusBuffer(address term, uint256 amount) external {\n        CreditToken(credit).transferFrom(msg.sender, address(this), amount);\n        uint256 newSurplusBuffer = termSurplusBuffer[term] + amount;\n        termSurplusBuffer[term] = newSurplusBuffer;\n        emit TermSurplusBufferUpdate(block.timestamp, term, newSurplusBuffer);\n    }\n\n    /// @notice withdraw from surplus buffer\n    function withdrawFromSurplusBuffer(\n        address to,\n        uint256 amount\n    ) external onlyCoreRole(CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW) {\n        uint256 newSurplusBuffer = surplusBuffer - amount; // this would revert due to underflow if withdrawing > surplusBuffer\n        surplusBuffer = newSurplusBuffer;\n        CreditToken(credit).transfer(to, amount);\n        emit SurplusBufferUpdate(block.timestamp, newSurplusBuffer);\n    }\n\n    /// @notice withdraw from surplus buffer of a given term\n    function withdrawFromTermSurplusBuffer(\n        address term,\n        address to,\n        uint256 amount\n    ) external onlyCoreRole(CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW) {\n        uint256 newSurplusBuffer = termSurplusBuffer[term] - amount; // this would revert due to underflow if withdrawing > termSurplusBuffer\n        termSurplusBuffer[term] = newSurplusBuffer;\n        CreditToken(credit).transfer(to, amount);\n        emit TermSurplusBufferUpdate(block.timestamp, term, newSurplusBuffer);\n    }\n\n    /// @notice notify profit and loss in a given gauge\n    /// if `amount` is > 0, the same number of CREDIT tokens are expected to be transferred to this contract\n    /// before `notifyPnL` is called.\n    function notifyPnL(\n        address gauge,\n        int256 amount\n    ) external onlyCoreRole(CoreRoles.GAUGE_PNL_NOTIFIER) {\n        uint256 _surplusBuffer = surplusBuffer;\n        uint256 _termSurplusBuffer = termSurplusBuffer[gauge];\n        address _credit = credit;\n\n        // handling loss\n        if (amount < 0) {\n            uint256 loss = uint256(-amount);\n\n            // save gauge loss\n            GuildToken(guild).notifyGaugeLoss(gauge);\n\n            // deplete the term surplus buffer, if any, and\n            // donate its content to the general surplus buffer\n            if (_termSurplusBuffer != 0) {\n                termSurplusBuffer[gauge] = 0;\n                emit TermSurplusBufferUpdate(block.timestamp, gauge, 0);\n                _surplusBuffer += _termSurplusBuffer;\n            }\n\n            if (loss < _surplusBuffer) {\n                // deplete the surplus buffer\n                surplusBuffer = _surplusBuffer - loss;\n                emit SurplusBufferUpdate(\n                    block.timestamp,\n                    _surplusBuffer - loss\n                );\n                CreditToken(_credit).burn(loss);\n            } else {\n                // empty the surplus buffer\n                loss -= _surplusBuffer;\n                surplusBuffer = 0;\n                CreditToken(_credit).burn(_surplusBuffer);\n                emit SurplusBufferUpdate(block.timestamp, 0);\n\n                // update the CREDIT multiplier\n                uint256 creditTotalSupply = CreditToken(_credit).totalSupply();\n                uint256 newCreditMultiplier = (creditMultiplier *\n                    (creditTotalSupply - loss)) / creditTotalSupply;\n                creditMultiplier = newCreditMultiplier;\n                emit CreditMultiplierUpdate(\n                    block.timestamp,\n                    newCreditMultiplier\n                );\n            }\n        }\n        // handling profit\n        else if (amount > 0) {\n            ProfitSharingConfig\n                memory _profitSharingConfig = profitSharingConfig;\n\n            uint256 amountForSurplusBuffer = (uint256(amount) *\n                uint256(_profitSharingConfig.surplusBufferSplit)) / 1e9;\n\n            uint256 amountForGuild = (uint256(amount) *\n                uint256(_profitSharingConfig.guildSplit)) / 1e9;\n\n            uint256 amountForOther = (uint256(amount) *\n                uint256(_profitSharingConfig.otherSplit)) / 1e9;\n\n            uint256 amountForCredit = uint256(amount) -\n                amountForSurplusBuffer -\n                amountForGuild -\n                amountForOther;\n\n            // distribute to surplus buffer\n            if (amountForSurplusBuffer != 0) {\n                surplusBuffer = _surplusBuffer + amountForSurplusBuffer;\n                emit SurplusBufferUpdate(\n                    block.timestamp,\n                    _surplusBuffer + amountForSurplusBuffer\n                );\n            }\n\n            // distribute to other\n            if (amountForOther != 0) {\n                CreditToken(_credit).transfer(\n                    _profitSharingConfig.otherRecipient,\n                    amountForOther\n                );\n            }\n\n            // distribute to lenders\n            if (amountForCredit != 0) {\n                CreditToken(_credit).distribute(amountForCredit);\n            }\n\n            // distribute to the guild\n            if (amountForGuild != 0) {\n                // update the gauge profit index\n                // if the gauge has 0 weight, does not update the profit index, this is unnecessary\n                // because the profit index is used to reattribute profit to users voting for the gauge,\n                // and if the weigth is 0, there are no users voting for the gauge.\n                uint256 _gaugeWeight = uint256(\n                    GuildToken(guild).getGaugeWeight(gauge)\n                );\n                if (_gaugeWeight != 0) {\n                    uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge];\n                    if (_gaugeProfitIndex == 0) {\n                        _gaugeProfitIndex = 1e18;\n                    }\n                    gaugeProfitIndex[gauge] =\n                        _gaugeProfitIndex +\n                        (amountForGuild * 1e18) /\n                        _gaugeWeight;\n                }\n            }\n        }\n\n        emit GaugePnL(gauge, block.timestamp, amount);\n    }\n\n    /// @notice claim a user's rewards for a given gauge.\n    /// @dev This should be called every time the user's weight changes in the gauge.\n    function claimGaugeRewards(\n        address user,\n        address gauge\n    ) public returns (uint256 creditEarned) {\n        uint256 _userGaugeWeight = uint256(\n            GuildToken(guild).getUserGaugeWeight(user, gauge)\n        );\n        if (_userGaugeWeight == 0) {\n            return 0;\n        }\n        uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge];\n        uint256 _userGaugeProfitIndex = userGaugeProfitIndex[user][gauge];\n        if (_gaugeProfitIndex == 0) {\n            _gaugeProfitIndex = 1e18;\n        }\n        if (_userGaugeProfitIndex == 0) {\n            _userGaugeProfitIndex = 1e18;\n        }\n        uint256 deltaIndex = _gaugeProfitIndex - _userGaugeProfitIndex;\n        if (deltaIndex != 0) {\n            creditEarned = (_userGaugeWeight * deltaIndex) / 1e18;\n            userGaugeProfitIndex[user][gauge] = _gaugeProfitIndex;\n        }\n        if (creditEarned != 0) {\n            emit ClaimRewards(block.timestamp, user, gauge, creditEarned);\n            CreditToken(credit).transfer(user, creditEarned);\n        }\n    }\n\n    /// @notice claim a user's rewards across all their active gauges.\n    function claimRewards(\n        address user\n    ) external returns (uint256 creditEarned) {\n        address[] memory gauges = GuildToken(guild).userGauges(user);\n        for (uint256 i = 0; i < gauges.length; ) {\n            creditEarned += claimGaugeRewards(user, gauges[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice read & return pending undistributed rewards for a given user\n    function getPendingRewards(\n        address user\n    )\n        external\n        view\n        returns (\n            address[] memory gauges,\n            uint256[] memory creditEarned,\n            uint256 totalCreditEarned\n        )\n    {\n        address _guild = guild;\n        gauges = GuildToken(_guild).userGauges(user);\n        creditEarned = new uint256[](gauges.length);\n\n        for (uint256 i = 0; i < gauges.length; ) {\n            address gauge = gauges[i];\n            uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge];\n            uint256 _userGaugeProfitIndex = userGaugeProfitIndex[user][gauge];\n\n            if (_gaugeProfitIndex == 0) {\n                _gaugeProfitIndex = 1e18;\n            }\n            if (_userGaugeProfitIndex == 0) {\n                _userGaugeProfitIndex = 1e18;\n            }\n            uint256 deltaIndex = _gaugeProfitIndex - _userGaugeProfitIndex;\n            if (deltaIndex != 0) {\n                uint256 _userGaugeWeight = uint256(\n                    GuildToken(_guild).getUserGaugeWeight(user, gauge)\n                );\n                creditEarned[i] = (_userGaugeWeight * deltaIndex) / 1e18;\n                totalCreditEarned += creditEarned[i];\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/loa",
      "content": ""
    }
  ]
}