{
  "Title": "M-3: Starting timestamp can be bypassed by calling `settle`",
  "Content": "# Issue M-3: Starting timestamp can be bypassed by calling `settle` \n\nSource: https://github.com/sherlock-audit/2023-02-fair-funding-judging/issues/39 \n\n## Found by \nck, Bahurum, carrot, 0xhacksmithh, 0xlmanini, HonorLt, 7siech, ABA, rvierdiiev, XKET, seyni\n\n## Summary\nThe starting timestamp set or still unset by the owner through the `start_auction` function can be bypassed by calling `settle`, which sends the first token to the fallback and then starts the auction for subsequent tokenIds.\n## Vulnerability Detail\nThe function `start_auction` is meant to be used to start the auction process, after which the bids start getting accepted. However, this entire system can be bypassed by calling the `settle` function. This leads to the first tokenId being minted to the fallback address, and the next tokenId auction being started immediately.\n\nThis can be exploited in two scenarios,\n1. The function `start_auction` hasn't been called yet\n2. The function `start_auction` has been called, and the timestamp passed is a timestamp in the future\n\nIn both these cases, the auctions can be made to start immediately. Thus the two issues are clubbed together.\n\nThe function `settle` only checks for the timestamp using the statement\nhttps://github.com/sherlock-audit/2023-02-fair-funding/blob/main/fair-funding/contracts/AuctionHouse.vy#L185\nwhich is defined as\nhttps://github.com/sherlock-audit/2023-02-fair-funding/blob/main/fair-funding/contracts/AuctionHouse.vy#L247-L252\nThis check passes if the current timestamp is after the end of the epoch, but also if the current timestamp is before the start of the auction, which is the main issue here.\n\nInside the `settle` function, it sets the start and end timestamps properly, which allows bids to be made for subsequent tokenIds.\nhttps://github.com/sherlock-audit/2023-02-fair-funding/blob/main/fair-funding/contracts/AuctionHouse.vy#L200-L206\n\nSo even if the starting timestamp is unset or set in the future, the checks in `settle` pass, and the function then proceeds to write the start and end timestamps to process bids correctly. \n## Impact\nBids can be started immediately. This goes against the design of the protocol.\n## Code Snippet\nThe issue can be recreated with the following POC\n```python\ndef test_ATTACK_settle_before_start(owner, house, nft):\n    token_id = house.current_epoch_token_id()\n    assert house.highest_bidder() == pytest.ZERO_ADDRESS\n    house.settle()\n    house.bid(house.current_epoch_token_id(), house.RESERVE_PRICE())\n    assert house.current_epoch_token_id() == token_id + 1\n    assert nft.ownerOf(token_id) == owner\n```\nThis shows a case where `start_action` is never called, yet the bids start. The same can be done if `start_auction` is called with a timestamp in the future\n## Tool used\nBoa\nManual Review\n\n## Recommendation\nChange the check in `settle` to check for the end timestamp ONLY\n```vyper\nassert block.timestamp > self.epoch_end\n```\n\n## Discussion\n\n**hrishibhat**\n\nWhile the issue is valid, there are no funds at risk with starting the auction early. \nConsidering this issue a valid medium. \n\n**Unstoppable-DeFi**\n\nhttps://github.com/Unstoppable-DeFi/fair-funding/pull/7\n\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/42",
  "Code": [
    {
      "filename": "fair-funding/contracts/AuctionHouse.vy",
      "content": "# @version 0.3.7\n\n\"\"\"\n@title Fair Funding Auction House\n@license GNU AGPLv3\n@author unstoppable.ooo\n\n@custom:security-contact team@unstoppable.com\n\n@notice\n    Once started the Auction House auctions off one NFT per epoch / 1 day up to\n    max_token_id NFTs.\n    When the auction gets settled after epoch_end, the NFT is minted to the \n    highest bidder and the auction proceeds are being transferred to the vault.\n\n    Bidding happens in WETH, any new bid refunds the previous bidder.\n\n    A bid close to epoch_end extends the auction by 15min since last bid to \n    prevent sniping.\n\n    If an epoch ends with no bids, the NFT is minted to the FALLBACK_RECEIVER \n    address.\n\n    The owner can change the max_token_id / max number of NFTs minted.\n\n    The owner can transfer ownership to a new address in a 2 step process\n    (suggest, accept).\n\n\"\"\"\n\nfrom vyper.interfaces import ERC20\n\ninterface MintableNFT:\n    def mint(_to: address, _token_id: uint256): nonpayable\n\ninterface Vault:\n    def register_deposit(_amount: uint256, _token_id: uint256): nonpayable\n\n\nNFT: public(immutable(address))\nWETH: public(immutable(address))\n\nvault: public(address)\n\nFALLBACK_RECEIVER: public(immutable(address))\n\nEPOCH_LENGTH: public(constant(uint256)) = 60 * 60 * 24  # 1 day in seconds\nTIME_BUFFER: public(constant(uint256)) = 15 * 60  # 15 min in seconds\n\nMIN_INCREMENT_PCT: public(constant(uint256)) = 2  # 2%\nRESERVE_PRICE: public(immutable(uint256))\n\ncurrent_epoch_token_id: public(uint256)\nmax_token_id: public(uint256)\n\nhighest_bid: public(uint256)\nhighest_bidder: public(address)\n\nepoch_start: public(uint256)\nepoch_end: public(uint256)\n\nowner: public(address)\nsuggested_owner: public(address)\n\n\nevent Bid:\n    token_id: uint256\n    bidder: indexed(address)\n    amount: uint256\n\nevent AuctionSettled:\n    token_id: uint256\n    winner: indexed(address)\n    amount: uint256\n\nevent AuctionSettledWithNoBid:\n    token_id: uint256\n    fallback_receiver: indexed(address)\n\nevent AuctionStart:\n    time: uint256\n    account: indexed(address)\n\nevent AuctionExtended:\n    token_id: uint256\n    new_end_time: uint256\n\nevent BidRefunded:\n    token_id: uint256\n    receiver: indexed(address)\n    amount: uint256\n\nevent NewOwnerSuggested:\n    current_owner: indexed(address)\n    suggested_owner: indexed(address)\n\nevent OwnershipTransferred:\n    old_owner: indexed(address)\n    new_owner: indexed(address)\n\n\n@external\ndef __init__(\n    _weth_address: address,\n    _nft_address: address,\n    _start_token_id: uint256,\n    _max_token_id: uint256,\n    _reserve_price: uint256,\n    _fallback_receiver: address,\n    _vault_address: address\n):\n    assert _weth_address != empty(address), \"invalid weth address\"\n    assert _nft_address != empty(address), \"invalid nft address\"\n    assert _start_token_id < _max_token_id, \"invalid token ids\"\n    assert _reserve_price > 0, \"reserve price cannot be zero\"\n    assert _fallback_receiver != empty(address), \"invalid fallback receiver address\"\n    assert _vault_address != empty(address), \"invalid vault address\"\n\n    WETH = _weth_address\n    NFT = _nft_address\n    self.vault = _vault_address\n    RESERVE_PRICE = _reserve_price\n    FALLBACK_RECEIVER = _fallback_receiver\n\n    self.owner = msg.sender\n\n    self.current_epoch_token_id = _start_token_id\n    self.max_token_id = _max_token_id\n\n\n@external\n@nonreentrant(\"lock\")\ndef bid(_token_id: uint256, _amount: uint256):\n    \"\"\"\n    @notice\n        Create a new bid for _token_id with _amount.\n        Requires msg.sender to have approved _amount of WETH to be transferred\n        by this contract.\n        If the bid is valid, the previous bidder is refunded.\n        If the bid is close to epoch_end, the auction is extended to prevent \n        sniping.\n    @param _token_id\n        The token id a user wants to bid on.\n    @param _amount\n        The amount of WETH a user wants to bid.\n    \"\"\"\n    assert self._epoch_in_progress(), \"auction not in progress\"\n\n    assert _amount >= RESERVE_PRICE, \"reserve price not met\"\n    assert _token_id == self.current_epoch_token_id, \"token id not up for auction\"\n    assert _amount > self.highest_bid * (100 + MIN_INCREMENT_PCT) / 100 , \"bid not high enough\" \n\n    last_bidder: address = self.highest_bidder\n    last_bid: uint256 = self.highest_bid\n\n    self.highest_bid = _amount\n    self.highest_bidder = msg.sender\n\n    # extend epoch_end to avoid sniping if necessary\n    if block.timestamp > self.epoch_end - TIME_BUFFER:\n        self.epoch_end = block.timestamp + TIME_BUFFER\n        log AuctionExtended(_token_id, self.epoch_end)\n\n    # refund last bidder\n    if last_bidder != empty(address) and last_bid > 0:\n        ERC20(WETH).transfer(last_bidder, last_bid)\n        log BidRefunded(_token_id, last_bidder, last_bid)\n\n    # collect bid from current bidder\n    ERC20(WETH).transferFrom(msg.sender, self, _amount)\n    log Bid(_token_id, self.highest_bidder, self.highest_bid)\n\n\n@external\ndef settle():\n    \"\"\"\n    @notice\n        Settles the latest epoch / auction.\n        Reverts if the auction is still running.\n        Mints the NFT to the highest bidder. \n        If there are no bids, mints the NFT to the FALLBACK_RECEIVER\n        address.\n        Resets everything and starts the next epoch / auction.\n    \"\"\"\n    assert self._epoch_in_progress() == False, \"epoch not over\"\n\n    winner: address = self.highest_bidder\n    token_id: uint256 = self.current_epoch_token_id\n    winning_amount: uint256 = self.highest_bid\n\n    if winner == empty(address):\n        winner = FALLBACK_RECEIVER\n        log AuctionSettledWithNoBid(token_id, FALLBACK_RECEIVER)\n\n    # reset for next round\n    self.highest_bid = 0\n    self.highest_bidder = empty(address)\n\n    # set up next round if there is one\n    if self.current_epoch_token_id < self.max_token_id:\n        self.current_epoch_token_id += 1\n        self.epoch_start = block.timestamp\n        self.epoch_end = self.epoch_start + EPOCH_LENGTH\n    else:\n        self.epoch_start = 0\n        self.epoch_end = 0\n\n    MintableNFT(NFT).mint(winner, token_id)\n\n    if winning_amount > 0:\n        ERC20(WETH).approve(self.vault, winning_amount)\n        Vault(self.vault).register_deposit(token_id, winning_amount)\n        log AuctionSettled(token_id, winner, winning_amount)\n\n\n@external\ndef start_auction(_start_time: uint256):\n    \"\"\"\n    @notice\n        Sets the timestamp when the first auction starts.\n        Can be changed while the auction has not started yet.\n        Can only be called by current owner.\n    @param _start_time\n        The timestamp when the first epoch starts.\n        If 0 is passed, it will start the auction now.\n    \"\"\"\n    assert msg.sender == self.owner, \"unauthorized\"\n    # epoch_start has already been set and is in the past\n    if self.epoch_start != 0 and self.epoch_start <= block.timestamp: \n        raise \"auction already started\"\n\n    start: uint256 = _start_time\n    if start == 0:\n        start = block.timestamp\n\n    assert start >= block.timestamp, \"cannot start in the past\"\n\n    self.epoch_start = start\n    self.epoch_end = self.epoch_start + EPOCH_LENGTH\n\n    log AuctionStart(self.epoch_start, msg.sender)\n    log Bid(0, msg.sender, 123)\n\n\n@internal\n@view\ndef _epoch_in_progress() -> bool:\n    \"\"\"\n    @notice\n        Checks if we are currently between epoch_start and epoch_end.\n    \"\"\"\n    return block.timestamp >= self.epoch_start and block.timestamp <= self.epoch_end\n\n\n@external\ndef suggest_owner(_new_owner: address):\n    \"\"\"\n    @notice\n        Step 1 of the 2 step process to transfer ownership.\n        Current owner suggests a new owner.\n        Requires the new owner to accept ownership in step 2.\n    @param _new_owner\n        The address of the new owner.\n    \"\"\"\n    assert msg.sender == self.owner, \"unauthorized\"\n    self.suggested_owner = _new_owner\n    log NewOwnerSuggested(self.owner, self.suggested_owner)\n\n\n@external\ndef accept_ownership():\n    \"\"\"\n    @notice\n        Step 2 of the 2 step process to transfer ownership.\n        The suggested owner accepts the transfer and becomes the\n        new owner.\n    \"\"\"\n    assert msg.sender == self.suggested_owner, \"unauthorized\"\n    prev_owner: address = self.owner\n    self.owner = self.suggested_owner\n    log OwnershipTransferred(prev_owner, self.owner)\n\n\n@external\ndef set_max_token_id(_new_max_token_id: uint256):\n    \"\"\"\n    @notice\n        Changes the max_token_id and the amount of NFTs to be auctioned.\n        Can only be called by owner.\n    @param _new_max_token_id\n        The last token id to be minted.\n    \"\"\"\n    assert msg.sender == self.owner, \"unauthorized\"\n    assert _new_max_token_id >= self.current_epoch_token_id, \"cannot set max < current\"\n\n    self.max_token_id = _new_max_token_id\n\n\n@external\ndef set_vault(_new_vault_address: address):\n    \"\"\"\n    @notice\n        Changes the vault address.\n        Can only be called by owner.\n    @param _new_vault_address\n        The last token id to be minted.\n    \"\"\"\n    assert msg.sender == self.owner, \"unauthorized\"\n    assert _new_vault_address != empty(address), \"vault cannot be zero address\"\n\n    self.vault = _new_vault_address\n\n\n@external\ndef refund_highest_bidder():\n    assert msg.sender == self.owner, \"unauthorized\"\n    assert self._epoch_in_progress() == False, \"epoch not over\"\n\n    refund_amount: uint256 = self.highest_bid\n    refund_receiver: address = self.highest_bidder\n\n    self.highest_bid = 0\n    self.highest_bidder = empty(address)\n\n    ERC20(WETH).transfer(refund_receiver, refund_amount)"
    },
    {
      "filename": "fair-funding/contracts/AuctionHouse.vy",
      "content": "# @version 0.3.7\n\n\"\"\"\n@title Fair Funding Auction House\n@license GNU AGPLv3\n@author unstoppable.ooo\n\n@custom:security-contact team@unstoppable.com\n\n@notice\n    Once started the Auction House auctions off one NFT per epoch / 1 day up to\n    max_token_id NFTs.\n    When the auction gets settled after epoch_end, the NFT is minted to the \n    highest bidder and the auction proceeds are being transferred to the vault.\n\n    Bidding happens in WETH, any new bid refunds the previous bidder.\n\n    A bid close to epoch_end extends the auction by 15min since last bid to \n    prevent sniping.\n\n    If an epoch ends with no bids, the NFT is minted to the FALLBACK_RECEIVER \n    address.\n\n    The owner can change the max_token_id / max number of NFTs minted.\n\n    The owner can transfer ownership to a new address in a 2 step process\n    (suggest, accept).\n\n\"\"\"\n\nfrom vyper.interfaces import ERC20\n\ninterface MintableNFT:\n    def mint(_to: address, _token_id: uint256): nonpayable\n\ninterface Vault:\n    def register_deposit(_amount: uint256, _token_id: uint256): nonpayable\n\n\nNFT: public(immutable(address))\nWETH: public(immutable(address))\n\nvault: public(address)\n\nFALLBACK_RECEIVER: public(immutable(address))\n\nEPOCH_LENGTH: public(constant(uint256)) = 60 * 60 * 24  # 1 day in seconds\nTIME_BUFFER: public(constant(uint256)) = 15 * 60  # 15 min in seconds\n\nMIN_INCREMENT_PCT: public(constant(uint256)) = 2  # 2%\nRESERVE_PRICE: public(immutable(uint256))\n\ncurrent_epoch_token_id: public(uint256)\nmax_token_id: public(uint256)\n\nhighest_bid: public(uint256)\nhighest_bidder: public(address)\n\nepoch_start: public(uint256)\nepoch_end: public(uint256)\n\nowner: public(address)\nsuggested_owner: public(address)\n\n\nevent Bid:\n    token_id: uint256\n    bidder: indexed(address)\n    amount: uint256\n\nevent AuctionSettled:\n    token_id: uint256\n    winner: indexed(address)\n    amount: uint256\n\nevent AuctionSettledWithNoBid:\n    token_id: uint256\n    fallback_receiver: indexed(address)\n\nevent AuctionStart:\n    time: uint256\n    account: indexed(address)\n\nevent AuctionExtended:\n    token_id: uint256\n    new_end_time: uint256\n\nevent BidRefunded:\n    token_id: uint256\n    receiver: indexed(address)\n    amount: uint256\n\nevent NewOwnerSuggested:\n    current_owner: indexed(address)\n    suggested_owner: indexed(address)\n\nevent OwnershipTransferred:\n    old_owner: indexed(address)\n    new_owner: indexed(address)\n\n\n@external\ndef __init__(\n    _weth_address: address,\n    _nft_address: address,\n    _start_token_id: uint256,\n    _max_token_id: uint256,\n    _reserve_price: uint256,\n    _fallback_receiver: address,\n    _vault_address: address\n):\n    assert _weth_address != empty(address), \"invalid weth address\"\n    assert _nft_address != empty(address), \"invalid nft address\"\n    assert _start_token_id < _max_token_id, \"invalid token ids\"\n    assert _reserve_price > 0, \"reserve price cannot be zero\"\n    assert _fallback_receiver != empty(address), \"invalid fallback receiver address\"\n    assert _vault_address != empty(address), \"invalid vault address\"\n\n    WETH = _weth_address\n    NFT = _nft_address\n    self.vault = _vault_address\n    RESERVE_PRICE = _reserve_price\n    FALLBACK_RECEIVER = _fallback_receiver\n\n    self.owner = msg.sender\n\n    self.current_epoch_token_id = _start_token_id\n    self.max_token_id = _max_token_id\n\n\n@external\n@nonreentrant(\"lock\")\ndef bid(_token_id: uint256, _amount: uint256):\n    \"\"\"\n    @notice\n        Create a new bid for _token_id with _amount.\n        Requires msg.sender to have approved _amount of WETH to be transferred\n        by this contract.\n        If the bid is valid, the previous bidder is refunded.\n        If the bid is close to epoch_end, the auction is extended to prevent \n        sniping.\n    @param _token_id\n        The token id a user wants to bid on.\n    @param _amount\n        The amount of WETH a user wants to bid.\n    \"\"\"\n    assert self._epoch_in_progress(), \"auction not in progress\"\n\n    assert _amount >= RESERVE_PRICE, \"reserve price not met\"\n    assert _token_id == self.current_epoch_token_id, \"token id not up for auction\"\n    assert _amount > self.highest_bid * (100 + MIN_INCREMENT_PCT) / 100 , \"bid not high enough\" \n\n    last_bidder: address = self.highest_bidder\n    last_bid: uint256 = self.highest_bid\n\n    self.highest_bid = _amount\n    self.highest_bidder = msg.sender\n\n    # extend epoch_end to avoid sniping if necessary\n    if block.timestamp > self.epoch_end - TIME_BUFFER:\n        self.epoch_end = block.timestamp + TIME_BUFFER\n        log AuctionExtended(_token_id, self.epoch_end)\n\n    # refund last bidder\n    if last_bidder != empty(address) and last_bid > 0:\n        ERC20(WETH).transfer(last_bidder, last_bid)\n        log BidRefunded(_token_id, last_bidder, last_bid)\n\n    # collect bid from current bidder\n    ERC20(WETH).transferFrom(msg.sender, self, _amount)\n    log Bid(_token_id, self.highest_bidder, self.highest_bid)\n\n\n@external\ndef settle():\n    \"\"\"\n    @notice\n        Settles the latest epoch / auction.\n        Reverts if the auction is still running.\n        Mints the NFT to the highest bidder. \n        If there are no bids, mints the NFT to the FALLBACK_RECEIVER\n        address.\n        Resets everything and starts the next epoch / auction.\n    \"\"\"\n    assert self._epoch_in_progress() == False, \"epoch not over\"\n\n    winner: address = self.highest_bidder\n    token_id: uint256 = self.current_epoch_token_id\n    winning_amount: uint256 = self.highest_bid\n\n    if winner == empty(address):\n        winner = FALLBACK_RECEIVER\n        log AuctionSettledWithNoBid(token_id, FALLBACK_RECEIVER)\n\n    # reset for next round\n    self.highest_bid = 0\n    self.highest_bidder = empty(address)\n\n    # set up next round if there is one\n    if self.current_epoch_token_id < self.max_token_id:\n        self.current_epoch_token_id += 1\n        self.epoch_start = block.timestamp\n        self.epoch_end = self.epoch_start + EPOCH_LENGTH\n    else:\n        self.epoch_start = 0\n        self.epoch_end = 0\n\n    MintableNFT(NFT).mint(winner, token_id)\n\n    if winning_amount > 0:\n        ERC20(WETH).approve(self.vault, winning_amount)\n        Vault(self.vault).register_deposit(token_id, winning_amount)\n        log AuctionSettled(token_id, winner, winning_amount)\n\n\n@external\ndef start_auction(_start_time: uint256):\n    \"\"\"\n    @notice\n        Sets the timestamp when the first auction starts.\n        Can be changed while the auction has not started yet.\n        Can only be called by current owner.\n    @param _start_time\n        The timestamp when the first epoch starts.\n        If 0 is passed, it will start the auction now.\n    \"\"\"\n    assert msg.sender == self.owner, \"unauthorized\"\n    # epoch_start has already been set and is in the past\n    if self.epoch_start != 0 and self.epoch_start <= block.timestamp: \n        raise \"auction already started\"\n\n    start: uint256 = _start_time\n    if start == 0:\n        start = block.timestamp\n\n    assert start >= block.timestamp, \"cannot start in the past\"\n\n    self.epoch_start = start\n    self.epoch_end = self.epoch_start + EPOCH_LENGTH\n\n    log AuctionStart(self.epoch_start, msg.sender)\n    log Bid(0, msg.sender, 123)\n\n\n@internal\n@view\ndef _epoch_in_progress() -> bool:\n    \"\"\"\n    @notice\n        Checks if we are currently between epoch_start and epoch_end.\n    \"\"\"\n    return block.timestamp >= self.epoch_start and block.timestamp <= self.epoch_end\n\n\n@external\ndef suggest_owner(_new_owner: address):\n    \"\"\"\n    @notice\n        Step 1 of the 2 step process to transfer ownership.\n        Current owner suggests a new owner.\n        Requires the new owner to accept ownership in step 2.\n    @param _new_owner\n        The address of the new owner.\n    \"\"\"\n    assert msg.sender == self.owner, \"unauthorized\"\n    self.suggested_owner = _new_owner\n    log NewOwnerSuggested(self.owner, self.suggested_owner)\n\n\n@external\ndef accept_ownership():\n    \"\"\"\n    @notice\n        Step 2 of the 2 step process to transfer ownership.\n        The suggested owner accepts the transfer and becomes the\n        new owner.\n    \"\"\"\n    assert msg.sender == self.suggested_owner, \"unauthorized\"\n    prev_owner: address = self.owner\n    self.owner = self.suggested_owner\n    log OwnershipTransferred(prev_owner, self.owner)\n\n\n@external\ndef set_max_token_id(_new_max_token_id: uint256):\n    \"\"\"\n    @notice\n        Changes the max_token_id and the amount of NFTs to be auctioned.\n        Can only be called by owner.\n    @param _new_max_token_id\n        The last token id to be minted.\n    \"\"\"\n    assert msg.sender == self.owner, \"unauthorized\"\n    assert _new_max_token_id >= self.current_epoch_token_id, \"cannot set max < current\"\n\n    self.max_token_id = _new_max_token_id\n\n\n@external\ndef set_vault(_new_vault_address: address):\n    \"\"\"\n    @notice\n        Changes the vault address.\n        Can only be called by owner.\n    @param _new_vault_address\n        The last token id to be minted.\n    \"\"\"\n    assert msg.sender == self.owner, \"unauthorized\"\n    assert _new_vault_address != empty(address), \"vault cannot be zero address\"\n\n    self.vault = _new_vault_address\n\n\n@external\ndef refund_highest_bidder():\n    assert msg.sender == self.owner, \"unauthorized\"\n    assert self._epoch_in_progress() == False, \"epoch not over\"\n\n    refund_amount: uint256 = self.highest_bid\n    refund_receiver: address = self.highest_bidder\n\n    self.highest_bid = 0\n    self.highest_bidder = empty(address)\n\n    ERC20(WETH).transfer(refund_receiver, refund_amount)"
    },
    {
      "filename": "fair-funding/contracts/AuctionHouse.vy",
      "content": "# @version 0.3.7\n\n\"\"\"\n@title Fair Funding Auction House\n@license GNU AGPLv3\n@author unstoppable.ooo\n\n@custom:security-contact team@unstoppable.com\n\n@notice\n    Once started the Auction House auctions off one NFT per epoch / 1 day up to\n    max_token_id NFTs.\n    When the auction gets settled after epoch_end, the NFT is minted to the \n    highest bidder and the auction proceeds are being transferred to the vault.\n\n    Bidding happens in WETH, any new bid refunds the previous bidder.\n\n    A bid close to epoch_end extends the auction by 15min since last bid to \n    prevent sniping.\n\n    If an epoch ends with no bids, the NFT is minted to the FALLBACK_RECEIVER \n    address.\n\n    The owner can change the max_token_id / max number of NFTs minted.\n\n    The owner can transfer ownership to a new address in a 2 step process\n    (suggest, accept).\n\n\"\"\"\n\nfrom vyper.interfaces import ERC20\n\ninterface MintableNFT:\n    def mint(_to: address, _token_id: uint256): nonpayable\n\ninterface Vault:\n    def register_deposit(_amount: uint256, _token_id: uint256): nonpayable\n\n\nNFT: public(immutable(address))\nWETH: public(immutable(address))\n\nvault: public(address)\n\nFALLBACK_RECEIVER: public(immutable(address))\n\nEPOCH_LENGTH: public(constant(uint256)) = 60 * 60 * 24  # 1 day in seconds\nTIME_BUFFER: public(constant(uint256)) = 15 * 60  # 15 min in seconds\n\nMIN_INCREMENT_PCT: public(constant(uint256)) = 2  # 2%\nRESERVE_PRICE: public(immutable(uint256))\n\ncurrent_epoch_token_id: public(uint256)\nmax_token_id: public(uint256)\n\nhighest_bid: public(uint256)\nhighest_bidder: public(address)\n\nepoch_start: public(uint256)\nepoch_end: public(uint256)\n\nowner: public(address)\nsuggested_owner: public(address)\n\n\nevent Bid:\n    token_id: uint256\n    bidder: indexed(address)\n    amount: uint256\n\nevent AuctionSettled:\n    token_id: uint256\n    winner: indexed(address)\n    amount: uint256\n\nevent AuctionSettledWithNoBid:\n    token_id: uint256\n    fallback_receiver: indexed(address)\n\nevent AuctionStart:\n    time: uint256\n    account: indexed(address)\n\nevent AuctionExtended:\n    token_id: uint256\n    new_end_time: uint256\n\nevent BidRefunded:\n    token_id: uint256\n    receiver: indexed(address)\n    amount: uint256\n\nevent NewOwnerSuggested:\n    current_owner: indexed(address)\n    suggested_owner: indexed(address)\n\nevent OwnershipTransferred:\n    old_owner: indexed(address)\n    new_owner: indexed(address)\n\n\n@external\ndef __init__(\n    _weth_address: address,\n    _nft_address: address,\n    _start_token_id: uint256,\n    _max_token_id: uint256,\n    _reserve_price: uint256,\n    _fallback_receiver: address,\n    _vault_address: address\n):\n    assert _weth_address != empty(address), \"invalid weth address\"\n    assert _nft_address != empty(address), \"invalid nft address\"\n    assert _start_token_id < _max_token_id, \"invalid token ids\"\n    assert _reserve_price > 0, \"reserve price cannot be zero\"\n    assert _fallback_receiver != empty(address), \"invalid fallback receiver address\"\n    assert _vault_address != empty(address), \"invalid vault address\"\n\n    WETH = _weth_address\n    NFT = _nft_address\n    self.vault = _vault_address\n    RESERVE_PRICE = _reserve_price\n    FALLBACK_RECEIVER = _fallback_receiver\n\n    self.owner = msg.sender\n\n    self.current_epoch_token_id = _start_token_id\n    self.max_token_id = _max_token_id\n\n\n@external\n@nonreentrant(\"lock\")\ndef bid(_token_id: uint256, _amount: uint256):\n    \"\"\"\n    @notice\n        Create a new bid for _token_id with _amount.\n        Requires msg.sender to have approved _amount of WETH to be transferred\n        by this contract.\n        If the bid is valid, the previous bidder is refunded.\n        If the bid is close to epoch_end, the auction is extended to prevent \n        sniping.\n    @param _token_id\n        The token id a user wants to bid on.\n    @param _amount\n        The amount of WETH a user wants to bid.\n    \"\"\"\n    assert self._epoch_in_progress(), \"auction not in progress\"\n\n    assert _amount >= RESERVE_PRICE, \"reserve price not met\"\n    assert _token_id == self.current_epoch_token_id, \"token id not up for auction\"\n    assert _amount > self.highest_bid * (100 + MIN_INCREMENT_PCT) / 100 , \"bid not high enough\" \n\n    last_bidder: address = self.highest_bidder\n    last_bid: uint256 = self.highest_bid\n\n    self.highest_bid = _amount\n    self.highest_bidder = msg.sender\n\n    # extend epoch_end to avoid sniping if necessary\n    if block.timestamp > self.epoch_end - TIME_BUFFER:\n        self.epoch_end = block.timestamp + TIME_BUFFER\n        log AuctionExtended(_token_id, self.epoch_end)\n\n    # refund last bidder\n    if last_bidder != empty(address) and last_bid > 0:\n        ERC20(WETH).transfer(last_bidder, last_bid)\n        log BidRefunded(_token_id, last_bidder, last_bid)\n\n    # collect bid from current bidder\n    ERC20(WETH).transferFrom(msg.sender, self, _amount)\n    log Bid(_token_id, self.highest_bidder, self.highest_bid)\n\n\n@external\ndef settle():\n    \"\"\"\n    @notice\n        Settles the latest epoch / auction.\n        Reverts if the auction is still running.\n        Mints the NFT to the highest bidder. \n        If there are no bids, mints the NFT to the FALLBACK_RECEIVER\n        address.\n        Resets everything and starts the next epoch / auction.\n    \"\"\"\n    assert self._epoch_in_progress() == False, \"epoch not over\"\n\n    winner: address = self.highest_bidder\n    token_id: uint256 = self.current_epoch_token_id\n    winning_amount: uint256 = self.highest_bid\n\n    if winner == empty(address):\n        winner = FALLBACK_RECEIVER\n        log AuctionSettledWithNoBid(token_id, FALLBACK_RECEIVER)\n\n    # reset for next round\n    self.highest_bid = 0\n    self.highest_bidder = empty(address)\n\n    # set up next round if there is one\n    if self.current_epoch_token_id < self.max_token_id:\n        self.current_epoch_token_id += 1\n        self.epoch_start = block.timestamp\n        self.epoch_end = self.epoch_start + EPOCH_LENGTH\n    else:\n        self.epoch_start = 0\n        self.epoch_end = 0\n\n    MintableNFT(NFT).mint(winner, token_id)\n\n    if winning_amount > 0:\n        ERC20(WETH).approve(self.vault, winning_amount)\n        Vault(self.vault).register_deposit(token_id, winning_amount)\n        log AuctionSettled(token_id, winner, winning_amount)\n\n\n@external\ndef start_auction(_start_time: uint256):\n    \"\"\"\n    @notice\n        Sets the timestamp when the first auction starts.\n        Can be changed while the auction has not started yet.\n        Can only be called by current owner.\n    @param _start_time\n        The timestamp when the first epoch starts.\n        If 0 is passed, it will start the auction now.\n    \"\"\"\n    assert msg.sender == self.owner, \"unauthorized\"\n    # epoch_start has already been set and is in the past\n    if self.epoch_start != 0 and self.epoch_start <= block.timestamp: \n        raise \"auction already started\"\n\n    start: uint256 = _start_time\n    if start == 0:\n        start = block.timestamp\n\n    assert start >= block.timestamp, \"cannot start in the past\"\n\n    self.epoch_start = start\n    self.epoch_end = self.epoch_start + EPOCH_LENGTH\n\n    log AuctionStart(self.epoch_start, msg.sender)\n    log Bid(0, msg.sender, 123)\n\n\n@internal\n@view\ndef _epoch_in_progress() -> bool:\n    \"\"\"\n    @notice\n        Checks if we are currently between epoch_start and epoch_end.\n    \"\"\"\n    return block.timestamp >= self.epoch_start and block.timestamp <= self.epoch_end\n\n\n@external\ndef suggest_owner(_new_owner: address):\n    \"\"\"\n    @notice\n        Step 1 of the 2 step process to transfer ownership.\n        Current owner suggests a new owner.\n        Requires the new owner to accept ownership in step 2.\n    @param _new_owner\n        The address of the new owner.\n    \"\"\"\n    assert msg.sender == self.owner, \"unauthorized\"\n    self.suggested_owner = _new_owner\n    log NewOwnerSuggested(self.owner, self.suggested_owner)\n\n\n@external\ndef accept_ownership():\n    \"\"\"\n    @notice\n        Step 2 of the 2 step process to transfer ownership.\n        The suggested owner accepts the transfer and becomes the\n        new owner.\n    \"\"\"\n    assert msg.sender == self.suggested_owner, \"unauthorized\"\n    prev_owner: address = self.owner\n    self.owner = self.suggested_owner\n    log OwnershipTransferred(prev_owner, self.owner)\n\n\n@external\ndef set_max_token_id(_new_max_token_id: uint256):\n    \"\"\"\n    @notice\n        Changes the max_token_id and the amount of NFTs to be auctioned.\n        Can only be called by owner.\n    @param _new_max_token_id\n        The last token id to be minted.\n    \"\"\"\n    assert msg.sender == self.owner, \"unauthorized\"\n    assert _new_max_token_id >= self.current_epoch_token_id, \"cannot set max < current\"\n\n    self.max_token_id = _new_max_token_id\n\n\n@external\ndef set_vault(_new_vault_address: address):\n    \"\"\"\n    @notice\n        Changes the vault address.\n        Can only be called by owner.\n    @param _new_vault_address\n        The last token id to be minted.\n    \"\"\"\n    assert msg.sender == self.owner, \"unauthorized\"\n    assert _new_vault_address != empty(address), \"vault cannot be zero address\"\n\n    self.vault = _new_vault_address\n\n\n@external\ndef refund_highest_bidder():\n    assert msg.sender == self.owner, \"unauthorized\"\n    assert self._epoch_in_progress() == False, \"epoch not over\"\n\n    refund_amount: uint256 = self.highest_bid\n    refund_receiver: address = self.highest_bidder\n\n    self.highest_bid = 0\n    self.highest_bidder = empty(address)\n\n    ERC20(WETH).transfer(refund_receiver, refund_amount)"
    }
  ]
}