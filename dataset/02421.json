{
  "Title": "M-8: Complete debt size is not paid off for fee on transfer tokens, but users aren't warned",
  "Content": "# Issue M-8: Complete debt size is not paid off for fee on transfer tokens, but users aren't warned \n\nSource: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/153 \n\n## Found by \ntsvetanovv, rvierdiiev, Avci, obront, chaduke, berndartmueller, Breeje\n\n## Summary\n\nThe protocol seems to be intentionally catering to fee on transfer tokens by measuring token balances before and after transfers to determine the value received. However, the mechanism to pay the full debt will not succeed in paying off the debt if it is used with a fee on transfer token.\n\n## Vulnerability Detail\n\nThe protocol is clearly designed to ensure it is compatible with fee on transfer tokens. For example, all functions that receive tokens check the balance before and after, and calculate the difference between these values to measure tokens received:\n```solidity\nfunction doERC20TransferIn(address token, uint256 amountCall)\n    internal\n    returns (uint256)\n{\n    uint256 balanceBefore = IERC20Upgradeable(token).balanceOf(\n        address(this)\n    );\n    IERC20Upgradeable(token).safeTransferFrom(\n        msg.sender,\n        address(this),\n        amountCall\n    );\n    uint256 balanceAfter = IERC20Upgradeable(token).balanceOf(\n        address(this)\n    );\n    return balanceAfter - balanceBefore;\n}\n```\n\nThere is another feature of the protocol, which is that when loans are being repaid, the protocol gives the option of passing `type(uint256).max` to pay your debt in full:\n```solidity\nif (amountCall == type(uint256).max) {\n    amountCall = oldDebt;\n}\n```\nHowever, these two features are not compatible. If a user paying off fee on transfer tokens passes in `type(uint256).max` to pay their debt in full, the full amount of their debt will be calculated. But when that amount is transferred to the contract, the amount that the result increases will be slightly less. As a result, the user will retain some balance that is not paid off.\n\n## Impact\n\nThe feature to allow loans to be paid in full will silently fail when used with fee on transfer tokens, which may trick users into thinking they have completely paid off their loans, and accidentally maintaining a balance.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/BlueBerryBank.sol#L760-L775\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nI understand that it would be difficult to implement a mechanism to pay fee on transfer tokens off in full. That adds a lot of complexity that is somewhat fragile.\n\nThe issue here is that the failure is silent, so that users request to pay off their loan in full, get confirmation, and may not realize that the loan still has an outstanding balance with interest accruing.\n\nTo solve this, there should be a confirmation that any user who passes `type(uint256).max` has paid off their debt in full. Otherwise, the function should revert, so that users paying fee on transfer tokens know that they cannot use the \"pay in full\" feature and must specify the correct amount to get their outstanding balance down to zero.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/41",
  "Code": [
    {
      "filename": "contracts/BlueBerryBank.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\n\nimport \"./utils/BlueBerryConst.sol\";\nimport \"./utils/BlueBerryErrors.sol\";\nimport \"./utils/ERC1155NaiveReceiver.sol\";\nimport \"./interfaces/IBank.sol\";\nimport \"./interfaces/IOracle.sol\";\nimport \"./interfaces/ISoftVault.sol\";\nimport \"./interfaces/IHardVault.sol\";\nimport \"./interfaces/compound/ICErc20.sol\";\nimport \"./interfaces/compound/IComptroller.sol\";\nimport \"./libraries/BBMath.sol\";\nimport \"hardhat/console.sol\";\n\ncontract BlueBerryBank is OwnableUpgradeable, ERC1155NaiveReceiver, IBank {\n    using BBMath for uint256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private constant _NO_ID = type(uint256).max;\n    address private constant _NO_ADDRESS = address(1);\n\n    uint256 public _GENERAL_LOCK; // TEMPORARY: re-entrancy lock guard.\n    uint256 public _IN_EXEC_LOCK; // TEMPORARY: exec lock guard.\n    uint256 public override POSITION_ID; // TEMPORARY: position ID currently under execution.\n    address public override SPELL; // TEMPORARY: spell currently under execution.\n\n    IProtocolConfig public config;\n    IOracle public oracle; // The oracle address for determining prices.\n    uint256 public override nextPositionId; // Next available position ID, starting from 1 (see initialize).\n\n    address[] public allBanks; // The list of all listed banks.\n    mapping(address => Bank) public banks; // Mapping from token to bank data.\n    mapping(address => bool) public cTokenInBank; // Mapping from cToken to its existence in bank.\n    mapping(uint256 => Position) public positions; // Mapping from position ID to position data.\n\n    bool public allowContractCalls; // The boolean status whether to allow call from contract (false = onlyEOA)\n    mapping(address => bool) public whitelistedTokens; // Mapping from token to whitelist status\n    mapping(address => bool) public whitelistedSpells; // Mapping from spell to whitelist status\n    mapping(address => bool) public whitelistedContracts; // Mapping from user to whitelist status\n\n    uint256 public bankStatus; // Each bit stores certain bank status, e.g. borrow allowed, repay allowed\n\n    /// @dev Ensure that the function is called from EOA\n    /// when allowContractCalls is set to false and caller is not whitelisted\n    modifier onlyEOAEx() {\n        if (!allowContractCalls && !whitelistedContracts[msg.sender]) {\n            if (msg.sender != tx.origin) revert NOT_EOA(msg.sender);\n        }\n        _;\n    }\n\n    /// @dev Ensure that the token is already whitelisted\n    modifier onlyWhitelistedToken(address token) {\n        if (!whitelistedTokens[token]) revert TOKEN_NOT_WHITELISTED(token);\n        _;\n    }\n\n    /// @dev Reentrancy lock guard.\n    modifier lock() {\n        if (_GENERAL_LOCK != _NOT_ENTERED) revert LOCKED();\n        _GENERAL_LOCK = _ENTERED;\n        _;\n        _GENERAL_LOCK = _NOT_ENTERED;\n    }\n\n    /// @dev Ensure that the function is called from within the execution scope.\n    modifier inExec() {\n        if (POSITION_ID == _NO_ID) revert NOT_IN_EXEC();\n        if (SPELL != msg.sender) revert NOT_FROM_SPELL(msg.sender);\n        if (_IN_EXEC_LOCK != _NOT_ENTERED) revert LOCKED();\n        _IN_EXEC_LOCK = _ENTERED;\n        _;\n        _IN_EXEC_LOCK = _NOT_ENTERED;\n    }\n\n    /// @dev Ensure that the interest rate of the given token is accrued.\n    modifier poke(address token) {\n        accrue(token);\n        _;\n    }\n\n    /// @dev Initialize the bank smart contract, using msg.sender as the first governor.\n    /// @param _oracle The oracle smart contract address.\n    /// @param _config The Protocol config address\n    function initialize(IOracle _oracle, IProtocolConfig _config)\n        external\n        initializer\n    {\n        __Ownable_init();\n        if (address(_oracle) == address(0) || address(_config) == address(0)) {\n            revert ZERO_ADDRESS();\n        }\n        _GENERAL_LOCK = _NOT_ENTERED;\n        _IN_EXEC_LOCK = _NOT_ENTERED;\n        POSITION_ID = _NO_ID;\n        SPELL = _NO_ADDRESS;\n\n        config = _config;\n        oracle = _oracle;\n        nextPositionId = 1;\n        bankStatus = 7; // allow borrow, lend, repay\n\n        emit SetOracle(address(_oracle));\n    }\n\n    /// @dev Return the current executor (the owner of the current position).\n    function EXECUTOR() external view override returns (address) {\n        uint256 positionId = POSITION_ID;\n        if (positionId == _NO_ID) {\n            revert NOT_UNDER_EXECUTION();\n        }\n        return positions[positionId].owner;\n    }\n\n    /// @dev Set allowContractCalls\n    /// @param ok The status to set allowContractCalls to (false = onlyEOA)\n    function setAllowContractCalls(bool ok) external onlyOwner {\n        allowContractCalls = ok;\n    }\n\n    /// @notice Set whitelist user status\n    /// @param contracts list of users to change status\n    /// @param statuses list of statuses to change to\n    function whitelistContracts(\n        address[] calldata contracts,\n        bool[] calldata statuses\n    ) external onlyOwner {\n        if (contracts.length != statuses.length) {\n            revert INPUT_ARRAY_MISMATCH();\n        }\n        for (uint256 idx = 0; idx < contracts.length; idx++) {\n            if (contracts[idx] == address(0)) {\n                revert ZERO_ADDRESS();\n            }\n            whitelistedContracts[contracts[idx]] = statuses[idx];\n        }\n    }\n\n    /// @dev Set whitelist spell status\n    /// @param spells list of spells to change status\n    /// @param statuses list of statuses to change to\n    function whitelistSpells(\n        address[] calldata spells,\n        bool[] calldata statuses\n    ) external onlyOwner {\n        if (spells.length != statuses.length) {\n            revert INPUT_ARRAY_MISMATCH();\n        }\n        for (uint256 idx = 0; idx < spells.length; idx++) {\n            if (spells[idx] == address(0)) {\n                revert ZERO_ADDRESS();\n            }\n            whitelistedSpells[spells[idx]] = statuses[idx];\n        }\n    }\n\n    /// @dev Set whitelist token status\n    /// @param tokens list of tokens to change status\n    /// @param statuses list of statuses to change to\n    function whitelistTokens(\n        address[] calldata tokens,\n        bool[] calldata statuses\n    ) external onlyOwner {\n        if (tokens.length != statuses.length) {\n            revert INPUT_ARRAY_MISMATCH();\n        }\n        for (uint256 idx = 0; idx < tokens.length; idx++) {\n            if (statuses[idx] && !oracle.support(tokens[idx]))\n                revert ORACLE_NOT_SUPPORT(tokens[idx]);\n            whitelistedTokens[tokens[idx]] = statuses[idx];\n        }\n    }\n\n    /**\n     * @dev Add a new bank to the ecosystem.\n     * @param token The underlying token for the bank.\n     * @param cToken The address of the cToken smart contract.\n     * @param softVault The address of softVault.\n     * @param hardVault The address of hardVault.\n     */\n    function addBank(\n        address token,\n        address cToken,\n        address softVault,\n        address hardVault\n    ) external onlyOwner onlyWhitelistedToken(token) {\n        if (\n            token == address(0) ||\n            cToken == address(0) ||\n            softVault == address(0) ||\n            hardVault == address(0)\n        ) revert ZERO_ADDRESS();\n        Bank storage bank = banks[token];\n        if (cTokenInBank[cToken]) revert CTOKEN_ALREADY_ADDED();\n        if (bank.isListed) revert BANK_ALREADY_LISTED();\n        if (allBanks.length >= 256) revert BANK_LIMIT();\n        cTokenInBank[cToken] = true;\n        bank.isListed = true;\n        bank.index = uint8(allBanks.length);\n        bank.cToken = cToken;\n        bank.softVault = softVault;\n        bank.hardVault = hardVault;\n\n        IHardVault(hardVault).setApprovalForAll(hardVault, true);\n        allBanks.push(token);\n\n        emit AddBank(token, cToken, softVault, hardVault);\n    }\n\n    /// @dev Set bank status\n    /// @param _bankStatus new bank status to change to\n    function setBankStatus(uint256 _bankStatus) external onlyOwner {\n        bankStatus = _bankStatus;\n    }\n\n    /// @dev Bank borrow status allowed or not\n    /// @notice check last bit of bankStatus\n    function isBorrowAllowed() public view returns (bool) {\n        return (bankStatus & 0x01) > 0;\n    }\n\n    /// @dev Bank repay status allowed or not\n    /// @notice Check second-to-last bit of bankStatus\n    function isRepayAllowed() public view returns (bool) {\n        return (bankStatus & 0x02) > 0;\n    }\n\n    /// @dev Bank borrow status allowed or not\n    /// @notice check last bit of bankStatus\n    function isLendAllowed() public view returns (bool) {\n        return (bankStatus & 0x04) > 0;\n    }\n\n    /// @dev Check whether the oracle supports the token\n    /// @param token ERC-20 token to check for support\n    function support(address token) external view override returns (bool) {\n        return oracle.support(token);\n    }\n\n    /// @dev Trigger interest accrual for the given bank.\n    /// @param token The underlying token to trigger the interest accrual.\n    function accrue(address token) public override {\n        Bank storage bank = banks[token];\n        if (!bank.isListed) revert BANK_NOT_LISTED(token);\n        bank.totalDebt = ICErc20(bank.cToken).borrowBalanceCurrent(\n            address(this)\n        );\n    }\n\n    /// @dev Convenient function to trigger interest accrual for a list of banks.\n    /// @param tokens The list of banks to trigger interest accrual.\n    function accrueAll(address[] memory tokens) external {\n        for (uint256 idx = 0; idx < tokens.length; idx++) {\n            accrue(tokens[idx]);\n        }\n    }\n\n    /// @dev Return the borrow balance for given position and token without triggering interest accrual.\n    /// @param positionId The position to query for borrow balance.\n    /// @param token The token to query for borrow balance.\n    function borrowBalanceStored(uint256 positionId, address token)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        uint256 totalDebt = banks[token].totalDebt;\n        uint256 totalShare = banks[token].totalShare;\n        uint256 share = positions[positionId].debtShareOf[token];\n        if (share == 0 || totalDebt == 0) {\n            return 0;\n        } else {\n            return (share * totalDebt).divCeil(totalShare);\n        }\n    }\n\n    /// @dev Trigger interest accrual and return the current borrow balance.\n    /// @param positionId The position to query for borrow balance.\n    /// @param token The token to query for borrow balance.\n    function borrowBalanceCurrent(uint256 positionId, address token)\n        external\n        override\n        poke(token)\n        returns (uint256)\n    {\n        return borrowBalanceStored(positionId, token);\n    }\n\n    /// @dev Return bank information for the given token.\n    /// @param token The token address to query for bank information.\n    function getBankInfo(address token)\n        external\n        view\n        override\n        returns (\n            bool isListed,\n            address cToken,\n            uint256 totalDebt,\n            uint256 totalShare\n        )\n    {\n        Bank storage bank = banks[token];\n        return (bank.isListed, bank.cToken, bank.totalDebt, bank.totalShare);\n    }\n\n    function getPositionIdsByOwner(address owner)\n        external\n        view\n        returns (uint256[] memory ids)\n    {\n        uint256[] memory matchingIds = new uint256[](nextPositionId);\n        uint256 index;\n        for (uint256 i = 0; i < nextPositionId; i++) {\n            if (positions[i].owner == owner) {\n                matchingIds[index] = i;\n                index++;\n            }\n        }\n\n        ids = new uint256[](index);\n        for (uint256 i = 0; i < index; i++) {\n            ids[i] = matchingIds[i];\n        }\n    }\n\n    /// @dev Return position information for the given position id.\n    /// @param positionId The position id to query for position information.\n    function getPositionInfo(uint256 positionId)\n        public\n        view\n        override\n        returns (\n            address owner,\n            address underlyingToken,\n            uint256 underlyingAmount,\n            uint256 underlyingVaultShare,\n            address collToken,\n            uint256 collId,\n            uint256 collateralSize,\n            uint256 risk\n        )\n    {\n        Position storage pos = positions[positionId];\n        owner = pos.owner;\n        underlyingToken = pos.underlyingToken;\n        underlyingAmount = pos.underlyingAmount;\n        underlyingVaultShare = pos.underlyingVaultShare;\n        collToken = pos.collToken;\n        collId = pos.collId;\n        collateralSize = pos.collateralSize;\n        risk = getPositionRisk(positionId);\n    }\n\n    /// @dev Return current position information\n    function getCurrentPositionInfo()\n        external\n        view\n        override\n        returns (\n            address owner,\n            address underlyingToken,\n            uint256 underlyingAmount,\n            uint256 underlyingVaultShare,\n            address collToken,\n            uint256 collId,\n            uint256 collateralSize,\n            uint256 risk\n        )\n    {\n        if (POSITION_ID == _NO_ID) revert BAD_POSITION(POSITION_ID);\n        return getPositionInfo(POSITION_ID);\n    }\n\n    /// @dev Return the debt share of the given bank token for the given position id.\n    /// @param positionId position id to get debt of\n    /// @param token ERC20 debt token to query\n    function getPositionDebtShareOf(uint256 positionId, address token)\n        external\n        view\n        returns (uint256)\n    {\n        return positions[positionId].debtShareOf[token];\n    }\n\n    /// @dev Return the list of all debts for the given position id.\n    /// @param positionId position id to get debts of\n    function getPositionDebts(uint256 positionId)\n        external\n        view\n        returns (address[] memory tokens, uint256[] memory debts)\n    {\n        Position storage pos = positions[positionId];\n        uint256 count = 0;\n        uint256 bitMap = pos.debtMap;\n        while (bitMap > 0) {\n            if ((bitMap & 1) != 0) {\n                count++;\n            }\n            bitMap >>= 1;\n        }\n        tokens = new address[](count);\n        debts = new uint256[](count);\n        bitMap = pos.debtMap;\n        count = 0;\n        uint256 idx = 0;\n        while (bitMap > 0) {\n            if ((bitMap & 1) != 0) {\n                address token = allBanks[idx];\n                Bank storage bank = banks[token];\n                tokens[count] = token;\n                debts[count] = (pos.debtShareOf[token] * bank.totalDebt)\n                    .divCeil(bank.totalShare);\n                count++;\n            }\n            idx++;\n            bitMap >>= 1;\n        }\n    }\n\n    /**\n     * @dev Return the USD value of total collateral of the given position.\n     * @param positionId The position ID to query for the collateral value.\n     */\n    function getPositionValue(uint256 positionId)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        Position storage pos = positions[positionId];\n        uint256 size = pos.collateralSize;\n        if (size == 0) {\n            return 0;\n        } else {\n            if (pos.collToken == address(0)) revert BAD_COLLATERAL(positionId);\n            return oracle.getCollateralValue(pos.collToken, pos.collId, size);\n        }\n    }\n\n    /// @dev Return the USD value total debt of the given position\n    /// @param positionId The position ID to query for the debt value.\n    function getDebtValue(uint256 positionId)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        uint256 value = 0;\n        Position storage pos = positions[positionId];\n        uint256 bitMap = pos.debtMap;\n        uint256 idx = 0;\n        while (bitMap > 0) {\n            if ((bitMap & 1) != 0) {\n                address token = allBanks[idx];\n                uint256 share = pos.debtShareOf[token];\n                Bank storage bank = banks[token];\n                uint256 debt = (share * bank.totalDebt).divCeil(\n                    bank.totalShare\n                );\n                value += oracle.getDebtValue(token, debt);\n            }\n            idx++;\n            bitMap >>= 1;\n        }\n        return value;\n    }\n\n    function getPositionRisk(uint256 positionId)\n        public\n        view\n        returns (uint256 risk)\n    {\n        Position storage pos = positions[positionId];\n        uint256 pv = getPositionValue(positionId);\n        uint256 ov = getDebtValue(positionId);\n        uint256 cv = oracle.getUnderlyingValue(\n            pos.underlyingToken,\n            pos.underlyingAmount\n        );\n\n        if (cv == 0) risk = 0;\n        else if (pv >= ov) risk = 0;\n        else {\n            risk = ((ov - pv) * DENOMINATOR) / cv;\n        }\n    }\n\n    function isLiquidatable(uint256 positionId)\n        public\n        view\n        returns (bool liquidatable)\n    {\n        Position storage pos = positions[positionId];\n        uint256 risk = getPositionRisk(positionId);\n        liquidatable = risk >= oracle.getLiqThreshold(pos.underlyingToken);\n    }\n\n    /// @dev Liquidate a position. Pay debt for its owner and take the collateral.\n    /// @param positionId The position ID to liquidate.\n    /// @param debtToken The debt token to repay.\n    /// @param amountCall The amount to repay when doing transferFrom call.\n    function liquidate(\n        uint256 positionId,\n        address debtToken,\n        uint256 amountCall\n    ) external override lock poke(debtToken) {\n        if (amountCall == 0) revert ZERO_AMOUNT();\n        if (!isLiquidatable(positionId)) revert NOT_LIQUIDATABLE(positionId);\n        Position storage pos = positions[positionId];\n        Bank memory bank = banks[pos.underlyingToken];\n        if (pos.collToken == address(0)) revert BAD_COLLATERAL(positionId);\n\n        uint256 oldShare = pos.debtShareOf[debtToken];\n        (uint256 amountPaid, uint256 share) = repayInternal(\n            positionId,\n            debtToken,\n            amountCall\n        );\n\n        uint256 liqSize = (pos.collateralSize * share) / oldShare;\n        uint256 uTokenSize = (pos.underlyingAmount * share) / oldShare;\n        uint256 uVaultShare = (pos.underlyingVaultShare * share) / oldShare;\n\n        pos.collateralSize -= liqSize;\n        pos.underlyingAmount -= uTokenSize;\n        pos.underlyingVaultShare -= uVaultShare;\n\n        // Transfer position (Wrapped LP Tokens) to liquidator\n        IERC1155Upgradeable(pos.collToken).safeTransferFrom(\n            address(this),\n            msg.sender,\n            pos.collId,\n            liqSize,\n            \"\"\n        );\n        // Transfer underlying collaterals(vault share tokens) to liquidator\n        if (\n            address(ISoftVault(bank.softVault).uToken()) == pos.underlyingToken\n        ) {\n            IERC20Upgradeable(bank.softVault).safeTransfer(\n                msg.sender,\n                uVaultShare\n            );\n        } else {\n            IERC1155Upgradeable(bank.hardVault).safeTransferFrom(\n                address(this),\n                msg.sender,\n                uint256(uint160(pos.underlyingToken)),\n                uVaultShare,\n                \"\"\n            );\n        }\n\n        emit Liquidate(\n            positionId,\n            msg.sender,\n            debtToken,\n            amountPaid,\n            share,\n            liqSize,\n            uTokenSize\n        );\n    }\n\n    /// @dev Execute the action with the supplied data.\n    /// @param positionId The position ID to execute the action, or zero for new position.\n    /// @param spell The target spell to invoke the execution.\n    /// @param data Extra data to pass to the target for the execution.\n    function execute(\n        uint256 positionId,\n        address spell,\n        bytes memory data\n    ) external payable lock onlyEOAEx returns (uint256) {\n        if (!whitelistedSpells[spell]) revert SPELL_NOT_WHITELISTED(spell);\n        if (positionId == 0) {\n            positionId = nextPositionId++;\n            positions[positionId].owner = msg.sender;\n        } else {\n            if (positionId >= nextPositionId) revert BAD_POSITION(positionId);\n            if (msg.sender != positions[positionId].owner)\n                revert NOT_FROM_OWNER(positionId, msg.sender);\n        }\n        POSITION_ID = positionId;\n        SPELL = spell;\n\n        (bool ok, bytes memory returndata) = SPELL.call{value: msg.value}(data);\n        if (!ok) {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(\"bad cast call\");\n            }\n        }\n\n        if (isLiquidatable(positionId)) revert INSUFFICIENT_COLLATERAL();\n\n        POSITION_ID = _NO_ID;\n        SPELL = _NO_ADDRESS;\n\n        return positionId;\n    }\n\n    /**\n     * @dev Lend tokens to bank as isolated collateral. Must only be called while under execution.\n     * @param token The token to deposit on bank as isolated collateral\n     * @param amount The amount of tokens to lend.\n     */\n    function lend(address token, uint256 amount)\n        external\n        override\n        inExec\n        poke(token)\n        onlyWhitelistedToken(token)\n    {\n        if (!isLendAllowed()) revert LEND_NOT_ALLOWED();\n\n        Position storage pos = positions[POSITION_ID];\n        Bank storage bank = banks[token];\n        if (pos.underlyingToken != address(0)) {\n            // already have isolated collateral, allow same isolated collateral\n            if (pos.underlyingToken != token)\n                revert INCORRECT_UNDERLYING(token);\n        }\n\n        IERC20Upgradeable(token).safeTransferFrom(\n            pos.owner,\n            address(this),\n            amount\n        );\n        amount = doCutDepositFee(token, amount);\n        pos.underlyingToken = token;\n        pos.underlyingAmount += amount;\n\n        if (address(ISoftVault(bank.softVault).uToken()) == token) {\n            IERC20Upgradeable(token).approve(bank.softVault, amount);\n            pos.underlyingVaultShare += ISoftVault(bank.softVault).deposit(\n                amount\n            );\n        } else {\n            IERC20Upgradeable(token).approve(bank.hardVault, amount);\n            pos.underlyingVaultShare += IHardVault(bank.hardVault).deposit(\n                token,\n                amount\n            );\n        }\n\n        bank.totalLend += amount;\n\n        emit Lend(POSITION_ID, msg.sender, token, amount);\n    }\n\n    /**\n     * @dev Withdraw isolated collateral tokens lent to bank. Must only be called from spell while under execution.\n     * @param token Isolated collateral token address\n     * @param shareAmount The amount of vaule share token to withdraw.\n     */\n    function withdrawLend(address token, uint256 shareAmount)\n        external\n        override\n        inExec\n        poke(token)\n    {\n        Position storage pos = positions[POSITION_ID];\n        Bank storage bank = banks[token];\n        if (token != pos.underlyingToken) revert INVALID_UTOKEN(token);\n        if (shareAmount == type(uint256).max) {\n            shareAmount = pos.underlyingVaultShare;\n        }\n\n        uint256 wAmount;\n        if (address(ISoftVault(bank.softVault).uToken()) == token) {\n            ISoftVault(bank.softVault).approve(\n                bank.softVault,\n                type(uint256).max\n            );\n            wAmount = ISoftVault(bank.softVault).withdraw(shareAmount);\n        } else {\n            wAmount = IHardVault(bank.hardVault).withdraw(token, shareAmount);\n        }\n\n        wAmount = wAmount > pos.underlyingAmount\n            ? pos.underlyingAmount\n            : wAmount;\n\n        pos.underlyingVaultShare -= shareAmount;\n        pos.underlyingAmount -= wAmount;\n        bank.totalLend -= wAmount;\n\n        wAmount = doCutWithdrawFee(token, wAmount);\n\n        IERC20Upgradeable(token).safeTransfer(msg.sender, wAmount);\n    }\n\n    /// @dev Borrow tokens from given bank. Must only be called from spell while under execution.\n    /// @param token The token to borrow from the bank.\n    /// @param amount The amount of tokens to borrow.\n    function borrow(address token, uint256 amount)\n        external\n        override\n        inExec\n        poke(token)\n        onlyWhitelistedToken(token)\n    {\n        if (!isBorrowAllowed()) revert BORROW_NOT_ALLOWED();\n        Bank storage bank = banks[token];\n        Position storage pos = positions[POSITION_ID];\n        uint256 totalShare = bank.totalShare;\n        uint256 totalDebt = bank.totalDebt;\n        uint256 share = totalShare == 0\n            ? amount\n            : (amount * totalShare).divCeil(totalDebt);\n        bank.totalShare += share;\n        uint256 newShare = pos.debtShareOf[token] + share;\n        pos.debtShareOf[token] = newShare;\n        if (newShare > 0) {\n            pos.debtMap |= (1 << uint256(bank.index));\n        }\n        IERC20Upgradeable(token).safeTransfer(\n            msg.sender,\n            doBorrow(token, amount)\n        );\n        emit Borrow(POSITION_ID, msg.sender, token, amount, share);\n    }\n\n    /// @dev Repay tokens to the bank. Must only be called while under execution.\n    /// @param token The token to repay to the bank.\n    /// @param amountCall The amount of tokens to repay via transferFrom.\n    function repay(address token, uint256 amountCall)\n        external\n        override\n        inExec\n        poke(token)\n        onlyWhitelistedToken(token)\n    {\n        if (!isRepayAllowed()) revert REPAY_NOT_ALLOWED();\n        (uint256 amount, uint256 share) = repayInternal(\n            POSITION_ID,\n            token,\n            amountCall\n        );\n        emit Repay(POSITION_ID, msg.sender, token, amount, share);\n    }\n\n    /// @dev Perform repay action. Return the amount actually taken and the debt share reduced.\n    /// @param positionId The position ID to repay the debt.\n    /// @param token The bank token to pay the debt.\n    /// @param amountCall The amount to repay by calling transferFrom, or -1 for debt size.\n    function repayInternal(\n        uint256 positionId,\n        address token,\n        uint256 amountCall\n    ) internal returns (uint256, uint256) {\n        Bank storage bank = banks[token];\n        Position storage pos = positions[positionId];\n        uint256 totalShare = bank.totalShare;\n        uint256 totalDebt = bank.totalDebt;\n        uint256 oldShare = pos.debtShareOf[token];\n        uint256 oldDebt = (oldShare * totalDebt).divCeil(totalShare);\n        if (amountCall == type(uint256).max) {\n            amountCall = oldDebt;\n        }\n        amountCall = doERC20TransferIn(token, amountCall);\n        uint256 paid = doRepay(token, amountCall);\n        if (paid > oldDebt) revert REPAY_EXCEEDS_DEBT(paid, oldDebt); // prevent share overflow attack\n        uint256 lessShare = paid == oldDebt\n            ? oldShare\n            : (paid * totalShare) / totalDebt;\n        bank.totalShare = totalShare - lessShare;\n        uint256 newShare = oldShare - lessShare;\n        pos.debtShareOf[token] = newShare;\n        if (newShare == 0) {\n            pos.debtMap &= ~(1 << uint256(bank.index));\n        }\n        return (paid, lessShare);\n    }\n\n    /// @dev Put more collateral for users. Must only be called during execution.\n    /// @param collToken The ERC1155 token wrapped for collateral. (Wrapped token of LP)\n    /// @param collId The token id to collateral. (Uint256 format of LP address)\n    /// @param amountCall The amount of tokens to put via transferFrom.\n    function putCollateral(\n        address collToken,\n        uint256 collId,\n        uint256 amountCall\n    ) external override inExec {\n        Position storage pos = positions[POSITION_ID];\n        if (pos.collToken != collToken || pos.collId != collId) {\n            if (!oracle.supportWrappedToken(collToken, collId))\n                revert ORACLE_NOT_SUPPORT_WTOKEN(collToken);\n            if (pos.collateralSize > 0) revert ANOTHER_COL_EXIST(pos.collToken);\n            pos.collToken = collToken;\n            pos.collId = collId;\n        }\n        uint256 amount = doERC1155TransferIn(collToken, collId, amountCall);\n        pos.collateralSize += amount;\n        emit PutCollateral(\n            POSITION_ID,\n            pos.owner,\n            msg.sender,\n            collToken,\n            collId,\n            amount\n        );\n    }\n\n    /// @dev Take some collateral back. Must only be called during execution.\n    /// @param amount The amount of tokens to take back via transfer.\n    function takeCollateral(uint256 amount)\n        external\n        override\n        inExec\n        returns (uint256)\n    {\n        Position storage pos = positions[POSITION_ID];\n        if (amount == type(uint256).max) {\n            amount = pos.collateralSize;\n        }\n        pos.collateralSize -= amount;\n        IERC1155Upgradeable(pos.collToken).safeTransferFrom(\n            address(this),\n            msg.sender,\n            pos.collId,\n            amount,\n            \"\"\n        );\n        emit TakeCollateral(\n            POSITION_ID,\n            msg.sender,\n            pos.collToken,\n            pos.collId,\n            amount\n        );\n\n        return amount;\n    }\n\n    /**\n     * @dev Internal function to perform borrow from the bank and return the amount received.\n     * @param token The token to perform borrow action.\n     * @param amountCall The amount use in the transferFrom call.\n     * NOTE: Caller must ensure that cToken interest was already accrued up to this block.\n     */\n    function doBorrow(address token, uint256 amountCall)\n        internal\n        returns (uint256 borrowAmount)\n    {\n        Bank storage bank = banks[token]; // assume the input is already sanity checked.\n\n        IERC20Upgradeable uToken = IERC20Upgradeable(token);\n        uint256 uBalanceBefore = uToken.balanceOf(address(this));\n        if (ICErc20(bank.cToken).borrow(amountCall) != 0)\n            revert BORROW_FAILED(amountCall);\n        uint256 uBalanceAfter = uToken.balanceOf(address(this));\n\n        borrowAmount = uBalanceAfter - uBalanceBefore;\n        bank.totalDebt += amountCall;\n    }\n\n    /**\n     * @dev Internal function to perform repay to the bank and return the amount actually repaid.\n     * @param token The token to perform repay action.\n     * @param amountCall The amount to use in the repay call.\n     * NOTE: Caller must ensure that cToken interest was already accrued up to this block.\n     */\n    function doRepay(address token, uint256 amountCall)\n        internal\n        returns (uint256 repaidAmount)\n    {\n        Bank storage bank = banks[token]; // assume the input is already sanity checked.\n        IERC20Upgradeable(token).approve(bank.cToken, amountCall);\n        if (ICErc20(bank.cToken).repayBorrow(amountCall) != 0)\n            revert REPAY_FAILED(amountCall);\n        uint256 newDebt = ICErc20(bank.cToken).borrowBalanceStored(\n            address(this)\n        );\n        repaidAmount = bank.totalDebt - newDebt;\n        bank.totalDebt = newDebt;\n    }\n\n    function doCutDepositFee(address token, uint256 amount)\n        internal\n        returns (uint256)\n    {\n        if (config.treasury() == address(0)) revert NO_TREASURY_SET();\n        uint256 fee = (amount * config.depositFee()) / DENOMINATOR;\n        IERC20Upgradeable(token).safeTransfer(config.treasury(), fee);\n        return amount - fee;\n    }\n\n    function doCutWithdrawFee(address token, uint256 amount)\n        internal\n        returns (uint256)\n    {\n        if (config.treasury() == address(0)) revert NO_TREASURY_SET();\n        uint256 fee = (amount * config.withdrawFee()) / DENOMINATOR;\n        IERC20Upgradeable(token).safeTransfer(config.treasury(), fee);\n        return amount - fee;\n    }\n\n    /// @dev Internal function to perform ERC20 transfer in and return amount actually received.\n    /// @param token The token to perform transferFrom action.\n    /// @param amountCall The amount use in the transferFrom call.\n    function doERC20TransferIn(address token, uint256 amountCall)\n        internal\n        returns (uint256)\n    {\n        uint256 balanceBefore = IERC20Upgradeable(token).balanceOf(\n            address(this)\n        );\n        IERC20Upgradeable(token).safeTransferFrom("
    }
  ]
}