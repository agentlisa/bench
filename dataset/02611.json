{
  "Title": "Incorrect calculations",
  "Content": "We found the following instances of incorrect calculations in `view` functions that are not currently called internally:\n\n\n* In the [`previewWithdraw`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/vaults/BaseVault.sol#L196-L201) function, the [`DENOMINATOR` over `invertedFee`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/vaults/BaseVault.sol#L199) is always bigger than 1 when the fee is non-zero. Hence, the final returned shares are always an overestimate. Further, the `withdrawFeeRatio` is multiplied to `shares` instead of `assets` as in other instances such as [`_getFee`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/vaults/BaseVault.sol#L399-L403). Consider correcting the withdrawal fee calculation.\n* The calculation in the [`assetsOf`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/vaults/BaseVault.sol#L277) function over-estimates the actual commitment by an additional `committedAssets`. Consider removing the extra component.\n\n\n**Update:** *Partially fixed in commit `6d37029` in [PR#75](https://github.com/pods-finance/yield-contracts/pull/75). `previewWithdraw` does not include fees as stated in the [EIP](https://eips.ethereum.org/EIPS/eip-4626).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/vaults/BaseVault.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../interfaces/IConfigurationManager.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../libs/AuxMath.sol\";\nimport \"../libs/DepositQueueLib.sol\";\nimport \"../libs/CastUint.sol\";\nimport \"../mixins/Capped.sol\";\n\n/**\n * @title A Vault that tokenize shares of strategy\n * @author Pods Finance\n */\nabstract contract BaseVault is IVault, ERC20Permit, Capped {\n    using SafeERC20 for IERC20Metadata;\n    using AuxMath for uint256;\n    using CastUint for uint256;\n    using DepositQueueLib for DepositQueueLib.DepositQueue;\n\n    IConfigurationManager public immutable configuration;\n    IERC20Metadata internal immutable _asset;\n\n    uint256 public currentRoundId;\n    bool public isProcessingDeposits = false;\n\n    /*\n    DENOMINATOR represents the precision for the following system variables:\n    - MAX_WITHDRAW_FEE\n    - InvestorRatio\n    */\n\n    uint256 public constant DENOMINATOR = 10000;\n    /*\n    MAX_WITDRAW_FEE is a safe check in case the ConfiguratorManager sets\n    a fee high enough that can be used as a way to drain funds. \n    The precision of this number is set by constant DENOMINATOR.\n    */\n    uint256 public constant MAX_WITHDRAW_FEE = 1000;\n    uint256 public constant EMERGENCY_INTERVAL = 604800;\n    uint256 public processedDeposits = 0;\n    uint256 private _lastEndRound;\n\n    DepositQueueLib.DepositQueue internal depositQueue;\n\n    constructor(IConfigurationManager _configuration, IERC20Metadata _asset_)\n        ERC20(\n            string(abi.encodePacked(\"Pods Yield \", _asset_.symbol())),\n            string(abi.encodePacked(\"py\", _asset_.symbol()))\n        )\n        ERC20Permit(string(abi.encodePacked(\"Pods Yield \", _asset_.symbol())))\n        Capped(_configuration)\n    {\n        configuration = _configuration;\n        _asset = _asset_;\n\n        // Vault starts in `start` state\n        emit StartRound(currentRoundId, 0);\n        _lastEndRound = block.timestamp;\n    }\n\n    modifier onlyController() {\n        if (msg.sender != controller()) revert IVault__CallerIsNotTheController();\n        _;\n    }\n\n    modifier onlyRoundStarter() {\n        bool lastRoundEndedAWeekAgo = block.timestamp >= _lastEndRound + EMERGENCY_INTERVAL;\n\n        if (!lastRoundEndedAWeekAgo && msg.sender != controller()) {\n            revert IVault__CallerIsNotTheController();\n        }\n        _;\n    }\n\n    /**\n     * @inheritdoc ERC20\n     */\n    function decimals() public view override returns (uint8) {\n        return _asset.decimals();\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function asset() public view returns (address) {\n        return address(_asset);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function deposit(uint256 assets, address receiver) external virtual override returns (uint256 shares) {\n        if (isProcessingDeposits) revert IVault__ForbiddenWhileProcessingDeposits();\n        shares = previewDeposit(assets);\n\n        if (shares == 0) revert IVault__ZeroShares();\n        _deposit(assets, shares, receiver);\n    }\n\n    function depositWithPermit(\n        uint256 assets,\n        address receiver,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 shares) {\n        if (isProcessingDeposits) revert IVault__ForbiddenWhileProcessingDeposits();\n        shares = previewDeposit(assets);\n\n        if (shares == 0) revert IVault__ZeroShares();\n        IERC20Permit(address(_asset)).permit(msg.sender, address(this), assets, deadline, v, r, s);\n        _deposit(assets, shares, receiver);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function mint(uint256 shares, address receiver) external virtual override returns (uint256 assets) {\n        if (isProcessingDeposits) revert IVault__ForbiddenWhileProcessingDeposits();\n        assets = previewMint(shares);\n        assets = _deposit(assets, shares, receiver);\n    }\n\n    function mintWithPermit(\n        uint256 shares,\n        address receiver,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public returns (uint256 assets) {\n        if (isProcessingDeposits) revert IVault__ForbiddenWhileProcessingDeposits();\n        assets = previewMint(shares);\n        IERC20Permit(address(_asset)).permit(msg.sender, address(this), assets, deadline, v, r, s);\n        assets = _deposit(assets, shares, receiver);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual override returns (uint256 assets) {\n        if (isProcessingDeposits) revert IVault__ForbiddenWhileProcessingDeposits();\n        assets = convertToAssets(shares);\n\n        if (assets == 0) revert IVault__ZeroAssets();\n        (assets, ) = _withdraw(assets, shares, receiver, owner);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external virtual override returns (uint256 shares) {\n        if (isProcessingDeposits) revert IVault__ForbiddenWhileProcessingDeposits();\n        shares = convertToShares(assets);\n        (, shares) = _withdraw(assets, shares, receiver, owner);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function totalAssets() public view virtual returns (uint256);\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function previewDeposit(uint256 assets) public view override returns (uint256 shares) {\n        return convertToShares(assets);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function previewMint(uint256 shares) public view override returns (uint256 assets) {\n        uint256 supply = totalSupply();\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function previewWithdraw(uint256 assets) public view override returns (uint256 shares) {\n        shares = convertToShares(assets);\n        uint256 invertedFee = DENOMINATOR - withdrawFeeRatio();\n        return shares.mulDivUp(DENOMINATOR, invertedFee);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function previewRedeem(uint256 shares) public view override returns (uint256 assets) {\n        assets = convertToAssets(shares);\n        return assets - _getFee(assets);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function convertToShares(uint256 assets) public view override returns (uint256 shares) {\n        uint256 supply = totalSupply();\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function convertToAssets(uint256 shares) public view override returns (uint256 assets) {\n        uint256 supply = totalSupply();\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function maxDeposit(address) public pure override returns (uint256 assets) {\n        return type(uint256).max;\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function maxMint(address) public pure override returns (uint256 shares) {\n        return type(uint256).max;\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function maxWithdraw(address owner) public view override returns (uint256 assets) {\n        return previewRedeem(balanceOf(owner));\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function maxRedeem(address owner) public view override returns (uint256 shares) {\n        return balanceOf(owner);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function withdrawFeeRatio() public view override returns (uint256) {\n        uint256 _withdrawFeeRatio = configuration.getParameter(address(this), \"WITHDRAW_FEE_RATIO\");\n        // Fee is limited to MAX_WITHDRAW_FEE\n        return AuxMath.min(_withdrawFeeRatio, MAX_WITHDRAW_FEE);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function idleAssetsOf(address owner) public view virtual returns (uint256) {\n        return depositQueue.balanceOf(owner);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function assetsOf(address owner) public view virtual returns (uint256) {\n        uint256 supply = totalSupply();\n        uint256 shares = balanceOf(owner);\n        uint256 committedAssets = supply == 0 ? 0 : shares.mulDivDown(_asset.balanceOf(address(this)), supply);\n        return convertToAssets(shares) + idleAssetsOf(owner) + committedAssets;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function totalIdleAssets() public view virtual returns (uint256) {\n        return depositQueue.totalDeposited;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function depositQueueSize() public view returns (uint256) {\n        return depositQueue.size();\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function controller() public view returns (address) {\n        return configuration.getParameter(address(this), \"VAULT_CONTROLLER\").toAddress();\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function startRound() external virtual onlyRoundStarter returns (uint256 roundId) {\n\n        if (!isProcessingDeposits) revert IVault__NotProcessingDeposits();\n\n        isProcessingDeposits = false;\n\n        _afterRoundStart(processedDeposits);\n        emit StartRound(currentRoundId, processedDeposits);\n        processedDeposits = 0;\n\n        return currentRoundId;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function endRound() external virtual onlyController {\n        if (isProcessingDeposits) revert IVault__AlreadyProcessingDeposits();\n\n        isProcessingDeposits = true;\n        _afterRoundEnd();\n        _lastEndRound = block.timestamp;\n\n        emit EndRound(currentRoundId++);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function refund() external returns (uint256 assets) {\n        assets = depositQueue.balanceOf(msg.sender);\n        if (assets == 0) revert IVault__ZeroAssets();\n\n        for (uint256 i = 0; i < depositQueue.size(); i++) {\n            DepositQueueLib.DepositEntry memory depositEntry = depositQueue.get(i);\n            if (depositEntry.owner == msg.sender) {\n                depositQueue.remove(i, i + 1);\n                break;\n            }\n        }\n\n        emit DepositRefunded(msg.sender, currentRoundId, assets);\n        _asset.safeTransfer(msg.sender, assets);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function migrate(IVault newVault) external override {\n        if (address(_asset) != newVault.asset() || !configuration.isVaultAllowed(address(newVault))) {\n            revert IVault__MigrationNotAllowed();\n        }\n\n        // Redeem owner assets from this Vault\n        uint256 shares = balanceOf(msg.sender);\n        uint256 assets = redeem(shares, address(this), msg.sender);\n\n        // Deposit assets to `newVault`\n        _asset.safeApprove(address(newVault), assets);\n        newVault.deposit(assets, msg.sender);\n\n        emit Migrated(msg.sender, address(this), address(newVault), assets, shares);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function processQueuedDeposits(uint256 startIndex, uint256 endIndex) external {\n        if (!isProcessingDeposits) revert IVault__NotProcessingDeposits();\n\n        uint256 _totalAssets = totalAssets();\n        for (uint256 i = startIndex; i < endIndex; i++) {\n            uint256 currentAssets = _totalAssets + processedDeposits;\n            DepositQueueLib.DepositEntry memory depositEntry = depositQueue.get(i);\n            _processDeposit(depositEntry, currentAssets);\n            processedDeposits += depositEntry.amount;\n        }\n        depositQueue.remove(startIndex, endIndex);\n    }\n\n    /** Internals **/\n\n    /**\n     * @notice Mint new shares, effectively representing user participation in the Vault.\n     */\n    function _processDeposit(DepositQueueLib.DepositEntry memory depositEntry, uint256 currentAssets) internal virtual {\n        uint256 supply = totalSupply();\n        uint256 assets = depositEntry.amount;\n        uint256 shares = currentAssets == 0 || supply == 0 ? assets : assets.mulDivUp(supply, currentAssets);\n        _mint(depositEntry.owner, shares);\n        emit DepositProcessed(depositEntry.owner, currentRoundId, assets, shares);\n    }\n\n    /**\n     * @notice Calculate the fee amount on withdraw.\n     */\n    function _getFee(uint256 assets) internal view returns (uint256) {\n        return assets.mulDivDown(withdrawFeeRatio(), DENOMINATOR);\n    }\n\n    /**\n     * @dev Pull assets from the caller and create shares to the receiver\n     */\n    function _deposit(\n        uint256 assets,\n        uint256 shares,\n        address receiver\n    ) internal virtual returns (uint256 depositedAssets) {\n        _spendCap(shares);\n\n        depositQueue.push(DepositQueueLib.DepositEntry(receiver, assets));\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n        _asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        return assets;\n    }\n\n    /**\n     * @dev Burn shares from the caller and release assets to the receiver\n     */\n    function _withdraw(\n        uint256 assets,\n        uint256 shares,\n        address receiver,\n        address owner\n    ) internal virtual returns (uint256 receiverAssets, uint256 receiverShares) {\n        if (msg.sender != owner) {\n            _spendAllowance(owner, msg.sender, shares);\n        }\n\n        _burn(owner, shares);\n        _restoreCap(shares);\n\n        // Apply custom withdraw logic\n        _beforeWithdraw(shares, assets);\n\n        uint256 fee = _getFee(assets);\n        receiverAssets = assets - fee;\n        receiverShares = shares;\n\n        emit Withdraw(msg.sender, receiver, owner, receiverAssets, shares);\n        _asset.safeTransfer(receiver, receiverAssets);\n\n        if (fee > 0) {\n            emit FeeCollected(fee);\n            _asset.safeTransfer(controller(), fee);\n        }\n    }\n\n    /** Hooks **/\n\n    // solhint-disable-next-line no-empty-blocks\n    /* This hook should be implemented in the contract implementation.\n        It will trigger after the shares were burned\n    */\n    function _beforeWithdraw(uint256 shares, uint256 assets) internal virtual {}\n\n    // solhint-disable-next-line no-empty-blocks\n    /* This hook should be implemented in the contract implementation.\n        It will trigger after setting isProcessingDeposits to false\n    */\n    function _afterRoundStart(uint256 assets) internal virtual {}\n\n    // solhint-disable-next-line no-empty-blocks\n    /* This hook should be implemented in the contract implementation.\n        It will trigger after setting isProcessingDeposits to true\n    */\n    function _afterRoundEnd() internal virtual {}\n}"
    },
    {
      "filename": "contracts/vaults/BaseVault.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../interfaces/IConfigurationManager.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../libs/AuxMath.sol\";\nimport \"../libs/DepositQueueLib.sol\";\nimport \"../libs/CastUint.sol\";\nimport \"../mixins/Capped.sol\";\n\n/**\n * @title A Vault that tokenize shares of strategy\n * @author Pods Finance\n */\nabstract contract BaseVault is IVault, ERC20Permit, Capped {\n    using SafeERC20 for IERC20Metadata;\n    using AuxMath for uint256;\n    using CastUint for uint256;\n    using DepositQueueLib for DepositQueueLib.DepositQueue;\n\n    IConfigurationManager public immutable configuration;\n    IERC20Metadata internal immutable _asset;\n\n    uint256 public currentRoundId;\n    bool public isProcessingDeposits = false;\n\n    /*\n    DENOMINATOR represents the precision for the following system variables:\n    - MAX_WITHDRAW_FEE\n    - InvestorRatio\n    */\n\n    uint256 public constant DENOMINATOR = 10000;\n    /*\n    MAX_WITDRAW_FEE is a safe check in case the ConfiguratorManager sets\n    a fee high enough that can be used as a way to drain funds. \n    The precision of this number is set by constant DENOMINATOR.\n    */\n    uint256 public constant MAX_WITHDRAW_FEE = 1000;\n    uint256 public constant EMERGENCY_INTERVAL = 604800;\n    uint256 public processedDeposits = 0;\n    uint256 private _lastEndRound;\n\n    DepositQueueLib.DepositQueue internal depositQueue;\n\n    constructor(IConfigurationManager _configuration, IERC20Metadata _asset_)\n        ERC20(\n            string(abi.encodePacked(\"Pods Yield \", _asset_.symbol())),\n            string(abi.encodePacked(\"py\", _asset_.symbol()))\n        )\n        ERC20Permit(string(abi.encodePacked(\"Pods Yield \", _asset_.symbol())))\n        Capped(_configuration)\n    {\n        configuration = _configuration;\n        _asset = _asset_;\n\n        // Vault starts in `start` state\n        emit StartRound(currentRoundId, 0);\n        _lastEndRound = block.timestamp;\n    }\n\n    modifier onlyController() {\n        if (msg.sender != controller()) revert IVault__CallerIsNotTheController();\n        _;\n    }\n\n    modifier onlyRoundStarter() {\n        bool lastRoundEndedAWeekAgo = block.timestamp >= _lastEndRound + EMERGENCY_INTERVAL;\n\n        if (!lastRoundEndedAWeekAgo && msg.sender != controller()) {\n            revert IVault__CallerIsNotTheController();\n        }\n        _;\n    }\n\n    /**\n     * @inheritdoc ERC20\n     */\n    function decimals() public view override returns (uint8) {\n        return _asset.decimals();\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function asset() public view returns (address) {\n        return address(_asset);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function deposit(uint256 assets, address receiver) external virtual override returns (uint256 shares) {\n        if (isProcessingDeposits) revert IVault__ForbiddenWhileProcessingDeposits();\n        shares = previewDeposit(assets);\n\n        if (shares == 0) revert IVault__ZeroShares();\n        _deposit(assets, shares, receiver);\n    }\n\n    function depositWithPermit(\n        uint256 assets,\n        address receiver,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 shares) {\n        if (isProcessingDeposits) revert IVault__ForbiddenWhileProcessingDeposits();\n        shares = previewDeposit(assets);\n\n        if (shares == 0) revert IVault__ZeroShares();\n        IERC20Permit(address(_asset)).permit(msg.sender, address(this), assets, deadline, v, r, s);\n        _deposit(assets, shares, receiver);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function mint(uint256 shares, address receiver) external virtual override returns (uint256 assets) {\n        if (isProcessingDeposits) revert IVault__ForbiddenWhileProcessingDeposits();\n        assets = previewMint(shares);\n        assets = _deposit(assets, shares, receiver);\n    }\n\n    function mintWithPermit(\n        uint256 shares,\n        address receiver,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public returns (uint256 assets) {\n        if (isProcessingDeposits) revert IVault__ForbiddenWhileProcessingDeposits();\n        assets = previewMint(shares);\n        IERC20Permit(address(_asset)).permit(msg.sender, address(this), assets, deadline, v, r, s);\n        assets = _deposit(assets, shares, receiver);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual override returns (uint256 assets) {\n        if (isProcessingDeposits) revert IVault__ForbiddenWhileProcessingDeposits();\n        assets = convertToAssets(shares);\n\n        if (assets == 0) revert IVault__ZeroAssets();\n        (assets, ) = _withdraw(assets, shares, receiver, owner);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external virtual override returns (uint256 shares) {\n        if (isProcessingDeposits) revert IVault__ForbiddenWhileProcessingDeposits();\n        shares = convertToShares(assets);\n        (, shares) = _withdraw(assets, shares, receiver, owner);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function totalAssets() public view virtual returns (uint256);\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function previewDeposit(uint256 assets) public view override returns (uint256 shares) {\n        return convertToShares(assets);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function previewMint(uint256 shares) public view override returns (uint256 assets) {\n        uint256 supply = totalSupply();\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function previewWithdraw(uint256 assets) public view override returns (uint256 shares) {\n        shares = convertToShares(assets);\n        uint256 invertedFee = DENOMINATOR - withdrawFeeRatio();\n        return shares.mulDivUp(DENOMINATOR, invertedFee);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function previewRedeem(uint256 shares) public view override returns (uint256 assets) {\n        assets = convertToAssets(shares);\n        return assets - _getFee(assets);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function convertToShares(uint256 assets) public view override returns (uint256 shares) {\n        uint256 supply = totalSupply();\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function convertToAssets(uint256 shares) public view override returns (uint256 assets) {\n        uint256 supply = totalSupply();\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function maxDeposit(address) public pure override returns (uint256 assets) {\n        return type(uint256).max;\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function maxMint(address) public pure override returns (uint256 shares) {\n        return type(uint256).max;\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function maxWithdraw(address owner) public view override returns (uint256 assets) {\n        return previewRedeem(balanceOf(owner));\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function maxRedeem(address owner) public view override returns (uint256 shares) {\n        return balanceOf(owner);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function withdrawFeeRatio() public view override returns (uint256) {\n        uint256 _withdrawFeeRatio = configuration.getParameter(address(this), \"WITHDRAW_FEE_RATIO\");\n        // Fee is limited to MAX_WITHDRAW_FEE\n        return AuxMath.min(_withdrawFeeRatio, MAX_WITHDRAW_FEE);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function idleAssetsOf(address owner) public view virtual returns (uint256) {\n        return depositQueue.balanceOf(owner);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function assetsOf(address owner) public view virtual returns (uint256) {\n        uint256 supply = totalSupply();\n        uint256 shares = balanceOf(owner);\n        uint256 committedAssets = supply == 0 ? 0 : shares.mulDivDown(_asset.balanceOf(address(this)), supply);\n        return convertToAssets(shares) + idleAssetsOf(owner) + committedAssets;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function totalIdleAssets() public view virtual returns (uint256) {\n        return depositQueue.totalDeposited;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function depositQueueSize() public view returns (uint256) {\n        return depositQueue.size();\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function controller() public view returns (address) {\n        return configuration.getParameter(address(this), \"VAULT_CONTROLLER\").toAddress();\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function startRound() external virtual onlyRoundStarter returns (uint256 roundId) {\n\n        if (!isProcessingDeposits) revert IVault__NotProcessingDeposits();\n\n        isProcessingDeposits = false;\n\n        _afterRoundStart(processedDeposits);\n        emit StartRound(currentRoundId, processedDeposits);\n        processedDeposits = 0;\n\n        return currentRoundId;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function endRound() external virtual onlyController {\n        if (isProcessingDeposits) revert IVault__AlreadyProcessingDeposits();\n\n        isProcessingDeposits = true;\n        _afterRoundEnd();\n        _lastEndRound = block.timestamp;\n\n        emit EndRound(currentRoundId++);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function refund() external returns (uint256 assets) {\n        assets = depositQueue.balanceOf(msg.sender);\n        if (assets == 0) revert IVault__ZeroAssets();\n\n        for (uint256 i = 0; i < depositQueue.size(); i++) {\n            DepositQueueLib.DepositEntry memory depositEntry = depositQueue.get(i);\n            if (depositEntry.owner == msg.sender) {\n                depositQueue.remove(i, i + 1);\n                break;\n            }\n        }\n\n        emit DepositRefunded(msg.sender, currentRoundId, assets);\n        _asset.safeTransfer(msg.sender, assets);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function migrate(IVault newVault) external override {\n        if (address(_asset) != newVault.asset() || !configuration.isVaultAllowed(address(newVault))) {\n            revert IVault__MigrationNotAllowed();\n        }\n\n        // Redeem owner assets from this Vault\n        uint256 shares = balanceOf(msg.sender);\n        uint256 assets = redeem(shares, address(this), msg.sender);\n\n        // Deposit assets to `newVault`\n        _asset.safeApprove(address(newVault), assets);\n        newVault.deposit(assets, msg.sender);\n\n        emit Migrated(msg.sender, address(this), address(newVault), assets, shares);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function processQueuedDeposits(uint256 startIndex, uint256 endIndex) external {\n        if (!isProcessingDeposits) revert IVault__NotProcessingDeposits();\n\n        uint256 _totalAssets = totalAssets();\n        for (uint256 i = startIndex; i < endIndex; i++) {\n            uint256 currentAssets = _totalAssets + processedDeposits;\n            DepositQueueLib.DepositEntry memory depositEntry = depositQueue.get(i);\n            _processDeposit(depositEntry, currentAssets);\n            processedDeposits += depositEntry.amount;\n        }\n        depositQueue.remove(startIndex, endIndex);\n    }\n\n    /** Internals **/\n\n    /**\n     * @notice Mint new shares, effectively representing user participation in the Vault.\n     */\n    function _processDeposit(DepositQueueLib.DepositEntry memory depositEntry, uint256 currentAssets) internal virtual {\n        uint256 supply = totalSupply();\n        uint256 assets = depositEntry.amount;\n        uint256 shares = currentAssets == 0 || supply == 0 ? assets : assets.mulDivUp(supply, currentAssets);\n        _mint(depositEntry.owner, shares);\n        emit DepositProcessed(depositEntry.owner, currentRoundId, assets, shares);\n    }\n\n    /**\n     * @notice Calculate the fee amount on withdraw.\n     */\n    function _getFee(uint256 assets) internal view returns (uint256) {\n        return assets.mulDivDown(withdrawFeeRatio(), DENOMINATOR);\n    }\n\n    /**\n     * @dev Pull assets from the caller and create shares to the receiver\n     */\n    function _deposit(\n        uint256 assets,\n        uint256 shares,\n        address receiver\n    ) internal virtual returns (uint256 depositedAssets) {\n        _spendCap(shares);\n\n        depositQueue.push(DepositQueueLib.DepositEntry(receiver, assets));\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n        _asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        return assets;\n    }\n\n    /**\n     * @dev Burn shares from the caller and release assets to the receiver\n     */\n    function _withdraw(\n        uint256 assets,\n        uint256 shares,\n        address receiver,\n        address owner\n    ) internal virtual returns (uint256 receiverAssets, uint256 receiverShares) {\n        if (msg.sender != owner) {\n            _spendAllowance(owner, msg.sender, shares);\n        }\n\n        _burn(owner, shares);\n        _restoreCap(shares);\n\n        // Apply custom withdraw logic\n        _beforeWithdraw(shares, assets);\n\n        uint256 fee = _getFee(assets);\n        receiverAssets = assets - fee;\n        receiverShares = shares;\n\n        emit Withdraw(msg.sender, receiver, owner, receiverAssets, shares);\n        _asset.safeTransfer(receiver, receiverAssets);\n\n        if (fee > 0) {\n            emit FeeCollected(fee);\n            _asset.safeTransfer(controller(), fee);\n        }\n    }\n\n    /** Hooks **/\n\n    // solhint-disable-next-line no-empty-blocks\n    /* This hook should be implemented in the contract implementation.\n        It will trigger after the shares were burned\n    */\n    function _beforeWithdraw(uint256 shares, uint256 assets) internal virtual {}\n\n    // solhint-disable-next-line no-empty-blocks\n    /* This hook should be implemented in the contract implementation.\n        It will trigger after setting isProcessingDeposits to false\n    */\n    function _afterRoundStart(uint256 assets) internal virtual {}\n\n    // solhint-disable-next-line no-empty-blocks\n    /* This hook should be implemented in the contract implementation.\n        It will trigger after setting isProcessingDeposits to true\n    */\n    function _afterRoundEnd() internal virtual {}\n}"
    }
  ]
}