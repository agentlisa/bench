{
  "Title": "[G-05] Refactor `configToken` function to fail early and `saves 1 external call` on failing",
  "Content": "\nTo refactor the `configToken` function to fail early and save one external call on failing condition. You can move the check for `config.isActive` and the subsequent check for `config.token0TriggerTick >= config.token1TriggerTick` up before the external call to `nonfungiblePositionManager.ownerOf(tokenId)`. This way if any of the conditions fail the function will revert before making the `external call`.\n\n```solidity\nFile : automators/AutoExit.sol\n\n218:    function configToken(uint256 tokenId, PositionConfig calldata config) external {\n219:        address owner = nonfungiblePositionManager.ownerOf(tokenId);\n220:        if (owner != msg.sender) {\n221:            revert Unauthorized();\n222:        }\n223:\n224:        if (config.isActive) {\n225:            if (config.token0TriggerTick >= config.token1TriggerTick) {\n226:                revert InvalidConfig();\n227:            }\n228:        }\n```\n\n[AutoExit.sol#L218-L228](https://github.com/code-423n4/2024-03-revert-lend/blob/main/src/automators/AutoExit.sol#L218-L228)\n\n### Recommended Mitigation Steps\n\n```diff\nFile : automators/AutoExit.sol\n\n218:    function configToken(uint256 tokenId, PositionConfig calldata config) external {\n+224:        if (config.isActive) {\n+225:            if (config.token0TriggerTick >= config.token1TriggerTick) {\n+226:                revert InvalidConfig();\n+227:            }\n+228:        }\n\n219:        address owner = nonfungiblePositionManager.ownerOf(tokenId);\n220:        if (owner != msg.sender) {\n221:            revert Unauthorized();\n222:        }\n223:\n-224:        if (config.isActive) {\n-225:            if (config.token0TriggerTick >= config.token1TriggerTick) {\n-226:                revert InvalidConfig();\n-227:            }\n-228:        }\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-03-revert-lend",
  "Code": [
    {
      "filename": "src/automators/AutoExit.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./Automator.sol\";\n\n/// @title AutoExit\n/// @notice Lets a v3 position to be automatically removed (limit order) or swapped to the opposite token (stop loss order) when it reaches a certain tick.\n/// A revert controlled bot (operator) is responsable for the execution of optimized swaps (using external swap router)\n/// Positions need to be approved (approve or setApprovalForAll) for the contract and configured with configToken method\ncontract AutoExit is Automator {\n    event Executed(\n        uint256 indexed tokenId,\n        address account,\n        bool isSwap,\n        uint256 amountReturned0,\n        uint256 amountReturned1,\n        address token0,\n        address token1\n    );\n    event PositionConfigured(\n        uint256 indexed tokenId,\n        bool isActive,\n        bool token0Swap,\n        bool token1Swap,\n        int24 token0TriggerTick,\n        int24 token1TriggerTick,\n        uint64 token0SlippageX64,\n        uint64 token1SlippageX64,\n        bool onlyFees,\n        uint64 maxRewardX64\n    );\n\n    constructor(\n        INonfungiblePositionManager _npm,\n        address _operator,\n        address _withdrawer,\n        uint32 _TWAPSeconds,\n        uint16 _maxTWAPTickDifference,\n        address _zeroxRouter,\n        address _universalRouter\n    ) Automator(_npm, _operator, _withdrawer, _TWAPSeconds, _maxTWAPTickDifference, _zeroxRouter, _universalRouter) {}\n\n    // define how stoploss / limit should be handled\n    struct PositionConfig {\n        bool isActive; // if position is active\n        // should swap token to other token when triggered\n        bool token0Swap;\n        bool token1Swap;\n        // when should action be triggered (when this tick is reached - allow execute)\n        int24 token0TriggerTick; // when tick is below this one\n        int24 token1TriggerTick; // when tick is equal or above this one\n        // max price difference from current pool price for swap / Q64\n        uint64 token0SlippageX64; // when token 0 is swapped to token 1\n        uint64 token1SlippageX64; // when token 1 is swapped to token 0\n        bool onlyFees; // if only fees maybe used for protocol reward\n        uint64 maxRewardX64; // max allowed reward percentage of fees or full position\n    }\n\n    // configured tokens\n    mapping(uint256 => PositionConfig) public positionConfigs;\n\n    /// @notice params for execute()\n    struct ExecuteParams {\n        uint256 tokenId; // tokenid to process\n        bytes swapData; // if its a swap order - must include swap data\n        uint128 liquidity; // liquidity the calculations are based on\n        uint256 amountRemoveMin0; // min amount to be removed from liquidity\n        uint256 amountRemoveMin1; // min amount to be removed from liquidity\n        uint256 deadline; // for uniswap operations - operator promises fair value\n        uint64 rewardX64; // which reward will be used for protocol, can be max configured amount (considering onlyFees)\n    }\n\n    struct ExecuteState {\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint128 liquidity;\n        uint256 amount0;\n        uint256 amount1;\n        uint256 feeAmount0;\n        uint256 feeAmount1;\n        uint256 amountOutMin;\n        uint256 amountInDelta;\n        uint256 amountOutDelta;\n        IUniswapV3Pool pool;\n        uint256 swapAmount;\n        int24 tick;\n        bool isSwap;\n        bool isAbove;\n        address owner;\n    }\n\n    /**\n     * @notice Handle token (must be in correct state)\n     * Can only be called only from configured operator account\n     * Swap needs to be done with max price difference from current pool price - otherwise reverts\n     */\n    function execute(ExecuteParams calldata params) external {\n        if (!operators[msg.sender]) {\n            revert Unauthorized();\n        }\n\n        ExecuteState memory state;\n        PositionConfig memory config = positionConfigs[params.tokenId];\n\n        if (!config.isActive) {\n            revert NotConfigured();\n        }\n\n        if (\n            config.onlyFees && params.rewardX64 > config.maxRewardX64\n                || !config.onlyFees && params.rewardX64 > config.maxRewardX64\n        ) {\n            revert ExceedsMaxReward();\n        }\n\n        // get position info\n        (,, state.token0, state.token1, state.fee, state.tickLower, state.tickUpper, state.liquidity,,,,) =\n            nonfungiblePositionManager.positions(params.tokenId);\n\n        // so can be executed only once\n        if (state.liquidity == 0) {\n            revert NoLiquidity();\n        }\n        if (state.liquidity != params.liquidity) {\n            revert LiquidityChanged();\n        }\n\n        state.pool = _getPool(state.token0, state.token1, state.fee);\n        (, state.tick,,,,,) = state.pool.slot0();\n\n        // not triggered\n        if (config.token0TriggerTick <= state.tick && state.tick < config.token1TriggerTick) {\n            revert NotReady();\n        }\n\n        state.isAbove = state.tick >= config.token1TriggerTick;\n        state.isSwap = !state.isAbove && config.token0Swap || state.isAbove && config.token1Swap;\n\n        // decrease full liquidity for given position - and return fees as well\n        (state.amount0, state.amount1, state.feeAmount0, state.feeAmount1) = _decreaseFullLiquidityAndCollect(\n            params.tokenId, state.liquidity, params.amountRemoveMin0, params.amountRemoveMin1, params.deadline\n        );\n\n        // swap to other token\n        if (state.isSwap) {\n            if (params.swapData.length == 0) {\n                revert MissingSwapData();\n            }\n\n            // reward is taken before swap - if from fees only\n            if (config.onlyFees) {\n                state.amount0 -= state.feeAmount0 * params.rewardX64 / Q64;\n                state.amount1 -= state.feeAmount1 * params.rewardX64 / Q64;\n            }\n\n            state.swapAmount = state.isAbove ? state.amount1 : state.amount0;\n\n            // checks if price in valid oracle range and calculates amountOutMin\n            (state.amountOutMin,,,) = _validateSwap(\n                !state.isAbove,\n                state.swapAmount,\n                state.pool,\n                TWAPSeconds,\n                maxTWAPTickDifference,\n                state.isAbove ? config.token1SlippageX64 : config.token0SlippageX64\n            );\n\n            (state.amountInDelta, state.amountOutDelta) = _routerSwap(\n                Swapper.RouterSwapParams(\n                    state.isAbove ? IERC20(state.token1) : IERC20(state.token0),\n                    state.isAbove ? IERC20(state.token0) : IERC20(state.token1),\n                    state.swapAmount,\n                    state.amountOutMin,\n                    params.swapData\n                )\n            );\n\n            state.amount0 = state.isAbove ? state.amount0 + state.amountOutDelta : state.amount0 - state.amountInDelta;\n            state.amount1 = state.isAbove ? state.amount1 - state.amountInDelta : state.amount1 + state.amountOutDelta;\n\n            // when swap and !onlyFees - protocol reward is removed only from target token (to incentivize optimal swap done by operator)\n            if (!config.onlyFees) {\n                if (state.isAbove) {\n                    state.amount0 -= state.amount0 * params.rewardX64 / Q64;\n                } else {\n                    state.amount1 -= state.amount1 * params.rewardX64 / Q64;\n                }\n            }\n        } else {\n            // reward is taken as configured\n            state.amount0 -= (config.onlyFees ? state.feeAmount0 : state.amount0) * params.rewardX64 / Q64;\n            state.amount1 -= (config.onlyFees ? state.feeAmount1 : state.amount1) * params.rewardX64 / Q64;\n        }\n\n        state.owner = nonfungiblePositionManager.ownerOf(params.tokenId);\n        if (state.amount0 > 0) {\n            _transferToken(state.owner, IERC20(state.token0), state.amount0, true);\n        }\n        if (state.amount1 > 0) {\n            _transferToken(state.owner, IERC20(state.token1), state.amount1, true);\n        }\n\n        // delete config for position\n        delete positionConfigs[params.tokenId];\n        emit PositionConfigured(params.tokenId, false, false, false, 0, 0, 0, 0, false, 0);\n\n        // log event\n        emit Executed(\n            params.tokenId, msg.sender, state.isSwap, state.amount0, state.amount1, state.token0, state.token1\n        );\n    }\n\n    // function to configure a token to be used with this runner\n    // it needs to have approvals set for this contract beforehand\n    function configToken(uint256 tokenId, PositionConfig calldata config) external {\n        address owner = nonfungiblePositionManager.ownerOf(tokenId);\n        if (owner != msg.sender) {\n            revert Unauthorized();\n        }\n\n        if (config.isActive) {\n            if (config.token0TriggerTick >= config.token1TriggerTick) {\n                revert InvalidConfig();\n            }\n        }\n\n        positionConfigs[tokenId] = config;\n\n        emit PositionConfigured(\n            tokenId,\n            config.isActive,\n            config.token0Swap,\n            config.token1Swap,\n            config.token0TriggerTick,\n            config.token1TriggerTick,\n            config.token0SlippageX64,\n            config.token1SlippageX64,\n            config.onlyFees,\n            config.maxRewardX64\n        );\n    }\n}"
    }
  ]
}