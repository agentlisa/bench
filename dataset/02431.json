{
  "Title": "M-1: The maximum size of an `ICHI` vault spell position can be arbitrarily surpassed",
  "Content": "# Issue M-1: The maximum size of an `ICHI` vault spell position can be arbitrarily surpassed \n\nSource: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/327 \n\n## Found by \nberndartmueller, koxuan, rvierdiiev, rbserver\n\n## Summary\n\nThe maximum size of an `ICHI` vault spell position can be arbitrarily surpassed by subsequent deposits to a position due to a flaw in the `curPosSize` calculation.\n\n## Vulnerability Detail\n\nIchi vault spell positions are subject to a maximum size limit to prevent large positions, ensuring a wide margin for liquidators and bad debt prevention for the protocol.\n\nThe maximum position size is enforced in the `IchiVaultSpell.depositInternal` function and compared to the current position size `curPosSize`.\n\nHowever, the `curPosSize` does not reflect the actual position size, but the amount of Ichi vault LP tokens that are currently held in the `IchiVaultSpell` contract (see [L153](https://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/spell/IchiVaultSpell.sol#L153)).\n\nAssets can be repeatedly deposited into an Ichi vault spell position using the `IchiVaultSpell.openPosition` function (via the `BlueBerryBank.execute` function).\n\nOn the very first deposit, the `curPosSize` correctly reflects the position size. However, on subsequent deposits, the previously received Ichi vault LP tokens are kept in the `BlueBerryBank` contract. Thus, checking the balance of `vault` tokens in the `IchiVaultSpell` contract only accounts for the current deposit.\n\n### Test case\n\nTo demonstrate this issue, please use the following test case:\n\n```diff\ndiff --git a/test/spell/ichivault.spell.test.ts b/test/spell/ichivault.spell.test.ts\nindex 258d653..551a6eb 100644\n--- a/test/spell/ichivault.spell.test.ts\n+++ b/test/spell/ichivault.spell.test.ts\n@@ -163,6 +163,26 @@ describe('ICHI Angel Vaults Spell', () => {\n                                afterTreasuryBalance.sub(beforeTreasuryBalance)\n                        ).to.be.equal(depositAmount.mul(50).div(10000))\n                })\n+               it(\"should revert when exceeds max pos size due to increasing position\", async () => {\n+                       await ichi.approve(bank.address, ethers.constants.MaxUint256);\n+                       await bank.execute(\n+                               0,\n+                               spell.address,\n+                               iface.encodeFunctionData(\"openPosition\", [\n+                                       0, ICHI, USDC, depositAmount.mul(4), borrowAmount.mul(6) // Borrow 1.800e6 USDC\n+                               ])\n+                       );\n+\n+                       await expect(\n+                               bank.execute(\n+                                       0,\n+                                       spell.address,\n+                                       iface.encodeFunctionData(\"openPosition\", [\n+                                               0, ICHI, USDC, depositAmount.mul(1), borrowAmount.mul(2) // Borrow 300e6 USDC\n+                                       ])\n+                               )\n+                       ).to.be.revertedWith(\"EXCEED_MAX_POS_SIZE\"); // 1_800e6 + 300e6 = 2_100e6 > 2_000e6 strategy max position size limit\n+               })\n                it(\"should be able to return position risk ratio\", async () => {\n                        let risk = await bank.getPositionRisk(1);\n                        console.log('Prev Position Risk', utils.formatUnits(risk, 2), '%');\n```\n\nRun the test with the following command:\n\n```bash\nyarn hardhat test --grep \"should revert when exceeds max pos size due to increasing position\"\n```\n\nThe test case fails and therefore shows that the maximum position size can be exceeded **without reverting**.\n\n## Impact\n\nThe maximum position size limit can be exceeded, leading to potential issues with liquidations and bad debt accumulation.\n\n## Code Snippet\n\n[spell/IchiVaultSpell.sol#L152-L156](https://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/spell/IchiVaultSpell.sol#L152-L156)\n\n```solidity\n122: function depositInternal(\n123:     uint256 strategyId,\n124:     address collToken,\n125:     address borrowToken,\n126:     uint256 collAmount,\n127:     uint256 borrowAmount\n128: ) internal {\n...      // [...]\n147:\n148:     // 4. Validate MAX LTV\n149:     _validateMaxLTV(strategyId);\n150:\n151:     // 5. Validate Max Pos Size\n152:     uint256 lpPrice = bank.oracle().getPrice(strategy.vault);\n153:     uint256 curPosSize = (lpPrice * vault.balanceOf(address(this))) /\n154:         10**IICHIVault(strategy.vault).decimals();\n155:     if (curPosSize > strategy.maxPositionSize)\n156:         revert EXCEED_MAX_POS_SIZE(strategyId);\n157: }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider determining the current position size using the `bank.getPositionValue()` function instead of using the current Ichi vault LP token balance.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/41",
  "Code": [
    {
      "filename": "contracts/spell/IchiVaultSpell.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\";\n\nimport \"./BasicSpell.sol\";\nimport \"../utils/BlueBerryConst.sol\";\nimport \"../libraries/UniV3/UniV3WrappedLibMockup.sol\";\nimport \"../interfaces/IOracle.sol\";\nimport \"../interfaces/IWIchiFarm.sol\";\nimport \"../interfaces/ichi/IICHIVault.sol\";\n\ncontract IchiVaultSpell is BasicSpell, IUniswapV3SwapCallback {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    struct Strategy {\n        address vault;\n        uint256 maxPositionSize;\n    }\n\n    /// @dev temperory state used to store uni v3 pool when swapping on uni v3\n    IUniswapV3Pool private swapPool;\n\n    /// @dev strategyId => ichi vault\n    Strategy[] public strategies;\n    /// @dev strategyId => collateral token => maxLTV\n    mapping(uint256 => mapping(address => uint256)) public maxLTV; // base 1e4\n    /// @dev address of ICHI farm wrapper\n    IWIchiFarm public wIchiFarm;\n    /// @dev address of ICHI token\n    address public ICHI;\n\n    event StrategyAdded(uint256 strategyId, address vault, uint256 maxPosSize);\n    event CollateralsSupportAdded(\n        uint256 strategyId,\n        address[] collaterals,\n        uint256[] maxLTVs\n    );\n\n    modifier existingStrategy(uint256 strategyId) {\n        if (strategyId >= strategies.length)\n            revert STRATEGY_NOT_EXIST(address(this), strategyId);\n\n        _;\n    }\n\n    modifier existingCollateral(uint256 strategyId, address col) {\n        if (maxLTV[strategyId][col] == 0)\n            revert COLLATERAL_NOT_EXIST(strategyId, col);\n\n        _;\n    }\n\n    function initialize(\n        IBank _bank,\n        address _werc20,\n        address _weth,\n        address _wichiFarm\n    ) external initializer {\n        __BasicSpell_init(_bank, _werc20, _weth);\n\n        wIchiFarm = IWIchiFarm(_wichiFarm);\n        ICHI = address(wIchiFarm.ICHI());\n        IWIchiFarm(_wichiFarm).setApprovalForAll(address(_bank), true);\n    }\n\n    /**\n     * @notice Owner privileged function to add vault\n     * @param vault Address of ICHI angel vault\n     * @param maxPosSize, USD price based maximum size of a position for given vault, based 1e18\n     */\n    function addStrategy(address vault, uint256 maxPosSize) external onlyOwner {\n        if (vault == address(0)) revert ZERO_ADDRESS();\n        if (maxPosSize == 0) revert ZERO_AMOUNT();\n        strategies.push(Strategy({vault: vault, maxPositionSize: maxPosSize}));\n        emit StrategyAdded(strategies.length - 1, vault, maxPosSize);\n    }\n\n    function addCollateralsSupport(\n        uint256 strategyId,\n        address[] memory collaterals,\n        uint256[] memory maxLTVs\n    ) external existingStrategy(strategyId) onlyOwner {\n        if (collaterals.length != maxLTVs.length || collaterals.length == 0)\n            revert INPUT_ARRAY_MISMATCH();\n\n        for (uint256 i = 0; i < collaterals.length; i++) {\n            if (collaterals[i] == address(0)) revert ZERO_ADDRESS();\n            if (maxLTVs[i] == 0) revert ZERO_AMOUNT();\n            maxLTV[strategyId][collaterals[i]] = maxLTVs[i];\n        }\n\n        emit CollateralsSupportAdded(strategyId, collaterals, maxLTVs);\n    }\n\n    function _validateMaxLTV(uint256 strategyId) internal view {\n        uint256 debtValue = bank.getDebtValue(bank.POSITION_ID());\n        (, address collToken, uint256 collAmount, , , , , ) = bank\n            .getCurrentPositionInfo();\n        uint256 collPrice = bank.oracle().getPrice(collToken);\n        uint256 collValue = (collPrice * collAmount) /\n            10**IERC20Metadata(collToken).decimals();\n\n        if (\n            debtValue >\n            (collValue * maxLTV[strategyId][collToken]) / DENOMINATOR\n        ) revert EXCEED_MAX_LTV();\n    }\n\n    /**\n     * @notice Internal function to deposit assets on ICHI Vault\n     * @param collToken Isolated collateral token address\n     * @param collAmount Amount of isolated collateral\n     * @param borrowToken Token address to borrow\n     * @param borrowAmount amount to borrow from Bank\n     */\n    function depositInternal(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 collAmount,\n        uint256 borrowAmount\n    ) internal {\n        Strategy memory strategy = strategies[strategyId];\n\n        // 1. Lend isolated collaterals on compound\n        doLend(collToken, collAmount);\n\n        // 2. Borrow specific amounts\n        doBorrow(borrowToken, borrowAmount);\n\n        // 3. Add liquidity - Deposit on ICHI Vault\n        IICHIVault vault = IICHIVault(strategy.vault);\n        bool isTokenA = vault.token0() == borrowToken;\n        uint256 balance = IERC20(borrowToken).balanceOf(address(this));\n        ensureApprove(borrowToken, address(vault));\n        if (isTokenA) {\n            vault.deposit(balance, 0, address(this));\n        } else {\n            vault.deposit(0, balance, address(this));\n        }\n\n        // 4. Validate MAX LTV\n        _validateMaxLTV(strategyId);\n\n        // 5. Validate Max Pos Size\n        uint256 lpPrice = bank.oracle().getPrice(strategy.vault);\n        uint256 curPosSize = (lpPrice * vault.balanceOf(address(this))) /\n            10**IICHIVault(strategy.vault).decimals();\n        if (curPosSize > strategy.maxPositionSize)\n            revert EXCEED_MAX_POS_SIZE(strategyId);\n    }\n\n    /**\n     * @notice External function to deposit assets on IchiVault\n     * @param collToken Collateral Token address to deposit (e.g USDC)\n     * @param collAmount Amount of user's collateral (e.g USDC)\n     * @param borrowToken Address of token to borrow\n     * @param borrowAmount Amount to borrow from Bank\n     */\n    function openPosition(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 collAmount,\n        uint256 borrowAmount\n    )\n        external\n        existingStrategy(strategyId)\n        existingCollateral(strategyId, collToken)\n    {\n        // 1-3 Deposit on ichi vault\n        depositInternal(\n            strategyId,\n            collToken,\n            borrowToken,\n            collAmount,\n            borrowAmount\n        );\n\n        // 4. Put collateral - ICHI Vault Lp Token\n        address vault = strategies[strategyId].vault;\n        doPutCollateral(vault, IERC20(vault).balanceOf(address(this)));\n    }\n\n    /**\n     * @notice External function to deposit assets on IchiVault and farm in Ichi Farm\n     * @param collToken Collateral Token address to deposit (e.g USDC)\n     * @param collAmount Amount of user's collateral (e.g USDC)\n     * @param borrowToken Address of token to borrow\n     * @param borrowAmount Amount to borrow from Bank\n     * @param farmingPid Pool Id of vault lp on ICHI Farm\n     */\n    function openPositionFarm(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 collAmount,\n        uint256 borrowAmount,\n        uint256 farmingPid\n    )\n        external\n        existingStrategy(strategyId)\n        existingCollateral(strategyId, collToken)\n    {\n        Strategy memory strategy = strategies[strategyId];\n        address lpToken = wIchiFarm.ichiFarm().lpToken(farmingPid);\n        if (strategy.vault != lpToken) revert INCORRECT_LP(lpToken);\n\n        // 1-3 Deposit on ichi vault\n        depositInternal(\n            strategyId,\n            collToken,\n            borrowToken,\n            collAmount,\n            borrowAmount\n        );\n\n        // 4. Take out collateral\n        (\n            ,\n            ,\n            ,\n            ,\n            address posCollToken,\n            uint256 collId,\n            uint256 collSize,\n\n        ) = bank.getCurrentPositionInfo();\n        if (collSize > 0) {\n            (uint256 decodedPid, ) = wIchiFarm.decodeId(collId);\n            if (farmingPid != decodedPid) revert INCORRECT_PID(farmingPid);\n            if (posCollToken != address(wIchiFarm))\n                revert INCORRECT_COLTOKEN(posCollToken);\n            bank.takeCollateral(collSize);\n            wIchiFarm.burn(collId, collSize);\n        }\n\n        // 5. Deposit on farming pool, put collateral\n        ensureApprove(strategy.vault, address(wIchiFarm));\n        uint256 lpAmount = IERC20(strategy.vault).balanceOf(address(this));\n        uint256 id = wIchiFarm.mint(farmingPid, lpAmount);\n        bank.putCollateral(address(wIchiFarm), id, lpAmount);\n    }\n\n    /**\n     * @dev Increase isolated collateral of position\n     * @param token Isolated collateral token address\n     * @param amount Amount of token to increase position\n     */\n    function increasePosition(address token, uint256 amount) external {\n        // 1. Get user input amounts\n        doLend(token, amount);\n    }\n\n    /**\n     * @dev Reduce isolated collateral of position\n     * @param collToken Isolated collateral token address\n     * @param collAmount Amount of Isolated collateral\n     */\n    function reducePosition(\n        uint256 strategyId,\n        address collToken,\n        uint256 collAmount\n    ) external {\n        doWithdraw(collToken, collAmount);\n        doRefund(collToken);\n        _validateMaxLTV(strategyId);\n    }\n\n    function withdrawInternal(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 amountRepay,\n        uint256 amountLpWithdraw,\n        uint256 amountShareWithdraw\n    ) internal {\n        Strategy memory strategy = strategies[strategyId];\n        IICHIVault vault = IICHIVault(strategy.vault);\n        uint256 positionId = bank.POSITION_ID();\n\n        // 1. Compute repay amount if MAX_INT is supplied (max debt)\n        if (amountRepay == type(uint256).max) {\n            amountRepay = bank.borrowBalanceCurrent(positionId, borrowToken);\n        }\n\n        // 2. Calculate actual amount to remove\n        uint256 amtLPToRemove = vault.balanceOf(address(this)) -\n            amountLpWithdraw;\n\n        // 3. Withdraw liquidity from ICHI vault\n        vault.withdraw(amtLPToRemove, address(this));\n\n        // 4. Swap withdrawn tokens to initial deposit token\n        bool isTokenA = vault.token0() == borrowToken;\n        uint256 amountToSwap = IERC20(\n            isTokenA ? vault.token1() : vault.token0()\n        ).balanceOf(address(this));\n        if (amountToSwap > 0) {\n            swapPool = IUniswapV3Pool(vault.pool());\n            swapPool.swap(\n                address(this),\n                // if withdraw token is Token0, then swap token1 -> token0 (false)\n                !isTokenA,\n                int256(amountToSwap),\n                isTokenA\n                    ? UniV3WrappedLibMockup.MAX_SQRT_RATIO - 1 // Token0 -> Token1\n                    : UniV3WrappedLibMockup.MIN_SQRT_RATIO + 1, // Token1 -> Token0\n                abi.encode(address(this))\n            );\n        }\n\n        // 5. Withdraw isolated collateral from Bank\n        doWithdraw(collToken, amountShareWithdraw);\n\n        // 6. Repay\n        doRepay(borrowToken, amountRepay);\n\n        _validateMaxLTV(strategyId);\n\n        // 7. Refund\n        doRefund(borrowToken);\n        doRefund(collToken);\n    }\n\n    /**\n     * @notice External function to withdraw assets from ICHI Vault\n     * @param collToken Token address to withdraw (e.g USDC)\n     * @param borrowToken Token address to withdraw (e.g USDC)\n     * @param lpTakeAmt Amount of ICHI Vault LP token to take out from Bank\n     * @param amountRepay Amount to repay the loan\n     * @param amountLpWithdraw Amount of ICHI Vault LP to withdraw from ICHI Vault\n     * @param amountShareWithdraw Amount of Isolated collateral to withdraw from Compound\n     */\n    function closePosition(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 lpTakeAmt,\n        uint256 amountRepay,\n        uint256 amountLpWithdraw,\n        uint256 amountShareWithdraw\n    )\n        external\n        existingStrategy(strategyId)\n        existingCollateral(strategyId, collToken)\n    {\n        // 1. Take out collateral\n        doTakeCollateral(strategies[strategyId].vault, lpTakeAmt);\n\n        withdrawInternal(\n            strategyId,\n            collToken,\n            borrowToken,\n            amountRepay,\n            amountLpWithdraw,\n            amountShareWithdraw\n        );\n    }\n\n    function closePositionFarm(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 lpTakeAmt,\n        uint256 amountRepay,\n        uint256 amountLpWithdraw,\n        uint256 amountShareWithdraw\n    )\n        external\n        existingStrategy(strategyId)\n        existingCollateral(strategyId, collToken)\n    {\n        address vault = strategies[strategyId].vault;\n        (, , , , address posCollToken, uint256 collId, , ) = bank\n            .getCurrentPositionInfo();\n        if (IWIchiFarm(posCollToken).getUnderlyingToken(collId) != vault)\n            revert INCORRECT_UNDERLYING(vault);\n        if (posCollToken != address(wIchiFarm))\n            revert INCORRECT_COLTOKEN(posCollToken);\n\n        // 1. Take out collateral\n        bank.takeCollateral(lpTakeAmt);\n        wIchiFarm.burn(collId, lpTakeAmt);\n        doCutRewardsFee(ICHI);\n\n        // 2-8. Remove liquidity\n        withdrawInternal(\n            strategyId,\n            collToken,\n            borrowToken,\n            amountRepay,\n            amountLpWithdraw,\n            amountShareWithdraw\n        );\n\n        // 9. Refund ichi token\n        doRefund(ICHI);\n    }\n\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external override {\n        if (msg.sender != address(swapPool)) revert NOT_FROM_UNIV3(msg.sender);\n        address payer = abi.decode(data, (address));\n\n        if (amount0Delta > 0) {\n            if (payer == address(this)) {\n                IERC20Upgradeable(swapPool.token0()).safeTransfer(\n                    msg.sender,\n                    uint256(amount0Delta)\n                );\n            } else {\n                IERC20Upgradeable(swapPool.token0()).safeTransferFrom(\n                    payer,\n                    msg.sender,\n                    uint256(amount0Delta)\n                );\n            }\n        } else if (amount1Delta > 0) {\n            if (payer == address(this)) {\n                IERC20Upgradeable(swapPool.token1()).safeTransfer(\n                    msg.sender,\n                    uint256(amount1Delta)\n                );\n            } else {\n                IERC20Upgradeable(swapPool.token1()).safeTransferFrom(\n                    payer,\n                    msg.sender,\n                    uint256(amount1Delta)\n                );\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/spell/IchiVaultSpell.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\";\n\nimport \"./BasicSpell.sol\";\nimport \"../utils/BlueBerryConst.sol\";\nimport \"../libraries/UniV3/UniV3WrappedLibMockup.sol\";\nimport \"../interfaces/IOracle.sol\";\nimport \"../interfaces/IWIchiFarm.sol\";\nimport \"../interfaces/ichi/IICHIVault.sol\";\n\ncontract IchiVaultSpell is BasicSpell, IUniswapV3SwapCallback {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    struct Strategy {\n        address vault;\n        uint256 maxPositionSize;\n    }\n\n    /// @dev temperory state used to store uni v3 pool when swapping on uni v3\n    IUniswapV3Pool private swapPool;\n\n    /// @dev strategyId => ichi vault\n    Strategy[] public strategies;\n    /// @dev strategyId => collateral token => maxLTV\n    mapping(uint256 => mapping(address => uint256)) public maxLTV; // base 1e4\n    /// @dev address of ICHI farm wrapper\n    IWIchiFarm public wIchiFarm;\n    /// @dev address of ICHI token\n    address public ICHI;\n\n    event StrategyAdded(uint256 strategyId, address vault, uint256 maxPosSize);\n    event CollateralsSupportAdded(\n        uint256 strategyId,\n        address[] collaterals,\n        uint256[] maxLTVs\n    );\n\n    modifier existingStrategy(uint256 strategyId) {\n        if (strategyId >= strategies.length)\n            revert STRATEGY_NOT_EXIST(address(this), strategyId);\n\n        _;\n    }\n\n    modifier existingCollateral(uint256 strategyId, address col) {\n        if (maxLTV[strategyId][col] == 0)\n            revert COLLATERAL_NOT_EXIST(strategyId, col);\n\n        _;\n    }\n\n    function initialize(\n        IBank _bank,\n        address _werc20,\n        address _weth,\n        address _wichiFarm\n    ) external initializer {\n        __BasicSpell_init(_bank, _werc20, _weth);\n\n        wIchiFarm = IWIchiFarm(_wichiFarm);\n        ICHI = address(wIchiFarm.ICHI());\n        IWIchiFarm(_wichiFarm).setApprovalForAll(address(_bank), true);\n    }\n\n    /**\n     * @notice Owner privileged function to add vault\n     * @param vault Address of ICHI angel vault\n     * @param maxPosSize, USD price based maximum size of a position for given vault, based 1e18\n     */\n    function addStrategy(address vault, uint256 maxPosSize) external onlyOwner {\n        if (vault == address(0)) revert ZERO_ADDRESS();\n        if (maxPosSize == 0) revert ZERO_AMOUNT();\n        strategies.push(Strategy({vault: vault, maxPositionSize: maxPosSize}));\n        emit StrategyAdded(strategies.length - 1, vault, maxPosSize);\n    }\n\n    function addCollateralsSupport(\n        uint256 strategyId,\n        address[] memory collaterals,\n        uint256[] memory maxLTVs\n    ) external existingStrategy(strategyId) onlyOwner {\n        if (collaterals.length != maxLTVs.length || collaterals.length == 0)\n            revert INPUT_ARRAY_MISMATCH();\n\n        for (uint256 i = 0; i < collaterals.length; i++) {\n            if (collaterals[i] == address(0)) revert ZERO_ADDRESS();\n            if (maxLTVs[i] == 0) revert ZERO_AMOUNT();\n            maxLTV[strategyId][collaterals[i]] = maxLTVs[i];\n        }\n\n        emit CollateralsSupportAdded(strategyId, collaterals, maxLTVs);\n    }\n\n    function _validateMaxLTV(uint256 strategyId) internal view {\n        uint256 debtValue = bank.getDebtValue(bank.POSITION_ID());\n        (, address collToken, uint256 collAmount, , , , , ) = bank\n            .getCurrentPositionInfo();\n        uint256 collPrice = bank.oracle().getPrice(collToken);\n        uint256 collValue = (collPrice * collAmount) /\n            10**IERC20Metadata(collToken).decimals();\n\n        if (\n            debtValue >\n            (collValue * maxLTV[strategyId][collToken]) / DENOMINATOR\n        ) revert EXCEED_MAX_LTV();\n    }\n\n    /**\n     * @notice Internal function to deposit assets on ICHI Vault\n     * @param collToken Isolated collateral token address\n     * @param collAmount Amount of isolated collateral\n     * @param borrowToken Token address to borrow\n     * @param borrowAmount amount to borrow from Bank\n     */\n    function depositInternal(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 collAmount,\n        uint256 borrowAmount\n    ) internal {\n        Strategy memory strategy = strategies[strategyId];\n\n        // 1. Lend isolated collaterals on compound\n        doLend(collToken, collAmount);\n\n        // 2. Borrow specific amounts\n        doBorrow(borrowToken, borrowAmount);\n\n        // 3. Add liquidity - Deposit on ICHI Vault\n        IICHIVault vault = IICHIVault(strategy.vault);\n        bool isTokenA = vault.token0() == borrowToken;\n        uint256 balance = IERC20(borrowToken).balanceOf(address(this));\n        ensureApprove(borrowToken, address(vault));\n        if (isTokenA) {\n            vault.deposit(balance, 0, address(this));\n        } else {\n            vault.deposit(0, balance, address(this));\n        }\n\n        // 4. Validate MAX LTV\n        _validateMaxLTV(strategyId);\n\n        // 5. Validate Max Pos Size\n        uint256 lpPrice = bank.oracle().getPrice(strategy.vault);\n        uint256 curPosSize = (lpPrice * vault.balanceOf(address(this))) /\n            10**IICHIVault(strategy.vault).decimals();\n        if (curPosSize > strategy.maxPositionSize)\n            revert EXCEED_MAX_POS_SIZE(strategyId);\n    }\n\n    /**\n     * @notice External function to deposit assets on IchiVault\n     * @param collToken Collateral Token address to deposit (e.g USDC)\n     * @param collAmount Amount of user's collateral (e.g USDC)\n     * @param borrowToken Address of token to borrow\n     * @param borrowAmount Amount to borrow from Bank\n     */\n    function openPosition(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 collAmount,\n        uint256 borrowAmount\n    )\n        external\n        existingStrategy(strategyId)\n        existingCollateral(strategyId, collToken)\n    {\n        // 1-3 Deposit on ichi vault\n        depositInternal(\n            strategyId,\n            collToken,\n            borrowToken,\n            collAmount,\n            borrowAmount\n        );\n\n        // 4. Put collateral - ICHI Vault Lp Token\n        address vault = strategies[strategyId].vault;\n        doPutCollateral(vault, IERC20(vault).balanceOf(address(this)));\n    }\n\n    /**\n     * @notice External function to deposit assets on IchiVault and farm in Ichi Farm\n     * @param collToken Collateral Token address to deposit (e.g USDC)\n     * @param collAmount Amount of user's collateral (e.g USDC)\n     * @param borrowToken Address of token to borrow\n     * @param borrowAmount Amount to borrow from Bank\n     * @param farmingPid Pool Id of vault lp on ICHI Farm\n     */\n    function openPositionFarm(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 collAmount,\n        uint256 borrowAmount,\n        uint256 farmingPid\n    )\n        external\n        existingStrategy(strategyId)\n        existingCollateral(strategyId, collToken)\n    {\n        Strategy memory strategy = strategies[strategyId];\n        address lpToken = wIchiFarm.ichiFarm().lpToken(farmingPid);\n        if (strategy.vault != lpToken) revert INCORRECT_LP(lpToken);\n\n        // 1-3 Deposit on ichi vault\n        depositInternal(\n            strategyId,\n            collToken,\n            borrowToken,\n            collAmount,\n            borrowAmount\n        );\n\n        // 4. Take out collateral\n        (\n            ,\n            ,\n            ,\n            ,\n            address posCollToken,\n            uint256 collId,\n            uint256 collSize,\n\n        ) = bank.getCurrentPositionInfo();\n        if (collSize > 0) {\n            (uint256 decodedPid, ) = wIchiFarm.decodeId(collId);\n            if (farmingPid != decodedPid) revert INCORRECT_PID(farmingPid);\n            if (posCollToken != address(wIchiFarm))\n                revert INCORRECT_COLTOKEN(posCollToken);\n            bank.takeCollateral(collSize);\n            wIchiFarm.burn(collId, collSize);\n        }\n\n        // 5. Deposit on farming pool, put collateral\n        ensureApprove(strategy.vault, address(wIchiFarm));\n        uint256 lpAmount = IERC20(strategy.vault).balanceOf(address(this));\n        uint256 id = wIchiFarm.mint(farmingPid, lpAmount);\n        bank.putCollateral(address(wIchiFarm), id, lpAmount);\n    }\n\n    /**\n     * @dev Increase isolated collateral of position\n     * @param token Isolated collateral token address\n     * @param amount Amount of token to increase position\n     */\n    function increasePosition(address token, uint256 amount) external {\n        // 1. Get user input amounts\n        doLend(token, amount);\n    }\n\n    /**\n     * @dev Reduce isolated collateral of position\n     * @param collToken Isolated collateral token address\n     * @param collAmount Amount of Isolated collateral\n     */\n    function reducePosition(\n        uint256 strategyId,\n        address collToken,\n        uint256 collAmount\n    ) external {\n        doWithdraw(collToken, collAmount);\n        doRefund(collToken);\n        _validateMaxLTV(strategyId);\n    }\n\n    function withdrawInternal(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 amountRepay,\n        uint256 amountLpWithdraw,\n        uint256 amountShareWithdraw\n    ) internal {\n        Strategy memory strategy = strategies[strategyId];\n        IICHIVault vault = IICHIVault(strategy.vault);\n        uint256 positionId = bank.POSITION_ID();\n\n        // 1. Compute repay amount if MAX_INT is supplied (max debt)\n        if (amountRepay == type(uint256).max) {\n            amountRepay = bank.borrowBalanceCurrent(positionId, borrowToken);\n        }\n\n        // 2. Calculate actual amount to remove\n        uint256 amtLPToRemove = vault.balanceOf(address(this)) -\n            amountLpWithdraw;\n\n        // 3. Withdraw liquidity from ICHI vault\n        vault.withdraw(amtLPToRemove, address(this));\n\n        // 4. Swap withdrawn tokens to initial deposit token\n        bool isTokenA = vault.token0() == borrowToken;\n        uint256 amountToSwap = IERC20(\n            isTokenA ? vault.token1() : vault.token0()\n        ).balanceOf(address(this));\n        if (amountToSwap > 0) {\n            swapPool = IUniswapV3Pool(vault.pool());\n            swapPool.swap(\n                address(this),\n                // if withdraw token is Token0, then swap token1 -> token0 (false)\n                !isTokenA,\n                int256(amountToSwap),\n                isTokenA\n                    ? UniV3WrappedLibMockup.MAX_SQRT_RATIO - 1 // Token0 -> Token1\n                    : UniV3WrappedLibMockup.MIN_SQRT_RATIO + 1, // Token1 -> Token0\n                abi.encode(address(this))\n            );\n        }\n\n        // 5. Withdraw isolated collateral from Bank\n        doWithdraw(collToken, amountShareWithdraw);\n\n        // 6. Repay\n        doRepay(borrowToken, amountRepay);\n\n        _validateMaxLTV(strategyId);\n\n        // 7. Refund\n        doRefund(borrowToken);\n        doRefund(collToken);\n    }\n\n    /**\n     * @notice External function to withdraw assets from ICHI Vault\n     * @param collToken Token address to withdraw (e.g USDC)\n     * @param borrowToken Token address to withdraw (e.g USDC)\n     * @param lpTakeAmt Amount of ICHI Vault LP token to take out from Bank\n     * @param amountRepay Amount to repay the loan\n     * @param amountLpWithdraw Amount of ICHI Vault LP to withdraw from ICHI Vault\n     * @param amountShareWithdraw Amount of Isolated collateral to withdraw from Compound\n     */\n    function closePosition(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 lpTakeAmt,\n        uint256 amountRepay,\n        uint256 amountLpWithdraw,\n        uint256 amountShareWithdraw\n    )\n        external\n        existingStrategy(strategyId)\n        existingCollateral(strategyId, collToken)\n    {\n        // 1. Take out collateral\n        doTakeCollateral(strategies[strategyId].vault, lpTakeAmt);\n\n        withdrawInternal(\n            strategyId,\n            collToken,\n            borrowToken,\n            amountRepay,\n            amountLpWithdraw,\n            amountShareWithdraw\n        );\n    }\n\n    function closePositionFarm(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 lpTakeAmt,\n        uint256 amountRepay,\n        uint256 amountLpWithdraw,\n        uint256 amountShareWithdraw\n    )\n        external\n        existingStrategy(strategyId)\n        existingCollateral(strategyId, collToken)\n    {\n        address vault = strategies[strategyId].vault;\n        (, , , , address posCollToken, uint256 collId, , ) = bank\n            .getCurrentPositionInfo();\n        if (IWIchiFarm(posCollToken).getUnderlyingToken(collId) != vault)\n            revert INCORRECT_UNDERLYING(vault);\n        if (posCollToken != address(wIchiFarm))\n            revert INCORRECT_COLTOKEN(posCollToken);\n\n        // 1. Take out collateral\n        bank.takeCollateral(lpTakeAmt);\n        wIchiFarm.burn(collId, lpTakeAmt);\n        doCutRewardsFee(ICHI);\n\n        // 2-8. Remove liquidity\n        withdrawInternal(\n            strategyId,\n            collToken,\n            borrowToken,\n            amountRepay,\n            amountLpWithdraw,\n            amountShareWithdraw\n        );\n\n        // 9. Refund ichi token\n        doRefund(ICHI);\n    }\n\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external override {\n        if (msg.sender != address(swapPool)) revert NOT_FROM_UNIV3(msg.sender);\n        address payer = abi.decode(data, (address));\n\n        if (amount0Delta > 0) {\n            if (payer == address(this)) {\n                IERC20Upgradeable(swapPool.token0()).safeTransfer(\n                    msg.sender,\n                    uint256(amount0Delta)\n                );\n            } else {\n                IERC20Upgradeable(swapPool.token0()).safeTransferFrom(\n                    payer,\n                    msg.sender,\n                    uint256(amount0Delta)\n                );\n            }\n        } else if (amount1Delta > 0) {\n            if (payer == address(this)) {\n                IERC20Upgradeable(swapPool.token1()).safeTransfer(\n                    msg.sender,\n                    uint256(amount1Delta)\n                );\n            } else {\n                IERC20Upgradeable(swapPool.token1()).safeTransferFrom(\n                    payer,\n                    msg.sender,\n                    uint256(amount1Delta)\n                );\n            }\n        }\n    }\n}"
    }
  ]
}