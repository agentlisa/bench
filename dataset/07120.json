{
  "Title": "[M-06] Division before multiplication incurs unnecessary precision loss",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2023-01-numoen/blob/2ad9a73d793ea23a25a381faadc86ae0c8cb5913/src/core/Pair.sol#L56\nhttps://github.com/code-423n4/2023-01-numoen/blob/2ad9a73d793ea23a25a381faadc86ae0c8cb5913/src/core/Pair.sol#L57\nhttps://github.com/code-423n4/2023-01-numoen/blob/2ad9a73d793ea23a25a381faadc86ae0c8cb5913/src/core/Lendgine.sol#L252\n\n\n# Vulnerability details\n\n## Impact\n\nDivision before multipilication incurs uncessary precision loss\n\n## Proof of Concept\n\nIn the current codebase, FullMath.mulDiv is used, the function takes three parameter, \n\nbasically FullMath.mulDIv(a, b, c) means a * b / c\n\nThen there are some operation which that incurs unnecessary precision loss because of division before multiplcation.\n\nWhen accuring interest, the code belows:\n\n```solidity\n  /// @notice Helper function for accruing lendgine interest\n  function _accrueInterest() private {\n    if (totalSupply == 0 || totalLiquidityBorrowed == 0) {\n      lastUpdate = block.timestamp;\n      return;\n    }\n\n    uint256 timeElapsed = block.timestamp - lastUpdate;\n    if (timeElapsed == 0) return;\n\n    uint256 _totalLiquidityBorrowed = totalLiquidityBorrowed; // SLOAD\n    uint256 totalLiquiditySupplied = totalLiquidity + _totalLiquidityBorrowed; // SLOAD\n\n    uint256 borrowRate = getBorrowRate(_totalLiquidityBorrowed, totalLiquiditySupplied);\n\n    uint256 dilutionLPRequested = (FullMath.mulDiv(borrowRate, _totalLiquidityBorrowed, 1e18) * timeElapsed) / 365 days;\n    uint256 dilutionLP = dilutionLPRequested > _totalLiquidityBorrowed ? _totalLiquidityBorrowed : dilutionLPRequested;\n    uint256 dilutionSpeculative = convertLiquidityToCollateral(dilutionLP);\n\n    totalLiquidityBorrowed = _totalLiquidityBorrowed - dilutionLP;\n    rewardPerPositionStored += FullMath.mulDiv(dilutionSpeculative, 1e18, totalPositionSize);\n    lastUpdate = block.timestamp;\n\n    emit AccrueInterest(timeElapsed, dilutionSpeculative, dilutionLP);\n  }\n```\n\nnote the line:\n\n```solidity\n uint256 dilutionLPRequested = (FullMath.mulDiv(borrowRate, _totalLiquidityBorrowed, 1e18) * timeElapsed) / 365 days;\n```\n\nThis basically equals to dilutionLPRequested = (borrowRate * totalLiquidityBorrowed / 1e18 * timeElapsed) / 365 days\n\nthe first part of division can greatly truncate the value borrowRate * totalLiquidityBorrowed / 1e18, the totalLiquidityBorrowed should normalized and scaled by token preciision when adding liqudiity instead of division by 1e18 here.\n\nSame preicision loss happens when computng the invariant\n\n```solidity\n  /// @inheritdoc IPair\n  function invariant(uint256 amount0, uint256 amount1, uint256 liquidity) public view override returns (bool) {\n    if (liquidity == 0) return (amount0 == 0 && amount1 == 0);\n\n    uint256 scale0 = FullMath.mulDiv(amount0, 1e18, liquidity) * token0Scale;\n    uint256 scale1 = FullMath.mulDiv(amount1, 1e18, liquidity) * token1Scale;\n```\n\nscale0 = (amount0 * 1e18 / liqudiity) * token0Scale\nscale1 = (amount1 * 1e18 / liqudiity) * token1Scale\n\nwhereas the amount0 and amount1 should be first be normalized by token0Scale and token1Scale and then divided by liquidity at last. If the liquidity is a larger number  amount0 * 1e18 / liqudiity is already truncated to 0.\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\nWe recommend the protocol avoid divison before multiplication and always perform division operation at last.",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-01-numoen-contest",
  "Code": [
    {
      "filename": "src/core/Pair.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.4;\n\nimport { ImmutableState } from \"./ImmutableState.sol\";\nimport { ReentrancyGuard } from \"./ReentrancyGuard.sol\";\n\nimport { IPair } from \"./interfaces/IPair.sol\";\nimport { IPairMintCallback } from \"./interfaces/callback/IPairMintCallback.sol\";\nimport { ISwapCallback } from \"./interfaces/callback/ISwapCallback.sol\";\n\nimport { Balance } from \"../libraries/Balance.sol\";\nimport { FullMath } from \"../libraries/FullMath.sol\";\nimport { SafeCast } from \"../libraries/SafeCast.sol\";\nimport { SafeTransferLib } from \"../libraries/SafeTransferLib.sol\";\n\nabstract contract Pair is ImmutableState, ReentrancyGuard, IPair {\n  /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n  event Mint(uint256 amount0In, uint256 amount1In, uint256 liquidity);\n\n  event Burn(uint256 amount0Out, uint256 amount1Out, uint256 liquidity, address indexed to);\n\n  event Swap(uint256 amount0Out, uint256 amount1Out, uint256 amount0In, uint256 amount1In, address indexed to);\n\n  /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n  error InvariantError();\n\n  error InsufficientOutputError();\n\n  /*//////////////////////////////////////////////////////////////\n                                 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n  /// @inheritdoc IPair\n  uint120 public override reserve0;\n\n  /// @inheritdoc IPair\n  uint120 public override reserve1;\n\n  /// @inheritdoc IPair\n  uint256 public override totalLiquidity;\n\n  /*//////////////////////////////////////////////////////////////\n                              PAIR LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /// @inheritdoc IPair\n  function invariant(uint256 amount0, uint256 amount1, uint256 liquidity) public view override returns (bool) {\n    if (liquidity == 0) return (amount0 == 0 && amount1 == 0);\n\n    uint256 scale0 = FullMath.mulDiv(amount0, 1e18, liquidity) * token0Scale;\n    uint256 scale1 = FullMath.mulDiv(amount1, 1e18, liquidity) * token1Scale;\n\n    if (scale1 > 2 * upperBound) revert InvariantError();\n\n    uint256 a = scale0 * 1e18;\n    uint256 b = scale1 * upperBound;\n    uint256 c = (scale1 * scale1) / 4;\n    uint256 d = upperBound * upperBound;\n\n    return a + b >= c + d;\n  }\n\n  /// @dev assumes liquidity is non-zero\n  function mint(uint256 liquidity, bytes calldata data) internal {\n    uint120 _reserve0 = reserve0; // SLOAD\n    uint120 _reserve1 = reserve1; // SLOAD\n    uint256 _totalLiquidity = totalLiquidity; // SLOAD\n\n    uint256 balance0Before = Balance.balance(token0);\n    uint256 balance1Before = Balance.balance(token1);\n    IPairMintCallback(msg.sender).pairMintCallback(liquidity, data);\n    uint256 amount0In = Balance.balance(token0) - balance0Before;\n    uint256 amount1In = Balance.balance(token1) - balance1Before;\n\n    if (!invariant(_reserve0 + amount0In, _reserve1 + amount1In, _totalLiquidity + liquidity)) {\n      revert InvariantError();\n    }\n\n    reserve0 = _reserve0 + SafeCast.toUint120(amount0In); // SSTORE\n    reserve1 = _reserve1 + SafeCast.toUint120(amount1In); // SSTORE\n    totalLiquidity = _totalLiquidity + liquidity; // SSTORE\n\n    emit Mint(amount0In, amount1In, liquidity);\n  }\n\n  /// @dev assumes liquidity is non-zero\n  function burn(address to, uint256 liquidity) internal returns (uint256 amount0, uint256 amount1) {\n    uint120 _reserve0 = reserve0; // SLOAD\n    uint120 _reserve1 = reserve1; // SLOAD\n    uint256 _totalLiquidity = totalLiquidity; // SLOAD\n\n    amount0 = FullMath.mulDiv(_reserve0, liquidity, _totalLiquidity);\n    amount1 = FullMath.mulDiv(_reserve1, liquidity, _totalLiquidity);\n    if (amount0 == 0 && amount1 == 0) revert InsufficientOutputError();\n\n    if (amount0 > 0) SafeTransferLib.safeTransfer(token0, to, amount0);\n    if (amount1 > 0) SafeTransferLib.safeTransfer(token1, to, amount1);\n\n    // Extra check of the invariant\n    if (!invariant(_reserve0 - amount0, _reserve1 - amount1, _totalLiquidity - liquidity)) revert InvariantError();\n\n    reserve0 = _reserve0 - SafeCast.toUint120(amount0); // SSTORE\n    reserve1 = _reserve1 - SafeCast.toUint120(amount1); // SSTORE\n    totalLiquidity = _totalLiquidity - liquidity; // SSTORE\n\n    emit Burn(amount0, amount1, liquidity, to);\n  }\n\n  /// @inheritdoc IPair\n  function swap(address to, uint256 amount0Out, uint256 amount1Out, bytes calldata data) external override nonReentrant {\n    if (amount0Out == 0 && amount1Out == 0) revert InsufficientOutputError();\n\n    uint120 _reserve0 = reserve0; // SLOAD\n    uint120 _reserve1 = reserve1; // SLOAD\n\n    if (amount0Out > 0) SafeTransferLib.safeTransfer(token0, to, amount0Out);\n    if (amount1Out > 0) SafeTransferLib.safeTransfer(token1, to, amount1Out);\n\n    uint256 balance0Before = Balance.balance(token0);\n    uint256 balance1Before = Balance.balance(token1);\n    ISwapCallback(msg.sender).swapCallback(amount0Out, amount1Out, data);\n    uint256 amount0In = Balance.balance(token0) - balance0Before;\n    uint256 amount1In = Balance.balance(token1) - balance1Before;\n\n    if (!invariant(_reserve0 + amount0In - amount0Out, _reserve1 + amount1In - amount1Out, totalLiquidity)) {\n      revert InvariantError();\n    }\n\n    reserve0 = _reserve0 + SafeCast.toUint120(amount0In) - SafeCast.toUint120(amount0Out); // SSTORE\n    reserve1 = _reserve1 + SafeCast.toUint120(amount1In) - SafeCast.toUint120(amount1Out); // SSTORE\n\n    emit Swap(amount0Out, amount1Out, amount0In, amount1In, to);\n  }\n}"
    },
    {
      "filename": "src/core/Pair.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.4;\n\nimport { ImmutableState } from \"./ImmutableState.sol\";\nimport { ReentrancyGuard } from \"./ReentrancyGuard.sol\";\n\nimport { IPair } from \"./interfaces/IPair.sol\";\nimport { IPairMintCallback } from \"./interfaces/callback/IPairMintCallback.sol\";\nimport { ISwapCallback } from \"./interfaces/callback/ISwapCallback.sol\";\n\nimport { Balance } from \"../libraries/Balance.sol\";\nimport { FullMath } from \"../libraries/FullMath.sol\";\nimport { SafeCast } from \"../libraries/SafeCast.sol\";\nimport { SafeTransferLib } from \"../libraries/SafeTransferLib.sol\";\n\nabstract contract Pair is ImmutableState, ReentrancyGuard, IPair {\n  /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n  event Mint(uint256 amount0In, uint256 amount1In, uint256 liquidity);\n\n  event Burn(uint256 amount0Out, uint256 amount1Out, uint256 liquidity, address indexed to);\n\n  event Swap(uint256 amount0Out, uint256 amount1Out, uint256 amount0In, uint256 amount1In, address indexed to);\n\n  /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n  error InvariantError();\n\n  error InsufficientOutputError();\n\n  /*//////////////////////////////////////////////////////////////\n                                 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n  /// @inheritdoc IPair\n  uint120 public override reserve0;\n\n  /// @inheritdoc IPair\n  uint120 public override reserve1;\n\n  /// @inheritdoc IPair\n  uint256 public override totalLiquidity;\n\n  /*//////////////////////////////////////////////////////////////\n                              PAIR LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /// @inheritdoc IPair\n  function invariant(uint256 amount0, uint256 amount1, uint256 liquidity) public view override returns (bool) {\n    if (liquidity == 0) return (amount0 == 0 && amount1 == 0);\n\n    uint256 scale0 = FullMath.mulDiv(amount0, 1e18, liquidity) * token0Scale;\n    uint256 scale1 = FullMath.mulDiv(amount1, 1e18, liquidity) * token1Scale;\n\n    if (scale1 > 2 * upperBound) revert InvariantError();\n\n    uint256 a = scale0 * 1e18;\n    uint256 b = scale1 * upperBound;\n    uint256 c = (scale1 * scale1) / 4;\n    uint256 d = upperBound * upperBound;\n\n    return a + b >= c + d;\n  }\n\n  /// @dev assumes liquidity is non-zero\n  function mint(uint256 liquidity, bytes calldata data) internal {\n    uint120 _reserve0 = reserve0; // SLOAD\n    uint120 _reserve1 = reserve1; // SLOAD\n    uint256 _totalLiquidity = totalLiquidity; // SLOAD\n\n    uint256 balance0Before = Balance.balance(token0);\n    uint256 balance1Before = Balance.balance(token1);\n    IPairMintCallback(msg.sender).pairMintCallback(liquidity, data);\n    uint256 amount0In = Balance.balance(token0) - balance0Before;\n    uint256 amount1In = Balance.balance(token1) - balance1Before;\n\n    if (!invariant(_reserve0 + amount0In, _reserve1 + amount1In, _totalLiquidity + liquidity)) {\n      revert InvariantError();\n    }\n\n    reserve0 = _reserve0 + SafeCast.toUint120(amount0In); // SSTORE\n    reserve1 = _reserve1 + SafeCast.toUint120(amount1In); // SSTORE\n    totalLiquidity = _totalLiquidity + liquidity; // SSTORE\n\n    emit Mint(amount0In, amount1In, liquidity);\n  }\n\n  /// @dev assumes liquidity is non-zero\n  function burn(address to, uint256 liquidity) internal returns (uint256 amount0, uint256 amount1) {\n    uint120 _reserve0 = reserve0; // SLOAD\n    uint120 _reserve1 = reserve1; // SLOAD\n    uint256 _totalLiquidity = totalLiquidity; // SLOAD\n\n    amount0 = FullMath.mulDiv(_reserve0, liquidity, _totalLiquidity);\n    amount1 = FullMath.mulDiv(_reserve1, liquidity, _totalLiquidity);\n    if (amount0 == 0 && amount1 == 0) revert InsufficientOutputError();\n\n    if (amount0 > 0) SafeTransferLib.safeTransfer(token0, to, amount0);\n    if (amount1 > 0) SafeTransferLib.safeTransfer(token1, to, amount1);\n\n    // Extra check of the invariant\n    if (!invariant(_reserve0 - amount0, _reserve1 - amount1, _totalLiquidity - liquidity)) revert InvariantError();\n\n    reserve0 = _reserve0 - SafeCast.toUint120(amount0); // SSTORE\n    reserve1 = _reserve1 - SafeCast.toUint120(amount1); // SSTORE\n    totalLiquidity = _totalLiquidity - liquidity; // SSTORE\n\n    emit Burn(amount0, amount1, liquidity, to);\n  }\n\n  /// @inheritdoc IPair\n  function swap(address to, uint256 amount0Out, uint256 amount1Out, bytes calldata data) external override nonReentrant {\n    if (amount0Out == 0 && amount1Out == 0) revert InsufficientOutputError();\n\n    uint120 _reserve0 = reserve0; // SLOAD\n    uint120 _reserve1 = reserve1; // SLOAD\n\n    if (amount0Out > 0) SafeTransferLib.safeTransfer(token0, to, amount0Out);\n    if (amount1Out > 0) SafeTransferLib.safeTransfer(token1, to, amount1Out);\n\n    uint256 balance0Before = Balance.balance(token0);\n    uint256 balance1Before = Balance.balance(token1);\n    ISwapCallback(msg.sender).swapCallback(amount0Out, amount1Out, data);\n    uint256 amount0In = Balance.balance(token0) - balance0Before;\n    uint256 amount1In = Balance.balance(token1) - balance1Before;\n\n    if (!invariant(_reserve0 + amount0In - amount0Out, _reserve1 + amount1In - amount1Out, totalLiquidity)) {\n      revert InvariantError();\n    }\n\n    reserve0 = _reserve0 + SafeCast.toUint120(amount0In) - SafeCast.toUint120(amount0Out); // SSTORE\n    reserve1 = _reserve1 + SafeCast.toUint120(amount1In) - SafeCast.toUint120(amount1Out); // SSTORE\n\n    emit Swap(amount0Out, amount1Out, amount0In, amount1In, to);\n  }\n}"
    },
    {
      "filename": "src/core/Lendgine.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.4;\n\nimport { ERC20 } from \"./ERC20.sol\";\nimport { JumpRate } from \"./JumpRate.sol\";\nimport { Pair } from \"./Pair.sol\";\n\nimport { ILendgine } from \"./interfaces/ILendgine.sol\";\nimport { IMintCallback } from \"./interfaces/callback/IMintCallback.sol\";\n\nimport { Balance } from \"../libraries/Balance.sol\";\nimport { FullMath } from \"../libraries/FullMath.sol\";\nimport { Position } from \"./libraries/Position.sol\";\nimport { SafeTransferLib } from \"../libraries/SafeTransferLib.sol\";\nimport { SafeCast } from \"../libraries/SafeCast.sol\";\n\ncontract Lendgine is ERC20, JumpRate, Pair, ILendgine {\n  using Position for mapping(address => Position.Info);\n  using Position for Position.Info;\n\n  /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n  event Mint(address indexed sender, uint256 collateral, uint256 shares, uint256 liquidity, address indexed to);\n\n  event Burn(address indexed sender, uint256 collateral, uint256 shares, uint256 liquidity, address indexed to);\n\n  event Deposit(address indexed sender, uint256 size, uint256 liquidity, address indexed to);\n\n  event Withdraw(address indexed sender, uint256 size, uint256 liquidity, address indexed to);\n\n  event AccrueInterest(uint256 timeElapsed, uint256 collateral, uint256 liquidity);\n\n  event AccruePositionInterest(address indexed owner, uint256 rewardPerPosition);\n\n  event Collect(address indexed owner, address indexed to, uint256 amount);\n\n  /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n  error InputError();\n\n  error CompleteUtilizationError();\n\n  error InsufficientInputError();\n\n  error InsufficientPositionError();\n\n  /*//////////////////////////////////////////////////////////////\n                          LENDGINE STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n  /// @inheritdoc ILendgine\n  mapping(address => Position.Info) public override positions;\n\n  /// @inheritdoc ILendgine\n  uint256 public override totalPositionSize;\n\n  /// @inheritdoc ILendgine\n  uint256 public override totalLiquidityBorrowed;\n\n  /// @inheritdoc ILendgine\n  uint256 public override rewardPerPositionStored;\n\n  /// @inheritdoc ILendgine\n  uint256 public override lastUpdate;\n\n  /// @inheritdoc ILendgine\n  function mint(\n    address to,\n    uint256 collateral,\n    bytes calldata data\n  )\n    external\n    override\n    nonReentrant\n    returns (uint256 shares)\n  {\n    _accrueInterest();\n\n    uint256 liquidity = convertCollateralToLiquidity(collateral);\n    shares = convertLiquidityToShare(liquidity);\n\n    if (collateral == 0 || liquidity == 0 || shares == 0) revert InputError();\n    if (liquidity > totalLiquidity) revert CompleteUtilizationError();\n    // next check is for the case when liquidity is borrowed but then was completely accrued\n    if (totalSupply > 0 && totalLiquidityBorrowed == 0) revert CompleteUtilizationError();\n\n    totalLiquidityBorrowed += liquidity;\n    (uint256 amount0, uint256 amount1) = burn(to, liquidity);\n    _mint(to, shares);\n\n    uint256 balanceBefore = Balance.balance(token1);\n    IMintCallback(msg.sender).mintCallback(collateral, amount0, amount1, liquidity, data);\n    uint256 balanceAfter = Balance.balance(token1);\n\n    if (balanceAfter < balanceBefore + collateral) revert InsufficientInputError();\n\n    emit Mint(msg.sender, collateral, shares, liquidity, to);\n  }\n\n  /// @inheritdoc ILendgine\n  function burn(address to, bytes calldata data) external override nonReentrant returns (uint256 collateral) {\n    _accrueInterest();\n\n    uint256 shares = balanceOf[address(this)];\n    uint256 liquidity = convertShareToLiquidity(shares);\n    collateral = convertLiquidityToCollateral(liquidity);\n\n    if (collateral == 0 || liquidity == 0 || shares == 0) revert InputError();\n\n    totalLiquidityBorrowed -= liquidity;\n    _burn(address(this), shares);\n    SafeTransferLib.safeTransfer(token1, to, collateral); // optimistically transfer\n    mint(liquidity, data);\n\n    emit Burn(msg.sender, collateral, shares, liquidity, to);\n  }\n\n  /// @inheritdoc ILendgine\n  function deposit(\n    address to,\n    uint256 liquidity,\n    bytes calldata data\n  )\n    external\n    override\n    nonReentrant\n    returns (uint256 size)\n  {\n    _accrueInterest();\n\n    uint256 _totalPositionSize = totalPositionSize; // SLOAD\n    uint256 totalLiquiditySupplied = totalLiquidity + totalLiquidityBorrowed;\n\n    size = Position.convertLiquidityToPosition(liquidity, totalLiquiditySupplied, _totalPositionSize);\n\n    if (liquidity == 0 || size == 0) revert InputError();\n    // next check is for the case when liquidity is borrowed but then was completely accrued\n    if (totalLiquiditySupplied == 0 && totalPositionSize > 0) revert CompleteUtilizationError();\n\n    positions.update(to, SafeCast.toInt256(size), rewardPerPositionStored);\n    totalPositionSize = _totalPositionSize + size;\n    mint(liquidity, data);\n\n    emit Deposit(msg.sender, size, liquidity, to);\n  }\n\n  /// @inheritdoc ILendgine\n  function withdraw(\n    address to,\n    uint256 size\n  )\n    external\n    override\n    nonReentrant\n    returns (uint256 amount0, uint256 amount1, uint256 liquidity)\n  {\n    _accrueInterest();\n\n    uint256 _totalPositionSize = totalPositionSize; // SLOAD\n    uint256 _totalLiquidity = totalLiquidity; // SLOAD\n    uint256 totalLiquiditySupplied = _totalLiquidity + totalLiquidityBorrowed;\n\n    Position.Info memory positionInfo = positions[msg.sender]; // SLOAD\n    liquidity = Position.convertPositionToLiquidity(size, totalLiquiditySupplied, _totalPositionSize);\n\n    if (liquidity == 0 || size == 0) revert InputError();\n\n    if (size > positionInfo.size) revert InsufficientPositionError();\n    if (liquidity > _totalLiquidity) revert CompleteUtilizationError();\n\n    positions.update(msg.sender, -SafeCast.toInt256(size), rewardPerPositionStored);\n    totalPositionSize -= size;\n    (amount0, amount1) = burn(to, liquidity);\n\n    emit Withdraw(msg.sender, size, liquidity, to);\n  }\n\n  /// @inheritdoc ILendgine\n  function accrueInterest() external override nonReentrant {\n    _accrueInterest();\n  }\n\n  /// @inheritdoc ILendgine\n  function accruePositionInterest() external override nonReentrant {\n    _accrueInterest();\n    _accruePositionInterest(msg.sender);\n  }\n\n  /// @inheritdoc ILendgine\n  function collect(address to, uint256 collateralRequested) external override nonReentrant returns (uint256 collateral) {\n    Position.Info storage position = positions[msg.sender]; // SLOAD\n    uint256 tokensOwed = position.tokensOwed;\n\n    collateral = collateralRequested > tokensOwed ? tokensOwed : collateralRequested;\n\n    if (collateral > 0) {\n      position.tokensOwed = tokensOwed - collateral; // SSTORE\n      SafeTransferLib.safeTransfer(token1, to, collateral);\n    }\n\n    emit Collect(msg.sender, to, collateral);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /// @inheritdoc ILendgine\n  function convertLiquidityToShare(uint256 liquidity) public view override returns (uint256) {\n    uint256 _totalLiquidityBorrowed = totalLiquidityBorrowed; // SLOAD\n    return _totalLiquidityBorrowed == 0 ? liquidity : FullMath.mulDiv(liquidity, totalSupply, _totalLiquidityBorrowed);\n  }\n\n  /// @inheritdoc ILendgine\n  function convertShareToLiquidity(uint256 shares) public view override returns (uint256) {\n    return FullMath.mulDiv(totalLiquidityBorrowed, shares, totalSupply);\n  }\n\n  /// @inheritdoc ILendgine\n  function convertCollateralToLiquidity(uint256 collateral) public view override returns (uint256) {\n    return FullMath.mulDiv(collateral * token1Scale, 1e18, 2 * upperBound);\n  }\n\n  /// @inheritdoc ILendgine\n  function convertLiquidityToCollateral(uint256 liquidity) public view override returns (uint256) {\n    return FullMath.mulDiv(liquidity, 2 * upperBound, 1e18) / token1Scale;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                         INTERNAL INTEREST LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /// @notice Helper function for accruing lendgine interest\n  function _accrueInterest() private {\n    if (totalSupply == 0 || totalLiquidityBorrowed == 0) {\n      lastUpdate = block.timestamp;\n      return;\n    }\n\n    uint256 timeElapsed = block.timestamp - lastUpdate;\n    if (timeElapsed == 0) return;\n\n    uint256 _totalLiquidityBorrowed = totalLiquidityBorrowed; // SLOAD\n    uint256 totalLiquiditySupplied = totalLiquidity + _totalLiquidityBorrowed; // SLOAD\n\n    uint256 borrowRate = getBorrowRate(_totalLiquidityBorrowed, totalLiquiditySupplied);\n\n    uint256 dilutionLPRequested = (FullMath.mulDiv(borrowRate, _totalLiquidityBorrowed, 1e18) * timeElapsed) / 365 days;\n    uint256 dilutionLP = dilutionLPRequested > _totalLiquidityBorrowed ? _totalLiquidityBorrowed : dilutionLPRequested;\n    uint256 dilutionSpeculative = convertLiquidityToCollateral(dilutionLP);\n\n    totalLiquidityBorrowed = _totalLiquidityBorrowed - dilutionLP;\n    rewardPerPositionStored += FullMath.mulDiv(dilutionSpeculative, 1e18, totalPositionSize);\n    lastUpdate = block.timestamp;\n\n    emit AccrueInterest(timeElapsed, dilutionSpeculative, dilutionLP);\n  }\n\n  /// @notice Helper function for accruing interest to a position\n  /// @dev Assume the global interest is up to date\n  /// @param owner The address that this position belongs to\n  function _accruePositionInterest(address owner) private {\n    uint256 _rewardPerPositionStored = rewardPerPositionStored; // SLOAD\n\n    positions.update(owner, 0, _rewardPerPositionStored);\n\n    emit AccruePositionInterest(owner, _rewardPerPositionStored);\n  }\n}"
    }
  ]
}