{
  "Title": "[L05] Errors and omissions in events",
  "Content": "Throughout the codebase, events are generally emitted when sensitive changes are made to the contracts. However, many events lack indexed parameters and/or are missing important parameters. For example:\n\n\n* The [`OrderRFQMixin.OrderFilledRFQ`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderRFQMixin.sol#L16), [`OrderMixin.OrderFilled`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L31), and [`OrderMixin.OrderCanceled`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L38) events should index the `orderHash` parameter.\n* The [`OrderRFQMixin.OrderFilledRFQ`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderRFQMixin.sol#L16) and [`OrderMixin.OrderFilled`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L31) events should be more complete, including the `maker`, `taker`, `target`, `amountMaking`, and `amountTaking` where possible.\n\n\nThere are also sensitive actions that are lacking events, such as:\n\n\n* In the [`OrderRFQMixin`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderRFQMixin.sol) contract, the [`cancelOrderRFQ`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderRFQMixin.sol#L44) function does not emit an event when an order is canceled.\n\n\nConsider more completely indexing existing events and adding new parameters where they are lacking. Also, consider emitting all events in such a complete manner that they could be used to rebuild the state of the contract by off-chain services.\n\n\n***Update:** Not fixed. However, the 1inch team did add an `orderRemaining` parameter to the `OrderCanceled` event in [pull request #62](https://github.com/1inch/limit-order-protocol/pull/62).*\n\n\n*The 1inch team states:*\n\n\n\n> We found that only a limited subset of data is required to satisfy frontend needs. In the case of extensive analysis, all the suggested fields are available via tracing. For `OrderRFQMixin` we expect market makers to build their own sophisticated way of tracking what orders have been canceled.\n> \n> \n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/OrderRFQMixin.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./libraries/Permitable.sol\";\n\n/// @title Order RFQ Limits v1 mixin\nabstract contract OrderRFQMixin is EIP712, Permitable {\n    using SafeERC20 for IERC20;\n\n    /// @notice Emitted when RFQ gets filled\n    event OrderFilledRFQ(\n        bytes32 orderHash,\n        uint256 makingAmount\n    );\n\n    struct OrderRFQ {\n        uint256 info;  // lowest 64 bits is the order id, next 64 bits is the expiration timestamp\n        IERC20 makerAsset;\n        IERC20 takerAsset;\n        address maker;\n        address allowedSender;  // equals to Zero address on public orders\n        uint256 makingAmount;\n        uint256 takingAmount;\n    }\n\n    bytes32 constant public LIMIT_ORDER_RFQ_TYPEHASH = keccak256(\n        \"OrderRFQ(uint256 info,address makerAsset,address takerAsset,address maker,address allowedSender,uint256 makingAmount,uint256 takingAmount)\"\n    );\n\n    mapping(address => mapping(uint256 => uint256)) private _invalidator;\n\n    /// @notice Returns bitmask for double-spend invalidators based on lowest byte of order.info and filled quotes\n    /// @return Result Each bit represents whenever corresponding quote was filled\n    function invalidatorForOrderRFQ(address maker, uint256 slot) external view returns(uint256) {\n        return _invalidator[maker][slot];\n    }\n\n    /// @notice Cancels order's quote\n    function cancelOrderRFQ(uint256 orderInfo) external {\n        _invalidator[msg.sender][uint64(orderInfo) >> 8] |= 1 << uint8(orderInfo);\n    }\n\n    /// @notice Fills order's quote, fully or partially (whichever is possible)\n    /// @param order Order quote to fill\n    /// @param signature Signature to confirm quote ownership\n    /// @param makingAmount Making amount\n    /// @param takingAmount Taking amount\n    function fillOrderRFQ(\n        OrderRFQ memory order,\n        bytes calldata signature,\n        uint256 makingAmount,\n        uint256 takingAmount\n    ) external returns(uint256 /* actualMakingAmount */, uint256 /* actualTakingAmount */) {\n        return fillOrderRFQTo(order, signature, makingAmount, takingAmount, msg.sender);\n    }\n\n    /// @notice Fills Same as `fillOrderRFQ` but calls permit first,\n    /// allowing to approve token spending and make a swap in one transaction.\n    /// Also allows to specify funds destination instead of `msg.sender`\n    /// @param order Order quote to fill\n    /// @param signature Signature to confirm quote ownership\n    /// @param makingAmount Making amount\n    /// @param takingAmount Taking amount\n    /// @param target Address that will receive swap funds\n    /// @param permit Should consist of abiencoded token address and encoded `IERC20Permit.permit` call.\n    /// See tests for examples\n    function fillOrderRFQToWithPermit(\n        OrderRFQ memory order,\n        bytes calldata signature,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        address target,\n        bytes calldata permit\n    ) external returns(uint256 /* actualMakingAmount */, uint256 /* actualTakingAmount */) {\n        _permit(address(order.takerAsset), permit);\n        return fillOrderRFQTo(order, signature, makingAmount, takingAmount, target);\n    }\n\n    /// @notice Same as `fillOrderRFQ` but allows to specify funds destination instead of `msg.sender`\n    /// @param order Order quote to fill\n    /// @param signature Signature to confirm quote ownership\n    /// @param makingAmount Making amount\n    /// @param takingAmount Taking amount\n    /// @param target Address that will receive swap funds\n    function fillOrderRFQTo(\n        OrderRFQ memory order,\n        bytes calldata signature,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        address target\n    ) public returns(uint256 /* actualMakingAmount */, uint256 /* actualTakingAmount */) {\n        address maker = order.maker;\n        {  // Stack too deep\n            uint256 info = order.info;\n            // Check time expiration\n            uint256 expiration = uint128(info) >> 64;\n            require(expiration == 0 || block.timestamp <= expiration, \"LOP: order expired\");  // solhint-disable-line not-rely-on-time\n\n            // Validate double spend\n            uint256 invalidatorSlot = uint64(info) >> 8;\n            uint256 invalidatorBit = 1 << uint8(info);\n            mapping(uint256 => uint256) storage invalidatorStorage = _invalidator[maker];\n            uint256 invalidator = invalidatorStorage[invalidatorSlot];\n            require(invalidator & invalidatorBit == 0, \"LOP: already filled\");\n            invalidatorStorage[invalidatorSlot] = invalidator | invalidatorBit;\n        }\n\n        {  // stack too deep\n            uint256 orderMakingAmount = order.makingAmount;\n            uint256 orderTakingAmount = order.takingAmount;\n            // Compute partial fill if needed\n            if (takingAmount == 0 && makingAmount == 0) {\n                // Two zeros means whole order\n                makingAmount = orderMakingAmount;\n                takingAmount = orderTakingAmount;\n            }\n            else if (takingAmount == 0) {\n                require(makingAmount <= orderMakingAmount, \"LOP: making amount exceeded\");\n                takingAmount = (orderTakingAmount * makingAmount + orderMakingAmount - 1) / orderMakingAmount;\n            }\n            else if (makingAmount == 0) {\n                require(takingAmount <= orderTakingAmount, \"LOP: taking amount exceeded\");\n                makingAmount = orderMakingAmount * takingAmount / orderTakingAmount;\n            }\n            else {\n                revert(\"LOP: one of amounts should be 0\");\n            }\n        }\n\n        require(makingAmount > 0 && takingAmount > 0, \"LOP: can't swap 0 amount\");\n\n        // Validate order\n        require(order.allowedSender == address(0) || order.allowedSender == msg.sender, \"LOP: private order\");\n        bytes32 orderHash = _hashTypedDataV4(keccak256(abi.encode(LIMIT_ORDER_RFQ_TYPEHASH, order)));\n        require(SignatureChecker.isValidSignatureNow(maker, orderHash, signature), \"LOP: bad signature\");\n\n        // Maker => Taker, Taker => Maker\n        order.makerAsset.safeTransferFrom(maker, target, makingAmount);\n        order.takerAsset.safeTransferFrom(msg.sender, maker, takingAmount);\n\n        emit OrderFilledRFQ(orderHash, makingAmount);\n        return (makingAmount, takingAmount);\n    }\n}"
    },
    {
      "filename": "contracts/OrderRFQMixin.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./libraries/Permitable.sol\";\n\n/// @title Order RFQ Limits v1 mixin\nabstract contract OrderRFQMixin is EIP712, Permitable {\n    using SafeERC20 for IERC20;\n\n    /// @notice Emitted when RFQ gets filled\n    event OrderFilledRFQ(\n        bytes32 orderHash,\n        uint256 makingAmount\n    );\n\n    struct OrderRFQ {\n        uint256 info;  // lowest 64 bits is the order id, next 64 bits is the expiration timestamp\n        IERC20 makerAsset;\n        IERC20 takerAsset;\n        address maker;\n        address allowedSender;  // equals to Zero address on public orders\n        uint256 makingAmount;\n        uint256 takingAmount;\n    }\n\n    bytes32 constant public LIMIT_ORDER_RFQ_TYPEHASH = keccak256(\n        \"OrderRFQ(uint256 info,address makerAsset,address takerAsset,address maker,address allowedSender,uint256 makingAmount,uint256 takingAmount)\"\n    );\n\n    mapping(address => mapping(uint256 => uint256)) private _invalidator;\n\n    /// @notice Returns bitmask for double-spend invalidators based on lowest byte of order.info and filled quotes\n    /// @return Result Each bit represents whenever corresponding quote was filled\n    function invalidatorForOrderRFQ(address maker, uint256 slot) external view returns(uint256) {\n        return _invalidator[maker][slot];\n    }\n\n    /// @notice Cancels order's quote\n    function cancelOrderRFQ(uint256 orderInfo) external {\n        _invalidator[msg.sender][uint64(orderInfo) >> 8] |= 1 << uint8(orderInfo);\n    }\n\n    /// @notice Fills order's quote, fully or partially (whichever is possible)\n    /// @param order Order quote to fill\n    /// @param signature Signature to confirm quote ownership\n    /// @param makingAmount Making amount\n    /// @param takingAmount Taking amount\n    function fillOrderRFQ(\n        OrderRFQ memory order,\n        bytes calldata signature,\n        uint256 makingAmount,\n        uint256 takingAmount\n    ) external returns(uint256 /* actualMakingAmount */, uint256 /* actualTakingAmount */) {\n        return fillOrderRFQTo(order, signature, makingAmount, takingAmount, msg.sender);\n    }\n\n    /// @notice Fills Same as `fillOrderRFQ` but calls permit first,\n    /// allowing to approve token spending and make a swap in one transaction.\n    /// Also allows to specify funds destination instead of `msg.sender`\n    /// @param order Order quote to fill\n    /// @param signature Signature to confirm quote ownership\n    /// @param makingAmount Making amount\n    /// @param takingAmount Taking amount\n    /// @param target Address that will receive swap funds\n    /// @param permit Should consist of abiencoded token address and encoded `IERC20Permit.permit` call.\n    /// See tests for examples\n    function fillOrderRFQToWithPermit(\n        OrderRFQ memory order,\n        bytes calldata signature,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        address target,\n        bytes calldata permit\n    ) external returns(uint256 /* actualMakingAmount */, uint256 /* actualTakingAmount */) {\n        _permit(address(order.takerAsset), permit);\n        return fillOrderRFQTo(order, signature, makingAmount, takingAmount, target);\n    }\n\n    /// @notice Same as `fillOrderRFQ` but allows to specify funds destination instead of `msg.sender`\n    /// @param order Order quote to fill\n    /// @param signature Signature to confirm quote ownership\n    /// @param makingAmount Making amount\n    /// @param takingAmount Taking amount\n    /// @param target Address that will receive swap funds\n    function fillOrderRFQTo(\n        OrderRFQ memory order,\n        bytes calldata signature,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        address target\n    ) public returns(uint256 /* actualMakingAmount */, uint256 /* actualTakingAmount */) {\n        address maker = order.maker;\n        {  // Stack too deep\n            uint256 info = order.info;\n            // Check time expiration\n            uint256 expiration = uint128(info) >> 64;\n            require(expiration == 0 || block.timestamp <= expiration, \"LOP: order expired\");  // solhint-disable-line not-rely-on-time\n\n            // Validate double spend\n            uint256 invalidatorSlot = uint64(info) >> 8;\n            uint256 invalidatorBit = 1 << uint8(info);\n            mapping(uint256 => uint256) storage invalidatorStorage = _invalidator[maker];\n            uint256 invalidator = invalidatorStorage[invalidatorSlot];\n            require(invalidator & invalidatorBit == 0, \"LOP: already filled\");\n            invalidatorStorage[invalidatorSlot] = invalidator | invalidatorBit;\n        }\n\n        {  // stack too deep\n            uint256 orderMakingAmount = order.makingAmount;\n            uint256 orderTakingAmount = order.takingAmount;\n            // Compute partial fill if needed\n            if (takingAmount == 0 && makingAmount == 0) {\n                // Two zeros means whole order\n                makingAmount = orderMakingAmount;\n                takingAmount = orderTakingAmount;\n            }\n            else if (takingAmount == 0) {\n                require(makingAmount <= orderMakingAmount, \"LOP: making amount exceeded\");\n                takingAmount = (orderTakingAmount * makingAmount + orderMakingAmount - 1) / orderMakingAmount;\n            }\n            else if (makingAmount == 0) {\n                require(takingAmount <= orderTakingAmount, \"LOP: taking amount exceeded\");\n                makingAmount = orderMakingAmount * takingAmount / orderTakingAmount;\n            }\n            else {\n                revert(\"LOP: one of amounts should be 0\");\n            }\n        }\n\n        require(makingAmount > 0 && takingAmount > 0, \"LOP: can't swap 0 amount\");\n\n        // Validate order\n        require(order.allowedSender == address(0) || order.allowedSender == msg.sender, \"LOP: private order\");\n        bytes32 orderHash = _hashTypedDataV4(keccak256(abi.encode(LIMIT_ORDER_RFQ_TYPEHASH, order)));\n        require(SignatureChecker.isValidSignatureNow(maker, orderHash, signature), \"LOP: bad signature\");\n\n        // Maker => Taker, Taker => Maker\n        order.makerAsset.safeTransferFrom(maker, target, makingAmount);\n        order.takerAsset.safeTransferFrom(msg.sender, maker, takingAmount);\n\n        emit OrderFilledRFQ(orderHash, makingAmount);\n        return (makingAmount, takingAmount);\n    }\n}"
    }
  ]
}