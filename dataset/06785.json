{
  "Title": "[M-05] Possible DOS attack using dust in `ReraiseETHCrowdfund._contribute()`",
  "Content": "\nNormal contributors wouldn't contribute to the crowdfund properly by a malicious frontrunner.\n\n### Proof of Concept\n\nWhen users contribute to the `ReraiseETHCrowdfund`, it mints the crowdfund NFT in `_contribute()`.\n\n```solidity\nFile: 2023-04-party\\contracts\\crowdfund\\ReraiseETHCrowdfund.sol\n228:         votingPower = _processContribution(contributor, delegate, amount);\n229: \n230:         // OK to contribute with zero just to update delegate.\n231:         if (amount == 0) return 0;\n232: \n233:         uint256 previousVotingPower = pendingVotingPower[contributor];\n234: \n235:         pendingVotingPower[contributor] += votingPower;\n236: \n237:         // Mint a crowdfund NFT if this is their first contribution.\n238:         if (previousVotingPower == 0) _mint(contributor); //@audit DOS by sending dust\n```\n\nAs we can see, it mints the NFT when `previousVotingPower == 0` to mint for the first contribution.\n\nBut `votingPower` from `_processContribution()` might be 0 even if `amount > 0` and `pendingVotingPower[contributor]` would be remained as 0 after the first contribution.\n\nThen this function will revert from the second contribution as it tries to mint the NFT again.\n\nThe below shows the detailed scenario and POC.\n\n1.  Let's assume `exchangeRateBps = 5e3`. So [votingPower for 1 wei is zero](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ETHCrowdfundBase.sol#L233). Also, [from the test configurations](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/sol-tests/crowdfund/ReraiseETHCrowdfund.t.sol#L251), it's not a strong condition to assume `minContributions = 0`.\n2.  After noticing an honest user contributes with 1 ether, an attacker frontruns `contributeFor()` for the honest user with 1 wei.\n3.  Then the crowdfund NFT of the honest user will be minted but the voting power is still 0.\n4.  During the honest user's `contribute()`, it will try to mint the NFT again as [previousVotingPower == 0](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L238) and revert. So he can't contribute for this crowdfund.\n\nWhile executing the POC, [opts.exchangeRateBps](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/sol-tests/crowdfund/ReraiseETHCrowdfund.t.sol#L72) should be `5e3`.\n\n```solidity\n    function test_contribute_DOSByFrontrunnerWithDust() public {\n        ReraiseETHCrowdfund crowdfund = _createCrowdfund({\n            initialContribution: 0,\n            initialContributor: payable(address(0)),\n            initialDelegate: address(0),\n            minContributions: 0,\n            maxContributions: type(uint96).max,\n            disableContributingForExistingCard: false,\n            minTotalContributions: 3 ether,\n            maxTotalContributions: 5 ether,\n            duration: 7 days,\n            fundingSplitBps: 0,\n            fundingSplitRecipient: payable(address(0))\n        });\n\n        address attacker = _randomAddress();\n        address honest = _randomAddress();\n        vm.deal(attacker, 1); //attacker has 1 wei\n        vm.deal(honest, 1 ether); //honest user has 1 ether\n\n        // Contribute\n        vm.startPrank(attacker); //attacker frontruns for the honest user\n        crowdfund.contributeFor{ value: 1 }(payable(honest), honest, \"\");\n        vm.stopPrank();\n\n        assertEq(crowdfund.balanceOf(honest), 1); //crowdfund NFT of the honest users was minted\n        assertEq(crowdfund.pendingVotingPower(honest), 0); //voting power = 0 because of the low exchangeRateBps\n\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                CrowdfundNFT.AlreadyMintedError.selector,\n                honest,\n                uint256(uint160(honest))\n            )\n        );\n        vm.startPrank(honest); //when the honest user contributes, reverts\n        crowdfund.contribute{ value: 1 ether }(honest, \"\");\n        vm.stopPrank();\n    }\n```\n\n### Recommended Mitigation Steps\n\nRecommend minting the crowdfund NFT when the new `votingPower` is positive. Then we can avoid duplicate mints.\n\n```solidity\nFile: 2023-04-party\\contracts\\crowdfund\\ReraiseETHCrowdfund.sol\n233:         uint256 previousVotingPower = pendingVotingPower[contributor];\n234: \n235:         pendingVotingPower[contributor] += votingPower;\n236: \n237:         // Mint a crowdfund NFT if this is their first meaningful contribution.\n238:         if (previousVotingPower == 0 && votingPower != 0) _mint(contributor); //++++++++++++++++\n```\n\n**[0xble (Party) confirmed and commented](https://github.com/code-423n4/2023-04-party-findings/issues/18#issuecomment-1518922059):**\n > Will be mitigated by reverting if contributing leads to zero voting power (i.e. `contributionAmount * exchangeRateBps / 1e4 == 0`).\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-04-party",
  "Code": [
    {
      "filename": "contracts/crowdfund/ETHCrowdfundBase.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"../utils/LibAddress.sol\";\nimport \"../utils/LibSafeCast.sol\";\nimport \"../party/Party.sol\";\nimport \"../gatekeepers/IGateKeeper.sol\";\n\ncontract ETHCrowdfundBase is Implementation {\n    using LibSafeCast for uint256;\n    using LibAddress for address payable;\n\n    enum CrowdfundLifecycle {\n        // In practice, this state is never used. If the crowdfund is ever in\n        // this stage, something is wrong (e.g. crowdfund was never initialized).\n        Invalid,\n        // Ready to accept contributions to reach contribution targets\n        // until a deadline or the minimum contribution target is reached and\n        // host finalizes.\n        Active,\n        // Expired and the minimum contribution target was not reached.\n        Lost,\n        // The crowdfund has expired and reached the minimum contribution\n        // target. It is now ready to finalize.\n        Won,\n        // A won crowdfund has been finalized, with funds transferred to the\n        // party and voting power successfully updated.\n        Finalized\n    }\n\n    // Options to be passed into `initialize()` when the crowdfund is created.\n    struct ETHCrowdfundOptions {\n        Party party;\n        address payable initialContributor;\n        address initialDelegate;\n        uint96 minContribution;\n        uint96 maxContribution;\n        bool disableContributingForExistingCard;\n        uint96 minTotalContributions;\n        uint96 maxTotalContributions;\n        uint16 exchangeRateBps;\n        uint16 fundingSplitBps;\n        address payable fundingSplitRecipient;\n        uint40 duration;\n        IGateKeeper gateKeeper;\n        bytes12 gateKeeperId;\n    }\n\n    error WrongLifecycleError(CrowdfundLifecycle lc);\n    error NotAllowedByGateKeeperError(\n        address contributor,\n        IGateKeeper gateKeeper,\n        bytes12 gateKeeperId,\n        bytes gateData\n    );\n    error OnlyPartyHostError();\n    error NotOwnerError();\n    error InvalidDelegateError();\n    error NotEnoughContributionsError(uint96 totalContribution, uint96 minTotalContributions);\n    error MinGreaterThanMaxError(uint96 min, uint96 max);\n    error MaxTotalContributionsCannotBeZeroError(uint96 maxTotalContributions);\n    error BelowMinimumContributionsError(uint96 contributions, uint96 minContributions);\n    error AboveMaximumContributionsError(uint96 contributions, uint96 maxContributions);\n    error ContributingForExistingCardDisabledError();\n\n    event Contributed(\n        address indexed sender,\n        address indexed contributor,\n        uint256 amount,\n        address delegate\n    );\n\n    /// @notice The address of the `Party` contract instance associated\n    ///         with the crowdfund.\n    Party public party;\n    /// @notice The minimum amount of ETH that a contributor can send to\n    ///         participate in the crowdfund.\n    uint96 public minContribution;\n    /// @notice The maximum amount of ETH that a contributor can send to\n    ///         participate in the crowdfund per address.\n    uint96 public maxContribution;\n    /// @notice A boolean flag that determines whether contributors are allowed\n    ///         to increase the voting power of their existing party cards.\n    bool public disableContributingForExistingCard;\n    /// @notice The minimum amount of total ETH contributions required for the\n    ///         crowdfund to be considered successful.\n    uint96 public minTotalContributions;\n    /// @notice The maximum amount of total ETH contributions allowed for the\n    ///         crowdfund.\n    uint96 public maxTotalContributions;\n    /// @notice The total amount of ETH contributed to the crowdfund so far.\n    uint96 public totalContributions;\n    /// @notice The timestamp at which the crowdfund will end or ended. If 0, the\n    ///         crowdfund has finalized.\n    uint40 public expiry;\n    /// @notice The exchange rate to use for converting ETH contributions to\n    ///         voting power in basis points (e.g. 10000 = 1:1).\n    uint16 public exchangeRateBps;\n    /// @notice The portion of contributions to send to the funding recipient in\n    ///         basis points (e.g. 100 = 1%).\n    uint16 public fundingSplitBps;\n    /// @notice The address to which a portion of the contributions is sent as a\n    ///         fee if set.\n    address payable public fundingSplitRecipient;\n    /// @notice The gatekeeper contract used to restrict who can contribute to the party.\n    IGateKeeper public gateKeeper;\n    /// @notice The ID of the gatekeeper to use for restricting contributions to the party.\n    bytes12 public gateKeeperId;\n    /// @notice The address a contributor is delegating their voting power to.\n    mapping(address => address) public delegationsByContributor;\n\n    // Initialize storage for proxy contracts, credit initial contribution (if\n    // any), and setup gatekeeper.\n    function _initialize(ETHCrowdfundOptions memory opts) internal {\n        // Set the minimum and maximum contribution amounts.\n        if (opts.minContribution > opts.maxContribution) {\n            revert MinGreaterThanMaxError(opts.minContribution, opts.maxContribution);\n        }\n        minContribution = opts.minContribution;\n        maxContribution = opts.maxContribution;\n        // Set the min total contributions.\n        if (opts.minTotalContributions > opts.maxTotalContributions) {\n            revert MinGreaterThanMaxError(opts.minTotalContributions, opts.maxTotalContributions);\n        }\n        minTotalContributions = opts.minTotalContributions;\n        // Set the max total contributions.\n        if (opts.maxTotalContributions == 0) {\n            // Prevent this because when `maxTotalContributions` is 0 the\n            // crowdfund is invalid in `getCrowdfundLifecycle()` meaning it has\n            // never been initialized.\n            revert MaxTotalContributionsCannotBeZeroError(opts.maxTotalContributions);\n        }\n        maxTotalContributions = opts.maxTotalContributions;\n        // Set the party crowdfund is for.\n        party = opts.party;\n        // Set the crowdfund start and end timestamps.\n        expiry = uint40(block.timestamp + opts.duration);\n        // Set the exchange rate.\n        exchangeRateBps = opts.exchangeRateBps;\n        // Set the funding split and its recipient.\n        fundingSplitBps = opts.fundingSplitBps;\n        fundingSplitRecipient = opts.fundingSplitRecipient;\n        // Set whether to disable contributing for existing card.\n        disableContributingForExistingCard = opts.disableContributingForExistingCard;\n    }\n\n    /// @notice Get the current lifecycle of the crowdfund.\n    function getCrowdfundLifecycle() public view returns (CrowdfundLifecycle lifecycle) {\n        if (maxTotalContributions == 0) {\n            return CrowdfundLifecycle.Invalid;\n        }\n\n        uint256 expiry_ = expiry;\n        if (expiry_ == 0) {\n            return CrowdfundLifecycle.Finalized;\n        }\n\n        if (block.timestamp >= expiry_) {\n            if (totalContributions >= minTotalContributions) {\n                return CrowdfundLifecycle.Won;\n            } else {\n                return CrowdfundLifecycle.Lost;\n            }\n        }\n\n        return CrowdfundLifecycle.Active;\n    }\n\n    function _processContribution(\n        address payable contributor,\n        address delegate,\n        uint96 amount\n    ) internal returns (uint96 votingPower) {\n        address oldDelegate = delegationsByContributor[contributor];\n        if (msg.sender == contributor || oldDelegate == address(0)) {\n            // Update delegate.\n            delegationsByContributor[contributor] = delegate;\n        } else {\n            // Prevent changing another's delegate if already delegated.\n            delegate = oldDelegate;\n        }\n\n        emit Contributed(msg.sender, contributor, amount, delegate);\n\n        // OK to contribute with zero just to update delegate.\n        if (amount == 0) return 0;\n\n        // Only allow contributions while the crowdfund is active.\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\n        if (lc != CrowdfundLifecycle.Active) {\n            revert WrongLifecycleError(lc);\n        }\n\n        // Check that the contribution amount is within the allowed range.\n        uint96 minContribution_ = minContribution;\n        if (amount < minContribution_) {\n            revert BelowMinimumContributionsError(amount, minContribution_);\n        }\n        uint96 maxContribution_ = maxContribution;\n        if (amount > maxContribution_) {\n            revert AboveMaximumContributionsError(amount, maxContribution_);\n        }\n\n        uint96 newTotalContributions = totalContributions + amount;\n        uint96 maxTotalContributions_ = maxTotalContributions;\n        if (newTotalContributions >= maxTotalContributions_) {\n            totalContributions = maxTotalContributions_;\n\n            // Finalize the crowdfund.\n            // This occurs before refunding excess contribution to act as a\n            // reentrancy guard.\n            _finalize(maxTotalContributions_);\n\n            // Refund excess contribution.\n            uint96 refundAmount = newTotalContributions - maxTotalContributions;\n            if (refundAmount > 0) {\n                amount -= refundAmount;\n                payable(msg.sender).transferEth(refundAmount);\n            }\n        } else {\n            totalContributions = newTotalContributions;\n        }\n\n        // Subtract fee from contribution amount if applicable.\n        address payable fundingSplitRecipient_ = fundingSplitRecipient;\n        uint16 fundingSplitBps_ = fundingSplitBps;\n        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {\n            uint96 feeAmount = (amount * fundingSplitBps_) / 1e4;\n            amount -= feeAmount;\n        }\n\n        // Calculate voting power.\n        votingPower = (amount * exchangeRateBps) / 1e4;\n    }\n\n    function _calculateRefundAmount(uint96 votingPower) internal view returns (uint96 amount) {\n        amount = (votingPower * 1e4) / exchangeRateBps;\n\n        // Add back fee to contribution amount if applicable.\n        address payable fundingSplitRecipient_ = fundingSplitRecipient;\n        uint16 fundingSplitBps_ = fundingSplitBps;\n        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {\n            amount = (amount * 1e4) / (1e4 - fundingSplitBps_);\n        }\n    }\n\n    function finalize() external {\n        uint96 totalContributions_ = totalContributions;\n\n        // Check that the crowdfund is not already finalized.\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\n        if (lc == CrowdfundLifecycle.Active) {\n            // Allow host to finalize crowdfund early if it has reached its minimum goal.\n            if (!party.isHost(msg.sender)) revert OnlyPartyHostError();\n\n            // Check that the crowdfund has reached its minimum goal.\n            uint96 minTotalContributions_ = minTotalContributions;\n            if (totalContributions_ < minTotalContributions_) {\n                revert NotEnoughContributionsError(totalContributions_, minTotalContributions_);\n            }\n        } else {\n            // Otherwise only allow finalization if the crowdfund has expired\n            // and been won. Can be finalized by anyone.\n            if (lc != CrowdfundLifecycle.Won) {\n                revert WrongLifecycleError(lc);\n            }\n        }\n\n        // Finalize the crowdfund.\n        _finalize(totalContributions_);\n    }\n\n    function _finalize(uint96 totalContributions_) internal {\n        // Finalize the crowdfund.\n        delete expiry;\n\n        // Update the party's total voting power.\n        uint96 newVotingPower = (totalContributions_ * exchangeRateBps) / 1e4;\n        party.increaseTotalVotingPower(newVotingPower);\n\n        // Transfer fee to recipient if applicable.\n        address payable fundingSplitRecipient_ = fundingSplitRecipient;\n        uint16 fundingSplitBps_ = fundingSplitBps;\n        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {\n            uint96 feeAmount = (totalContributions_ * fundingSplitBps_) / 1e4;\n            totalContributions_ -= feeAmount;\n            fundingSplitRecipient_.transferEth(feeAmount);\n        }\n\n        // Transfer ETH to the party.\n        payable(address(party)).transferEth(totalContributions_);\n    }\n}"
    },
    {
      "filename": "contracts/crowdfund/ReraiseETHCrowdfund.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./ETHCrowdfundBase.sol\";\nimport \"../crowdfund/CrowdfundNFT.sol\";\nimport \"../utils/LibAddress.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/LibSafeCast.sol\";\nimport \"../tokens/ERC721Receiver.sol\";\nimport \"../party/Party.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../gatekeepers/IGateKeeper.sol\";\n\n/// @notice A crowdfund for raising additional funds for an existing parties.\ncontract ReraiseETHCrowdfund is ETHCrowdfundBase, CrowdfundNFT {\n    using LibRawResult for bytes;\n    using LibSafeCast for uint256;\n    using LibAddress for address payable;\n\n    struct BatchContributeArgs {\n        // The address to which voting power will be delegated for all contributions.\n        address delegate;\n        // The contribution amounts in wei. The length of this array must be\n        // equal to the length of `tokenIds`.\n        uint96[] values;\n        // The data required to be validated by the `gatekeeper`, if set. If no\n        // `gatekeeper` is set, this can be empty.\n        bytes[] gateDatas;\n    }\n\n    struct BatchContributeForArgs {\n        // Addresses of to credit the contributions under. Each contribution\n        // amount in `values` corresponds to a recipient in this array.\n        address payable[] recipients;\n        // The delegate to set for each recipient if they have not delegated\n        // before.\n        address[] initialDelegates;\n        // The contribution amounts in wei. The length of this array must be\n        // equal to the length of `recipients`.\n        uint96[] values;\n        // The data required to be validated by the `gatekeeper`, if set. If no\n        // `gatekeeper` is set, this can be empty.\n        bytes[] gateDatas;\n        // Whether to revert if any individual contribution fails or continue.\n        bool revertOnFailure;\n    }\n\n    event Claimed(address indexed contributor, uint256 indexed tokenId, uint256 votingPower);\n    event Refunded(address indexed contributor, uint256 amount);\n\n    error RemainingVotingPowerAfterClaimError(uint256 remainingVotingPower);\n\n    // The `Globals` contract storing global configuration values. This contract\n    // is immutable and itâ€™s address will never change.\n    IGlobals private immutable _GLOBALS;\n\n    /// @notice The amount of voting power that will be received by a\n    ///         contributor after the crowdfund is won.\n    mapping(address => uint96) public pendingVotingPower;\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) CrowdfundNFT(globals) {\n        _GLOBALS = globals;\n    }\n\n    /// @notice Initializer to be delegatecalled by `Proxy` constructor. Will\n    ///         revert if called outside the constructor.\n    /// @param opts The options to initialize the crowdfund with.\n    function initialize(ETHCrowdfundOptions memory opts) external payable onlyConstructor {\n        // Initialize the crowdfund.\n        ETHCrowdfundBase._initialize(opts);\n\n        // Initialize the crowdfund NFT.\n        _initialize(\n            opts.party.name(),\n            opts.party.symbol(),\n            0 // Ignored. Will use customization preset from party.\n        );\n\n        // If the deployer passed in some ETH during deployment, credit them\n        // for the initial contribution.\n        uint96 initialContribution = msg.value.safeCastUint256ToUint96();\n        if (initialContribution > 0) {\n            // If this contract has ETH, either passed in during deployment or\n            // pre-existing, credit it to the `initialContributor`.\n            _contribute(opts.initialContributor, opts.initialDelegate, initialContribution, \"\");\n        }\n\n        // Set up gatekeeper after initial contribution (initial always gets in).\n        gateKeeper = opts.gateKeeper;\n        gateKeeperId = opts.gateKeeperId;\n    }\n\n    // Initialize name and symbol for crowdfund NFT.\n    function _initialize(string memory name_, string memory symbol_, uint256) internal override {\n        name = name_;\n        symbol = symbol_;\n\n        RendererStorage rendererStorage = RendererStorage(\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_RENDERER_STORAGE)\n        );\n\n        // Use the same customization preset as the party.\n        uint256 customizationPresetId = rendererStorage.getPresetFor(address(party));\n        if (customizationPresetId != 0) {\n            rendererStorage.useCustomizationPreset(customizationPresetId);\n        }\n    }\n\n    /// @notice Contribute ETH to this crowdfund on behalf of a contributor.\n    /// @param delegate The address to which voting power will be delegated to\n    ///                 during the governance phase.\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility.\n    /// @return votingPower The voting power the contributor receives for their\n    ///                     contribution.\n    function contribute(\n        address delegate,\n        bytes memory gateData\n    ) public payable onlyDelegateCall returns (uint96 votingPower) {\n        return\n            _contribute(\n                payable(msg.sender),\n                delegate,\n                msg.value.safeCastUint256ToUint96(),\n                gateData\n            );\n    }\n\n    /// @notice `contribute()` in batch form.\n    ///         May not revert if any individual contribution fails.\n    /// @param args The arguments to pass to each `contribute()` call.\n    /// @return votingPowers The voting power received for each contribution.\n    function batchContribute(\n        BatchContributeArgs calldata args\n    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {\n        uint256 numContributions = args.values.length;\n        votingPowers = new uint96[](numContributions);\n\n        uint256 ethAvailable = msg.value;\n        for (uint256 i; i < numContributions; ++i) {\n            ethAvailable -= args.values[i];\n\n            votingPowers[i] = _contribute(\n                payable(msg.sender),\n                args.delegate,\n                args.values[i],\n                args.gateDatas[i]\n            );\n        }\n\n        // Refund any unused ETH.\n        if (ethAvailable > 0) payable(msg.sender).transfer(ethAvailable);\n    }\n\n    /// @notice Contribute to this crowdfund on behalf of another address.\n    /// @param recipient The address to record the contribution under\n    /// @param initialDelegate The address to delegate to for the governance\n    ///                        phase if recipient hasn't delegated\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility\n    /// @return votingPower The voting power received for the contribution\n    function contributeFor(\n        address payable recipient,\n        address initialDelegate,\n        bytes memory gateData\n    ) external payable onlyDelegateCall returns (uint96 votingPower) {\n        return\n            _contribute(recipient, initialDelegate, msg.value.safeCastUint256ToUint96(), gateData);\n    }\n\n    /// @notice `contributeFor()` in batch form.\n    ///         May not revert if any individual contribution fails.\n    /// @param args The arguments for the batched `contributeFor()` calls.\n    /// @return votingPowers The voting power received for each contribution.\n    function batchContributeFor(\n        BatchContributeForArgs memory args\n    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {\n        uint256 numContributions = args.recipients.length;\n        votingPowers = new uint96[](numContributions);\n\n        uint256 ethAvailable = msg.value;\n        for (uint256 i; i < numContributions; ++i) {\n            ethAvailable -= args.values[i];\n\n            (bool s, bytes memory r) = address(this).call{ value: args.values[i] }(\n                abi.encodeCall(\n                    this.contributeFor,\n                    (args.recipients[i], args.initialDelegates[i], args.gateDatas[i])\n                )\n            );\n\n            if (!s) {\n                if (args.revertOnFailure) {\n                    r.rawRevert();\n                }\n            } else {\n                votingPowers[i] = abi.decode(r, (uint96));\n            }\n        }\n\n        // Refund any unused ETH.\n        if (ethAvailable > 0) payable(msg.sender).transfer(ethAvailable);\n    }\n\n    function _contribute(\n        address payable contributor,\n        address delegate,\n        uint96 amount,\n        bytes memory gateData\n    ) private returns (uint96 votingPower) {\n        // Require a non-null delegate.\n        if (delegate == address(0)) {\n            revert InvalidDelegateError();\n        }\n\n        // Must not be blocked by gatekeeper.\n        IGateKeeper _gateKeeper = gateKeeper;\n        if (_gateKeeper != IGateKeeper(address(0))) {\n            if (!_gateKeeper.isAllowed(contributor, gateKeeperId, gateData)) {\n                revert NotAllowedByGateKeeperError(\n                    contributor,\n                    _gateKeeper,\n                    gateKeeperId,\n                    gateData\n                );\n            }\n        }\n\n        votingPower = _processContribution(contributor, delegate, amount);\n\n        // OK to contribute with zero just to update delegate.\n        if (amount == 0) return 0;\n\n        uint256 previousVotingPower = pendingVotingPower[contributor];\n\n        pendingVotingPower[contributor] += votingPower;\n\n        // Mint a crowdfund NFT if this is their first contribution.\n        if (previousVotingPower == 0) _mint(contributor);\n    }\n\n    /// @notice Claim a party card for a contributor if the crowdfund won. Can be called\n    ///         to claim for self or on another's behalf.\n    /// @param contributor The contributor to claim for.\n    function claim(address contributor) external {\n        claim(\n            0, // Mint a new party card.\n            contributor\n        );\n    }\n\n    /// @notice Claim a party card for a contributor if the crowdfund won. Can be called\n    ///         to claim for self or on another's behalf.\n    /// @param tokenId The ID of the party card to add voting power to. If 0, a\n    ///                new card will be minted.\n    /// @param contributor The contributor to claim for.\n    function claim(uint256 tokenId, address contributor) public {\n        // Check crowdfund lifecycle.\n        {\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\n            if (lc != CrowdfundLifecycle.Finalized) {\n                revert WrongLifecycleError(lc);\n            }\n        }\n\n        uint96 votingPower = pendingVotingPower[contributor];\n\n        if (votingPower == 0) return;\n\n        {\n            uint96 contribution = (votingPower * 1e4) / exchangeRateBps;\n            uint96 maxContribution_ = maxContribution;\n            // Check that the contribution equivalent of total pending voting\n            // power is not above the max contribution range. This can happen\n            // for contributors who contributed multiple times In this case, the\n            // `claimMultiple` function should be called instead. This is done\n            // so parties may use the minimum and maximum contribution values to\n            // limit the voting power of each card (e.g.  a party desiring a \"1\n            // card = 1 vote\"-like governance system where each card has equal\n            // voting power).\n            if (contribution > maxContribution_) {\n                revert AboveMaximumContributionsError(contribution, maxContribution_);\n            }\n        }\n\n        // Burn the crowdfund NFT.\n        _burn(contributor);\n\n        delete pendingVotingPower[contributor];\n\n        if (tokenId == 0) {\n            // Mint contributor a new party card.\n            tokenId = party.mint(contributor, votingPower, delegationsByContributor[contributor]);\n        } else if (disableContributingForExistingCard) {\n            revert ContributingForExistingCardDisabledError();\n        } else if (party.ownerOf(tokenId) == contributor) {\n            // Increase voting power of contributor's existing party card.\n            party.addVotingPower(tokenId, votingPower);\n        } else {\n            revert NotOwnerError();\n        }\n\n        emit Claimed(contributor, tokenId, votingPower);\n    }\n\n    /// @notice `claim()` in batch form.\n    ///         May not revert if any individual refund fails.\n    /// @param tokenIds The IDs of the party cards to add voting power to. If 0, a\n    ///                 new card will be minted.\n    /// @param contributors The contributors to claim for.\n    /// @param revertOnFailure If true, reverts if any individual claim fails.\n    function batchClaim(\n        uint256[] calldata tokenIds,\n        address[] calldata contributors,\n        bool revertOnFailure\n    ) external {\n        for (uint256 i; i < contributors.length; ++i) {\n            (bool s, bytes memory r) = address(this).call(\n                // Using `abi.encodeWithSignature()` instead of `abi.encodeCall()`\n                // because `abi.encodeCall()` doesn't support overloaded functions.\n                abi.encodeWithSignature(\"claim(uint256,address)\", tokenIds[i], contributors[i])\n            );\n            if (revertOnFailure && !s) {\n                r.rawRevert();\n            }\n        }\n    }\n\n    /// @notice Claim multiple party cards for a contributor if the crowdfund won. Can be called\n    ///         to claim for self or on another's behalf.\n    /// @param votingPowerByCard The voting power for each card claimed. Must add up to the\n    ///                          total pending voting power for the contributor.\n    /// @param contributor The contributor to claim for.\n    function claimMultiple(uint96[] memory votingPowerByCard, address contributor) external {\n        // Check crowdfund lifecycle.\n        {\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\n            if (lc != CrowdfundLifecycle.Finalized) {\n                revert WrongLifecycleError(lc);\n            }\n        }\n\n        uint256 votingPower = pendingVotingPower[contributor];\n\n        if (votingPower == 0) return;\n\n        // Burn the crowdfund NFT.\n        _burn(contributor);\n\n        delete pendingVotingPower[contributor];\n\n        address delegate = delegationsByContributor[contributor];\n        uint96 minContribution_ = minContribution;\n        uint96 maxContribution_ = maxContribution;\n        for (uint256 i; i < votingPowerByCard.length; ++i) {\n            if (votingPowerByCard[i] == 0) continue;\n\n            // Check that the contribution equivalent of voting power is within\n            // contribution range. This is done so parties may use the minimum\n            // and maximum contribution values to limit the voting power of each\n            // card (e.g. a party desiring a \"1 card = 1 vote\"-like governance\n            // system where each card has equal voting power).\n            uint96 contribution = (votingPowerByCard[i] * 1e4) / exchangeRateBps;\n            if (contribution < minContribution_) {\n                revert BelowMinimumContributionsError(contribution, minContribution_);\n            }\n\n            if (contribution > maxContribution_) {\n                revert AboveMaximumContributionsError(contribution, maxContribution_);\n            }\n\n            votingPower -= votingPowerByCard[i];\n\n            // Mint contributor a new party card.\n            uint256 tokenId = party.mint(contributor, votingPowerByCard[i], delegate);\n\n            emit Claimed(contributor, tokenId, votingPowerByCard[i]);\n        }\n\n        // Requires that all voting power is claimed because the contributor is\n        // expected to have burned their crowdfund NFT.\n        if (votingPower != 0) revert RemainingVotingPowerAfterClaimError(votingPower);\n    }\n\n    /// @notice `claimMultiple()` in batch form.\n    ///         May not revert if any individual refund fails.\n    /// @param votingPowerByCards The voting power for each card claimed for each\n    ///                           contributor. Must add up to the total pending\n    ///                           voting power for the contributor.\n    /// @param contributors The contributors to claim for.\n    /// @param revertOnFailure If true, reverts if any individual claim fails.\n    function batchClaimMultiple(\n        uint96[][] calldata votingPowerByCards,\n        address[] calldata contributors,\n        bool revertOnFailure\n    ) external {\n        for (uint256 i; i < contributors.length; ++i) {\n            (bool s, bytes memory r) = address(this).call(\n                abi.encodeCall(this.claimMultiple, (votingPowerByCards[i], contributors[i]))\n            );\n            if (revertOnFailure && !s) {\n                r.rawRevert();\n            }\n        }\n    }\n\n    /// @notice Refund the owner of a party card and burn it. Only available if\n    ///         the crowdfund lost. Can be called to refund for self or on\n    ///         another's behalf.\n    /// @param contributor The contributor to refund.\n    function refund(address payable contributor) external returns (uint96 amount) {\n        // Check crowdfund lifecycle.\n        {\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\n            if (lc != CrowdfundLifecycle.Lost) {\n                revert WrongLifecycleError(lc);\n            }\n        }\n\n        // Get amount to refund.\n        uint96 votingPower = pendingVotingPower[contributor];\n        amount = _calculateRefundAmount(votingPower);\n\n        if (amount == 0) return 0;\n\n        // Burn the crowdfund NFT.\n        _burn(contributor);\n\n        delete pendingVotingPower[contributor];\n\n        // Refund contributor.\n        contributor.transferEth(amount);\n\n        emit Refunded(contributor, amount);\n    }\n\n    /// @notice `refund()` in batch form.\n    ///         May not revert if any individual refund fails.\n    /// @param contributors The contributors to refund.\n    /// @param revertOnFailure If true, revert if any refund fails.\n    /// @return amounts The amounts of ETH refunded for each refund.\n    function batchRefund(\n        address payable[] calldata contributors,\n        bool revertOnFailure\n    ) external returns (uint96[] memory amounts) {\n        uint256 numRefunds = contributors.length;\n        amounts = new uint96[](numRefunds);\n\n        for (uint256 i; i < numRefunds; ++i) {\n            (bool s, bytes memory r) = address(this).call(\n                abi.encodeCall(this.refund, (contributors[i]))\n            );\n\n            if (!s) {\n                if (revertOnFailure) {\n                    r.rawRevert();\n                }\n            } else {\n                amounts[i] = abi.decode(r, (uint96));\n            }\n        }\n    }\n}"
    },
    {
      "filename": "sol-tests/crowdfund/ReraiseETHCrowdfund.t.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8;\n\nimport \"forge-std/Test.sol\";\n\nimport \"../../contracts/crowdfund/ReraiseETHCrowdfund.sol\";\nimport \"../../contracts/globals/Globals.sol\";\nimport \"../../contracts/utils/Proxy.sol\";\nimport \"../../contracts/party/PartyFactory.sol\";\nimport \"../../contracts/tokens/ERC721Receiver.sol\";\n\nimport \"../TestUtils.sol\";\n\ncontract ReraiseETHCrowdfundTest is Test, TestUtils, ERC721Receiver {\n    event Transfer(address indexed owner, address indexed to, uint256 indexed tokenId);\n    event Contributed(\n        address indexed sender,\n        address indexed contributor,\n        uint256 amount,\n        address delegate\n    );\n    event Refunded(address indexed contributor, uint256 amount);\n    event Claimed(address indexed contributor, uint256 indexed tokenId, uint256 votingPower);\n\n    Party party;\n    ReraiseETHCrowdfund reraiseETHCrowdfundImpl;\n\n    constructor() {\n        Globals globals = new Globals(address(this));\n\n        reraiseETHCrowdfundImpl = new ReraiseETHCrowdfund(globals);\n\n        globals.setAddress(LibGlobals.GLOBAL_PARTY_IMPL, address(new Party(globals)));\n        globals.setAddress(LibGlobals.GLOBAL_PARTY_FACTORY, address(new PartyFactory()));\n        globals.setAddress(LibGlobals.GLOBAL_RENDERER_STORAGE, address(new MockRendererStorage()));\n\n        Party.PartyInitData memory partyOpts;\n        partyOpts.options.governance.voteDuration = 7 days;\n        partyOpts.options.governance.executionDelay = 1 days;\n        partyOpts.options.governance.passThresholdBps = 0.5e4;\n        partyOpts.options.governance.hosts = new address[](1);\n        partyOpts.options.governance.hosts[0] = address(this);"
    }
  ]
}