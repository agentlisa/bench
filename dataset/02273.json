{
  "Title": "M-3: Oracle slippage rate is used for checking primary and secondary ratio",
  "Content": "# Issue M-3: Oracle slippage rate is used for checking primary and secondary ratio \n\nSource: https://github.com/sherlock-audit/2023-02-notional-judging/issues/18 \n\n## Found by \nxiaoming90\n\n## Summary\n\nThe oracle slippage rate (`oraclePriceDeviationLimitPercent`) is used for checking the ratio of the primary and secondary tokens to be deposited into the pool. \n\nAs a result, changing the `oraclePriceDeviationLimitPercent` setting to increase or decrease the allowable slippage between the spot and oracle prices can cause unexpected side-effects to the `_checkPrimarySecondaryRatio` function, which might break the `reinvestReward` function that relies on the `_checkPrimarySecondaryRatio` function under certain condition.\n\n## Vulnerability Detail\n\nThe `_checkPriceLimit` function is for the purpose of comparing the spot price with the oracle price. Thus, the slippage (`oraclePriceDeviationLimitPercent`) is specially selected for this purpose.\n\nhttps://github.com/sherlock-audit/2023-02-notional/blob/main/leveraged-vaults/contracts/vaults/common/internal/strategy/StrategyUtils.sol#L21\n\n```solidity\nFile: StrategyUtils.sol\n21:     function _checkPriceLimit(\n22:         StrategyContext memory strategyContext,\n23:         uint256 oraclePrice,\n24:         uint256 poolPrice\n25:     ) internal pure {\n26:         uint256 lowerLimit = (oraclePrice * \n27:             (VaultConstants.VAULT_PERCENT_BASIS - strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n28:             VaultConstants.VAULT_PERCENT_BASIS;\n29:         uint256 upperLimit = (oraclePrice * \n30:             (VaultConstants.VAULT_PERCENT_BASIS + strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n31:             VaultConstants.VAULT_PERCENT_BASIS;\n32: \n33:         if (poolPrice < lowerLimit || upperLimit < poolPrice) {\n34:             revert Errors.InvalidPrice(oraclePrice, poolPrice);\n35:         }\n36:     }\n```\n\nHowever, it was observed that `_checkPriceLimit` function is repurposed for checking if the ratio of the primary and secondary tokens to be deposited to the pool is more or less proportional to the pool's balances within the `_checkPrimarySecondaryRatio` function during reinvestment. \n\nThe `oraclePriceDeviationLimitPercent` setting should not be used here as it does not involve any oracle data. Thus, the correct way is to define another setting specifically for checking if the ratio of the primary and secondary tokens to be deposited to the pool is more or less proportional to the pool's balances.\n\nhttps://github.com/sherlock-audit/2023-02-notional/blob/main/leveraged-vaults/contracts/vaults/curve/internal/pool/Curve2TokenPoolUtils.sol#L147\n\n```solidity\nFile: Curve2TokenPoolUtils.sol\n147:     function _checkPrimarySecondaryRatio(\n148:         StrategyContext memory strategyContext,\n149:         uint256 primaryAmount, \n150:         uint256 secondaryAmount, \n151:         uint256 primaryPoolBalance, \n152:         uint256 secondaryPoolBalance\n153:     ) private pure {\n154:         uint256 totalAmount = primaryAmount + secondaryAmount;\n155:         uint256 totalPoolBalance = primaryPoolBalance + secondaryPoolBalance;\n156: \n157:         uint256 primaryPercentage = primaryAmount * CurveConstants.CURVE_PRECISION / totalAmount;        \n158:         uint256 expectedPrimaryPercentage = primaryPoolBalance * CurveConstants.CURVE_PRECISION / totalPoolBalance;\n159: \n160:         strategyContext._checkPriceLimit(expectedPrimaryPercentage, primaryPercentage);\n161: \n162:         uint256 secondaryPercentage = secondaryAmount * CurveConstants.CURVE_PRECISION / totalAmount;\n163:         uint256 expectedSecondaryPercentage = secondaryPoolBalance * CurveConstants.CURVE_PRECISION / totalPoolBalance;\n164: \n165:         strategyContext._checkPriceLimit(expectedSecondaryPercentage, secondaryPercentage);\n166:     }\n```\n\n## Impact\n\nChanging the `oraclePriceDeviationLimitPercent` setting to increase or decrease the allowable slippage between the spot price and oracle price can cause unexpected side-effects to the `_checkPrimarySecondaryRatio` function, which might break the `reinvestReward` function that relies on the `_checkPrimarySecondaryRatio` function under certain condition.\n\nAdditionally, the value chosen for the `oraclePriceDeviationLimitPercent` is to compare the spot price with the oracle price. Thus, it might not be the optimal value for checking if the ratio of the primary and secondary tokens deposited to the pool is more or less proportional to the pool's balances.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-notional/blob/main/leveraged-vaults/contracts/vaults/common/internal/strategy/StrategyUtils.sol#L21\n\nhttps://github.com/sherlock-audit/2023-02-notional/blob/main/leveraged-vaults/contracts/vaults/curve/internal/pool/Curve2TokenPoolUtils.sol#L147\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThere is a difference between the slippage for the following two items:\n\n- Allowable slippage between the spot price and oracle price\n- Allowable slippage between the ratio of the primary and secondary tokens to be deposited to the pool against the pool's balances\n\nSince they serve a different purposes, they should not share the same slippage. Consider defining a separate slippage setting and function for checking if the ratio of the primary and secondary tokens deposited to the pool is more or less proportional to the pool's balances.\n\n## Discussion\n\n**jeffywu**\n\nValid, should add a second setting here.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/52",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/common/internal/strategy/StrategyUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {VaultConstants} from \"../../VaultConstants.sol\";\nimport {StrategyContext, TradeParams, StrategyVaultState} from \"../../VaultTypes.sol\";\nimport {TokenUtils, IERC20} from \"../../../../utils/TokenUtils.sol\";\nimport {TradeHandler} from \"../../../../trading/TradeHandler.sol\";\nimport {Deployments} from \"../../../../global/Deployments.sol\";\nimport {Constants} from \"../../../../global/Constants.sol\";\nimport {ITradingModule, Trade, TradeType} from \"../../../../../interfaces/trading/ITradingModule.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {VaultStorage} from \"../../VaultStorage.sol\";\n\nlibrary StrategyUtils {\n    using TradeHandler for Trade;\n    using TokenUtils for IERC20;\n    using TypeConvert for uint256;\n    using VaultStorage for StrategyVaultState;\n\n    function _checkPriceLimit(\n        StrategyContext memory strategyContext,\n        uint256 oraclePrice,\n        uint256 poolPrice\n    ) internal pure {\n        uint256 lowerLimit = (oraclePrice * \n            (VaultConstants.VAULT_PERCENT_BASIS - strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            VaultConstants.VAULT_PERCENT_BASIS;\n        uint256 upperLimit = (oraclePrice * \n            (VaultConstants.VAULT_PERCENT_BASIS + strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            VaultConstants.VAULT_PERCENT_BASIS;\n\n        if (poolPrice < lowerLimit || upperLimit < poolPrice) {\n            revert Errors.InvalidPrice(oraclePrice, poolPrice);\n        }\n    }\n\n    /// @notice Converts strategy tokens to LP tokens\n    function _convertStrategyTokensToPoolClaim(StrategyContext memory context, uint256 strategyTokenAmount)\n        internal pure returns (uint256 poolClaim) {\n        require(strategyTokenAmount <= context.vaultState.totalStrategyTokenGlobal);\n        if (context.vaultState.totalStrategyTokenGlobal > 0) {\n            poolClaim = (strategyTokenAmount * context.vaultState.totalPoolClaim) / context.vaultState.totalStrategyTokenGlobal;\n        }\n    }\n\n    /// @notice Converts LP tokens to strategy tokens\n    function _convertPoolClaimToStrategyTokens(StrategyContext memory context, uint256 poolClaim)\n        internal pure returns (uint256 strategyTokenAmount) {\n        if (context.vaultState.totalPoolClaim == 0) {\n            // Strategy tokens are in 8 decimal precision. Scale the minted amount according to pool claim precision.\n            return (poolClaim * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / \n                context.poolClaimPrecision;\n        }\n\n        // Pool claim in maturity is calculated before the new pool tokens are minted, so this calculation\n        // is the tokens minted that will give the account a corresponding share of the new pool balance held.\n        // The precision here will be the same as strategy token supply.\n        strategyTokenAmount = (poolClaim * context.vaultState.totalStrategyTokenGlobal) / context.vaultState.totalPoolClaim;\n    }\n\n    function _executeTradeExactIn(\n        TradeParams memory params,\n        ITradingModule tradingModule,\n        address sellToken,\n        address buyToken,\n        uint256 amount,\n        bool useDynamicSlippage\n    ) internal returns (uint256 amountSold, uint256 amountBought) {\n        require(\n            params.tradeType == TradeType.EXACT_IN_SINGLE || params.tradeType == TradeType.EXACT_IN_BATCH\n        );\n        if (useDynamicSlippage) {\n            require(params.oracleSlippagePercentOrLimit <= Constants.SLIPPAGE_LIMIT_PRECISION);\n        }\n\n        // Sell residual secondary balance\n        Trade memory trade = Trade(\n            params.tradeType,\n            sellToken,\n            buyToken,\n            amount,\n            useDynamicSlippage ? 0 : params.oracleSlippagePercentOrLimit,\n            block.timestamp, // deadline\n            params.exchangeData\n        );\n\n        // stETH generally has deeper liquidity than wstETH, setting tradeUnwrapped\n        // to lets the contract trade in stETH instead of wstETH\n        if (params.tradeUnwrapped) {\n            if (sellToken == address(Deployments.WRAPPED_STETH)) {\n                trade.sellToken = Deployments.WRAPPED_STETH.stETH();\n                uint256 amountBeforeUnwrap = IERC20(trade.sellToken).balanceOf(address(this));\n                // NOTE: the amount returned by unwrap is not always accurate for some reason\n                Deployments.WRAPPED_STETH.unwrap(trade.amount);\n                trade.amount = IERC20(trade.sellToken).balanceOf(address(this)) - amountBeforeUnwrap;\n            }\n            if (buyToken == address(Deployments.WRAPPED_STETH)) {\n                trade.buyToken = Deployments.WRAPPED_STETH.stETH();\n            }\n        }\n\n        if (useDynamicSlippage) {\n            /// @dev params.oracleSlippagePercentOrLimit checked above\n            (amountSold, amountBought) = trade._executeTradeWithDynamicSlippage(\n                params.dexId, tradingModule, uint32(params.oracleSlippagePercentOrLimit)\n            );\n        } else {\n            (amountSold, amountBought) = trade._executeTrade(\n                params.dexId, tradingModule\n            );\n        }\n\n        if (params.tradeUnwrapped) {\n            if (sellToken == address(Deployments.WRAPPED_STETH)) {\n                // Setting amountSold to the original wstETH amount because _executeTradeWithDynamicSlippage\n                // returns the amount of stETH sold in this case\n                /// @notice amountSold == amount because this function only supports EXACT_IN trades\n                amountSold = amount;\n            }\n            if (buyToken == address(Deployments.WRAPPED_STETH) && amountBought > 0) {\n                // trade.buyToken == stETH here\n                IERC20(trade.buyToken).checkApprove(address(Deployments.WRAPPED_STETH), amountBought);\n                uint256 amountBeforeWrap = Deployments.WRAPPED_STETH.balanceOf(address(this));\n                /// @notice the amount returned by wrap is not always accurate for some reason\n                Deployments.WRAPPED_STETH.wrap(amountBought);\n                amountBought = Deployments.WRAPPED_STETH.balanceOf(address(this)) - amountBeforeWrap;\n            }\n        }\n    }\n\n    function _mintStrategyTokens(\n        StrategyContext memory strategyContext,\n        uint256 poolClaimMinted\n    ) internal returns (uint256 strategyTokensMinted) {\n        strategyTokensMinted = _convertPoolClaimToStrategyTokens(strategyContext, poolClaimMinted);\n\n        if (strategyTokensMinted == 0) {\n            revert Errors.ZeroStrategyTokens();\n        }\n\n        strategyContext.vaultState.totalPoolClaim += poolClaimMinted;\n        strategyContext.vaultState.totalStrategyTokenGlobal += strategyTokensMinted.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n\n    function _redeemStrategyTokens(\n        StrategyContext memory strategyContext,\n        uint256 strategyTokens\n    ) internal returns (uint256 poolClaim) {\n        poolClaim = _convertStrategyTokensToPoolClaim(strategyContext, strategyTokens);\n\n        if (poolClaim == 0) {\n            revert Errors.ZeroPoolClaim();\n        }\n\n        strategyContext.vaultState.totalPoolClaim -= poolClaim;\n        strategyContext.vaultState.totalStrategyTokenGlobal -= strategyTokens.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/curve/internal/pool/Curve2TokenPoolUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {Deployments} from \"../../../../global/Deployments.sol\";\nimport {\n    StrategyContext, \n    TwoTokenPoolContext,\n    StrategyVaultSettings, \n    StrategyVaultState,\n    DepositParams,\n    RedeemParams,\n    ReinvestRewardParams\n} from \"../../../common/VaultTypes.sol\";\nimport {CurveConstants} from \"../CurveConstants.sol\";\nimport {Curve2TokenPoolContext, ConvexStakingContext} from \"../../CurveVaultTypes.sol\";\nimport {TwoTokenPoolUtils} from \"../../../common/internal/pool/TwoTokenPoolUtils.sol\";\nimport {StrategyUtils} from \"../../../common/internal/strategy/StrategyUtils.sol\";\nimport {VaultStorage} from \"../../../common/VaultStorage.sol\";\nimport {VaultConstants} from \"../../../common/VaultConstants.sol\";\nimport {ICurve2TokenPool} from \"../../../../../interfaces/curve/ICurvePool.sol\";\n\nlibrary Curve2TokenPoolUtils {\n    using StrategyUtils for StrategyContext;\n    using Curve2TokenPoolUtils for Curve2TokenPoolContext;\n    using TwoTokenPoolUtils for TwoTokenPoolContext;\n    using TypeConvert for uint256;\n    using VaultStorage for StrategyVaultSettings;\n    using VaultStorage for StrategyVaultState;\n\n    function _deposit(\n        Curve2TokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        ConvexStakingContext memory stakingContext,\n        uint256 deposit,\n        DepositParams memory params\n    ) internal returns (uint256 strategyTokensMinted) {\n        uint256 secondaryAmount;\n        if (params.tradeData.length != 0) {\n            // Allows users to trade on a different DEX when joining\n            (uint256 primarySold, uint256 secondaryBought) = poolContext.basePool._tradePrimaryForSecondary({\n                strategyContext: strategyContext,\n                data: params.tradeData\n            });\n            deposit -= primarySold;\n            secondaryAmount = secondaryBought;\n        }\n\n        uint256 poolClaimMinted = poolContext._joinPoolAndStake({\n            strategyContext: strategyContext,\n            stakingContext: stakingContext,\n            primaryAmount: deposit,\n            secondaryAmount: secondaryAmount,\n            minPoolClaim: params.minPoolClaim\n        });\n\n        strategyTokensMinted = strategyContext._mintStrategyTokens(poolClaimMinted);\n    }\n\n    function _redeem(\n        Curve2TokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        ConvexStakingContext memory stakingContext,\n        uint256 strategyTokens,\n        RedeemParams memory params\n    ) internal returns (uint256 finalPrimaryBalance) {\n        uint256 poolClaim = strategyContext._redeemStrategyTokens(strategyTokens);\n\n        // Underlying token balances from exiting the pool\n        (uint256 primaryBalance, uint256 secondaryBalance)\n            = _unstakeAndExitPool(poolContext, stakingContext, poolClaim, params);\n\n        finalPrimaryBalance = primaryBalance;\n        if (secondaryBalance > 0) {\n            uint256 primaryPurchased = poolContext.basePool._sellSecondaryBalance(\n                strategyContext, params, secondaryBalance\n            );\n\n            finalPrimaryBalance += primaryPurchased;\n        }\n    }\n\n    function _getSpotPrice(\n        Curve2TokenPoolContext memory poolContext, \n        uint256 tokenIndex\n    ) internal view returns (uint256 spotPrice) {\n        require(tokenIndex < 2);\n        if (tokenIndex == 0) {\n            spotPrice = poolContext.curvePool.get_dy(\n                int8(poolContext.basePool.primaryIndex), \n                int8(poolContext.basePool.secondaryIndex), \n                10**poolContext.basePool.primaryDecimals // 1 unit of primary\n            );\n            uint256 secondaryPrecision = 10**poolContext.basePool.secondaryDecimals;\n            spotPrice = spotPrice * CurveConstants.CURVE_PRECISION / secondaryPrecision;\n        } else {\n            spotPrice = poolContext.curvePool.get_dy(\n                int8(poolContext.basePool.secondaryIndex),\n                int8(poolContext.basePool.primaryIndex), \n                10**poolContext.basePool.secondaryDecimals // 1 unit of secondary\n            );\n            uint256 primaryPrecision = 10**poolContext.basePool.primaryDecimals;\n            spotPrice = spotPrice * CurveConstants.CURVE_PRECISION / primaryPrecision;\n        }\n    }\n\n    function _validateSpotPriceAndPairPrice(\n        Curve2TokenPoolContext calldata poolContext,\n        StrategyContext memory strategyContext,\n        uint256 oraclePrice,\n        uint256 primaryAmount, \n        uint256 secondaryAmount\n    ) internal view {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        uint256 spotPrice = _getSpotPrice({\n            poolContext: poolContext,\n            tokenIndex: 0\n        });\n\n        /// @notice Check spotPrice against oracle price to make sure that \n        /// the pool is not being manipulated\n        strategyContext._checkPriceLimit(oraclePrice, spotPrice);\n\n        uint256 primaryPrecision = 10**poolContext.basePool.primaryDecimals;\n        uint256 secondaryPrecision = 10**poolContext.basePool.secondaryDecimals;\n\n        // Convert input amounts and pool amounts to CURVE_PRECISION (1e18)\n\n        primaryAmount = primaryAmount * strategyContext.poolClaimPrecision / primaryPrecision;\n        secondaryAmount = secondaryAmount * strategyContext.poolClaimPrecision / secondaryPrecision;\n\n        uint256 primaryPoolBalance = poolContext.basePool.primaryBalance * CurveConstants.CURVE_PRECISION \n            / primaryPrecision;\n        uint256 secondaryPoolBalance = poolContext.basePool.secondaryBalance * CurveConstants.CURVE_PRECISION \n            / secondaryPrecision;\n\n        return _checkPrimarySecondaryRatio({\n            strategyContext: strategyContext,\n            primaryAmount: primaryAmount,\n            secondaryAmount: secondaryAmount,\n            primaryPoolBalance: primaryPoolBalance,\n            secondaryPoolBalance: secondaryPoolBalance\n        });\n    }\n    \n    function _checkPrimarySecondaryRatio(\n        StrategyContext memory strategyContext,\n        uint256 primaryAmount, \n        uint256 secondaryAmount, \n        uint256 primaryPoolBalance, \n        uint256 secondaryPoolBalance\n    ) private pure {\n        uint256 totalAmount = primaryAmount + secondaryAmount;\n        uint256 totalPoolBalance = primaryPoolBalance + secondaryPoolBalance;\n\n        uint256 primaryPercentage = primaryAmount * CurveConstants.CURVE_PRECISION / totalAmount;        \n        uint256 expectedPrimaryPercentage = primaryPoolBalance * CurveConstants.CURVE_PRECISION / totalPoolBalance;\n\n        strategyContext._checkPriceLimit(expectedPrimaryPercentage, primaryPercentage);\n\n        uint256 secondaryPercentage = secondaryAmount * CurveConstants.CURVE_PRECISION / totalAmount;\n        uint256 expectedSecondaryPercentage = secondaryPoolBalance * CurveConstants.CURVE_PRECISION / totalPoolBalance;\n\n        strategyContext._checkPriceLimit(expectedSecondaryPercentage, secondaryPercentage);\n    }\n\n    /// @notice We value strategy tokens in terms of the primary balance. The time weighted\n    /// primary balance is used in order to prevent pool manipulation.\n    /// @param poolContext pool context variables\n    /// @param strategyContext strategy context variables\n    /// @param strategyTokenAmount amount of strategy tokens\n    /// @return underlyingValue underlying value of strategy tokens\n    function _convertStrategyToUnderlying(\n        Curve2TokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        uint256 strategyTokenAmount,\n        uint256 oraclePrice,\n        uint256 spotPrice\n    ) internal view returns (int256 underlyingValue) {\n        \n        uint256 poolClaim \n            = strategyContext._convertStrategyTokensToPoolClaim(strategyTokenAmount);\n\n        underlyingValue \n            = poolContext.basePool._getTimeWeightedPrimaryBalance({\n                strategyContext: strategyContext,\n                poolClaim: poolClaim,\n                oraclePrice: oraclePrice, \n                spotPrice: spotPrice\n            }).toInt();\n    }   \n\n    function _joinPoolAndStake(\n        Curve2TokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        ConvexStakingContext memory stakingContext,\n        uint256 primaryAmount,\n        uint256 secondaryAmount,\n        uint256 minPoolClaim\n    ) internal returns (uint256 poolClaimMinted) {\n        uint256[2] memory amounts;\n        uint256 msgValue;\n        amounts[poolContext.basePool.primaryIndex] = primaryAmount;\n        amounts[poolContext.basePool.secondaryIndex] = secondaryAmount;\n\n        if (poolContext.basePool.primaryToken == Deployments.ETH_ADDRESS) {\n            msgValue = primaryAmount;\n        } else if (poolContext.basePool.secondaryToken == Deployments.ETH_ADDRESS) {\n            msgValue = secondaryAmount;\n        }\n\n        poolClaimMinted = ICurve2TokenPool(address(poolContext.curvePool)).add_liquidity{value: msgValue}(\n            amounts, minPoolClaim\n        );\n\n        // Check pool claim threshold to make sure our share of the pool is\n        // below maxPoolShare\n        uint256 poolClaimThreshold = strategyContext.vaultSettings._poolClaimThreshold(\n            poolContext.basePool.poolToken.totalSupply()\n        );\n        uint256 poolClaimHeldAfterJoin = strategyContext.vaultState.totalPoolClaim + poolClaimMinted;\n        if (poolClaimThreshold < poolClaimHeldAfterJoin)\n            revert Errors.PoolShareTooHigh(poolClaimHeldAfterJoin, poolClaimThreshold);\n\n\n        bool success = stakingContext.booster.deposit(stakingContext.poolId, poolClaimMinted, true); // stake = true\n        require(success);    \n    }\n\n    function _unstakeAndExitPool(\n        Curve2TokenPoolContext memory poolContext,\n        ConvexStakingContext memory stakingContext,\n        uint256 poolClaim,\n        RedeemParams memory params\n    ) internal returns (uint256 primaryBalance, uint256 secondaryBalance) {\n        // Withdraw pool tokens back to the vault for redemption\n        bool success = stakingContext.rewardPool.withdrawAndUnwrap(poolClaim, false); // claimRewards = false\n        if (!success) revert Errors.UnstakeFailed();\n\n        if (params.secondaryTradeParams.length == 0) {\n            // Redeem single-sided\n            primaryBalance = ICurve2TokenPool(address(poolContext.curvePool)).remove_liquidity_one_coin(\n                poolClaim, int8(poolContext.basePool.primaryIndex), params.minPrimary\n            );\n        } else {\n            // Redeem proportionally\n            uint256[2] memory minAmounts;\n            minAmounts[poolContext.basePool.primaryIndex] = params.minPrimary;\n            minAmounts[poolContext.basePool.secondaryIndex] = params.minSecondary;\n            uint256[2] memory exitBalances = ICurve2TokenPool(address(poolContext.curvePool)).remove_liquidity(\n                poolClaim, minAmounts\n            );\n\n            (primaryBalance, secondaryBalance) \n                = (exitBalances[poolContext.basePool.primaryIndex], exitBalances[poolContext.basePool.secondaryIndex]);\n        }\n    }\n\n    function _getSpotPriceAndOraclePrice(\n        Curve2TokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext\n    ) internal view returns (uint256 spotPrice, uint256 oraclePrice) {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        // Validate the spot price to make sure the pool is not being manipulated\n        spotPrice = poolContext._getSpotPrice(0); // tokenIndex\n        oraclePrice = poolContext.basePool._getOraclePairPrice(strategyContext);\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/common/internal/strategy/StrategyUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {VaultConstants} from \"../../VaultConstants.sol\";\nimport {StrategyContext, TradeParams, StrategyVaultState} from \"../../VaultTypes.sol\";\nimport {TokenUtils, IERC20} from \"../../../../utils/TokenUtils.sol\";\nimport {TradeHandler} from \"../../../../trading/TradeHandler.sol\";\nimport {Deployments} from \"../../../../global/Deployments.sol\";\nimport {Constants} from \"../../../../global/Constants.sol\";\nimport {ITradingModule, Trade, TradeType} from \"../../../../../interfaces/trading/ITradingModule.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {VaultStorage} from \"../../VaultStorage.sol\";\n\nlibrary StrategyUtils {\n    using TradeHandler for Trade;\n    using TokenUtils for IERC20;\n    using TypeConvert for uint256;\n    using VaultStorage for StrategyVaultState;\n\n    function _checkPriceLimit(\n        StrategyContext memory strategyContext,\n        uint256 oraclePrice,\n        uint256 poolPrice\n    ) internal pure {\n        uint256 lowerLimit = (oraclePrice * \n            (VaultConstants.VAULT_PERCENT_BASIS - strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            VaultConstants.VAULT_PERCENT_BASIS;\n        uint256 upperLimit = (oraclePrice * \n            (VaultConstants.VAULT_PERCENT_BASIS + strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            VaultConstants.VAULT_PERCENT_BASIS;\n\n        if (poolPrice < lowerLimit || upperLimit < poolPrice) {\n            revert Errors.InvalidPrice(oraclePrice, poolPrice);\n        }\n    }\n\n    /// @notice Converts strategy tokens to LP tokens\n    function _convertStrategyTokensToPoolClaim(StrategyContext memory context, uint256 strategyTokenAmount)\n        internal pure returns (uint256 poolClaim) {\n        require(strategyTokenAmount <= context.vaultState.totalStrategyTokenGlobal);\n        if (context.vaultState.totalStrategyTokenGlobal > 0) {\n            poolClaim = (strategyTokenAmount * context.vaultState.totalPoolClaim) / context.vaultState.totalStrategyTokenGlobal;\n        }\n    }\n\n    /// @notice Converts LP tokens to strategy tokens\n    function _convertPoolClaimToStrategyTokens(StrategyContext memory context, uint256 poolClaim)\n        internal pure returns (uint256 strategyTokenAmount) {\n        if (context.vaultState.totalPoolClaim == 0) {\n            // Strategy tokens are in 8 decimal precision. Scale the minted amount according to pool claim precision.\n            return (poolClaim * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / \n                context.poolClaimPrecision;\n        }\n\n        // Pool claim in maturity is calculated before the new pool tokens are minted, so this calculation\n        // is the tokens minted that will give the account a corresponding share of the new pool balance held.\n        // The precision here will be the same as strategy token supply.\n        strategyTokenAmount = (poolClaim * context.vaultState.totalStrategyTokenGlobal) / context.vaultState.totalPoolClaim;\n    }\n\n    function _executeTradeExactIn(\n        TradeParams memory params,\n        ITradingModule tradingModule,\n        address sellToken,\n        address buyToken,\n        uint256 amount,\n        bool useDynamicSlippage\n    ) internal returns (uint256 amountSold, uint256 amountBought) {\n        require(\n            params.tradeType == TradeType.EXACT_IN_SINGLE || params.tradeType == TradeType.EXACT_IN_BATCH\n        );\n        if (useDynamicSlippage) {\n            require(params.oracleSlippagePercentOrLimit <= Constants.SLIPPAGE_LIMIT_PRECISION);\n        }\n\n        // Sell residual secondary balance\n        Trade memory trade = Trade(\n            params.tradeType,\n            sellToken,\n            buyToken,\n            amount,\n            useDynamicSlippage ? 0 : params.oracleSlippagePercentOrLimit,\n            block.timestamp, // deadline\n            params.exchangeData\n        );\n\n        // stETH generally has deeper liquidity than wstETH, setting tradeUnwrapped\n        // to lets the contract trade in stETH instead of wstETH\n        if (params.tradeUnwrapped) {\n            if (sellToken == address(Deployments.WRAPPED_STETH)) {\n                trade.sellToken = Deployments.WRAPPED_STETH.stETH();\n                uint256 amountBeforeUnwrap = IERC20(trade.sellToken).balanceOf(address(this));\n                // NOTE: the amount returned by unwrap is not always accurate for some reason\n                Deployments.WRAPPED_STETH.unwrap(trade.amount);\n                trade.amount = IERC20(trade.sellToken).balanceOf(address(this)) - amountBeforeUnwrap;\n            }\n            if (buyToken == address(Deployments.WRAPPED_STETH)) {\n                trade.buyToken = Deployments.WRAPPED_STETH.stETH();\n            }\n        }\n\n        if (useDynamicSlippage) {\n            /// @dev params.oracleSlippagePercentOrLimit checked above\n            (amountSold, amountBought) = trade._executeTradeWithDynamicSlippage(\n                params.dexId, tradingModule, uint32(params.oracleSlippagePercentOrLimit)\n            );\n        } else {\n            (amountSold, amountBought) = trade._executeTrade(\n                params.dexId, tradingModule\n            );\n        }\n\n        if (params.tradeUnwrapped) {\n            if (sellToken == address(Deployments.WRAPPED_STETH)) {\n                // Setting amountSold to the original wstETH amount because _executeTradeWithDynamicSlippage\n                // returns the amount of stETH sold in this case\n                /// @notice amountSold == amount because this function only supports EXACT_IN trades\n                amountSold = amount;\n            }\n            if (buyToken == address(Deployments.WRAPPED_STETH) && amountBought > 0) {\n                // trade.buyToken == stETH here\n                IERC20(trade.buyToken).checkApprove(address(Deployments.WRAPPED_STETH), amountBought);\n                uint256 amountBeforeWrap = Deployments.WRAPPED_STETH.balanceOf(address(this));\n                /// @notice the amount returned by wrap is not always accurate for some reason\n                Deployments.WRAPPED_STETH.wrap(amountBought);\n                amountBought = Deployments.WRAPPED_STETH.balanceOf(address(this)) - amountBeforeWrap;\n            }\n        }\n    }\n\n    function _mintStrategyTokens(\n        StrategyContext memory strategyContext,\n        uint256 poolClaimMinted\n    ) internal returns (uint256 strategyTokensMinted) {\n        strategyTokensMinted = _convertPoolClaimToStrategyTokens(strategyContext, poolClaimMinted);\n\n        if (strategyTokensMinted == 0) {\n            revert Errors.ZeroStrategyTokens();\n        }\n\n        strategyContext.vaultState.totalPoolClaim += poolClaimMinted;\n        strategyContext.vaultState.totalStrategyTokenGlobal += strategyTokensMinted.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n\n    function _redeemStrategyTokens(\n        StrategyContext memory strategyContext,\n        uint256 strategyTokens\n    ) internal returns (uint256 poolClaim) {\n        poolClaim = _convertStrategyTokensToPoolClaim(strategyContext, strategyTokens);\n\n        if (poolClaim == 0) {\n            revert Errors.ZeroPoolClaim();\n        }\n\n        strategyContext.vaultState.totalPoolClaim -= poolClaim;\n        strategyContext.vaultState.totalStrategyTokenGlobal -= strategyTokens.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/curve/internal/pool/Curve2TokenPoolUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {Deployments} from \"../../../../global/Deployments.sol\";\nimport {\n    StrategyContext, \n    TwoTokenPoolContext,\n    StrategyVaultSettings, \n    StrategyVaultState,\n    DepositParams,\n    RedeemParams,\n    ReinvestRewardParams\n} from \"../../../common/VaultTypes.sol\";\nimport {CurveConstants} from \"../CurveConstants.sol\";\nimport {Curve2TokenPoolContext, ConvexStakingContext} from \"../../CurveVaultTypes.sol\";\nimport {TwoTokenPoolUtils} from \"../../../common/internal/pool/TwoTokenPoolUtils.sol\";\nimport {StrategyUtils} from \"../../../common/internal/strategy/StrategyUtils.sol\";\nimport {VaultStorage} from \"../../../common/VaultStorage.sol\";\nimport {VaultConstants} from \"../../../common/VaultConstants.sol\";\nimport {ICurve2TokenPool} from \"../../../../../interfaces/curve/ICurvePool.sol\";\n\nlibrary Curve2TokenPoolUtils {\n    using StrategyUtils for StrategyContext;\n    using Curve2TokenPoolUtils for Curve2TokenPoolContext;\n    using TwoTokenPoolUtils for TwoTokenPoolContext;\n    using TypeConvert for uint256;\n    using VaultStorage for StrategyVaultSettings;\n    using VaultStorage for StrategyVaultState;\n\n    function _deposit(\n        Curve2TokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        ConvexStakingContext memory stakingContext,\n        uint256 deposit,\n        DepositParams memory params\n    ) internal returns (uint256 strategyTokensMinted) {\n        uint256 secondaryAmount;\n        if (params.tradeData.length != 0) {\n            // Allows users to trade on a different DEX when joining\n            (uint256 primarySold, uint256 secondaryBought) = poolContext.basePool._tradePrimaryForSecondary({\n                strategyContext: strategyContext,\n                data: params.tradeData\n            });\n            deposit -= primarySold;\n            secondaryAmount = secondaryBought;\n        }\n\n        uint256 poolClaimMinted = poolContext._joinPoolAndStake({\n            strategyContext: strategyContext,\n            stakingContext: stakingContext,\n            primaryAmount: deposit,\n            secondaryAmount: secondaryAmount,\n            minPoolClaim: params.minPoolClaim\n        });\n\n        strategyTokensMinted = strategyContext._mintStrategyTokens(poolClaimMinted);\n    }\n\n    function _redeem(\n        Curve2TokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        ConvexStakingContext memory stakingContext,\n        uint256 strategyTokens,\n        RedeemParams memory params\n    ) internal returns (uint256 finalPrimaryBalance) {\n        uint256 poolClaim = strategyContext._redeemStrategyTokens(strategyTokens);\n\n        // Underlying token balances from exiting the pool\n        (uint256 primaryBalance, uint256 secondaryBalance)\n            = _unstakeAndExitPool(poolContext, stakingContext, poolClaim, params);\n\n        finalPrimaryBalance = primaryBalance;\n        if (secondaryBalance > 0) {\n            uint256 primaryPurchased = poolContext.basePool._sellSecondaryBalance(\n                strategyContext, params, secondaryBalance\n            );\n\n            finalPrimaryBalance += primaryPurchased;\n        }\n    }\n\n    function _getSpotPrice(\n        Curve2TokenPoolContext memory poolContext, \n        uint256 tokenIndex\n    ) internal view returns (uint256 spotPrice) {\n        require(tokenIndex < 2);\n        if (tokenIndex == 0) {\n            spotPrice = poolContext.curvePool.get_dy(\n                int8(poolContext.basePool.primaryIndex), \n                int8(poolContext.basePool.secondaryIndex), \n                10**poolContext.basePool.primaryDecimals // 1 unit of primary\n            );\n            uint256 secondaryPrecision = 10**poolContext.basePool.secondaryDecimals;\n            spotPrice = spotPrice * CurveConstants.CURVE_PRECISION / secondaryPrecision;\n        } else {\n            spotPrice = poolContext.curvePool.get_dy(\n                int8(poolContext.basePool.secondaryIndex),\n                int8(poolContext.basePool.primaryIndex), \n                10**poolContext.basePool.secondaryDecimals // 1 unit of secondary\n            );\n            uint256 primaryPrecision = 10**poolContext.basePool.primaryDecimals;\n            spotPrice = spotPrice * CurveConstants.CURVE_PRECISION / primaryPrecision;\n        }\n    }\n\n    function _validateSpotPriceAndPairPrice(\n        Curve2TokenPoolContext calldata poolContext,\n        StrategyContext memory strategyContext,\n        uint256 oraclePrice,\n        uint256 primaryAmount, \n        uint256 secondaryAmount\n    ) internal view {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        uint256 spotPrice = _getSpotPrice({\n            poolContext: poolContext,\n            tokenIndex: 0\n        });\n\n        /// @notice Check spotPrice against oracle price to make sure that \n        /// the pool is not being manipulated\n        strategyContext._checkPriceLimit(oraclePrice, spotPrice);\n\n        uint256 primaryPrecision = 10**poolContext.basePool.primaryDecimals;\n        uint256 secondaryPrecision = 10**poolContext.basePool.secondaryDecimals;\n\n        // Convert input amounts and pool amounts to CURVE_PRECISION (1e18)\n\n        primaryAmount = primaryAmount * strategyContext.poolClaimPrecision / primaryPrecision;\n        secondaryAmount = secondaryAmount * strategyContext.poolClaimPrecision / secondaryPrecision;\n\n        uint256 primaryPoolBalance = poolContext"
    }
  ]
}