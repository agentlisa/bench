{
  "Title": "[M-24] Staking `preSign` could use some basic validations",
  "Content": "_Submitted by Alex the Entreprenerd_\n\nThe function `preSign` accepts any `orderUid`.<br>\n`function preSign(bytes calldata orderUid) external onlyOwner`\n\nBecause of how Cowswap works, accepting any `orderUid` can be used as a rug-vector.\n\nThis is because the orderData contains a `receiver` which in lack of validation could be any address.\n\nYou'd also be signing other parameters such as minOut and how long the order could be filled for, which you may or may not want to validate to give stronger security guarantees to end users.\n\n### Recomended Mitigation Steps\n\nI'd recommend adding basic validation for tokenOut, minOut and receiver.\n\nFeel free to check the work we've done at Badger to validate order parameters, giving way stronger guarantees to end users.\n<https://github.com/GalloDaSballo/fair-selling/blob/44c0c0629289a0c4ccb3ca971cc5cd665ce5cb82/contracts/CowSwapSeller.sol#L194>\n\nAlso notice how through the code above we are able to re-construct the `orderUid`, feel free to re-use that code which has been validated by the original Cowswap / GPv2 Developers.\n\n**[toshiSat (Yieldy) confirmed, resolved and commented](https://github.com/code-423n4/2022-06-yieldy-findings/issues/172#issuecomment-1201510899):**\n > Thanks for the functions, I like what you guys did.  Our cowswap function is only called using the `onlyOwner` modifier, so I think it's pretty safe, but I agree some validation would be better than none.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-06-yieldy-contest",
  "Code": [
    {
      "filename": "contracts/CowSwapSeller.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n\nimport {IERC20} from \"@oz/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@oz/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"@oz/security/ReentrancyGuard.sol\";\n\n\nimport \"../interfaces/uniswap/IUniswapRouterV2.sol\";\nimport \"../interfaces/curve/ICurveRouter.sol\";\nimport \"../interfaces/cowswap/ICowSettlement.sol\";\n\n// Onchain Pricing Interface\nstruct Quote {\n    string name;\n    uint256 amountOut;\n}\ninterface OnChainPricing {\n  function findOptimalSwap(address tokenIn, address tokenOut, uint256 amountIn) external returns (Quote memory);\n}\n// END OnchainPricing\n\n/// @title CowSwapSeller\n/// @author Alex the Entreprenerd @ BadgerDAO\n/// @dev Cowswap seller, a smart contract that receives order data and verifies if the order is worth going for\n/// @notice CREDITS\n/// Thank you Cowswap Team as well as Poolpi\n/// @notice For the awesome project and the tutorial: https://hackmd.io/@2jvugD4TTLaxyG3oLkPg-g/H14TQ1Omt\ncontract CowSwapSeller is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    OnChainPricing public pricer; // Contract we will ask for a fair price of before accepting the cowswap order\n\n    address public manager;\n\n    address public constant DEV_MULTI = 0xB65cef03b9B89f99517643226d76e286ee999e77;\n\n    /// Contract we give allowance to perform swaps\n    address public constant RELAYER = 0xC92E8bdf79f0507f65a392b0ab4667716BFE0110;\n\n    ICowSettlement public constant SETTLEMENT = ICowSettlement(0x9008D19f58AAbD9eD0D60971565AA8510560ab41);\n\n    bytes32 private constant TYPE_HASH =\n        hex\"d5a25ba2e97094ad7d83dc28a6572da797d6b3e7fc6663bd93efb789fc17e489\";\n\n    // keccak256(\"sell\")\n    bytes32 public constant KIND_SELL =\n        hex\"f3b277728b3fee749481eb3e0b3b48980dbbab78658fc419025cb16eee346775\";\n    // keccak256(\"erc20\")\n    bytes32 public constant BALANCE_ERC20 =\n        hex\"5a28e9363bb942b639270062aa6bb295f434bcdfc42c97267bf003f272060dc9\";\n\n    /// @dev The domain separator used for signing orders that gets mixed in\n    /// making signatures for different domains incompatible. This domain\n    /// separator is computed following the EIP-712 standard and has replay\n    /// protection mixed in so that signed orders are only valid for specific\n    /// GPv2 contracts.\n    /// @notice Copy pasted from mainnet because we need this\n    bytes32 public immutable domainSeparator;\n        // Cowswap Order Data Interface \n    uint256 constant UID_LENGTH = 56;\n\n    struct Data {\n        IERC20 sellToken;\n        IERC20 buyToken;\n        address receiver;\n        uint256 sellAmount;\n        uint256 buyAmount;\n        uint32 validTo;\n        bytes32 appData;\n        uint256 feeAmount;\n        bytes32 kind;\n        bool partiallyFillable;\n        bytes32 sellTokenBalance;\n        bytes32 buyTokenBalance;\n    }\n        \n\n    /// @dev Packs order UID parameters into the specified memory location. The\n    /// result is equivalent to `abi.encodePacked(...)` with the difference that\n    /// it allows re-using the memory for packing the order UID.\n    ///\n    /// This function reverts if the order UID buffer is not the correct size.\n    ///\n    /// @param orderUid The buffer pack the order UID parameters into.\n    /// @param orderDigest The EIP-712 struct digest derived from the order\n    /// parameters.\n    /// @param owner The address of the user who owns this order.\n    /// @param validTo The epoch time at which the order will stop being valid.\n    function packOrderUidParams(\n        bytes memory orderUid,\n        bytes32 orderDigest,\n        address owner,\n        uint32 validTo\n    ) pure public {\n        require(orderUid.length == UID_LENGTH, \"GPv2: uid buffer overflow\");\n\n        // NOTE: Write the order UID to the allocated memory buffer. The order\n        // parameters are written to memory in **reverse order** as memory\n        // operations write 32-bytes at a time and we want to use a packed\n        // encoding. This means, for example, that after writing the value of\n        // `owner` to bytes `20:52`, writing the `orderDigest` to bytes `0:32`\n        // will **overwrite** bytes `20:32`. This is desirable as addresses are\n        // only 20 bytes and `20:32` should be `0`s:\n        //\n        //        |           1111111111222222222233333333334444444444555555\n        //   byte | 01234567890123456789012345678901234567890123456789012345\n        // -------+---------------------------------------------------------\n        //  field | [.........orderDigest..........][......owner.......][vT]\n        // -------+---------------------------------------------------------\n        // mstore |                         [000000000000000000000000000.vT]\n        //        |                     [00000000000.......owner.......]\n        //        | [.........orderDigest..........]\n        //\n        // Additionally, since Solidity `bytes memory` are length prefixed,\n        // 32 needs to be added to all the offsets.\n        //\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(add(orderUid, 56), validTo)\n            mstore(add(orderUid, 52), owner)\n            mstore(add(orderUid, 32), orderDigest)\n        }\n    }\n    constructor(address _pricer) {\n        pricer = OnChainPricing(_pricer);\n        manager = msg.sender;\n\n        // Fetch the domainSeparator from Settlement from THIS chain\n        domainSeparator = SETTLEMENT.domainSeparator();\n    }\n\n    function setPricer(OnChainPricing newPricer) external {\n        require(msg.sender == DEV_MULTI);\n        pricer = newPricer;\n    }\n\n    function setManager(address newManager) external {\n        require(msg.sender == manager);\n        manager = newManager;\n    }\n\n    /// @dev Return the EIP-712 signing hash for the specified order.\n    ///\n    /// @param order The order to compute the EIP-712 signing hash for.\n    /// @param separator The EIP-712 domain separator to use.\n    /// @return orderDigest The 32 byte EIP-712 struct hash.\n    function getHash(Data memory order, bytes32 separator)\n        public\n        pure\n        returns (bytes32 orderDigest)\n    {\n        bytes32 structHash;\n\n        // NOTE: Compute the EIP-712 order struct hash in place. As suggested\n        // in the EIP proposal, noting that the order struct has 10 fields, and\n        // including the type hash `(12 + 1) * 32 = 416` bytes to hash.\n        // <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#rationale-for-encodedata>\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let dataStart := sub(order, 32)\n            let temp := mload(dataStart)\n            mstore(dataStart, TYPE_HASH)\n            structHash := keccak256(dataStart, 416)\n            mstore(dataStart, temp)\n        }\n\n        // NOTE: Now that we have the struct hash, compute the EIP-712 signing\n        // hash using scratch memory past the free memory pointer. The signing\n        // hash is computed from `\"\\x19\\x01\" || domainSeparator || structHash`.\n        // <https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html#layout-in-memory>\n        // <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#specification>\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, \"\\x19\\x01\")\n            mstore(add(freeMemoryPointer, 2), separator)\n            mstore(add(freeMemoryPointer, 34), structHash)\n            orderDigest := keccak256(freeMemoryPointer, 66)\n        }\n    }\n\n    function getOrderID(Data calldata orderData) public view returns (bytes memory) {\n        // Allocated\n        bytes memory orderUid = new bytes(UID_LENGTH);\n\n        // Get the hash\n        bytes32 digest = getHash(orderData, domainSeparator);\n        packOrderUidParams(orderUid, digest, address(this), orderData.validTo);\n\n        return orderUid;\n    }\n\n    function checkCowswapOrder(Data calldata orderData, bytes memory orderUid) public virtual returns(bool) {\n        // Verify we get the same ID\n        // NOTE: technically superfluous as we could just derive the id and setPresignature with that\n        // But nice for internal testing\n        bytes memory derivedOrderID = getOrderID(orderData);\n        require(keccak256(derivedOrderID) == keccak256(orderUid));\n\n        require(orderData.validTo > block.timestamp);\n        require(orderData.receiver == address(this));\n        require(keccak256(abi.encodePacked(orderData.kind)) == keccak256(abi.encodePacked(KIND_SELL)));\n\n        // TODO: This should be done by using a gas cost oracle (see Chainlink)\n        require(orderData.feeAmount <= orderData.sellAmount / 10); // Fee can be at most 1/10th of order\n\n        // Check the price we're agreeing to. Before we continue, let's get a full onChain quote as baseline\n        address tokenIn = address(orderData.sellToken);\n        address tokenOut = address(orderData.buyToken);\n\n        uint256 amountIn = orderData.sellAmount;\n        uint256 amountOut = orderData.buyAmount;\n\n        Quote memory result = pricer.findOptimalSwap(tokenIn, tokenOut, amountIn);\n\n        // Require that Cowswap is offering a better price or matching\n        return(result.amountOut <= amountOut);\n    }\n\n\n    /// @dev This is the function you want to use to perform a swap on Cowswap via this smart contract\n    function _doCowswapOrder(Data calldata orderData, bytes memory orderUid) internal nonReentrant {\n        require(msg.sender == manager);\n\n        require(checkCowswapOrder(orderData, orderUid));\n\n        // Because swap is looking good, check we have the amount, then give allowance to the Cowswap Router\n        orderData.sellToken.safeApprove(RELAYER, 0); // Set to 0 just in case\n        orderData.sellToken.safeApprove(RELAYER, orderData.sellAmount + orderData.feeAmount);\n\n        // Once allowance is set, let's setPresignature and the order will happen\n        //setPreSignature\n        SETTLEMENT.setPreSignature(orderUid, true);\n    }\n\n    /// @dev Allows to cancel a cowswap order perhaps if it took too long or was with invalid parameters\n    /// @notice This function performs no checks, there's a high change it will revert if you send it with fluff parameters\n    function _cancelCowswapOrder(bytes memory orderUid) internal nonReentrant {\n        require(msg.sender == manager);\n\n        SETTLEMENT.setPreSignature(orderUid, false);\n    }\n}"
    }
  ]
}