{
  "Title": "[M-01] `LiquidInfrastructureERC20.sol` disapproved holders keep part of the supply, diluting approved holders revenue.",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2024-02-althea-liquid-infrastructure/blob/main/liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol#L222>\n\n### Impact\n\nWhen `LiquidInfrastructureERC20` owner disapproves a holder, it prevents the holder from receiving any revenue from the contract. However, the disapproved holder will still keep part of the supply, diluting the revenue of the approved holders.\n\nThe dilution is a result of the calculation of the entitlements per token held, which is based on the division of the ERC20 balances held by the `LiquidInfrastructureERC20` contract and the total supply of the `LiquidInfrastructureERC20` token.\n\n<https://github.com/code-423n4/2024-02-althea-liquid-infrastructure/blob/main/liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol#L257-L281>\n\n```solidity\n    function _beginDistribution() internal {\n        require(\n            !LockedForDistribution,\n            \"cannot begin distribution when already locked\"\n        );\n        LockedForDistribution = true;\n\n        // clear the previous entitlements, if any\n        if (erc20EntitlementPerUnit.length > 0) {\n            delete erc20EntitlementPerUnit;\n        }\n\n        // Calculate the entitlement per token held\n        uint256 supply = this.totalSupply();\n        for (uint i = 0; i < distributableERC20s.length; i++) {\n            uint256 balance = IERC20(distributableERC20s[i]).balanceOf(\n                address(this)\n            );\n@>            uint256 entitlement = balance / supply;\n            erc20EntitlementPerUnit.push(entitlement);\n        }\n\n        nextDistributionRecipient = 0;\n        emit DistributionStarted();\n    }\n```\n\n### Proof of Concept\n\nTest Case:\n\n```solidity\n    function test_dilutedDistribution() public {\n        address nftOwner1 = makeAddr(\"nftOwner1\");\n        uint256 rewardAmount1 = 1000000;\n        nftOwners = [nftOwner1];\n\n        vm.prank(nftOwner1);\n        LiquidInfrastructureNFT nft1 = new LiquidInfrastructureNFT(\"nftAccount1\");\n\n        nfts = [nft1];\n\n        // Register one NFT as a source of reward erc20s\n\n        uint256 accountId = nft1.AccountId();\n\n        thresholdAmounts = [0];\n\n        // Transfer the NFT to ERC20 and manage\n\n        vm.startPrank(nftOwner1);\n        nft1.setThresholds(erc20Addresses, thresholdAmounts);\n        nft1.transferFrom(nftOwner1, address(infraERC20), accountId);\n        \n        vm.stopPrank();\n        assertEq(nft1.ownerOf(accountId), address(infraERC20));\n        vm.expectEmit(address(infraERC20));\n        emit AddManagedNFT(address(nft1));\n        vm.startPrank(erc20Owner);\n        infraERC20.addManagedNFT(address(nft1));\n        vm.roll(1);\n\n        // Allocate rewards to the NFT\n        erc20A.transfer(address(nft1), rewardAmount1);\n        assertEq(erc20A.balanceOf(address(nft1)), rewardAmount1);\n\n        // And then send the rewards to the ERC20\n\n        infraERC20.withdrawFromAllManagedNFTs();\n\n        // Approve holders\n        infraERC20.approveHolder(address(holder1));\n        infraERC20.approveHolder(address(holder2));\n\n        // Mint LiquidInfrastructureERC20 tokens to holders\n        // 200 total supply of LiquidInfrastructureERC20 tokens\n        infraERC20.mint(address(holder1), 100);\n        infraERC20.mint(address(holder2), 100); \n\n        // Wait for the minimum distribution period to pass\n        vm.roll(vm.getBlockNumber() + 500);\n\n        // Distribute revenue to holders\n        infraERC20.distributeToAllHolders();\n        console.log(\"First distribution (2 approved holders) \\n  balance of holder 1: %s\", erc20A.balanceOf(address(holder1)));\n        console.log(\"balance of holder 2: %s\", erc20A.balanceOf(address(holder2)));\n        console.log(\"balance remaining in infraERC20: %s\", erc20A.balanceOf(address(infraERC20)));\n\n        // Wait for the minimum distribution period to pass\n        vm.roll(vm.getBlockNumber() + 500);\n\n        // Allocate more rewards to the NFT\n        erc20A.transfer(address(nft1), rewardAmount1);\n        infraERC20.withdrawFromAllManagedNFTs();\n\n        // Holder 2 is no longer approved\n        infraERC20.disapproveHolder(address(holder2));\n\n        // Now there is 1 holder remaining, but the rewards are diluted\n        infraERC20.distributeToAllHolders();\n\n        console.log(\"\\n  Second distribution (1 approved holder) \\n  balance of holder 1: %s\", erc20A.balanceOf(address(holder1)));\n        console.log(\"balance of holder 2: %s\", erc20A.balanceOf(address(holder2)));\n\n        // There is remaining unallocated rewards in the contract\n        console.log(\"balance remaining in infraERC20: %s\", erc20A.balanceOf(address(infraERC20)));\n        // holder 2 has 100 LiquidInfrastructureERC20 tokens, this dilutes the rewards\n        assertEq(infraERC20.balanceOf(address(holder2)), 100);\n\n        // Wait for the minimum distribution period to pass\n        vm.roll(vm.getBlockNumber() + 500);\n\n        // Distribute revenue to holders\n        infraERC20.distributeToAllHolders();\n        console.log(\"\\n  Third distribution (1 approved holder) \\n  balance of holder 1: %s\", erc20A.balanceOf(address(holder1)));\n        console.log(\"balance of holder 2: %s\", erc20A.balanceOf(address(holder2)));\n        console.log(\"balance remaining in infraERC20: %s\", erc20A.balanceOf(address(infraERC20)));\n    }\n```\n\nLogs:\n\n      First distribution (2 approved holders)\n      balance of holder 1: 500000\n      balance of holder 2: 500000\n      balance remaining in infraERC20: 0\n\n      Second distribution (1 approved holder)\n      balance of holder 1: 1000000\n      balance of holder 2: 500000\n      balance remaining in infraERC20: 500000\n\n      Third distribution (1 approved holder)\n      balance of holder 1: 1250000\n      balance of holder 2: 500000\n      balance remaining in infraERC20: 250000\n\nSteps to reproduce the test:\n\nInside the `2024-02-althea-liquid-infrastructure/liquid-infrastructure` folder:\n\n1. `npm i --save-dev @nomicfoundation/hardhat-foundry` - Install the hardhat-foundry plugin.\n2. Add `require(\"@nomicfoundation/hardhat-foundry\");` to the top of the `hardhat.config.js` file.\n3. Run `npx hardhat init-foundry` in the terminal. This will generate a `foundry.toml` file based on the Hardhat project's existing configuration, and will install the forge-std library.\n4. Copy the full test suite case from below and paste it in a new file: `2024-02-althea-liquid-infrastructure/liquid-infrastructure/test/liquidInfrastructureERC20Test.t.sol`\n5. Run `forge test --mt test_dilutedDistribution -vv` in the terminal.\n\nFull Test Suite:\n\n<details>\n\n```solidity\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {Test, console} from \"forge-std/Test.sol\";\nimport {TestERC20A} from \"../contracts/TestERC20A.sol\";\nimport {LiquidInfrastructureERC20} from \"../contracts/LiquidInfrastructureERC20.sol\";\nimport {LiquidInfrastructureNFT} from \"../contracts/LiquidInfrastructureNFT.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract LiquidInfrastructureERC20Test is Test {\n    event AddManagedNFT(address nft);\n\n    address nftAccount1 = makeAddr(\"nftAccount1\");\n    address erc20Owner = makeAddr(\"erc20Owner\");\n    address holder1 = makeAddr(\"holder1\");\n    address holder2 = makeAddr(\"holder2\");\n\n    LiquidInfrastructureERC20 infraERC20;\n    address[] managedNFTs;\n    address[] approvedHolders;\n    address[] holders;\n    address[] nftOwners;\n    uint256[] thresholdAmounts;\n    LiquidInfrastructureNFT[] nfts;\n    ERC20[] rewardErc20s;\n\n    TestERC20A erc20A;\n\n    address[] erc20Addresses;\n\n    function setUp() public {\n        vm.startPrank(erc20Owner);\n        erc20A = new TestERC20A();\n\n        erc20Addresses.push(address(erc20A));\n\n        infraERC20 = new LiquidInfrastructureERC20({\n            _name: \"Infra\",\n            _symbol: \"INFRA\",\n            _managedNFTs: managedNFTs,\n            _approvedHolders: approvedHolders,\n            _minDistributionPeriod: 500,\n            _distributableErc20s: erc20Addresses\n        });\n        vm.stopPrank();\n    }\n\n    function test_dilutedDistribution() public {\n        address nftOwner1 = makeAddr(\"nftOwner1\");\n        uint256 rewardAmount1 = 1000000;\n        nftOwners = [nftOwner1];\n\n        vm.prank(nftOwner1);\n        LiquidInfrastructureNFT nft1 = new LiquidInfrastructureNFT(\"nftAccount1\");\n\n        nfts = [nft1];\n\n        // Register one NFT as a source of reward erc20s\n\n        uint256 accountId = nft1.AccountId();\n\n        thresholdAmounts = [0];\n\n        // Transfer the NFT to ERC20 and manage\n\n        vm.startPrank(nftOwner1);\n        nft1.setThresholds(erc20Addresses, thresholdAmounts);\n        nft1.transferFrom(nftOwner1, address(infraERC20), accountId);\n        \n        vm.stopPrank();\n        assertEq(nft1.ownerOf(accountId), address(infraERC20));\n        vm.expectEmit(address(infraERC20));\n        emit AddManagedNFT(address(nft1));\n        vm.startPrank(erc20Owner);\n        infraERC20.addManagedNFT(address(nft1));\n        vm.roll(1);\n\n        // Allocate rewards to the NFT\n        erc20A.transfer(address(nft1), rewardAmount1);\n        assertEq(erc20A.balanceOf(address(nft1)), rewardAmount1);\n\n        // And then send the rewards to the ERC20\n\n        infraERC20.withdrawFromAllManagedNFTs();\n\n        // Approve holders\n        infraERC20.approveHolder(address(holder1));\n        infraERC20.approveHolder(address(holder2));\n\n        // Mint LiquidInfrastructureERC20 tokens to holders\n        // 200 total supply of LiquidInfrastructureERC20 tokens\n        infraERC20.mint(address(holder1), 100);\n        infraERC20.mint(address(holder2), 100); \n\n        // Wait for the minimum distribution period to pass\n        vm.roll(vm.getBlockNumber() + 500);\n\n        // Distribute revenue to holders\n        infraERC20.distributeToAllHolders();\n        console.log(\"First distribution (2 approved holders) \\n  balance of holder 1: %s\", erc20A.balanceOf(address(holder1)));\n        console.log(\"balance of holder 2: %s\", erc20A.balanceOf(address(holder2)));\n        console.log(\"balance remaining in infraERC20: %s\", erc20A.balanceOf(address(infraERC20)));\n\n        // Wait for the minimum distribution period to pass\n        vm.roll(vm.getBlockNumber() + 500);\n\n        // Allocate more rewards to the NFT\n        erc20A.transfer(address(nft1), rewardAmount1);\n        infraERC20.withdrawFromAllManagedNFTs();\n\n        // Holder 2 is no longer approved\n        infraERC20.disapproveHolder(address(holder2));\n\n        // Now there is 1 holder remaining, but the rewards are diluted\n        infraERC20.distributeToAllHolders();\n\n        console.log(\"\\n  Second distribution (1 approved holder) \\n  balance of holder 1: %s\", erc20A.balanceOf(address(holder1)));\n        console.log(\"balance of holder 2: %s\", erc20A.balanceOf(address(holder2)));\n\n        // There is remaining unallocated rewards in the contract\n        console.log(\"balance remaining in infraERC20: %s\", erc20A.balanceOf(address(infraERC20)));\n        // holder 2 has 100 LiquidInfrastructureERC20 tokens, this dilutes the rewards\n        assertEq(infraERC20.balanceOf(address(holder2)), 100);\n\n        // Wait for the minimum distribution period to pass\n        vm.roll(vm.getBlockNumber() + 500);\n\n        // Distribute revenue to holders\n        infraERC20.distributeToAllHolders();\n        console.log(\"\\n  Third distribution (1 approved holder) \\n  balance of holder 1: %s\", erc20A.balanceOf(address(holder1)));\n        console.log(\"balance of holder 2: %s\", erc20A.balanceOf(address(holder2)));\n        console.log(\"balance remaining in infraERC20: %s\", erc20A.balanceOf(address(infraERC20)));\n    }\n}\n```\n\n</details>\n\n### Recommended Mitigation Steps\n\nTo prevent dilution of revenue for approved holders, consider implementing a mechanism to burn the tokens of disapproved holders upon disapproval.\n\nIn the event that disapproved holders are intended to retain their tokens for potential reapproval in the future, track the balance of the `LiquidInfrastructureERC20` tokens held by the holder at the time of their disapproval. Subsequently, burn the tokens. Upon reapproval, mint the same amount of tokens to the holder, ensuring they regain their previous token balance.\n\n**[ChristianBorst (Althea) confirmed and commented](https://github.com/code-423n4/2024-02-althea-liquid-infrastructure-findings/issues/703#issuecomment-1974262944):**\n > This is a good suggestion.\n\n**[0xA5DF (judge) commented](https://github.com/code-423n4/2024-02-althea-liquid-infrastructure-findings/issues/703#issuecomment-1976753505):**\n > Maintaining medium severity (despite some dupes suggesting high) since this would only affect part of the revenue (% of disapproved supply) and the funds aren't lost forever - they're kept in the contract and will be distributed in the next round.\n\n**[SovaSlava (warden) commented](https://github.com/code-423n4/2024-02-althea-liquid-infrastructure-findings/issues/703#issuecomment-1986367247):**\n > I think this is not a valid issue, because function `disapproveHolder()` is intended to limit the user's receipt of rewards and this is intended.\n> \n> To completely remove a user from the project and prevent him from receiving rewards, the owner must burn the user's tokens. The `disapproveHolder` function is not enough for this and the owner must know this.\n> \n> Owner could just call function `burnFromAndDistribute()` and `disapproveHolder()` in one tx.\n\n\n**[sl1 (warden) commented](https://github.com/code-423n4/2024-02-althea-liquid-infrastructure-findings/issues/703#issuecomment-1986780508):**\n > > Owner could just call function `burnFromAndDistribute()` and `disapproveHolder()` in one tx.\n> \n> Just as a note, `burnFromAndDistribute()` requires allowance, so it will be impossible for owner to just burn user's tokens.\n\n\n**[0xA5DF (judge) commented](https://github.com/code-423n4/2024-02-althea-liquid-infrastructure-findings/issues/703#issuecomment-1986810526):**\n > 1. The sponsor confirmed this is not the intended design.\n> 2. The current design doesn't actually reserve the reward for the disapproved holder, the remaining balance would be distributed in the next cycle to all holders equally.\n> \n> Maintaining medium severity.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-althea-liquid-infrastructure",
  "Code": [
    {
      "filename": "liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol",
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.12; // Force solidity compliance\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./LiquidInfrastructureNFT.sol\";\n\n/**\n * @title Liquid Infrastructure ERC20\n * @author Christian Borst <christian@althea.systems>\n *\n * @dev An ERC20 contract used to earn rewards from managed LiquidInfrastructreNFTs.\n *\n * A LiquidInfrastructureNFT typically represents some form of infrastructure involved in an Althea pay-per-forward network\n * which frequently receives payments from peers on the network for performing an automated service (e.g. providing internet).\n * This LiquidInfrastructureERC20 acts as a convenient aggregation layer to enable dead-simple investment in real-world assets\n * with automatic revenue accrual. Simply by holding this ERC20 owners are entitled to revenue from the network represented by the token.\n *\n * Revenue is gathered from managed LiquidInfrastructureNFTs by the protocol and distributed to token holders on a semi-regular basis,\n * where there is a minimum number of blocks required to elapse before a new payout to token holders.\n *\n * Minting and burning of this ERC20 is restricted if the minimum distribution period has elapsed, and it is reenabled once a new distribution is complete.\n */\ncontract LiquidInfrastructureERC20 is\n    ERC20,\n    ERC20Burnable,\n    Ownable,\n    ERC721Holder,\n    ReentrancyGuard\n{\n    event Deployed();\n    event DistributionStarted();\n    event Distribution(address recipient, address[] tokens, uint256[] amounts);\n    event DistributionFinished();\n    event WithdrawalStarted();\n    event Withdrawal(address source);\n    event WithdrawalFinished();\n    event AddManagedNFT(address nft);\n    event ReleaseManagedNFT(address nft, address to);\n\n    address[] private distributableERC20s;\n    uint256[] private erc20EntitlementPerUnit;\n    address[] private holders;\n\n    /**\n     * @notice This is the current version of the contract. Every update to the contract will introduce a new\n     * version, regardless of anticipated compatibility.\n     */\n    uint256 public constant Version = 1;\n\n    /**\n     * @notice This collection holds the managed LiquidInfrastructureNFTs which periodically generate revenue and deliver\n     * the balances to this contract.\n     */\n    address[] public ManagedNFTs;\n\n    /**\n     * @notice This collection holds the whitelist for accounts approved to hold the LiquidInfrastructureERC20\n     */\n    mapping(address => bool) public HolderAllowlist;\n\n    /**\n     * @notice Holds the block of the last distribution, used for limiting distribution lock ups\n     */\n    uint256 public LastDistribution;\n\n    /**\n     * @notice Holds the minimum number of blocks required to elapse before a new distribution can begin\n     */\n    uint256 public MinDistributionPeriod;\n\n    /**\n     * @notice When true, locks all transfers, mints, and burns until the current distribution has completed\n     */\n    bool public LockedForDistribution;\n\n    /**\n     * @dev Holds the index into `holders` of the next account owed the current distribution\n     */\n    uint256 internal nextDistributionRecipient;\n\n    /**\n     * @dev Holds the index into `ManagedNFTs` of the next contract to withdraw funds from\n     */\n    uint256 private nextWithdrawal;\n\n    /**\n     * Indicates if the account is approved to hold the ERC20 token or not\n     * @param account the potential holder of the token\n     */\n    function isApprovedHolder(address account) public view returns (bool) {\n        return HolderAllowlist[account];\n    }\n\n    /**\n     * Adds `holder` to the list of approved token holders. This is necessary before `holder` may receive any of the underlying ERC20.\n     * @notice this call will fail if `holder` is already approved. Call isApprovedHolder() first to avoid mistakes.\n     *\n     * @param holder the account to add to the allowlist\n     */\n    function approveHolder(address holder) public onlyOwner {\n        require(!isApprovedHolder(holder), \"holder already approved\");\n        HolderAllowlist[holder] = true;\n    }\n\n    /**\n     * Marks `holder` as NOT approved to hold the token, preventing them from receiving any more of the underlying ERC20.\n     *\n     * @param holder the account to add to the allowlist\n     */\n    function disapproveHolder(address holder) public onlyOwner {\n        require(isApprovedHolder(holder), \"holder not approved\");\n        HolderAllowlist[holder] = false;\n    }\n\n    /**\n     * Implements the lock during distributions, adds `to` to the list of holders when needed\n     * @param from token sender\n     * @param to  token receiver\n     * @param amount  amount sent\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        require(!LockedForDistribution, \"distribution in progress\");\n        if (!(to == address(0))) {\n            require(\n                isApprovedHolder(to),\n                \"receiver not approved to hold the token\"\n            );\n        }\n        if (from == address(0) || to == address(0)) {\n            _beforeMintOrBurn();\n        }\n        bool exists = (this.balanceOf(to) != 0);\n        if (!exists) {\n            holders.push(to);\n        }\n    }\n\n    /**\n     * Implements an additional lock on minting and burning, ensuring that supply changes happen after any potential distributions\n     */\n    function _beforeMintOrBurn() internal view {\n        require(\n            !_isPastMinDistributionPeriod(),\n            \"must distribute before minting or burning\"\n        );\n    }\n\n    /**\n     * Removes `from` from the list of holders when they no longer hold any balance\n     * @param from token sender\n     * @param to  token receiver\n     * @param amount  amount sent\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        bool stillHolding = (this.balanceOf(from) != 0);\n        if (!stillHolding) {\n            for (uint i = 0; i < holders.length; i++) {\n                if (holders[i] == from) {\n                    // Remove the element at i by copying the last one into its place and removing the last element\n                    holders[i] = holders[holders.length - 1];\n                    holders.pop();\n                }\n            }\n        }\n    }\n\n    /**\n     * Performs a distribution to all of the current holders, which may trigger out of gas errors if there are too many holders\n     */\n    function distributeToAllHolders() public {\n        uint256 num = holders.length;\n        if (num > 0) {\n            distribute(holders.length);\n        }\n    }\n\n    /**\n     * Begins or continues a distribution, preventing transfers, mints, and burns of the token until all rewards have been paid out\n     *\n     * @notice distributions may only begin once every MinDistributionPeriod.\n     *\n     * @param numDistributions the number of distributions to process in this execution\n     */\n    function distribute(uint256 numDistributions) public nonReentrant {\n        require(numDistributions > 0, \"must process at least 1 distribution\");\n        if (!LockedForDistribution) {\n            require(\n                _isPastMinDistributionPeriod(),\n                \"MinDistributionPeriod not met\"\n            );\n            _beginDistribution();\n        }\n\n        uint256 limit = Math.min(\n            nextDistributionRecipient + numDistributions,\n            holders.length\n        );\n\n        uint i;\n        for (i = nextDistributionRecipient; i < limit; i++) {\n            address recipient = holders[i];\n            if (isApprovedHolder(recipient)) {\n                uint256[] memory receipts = new uint256[](\n                    distributableERC20s.length\n                );\n                for (uint j = 0; j < distributableERC20s.length; j++) {\n                    IERC20 toDistribute = IERC20(distributableERC20s[j]);\n                    uint256 entitlement = erc20EntitlementPerUnit[j] *\n                        this.balanceOf(recipient);\n                    if (toDistribute.transfer(recipient, entitlement)) {\n                        receipts[j] = entitlement;\n                    }\n                }\n\n                emit Distribution(recipient, distributableERC20s, receipts);\n            }\n        }\n        nextDistributionRecipient = i;\n\n        if (nextDistributionRecipient == holders.length) {\n            _endDistribution();\n        }\n    }\n\n    /**\n     * Determines if the minimum distribution period has elapsed, which is used for restricting\n     * minting and burning operations\n     */\n    function _isPastMinDistributionPeriod() internal view returns (bool) {\n        // Do not force a distribution with no holders or supply\n        if (totalSupply() == 0 || holders.length == 0) {\n            return false;\n        }\n\n        return (block.number - LastDistribution) >= MinDistributionPeriod;\n    }\n\n    /**\n     * Prepares this contract for distribution:\n     * - Locks the contract\n     * - Calculates the entitlement to protocol-held ERC20s per unit of the LiquidInfrastructureERC20 held\n     */\n    function _beginDistribution() internal {\n        require(\n            !LockedForDistribution,\n            \"cannot begin distribution when already locked\"\n        );\n        LockedForDistribution = true;\n\n        // clear the previous entitlements, if any\n        if (erc20EntitlementPerUnit.length > 0) {\n            delete erc20EntitlementPerUnit;\n        }\n\n        // Calculate the entitlement per token held\n        uint256 supply = this.totalSupply();\n        for (uint i = 0; i < distributableERC20s.length; i++) {\n            uint256 balance = IERC20(distributableERC20s[i]).balanceOf(\n                address(this)\n            );\n            uint256 entitlement = balance / supply;\n            erc20EntitlementPerUnit.push(entitlement);\n        }\n\n        nextDistributionRecipient = 0;\n        emit DistributionStarted();\n    }\n\n    /**\n     * Unlocks this contract at the end of a distribution\n     */\n    function _endDistribution() internal {\n        require(\n            LockedForDistribution,\n            \"cannot end distribution when not locked\"\n        );\n        delete erc20EntitlementPerUnit;\n        LockedForDistribution = false;\n        LastDistribution = block.number;\n        emit DistributionFinished();\n    }\n\n    /**\n     * Convenience function that allows the contract owner to distribute when necessary and then mint right after\n     *\n     * @notice attempts to distribute to every holder in this block, which may exceed the block gas limit\n     * if this fails then first call distribute\n     */\n    function mintAndDistribute(\n        address account,\n        uint256 amount\n    ) public onlyOwner {\n        if (_isPastMinDistributionPeriod()) {\n            distributeToAllHolders();\n        }\n        mint(account, amount);\n    }\n\n    /**\n     * Allows the contract owner to mint tokens for an address\n     *\n     * @notice minting may only occur when a distribution has happened within MinDistributionPeriod blocks\n     */\n    function mint(\n        address account,\n        uint256 amount\n    ) public onlyOwner nonReentrant {\n        _mint(account, amount);\n    }\n\n    /**\n     * Convenience function that allows a token holder to distribute when necessary and then burn their tokens right after\n     *\n     * @notice attempts to distribute to every holder in this block, which may exceed the block gas limit\n     * if this fails then first call distribute() enough times to finish a distribution and then call burn()\n     */\n    function burnAndDistribute(uint256 amount) public {\n        if (_isPastMinDistributionPeriod()) {\n            distributeToAllHolders();\n        }\n        burn(amount);\n    }\n\n    /**\n     * Convenience function that allows an approved sender to distribute when necessary and then burn the approved tokens right after\n     *\n     * @notice attempts to distribute to every holder in this block, which may exceed the block gas limit\n     * if this fails then first call distribute() enough times to finish a distribution and then call burnFrom()\n     */\n    function burnFromAndDistribute(address account, uint256 amount) public {\n        if (_isPastMinDistributionPeriod()) {\n            distributeToAllHolders();\n        }\n        burnFrom(account, amount);\n    }\n\n    function withdrawFromAllManagedNFTs() public {\n        withdrawFromManagedNFTs(ManagedNFTs.length);\n    }\n\n    /**\n     * Performs withdrawals from the ManagedNFTs collection, depositing all token balances into the custody of this contract\n     * @param numWithdrawals the number of withdrawals to perform\n     */\n    function withdrawFromManagedNFTs(uint256 numWithdrawals) public {\n        require(!LockedForDistribution, \"cannot withdraw during distribution\");\n\n        if (nextWithdrawal == 0) {\n            emit WithdrawalStarted();\n        }\n\n        uint256 limit = Math.min(\n            numWithdrawals + nextWithdrawal,\n            ManagedNFTs.length\n        );\n        uint256 i;\n        for (i = nextWithdrawal; i < limit; i++) {\n            LiquidInfrastructureNFT withdrawFrom = LiquidInfrastructureNFT(\n                ManagedNFTs[i]\n            );\n\n            (address[] memory withdrawERC20s, ) = withdrawFrom.getThresholds();\n            withdrawFrom.withdrawBalancesTo(withdrawERC20s, address(this));\n            emit Withdrawal(address(withdrawFrom));\n        }\n        nextWithdrawal = i;\n\n        if (nextWithdrawal == ManagedNFTs.length) {\n            nextWithdrawal = 0;\n            emit WithdrawalFinished();\n        }\n    }\n\n    /**\n     * Adds a LiquidInfrastructureNFT contract to the ManagedNFTs collection\n     * @notice this contract must already be the owner of the `nftContract` before this function is called\n     *\n     * @param nftContract the LiquidInfrastructureNFT contract to add to ManagedNFTs\n     */\n    function addManagedNFT(address nftContract) public onlyOwner {\n        LiquidInfrastructureNFT nft = LiquidInfrastructureNFT(nftContract);\n        address nftOwner = nft.ownerOf(nft.AccountId());\n        require(\n            nftOwner == address(this),\n            \"this contract does not own the new ManagedNFT\"\n        );\n        ManagedNFTs.push(nftContract);\n        emit AddManagedNFT(nftContract);\n    }\n\n    /**\n     * Transfers a LiquidInfrastructureNFT contract out of the control of this contract\n     * @notice LiquidInfrastructureNFTs only hold a single token with a specific id (AccountId), this function\n     * only transfers the token with that specific id\n     *\n     * @param nftContract the NFT to release\n     * @param to the new owner of the NFT\n     */\n    function releaseManagedNFT(\n        address nftContract,\n        address to\n    ) public onlyOwner nonReentrant {\n        LiquidInfrastructureNFT nft = LiquidInfrastructureNFT(nftContract);\n        nft.transferFrom(address(this), to, nft.AccountId());\n\n        // Remove the released NFT from the collection\n        for (uint i = 0; i < ManagedNFTs.length; i++) {\n            address managed = ManagedNFTs[i];\n            if (managed == nftContract) {\n                // Delete by copying in the last element and then pop the end\n                ManagedNFTs[i] = ManagedNFTs[ManagedNFTs.length - 1];\n                ManagedNFTs.pop();\n                break;\n            }\n        }\n        // By this point the NFT should have been found and removed from ManagedNFTs\n        require(true, \"unable to find released NFT in ManagedNFTs\");\n\n        emit ReleaseManagedNFT(nftContract, to);\n    }\n\n    /**\n     * Allows the owner to overwrite the list of ERC20s which may be distributed from ManagedNFTs to the holders\n     *\n     * @param _distributableERC20s  The new list value to set\n     */\n    function setDistributableERC20s(\n        address[] memory _distributableERC20s\n    ) public onlyOwner {\n        distributableERC20s = _distributableERC20s;\n    }\n\n    /**\n     * Constructs the underlying ERC20 and initializes critical variables\n     *\n     * @param _name The name of the underlying ERC20\n     * @param _symbol The symbol of the underlying ERC20\n     * @param _managedNFTs The addresses of the controlled LiquidInfrastructureNFT contracts\n     * @param _approvedHolders The addresses of the initial allowed holders\n     * @param _distributableErc20s The addresses of ERC20s which should be distributed from ManagedNFTs to holders\n     */\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address[] memory _managedNFTs,\n        address[] memory _approvedHolders,\n        uint256 _minDistributionPeriod,\n        address[] memory _distributableErc20s\n    ) ERC20(_name, _symbol) Ownable() {\n        ManagedNFTs = _managedNFTs;\n        LastDistribution = block.number;\n\n        for (uint i = 0; i < _approvedHolders.length; i++) {\n            HolderAllowlist[_approvedHolders[i]] = true;\n        }\n\n        MinDistributionPeriod = _minDistributionPeriod;\n\n        distributableERC20s = _distributableErc20s;\n\n        emit Deployed();\n    }\n}"
    },
    {
      "filename": "liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol",
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.12; // Force solidity compliance\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./LiquidInfrastructureNFT.sol\";\n\n/**\n * @title Liquid Infrastructure ERC20\n * @author Christian Borst <christian@althea.systems>\n *\n * @dev An ERC20 contract used to earn rewards from managed LiquidInfrastructreNFTs.\n *\n * A LiquidInfrastructureNFT typically represents some form of infrastructure involved in an Althea pay-per-forward network\n * which frequently receives payments from peers on the network for performing an automated service (e.g. providing internet).\n * This LiquidInfrastructureERC20 acts as a convenient aggregation layer to enable dead-simple investment in real-world assets\n * with automatic revenue accrual. Simply by holding this ERC20 owners are entitled to revenue from the network represented by the token.\n *\n * Revenue is gathered from managed LiquidInfrastructureNFTs by the protocol and distributed to token holders on a semi-regular basis,\n * where there is a minimum number of blocks required to elapse before a new payout to token holders.\n *\n * Minting and burning of this ERC20 is restricted if the minimum distribution period has elapsed, and it is reenabled once a new distribution is complete.\n */\ncontract LiquidInfrastructureERC20 is\n    ERC20,\n    ERC20Burnable,\n    Ownable,\n    ERC721Holder,\n    ReentrancyGuard\n{\n    event Deployed();\n    event DistributionStarted();\n    event Distribution(address recipient, address[] tokens, uint256[] amounts);\n    event DistributionFinished();\n    event WithdrawalStarted();\n    event Withdrawal(address source);\n    event WithdrawalFinished();\n    event AddManagedNFT(address nft);\n    event ReleaseManagedNFT(address nft, address to);\n\n    address[] private distributableERC20s;\n    uint256[] private erc20EntitlementPerUnit;\n    address[] private holders;\n\n    /**\n     * @notice This is the current version of the contract. Every update to the contract will introduce a new\n     * version, regardless of anticipated compatibility.\n     */\n    uint256 public constant Version = 1;\n\n    /**\n     * @notice This collection holds the managed LiquidInfrastructureNFTs which periodically generate revenue and deliver\n     * the balances to this contract.\n     */\n    address[] public ManagedNFTs;\n\n    /**\n     * @notice This collection holds the whitelist for accounts approved to hold the LiquidInfrastructureERC20\n     */\n    mapping(address => bool) public HolderAllowlist;\n\n    /**\n     * @notice Holds the block of the last distribution, used for limiting distribution lock ups\n     */\n    uint256 public LastDistribution;\n\n    /**\n     * @notice Holds the minimum number of blocks required to elapse before a new distribution can begin\n     */\n    uint256 public MinDistributionPeriod;\n\n    /**\n     * @notice When true, locks all transfers, mints, and burns until the current distribution has completed\n     */\n    bool public LockedForDistribution;\n\n    /**\n     * @dev Holds the index into `holders` of the next account owed the current distribution\n     */\n    uint256 internal nextDistributionRecipient;\n\n    /**\n     * @dev Holds the index into `ManagedNFTs` of the next contract to withdraw funds from\n     */\n    uint256 private nextWithdrawal;\n\n    /**\n     * Indicates if the account is approved to hold the ERC20 token or not\n     * @param account the potential holder of the token\n     */\n    function isApprovedHolder(address account) public view returns (bool) {\n        return HolderAllowlist[account];\n    }\n\n    /**\n     * Adds `holder` to the list of approved token holders. This is necessary before `holder` may receive any of the underlying ERC20.\n     * @notice this call will fail if `holder` is already approved. Call isApprovedHolder() first to avoid mistakes.\n     *\n     * @param holder the account to add to the allowlist\n     */\n    function approveHolder(address holder) public onlyOwner {\n        require(!isApprovedHolder(holder), \"holder already approved\");\n        HolderAllowlist[holder] = true;\n    }\n\n    /**\n     * Marks `holder` as NOT approved to hold the token, preventing them from receiving any more of the underlying ERC20.\n     *\n     * @param holder the account to add to the allowlist\n     */\n    function disapproveHolder(address holder) public onlyOwner {\n        require(isApprovedHolder(holder), \"holder not approved\");\n        HolderAllowlist[holder] = false;\n    }\n\n    /**\n     * Implements the lock during distributions, adds `to` to the list of holders when needed\n     * @param from token sender\n     * @param to  token receiver\n     * @param amount  amount sent\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        require(!LockedForDistribution, \"distribution in progress\");\n        if (!(to == address(0))) {\n            require(\n                isApprovedHolder(to),\n                \"receiver not approved to hold the token\"\n            );\n        }\n        if (from == address(0) || to == address(0)) {\n            _beforeMintOrBurn();\n        }\n        bool exists = (this.balanceOf(to) != 0);\n        if (!exists) {\n            holders.push(to);\n        }\n    }\n\n    /**\n     * Implements an additional lock on minting and burning, ensuring that supply changes happen after any potential distributions\n     */\n    function _beforeMintOrBurn() internal view {\n        require(\n            !_isPastMinDistributionPeriod(),\n            \"must distribute before minting or burning\"\n        );\n    }\n\n    /**\n     * Removes `from` from the list of holders when they no longer hold any balance\n     * @param from token sender\n     * @param to  token receiver\n     * @param amount  amount sent\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        bool stillHolding = (this.balanceOf(from) != 0);\n        if (!stillHolding) {\n            for (uint i = 0; i < holders.length; i++) {\n                if (holders[i] == from) {\n                    // Remove the element at i by copying the last one into its place and removing the last element\n                    holders[i] = holders[holders.length - 1];\n                    holders.pop();\n                }\n            }\n        }\n    }\n\n    /**\n     * Performs a distribution to all of the current holders, which may trigger out of gas errors if there are too many holders\n     */\n    function distributeToAllHolders() public {\n        uint256 num = holders.length;\n        if (num > 0) {\n            distribute(holders.length);\n        }\n    }\n\n    /**\n     * Begins or continues a distribution, preventing transfers, mints, and burns of the token until all rewards have been paid out\n     *\n     * @notice distributions may only begin once every MinDistributionPeriod.\n     *\n     * @param numDistributions the number of distributions to process in this execution\n     */\n    function distribute(uint256 numDistributions) public nonReentrant {\n        require(numDistributions > 0, \"must process at least 1 distribution\");\n        if (!LockedForDistribution) {\n            require(\n                _isPastMinDistributionPeriod(),\n                \"MinDistributionPeriod not met\"\n            );\n            _beginDistribution();\n        }\n\n        uint256 limit = Math.min(\n            nextDistributionRecipient + numDistributions,\n            holders.length\n        );\n\n        uint i;\n        for (i = nextDistributionRecipient; i < limit; i++) {\n            address recipient = holders[i];\n            if (isApprovedHolder(recipient)) {\n                uint256[] memory receipts = new uint256[](\n                    distributableERC20s.length\n                );\n                for (uint j = 0; j < distributableERC20s.length; j++) {\n                    IERC20 toDistribute = IERC20(distributableERC20s[j]);\n                    uint256 entitlement = erc20EntitlementPerUnit[j] *\n                        this.balanceOf(recipient);\n                    if (toDistribute.transfer(recipient, entitlement)) {\n                        receipts[j] = entitlement;\n                    }\n                }\n\n                emit Distribution(recipient, distributableERC20s, receipts);\n            }\n        }\n        nextDistributionRecipient = i;\n\n        if (nextDistributionRecipient == holders.length) {\n            _endDistribution();\n        }\n    }\n\n    /**\n     * Determines if the minimum distribution period has elapsed, which is used for restricting\n     * minting and burning operations\n     */\n    function _isPastMinDistributionPeriod() internal view returns (bool) {\n        // Do not force a distribution with no holders or supply\n        if (totalSupply() == 0 || holders.length == 0) {\n            return false;\n        }\n\n        return (block.number - LastDistribution) >= MinDistributionPeriod;\n    }\n\n    /**\n     * Prepares this contract for distribution:\n     * - Locks the contract\n     * - Calculates the entitlement to protocol-held ERC20s per unit of the LiquidInfrastructureERC20 held\n     */\n    function _beginDistribution() internal {\n        require(\n            !LockedForDistribution,\n            \"cannot begin distribution when already locked\"\n        );\n        LockedForDistribution = true;\n\n        // clear the previous entitlements, if any\n        if (erc20EntitlementPerUnit.length > 0) {\n            delete erc20EntitlementPerUnit;\n        }\n\n        // Calculate the entitlement per token held\n        uint256 supply = this.totalSupply();\n        for (uint i = 0; i < distributableERC20s.length; i++) {\n            uint256 balance = IERC20(distributableERC20s[i]).balanceOf(\n                address(this)\n            );\n            uint256 entitlement = balance / supply;\n            erc20EntitlementPerUnit.push(entitlement);\n        }\n\n        nextDistributionRecipient = 0;\n        emit DistributionStarted();\n    }\n\n    /**\n     * Unlocks this contract at the end of a distribution\n     */\n    function _endDistribution() internal {\n        require(\n            LockedForDistribution,\n            \"cannot end distribution when not locked\"\n        );\n        delete erc20EntitlementPerUnit;\n        LockedForDistribution = false;\n        LastDistribution = block.number;\n        emit DistributionFinished();\n    }\n\n    /**\n     * Convenience function that allows the contract owner to distribute when necessary and then mint right after\n     *\n     * @notice attempts to distribute to every holder in this block, which may exceed the block gas limit\n     * if this fails then first call distribute\n     */\n    function mintAndDistribute(\n        address account,\n        uint256 amount\n    ) public onlyOwner {\n        if (_isPastMinDistributionPeriod()) {\n            distributeToAllHolders();\n        }\n        mint(account, amount);\n    }\n\n    /**\n     * Allows the contract owner to mint tokens for an address\n     *\n     * @notice minting may only occur when a distribution has happened within MinDistributionPeriod blocks\n     */\n    function mint(\n        address account,\n        uint256 amount\n    ) public onlyOwner nonReentrant {\n        _mint(account, amount);\n    }\n\n    /**\n     * Convenience function that allows a token holder to distribute when necessary and then burn their tokens right after\n     *\n     * @notice attempts to distribute to every holder in this block, which may exceed the block gas limit\n     * if this fails then first call distribute() enough times to finish a distribution and then call burn()\n     */\n    function burnAndDistribute(uint256 amount) public {\n        if (_isPastMinDistributionPeriod()) {\n            distributeToAllHolders();\n        }\n        burn(amount);\n    }\n\n    /**\n     * Convenience function that allows an approved sender to distribute when necessary and then burn the approved tokens right after\n     *\n     * @notice attempts to distribute to every holder in this block, which may exceed the block gas limit\n     * if this fails then first call distribute() enough times to finish a distribution and then call burnFrom()\n     */\n    function burnFromAndDistribute(address account, uint256 amount) public {\n        if (_isPastMinDistributionPeriod()) {\n            distributeToAllHolders();\n        }\n        burnFrom(account, amount);\n    }\n\n    function withdrawFromAllManagedNFTs() public {\n        withdrawFromManagedNFTs(ManagedNFTs.length);\n    }\n\n    /**\n     * Performs withdrawals from the ManagedNFTs collection, depositing all token balances into the custody of this contract\n     * @param numWithdrawals the number of withdrawals to perform\n     */\n    function withdrawFromManagedNFTs(uint256 numWithdrawals) public {\n        require(!LockedForDistribution, \"cannot withdraw during distribution\");\n\n        if (nextWithdrawal == 0) {\n            emit WithdrawalStarted();\n        }\n\n        uint256 limit = Math.min(\n            numWithdrawals + nextWithdrawal,\n            ManagedNFTs.length\n        );\n        uint256 i;\n        for (i = nextWithdrawal; i < limit; i++) {\n            LiquidInfrastructureNFT withdrawFrom = LiquidInfrastructureNFT(\n                ManagedNFTs[i]\n            );\n\n            (address[] memory withdrawERC20s, ) = withdrawFrom.getThresholds();\n            withdrawFrom.withdrawBalancesTo(withdrawERC20s, address(this));\n            emit Withdrawal(address(withdrawFrom));\n        }\n        nextWithdrawal = i;\n\n        if (nextWithdrawal == ManagedNFTs.length) {\n            nextWithdrawal = 0;\n            emit WithdrawalFinished();\n        }\n    }\n\n    /**\n     * Adds a LiquidInfrastructureNFT contract to the ManagedNFTs collection\n     * @notice this contract must already be the owner of the `nftContract` before this function is called\n     *\n     * @param nftContract the LiquidInfrastructureNFT contract to add to ManagedNFTs\n     */\n    function addManagedNFT(address nftContract) public onlyOwner {\n        LiquidInfrastructureNFT nft = LiquidInfrastructureNFT(nftContract);\n        address nftOwner = nft.ownerOf(nft.AccountId());\n        require(\n            nftOwner == address(this),\n            \"this contract does not own the new ManagedNFT\"\n        );\n        ManagedNFTs.push(nftContract);\n        emit AddManagedNFT(nftContract);\n    }\n\n    /**\n     * Transfers a LiquidInfrastructureNFT contract out of the control of this contract\n     * @notice LiquidInfrastructureNFTs only hold a single token with a specific id (AccountId), this function\n     * only transfers the token with that specific id\n     *\n     * @param nftContract the NFT to release\n     * @param to the new owner of the NFT\n     */\n    function releaseManagedNFT(\n        address nftContract,\n        addr"
    }
  ]
}