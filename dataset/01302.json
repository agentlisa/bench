{
  "Title": "M-11: Recipient cannot always claim expected donation amount from a vault",
  "Content": "# Issue M-11: Recipient cannot always claim expected donation amount from a vault \n\nSource: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/547 \n\n## Found by \n0x00ffDa, 0xdeadbeef, Arz, BenRai, Kow, Silvermist, ZdravkoHr., alymurtazamemon, hals, jkoppel, lemonmon, p0wd3r\n\n## Vulnerability Detail\n**First, why is this issue valid despite Sherlock rules excluding non-standard ERC20 behavior?**\nWhile the Sherlock rules currently exclude \"issues related to tokens with non-standard behaviors\", t[he rules also state that](https://docs.sherlock.xyz/audits/judging/judging#iii.-some-standards-observed) \"In case of conflict between information in the README, vs Sherlock rules, **the README overrides Sherlock rules**.\" And the contest README specifically says that all ERC20 with non-standard behavior are supported:\n\n> \"Q: Do you expect to use any of the following tokens with non-standard behaviour with the smart contracts?\n> Yes as we support all ERC20 tokens.\"\n\nDonationVotingMerkleDistributionVaultStrategy contracts store donation amounts in [a `claims` mapping](https://github.com/allo-protocol/allo-v2/blob/851571c27df5c16f6586ece2a1cb6fd0acf04ec9/contracts/strategies/donation-voting-merkle-distribution-vault/DonationVotingMerkleDistributionVaultStrategy.sol#L54C18-L54C18) per recipient and per donated token. This is intended to also represent all the amounts claimable by registered recipients. However, in the case of donated [ERC20 tokens with a non-zero transfer fee](https://github.com/d-xo/weird-erc20#fee-on-transfer), a donated amount is not claimable in full since the transfer from the donor to the vault will reduce the amount that can be claimed by the recipient.\n\n## Impact\nRecipients cannot claim the amount expected from a vault in a DonationVotingMerkleDistributionVaultStrategy pool when a donated token has a transfer fee.\n\n## Code Snippet\n[DonationVotingMerkleDistributionVaultStrategy._afterAllocate() function](https://github.com/allo-protocol/allo-v2/blob/851571c27df5c16f6586ece2a1cb6fd0acf04ec9/contracts/strategies/donation-voting-merkle-distribution-vault/DonationVotingMerkleDistributionVaultStrategy.sol#L104-L136) - the last line contains the faulty assumption.\n```javascript\n    /// @notice After allocation hook to store the allocated tokens in the vault\n    /// @param _data The encoded recipientId, amount and token\n    /// @param _sender The sender of the allocation\n    function _afterAllocate(bytes memory _data, address _sender) internal override {\n        // Decode the '_data' to get the recipientId, amount and token\n        (address recipientId, Permit2Data memory p2Data) = abi.decode(_data, (address, Permit2Data));\n\n        // Get the token address\n        address token = p2Data.permit.permitted.token;\n        uint256 amount = p2Data.permit.permitted.amount;\n\n        if (token == NATIVE) {\n            if (msg.value < amount) {\n                revert AMOUNT_MISMATCH();\n            }\n            SafeTransferLib.safeTransferETH(address(this), amount);\n        } else {\n            PERMIT2.permitTransferFrom(\n                // The permit message.\n                p2Data.permit,\n                // The transfer recipient and amount.\n                ISignatureTransfer.SignatureTransferDetails({to: address(this), requestedAmount: amount}),\n                // Owner of the tokens and signer of the message.\n                _sender,\n                // The packed signature that was the result of signing\n                // the EIP712 hash of `_permit`.\n                p2Data.signature\n            );\n        }\n\n        // Update the total payout amount for the claim\n        claims[recipientId][token] += amount;\n    }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\nIn the `_afterAllocate()` cited above, compare vault's balance of the token being donated before and after calling `permitTransferFrom()`. If it is lower than the donated `amount`, assume this difference is a transfer fee and reduce the claimable amount by the fee.\n\n\n\n\n## Discussion\n\n**0x00ffDa**\n\nEscalate for 10 USDC\n\nThis is not a duplicate of https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/19 and [the fix for that issue](https://github.com/allo-protocol/allo-v2/pull/355/commits/70b38cf08f49bd305009735d823e984221f9a665#diff-0291f3e80e43e69124a1d57e9029ee22f6506a0503b00df881a3949915b43451) does not affect this issue.\n\nThis fee-on-transfer issue is specific to transfers from donors to recipients via `DonationVotingMerkleDistributionVaultStrategy`.\n\n**sherlock-admin2**\n\n > Escalate for 10 USDC\n> \n> This is not a duplicate of https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/19 and [the fix for that issue](https://github.com/allo-protocol/allo-v2/pull/355/commits/70b38cf08f49bd305009735d823e984221f9a665#diff-0291f3e80e43e69124a1d57e9029ee22f6506a0503b00df881a3949915b43451) does not affect this issue.\n> \n> This fee-on-transfer issue is specific to transfers from donors to recipients via `DonationVotingMerkleDistributionVaultStrategy`.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**neeksec**\n\nAgree with Escalation that this is not a duplicate of #19 and should be a seperate issue.\n\nDuplicates of this one,\n#124, #208, #268, #295, #342, #379, #422, #449, #482, #724, #903, #913\n\n**MLON33**\n\nhttps://github.com/allo-protocol/allo-v2/pull/381\n\n**Evert0x**\n\nPlanning to accept escalation and create a new medium family (https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/547 https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/124, https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/208, https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/268, https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/295, https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/342, https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/379, https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/422, https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/449, https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/482, https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/724, https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/903, https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/913)\n\n**Evert0x**\n\nResult:\nMedium\nHas Duplicates\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0x00ffDa](https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/547/#issuecomment-1763254901): accepted\n\n**jack-the-pug**\n\nFixed.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/109",
  "Code": [
    {
      "filename": "contracts/strategies/donation-voting-merkle-distribution-vault/DonationVotingMerkleDistributionVaultStrategy.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\nimport {ISignatureTransfer} from \"permit2/ISignatureTransfer.sol\";\nimport {DonationVotingMerkleDistributionBaseStrategy} from\n    \"../donation-voting-merkle-base/DonationVotingMerkleDistributionBaseStrategy.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\nimport {SafeTransferLib} from \"solady/src/utils/SafeTransferLib.sol\";\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\n\n/// @title Donation Voting Merkle Distribution Strategy\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\n/// @notice Strategy for donation voting allocation with a merkle distribution\ncontract DonationVotingMerkleDistributionVaultStrategy is\n    DonationVotingMerkleDistributionBaseStrategy,\n    ReentrancyGuardUpgradeable\n{\n    /// @notice Stores the details of the allocations to claim.\n    struct Claim {\n        address recipientId;\n        address token;\n    }\n\n    /// ===============================\n    /// ========== Events =============\n    /// ===============================\n\n    /// @notice Emitted when a recipient has claimed their allocated funds\n    /// @param recipientId Id of the recipient\n    /// @param recipientAddress Address of the recipient\n    /// @param amount Amount of tokens claimed\n    /// @param token Address of the token\n    event Claimed(address indexed recipientId, address recipientAddress, uint256 amount, address token);\n\n    /// ================================\n    /// ========== Storage =============\n    /// ================================\n\n    /// @notice 'recipientId' => 'token' => 'amount'.\n    mapping(address => mapping(address => uint256)) public claims;\n\n    /// ===============================\n    /// ======== Constructor ==========\n    /// ===============================\n\n    /// @notice Constructor for the Donation Voting Merkle Distribution Strategy\n    /// @param _allo The 'Allo' contract\n    /// @param _name The name of the strategy\n    constructor(address _allo, string memory _name, ISignatureTransfer _permit2)\n        DonationVotingMerkleDistributionBaseStrategy(_allo, _name, _permit2)\n    {}\n\n    /// @notice Claim allocated tokens for recipients.\n    /// @dev Uses the merkle root to verify the claims. Allocation must have ended to claim.\n    /// @param _claims Claims to be claimed\n    function claim(Claim[] calldata _claims) external nonReentrant onlyAfterAllocation {\n        uint256 claimsLength = _claims.length;\n\n        // Loop through the claims\n        for (uint256 i; i < claimsLength;) {\n            Claim memory singleClaim = _claims[i];\n            Recipient memory recipient = _recipients[singleClaim.recipientId];\n            uint256 amount = claims[singleClaim.recipientId][singleClaim.token];\n\n            // If the claim amount is zero this will revert\n            if (amount == 0) {\n                revert INVALID();\n            }\n\n            /// Delete the claim from the mapping\n            delete claims[singleClaim.recipientId][singleClaim.token];\n\n            address token = singleClaim.token;\n\n            // Transfer the tokens to the recipient\n            _transferAmount(token, recipient.recipientAddress, amount);\n\n            // Emit that the tokens have been claimed and sent to the recipient\n            emit Claimed(singleClaim.recipientId, recipient.recipientAddress, amount, token);\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// ================================\n    /// ============ Hooks =============\n    /// ================================\n\n    /// @notice After allocation hook to store the allocated tokens in the vault\n    /// @param _data The encoded recipientId, amount and token\n    /// @param _sender The sender of the allocation\n    function _afterAllocate(bytes memory _data, address _sender) internal override {\n        // Decode the '_data' to get the recipientId, amount and token\n        (address recipientId, Permit2Data memory p2Data) = abi.decode(_data, (address, Permit2Data));\n\n        // Get the token address\n        address token = p2Data.permit.permitted.token;\n        uint256 amount = p2Data.permit.permitted.amount;\n\n        if (token == NATIVE) {\n            if (msg.value < amount) {\n                revert AMOUNT_MISMATCH();\n            }\n            SafeTransferLib.safeTransferETH(address(this), amount);\n        } else {\n            PERMIT2.permitTransferFrom(\n                // The permit message.\n                p2Data.permit,\n                // The transfer recipient and amount.\n                ISignatureTransfer.SignatureTransferDetails({to: address(this), requestedAmount: amount}),\n                // Owner of the tokens and signer of the message.\n                _sender,\n                // The packed signature that was the result of signing\n                // the EIP712 hash of `_permit`.\n                p2Data.signature\n            );\n        }\n\n        // Update the total payout amount for the claim\n        claims[recipientId][token] += amount;\n    }\n}"
    },
    {
      "filename": "contracts/strategies/donation-voting-merkle-distribution-vault/DonationVotingMerkleDistributionVaultStrategy.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\nimport {ISignatureTransfer} from \"permit2/ISignatureTransfer.sol\";\nimport {DonationVotingMerkleDistributionBaseStrategy} from\n    \"../donation-voting-merkle-base/DonationVotingMerkleDistributionBaseStrategy.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\nimport {SafeTransferLib} from \"solady/src/utils/SafeTransferLib.sol\";\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\n\n/// @title Donation Voting Merkle Distribution Strategy\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\n/// @notice Strategy for donation voting allocation with a merkle distribution\ncontract DonationVotingMerkleDistributionVaultStrategy is\n    DonationVotingMerkleDistributionBaseStrategy,\n    ReentrancyGuardUpgradeable\n{\n    /// @notice Stores the details of the allocations to claim.\n    struct Claim {\n        address recipientId;\n        address token;\n    }\n\n    /// ===============================\n    /// ========== Events =============\n    /// ===============================\n\n    /// @notice Emitted when a recipient has claimed their allocated funds\n    /// @param recipientId Id of the recipient\n    /// @param recipientAddress Address of the recipient\n    /// @param amount Amount of tokens claimed\n    /// @param token Address of the token\n    event Claimed(address indexed recipientId, address recipientAddress, uint256 amount, address token);\n\n    /// ================================\n    /// ========== Storage =============\n    /// ================================\n\n    /// @notice 'recipientId' => 'token' => 'amount'.\n    mapping(address => mapping(address => uint256)) public claims;\n\n    /// ===============================\n    /// ======== Constructor ==========\n    /// ===============================\n\n    /// @notice Constructor for the Donation Voting Merkle Distribution Strategy\n    /// @param _allo The 'Allo' contract\n    /// @param _name The name of the strategy\n    constructor(address _allo, string memory _name, ISignatureTransfer _permit2)\n        DonationVotingMerkleDistributionBaseStrategy(_allo, _name, _permit2)\n    {}\n\n    /// @notice Claim allocated tokens for recipients.\n    /// @dev Uses the merkle root to verify the claims. Allocation must have ended to claim.\n    /// @param _claims Claims to be claimed\n    function claim(Claim[] calldata _claims) external nonReentrant onlyAfterAllocation {\n        uint256 claimsLength = _claims.length;\n\n        // Loop through the claims\n        for (uint256 i; i < claimsLength;) {\n            Claim memory singleClaim = _claims[i];\n            Recipient memory recipient = _recipients[singleClaim.recipientId];\n            uint256 amount = claims[singleClaim.recipientId][singleClaim.token];\n\n            // If the claim amount is zero this will revert\n            if (amount == 0) {\n                revert INVALID();\n            }\n\n            /// Delete the claim from the mapping\n            delete claims[singleClaim.recipientId][singleClaim.token];\n\n            address token = singleClaim.token;\n\n            // Transfer the tokens to the recipient\n            _transferAmount(token, recipient.recipientAddress, amount);\n\n            // Emit that the tokens have been claimed and sent to the recipient\n            emit Claimed(singleClaim.recipientId, recipient.recipientAddress, amount, token);\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// ================================\n    /// ============ Hooks =============\n    /// ================================\n\n    /// @notice After allocation hook to store the allocated tokens in the vault\n    /// @param _data The encoded recipientId, amount and token\n    /// @param _sender The sender of the allocation\n    function _afterAllocate(bytes memory _data, address _sender) internal override {\n        // Decode the '_data' to get the recipientId, amount and token\n        (address recipientId, Permit2Data memory p2Data) = abi.decode(_data, (address, Permit2Data));\n\n        // Get the token address\n        address token = p2Data.permit.permitted.token;\n        uint256 amount = p2Data.permit.permitted.amount;\n\n        if (token == NATIVE) {\n            if (msg.value < amount) {\n                revert AMOUNT_MISMATCH();\n            }\n            SafeTransferLib.safeTransferETH(address(this), amount);\n        } else {\n            PERMIT2.permitTransferFrom(\n                // The permit message.\n                p2Data.permit,\n                // The transfer recipient and amount.\n                ISignatureTransfer.SignatureTransferDetails({to: address(this), requestedAmount: amount}),\n                // Owner of the tokens and signer of the message.\n                _sender,\n                // The packed signature that was the result of signing\n                // the EIP712 hash of `_permit`.\n                p2Data.signature\n            );\n        }\n\n        // Update the total payout amount for the claim\n        claims[recipientId][token] += amount;\n    }\n}"
    }
  ]
}