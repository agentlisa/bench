{
  "Title": "[M02] Faulty append function",
  "Content": "The [`appendKeyValueBytes32` function](https://github.com/UMAprotocol/protocol/blob/f24ad501c8e813cf685f72217e7f13c8f3c366df/packages/core/contracts/common/implementation/AncillaryData.sol#L87) should combine its inputs into a formatted `bytes` array. However, the `currentAncillaryData` is [incorrectly discarded](https://github.com/UMAprotocol/protocol/blob/f24ad501c8e813cf685f72217e7f13c8f3c366df/packages/core/contracts/common/implementation/AncillaryData.sol#L93).\n\n\nSince the ancillary data [influences the oracle resolution process](https://github.com/UMAprotocol/protocol/blob/f24ad501c8e813cf685f72217e7f13c8f3c366df/packages/core/contracts/insured-bridge/BridgePool.sol#L345), an incorrect value could undermine the oracle results. Fortunately, there is only [one call to `appendKeyValueBytes32`](https://github.com/UMAprotocol/protocol/blob/f24ad501c8e813cf685f72217e7f13c8f3c366df/packages/core/contracts/insured-bridge/BridgePool.sol#L731) in the codebase, and it uses an empty `currentAncillaryData` buffer, so the bug does not affect this case.\n\n\nConsider updating the `appendKeyValueBytes32` function so that the `currentAncillaryData` is included in the returned bytes array.\n\n\n**Update:** *Fixed in commit [`5609433c154f47e8ee9c52f9b6d7c787fbe3e455`](https://github.com/UMAprotocol/protocol/pull/3532/commits/5609433c154f47e8ee9c52f9b6d7c787fbe3e455) of [PR3532](https://github.com/UMAprotocol/protocol/pull/3532).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "packages/core/contracts/common/implementation/AncillaryData.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n/**\n * @title Library for encoding and decoding ancillary data for DVM price requests.\n * @notice  We assume that on-chain ancillary data can be formatted directly from bytes to utf8 encoding via\n * web3.utils.hexToUtf8, and that clients will parse the utf8-encoded ancillary data as a comma-delimitted key-value\n * dictionary. Therefore, this library provides internal methods that aid appending to ancillary data from Solidity\n * smart contracts. More details on UMA's ancillary data guidelines below:\n * https://docs.google.com/document/d/1zhKKjgY1BupBGPPrY_WOJvui0B6DMcd-xDR8-9-SPDw/edit\n */\nlibrary AncillaryData {\n    // This converts the bottom half of a bytes32 input to hex in a highly gas-optimized way.\n    // Source: the brilliant implementation at https://gitter.im/ethereum/solidity?at=5840d23416207f7b0ed08c9b.\n    function toUtf8Bytes32Bottom(bytes32 bytesIn) private pure returns (bytes32) {\n        unchecked {\n            uint256 x = uint256(bytesIn);\n\n            // Nibble interleave\n            x = x & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff;\n            x = (x | (x * 2**64)) & 0x0000000000000000ffffffffffffffff0000000000000000ffffffffffffffff;\n            x = (x | (x * 2**32)) & 0x00000000ffffffff00000000ffffffff00000000ffffffff00000000ffffffff;\n            x = (x | (x * 2**16)) & 0x0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff;\n            x = (x | (x * 2**8)) & 0x00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff;\n            x = (x | (x * 2**4)) & 0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f;\n\n            // Hex encode\n            uint256 h = (x & 0x0808080808080808080808080808080808080808080808080808080808080808) / 8;\n            uint256 i = (x & 0x0404040404040404040404040404040404040404040404040404040404040404) / 4;\n            uint256 j = (x & 0x0202020202020202020202020202020202020202020202020202020202020202) / 2;\n            x = x + (h & (i | j)) * 0x27 + 0x3030303030303030303030303030303030303030303030303030303030303030;\n\n            // Return the result.\n            return bytes32(x);\n        }\n    }\n\n    /**\n     * @notice Returns utf8-encoded bytes32 string that can be read via web3.utils.hexToUtf8.\n     * @dev Will return bytes32 in all lower case hex characters and without the leading 0x.\n     * This has minor changes from the toUtf8BytesAddress to control for the size of the input.\n     * @param bytesIn bytes32 to encode.\n     * @return utf8 encoded bytes32.\n     */\n    function toUtf8Bytes(bytes32 bytesIn) internal pure returns (bytes memory) {\n        return abi.encodePacked(toUtf8Bytes32Bottom(bytesIn >> 128), toUtf8Bytes32Bottom(bytesIn));\n    }\n\n    /**\n     * @notice Returns utf8-encoded address that can be read via web3.utils.hexToUtf8.\n     * Source: https://ethereum.stackexchange.com/questions/8346/convert-address-to-string/8447#8447\n     * @dev Will return address in all lower case characters and without the leading 0x.\n     * @param x address to encode.\n     * @return utf8 encoded address bytes.\n     */\n    function toUtf8BytesAddress(address x) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(toUtf8Bytes32Bottom(bytes32(bytes20(x)) >> 128), bytes8(toUtf8Bytes32Bottom(bytes20(x))));\n    }\n\n    /**\n     * @notice Converts a uint into a base-10, UTF-8 representation stored in a `string` type.\n     * @dev This method is based off of this code: https://stackoverflow.com/a/65707309.\n     */\n    function toUtf8BytesUint(uint256 x) internal pure returns (bytes memory) {\n        if (x == 0) {\n            return \"0\";\n        }\n        uint256 j = x;\n        uint256 len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint256 k = len;\n        while (x != 0) {\n            k = k - 1;\n            uint8 temp = (48 + uint8(x - (x / 10) * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            x /= 10;\n        }\n        return bstr;\n    }\n\n    function appendKeyValueBytes32(\n        bytes memory currentAncillaryData,\n        bytes memory key,\n        bytes32 value\n    ) internal pure returns (bytes memory) {\n        bytes memory prefix = constructPrefix(currentAncillaryData, key);\n        return abi.encodePacked(prefix, toUtf8Bytes(value));\n    }\n\n    /**\n     * @notice Adds \"key:value\" to `currentAncillaryData` where `value` is an address that first needs to be converted\n     * to utf8 bytes. For example, if `utf8(currentAncillaryData)=\"k1:v1\"`, then this function will return\n     * `utf8(k1:v1,key:value)`, and if `currentAncillaryData` is blank, then this will return `utf8(key:value)`.\n     * @param currentAncillaryData This bytes data should ideally be able to be utf8-decoded, but its OK if not.\n     * @param key Again, this bytes data should ideally be able to be utf8-decoded, but its OK if not.\n     * @param value An address to set as the value in the key:value pair to append to `currentAncillaryData`.\n     * @return Newly appended ancillary data.\n     */\n    function appendKeyValueAddress(\n        bytes memory currentAncillaryData,\n        bytes memory key,\n        address value\n    ) internal pure returns (bytes memory) {\n        bytes memory prefix = constructPrefix(currentAncillaryData, key);\n        return abi.encodePacked(currentAncillaryData, prefix, toUtf8BytesAddress(value));\n    }\n\n    /**\n     * @notice Adds \"key:value\" to `currentAncillaryData` where `value` is a uint that first needs to be converted\n     * to utf8 bytes. For example, if `utf8(currentAncillaryData)=\"k1:v1\"`, then this function will return\n     * `utf8(k1:v1,key:value)`, and if `currentAncillaryData` is blank, then this will return `utf8(key:value)`.\n     * @param currentAncillaryData This bytes data should ideally be able to be utf8-decoded, but its OK if not.\n     * @param key Again, this bytes data should ideally be able to be utf8-decoded, but its OK if not.\n     * @param value A uint to set as the value in the key:value pair to append to `currentAncillaryData`.\n     * @return Newly appended ancillary data.\n     */\n    function appendKeyValueUint(\n        bytes memory currentAncillaryData,\n        bytes memory key,\n        uint256 value\n    ) internal pure returns (bytes memory) {\n        bytes memory prefix = constructPrefix(currentAncillaryData, key);\n        return abi.encodePacked(currentAncillaryData, prefix, toUtf8BytesUint(value));\n    }\n\n    /**\n     * @notice Helper method that returns the left hand side of a \"key:value\" pair plus the colon \":\" and a leading\n     * comma \",\" if the `currentAncillaryData` is not empty. The return value is intended to be prepended as a prefix to\n     * some utf8 value that is ultimately added to a comma-delimited, key-value dictionary.\n     */\n    function constructPrefix(bytes memory currentAncillaryData, bytes memory key) internal pure returns (bytes memory) {\n        if (currentAncillaryData.length > 0) {\n            return abi.encodePacked(\",\", key, \":\");\n        } else {\n            return abi.encodePacked(key, \":\");\n        }\n    }\n}"
    },
    {
      "filename": "packages/core/contracts/insured-bridge/BridgePool.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"./interfaces/BridgeAdminInterface.sol\";\nimport \"./interfaces/BridgePoolInterface.sol\";\n\nimport \"../oracle/interfaces/SkinnyOptimisticOracleInterface.sol\";\nimport \"../oracle/interfaces/StoreInterface.sol\";\nimport \"../oracle/interfaces/FinderInterface.sol\";\nimport \"../oracle/implementation/Constants.sol\";\n\nimport \"../common/implementation/AncillaryData.sol\";\nimport \"../common/implementation/Testable.sol\";\nimport \"../common/implementation/FixedPoint.sol\";\nimport \"../common/implementation/Lockable.sol\";\nimport \"../common/implementation/ExpandedERC20.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"hardhat/console.sol\";\n\ninterface WETH9Like {\n    function withdraw(uint256 wad) external;\n}\n\n/**\n * @notice Contract deployed on L1 that provides methods for \"Relayers\" to fulfill deposit orders that originated on L2.\n * The Relayers can either post capital to fulfill the deposit (instant relay), or request that the funds are taken out\n * of a passive liquidity provider pool following a challenge period (slow relay). This contract ingests liquidity from\n * passive liquidity providers and returns them claims to withdraw their funds. Liquidity providers are incentivized\n * to post collateral by earning a fee per fulfilled deposit order.\n * @dev A \"Deposit\" is an order to send capital from L2 to L1, and a \"Relay\" is a fulfillment attempt of that order.\n */\ncontract BridgePool is Testable, BridgePoolInterface, ExpandedERC20, Lockable {\n    using SafeERC20 for IERC20;\n    using FixedPoint for FixedPoint.Unsigned;\n\n    // Token that this contract receives as LP deposits.\n    IERC20 public override l1Token;\n\n    // Track the total number of relays and uniquely identifies relays.\n    uint32 public numberOfRelays;\n\n    // Reserves that are unutilized and withdrawable.\n    uint256 public liquidReserves;\n\n    // Reserves currently utilized due to L2-L1 transactions in flight.\n    int256 public utilizedReserves;\n\n    // Reserves that are not yet utilized but are pre-allocated for a pending relay.\n    uint256 public pendingReserves;\n\n    // If this pool contains WETH. If the withdrawn token is WETH then unwrap and send ETH when finalizing withdrawal.\n    bool public isWethPool;\n\n    // Exponential decay exchange rate to accumulate fees to LPs over time.\n    uint64 public lpFeeRatePerSecond;\n\n    // Last timestamp that LP fees were updated.\n    uint32 public lastLpFeeUpdate;\n\n    // Store local instances of contract params to save gas relaying. Can be synced with the BridgeAdmin at any time.\n    uint64 public proposerBondPct;\n    uint32 public optimisticOracleLiveness;\n\n    // Cumulative undistributed LP fees. As fees accumulate, they are subtracted from this number.\n    uint256 public undistributedLpFees;\n\n    // Total bonds held.\n    uint256 public bonds;\n\n    // Administrative contract that deployed this contract and also houses all state variables needed to relay deposits.\n    BridgeAdminInterface public bridgeAdmin;\n\n    // Store local instances of the contract instances to save gas relaying. Can be sync with the Finder at any time.\n    StoreInterface public store;\n    SkinnyOptimisticOracleInterface public optimisticOracle;\n\n    bytes32 public identifier;\n\n    // A Relay represents an attempt to finalize a cross-chain transfer that originated on an L2 DepositBox contract.\n    // The flow chart between states is as follows:\n    // - Begin at Uninitialized.\n    // - When relayDeposit() is called, a new relay is created with state Pending and mapped to the L2 deposit hash.\n    // - If the relay is disputed, the RelayData gets deleted and the L2 deposit hash has no relay mapped to it anymore.\n    // - The above statements enable state to transfer between the Uninitialized and Pending states.\n    // - When settleRelay() is successfully called, the relay state gets set to Finalized and cannot change from there.\n    // - It is impossible for a relay to be deleted when in Finalized state (and have its state set to Uninitialized)\n    //   because the only way for settleRelay() to succeed is if the price has resolved on the OptimisticOracle.\n    // - You cannot dispute an already resolved request on the OptimisticOracle. Moreover, the mapping from\n    //   a relay's ancillary data hash to its deposit hash is deleted after a successful settleRelay() call.\n    enum RelayState { Uninitialized, Pending, Finalized }\n\n    // Data from L2 deposit transaction.\n    struct DepositData {\n        uint8 chainId;\n        uint64 depositId;\n        address payable l1Recipient;\n        address l2Sender;\n        uint256 amount;\n        uint64 slowRelayFeePct;\n        uint64 instantRelayFeePct;\n        uint32 quoteTimestamp;\n    }\n\n    // Each L2 Deposit can have one Relay attempt at any one time. A Relay attempt is characterized by its RelayData.\n    struct RelayData {\n        RelayState relayState;\n        address slowRelayer;\n        uint32 relayId;\n        uint64 realizedLpFeePct;\n        uint32 priceRequestTime;\n        uint256 proposerBond;\n        uint256 finalFee;\n    }\n\n    // Associate deposits with pending relay data. When the mapped relay hash is empty, new relay attempts can be made\n    // for this deposit. The relay data contains information necessary to pay out relayers on successful relay.\n    // Relay hashes are deleted when they are disputed on the OptimisticOracle.\n    mapping(bytes32 => bytes32) public relays;\n\n    // Map hash of deposit and realized-relay fee to instant relayers. This mapping is checked at settlement time\n    // to determine if there was a valid instant relayer.\n    mapping(bytes32 => address) public instantRelays;\n\n    event LiquidityAdded(address indexed token, uint256 amount, uint256 lpTokensMinted, address liquidityProvider);\n    event LiquidityRemoved(address indexed token, uint256 amount, uint256 lpTokensBurnt, address liquidityProvider);\n    event DepositRelayed(\n        bytes32 indexed depositHash,\n        DepositData depositData,\n        address l1Token,\n        RelayData relay,\n        bytes32 relayAncillaryDataHash\n    );\n    event RelaySpedUp(bytes32 indexed depositHash, address indexed instantRelayer, RelayData relay);\n\n    // Note: the difference between a dispute and a cancellation is that a cancellation happens in the case where\n    // something changes in the OO between request and dispute that causes calls to it to fail. The most common\n    // case would be an increase in final fee. However, things like whitelisting can also cause problems.\n    event RelayDisputed(bytes32 indexed depositHash, bytes32 indexed relayHash, address indexed disputer);\n    event RelayCanceled(bytes32 indexed depositHash, bytes32 indexed relayHash, address indexed disputer);\n    event RelaySettled(bytes32 indexed depositHash, address indexed caller, RelayData relay);\n    event BridgePoolAdminTransferred(address oldAdmin, address newAdmin);\n\n    modifier onlyFromOptimisticOracle() {\n        require(msg.sender == address(optimisticOracle), \"Caller must be OptimisticOracle\");\n        _;\n    }\n\n    /**\n     * @notice Construct the Bridge Pool.\n     * @param _lpTokenName Name of the LP token to be deployed by this contract.\n     * @param _lpTokenSymbol Symbol of the LP token to be deployed by this contract.\n     * @param _bridgeAdmin Admin contract deployed alongside on L1. Stores global variables and has owner control.\n     * @param _l1Token Address of the L1 token that this bridgePool holds. This is the token LPs deposit and is bridged.\n     * @param _lpFeeRatePerSecond Interest rate payment that scales the amount of pending fees per second paid to LPs.\n     * @param _timer Timer used to synchronize contract time in testing. Set to 0x000... in production.\n     */\n    constructor(\n        string memory _lpTokenName,\n        string memory _lpTokenSymbol,\n        address _bridgeAdmin,\n        address _l1Token,\n        uint64 _lpFeeRatePerSecond,\n        bool _isWethPool,\n        address _timer\n    ) Testable(_timer) ExpandedERC20(_lpTokenName, _lpTokenSymbol, 18) {\n        require(bytes(_lpTokenName).length != 0 && bytes(_lpTokenSymbol).length != 0, \"Bad LP token name or symbol\");\n        bridgeAdmin = BridgeAdminInterface(_bridgeAdmin);\n        l1Token = IERC20(_l1Token);\n        lastLpFeeUpdate = uint32(getCurrentTime());\n        lpFeeRatePerSecond = _lpFeeRatePerSecond;\n        isWethPool = _isWethPool;\n\n        syncWithFinderAddresses(); // Fetch OptimisticOracle and Store addresses from the Finder.\n        syncWithBridgeAdminParams(); // Fetch ProposerBondPct OptimisticOracleLiveness, Identifier from the BridgeAdmin.\n    }\n\n    /*************************************************\n     *          LIQUIDITY PROVIDER FUNCTIONS         *\n     *************************************************/\n\n    /**\n     * @notice Add liquidity to the bridge pool. Pulls l1tokens from the callers wallet. The caller is sent back a\n     * commensurate number of LP tokens (minted to their address) at the prevailing exchange rate.\n     * @dev The caller must approve this contract to transfer `l1TokenAmount` amount of l1Token.\n     * @dev Reentrancy guard not added to this function because this indirectly calls sync() which is guarded.\n     * @param l1TokenAmount Number of l1Token to add as liquidity.\n     */\n    function addLiquidity(uint256 l1TokenAmount) public {\n        l1Token.safeTransferFrom(msg.sender, address(this), l1TokenAmount);\n\n        uint256 lpTokensToMint = (l1TokenAmount * 1e18) / exchangeRateCurrent();\n\n        _mint(msg.sender, lpTokensToMint);\n\n        liquidReserves += l1TokenAmount;\n\n        emit LiquidityAdded(address(l1Token), l1TokenAmount, lpTokensToMint, msg.sender);\n    }\n\n    /**\n     * @notice Removes liquidity to the bridge pool. Burns lpTokenAmount LP tokens from the callers wallet. The caller\n     * is sent back a commensurate number of l1Tokens at the prevailing exchange rate.\n     * @dev The caller does not need to approve the spending of LP tokens as this method directly uses the burn logic.\n     * @dev Reentrancy guard not added to this function because this indirectly calls sync() which is guarded.\n     * @param lpTokenAmount Number of lpTokens to redeem for underlying.\n     */\n    function removeLiquidity(uint256 lpTokenAmount) public {\n        uint256 l1TokensToReturn = (lpTokenAmount * exchangeRateCurrent()) / 1e18;\n\n        // Check that there is enough liquid reserves to withdraw the requested amount.\n        require(liquidReserves >= (pendingReserves + l1TokensToReturn), \"Utilization too high to remove\");\n\n        _burn(msg.sender, lpTokenAmount);\n\n        liquidReserves -= l1TokensToReturn;\n\n        l1Token.safeTransfer(msg.sender, l1TokensToReturn);\n\n        emit LiquidityRemoved(address(l1Token), l1TokensToReturn, lpTokenAmount, msg.sender);\n    }\n\n    /**************************************\n     *          RELAYER FUNCTIONS         *\n     **************************************/\n\n    /**\n     * @notice Called by Relayer to execute a slow + fast relay from L2 to L1, fulfilling a corresponding deposit order.\n     * @dev There can only be one pending relay for a deposit. This method is effectively the relayDeposit and\n     * speedUpRelay methods concatenated. This could be refactored to just call each method, but there\n     * are some gas savings in combining the transfers and hash computations.\n     * @dev Caller must have approved this contract to spend the total bond + amount - fees for `l1Token`.\n     * @param depositData the deposit data struct containing all the user's deposit information.\n     * @param realizedLpFeePct LP fee calculated off-chain considering the L1 pool liquidity at deposit time, before\n     *      quoteTimestamp. The OO acts to verify the correctness of this realized fee. Can not exceed 50%.\n     */\n    function relayAndSpeedUp(DepositData memory depositData, uint64 realizedLpFeePct) public nonReentrant() {\n        // If no pending relay for this deposit, then associate the caller's relay attempt with it.\n        uint32 priceRequestTime = uint32(getCurrentTime());\n\n        // The realizedLPFeePct should never be greater than 0.5e18 and the slow and instant relay fees should never be\n        // more than 0.25e18 each. Therefore, the sum of all fee types can never exceed 1e18 (or 100%).\n        require(\n            depositData.slowRelayFeePct < 0.25e18 &&\n                depositData.instantRelayFeePct < 0.25e18 &&\n                realizedLpFeePct < 0.5e18\n        );\n\n        // Check if there is a pending relay for this deposit.\n        bytes32 depositHash = _getDepositHash(depositData);\n\n        // Note: A disputed relay deletes the stored relay hash and enables this require statement to pass.\n        require(relays[depositHash] == bytes32(0), \"Pending relay exists\");\n\n        uint256 proposerBond = _getProposerBond(depositData.amount);\n        uint256 finalFee = store.computeFinalFee(address(l1Token)).rawValue;\n\n        // Save hash of new relay attempt parameters.\n        RelayData memory relayData =\n            RelayData({\n                relayState: RelayState.Pending,\n                slowRelayer: msg.sender,\n                relayId: numberOfRelays++, // Note: Increment numberOfRelays at the same time as setting relayId to its current value.\n                realizedLpFeePct: realizedLpFeePct,\n                priceRequestTime: priceRequestTime,\n                proposerBond: proposerBond,\n                finalFee: finalFee\n            });\n        bytes32 relayHash = _getRelayHash(depositData, relayData);\n        relays[depositHash] = _getRelayDataHash(relayData);\n\n        bytes32 instantRelayHash = _getInstantRelayHash(depositHash, relayData);\n        require(\n            // Can only speed up a pending relay without an existing instant relay associated with it.\n            instantRelays[instantRelayHash] == address(0),\n            \"Relay cannot be sped up\"\n        );\n\n        // Sanity check that pool has enough balance to cover relay amount + proposer reward. Reward amount will be\n        // paid on settlement after the OptimisticOracle price request has passed the challenge period.\n        require(\n            l1Token.balanceOf(address(this)) >= depositData.amount + proposerBond &&\n                liquidReserves >= depositData.amount + proposerBond,\n            \"Insufficient pool balance\"\n        );\n\n        // Compute total proposal bond and pull from caller so that the OptimisticOracle can pull it from here.\n        uint256 totalBond = proposerBond + finalFee;\n\n        // Pull relay amount minus fees from caller and send to the deposit l1Recipient. The total fees paid is the sum\n        // of the LP fees, the relayer fees and the instant relay fee.\n        uint256 feesTotal =\n            _getAmountFromPct(\n                relayData.realizedLpFeePct + depositData.slowRelayFeePct + depositData.instantRelayFeePct,\n                depositData.amount\n            );\n        // If the L1 token is WETH then: a) pull WETH from instant relayer b) unwrap WETH c) send ETH to recipient.\n        uint256 recipientAmount = depositData.amount - feesTotal;\n\n        l1Token.safeTransferFrom(msg.sender, address(this), recipientAmount + totalBond);\n        bonds += totalBond;\n\n        pendingReserves += depositData.amount; // Book off maximum liquidity used by this relay in the pending reserves.\n\n        instantRelays[instantRelayHash] = msg.sender;\n\n        if (isWethPool) {\n            _unwrapWETHTo(depositData.l1Recipient, recipientAmount);\n        }\n        // Else, this is a normal ERC20 token. Send to recipient.\n        else l1Token.safeTransfer(depositData.l1Recipient, recipientAmount);\n\n        emit DepositRelayed(depositHash, depositData, address(l1Token), relayData, relayHash);\n        emit RelaySpedUp(depositHash, msg.sender, relayData);\n    }\n\n    /**\n     * @notice Called by Disiputer to dispute an ongoing relay.\n     * @dev The result of this method is to always throw out the relay, providing an opportunity for another relay for\n     * the same deposit. Between the disputer and proposer, whoever is incorrect loses their bond. Whoever is correct\n     * gets it back + a payout.\n     * @dev Caller must have approved this contract to spend the total bond + amount - fees for `l1Token`.\n     * @param depositData the deposit data struct containing all the user's deposit information.\n     * @param relayData RelayData logged in the disputed relay.\n     */\n    function disputeRelay(DepositData memory depositData, RelayData memory relayData) public nonReentrant() {\n        require(relayData.priceRequestTime + optimisticOracleLiveness > getCurrentTime(), \"Past liveness\");\n        require(relayData.relayState == RelayState.Pending, \"Not disputable\");\n        // Validate the input data.\n        bytes32 depositHash = _getDepositHash(depositData);\n        _validateRelayDataHash(depositHash, relayData);\n\n        // Submit the proposal and dispute to the OO.\n        bytes32 relayHash = _getRelayHash(depositData, relayData);\n\n        // Note: in some cases this will fail due to changes in the OO and the method will refund the relayer.\n        bool success =\n            _requestProposeDispute(\n                relayData.slowRelayer,\n                msg.sender,\n                relayData.proposerBond,\n                relayData.finalFee,\n                // relayData.priceRequestTime,\n                _getRelayAncillaryData(relayHash)\n            );\n\n        // Drop the relay and remove the bond from the tracked bonds.\n        bonds -= relayData.finalFee + relayData.proposerBond;\n        delete relays[depositHash];\n        if (success) emit RelayDisputed(depositHash, _getRelayDataHash(relayData), msg.sender);\n        else emit RelayCanceled(depositHash, _getRelayDataHash(relayData), msg.sender);\n    }\n\n    /**\n     * @notice Called by Relayer to execute a slow relay from L2 to L1, fulfilling a corresponding deposit order.\n     * @dev There can only be one pending relay for a deposit.\n     * @dev Caller must have approved this contract to spend the total bond for `l1Token`.\n     * @param chainId Unique network ID on which deposit event occurred.\n     * @param depositId Unique ID corresponding to deposit order that caller wants to relay.\n     * @param l1Recipient Address on this network who should receive the relayed deposit.\n     * @param l2Sender Address on the L2 network of depositor.\n     * @param amount Amount deposited on L2 to be brought over to L1.\n     * @param slowRelayFeePct Max fraction of `amount` that the depositor is willing to pay as a slow relay fee.\n     * @param instantRelayFeePct Fraction of `amount` that the depositor is willing to pay as a instant relay fee.\n     * @param quoteTimestamp Timestamp up until the depositor is willing to accept an LP quotation for.\n     * @param realizedLpFeePct LP fee calculated off-chain considering the L1 pool liquidity at deposit time, before\n     *      quoteTimestamp. The OO acts to verify the correctness of this realized fee. Can not exceed 50%.\n     */\n    function relayDeposit(\n        uint8 chainId,\n        uint64 depositId,\n        address payable l1Recipient,\n        address l2Sender,\n        uint256 amount,\n        uint64 slowRelayFeePct,\n        uint64 instantRelayFeePct,\n        uint32 quoteTimestamp,\n        uint64 realizedLpFeePct\n    ) public nonReentrant() {\n        // The realizedLPFeePct should never be greater than 0.5e18 and the slow and instant relay fees should never be\n        // more than 0.25e18 each. Therefore, the sum of all fee types can never exceed 1e18 (or 100%).\n        require(slowRelayFeePct < 0.25e18 && instantRelayFeePct < 0.25e18 && realizedLpFeePct < 0.5e18);\n\n        // Check if there is a pending relay for this deposit.\n        DepositData memory depositData =\n            DepositData({\n                chainId: chainId,\n                depositId: depositId,\n                l1Recipient: l1Recipient,\n                l2Sender: l2Sender,\n                amount: amount,\n                slowRelayFeePct: slowRelayFeePct,\n                instantRelayFeePct: instantRelayFeePct,\n                quoteTimestamp: quoteTimestamp\n            });\n        bytes32 depositHash = _getDepositHash(depositData);\n\n        // Note: A disputed relay deletes the stored relay hash and enables this require statement to pass.\n        require(relays[depositHash] == bytes32(0), \"Pending relay exists\");\n\n        // If no pending relay for this deposit, then associate the caller's relay attempt with it.\n        uint32 priceRequestTime = uint32(getCurrentTime());\n\n        uint256 proposerBond = _getProposerBond(amount);\n        uint256 finalFee = store.computeFinalFee(address(l1Token)).rawValue;\n\n        // Save hash of new relay attempt parameters.\n        RelayData memory relayData =\n            RelayData({\n                relayState: RelayState.Pending,\n                slowRelayer: msg.sender,\n                relayId: numberOfRelays++, // Note: Increment numberOfRelays at the same time as setting relayId to its current value.\n                realizedLpFeePct: realizedLpFeePct,\n                priceRequestTime: priceRequestTime,\n                proposerBond: proposerBond,\n                finalFee: finalFee\n            });\n        relays[depositHash] = _getRelayDataHash(relayData);\n\n        bytes32 relayHash = _getRelayHash(depositData, relayData);\n\n        // Sanity check that pool has enough balance to cover relay amount + proposer reward. Reward amount will be\n        // paid on settlement after the OptimisticOracle price request has passed the challenge period.\n        require(\n            l1Token.balanceOf(address(this)) >= amount + proposerBond && liquidReserves >= amount + proposerBond,\n            \"Insufficient pool balance\"\n        );\n\n        // Compute total proposal bond and pull from caller so that the OptimisticOracle can pull it from here.\n        uint256 totalBond = proposerBond + finalFee;\n        l1Token.safeTransferFrom(msg.sender, address(this), totalBond);\n\n        pendingReserves += amount; // Book off maximum liquidity used by this relay in the pending reserves.\n        bonds += totalBond;\n\n        emit DepositRelayed(depositHash, depositData, address(l1Token), relayData, relayHash);\n    }\n\n    /**\n     * @notice Instantly relay a deposit amount minus fees to the l1Recipient. Instant relayer earns a reward following\n     * the pending relay challenge period.\n     * @dev We assume that the caller has performed an off-chain check that the deposit data they are attempting to\n     * relay is valid. If the deposit data is invalid, then the instant relayer has no recourse to receive their funds\n     * back after the invalid deposit data is disputed. Moreover, no one will be able to resubmit a relay for the\n     * invalid deposit data because they know it will get disputed again. On the other hand, if the deposit data is\n     * valid, then even if it is falsely disputed, the instant relayer will eventually get reimbursed because someone\n     * else will be incentivized to resubmit the relay to earn slow relayer rewards. Once the valid relay is finalized,\n     * the instant relayer will be reimbursed. Therefore, the caller has the same responsibility as the disputer in\n     * validating the relay data.\n     * @dev Caller must have approved this contract to spend the deposit amount of L1 tokens to relay. There can only\n     * be one instant relayer per relay attempt.\n     * @param depositData Unique set of L2 deposit data that caller is trying to instantly relay.\n     * @param relayData Parameters of Relay that caller is attempting to speedup. Must hash to the stored relay hash\n     * for this deposit or this method will revert.\n     */\n    function speedUpRelay(DepositData memory depositData, RelayData memory relayData) public nonReentrant() {\n        bytes32 depositHash = _getDepositHash(depositData);\n        _validateRelayDataHash(depositHash, relayData);\n\n        bytes32 instantRelayHash = _getInstantRelayHash(depositHash, relayData);\n        require(\n            // Can only speed up a pending relay without an existing instant relay associated with it.\n            relayData.relayState == RelayState.Pending && instantRelays[instantRelayHash] == address(0),\n            \"Relay cannot be sped up\"\n        );\n        instantRelays[instantRelayHash] = msg.sender;\n\n        // Pull relay amount minus fees from caller and send to the deposit l1Recipient. The total fees paid is the sum\n        // of the LP fees, the relayer fees and the instant relay fee.\n        uint256 feesTotal =\n            _getAmountFromPct(\n                relayData.realizedLpFeePct + depositData.slowRelayFeePct + depositData.instantRelayFeePct,\n                depositData.amount\n            );\n        // If the L1 token is WETH then: a) pull WETH from instant relayer b) unwrap WETH c) send ETH to recipient.\n        uint256 recipientAmount = depositData.amount - feesTotal;\n        if (isWethPool) {\n            l1Token.safeTransferFrom(msg.sender, address(this), recipientAmount);\n            _unwrapWETHTo(depositData.l1Recipient, recipientAmount);\n        }\n        // Else, this is a normal ERC20 token. Send to recipient.\n        else l1Token.safeTransferFrom(msg.sender, depositData.l1Recipient, recipientAmount);\n\n        emit RelaySpedUp(depo"
    }
  ]
}