{
  "Title": "H-2: YT holder are unable to claim their interest",
  "Content": "# Issue H-2: YT holder are unable to claim their interest \n\nSource: https://github.com/sherlock-audit/2024-01-napier-judging/issues/80 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nxiaoming90\n## Summary\n\nA malicious user could prevent YT holders from claiming their interest, leading to a loss of assets.\n\n## Vulnerability Detail\n\nThe interest accrued (in target token) by a user is computed based on the following formula, where $lscale$ is the user's last scale update and $maxScale$ is the max scale observed so far. The formula is taken from [here](https://github.com/sherlock-audit/2024-01-napier/blob/main/napier-v1/src/Tranche.sol#L722):\n\n$$\ninterestAccrued = y(\\frac{1}{lscale} - \\frac{1}{maxScale})\n$$\n\nA malicious user could perform the following steps to manipulate the $maxScale$ to a large value to prevent YT holders from claiming their interest.\n\n1) When the Tranche and Adaptor are deployed, immediately mint the smallest possible number of shares. Attackers can do so by calling the Adaptor's `prefundedDeposit` function directly if they want to avoid issuance fees OR call the `Tranche.issue` function\n2) Transfer large amounts of assets to the Adaptor directly. With a small amount of total supply and a large amount of total assets, the Adaptor's scale will be extremely large. Let the large scale at this point be $L$.\n3) Trigger any function that will trigger an update to the global scale. The max scale will be updated to $L$ and locked at this large scale throughout the entire lifecycle of the Tranche, as it is not possible for the scale to exceed $L$ based on the current market yield or condition.\n4) Attacker withdraws all their shares and assets via Adaptor's `prefundedDeposit` function or Tranche's redeem functions. Note that the attacker will not incur any fees during withdrawal. Thus, this attack is economically cheap and easy to execute.\n5) After the attacker's withdrawal, the current scale of the adapter will revert back to normal (e.g. 1.0 exchange rate), and the scale will only increase due to the yield from staked ETH (e.g. daily rebase) and increase progressively (e.g., 1.0 > 1.05 > 1.10 > 1.15)\n\nWhen a user issues/mints new PT and YT, their `lscales[user]` will be set to the $maxScale$, which is $L$. \n\nA user's `lscales[user]` will only be updated if the adaptor's current scale is larger than $L$. As stated earlier, it is not possible for the scale to exceed $L$ based on the current market yield or condition. Thus, the user's `lscales[user]` will be stuck at $L$ throughout the entire lifecycle of the Tranche.\n\nAs a result, there is no way for the YT holder to claim their interest because, since $lscale == maxScale$, the interest accrued computed from the formula will always be zero. Thus, even if the Tranche/Adaptor started gaining yield from staked ETH, there is no way for YT holders to claim that.\n\n## Impact\n\nYT holders cannot claim their interest, leading to a loss of assets.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/napier-v1/src/Tranche.sol#L704\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nEnsure that the YT holders can continue to claim their accrued interest earned within the Tranche/Adaptor regardless of the max scale.\n\n\n\n## Discussion\n\n**nevillehuang**\n\nEscalate\n\nDuplicate of #92, exact same root cause, involving manipulations of maxScales\n\n**sherlock-admin2**\n\n> Escalate\n> \n> Duplicate of #92, exact same root cause, involving manipulations of maxScales\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**massun-onibakuchi**\n\nEscalate\n@nevillehuang  \nThis issue should be lower. I think this is duplicate of #125.\nAs you say,  the root cause is that scale can be manipulated, which is mainly based on a kind of inflation attack. This attack assume an attacker is able to be the first depositor to manipulate rate effectively. Also at that time, basically no one has not issued any PT/YT. Even if someone mints some PT/YT, they can redeem them by burning together (`redeemWithYt`) with minimum issuance fee loss.  This issue can be easily prevented by minting some shares earlier than a attacker in the same way as well-known inflation attack.\n\n**nevillehuang**\n\n@massun-onibakuchi In that case, I think medium severity is appropriate for this issue and #92, which should be duplicated together. \n\n**xiaoming9090**\n\nThe sponsor mentioned that the mitigation would be to mint some shares in advance to prevent the well-known inflation attack. I agree with the sponsor that this is the correct approach to fix the issue.\n\nHowever, the mitigation of minting some shares in advance to prevent this issue was not documented in the contestâ€™s README. Thus, the issue remains valid and as it is, as mitigation cannot be applied retrospectively after the contest. Otherwise, it would be unfair to the Watsons to raise an issue that only gets invalid by a mitigation shared after the contest/audit.\n\n**xiaoming9090**\n\n> Escalate @nevillehuang This issue should be lower. I think this is duplicate of #125. As you say, the root cause is that scale can be manipulated, which is mainly based on a kind of inflation attack. This attack assume an attacker is able to be the first depositor to manipulate rate effectively. Also at that time, basically no one has not issued any PT/YT. Even if someone mints some PT/YT, they can redeem them by burning together (`redeemWithYt`) with minimum issuance fee loss. This issue can be easily prevented by minting some shares earlier than a attacker in the same way as well-known inflation attack.\n\nDisagree that this issue should be duplicated with Issue https://github.com/sherlock-audit/2024-01-napier-judging/issues/125.\n\nIssue https://github.com/sherlock-audit/2024-01-napier-judging/issues/125 (and its duplicate https://github.com/sherlock-audit/2024-01-napier-judging/issues/94, which has a better write-up of the issue) discusses the classic vault inflation attack. This attack exploits the rounding error and exchange rate manipulation to steal from the victim depositor. It is a well-known attack that everyone is aware of.\n\nThis issue concerns manipulating the max scale by malicious users, which has prevented the YT holders from claiming their interest. This is a more complex issue and only specific to the Naiper protocol.\n\nThus, these two are different issues, and we should be careful not to overgeneralize all issues under the same category (e.g., re-entrancy, manipulation, access control) as one single issue without considering the details.\n\n\n\n**xiaoming9090**\n\nEscalate\n\nThis issue should be a High risk instead of Medium as this issue prevents YT holders from claiming their interest, leading to a loss of assets.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> This issue should be a High risk instead of Medium as this issue prevents YT holders from claiming their interest, leading to a loss of assets.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**cvetanovv**\n\nFirst, I disagree with the sponsor that this should be Low severity and a duplicate of the #125.\n\n As I wrote in other reports, this \"inflation attack\" is not documented as a known issue. \n\nI agree with the escalations of @xiaoming9090 and @nevillehuang. This issue has the same root cause as #92 and can be duplicated as a valid High.\n\n**Czar102**\n\nAfter some considerations, I think duplicating this issue with #92 makes sense by claiming that both of these are sourced in the ability to manipulate the scale by donations.\n\nPlease note that this doesn't mean that all \"inflation attacks\" are considered of the same root cause.\n\n**Czar102**\n\nResult:\nHigh\nDuplicate of #92\n\nAccepting only the first escalation since it was the first accurate one.\n\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [nevillehuang](https://github.com/sherlock-audit/2024-01-napier-judging/issues/80/#issuecomment-1984771258): accepted\n- [xiaoming9090](https://github.com/sherlock-audit/2024-01-napier-judging/issues/80/#issuecomment-1987104210): rejected\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/171",
  "Code": [
    {
      "filename": "napier-v1/src/Tranche.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.19;\n\n// interfaces\nimport {IERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/IERC20.sol\";\nimport {IERC5095} from \"./interfaces/IERC5095.sol\";\nimport {ITranche} from \"./interfaces/ITranche.sol\";\nimport {IYieldToken} from \"./interfaces/IYieldToken.sol\";\nimport {ITrancheFactory} from \"./interfaces/ITrancheFactory.sol\";\nimport {IBaseAdapter} from \"./interfaces/IBaseAdapter.sol\";\n// libs\nimport {Math} from \"@openzeppelin/contracts@4.9.3/utils/math/Math.sol\";\nimport {FixedPointMathLib} from \"./utils/FixedPointMathLib.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts@4.9.3/utils/math/SafeCast.sol\";\nimport {SafeERC20Namer} from \"./utils/SafeERC20Namer.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/utils/SafeERC20.sol\";\nimport {MAX_BPS} from \"./Constants.sol\";\n// inheriting\nimport {ERC20Permit, ERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/extensions/ERC20Permit.sol\";\nimport {Pausable} from \"@openzeppelin/contracts@4.9.3/security/Pausable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts@4.9.3/security/ReentrancyGuard.sol\";\nimport {BaseToken} from \"./BaseToken.sol\";\n\n/// @title Tranche\n/// @author Napier Labs\n/// @author 0xbakuchi\n/// @notice Tranche divides a yield-bearing token into two tokens: principal token and yield token.\n/// This contract itself is a principal token.\n/// Users can interact with this contract to issue, redeem tokens, and gather yield.\n/// Both the Principal and Yield tokens share the same decimal notation as the underlying token.\n/// Math:\n/// - Yield Stripping Math paper: https://github.com/Napier-Lab/napier-v1/blob/main/assets/Yield_Stripping_Math__1_.pdf\n/// - Hackmd: https://hackmd.io/W2mPhP7YRjGxqnAc93omLg?both\n/// PT/YT and Target token conversion is defined as:\n/// P = T * scale / 1e18\n///   = T * price * 10^(18 + uDecimals - tDecimals) / 1e18\n/// Where P is amount of PT and T is amount of Target.\n/// @dev Supported Tokens:\n/// - Underlying token can be rebased token.\n/// - Underlying must not be ERC777 token.\n/// - Target token can not be rebased token.\ncontract Tranche is BaseToken, ReentrancyGuard, Pausable, ITranche {\n    using SafeERC20 for IERC20;\n    using FixedPointMathLib for uint256;\n    using SafeCast for uint256;\n\n    uint8 internal immutable uDecimals;\n\n    /// @notice Represents the underlying token where users deposit (e.g. DAI)\n    IERC20 internal immutable _underlying;\n\n    /// @notice Represents the yield-bearing token (e.g. cDAI)\n    IERC20 internal immutable _target;\n\n    /// @notice Represents the Yield token that represents the right to claim the yield\n    IYieldToken internal immutable _yt;\n\n    /// @notice An adapter that interacts with the yield source (e.g. Compound)\n    IBaseAdapter public immutable adapter;\n\n    /// @notice Address of the management account\n    address public immutable management;\n\n    // Principal token Parameters\n\n    /// @inheritdoc IERC5095\n    /// @notice The timestamp of maturity in unix seconds\n    uint256 public immutable override(BaseToken, IERC5095) maturity;\n\n    /// @notice Percentage of underlying principal reserved for YTs.\n    /// YT holders can claim this after maturity. (10000 = 100%)\n    uint256 internal immutable tilt;\n\n    /// @notice 10_000 - tilt (10000 = 100%) for gas savings\n    uint256 internal immutable oneSubTilt;\n\n    /// @notice The fee for issuing new tokens (10000 = 100%)\n    uint256 internal immutable issuanceFeeBps;\n\n    //////////////////////////////////////////////////\n    // State Variables\n    //////////////////////////////////////////////////\n\n    /// @notice Variables tracking the yield-bearing token's scales\n    /// @dev This is used to calculate the claimable yield and is updated on every issue, collect, and redeemYT action.\n    ///  - `mscale` represents the scale of the yield-bearing token at or after maturity,\n    /// it is set only at the time of users redeeming, redeemingYT and collecting at/after maturity.\n    ///  - `maxscale` represents the maximum scale of the yield-bearing token since the Tranche's creation till now.\n    GlobalScales internal gscales;\n\n    /// @dev Accumulated issuance fees charged (in units of target token). The management can withdraw this fees.\n    uint256 public issuanceFees;\n\n    /// @dev The address that receives the issuance fees. This address can be changed by the `management`.\n    address public feeRecipient;\n\n    /// @notice Keeps track of the scale of the target token at the last user action.\n    /// @dev It is used for calculating the yield that can be claimed. It gets updated on every user action.\n    /// user -> lscale (last scale)\n    /// See \"Yield Stripping Math\" for more details.\n    mapping(address => uint256) public lscales;\n\n    /// @notice Keeps track of the yield not claimed by each user in units of the target token.\n    /// @dev This value is reset to 0 on every issue, collect and redeemYT action. Every YT transfer also increases this value.\n    mapping(address => uint256) public unclaimedYields;\n\n    /* ================== MODIFIERS =================== */\n\n    /// @notice Revert if timestamp is before maturity\n    modifier expired() {\n        if (block.timestamp < maturity) revert TimestampBeforeMaturity();\n        _;\n    }\n\n    /// @notice Revert if timestamp is at or after maturity\n    modifier notExpired() {\n        if (block.timestamp >= maturity) revert TimestampAfterMaturity();\n        _;\n    }\n\n    /// @notice Revert if reentrancy guard is already set to `entered`\n    modifier notEntered() {\n        if (_reentrancyGuardEntered()) revert ReentrancyGuarded();\n        _;\n    }\n\n    /// @notice Revert if msg sender is not management address\n    modifier onlyManagement() {\n        if (msg.sender != management) revert Unauthorized();\n        _;\n    }\n\n    /// @dev Assume Tranche is deployed from a factory.\n    /// Doesn't take constructor arguments directly so that CREATE2 address is independent of the constructor arguments.\n    /// The arguments are fetched through a callback to the factory.\n    /// @custom:param _args The arguments for the Tranche contract.\n    ///\n    /// The constructor is `payable` to remove msg.value check and reduce about 198 gas cost at deployment time.\n    /// This is acceptable because the factory contract doesn't deploy Tranche with ETH.\n    constructor() payable ERC20(\"Napier Principal Token\", \"ePT\") ERC20Permit(\"Napier Principal Token\") {\n        // Retrieve constructor arguments from the factory\n        ITrancheFactory.TrancheInitArgs memory args = ITrancheFactory(msg.sender).args();\n        address underlying_ = IBaseAdapter(args.adapter).underlying();\n        address target_ = IBaseAdapter(args.adapter).target();\n\n        // Initialize immutable and state variables\n        feeRecipient = args.management;\n        management = args.management;\n\n        _underlying = IERC20(underlying_);\n        _target = IERC20(target_);\n        _yt = IYieldToken(args.yt);\n        adapter = IBaseAdapter(args.adapter);\n        tilt = args.tilt;\n        oneSubTilt = MAX_BPS - tilt; // 10_000 - tilt\n        issuanceFeeBps = args.issuanceFee;\n        maturity = args.maturity;\n        uDecimals = ERC20(underlying_).decimals();\n        // Set maxscale to the current scale\n        gscales.maxscale = IBaseAdapter(args.adapter).scale().toUint128();\n\n        emit SeriesCreated(args.adapter, args.maturity, args.tilt, args.issuanceFee);\n    }\n\n    /* ================== MUTATIVE METHODS =================== */\n\n    /// @inheritdoc ITranche\n    /// @notice This function issues Principal Token (PT) and Yield Token (YT) to `to` in exchange for `underlyingAmount` of underlying token.\n    /// Issued PT and YT is the sum of:\n    /// - amount derived from the deposited underlying token\n    /// - amount derived from reinveted unclaimed yield\n    /// - amount derived from reinvested accrued yield from last time when YT balance was updated to now\n    ///\n    /// Issuance Fee is charged on the amount of Target Token used to issue PT and YT.\n    /// @dev The function will be reverted if the maturity has passed.\n    /// @param to The recipient of PT and YT\n    /// @param underlyingAmount The amount of underlying token to be deposited. (in units of underlying token)\n    /// @return issued The amount of PT and YT minted\n    function issue(\n        address to,\n        uint256 underlyingAmount\n    ) external nonReentrant whenNotPaused notExpired returns (uint256 issued) {\n        uint256 _lscale = lscales[to];\n        uint256 accruedInTarget = unclaimedYields[to];\n        uint256 _maxscale = gscales.maxscale;\n\n        // NOTE: Updating mscale/maxscale in the cache before the issue to determine the accrued yield.\n        uint256 cscale = adapter.scale();\n\n        if (cscale > _maxscale) {\n            // If the current scale is greater than the maxscale, update scales\n            _maxscale = cscale;\n            gscales.maxscale = cscale.toUint128();\n        }\n        // Updating user's last scale to the latest maxscale\n        lscales[to] = _maxscale;\n        delete unclaimedYields[to];\n\n        uint256 yBal = _yt.balanceOf(to);\n        // If recipient has unclaimed interest, claim it and then reinvest it to issue more PT and YT.\n        // Reminder: lscale is the last scale when the YT balance of the user was updated.\n        if (_lscale != 0) {\n            accruedInTarget += _computeAccruedInterestInTarget(_maxscale, _lscale, yBal);\n        }\n\n        // Transfer underlying from user to adapter and deposit it into adapter to get target token\n        _underlying.safeTransferFrom(msg.sender, address(adapter), underlyingAmount);\n        (, uint256 sharesMinted) = adapter.prefundedDeposit();\n\n        // Deduct the issuance fee from the amount of target token minted + reinvested yield\n        // Fee should be rounded up towards the protocol (against the user) so that issued principal is rounded down\n        // Hackmd: F0\n        // ptIssued\n        // = (u/s + y - fee) * S\n        // = (sharesUsed - fee) * S\n        // where u = underlyingAmount, s = current scale, y = reinvested yield, S = maxscale\n        uint256 sharesUsed = sharesMinted + accruedInTarget;\n        uint256 fee = sharesUsed.mulDivUp(issuanceFeeBps, MAX_BPS);\n        issued = (sharesUsed - fee).mulWadDown(_maxscale);\n\n        // Accumulate issueance fee in units of target token\n        issuanceFees += fee;\n        // Mint PT and YT to user\n        _mint(to, issued);\n        _yt.mint(to, issued);\n\n        emit Issue(msg.sender, to, issued, sharesUsed);\n    }\n\n    /// @inheritdoc ITranche\n    /// @notice Withdraws underlying tokens from the caller in exchange for `amount` of PT and YT.\n    /// 1 PT + 1 YT = 1 Target token (e.g. 1 wstETH). This equation is always true\n    /// because PT represents the principal amount of the Target token and YT represents the yield of the Target token.\n    /// Basically, anyone can burn `x` PT and `x` YT to withdraw `x` Target tokens anytime.\n    ///\n    /// Withdrawn amount will be the sum of the following:\n    /// - amount derived from PT + YT burn\n    /// - amount of unclaimed yield\n    /// - amount of accrued yield from the last time when the YT balance was updated to now\n    /// @notice If the caller is not `from`, `from` must have approved the caller to spend `pyAmount` for PT and YT prior to calling this function.\n    /// @dev Reverts if the caller does not have enough PT and YT.\n    /// @param from The owner of PT and YT.\n    /// @param to The recipient of the redeemed underlying tokens.\n    /// @param pyAmount The amount of principal token (and yield token) to redeem in units of underlying tokens.\n    /// @return (uint256) The amount of underlying tokens redeemed.\n    function redeemWithYT(address from, address to, uint256 pyAmount) external nonReentrant returns (uint256) {\n        uint256 _lscale = lscales[from];\n        uint256 accruedInTarget = unclaimedYields[from];\n\n        // Calculate the accrued interest in Target token\n        // The lscale should not be 0 because the user should have some YT balance\n        if (_lscale == 0) revert NoAccruedYield();\n\n        GlobalScales memory _gscales = gscales;\n        _updateGlobalScalesCache(_gscales);\n\n        // Compute the accrued yield from the time when the YT balance is updated last to now\n        // The accrued yield in units of target is computed as:\n        // Formula: yield = ytBalance * (1/lscale - 1/maxscale)\n        // Sum up the accrued yield, plus the unclaimed yield from the last time to now\n        accruedInTarget += _computeAccruedInterestInTarget(\n            _gscales.maxscale,\n            _lscale,\n            // Use yt balance instead of `pyAmount`\n            // because we'll update the user's lscale to the current maxscale after this line\n            // regardless of whether the user redeems all of their yt or not.\n            // Otherwise, the user will lose some accrued yield from the last time to now.\n            _yt.balanceOf(from)\n        );\n        // Compute shares equivalent to the amount of principal token to redeem\n        uint256 sharesRedeemed = pyAmount.divWadDown(_gscales.maxscale);\n\n        // Update the local scale and accrued yield of `from`\n        lscales[from] = _gscales.maxscale;\n        delete unclaimedYields[from];\n        gscales = _gscales;\n\n        // Burn PT and YT tokens from `from`\n        _burnFrom(from, pyAmount);\n        _yt.burnFrom(from, msg.sender, pyAmount);\n\n        // Withdraw underlying tokens from the adapter and transfer them to the user\n        _target.safeTransfer(address(adapter), sharesRedeemed + accruedInTarget);\n        (uint256 amountWithdrawn, ) = adapter.prefundedRedeem(to);\n\n        emit RedeemWithYT(from, to, amountWithdrawn);\n        return amountWithdrawn;\n    }\n\n    /// @inheritdoc IERC5095\n    /// @notice If the sender is not `from`, it must have approval from `from` to redeem `principalAmount` PT.\n    /// Redeems `principalAmount` PT from `from` and transfers underlying tokens to `to`.\n    /// @dev Reverts if maturity has not passed.\n    /// @param principalAmount The amount of principal tokens to redeem in units of underlying tokens.\n    /// @param to The recipient of the redeemed underlying tokens.\n    /// @param from The owner of the PT.\n    /// @return (uint256) The amount of underlying tokens redeemed.\n    function redeem(\n        uint256 principalAmount,\n        address to,\n        address from\n    ) external override nonReentrant expired returns (uint256) {\n        GlobalScales memory _gscales = gscales;\n        _updateGlobalScalesCache(_gscales);\n\n        // Compute the shares to be redeemed\n        uint256 shares = _computeSharesRedeemed(_gscales, principalAmount);\n\n        gscales = _gscales;\n        // Burn PT tokens from `from`\n        _burnFrom(from, principalAmount);\n        // Withdraw underlying tokens from the adapter and transfer them to `to`\n        _target.safeTransfer(address(adapter), shares);\n        (uint256 underlyingWithdrawn, ) = adapter.prefundedRedeem(to);\n\n        emit Redeem(from, to, underlyingWithdrawn);\n        return underlyingWithdrawn;\n    }\n\n    /// @inheritdoc IERC5095\n    /// @notice If the sender is not `from`, it must have approval from `from` to redeem an equivalent amount of principal tokens.\n    /// Redeems PT equivalent to `underlyingAmount` underlying tokens from `from` and transfers underlying tokens to `to`.\n    /// @dev Reverts if maturity has not passed.\n    /// @param underlyingAmount The amount of underlying tokens to redeem in units of underlying tokens.\n    /// @param to The recipient of the redeemed underlying tokens.\n    /// @param from The owner of the PT.\n    /// @return (uint256) The amount of principal tokens redeemed.\n    function withdraw(\n        uint256 underlyingAmount,\n        address to,\n        address from\n    ) external override nonReentrant expired returns (uint256) {\n        GlobalScales memory _gscales = gscales;\n        uint256 cscale = _updateGlobalScalesCache(_gscales);\n\n        // Compute the shares to be redeemed\n        uint256 sharesRedeem = underlyingAmount.divWadDown(cscale);\n        uint256 principalAmount = _computePrincipalTokenRedeemed(_gscales, sharesRedeem);\n\n        // Update the global scales\n        gscales = _gscales;\n        // Burn PT tokens from `from`\n        _burnFrom(from, principalAmount);\n        // Withdraw underlying tokens from the adapter and transfer them to `to`\n        _target.safeTransfer(address(adapter), sharesRedeem);\n        (uint256 underlyingWithdrawn, ) = adapter.prefundedRedeem(to);\n\n        emit Redeem(from, to, underlyingWithdrawn);\n        return principalAmount;\n    }\n\n    /// @notice Before transferring YT, update the accrued yield for the sender and receiver.\n    /// NOTE: Every YT transfer will trigger this function to track accrued yield for each user.\n    /// @dev This function is only callable by the Yield Token contract when the user transfers YT to another user.\n    /// NOTE: YT is not burned in this function even if the maturity has passed.\n    /// @param from The address to transfer the Yield Token from.\n    /// @param to The address to transfer the Yield Token to (CAN be the same as `from`).\n    /// NOTE: `from` and `to` SHOULD NOT be zero addresses.\n    /// @param value The amount of Yield Token transferred to `to` (CAN be 0).\n    function updateUnclaimedYield(address from, address to, uint256 value) external nonReentrant whenNotPaused {\n        if (msg.sender != address(_yt)) revert OnlyYT();\n        if (from == address(0) || to == address(0)) revert ZeroAddress();\n        if (value == 0) return;\n\n        GlobalScales memory _gscales = gscales;\n        uint256 _lscaleFrom = lscales[from];\n\n        // If the lscale is 0, it means the user have never hold any YT before\n        // because the lscale is always set to maxscale when the YT is transferrred or minted.\n        // This doesn't mean current YT balance is 0 because the user could have transferred all YT out or burned YT.\n        // Thus there is no accrued interest for the user.\n        if (_lscaleFrom == 0) revert NoAccruedYield();\n\n        _updateGlobalScalesCache(_gscales);\n\n        // Calculate the accrued interest in Target token for `from`\n        unclaimedYields[from] += _computeAccruedInterestInTarget(_gscales.maxscale, _lscaleFrom, _yt.balanceOf(from));\n        lscales[from] = _gscales.maxscale;\n\n        // Calculate the accrued interest in Target token for `to`. `from` and `to` can be equal.\n        uint256 _lscaleReceiver = lscales[to];\n        if (_lscaleReceiver != 0) {\n            unclaimedYields[to] +=\n                _computeAccruedInterestInTarget(_gscales.maxscale, _lscaleReceiver, _yt.balanceOf(to)); // prettier-ignore\n        }\n        lscales[to] = _gscales.maxscale;\n        // update global scales\n        gscales = _gscales;\n    }\n\n    /// @notice Collects yield for `msg.sender` and converts it to underlying token and transfers it to `msg.sender`.\n    /// NOTE: If the maturity has passed, YT will be burned, and some of the principal will be transferred to `msg.sender` based on the `tilt` parameter.\n    /// The withdrwan amount of underlying token is the sum of the following:\n    /// - Amount of unclaimed yield\n    /// - Amount of accrued yield from the time when the YT balance was updated to now\n    /// - Amount of principal reserved for YT holders if the maturity has passed\n    /// @dev Anyone can call this function to collect yield for themselves.\n    /// @return The collected yield in underlying token.\n    function collect() public nonReentrant whenNotPaused returns (uint256) {\n        uint256 _lscale = lscales[msg.sender];\n        uint256 accruedInTarget = unclaimedYields[msg.sender];\n\n        if (_lscale == 0) revert NoAccruedYield();\n\n        GlobalScales memory _gscales = gscales;\n        _updateGlobalScalesCache(_gscales);\n\n        uint256 yBal = _yt.balanceOf(msg.sender);\n        accruedInTarget += _computeAccruedInterestInTarget(_gscales.maxscale, _lscale, yBal);\n        lscales[msg.sender] = _gscales.maxscale;\n        delete unclaimedYields[msg.sender];\n        gscales = _gscales;\n\n        if (block.timestamp >= maturity) {\n            // If matured, burn YT and add the principal portion to the accrued yield\n            accruedInTarget += _computeTargetBelongsToYT(_gscales, yBal);\n            _yt.burn(msg.sender, yBal);\n        }\n\n        // Convert the accrued yield in Target token to underlying token and transfer it to the `msg.sender`\n        // Target token may revert if zero-amount transfer is not allowed.\n        _target.safeTransfer(address(adapter), accruedInTarget);\n        (uint256 accrued, ) = adapter.prefundedRedeem(msg.sender);\n        emit Collect(msg.sender, accruedInTarget);\n        return accrued;\n    }\n\n    /* ================== VIEW METHODS =================== */\n\n    /// @inheritdoc ITranche\n    /// @dev This function is useful for off-chain services to get the accrued yield of a user.\n    /// @dev This function must not revert in any case.\n    function previewCollect(address account) external view returns (uint256) {\n        uint256 _lscale = lscales[account];\n        uint256 accruedInTarget = unclaimedYields[account];\n\n        // If the lscale is 0, it means the user have never hold any YT before\n        if (_lscale == 0) return 0;\n\n        GlobalScales memory _gscales = gscales;\n        uint256 cscale = _updateGlobalScalesCache(_gscales);\n\n        // At this point, the scales cache is up to date.\n        // Calculate the accrued yield in Target token for `account`\n\n        uint256 yBal = _yt.balanceOf(account);\n        accruedInTarget += _computeAccruedInterestInTarget(_gscales.maxscale, _lscale, yBal);\n\n        if (block.timestamp >= maturity) {\n            // If matured, add the principal portion to the accrued yield\n            accruedInTarget += _computeTargetBelongsToYT(_gscales, yBal);\n        }\n        // Convert the accrued yield to underlying token\n        return accruedInTarget.mulWadDown(cscale);\n    }\n\n    /// @inheritdoc IERC5095\n    function maxRedeem(address owner) external view override notEntered returns (uint256) {\n        // Before maturity, PT can't be redeemed. Return 0.\n        if (block.timestamp < maturity) return 0;\n        return balanceOf(owner);\n    }\n\n    /// @inheritdoc IERC5095\n    function maxWithdraw(address owner) external view override returns (uint256 maxUnderlyingAmount) {\n        if (block.timestamp < maturity) return 0;\n        return convertToUnderlying(balanceOf(owner));\n    }\n\n    /// @inheritdoc IERC5095\n    function previewRedeem(uint256 principalAmount) external view override returns (uint256 underlyingAmount) {\n        if (block.timestamp < maturity) return 0;\n        return convertToUnderlying(principalAmount);\n    }\n\n    /// @inheritdoc IERC5095\n    function previewWithdraw(uint256 underlyingAmount) external view override returns (uint256 principalAmount) {\n        if (block.timestamp < maturity) return 0;\n        return convertToPrincipal(underlyingAmount);\n    }\n\n    /// @inheritdoc IERC5095\n    /// @dev Before maturity, the amount of underlying returned is as if the PTs would be at maturity.\n    function convertToUnderlying(\n        uint256 principalAmount\n    ) public view override notEntered returns (uint256 underlyingAmount) {\n        GlobalScales memory _gscales = gscales; // Load gscales into memory\n        uint128 cscale = adapter.scale().toUint128();\n        if (_gscales.mscale == 0) {\n            // Simulate the settlement as if it is settled now\n            _gscales.mscale = cscale;\n            if (cscale > _gscales.maxscale) {\n                _gscales.maxscale = cscale;\n            }\n        }\n        uint256 shares = _computeSharesRedeemed(_gscales, principalAmount);\n\n        return shares.mulWadDown(cscale);\n    }\n\n    /// @inheritdoc IERC5095\n    /// @dev Before maturity, the amount of underlying returned is as if the PTs would be at maturity.\n    function convertToPrincipal(uint256 underlyingAmount) public view override notEntered returns (uint256) {\n        GlobalScales memory _gscales = gscales; // Load gscales into memory\n        uint128 cscale = adapter.scale().toUint128();\n        if (_gscales.mscale == 0) {\n            // Simulate the settlement as if it is settled now\n            _gscales.mscale = cscale;\n            if (cscale > _gscales.maxscale) {\n                _gscales.maxscale = cscale;\n            }\n        }\n        return _computePrincipalTokenRedeemed(_gscales, underlyingAmount.divWadDown(cscale));\n    }\n\n    /* ================== METADATA =================== */\n\n    /// @inheritdoc ITranche\n    /// @dev We return the address type instead of IERC20 to avoid additional dependencies for integrators.\n    function yieldToken() external view returns (address) {\n        return address(_yt);\n    }\n\n    /// @inheritdoc IERC5095\n    /// @dev We return the address type instead of IERC20 to avoid additional dependencies for integrators.\n    function underlying() external view returns (address) {\n        return address(_underlying);\n    }\n\n    /// @inheritdoc BaseToken\n    /// @dev We return the address type instead of IERC20 to avoid additional dependencies for integrators.\n    function target() external view override returns (address) {\n        return address(_target);\n    }\n\n    /// @inheritdoc ERC20\n    function name() public view override returns (string memory) {\n        string memory tokenName = SafeERC20Namer.tokenName(address(_target));\n        return string.concat(\"Napier Principal Token \", tokenName, \"@\", _toDateString(maturity));\n    }\n\n    /// @inheritdoc ERC20\n    function symbol() public view override returns (string memory) {\n        string memory tokenSymbol = SafeERC20Namer.tokenSymbol(address(_target));\n        return string.concat(\"eP-\", tokenSymbol, \"@\", _toDateString(maturity));\n    }\n\n    /// @inheritdoc ERC20\n    function decimals() public view override returns (uint8) {\n        return uDecimals;\n    }\n\n    /// @notice get the global scales\n    function getGlobalScales() external view notEntered returns (GlobalScales memory) {\n        return gscales;\n    }\n\n    /// @inheritdoc ITranche\n    /// @notice This function is useful for off-chain services to get the series information.\n    function getSeries() external view notEntered returns (Series memory) {\n        GlobalScales memory _gscales = gscales;\n        return\n            Series({\n                underlying: address(_underlying),\n                target: address(_target),\n                yt: address(_yt),\n                adapter: address(adapter),\n                mscale: _gscales.mscale,\n                maxscale: _gscales.maxscale,\n                tilt: tilt.toUint64(),\n                issuanceFee: issuanceFeeBps.toUint64(),\n                maturity: maturity.toUint64()\n            });\n    }\n\n    /* ================== PERMISSIONED METHODS =================== */\n\n    /// @notice Claim accumulated issuance fees. Redeem the fees in underlying.\n    /// @dev Only callable by management\n    /// @return Issuance fees in units of underlying token (e.g DAI)\n    function claimIssuanceFees() external onlyManagement returns (uint256) {\n        uint256 fees = issuanceFees - 1; // Ensure that the slot is not cleared, for gas savings\n        issuanceFees = 1;\n        _target.safeTransfer(address(adapter), fees);\n        (uint256 feesInUnderlying, ) = adapter.prefundedRedeem(feeRecipient);\n        return feesInUnderlying;\n    }\n\n    function setFeeRecipient(address _feeRecipient) external onlyManagement {\n        if (_feeRecipient == address(0)) revert ZeroAddress();\n        feeRecipient = _feeRecipient;\n    }\n\n    /// @notice Rescue a token from the contract. Usually used for tokens sent by a mistake.\n    /// @param token erc20 token\n    /// @param recipient recipient of the tokens\n    function recoverERC20(address token, address recipient) external onlyManagement {\n        if (token == address(_target)) revert ProtectedToken();\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransfer(recipient, balance);\n    }\n\n    /// @notice Pause issue, collect and updateUnclaimedYield\n    /// @dev only callable by management\n    function pause() external onlyManagement {\n        _pause();\n    }\n\n    /// @notice Unpause issue, collect and updateUnclaimedYield\n    /// @dev only callable by management\n    function unpause() external onlyManagement {\n        _unpause();\n    }\n\n    /* ================== INTERNAL METHODS =================== */\n    /* ================== UTIL METHODS =================== */\n\n    function _burnFrom(address owner, uint256 amount) internal {\n        if (owner != msg.sender) {\n            _spendAllowance(owner, msg.sender, amount);\n        }\n        _burn(owner, amount);\n    }\n\n    /// @notice Updates the global scales cache.\n    /// If the maturity has passed, updates the maturity scale `mscale` if it's not updated yet. (Settlement)\n    /// @return cscale The current scale of the adapter.\n    function _updateGlobalScalesCache(GlobalScales memory _cache) internal view returns (uint256) {\n        // Get the current scale of the adapter\n        uint256 cscale = adapter.scale();\n        if (_cache.mscale != 0) return cscale; // Skip if already settled\n\n        // If mscale == 0 and maturity has passed, settle the _cache.\n        if (block.timestamp >= maturity) {\n            _cache.mscale = cscale.toUint128();\n        }\n        // Update the _cache's maxscale\n        if (cscale > _cache.maxscale) {\n            _cache.maxscale = cscale.toUint128();\n        }\n        return cscale;\n    }\n\n    /// @notice Computes the amount of Target tokens to be redeemed for the given PT amount.\n    /// @dev This function is responsible for the logic of computing the amount of Target tokens to be redeemed.\n    /// The logic is as follows: 1) sunny day (ideal case), 2) not sunny day.\n    /// @param _gscales Local cache of global scales.\n    /// @param _principalAmount PT amount to redeem in units of underlying tokens.\n    function _computeSharesRedeemed(\n        GlobalScales memory _gscales,\n        uint256 _principalAmount\n    ) internal view returns (uint256) {\n        // Hackmd: F1\n        // If it's a sunny day, PT holders lose `tilt` % of the principal amount.\n        if ((_gscales.mscale * MAX_BPS) / _gscales.maxscale >= oneSubTilt) {\n            // Formula: shares = principalAmount * (1 - tilt) / mscale\n            return ((_principalAmount * oneSubTilt) / MAX_BPS).divWadDown(_gscales.mscale);\n        } else {\n            // If it's not a sunny day,\n            // Formula: shares = principalAmount / maxscale\n            return _principalAmount.divWadDown(_gscales.maxscale);\n        }\n    }\n\n    /// @notice Computes the amount of PT to be redeemed for the given shares amount.\n    /// @param _gscales Local cache of global scales.\n    /// @param _shares Amount of Target tokens equivalent to the amount of PT to be redeemed (in units of Target tokens).\n    function _computePrincipalTokenRedeemed(\n        GlobalScales memory _gscales,\n        uint256 _shares\n    ) internal view returns (uint256) {\n        // Hackmd: F1\n        // If it's a sunny day, PT holders lose `tilt` % of the principal amount.\n        if ((_gscales.mscale * MAX_BPS) / _gscales.maxscale >= oneSubTilt) {\n            // Formula: principalAmount = (shares * mscale * MAX_BPS) / oneSubTilt\n            return (_shares.mulWadDown(_gscales.mscale) * MAX_BPS) / oneSubTilt;\n        }\n        // If it's not a sunny day,\n        // Formula: principalAmount = shares * maxscale\n        return _shares.mulWadDown(_gscales.maxscale);\n    }\n\n    /// @notice Computes the amount of Target token that belongs to YT.\n    /// @param _gscales Local cache of global scales.\n    /// @param _yBal The balance of YT for the user.\n    function _computeTargetBelongsToYT(GlobalScales memory _gscales, uint256 _yBal) internal view returns (uint256) {\n        // Hackmd: F3\n        // If it's a sunny day, PT holders lose `tilt` % of the principal amount and YT holders get the amount.\n        if ((_gscales.mscale * MAX_BPS) / _gscales.maxscale >= oneSubTilt) {\n            // Formula: targetBelongsToYT = yBal / maxscale - (1 - tilt) * yBal / mscale\n            return _yBal.divWadDown(_gscales.maxscale) - ((_yBal * oneSubTilt) / MAX_BPS).divWadDown(_gscales.mscale);\n        }\n        return 0;\n    }\n\n    /// @notice Computes the amount of accrued interest in the Target.\n    /// e.g. if the Target scale increases by 5% since the last time the account collected and the account has 100 YT,\n    /// then the account will receive 100 * 5% = 5 Target as interest, which is equivalent"
    }
  ]
}