{
  "Title": "[L10] Unnecessary handling of single byte returned data",
  "Content": "In the `Lib_SafeExecutionManagerWrapper` library, the internal `_safeExecutionManagerInteraction` function handles [a case](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/wrappers/Lib_SafeExecutionManagerWrapper.sol#L354-L357) in which the returned data from a call to the `OVM_ExecutionManager` is a single byte. This code segment appears to be outdated, left over from an earlier version of the system, and it is no longer used.\n\n\nAdditionally, the `ovmEXTCODECOPY` function of the `OVM_ExecutionManager` contract introduces an [artificial manipulation](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol#L747) to avoid users inadvertently triggering this special case.\n\n\nConsider removing both code segments to favor simplicity and avoid confusion.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/optimistic-ethereum/libraries/wrappers/Lib_SafeExecutionManagerWrapper.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\n\n/* Library Imports */\nimport { Lib_ErrorUtils } from \"../utils/Lib_ErrorUtils.sol\";\n\n/**\n * @title Lib_SafeExecutionManagerWrapper\n * @dev The Safe Execution Manager Wrapper provides functions which facilitate writing OVM safe\n * code using the standard solidity compiler, by routing all its operations through the Execution\n * Manager.\n *\n * Compiler used: solc\n * Runtime target: OVM\n */\nlibrary Lib_SafeExecutionManagerWrapper {\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Performs a safe ovmCALL.\n     * @param _gasLimit Gas limit for the call.\n     * @param _target Address to call.\n     * @param _calldata Data to send to the call.\n     * @return _success Whether or not the call reverted.\n     * @return _returndata Data returned by the call.\n     */\n    function safeCALL(\n        uint256 _gasLimit,\n        address _target,\n        bytes memory _calldata\n    )\n        internal\n        returns (\n            bool _success,\n            bytes memory _returndata\n        )\n    {\n        bytes memory returndata = _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmCALL(uint256,address,bytes)\",\n                _gasLimit,\n                _target,\n                _calldata\n            )\n        );\n\n        return abi.decode(returndata, (bool, bytes));\n    }\n\n    /**\n     * Performs a safe ovmDELEGATECALL.\n     * @param _gasLimit Gas limit for the call.\n     * @param _target Address to call.\n     * @param _calldata Data to send to the call.\n     * @return _success Whether or not the call reverted.\n     * @return _returndata Data returned by the call.\n     */\n    function safeDELEGATECALL(\n        uint256 _gasLimit,\n        address _target,\n        bytes memory _calldata\n    )\n        internal\n        returns (\n            bool _success,\n            bytes memory _returndata\n        )\n    {\n        bytes memory returndata = _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmDELEGATECALL(uint256,address,bytes)\",\n                _gasLimit,\n                _target,\n                _calldata\n            )\n        );\n\n        return abi.decode(returndata, (bool, bytes));\n    }\n\n    /**\n     * Performs a safe ovmCREATE call.\n     * @param _gasLimit Gas limit for the creation.\n     * @param _bytecode Code for the new contract.\n     * @return _contract Address of the created contract.\n     */\n    function safeCREATE(\n        uint256 _gasLimit,\n        bytes memory _bytecode\n    )\n        internal\n        returns (\n            address,\n            bytes memory\n        )\n    {\n        bytes memory returndata = _safeExecutionManagerInteraction(\n            _gasLimit,\n            abi.encodeWithSignature(\n                \"ovmCREATE(bytes)\",\n                _bytecode\n            )\n        );\n\n        return abi.decode(returndata, (address, bytes));\n    }\n\n    /**\n     * Performs a safe ovmEXTCODESIZE call.\n     * @param _contract Address of the contract to query the size of.\n     * @return _EXTCODESIZE Size of the requested contract in bytes.\n     */\n    function safeEXTCODESIZE(\n        address _contract\n    )\n        internal\n        returns (\n            uint256 _EXTCODESIZE\n        )\n    {\n        bytes memory returndata = _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmEXTCODESIZE(address)\",\n                _contract\n            )\n        );\n\n        return abi.decode(returndata, (uint256));\n    }\n\n    /**\n     * Performs a safe ovmCHAINID call.\n     * @return _CHAINID Result of calling ovmCHAINID.\n     */\n    function safeCHAINID()\n        internal\n        returns (\n            uint256 _CHAINID\n        )\n    {\n        bytes memory returndata = _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmCHAINID()\"\n            )\n        );\n\n        return abi.decode(returndata, (uint256));\n    }\n\n    /**\n     * Performs a safe ovmCALLER call.\n     * @return _CALLER Result of calling ovmCALLER.\n     */\n    function safeCALLER()\n        internal\n        returns (\n            address _CALLER\n        )\n    {\n        bytes memory returndata = _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmCALLER()\"\n            )\n        );\n\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * Performs a safe ovmADDRESS call.\n     * @return _ADDRESS Result of calling ovmADDRESS.\n     */\n    function safeADDRESS()\n        internal\n        returns (\n            address _ADDRESS\n        )\n    {\n        bytes memory returndata = _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmADDRESS()\"\n            )\n        );\n\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * Performs a safe ovmGETNONCE call.\n     * @return _nonce Result of calling ovmGETNONCE.\n     */\n    function safeGETNONCE()\n        internal\n        returns (\n            uint64 _nonce\n        )\n    {\n        bytes memory returndata = _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmGETNONCE()\"\n            )\n        );\n\n        return abi.decode(returndata, (uint64));\n    }\n\n    /**\n     * Performs a safe ovmINCREMENTNONCE call.\n     */\n    function safeINCREMENTNONCE()\n        internal\n    {\n        _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmINCREMENTNONCE()\"\n            )\n        );\n    }\n\n    /**\n     * Performs a safe ovmCREATEEOA call.\n     * @param _messageHash Message hash which was signed by EOA\n     * @param _v v value of signature (0 or 1)\n     * @param _r r value of signature\n     * @param _s s value of signature\n     */\n    function safeCREATEEOA(\n        bytes32 _messageHash,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n        internal\n    {\n        _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmCREATEEOA(bytes32,uint8,bytes32,bytes32)\",\n                _messageHash,\n                _v,\n                _r,\n                _s\n            )\n        );\n    }\n\n    /**\n     * Performs a safe REVERT.\n     * @param _reason String revert reason to pass along with the REVERT.\n     */\n    function safeREVERT(\n        string memory _reason\n    )\n        internal\n    {\n        _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmREVERT(bytes)\",\n                Lib_ErrorUtils.encodeRevertString(\n                    _reason\n                )\n            )\n        );\n    }\n\n    /**\n     * Performs a safe \"require\".\n     * @param _condition Boolean condition that must be true or will revert.\n     * @param _reason String revert reason to pass along with the REVERT.\n     */\n    function safeREQUIRE(\n        bool _condition,\n        string memory _reason\n    )\n        internal\n    {\n        if (!_condition) {\n            safeREVERT(\n                _reason\n            );\n        }\n    }\n\n    /**\n     * Performs a safe ovmSLOAD call.\n     */\n    function safeSLOAD(\n        bytes32 _key\n    )\n        internal\n        returns (\n            bytes32\n        )\n    {\n        bytes memory returndata = _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmSLOAD(bytes32)\",\n                _key\n            )\n        );\n\n        return abi.decode(returndata, (bytes32));\n    }\n\n    /**\n     * Performs a safe ovmSSTORE call.\n     */\n    function safeSSTORE(\n        bytes32 _key,\n        bytes32 _value\n    )\n        internal\n    {\n        _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmSSTORE(bytes32,bytes32)\",\n                _key,\n                _value\n            )\n        );\n    }\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * Performs an ovm interaction and the necessary safety checks.\n     * @param _gasLimit Gas limit for the interaction.\n     * @param _calldata Data to send to the OVM_ExecutionManager (encoded with sighash).\n     * @return _returndata Data sent back by the OVM_ExecutionManager.\n     */\n    function _safeExecutionManagerInteraction(\n        uint256 _gasLimit,\n        bytes memory _calldata\n    )\n        private\n        returns (\n            bytes memory _returndata\n        )\n    {\n        address ovmExecutionManager = msg.sender;\n        (\n            bool success,\n            bytes memory returndata\n        ) = ovmExecutionManager.call{gas: _gasLimit}(_calldata);\n\n        if (success == false) {\n            assembly {\n                revert(add(returndata, 0x20), mload(returndata))\n            }\n        } else if (returndata.length == 1) {\n            assembly {\n                return(0, 1)\n            }\n        } else {\n            return returndata;\n        }\n    }\n\n    function _safeExecutionManagerInteraction(\n        bytes memory _calldata\n    )\n        private\n        returns (\n            bytes memory _returndata\n        )\n    {\n        return _safeExecutionManagerInteraction(\n            gasleft(),\n            _calldata\n        );\n    }\n}"
    },
    {
      "filename": "contracts/optimistic-ethereum/OVM/execution/OVM_ExecutionManager.sol",
      "content": "// SPDX-License-Identifier: MIT\n// @unsupported: ovm\npragma solidity >0.5.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\n/* Library Imports */\nimport { Lib_OVMCodec } from \"../../libraries/codec/Lib_OVMCodec.sol\";\nimport { Lib_AddressResolver } from \"../../libraries/resolver/Lib_AddressResolver.sol\";\nimport { Lib_EthUtils } from \"../../libraries/utils/Lib_EthUtils.sol\";\nimport { Lib_ErrorUtils } from \"../../libraries/utils/Lib_ErrorUtils.sol\";\n\n/* Interface Imports */\nimport { iOVM_ExecutionManager } from \"../../iOVM/execution/iOVM_ExecutionManager.sol\";\nimport { iOVM_StateManager } from \"../../iOVM/execution/iOVM_StateManager.sol\";\nimport { iOVM_SafetyChecker } from \"../../iOVM/execution/iOVM_SafetyChecker.sol\";\n\n/* Contract Imports */\nimport { OVM_ECDSAContractAccount } from \"../accounts/OVM_ECDSAContractAccount.sol\";\nimport { OVM_ProxyEOA } from \"../accounts/OVM_ProxyEOA.sol\";\nimport { OVM_DeployerWhitelist } from \"../predeploys/OVM_DeployerWhitelist.sol\";\n\n/**\n * @title OVM_ExecutionManager\n * @dev The Execution Manager (EM) is the core of our OVM implementation, and provides a sandboxed\n * environment allowing us to execute OVM transactions deterministically on either Layer 1 or\n * Layer 2.\n * The EM's run() function is the first function called during the execution of any\n * transaction on L2.\n * For each context-dependent EVM operation the EM has a function which implements a corresponding\n * OVM operation, which will read state from the State Manager contract.\n * The EM relies on the Safety Checker to verify that code deployed to Layer 2 does not contain any\n * context-dependent operations.\n *\n * Compiler used: solc\n * Runtime target: EVM\n */\ncontract OVM_ExecutionManager is iOVM_ExecutionManager, Lib_AddressResolver {\n\n    /********************************\n     * External Contract References *\n     ********************************/\n\n    iOVM_SafetyChecker internal ovmSafetyChecker;\n    iOVM_StateManager internal ovmStateManager;\n\n\n    /*******************************\n     * Execution Context Variables *\n     *******************************/\n\n    GasMeterConfig internal gasMeterConfig;\n    GlobalContext internal globalContext;\n    TransactionContext internal transactionContext;\n    MessageContext internal messageContext;\n    TransactionRecord internal transactionRecord;\n    MessageRecord internal messageRecord;\n\n\n    /**************************\n     * Gas Metering Constants *\n     **************************/\n\n    address constant GAS_METADATA_ADDRESS = 0x06a506A506a506A506a506a506A506A506A506A5;\n    uint256 constant NUISANCE_GAS_SLOAD = 20000;\n    uint256 constant NUISANCE_GAS_SSTORE = 20000;\n    uint256 constant MIN_NUISANCE_GAS_PER_CONTRACT = 30000;\n    uint256 constant NUISANCE_GAS_PER_CONTRACT_BYTE = 100;\n    uint256 constant MIN_GAS_FOR_INVALID_STATE_ACCESS = 30000;\n\n    /**************************\n     * Default Context Values *\n     **************************/\n\n    uint256 constant DEFAULT_UINT256 = 0xdefa017defa017defa017defa017defa017defa017defa017defa017defa017d;\n    address constant DEFAULT_ADDRESS = 0xdEfa017defA017DeFA017DEfa017DeFA017DeFa0;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _libAddressManager Address of the Address Manager.\n     */\n    constructor(\n        address _libAddressManager,\n        GasMeterConfig memory _gasMeterConfig,\n        GlobalContext memory _globalContext\n    )\n        Lib_AddressResolver(_libAddressManager)\n    {\n        ovmSafetyChecker = iOVM_SafetyChecker(resolve(\"OVM_SafetyChecker\"));\n        gasMeterConfig = _gasMeterConfig;\n        globalContext = _globalContext;\n        _resetContext();\n    }\n\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    /**\n     * Applies dynamically-sized refund to a transaction to account for the difference in execution\n     * between L1 and L2, so that the overall cost of the ovmOPCODE is fixed.\n     * @param _cost Desired gas cost for the function after the refund.\n     */\n    modifier netGasCost(\n        uint256 _cost\n    ) {\n        uint256 gasProvided = gasleft();\n        _;\n        uint256 gasUsed = gasProvided - gasleft();\n\n        // We want to refund everything *except* the specified cost.\n        if (_cost < gasUsed) {\n            transactionRecord.ovmGasRefund += gasUsed - _cost;\n        }\n    }\n\n    /**\n     * Applies a fixed-size gas refund to a transaction to account for the difference in execution\n     * between L1 and L2, so that the overall cost of an ovmOPCODE can be lowered.\n     * @param _discount Amount of gas cost to refund for the ovmOPCODE.\n     */\n    modifier fixedGasDiscount(\n        uint256 _discount\n    ) {\n        uint256 gasProvided = gasleft();\n        _;\n        uint256 gasUsed = gasProvided - gasleft();\n\n        // We want to refund the specified _discount, unless this risks underflow.\n        if (_discount < gasUsed) {\n            transactionRecord.ovmGasRefund += _discount;\n        } else {\n            // refund all we can without risking underflow.\n            transactionRecord.ovmGasRefund += gasUsed;\n        }\n    }\n\n    /**\n     * Makes sure we're not inside a static context.\n     */\n    modifier notStatic() {\n        if (messageContext.isStatic == true) {\n            _revertWithFlag(RevertFlag.STATIC_VIOLATION);\n        }\n        _;\n    }\n\n\n    /************************************\n     * Transaction Execution Entrypoint *\n     ************************************/\n\n    /**\n     * Starts the execution of a transaction via the OVM_ExecutionManager.\n     * @param _transaction Transaction data to be executed.\n     * @param _ovmStateManager iOVM_StateManager implementation providing account state.\n     */\n    function run(\n        Lib_OVMCodec.Transaction memory _transaction,\n        address _ovmStateManager\n    )\n        override\n        public\n    {\n        // Make sure that run() is not re-enterable.  This condition should awlways be satisfied\n        // Once run has been called once, due to the behvaior of _isValidInput().\n        if (transactionContext.ovmNUMBER != DEFAULT_UINT256) {\n            return;\n        }\n\n        // Store our OVM_StateManager instance (significantly easier than attempting to pass the\n        // address around in calldata).\n        ovmStateManager = iOVM_StateManager(_ovmStateManager);\n\n        // Make sure this function can't be called by anyone except the owner of the\n        // OVM_StateManager (expected to be an OVM_StateTransitioner). We can revert here because\n        // this would make the `run` itself invalid.\n        require(\n            // This method may return false during fraud proofs, but always returns true in L2 nodes' State Manager precompile.\n            ovmStateManager.isAuthenticated(msg.sender),\n            \"Only authenticated addresses in ovmStateManager can call this function\"\n        );\n\n        // Initialize the execution context, must be initialized before we perform any gas metering\n        // or we'll throw a nuisance gas error.\n        _initContext(_transaction);\n\n        // TEMPORARY: Gas metering is disabled for minnet.\n        // // Check whether we need to start a new epoch, do so if necessary.\n        // _checkNeedsNewEpoch(_transaction.timestamp);\n\n        // Make sure the transaction's gas limit is valid. We don't revert here because we reserve\n        // reverts for INVALID_STATE_ACCESS.\n        if (_isValidInput(_transaction) == false) {\n            _resetContext();\n            return;\n        }\n\n        // TEMPORARY: Gas metering is disabled for minnet.\n        // // Check gas right before the call to get total gas consumed by OVM transaction.\n        // uint256 gasProvided = gasleft();\n\n        // Run the transaction, make sure to meter the gas usage.\n        ovmCALL(\n            _transaction.gasLimit - gasMeterConfig.minTransactionGasLimit,\n            _transaction.entrypoint,\n            _transaction.data\n        );\n\n        // TEMPORARY: Gas metering is disabled for minnet.\n        // // Update the cumulative gas based on the amount of gas used.\n        // uint256 gasUsed = gasProvided - gasleft();\n        // _updateCumulativeGas(gasUsed, _transaction.l1QueueOrigin);\n\n        // Wipe the execution context.\n        _resetContext();\n    }\n\n\n    /******************************\n     * Opcodes: Execution Context *\n     ******************************/\n\n    /**\n     * @notice Overrides CALLER.\n     * @return _CALLER Address of the CALLER within the current message context.\n     */\n    function ovmCALLER()\n        override\n        public\n        view\n        returns (\n            address _CALLER\n        )\n    {\n        address caller = messageContext.ovmCALLER;\n        if (caller == address(0)) {\n            _revertWithFlag(RevertFlag.UNINITIALIZED_ACCESS);\n        } else {\n            return caller;\n        }\n    }\n\n    /**\n     * @notice Overrides ADDRESS.\n     * @return _ADDRESS Active ADDRESS within the current message context.\n     */\n    function ovmADDRESS()\n        override\n        public\n        view\n        returns (\n            address _ADDRESS\n        )\n    {\n        return messageContext.ovmADDRESS;\n    }\n\n    /**\n     * @notice Overrides TIMESTAMP.\n     * @return _TIMESTAMP Value of the TIMESTAMP within the transaction context.\n     */\n    function ovmTIMESTAMP()\n        override\n        public\n        view\n        returns (\n            uint256 _TIMESTAMP\n        )\n    {\n        return transactionContext.ovmTIMESTAMP;\n    }\n\n    /**\n     * @notice Overrides NUMBER.\n     * @return _NUMBER Value of the NUMBER within the transaction context.\n     */\n    function ovmNUMBER()\n        override\n        public\n        view\n        returns (\n            uint256 _NUMBER\n        )\n    {\n        return transactionContext.ovmNUMBER;\n    }\n\n    /**\n     * @notice Overrides GASLIMIT.\n     * @return _GASLIMIT Value of the block's GASLIMIT within the transaction context.\n     */\n    function ovmGASLIMIT()\n        override\n        public\n        view\n        returns (\n            uint256 _GASLIMIT\n        )\n    {\n        return transactionContext.ovmGASLIMIT;\n    }\n\n    /**\n     * @notice Overrides CHAINID.\n     * @return _CHAINID Value of the chain's CHAINID within the global context.\n     */\n    function ovmCHAINID()\n        override\n        public\n        view\n        returns (\n            uint256 _CHAINID\n        )\n    {\n        return globalContext.ovmCHAINID;\n    }\n\n    /*********************************\n     * Opcodes: L2 Execution Context *\n     *********************************/\n\n    /**\n     * @notice Specifies from which L1 rollup queue this transaction originated from.\n     * @return _queueOrigin Address of the ovmL1QUEUEORIGIN within the current message context.\n     */\n    function ovmL1QUEUEORIGIN()\n        override\n        public\n        view\n        returns (\n            Lib_OVMCodec.QueueOrigin _queueOrigin\n        )\n    {\n        return transactionContext.ovmL1QUEUEORIGIN;\n    }\n\n    /**\n     * @notice Specifies which L1 account, if any, sent this transaction by calling enqueue().\n     * @return _l1TxOrigin Address of the account which sent the tx into L2 from L1.\n     */\n    function ovmL1TXORIGIN()\n        override\n        public\n        view\n        returns (\n            address _l1TxOrigin\n        )\n    {\n        return transactionContext.ovmL1TXORIGIN;\n    }\n\n    /********************\n     * Opcodes: Halting *\n     ********************/\n\n    /**\n     * @notice Overrides REVERT.\n     * @param _data Bytes data to pass along with the REVERT.\n     */\n    function ovmREVERT(\n        bytes memory _data\n    )\n        override\n        public\n        view\n    {\n        _revertWithFlag(RevertFlag.INTENTIONAL_REVERT, _data);\n    }\n\n\n    /******************************\n     * Opcodes: Contract Creation *\n     ******************************/\n\n    /**\n     * @notice Overrides CREATE.\n     * @param _bytecode Code to be used to CREATE a new contract.\n     * @return Address of the created contract.\n     * @return Revert data, if and only if the creation threw an exception.\n     */\n    function ovmCREATE(\n        bytes memory _bytecode\n    )\n        override\n        public\n        notStatic\n        fixedGasDiscount(40000)\n        returns (\n            address,\n            bytes memory\n        )\n    {\n        // Creator is always the current ADDRESS.\n        address creator = ovmADDRESS();\n\n        // Check that the deployer is whitelisted, or\n        // that arbitrary contract deployment has been enabled.\n        _checkDeployerAllowed(creator);\n\n        // Generate the correct CREATE address.\n        address contractAddress = Lib_EthUtils.getAddressForCREATE(\n            creator,\n            _getAccountNonce(creator)\n        );\n\n        return _createContract(\n            contractAddress,\n            _bytecode\n        );\n    }\n\n    /**\n     * @notice Overrides CREATE2.\n     * @param _bytecode Code to be used to CREATE2 a new contract.\n     * @param _salt Value used to determine the contract's address.\n     * @return Address of the created contract.\n     * @return Revert data, if and only if the creation threw an exception.\n     */\n    function ovmCREATE2(\n        bytes memory _bytecode,\n        bytes32 _salt\n    )\n        override\n        public\n        notStatic\n        fixedGasDiscount(40000)\n        returns (\n            address,\n            bytes memory\n        )\n    {\n        // Creator is always the current ADDRESS.\n        address creator = ovmADDRESS();\n\n        // Check that the deployer is whitelisted, or\n        // that arbitrary contract deployment has been enabled.\n        _checkDeployerAllowed(creator);\n\n        // Generate the correct CREATE2 address.\n        address contractAddress = Lib_EthUtils.getAddressForCREATE2(\n            creator,\n            _bytecode,\n            _salt\n        );\n\n        return _createContract(\n            contractAddress,\n            _bytecode\n        );\n    }\n\n\n    /*******************************\n     * Account Abstraction Opcodes *\n     ******************************/\n\n    /**\n     * Retrieves the nonce of the current ovmADDRESS.\n     * @return _nonce Nonce of the current contract.\n     */\n    function ovmGETNONCE()\n        override\n        public\n        returns (\n            uint64 _nonce\n        )\n    {\n        return _getAccountNonce(ovmADDRESS());\n    }\n\n    /**\n     * Bumps the nonce of the current ovmADDRESS by one.\n     */\n    function ovmINCREMENTNONCE()\n        override\n        public\n        notStatic\n    {\n        address account = ovmADDRESS();\n        uint64 nonce = _getAccountNonce(account);\n\n        // Prevent overflow.\n        if (nonce + 1 > nonce) {\n            _setAccountNonce(account, nonce + 1);\n        }\n    }\n\n    /**\n     * Creates a new EOA contract account, for account abstraction.\n     * @dev Essentially functions like ovmCREATE or ovmCREATE2, but we can bypass a lot of checks\n     *      because the contract we're creating is trusted (no need to do safety checking or to\n     *      handle unexpected reverts). Doesn't need to return an address because the address is\n     *      assumed to be the user's actual address.\n     * @param _messageHash Hash of a message signed by some user, for verification.\n     * @param _v Signature `v` parameter.\n     * @param _r Signature `r` parameter.\n     * @param _s Signature `s` parameter.\n     */\n    function ovmCREATEEOA(\n        bytes32 _messageHash,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n        override\n        public\n        notStatic\n    {\n        // Recover the EOA address from the message hash and signature parameters. Since we do the\n        // hashing in advance, we don't have handle different message hashing schemes. Even if this\n        // function were to return the wrong address (rather than explicitly returning the zero\n        // address), the rest of the transaction would simply fail (since there's no EOA account to\n        // actually execute the transaction).\n        address eoa = ecrecover(\n            _messageHash,\n            _v + 27,\n            _r,\n            _s\n        );\n\n        // Invalid signature is a case we proactively handle with a revert. We could alternatively\n        // have this function return a `success` boolean, but this is just easier.\n        if (eoa == address(0)) {\n            ovmREVERT(bytes(\"Signature provided for EOA contract creation is invalid.\"));\n        }\n\n        // If the user already has an EOA account, then there's no need to perform this operation.\n        if (_hasEmptyAccount(eoa) == false) {\n            return;\n        }\n\n        // We always need to initialize the contract with the default account values.\n        _initPendingAccount(eoa);\n\n        // Temporarily set the current address so it's easier to access on L2.\n        address prevADDRESS = messageContext.ovmADDRESS;\n        messageContext.ovmADDRESS = eoa;\n\n        // Now actually create the account and get its bytecode. We're not worried about reverts\n        // (other than out of gas, which we can't capture anyway) because this contract is trusted.\n        OVM_ProxyEOA proxyEOA = new OVM_ProxyEOA(0x4200000000000000000000000000000000000003);\n\n        // Reset the address now that we're done deploying.\n        messageContext.ovmADDRESS = prevADDRESS;\n\n        // Commit the account with its final values.\n        _commitPendingAccount(\n            eoa,\n            address(proxyEOA),\n            keccak256(Lib_EthUtils.getCode(address(proxyEOA)))\n        );\n\n        _setAccountNonce(eoa, 0);\n    }\n\n\n    /*********************************\n     * Opcodes: Contract Interaction *\n     *********************************/\n\n    /**\n     * @notice Overrides CALL.\n     * @param _gasLimit Amount of gas to be passed into this call.\n     * @param _address Address of the contract to call.\n     * @param _calldata Data to send along with the call.\n     * @return _success Whether or not the call returned (rather than reverted).\n     * @return _returndata Data returned by the call.\n     */\n    function ovmCALL(\n        uint256 _gasLimit,\n        address _address,\n        bytes memory _calldata\n    )\n        override\n        public\n        fixedGasDiscount(100000)\n        returns (\n            bool _success,\n            bytes memory _returndata\n        )\n    {\n        // CALL updates the CALLER and ADDRESS.\n        MessageContext memory nextMessageContext = messageContext;\n        nextMessageContext.ovmCALLER = nextMessageContext.ovmADDRESS;\n        nextMessageContext.ovmADDRESS = _address;\n\n        return _callContract(\n            nextMessageContext,\n            _gasLimit,\n            _address,\n            _calldata\n        );\n    }\n\n    /**\n     * @notice Overrides STATICCALL.\n     * @param _gasLimit Amount of gas to be passed into this call.\n     * @param _address Address of the contract to call.\n     * @param _calldata Data to send along with the call.\n     * @return _success Whether or not the call returned (rather than reverted).\n     * @return _returndata Data returned by the call.\n     */\n    function ovmSTATICCALL(\n        uint256 _gasLimit,\n        address _address,\n        bytes memory _calldata\n    )\n        override\n        public\n        fixedGasDiscount(80000)\n        returns (\n            bool _success,\n            bytes memory _returndata\n        )\n    {\n        // STATICCALL updates the CALLER, updates the ADDRESS, and runs in a static context.\n        MessageContext memory nextMessageContext = messageContext;\n        nextMessageContext.ovmCALLER = nextMessageContext.ovmADDRESS;\n        nextMessageContext.ovmADDRESS = _address;\n        nextMessageContext.isStatic = true;\n\n        return _callContract(\n            nextMessageContext,\n            _gasLimit,\n            _address,\n            _calldata\n        );\n    }\n\n    /**\n     * @notice Overrides DELEGATECALL.\n     * @param _gasLimit Amount of gas to be passed into this call.\n     * @param _address Address of the contract to call.\n     * @param _calldata Data to send along with the call.\n     * @return _success Whether or not the call returned (rather than reverted).\n     * @return _returndata Data returned by the call.\n     */\n    function ovmDELEGATECALL(\n        uint256 _gasLimit,\n        address _address,\n        bytes memory _calldata\n    )\n        override\n        public\n        fixedGasDiscount(40000)\n        returns (\n            bool _success,\n            bytes memory _returndata\n        )\n    {\n        // DELEGATECALL does not change anything about the message context.\n        MessageContext memory nextMessageContext = messageContext;\n\n        return _callContract(\n            nextMessageContext,\n            _gasLimit,\n            _address,\n            _calldata\n        );\n    }\n\n\n    /************************************\n     * Opcodes: Contract Storage Access *\n     ************************************/\n\n    /**\n     * @notice Overrides SLOAD.\n     * @param _key 32 byte key of the storage slot to load.\n     * @return _value 32 byte value of the requested storage slot.\n     */\n    function ovmSLOAD(\n        bytes32 _key\n    )\n        override\n        public\n        netGasCost(40000)\n        returns (\n            bytes32 _value\n        )\n    {\n        // We always SLOAD from the storage of ADDRESS.\n        address contractAddress = ovmADDRESS();\n\n        return _getContractStorage(\n            contractAddress,\n            _key\n        );\n    }\n\n    /**\n     * @notice Overrides SSTORE.\n     * @param _key 32 byte key of the storage slot to set.\n     * @param _value 32 byte value for the storage slot.\n     */\n    function ovmSSTORE(\n        bytes32 _key,\n        bytes32 _value\n    )\n        override\n        public\n        notStatic\n        netGasCost(60000)\n    {\n        // We always SSTORE to the storage of ADDRESS.\n        address contractAddress = ovmADDRESS();\n\n        _putContractStorage(\n            contractAddress,\n            _key,\n            _value\n        );\n    }\n\n\n    /*********************************\n     * Opcodes: Contract Code Access *\n     *********************************/\n\n    /**\n     * @notice Overrides EXTCODECOPY.\n     * @param _contract Address of the contract to copy code from.\n     * @param _offset Offset in bytes from the start of contract code to copy beyond.\n     * @param _length Total number of bytes to copy from the contract's code.\n     * @return _code Bytes of code copied from the requested contract.\n     */\n    function ovmEXTCODECOPY(\n        address _contract,\n        uint256 _offset,\n        uint256 _length\n    )\n        override\n        public\n        returns (\n            bytes memory _code\n        )\n    {\n        // `ovmEXTCODECOPY` is the only overridden opcode capable of producing exactly one byte of\n        // return data. By blocking reads of one byte, we're able to use the condition that an\n        // OVM_ExecutionManager function return value having a length of exactly one byte indicates\n        // an error without an explicit revert. If users were able to read a single byte, they\n        // could forcibly trigger behavior that should only be available to this contract.\n        uint256 length = _length == 1 ? 2 : _length;\n\n        return Lib_EthUtils.getCode(\n            _getAccountEthAddress(_contract),\n            _offset,\n            length\n        );\n    }\n\n    /**\n     * @notice"
    }
  ]
}