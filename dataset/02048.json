{
  "Title": "M-2: ControllerPeggedAssetV2: `triggerEndEpoch` function can be called even if epoch is null epoch leading to loss of funds",
  "Content": "# Issue M-2: ControllerPeggedAssetV2: `triggerEndEpoch` function can be called even if epoch is null epoch leading to loss of funds \n\nSource: https://github.com/sherlock-audit/2023-03-Y2K-judging/issues/108 \n\n## Found by \n0xRobocop, 0xnirlin, 0xvj, KingNFT, berndartmueller, bin2chen, charlesjhongc, climber2002, evan, holyhansss, kenzo, libratus, ltyu, minhtrng, roguereddwarf, warRoom, yixxas\n\n## Summary\nAn epoch can be resolved in three ways which correspond to the three functions available in the Controller:\n`triggerDepeg`, `triggerEndEpoch`, `triggerNullEpoch`.\n\nThe issue is that `triggerEndEpoch` can be called even though `triggerNullEpoch` should be called.\n\"Null epoch\" means that any of the two vaults does not have funds deposited. In this case the epoch should be resolved with `triggerNullEpoch` such that funds are not transferred from the premium vault to the collateral vault.\n\nSo in `triggerEndEpoch` is should be checked whether the conditions for a null epoch apply. If that's the case, the `triggerEndEpoch` function should revert.\n\n## Vulnerability Detail\nThe assumption the code makes is that if the null epoch applies, `triggerNullEpoch` will be called before the end timestamp of the epoch which is when `triggerEndEpoch` can be called.\n\nThis is not necessarily true.\n\n`triggerNullEpoch` might not be called in time (e.g. because the epoch duration is very short or simply nobody calls it) and then the `triggerEndEpoch` function can be called which sends the funds from the premium vault into the collateral vault:\nhttps://github.com/sherlock-audit/2023-03-Y2K/blob/main/Earthquake/src/v2/Controllers/ControllerPeggedAssetV2.sol#L172-L192\n\nIf the premium vault is the vault which has funds and the collateral vault does not, then the funds sent to the collateral vault are lost.\n\n## Impact\nLoss of funds for users that have deposited into the premium vault.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-03-Y2K/blob/main/Earthquake/src/v2/Controllers/ControllerPeggedAssetV2.sol#L144-L202\n\n## Tool used\nManual Review\n\n## Recommendation\n`triggerEndEpoch` should only be callable when the conditions for a null epoch don't apply:\n```diff\ndiff --git a/Earthquake/src/v2/Controllers/ControllerPeggedAssetV2.sol b/Earthquake/src/v2/Controllers/ControllerPeggedAssetV2.sol\nindex 0587c86..7b25cf3 100644\n--- a/Earthquake/src/v2/Controllers/ControllerPeggedAssetV2.sol\n+++ b/Earthquake/src/v2/Controllers/ControllerPeggedAssetV2.sol\n@@ -155,6 +155,13 @@ contract ControllerPeggedAssetV2 {\n             collateralVault.epochExists(_epochId) == false\n         ) revert EpochNotExist();\n \n+        if (\n+            premiumVault.totalAssets(_epochId) == 0 ||\n+            collateralVault.totalAssets(_epochId) == 0\n+        ) {\n+            revert VaultZeroTVL();\n+        }\n+\n         (, uint40 epochEnd, ) = premiumVault.getEpochConfig(_epochId);\n \n         if (block.timestamp <= uint256(epochEnd)) revert EpochNotExpired();\n```\n\n\n\n## Discussion\n\n**3xHarry**\n\nfix PR: https://github.com/Y2K-Finance/Earthquake/pull/140\n\n**IAm0x52**\n\nFix looks good. triggerEndEpoch can no longer be called on expired, null epochs\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/57",
  "Code": [
    {
      "filename": "Earthquake/src/v2/Controllers/ControllerPeggedAssetV2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {IVaultFactoryV2} from \"../interfaces/IVaultFactoryV2.sol\";\nimport {IVaultV2} from \"../interfaces/IVaultV2.sol\";\nimport \"@chainlink/interfaces/AggregatorV3Interface.sol\";\nimport \"@chainlink/interfaces/AggregatorV2V3Interface.sol\";\nimport {FixedPointMathLib} from \"@solmate/utils/FixedPointMathLib.sol\";\n\n/// @author Y2K Finance Team\n\ncontract ControllerPeggedAssetV2 {\n    using FixedPointMathLib for uint256;\n    IVaultFactoryV2 public immutable vaultFactory;\n    AggregatorV2V3Interface internal sequencerUptimeFeed;\n\n    uint16 private constant GRACE_PERIOD_TIME = 3600;\n    address public immutable treasury;\n\n    /*//////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Contract constructor\n     * @param _factory VaultFactory address\n     * @param _l2Sequencer Arbitrum sequencer address\n     * @param _treasury Treasury address\n     */\n    constructor(\n        address _factory,\n        address _l2Sequencer,\n        address _treasury\n    ) {\n        if (_factory == address(0)) revert ZeroAddress();\n\n        if (_l2Sequencer == address(0)) revert ZeroAddress();\n\n        vaultFactory = IVaultFactoryV2(_factory);\n        sequencerUptimeFeed = AggregatorV2V3Interface(_l2Sequencer);\n        treasury = _treasury;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Trigger depeg event\n     * @param _marketId Target market index\n     * @param _epochId End of epoch set for market\n     */\n    function triggerDepeg(uint256 _marketId, uint256 _epochId) public {\n        address[2] memory vaults = vaultFactory.getVaults(_marketId);\n\n        if (vaults[0] == address(0) || vaults[1] == address(0))\n            revert MarketDoesNotExist(_marketId);\n\n        IVaultV2 premiumVault = IVaultV2(vaults[0]);\n        IVaultV2 collateralVault = IVaultV2(vaults[1]);\n\n        if (premiumVault.epochExists(_epochId) == false) revert EpochNotExist();\n\n        int256 price = getLatestPrice(premiumVault.token());\n\n        if (int256(premiumVault.strike()) <= price)\n            revert PriceNotAtStrikePrice(price);\n\n        (uint40 epochStart, uint40 epochEnd, ) = premiumVault.getEpochConfig(\n            _epochId\n        );\n\n        if (uint256(epochStart) > block.timestamp) revert EpochNotStarted();\n\n        if (block.timestamp > uint256(epochEnd)) revert EpochExpired();\n\n        //require this function cannot be called twice in the same epoch for the same vault\n        if (premiumVault.epochResolved(_epochId)) revert EpochFinishedAlready();\n        if (collateralVault.epochResolved(_epochId))\n            revert EpochFinishedAlready();\n\n        // check if epoch qualifies for null epoch\n        if (\n            premiumVault.totalAssets(_epochId) == 0 ||\n            collateralVault.totalAssets(_epochId) == 0\n        ) {\n            revert VaultZeroTVL();\n        }\n\n        premiumVault.resolveEpoch(_epochId);\n        collateralVault.resolveEpoch(_epochId);\n\n        uint256 epochFee = vaultFactory.getEpochFee(_epochId);\n\n        uint256 premiumTVL = premiumVault.finalTVL(_epochId);\n        uint256 collateralTVL = collateralVault.finalTVL(_epochId);\n\n        uint256 premiumFee = calculateWithdrawalFeeValue(premiumTVL, epochFee);\n        uint256 collateralFee = calculateWithdrawalFeeValue(\n            collateralTVL,\n            epochFee\n        );\n\n        // avoid stack too deep error by avoiding local variables\n        // uint256 premiumTVLAfterFee = premiumTVL - premiumFee;\n        // uint256 collateralTVLAfterFee = collateralTVL - collateralFee;\n\n        premiumVault.setClaimTVL(_epochId, collateralTVL - collateralFee);\n        collateralVault.setClaimTVL(_epochId, premiumTVL - premiumFee);\n\n        // send fees to treasury and remaining TVL to respective counterparty vault\n        // strike price reached so premium is entitled to collateralTVL - collateralFee\n        premiumVault.sendTokens(_epochId, premiumFee, treasury);\n        premiumVault.sendTokens(\n            _epochId,\n            premiumTVL - premiumFee,\n            address(collateralVault)\n        );\n        // strike price is reached so collateral is still entitled to premiumTVL - premiumFee but looses collateralTVL\n        collateralVault.sendTokens(_epochId, collateralFee, treasury);\n        collateralVault.sendTokens(\n            _epochId,\n            collateralTVL - collateralFee,\n            address(premiumVault)\n        );\n\n        emit EpochResolved(\n            _epochId,\n            _marketId,\n            VaultTVL(\n                premiumTVL - premiumFee,\n                collateralTVL,\n                collateralTVL - collateralFee,\n                premiumTVL\n            ),\n            true,\n            block.timestamp,\n            price\n        );\n    }\n\n    /** @notice Trigger epoch end without depeg event\n     * @param _marketId Target market index\n     * @param _epochId End of epoch set for market\n     */\n    function triggerEndEpoch(uint256 _marketId, uint256 _epochId) public {\n        address[2] memory vaults = vaultFactory.getVaults(_marketId);\n\n        if (vaults[0] == address(0) || vaults[1] == address(0))\n            revert MarketDoesNotExist(_marketId);\n\n        IVaultV2 premiumVault = IVaultV2(vaults[0]);\n        IVaultV2 collateralVault = IVaultV2(vaults[1]);\n\n        if (\n            premiumVault.epochExists(_epochId) == false ||\n            collateralVault.epochExists(_epochId) == false\n        ) revert EpochNotExist();\n\n        (, uint40 epochEnd, ) = premiumVault.getEpochConfig(_epochId);\n\n        if (block.timestamp <= uint256(epochEnd)) revert EpochNotExpired();\n\n        //require this function cannot be called twice in the same epoch for the same vault\n        if (premiumVault.epochResolved(_epochId)) revert EpochFinishedAlready();\n        if (collateralVault.epochResolved(_epochId))\n            revert EpochFinishedAlready();\n\n        premiumVault.resolveEpoch(_epochId);\n        collateralVault.resolveEpoch(_epochId);\n\n        uint256 epochFee = vaultFactory.getEpochFee(_epochId);\n\n        uint256 premiumTVL = premiumVault.finalTVL(_epochId);\n        uint256 collateralTVL = collateralVault.finalTVL(_epochId);\n\n        uint256 premiumFee = calculateWithdrawalFeeValue(premiumTVL, epochFee);\n\n        uint256 premiumTVLAfterFee = premiumTVL - premiumFee;\n        uint256 collateralTVLAfterFee = collateralTVL + premiumTVLAfterFee;\n\n        // strike price is not reached so premium is entiled to 0\n        premiumVault.setClaimTVL(_epochId, 0);\n        // strike price is not reached so collateral is entitled to collateralTVL + premiumTVLAfterFee\n        collateralVault.setClaimTVL(_epochId, collateralTVLAfterFee);\n\n        // send premium fees to treasury and remaining TVL to collateral vault\n        premiumVault.sendTokens(_epochId, premiumFee, treasury);\n        // strike price reached so collateral is entitled to collateralTVLAfterFee\n        premiumVault.sendTokens(\n            _epochId,\n            premiumTVLAfterFee,\n            address(collateralVault)\n        );\n\n        emit EpochResolved(\n            _epochId,\n            _marketId,\n            VaultTVL(collateralTVLAfterFee, collateralTVL, 0, premiumTVL),\n            false,\n            block.timestamp,\n            0\n        );\n    }\n\n    /** @notice Trigger epoch invalid when one vault has 0 TVL\n     * @param _marketId Target market index\n     * @param _epochId End of epoch set for market\n     */\n    function triggerNullEpoch(uint256 _marketId, uint256 _epochId) public {\n        address[2] memory vaults = vaultFactory.getVaults(_marketId);\n\n        if (vaults[0] == address(0) || vaults[1] == address(0))\n            revert MarketDoesNotExist(_marketId);\n\n        IVaultV2 premiumVault = IVaultV2(vaults[0]);\n        IVaultV2 collateralVault = IVaultV2(vaults[1]);\n\n        if (\n            premiumVault.epochExists(_epochId) == false ||\n            collateralVault.epochExists(_epochId) == false\n        ) revert EpochNotExist();\n\n        (uint40 epochStart, , ) = premiumVault.getEpochConfig(_epochId);\n\n        if (block.timestamp < uint256(epochStart)) revert EpochNotStarted();\n\n        //require this function cannot be called twice in the same epoch for the same vault\n        if (premiumVault.epochResolved(_epochId)) revert EpochFinishedAlready();\n        if (collateralVault.epochResolved(_epochId))\n            revert EpochFinishedAlready();\n\n        //set claim TVL to final TVL if total assets are 0\n        if (premiumVault.totalAssets(_epochId) == 0) {\n            premiumVault.resolveEpoch(_epochId);\n            collateralVault.resolveEpoch(_epochId);\n\n            premiumVault.setClaimTVL(_epochId, 0);\n            collateralVault.setClaimTVL(\n                _epochId,\n                collateralVault.finalTVL(_epochId)\n            );\n\n            collateralVault.setEpochNull(_epochId);\n        } else if (collateralVault.totalAssets(_epochId) == 0) {\n            premiumVault.resolveEpoch(_epochId);\n            collateralVault.resolveEpoch(_epochId);\n\n            premiumVault.setClaimTVL(_epochId, premiumVault.finalTVL(_epochId));\n            collateralVault.setClaimTVL(_epochId, 0);\n\n            premiumVault.setEpochNull(_epochId);\n        } else revert VaultNotZeroTVL();\n\n        emit NullEpoch(\n            _epochId,\n            _marketId,\n            VaultTVL(\n                collateralVault.claimTVL(_epochId),\n                collateralVault.finalTVL(_epochId),\n                premiumVault.claimTVL(_epochId),\n                premiumVault.finalTVL(_epochId)\n            ),\n            block.timestamp\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                GETTERS\n    //////////////////////////////////////////////////////////////*/\n    /** @notice Lookup token price\n     * @param _token Target token address\n     * @return nowPrice Current token price\n     */\n    function getLatestPrice(address _token) public view returns (int256) {\n        (\n            ,\n            /*uint80 roundId*/\n            int256 answer,\n            uint256 startedAt, /*uint256 updatedAt*/ /*uint80 answeredInRound*/\n            ,\n\n        ) = sequencerUptimeFeed.latestRoundData();\n\n        // Answer == 0: Sequencer is up\n        // Answer == 1: Sequencer is down\n        bool isSequencerUp = answer == 0;\n        if (!isSequencerUp) {\n            revert SequencerDown();\n        }\n\n        // Make sure the grace period has passed after the sequencer is back up.\n        uint256 timeSinceUp = block.timestamp - startedAt;\n        if (timeSinceUp <= GRACE_PERIOD_TIME) {\n            revert GracePeriodNotOver();\n        }\n\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(\n            vaultFactory.tokenToOracle(_token)\n        );\n        (uint80 roundID, int256 price, , , uint80 answeredInRound) = priceFeed\n            .latestRoundData();\n        uint256 decimals = priceFeed.decimals();\n\n        if (decimals < 18) {\n            decimals = 10**(18 - (decimals));\n            price = price * int256(decimals);\n        } else if (decimals == 18) {\n            price = price;\n        } else {\n            decimals = 10**((decimals - 18));\n            price = price / int256(decimals);\n        }\n\n        if (price <= 0) revert OraclePriceZero();\n\n        if (answeredInRound < roundID) revert RoundIDOutdated();\n\n        return price;\n    }\n\n    /** @notice Lookup target VaultFactory address\n     * @dev need to find way to express typecasts in NatSpec\n     */\n    function getVaultFactory() external view returns (address) {\n        return address(vaultFactory);\n    }\n\n    /** @notice Calculate amount to withdraw after subtracting protocol fee\n     * @param amount Amount of tokens to withdraw\n     * @param fee Fee to be applied\n     */\n    function calculateWithdrawalFeeValue(uint256 amount, uint256 fee)\n        public\n        pure\n        returns (uint256 feeValue)\n    {\n        // 0.5% = multiply by 10000 then divide by 50\n        return amount.mulDivDown(fee, 10000);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error MarketDoesNotExist(uint256 marketId);\n    error SequencerDown();\n    error GracePeriodNotOver();\n    error ZeroAddress();\n    error EpochFinishedAlready();\n    error PriceNotAtStrikePrice(int256 price);\n    error EpochNotStarted();\n    error EpochExpired();\n    error OraclePriceZero();\n    error RoundIDOutdated();\n    error EpochNotExist();\n    error EpochNotExpired();\n    error VaultNotZeroTVL();\n    error VaultZeroTVL();\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Resolves epoch when event is emitted\n     * @param epochId market epoch ID\n     * @param marketId market ID\n     * @param tvl TVL\n     * @param strikeMet Flag if event isDisaster\n     * @param time time\n     * @param depegPrice Price that triggered depeg\n     */\n    event EpochResolved(\n        uint256 indexed epochId,\n        uint256 indexed marketId,\n        VaultTVL tvl,\n        bool strikeMet,\n        uint256 time,\n        int256 depegPrice\n    );\n\n    /** @notice Sets epoch to null when event is emitted\n     * @param epochId market epoch ID\n     * @param marketId market ID\n     * @param tvl TVL\n     * @param time timestamp\n     */\n    event NullEpoch(\n        uint256 indexed epochId,\n        uint256 indexed marketId,\n        VaultTVL tvl,\n        uint256 time\n    );\n\n    struct VaultTVL {\n        uint256 COLLAT_claimTVL;\n        uint256 COLLAT_finalTVL;\n        uint256 PREM_claimTVL;\n        uint256 PREM_finalTVL;\n    }\n}"
    },
    {
      "filename": "Earthquake/src/v2/Controllers/ControllerPeggedAssetV2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {IVaultFactoryV2} from \"../interfaces/IVaultFactoryV2.sol\";\nimport {IVaultV2} from \"../interfaces/IVaultV2.sol\";\nimport \"@chainlink/interfaces/AggregatorV3Interface.sol\";\nimport \"@chainlink/interfaces/AggregatorV2V3Interface.sol\";\nimport {FixedPointMathLib} from \"@solmate/utils/FixedPointMathLib.sol\";\n\n/// @author Y2K Finance Team\n\ncontract ControllerPeggedAssetV2 {\n    using FixedPointMathLib for uint256;\n    IVaultFactoryV2 public immutable vaultFactory;\n    AggregatorV2V3Interface internal sequencerUptimeFeed;\n\n    uint16 private constant GRACE_PERIOD_TIME = 3600;\n    address public immutable treasury;\n\n    /*//////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Contract constructor\n     * @param _factory VaultFactory address\n     * @param _l2Sequencer Arbitrum sequencer address\n     * @param _treasury Treasury address\n     */\n    constructor(\n        address _factory,\n        address _l2Sequencer,\n        address _treasury\n    ) {\n        if (_factory == address(0)) revert ZeroAddress();\n\n        if (_l2Sequencer == address(0)) revert ZeroAddress();\n\n        vaultFactory = IVaultFactoryV2(_factory);\n        sequencerUptimeFeed = AggregatorV2V3Interface(_l2Sequencer);\n        treasury = _treasury;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Trigger depeg event\n     * @param _marketId Target market index\n     * @param _epochId End of epoch set for market\n     */\n    function triggerDepeg(uint256 _marketId, uint256 _epochId) public {\n        address[2] memory vaults = vaultFactory.getVaults(_marketId);\n\n        if (vaults[0] == address(0) || vaults[1] == address(0))\n            revert MarketDoesNotExist(_marketId);\n\n        IVaultV2 premiumVault = IVaultV2(vaults[0]);\n        IVaultV2 collateralVault = IVaultV2(vaults[1]);\n\n        if (premiumVault.epochExists(_epochId) == false) revert EpochNotExist();\n\n        int256 price = getLatestPrice(premiumVault.token());\n\n        if (int256(premiumVault.strike()) <= price)\n            revert PriceNotAtStrikePrice(price);\n\n        (uint40 epochStart, uint40 epochEnd, ) = premiumVault.getEpochConfig(\n            _epochId\n        );\n\n        if (uint256(epochStart) > block.timestamp) revert EpochNotStarted();\n\n        if (block.timestamp > uint256(epochEnd)) revert EpochExpired();\n\n        //require this function cannot be called twice in the same epoch for the same vault\n        if (premiumVault.epochResolved(_epochId)) revert EpochFinishedAlready();\n        if (collateralVault.epochResolved(_epochId))\n            revert EpochFinishedAlready();\n\n        // check if epoch qualifies for null epoch\n        if (\n            premiumVault.totalAssets(_epochId) == 0 ||\n            collateralVault.totalAssets(_epochId) == 0\n        ) {\n            revert VaultZeroTVL();\n        }\n\n        premiumVault.resolveEpoch(_epochId);\n        collateralVault.resolveEpoch(_epochId);\n\n        uint256 epochFee = vaultFactory.getEpochFee(_epochId);\n\n        uint256 premiumTVL = premiumVault.finalTVL(_epochId);\n        uint256 collateralTVL = collateralVault.finalTVL(_epochId);\n\n        uint256 premiumFee = calculateWithdrawalFeeValue(premiumTVL, epochFee);\n        uint256 collateralFee = calculateWithdrawalFeeValue(\n            collateralTVL,\n            epochFee\n        );\n\n        // avoid stack too deep error by avoiding local variables\n        // uint256 premiumTVLAfterFee = premiumTVL - premiumFee;\n        // uint256 collateralTVLAfterFee = collateralTVL - collateralFee;\n\n        premiumVault.setClaimTVL(_epochId, collateralTVL - collateralFee);\n        collateralVault.setClaimTVL(_epochId, premiumTVL - premiumFee);\n\n        // send fees to treasury and remaining TVL to respective counterparty vault\n        // strike price reached so premium is entitled to collateralTVL - collateralFee\n        premiumVault.sendTokens(_epochId, premiumFee, treasury);\n        premiumVault.sendTokens(\n            _epochId,\n            premiumTVL - premiumFee,\n            address(collateralVault)\n        );\n        // strike price is reached so collateral is still entitled to premiumTVL - premiumFee but looses collateralTVL\n        collateralVault.sendTokens(_epochId, collateralFee, treasury);\n        collateralVault.sendTokens(\n            _epochId,\n            collateralTVL - collateralFee,\n            address(premiumVault)\n        );\n\n        emit EpochResolved(\n            _epochId,\n            _marketId,\n            VaultTVL(\n                premiumTVL - premiumFee,\n                collateralTVL,\n                collateralTVL - collateralFee,\n                premiumTVL\n            ),\n            true,\n            block.timestamp,\n            price\n        );\n    }\n\n    /** @notice Trigger epoch end without depeg event\n     * @param _marketId Target market index\n     * @param _epochId End of epoch set for market\n     */\n    function triggerEndEpoch(uint256 _marketId, uint256 _epochId) public {\n        address[2] memory vaults = vaultFactory.getVaults(_marketId);\n\n        if (vaults[0] == address(0) || vaults[1] == address(0))\n            revert MarketDoesNotExist(_marketId);\n\n        IVaultV2 premiumVault = IVaultV2(vaults[0]);\n        IVaultV2 collateralVault = IVaultV2(vaults[1]);\n\n        if (\n            premiumVault.epochExists(_epochId) == false ||\n            collateralVault.epochExists(_epochId) == false\n        ) revert EpochNotExist();\n\n        (, uint40 epochEnd, ) = premiumVault.getEpochConfig(_epochId);\n\n        if (block.timestamp <= uint256(epochEnd)) revert EpochNotExpired();\n\n        //require this function cannot be called twice in the same epoch for the same vault\n        if (premiumVault.epochResolved(_epochId)) revert EpochFinishedAlready();\n        if (collateralVault.epochResolved(_epochId))\n            revert EpochFinishedAlready();\n\n        premiumVault.resolveEpoch(_epochId);\n        collateralVault.resolveEpoch(_epochId);\n\n        uint256 epochFee = vaultFactory.getEpochFee(_epochId);\n\n        uint256 premiumTVL = premiumVault.finalTVL(_epochId);\n        uint256 collateralTVL = collateralVault.finalTVL(_epochId);\n\n        uint256 premiumFee = calculateWithdrawalFeeValue(premiumTVL, epochFee);\n\n        uint256 premiumTVLAfterFee = premiumTVL - premiumFee;\n        uint256 collateralTVLAfterFee = collateralTVL + premiumTVLAfterFee;\n\n        // strike price is not reached so premium is entiled to 0\n        premiumVault.setClaimTVL(_epochId, 0);\n        // strike price is not reached so collateral is entitled to collateralTVL + premiumTVLAfterFee\n        collateralVault.setClaimTVL(_epochId, collateralTVLAfterFee);\n\n        // send premium fees to treasury and remaining TVL to collateral vault\n        premiumVault.sendTokens(_epochId, premiumFee, treasury);\n        // strike price reached so collateral is entitled to collateralTVLAfterFee\n        premiumVault.sendTokens(\n            _epochId,\n            premiumTVLAfterFee,\n            address(collateralVault)\n        );\n\n        emit EpochResolved(\n            _epochId,\n            _marketId,\n            VaultTVL(collateralTVLAfterFee, collateralTVL, 0, premiumTVL),\n            false,\n            block.timestamp,\n            0\n        );\n    }\n\n    /** @notice Trigger epoch invalid when one vault has 0 TVL\n     * @param _marketId Target market index\n     * @param _epochId End of epoch set for market\n     */\n    function triggerNullEpoch(uint256 _marketId, uint256 _epochId) public {\n        address[2] memory vaults = vaultFactory.getVaults(_marketId);\n\n        if (vaults[0] == address(0) || vaults[1] == address(0))\n            revert MarketDoesNotExist(_marketId);\n\n        IVaultV2 premiumVault = IVaultV2(vaults[0]);\n        IVaultV2 collateralVault = IVaultV2(vaults[1]);\n\n        if (\n            premiumVault.epochExists(_epochId) == false ||\n            collateralVault.epochExists(_epochId) == false\n        ) revert EpochNotExist();\n\n        (uint40 epochStart, , ) = premiumVault.getEpochConfig(_epochId);\n\n        if (block.timestamp < uint256(epochStart)) revert EpochNotStarted();\n\n        //require this function cannot be called twice in the same epoch for the same vault\n        if (premiumVault.epochResolved(_epochId)) revert EpochFinishedAlready();\n        if (collateralVault.epochResolved(_epochId))\n            revert EpochFinishedAlready();\n\n        //set claim TVL to final TVL if total assets are 0\n        if (premiumVault.totalAssets(_epochId) == 0) {\n            premiumVault.resolveEpoch(_epochId);\n            collateralVault.resolveEpoch(_epochId);\n\n            premiumVault.setClaimTVL(_epochId, 0);\n            collateralVault.setClaimTVL(\n                _epochId,\n                collateralVault.finalTVL(_epochId)\n            );\n\n            collateralVault.setEpochNull(_epochId);\n        } else if (collateralVault.totalAssets(_epochId) == 0) {\n            premiumVault.resolveEpoch(_epochId);\n            collateralVault.resolveEpoch(_epochId);\n\n            premiumVault.setClaimTVL(_epochId, premiumVault.finalTVL(_epochId));\n            collateralVault.setClaimTVL(_epochId, 0);\n\n            premiumVault.setEpochNull(_epochId);\n        } else revert VaultNotZeroTVL();\n\n        emit NullEpoch(\n            _epochId,\n            _marketId,\n            VaultTVL(\n                collateralVault.claimTVL(_epochId),\n                collateralVault.finalTVL(_epochId),\n                premiumVault.claimTVL(_epochId),\n                premiumVault.finalTVL(_epochId)\n            ),\n            block.timestamp\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                GETTERS\n    //////////////////////////////////////////////////////////////*/\n    /** @notice Lookup token price\n     * @param _token Target token address\n     * @return nowPrice Current token price\n     */\n    function getLatestPrice(address _token) public view returns (int256) {\n        (\n            ,\n            /*uint80 roundId*/\n            int256 answer,\n            uint256 startedAt, /*uint256 updatedAt*/ /*uint80 answeredInRound*/\n            ,\n\n        ) = sequencerUptimeFeed.latestRoundData();\n\n        // Answer == 0: Sequencer is up\n        // Answer == 1: Sequencer is down\n        bool isSequencerUp = answer == 0;\n        if (!isSequencerUp) {\n            revert SequencerDown();\n        }\n\n        // Make sure the grace period has passed after the sequencer is back up.\n        uint256 timeSinceUp = block.timestamp - startedAt;\n        if (timeSinceUp <= GRACE_PERIOD_TIME) {\n            revert GracePeriodNotOver();\n        }\n\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(\n            vaultFactory.tokenToOracle(_token)\n        );\n        (uint80 roundID, int256 price, , , uint80 answeredInRound) = priceFeed\n            .latestRoundData();\n        uint256 decimals = priceFeed.decimals();\n\n        if (decimals < 18) {\n            decimals = 10**(18 - (decimals));\n            price = price * int256(decimals);\n        } else if (decimals == 18) {\n            price = price;\n        } else {\n            decimals = 10**((decimals - 18));\n            price = price / int256(decimals);\n        }\n\n        if (price <= 0) revert OraclePriceZero();\n\n        if (answeredInRound < roundID) revert RoundIDOutdated();\n\n        return price;\n    }\n\n    /** @notice Lookup target VaultFactory address\n     * @dev need to find way to express typecasts in NatSpec\n     */\n    function getVaultFactory() external view returns (address) {\n        return address(vaultFactory);\n    }\n\n    /** @notice Calculate amount to withdraw after subtracting protocol fee\n     * @param amount Amount of tokens to withdraw\n     * @param fee Fee to be applied\n     */\n    function calculateWithdrawalFeeValue(uint256 amount, uint256 fee)\n        public\n        pure\n        returns (uint256 feeValue)\n    {\n        // 0.5% = multiply by 10000 then divide by 50\n        return amount.mulDivDown(fee, 10000);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error MarketDoesNotExist(uint256 marketId);\n    error SequencerDown();\n    error GracePeriodNotOver();\n    error ZeroAddress();\n    error EpochFinishedAlready();\n    error PriceNotAtStrikePrice(int256 price);\n    error EpochNotStarted();\n    error EpochExpired();\n    error OraclePriceZero();\n    error RoundIDOutdated();\n    error EpochNotExist();\n    error EpochNotExpired();\n    error VaultNotZeroTVL();\n    error VaultZeroTVL();\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Resolves epoch when event is emitted\n     * @param epochId market epoch ID\n     * @param marketId market ID\n     * @param tvl TVL\n     * @param strikeMet Flag if event isDisaster\n     * @param time time\n     * @param depegPrice Price that triggered depeg\n     */\n    event EpochResolved(\n        uint256 indexed epochId,\n        uint256 indexed marketId,\n        VaultTVL tvl,\n        bool strikeMet,\n        uint256 time,\n        int256 depegPrice\n    );\n\n    /** @notice Sets epoch to null when event is emitted\n     * @param epochId market epoch ID\n     * @param marketId market ID\n     * @param tvl TVL\n     * @param time timestamp\n     */\n    event NullEpoch(\n        uint256 indexed epochId,\n        uint256 indexed marketId,\n        VaultTVL tvl,\n        uint256 time\n    );\n\n    struct VaultTVL {\n        uint256 COLLAT_claimTVL;\n        uint256 COLLAT_finalTVL;\n        uint256 PREM_claimTVL;\n        uint256 PREM_finalTVL;\n    }\n}"
    }
  ]
}