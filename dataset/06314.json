{
  "Title": "[01] Missing `emit` in `lsp20VerifyCall()`",
  "Content": "\nThe function `lsp20VerifyCall()` has two calls to `_verifyPermissions()`; however, only the first one is followed by an `emit`.\nThis might make debugging transaction more difficult. Also indexed data by protocols like TheGraph will be incomplete.\n\n### Proof of Concept\n[LSP6KeyManagerCore.sol#L249-L296](https://github.com/lukso-network/lsp-smart-contracts/blob/v0.10.2/contracts/LSP6KeyManager/LSP6KeyManagerCore.sol#L249-L296)\n\n```solidity\nfunction lsp20VerifyCall(...) ... {\n    ...\n    if (msg.sender == _target) {\n        ...\n        _verifyPermissions(caller, msgValue, data);\n        emit VerifiedCall(caller, msgValue, bytes4(data));\n        return ...\n    }\n    else {\n        ...\n        _verifyPermissions(caller, msgValue, data);\n        // no emit\n        return ...\n    }\n}\n```\n### Recommended Mitigation Steps\nAdd an `emit` after the second call to `_verifyPermissions()`:\n```diff\nfunction lsp20VerifyCall(...) ... {\n    ...\n    if (msg.sender == _target) {\n        ...\n        _verifyPermissions(caller, msgValue, data);\n        emit VerifiedCall(caller, msgValue, bytes4(data));\n        return ...\n    }\n    else {\n        ...\n        _verifyPermissions(caller, msgValue, data);\n+       emit VerifiedCall(caller, msgValue, bytes4(data));\n        return ...\n    }\n}\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-06-lukso",
  "Code": [
    {
      "filename": "contracts/LSP6KeyManager/LSP6KeyManagerCore.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.5;\n\n// interfaces\nimport {IERC1271} from \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\nimport {\n    IERC725X\n} from \"@erc725/smart-contracts/contracts/interfaces/IERC725X.sol\";\nimport {\n    IERC725Y\n} from \"@erc725/smart-contracts/contracts/interfaces/IERC725Y.sol\";\nimport {ILSP6KeyManager} from \"./ILSP6KeyManager.sol\";\nimport {\n    ILSP20CallVerifier as ILSP20\n} from \"../LSP20CallVerification/ILSP20CallVerifier.sol\";\n\n// modules\nimport {ILSP14Ownable2Step} from \"../LSP14Ownable2Step/ILSP14Ownable2Step.sol\";\nimport {ERC725Y} from \"@erc725/smart-contracts/contracts/ERC725Y.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {LSP6SetDataModule} from \"./LSP6Modules/LSP6SetDataModule.sol\";\nimport {LSP6ExecuteModule} from \"./LSP6Modules/LSP6ExecuteModule.sol\";\nimport {LSP6OwnershipModule} from \"./LSP6Modules/LSP6OwnershipModule.sol\";\n\n// libraries\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {LSP6Utils} from \"./LSP6Utils.sol\";\n\n// errors\nimport {\n    BatchExecuteParamsLengthMismatch,\n    BatchExecuteRelayCallParamsLengthMismatch,\n    LSP6BatchExcessiveValueSent,\n    LSP6BatchInsufficientValueSent,\n    InvalidPayload,\n    InvalidRelayNonce,\n    NoPermissionsSet,\n    InvalidERC725Function,\n    CannotSendValueToSetData,\n    RelayCallBeforeStartTime,\n    RelayCallExpired\n} from \"./LSP6Errors.sol\";\n\nimport {\n    _INTERFACEID_ERC1271,\n    _ERC1271_MAGICVALUE,\n    _ERC1271_FAILVALUE\n} from \"../LSP0ERC725Account/LSP0Constants.sol\";\nimport {\n    LSP6_VERSION,\n    _INTERFACEID_LSP6,\n    _PERMISSION_SIGN,\n    _PERMISSION_REENTRANCY\n} from \"./LSP6Constants.sol\";\nimport \"../LSP20CallVerification/LSP20Constants.sol\";\n\n/**\n * @title Core implementation of the LSP6 Key Manager standard.\n * @author Fabian Vogelsteller <frozeman>, Jean Cavallera (CJ42), Yamen Merhi (YamenMerhi)\n * @dev This contract acts as a controller for an ERC725 Account.\n *      Permissions for controllers are stored in the ERC725Y storage of the ERC725 Account and can be updated using `setData(...)`.\n */\nabstract contract LSP6KeyManagerCore is\n    ERC165,\n    ILSP6KeyManager,\n    ILSP20,\n    LSP6SetDataModule,\n    LSP6ExecuteModule,\n    LSP6OwnershipModule\n{\n    using LSP6Utils for *;\n    using ECDSA for *;\n    using BytesLib for bytes;\n\n    address internal _target;\n\n    // Variables, methods and modifier used for ReentrancyGuard are taken from the link below and modified accordingly.\n    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.8/contracts/security/ReentrancyGuard.sol\n    bool private _reentrancyStatus;\n\n    mapping(address => mapping(uint256 => uint256)) internal _nonceStore;\n\n    function target() public view returns (address) {\n        return _target;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override returns (bool) {\n        return\n            interfaceId == _INTERFACEID_LSP6 ||\n            interfaceId == _INTERFACEID_ERC1271 ||\n            interfaceId == _INTERFACEID_LSP20_CALL_VERIFIER ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @inheritdoc ILSP6KeyManager\n     */\n    function getNonce(\n        address from,\n        uint128 channelId\n    ) public view returns (uint256) {\n        uint256 nonceInChannel = _nonceStore[from][channelId];\n        return (uint256(channelId) << 128) | nonceInChannel;\n    }\n\n    /**\n     * @inheritdoc IERC1271\n     */\n    function isValidSignature(\n        bytes32 dataHash,\n        bytes memory signature\n    ) public view returns (bytes4 magicValue) {\n        // if isValidSignature fail, the error is catched in returnedError\n        (address recoveredAddress, ECDSA.RecoverError returnedError) = ECDSA\n            .tryRecover(dataHash, signature);\n\n        // if recovering throws an error, return the fail value\n        if (returnedError != ECDSA.RecoverError.NoError)\n            return _ERC1271_FAILVALUE;\n\n        // if the address recovered has SIGN permission return the ERC1271 magic value, otherwise the fail value\n        return (\n            ERC725Y(_target).getPermissionsFor(recoveredAddress).hasPermission(\n                _PERMISSION_SIGN\n            )\n                ? _ERC1271_MAGICVALUE\n                : _ERC1271_FAILVALUE\n        );\n    }\n\n    /**\n     * @inheritdoc ILSP6KeyManager\n     */\n    function execute(\n        bytes calldata payload\n    ) public payable virtual returns (bytes memory) {\n        return _execute(msg.value, payload);\n    }\n\n    /**\n     * @inheritdoc ILSP6KeyManager\n     */\n    function executeBatch(\n        uint256[] calldata values,\n        bytes[] calldata payloads\n    ) public payable virtual returns (bytes[] memory) {\n        if (values.length != payloads.length) {\n            revert BatchExecuteParamsLengthMismatch();\n        }\n\n        bytes[] memory results = new bytes[](payloads.length);\n        uint256 totalValues;\n\n        for (uint256 ii = 0; ii < payloads.length; ) {\n            if ((totalValues += values[ii]) > msg.value) {\n                revert LSP6BatchInsufficientValueSent(totalValues, msg.value);\n            }\n\n            results[ii] = _execute(values[ii], payloads[ii]);\n\n            unchecked {\n                ++ii;\n            }\n        }\n\n        if (totalValues < msg.value) {\n            revert LSP6BatchExcessiveValueSent(totalValues, msg.value);\n        }\n\n        return results;\n    }\n\n    /**\n     * @inheritdoc ILSP6KeyManager\n     */\n    function executeRelayCall(\n        bytes memory signature,\n        uint256 nonce,\n        uint256 validityTimestamps,\n        bytes calldata payload\n    ) public payable virtual returns (bytes memory) {\n        return\n            _executeRelayCall(\n                signature,\n                nonce,\n                validityTimestamps,\n                msg.value,\n                payload\n            );\n    }\n\n    /**\n     * @inheritdoc ILSP6KeyManager\n     */\n    function executeRelayCallBatch(\n        bytes[] memory signatures,\n        uint256[] calldata nonces,\n        uint256[] calldata validityTimestamps,\n        uint256[] calldata values,\n        bytes[] calldata payloads\n    ) public payable virtual returns (bytes[] memory) {\n        if (\n            signatures.length != nonces.length ||\n            nonces.length != validityTimestamps.length ||\n            validityTimestamps.length != values.length ||\n            values.length != payloads.length\n        ) {\n            revert BatchExecuteRelayCallParamsLengthMismatch();\n        }\n\n        bytes[] memory results = new bytes[](payloads.length);\n        uint256 totalValues;\n\n        for (uint256 ii = 0; ii < payloads.length; ) {\n            if ((totalValues += values[ii]) > msg.value) {\n                revert LSP6BatchInsufficientValueSent(totalValues, msg.value);\n            }\n\n            results[ii] = _executeRelayCall(\n                signatures[ii],\n                nonces[ii],\n                validityTimestamps[ii],\n                values[ii],\n                payloads[ii]\n            );\n\n            unchecked {\n                ++ii;\n            }\n        }\n\n        if (totalValues < msg.value) {\n            revert LSP6BatchExcessiveValueSent(totalValues, msg.value);\n        }\n\n        return results;\n    }\n\n    /**\n     * @inheritdoc ILSP20\n     */\n    function lsp20VerifyCall(\n        address caller,\n        uint256 msgValue,\n        bytes calldata data\n    ) external returns (bytes4) {\n        bool isSetData = false;\n        if (\n            bytes4(data) == IERC725Y.setData.selector ||\n            bytes4(data) == IERC725Y.setDataBatch.selector\n        ) {\n            isSetData = true;\n        }\n\n        // If target is invoking the verification, emit the event and change the reentrancy guard\n        if (msg.sender == _target) {\n            bool isReentrantCall = _nonReentrantBefore(isSetData, caller);\n\n            _verifyPermissions(caller, msgValue, data);\n            emit VerifiedCall(caller, msgValue, bytes4(data));\n\n            // if it's a setData call, do not invoke the `lsp20VerifyCallResult(..)` function\n            return\n                isSetData || isReentrantCall\n                    ? _LSP20_VERIFY_CALL_MAGIC_VALUE_WITHOUT_POST_VERIFICATION\n                    : _LSP20_VERIFY_CALL_MAGIC_VALUE_WITH_POST_VERIFICATION;\n        }\n        // If a different address is invoking the verification, do not change the state\n        // and do read-only verification\n        else {\n            bool isReentrantCall = _reentrancyStatus;\n\n            if (isReentrantCall) {\n                _requirePermissions(\n                    caller,\n                    ERC725Y(_target).getPermissionsFor(caller),\n                    _PERMISSION_REENTRANCY\n                );\n            }\n\n            _verifyPermissions(caller, msgValue, data);\n\n            // if it's a setData call, do not invoke the `lsp20VerifyCallResult(..)` function\n            return\n                isSetData || isReentrantCall\n                    ? _LSP20_VERIFY_CALL_MAGIC_VALUE_WITHOUT_POST_VERIFICATION\n                    : _LSP20_VERIFY_CALL_MAGIC_VALUE_WITH_POST_VERIFICATION;\n        }\n    }\n\n    /**\n     * @inheritdoc ILSP20\n     */\n    function lsp20VerifyCallResult(\n        bytes32 /*callHash*/,\n        bytes memory /*result*/\n    ) external returns (bytes4) {\n        // If it's the target calling, set back the reentrancy guard\n        // to false, if not return the magic value\n        if (msg.sender == _target) {\n            _nonReentrantAfter();\n        }\n        return _LSP20_VERIFY_CALL_RESULT_MAGIC_VALUE;\n    }\n\n    function _execute(\n        uint256 msgValue,\n        bytes calldata payload\n    ) internal virtual returns (bytes memory) {\n        if (payload.length < 4) {\n            revert InvalidPayload(payload);\n        }\n\n        bool isSetData = false;\n        if (\n            bytes4(payload) == IERC725Y.setData.selector ||\n            bytes4(payload) == IERC725Y.setDataBatch.selector\n        ) {\n            isSetData = true;\n        }\n\n        bool isReentrantCall = _nonReentrantBefore(isSetData, msg.sender);\n\n        _verifyPermissions(msg.sender, msgValue, payload);\n        emit VerifiedCall(msg.sender, msgValue, bytes4(payload));\n\n        bytes memory result = _executePayload(msgValue, payload);\n\n        if (!isReentrantCall && !isSetData) {\n            _nonReentrantAfter();\n        }\n\n        return result;\n    }\n\n    function _executeRelayCall(\n        bytes memory signature,\n        uint256 nonce,\n        uint256 validityTimestamps,\n        uint256 msgValue,\n        bytes calldata payload\n    ) internal virtual returns (bytes memory) {\n        if (payload.length < 4) {\n            revert InvalidPayload(payload);\n        }\n\n        bytes memory encodedMessage = abi.encodePacked(\n            LSP6_VERSION,\n            block.chainid,\n            nonce,\n            validityTimestamps,\n            msgValue,\n            payload\n        );\n\n        address signer = address(this)\n            .toDataWithIntendedValidatorHash(encodedMessage)\n            .recover(signature);\n\n        bool isSetData = false;\n        if (\n            bytes4(payload) == IERC725Y.setData.selector ||\n            bytes4(payload) == IERC725Y.setDataBatch.selector\n        ) {\n            isSetData = true;\n        }\n\n        bool isReentrantCall = _nonReentrantBefore(isSetData, signer);\n\n        if (!_isValidNonce(signer, nonce)) {\n            revert InvalidRelayNonce(signer, nonce, signature);\n        }\n\n        // increase nonce after successful verification\n        _nonceStore[signer][nonce >> 128]++;\n\n        if (validityTimestamps != 0) {\n            uint128 startingTimestamp = uint128(validityTimestamps >> 128);\n            uint128 endingTimestamp = uint128(validityTimestamps);\n\n            // solhint-disable not-rely-on-time\n            if (block.timestamp < startingTimestamp) {\n                revert RelayCallBeforeStartTime();\n            }\n            if (block.timestamp > endingTimestamp) {\n                revert RelayCallExpired();\n            }\n        }\n\n        _verifyPermissions(signer, msgValue, payload);\n        emit VerifiedCall(signer, msgValue, bytes4(payload));\n\n        bytes memory result = _executePayload(msgValue, payload);\n\n        if (!isReentrantCall && !isSetData) {\n            _nonReentrantAfter();\n        }\n\n        return result;\n    }\n\n    /**\n     * @notice execute the `payload` passed to `execute(...)` or `executeRelayCall(...)`\n     * @param payload the abi-encoded function call to execute on the target.\n     * @return bytes the result from calling the target with `payload`\n     */\n    function _executePayload(\n        uint256 msgValue,\n        bytes calldata payload\n    ) internal virtual returns (bytes memory) {\n        (bool success, bytes memory returnData) = _target.call{\n            value: msgValue,\n            gas: gasleft()\n        }(payload);\n        bytes memory result = Address.verifyCallResult(\n            success,\n            returnData,\n            \"LSP6: failed executing payload\"\n        );\n\n        return result.length != 0 ? abi.decode(result, (bytes)) : result;\n    }\n\n    /**\n     * @notice verify the nonce `_idx` for `_from` (obtained via `getNonce(...)`)\n     * @dev \"idx\" is a 256bits (unsigned) integer, where:\n     *          - the 128 leftmost bits = channelId\n     *      and - the 128 rightmost bits = nonce within the channel\n     * @param from caller address\n     * @param idx (channel id + nonce within the channel)\n     */\n    function _isValidNonce(\n        address from,\n        uint256 idx\n    ) internal view virtual returns (bool) {\n        uint256 mask = ~uint128(0);\n        // Alternatively:\n        // uint256 mask = (1<<128)-1;\n        // uint256 mask = 0xffffffffffffffffffffffffffffffff;\n        return (idx & mask) == (_nonceStore[from][idx >> 128]);\n    }\n\n    /**\n     * @dev verify if the `from` address is allowed to execute the `payload` on the `target`.\n     * @param from either the caller of `execute(...)` or the signer of `executeRelayCall(...)`.\n     * @param payload the payload to execute on the `target`.\n     */\n    function _verifyPermissions(\n        address from,\n        uint256 msgValue,\n        bytes calldata payload\n    ) internal view virtual {\n        bytes32 permissions = ERC725Y(_target).getPermissionsFor(from);\n        if (permissions == bytes32(0)) revert NoPermissionsSet(from);\n\n        bytes4 erc725Function = bytes4(payload);\n\n        // ERC725Y.setData(bytes32,bytes)\n        if (erc725Function == IERC725Y.setData.selector) {\n            if (msgValue != 0) revert CannotSendValueToSetData();\n            (bytes32 inputKey, bytes memory inputValue) = abi.decode(\n                payload[4:],\n                (bytes32, bytes)\n            );\n\n            LSP6SetDataModule._verifyCanSetData(\n                _target,\n                from,\n                permissions,\n                inputKey,\n                inputValue\n            );\n\n            // ERC725Y.setDataBatch(bytes32[],bytes[])\n        } else if (erc725Function == IERC725Y.setDataBatch.selector) {\n            if (msgValue != 0) revert CannotSendValueToSetData();\n            (bytes32[] memory inputKeys, bytes[] memory inputValues) = abi\n                .decode(payload[4:], (bytes32[], bytes[]));\n\n            LSP6SetDataModule._verifyCanSetData(\n                _target,\n                from,\n                permissions,\n                inputKeys,\n                inputValues\n            );\n\n            // ERC725X.execute(uint256,address,uint256,bytes)\n        } else if (erc725Function == IERC725X.execute.selector) {\n            LSP6ExecuteModule._verifyCanExecute(\n                _target,\n                from,\n                permissions,\n                payload\n            );\n        } else if (\n            erc725Function == ILSP14Ownable2Step.transferOwnership.selector ||\n            erc725Function == ILSP14Ownable2Step.acceptOwnership.selector\n        ) {\n            LSP6OwnershipModule._verifyOwnershipPermissions(from, permissions);\n        } else {\n            revert InvalidERC725Function(erc725Function);\n        }\n    }\n\n    /**\n     * @dev Initialise _reentrancyStatus to _NOT_ENTERED.\n     */\n    function _setupLSP6ReentrancyGuard() internal virtual {\n        _reentrancyStatus = false;\n    }\n\n    /**\n     * @dev Update the status from `_NON_ENTERED` to `_ENTERED` and checks if\n     * the status is `_ENTERED` in order to revert the call unless the caller has the REENTRANCY permission\n     * Used in the beginning of the `nonReentrant` modifier, before the method execution starts.\n     */\n    function _nonReentrantBefore(\n        bool isSetData,\n        address from\n    ) internal virtual returns (bool isReentrantCall) {\n        isReentrantCall = _reentrancyStatus;\n        if (isReentrantCall) {\n            // CHECK the caller has REENTRANCY permission\n            _requirePermissions(\n                from,\n                ERC725Y(_target).getPermissionsFor(from),\n                _PERMISSION_REENTRANCY\n            );\n        } else {\n            if (!isSetData) {\n                _reentrancyStatus = true;\n            }\n        }\n    }\n\n    /**\n     * @dev Resets the status to `_NOT_ENTERED`\n     * Used in the end of the `nonReentrant` modifier after the method execution is terminated\n     */\n    function _nonReentrantAfter() internal virtual {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _reentrancyStatus = false;\n    }\n\n    /**\n     * @dev revert if `controller`'s `addressPermissions` doesn't contain `permissionsRequired`\n     * @param controller the caller address\n     * @param addressPermissions the caller's permissions BitArray\n     * @param permissionRequired the required permission\n     */\n    function _requirePermissions(\n        address controller,\n        bytes32 addressPermissions,\n        bytes32 permissionRequired\n    ) internal pure override(LSP6ExecuteModule, LSP6SetDataModule) {\n        LSP6ExecuteModule._requirePermissions(\n            controller,\n            addressPermissions,\n            permissionRequired\n        );\n    }\n}"
    }
  ]
}