{
  "Title": "M-5: getPriceFromChainlink() doesn't check If Arbitrum sequencer is down in Chainlink feeds",
  "Content": "# Issue M-5: getPriceFromChainlink() doesn't check If Arbitrum sequencer is down in Chainlink feeds \n\nSource: https://github.com/sherlock-audit/2023-05-ironbank-judging/issues/440 \n\n## Found by \n0x52, 0xMAKEOUTHILL, Angry\\_Mustache\\_Man, Arabadzhiev, Arz, Aymen0909, BenRai, Breeje, Brenzee, BugBusters, Delvir0, HexHackers, Ignite, Jaraxxus, Kodyvim, Madalad, MohammedRizwan, Ocean\\_Sky, Proxy, R-Nemes, SovaSlava, berlin-101, bin2chen, bitsurfer, branch\\_indigo, deadrxsezzz, devScrooge, josephdara, kutugu, n1punp, n33k, ni8mare, p0wd3r, plainshift-2, rvierdiiev, santipu\\_, sashik\\_eth, shaka, simon135, sl1, toshii, tsvetanovv, turvec, vagrant\n## Summary\nWhen utilizing Chainlink in L2 chains like Arbitrum, it's important to ensure that the prices provided are not falsely perceived as fresh, even when the sequencer is down. This vulnerability could potentially be exploited by malicious actors to gain an unfair advantage.\n\n## Vulnerability Detail\nThere is no check:\ngetPriceFromChainlink\n```solidity\n    function getPriceFromChainlink(address base, address quote) internal view returns (uint256) {\n@>      (, int256 price,,,) = registry.latestRoundData(base, quote);\n        require(price > 0, \"invalid price\");\n\n        // Extend the decimals to 1e18.\n        return uint256(price) * 10 ** (18 - uint256(registry.decimals(base, quote)));\n    }\n```\n\n\n## Impact\n\ncould potentially be exploited by malicious actors to gain an unfair advantage.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-ironbank/blob/main/ib-v2/src/protocol/oracle/PriceOracle.sol#L66-L72\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\ncode example of Chainlink:\nhttps://docs.chain.link/data-feeds/l2-sequencer-feeds#example-code\n\n\n\n## Discussion\n\n**0xffff11**\n\nValid medium\n\n**ib-tycho**\n\nRegarding the mistake in the contest details mentioned in the `README`, we apologize for any confusion caused. When we stated that we would deploy on Arbitrum and Optimism, we meant that we would make the necessary modifications before deployment. This is our standard practice of maintaining contracts with different branches, same as what we did in v1: https://github.com/ibdotxyz/compound-protocol/branches\n\nWe are aware of the absence of a registry on OP and Arb, as pointed out by some individuals. We would like to inquire if it is possible to offer the minimum reward for an oracle issue on L2. Thank you.\n\n**ib-tycho**\n\nWe'll fix this when deploying on L2, but we disagree with Severity. I would consider this as Low\n\n**0xffff11**\n\nAccording to past reports and sponsor confirmed that they will fix the issue. The issue will remain as a medium.\n\n**MLON33**\n\nAssuming this issue is acknowledged by the protocol team and wonâ€™t be fixed.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/84",
  "Code": [
    {
      "filename": "ib-v2/src/protocol/oracle/PriceOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"chainlink/contracts/src/v0.8/interfaces/FeedRegistryInterface.sol\";\nimport \"chainlink/contracts/src/v0.8/Denominations.sol\";\nimport \"openzeppelin-contracts/contracts/access/Ownable2Step.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../../extensions/interfaces/WstEthInterface.sol\";\nimport \"../../interfaces/PriceOracleInterface.sol\";\n\ncontract PriceOracle is Ownable2Step, PriceOracleInterface {\n    /// @notice The Chainlink feed registry\n    FeedRegistryInterface public immutable registry;\n\n    /// @notice The address of Lido staked ETH\n    address public immutable steth;\n\n    /// @notice The address of Lido wrapped staked ETH\n    address public immutable wsteth;\n\n    struct AggregatorInfo {\n        address base;\n        address quote;\n    }\n\n    /// @notice The mapping from asset to aggregator\n    mapping(address => AggregatorInfo) public aggregators;\n\n    constructor(address registry_, address steth_, address wsteth_) {\n        registry = FeedRegistryInterface(registry_);\n        steth = steth_;\n        wsteth = wsteth_;\n    }\n\n    /**\n     * @notice Get the price of an asset in USD.\n     * @dev The price returned will be normalized by asset's decimals.\n     * @param asset The asset to get the price of\n     * @return The price of the asset in USD\n     */\n    function getPrice(address asset) external view returns (uint256) {\n        if (asset == wsteth) {\n            uint256 stEthPrice = getPriceFromChainlink(steth, Denominations.USD);\n            uint256 stEthPerToken = WstEthInterface(wsteth).stEthPerToken();\n            uint256 wstEthPrice = (stEthPrice * stEthPerToken) / 1e18;\n            return getNormalizedPrice(wstEthPrice, asset);\n        }\n\n        AggregatorInfo memory aggregatorInfo = aggregators[asset];\n        uint256 price = getPriceFromChainlink(aggregatorInfo.base, aggregatorInfo.quote);\n        if (aggregatorInfo.quote == Denominations.ETH) {\n            // Convert the price to USD based if it's ETH based.\n            uint256 ethUsdPrice = getPriceFromChainlink(Denominations.ETH, Denominations.USD);\n            price = (price * ethUsdPrice) / 1e18;\n        }\n        return getNormalizedPrice(price, asset);\n    }\n\n    /**\n     * @notice Get price from Chainlink.\n     * @param base The base asset\n     * @param quote The quote asset\n     * @return The price\n     */\n    function getPriceFromChainlink(address base, address quote) internal view returns (uint256) {\n        (, int256 price,,,) = registry.latestRoundData(base, quote);\n        require(price > 0, \"invalid price\");\n\n        // Extend the decimals to 1e18.\n        return uint256(price) * 10 ** (18 - uint256(registry.decimals(base, quote)));\n    }\n\n    /**\n     * @dev Get the normalized price.\n     * @param price The price\n     * @param asset The asset\n     * @return The normalized price\n     */\n    function getNormalizedPrice(uint256 price, address asset) internal view returns (uint256) {\n        uint8 decimals = IERC20Metadata(asset).decimals();\n        return price * 10 ** (18 - decimals);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    struct Aggregator {\n        address asset;\n        address base;\n        address quote;\n    }\n\n    /**\n     * @notice Set the aggregators.\n     * @param aggrs The aggregators\n     */\n    function _setAggregators(Aggregator[] calldata aggrs) external onlyOwner {\n        uint256 length = aggrs.length;\n        for (uint256 i = 0; i < length;) {\n            if (aggrs[i].base != address(0)) {\n                require(aggrs[i].quote == Denominations.ETH || aggrs[i].quote == Denominations.USD, \"unsupported quote\");\n\n                // Make sure the aggregator works.\n                address aggregator = address(registry.getFeed(aggrs[i].base, aggrs[i].quote));\n                require(registry.isFeedEnabled(aggregator), \"aggregator not enabled\");\n\n                (, int256 price,,,) = registry.latestRoundData(aggrs[i].base, aggrs[i].quote);\n                require(price > 0, \"invalid price\");\n            }\n            aggregators[aggrs[i].asset] = AggregatorInfo({base: aggrs[i].base, quote: aggrs[i].quote});\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n}"
    }
  ]
}