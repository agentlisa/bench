{
  "Title": "[M01] Affiliate keys can be reused",
  "Content": "The [`addKey` function of the `AffiliateValidator` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/AffiliateValidator.sol#L23) is used to associate a `key` with a user account. The `key` is expected to be derived from the user’s KYC information. The function first confirms that a given key-salt pair was signed by an operator and that the salt has not been used already. Then it associates the key with the sender’s account.\n\n\nHowever, should the signer be a registered operator on multiple instances of the same `AffiliateValidator` contract, any user can take a signature intended for one contract and apply it to any other. As a consequence, any user would be able to obtain valid keys without going through the mandatory KYC process.\n\n\nDepending on the expected scenarios where multiple `AffiliateValidator` contracts share operators, it may be acceptable for the same user to reuse a key (assuming the reported **“[H03] Affiliate keys can be stolen”** issue is first addressed). Otherwise, consider including the contract’s address within the key hash to ensure the signature can only be used with the expected `AffiliateValidator` contract.\n\n\n**Update**: *Fixed in [PR #5564](https://github.com/AugurProject/augur/pull/5564/files). The `AffiliateValidator` contract address is included within the key hash.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "packages/augur-core/source/contracts/AffiliateValidator.sol",
      "content": "pragma solidity 0.5.10;\n\nimport 'ROOT/libraries/Ownable.sol';\nimport 'ROOT/external/IAffiliateValidator.sol';\n\n\ncontract AffiliateValidator is Ownable, IAffiliateValidator {\n    // Mapping of affiliate address to their key\n    mapping (address => bytes32) keys;\n\n    mapping (address => bool) operators;\n\n    mapping (uint256 => bool) usedSalts;\n\n    function addOperator(address _operator) external onlyOwner {\n        operators[_operator] = true;\n    }\n\n    function removeOperator(address _operator) external onlyOwner {\n        operators[_operator] = false;\n    }\n\n    function addKey(bytes32 _key, uint256 _salt, bytes32 _r, bytes32 _s, uint8 _v) external {\n        require(!usedSalts[_salt], \"Salt already used\");\n        bytes32 _hash = getKeyHash(_key, _salt);\n        require(isValidSignature(_hash, _r, _s, _v), \"Signature invalid\");\n        usedSalts[_salt] = true;\n        keys[msg.sender] = _key;\n    }\n\n    function getKeyHash(bytes32 _key, uint256 _salt) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_key, _salt));\n    }\n\n    function isValidSignature(bytes32 _hash, bytes32 _r, bytes32 _s, uint8 _v) public view returns (bool) {\n        address recovered = ecrecover(\n            keccak256(abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n32\",\n                _hash\n            )),\n            _v,\n            _r,\n            _s\n        );\n        return operators[recovered];\n    }\n\n    function validateReference(address _account, address _referrer) external view {\n        bytes32 _accountKey = keys[_account];\n        bytes32 _referralKey = keys[_referrer];\n        if (_accountKey == bytes32(0) || _referralKey == bytes32(0)) {\n            revert(\"Key must be registered for both accounts\");\n        }\n        require(_accountKey != _referralKey, \"Key must not be equal for both accounts\");\n    }\n\n    function onTransferOwnership(address, address) internal {}\n}"
    }
  ]
}