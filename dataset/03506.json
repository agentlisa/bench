{
  "Title": "[L19] Lack of event emissions",
  "Content": "* In the `OVM_ProxySequencerEntrypoint` contract, the [`upgrade` function](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/predeploys/OVM_ProxySequencerEntrypoint.sol#L51) does not emit an event after a successful upgrade operation.\n\n\nConsider emitting events after sensitive changes take place to facilitate tracking and notify off-chain clients following the contractsâ€™ activity.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/optimistic-ethereum/OVM/predeploys/OVM_ProxySequencerEntrypoint.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\n\n/* Library Imports */\nimport { Lib_SafeExecutionManagerWrapper } from \"../../libraries/wrappers/Lib_SafeExecutionManagerWrapper.sol\";\n\n/**\n * @title OVM_ProxySequencerEntrypoint \n * @dev The Proxy Sequencer Entrypoint is a predeployed proxy to the implementation of the \n * Sequencer Entrypoint. This will enable the Optimism team to upgrade the Sequencer Entrypoint \n * contract.\n * \n * Compiler used: solc\n * Runtime target: OVM\n */\ncontract OVM_ProxySequencerEntrypoint {\n\n    /*********************\n     * Fallback Function *\n     *********************/\n\n    fallback()\n        external\n    {\n        Lib_SafeExecutionManagerWrapper.safeDELEGATECALL(\n            gasleft(),\n            _getImplementation(),\n            msg.data\n        );\n    }\n\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    function init(\n        address _implementation,\n        address _owner\n    )\n        external\n    {\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(\n            _getOwner() == address(0),\n            \"ProxySequencerEntrypoint has already been inited\"\n        );\n        _setOwner(_owner);\n        _setImplementation(_implementation);\n    }\n\n    function upgrade(\n        address _implementation\n    )\n        external\n    {\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(\n            _getOwner() == Lib_SafeExecutionManagerWrapper.safeCALLER(),\n            \"Only owner can upgrade the Entrypoint\"\n        );\n\n        _setImplementation(_implementation);\n    }\n\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function _setImplementation(\n        address _implementation\n    )\n        internal\n    {\n        Lib_SafeExecutionManagerWrapper.safeSSTORE(\n            bytes32(uint256(0)),\n            bytes32(uint256(uint160(_implementation)))\n        );\n    }\n\n    function _getImplementation()\n        internal\n        returns (\n            address _implementation\n        )\n    {\n        return address(uint160(uint256(\n            Lib_SafeExecutionManagerWrapper.safeSLOAD(\n                bytes32(uint256(0))\n            )\n        )));\n    }\n\n    function _setOwner(\n        address _owner\n    )\n        internal\n    {\n        Lib_SafeExecutionManagerWrapper.safeSSTORE(\n            bytes32(uint256(1)),\n            bytes32(uint256(uint160(_owner)))\n        );\n    }\n\n    function _getOwner()\n        internal\n        returns (\n            address _owner\n        )\n    {\n        return address(uint160(uint256(\n            Lib_SafeExecutionManagerWrapper.safeSLOAD(\n                bytes32(uint256(1))\n            )\n        )));\n    }\n}"
    }
  ]
}