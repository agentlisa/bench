{
  "Title": "[C03] Anyone can partially bypass the FEI sell penalty to earn a profit",
  "Content": "The [`UniswapIncentive` contract](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/token/UniswapIncentive.sol) defines the incentives to be applied when users buy or sell `FEI` tokens in the `ETH/FEI` Uniswap pool. On the one hand, when a user sells tokens and causes a deviation in the price peg, a sell penalty is applied and the protocol burns a portion of their tokens. This penalty is calculated using the following formulas:\n\n\n![](https://i0.wp.com/blog.openzeppelin.com/wp-content/uploads/2021/02/fei-sell-penalty.png?w=840&ssl=1)\n\n\n![](https://i0.wp.com/blog.openzeppelin.com/wp-content/uploads/2021/02/fei-sell-incentive-multiplier.png?w=840&ssl=1)\n\n\nWhere `deviation` is the price deviation from the peg caused by selling an `amountSold` amount, and `amountSold` is the amount sold by the user. This sell penalty will be burned from the userâ€™s account after the sell operation is performed.\n\n\nOn the other hand, when a user buys `FEI` tokens to move the price back towards the peg, a buy incentive is applied and the protocol mints tokens to them. This incentive is calculated as follows:\n\n\n![](https://i0.wp.com/blog.openzeppelin.com/wp-content/uploads/2021/02/fei-buy-incentive.png?w=840&ssl=1)\n\n\nWhere `deviation` is the price deviation from the peg before buying the `amountBought` amount, `weight` is the [time-weighted function](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/token/UniswapIncentive.sol#L84-L92), [`timeGranularity`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/token/UniswapIncentive.sol#L27) is the granularity, and [`sellIncentiveMultiplier`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/token/UniswapIncentive.sol#L206) is the sell penalty multiplier described above. Notably, when the [`buyIncentiveMultiplier` is equal or greater than the `sellIncentiveMultiplier`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/token/UniswapIncentive.sol#L199), [incentive parity is reached](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/token/UniswapIncentive.sol#L102), and the `EthUniswapPCVController` contract may be able to [do a reweight](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pcv/EthUniswapPCVController.sol#L78) to move the price back to the peg if necessary.\n\n\nSince the `sellIncentiveMultiplier` function is quadratic, performing several small sell operations results in a considerably lower total penalty than performing one large sell operation, each of which take the `FEI` price from `deviation A` to `deviation B`.  \n\nThis means that an attacker would be able to buy a `X` amount of `FEI` to move the price from `deviation B` to `deviation A` and get the buy incentive described above (capped at the sell incentive multiplier), and then sell the same `X` amount of `FEI` in multiple sell operations to move the price back from `deviation A` to `deviation B`. This could significantly reduce the sell penalty, and the attacker will retain a profit. Notably, the maximum profit will be reached when the incentive parity is reached.\n\n\nMoreover, since performing a buy operation in the first place will either [decrease](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/token/UniswapIncentive.sol#L228-L237) or [reset](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/token/UniswapIncentive.sol#L219) the time-weight function, other users may not have enough incentive to move the price back to the peg, and since there will no longer be incentive parity, the `EthUniswapPCVController` will not be able to do a conventional reweight, instead having to use the [force reweight](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pcv/EthUniswapPCVController.sol#L59) function.\n\n\nConsider revising the sell incentive multiplier formula so that multiple sell operations will not decrease the sell penalty, or consider revising the buy incentive multiplier so that even after performing multiple sell operations, the attack is not profitable.\n\n\n**Update:** *Fixed in [PR#63](https://github.com/fei-protocol/fei-protocol-core/pull/63). The buy incentive multiplier was capped to 30% of the sell incentive multiplier to make this attack unprofitable.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/token/UniswapIncentive.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"./IUniswapIncentive.sol\";\nimport \"../utils/SafeMath32.sol\";\nimport \"../refs/UniRef.sol\";\nimport \"../oracle/IOracle.sol\";\n\n/// @title IUniswapIncentive implementation\n/// @author Fei Protocol\ncontract UniswapIncentive is IUniswapIncentive, UniRef {\n\tusing Decimal for Decimal.D256;\n    using SafeMath32 for uint32;\n    using SafeCast for uint;\n\n    struct TimeWeightInfo {\n        uint32 blockNo;\n        uint32 weight;\n        uint32 growthRate;\n        bool active;\n    }\n\n    TimeWeightInfo private timeWeightInfo;\n\n    uint32 public constant override TIME_WEIGHT_GRANULARITY = 100_000;\n\n    mapping(address => bool) private _exempt;\n\n    /// @notice UniswapIncentive constructor\n    /// @param _core Fei Core to reference\n    /// @param _oracle Oracle to reference\n    /// @param _pair Uniswap Pair to incentivize\n    /// @param _router Uniswap Router\n\tconstructor(\n        address _core, \n        address _oracle, \n        address _pair, \n        address _router,\n        uint32 _growthRate\n    ) public UniRef(_core, _pair, _router, _oracle) {\n        _setTimeWeight(0, _growthRate, false);    \n    }\n\n    function incentivize(\n    \taddress sender, \n    \taddress receiver, \n    \taddress, \n    \tuint amountIn\n    ) external override onlyFei {\n        updateOracle();\n\n    \tif (isPair(sender)) {\n    \t\tincentivizeBuy(receiver, amountIn);\n    \t}\n\n    \tif (isPair(receiver)) {\n    \t\tincentivizeSell(sender, amountIn);\n    \t}\n    }\n\n    function setExemptAddress(address account, bool isExempt) external override onlyGovernor {\n    \t_exempt[account] = isExempt;\n        emit ExemptAddressUpdate(account, isExempt);\n    }\n\n    function setTimeWeightGrowth(uint32 growthRate) external override onlyGovernor {\n        TimeWeightInfo memory tw = timeWeightInfo;\n        timeWeightInfo = TimeWeightInfo(tw.blockNo, tw.weight, growthRate, tw.active);\n        emit GrowthRateUpdate(growthRate);\n    }\n\n    function setTimeWeight(uint32 weight, uint32 growth, bool active) external override onlyGovernor {\n        _setTimeWeight(weight, growth, active);\n        // TimeWeightInfo memory tw = timeWeightInfo;\n        // timeWeightInfo = TimeWeightInfo(blockNo, tw.weight, tw.growthRate, tw.active);\n    }\n\n    function getGrowthRate() public view override returns (uint32) {\n        return timeWeightInfo.growthRate;\n    }\n\n    function getTimeWeight() public view override returns (uint32) {\n        TimeWeightInfo memory tw = timeWeightInfo;\n        if (!tw.active) {\n            return 0;\n        }\n\n        uint32 blockDelta = block.number.toUint32().sub(tw.blockNo);\n        return tw.weight.add(blockDelta * tw.growthRate);\n    }\n\n    function isTimeWeightActive() public view override returns (bool) {\n    \treturn timeWeightInfo.active;\n    }\n\n    function isExemptAddress(address account) public view override returns (bool) {\n    \treturn _exempt[account];\n    }\n\n    function isIncentiveParity() public view override returns (bool) {\n        uint32 weight = getTimeWeight();\n        require(weight != 0, \"UniswapIncentive: Incentive zero or not active\");\n\n        (Decimal.D256 memory price,,) = getUniswapPrice();\n        Decimal.D256 memory deviation = calculateDeviation(price, peg());\n        require(!deviation.equals(Decimal.zero()), \"UniswapIncentive: Price already at or above peg\");\n\n        Decimal.D256 memory incentive = calculateBuyIncentiveMultiplier(deviation, weight);\n        Decimal.D256 memory penalty = calculateSellPenaltyMultiplier(deviation);\n        return incentive.equals(penalty);\n    }\n\n    function getBuyIncentive(uint amount) public view override returns(\n        uint incentive, \n        uint32 weight,\n        Decimal.D256 memory initialDeviation,\n        Decimal.D256 memory finalDeviation\n    ) {\n        (initialDeviation, finalDeviation) = getPriceDeviations(-1 * int256(amount));\n        weight = getTimeWeight();\n\n        if (initialDeviation.equals(Decimal.zero())) {\n            return (0, weight, initialDeviation, finalDeviation);\n        }\n\n        uint incentivizedAmount = amount;\n        if (finalDeviation.equals(Decimal.zero())) {\n            incentivizedAmount = getAmountToPegFei();\n        }\n\n        Decimal.D256 memory multiplier = calculateBuyIncentiveMultiplier(initialDeviation, weight);\n        incentive = multiplier.mul(incentivizedAmount).asUint256();\n        return (incentive, weight, initialDeviation, finalDeviation);\n    }\n\n    function getSellPenalty(uint amount) public view override returns(\n        uint penalty, \n        Decimal.D256 memory initialDeviation,\n        Decimal.D256 memory finalDeviation\n    ) {\n        (initialDeviation, finalDeviation) = getPriceDeviations(int256(amount));\n\n        if (finalDeviation.equals(Decimal.zero())) {\n            return (0, initialDeviation, finalDeviation);\n        }\n\n        uint incentivizedAmount = amount;\n        if (initialDeviation.equals(Decimal.zero())) {\n            uint amountToPeg = getAmountToPegFei();\n            require(amount >= amountToPeg, \"UniswapIncentive: Underflow\");\n            incentivizedAmount = amount - amountToPeg;\n        }\n\n        Decimal.D256 memory multiplier = calculateSellPenaltyMultiplier(finalDeviation); \n        penalty = multiplier.mul(incentivizedAmount).asUint256(); \n        return (penalty, initialDeviation, finalDeviation);   \n    }\n\n    function incentivizeBuy(address target, uint amountIn) internal ifMinterSelf {\n    \tif (isExemptAddress(target)) {\n    \t\treturn;\n    \t}\n\n        (uint incentive, uint32 weight,\n        Decimal.D256 memory initialDeviation, \n        Decimal.D256 memory finalDeviation) = getBuyIncentive(amountIn);\n\n        updateTimeWeight(initialDeviation, finalDeviation, weight);\n        if (incentive != 0) {\n            fei().mint(target, incentive);         \n        }\n    }\n\n    function incentivizeSell(address target, uint amount) internal ifBurnerSelf {\n    \tif (isExemptAddress(target)) {\n    \t\treturn;\n    \t}\n\n        (uint penalty, Decimal.D256 memory initialDeviation,\n        Decimal.D256 memory finalDeviation) = getSellPenalty(amount);\n\n        uint32 weight = getTimeWeight();\n        updateTimeWeight(initialDeviation, finalDeviation, weight);\n\n        if (penalty != 0) {\n            fei().burnFrom(target, penalty);\n        }\n    }\n\n    function calculateBuyIncentiveMultiplier(\n        Decimal.D256 memory deviation,\n        uint32 weight\n    ) internal pure returns (Decimal.D256 memory) {\n        Decimal.D256 memory correspondingPenalty = calculateSellPenaltyMultiplier(deviation);\n        Decimal.D256 memory buyMultiplier = deviation.mul(uint(weight)).div(uint(TIME_WEIGHT_GRANULARITY));\n        \n        if (correspondingPenalty.lessThan(buyMultiplier)) {\n            return correspondingPenalty;\n        }\n        \n        return buyMultiplier;\n    }\n\n    function calculateSellPenaltyMultiplier(\n        Decimal.D256 memory deviation\n    ) internal pure returns (Decimal.D256 memory) {\n        return deviation.mul(deviation).mul(100); // m^2 * 100\n    }\n\n    function updateTimeWeight (\n        Decimal.D256 memory initialDeviation, \n        Decimal.D256 memory finalDeviation, \n        uint32 currentWeight\n    ) internal {\n        // Reset after completion\n        if (finalDeviation.equals(Decimal.zero())) {\n            _setTimeWeight(0, getGrowthRate(), false);\n            return;\n        } \n        // Init\n        if (initialDeviation.equals(Decimal.zero())) {\n            _setTimeWeight(0, getGrowthRate(), true);\n            return;\n        }\n\n        uint updatedWeight = uint(currentWeight);\n        // Partial buy\n        if (initialDeviation.greaterThan(finalDeviation)) {\n            Decimal.D256 memory remainingRatio = finalDeviation.div(initialDeviation);\n            updatedWeight = remainingRatio.mul(uint(currentWeight)).asUint256();\n        }\n        \n        uint maxWeight = finalDeviation.mul(100).mul(uint(TIME_WEIGHT_GRANULARITY)).asUint256(); // m^2*100 (sell) = t*m (buy) \n        updatedWeight = Math.min(updatedWeight, maxWeight);\n        _setTimeWeight(updatedWeight.toUint32(), getGrowthRate(), true);\n    }\n\n    function _setTimeWeight(uint32 weight, uint32 growthRate, bool active) internal {\n        uint32 currentGrowth = getGrowthRate();\n\n        uint32 blockNo = block.number.toUint32();\n\n        timeWeightInfo = TimeWeightInfo(blockNo, weight, growthRate, active);\n\n        emit TimeWeightUpdate(weight, active);   \n        if (currentGrowth != growthRate) {\n            emit GrowthRateUpdate(growthRate);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/token/UniswapIncentive.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"./IUniswapIncentive.sol\";\nimport \"../utils/SafeMath32.sol\";\nimport \"../refs/UniRef.sol\";\nimport \"../oracle/IOracle.sol\";\n\n/// @title IUniswapIncentive implementation\n/// @author Fei Protocol\ncontract UniswapIncentive is IUniswapIncentive, UniRef {\n\tusing Decimal for Decimal.D256;\n    using SafeMath32 for uint32;\n    using SafeCast for uint;\n\n    struct TimeWeightInfo {\n        uint32 blockNo;\n        uint32 weight;\n        uint32 growthRate;\n        bool active;\n    }\n\n    TimeWeightInfo private timeWeightInfo;\n\n    uint32 public constant override TIME_WEIGHT_GRANULARITY = 100_000;\n\n    mapping(address => bool) private _exempt;\n\n    /// @notice UniswapIncentive constructor\n    /// @param _core Fei Core to reference\n    /// @param _oracle Oracle to reference\n    /// @param _pair Uniswap Pair to incentivize\n    /// @param _router Uniswap Router\n\tconstructor(\n        address _core, \n        address _oracle, \n        address _pair, \n        address _router,\n        uint32 _growthRate\n    ) public UniRef(_core, _pair, _router, _oracle) {\n        _setTimeWeight(0, _growthRate, false);    \n    }\n\n    function incentivize(\n    \taddress sender, \n    \taddress receiver, \n    \taddress, \n    \tuint amountIn\n    ) external override onlyFei {\n        updateOracle();\n\n    \tif (isPair(sender)) {\n    \t\tincentivizeBuy(receiver, amountIn);\n    \t}\n\n    \tif (isPair(receiver)) {\n    \t\tincentivizeSell(sender, amountIn);\n    \t}\n    }\n\n    function setExemptAddress(address account, bool isExempt) external override onlyGovernor {\n    \t_exempt[account] = isExempt;\n        emit ExemptAddressUpdate(account, isExempt);\n    }\n\n    function setTimeWeightGrowth(uint32 growthRate) external override onlyGovernor {\n        TimeWeightInfo memory tw = timeWeightInfo;\n        timeWeightInfo = TimeWeightInfo(tw.blockNo, tw.weight, growthRate, tw.active);\n        emit GrowthRateUpdate(growthRate);\n    }\n\n    function setTimeWeight(uint32 weight, uint32 growth, bool active) external override onlyGovernor {\n        _setTimeWeight(weight, growth, active);\n        // TimeWeightInfo memory tw = timeWeightInfo;\n        // timeWeightInfo = TimeWeightInfo(blockNo, tw.weight, tw.growthRate, tw.active);\n    }\n\n    function getGrowthRate() public view override returns (uint32) {\n        return timeWeightInfo.growthRate;\n    }\n\n    function getTimeWeight() public view override returns (uint32) {\n        TimeWeightInfo memory tw = timeWeightInfo;\n        if (!tw.active) {\n            return 0;\n        }\n\n        uint32 blockDelta = block.number.toUint32().sub(tw.blockNo);\n        return tw.weight.add(blockDelta * tw.growthRate);\n    }\n\n    function isTimeWeightActive() public view override returns (bool) {\n    \treturn timeWeightInfo.active;\n    }\n\n    function isExemptAddress(address account) public view override returns (bool) {\n    \treturn _exempt[account];\n    }\n\n    function isIncentiveParity() public view override returns (bool) {\n        uint32 weight = getTimeWeight();\n        require(weight != 0, \"UniswapIncentive: Incentive zero or not active\");\n\n        (Decimal.D256 memory price,,) = getUniswapPrice();\n        Decimal.D256 memory deviation = calculateDeviation(price, peg());\n        require(!deviation.equals(Decimal.zero()), \"UniswapIncentive: Price already at or above peg\");\n\n        Decimal.D256 memory incentive = calculateBuyIncentiveMultiplier(deviation, weight);\n        Decimal.D256 memory penalty = calculateSellPenaltyMultiplier(deviation);\n        return incentive.equals(penalty);\n    }\n\n    function getBuyIncentive(uint amount) public view override returns(\n        uint incentive, \n        uint32 weight,\n        Decimal.D256 memory initialDeviation,\n        Decimal.D256 memory finalDeviation\n    ) {\n        (initialDeviation, finalDeviation) = getPriceDeviations(-1 * int256(amount));\n        weight = getTimeWeight();\n\n        if (initialDeviation.equals(Decimal.zero())) {\n            return (0, weight, initialDeviation, finalDeviation);\n        }\n\n        uint incentivizedAmount = amount;\n        if (finalDeviation.equals(Decimal.zero())) {\n            incentivizedAmount = getAmountToPegFei();\n        }\n\n        Decimal.D256 memory multiplier = calculateBuyIncentiveMultiplier(initialDeviation, weight);\n        incentive = multiplier.mul(incentivizedAmount).asUint256();\n        return (incentive, weight, initialDeviation, finalDeviation);\n    }\n\n    function getSellPenalty(uint amount) public view override returns(\n        uint penalty, \n        Decimal.D256 memory initialDeviation,\n        Decimal.D256 memory finalDeviation\n    ) {\n        (initialDeviation, finalDeviation) = getPriceDeviations(int256(amount));\n\n        if (finalDeviation.equals(Decimal.zero())) {\n            return (0, initialDeviation, finalDeviation);\n        }\n\n        uint incentivizedAmount = amount;\n        if (initialDeviation.equals(Decimal.zero())) {\n            uint amountToPeg = getAmountToPegFei();\n            require(amount >= amountToPeg, \"UniswapIncentive: Underflow\");\n            incentivizedAmount = amount - amountToPeg;\n        }\n\n        Decimal.D256 memory multiplier = calculateSellPenaltyMultiplier(finalDeviation); \n        penalty = multiplier.mul(incentivizedAmount).asUint256(); \n        return (penalty, initialDeviation, finalDeviation);   \n    }\n\n    function incentivizeBuy(address target, uint amountIn) internal ifMinterSelf {\n    \tif (isExemptAddress(target)) {\n    \t\treturn;\n    \t}\n\n        (uint incentive, uint32 weight,\n        Decimal.D256 memory initialDeviation, \n        Decimal.D256 memory finalDeviation) = getBuyIncentive(amountIn);\n\n        updateTimeWeight(initialDeviation, finalDeviation, weight);\n        if (incentive != 0) {\n            fei().mint(target, incentive);         \n        }\n    }\n\n    function incentivizeSell(address target, uint amount) internal ifBurnerSelf {\n    \tif (isExemptAddress(target)) {\n    \t\treturn;\n    \t}\n\n        (uint penalty, Decimal.D256 memory initialDeviation,\n        Decimal.D256 memory finalDeviation) = getSellPenalty(amount);\n\n        uint32 weight = getTimeWeight();\n        updateTimeWeight(initialDeviation, finalDeviation, weight);\n\n        if (penalty != 0) {\n            fei().burnFrom(target, penalty);\n        }\n    }\n\n    function calculateBuyIncentiveMultiplier(\n        Decimal.D256 memory deviation,\n        uint32 weight\n    ) internal pure returns (Decimal.D256 memory) {\n        Decimal.D256 memory correspondingPenalty = calculateSellPenaltyMultiplier(deviation);\n        Decimal.D256 memory buyMultiplier = deviation.mul(uint(weight)).div(uint(TIME_WEIGHT_GRANULARITY));\n        \n        if (correspondingPenalty.lessThan(buyMultiplier)) {\n            return correspondingPenalty;\n        }\n        \n        return buyMultiplier;\n    }\n\n    function calculateSellPenaltyMultiplier(\n        Decimal.D256 memory deviation\n    ) internal pure returns (Decimal.D256 memory) {\n        return deviation.mul(deviation).mul(100); // m^2 * 100\n    }\n\n    function updateTimeWeight (\n        Decimal.D256 memory initialDeviation, \n        Decimal.D256 memory finalDeviation, \n        uint32 currentWeight\n    ) internal {\n        // Reset after completion\n        if (finalDeviation.equals(Decimal.zero())) {\n            _setTimeWeight(0, getGrowthRate(), false);\n            return;\n        } \n        // Init\n        if (initialDeviation.equals(Decimal.zero())) {\n            _setTimeWeight(0, getGrowthRate(), true);\n            return;\n        }\n\n        uint updatedWeight = uint(currentWeight);\n        // Partial buy\n        if (initialDeviation.greaterThan(finalDeviation)) {\n            Decimal.D256 memory remainingRatio = finalDeviation.div(initialDeviation);\n            updatedWeight = remainingRatio.mul(uint(currentWeight)).asUint256();\n        }\n        \n        uint maxWeight = finalDeviation.mul(100).mul(uint(TIME_WEIGHT_GRANULARITY)).asUint256(); // m^2*100 (sell) = t*m (buy) \n        updatedWeight = Math.min(updatedWeight, maxWeight);\n        _setTimeWeight(updatedWeight.toUint32(), getGrowthRate(), true);\n    }\n\n    function _setTimeWeight(uint32 weight, uint32 growthRate, bool active) internal {\n        uint32 currentGrowth = getGrowthRate();\n\n        uint32 blockNo = block.number.toUint32();\n\n        timeWeightInfo = TimeWeightInfo(blockNo, weight, growthRate, active);\n\n        emit TimeWeightUpdate(weight, active);   \n        if (currentGrowth != growthRate) {\n            emit GrowthRateUpdate(growthRate);\n        }\n    }\n}"
    }
  ]
}