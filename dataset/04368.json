{
  "Title": "[M09] Calls to sellCompleteSets function in FillOrder contract can be unexpectedly reverted",
  "Content": "In the [`CompleteSets`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/CompleteSets.sol) [contract](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/CompleteSets.sol), the [`sellCompleteSets`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/CompleteSets.sol#L83) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/CompleteSets.sol#L83) is used to burn a complete set of outcome tokens in exchange for the underlying CASH token for a given market. This function is used by the `FillOrder` contract’s [`fillOrder`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/FillOrder.sol#L390) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/FillOrder.sol#L390) [when the parameter](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/FillOrder.sol#L404-L405) [`_ignoreShares`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/FillOrder.sol#L404-L405) [is set to false](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/FillOrder.sol#L404-L405).\n\n\nThe `sellCompleteSets` function, in [line 100](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/CompleteSets.sol#L100) of `CompleteSets.sol`, calls the [`destroyShares`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/ShareToken.sol#L48) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/ShareToken.sol#L48) which then calls the `VariableSupplyToken` contract’s [`burn`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/VariableSupplyToken.sol#L22) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/libraries/token/VariableSupplyToken.sol#L22), that in turn calls the [`ERC777`](https://eips.ethereum.org/EIPS/eip-777) [hook](https://eips.ethereum.org/EIPS/eip-777) on the `_sender` if the `_sender` is an ERC820-registered contract. This can be leveraged by a malicious `_sender` by reverting transactions when `sellCompleteSets` is called. This includes any calls to the [`fillOrder`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/FillOrder.sol#L390) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/trading/FillOrder.sol#L390) when the `_ignoreShares` parameter is set to false.\n\n\nConsider not calling the ERC777 token hooks when outcome tokens are burned by the `sellCompleteSets` function. This will eliminate the risk of a malicious party unexpectedly reverting transactions.\n\n\n***Update****: Fixed in* [*`c6eed38`*](https://github.com/AugurProject/augur/commit/c6eed38e36d2ca6f11d26175df05d9284e830936) *. The call to the* *`VariableSupplyToken`* *contract’s* *`burn`* *function no longer triggers the ERC777 hook.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "packages/augur-core/source/contracts/trading/CompleteSets.sol",
      "content": "pragma solidity 0.5.4;\n\n\nimport 'ROOT/trading/ICompleteSets.sol';\nimport 'ROOT/IAugur.sol';\nimport 'ROOT/libraries/ReentrancyGuard.sol';\nimport 'ROOT/libraries/math/SafeMathUint256.sol';\nimport 'ROOT/trading/ICash.sol';\nimport 'ROOT/reporting/IMarket.sol';\nimport 'ROOT/reporting/IDisputeWindow.sol';\nimport 'ROOT/reporting/IAuction.sol';\nimport 'ROOT/trading/IOrders.sol';\nimport 'ROOT/libraries/Initializable.sol';\nimport 'ROOT/IAugur.sol';\n\n\ncontract CompleteSets is Initializable, ReentrancyGuard, ICompleteSets {\n    using SafeMathUint256 for uint256;\n\n    IAugur public augur;\n    ICash public cash;\n    address public fillOrder;\n\n    function initialize(IAugur _augur) public beforeInitialized returns (bool) {\n        endInitialization();\n        augur = _augur;\n        fillOrder = augur.lookup(\"FillOrder\");\n        cash = ICash(augur.lookup(\"Cash\"));\n        return true;\n    }\n\n    /**\n     * Buys `_amount` shares of every outcome in the specified market.\n    **/\n    function publicBuyCompleteSets(IMarket _market, uint256 _amount) external afterInitialized returns (bool) {\n        this.buyCompleteSets(msg.sender, _market, _amount);\n        augur.logCompleteSetsPurchased(_market.getUniverse(), _market, msg.sender, _amount);\n        _market.assertBalances();\n        return true;\n    }\n\n    function publicBuyCompleteSetsWithCash(IMarket _market, uint256 _amount) external afterInitialized returns (bool) {\n        this.buyCompleteSets(msg.sender, _market, _amount);\n        augur.logCompleteSetsPurchased(_market.getUniverse(), _market, msg.sender, _amount);\n        _market.assertBalances();\n        return true;\n    }\n\n    function buyCompleteSets(address _sender, IMarket _market, uint256 _amount) external nonReentrant returns (bool) {\n        require(augur.isValidMarket(_market));\n        require(msg.sender == fillOrder || msg.sender == address(this));\n        require(_sender != address(0));\n\n        uint256 _numOutcomes = _market.getNumberOfOutcomes();\n\n        uint256 _cost = _amount.mul(_market.getNumTicks());\n        require(augur.trustedTransfer(cash, _sender, address(_market), _cost));\n        for (uint256 _outcome = 0; _outcome < _numOutcomes; ++_outcome) {\n            _market.getShareToken(_outcome).createShares(_sender, _amount);\n        }\n\n        if (!_market.isFinalized()) {\n            _market.getUniverse().incrementOpenInterest(_cost);\n        }\n\n        return true;\n    }\n\n    function publicSellCompleteSets(IMarket _market, uint256 _amount) external afterInitialized returns (bool) {\n        (uint256 _creatorFee, uint256 _reportingFee) = this.sellCompleteSets(msg.sender, _market, _amount, address(0));\n        augur.logCompleteSetsSold(_market.getUniverse(), _market, msg.sender, _amount, _creatorFee, _reportingFee);\n        _market.assertBalances();\n        return true;\n    }\n\n    function publicSellCompleteSetsWithCash(IMarket _market, uint256 _amount) external afterInitialized returns (bool) {\n        (uint256 _creatorFee, uint256 _reportingFee) = this.sellCompleteSets(msg.sender, _market, _amount, address(0));\n        augur.logCompleteSetsSold(_market.getUniverse(), _market, msg.sender, _amount, _creatorFee, _reportingFee);\n        _market.assertBalances();\n        return true;\n    }\n\n    function sellCompleteSets(address _sender, IMarket _market, uint256 _amount, address _affiliateAddress) external afterInitialized nonReentrant returns (uint256 _creatorFee, uint256 _reportingFee) {\n        require(augur.isValidMarket(_market));\n        require(msg.sender == fillOrder || msg.sender == address(this));\n        require(_sender != address(0));\n\n        uint256 _numOutcomes = _market.getNumberOfOutcomes();\n        uint256 _payout = _amount.mul(_market.getNumTicks());\n        if (!_market.isFinalized()) {\n            _market.getUniverse().decrementOpenInterest(_payout);\n        }\n        _creatorFee = _market.deriveMarketCreatorFeeAmount(_payout);\n        uint256 _reportingFeeDivisor = _market.getUniverse().getOrCacheReportingFeeDivisor();\n        _reportingFee = _payout.div(_reportingFeeDivisor);\n        _payout = _payout.sub(_creatorFee).sub(_reportingFee);\n\n        // Takes shares away from participant and decreases the amount issued in the market since we're exchanging complete sets\n        for (uint256 _outcome = 0; _outcome < _numOutcomes; ++_outcome) {\n            _market.getShareToken(_outcome).destroyShares(_sender, _amount);\n        }\n\n        if (_creatorFee != 0) {\n            _market.recordMarketCreatorFees(_creatorFee, _affiliateAddress);\n        }\n        if (_reportingFee != 0) {\n            require(cash.transferFrom(address(_market), address(_market.getUniverse().getOrCreateNextDisputeWindow(false)), _reportingFee));\n        }\n        require(cash.transferFrom(address(_market), _sender, _payout));\n\n        return (_creatorFee, _reportingFee);\n    }\n}"
    }
  ]
}