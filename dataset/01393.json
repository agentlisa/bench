{
  "Title": "`CurveProxy` contract needs to be approved by Curve DAO",
  "Content": "##### Description\n\nThere is the following line in the methods for blocking CRV tokens (in Curve vesting contract):\n```\nself.assert_not_contract(msg.sender)\n```\n\n- https://github.com/prisma-fi/prisma-contracts/blob/c0122d27677cd4e1aaee7f1e21f807ccadf46ac8/contracts/staking/Curve/CurveProxy.sol#L307\n\nIn order to make`CurveProxy` work, you need to get an approval from the Curve DAO.\n\n##### Recommendation\n\nWe recommend documenting the CurveProxy deployment process.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/staking/Curve/CurveProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../../interfaces/IGaugeController.sol\";\nimport \"../../interfaces/ILiquidityGauge.sol\";\nimport \"../../dependencies/PrismaOwnable.sol\";\n\ninterface IVotingEscrow {\n    function create_lock(uint256 amount, uint256 unlock_time) external;\n\n    function increase_amount(uint256 amount) external;\n\n    function increase_unlock_time(uint256 unlock_time) external;\n}\n\ninterface IMinter {\n    function mint(address gauge) external;\n}\n\ninterface IFeeDistributor {\n    function claim() external returns (uint256);\n\n    function token() external view returns (address);\n}\n\ninterface IAragon {\n    function vote(uint256 _voteData, bool _supports, bool _executesIfDecided) external;\n}\n\n/**\n    @title Prisma Curve Proxy\n    @notice Locks CRV in Curve's `VotingEscrow` and interacts with various Curve\n            contracts that require / provide benefit from the locked CRV position.\n */\ncontract CurveProxy is PrismaOwnable {\n    using Address for address;\n    using SafeERC20 for IERC20;\n\n    event CrvFeePctSet(uint256 feePct);\n\n    IERC20 public immutable CRV;\n    IGaugeController public immutable gaugeController;\n    IMinter public immutable minter;\n    IVotingEscrow public immutable votingEscrow;\n    IFeeDistributor public immutable feeDistributor;\n    IERC20 public immutable feeToken;\n\n    uint256 constant WEEK = 604800;\n    uint256 constant MAX_LOCK_DURATION = 4 * 365 * 86400; // 4 years\n\n    uint64 public crvFeePct; // fee as a pct out of 10000\n    uint64 public unlockTime;\n\n    // the vote manager is approved to call voting-related functions\n    // these functions are also callable directly by the owner\n    address public voteManager;\n\n    // the deposit manager is approved to call all gauge-related functionality\n    // and can permit other contracts to access the same functions on a per-gauge basis\n    address public depositManager;\n\n    // permission for contracts which can call gauge-related functionality for a single gauge\n    mapping(address caller => address gauge) public perGaugeApproval;\n\n    // permission for callers which can execute arbitrary calls via this contract's `execute` function\n    mapping(address caller => mapping(address target => mapping(bytes4 selector => bool))) executePermissions;\n\n    struct GaugeWeightVote {\n        address gauge;\n        uint256 weight;\n    }\n\n    struct TokenBalance {\n        IERC20 token;\n        uint256 amount;\n    }\n\n    constructor(\n        address _prismaCore,\n        IERC20 _CRV,\n        IGaugeController _gaugeController,\n        IMinter _minter,\n        IVotingEscrow _votingEscrow,\n        IFeeDistributor _feeDistributor\n    ) PrismaOwnable(_prismaCore) {\n        CRV = _CRV;\n        gaugeController = _gaugeController;\n        minter = _minter;\n        votingEscrow = _votingEscrow;\n        feeDistributor = _feeDistributor;\n        feeToken = IERC20(_feeDistributor.token());\n\n        CRV.approve(address(votingEscrow), type(uint256).max);\n    }\n\n    modifier ownerOrVoteManager() {\n        require(msg.sender == voteManager || msg.sender == owner(), \"Only owner or vote manager\");\n        _;\n    }\n\n    modifier onlyDepositManager() {\n        require(msg.sender == depositManager, \"Only deposit manager\");\n        _;\n    }\n\n    modifier onlyApprovedGauge(address gauge) {\n        require(perGaugeApproval[msg.sender] == gauge || msg.sender == depositManager, \"Not approved for gauge\");\n        _;\n    }\n\n    /**\n        @notice Grant or revoke permission for `caller` to call one or more\n                functions on `target` via this contract.\n     */\n    function setExecutePermissions(\n        address caller,\n        address target,\n        bytes4[] memory selectors,\n        bool permitted\n    ) external onlyOwner returns (bool) {\n        mapping(bytes4 => bool) storage _executePermission = executePermissions[caller][target];\n        for (uint256 i = 0; i < selectors.length; i++) {\n            _executePermission[selectors[i]] = permitted;\n        }\n        return true;\n    }\n\n    /**\n        @notice Set the fee percent taken on all CRV earned through this contract\n        @dev CRV earned as fees is periodically added to the contract's locked position\n     */\n    function setCrvFeePct(uint64 _feePct) external onlyOwner returns (bool) {\n        require(_feePct <= 10000, \"Invalid setting\");\n        crvFeePct = _feePct;\n        emit CrvFeePctSet(_feePct);\n        return true;\n    }\n\n    function setVoteManager(address _voteManager) external onlyOwner returns (bool) {\n        voteManager = _voteManager;\n\n        return true;\n    }\n\n    function setDepositManager(address _depositManager) external onlyOwner returns (bool) {\n        depositManager = _depositManager;\n\n        return true;\n    }\n\n    function setPerGaugeApproval(address caller, address gauge) external onlyDepositManager returns (bool) {\n        perGaugeApproval[caller] = gauge;\n\n        return true;\n    }\n\n    /**\n        @notice Claim pending 3CRV fees earned from the veCRV balance\n                and transfer the fees onward to the fee receiver\n        @dev This method is intentionally left unguarded\n     */\n    function claimFees() external returns (uint256) {\n        feeDistributor.claim();\n        uint256 amount = feeToken.balanceOf(address(this));\n\n        feeToken.transfer(PRISMA_CORE.feeReceiver(), amount);\n\n        return amount;\n    }\n\n    /**\n        @notice Lock any CRV balance within the contract, and extend\n                the unlock time to the maximum possible\n        @dev This method is intentionally left unguarded\n     */\n    function lockCRV() external returns (bool) {\n        uint256 maxUnlock = ((block.timestamp / WEEK) * WEEK) + MAX_LOCK_DURATION;\n        uint256 amount = CRV.balanceOf(address(this));\n\n        _updateLock(amount, unlockTime, maxUnlock);\n\n        return true;\n    }\n\n    /**\n        @notice Mint CRV rewards earned for a specific gauge\n        @dev Once per week, also locks any CRV balance within the contract and extends the lock duration\n        @param gauge Address of the gauge to mint CRV for\n        @param receiver Address to send the minted CRV to\n        @return uint256 Amount of CRV send to the receiver (after the fee)\n     */\n    function mintCRV(address gauge, address receiver) external onlyApprovedGauge(gauge) returns (uint256) {\n        uint256 initial = CRV.balanceOf(address(this));\n        minter.mint(gauge);\n        uint256 amount = CRV.balanceOf(address(this)) - initial;\n\n        // apply fee prior to transfer\n        uint256 fee = (amount * crvFeePct) / 10000;\n        amount -= fee;\n\n        CRV.transfer(receiver, amount);\n\n        // lock and extend if needed\n        uint256 unlock = unlockTime;\n        uint256 maxUnlock = ((block.timestamp / WEEK) * WEEK) + MAX_LOCK_DURATION;\n        if (unlock < maxUnlock) {\n            _updateLock(initial + fee, unlock, maxUnlock);\n        }\n\n        return amount;\n    }\n\n    /**\n        @notice Submit one or more gauge weight votes\n     */\n    function voteForGaugeWeights(GaugeWeightVote[] calldata votes) external ownerOrVoteManager returns (bool) {\n        for (uint256 i = 0; i < votes.length; i++) {\n            gaugeController.vote_for_gauge_weights(votes[i].gauge, votes[i].weight);\n        }\n\n        return true;\n    }\n\n    /**\n        @notice Submit a vote within the Curve DAO\n     */\n    function voteInCurveDao(IAragon aragon, uint256 id, bool support) external ownerOrVoteManager returns (bool) {\n        aragon.vote(id, support, false);\n\n        return true;\n    }\n\n    /**\n        @notice Approve a 3rd-party caller to deposit into a specific gauge\n        @dev Only required for some older Curve gauges\n     */\n    function approveGaugeDeposit(address gauge, address depositor) external onlyApprovedGauge(gauge) returns (bool) {\n        ILiquidityGauge(gauge).set_approve_deposit(depositor, true);\n\n        return true;\n    }\n\n    /**\n        @notice Set the default receiver for extra rewards on a specific gauge\n        @dev Only works on some gauge versions\n     */\n    function setGaugeRewardsReceiver(address gauge, address receiver) external onlyApprovedGauge(gauge) returns (bool) {\n        ILiquidityGauge(gauge).set_rewards_receiver(receiver);\n\n        return true;\n    }\n\n    /**\n        @notice Withdraw LP tokens from a gauge\n        @param gauge Address of the gauge to withdraw from\n        @param lpToken Address of the LP token we are withdrawing from the gauge.\n                       The contract trusts the caller to supply the correct address.\n        @param amount Amount of LP tokens to withdraw\n        @param receiver Address to send the LP token to\n     */\n    function withdrawFromGauge(\n        address gauge,\n        IERC20 lpToken,\n        uint256 amount,\n        address receiver\n    ) external onlyApprovedGauge(gauge) returns (bool) {\n        ILiquidityGauge(gauge).withdraw(amount);\n        lpToken.transfer(receiver, amount);\n\n        return true;\n    }\n\n    /**\n        @notice Transfer arbitrary token balances out of this contract\n        @dev Necessary for handling extra rewards on older gauge types\n     */\n    function transferTokens(\n        address receiver,\n        TokenBalance[] calldata balances\n    ) external onlyDepositManager returns (bool) {\n        for (uint256 i = 0; i < balances.length; i++) {\n            balances[i].token.safeTransfer(receiver, balances[i].amount);\n        }\n\n        return true;\n    }\n\n    /**\n        @notice Execute an arbitrary function call using this contract\n        @dev Callable via the owner, or if explicit permission is given\n             to the caller for this target and function selector\n     */\n    function execute(address target, bytes calldata data) external returns (bytes memory) {\n        if (msg.sender != owner()) {\n            bytes4 selector = bytes4(data[:4]);\n            require(executePermissions[msg.sender][target][selector], \"Not permitted\");\n        }\n        return target.functionCall(data);\n    }\n\n    function _updateLock(uint256 amount, uint256 unlock, uint256 maxUnlock) internal {\n        if (amount > 0) {\n            if (unlock == 0) {\n                votingEscrow.create_lock(amount, maxUnlock);\n                unlockTime = uint64(maxUnlock);\n                return;\n            }\n            votingEscrow.increase_amount(amount);\n        }\n        if (unlock < maxUnlock) {\n            votingEscrow.increase_unlock_time(maxUnlock);\n            unlockTime = uint64(maxUnlock);\n        }\n    }\n}"
    }
  ]
}