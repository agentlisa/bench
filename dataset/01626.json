{
  "Title": "M-14: Imbalanced approach of distributing the liquidation fee within `setSymbolsPrice` function",
  "Content": "# Issue M-14: Imbalanced approach of distributing the liquidation fee within `setSymbolsPrice` function \n\nSource: https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/231 \n\n## Found by \n0xGoodess, PokemonAuditSimulator, Yuki, cergyk, kutugu, rvierdiiev, xiaoming90\n## Summary\n\nThe imbalance approach of distributing the liquidation fee within `setSymbolsPrice` function could be exploited by malicious liquidators to obtain the liquidation fee without completing their tasks and maximizing their gains. While doing so, it causes harm or losses to other parties within the protocols.\n\n## Vulnerability Detail\n\nA PartyA can own a large number of different symbols in its portfolio. To avoid out-of-gas (OOG) errors from occurring during liquidation, the `setSymbolsPrice` function allows the liquidators to inject the price of the symbols in multiple transactions instead of all in one go.\n\nAssume that the injection of the price symbols requires 5 transactions/rounds to complete and populate the price of all the symbols in a PartyA's portfolio. Based on the current implementation, only the first liquidator that calls the `setSymbolsPrice` will receive the liquidation fee. Liquidators that call the `setSymbolsPrice` function subsequently will not be added to the `AccountStorage.layout().liquidators[partyA]` listing as Line 88 will only be executed once when the `liquidationType` is still not initialized yet.\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol#L34\n\n```solidity\nFile: LiquidationFacetImpl.sol\n34:     function setSymbolsPrice(address partyA, PriceSig memory priceSig) internal {\n..SNIP..\n56:         if (accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.NONE) {\n57:             accountLayout.liquidationDetails[partyA] = LiquidationDetail({\n58:                 liquidationType: LiquidationType.NONE,\n59:                 upnl: priceSig.upnl,\n60:                 totalUnrealizedLoss: priceSig.totalUnrealizedLoss,\n61:                 deficit: 0,\n62:                 liquidationFee: 0\n63:             });\n..SNIP..\n88:             AccountStorage.layout().liquidators[partyA].push(msg.sender);\n89:         } else {\n90:             require(\n91:                 accountLayout.liquidationDetails[partyA].upnl == priceSig.upnl &&\n92:                     accountLayout.liquidationDetails[partyA].totalUnrealizedLoss ==\n93:                     priceSig.totalUnrealizedLoss,\n94:                 \"LiquidationFacet: Invalid upnl sig\"\n95:             );\n96:         }\n97:     }\n```\n\nA malicious liquidator could take advantage of this by only setting the symbol prices for the first round for each liquidation happening in the protocol. To maximize their profits, the malicious liquidator would call the `setSymbolsPrice` with none or only one (1) symbol price to save on the gas cost. The malicious liquidator would then leave it to the others to complete the rest of the liquidation process, and they will receive half of the liquidation fee at the end of the liquidation process.\n\nSomeone would eventually need to step in to complete the liquidation process. Even if none of the liquidators is incentivized to complete the process of setting the symbol prices since they will not receive any liquidation fee, the counterparty would eventually have no choice but to step in to perform the liquidation themselves. Otherwise, the profits of the counterparty cannot be realized. At the end of the day, the liquidation will be completed, and the malicious liquidator will still receive the liquidation fee.\n\n## Impact\n\nMalicious liquidators could exploit the liquidation process to obtain the liquidation fee without completing their tasks and maximizing their gains. While doing so, many liquidations would be stuck halfway since it is likely that no other liquidators will step in to complete the setting of the symbol prices because they will not receive any liquidation fee for doing so (not incentivized).\n\nThis could potentially lead to the loss of assets for various parties:\n\n- The counterparty would eventually have no choice but to step in to perform the liquidation themselves. The counterparty has to pay for its own liquidation, even though it has already paid half the liquidation fee to the liquidator.\n- Many liquidations would be stuck halfway, and liquidation might be delayed, which exposes users to greater market risks, including the risk of incurring larger losses or having to exit at an unfavorable price. \n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol#L34\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider a more balanced approach for distributing the liquidation fee for liquidators that calls the `setSymbolsPrice` function. For instance, the liquidators should be compensated based on the number of symbol prices they have injected. \n\nIf there are 10 symbols to be filled up, if Bob filled up 4 out of 10 symbols, he should only receive 40% of the liquidation fee. This approach has already been implemented within the `liquidatePartyB` function via the `partyBPositionLiquidatorsShare` variable. Thus, the same design could be retrofitted into the `setSymbolsPrice` function.\n\n\n\n## Discussion\n\n**MoonKnightDev**\n\nIn the current system setup, we have established a role for liquidators. To give them this role, we might require an external contract in which they are obliged to lock a certain amount of money. This serves as a guarantee against any potential system sabotage or incomplete liquidation they may commit. If they fail to fulfill their role appropriately, they would face penalties.\n\n**hrishibhat**\n\n@xiaoming9090 Based on the above comment there are no restrictions applied on liquidators currently and there is the possibility of malicious actions by the liquidator, correct?\n\n**hrishibhat**\n\nConsidering this issue as a valid medium, although the `liquidator role` is an external role and is restricted, it is still granted by the protocol. \n\n**Navid-Fkh**\n\nWe don't consider this to be an issue in the system for two obvious reasons:\n\n1. The liquidator has an incentive to complete the process in order to claim their LF.\n2. Malicious liquidators can be easily identified and punished. Given that we have defined a liquidator role, it's probable that they have locked funds with us as a prerequisite for that role\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/85",
  "Code": [
    {
      "filename": "symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../../libraries/LibLockedValues.sol\";\nimport \"../../libraries/LibMuon.sol\";\nimport \"../../libraries/LibAccount.sol\";\nimport \"../../libraries/LibQuote.sol\";\nimport \"../../storages/MAStorage.sol\";\nimport \"../../storages/QuoteStorage.sol\";\nimport \"../../storages/MuonStorage.sol\";\nimport \"../../storages/AccountStorage.sol\";\nimport \"../../storages/SymbolStorage.sol\";\n\nlibrary LiquidationFacetImpl {\n    using LockedValuesOps for LockedValues;\n\n    function liquidatePartyA(address partyA, SingleUpnlSig memory upnlSig) internal {\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n\n        LibMuon.verifyPartyAUpnl(upnlSig, partyA);\n        int256 availableBalance = LibAccount.partyAAvailableBalanceForLiquidation(\n            upnlSig.upnl,\n            partyA\n        );\n        require(availableBalance < 0, \"LiquidationFacet: PartyA is solvent\");\n        maLayout.liquidationStatus[partyA] = true;\n        maLayout.liquidationTimestamp[partyA] = upnlSig.timestamp;\n        AccountStorage.layout().liquidators[partyA].push(msg.sender);\n    }\n\n    function setSymbolsPrice(address partyA, PriceSig memory priceSig) internal {\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        LibMuon.verifyPrices(priceSig, partyA);\n        require(maLayout.liquidationStatus[partyA], \"LiquidationFacet: PartyA is solvent\");\n        require(\n            priceSig.timestamp <=\n                maLayout.liquidationTimestamp[partyA] + maLayout.liquidationTimeout,\n            \"LiquidationFacet: Expired signature\"\n        );\n        for (uint256 index = 0; index < priceSig.symbolIds.length; index++) {\n            accountLayout.symbolsPrices[partyA][priceSig.symbolIds[index]] = Price(\n                priceSig.prices[index],\n                maLayout.liquidationTimestamp[partyA]\n            );\n        }\n\n        int256 availableBalance = LibAccount.partyAAvailableBalanceForLiquidation(\n            priceSig.upnl,\n            partyA\n        );\n        if (accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.NONE) {\n            accountLayout.liquidationDetails[partyA] = LiquidationDetail({\n                liquidationType: LiquidationType.NONE,\n                upnl: priceSig.upnl,\n                totalUnrealizedLoss: priceSig.totalUnrealizedLoss,\n                deficit: 0,\n                liquidationFee: 0\n            });\n            if (availableBalance >= 0) {\n                uint256 remainingLf = accountLayout.lockedBalances[partyA].lf;\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.NORMAL;\n                accountLayout.liquidationDetails[partyA].liquidationFee = remainingLf;\n            } else if (uint256(-availableBalance) < accountLayout.lockedBalances[partyA].lf) {\n                uint256 remainingLf = accountLayout.lockedBalances[partyA].lf -\n                    uint256(-availableBalance);\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.NORMAL;\n                accountLayout.liquidationDetails[partyA].liquidationFee = remainingLf;\n            } else if (\n                uint256(-availableBalance) <=\n                accountLayout.lockedBalances[partyA].lf + accountLayout.lockedBalances[partyA].cva\n            ) {\n                uint256 deficit = uint256(-availableBalance) -\n                    accountLayout.lockedBalances[partyA].lf;\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.LATE;\n                accountLayout.liquidationDetails[partyA].deficit = deficit;\n            } else {\n                uint256 deficit = uint256(-availableBalance) -\n                    accountLayout.lockedBalances[partyA].lf -\n                    accountLayout.lockedBalances[partyA].cva;\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.OVERDUE;\n                accountLayout.liquidationDetails[partyA].deficit = deficit;\n            }\n            AccountStorage.layout().liquidators[partyA].push(msg.sender);\n        } else {\n            require(\n                accountLayout.liquidationDetails[partyA].upnl == priceSig.upnl &&\n                    accountLayout.liquidationDetails[partyA].totalUnrealizedLoss ==\n                    priceSig.totalUnrealizedLoss,\n                \"LiquidationFacet: Invalid upnl sig\"\n            );\n        }\n    }\n\n    function liquidatePendingPositionsPartyA(address partyA) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        require(\n            MAStorage.layout().liquidationStatus[partyA],\n            \"LiquidationFacet: PartyA is solvent\"\n        );\n        for (uint256 index = 0; index < quoteLayout.partyAPendingQuotes[partyA].length; index++) {\n            Quote storage quote = quoteLayout.quotes[\n                quoteLayout.partyAPendingQuotes[partyA][index]\n            ];\n            if (\n                (quote.quoteStatus == QuoteStatus.LOCKED ||\n                    quote.quoteStatus == QuoteStatus.CANCEL_PENDING) &&\n                quoteLayout.partyBPendingQuotes[quote.partyB][partyA].length > 0\n            ) {\n                delete quoteLayout.partyBPendingQuotes[quote.partyB][partyA];\n                AccountStorage\n                .layout()\n                .partyBPendingLockedBalances[quote.partyB][partyA].makeZero();\n            }\n            quote.quoteStatus = QuoteStatus.LIQUIDATED;\n            quote.modifyTimestamp = block.timestamp;\n        }\n        AccountStorage.layout().pendingLockedBalances[partyA].makeZero();\n        delete quoteLayout.partyAPendingQuotes[partyA];\n    }\n\n    function liquidatePositionsPartyA(\n        address partyA,\n        uint256[] memory quoteIds\n    ) internal returns (bool) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n\n        require(maLayout.liquidationStatus[partyA], \"LiquidationFacet: PartyA is solvent\");\n        for (uint256 index = 0; index < quoteIds.length; index++) {\n            Quote storage quote = quoteLayout.quotes[quoteIds[index]];\n            require(\n                quote.quoteStatus == QuoteStatus.OPENED ||\n                    quote.quoteStatus == QuoteStatus.CLOSE_PENDING ||\n                    quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n                \"LiquidationFacet: Invalid state\"\n            );\n            require(quote.partyA == partyA, \"LiquidationFacet: Invalid party\");\n            require(\n                accountLayout.symbolsPrices[partyA][quote.symbolId].timestamp ==\n                    maLayout.liquidationTimestamp[partyA],\n                \"LiquidationFacet: Price should be set\"\n            );\n            quote.quoteStatus = QuoteStatus.LIQUIDATED;\n            quote.modifyTimestamp = block.timestamp;\n\n            (bool hasMadeProfit, uint256 amount) = LibQuote.getValueOfQuoteForPartyA(\n                accountLayout.symbolsPrices[partyA][quote.symbolId].price,\n                LibQuote.quoteOpenAmount(quote),\n                quote\n            );\n            if (hasMadeProfit) {\n                accountLayout.totalUnplForLiquidation[partyA] += int256(amount);\n            } else {\n                accountLayout.totalUnplForLiquidation[partyA] -= int256(amount);\n            }\n\n            if (\n                accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.NORMAL\n            ) {\n                accountLayout.partyBAllocatedBalances[quote.partyB][partyA] += quote\n                    .lockedValues\n                    .cva;\n                if (hasMadeProfit) {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] -= amount;\n                } else {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] += amount;\n                }\n            } else if (\n                accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.LATE\n            ) {\n                accountLayout.partyBAllocatedBalances[quote.partyB][partyA] +=\n                    quote.lockedValues.cva -\n                    ((quote.lockedValues.cva * accountLayout.liquidationDetails[partyA].deficit) /\n                        accountLayout.lockedBalances[partyA].cva);\n                if (hasMadeProfit) {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] -= amount;\n                } else {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] += amount;\n                }\n            } else if (\n                accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.OVERDUE\n            ) {\n                if (hasMadeProfit) {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] -= amount;\n                } else {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] +=\n                        amount -\n                        ((amount * accountLayout.liquidationDetails[partyA].deficit) /\n                            uint256(-accountLayout.liquidationDetails[partyA].totalUnrealizedLoss));\n                }\n            }\n            accountLayout.partyBLockedBalances[quote.partyB][partyA].subQuote(quote);\n            quote.avgClosedPrice =\n                (quote.avgClosedPrice *\n                    quote.closedAmount +\n                    LibQuote.quoteOpenAmount(quote) *\n                    accountLayout.symbolsPrices[partyA][quote.symbolId].price) /\n                (quote.closedAmount + LibQuote.quoteOpenAmount(quote));\n            quote.closedAmount = quote.quantity;\n\n            LibQuote.removeFromOpenPositions(quote.id);\n            quoteLayout.partyAPositionsCount[partyA] -= 1;\n            quoteLayout.partyBPositionsCount[quote.partyB][partyA] -= 1;\n        }\n        if (quoteLayout.partyAPositionsCount[partyA] == 0) {\n            require(\n                quoteLayout.partyAPendingQuotes[partyA].length == 0,\n                \"LiquidationFacet: Pending quotes should be liquidated first\"\n            );\n            accountLayout.allocatedBalances[partyA] = 0;\n            accountLayout.lockedBalances[partyA].makeZero();\n\n            uint256 lf = accountLayout.liquidationDetails[partyA].liquidationFee;\n            if (lf > 0) {\n                accountLayout.allocatedBalances[accountLayout.liquidators[partyA][0]] += lf / 2;\n                accountLayout.allocatedBalances[accountLayout.liquidators[partyA][1]] += lf / 2;\n            }\n            delete accountLayout.liquidators[partyA];\n            maLayout.liquidationStatus[partyA] = false;\n            maLayout.liquidationTimestamp[partyA] = 0;\n            accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.NONE;\n            if (\n                accountLayout.totalUnplForLiquidation[partyA] !=\n                accountLayout.liquidationDetails[partyA].upnl\n            ) {\n                accountLayout.totalUnplForLiquidation[partyA] = 0;\n                return false;\n            }\n            accountLayout.totalUnplForLiquidation[partyA] = 0;\n        }\n        return true;\n    }\n\n    function liquidatePartyB(\n        address partyB,\n        address partyA,\n        SingleUpnlSig memory upnlSig\n    ) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n\n        LibMuon.verifyPartyBUpnl(upnlSig, partyB, partyA);\n        int256 availableBalance = LibAccount.partyBAvailableBalanceForLiquidation(\n            upnlSig.upnl,\n            partyB,\n            partyA\n        );\n\n        require(availableBalance < 0, \"LiquidationFacet: partyB is solvent\");\n        uint256 liquidatorShare;\n        uint256 remainingLf;\n        if (uint256(-availableBalance) < accountLayout.partyBLockedBalances[partyB][partyA].lf) {\n            remainingLf =\n                accountLayout.partyBLockedBalances[partyB][partyA].lf -\n                uint256(-availableBalance);\n            liquidatorShare = (remainingLf * maLayout.liquidatorShare) / 1e18;\n\n            maLayout.partyBPositionLiquidatorsShare[partyB][partyA] =\n                (remainingLf - liquidatorShare) /\n                quoteLayout.partyBPositionsCount[partyB][partyA];\n        } else {\n            maLayout.partyBPositionLiquidatorsShare[partyB][partyA] = 0;\n        }\n\n        maLayout.partyBLiquidationStatus[partyB][partyA] = true;\n        maLayout.partyBLiquidationTimestamp[partyB][partyA] = upnlSig.timestamp;\n\n        uint256[] storage pendingQuotes = quoteLayout.partyAPendingQuotes[partyA];\n\n        for (uint256 index = 0; index < pendingQuotes.length; ) {\n            Quote storage quote = quoteLayout.quotes[pendingQuotes[index]];\n            if (\n                quote.partyB == partyB &&\n                (quote.quoteStatus == QuoteStatus.LOCKED ||\n                    quote.quoteStatus == QuoteStatus.CANCEL_PENDING)\n            ) {\n                accountLayout.pendingLockedBalances[partyA].subQuote(quote);\n\n                pendingQuotes[index] = pendingQuotes[pendingQuotes.length - 1];\n                pendingQuotes.pop();\n                quote.quoteStatus = QuoteStatus.LIQUIDATED;\n                quote.modifyTimestamp = block.timestamp;\n            } else {\n                index++;\n            }\n        }\n        accountLayout.allocatedBalances[partyA] +=\n            accountLayout.partyBAllocatedBalances[partyB][partyA] -\n            remainingLf;\n\n        delete quoteLayout.partyBPendingQuotes[partyB][partyA];\n        accountLayout.partyBAllocatedBalances[partyB][partyA] = 0;\n        accountLayout.partyBLockedBalances[partyB][partyA].makeZero();\n        accountLayout.partyBPendingLockedBalances[partyB][partyA].makeZero();\n\n        if (liquidatorShare > 0) {\n            accountLayout.allocatedBalances[msg.sender] += liquidatorShare;\n        }\n    }\n\n    function liquidatePositionsPartyB(\n        address partyB,\n        address partyA,\n        QuotePriceSig memory priceSig\n    ) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n\n        LibMuon.verifyQuotePrices(priceSig);\n        require(\n            priceSig.timestamp <=\n                maLayout.partyBLiquidationTimestamp[partyB][partyA] + maLayout.liquidationTimeout,\n            \"LiquidationFacet: Expired signature\"\n        );\n        require(\n            maLayout.partyBLiquidationStatus[partyB][partyA],\n            \"LiquidationFacet: PartyB is solvent\"\n        );\n        require(\n            block.timestamp <= priceSig.timestamp + maLayout.liquidationTimeout,\n            \"LiquidationFacet: Expired price sig\"\n        );\n        for (uint256 index = 0; index < priceSig.quoteIds.length; index++) {\n            Quote storage quote = quoteLayout.quotes[priceSig.quoteIds[index]];\n            require(\n                quote.quoteStatus == QuoteStatus.OPENED ||\n                    quote.quoteStatus == QuoteStatus.CLOSE_PENDING ||\n                    quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n                \"LiquidationFacet: Invalid state\"\n            );\n            require(\n                quote.partyA == partyA && quote.partyB == partyB,\n                \"LiquidationFacet: Invalid party\"\n            );\n\n            quote.quoteStatus = QuoteStatus.LIQUIDATED;\n            quote.modifyTimestamp = block.timestamp;\n\n            // accountLayout.allocatedBalances[partyA] += quote.lockedValues.cva;\n            accountLayout.lockedBalances[partyA].subQuote(quote);\n\n            // (bool hasMadeProfit, uint256 amount) = LibQuote.getValueOfQuoteForPartyA(\n            //     priceSig.prices[index],\n            //     LibQuote.quoteOpenAmount(quote),\n            //     quote\n            // );\n\n            // if (hasMadeProfit) {\n            //     accountLayout.allocatedBalances[partyA] += amount;\n            // } else {\n            //     accountLayout.allocatedBalances[partyA] -= amount;\n            // }\n            quote.avgClosedPrice =\n                (quote.avgClosedPrice *\n                    quote.closedAmount +\n                    LibQuote.quoteOpenAmount(quote) *\n                    priceSig.prices[index]) /\n                (quote.closedAmount + LibQuote.quoteOpenAmount(quote));\n            quote.closedAmount = quote.quantity;\n\n            LibQuote.removeFromOpenPositions(quote.id);\n            quoteLayout.partyAPositionsCount[partyA] -= 1;\n            quoteLayout.partyBPositionsCount[partyB][partyA] -= 1;\n        }\n        if (maLayout.partyBPositionLiquidatorsShare[partyB][partyA] > 0) {\n            accountLayout.allocatedBalances[msg.sender] +=\n                maLayout.partyBPositionLiquidatorsShare[partyB][partyA] *\n                priceSig.quoteIds.length;\n        }\n\n        if (quoteLayout.partyBPositionsCount[partyB][partyA] == 0) {\n            maLayout.partyBLiquidationStatus[partyB][partyA] = false;\n            maLayout.partyBLiquidationTimestamp[partyB][partyA] = 0;\n        }\n    }\n}"
    },
    {
      "filename": "symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../../libraries/LibLockedValues.sol\";\nimport \"../../libraries/LibMuon.sol\";\nimport \"../../libraries/LibAccount.sol\";\nimport \"../../libraries/LibQuote.sol\";\nimport \"../../storages/MAStorage.sol\";\nimport \"../../storages/QuoteStorage.sol\";\nimport \"../../storages/MuonStorage.sol\";\nimport \"../../storages/AccountStorage.sol\";\nimport \"../../storages/SymbolStorage.sol\";\n\nlibrary LiquidationFacetImpl {\n    using LockedValuesOps for LockedValues;\n\n    function liquidatePartyA(address partyA, SingleUpnlSig memory upnlSig) internal {\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n\n        LibMuon.verifyPartyAUpnl(upnlSig, partyA);\n        int256 availableBalance = LibAccount.partyAAvailableBalanceForLiquidation(\n            upnlSig.upnl,\n            partyA\n        );\n        require(availableBalance < 0, \"LiquidationFacet: PartyA is solvent\");\n        maLayout.liquidationStatus[partyA] = true;\n        maLayout.liquidationTimestamp[partyA] = upnlSig.timestamp;\n        AccountStorage.layout().liquidators[partyA].push(msg.sender);\n    }\n\n    function setSymbolsPrice(address partyA, PriceSig memory priceSig) internal {\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        LibMuon.verifyPrices(priceSig, partyA);\n        require(maLayout.liquidationStatus[partyA], \"LiquidationFacet: PartyA is solvent\");\n        require(\n            priceSig.timestamp <=\n                maLayout.liquidationTimestamp[partyA] + maLayout.liquidationTimeout,\n            \"LiquidationFacet: Expired signature\"\n        );\n        for (uint256 index = 0; index < priceSig.symbolIds.length; index++) {\n            accountLayout.symbolsPrices[partyA][priceSig.symbolIds[index]] = Price(\n                priceSig.prices[index],\n                maLayout.liquidationTimestamp[partyA]\n            );\n        }\n\n        int256 availableBalance = LibAccount.partyAAvailableBalanceForLiquidation(\n            priceSig.upnl,\n            partyA\n        );\n        if (accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.NONE) {\n            accountLayout.liquidationDetails[partyA] = LiquidationDetail({\n                liquidationType: LiquidationType.NONE,\n                upnl: priceSig.upnl,\n                totalUnrealizedLoss: priceSig.totalUnrealizedLoss,\n                deficit: 0,\n                liquidationFee: 0\n            });\n            if (availableBalance >= 0) {\n                uint256 remainingLf = accountLayout.lockedBalances[partyA].lf;\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.NORMAL;\n                accountLayout.liquidationDetails[partyA].liquidationFee = remainingLf;\n            } else if (uint256(-availableBalance) < accountLayout.lockedBalances[partyA].lf) {\n                uint256 remainingLf = accountLayout.lockedBalances[partyA].lf -\n                    uint256(-availableBalance);\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.NORMAL;\n                accountLayout.liquidationDetails[partyA].liquidationFee = remainingLf;\n            } else if (\n                uint256(-availableBalance) <=\n                accountLayout.lockedBalances[partyA].lf + accountLayout.lockedBalances[partyA].cva\n            ) {\n                uint256 deficit = uint256(-availableBalance) -\n                    accountLayout.lockedBalances[partyA].lf;\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.LATE;\n                accountLayout.liquidationDetails[partyA].deficit = deficit;\n            } else {\n                uint256 deficit = uint256(-availableBalance) -\n                    accountLayout.lockedBalances[partyA].lf -\n                    accountLayout.lockedBalances[partyA].cva;\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.OVERDUE;\n                accountLayout.liquidationDetails[partyA].deficit = deficit;\n            }\n            AccountStorage.layout().liquidators[partyA].push(msg.sender);\n        } else {\n            require(\n                accountLayout.liquidationDetails[partyA].upnl == priceSig.upnl &&\n                    accountLayout.liquidationDetails[partyA].totalUnrealizedLoss ==\n                    priceSig.totalUnrealizedLoss,\n                \"LiquidationFacet: Invalid upnl sig\"\n            );\n        }\n    }\n\n    function liquidatePendingPositionsPartyA(address partyA) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        require(\n            MAStorage.layout().liquidationStatus[partyA],\n            \"LiquidationFacet: PartyA is solvent\"\n        );\n        for (uint256 index = 0; index < quoteLayout.partyAPendingQuotes[partyA].length; index++) {\n            Quote storage quote = quoteLayout.quotes[\n                quoteLayout.partyAPendingQuotes[partyA][index]\n            ];\n            if (\n                (quote.quoteStatus == QuoteStatus.LOCKED ||\n                    quote.quoteStatus == QuoteStatus.CANCEL_PENDING) &&\n                quoteLayout.partyBPendingQuotes[quote.partyB][partyA].length > 0\n            ) {\n                delete quoteLayout.partyBPendingQuotes[quote.partyB][partyA];\n                AccountStorage\n                .layout()\n                .partyBPendingLockedBalances[quote.partyB][partyA].makeZero();\n            }\n            quote.quoteStatus = QuoteStatus.LIQUIDATED;\n            quote.modifyTimestamp = block.timestamp;\n        }\n        AccountStorage.layout().pendingLockedBalances[partyA].makeZero();\n        delete quoteLayout.partyAPendingQuotes[partyA];\n    }\n\n    function liquidatePositionsPartyA(\n        address partyA,\n        uint256[] memory quoteIds\n    ) internal returns (bool) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n\n        require(maLayout.liquidationStatus[partyA], \"LiquidationFacet: PartyA is solvent\");\n        for (uint256 index = 0; index < quoteIds.length; index++) {\n            Quote storage quote = quoteLayout.quotes[quoteIds[index]];\n            require(\n                quote.quoteStatus == QuoteStatus.OPENED ||\n                    quote.quoteStatus == QuoteStatus.CLOSE_PENDING ||\n                    quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n                \"LiquidationFacet: Invalid state\"\n            );\n            require(quote.partyA == partyA, \"LiquidationFacet: Invalid party\");\n            require(\n                accountLayout.symbolsPrices[partyA][quote.symbolId].timestamp ==\n                    maLayout.liquidationTimestamp[partyA],\n                \"LiquidationFacet: Price should be set\"\n            );\n            quote.quoteStatus = QuoteStatus.LIQUIDATED;\n            quote.modifyTimestamp = block.timestamp;\n\n            (bool hasMadeProfit, uint256 amount) = LibQuote.getValueOfQuoteForPartyA(\n                accountLayout.symbolsPrices[partyA][quote.symbolId].price,\n                LibQuote.quoteOpenAmount(quote),\n                quote\n            );\n            if (hasMadeProfit) {\n                accountLayout.totalUnplForLiquidation[partyA] += int256(amount);\n            } else {\n                accountLayout.totalUnplForLiquidation[partyA] -= int256(amount);\n            }\n\n            if (\n                accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.NORMAL\n            ) {\n                accountLayout.partyBAllocatedBalances[quote.partyB][partyA] += quote\n                    .lockedValues\n                    .cva;\n                if (hasMadeProfit) {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] -= amount;\n                } else {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] += amount;\n                }\n            } else if (\n                accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.LATE\n            ) {\n                accountLayout.partyBAllocatedBalances[quote.partyB][partyA] +=\n                    quote.lockedValues.cva -\n                    ((quote.lockedValues.cva * accountLayout.liquidationDetails[partyA].deficit) /\n                        accountLayout.lockedBalances[partyA].cva);\n                if (hasMadeProfit) {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] -= amount;\n                } else {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] += amount;\n                }\n            } else if (\n                accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.OVERDUE\n            ) {\n                if (hasMadeProfit) {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] -= amount;\n                } else {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] +=\n                        amount -\n                        ((amount * accountLayout.liquidationDetails[partyA].deficit) /\n                            uint256(-accountLayout.liquidationDetails[partyA].totalUnrealizedLoss));\n                }\n            }\n            accountLayout.partyBLockedBalances[quote.partyB][partyA].subQuote(quote);\n            quote.avgClosedPrice =\n                (quote.avgClosedPrice *\n                    quote.closedAmount +\n                    LibQuote.quoteOpenAmount(quote) *\n                    accountLayout.symbolsPrices[partyA][quote.symbolId].price) /\n                (quote.closedAmount + LibQuote.quoteOpenAmount(quote));\n            quote.closedAmount = quote.quantity;\n\n            LibQuote.removeFromOpenPositions(quote.id);\n            quoteLayout.partyAPositionsCount[partyA] -= 1;\n            quoteLayout.partyBPositionsCount[quote.partyB][partyA] -= 1;\n        }\n        if (quoteLayout.partyAPositionsCount[partyA] == 0) {\n            require(\n                quoteLayout.partyAPendingQuotes[partyA].length == 0,\n                \"LiquidationFacet: Pending quotes should be liquidated first\"\n            );\n            accountLayout.allocatedBalances[partyA] = 0;\n            accountLayout.lockedBalances[partyA].makeZero();\n\n            uint256 lf = accountLayout.liquidationDetails[partyA].liquidationFee;\n            if (lf > 0) {\n                accountLayout.allocatedBalances[accountLayout.liquidators[partyA][0]] += lf / 2;\n                accountLayout.allocatedBalances[accountLayout.liquidators[partyA][1]] += lf / 2;\n            }\n            delete accountLayout.liquidators[partyA];\n            maLayout.liquidationStatus[partyA] = false;\n            maLayout.liquidationTimestamp[partyA] = 0;\n            accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.NONE;\n            if (\n                accountLayout.totalUnplForLiquidation[partyA] !=\n                accountLayout.liquidationDetails[partyA].upnl\n            ) {\n                accountLayout.totalUnplForLiquidation[partyA] = 0;\n                return false;\n            }\n            accountLayout.totalUnplForLiquidation[partyA] = 0;\n        }\n        return true;\n    }\n\n    function liquidatePartyB(\n        address partyB,\n        address partyA,\n        SingleUpnlSig memory upnlSig\n    ) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n\n        LibMuon.verifyPartyBUpnl(upnlSig, partyB, partyA);\n        int256 availableBalance = LibAccount.partyBAvailableBalanceForLiquidation(\n            upnlSig.upnl,\n            partyB,\n            partyA\n        );\n\n        require(availableBalance < 0, \"LiquidationFacet: partyB is solvent\");\n        uint256 liquidatorShare;\n        uint256 remainingLf;\n        if (uint256(-availableBalance) < accountLayout.partyBLockedBalances[partyB][partyA].lf) {\n            remainingLf =\n                accountLayout.partyBLockedBalances[partyB][partyA].lf -\n                uint256(-availableBalance);\n            liquidatorShare = (remainingLf * maLayout.liquidatorShare) / 1e18;\n\n            maLayout.partyBPositionLiquidatorsShare[partyB][partyA] =\n                (remainingLf - liquidatorShare) /\n                quoteLayout.partyBPositionsCount[partyB][partyA];\n        } else {\n            maLayout.partyBPositionLiquidatorsShare[partyB][partyA] = 0;\n        }\n\n        maLayout.partyBLiquidationStatus[partyB][partyA] = true;\n        maLayout.partyBLiquidationTimestamp[partyB][partyA] = upnlSig.timestamp;\n\n        uint256[] storage pendingQuotes = quoteLayout.partyAPendingQuotes[partyA];\n\n        for (uint256 index = 0; index < pendingQuotes.length; ) {\n            Quote storage quote = quoteLayout.quotes[pendingQuotes[index]];\n            if (\n                quote.partyB == partyB &&\n                (quote.quoteStatus == QuoteStatus.LOCKED ||\n                    quote.quoteStatus == QuoteStatus.CANCEL_PENDING)\n            ) {\n                accountLayout.pendingLockedBalances[partyA].subQuote(quote);\n\n                pendingQuotes[index] = pendingQuotes[pendingQuotes.length - 1];\n                pendingQuotes.pop();\n                quote.quoteStatus = QuoteStatus.LIQUIDATED;\n                quote.modifyTimestamp = block.timestamp;\n            } else {\n                index++;\n            }\n        }\n        accountLayout.allocatedBalances[partyA] +=\n            accountLayout.partyBAllocatedBalances[partyB][partyA] -\n            remainingLf;\n\n        delete quoteLayout.partyBPendingQuotes[partyB][partyA];\n        accountLayout.partyBAllocatedBalances[partyB][partyA] = 0;\n        accountLayout.partyBLockedBalances[partyB][partyA].makeZero();\n        accountLayout.partyBPendingLockedBalances[partyB][partyA].makeZero();\n\n        if (liquidatorShare > 0) {\n            accountLayout.allocatedBalances[msg.sender] += liquidatorShare;\n        }\n    }\n\n    function liquidatePositionsPartyB(\n        address partyB,\n        address partyA,\n        QuotePriceSig memory priceSig\n    ) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n\n        LibMuon.verifyQuotePrices(priceSig);\n        require(\n            priceSig.timestamp <=\n                maLayout.partyBLiquidationTimestamp[partyB][partyA] + maLayout.liquidationTimeout,"
    }
  ]
}