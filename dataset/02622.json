{
  "Title": "Remove function does not revert if startIndex is greater than or equal to endIndex",
  "Content": "The [`remove`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/libs/DepositQueueLib.sol#L26) function is responsible for removing records from the queue. When called, it checks if the [`endIndex` is greater than the `startIndex`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/libs/DepositQueueLib.sol#L31) to execute the function’s implementation. The issue is that if the condition is not met, the transaction is not reverted, and the code execution continues. This could cause [`processQueuedDeposits`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/vaults/BaseVault.sol#L371) to fail silently when the indexes are not valid.\n\n\nAlthough it does not currently cause any errors other than spending gas unnecessarily, consider rolling back the transaction if the condition is met to avoid unwanted behaviors.\n\n\n**Update:** *Fixed in commit [`e05f165`](https://github.com/pods-finance/yield-contracts/pull/41/commits/e05f165850fe93341dacd5266d634c9ade3410b3).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/libs/DepositQueueLib.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.9;\n\nlibrary DepositQueueLib {\n    struct DepositEntry {\n        address owner;\n        uint256 amount;\n    }\n\n    struct DepositQueue {\n        address[] list;\n        mapping(address => uint256) cache;\n        uint256 totalDeposited;\n    }\n\n    function push(DepositQueue storage queue, DepositEntry memory deposit) internal {\n        if (queue.cache[deposit.owner] == 0 && deposit.amount > 0) {\n            queue.list.push(deposit.owner);\n        }\n\n        queue.cache[deposit.owner] += deposit.amount;\n        queue.totalDeposited += deposit.amount;\n    }\n\n    function remove(\n        DepositQueue storage queue,\n        uint256 startIndex,\n        uint256 endIndex\n    ) internal {\n        if (endIndex > startIndex) {\n            address[] memory newList = new address[](queue.list.length - (endIndex - startIndex));\n            uint256 i = 0;\n            uint256 totalDeposited = queue.totalDeposited;\n\n            // Copying the skipped interval to the new array\n            while (i < startIndex) {\n                newList[i] = queue.list[i];\n                i++;\n            }\n\n            // Remove the interval from the cache\n            while (startIndex < endIndex) {\n                // No need to check, it can't go below 0\n                unchecked {\n                    totalDeposited -= queue.cache[queue.list[startIndex]];\n                }\n                queue.cache[queue.list[startIndex]] = 0;\n                startIndex++;\n            }\n\n            // Copying the rest of the list with the remaining entries\n            while (endIndex < queue.list.length) {\n                newList[i++] = queue.list[endIndex++];\n            }\n\n            queue.list = newList;\n            queue.totalDeposited = totalDeposited;\n        }\n    }\n\n    function get(DepositQueue storage queue, uint256 index) internal view returns (DepositEntry memory depositEntry) {\n        if (index < queue.list.length) {\n            address owner = queue.list[index];\n            depositEntry.owner = owner;\n            depositEntry.amount = queue.cache[owner];\n        }\n    }\n\n    function balanceOf(DepositQueue storage queue, address owner) internal view returns (uint256) {\n        return queue.cache[owner];\n    }\n\n    function size(DepositQueue storage queue) internal view returns (uint256) {\n        return queue.list.length;\n    }\n}"
    }
  ]
}