{
  "Title": "M-15: `CrossCurrencyfCashVault` Cannot Be Upgraded",
  "Content": "# Issue M-15: `CrossCurrencyfCashVault` Cannot Be Upgraded \n\nSource: https://github.com/sherlock-audit/2022-09-notional-judging/issues/65 \n\n## Found by \nxiaoming90\n\n## Summary\n\n`CrossCurrencyfCashVault` cannot be upgraded as it is missing the authorize upgrade method.\n\n## Vulnerability Detail\n\nThe Cross Currency Vault is expected to be upgradeable as:\n\n- This vault is similar to the other vaults (Boosted3TokenAuraVault and MetaStable2TokenAuraVault) provided by Notional that are upgradeable by default.\n- The `BaseStrategyVault` has configured the storage gaps `uint256[45] private __gap` for upgrading purposes\n- Clarified with the sponsor and noted that Cross Currency Vault should be upgradeable\n\n`CrossCurrencyfCashVault` inherits from `BaseStrategyVault`.  However, the `BaseStrategyVault` forget to inherit Openzepplin's `UUPSUpgradeable` contract. Therefore, it is missing the authorize upgrade method, and the contract cannot be upgraded.\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/BaseStrategyVault.sol#L14\n\n```solidity\nabstract contract BaseStrategyVault is Initializable, IStrategyVault {\n    using TokenUtils for IERC20;\n    using TradeHandler for Trade;\n\n    /// @notice Hardcoded on the implementation contract during deployment\n    NotionalProxy public immutable NOTIONAL;\n    ITradingModule public immutable TRADING_MODULE;\n    uint8 constant internal INTERNAL_TOKEN_DECIMALS = 8;\n    \n    ..SNIP..\n    \n    // Storage gap for future potential upgrades\n    uint256[45] private __gap;\n }\n```\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/CrossCurrencyfCashVault.sol#L32\n\n```solidity\ncontract CrossCurrencyfCashVault is BaseStrategyVault {\n    using TypeConvert for uint256;\n    using TypeConvert for int256;\n\n    uint256 public constant SETTLEMENT_SLIPPAGE_PRECISION = 1e18;\n\n    struct DepositParams {\n        // Minimum purchase amount of the lend underlying token, this is\n        // based on the deposit + borrowed amount and must be set to a non-zero\n        // value to establish a slippage limit.\n        uint256 minPurchaseAmount;\n        // Minimum annualized lending rate, can be set to zero for no slippage limit\n        uint32 minLendRate;\n        // ID of the desired DEX to trade on, _depositFromNotional will always trade\n        // using an EXACT_IN_SINGLE trade which is supported by all DEXes\n        uint16 dexId;\n        // Exchange data depending on the selected dexId\n        ..SNIP..\n```\n\n## Impact\n\nIf a critical bug is discovered within the Cross Currency Vault after launching that causes a loss of assets, the vault cannot be upgraded unlike the other balancer-related vaults to fix the bugs. All assets within the vault will be lost\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/BaseStrategyVault.sol#L14\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/CrossCurrencyfCashVault.sol#L32\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIt is recommended to Inherit Openzepplin's `UUPSUpgradeable` contract and implement the missing authorize upgrade method.\n\n```diff\n- abstract contract BaseStrategyVault is Initializable, IStrategyVault {\n+ abstract contract BaseStrategyVault is Initializable, IStrategyVault, UUPSUpgradeable {\n    using TokenUtils for IERC20;\n    using TradeHandler for Trade;\n\n    /// @notice Hardcoded on the implementation contract during deployment\n    NotionalProxy public immutable NOTIONAL;\n    ITradingModule public immutable TRADING_MODULE;\n    uint8 constant internal INTERNAL_TOKEN_DECIMALS = 8;\n    \n    ..SNIP..\n    \n+    function _authorizeUpgrade(\n+        address /* newImplementation */\n+    ) internal override onlyNotionalOwner {}    \n    \n    // Storage gap for future potential upgrades\n    uint256[45] private __gap;\n }\n```\n\n## Discussion\n\n**jeffywu**\n\nValid issue, the vault is missing the proper method.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/2",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/BaseStrategyVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {Token, TokenType} from \"../global/Types.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {IStrategyVault} from \"../../interfaces/notional/IStrategyVault.sol\";\nimport {NotionalProxy} from \"../../interfaces/notional/NotionalProxy.sol\";\nimport {ITradingModule, Trade} from \"../../interfaces/trading/ITradingModule.sol\";\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\nimport {TokenUtils} from \"../utils/TokenUtils.sol\";\nimport {TradeHandler} from \"../trading/TradeHandler.sol\";\nimport {nProxy} from \"../proxy/nProxy.sol\";\n\nabstract contract BaseStrategyVault is Initializable, IStrategyVault {\n    using TokenUtils for IERC20;\n    using TradeHandler for Trade;\n\n    /// @notice Hardcoded on the implementation contract during deployment\n    NotionalProxy public immutable NOTIONAL;\n    ITradingModule public immutable TRADING_MODULE;\n    uint8 constant internal INTERNAL_TOKEN_DECIMALS = 8;\n\n    // Borrowing Currency ID the vault is configured with\n    uint16 private _BORROW_CURRENCY_ID;\n    // True if the underlying is ETH\n    bool private _UNDERLYING_IS_ETH;\n    // Address of the underlying token\n    IERC20 private _UNDERLYING_TOKEN;\n    // NOTE: end of first storage slot here\n\n    // Name of the vault\n    string private _NAME;\n\n\n    /**************************************************************************/\n    /* Global Modifiers, Constructor and Initializer                          */\n    /**************************************************************************/\n    modifier onlyNotional() {\n        require(msg.sender == address(NOTIONAL));\n        _;\n    }\n\n    modifier onlyNotionalOwner() {\n        require(msg.sender == address(NOTIONAL.owner()));\n        _;\n    }\n    \n    /// @notice Set the NOTIONAL address on deployment\n    constructor(NotionalProxy notional_, ITradingModule tradingModule_) initializer {\n        NOTIONAL = notional_;\n        TRADING_MODULE = tradingModule_;\n    }\n\n    /// @notice Override this method and revert if the contract should not receive ETH.\n    /// Upgradeable proxies must have this implemented on the proxy for transfer calls\n    /// succeed (use nProxy for this).\n    receive() external virtual payable {\n        // Allow ETH transfers to succeed\n    }\n\n    /// @notice All strategy vaults MUST implement 8 decimal precision\n    function decimals() public override view returns (uint8) {\n        return INTERNAL_TOKEN_DECIMALS;\n    }\n\n    function name() external override view returns (string memory) {\n        return _NAME;\n    }\n\n    function strategy() external virtual view returns (bytes4);\n\n    function _borrowCurrencyId() internal view returns (uint16) {\n        return _BORROW_CURRENCY_ID;\n    }\n\n    function _underlyingToken() internal view returns (IERC20) {\n        return _UNDERLYING_TOKEN;\n    }\n\n    function _isUnderlyingETH() internal view returns (bool) {\n        return _UNDERLYING_IS_ETH;\n    }\n\n    /// @notice Can only be called once during initialization\n    function __INIT_VAULT(\n        string memory name_,\n        uint16 borrowCurrencyId_\n    ) internal onlyInitializing {\n        _NAME = name_;\n        _BORROW_CURRENCY_ID = borrowCurrencyId_;\n\n        address underlyingAddress = _getNotionalUnderlyingToken(borrowCurrencyId_);\n        _UNDERLYING_TOKEN = IERC20(underlyingAddress);\n        _UNDERLYING_IS_ETH = underlyingAddress == address(0);\n    }\n\n    function _getNotionalUnderlyingToken(uint16 currencyId) internal view returns (address) {\n        (Token memory assetToken, Token memory underlyingToken) = NOTIONAL.getCurrency(currencyId);\n\n        return assetToken.tokenType == TokenType.NonMintable ?\n            assetToken.tokenAddress : underlyingToken.tokenAddress;\n    }\n\n    /// @notice Can be used to delegate call to the TradingModule's implementation in order to execute\n    /// a trade.\n    function _executeTrade(\n        uint16 dexId,\n        Trade memory trade\n    ) internal returns (uint256 amountSold, uint256 amountBought) {\n        return trade._executeTrade(dexId, TRADING_MODULE);\n    }\n\n    /**************************************************************************/\n    /* Virtual Methods Requiring Implementation                               */\n    /**************************************************************************/\n    function convertStrategyToUnderlying(\n        address account,\n        uint256 strategyTokens,\n        uint256 maturity\n    ) public view virtual returns (int256 underlyingValue);\n    \n    // Vaults need to implement these two methods\n    function _depositFromNotional(\n        address account,\n        uint256 deposit,\n        uint256 maturity,\n        bytes calldata data\n    ) internal virtual returns (uint256 strategyTokensMinted);\n\n    function _redeemFromNotional(\n        address account,\n        uint256 strategyTokens,\n        uint256 maturity,\n        bytes calldata data\n    ) internal virtual returns (uint256 tokensFromRedeem);\n\n    // This can be overridden if the vault borrows in a secondary currency, but reverts by default.\n    function _repaySecondaryBorrowCallback(\n        address token,  uint256 underlyingRequired, bytes calldata data\n    ) internal virtual returns (bytes memory returnData) {\n        revert();\n    }\n\n    /**************************************************************************/\n    /* Default External Method Implementations                                */\n    /**************************************************************************/\n    function depositFromNotional(\n        address account,\n        uint256 deposit,\n        uint256 maturity,\n        bytes calldata data\n    ) external payable onlyNotional returns (uint256 strategyTokensMinted) {\n        return _depositFromNotional(account, deposit, maturity, data);\n    }\n\n    function redeemFromNotional(\n        address account,\n        address receiver,\n        uint256 strategyTokens,\n        uint256 maturity,\n        uint256 underlyingToRepayDebt,\n        bytes calldata data\n    ) external onlyNotional returns (uint256 transferToReceiver) {\n        uint256 borrowedCurrencyAmount = _redeemFromNotional(account, strategyTokens, maturity, data);\n\n        uint256 transferToNotional;\n        if (account == address(this) || borrowedCurrencyAmount <= underlyingToRepayDebt) {\n            // It may be the case that insufficient tokens were redeemed to repay the debt. If this\n            // happens the Notional will attempt to recover the shortfall from the account directly.\n            // This can happen if an account wants to reduce their leverage by paying off debt but\n            // does not want to sell strategy tokens to do so.\n            // The other situation would be that the vault is calling redemption to deleverage or\n            // settle. In that case all tokens go back to Notional.\n            transferToNotional = borrowedCurrencyAmount;\n        } else {\n            transferToNotional = underlyingToRepayDebt;\n            unchecked { transferToReceiver = borrowedCurrencyAmount - underlyingToRepayDebt; }\n        }\n\n        if (_UNDERLYING_IS_ETH) {\n            if (transferToReceiver > 0) payable(receiver).transfer(transferToReceiver);\n            if (transferToNotional > 0) payable(address(NOTIONAL)).transfer(transferToNotional);\n        } else {\n            if (transferToReceiver > 0) _UNDERLYING_TOKEN.checkTransfer(receiver, transferToReceiver);\n            if (transferToNotional > 0) _UNDERLYING_TOKEN.checkTransfer(address(NOTIONAL), transferToNotional);\n        }\n    }\n\n    function repaySecondaryBorrowCallback(\n        address token, uint256 underlyingRequired, bytes calldata data\n    ) external onlyNotional returns (bytes memory returnData) {\n        return _repaySecondaryBorrowCallback(token, underlyingRequired, data);\n    }\n\n    // Storage gap for future potential upgrades\n    uint256[45] private __gap;\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/CrossCurrencyfCashVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {NotionalProxy} from \"../../interfaces/notional/NotionalProxy.sol\";\nimport {IWrappedfCashFactory} from \"../../interfaces/notional/IWrappedfCashFactory.sol\";\nimport {WETH9} from \"../../interfaces/WETH9.sol\";\nimport {IWrappedfCashComplete as IWrappedfCash} from \"../../interfaces/notional/IWrappedfCash.sol\";\nimport {BaseStrategyVault} from \"./BaseStrategyVault.sol\";\nimport {IERC20} from \"../utils/TokenUtils.sol\";\nimport {\n    AccountContext,\n    BalanceActionWithTrades,\n    DepositActionType,\n    TradeActionType,\n    BatchLend,\n    Token,\n    TokenType,\n    VaultState\n} from \"../global/Types.sol\";\nimport {Constants} from \"../global/Constants.sol\";\nimport {DateTime} from \"../global/DateTime.sol\";\nimport {TypeConvert} from \"../global/TypeConvert.sol\";\nimport {ITradingModule, DexId, TradeType, Trade} from \"../../interfaces/trading/ITradingModule.sol\";\nimport {TradeHandler} from \"../trading/TradeHandler.sol\";\n\n/**\n * @notice This vault borrows in one currency, trades it to a different currency\n * and lends on Notional in that currency. It will be paired with another vault\n * that lends and borrows in the opposite direction.\n */\ncontract CrossCurrencyfCashVault is BaseStrategyVault {\n    using TypeConvert for uint256;\n    using TypeConvert for int256;\n\n    uint256 public constant SETTLEMENT_SLIPPAGE_PRECISION = 1e18;\n\n    struct DepositParams {\n        // Minimum purchase amount of the lend underlying token, this is\n        // based on the deposit + borrowed amount and must be set to a non-zero\n        // value to establish a slippage limit.\n        uint256 minPurchaseAmount;\n        // Minimum annualized lending rate, can be set to zero for no slippage limit\n        uint32 minLendRate;\n        // ID of the desired DEX to trade on, _depositFromNotional will always trade\n        // using an EXACT_IN_SINGLE trade which is supported by all DEXes\n        uint16 dexId;\n        // Exchange data depending on the selected dexId\n        bytes exchangeData;\n    }\n\n    struct RedeemParams {\n        // Minimum purchase amount of the borrow underlying token, this is\n        // based on the amount of lend underlying received and must be set to a non-zero\n        // value to establish a slippage limit.\n        uint256 minPurchaseAmount;\n        // Maximum annualized borrow rate, can be set to zero for no slippage limit\n        uint32 maxBorrowRate;\n        // ID of the desired DEX to trade on, _depositFromNotional will always trade\n        // using an EXACT_IN_SINGLE trade which is supported by all DEXes\n        uint16 dexId;\n        // Exchange data depending on the selected dexId\n        bytes exchangeData;\n    }\n\n    uint16 public LEND_CURRENCY_ID;\n    IERC20 public LEND_UNDERLYING_TOKEN;\n    /// @notice a maximum slippage limit in 1e18 precision, uint64 is sufficient to hold the maximum value which\n    /// is 1e18\n    uint64 public settlementSlippageLimit;\n    // NOTE: 2 bytes left in first storage slot here\n\n    constructor(NotionalProxy notional_, ITradingModule tradingModule_)\n        BaseStrategyVault(notional_, tradingModule_) {}\n\n    function strategy() external override view returns (bytes4) {\n        return bytes4(keccak256(\"CrossCurrencyfCash\"));\n    }\n    function initialize(\n        string memory name_,\n        uint16 borrowCurrencyId_,\n        uint16 lendCurrencyId_,\n        uint64 settlementSlippageLimit_\n    ) external initializer {\n        __INIT_VAULT(name_, borrowCurrencyId_);\n\n        LEND_CURRENCY_ID = lendCurrencyId_;\n        (\n            Token memory assetToken,\n            Token memory underlyingToken,\n            /* ETHRate memory ethRate */,\n            /* AssetRateParameters memory assetRate */\n        ) = NOTIONAL.getCurrencyAndRates(lendCurrencyId_);\n\n        IERC20 tokenAddress = assetToken.tokenType == TokenType.NonMintable ?\n            IERC20(assetToken.tokenAddress) : IERC20(underlyingToken.tokenAddress);\n        LEND_UNDERLYING_TOKEN = tokenAddress;\n\n        // Allow Notional to pull the lend underlying currency\n        tokenAddress.approve(address(NOTIONAL), type(uint256).max);\n\n        // This value cannot be greater than 1e18\n        require(settlementSlippageLimit_ < SETTLEMENT_SLIPPAGE_PRECISION);\n        settlementSlippageLimit = settlementSlippageLimit_;\n    }\n\n    function updateSettlementSlippageLimit(uint64 newSlippageLimit) external {\n        require(msg.sender == NOTIONAL.owner());\n        require(newSlippageLimit < SETTLEMENT_SLIPPAGE_PRECISION);\n        settlementSlippageLimit = newSlippageLimit;\n    }\n\n    /**\n     * @notice During settlement all of the fCash balance in the lend currency will be redeemed to the\n     * underlying token and traded back to the borrow currency. All of the borrow currency will be deposited\n     * into the Notional contract as asset tokens and held for accounts to withdraw. Settlement can only\n     * be called after maturity.\n     * @param maturity the maturity to settle\n     * @param settlementTrade details for the settlement trade\n     */\n    function settleVault(uint256 maturity, uint256 strategyTokens, bytes calldata settlementTrade) external {\n        require(maturity <= block.timestamp, \"Cannot Settle\");\n        VaultState memory vaultState = NOTIONAL.getVaultState(address(this), maturity);\n        require(vaultState.isSettled == false);\n        require(vaultState.totalStrategyTokens >= strategyTokens);\n\n        RedeemParams memory params = abi.decode(settlementTrade, (RedeemParams));\n    \n        // The only way for underlying value to be negative would be if the vault has somehow ended up with a borrowing\n        // position in the lend underlying currency. This is explicitly prevented during redemption.\n        uint256 underlyingValue = convertStrategyToUnderlying(\n            address(0), vaultState.totalStrategyTokens, maturity\n        ).toUint();\n\n        // Authenticate the minimum purchase amount, all tokens will be sold given this slippage limit.\n        uint256 minAllowedPurchaseAmount = (underlyingValue * settlementSlippageLimit) / SETTLEMENT_SLIPPAGE_PRECISION;\n        require(params.minPurchaseAmount >= minAllowedPurchaseAmount, \"Purchase Limit\");\n\n        NOTIONAL.redeemStrategyTokensToCash(maturity, strategyTokens, settlementTrade);\n\n        // If there are no more strategy tokens left, then mark the vault as settled\n        vaultState = NOTIONAL.getVaultState(address(this), maturity);\n        if (vaultState.totalStrategyTokens == 0) {\n            NOTIONAL.settleVault(address(this), maturity);\n        }\n    }\n\n    /**\n     * @notice Converts the amount of fCash the vault holds into underlying denomination for the\n     * borrow currency.\n     * @param strategyTokens each strategy token is equivalent to 1 unit of fCash\n     * @param maturity the maturity of the fCash\n     * @return underlyingValue the value of the lent fCash in terms of the borrowed currency\n     */\n    function convertStrategyToUnderlying(\n        address /* account */,\n        uint256 strategyTokens,\n        uint256 maturity\n    ) public override view returns (int256 underlyingValue) {\n        int256 pvInternal;\n        if (maturity <= block.timestamp) {\n            // After maturity, strategy tokens no longer have a present value\n            pvInternal = strategyTokens.toInt();\n        } else {\n            // This is the non-risk adjusted oracle price for fCash, present value is used in case\n            // liquidation is required. The liquidator may need to exit the fCash position in order\n            // to repay a flash loan.\n            pvInternal = NOTIONAL.getPresentfCashValue(\n                LEND_CURRENCY_ID, maturity, strategyTokens.toInt(), block.timestamp, false\n            );\n        }\n\n        IERC20 underlyingToken = _underlyingToken();\n        (int256 rate, int256 rateDecimals) = TRADING_MODULE.getOraclePrice(\n            address(LEND_UNDERLYING_TOKEN), address(underlyingToken)\n        );\n        int256 borrowTokenDecimals = int256(10**underlyingToken.decimals());\n\n        // Convert this back to the borrow currency, external precision\n        // (pv (8 decimals) * borrowTokenDecimals * rate) / (rateDecimals * 8 decimals)\n        return (pvInternal * borrowTokenDecimals * rate) /\n            (rateDecimals * int256(Constants.INTERNAL_TOKEN_PRECISION));\n    }\n\n    /**\n     * @notice Will receive a deposit from Notional in underlying tokens of the borrowed currency.\n     * Needs to first trade that deposit into the lend currency and then lend it to fCash on the\n     * corresponding maturity.\n     * @param depositUnderlyingExternal amount of tokens deposited in the borrow currency\n     * @param maturity the maturity that was borrowed at, will also be the maturity that is lent to\n     * @param data DepositParams\n     * @return lendfCashMinted the amount of strategy tokens (fCash lent) generated\n     */\n    function _depositFromNotional(\n        address /* account */,\n        uint256 depositUnderlyingExternal,\n        uint256 maturity,\n        bytes calldata data\n    ) internal override returns (uint256 lendfCashMinted) {\n        DepositParams memory params = abi.decode(data, (DepositParams));\n        Trade memory trade = Trade({\n            tradeType: TradeType.EXACT_IN_SINGLE,\n            sellToken: address(_underlyingToken()),\n            buyToken: address(LEND_UNDERLYING_TOKEN),\n            amount: depositUnderlyingExternal,\n            limit: params.minPurchaseAmount,\n            deadline: block.timestamp,\n            exchangeData: params.exchangeData\n        });\n\n        (/* */, uint256 lendUnderlyingTokens) = _executeTrade(params.dexId, trade);\n\n        // Now we lend the underlying amount\n        (uint256 fCashAmount, /* */, bytes32 encodedTrade) = NOTIONAL.getfCashLendFromDeposit(\n            LEND_CURRENCY_ID,\n            lendUnderlyingTokens,\n            maturity,\n            params.minLendRate,\n            block.timestamp,\n            true // useUnderlying is true\n        );\n\n        BatchLend[] memory action = new BatchLend[](1);\n        action[0].currencyId = LEND_CURRENCY_ID;\n        action[0].depositUnderlying = true;\n        action[0].trades = new bytes32[](1);\n        action[0].trades[0] = encodedTrade;\n        NOTIONAL.batchLend(address(this), action);\n\n        // fCash is the strategy token in this case, batchLend will always mint exactly fCashAmount\n        return fCashAmount;\n    }\n\n    /**\n     * @notice Withdraws lent fCash from Notional (by selling it prior to maturity or withdrawing post maturity),\n     * and trades it all back to the borrowed currency.\n     * @param account the account that is doing the redemption\n     * @param strategyTokens the amount of fCash to redeem\n     * @param maturity the maturity of the fCash\n     * @param data RedeemParams\n     * @return borrowedCurrencyAmount the amount of borrowed currency raised by the redemption\n     */\n    function _redeemFromNotional(\n        address account,\n        uint256 strategyTokens,\n        uint256 maturity,\n        bytes calldata data\n    ) internal override returns (uint256 borrowedCurrencyAmount) {\n        uint256 balanceBefore = LEND_UNDERLYING_TOKEN.balanceOf(address(this));\n        RedeemParams memory params = abi.decode(data, (RedeemParams));\n\n        if (maturity <= block.timestamp) {\n            // Only allow the vault to redeem past maturity to settle all positions\n            require(account == address(this));\n            NOTIONAL.settleAccount(address(this));\n            (int256 cashBalance, /* */, /* */) = NOTIONAL.getAccountBalance(LEND_CURRENCY_ID, address(this));\n\n            // It should never be possible that this contract has a negative cash balance\n            require(0 <= cashBalance && cashBalance <= int256(uint256(type(uint88).max)));\n\n            // Withdraws all cash to underlying\n            NOTIONAL.withdraw(LEND_CURRENCY_ID, uint88(uint256(cashBalance)), true);\n        } else {\n            // Sells fCash on Notional AMM (via borrowing)\n            BalanceActionWithTrades[] memory action = _encodeBorrowTrade(\n                maturity,\n                strategyTokens,\n                params.maxBorrowRate\n            );\n            NOTIONAL.batchBalanceAndTradeAction(address(this), action);\n\n            // Check that we have not somehow borrowed into a negative fCash position, vault borrows\n            // are not included in account context\n            AccountContext memory accountContext = NOTIONAL.getAccountContext(address(this));\n            require(accountContext.hasDebt == 0x00);\n        }\n\n        uint256 balanceAfter = LEND_UNDERLYING_TOKEN.balanceOf(address(this));\n        \n        // Trade back to borrow currency for repayment\n        Trade memory trade = Trade({\n            tradeType: TradeType.EXACT_IN_SINGLE,\n            sellToken: address(LEND_UNDERLYING_TOKEN),\n            buyToken: address(_underlyingToken()),\n            amount: balanceAfter - balanceBefore,\n            limit: params.minPurchaseAmount,\n            deadline: block.timestamp,\n            exchangeData: params.exchangeData\n        });\n\n        (/* */, borrowedCurrencyAmount) = _executeTrade(params.dexId, trade);\n    }\n\n    function _encodeBorrowTrade(\n        uint256 maturity,\n        uint256 fCashAmount,\n        uint32 maxImpliedRate\n    ) private view returns (BalanceActionWithTrades[] memory action) {\n        (uint256 marketIndex, bool isIdiosyncratic) = DateTime.getMarketIndex(\n            Constants.MAX_TRADED_MARKET_INDEX,\n            maturity,\n            block.timestamp\n        );\n        require(!isIdiosyncratic);\n        require(fCashAmount <= uint256(type(uint88).max));\n\n        action = new BalanceActionWithTrades[](1);\n        action[0].actionType = DepositActionType.None;\n        action[0].currencyId = LEND_CURRENCY_ID;\n        action[0].withdrawEntireCashBalance = true;\n        action[0].redeemToUnderlying = true;\n        action[0].trades = new bytes32[](1);\n        action[0].trades[0] = bytes32(\n            (uint256(uint8(TradeActionType.Borrow)) << 248) |\n            (uint256(marketIndex) << 240) |\n            (uint256(fCashAmount) << 152) |\n            (uint256(maxImpliedRate) << 120)\n        );\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/BaseStrategyVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {Token, TokenType} from \"../global/Types.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {IStrategyVault} from \"../../interfaces/notional/IStrategyVault.sol\";\nimport {NotionalProxy} from \"../../interfaces/notional/NotionalProxy.sol\";\nimport {ITradingModule, Trade} from \"../../interfaces/trading/ITradingModule.sol\";\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\nimport {TokenUtils} from \"../utils/TokenUtils.sol\";\nimport {TradeHandler} from \"../trading/TradeHandler.sol\";\nimport {nProxy} from \"../proxy/nProxy.sol\";\n\nabstract contract BaseStrategyVault is Initializable, IStrategyVault {\n    using TokenUtils for IERC20;\n    using TradeHandler for Trade;\n\n    /// @notice Hardcoded on the implementation contract during deployment\n    NotionalProxy public immutable NOTIONAL;\n    ITradingModule public immutable TRADING_MODULE;\n    uint8 constant internal INTERNAL_TOKEN_DECIMALS = 8;\n\n    // Borrowing Currency ID the vault is configured with\n    uint16 private _BORROW_CURRENCY_ID;\n    // True if the underlying is ETH\n    bool private _UNDERLYING_IS_ETH;\n    // Address of the underlying token\n    IERC20 private _UNDERLYING_TOKEN;\n    // NOTE: end of first storage slot here\n\n    // Name of the vault\n    string private _NAME;\n\n\n    /**************************************************************************/\n    /* Global Modifiers, Constructor and Initializer                          */\n    /**************************************************************************/\n    modifier onlyNotional() {\n        require(msg.sender == address(NOTIONAL));\n        _;\n    }\n\n    modifier onlyNotionalOwner() {\n        require(msg.sender == address(NOTIONAL.owner()));\n        _;\n    }\n    \n    /// @notice Set the NOTIONAL address on deployment\n    constructor(NotionalProxy notional_, ITradingModule tradingModule_) initializer {\n        NOTIONAL = notional_;\n        TRADING_MODULE = tradingModule_;\n    }\n\n    /// @notice Override this method and revert if the contract should not receive ETH.\n    /// Upgradeable proxies must have this implemented on the proxy for transfer calls\n    /// succeed (use nProxy for this).\n    receive() external virtual payable {\n        // Allow ETH transfers to succeed\n    }\n\n    /// @notice All strategy vaults MUST implement 8 decimal precision\n    function decimals() public override view returns (uint8) {\n        return INTERNAL_TOKEN_DECIMALS;\n    }\n\n    function name() external override view returns (string memory) {\n        return _NAME;\n    }\n\n    function strategy() external virtual view returns (bytes4);\n\n    function _borrowCurrencyId() internal view returns (uint16) {\n        return _BORROW_CURRENCY_ID;\n    }\n\n    function _underlyingToken() internal view returns (IERC20) {\n        return _UNDERLYING_TOKEN;\n    }\n\n    function _isUnderlyingETH() internal view returns (bool) {\n        return _UNDERLYING_IS_ETH;\n    }\n\n    /// @notice Can only be called once during initialization\n    function __INIT_VAULT(\n        string memory name_,\n        uint16 borrowCurrencyId_\n    ) internal onlyInitializing {\n        _NAME = name_;\n        _BORROW_CURRENCY_ID = borrowCurrencyId_;\n\n        address underlyingAddress = _getNotionalUnderlyingToken(borrowCurrencyId_);\n        _UNDERLYING_TOKEN = IERC20(underlyingAddress);\n        _UNDERLYING_IS_ETH = underlyingAddress == address(0);\n    }\n\n    function _getNotionalUnderlyingToken(uint16 currencyId) internal view returns (address) {\n        (Token memory assetToken, Token memory underlyingToken) = NOTIONAL.getCurrency(currencyId);\n\n        return assetToken.tokenType == TokenType.NonMintable ?\n            assetToken.tokenAddress : underlyingToken.tokenAddress;\n    }\n\n    /// @notice Can be used to delegate call to the TradingModule's implementation in order to execute\n    /// a trade.\n    function _executeTrade(\n        uint16 dexId,\n        Trade memory trade\n    ) internal returns (uint256 amountSold, uint256 amountBought) {\n        return trade._executeTrade(dexId, TRADING_MODULE);\n    }\n\n    /**************************************************************************/\n    /* Virtual Methods Requiring Implementation                               */\n    /**************************************************************************/\n    function convertStrategyToUnderlying(\n        address account,\n        uint256 strategyTokens,\n        uint256 maturity\n    ) public view virtual returns (int256 underlyingValue);\n    \n    // Vaults need to implement these two methods\n    function _depositFromNotional(\n        address account,\n        uint256 deposit,\n        uint256 maturity,\n        bytes calldata data\n    ) internal virtual returns (uint256 strategyTokensMinted);\n\n    function _redeemFromNotional(\n        address account,\n        uint256 strategyTokens,\n        uint256 maturity,\n        bytes calldata data\n    ) internal virtual returns (uint256 tokensFromRedeem);\n\n    // This can be overridden if the vault borrows in a secondary currency, but reverts by default.\n    function _repaySecondaryBorrowCallback(\n        address token,  uint256 underlyingRequired, bytes calldata data\n    ) internal virtual returns (bytes memory returnData) {\n        revert();\n    }\n\n    /**************************************************************************/\n    /* Default External Method Implementations                                */\n    /**************************************************************************/\n    function depositFromNotional(\n        address account,\n        uint256 deposit,\n        uint256 maturity,\n        bytes calldata data\n    ) external payable onlyNotional returns (uint256 strategyTokensMinted) {\n        return _depositFromNotional(account, deposit, maturity, data);\n    }\n\n    function redeemFromNotional(\n        address account,\n        address receiver,\n        uint256 strategyTokens,\n        uint256 maturity,\n        uint256 underlyingToRepayDebt,\n        bytes calldata data\n    ) external onlyNotional returns (uint256 transferToReceiver) {\n        uint256 borrowedCurrencyAmount = _redeemFromNotional(account, strategyTokens, maturity, data);\n\n        uint256 transferToNotional;\n        if (account == address(this) || borrowedCurrencyAmount <= underlyingToRepayDebt) {\n            // It may be the case that insufficient tokens were redeemed to repay the debt. If this\n            // happens the Notional will attempt to recover the shortfall from the account directly.\n            // This can happen if an account wants to reduce their leverage by paying off debt but\n            // does not want to sell strategy tokens to do so.\n            // The other situation would be that the vault is calling redemption to deleverage or\n            // settle. In that case all tokens go back to Notional.\n            transferToNotional = borrowedCurrencyAmount;\n        } else {\n            transferToNotional = underlyingToRepayDebt;\n            unchecked { transferToReceiver = borrowedCurrencyAmount - underlyingToRepayDebt; }\n        }\n\n        if (_UNDERLYING_IS_ETH) {\n            if (transferToReceiver > 0) payable(receiver).transfer(transferToReceiver);\n            if (transferToNotional > 0) payable(address(NOTIONAL)).transfer(transferToNotional);\n        } else {\n            if (transferToReceiver > 0) _UNDERLYING_TOKEN.checkTransfer(receiver, transferToReceiver);\n            if (transferToNotional > 0) _UNDERLYING_TOKEN.checkTransfer(address(NOTIONAL), transferToNotional);\n        }\n    }\n\n    function repaySecondaryBorrowCallback(\n        address token, uint256 underlyingRequired, bytes calldata data\n    ) external onlyNotional returns (bytes memory returnData) {\n        return _repaySecondaryBorrowCallback(token, underlyingRequired, data);\n    }\n\n    // Storage gap for future potential upgrades\n    uint256[45] private __gap;\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/CrossCurrencyfCashVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {NotionalProxy} from \"../../interfaces/notional/NotionalProxy.sol\";\nimport {IWrappedfCashFactory} from \"../../interfaces/notional/IWrappedfCashFactory.sol\";\nimport {WETH9} from \"../../interfaces/WETH9.sol\";\nimport {IWrappedfCashComplete as IWrappedfCash} from \"../../interfaces/notional/IWrappedfCash.sol\";\nimport {BaseStrategyVault} from \"./BaseStrategyVault.sol\";\nimport {IERC20} from \"../utils/TokenUtils.sol\";\nimport {\n    AccountContext,\n    BalanceActionWithTrades,\n    DepositActionType,\n    TradeActionType,\n    BatchLend,\n    Token,\n    TokenType,\n    VaultState\n} from \"../global/Types.sol\";\nimport {Constants} from \"../global/Constants.sol\";\nimport {DateTime} from \"../global/DateTime.sol\";\nimport {TypeConvert} from \"../global/TypeConvert.sol\";\nimport {ITradingModule, DexId, TradeType, Trade} from \"../../interfaces/trading/ITradingModule.sol\";\nimport {TradeHandler} from \"../trading/TradeHandler.sol\";\n\n/**\n * @notice This vault borrows in one currency, trades it to a different currency\n * and lends on Notional in that currency. It will be paired with another vault\n * that lends and borrows in the opposite direction.\n */\ncontract CrossCurrencyfCashVault is BaseStrategyVault {\n    using TypeConvert for uint256;\n    using TypeConvert for int256;\n\n    uint256 public constant SETTLEMENT_SLIPPAGE_PRECISION = 1e18;\n\n    struct DepositParams {\n        // Minimum purchase amount of the lend underlying token, this is\n        // based on the deposit + borrowed amount and must be set to a non-zero\n        // value to establish a slippage limit.\n        uint256 minPurchaseAmount;\n        // Minimum annualized lending rate, can be set to zero for no slippage limit\n        uint32 minLendRate;\n        // ID of the desired DEX to trade on, _depositFromNotional will always trade\n        // using an EXACT_IN_SINGLE trade which is supported by all DEXes\n        uint16 dexId;\n        // Exchange data depending on the selected dexId\n        bytes exchangeData;\n    }\n\n    struct RedeemParams {\n        // Minimum purchase amount of the borrow underlying token, this is\n        // based on the amount of lend underlying received and must be set to a non-zero\n        /"
    }
  ]
}