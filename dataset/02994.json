{
  "Title": "M-17: Did Not Approve To Zero First",
  "Content": "# Issue M-17: Did Not Approve To Zero First \n\nSource: https://github.com/sherlock-audit/2022-09-notional-judging/issues/59 \n\n## Found by \nxiaoming90, 0x52, csanuragjain\n\n## Summary\n\nAllowance was not set to zero first before changing the allowance.\n\n## Vulnerability Detail\n\nSome ERC20 tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value. For example Tether (USDT)'s `approve()` function will revert if the current approval is not zero, to protect against front-running changes of approvals.\n\nThe following  attempt to call the `approve()` function without setting the allowance to zero first.\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/utils/TokenUtils.sol#L18\n\n```solidity\nFile: TokenUtils.sol\n18:     function checkApprove(IERC20 token, address spender, uint256 amount) internal {\n19:         if (address(token) == address(0)) return;\n20: \n21:         IEIP20NonStandard(address(token)).approve(spender, amount);\n22:         _checkReturnCode();\n23:     }\n```\n\nHowever, if the token involved is an ERC20 token that does not work when changing the allowance from an existing non-zero allowance value, it will break a number of key functions or features of the protocol as the `TokenUtils.checkApprove` function is utilised extensively within the vault as shown below.\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/pool/TwoTokenPoolUtils.sol#L159\n\n```solidity\nFile: TwoTokenPoolUtils.sol\n157:     function _approveBalancerTokens(TwoTokenPoolContext memory poolContext, address bptSpender) internal {\n158:         IERC20(poolContext.primaryToken).checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n159:         IERC20(poolContext.secondaryToken).checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n160:         // Allow BPT spender to pull BALANCER_POOL_TOKEN\n161:         IERC20(address(poolContext.basePool.pool)).checkApprove(bptSpender, type(uint256).max);\n162:     }\n```\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/pool/Boosted3TokenPoolUtils.sol#L225\n\n```solidity\nFile: Boosted3TokenPoolUtils.sol\n222:     function _approveBalancerTokens(ThreeTokenPoolContext memory poolContext, address bptSpender) internal {\n223:         poolContext.basePool._approveBalancerTokens(bptSpender);\n224: \n225:         IERC20(poolContext.tertiaryToken).checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n226: \n227:         // For boosted pools, the tokens inside pool context are AaveLinearPool tokens.\n228:         // So, we need to approve the _underlyingToken (primary borrow currency) for trading.\n229:         IBoostedPool underlyingPool = IBoostedPool(poolContext.basePool.primaryToken);\n230:         address primaryUnderlyingAddress = BalancerUtils.getTokenAddress(underlyingPool.getMainToken());\n231:         IERC20(primaryUnderlyingAddress).checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n232:     }\n```\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/trading/TradingUtils.sol#L115\n\n```solidity\nFile: TradingUtils.sol\n110:     /// @notice Approve exchange to pull from this contract\n111:     /// @dev approve up to trade.amount for EXACT_IN trades and up to trade.limit\n112:     /// for EXACT_OUT trades\n113:     function _approve(Trade memory trade, address spender) private {\n114:         uint256 allowance = _isExactIn(trade) ? trade.amount : trade.limit;\n115:         IERC20(trade.sellToken).checkApprove(spender, allowance);\n116:     }\n```\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/strategy/StrategyUtils.sol#L85\n\n```solidity\nFile: StrategyUtils.sol\n85:             IERC20(buyToken).checkApprove(address(Deployments.WRAPPED_STETH), amountBought);\n86:             uint256 wrappedAmount = Deployments.WRAPPED_STETH.balanceOf(address(this));\n87:             /// @notice the amount returned by wrap is not always accurate for some reason\n88:             Deployments.WRAPPED_STETH.wrap(amountBought);\n89:             amountBought = Deployments.WRAPPED_STETH.balanceOf(address(this)) - wrappedAmount;\n```\n\n## Impact\n\nA number of features within the vaults will not work if the `approve` function reverts.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/utils/TokenUtils.sol#L18\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/pool/TwoTokenPoolUtils.sol#L159\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/pool/Boosted3TokenPoolUtils.sol#L225\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/trading/TradingUtils.sol#L115\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/strategy/StrategyUtils.sol#L85\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIt is recommended to set the allowance to zero before increasing the allowance and use safeApprove/safeIncreaseAllowance.\n\n## Discussion\n\n**jeffywu**\n\n@weitianjie2000 \n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/2",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/utils/TokenUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\nimport {IEIP20NonStandard} from \"../../interfaces/IEIP20NonStandard.sol\";\nimport {Deployments} from \"../global/Deployments.sol\";\n\nlibrary TokenUtils {\n    error ERC20Error();\n\n    function tokenBalance(address token) internal view returns (uint256) {\n        return\n            token == Deployments.ETH_ADDRESS\n                ? address(this).balance\n                : IERC20(token).balanceOf(address(this));\n    }\n\n    function checkApprove(IERC20 token, address spender, uint256 amount) internal {\n        if (address(token) == address(0)) return;\n\n        IEIP20NonStandard(address(token)).approve(spender, amount);\n        _checkReturnCode();\n    }\n\n    function checkRevoke(IERC20 token, address spender) internal {\n        if (address(token) == address(0)) return;\n\n        IEIP20NonStandard(address(token)).approve(spender, 0);\n        _checkReturnCode();\n    }\n\n    function checkTransfer(IERC20 token, address receiver, uint256 amount) internal {\n        IEIP20NonStandard(address(token)).transfer(receiver, amount);\n        _checkReturnCode();\n    }\n\n    // Supports checking return codes on non-standard ERC20 contracts\n    function _checkReturnCode() private pure {\n        bool success;\n        uint256[1] memory result;\n        assembly {\n            switch returndatasize()\n                case 0 {\n                    // This is a non-standard ERC-20\n                    success := 1 // set success to true\n                }\n                case 32 {\n                    // This is a compliant ERC-20\n                    returndatacopy(result, 0, 32)\n                    success := mload(result) // Set `success = returndata` of external call\n                }\n                default {\n                    // This is an excessively non-compliant ERC-20, revert.\n                    revert(0, 0)\n                }\n        }\n\n        if (!success) revert ERC20Error();\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/internal/pool/TwoTokenPoolUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {\n    TwoTokenPoolContext, \n    OracleContext, \n    PoolParams,\n    DepositParams,\n    DynamicTradeParams,\n    DepositTradeParams,\n    RedeemParams,\n    AuraStakingContext,\n    StrategyContext,\n    StrategyVaultSettings,\n    StrategyVaultState\n} from \"../../BalancerVaultTypes.sol\";\nimport {Deployments} from \"../../../../global/Deployments.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {Constants} from \"../../../../global/Constants.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {IAsset} from \"../../../../../interfaces/balancer/IBalancerVault.sol\";\nimport {TradeHandler} from \"../../../../trading/TradeHandler.sol\";\nimport {BalancerUtils} from \"../pool/BalancerUtils.sol\";\nimport {AuraStakingUtils} from \"../staking/AuraStakingUtils.sol\";\nimport {BalancerVaultStorage} from \"../BalancerVaultStorage.sol\";\nimport {StrategyUtils} from \"../strategy/StrategyUtils.sol\";\nimport {TwoTokenPoolUtils} from \"../pool/TwoTokenPoolUtils.sol\";\nimport {ITradingModule, Trade} from \"../../../../../interfaces/trading/ITradingModule.sol\";\nimport {IPriceOracle} from \"../../../../../interfaces/balancer/IPriceOracle.sol\";\nimport {TokenUtils, IERC20} from \"../../../../utils/TokenUtils.sol\";\n\nlibrary TwoTokenPoolUtils {\n    using TokenUtils for IERC20;\n    using TwoTokenPoolUtils for TwoTokenPoolContext;\n    using TradeHandler for Trade;\n    using TypeConvert for uint256;\n    using StrategyUtils for StrategyContext;\n    using AuraStakingUtils for AuraStakingContext;\n    using BalancerVaultStorage for StrategyVaultSettings;\n    using BalancerVaultStorage for StrategyVaultState;\n\n    /// @notice Returns parameters for joining and exiting Balancer pools\n    function _getPoolParams(\n        TwoTokenPoolContext memory context,\n        uint256 primaryAmount,\n        uint256 secondaryAmount,\n        bool isJoin\n    ) internal pure returns (PoolParams memory) {\n        IAsset[] memory assets = new IAsset[](2);\n        assets[context.primaryIndex] = IAsset(context.primaryToken);\n        assets[context.secondaryIndex] = IAsset(context.secondaryToken);\n\n        uint256[] memory amounts = new uint256[](2);\n        amounts[context.primaryIndex] = primaryAmount;\n        amounts[context.secondaryIndex] = secondaryAmount;\n\n        uint256 msgValue;\n        if (isJoin && assets[context.primaryIndex] == IAsset(Deployments.ETH_ADDRESS)) {\n            msgValue = amounts[context.primaryIndex];\n        }\n\n        return PoolParams(assets, amounts, msgValue);\n    }\n\n    /// @notice Gets the oracle price pair price between two tokens using a weighted\n    /// average between a chainlink oracle and the balancer TWAP oracle.\n    /// @param poolContext oracle context variables\n    /// @param oracleContext oracle context variables\n    /// @param tradingModule address of the trading module\n    /// @return oraclePairPrice oracle price for the pair in 18 decimals\n    function _getOraclePairPrice(\n        TwoTokenPoolContext memory poolContext,\n        OracleContext memory oracleContext, \n        ITradingModule tradingModule\n    ) internal view returns (uint256 oraclePairPrice) {\n        // NOTE: this balancer price is denominated in 18 decimal places\n        uint256 balancerWeightedPrice;\n        if (oracleContext.balancerOracleWeight > 0) {\n            uint256 balancerPrice = BalancerUtils._getTimeWeightedOraclePrice(\n                address(poolContext.basePool.pool),\n                IPriceOracle.Variable.PAIR_PRICE,\n                oracleContext.oracleWindowInSeconds\n            );\n\n            if (poolContext.primaryIndex == 1) {\n                // If the primary index is the second token, we need to invert\n                // the balancer price.\n                balancerPrice = BalancerConstants.BALANCER_PRECISION_SQUARED / balancerPrice;\n            }\n\n            balancerWeightedPrice = balancerPrice * oracleContext.balancerOracleWeight;\n        }\n\n        uint256 chainlinkWeightedPrice;\n        if (oracleContext.balancerOracleWeight < BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION) {\n            (int256 rate, int256 decimals) = tradingModule.getOraclePrice(\n                poolContext.primaryToken, poolContext.secondaryToken\n            );\n            require(rate > 0);\n            require(decimals >= 0);\n\n            if (uint256(decimals) != BalancerConstants.BALANCER_PRECISION) {\n                rate = (rate * int256(BalancerConstants.BALANCER_PRECISION)) / decimals;\n            }\n\n            // No overflow in rate conversion, checked above\n            chainlinkWeightedPrice = uint256(rate) * \n                (BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION - oracleContext.balancerOracleWeight);\n        }\n\n        oraclePairPrice = (balancerWeightedPrice + chainlinkWeightedPrice) / \n            BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION;\n    }\n\n    /// @notice Gets the time-weighted primary token balance for a given bptAmount\n    /// @dev Balancer pool needs to be fully initialized with at least 1024 trades\n    /// @param poolContext pool context variables\n    /// @param oracleContext oracle context variables\n    /// @param bptAmount amount of balancer pool lp tokens\n    /// @return primaryAmount primary token balance\n    function _getTimeWeightedPrimaryBalance(\n        TwoTokenPoolContext memory poolContext,\n        OracleContext memory oracleContext,\n        StrategyContext memory strategyContext,\n        uint256 bptAmount\n    ) internal view returns (uint256 primaryAmount) {\n        // Gets the BPT token price denominated in token index = 0\n        uint256 bptPrice = BalancerUtils._getTimeWeightedOraclePrice(\n            address(poolContext.basePool.pool),\n            IPriceOracle.Variable.BPT_PRICE,\n            oracleContext.oracleWindowInSeconds\n        );\n\n        uint256 pairPrice = _getOraclePairPrice(poolContext, oracleContext, strategyContext.tradingModule);\n        uint256 primaryPrecision = 10 ** poolContext.primaryDecimals;\n\n        if (poolContext.primaryIndex == 0) {\n            // Since bptPrice is always denominated in the first token, we can just multiply by\n            // the amount in this case. Both bptPrice and bptAmount are in 1e18 but we need to scale\n            // this back to the primary token's native precision.\n            // underlyingValue = (bptPrice * bptAmount * primaryPrecision) / (1e18 * 1e18)\n            primaryAmount = (bptPrice * bptAmount * primaryPrecision) / \n                BalancerConstants.BALANCER_PRECISION_SQUARED;\n        } else {\n            // The second token in the BPT pool is the price that we want to get. In this case, we need to\n            // convert secondaryTokenValue to underlyingValue using the pairPrice.\n            // Both bptPrice and bptAmount are in 1e18\n            uint256 secondaryAmount = (bptPrice * bptAmount) / BalancerConstants.BALANCER_PRECISION;\n\n            // And then normalizing to primary token precision we add:\n            // PrimaryAmount = (SecondaryAmount * primaryPrecision) / PairPrice\n            primaryAmount = (secondaryAmount * primaryPrecision) / pairPrice;\n        }\n    }\n\n    function _approveBalancerTokens(TwoTokenPoolContext memory poolContext, address bptSpender) internal {\n        IERC20(poolContext.primaryToken).checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n        IERC20(poolContext.secondaryToken).checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n        // Allow BPT spender to pull BALANCER_POOL_TOKEN\n        IERC20(address(poolContext.basePool.pool)).checkApprove(bptSpender, type(uint256).max);\n    }\n\n    /// @notice Trade primary currency for secondary if the trade is specified\n    function _tradePrimaryForSecondary(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        bytes memory data\n    ) private returns (uint256 primarySold, uint256 secondaryBought) {\n        (DepositTradeParams memory params) = abi.decode(data, (DepositTradeParams));\n\n        (primarySold, secondaryBought) = StrategyUtils._executeDynamicTradeExactIn({\n            params: params.tradeParams, \n            tradingModule: strategyContext.tradingModule, \n            sellToken: poolContext.primaryToken, \n            buyToken: poolContext.secondaryToken, \n            amount: params.tradeAmount\n        });\n    }\n\n    function _deposit(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        uint256 deposit,\n        DepositParams memory params\n    ) internal returns (uint256 strategyTokensMinted) {\n        uint256 secondaryAmount;\n        if (params.tradeData.length != 0) {\n            // Allows users to trade on a different DEX instead of Balancer when joining\n            (uint256 primarySold, uint256 secondaryBought) = _tradePrimaryForSecondary({\n                poolContext: poolContext,\n                strategyContext: strategyContext,\n                data: params.tradeData\n            });\n            deposit -= primarySold;\n            secondaryAmount = secondaryBought;\n        }\n\n        uint256 bptMinted = poolContext._joinPoolAndStake({\n            strategyContext: strategyContext,\n            stakingContext: stakingContext,\n            primaryAmount: deposit,\n            secondaryAmount: secondaryAmount,\n            minBPT: params.minBPT\n        });\n\n        strategyTokensMinted = strategyContext._convertBPTClaimToStrategyTokens(bptMinted);\n\n        // Update global supply count\n        strategyContext.vaultState.totalStrategyTokenGlobal += strategyTokensMinted.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n\n    function _sellSecondaryBalance(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        RedeemParams memory params,\n        uint256 secondaryBalance\n    ) private returns (uint256 primaryPurchased) {\n        (DynamicTradeParams memory tradeParams) = abi.decode(\n            params.secondaryTradeParams, (DynamicTradeParams)\n        );\n\n        ( /*uint256 amountSold */, primaryPurchased) = \n            StrategyUtils._executeDynamicTradeExactIn({\n                params: tradeParams,\n                tradingModule: strategyContext.tradingModule,\n                sellToken: poolContext.secondaryToken,\n                buyToken: poolContext.primaryToken,\n                amount: secondaryBalance\n            });\n    }\n\n    function _redeem(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        address account,\n        uint256 strategyTokens,\n        uint256 maturity,\n        RedeemParams memory params\n    ) internal returns (uint256 finalPrimaryBalance) {\n        uint256 bptClaim = strategyContext._convertStrategyTokensToBPTClaim(strategyTokens);\n\n        if (bptClaim == 0) return 0;\n\n        // Underlying token balances from exiting the pool\n        (uint256 primaryBalance, uint256 secondaryBalance)\n            = _unstakeAndExitPool(\n                poolContext, stakingContext, bptClaim, params.minPrimary, params.minSecondary\n            );\n\n        finalPrimaryBalance = primaryBalance;\n        if (secondaryBalance > 0) {\n            uint256 primaryPurchased = _sellSecondaryBalance(\n                poolContext, strategyContext, params, secondaryBalance\n            );\n\n            finalPrimaryBalance += primaryPurchased;\n        }\n\n        // Update global strategy token balance\n        strategyContext.vaultState.totalStrategyTokenGlobal -= strategyTokens.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n\n    function _joinPoolAndStake(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        uint256 primaryAmount,\n        uint256 secondaryAmount,\n        uint256 minBPT\n    ) internal returns (uint256 bptMinted) {\n        // prettier-ignore\n        PoolParams memory poolParams = poolContext._getPoolParams( \n            primaryAmount, \n            secondaryAmount,\n            true // isJoin\n        );\n\n        bptMinted = BalancerUtils._joinPoolExactTokensIn({\n            context: poolContext.basePool,\n            params: poolParams,\n            minBPT: minBPT\n        });\n\n        // Check BPT threshold to make sure our share of the pool is\n        // below maxBalancerPoolShare\n        uint256 bptThreshold = strategyContext.vaultSettings._bptThreshold(\n            poolContext.basePool.pool.totalSupply()\n        );\n        uint256 bptHeldAfterJoin = strategyContext.totalBPTHeld + bptMinted;\n        if (bptHeldAfterJoin > bptThreshold)\n            revert Errors.BalancerPoolShareTooHigh(bptHeldAfterJoin, bptThreshold);\n\n        // Transfer token to Aura protocol for boosted staking\n        stakingContext.auraBooster.deposit(stakingContext.auraPoolId, bptMinted, true); // stake = true\n    }\n\n    function _unstakeAndExitPool(\n        TwoTokenPoolContext memory poolContext,\n        AuraStakingContext memory stakingContext,\n        uint256 bptClaim,\n        uint256 minPrimary,\n        uint256 minSecondary\n    ) internal returns (uint256 primaryBalance, uint256 secondaryBalance) {\n        // Withdraw BPT tokens back to the vault for redemption\n        stakingContext.auraRewardPool.withdrawAndUnwrap(bptClaim, false); // claimRewards = false\n\n        uint256[] memory exitBalances = BalancerUtils._exitPoolExactBPTIn({\n            context: poolContext.basePool,\n            params: poolContext._getPoolParams(minPrimary, minSecondary, false), // isJoin = false\n            bptExitAmount: bptClaim\n        });\n        \n        (primaryBalance, secondaryBalance) \n            = (exitBalances[poolContext.primaryIndex], exitBalances[poolContext.secondaryIndex]);\n    }\n\n    /// @notice We value strategy tokens in terms of the primary balance. The time weighted\n    /// primary balance is used in order to prevent pool manipulation.\n    /// @param poolContext pool context variables\n    /// @param oracleContext oracle context variables\n    /// @param strategyTokenAmount amount of strategy tokens\n    /// @return underlyingValue underlying value of strategy tokens\n    function _convertStrategyToUnderlying(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        OracleContext memory oracleContext,\n        uint256 strategyTokenAmount\n    ) internal view returns (int256 underlyingValue) {\n        \n        uint256 bptClaim \n            = strategyContext._convertStrategyTokensToBPTClaim(strategyTokenAmount);\n\n        underlyingValue \n            = poolContext._getTimeWeightedPrimaryBalance(oracleContext, strategyContext, bptClaim).toInt();\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/internal/pool/Boosted3TokenPoolUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {\n    ThreeTokenPoolContext,\n    TwoTokenPoolContext,\n    BoostedOracleContext,\n    AuraStakingContext,\n    StrategyContext,\n    StrategyVaultSettings,\n    StrategyVaultState\n} from \"../../BalancerVaultTypes.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {Deployments} from \"../../../../global/Deployments.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {BalancerUtils} from \"../pool/BalancerUtils.sol\";\nimport {Boosted3TokenPoolUtils} from \"../pool/Boosted3TokenPoolUtils.sol\";\nimport {StableMath} from \"../math/StableMath.sol\";\nimport {AuraStakingUtils} from \"../staking/AuraStakingUtils.sol\";\nimport {StrategyUtils} from \"../strategy/StrategyUtils.sol\";\nimport {BalancerVaultStorage} from \"../BalancerVaultStorage.sol\";\nimport {ITradingModule} from \"../../../../../interfaces/trading/ITradingModule.sol\";\nimport {IBoostedPool} from \"../../../../../interfaces/balancer/IBalancerPool.sol\";\nimport {TokenUtils, IERC20} from \"../../../../utils/TokenUtils.sol\";\nimport {TwoTokenPoolUtils} from \"./TwoTokenPoolUtils.sol\";\nimport {FixedPoint} from \"../math/FixedPoint.sol\";\n\nlibrary Boosted3TokenPoolUtils {\n    using TypeConvert for uint256;\n    using FixedPoint for uint256;\n    using TypeConvert for int256;\n    using TokenUtils for IERC20;\n    using TwoTokenPoolUtils for TwoTokenPoolContext;\n    using Boosted3TokenPoolUtils for ThreeTokenPoolContext;\n    using AuraStakingUtils for AuraStakingContext;\n    using StrategyUtils for StrategyContext;\n    using BalancerVaultStorage for StrategyVaultSettings;\n    using BalancerVaultStorage for StrategyVaultState;\n\n    // Preminted BPT is sometimes called Phantom BPT, as the preminted BPT (which is deposited in the Vault as balance of\n    // the Pool) doesn't belong to any entity until transferred out of the Pool. The Pool's arithmetic behaves as if it\n    // didn't exist, and the BPT total supply is not a useful value: we rely on the 'virtual supply' (how much BPT is\n    // actually owned by some entity) instead.\n    uint256 private constant _MAX_TOKEN_BALANCE = 2**(112) - 1;\n\n    function _getSpotPrice(\n        uint256 ampParam,\n        uint256 invariant,\n        uint256[] memory balances, \n        uint8 tokenIndexIn, \n        uint8 tokenIndexOut\n    ) private pure returns (uint256 spotPrice) {\n        // Trade 1 unit of tokenIn for tokenOut to get the spot price\n        uint256 amountIn = BalancerConstants.BALANCER_PRECISION;\n        uint256 amountOut = StableMath._calcOutGivenIn({\n            amplificationParameter: ampParam,\n            balances: balances,\n            tokenIndexIn: tokenIndexIn,\n            tokenIndexOut: tokenIndexOut,\n            tokenAmountIn: amountIn,\n            invariant: invariant\n        });\n        spotPrice = amountOut;\n    }\n\n    function _validateSpotPrice(\n        StrategyContext memory context,\n        address tokenIn,\n        uint8 tokenIndexIn,\n        address tokenOut,\n        uint8 tokenIndexOut,\n        uint256[] memory balances,\n        uint256 ampParam,\n        uint256 invariant\n    ) private view {\n        (int256 answer, int256 decimals) = context.tradingModule.getOraclePrice(tokenOut, tokenIn);\n        require(decimals == int256(BalancerConstants.BALANCER_PRECISION));\n        \n        uint256 spotPrice = _getSpotPrice({\n            ampParam: ampParam,\n            invariant: invariant,\n            balances: balances, \n            tokenIndexIn: tokenIndexIn, // Primary index\n            tokenIndexOut: tokenIndexOut // Secondary index\n        }); \n\n        uint256 oraclePrice = answer.toUint();\n        uint256 lowerLimit = (oraclePrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS - context.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n        uint256 upperLimit = (oraclePrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS + context.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n\n        // Check spot price against oracle price to make sure it hasn't been manipulated\n        if (spotPrice < lowerLimit || upperLimit < spotPrice) {\n            revert Errors.InvalidPrice(oraclePrice, spotPrice);\n        }\n    }\n\n    function _validateTokenPrices(\n        ThreeTokenPoolContext memory poolContext, \n        StrategyContext memory strategyContext,\n        uint256[] memory balances,\n        uint256 ampParam,\n        uint256 invariant\n    ) private view {\n        address primaryUnderlying = IBoostedPool(address(poolContext.basePool.primaryToken)).getMainToken();\n        address secondaryUnderlying = IBoostedPool(address(poolContext.basePool.secondaryToken)).getMainToken();\n        address tertiaryUnderlying = IBoostedPool(address(poolContext.tertiaryToken)).getMainToken();\n\n        _validateSpotPrice({\n            context: strategyContext,\n            tokenIn: primaryUnderlying,\n            tokenIndexIn: 0, // primary index\n            tokenOut: secondaryUnderlying,\n            tokenIndexOut: 1, // secondary index\n            balances: balances,\n            ampParam: ampParam,\n            invariant: invariant\n        });\n\n        _validateSpotPrice({\n            context: strategyContext,\n            tokenIn: primaryUnderlying,\n            tokenIndexIn: 0, // primary index\n            tokenOut: tertiaryUnderlying,\n            tokenIndexOut: 2, // secondary index\n            balances: balances,\n            ampParam: ampParam,\n            invariant: invariant\n        });\n    }\n\n    function _getVirtualSupply(\n        ThreeTokenPoolContext memory poolContext, \n        BoostedOracleContext memory oracleContext\n    ) internal pure returns (uint256 virtualSupply) {\n        // The initial amount of BPT pre-minted is _MAX_TOKEN_BALANCE and it goes entirely to the pool balance in the\n        // vault. So the virtualSupply (the actual supply in circulation) is defined as:\n        // virtualSupply = totalSupply() - (_balances[_bptIndex] - _dueProtocolFeeBptAmount)\n        //\n        // However, since this Pool never mints or burns BPT outside of the initial supply (except in the event of an\n        // emergency pause), we can simply use `_MAX_TOKEN_BALANCE` instead of `totalSupply()` and save\n        // gas.\n        virtualSupply = _MAX_TOKEN_BALANCE - oracleContext.bptBalance + oracleContext.dueProtocolFeeBptAmount;\n    }\n\n    function _getVirtualSupplyAndBalances(\n        ThreeTokenPoolContext memory poolContext, \n        BoostedOracleContext memory oracleContext\n    ) private pure returns (uint256 virtualSupply, uint256[] memory amountsWithoutBpt) {\n        virtualSupply = _getVirtualSupply(poolContext, oracleContext);\n\n        amountsWithoutBpt = new uint256[](3);\n        amountsWithoutBpt[0] = poolContext.basePool.primaryBalance;\n        amountsWithoutBpt[1] = poolContext.basePool.secondaryBalance;\n        amountsWithoutBpt[2] = poolContext.tertiaryBalance;\n    }\n\n    function _getValidatedPoolData(\n        ThreeTokenPoolContext memory poolContext,\n        BoostedOracleContext memory oracleContext,\n        StrategyContext memory strategyContext\n    ) internal view returns (uint256 virtualSupply, uint256[] memory balances, uint256 invariant) {\n        (virtualSupply, balances) = \n            _getVirtualSupplyAndBalances(poolContext, oracleContext);\n\n        // Get the current and new invariants. Since we need a bigger new invariant, we round the current one up.\n        invariant = StableMath._calculateInvariant(\n            oracleContext.ampParam, balances, true // roundUp = true\n        );\n\n        // validate spot prices against oracle prices\n        _validateTokenPrices({\n            poolContext: poolContext,\n            strategyContext: strategyContext,\n            balances: balances,\n            ampParam: oracleContext.ampParam,\n            invariant: invariant\n        });\n    }\n\n    /// @notice Gets the time-weighted primary token balance for a given bptAmount\n    /// @dev Boosted pool can't use the Balancer oracle, using Chainlink instead\n    /// @param poolContext pool context variables\n    /// @param oracleContext oracle context variables\n    /// @param bptAmount amount of balancer pool lp tokens\n    /// @return primaryAmount primary token balance\n    function _getTimeWeightedPrimaryBalance(\n        ThreeTokenPoolContext memory poolContext,\n        BoostedOracleContext memory oracleContext,\n        StrategyContext memory strategyContext,\n        uint256 bptAmount\n    ) internal view returns (uint256 primaryAmount) {\n        (\n           uint256 virtualSupply, \n           uint256[] memory balances, \n           uint256 invariant\n        ) = _getValidatedPoolData(poolContext, oracleContext, strategyContext);\n\n        // NOTE: For Boosted 3 token pools, the LP token (BPT) is just another\n        // token in the pool. So, we first use _calcTokenOutGivenExactBptIn\n        // to calculate the value of 1 BPT. Then, we scale it to the BPT\n        // amount to get the value in terms of the primary currency.\n        // Use virtual total supply and zero swap fees for joins\n        primaryAmount = StableMath._calcTokenOutGivenExactBptIn({\n            amp: oracleContext.ampParam, \n            balances: balances, \n            tokenIndex: 0, \n            bptAmountIn: BalancerConstants.BALANCER_PRECISION, // 1 BPT \n            bptTotalSupply: virtualSupply, \n            swapFeePercentage: 0, \n            currentInvariant: invariant\n        });\n\n        uint256 primaryPrecision = 10 ** poolContext.basePool.primaryDecimals;\n        primaryAmount = (primaryAmount * bptAmount * primaryPrecision) / BalancerConstants.BALANCER_PRECISION_SQUARED;\n    }\n\n    function _approveBalancerTokens(ThreeTokenPoolContext memory poolContext, address bptSpender) internal {\n        poolContext.basePool._approveBalancerTokens(bptSpender);\n\n        IERC20(poolContext.tertiaryToken).checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n\n        // For boosted pools, the tokens inside pool context are AaveLinearPool tokens.\n        // So, we need to approve the _underlyingToken (primary borrow currency) for trading.\n        IBoostedPool underlyingPool = IBoostedPool(poolContext.basePool.primaryToken);\n        address primaryUnderlyingAddress = BalancerUtils.getTokenAddress(underlyingPool.getMainToken());\n        IERC20(primaryUnderlyingAddress).checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n    }\n\n    function _joinPoolExactTokensIn(ThreeTokenPoolContext memory context, uint256 primaryAmount, uint256 minBPT)\n        private returns (uint256 bptAmount) {\n        IBoostedPool underlyingPool = IBoostedPool(address(context.basePool.primaryToken));\n\n        // Swap underlyingToken for LinearPool BPT\n        uint256 linearPoolBPT = BalancerUtils._swapGivenIn({\n            poolId: underlyingPool.getPoolId(),\n            tokenIn: underlyingPool.getMainToken(),\n            tokenOut: address(underlyingPool),\n            amountIn: primaryAmount,\n            limit: 0 // slippage checked on the second swap\n        });\n\n        // Swap LinearPool BPT for Boosted BPT\n        bptAmount = BalancerUtils._swapGivenIn({\n            poolId: context.basePool.basePool.poolId,\n            tokenIn: address(underlyingPool),\n            tokenOut: address(context.basePool.basePool.pool), // Boosted pool\n            amountIn: linearPoolBPT,\n            limit: minBPT\n        });\n    }\n\n    function _exitPoolExactBPTIn(ThreeTokenPoolContext memory context, uint256 bptExitAmount, uint256 minPrimary)\n        private returns (uint256 primaryBalance) {\n        IBoostedPool underlyingPool = IBoostedPool(address(context.basePool.primaryToken));\n\n        // Swap Boosted BPT for LinearPool BPT\n        uint256 linearPoolBPT = BalancerUtils._swapGivenIn({\n            poolId: context.basePool.basePool.poolId,\n            tokenIn: address(context.basePool.basePool.pool), // Boosted pool\n            tokenOut: address(underlyingPool),\n            amountIn: bptExitAmount,\n            limit: 0 // slippage checked on the second swap\n        });\n\n        // Swap LinearPool BPT for underlyingToken\n        primaryBalance = BalancerUtils._swapGivenIn({\n            poolId: underlyingPool.getPoolId(),\n            tokenIn: address(underlyingPool),\n            tokenOut: underlyingPool.getMainToken(),\n            amountIn: linearPoolBPT,\n            limit: minPrimary\n        }); \n    }\n\n    function _deposit(\n        ThreeTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        BoostedOracleContext memory oracleContext,\n        uint256 deposit,\n        uint256 minBPT\n    ) internal returns (uint256 strategyTokensMinted) {\n        uint256 bptMinted = poolContext._joinPoolAndStake({\n            strategyContext: strategyContext,\n            stakingContext: stakingContext,\n            oracleContext: oracleContext,\n            deposit: deposit,\n            minBPT: minBPT\n        });\n\n        strategyTokensMinted = strategyContext._convertBPTClaimToStrategyTokens(bptMinted);\n\n        // Update global supply count\n        strategyContext.vaultState.totalStrategyTokenGlobal += strategyTokensMinted.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n\n    function _redeem(\n        ThreeTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        uint256 strategyTokens,\n        uint256 minPrimary\n    ) internal returns (uint256 finalPrimaryBalance) {\n        uint256 bptClaim = strategyContext._convertStrategyTokensToBPTClaim(strategyTokens);\n\n        if (bptClaim == 0) return 0;\n\n        finalPrimaryBalance = _unstakeAndExitPool({\n            stakingContext: stakingContext,\n            poolContext: poolContext,\n            bptClaim: bptClaim,\n            minPrimary: minPrimary\n        });\n\n        strategyContext.vaultState.totalStrategyTokenGlobal -= strategyTokens.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n\n    function _joinPoolAndStake(\n        ThreeTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        BoostedOracleContext memory oracleContext,\n        uint256 deposit,\n        uint256 minBPT\n    ) internal returns (uint256 bptMinted) {\n        bptMinted = _joinPoolExactTokensIn(poolContext, deposit, minBPT);\n\n        // Check BPT threshold to make sure our share of the pool is\n        // below maxBalancerPoolShare\n        uint256 bptThreshold = strategyContext.vaultSettings._bptThreshold(\n            poolContext._getVirtualSupply(oracleContext)\n        );\n        uint256 bptHeldAfterJoin = strategyContext.totalBPTHeld + bptMinted;\n        if (bptHeldAfterJoin > bptThreshold)\n            revert Errors.BalancerPoolShareTooHigh(bptHeldAfterJoin, bptThreshold);\n\n        // Transfer token to Aura protocol for boosted staking\n        stakingContext.auraBooster.deposit(stakingContext.auraPoolId, bptMinted, true); // stake = true\n    }\n\n    function _unstakeAndExitPool(\n        ThreeTokenPoolContext memory poolContext,\n        AuraStakingContext memory stakingContext,\n        uint256 bptClaim,\n        uint256 minPrimary\n    ) internal returns (uint256 primaryBalance) {\n        // Withdraw BPT tokens back to the vault for redemption\n        stakingContext.auraRewardPool.withdraw"
    }
  ]
}