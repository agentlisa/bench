{
  "Title": "Function without logic",
  "Content": "##### Description\nAt the line https://github.com/Grandthrax/yearnV2-generic-lender-strat/blob/979ef2f0e5da39ca59a5907c37ba2064fcd6be82/contracts/Interfaces/GenericLender/IGeneric.sol#L23 has an external function `enabled()`.\nThis function always returns true when executed. There is no other logic in this function.\nThis function is located in the following locations:\n- at the line https://github.com/Grandthrax/yearnV2-generic-lender-strat/blob/979ef2f0e5da39ca59a5907c37ba2064fcd6be82/contracts/GenericLender/AlphaHomoLender.sol#L177\n- at the line https://github.com/Grandthrax/yearnV2-generic-lender-strat/blob/979ef2f0e5da39ca59a5907c37ba2064fcd6be82/contracts/GenericLender/EthCompound.sol#L164\n- at the line https://github.com/Grandthrax/yearnV2-generic-lender-strat/blob/979ef2f0e5da39ca59a5907c37ba2064fcd6be82/contracts/GenericLender/EthCream.sol#L143\n- at the line https://github.com/Grandthrax/yearnV2-generic-lender-strat/blob/979ef2f0e5da39ca59a5907c37ba2064fcd6be82/contracts/GenericLender/GenericCompound.sol#L150\n- at the line https://github.com/Grandthrax/yearnV2-generic-lender-strat/blob/979ef2f0e5da39ca59a5907c37ba2064fcd6be82/contracts/GenericLender/GenericCream.sol#L129\n- at the line https://github.com/Grandthrax/yearnV2-generic-lender-strat/blob/979ef2f0e5da39ca59a5907c37ba2064fcd6be82/contracts/GenericLender/GenericDyDx.sol#L160\n\n##### Recommendation\nIt is recommended that you remove this function or add logic to the body of the function.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Interfaces/GenericLender/IGeneric.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.6.12;\n\ninterface IGeneric {\n    //state changing\n\n    function withdraw(uint256 amount) external returns (uint256);\n\n    function emergencyWithdraw(uint256 amount) external;\n\n    function deposit() external;\n\n    function withdrawAll() external returns (bool);\n\n    //view only\n\n    function nav() external view returns (uint256);\n\n    function apr() external view returns (uint256);\n\n    function weightedApr() external view returns (uint256);\n\n    function enabled() external view returns (bool);\n\n    function hasAssets() external view returns (bool);\n\n    function aprAfterDeposit(uint256 amount) external view returns (uint256);\n}"
    },
    {
      "filename": "contracts/GenericLender/AlphaHomoLender.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../Interfaces/alpha-homora/Bank.sol\";\nimport \"../Interfaces/alpha-homora/BankConfig.sol\";\nimport \"../Interfaces/UniswapInterfaces/IWETH.sol\";\n\nimport \"./GenericLenderBase.sol\";\n\n/********************\n *   A lender plugin for LenderYieldOptimiser for any erc20 asset on Cream (not eth)\n *   Made by SamPriestley.com\n *   https://github.com/Grandthrax/yearnv2/blob/master/contracts/GenericLender/GenericCream.sol\n *\n ********************* */\n\ncontract AlphaHomo is GenericLenderBase {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    uint256 private constant secondsPerYear = 31556952;\n    address public constant weth = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    address public constant bank = address(0x67B66C99D3Eb37Fa76Aa3Ed1ff33E8e39F0b9c7A);\n\n    constructor(address _strategy, string memory name) public GenericLenderBase(_strategy, name) {\n        require(address(want) == weth, \"NOT WETH\");\n        dust = 1e12;\n        //want.approve(_cToken, uint256(-1));\n    }\n\n    receive() external payable {}\n\n    function nav() external view override returns (uint256) {\n        return _nav();\n    }\n\n    function _nav() internal view returns (uint256) {\n        return want.balanceOf(address(this)).add(underlyingBalanceStored());\n    }\n\n    function withdrawUnderlying(uint256 amount) internal returns (uint256) {\n        Bank b = Bank(bank);\n\n        uint256 shares = amount.mul(b.totalSupply()).div(_bankTotalEth());\n        //uint256 shares = amount.mul(b.glbDebtVal().add(b.pendingInterest(0))).div(b.glbDebtShare());\n        // uint256 shares = b.debtValToShare(amount);\n        uint256 balance = b.balanceOf(address(this));\n        if (shares > balance) {\n            b.withdraw(balance);\n        } else {\n            b.withdraw(shares);\n        }\n\n        uint256 withdrawn = address(this).balance;\n        IWETH(weth).deposit{value: withdrawn}();\n\n        return withdrawn;\n    }\n\n    function underlyingBalanceStored() public view returns (uint256 balance) {\n        Bank b = Bank(bank);\n        return b.balanceOf(address(this)).mul(_bankTotalEth()).div(b.totalSupply());\n        //return b.balanceOf(address(this)).mul(b.glbDebtVal().add(b.pendingInterest(0))).div(b.glbDebtShare());\n    }\n\n    function _bankTotalEth() internal view returns (uint256 _totalEth) {\n        Bank b = Bank(bank);\n\n        uint256 interest = b.pendingInterest(0);\n        BankConfig config = BankConfig(b.config());\n        uint256 toReserve = interest.mul(config.getReservePoolBps()).div(10000);\n\n        uint256 glbDebtVal = b.glbDebtVal().add(interest);\n        uint256 reservePool = b.reservePool().add(toReserve);\n\n        _totalEth = bank.balance.add(glbDebtVal).sub(reservePool);\n    }\n\n    function apr() external view override returns (uint256) {\n        return _apr(0);\n    }\n\n    function aprAfterDeposit(uint256 amount) external view override returns (uint256) {\n        return _apr(amount);\n    }\n\n    function _apr(uint256 amount) internal view returns (uint256) {\n        Bank b = Bank(bank);\n        BankConfig config = BankConfig(b.config());\n        uint256 balance = bank.balance.add(amount);\n        uint256 ratePerSec = config.getInterestRate(b.glbDebtVal(), balance);\n\n        return ratePerSec.mul(secondsPerYear);\n    }\n\n    function weightedApr() external view override returns (uint256) {\n        uint256 a = _apr(0);\n        return a.mul(_nav());\n    }\n\n    function withdraw(uint256 amount) external override management returns (uint256) {\n        return _withdraw(amount);\n    }\n\n    //emergency withdraw. sends balance plus amount to governance\n    function emergencyWithdraw(uint256 amount) external override management {\n        withdrawUnderlying(amount);\n\n        want.safeTransfer(vault.governance(), want.balanceOf(address(this)));\n    }\n\n    //withdraw an amount including any want balance\n    function _withdraw(uint256 amount) internal returns (uint256) {\n        uint256 balanceUnderlying = underlyingBalanceStored();\n        uint256 looseBalance = want.balanceOf(address(this));\n        uint256 total = balanceUnderlying.add(looseBalance);\n\n        if (amount > total) {\n            //cant withdraw more than we own\n            amount = total;\n        }\n        if (looseBalance >= amount) {\n            want.safeTransfer(address(strategy), amount);\n            return amount;\n        }\n\n        //not state changing but OK because of previous call\n        uint256 liquidity = bank.balance;\n\n        if (liquidity > 1) {\n            uint256 toWithdraw = amount.sub(looseBalance);\n\n            if (toWithdraw <= liquidity) {\n                //we can take all\n                withdrawUnderlying(toWithdraw);\n            } else {\n                //take all we can\n                withdrawUnderlying(liquidity);\n            }\n        }\n        looseBalance = want.balanceOf(address(this));\n        want.safeTransfer(address(strategy), looseBalance);\n        return looseBalance;\n    }\n\n    function deposit() external override management {\n        uint256 balance = want.balanceOf(address(this));\n\n        IWETH(weth).withdraw(balance);\n        Bank(bank).deposit{value: balance}();\n    }\n\n    function withdrawAll() external override management returns (bool) {\n        uint256 invested = _nav();\n        Bank b = Bank(bank);\n\n        uint256 balance = b.balanceOf(address(this));\n\n        b.withdraw(balance);\n\n        uint256 withdrawn = address(this).balance;\n        IWETH(weth).deposit{value: withdrawn}();\n        uint256 returned = want.balanceOf(address(this));\n        want.safeTransfer(address(strategy), returned);\n\n        return returned.add(dust) >= invested;\n    }\n\n    //think about this\n    function enabled() external view override returns (bool) {\n        return true;\n    }\n\n    function hasAssets() external view override returns (bool) {\n        uint256 bankBal = Bank(bank).balanceOf(address(this));\n        uint256 wantBal = want.balanceOf(address(this));\n\n        //adding apples to oranges but doesnt matter as we are just looking for rounding errors\n        return bankBal.add(wantBal) > dust;\n    }\n\n    function protectedTokens() internal view override returns (address[] memory) {\n        address[] memory protected = new address[](2);\n        protected[0] = address(want);\n        protected[1] = bank;\n        return protected;\n    }\n}"
    },
    {
      "filename": "contracts/GenericLender/EthCompound.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../Interfaces/Compound/InterestRateModel.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../Interfaces/UniswapInterfaces/IUniswapV2Router02.sol\";\n\nimport \"../Interfaces/Compound/CEtherI.sol\";\nimport \"../Interfaces/UniswapInterfaces/IWETH.sol\";\n\nimport \"./GenericLenderBase.sol\";\n\n/********************\n *   A lender plugin for LenderYieldOptimiser for any erc20 asset on Cream (not eth)\n *   Made by SamPriestley.com\n *   https://github.com/Grandthrax/yearnv2/blob/master/contracts/GenericLender/GenericCream.sol\n *\n ********************* */\n\ncontract EthCompound is GenericLenderBase {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    uint256 private constant blocksPerYear = 2_300_000;\n    IWETH public constant weth = IWETH(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2));\n    CEtherI public constant crETH = CEtherI(address(0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5));\n    address public constant comp = address(0xc00e94Cb662C3520282E6f5717214004A7f26888);\n    address public constant uniswapRouter = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n\n    uint256 public minCompToSell = 0.5 ether;\n\n    constructor(address _strategy, string memory name) public GenericLenderBase(_strategy, name) {\n        require(address(want) == address(weth), \"NOT WETH\");\n        dust = 10;\n    }\n\n    //to receive eth from weth\n    receive() external payable {}\n\n    function nav() external view override returns (uint256) {\n        return _nav();\n    }\n\n    function _nav() internal view returns (uint256) {\n        return want.balanceOf(address(this)).add(underlyingBalanceStored());\n    }\n\n    function underlyingBalanceStored() public view returns (uint256 balance) {\n        uint256 currentCr = crETH.balanceOf(address(this));\n        if (currentCr == 0) {\n            balance = 0;\n        } else {\n            balance = currentCr.mul(crETH.exchangeRateStored()).div(1e18);\n        }\n    }\n\n    function apr() external view override returns (uint256) {\n        return _apr();\n    }\n\n    function _apr() internal view returns (uint256) {\n        return crETH.supplyRatePerBlock().mul(blocksPerYear);\n    }\n\n    function weightedApr() external view override returns (uint256) {\n        uint256 a = _apr();\n        return a.mul(_nav());\n    }\n\n    function withdraw(uint256 amount) external override management returns (uint256) {\n        return _withdraw(amount);\n    }\n\n    //emergency withdraw. sends balance plus amount to governance\n    function emergencyWithdraw(uint256 amount) external override management {\n        crETH.redeemUnderlying(amount);\n\n        //now turn to weth\n        weth.deposit{value: address(this).balance}();\n\n        want.safeTransfer(vault.governance(), want.balanceOf(address(this)));\n    }\n\n    //withdraw an amount including any want balance\n    function _withdraw(uint256 amount) internal returns (uint256) {\n        uint256 balanceUnderlying = crETH.balanceOfUnderlying(address(this));\n        uint256 looseBalance = want.balanceOf(address(this));\n        uint256 total = balanceUnderlying.add(looseBalance);\n\n        if (amount > total) {\n            //cant withdraw more than we own\n            amount = total;\n        }\n        if (looseBalance >= amount) {\n            want.safeTransfer(address(strategy), amount);\n            return amount;\n        }\n\n        //not state changing but OK because of previous call\n        uint256 liquidity = crETH.getCash();\n\n        if (liquidity > 1) {\n            uint256 toWithdraw = amount.sub(looseBalance);\n\n            if (toWithdraw <= liquidity) {\n                //we can take all\n                crETH.redeemUnderlying(toWithdraw);\n            } else {\n                //take all we can\n                crETH.redeemUnderlying(liquidity);\n            }\n        }\n\n        weth.deposit{value: address(this).balance}();\n\n        _disposeOfComp();\n\n        looseBalance = want.balanceOf(address(this));\n        want.safeTransfer(address(strategy), looseBalance);\n        return looseBalance;\n    }\n\n    function _disposeOfComp() internal {\n        uint256 _comp = IERC20(comp).balanceOf(address(this));\n\n        if (_comp > minCompToSell) {\n            address[] memory path = new address[](2);\n            path[0] = comp;\n            path[1] = address(want);\n\n            IUniswapV2Router02(uniswapRouter).swapExactTokensForTokens(_comp, uint256(0), path, address(this), now);\n        }\n    }\n\n    function deposit() external override management {\n        uint256 balance = want.balanceOf(address(this));\n\n        weth.withdraw(balance);\n        crETH.mint{value: balance}();\n    }\n\n    function withdrawAll() external override management returns (bool) {\n        uint256 invested = _nav();\n\n        uint256 balance = crETH.balanceOf(address(this));\n\n        crETH.redeem(balance);\n\n        uint256 withdrawn = address(this).balance;\n        IWETH(weth).deposit{value: withdrawn}();\n        uint256 returned = want.balanceOf(address(this));\n        want.safeTransfer(address(strategy), returned);\n\n        return returned.add(dust) >= invested;\n    }\n\n    //think about this\n    function enabled() external view override returns (bool) {\n        return true;\n    }\n\n    function hasAssets() external view override returns (bool) {\n        return crETH.balanceOf(address(this)) > dust;\n    }\n\n    function aprAfterDeposit(uint256 amount) external view override returns (uint256) {\n        uint256 cashPrior = crETH.getCash();\n\n        uint256 borrows = crETH.totalBorrows();\n        uint256 reserves = crETH.totalReserves();\n\n        uint256 exchangeRate = crETH.exchangeRateStored();\n        uint256 totalSupply = crETH.totalSupply();\n\n        uint256 underlying = totalSupply.mul(exchangeRate).div(1e18).add(amount);\n\n        uint256 reserverFactor = crETH.reserveFactorMantissa();\n        InterestRateModel model = crETH.interestRateModel();\n\n        //the supply rate is derived from the borrow rate, reserve factor and the amount of total borrows.\n        (, uint256 borrowRate) = model.getBorrowRate(cashPrior.add(amount), borrows, reserves);\n\n        uint256 borrowsPer = uint256(1e18).mul(borrows).div(underlying);\n\n        uint256 supplyRate = borrowRate.mul(uint256(1e18).sub(reserverFactor)).mul(borrowsPer).div(1e18).div(1e18);\n\n        return supplyRate.mul(blocksPerYear);\n    }\n\n    function protectedTokens() internal view override returns (address[] memory) {\n        address[] memory protected = new address[](3);\n        protected[0] = address(want);\n        protected[1] = address(crETH);\n        protected[2] = comp;\n        return protected;\n    }\n}"
    },
    {
      "filename": "contracts/GenericLender/EthCream.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../Interfaces/Compound/InterestRateModel.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../Interfaces/Compound/CEtherI.sol\";\nimport \"../Interfaces/UniswapInterfaces/IWETH.sol\";\n\nimport \"./GenericLenderBase.sol\";\n\n/********************\n *   A lender plugin for LenderYieldOptimiser for any erc20 asset on Cream (not eth)\n *   Made by SamPriestley.com\n *   https://github.com/Grandthrax/yearnv2/blob/master/contracts/GenericLender/GenericCream.sol\n *\n ********************* */\n\ncontract EthCream is GenericLenderBase {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    uint256 private constant blocksPerYear = 2_300_000;\n    IWETH public constant weth = IWETH(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2));\n    CEtherI public constant crETH = CEtherI(address(0xD06527D5e56A3495252A528C4987003b712860eE));\n\n    constructor(address _strategy, string memory name) public GenericLenderBase(_strategy, name) {\n        require(address(want) == address(weth), \"NOT WETH\");\n        dust = 10;\n    }\n\n    //to receive eth from weth\n    receive() external payable {}\n\n    function nav() external view override returns (uint256) {\n        return _nav();\n    }\n\n    function _nav() internal view returns (uint256) {\n        return want.balanceOf(address(this)).add(underlyingBalanceStored());\n    }\n\n    function underlyingBalanceStored() public view returns (uint256 balance) {\n        uint256 currentCr = crETH.balanceOf(address(this));\n        if (currentCr == 0) {\n            balance = 0;\n        } else {\n            balance = currentCr.mul(crETH.exchangeRateStored()).div(1e18);\n        }\n    }\n\n    function apr() external view override returns (uint256) {\n        return _apr();\n    }\n\n    function _apr() internal view returns (uint256) {\n        return crETH.supplyRatePerBlock().mul(blocksPerYear);\n    }\n\n    function weightedApr() external view override returns (uint256) {\n        uint256 a = _apr();\n        return a.mul(_nav());\n    }\n\n    function withdraw(uint256 amount) external override management returns (uint256) {\n        return _withdraw(amount);\n    }\n\n    //emergency withdraw. sends balance plus amount to governance\n    function emergencyWithdraw(uint256 amount) external override management {\n        crETH.redeemUnderlying(amount);\n\n        //now turn to weth\n        weth.deposit{value: address(this).balance}();\n\n        want.safeTransfer(vault.governance(), want.balanceOf(address(this)));\n    }\n\n    //withdraw an amount including any want balance\n    function _withdraw(uint256 amount) internal returns (uint256) {\n        uint256 balanceUnderlying = crETH.balanceOfUnderlying(address(this));\n        uint256 looseBalance = want.balanceOf(address(this));\n        uint256 total = balanceUnderlying.add(looseBalance);\n\n        if (amount > total) {\n            //cant withdraw more than we own\n            amount = total;\n        }\n        if (looseBalance >= amount) {\n            want.safeTransfer(address(strategy), amount);\n            return amount;\n        }\n\n        //not state changing but OK because of previous call\n        uint256 liquidity = crETH.getCash();\n\n        if (liquidity > 1) {\n            uint256 toWithdraw = amount.sub(looseBalance);\n\n            if (toWithdraw <= liquidity) {\n                //we can take all\n                crETH.redeemUnderlying(toWithdraw);\n            } else {\n                //take all we can\n                crETH.redeemUnderlying(liquidity);\n            }\n        }\n\n        weth.deposit{value: address(this).balance}();\n        looseBalance = want.balanceOf(address(this));\n        want.safeTransfer(address(strategy), looseBalance);\n        return looseBalance;\n    }\n\n    function deposit() external override management {\n        uint256 balance = want.balanceOf(address(this));\n\n        weth.withdraw(balance);\n        crETH.mint{value: balance}();\n    }\n\n    function withdrawAll() external override management returns (bool) {\n        uint256 invested = _nav();\n\n        uint256 balance = crETH.balanceOf(address(this));\n\n        crETH.redeem(balance);\n\n        uint256 withdrawn = address(this).balance;\n        IWETH(weth).deposit{value: withdrawn}();\n        uint256 returned = want.balanceOf(address(this));\n        want.safeTransfer(address(strategy), returned);\n\n        return returned.add(dust) >= invested;\n    }\n\n    //think about this\n    function enabled() external view override returns (bool) {\n        return true;\n    }\n\n    function hasAssets() external view override returns (bool) {\n        return crETH.balanceOf(address(this)) > dust;\n    }\n\n    function aprAfterDeposit(uint256 amount) external view override returns (uint256) {\n        uint256 cashPrior = crETH.getCash();\n\n        uint256 borrows = crETH.totalBorrows();\n        uint256 reserves = crETH.totalReserves();\n\n        uint256 reserverFactor = crETH.reserveFactorMantissa();\n        InterestRateModel model = crETH.interestRateModel();\n\n        //the supply rate is derived from the borrow rate, reserve factor and the amount of total borrows.\n        uint256 supplyRate = model.getSupplyRate(cashPrior.add(amount), borrows, reserves, reserverFactor);\n\n        return supplyRate.mul(blocksPerYear);\n    }\n\n    function protectedTokens() internal view override returns (address[] memory) {\n        address[] memory protected = new address[](2);\n        protected[0] = address(want);\n        protected[1] = address(crETH);\n        return protected;\n    }\n}"
    },
    {
      "filename": "contracts/GenericLender/GenericCompound.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../Interfaces/Compound/CErc20I.sol\";\nimport \"../Interfaces/Compound/InterestRateModel.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../Interfaces/UniswapInterfaces/IUniswapV2Router02.sol\";\n\nimport \"./GenericLenderBase.sol\";\n\n/********************\n *   A lender plugin for LenderYieldOptimiser for any erc20 asset on compound (not eth)\n *   Made by SamPriestley.com\n *   https://github.com/Grandthrax/yearnv2/blob/master/contracts/GenericDyDx/GenericCompound.sol\n *\n ********************* */\n\ncontract GenericCompound is GenericLenderBase {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    uint256 private constant blocksPerYear = 2_300_000;\n    address public constant uniswapRouter = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    address public constant comp = address(0xc00e94Cb662C3520282E6f5717214004A7f26888);\n    address public constant weth = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    uint256 public minCompToSell = 0.5 ether;\n\n    CErc20I public cToken;\n\n    constructor(\n        address _strategy,\n        string memory name,\n        address _cToken\n    ) public GenericLenderBase(_strategy, name) {\n        cToken = CErc20I(_cToken);\n\n        require(cToken.underlying() == address(want), \"WRONG CTOKEN\");\n\n        want.approve(_cToken, uint256(-1));\n    }\n\n    function nav() external view override returns (uint256) {\n        return _nav();\n    }\n\n    function _nav() internal view returns (uint256) {\n        return want.balanceOf(address(this)).add(underlyingBalanceStored());\n    }\n\n    function underlyingBalanceStored() public view returns (uint256 balance) {\n        uint256 currentCr = cToken.balanceOf(address(this));\n        if (currentCr == 0) {\n            balance = 0;\n        } else {\n            balance = currentCr.mul(cToken.exchangeRateStored()).div(1e18);\n        }\n    }\n\n    function apr() external view override returns (uint256) {\n        return _apr();\n    }\n\n    function _apr() internal view returns (uint256) {\n        return cToken.supplyRatePerBlock().mul(blocksPerYear);\n    }\n\n    function weightedApr() external view override returns (uint256) {\n        uint256 a = _apr();\n        return a.mul(_nav());\n    }\n\n    function withdraw(uint256 amount) external override management returns (uint256) {\n        return _withdraw(amount);\n    }\n\n    //emergency withdraw. sends balance plus amount to governance\n    function emergencyWithdraw(uint256 amount) external override management {\n        cToken.redeemUnderlying(amount);\n\n        want.safeTransfer(vault.governance(), want.balanceOf(address(this)));\n    }\n\n    //withdraw an amount including any want balance\n    function _withdraw(uint256 amount) internal returns (uint256) {\n        uint256 balanceUnderlying = cToken.balanceOfUnderlying(address(this));\n        uint256 looseBalance = want.balanceOf(address(this));\n        uint256 total = balanceUnderlying.add(looseBalance);\n\n        if (amount > total) {\n            //cant withdraw more than we own\n            amount = total;\n        }\n        if (looseBalance >= amount) {\n            want.safeTransfer(address(strategy), amount);\n            return amount;\n        }\n\n        //not state changing but OK because of previous call\n        uint256 liquidity = want.balanceOf(address(cToken));\n\n        if (liquidity > 1) {\n            uint256 toWithdraw = amount.sub(looseBalance);\n\n            if (toWithdraw <= liquidity) {\n                //we can take all\n                cToken.redeemUnderlying(toWithdraw);\n            } else {\n                //take all we can\n                cToken.redeemUnderlying(liquidity);\n            }\n        }\n        _disposeOfComp();\n        looseBalance = want.balanceOf(address(this));\n        want.safeTransfer(address(strategy), looseBalance);\n        return looseBalance;\n    }\n\n    function _disposeOfComp() internal {\n        uint256 _comp = IERC20(comp).balanceOf(address(this));\n\n        if (_comp > minCompToSell) {\n            address[] memory path = new address[](3);\n            path[0] = comp;\n            path[1] = weth;\n            path[2] = address(want);\n\n            IUniswapV2Router02(uniswapRouter).swapExactTokensForTokens(_comp, uint256(0), path, address(this), now);\n        }\n    }\n\n    function deposit() external override management {\n        uint256 balance = want.balanceOf(address(this));\n        cToken.mint(balance);\n    }\n\n    function withdrawAll() external override management returns (bool) {\n        uint256 invested = _nav();\n        uint256 returned = _withdraw(invested);\n        return returned >= invested;\n    }\n\n    //think about this\n    function enabled() external view override returns (bool) {\n        return true;\n    }\n\n    function hasAssets() external view override returns (bool) {\n        //return cToken.balanceOf(address(this)) > 0;\n        return cToken.balanceOf(address(this)) > 0 || want.balanceOf(address(this)) > 0;\n    }\n\n    function aprAfterDeposit(uint256 amount) external view override returns (uint256) {\n        uint256 cashPrior = want.balanceOf(address(cToken));\n\n        uint256 borrows = cToken.totalBorrows();\n\n        uint256 reserves = cToken.totalReserves();\n\n        uint256 reserverFactor = cToken.reserveFactorMantissa();\n\n        InterestRateModel model = cToken.interestRateModel();\n\n        //the supply rate is derived from the borrow rate, reserve factor and the amount of total borrows.\n        uint256 supplyRate = model.getSupplyRate(cashPrior.add(amount), borrows, reserves, reserverFactor);\n\n        return supplyRate.mul(blocksPerYear);\n    }\n\n    function protectedTokens() internal view override returns (address[] memory) {\n        address[] memory protected = new address[](3);\n        protected[0] = address(want);\n        protected[1] = address(cToken);\n        protected[2] = comp;\n        return protected;\n    }\n}"
    },
    {
      "filename": "contracts/GenericLender/GenericCream.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../Interfaces/Compound/CErc20I.sol\";\nimport \"../Interfaces/Compound/InterestRateModel.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./GenericLenderBase.sol\";\n\n/********************\n *   A lender plugin for LenderYieldOptimiser for any erc20 asset on Cream (not eth)\n *   Made by SamPriestley.com\n *   https://github.com/Grandthrax/yearnv2/blob/master/contracts/GenericLender/GenericCream.sol\n *\n ********************* */\n\ncontract GenericCream is GenericLenderBase {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    uint256 private constant blocksPerYear = 2_300_000;\n\n    CErc20I public cToken;\n\n    constructor(\n        address _strategy,\n        string memory name,\n        address _cToken\n    ) public GenericLenderBase(_strategy, name) {\n        cToken = CErc20I(_cToken);\n\n        require(cToken.underlying() == address(want), \"WRONG CTOKEN\");\n\n        want.approve(_cToken, uint256(-1));\n    }\n\n    function nav() external view override returns (uint256) {\n        return _nav();\n    }\n\n    function _nav() internal view returns (uint256) {\n        return want.balanceOf(address(this)).add(underlyingBalanceStored());\n    }\n\n    function underlyingBalanceStored() public view returns (uint256 balance) {\n        uint256 currentCr = cToken.balanceOf(address(this));\n        if (currentCr == 0) {\n            balance = 0;\n        } else {\n            balance = currentCr.mul(cToken.exchangeRateStored()).div(1e18);\n        }\n    }\n\n    function apr() external view override returns (uint256) {\n        return _apr();\n    }\n\n    function _apr() internal view returns (uint256) {\n        return cToken.supplyRatePerBlock().mul(blocksPerYear);\n    }\n\n    function weightedApr() external view override returns (uint256) {\n        uint256 a = _apr();\n        return a.mul(_nav());\n    }\n\n    function withdraw(uint256 amount) external override management returns (uint256) {\n        return _withdraw(amount);\n    }\n\n    //emergency withdraw. sends balance plus amount to governance\n    function emergencyWithdraw(uint256 amount) external override management {\n        cToken.redeemUnderlying(amount);\n\n        want.safeTransfer(vault.governance(), want.balanceOf(address(this)));\n    }\n\n    //withdraw an amount including any want balance\n    function _withdraw(uint256 amount) internal returns (uint256) {\n        uint256 balanceUnderlying = cToken.balanceOfUnderlying(address(this));\n        uint256 looseBalance = want.balanceOf(address(this));\n        uint256 total = balanceUnderlying.add(looseBalance);\n\n        if (amount > total) {\n            //cant withdraw more than we own\n            amount = total;\n        }\n        if (looseBalance >= amount) {\n            want.safeTransfer(address(strategy), amount);\n            return amount;\n        }\n\n        //not state changing but OK because of previous call\n        uint256 liquidity = want.balanceOf(address(cToken));\n\n        if (liquidity > 1) {\n            uint256 toWithdraw = amount.sub(looseBalance);\n\n            if (toWithdraw <= liquidity) {\n                //we can take all\n                cToken.redeemUnderlying(toWithdraw);\n            } else {\n                //take all we can\n                cToken.redeemUnderlying(liquidity);\n            }\n        }\n        looseBalance = want.balanceOf(address(this));\n        want.safeTransfer(address(strategy), looseBalance);\n        return looseBalance;\n    }\n\n    function deposit() external override management {\n        uint256 balance = want.balanceOf(address(this));\n        cToken.mint(balance);\n    }\n\n    function withdrawAll() external override management returns (bool) {\n        uint256 invested = _nav();\n        uint256 returned = _withdraw(invested);\n        return returned >= invested;\n    }\n\n    //think about this\n    function enabled() external view override returns (bool) {\n        return true;\n    }\n\n    function hasAssets() external view override returns (bool) {\n        return cToken.balanceOf(address(this)) > 0;\n    }\n\n    function aprAfterDeposit(uint256 amount) external view override returns (uint256) {\n        uint256 cashPrior = want.balanceOf(address(cToken));\n\n        uint256 borrows = cToken.totalBorrows();\n        uint256 reserves = cToken.totalReserves();\n\n        uint256 reserverFactor = cToken.reserveFactorMantissa();\n        InterestRateModel model = cToken.interestRateModel();\n\n        //the supply rate is derived from the borrow rate, reserve factor and the amount of total borrows.\n        uint256 supplyRate = model.getSupplyRate(cashPrior.add(amount), borrows, reserves, reserverFactor);\n\n        return supplyRate.mul(blocksPerYear);\n    }\n\n    function protectedTokens() internal view override returns (address[] memory) {\n        address[] memory protected = new address[](2);\n        protected[0] = address(want);\n        protected[1] = address(cToken);\n        return protected;\n    }\n}"
    },
    {
      "filename": "contracts/GenericLender/GenericDyDx.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../Interfaces/DyDx/ISoloMargin.sol\";\nimport \"../Interfaces/DyDx/IInterestSetter.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../Interfaces/UniswapInterfaces/IUniswapV2Router02.sol\";\n\nimport \"./GenericLenderBase.sol\";\n\n/********************\n *   A lender plugin for LenderYieldOptimiser for DyDx\n *   Made by SamPriestley.com\n *   https://github.com/Grandthrax/yearnv2/blob/master/contracts/GenericLender/GenericDyDx.sol\n *\n ********************* */\n\ncontract GenericDyDx is GenericLenderBase {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    uint256 private constant secondPerYear = 31_153_900; //todo\n    address private constant SOLO ="
    }
  ]
}