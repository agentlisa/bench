{
  "Title": "H-1: An update gap in Chainlink's feed can malfunction the whole market",
  "Content": "# Issue H-1: An update gap in Chainlink's feed can malfunction the whole market \n\nSource: https://github.com/sherlock-audit/2022-11-float-capital-judging/issues/42 \n\n## Found by \nWATCHPUG\n\n## Summary\n\nThe `roundId` that is used for settling the price change and pushing the `latestExecutedEpochIndex` forward is strictly limited to be in a precise period of time. When there is no such `roundId`, the system will freeze and lock everyone out.\n\n## Vulnerability Detail\n\nThe check at L127 makes it impossible to use a roundId that was created at a later time than `relevantEpochStartTimestampWithMEWT + EPOCH_LENGTH`.\n\nHowever, when the `EPOCH_LENGTH` is larger than the Chainlink feed's heartbeat length, or Chainlink failed to post a feed within the expected heartbeat for whatever reason, then it would be impossible to find a suitable roundId (as it does not exist) to push the epoch forward due to the rather strict limitation for the roundId.\n\n## Impact\n\nAs a result, the whole system will malfunction and no one can enter or exit the market.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-float-capital/blob/main/contracts/market/template/MarketCore.sol#L188-L195\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider allowing the `roundId` not to falls into the epoch, and use the previous roundId's price when that's the case:\n\n```diff\n    for (uint32 i = 0; i < lengthOfEpochsToExecute; i++) {\n      // Get correct data\n      (, int256 currentOraclePrice, uint256 currentOracleUpdateTimestamp, , ) = chainlinkOracle.getRoundData(oracleRoundIdsToExecute[i]);\n\n      // Get Previous round data to validate correctness.\n-      (, , uint256 previousOracleUpdateTimestamp, , ) = chainlinkOracle.getRoundData(oracleRoundIdsToExecute[i] - 1);\n+      (, int256 previousOraclePrice, uint256 previousOracleUpdateTimestamp, , ) = chainlinkOracle.getRoundData(oracleRoundIdsToExecute[i] - 1);\n\n      // Check if there was a 'phase change' AND the `_currentOraclePrice` is zero.\n      if ((oracleRoundIdsToExecute[i] >> 64) > (latestExecutedOracleRoundId >> 64) && previousOracleUpdateTimestamp == 0) {\n        // NOTE: if the phase changes, then we want to correct the phase of the update.\n        //       There is no guarantee that the phaseID won't increase multiple times in a short period of time (hence the while loop).\n        //       But chainlink does promise that it will be sequential.\n        // View how phase changes happen here: https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/dev/AggregatorProxy.sol#L335\n        while (previousOracleUpdateTimestamp == 0) {\n          // NOTE: re-using this variable to keep gas costs low for this edge case.\n          latestExecutedOracleRoundId = (((latestExecutedOracleRoundId >> 64) + 1) << 64) | uint64(oracleRoundIdsToExecute[i] - 1);\n\n          (, , previousOracleUpdateTimestamp, , ) = chainlinkOracle.getRoundData(latestExecutedOracleRoundId);\n        }\n      }\n\n      // This checks the price given is valid and falls within the correct window.\n      // see https://app.excalidraw.com/l/2big5WYTyfh/4PhAp1a28s1\n      if (\n        previousOracleUpdateTimestamp >= relevantEpochStartTimestampWithMEWT ||\n        currentOracleUpdateTimestamp < relevantEpochStartTimestampWithMEWT\n-        currentOracleUpdateTimestamp >= relevantEpochStartTimestampWithMEWT + EPOCH_LENGTH\n      ) revert InvalidOracleExecutionRoundId({oracleRoundId: oracleRoundIdsToExecute[i]});\n\n+      // If the new roundId does not falls into the epoch, use the prev roundId then\n+      if (currentOracleUpdateTimestamp >= relevantEpochStartTimestampWithMEWT + EPOCH_LENGTH) {\n+        currentOraclePrice = previousOraclePrice;\n+      }\n\n      if (currentOraclePrice <= 0) revert InvalidOraclePrice({oraclePrice: currentOraclePrice});\n\n      missedEpochPriceUpdates[i] = currentOraclePrice;\n\n      relevantEpochStartTimestampWithMEWT += EPOCH_LENGTH;\n    }\n```\n\n## Discussion\n\n**JasoonS**\n\nThanks - we had a long internal debate discussion about this.\n\nWe decided that it is best to make the parameters (such as epoch length) long enough such that this is extremely unlikely to happen.\n\nWe have done some extensive latency and heartbeat analysis on chainlink oracles - as well as had an in-details discussion about how gas price spikes can cause delays to prices being pushed on chain (a side note - this is why a large mewt/minimumExecutionWatingTime is required - otherwise a gas price spike/griefing attack would be more feasible). I'll link some of that to this issue in a bit if that is interesting to you.\n\nAnyway - getting back to this issue - we believe it is better to leave the market paused if such an anomaly happens and give us time to analyse what happened. It is a sort of risk protection mechanism. Either we upgrade market for a fix (which will be under timelock), or we deprecate the market.\n\nI think our users will appreciate our prudence.\n\nOne thing to consider is that withdrawals also won't be processed in this edge case (maybe a good think?). I'll have another chat with the team on that.\n\nAgree that your solution is pretty benign too since there will just be no price change.\n\n**moose-code**\n\n@WooSungD would be useful if you could post that graph of chainlink prices on the analysis we did. \n\n**moose-code**\n\nFor more context, a few weeks ago we had detailed disscussion with the chainlink team, as you can't even rely on the hearbeat with certainty. \n\nE.g. the heartbeat of 27sec on polygon still showed outliers where we waited for up to 180 seconds in some cases for a new price because of big gas spikes. This is why we conducted the analysis so carefully, we want to make sure that we don't miss a chainlink price.\n\nHowever if we do miss a price, the auto deprecation means the system fails very gracefully, the markets are paused and everyone can simply withdraw after a cooldown period. \n\n**WooSungD**\n\nHere are some graphs showing the distribution of heartbeat (in seconds) for ETH-USD price feed on Chainlink Polygon.\n\n<img width=\"1641\" alt=\"image\" src=\"https://user-images.githubusercontent.com/88306711/202707461-cb8107d9-436f-44aa-af73-e9801c12aae3.png\">\n\n\n<img width=\"1654\" alt=\"image\" src=\"https://user-images.githubusercontent.com/88306711/202707525-b0dbb6d1-fd10-4aaa-bd93-b30dae6ef8cb.png\">\n\n\nThe outliers for the heartbeat mean that our MEWT needs to be longer (longer than max outlier necessarily) to prevent front-running.\n\nThe causes of outliers ito heartbeat were network congestion and gas spikes, according to the Chainlink team\n\n**moose-code**\n\nAfter chatting with the chainlink team more on this, the one potential attack vector (that seems unrealistic) that I can point out is spamming the polygon chain to the point where it delays the chainlink price update from being mined until the point where no valid price exists.\n\nThis would be extremely expensive and simply cause the market to deprecate (no financial gain). \n\n**Evert0x**\n\nWe still think this is a high severity issue as it can make the protocol malfunction\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/15",
  "Code": [
    {
      "filename": "contracts/market/template/MarketCore.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.17;\n\nimport \"./MarketStorage.sol\";\n\n/// @title Main market contract with all the main functionality\ncontract MarketCore is AccessControlledAndUpgradeableModifiers, IMarketCommon, IMarketCore, MarketStorage, ProxyNonPayable {\n  using SafeERC20 for IERC20;\n  using MathUintFloat for uint256;\n  using MathIntFloat for int256;\n\n  /*╔═════════════════════════════╗\n    ║          MODIFIERS          ║\n    ╚═════════════════════════════╝*/\n\n  function gemCollectingModifierLogic(address user) internal {\n    IGEMS(gems).gm(user);\n  }\n\n  modifier gemCollecting(address user) {\n    gemCollectingModifierLogic(user);\n    _;\n  }\n\n  modifier checkMarketNotDeprecated() {\n    if (marketDeprecated) revert MarketDeprecated();\n    _;\n  }\n\n  /*╔═══════════════════════════════╗\n    ║     UPDATING SYSTEM STATE     ║\n    ╚═══════════════════════════════╝*/\n\n  /// @notice This calculates the value transfer from the overbalanced to underbalanced side (i.e. the funding rate)\n  /// This is a further incentive measure to balanced markets. This may be present on some and not other pool token markets.\n  /// @param overbalancedIndex poolType with more liquidity.\n  /// @param overbalancedValue Side with more liquidity.\n  /// @param underbalancedValue Side with less liquidity.\n  /// @return fundingAmount The amount the overbalanced side needs to pay the underbalanced.\n  function _calculateFundingAmount(\n    uint256 overbalancedIndex,\n    uint256 overbalancedValue,\n    uint256 underbalancedValue\n  ) internal view returns (int256[2] memory fundingAmount) {\n    /*\n    totalFunding is calculated on the notional of between long and short liquidity and 2x long and short liquidity. \n    The notional on which funding is calculated increaseas as the imbalance increases.\n    The split of funding paid between underbalanced and overbalanced is 50/50 when long = short liq and moves\n    linearly to 100% paid by the overbalanced beyong the point where liquidity is 2:1 ratio\n    (liquidity in overbalanced side is more than double liquidity in underbalanced side)\n    This modular function is logical but naive implementation that will likely change somewhat upon more indepth \n    modelling results that are still pending. \n    */\n\n    // fundingRateMultiplier is in basis points so need to divide by 10,000.\n    uint256 totalFunding = (2 * overbalancedValue * fundingRateMultiplier * oracleManager.EPOCH_LENGTH()) / (365.25 days * 10000);\n\n    uint256 overbalancedFunding = Math.min(\n      totalFunding,\n      (totalFunding * ((2 * overbalancedValue) - underbalancedValue)) / (overbalancedValue + underbalancedValue)\n    );\n    uint256 underbalancedFunding = totalFunding - overbalancedFunding;\n\n    if (overbalancedIndex == SHORT_TYPE) fundingAmount = [-int256(overbalancedFunding), int256(underbalancedFunding)];\n    else fundingAmount = [-int256(underbalancedFunding), int256(overbalancedFunding)];\n  }\n\n  function _getValueChangeAndFunding(\n    uint256 effectiveValueLong,\n    uint256 effectiveValueShort,\n    int256 previousPrice,\n    int256 currentPrice\n  ) internal view returns (int256 floatPoolLeverage, ValueChangeAndFunding memory params) {\n    uint256 floatPoolLiquidity = pools[PoolType.FLOAT][0].value;\n    // We set the floating tranche leverage to the exact leverage that ensure effectiveValueLong = effectiveValueShort when taking\n    //     into the floating liquidity added the underbalanced side.\n    floatPoolLeverage = (int256(effectiveValueShort) - int256(effectiveValueLong)).div(int256(floatPoolLiquidity));\n\n    // If there is a large diff between long and short liquidity or little floatPoolLiquidity, then the float pool leverage\n    // may be set to a very high amount. Here we cap it such that floatPoolLeverage is between -5x and 5x.\n    // This give Market Makers who deposit in the floatPool certain garuntees on the maximum delta they will be exposed to.\n    if (floatPoolLeverage > 5e18) floatPoolLeverage = 5e18;\n    else if (floatPoolLeverage < -5e18) floatPoolLeverage = -5e18;\n\n    // NOTE - we are dividing by previous price before multiplying this value again in _rebalancePoolsAndExecuteBatchedActions - this means some accuracy is lost - however we deem this insignificant.\n    int256 priceMovement_e18 = (currentPrice - previousPrice).div(previousPrice);\n\n    // A really large price movement could bankrupt a 5x leveraged pool. We contrain the price movement to a max percentage\n    // that ensure no pool will be underwater. This limimts the gain/loss on any single price movement. In practice\n    // maxPercentChange is about 20% for a 5x pool, and we don't expect to see 20% price changes in one epoch, but if we do,\n    // The system is able to tolerate it.\n    if (priceMovement_e18 > maxPercentChange) priceMovement_e18 = maxPercentChange;\n    else if (priceMovement_e18 < -maxPercentChange) priceMovement_e18 = -maxPercentChange;\n\n    // Value change (amount to transfer between Short and Long pools) is based on the price movement multiplied by the\n    // Notional value of the smaller side (long or short). Given the float pool should in most cases make the liquidity of long and short\n    // exactly equal, the only case where long and short liquidity is different is when the float pool leverage is constrained to its 5x or -5x cap.\n    // If this is the case, the side with greater liquidity will have a reduced exposure or delta of their position. I.e. If $1m long and $500k short,\n    // Longs will only get 50% ($500k) long exposure.\n    if (effectiveValueShort > effectiveValueLong) {\n      params.fundingAmount = _calculateFundingAmount(SHORT_TYPE, effectiveValueShort, effectiveValueLong);\n      params.valueChange = priceMovement_e18.mul(int256(effectiveValueLong + uint256(floatPoolLeverage).mul(floatPoolLiquidity)));\n      params.underBalancedSide = LONG_TYPE;\n    } else {\n      params.fundingAmount = _calculateFundingAmount(LONG_TYPE, effectiveValueLong, effectiveValueShort);\n      params.valueChange = priceMovement_e18.mul(int256(effectiveValueShort + uint256(-floatPoolLeverage).mul(floatPoolLiquidity)));\n      params.underBalancedSide = SHORT_TYPE;\n    }\n  }\n\n  /// @notice Reblances the pool given the epoch execution information and can also perform batched actions from the epoch.\n  /// @param epochIndex The index of the epoch to execute\n  /// @param totalEffectiveLiquidityPoolType Effective liquidity of short (0) and long (1) pools\n  /// @param params Compact struct with all parameters needed for rebalance\n  /// @return nextTotalEffectiveLiquidityPoolType Updated short and long liquidities\n  /// @return poolStates Compact struct of pool states after rebalance\n  function _rebalancePoolsAndExecuteBatchedActions(\n    uint32 epochIndex,\n    uint128[2] memory totalEffectiveLiquidityPoolType,\n    int256 floatPoolLeverage,\n    ValueChangeAndFunding memory params\n  ) internal returns (uint128[2] memory nextTotalEffectiveLiquidityPoolType, PoolState[] memory poolStates) {\n    poolStates = new PoolState[](_totalNumberOfPoolTiers);\n    uint8 currentPoolStateIndex;\n\n    // Correctly account for liquidity in long and short by adding the float liquidity to the underbalanced side.\n    totalEffectiveLiquidityPoolType[params.underBalancedSide] += uint128(uint256(pools[PoolType.FLOAT][0].value).mul(floatPoolLeverage.abs()));\n\n    // For every pool (long pools, short pools and float pool)\n    // 1) Adjust poolValue based on price movements and funding (and fees for float pool)\n    // 2) Batch process all new entries and exits in pool\n    for (uint256 poolType = SHORT_TYPE; poolType < POOL_TYPE_UPPER_BOUND; ++poolType) {\n      for (uint256 poolTier = 0; poolTier < _numberOfPoolsOfType[poolType]; ++poolTier) {\n        int256 poolValue = int256(pools[PoolType(poolType)][poolTier].value);\n        PoolFixedConfig memory poolFixedConfig = pools[PoolType(poolType)][poolTier].fixedConfig;\n\n        if (poolType != FLOAT_TYPE) {\n          // To correctly apportion funding owed for the underblananced tiers, we need to remove the float liquidity contribution\n          int256 actualTotalEffectiveLiquidityForPoolType = int256(\n            (uint256(totalEffectiveLiquidityPoolType[poolType]) -\n              (poolType == params.underBalancedSide ? uint256(pools[PoolType.FLOAT][0].value).mul(floatPoolLeverage.abs()) : 0))\n          );\n\n          // Long and short pools both pay funding\n          poolValue +=\n            (((poolValue * poolFixedConfig.leverage * params.valueChange) / int128(totalEffectiveLiquidityPoolType[poolType])) -\n              ((poolValue * poolFixedConfig.leverage * params.fundingAmount[poolType]) / (actualTotalEffectiveLiquidityForPoolType))) /\n            1e18;\n        } else {\n          // Float pool recieves all funding and fees.\n          poolValue +=\n            ((poolValue * floatPoolLeverage * params.valueChange) /\n              (int256(uint256(totalEffectiveLiquidityPoolType[params.underBalancedSide])) * 1e18)) +\n            -params.fundingAmount[SHORT_TYPE] + // funding value is negative for short side (double negative to add it)\n            params.fundingAmount[LONG_TYPE] +\n            int256(feesToDistribute[epochIndex & 1]);\n\n          feesToDistribute[epochIndex & 1] = 0;\n        }\n\n        uint256 tokenSupply = IPoolToken(poolFixedConfig.token).totalSupply();\n        uint256 price = uint256(poolValue).div(tokenSupply);\n\n        // All entries and exits to the pool are processed at latest price based on newly calculated poolValue\n        poolValue += _processAllBatchedEpochActions(epochIndex, PoolType(poolType), poolTier, price, poolFixedConfig.token);\n\n        // We calculate the new total liquidity always excluding the floating tranche.\n        if (poolType != FLOAT_TYPE)\n          nextTotalEffectiveLiquidityPoolType[poolType] += uint128(uint256(poolValue).mul(int256(poolFixedConfig.leverage).abs()));\n\n        pools[PoolType(poolType)][poolTier].value = uint256(poolValue);\n\n        // Token price snapshot for this epoch is used to calculate amount individual token allocation retrospectively for entrants/exits\n        poolToken_priceSnapshot[epochIndex][PoolType(poolType)][poolTier] = price;\n\n        // This structure is purely to emit event info as easily as possible for the indexer.\n        poolStates[currentPoolStateIndex++] = PoolState({\n          poolId: MarketHelpers.packPoolId(PoolType(poolType), uint8(poolTier)),\n          tokenPrice: price,\n          value: poolValue\n        });\n      }\n    }\n  }\n\n  /// @notice System state update function that verifies (instead of trying to find) oracle prices\n  /// @param oracleRoundIdsToExecute The oracle prices that will be the prices for each epoch\n  function updateSystemStateUsingValidatedOracleRoundIds(uint80[] memory oracleRoundIdsToExecute) external checkMarketNotDeprecated {\n    uint32 latestExecutedEpochIndex = epochInfo.latestExecutedEpochIndex;\n    (int256 previousPrice, int256[] memory epochPrices) = oracleManager.validateAndReturnMissedEpochInformation(\n      latestExecutedEpochIndex,\n      epochInfo.latestExecutedOracleRoundId,\n      oracleRoundIdsToExecute\n    );\n\n    uint256 numberOfEpochsToExecute = epochPrices.length;\n\n    uint128[2] memory totalEffectiveLiquidityPoolType = effectiveLiquidityForPoolType;\n\n    for (uint256 i = 0; i < numberOfEpochsToExecute; ) {\n      /* i is incremented later in scope*/\n      (int256 floatPoolLeverage, ValueChangeAndFunding memory rebalanceParams) = _getValueChangeAndFunding(\n        totalEffectiveLiquidityPoolType[LONG_TYPE],\n        totalEffectiveLiquidityPoolType[SHORT_TYPE],\n        // this is the previous execution price, not the previous oracle update price\n        previousPrice,\n        epochPrices[i]\n      );\n\n      previousPrice = epochPrices[i];\n\n      PoolState[] memory poolStates;\n      (totalEffectiveLiquidityPoolType, poolStates) = _rebalancePoolsAndExecuteBatchedActions(\n        latestExecutedEpochIndex + uint32(++i),\n        totalEffectiveLiquidityPoolType,\n        floatPoolLeverage,\n        rebalanceParams\n      );\n\n      emit EpochUpdated(latestExecutedEpochIndex + uint32(i), previousPrice, rebalanceParams.valueChange, rebalanceParams.fundingAmount, poolStates);\n    }\n\n    // Saving the final state of liquidity and info once all epochs have been executed.\n    // In practive, keepers should ensure that the above loop length is only ever 1,\n    // and we are never catching up multiple epochs. This arcitecture is built such that the\n    // the system can gracefully handle missed upkeep fairly.\n    effectiveLiquidityForPoolType = totalEffectiveLiquidityPoolType;\n    epochInfo = EpochInfo({\n      latestExecutedEpochIndex: latestExecutedEpochIndex + uint32(numberOfEpochsToExecute),\n      latestExecutedOracleRoundId: oracleRoundIdsToExecute[oracleRoundIdsToExecute.length - 1]\n    });\n  }\n\n  /*╔═══════════════════════════╗\n    ║       MINT POSITION       ║\n    ╚═══════════════════════════╝*/\n\n  /// @notice Calculates the fees for the mint amount depending on the market\n  /// @param amount Amount of payment tokens in that token's lowest denomination for which to mint pool token assets at next price.\n  function _calculateStabilityFees(uint256 amount) internal view returns (uint256 amountFees) {\n    // stability fee is based on effectiveLiquidity added (takes into account leverage)\n    amountFees = (amount * stabilityFee_basisPoints) / (10000);\n  }\n\n  /// @notice Allows users to mint pool token assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.\n  /// @dev We have to check market not deprecated after system state update because that is the function that determines whether the market should be deprecated.\n  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint pool token assets at next price.\n  /// @param poolType an enum representing the type of poolTier for eg. LONG or SHORT.\n  /// @param poolTier leveraged poolTier index\n  function _mint(\n    uint112 amount,\n    address user,\n    PoolType poolType,\n    uint256 poolTier\n  ) internal {\n    // ASIDE: This check also checks that the poolType is valid - since if it is invalid it will be zero - and no uint can be less than zero\n    if (uint256(poolTier) >= _numberOfPoolsOfType[uint256(poolType)]) revert InvalidPool();\n\n    if (mintingPaused) revert MintingPaused();\n\n    // Due to get amount of payment token calculation we must have amount * 1e18 > poolTokenPriceInPaymentTokens otherwise we get 0\n    // In fact, all the decimals of amount * 1e18 that are less than poolTokenPriceInPaymentTokens get cut off\n    if (amount < 1e18) revert InvalidActionAmount(amount);\n\n    IERC20(paymentToken).safeTransferFrom(msg.sender, liquidityManager, amount);\n\n    uint256 fees = _calculateStabilityFees(uint256(amount).mul(int256(pools[poolType][poolTier].fixedConfig.leverage).abs()));\n    amount -= uint112(fees);\n\n    uint32 currentEpoch = uint32(oracleManager.getCurrentEpochIndex());\n\n    // Actions cannot take place if upkeep has fallen behind and there are already 2 oustanding epochs needing to be executed\n    if (currentEpoch > epochInfo.latestExecutedEpochIndex + 2)\n      revert MarketStale({currentEpoch: currentEpoch, latestExecutedEpoch: epochInfo.latestExecutedEpochIndex});\n\n    // Before minting we ensure user recieves tokens from any already executed mints in previous epochs.\n    // This ensures the userAction_depositPaymentToken[user][poolType][poolTier] struct will be up to date\n    // and correctly handle to new mint.\n    settlePoolUserMints(user, poolType, poolTier);\n\n    UserAction memory userAction = userAction_depositPaymentToken[user][poolType][poolTier];\n\n    /// NOTE: userAction.amount > 0 IFF userAction.correspondingEpoch <= currentEpoch - this check is redundant for safety.\n    if (userAction.amount > 0 && userAction.correspondingEpoch < currentEpoch) {\n      // This case occurs when a user minted in the previous epoch and upkeep has still not yet\n      // occured and therefore this previous order has not been processed.\n      // This is likely to happen if the user mints early on in a new epoch when enough time has not\n      // passed (see MEWT) for the previous epoch to be executed.\n      userAction.nextEpochAmount += amount;\n    } else {\n      userAction.amount += amount;\n      userAction.correspondingEpoch = currentEpoch;\n    }\n\n    // NOTE: `currentEpoch & 1` and `currentEpoch % 2` are equivalent, but the former is more efficient using bitwise operations.\n    // Since there can only ever be oustanding mint and redeem orders in two consecutive epochs (cannot have oustanding orders in 3 epochs etc)\n    // We use an odd even batch scheme to easily batch orders.\n    pools[poolType][poolTier].batchedAmount[currentEpoch & 1].paymentToken_deposit += amount;\n    feesToDistribute[currentEpoch & 1] += fees;\n\n    userAction_depositPaymentToken[user][poolType][poolTier] = userAction;\n\n    emit Deposit(MarketHelpers.packPoolId(poolType, uint8(poolTier)), amount, fees, user, currentEpoch);\n  }\n\n  /// @notice Allows users to mint long pool token assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param poolTier leveraged poolTier index\n  /// @param amount Amount of payment tokens in that token's lowest denomination for which to mint pool token assets at next price.\n  function mintLong(uint256 poolTier, uint112 amount) external gemCollecting(msg.sender) {\n    _mint(amount, msg.sender, PoolType.LONG, poolTier);\n  }\n\n  /// @notice Allows users to mint short pool token assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param poolTier leveraged poolTier index\n  /// @param amount Amount of payment tokens in that token's lowest denomination for which to mint pool token assets at next price.\n  function mintShort(uint256 poolTier, uint112 amount) external gemCollecting(msg.sender) {\n    _mint(amount, msg.sender, PoolType.SHORT, poolTier);\n  }\n\n  /// @notice Allows users to mint float pool token assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param amount Amount of payment tokens in that token's lowest denomination for which to mint pool token assets at next price.\n  function mintFloatPool(uint112 amount) external {\n    _checkRole(FLOAT_POOL_ROLE, msg.sender);\n    _mint(amount, msg.sender, PoolType.FLOAT, 0); // There is always only one float pool at poolTier index 0\n  }\n\n  /// @notice Allows mint long pool token assets for a market on behalf of some user. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param poolTier leveraged poolTier index\n  /// @param amount Amount of payment tokens in that token's lowest denomination for which to mint pool token assets at next price.\n  /// @param user Address of the user.\n  function mintLongFor(\n    uint256 poolTier,\n    uint112 amount,\n    address user\n  ) external override gemCollecting(user) {\n    _mint(amount, user, PoolType.LONG, poolTier);\n  }\n\n  /// @notice Allows mint short pool token assets for a market on behalf of some user. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param poolTier leveraged poolTier index\n  /// @param amount Amount of payment tokens in that token's lowest denomination for which to mint pool token assets at next price.\n  /// @param user Address of the user.\n  function mintShortFor(\n    uint256 poolTier,\n    uint112 amount,\n    address user\n  ) external gemCollecting(user) {\n    _mint(amount, user, PoolType.SHORT, poolTier);\n  }\n\n  /*╔═══════════════════════════╗\n    ║       REDEEM POSITION     ║\n    ╚═══════════════════════════╝*/\n\n  /// @notice Allows users to mint pool token assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.\n  /// @dev We have to check market not deprecated after system state update because that is the function that determines whether the market should be deprecated.\n  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint pool token assets at next price.\n  /// @param poolType an enum representing the type of poolTier for eg. LONG or SHORT.\n  /// @param poolTier leveraged poolTier index\n  function _redeem(\n    uint112 amount,\n    address user,\n    PoolType poolType,\n    uint256 poolTier\n  ) internal checkMarketNotDeprecated {\n    // In this function, amount refers to the amount of poolToken.\n    // In the _mint function amount refers to the amount of paymentToken\n    // This function is very similar to _mint. See _mint for comprehensive commenting\n    if (amount < 1e12) revert InvalidActionAmount(amount);\n\n    uint32 currentEpoch = uint32(oracleManager.getCurrentEpochIndex());\n    if (currentEpoch > epochInfo.latestExecutedEpochIndex + 2)\n      revert MarketStale({currentEpoch: currentEpoch, latestExecutedEpoch: epochInfo.latestExecutedEpochIndex});\n\n    settlePoolUserRedeems(user, poolType, poolTier);\n\n    //slither-disable-next-line unchecked-transfer\n    // If an invalid poolType and poolTier is passed, this will revert.\n    IPoolToken(pools[poolType][poolTier].fixedConfig.token).transferFrom(user, address(this), amount);\n\n    UserAction memory userAction = userAction_redeemPoolToken[user][poolType][poolTier];\n\n    if (userAction.amount > 0 && userAction.correspondingEpoch < currentEpoch) {\n      userAction.nextEpochAmount += amount;\n    } else {\n      userAction.amount += amount;\n      userAction.correspondingEpoch = currentEpoch;\n    }\n\n    // NOTE: `currentEpoch & 1` and `currentEpoch % 2` are equivalent, but the former is more efficient using bitwise operations.\n    pools[poolType][poolTier].batchedAmount[currentEpoch & 1].poolToken_redeem += amount;\n\n    userAction_redeemPoolToken[user][poolType][poolTier] = userAction;\n\n    emit Redeem(MarketHelpers.packPoolId(poolType, uint8(poolTier)), amount, user, currentEpoch);\n  }\n\n  /// @notice Allows users to mint long pool token assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param poolTier leveraged poolTier index\n  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint pool token assets at next price.\n  function redeemLong(uint256 poolTier, uint112 amount) external gemCollecting(msg.sender) {\n    _redeem(amount, msg.sender, PoolType.LONG, poolTier);\n  }\n\n  /// @notice Allows users to redeem short pool token assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @param poolTier leveraged poolTier index\n  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to redeem pool token assets at next price.\n  function redeemShort(uint256 poolTier, uint112 amount) external gemCollecting(msg.sender) {\n    _redeem(amount, msg.sender, PoolType.SHORT, poolTier);\n  }\n\n  /// @notice Allows users to redeem float pool token assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to redeem pool token assets at next price.\n  function redeemFloatPool(uint112 amount) external {\n    _redeem(amount, msg.sender, PoolType.FLOAT, 0);\n  }\n\n  /*╔═════════════════════╗\n    ║  USER SETTLEMENTS   ║\n    ╚═════════════════════╝*/\n\n  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their mints during that epoch to that user.\n  /// @param user Address of the user.\n  /// @param poolType an enum representing the type of poolTier for eg. LONG or SHORT.\n  /// @param poolTier leveraged poolTier index\n  function settlePoolUserMints(\n    address user,\n    PoolType poolType,\n    uint256 poolTier\n  ) public {\n    /*\n      NOTE: please reflect any changes made to this function to the `getUsersConfirmedButNotSettledPoolTokenBalance` function too.\n\n     Users can have mints in two consecutive epochs (with both not yet being executed). In this case we say both there primary,\n     and seconday order slot are full. Once upkeep has been performed on those epochs, this function can be called at a later stage,\n     asynchronusly (generally when a user mints again or uses their tokens), in order to calculate and send the tokens owed to the user\n     based on their mints in the primiary and secondary slot (the secondary slot may not always exist).\n\n     Corresponding epoch refers to the epoch associated with the primary slot action.\n    */\n\n    UserAction memory userAction = userAction_depositPaymentToken[user][poolType][poolTier];\n\n    // Case if the primary order can be executed.\n    if (userAction.correspondingEpoch != 0 && userAction.correspondingEpoch <= epochInfo.latestExecutedEpochIndex) {\n      uint256 poolToken_price = poolToken_priceSnapshot[userAction.correspondingEpoch][poolType][poolTier];\n      uint256 amountPoolTokenToMint = uint256(userAction.amount).div(poolToken_price);\n\n      // If secondary order exists\n      if (userAction.nextEpochAmount > 0) {\n        uint32 secondaryOrderEpoch = userAction.correspondingEpoch + 1;\n\n        // If its possible to also execute the secondary order slot\n        if (secondaryOrderEpoch <= epochInfo.latestExecutedEpochIndex) {\n          // then also execute\n          poolToken_price = poolToken_priceSnapshot[secondaryOrderEpoch][poolType][poolTier];\n          amountPoolTokenToMint += uint256(userAction.nextEpochAmount).div(poolToken_price);\n\n          userAction.amount = 0;\n          userAction.correspondingEpoch = 0;\n        } else {\n          // If secondary order cannot be executed, bump it to the primary slot.\n          userAction.amount = userAction.nextEpochAmount;\n          userAction.correspondingEpoch = secondaryOrderEpoch;\n        }\n        // has to zero as either executed or bumped to primary slot\n        userAction.nextEpochAmount = 0;\n      } else {\n        // If user has no pending mints then simply wipe\n        userAction.amount = 0;\n        userAction.correspondingEpoch = 0;\n      }\n\n      //slither-disable-next-line unchecked-transfer\n      IPoolToken(pools[poolType][poolTier].fixedConfig.token).transfer(user, amountPoolTokenToMint);\n\n      userAction_depositPaymentToken[user][poolType][poolTier] = userAction;\n\n      emit ExecuteEpochSettlementMintUser(\n        MarketHelpers.packPoolId(poolType, uint8(poolTier)),\n        user,\n        epochInfo.latestExecutedEpochIndex,\n        amountPoolTokenToMint\n      );\n    }\n  }\n\n  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their redeems during that epoch to that user.\n  /// @param user Address of the user.\n  /// @param poolType an enum representing the type of poolTier for eg. LONG or SHORT.\n  /// @param poolTier leveraged poolTier index\n  function settlePoolUserRedeems(\n    address user,\n    PoolType poolType,\n    uint256 poolTier\n  ) public {\n    // Functions almost identically to settlePoolUserMints. See settlePoolUserMints for comprehensive comments.\n    UserAction memory userAction = userAction_redeemPoolToken[user][poolType][poolTier];\n\n    // Case if the primary order can be executed.\n    if (userAction.amount > 0 && userAction.correspondingEpoch <= epochInfo.latestExecutedEpochIndex) {\n      uint256 poolToken_price = poolToken_priceSnapshot[userAction.correspondingEpoch][poolType][poolTier];\n\n      uint256 amountPaymentTokenToSend = uint256(userAction.amount).mul(poolToken_price);\n\n      if (userAction.nextEpochAmount > 0) {\n        uint32 secondaryOrderEpoch = userAction.correspondingEpoch + 1;\n\n        if (secondaryOrderEpoch <= epochInfo.latestExecutedEpochIndex) {\n          poolToken_price = poolToken_priceSnapshot[secondaryOrderEpoch][poolType][poolTier];\n          amountPaymentTokenToSend += uint256(userAction.nextEpochAmount).mul(poolToken_price);\n\n          userAction.amount = 0;\n          userAction.correspondingEpoch = 0;\n        } else {\n          userAction.amount = userAction.nextEpochAmount;\n          userAction.correspondingEpoch = secondaryOrderEpoch;\n        }\n        // has to zero as either executed or bumped to primary slot\n        userAction.nextEpochAmount = 0;\n      } else {\n        // If user has no pending redeems then simply wipe\n        userAction.amount = 0;\n        userAction.correspondingEpoch = 0;\n      }\n\n      userAction_redeemPoolToken[user][poolType][poolTier] = userAction;\n\n      ILiquidityManager(liquidityManager).transferPaymentTokensToUser(user, amountPaymentTokenToSend);\n\n      emit ExecuteEpochSettlementRedeemUser(\n        MarketHelpers.packPoolId(poolType, uint8(poolTier)),\n        user,\n        epochInfo.latestExecutedEpochIndex,\n        amountPaymentTokenToSend\n      );\n    }\n  }\n\n  /*╔═══════════════════╗\n    ║   BATCH ACTIONS   ║\n    ╚═══════════════════╝*/\n\n  /// @notice Either mints or burns pool token supply.\n  /// @param poolToken Address of the pool token.\n  /// @param changeInPoolTokensTotalSupply Positive indicates amount to be minted and negative indicates amount to be burned.\n  function _handleChangeInPoolTokensTotalSupply(address poolToken, int256 changeInPoolTokensTotalSupply) internal {\n    if (changeInPoolTokensTotalSupply > 0) {\n      IPoolToken(poolToken).mint(address(this), uint256(changeInPoolTokensTotalSupply));\n    } else if (changeInPoolTokensTotalSupply < 0) {\n      IPoolToken(poolToken).burn(uint256(-changeInPoolTokensTotalSupply));\n    }\n  }\n\n  /// @notice For a given pool, updates the value depending on the batched deposits and redeems that took place during the epoch\n  /// @param associatedEpochIndex Index of epoch where the batched actions were performed.\n  /// @param poolType an enum representing the type of poolTier for eg. LONG or SHORT.\n  /// @param poolTier leveraged poolTier index.\n  /// @param price Price of the pool token.\n  function _processAllBatchedEpochActions(\n    uint256 associatedEpochIndex,\n    PoolType poolType,\n    uint256 poolTier,\n    uint256 price,\n    address poolToken\n  ) internal returns (int256 changeInMarketValue_inPaymentToken) {\n    // QUESTION: is it worth the gas saving this storage pointer - we only use 'pool' twice in this function.\n    Pool storage pool = pools[poolType][poolTier];\n\n    BatchedActions memory batch = pool.batchedAmount[associatedEpochIndex & 1];\n\n    // Only if mints or redeems exist is it necessary to adjust supply and collateral.\n    if (batch.paymentToken_deposit > 0 || batch.poolToken_redeem > 0) {\n      changeInMarketValue_inPaymentToken = int128(batch.paymentToken_deposit) - int256(uint256(batch.poolToken_redeem).mul(price));\n\n      int256 changeInSupply_poolToken = int256(uint256(batch.paymentToken_deposit).div(price)) - int128(batch.poolToken_redeem);\n\n      pool.batchedAmount[associatedEpochIndex & 1] = BatchedActions(0, 0);\n\n      _handleChangeInPoolTokensTotalSupply(poolToken, changeInSupply_poolToken);\n    }\n  }\n\n  /*╔═══════════════════════════╗\n    ║ DEPRECATED MARKET ACTIONS ║\n    ╚═══════════════════════════╝*/\n\n  /*\n  In the case that upkeep contiously fails (could be because of chainlink failing, the chain going offline etc.),\n  which will most likely happen if no chainlink price is recieved within an epoch, therefore no valid price is available\n  to execute and process all oustanding orders and value transfer - The markets gracefully go into a state of deprecation. \n  When this happens, all normal mints and redeems are suspended. It is only possible to burn all poolTokens and redeem collateral. \n  The tokens will no longer change value according any price feed, or pay funding etc, the token price will simply stay constant.\n  This seems the safest way to handle a blackswan event. That being said EPOCH_LENGTH will be set to ensure its highly unlikely\n  price events don't ocur during an epoch.\n  */\n\n  /// @notice Place the market in a state where no more price updates or mints are allowed\n  function _deprecateMarket() internal {\n    ValueChangeAndFunding memory emptyValueChangeAndFunding;\n\n    uint128[2] memory newEffectiveLiquidity = effectiveLiquidityForPoolType;\n\n    // Here we rebalance the ma"
    }
  ]
}