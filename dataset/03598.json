{
  "Title": "[L10] Naming issues hinder code understanding and readability",
  "Content": "To favor explicitness and readability, several parts of the contracts may benefit from better naming. We noted the following general issues:\n\n\n* The terminology around the `asset` in the vault is not as clear as it should be. It is sometimes [referred to as `collateral`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/base/RibbonVault.sol#L370-L374) and other times [implicitly referred to as `underlying`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/base/RibbonVault.sol#L370-L374). Since [vaults have an `underlying` parameter](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/base/RibbonVault.sol#L370-L374) – this imprecise naming can lead to unnecessary confusion. Consider being precise and consistent when referencing tokens in the system either explicitly or implicitly.\n* The library name [`SupportsNonCompliantERC20`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/SupportsNonCompliantERC20.sol#L6) is misleading. In fact, it only supports a single non-compliant ERC20, which is `USDT`. There are other tokens that have the same “non-compliant” approval behavior and this library would not support any of them. ([CRV](https://etherscan.io/address/0xD533a949740bb3306d119CC777fa900bA034cd52#code) for instance.) If the contract is only meant to handle USDT, consider renaming it. Alternatively, if it may handle additional non-compliant tokens in the future, consider adding inline comments signaling this intention.\n\n\nAdditionally, we recommend the following, more specific, suggestions related to naming:\n\n\n* In [`IOptionsPremiumPricer`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/interfaces/IRibbon.sol#L13), the arguments to the [`getOptionDelta`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/interfaces/IRibbon.sol#L20) event, `sp`, `st`, `v`, and `t` should be renamed to `underlyingPrice`,`strikePrice`,`volatility`, and `time` respectively.\n* In the [`SupportsNonCompliantERC20`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/SupportsNonCompliantERC20.sol) library, the [`safeApprove`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/SupportsNonCompliantERC20.sol#L9) method should be renamed to `safeApproveNonCompliant` or something similar, so that it does not share the same name as the `safeApprove` method in the `SafeERC20` library used throughout the codebase.\n* In the [`RibbonVault`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/base/RibbonVault.sol) contract, the [`topup`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/base/RibbonVault.sol#L322) variable should be renamed to `doCombineSameRound` or similar.\n* In the [`ShareMath`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/ShareMath.sol) library:\n* [`pps`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/ShareMath.sol#L15) should be `pricePerShare` or `assetPerShare`.\n* [`sharesToUnderlying`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/ShareMath.sol#L30) should be `sharesToAsset`.\n* [`underlyingToShares`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/ShareMath.sol#L13) should be `assetToShares`.\n* In the [`VaultLifecycle`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/VaultLifecycle.sol) library:\n* [`currentSupply`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/VaultLifecycle.sol#L105) should be renamed to `currentShareSupply`.\n* [`verifyConstructorParams`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/VaultLifecycle.sol#L462) should be renamed to `verifyInitializerParams`.\n* [`OTOKEN_DECIMALS`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/VaultLifecycle.sol#L155) should be `OTOKEN_MULTIPLER`. Alternatively, if it is not renamed, then its value should be changed to `8` instead of `10**8`, and any logic that depends on it should be updated appropriately.\n* In the [`OptionsVaultStorage`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/storage/OptionsVaultStorage.sol) contract, [`lastStrikeOverride`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/storage/OptionsVaultStorage.sol#L55) should be `lastStrikeOverrideRound`.\n* In the [`Vault`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/Vault.sol) contract, [`minimumSupply`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/Vault.sol#L15) should be `minimumInitialSupply`.\n* In the [`RibbonThetaVault`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/RibbonThetaVault.sol) contract, [`unlockedAssedAmount`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/RibbonThetaVault.sol#L310) should be `unlockedAssetAmount`.\n* In the [`RibbonDeltaVault`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/RibbonDeltaVault.sol) contract,`options` [here](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/RibbonDeltaVault.sol#L40) and [here](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/RibbonDeltaVault.sol#L33) should be `option`.\n* In the [`GnosisAuction`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/GnosisAuction.sol) contract, [`auctionCounter`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/GnosisAuction.sol#L21) should be `auctionID`.\n\n\nConsider renaming any potentially confusing or misleading parts of the codebase to increase overall code clarity.\n\n\n**Update**: *Partially fixed in [commit `29d4de9b8bd3cbb7a8f34650daf20fb01be06e43` of PR#97](https://github.com/ribbon-finance/ribbon-v2/pull/97/commits/29d4de9b8bd3cbb7a8f34650daf20fb01be06e43).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/vaults/base/RibbonVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.3;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport {GnosisAuction} from \"../../libraries/GnosisAuction.sol\";\nimport {OptionsVaultStorage} from \"../../storage/OptionsVaultStorage.sol\";\nimport {Vault} from \"../../libraries/Vault.sol\";\nimport {VaultLifecycle} from \"../../libraries/VaultLifecycle.sol\";\nimport {ShareMath} from \"../../libraries/ShareMath.sol\";\nimport {IOtoken} from \"../../interfaces/GammaInterface.sol\";\nimport {IWETH} from \"../../interfaces/IWETH.sol\";\nimport {IGnosisAuction} from \"../../interfaces/IGnosisAuction.sol\";\nimport {\n    IStrikeSelection,\n    IOptionsPremiumPricer\n} from \"../../interfaces/IRibbon.sol\";\n\ncontract RibbonVault is OptionsVaultStorage {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using ShareMath for Vault.DepositReceipt;\n\n    /************************************************\n     *  IMMUTABLES & CONSTANTS\n     ***********************************************/\n\n    address public immutable WETH;\n    address public immutable USDC;\n\n    uint256 public constant delay = 1 hours;\n\n    uint256 public constant period = 7 days;\n\n    uint128 internal constant PLACEHOLDER_UINT = 1;\n\n    // Number of weeks per year = 52.142857 weeks * 10**6 = 52142857\n    // Dividing by weeks per year requires doing num.mul(10**6).div(WEEKS_PER_YEAR)\n    uint256 private constant WEEKS_PER_YEAR = 52142857;\n\n    // GAMMA_CONTROLLER is the top-level contract in Gamma protocol\n    // which allows users to perform multiple actions on their vaults\n    // and positions https://github.com/opynfinance/GammaProtocol/blob/master/contracts/Controller.sol\n    address public immutable GAMMA_CONTROLLER;\n\n    // MARGIN_POOL is Gamma protocol's collateral pool.\n    // Needed to approve collateral.safeTransferFrom for minting otokens.\n    // https://github.com/opynfinance/GammaProtocol/blob/master/contracts/MarginPool.sol\n    address public immutable MARGIN_POOL;\n\n    // GNOSIS_EASY_AUCTION is Gnosis protocol's contract for initiating auctions and placing bids\n    // https://github.com/gnosis/ido-contracts/blob/main/contracts/EasyAuction.sol\n    address public immutable GNOSIS_EASY_AUCTION;\n\n    /************************************************\n     *  EVENTS\n     ***********************************************/\n\n    event Deposit(address indexed account, uint256 amount, uint256 round);\n\n    event InitiateWithdraw(address account, uint256 shares, uint256 round);\n\n    event Redeem(address indexed account, uint256 share, uint16 round);\n\n    event ManagementFeeSet(uint256 managementFee, uint256 newManagementFee);\n\n    event PerformanceFeeSet(uint256 performanceFee, uint256 newPerformanceFee);\n\n    event CapSet(uint256 oldCap, uint256 newCap, address manager);\n\n    event Withdraw(address account, uint256 amount, uint256 shares);\n\n    event CollectVaultFees(\n        uint256 performanceFee,\n        uint256 vaultFee,\n        uint256 round\n    );\n\n    /************************************************\n     *  CONSTRUCTOR & INITIALIZATION\n     ***********************************************/\n\n    /**\n     * @notice Initializes the contract with immutable variables\n     * @param _weth is the Wrapped Ether contract\n     * @param _usdc is the USDC contract\n     * @param _gammaController is the contract address for opyn actions\n     * @param _marginPool is the contract address for providing collateral to opyn\n     * @param _gnosisEasyAuction is the contract address that facilitates gnosis auctions\n     */\n    constructor(\n        address _weth,\n        address _usdc,\n        address _gammaController,\n        address _marginPool,\n        address _gnosisEasyAuction\n    ) {\n        require(_weth != address(0), \"!_weth\");\n        require(_usdc != address(0), \"!_usdc\");\n        require(_gnosisEasyAuction != address(0), \"!_gnosisEasyAuction\");\n        require(_gammaController != address(0), \"!_gammaController\");\n        require(_marginPool != address(0), \"!_marginPool\");\n\n        WETH = _weth;\n        USDC = _usdc;\n        GAMMA_CONTROLLER = _gammaController;\n        MARGIN_POOL = _marginPool;\n        GNOSIS_EASY_AUCTION = _gnosisEasyAuction;\n    }\n\n    /**\n     * @notice Initializes the OptionVault contract with storage variables.\n     */\n    function baseInitialize(\n        address _owner,\n        address _feeRecipient,\n        uint256 _managementFee,\n        uint256 _performanceFee,\n        string memory tokenName,\n        string memory tokenSymbol,\n        Vault.VaultParams calldata _vaultParams\n    ) internal initializer {\n        VaultLifecycle.verifyConstructorParams(\n            _owner,\n            _feeRecipient,\n            _performanceFee,\n            tokenName,\n            tokenSymbol,\n            _vaultParams\n        );\n\n        __ReentrancyGuard_init();\n        __ERC20_init(tokenName, tokenSymbol);\n        __Ownable_init();\n        transferOwnership(_owner);\n\n        feeRecipient = _feeRecipient;\n        performanceFee = _performanceFee;\n        managementFee = _managementFee.mul(10**6).div(WEEKS_PER_YEAR);\n        vaultParams = _vaultParams;\n        vaultState.lastLockedAmount = uint104(\n            IERC20(vaultParams.asset).balanceOf(address(this))\n        );\n\n        vaultState.round = 1;\n    }\n\n    /************************************************\n     *  SETTERS\n     ***********************************************/\n\n    /**\n     * @notice Sets the new fee recipient\n     * @param newFeeRecipient is the address of the new fee recipient\n     */\n    function setFeeRecipient(address newFeeRecipient) external onlyOwner {\n        require(newFeeRecipient != address(0), \"!newFeeRecipient\");\n        feeRecipient = newFeeRecipient;\n    }\n\n    /**\n     * @notice Sets the management fee for the vault\n     * @param newManagementFee is the management fee (6 decimals). ex: 2 * 10 ** 6 = 2%\n     */\n    function setManagementFee(uint256 newManagementFee) external onlyOwner {\n        require(newManagementFee < 100 * 10**6, \"Invalid management fee\");\n\n        emit ManagementFeeSet(managementFee, newManagementFee);\n\n        // We are dividing annualized management fee by num weeks in a year\n        managementFee = newManagementFee.mul(10**6).div(WEEKS_PER_YEAR);\n    }\n\n    /**\n     * @notice Sets the performance fee for the vault\n     * @param newPerformanceFee is the performance fee (6 decimals). ex: 20 * 10 ** 6 = 20%\n     */\n    function setPerformanceFee(uint256 newPerformanceFee) external onlyOwner {\n        require(newPerformanceFee < 100 * 10**6, \"Invalid performance fee\");\n\n        emit PerformanceFeeSet(performanceFee, newPerformanceFee);\n\n        performanceFee = newPerformanceFee;\n    }\n\n    /**\n     * @notice Sets a new cap for deposits\n     * @param newCap is the new cap for deposits\n     */\n    function setCap(uint104 newCap) external onlyOwner {\n        require(newCap > 0, \"!newCap\");\n        uint256 oldCap = vaultParams.cap;\n        vaultParams.cap = newCap;\n        emit CapSet(oldCap, newCap, msg.sender);\n    }\n\n    /************************************************\n     *  DEPOSIT & WITHDRAWALS\n     ***********************************************/\n\n    /**\n     * @notice Deposits ETH into the contract and mint vault shares. Reverts if the asset is not WETH.\n     */\n    function depositETH() external payable nonReentrant {\n        require(vaultParams.asset == WETH, \"!WETH\");\n        require(msg.value > 0, \"!value\");\n\n        _depositFor(msg.value, msg.sender);\n\n        IWETH(WETH).deposit{value: msg.value}();\n    }\n\n    /**\n     * @notice Deposits the `asset` from msg.sender.\n     * @param amount is the amount of `asset` to deposit\n     */\n    function deposit(uint256 amount) external nonReentrant {\n        require(amount > 0, \"!amount\");\n\n        _depositFor(amount, msg.sender);\n\n        IERC20(vaultParams.asset).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n    }\n\n    /**\n     * @notice Deposits the `asset` from msg.sender added to `creditor`'s deposit.\n     * @notice Used for vault -> vault deposits on the user's behalf\n     * @param amount is the amount of `asset` to deposit\n     * @param creditor is the address that can claim/withdraw deposited amount\n     */\n    function depositFor(uint256 amount, address creditor)\n        external\n        nonReentrant\n    {\n        require(amount > 0, \"!amount\");\n        require(creditor != address(0));\n\n        _depositFor(amount, creditor);\n\n        IERC20(vaultParams.asset).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n    }\n\n    /**\n     * @notice Deposits the `asset` from msg.sender added to `creditor`'s deposit.\n     * @notice Used for vault -> vault deposits on the user's behalf\n     * @param amount is the amount of `asset` to deposit\n     * @param creditor is the address that can claim/withdraw deposited amount\n     */\n    function _depositFor(uint256 amount, address creditor) private {\n        uint256 currentRound = vaultState.round;\n        uint256 totalWithDepositedAmount = totalBalance().add(amount);\n\n        require(totalWithDepositedAmount <= vaultParams.cap, \"Exceed cap\");\n        require(\n            totalWithDepositedAmount >= vaultParams.minimumSupply,\n            \"Insufficient balance\"\n        );\n\n        emit Deposit(creditor, amount, currentRound);\n\n        Vault.DepositReceipt memory depositReceipt = depositReceipts[creditor];\n\n        // If we have an unprocessed pending deposit from the previous rounds, we have to process it.\n        uint128 unredeemedShares =\n            depositReceipt.getSharesFromReceipt(\n                currentRound,\n                roundPricePerShare[depositReceipt.round],\n                vaultParams.decimals\n            );\n\n        uint256 depositAmount = uint104(amount);\n        // If we have a pending deposit in the current round, we add on to the pending deposit\n        if (currentRound == depositReceipt.round) {\n            uint256 newAmount = uint256(depositReceipt.amount).add(amount);\n            depositAmount = newAmount;\n        }\n\n        ShareMath.assertUint104(depositAmount);\n\n        depositReceipts[creditor] = Vault.DepositReceipt({\n            processed: false,\n            round: uint16(currentRound),\n            amount: uint104(depositAmount),\n            unredeemedShares: unredeemedShares\n        });\n\n        vaultState.totalPending = uint128(\n            uint256(vaultState.totalPending).add(amount)\n        );\n    }\n\n    /**\n     * @notice Initiates a withdrawal that can be processed once the round completes\n     * @param shares is the number of shares to withdraw\n     */\n    function initiateWithdraw(uint128 shares) external nonReentrant {\n        require(shares > 0, \"!shares\");\n\n        // We do a max redeem before initiating a withdrawal\n        // But we check if they must first have unredeemed shares\n        if (\n            depositReceipts[msg.sender].amount > 0 ||\n            depositReceipts[msg.sender].unredeemedShares > 0\n        ) {\n            _redeem(0, true);\n        }\n\n        // This caches the `round` variable used in shareBalances\n        uint256 currentRound = vaultState.round;\n        Vault.Withdrawal storage withdrawal = withdrawals[msg.sender];\n\n        bool topup = withdrawal.round == currentRound;\n\n        emit InitiateWithdraw(msg.sender, shares, currentRound);\n\n        uint256 withdrawalShares = uint256(withdrawal.shares);\n\n        if (topup) {\n            uint256 increasedShares = withdrawalShares.add(shares);\n            ShareMath.assertUint128(increasedShares);\n            withdrawals[msg.sender].shares = uint128(increasedShares);\n        } else if (withdrawalShares == 0) {\n            withdrawals[msg.sender].shares = shares;\n            withdrawals[msg.sender].round = uint16(currentRound);\n        } else {\n            // If we have an old withdrawal, we revert\n            // The user has to process the withdrawal\n            revert(\"Existing withdraw\");\n        }\n\n        vaultState.queuedWithdrawShares = uint128(\n            uint256(vaultState.queuedWithdrawShares).add(shares)\n        );\n\n        _transfer(msg.sender, address(this), shares);\n    }\n\n    /**\n     * @notice Completes a scheduled withdrawal from a past round. Uses finalized pps for the round\n     */\n    function completeWithdraw() external nonReentrant {\n        Vault.Withdrawal storage withdrawal = withdrawals[msg.sender];\n\n        uint256 withdrawalShares = withdrawal.shares;\n        uint256 withdrawalRound = withdrawal.round;\n\n        // This checks if there is a withdrawal\n        require(withdrawalShares > 0, \"Not initiated\");\n\n        require(withdrawalRound < vaultState.round, \"Round not closed\");\n\n        // We leave the round number as non-zero to save on gas for subsequent writes\n        withdrawals[msg.sender].shares = 0;\n        vaultState.queuedWithdrawShares = uint128(\n            uint256(vaultState.queuedWithdrawShares).sub(withdrawalShares)\n        );\n\n        uint256 withdrawAmount =\n            ShareMath.sharesToUnderlying(\n                withdrawalShares,\n                roundPricePerShare[uint16(withdrawalRound)],\n                vaultParams.decimals\n            );\n\n        emit Withdraw(msg.sender, withdrawAmount, withdrawalShares);\n\n        _burn(address(this), withdrawalShares);\n\n        require(withdrawAmount > 0, \"!withdrawAmount\");\n        transferAsset(msg.sender, withdrawAmount);\n    }\n\n    /**\n     * @notice Redeems shares that are owed to the account\n     * @param shares is the number of shares to redeem\n     */\n    function redeem(uint256 shares) external nonReentrant {\n        require(shares > 0, \"!shares\");\n        _redeem(shares, false);\n    }\n\n    /**\n     * @notice Redeems the entire unredeemedShares balance that is owed to the account\n     */\n    function maxRedeem() external nonReentrant {\n        _redeem(0, true);\n    }\n\n    /**\n     * @notice Redeems shares that are owed to the account\n     * @param shares is the number of shares to redeem, could be 0 when isMax=true\n     * @param isMax is flag for when callers do a max redemption\n     */\n    function _redeem(uint256 shares, bool isMax) internal {\n        ShareMath.assertUint104(shares);\n\n        Vault.DepositReceipt memory depositReceipt =\n            depositReceipts[msg.sender];\n\n        // This handles the null case when depositReceipt.round = 0\n        // Because we start with round = 1 at `initialize`\n        uint16 currentRound = vaultState.round;\n        require(depositReceipt.round < currentRound, \"Round not closed\");\n\n        uint128 unredeemedShares =\n            depositReceipt.getSharesFromReceipt(\n                currentRound,\n                roundPricePerShare[depositReceipt.round],\n                vaultParams.decimals\n            );\n\n        shares = isMax ? unredeemedShares : shares;\n        require(shares > 0, \"!shares\");\n        require(shares <= unredeemedShares, \"Exceeds available\");\n\n        // This zeroes out any pending amount from depositReceipt\n        depositReceipts[msg.sender].amount = 0;\n        depositReceipts[msg.sender].processed = true;\n        depositReceipts[msg.sender].unredeemedShares = uint128(\n            uint256(unredeemedShares).sub(shares)\n        );\n\n        emit Redeem(msg.sender, shares, depositReceipt.round);\n\n        _transfer(address(this), msg.sender, shares);\n    }\n\n    /************************************************\n     *  VAULT OPERATIONS\n     ***********************************************/\n\n    /*\n     * @notice Helper function that helps to save gas for writing values into the roundPricePerShare map.\n     *         Writing `1` into the map makes subsequent writes warm, reducing the gas from 20k to 5k.\n     *         Having 1 initialized beforehand will not be an issue as long as we round down share calculations to 0.\n     * @param numRounds is the number of rounds to initialize in the map\n     */\n    function initRounds(uint256 numRounds) external nonReentrant {\n        require(numRounds < 52, \"numRounds >= 52\");\n\n        uint16 _round = vaultState.round;\n        for (uint16 i = 0; i < numRounds; i++) {\n            uint16 index = _round + i;\n            require(index >= _round, \"Overflow\");\n            require(roundPricePerShare[index] == 0, \"Initialized\"); // AVOID OVERWRITING ACTUAL VALUES\n            roundPricePerShare[index] = PLACEHOLDER_UINT;\n        }\n    }\n\n    /*\n     * @notice Helper function that performs most administrative tasks\n     * such as setting next option, minting new shares, getting vault fees, etc.\n     * @return newOption is the new option address\n     * @return lockedBalance is the new balance used to calculate next option purchase size or collateral size\n     */\n    function _rollToNextOption() internal returns (address, uint256) {\n        require(block.timestamp >= optionState.nextOptionReadyAt, \"!ready\");\n\n        address newOption = optionState.nextOption;\n        require(newOption != address(0), \"!nextOption\");\n\n        (uint256 lockedBalance, uint256 newPricePerShare, uint256 mintShares) =\n            VaultLifecycle.rollover(\n                totalSupply(),\n                vaultParams.asset,\n                vaultParams.decimals,\n                vaultParams.initialSharePrice,\n                uint256(vaultState.totalPending),\n                vaultState.queuedWithdrawShares\n            );\n\n        optionState.currentOption = newOption;\n        optionState.nextOption = address(0);\n\n        // Finalize the pricePerShare at the end of the round\n        uint16 currentRound = vaultState.round;\n        roundPricePerShare[currentRound] = newPricePerShare;\n\n        // Take management / performance fee from previous round and deduct\n        lockedBalance = lockedBalance.sub(_collectVaultFees(lockedBalance));\n\n        vaultState.totalPending = 0;\n        vaultState.round = currentRound + 1;\n\n        _mint(address(this), mintShares);\n\n        return (newOption, lockedBalance);\n    }\n\n    /*\n     * @notice Helper function that transfers management fees and performance fees from previous round.\n     * @param currentLockedBalance is the balance we are about to lock for next round\n     * @return vaultFee is the fee deducted\n     */\n    function _collectVaultFees(uint256 currentLockedBalance)\n        internal\n        returns (uint256 vaultFee)\n    {\n        uint256 prevLockedAmount = vaultState.lastLockedAmount;\n        uint256 lockedBalanceSansPending =\n            currentLockedBalance.sub(vaultState.totalPending);\n\n        // Take performance fee and management fee ONLY if difference between\n        // last week and this week's vault deposits, taking into account pending\n        // deposits and withdrawals, is positive. If it is negative, last week's\n        // option expired ITM past breakeven, and the vault took a loss so we\n        // do not collect performance fee for last week\n        if (lockedBalanceSansPending > prevLockedAmount) {\n            uint256 performanceFeeInAsset =\n                performanceFee > 0\n                    ? lockedBalanceSansPending\n                        .sub(prevLockedAmount)\n                        .mul(performanceFee)\n                        .div(100 * 10**6)\n                    : 0;\n            uint256 managementFeeInAsset =\n                managementFee > 0\n                    ? currentLockedBalance.mul(managementFee).div(100 * 10**6)\n                    : 0;\n\n            vaultFee = performanceFeeInAsset.add(managementFeeInAsset);\n        }\n\n        if (vaultFee > 0) {\n            transferAsset(payable(feeRecipient), vaultFee);\n            emit CollectVaultFees(performanceFee, vaultFee, vaultState.round);\n        }\n    }\n\n    /**\n     * @notice Helper function to make either an ETH transfer or ERC20 transfer\n     * @param recipient is the receiving address\n     * @param amount is the transfer amount\n     */\n    function transferAsset(address payable recipient, uint256 amount) internal {\n        address asset = vaultParams.asset;\n        if (asset == WETH) {\n            IWETH(WETH).withdraw(amount);\n            (bool success, ) = recipient.call{value: amount}(\"\");\n            require(success, \"!success\");\n            return;\n        }\n        IERC20(asset).safeTransfer(recipient, amount);\n    }\n\n    /************************************************\n     *  GETTERS\n     ***********************************************/\n\n    /**\n     * @notice Returns the underlying balance held on the vault for the account\n     * @param account is the address to lookup balance for\n     */\n    function accountVaultBalance(address account)\n        external\n        view\n        returns (uint256)\n    {\n        uint8 decimals = vaultParams.decimals;\n        uint256 numShares = shares(account);\n        uint256 pps =\n            totalBalance().sub(vaultState.totalPending).mul(10**decimals).div(\n                totalSupply()\n            );\n        return ShareMath.sharesToUnderlying(numShares, pps, decimals);\n    }\n\n    /**\n     * @notice Getter for returning the account's share balance including unredeemed shares\n     * @param account is the account to lookup share balance for\n     * @return the share balance\n     */\n    function shares(address account) public view returns (uint256) {\n        (uint256 heldByAccount, uint256 heldByVault) = shareBalances(account);\n        return heldByAccount.add(heldByVault);\n    }\n\n    /**\n     * @notice Getter for returning the account's share balance split between account and vault holdings\n     * @param account is the account to lookup share balance for\n     * @return heldByAccount is the shares held by account\n     * @return heldByVault is the shares held on the vault (unredeemedShares)\n     */\n    function shareBalances(address account)\n        public\n        view\n        returns (uint256 heldByAccount, uint256 heldByVault)\n    {\n        Vault.DepositReceipt memory depositReceipt = depositReceipts[account];\n\n        if (depositReceipt.round < PLACEHOLDER_UINT) {\n            return (balanceOf(account), 0);\n        }\n\n        uint128 unredeemedShares =\n            depositReceipt.getSharesFromReceipt(\n                vaultState.round,\n                roundPricePerShare[depositReceipt.round],\n                vaultParams.decimals\n            );\n\n        return (balanceOf(account), unredeemedShares);\n    }\n\n    /**\n     * @notice The price of a unit of share denominated in the `collateral`\n     */\n    function pricePerShare() external view returns (uint256) {\n        uint256 balance = totalBalance().sub(vaultState.totalPending);\n        return\n            (10**uint256(vaultParams.decimals)).mul(balance).div(totalSupply());\n    }\n\n    /**\n     * @notice Returns the vault's total balance, including the amounts locked into a short position\n     * @return total balance of the vault, including the amounts locked in third party protocols\n     */\n    function totalBalance() public view returns (uint256) {\n        return\n            uint256(vaultState.lockedAmount).add(\n                IERC20(vaultParams.asset).balanceOf(address(this))\n            );\n    }\n\n    /**\n     * @notice Returns the token decimals\n     */\n    function decimals() public view override returns (uint8) {\n        return vaultParams.decimals;\n    }\n\n    function cap() external view returns (uint256) {\n        return vaultParams.cap;\n    }\n\n    function nextOptionReadyAt() external view returns (uint256) {\n        return optionState.nextOptionReadyAt;\n    }\n\n    function currentOption() external view returns (address) {\n        return optionState.currentOption;\n    }\n\n    function nextOption() external view returns (address) {\n        return optionState.nextOption;\n    }\n\n    function totalPending() external view returns (uint256) {\n        return vaultState.totalPending;\n    }\n\n    /************************************************\n     *  HELPERS\n     ***********************************************/\n}"
    },
    {
      "filename": "contracts/libraries/SupportsNonCompliantERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.3;\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nlibrary SupportsNonCompliantERC20 {\n    address constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 amount\n    ) internal {\n        if (address(token) == USDT) {\n            SafeERC20.safeApprove(token, spender, 0);\n        }\n        SafeERC20.safeApprove(token, spender, amount);\n    }\n}"
    },
    {
      "filename": "contracts/interfaces/IRibbon.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.3;\n\ninterface IStrikeSelection {\n    function getStrikePrice(uint256 expiryTimestamp, bool isPut)\n        external\n        view\n        returns (uint256, uint256);\n\n    function delta() external view returns (uint256);\n}\n\ninterface IOptionsPremiumPricer {\n    function getPremium(\n        uint256 strikePrice,\n        uint256 timeToExpiry,\n        bool isPut\n    ) external view returns (uint256);\n\n    function getOptionDelta(\n        uint256 sp,\n        uint256 st,\n        uint256 v,\n        uint256 t\n    ) external view returns (uint256 delta);\n\n    function getUnderlyingPrice() external view returns (uint256 price);\n\n    function priceOracle() external view returns (address oracle);\n\n    function volatilityOracle() external view returns (address oracle);\n\n    function pool() external view returns (address _pool);\n}"
    },
    {
      "filename": "contracts/libraries/ShareMath.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.3;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {Vault} from \"./Vault.sol\";\n\nlibrary ShareMath {\n    using SafeMath for uint256;\n\n    uint256 constant PLACEHOLDER_UINT = 1;\n\n    function underlyingToShares(\n        uint256 underlyingAmount,\n        uint256 pps,\n        uint8 decimals\n    ) internal pure returns (uint104) {\n        // If this throws, it means that vault's roundPricePerShare[currentRound] has not been set yet\n        // which should never happen.\n        // Has to be larger than 1 because `1` is used in `initRoundPricePerShares` to prevent cold writes.\n        require(pps > PLACEHOLDER_UINT, \"Invalid pps\");\n\n        uint256 shares =\n            uint256(underlyingAmount).mul(10**uint256(decimals)).div(pps);\n        assertUint104(shares);\n\n        return uint104(shares);\n    }\n\n    function sharesToUnderlying(\n        uint256 shares,\n        uint256 pps,\n        uint8 decimals\n    ) internal pure returns (uint256) {\n        // If this throws, it means that vault's roundPricePerShare[currentRound] has not been set yet\n        // which should never happen.\n        // Has to be larger than 1 because `1` is used in `initRoundPricePerShares` to prevent cold writes.\n        require(pps > PLACEHOLDER_UINT, \"Invalid pps\");\n\n        uint256 underlyingAmount =\n            uint256(shares).mul(pps).div(10**uint256(decimals));\n        assertUint104(shares);\n\n        return underlyingAmount;\n    }\n\n    /**\n     * @notice Returns the shares unredeemed by the user given their DepositReceipt\n     * @param depositReceipt is the user's deposit receipt\n     * @param currentRound is the `round` stored on the vault\n     * @param pps is the price in underlying per share\n     * @param decimals is the number of decimals the underlying/shares use\n     * @return unredeemedShares is the user's virtual balance of shares that are owed\n     */\n    function getSharesFromReceipt(\n        Vault.DepositReceipt memory depositReceipt,\n        uint256 currentRound,\n        uint256 pps,\n        uint8 decimals\n    ) internal pure returns (uint128 unredeemedShares) {\n        if (\n            depositReceipt.round > 0 &&\n            depositReceipt.round < currentRound &&\n            !depositReceipt.processed\n        ) {\n            uint256 sharesFromRound =\n                underlyingToShares(depositReceipt.amount, pps, decimals);\n\n            assertUint104(sharesFromRound);\n\n            uint256 unredeemedShares256 =\n                uint256(depositReceipt.unredeemedShares).add(sharesFromRound);\n            assertUint128(unredeemedShares256);\n\n            unredeemedShares = uint128(unredeemedShares256);\n        } else {\n            unredeemedShares = depositReceipt.unredeemedShares;\n        }\n    }\n\n    /************************************************\n     *  HELPERS\n     ***********************************************/\n\n    function assertUint104(uint256 num) internal pure {\n        require(num <= type(uint104).max, \">U104\");\n    }\n\n    function assertUint128(uint256 num) internal pure {\n        require(num <= type(uint128).max, \">U128\");\n    }\n}"
    },
    {
      "filename": "contracts/libraries/ShareMath.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.3;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {Vault} from \"./Vault.sol\";\n\nlibrary ShareMath {\n    using SafeMath for uint256;\n\n    uint256 constant PLACEHOLDER_UINT = 1;\n\n    function underlyingToShares(\n        uint256 underlyingAmount,\n        uint256 pps,\n        uint8 decimals\n    ) internal pure returns (uint104) {\n        // If this throws, it means that vault's roundPricePerShare[currentRound] has not been set yet\n        // which should never happen.\n        // Has to be larger than 1 because `1` is used in `initRoundPricePerShares` to prevent cold writes.\n        require(pps > PLACEHOLDER_UINT, \"Invalid pps\");\n\n        uint256 shares =\n            uint256(underlyingAmount).mul(10**uint256(decimals)).div(pps);\n        assertUint104(shares);\n\n        return uint104(shares);\n    }\n\n    function sharesToUnderlying(\n        uint256 shares,\n        uint256 pps,\n        uint8 decimals\n    ) internal pure returns (uint256) {\n        // If this throws, it means that vault's roundPricePerShare[currentRound] has not been set yet\n        // which should never happen.\n        // Has to be larger than 1 because `1` is used in `initRoundPricePerShares` to prevent cold writes.\n        require(pps > PLACEHOLDER_UINT, \"Invalid pps\");\n\n        uint256 underlyingAmount =\n            uint256(shares).mul(pps).div(10**uint256(decimals));\n        assertUint104(shares);\n\n        return underlyingAmount;\n    }\n\n    /**\n     * @notice Returns the shares unredeemed by the user given their DepositReceipt\n     * @param depositReceipt is the user's deposit receipt\n     * @param currentRound is the `round` stored on the vault\n     * @param pps is the price in underlying per share\n     * @param decimals is the number of decimals the underlying/shares use\n     * @return unredeemedShares is the user's virtual balance of shares that are owed\n     */\n    function getSharesFromReceipt(\n        Vault.DepositReceipt memory depositReceipt,\n        uint256 currentRound,\n        uint256 pps,\n        uint8 decimals\n    ) internal pure returns (uint128 unredeemedShares) {\n        if (\n            depositReceipt.round > 0 &&\n            depositReceipt.round < currentRound &&\n            !depositReceipt.processed\n        ) {\n            uint256 sharesFromRound =\n                underlyingToShares(depositReceipt.amount, pps, decimals);\n\n            assertUint104(sharesFromRound);\n\n            uint256 unredeemedShares256 =\n                uint256(depositReceipt.unredeemedShares).add(sharesFromRound);\n            assertUint128(unredeemedShares256);\n\n            unredeemedShares = uint128(unredeemedShares256);\n        } else {\n            unredeemedShares = depositReceipt.unredeemedShares;\n        }\n    }\n\n    /************************************************\n     *  HELPERS\n     ***********************************************/\n\n    function assertUint104(uint256 num) internal pure {\n        require(num <= type(uint104).max, \">U104\");\n    }\n\n    function assertUint128(uint256 num) internal pure {\n        require(num <= type(uint128).max, \">U128\");\n    }\n}"
    },
    {
      "filename": "contracts/libraries/ShareMath.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.3;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {Vault} from \"./Vault.sol\";\n\nlibrary ShareMath {\n    using SafeMath for uint256;\n\n    uint256 constant PLACEHOLDER_UINT = 1;\n\n    function underlyingToShares(\n        uint256 underlyingAmount,\n        uint256 pps,\n        uint8 decimals\n    ) internal pure returns (uint104) {\n        // If this throws, it means that vault's roundPricePerShare[currentRound] has not been set yet"
    }
  ]
}