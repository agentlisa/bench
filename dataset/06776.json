{
  "Title": "[H-04] `ReraiseETHCrowdfund.sol`: Multiple scenarios how pending votes might not be claimable which is a complete loss of funds for a user",
  "Content": "\n<https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L256-L303>\n\n<https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L333-L382>\n\nThis issue is about how the [`ReraiseETHCrowdfund`](https://github.com/code-423n4/2023-04-party/blob/main/contracts/crowdfund/ReraiseETHCrowdfund.sol) claim functionality can be broken.\n\nWhen the claim functionality is broken this means that a user cannot claim his voting power, resulting in a complete loss of funds.\n\nThe claim functionality is not broken in any case, i.e. with any configuration of the `ReraiseETHCrowdfund` contract.\n\nHowever the contract can be configured in a way - and by configured I mean specifically the `minContribution`, `maxContribution`, `minTotalContributions` and `maxTotalContributions` variables - that the claim functionality breaks.\n\nAnd the configurations under which it breaks are NOT edge cases. They represent the **intended use** of the contract as discussed with the sponsor.\n\nThe fact that when the contract is used as intended it can lead to a complete loss of funds for the users makes me estimate this to be \"High\" severity.\n\n### Proof of Concept\n\nWe first need to understand the `claim(uint256 tokenId, address contributor)` and `claimMultiple(uint96[] memory votingPowerByCard, address contributor)` functions. They essentially make up the claim functionality as all other functions regarding claiming are just wrappers around them.\n\nLet's first look at the `claim(uint256 tokenId, address contributor)` function. The first part of the function is what we are interested in:\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L256-L283)\n\n```solidity\nfunction claim(uint256 tokenId, address contributor) public {\n    // Check crowdfund lifecycle.\n    {\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\n        if (lc != CrowdfundLifecycle.Finalized) {\n            revert WrongLifecycleError(lc);\n        }\n    }\n\n\n    uint96 votingPower = pendingVotingPower[contributor];\n\n\n    if (votingPower == 0) return;\n\n\n    {\n        uint96 contribution = (votingPower * 1e4) / exchangeRateBps;\n        uint96 maxContribution_ = maxContribution;\n        // Check that the contribution equivalent of total pending voting\n        // power is not above the max contribution range. This can happen\n        // for contributors who contributed multiple times In this case, the\n        // `claimMultiple` function should be called instead. This is done\n        // so parties may use the minimum and maximum contribution values to\n        // limit the voting power of each card (e.g.  a party desiring a \"1\n        // card = 1 vote\"-like governance system where each card has equal\n        // voting power).\n        if (contribution > maxContribution_) {\n            revert AboveMaximumContributionsError(contribution, maxContribution_);\n        }\n    }\n```\n\nWhat is important is that `contribution` is calculatesd as:\n\n```solidity\nuint96 contribution = (votingPower * 1e4) / exchangeRateBps;\n```\n\nAnd then `contribution` is checked that it is `<= maxContribution`:\n\n```solidity\nif (contribution > maxContribution_) {\n    revert AboveMaximumContributionsError(contribution, maxContribution_);\n}\n```\n\nThe explanation for why this check is necessary can be seen in the comment:\n\n```text\n// This is done\n// so parties may use the minimum and maximum contribution values to\n// limit the voting power of each card (e.g.  a party desiring a \"1\n// card = 1 vote\"-like governance system where each card has equal\n// voting power).\n```\n\nThe `claimMultiple(uint96[] memory votingPowerByCard, address contributor)` function allows to divide the pending voting power across multiple party cards and it employs the following checks:\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L352-L382)\n\n```solidity\n    uint96 minContribution_ = minContribution;\n    uint96 maxContribution_ = maxContribution;\n    for (uint256 i; i < votingPowerByCard.length; ++i) {\n        if (votingPowerByCard[i] == 0) continue;\n\n\n        // Check that the contribution equivalent of voting power is within\n        // contribution range. This is done so parties may use the minimum\n        // and maximum contribution values to limit the voting power of each\n        // card (e.g. a party desiring a \"1 card = 1 vote\"-like governance\n        // system where each card has equal voting power).\n        uint96 contribution = (votingPowerByCard[i] * 1e4) / exchangeRateBps;\n        if (contribution < minContribution_) {\n            revert BelowMinimumContributionsError(contribution, minContribution_);\n        }\n\n\n        if (contribution > maxContribution_) {\n            revert AboveMaximumContributionsError(contribution, maxContribution_);\n        }\n\n\n        votingPower -= votingPowerByCard[i];\n\n\n        // Mint contributor a new party card.\n        uint256 tokenId = party.mint(contributor, votingPowerByCard[i], delegate);\n\n\n        emit Claimed(contributor, tokenId, votingPowerByCard[i]);\n    }\n\n\n    // Requires that all voting power is claimed because the contributor is\n    // expected to have burned their crowdfund NFT.\n    if (votingPower != 0) revert RemainingVotingPowerAfterClaimError(votingPower);\n}\n```\n\nWe can see that for each party card the `contribution` needs to be `>= minContribution` and `<= maxContribution`. Also the function must deal with all the voting power, so after the function call all pending voting power must be processed:\n\n```solidity\nif (votingPower != 0) revert RemainingVotingPowerAfterClaimError(votingPower);\n```\n\nNow we are in a position to look at a simple scenario how a user can end up without being able to claim his pending voting power (Note that this can also be a griefing attack whereby an attacker contributes for the victim some possibly small amount thereby making it impossible for the victim to claim):\n\n(The test should be added to the `ReraiseETHCrowdfund.t.sol` test file)\n\n```solidity\nfunction test_cannotClaim1() public {\n        ReraiseETHCrowdfund crowdfund = _createCrowdfund({\n            initialContribution: 0,\n            initialContributor: payable(address(0)),\n            initialDelegate: address(0),\n            minContributions: 0.9 ether,\n            maxContributions: 1 ether,\n            disableContributingForExistingCard: false,\n            minTotalContributions: 1 ether,\n            maxTotalContributions: 1.5 ether,\n            duration: 7 days,\n            fundingSplitBps: 0,\n            fundingSplitRecipient: payable(address(0))\n        });\n\n        address member = _randomAddress();\n        vm.deal(member, 2 ether);\n\n        // Contribute\n        vm.startPrank(member);\n        crowdfund.contribute{ value: 1 ether }(member, \"\");\n        crowdfund.contribute{ value: 1 ether }(member, \"\");\n        vm.stopPrank();\n\n        assertEq(crowdfund.pendingVotingPower(member), 1.5 ether);\n\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                ETHCrowdfundBase.AboveMaximumContributionsError.selector,\n                1500000000000000000,\n                1000000000000000000\n            )\n        );\n        crowdfund.claim(member);\n    }\n```\n\nIn this test the following values were chosen for the important variables that I mentioned above:\n\n    minContribution = 0.9e18\n    maxContribution = 1e18\n\n    minTotalContributions = 1e18\n    maxTotalContributions = 1.5e18\n\nWhat happens in the test is that first `1 ETH` is contributed then another `0.5 ETH` is contributed (It says `1 ETH` but `maxTotalContributions` is hit and so only `0.5 ETH` is contributed and the crowdfund is finalized).\n\nThe call to the `claim` function fails because `contribution = 1.5 ETH` which is above `maxContribution`.\n\nThe important thing is now to understand that `claimMultiple` can also not be called (therefore the pending voting power cannot be claimed at all).\n\nWhen we call `claimMultiple` the contribution for the first party card must be in the range `[0.9e18, 1e18]` to succeed and therefore the second contribution can only be in the range of `[0.5e18,0.6e18]` which is below `minContribution` and therefore it is not possible to distribute the voting power across cards such that the call succeeds.\n\nWhat we discussed so far could be mitigated by introducing some simple checks when setting up the crowdfund. The sort of checks required are like \"`minTotalContributions` must be divisible by `minContribution`\". I won't go into this deeply however because these checks are insufficient when we introduce a funding fee.\n\nLet's consider a case with:\n\n    minContribution = 1e18\n    maxContribution = 1e18\n    minTotalContributions = 2e18\n    maxTotalContributions = 2e18\n\n(Note that setting up the crowdfund with `minContribution==maxContribution` is an important use case where the party wants to enforce a \"1 card = 1 vote\"-policy).\n\nThere should be no way how this scenario causes a problem right? The contribution of a user can only be `1e18` or `2e18` and in both cases the checks in the claim functions should pass. - No\n\nIt breaks when we introduce a fee. Say there is a 1% fee (`fundingSplitBps=100`).\n\nThe contribution is calculated as (as we know from above):\n\n(Also note that `exchangeRateBps=1e4` for all tests, i.e. the exchange rate between ETH and votes is 1:1)\n\n```solidity\nuint96 contribution = (votingPower * 1e4) / exchangeRateBps;\n```\n\nThe problem is that `votingPower` has been reduced by 1% due to the funding fee. So when a user initially contributes `1e18`, the `contribution` here is calculated to be `0.99e18 * 1e4 / 1e4 = 0.99e18` which is below `minContribution` and claiming is not possible.\n\nLet's make a final observation: The parameters can also be such that due to rounding a similar thing happens:\n\n    minContribution = 1e18 + 1 Wei\n    maxContribution = 1e18 + 1 Wei\n    minTotalContributions = 2e18 + 2 Wei\n    maxTotalContributions = 2e18 + 2 Wei\n\nDue to rounding (when calculating the funding fee or when there is not a 1:1 exchange rate) the 1 Wei in the contribution can be lost (or some other small amount) and thereby when calling `claim`, the `contribution` which has been rounded down is below `minContribution` and the claim fails.\n\nTo summarize we have seen 3 scenarios. It is not possible for me to provide an overview of all the things that can go wrong. There are just too many variables. I come back to this point in my recommendation.\n\n### Tools Used\n\nVSCode, Foundry\n\n### Recommended Mitigation Steps\n\nA part of the fix is straightforward. However this is not a full fix.\n\nI recommend to implement a functionality for claiming that cannot be blocked. I know that this may cause the \"1 card = 1 vote\"-policy to be violated and it may also cause `minContribution` or `maxContribution` to be violated. But maybe this is the price to pay to ensure that users can always claim.\n\nAn alternative solution may be to reduce the range of possible configurations of the crowdfund drastically such that it can be mathematically proven that users are always able to claim.\n\nThat being said there is an obvious flaw in the current code that has been confirmed by the sponsor.\n\nThe `contribution` amount that is calculated when claiming needs to add back the funding fee amount. I.e. if there was a 1% funding fee, the `contribution` amount should be `1e18` instead of `0.99e18`.\n\nPartial fix:\n\n```diff\ndiff --git a/contracts/crowdfund/ReraiseETHCrowdfund.sol b/contracts/crowdfund/ReraiseETHCrowdfund.sol\nindex 580623d..0b1ba9e 100644\n--- a/contracts/crowdfund/ReraiseETHCrowdfund.sol\n+++ b/contracts/crowdfund/ReraiseETHCrowdfund.sol\n@@ -268,6 +268,13 @@ contract ReraiseETHCrowdfund is ETHCrowdfundBase, CrowdfundNFT {\n \n         {\n             uint96 contribution = (votingPower * 1e4) / exchangeRateBps;\n+\n+            address payable fundingSplitRecipient_ = fundingSplitRecipient;\n+            uint16 fundingSplitBps_ = fundingSplitBps;\n+            if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {\n+                contribution = (contribution * 1e4) / (1e4 - fundingSplitBps_);\n+            }\n+\n             uint96 maxContribution_ = maxContribution;\n             // Check that the contribution equivalent of total pending voting\n             // power is not above the max contribution range. This can happen\n@@ -360,6 +367,13 @@ contract ReraiseETHCrowdfund is ETHCrowdfundBase, CrowdfundNFT {\n             // card (e.g. a party desiring a \"1 card = 1 vote\"-like governance\n             // system where each card has equal voting power).\n             uint96 contribution = (votingPowerByCard[i] * 1e4) / exchangeRateBps;\n+\n+            address payable fundingSplitRecipient_ = fundingSplitRecipient;\n+            uint16 fundingSplitBps_ = fundingSplitBps;\n+            if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {\n+                contribution = (contribution * 1e4) / (1e4 - fundingSplitBps_);\n+            }\n+\n             if (contribution < minContribution_) {\n                 revert BelowMinimumContributionsError(contribution, minContribution_);\n             }\n```\n\n**[0xble (Party) commented](https://github.com/code-423n4/2023-04-party-findings/issues/13#issuecomment-1526174262):**\n > Additional to the partial fix recommended in the mitigation, this will be mitigated by [preventing the case where `minContribution` may be bypassed for the last contributor when the remaining contribution is less than the minimum](https://github.com/code-423n4/2023-04-party-findings/issues/37#issuecomment-1526104629).\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-04-party",
  "Code": [
    {
      "filename": "contracts/crowdfund/ReraiseETHCrowdfund.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./ETHCrowdfundBase.sol\";\nimport \"../crowdfund/CrowdfundNFT.sol\";\nimport \"../utils/LibAddress.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/LibSafeCast.sol\";\nimport \"../tokens/ERC721Receiver.sol\";\nimport \"../party/Party.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../gatekeepers/IGateKeeper.sol\";\n\n/// @notice A crowdfund for raising additional funds for an existing parties.\ncontract ReraiseETHCrowdfund is ETHCrowdfundBase, CrowdfundNFT {\n    using LibRawResult for bytes;\n    using LibSafeCast for uint256;\n    using LibAddress for address payable;\n\n    struct BatchContributeArgs {\n        // The address to which voting power will be delegated for all contributions.\n        address delegate;\n        // The contribution amounts in wei. The length of this array must be\n        // equal to the length of `tokenIds`.\n        uint96[] values;\n        // The data required to be validated by the `gatekeeper`, if set. If no\n        // `gatekeeper` is set, this can be empty.\n        bytes[] gateDatas;\n    }\n\n    struct BatchContributeForArgs {\n        // Addresses of to credit the contributions under. Each contribution\n        // amount in `values` corresponds to a recipient in this array.\n        address payable[] recipients;\n        // The delegate to set for each recipient if they have not delegated\n        // before.\n        address[] initialDelegates;\n        // The contribution amounts in wei. The length of this array must be\n        // equal to the length of `recipients`.\n        uint96[] values;\n        // The data required to be validated by the `gatekeeper`, if set. If no\n        // `gatekeeper` is set, this can be empty.\n        bytes[] gateDatas;\n        // Whether to revert if any individual contribution fails or continue.\n        bool revertOnFailure;\n    }\n\n    event Claimed(address indexed contributor, uint256 indexed tokenId, uint256 votingPower);\n    event Refunded(address indexed contributor, uint256 amount);\n\n    error RemainingVotingPowerAfterClaimError(uint256 remainingVotingPower);\n\n    // The `Globals` contract storing global configuration values. This contract\n    // is immutable and it’s address will never change.\n    IGlobals private immutable _GLOBALS;\n\n    /// @notice The amount of voting power that will be received by a\n    ///         contributor after the crowdfund is won.\n    mapping(address => uint96) public pendingVotingPower;\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) CrowdfundNFT(globals) {\n        _GLOBALS = globals;\n    }\n\n    /// @notice Initializer to be delegatecalled by `Proxy` constructor. Will\n    ///         revert if called outside the constructor.\n    /// @param opts The options to initialize the crowdfund with.\n    function initialize(ETHCrowdfundOptions memory opts) external payable onlyConstructor {\n        // Initialize the crowdfund.\n        ETHCrowdfundBase._initialize(opts);\n\n        // Initialize the crowdfund NFT.\n        _initialize(\n            opts.party.name(),\n            opts.party.symbol(),\n            0 // Ignored. Will use customization preset from party.\n        );\n\n        // If the deployer passed in some ETH during deployment, credit them\n        // for the initial contribution.\n        uint96 initialContribution = msg.value.safeCastUint256ToUint96();\n        if (initialContribution > 0) {\n            // If this contract has ETH, either passed in during deployment or\n            // pre-existing, credit it to the `initialContributor`.\n            _contribute(opts.initialContributor, opts.initialDelegate, initialContribution, \"\");\n        }\n\n        // Set up gatekeeper after initial contribution (initial always gets in).\n        gateKeeper = opts.gateKeeper;\n        gateKeeperId = opts.gateKeeperId;\n    }\n\n    // Initialize name and symbol for crowdfund NFT.\n    function _initialize(string memory name_, string memory symbol_, uint256) internal override {\n        name = name_;\n        symbol = symbol_;\n\n        RendererStorage rendererStorage = RendererStorage(\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_RENDERER_STORAGE)\n        );\n\n        // Use the same customization preset as the party.\n        uint256 customizationPresetId = rendererStorage.getPresetFor(address(party));\n        if (customizationPresetId != 0) {\n            rendererStorage.useCustomizationPreset(customizationPresetId);\n        }\n    }\n\n    /// @notice Contribute ETH to this crowdfund on behalf of a contributor.\n    /// @param delegate The address to which voting power will be delegated to\n    ///                 during the governance phase.\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility.\n    /// @return votingPower The voting power the contributor receives for their\n    ///                     contribution.\n    function contribute(\n        address delegate,\n        bytes memory gateData\n    ) public payable onlyDelegateCall returns (uint96 votingPower) {\n        return\n            _contribute(\n                payable(msg.sender),\n                delegate,\n                msg.value.safeCastUint256ToUint96(),\n                gateData\n            );\n    }\n\n    /// @notice `contribute()` in batch form.\n    ///         May not revert if any individual contribution fails.\n    /// @param args The arguments to pass to each `contribute()` call.\n    /// @return votingPowers The voting power received for each contribution.\n    function batchContribute(\n        BatchContributeArgs calldata args\n    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {\n        uint256 numContributions = args.values.length;\n        votingPowers = new uint96[](numContributions);\n\n        uint256 ethAvailable = msg.value;\n        for (uint256 i; i < numContributions; ++i) {\n            ethAvailable -= args.values[i];\n\n            votingPowers[i] = _contribute(\n                payable(msg.sender),\n                args.delegate,\n                args.values[i],\n                args.gateDatas[i]\n            );\n        }\n\n        // Refund any unused ETH.\n        if (ethAvailable > 0) payable(msg.sender).transfer(ethAvailable);\n    }\n\n    /// @notice Contribute to this crowdfund on behalf of another address.\n    /// @param recipient The address to record the contribution under\n    /// @param initialDelegate The address to delegate to for the governance\n    ///                        phase if recipient hasn't delegated\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility\n    /// @return votingPower The voting power received for the contribution\n    function contributeFor(\n        address payable recipient,\n        address initialDelegate,\n        bytes memory gateData\n    ) external payable onlyDelegateCall returns (uint96 votingPower) {\n        return\n            _contribute(recipient, initialDelegate, msg.value.safeCastUint256ToUint96(), gateData);\n    }\n\n    /// @notice `contributeFor()` in batch form.\n    ///         May not revert if any individual contribution fails.\n    /// @param args The arguments for the batched `contributeFor()` calls.\n    /// @return votingPowers The voting power received for each contribution.\n    function batchContributeFor(\n        BatchContributeForArgs memory args\n    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {\n        uint256 numContributions = args.recipients.length;\n        votingPowers = new uint96[](numContributions);\n\n        uint256 ethAvailable = msg.value;\n        for (uint256 i; i < numContributions; ++i) {\n            ethAvailable -= args.values[i];\n\n            (bool s, bytes memory r) = address(this).call{ value: args.values[i] }(\n                abi.encodeCall(\n                    this.contributeFor,\n                    (args.recipients[i], args.initialDelegates[i], args.gateDatas[i])\n                )\n            );\n\n            if (!s) {\n                if (args.revertOnFailure) {\n                    r.rawRevert();\n                }\n            } else {\n                votingPowers[i] = abi.decode(r, (uint96));\n            }\n        }\n\n        // Refund any unused ETH.\n        if (ethAvailable > 0) payable(msg.sender).transfer(ethAvailable);\n    }\n\n    function _contribute(\n        address payable contributor,\n        address delegate,\n        uint96 amount,\n        bytes memory gateData\n    ) private returns (uint96 votingPower) {\n        // Require a non-null delegate.\n        if (delegate == address(0)) {\n            revert InvalidDelegateError();\n        }\n\n        // Must not be blocked by gatekeeper.\n        IGateKeeper _gateKeeper = gateKeeper;\n        if (_gateKeeper != IGateKeeper(address(0))) {\n            if (!_gateKeeper.isAllowed(contributor, gateKeeperId, gateData)) {\n                revert NotAllowedByGateKeeperError(\n                    contributor,\n                    _gateKeeper,\n                    gateKeeperId,\n                    gateData\n                );\n            }\n        }\n\n        votingPower = _processContribution(contributor, delegate, amount);\n\n        // OK to contribute with zero just to update delegate.\n        if (amount == 0) return 0;\n\n        uint256 previousVotingPower = pendingVotingPower[contributor];\n\n        pendingVotingPower[contributor] += votingPower;\n\n        // Mint a crowdfund NFT if this is their first contribution.\n        if (previousVotingPower == 0) _mint(contributor);\n    }\n\n    /// @notice Claim a party card for a contributor if the crowdfund won. Can be called\n    ///         to claim for self or on another's behalf.\n    /// @param contributor The contributor to claim for.\n    function claim(address contributor) external {\n        claim(\n            0, // Mint a new party card.\n            contributor\n        );\n    }\n\n    /// @notice Claim a party card for a contributor if the crowdfund won. Can be called\n    ///         to claim for self or on another's behalf.\n    /// @param tokenId The ID of the party card to add voting power to. If 0, a\n    ///                new card will be minted.\n    /// @param contributor The contributor to claim for.\n    function claim(uint256 tokenId, address contributor) public {\n        // Check crowdfund lifecycle.\n        {\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\n            if (lc != CrowdfundLifecycle.Finalized) {\n                revert WrongLifecycleError(lc);\n            }\n        }\n\n        uint96 votingPower = pendingVotingPower[contributor];\n\n        if (votingPower == 0) return;\n\n        {\n            uint96 contribution = (votingPower * 1e4) / exchangeRateBps;\n            uint96 maxContribution_ = maxContribution;\n            // Check that the contribution equivalent of total pending voting\n            // power is not above the max contribution range. This can happen\n            // for contributors who contributed multiple times In this case, the\n            // `claimMultiple` function should be called instead. This is done\n            // so parties may use the minimum and maximum contribution values to\n            // limit the voting power of each card (e.g.  a party desiring a \"1\n            // card = 1 vote\"-like governance system where each card has equal\n            // voting power).\n            if (contribution > maxContribution_) {\n                revert AboveMaximumContributionsError(contribution, maxContribution_);\n            }\n        }\n\n        // Burn the crowdfund NFT.\n        _burn(contributor);\n\n        delete pendingVotingPower[contributor];\n\n        if (tokenId == 0) {\n            // Mint contributor a new party card.\n            tokenId = party.mint(contributor, votingPower, delegationsByContributor[contributor]);\n        } else if (disableContributingForExistingCard) {\n            revert ContributingForExistingCardDisabledError();\n        } else if (party.ownerOf(tokenId) == contributor) {\n            // Increase voting power of contributor's existing party card.\n            party.addVotingPower(tokenId, votingPower);\n        } else {\n            revert NotOwnerError();\n        }\n\n        emit Claimed(contributor, tokenId, votingPower);\n    }\n\n    /// @notice `claim()` in batch form.\n    ///         May not revert if any individual refund fails.\n    /// @param tokenIds The IDs of the party cards to add voting power to. If 0, a\n    ///                 new card will be minted.\n    /// @param contributors The contributors to claim for.\n    /// @param revertOnFailure If true, reverts if any individual claim fails.\n    function batchClaim(\n        uint256[] calldata tokenIds,\n        address[] calldata contributors,\n        bool revertOnFailure\n    ) external {\n        for (uint256 i; i < contributors.length; ++i) {\n            (bool s, bytes memory r) = address(this).call(\n                // Using `abi.encodeWithSignature()` instead of `abi.encodeCall()`\n                // because `abi.encodeCall()` doesn't support overloaded functions.\n                abi.encodeWithSignature(\"claim(uint256,address)\", tokenIds[i], contributors[i])\n            );\n            if (revertOnFailure && !s) {\n                r.rawRevert();\n            }\n        }\n    }\n\n    /// @notice Claim multiple party cards for a contributor if the crowdfund won. Can be called\n    ///         to claim for self or on another's behalf.\n    /// @param votingPowerByCard The voting power for each card claimed. Must add up to the\n    ///                          total pending voting power for the contributor.\n    /// @param contributor The contributor to claim for.\n    function claimMultiple(uint96[] memory votingPowerByCard, address contributor) external {\n        // Check crowdfund lifecycle.\n        {\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\n            if (lc != CrowdfundLifecycle.Finalized) {\n                revert WrongLifecycleError(lc);\n            }\n        }\n\n        uint256 votingPower = pendingVotingPower[contributor];\n\n        if (votingPower == 0) return;\n\n        // Burn the crowdfund NFT.\n        _burn(contributor);\n\n        delete pendingVotingPower[contributor];\n\n        address delegate = delegationsByContributor[contributor];\n        uint96 minContribution_ = minContribution;\n        uint96 maxContribution_ = maxContribution;\n        for (uint256 i; i < votingPowerByCard.length; ++i) {\n            if (votingPowerByCard[i] == 0) continue;\n\n            // Check that the contribution equivalent of voting power is within\n            // contribution range. This is done so parties may use the minimum\n            // and maximum contribution values to limit the voting power of each\n            // card (e.g. a party desiring a \"1 card = 1 vote\"-like governance\n            // system where each card has equal voting power).\n            uint96 contribution = (votingPowerByCard[i] * 1e4) / exchangeRateBps;\n            if (contribution < minContribution_) {\n                revert BelowMinimumContributionsError(contribution, minContribution_);\n            }\n\n            if (contribution > maxContribution_) {\n                revert AboveMaximumContributionsError(contribution, maxContribution_);\n            }\n\n            votingPower -= votingPowerByCard[i];\n\n            // Mint contributor a new party card.\n            uint256 tokenId = party.mint(contributor, votingPowerByCard[i], delegate);\n\n            emit Claimed(contributor, tokenId, votingPowerByCard[i]);\n        }\n\n        // Requires that all voting power is claimed because the contributor is\n        // expected to have burned their crowdfund NFT.\n        if (votingPower != 0) revert RemainingVotingPowerAfterClaimError(votingPower);\n    }\n\n    /// @notice `claimMultiple()` in batch form.\n    ///         May not revert if any individual refund fails.\n    /// @param votingPowerByCards The voting power for each card claimed for each\n    ///                           contributor. Must add up to the total pending\n    ///                           voting power for the contributor.\n    /// @param contributors The contributors to claim for.\n    /// @param revertOnFailure If true, reverts if any individual claim fails.\n    function batchClaimMultiple(\n        uint96[][] calldata votingPowerByCards,\n        address[] calldata contributors,\n        bool revertOnFailure\n    ) external {\n        for (uint256 i; i < contributors.length; ++i) {\n            (bool s, bytes memory r) = address(this).call(\n                abi.encodeCall(this.claimMultiple, (votingPowerByCards[i], contributors[i]))\n            );\n            if (revertOnFailure && !s) {\n                r.rawRevert();\n            }\n        }\n    }\n\n    /// @notice Refund the owner of a party card and burn it. Only available if\n    ///         the crowdfund lost. Can be called to refund for self or on\n    ///         another's behalf.\n    /// @param contributor The contributor to refund.\n    function refund(address payable contributor) external returns (uint96 amount) {\n        // Check crowdfund lifecycle.\n        {\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\n            if (lc != CrowdfundLifecycle.Lost) {\n                revert WrongLifecycleError(lc);\n            }\n        }\n\n        // Get amount to refund.\n        uint96 votingPower = pendingVotingPower[contributor];\n        amount = _calculateRefundAmount(votingPower);\n\n        if (amount == 0) return 0;\n\n        // Burn the crowdfund NFT.\n        _burn(contributor);\n\n        delete pendingVotingPower[contributor];\n\n        // Refund contributor.\n        contributor.transferEth(amount);\n\n        emit Refunded(contributor, amount);\n    }\n\n    /// @notice `refund()` in batch form.\n    ///         May not revert if any individual refund fails.\n    /// @param contributors The contributors to refund.\n    /// @param revertOnFailure If true, revert if any refund fails.\n    /// @return amounts The amounts of ETH refunded for each refund.\n    function batchRefund(\n        address payable[] calldata contributors,\n        bool revertOnFailure\n    ) external returns (uint96[] memory amounts) {\n        uint256 numRefunds = contributors.length;\n        amounts = new uint96[](numRefunds);\n\n        for (uint256 i; i < numRefunds; ++i) {\n            (bool s, bytes memory r) = address(this).call(\n                abi.encodeCall(this.refund, (contributors[i]))\n            );\n\n            if (!s) {\n                if (revertOnFailure) {\n                    r.rawRevert();\n                }\n            } else {\n                amounts[i] = abi.decode(r, (uint96));\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/crowdfund/ReraiseETHCrowdfund.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./ETHCrowdfundBase.sol\";\nimport \"../crowdfund/CrowdfundNFT.sol\";\nimport \"../utils/LibAddress.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/LibSafeCast.sol\";\nimport \"../tokens/ERC721Receiver.sol\";\nimport \"../party/Party.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../gatekeepers/IGateKeeper.sol\";\n\n/// @notice A crowdfund for raising additional funds for an existing parties.\ncontract ReraiseETHCrowdfund is ETHCrowdfundBase, CrowdfundNFT {\n    using LibRawResult for bytes;\n    using LibSafeCast for uint256;\n    using LibAddress for address payable;\n\n    struct BatchContributeArgs {\n        // The address to which voting power will be delegated for all contributions.\n        address delegate;\n        // The contribution amounts in wei. The length of this array must be\n        // equal to the length of `tokenIds`.\n        uint96[] values;\n        // The data required to be validated by the `gatekeeper`, if set. If no\n        // `gatekeeper` is set, this can be empty.\n        bytes[] gateDatas;\n    }\n\n    struct BatchContributeForArgs {\n        // Addresses of to credit the contributions under. Each contribution\n        // amount in `values` corresponds to a recipient in this array.\n        address payable[] recipients;\n        // The delegate to set for each recipient if they have not delegated\n        // before.\n        address[] initialDelegates;\n        // The contribution amounts in wei. The length of this array must be\n        // equal to the length of `recipients`.\n        uint96[] values;\n        // The data required to be validated by the `gatekeeper`, if set. If no\n        // `gatekeeper` is set, this can be empty.\n        bytes[] gateDatas;\n        // Whether to revert if any individual contribution fails or continue.\n        bool revertOnFailure;\n    }\n\n    event Claimed(address indexed contributor, uint256 indexed tokenId, uint256 votingPower);\n    event Refunded(address indexed contributor, uint256 amount);\n\n    error RemainingVotingPowerAfterClaimError(uint256 remainingVotingPower);\n\n    // The `Globals` contract storing global configuration values. This contract\n    // is immutable and it’s address will never change.\n    IGlobals private immutable _GLOBALS;\n\n    /// @notice The amount of voting power that will be received by a\n    ///         contributor after the crowdfund is won.\n    mapping(address => uint96) public pendingVotingPower;\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) CrowdfundNFT(globals) {\n        _GLOBALS = globals;\n    }\n\n    /// @notice Initializer to be delegatecalled by `Proxy` constructor. Will\n    ///         revert if called outside the constructor.\n    /// @param opts The options to initialize the crowdfund with.\n    function initialize(ETHCrowdfundOptions memory opts) external payable onlyConstructor {\n        // Initialize the crowdfund.\n        ETHCrowdfundBase._initialize(opts);\n\n        // Initialize the crowdfund NFT.\n        _initialize(\n            opts.party.name(),\n            opts.party.symbol(),\n            0 // Ignored. Will use customization preset from party.\n        );\n\n        // If the deployer passed in some ETH during deployment, credit them\n        // for the initial contribution.\n        uint96 initialContribution = msg.value.safeCastUint256ToUint96();\n        if (initialContribution > 0) {\n            // If this contract has ETH, either passed in during deployment or\n            // pre-existing, credit it to the `initialContributor`.\n            _contribute(opts.initialContributor, opts.initialDelegate, initialContribution, \"\");\n        }\n\n        // Set up gatekeeper after initial contribution (initial always gets in).\n        gateKeeper = opts.gateKeeper;\n        gateKeeperId = opts.gateKeeperId;\n    }\n\n    // Initialize name and symbol for crowdfund NFT.\n    function _initialize(string memory name_, string memory symbol_, uint256) internal override {\n        name = name_;\n        symbol = symbol_;\n\n        RendererStorage rendererStorage = RendererStorage(\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_RENDERER_STORAGE)\n        );\n\n        // Use the same customization preset as the party.\n        uint256 customizationPresetId = rendererStorage.getPresetFor(address(party));\n        if (customizationPresetId != 0) {\n            rendererStorage.useCustomizationPreset(customizationPresetId);\n        }\n    }\n\n    /// @notice Contribute ETH to this crowdfund on behalf of a contributor.\n    /// @param delegate The address to which voting power will be delegated to\n    ///                 during the governance phase.\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility.\n    /// @return votingPower The voting power the contributor receives for their\n    ///                     contribution.\n    function contribute(\n        address delegate,\n        bytes memory gateData\n    ) public payable onlyDelegateCall returns (uint96 votingPower) {\n        return\n            _contribute(\n                payable(msg.sender),\n                delegate,\n                msg.value.safeCastUint256ToUint96(),\n                gateData\n            );\n    }\n\n    /// @notice `contribute()` in batch form.\n    ///         May not revert if any individual contribution fails.\n    /// @param args The arguments to pass to each `contribute()` call.\n    /// @return votingPowers The voting power received for each contribution.\n    function batchContribute(\n        BatchContributeArgs calldata args\n    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {\n        uint256 numContributions = args.values.length;\n        votingPowers = new uint96[](numContributions);\n\n        uint256 ethAvailable = msg.value;\n        for (uint256 i; i < numContributions; ++i) {\n            ethAvailable -= args.values[i];\n\n            votingPowers[i] = _contribute(\n                payable(msg.sender),\n                args.delegate,\n                args.values[i],\n                args.gateDatas[i]\n            );\n        }\n\n        // Refund any unused ETH.\n        if (ethAvailable > 0) payable(msg.sender).transfer(ethAvailable);\n    }\n\n    /// @notice Contribute to this crowdfund on behalf of another address.\n    /// @param recipient The address to record the contribution under\n    /// @param initialDelegate The address to delegate to for the governance\n    ///                        phase if recipient hasn't delegated\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility\n    /// @return votingPower The voting power received for the contribution\n    function contributeFor(\n        address payable recipient,\n        address initialDelegate,\n        bytes memory gateData\n    ) external payable onlyDelegateCall returns (uint96 votingPower) {\n        return\n            _contribute(recipient, initialDelegate, msg.value.safeCastUint256ToUint96(), gateData);\n    }\n\n    /// @notice `contributeFor()` in batch form.\n    ///         May not revert if any individual contribution fails.\n    /// @param args The arguments for the batched `contributeFor()` calls.\n    /// @return votingPowers The voting power received for each contribution.\n    function batchContributeFor(\n        BatchContributeForArgs memory args\n    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {\n        uint256 numContributions = args.recipients.length;\n        votingPowers = new uint96[](numContributions);\n\n        uint256 ethAvailable = msg.value;\n        for (uint256 i; i < numContributions; ++i) {\n            ethAvailable -= args.values[i];\n\n            (bool s, bytes memory r) = address(this).call{ value: args.values[i] }(\n                abi.encodeCall(\n                    this.contributeFor,\n                    (args.recipients[i], args.initialDelegates[i], args.gateDatas[i])\n                )\n            );\n\n            if (!s) {\n                if (args.revertOnFailure) {\n                    r.rawRevert();\n                }\n            } else {\n                votingPowers[i] = abi.decode(r, (uint96));\n            }\n        }\n\n        // Refund any unused ETH.\n        if (ethAvailable > 0) payable(msg.sender).transfer(ethAvailable);\n    }\n\n    function _contribute(\n        address payable contributor,\n        address delegate,\n        uint96 amount,\n        bytes memory gateData\n    ) private returns (uint96 votingPower) {\n        // Require a non-null delegate.\n        if (delegate == address(0)) {\n            revert InvalidDelegateError();\n        }\n\n        // Must not be blocked by gatekeeper.\n        IGateKeeper _gateKeeper = gateKeeper;\n        if (_gateKeeper != IGateKeeper(address(0))) {\n            if (!_gateKeeper.isAllowed(contributor, gateKeeperId, gateData)) {\n                revert NotAllowedByGateKeeperError(\n                    contributor,\n                    _gateKeeper,\n                    gateKeeperId,\n                    gateData\n                );\n            }\n        }\n\n        votingPower = _processContribution(contributor, delegate, amount);\n\n        // OK to contribute with zero just to update delegate.\n        if (amount == 0) return 0;\n\n        uint256 previousVotingPower = pendingVotingPower[contributor];\n\n        pendingVotingPower[contributor] += votingPower;\n\n        // Mint a crowdfund NFT if this is their first contribution.\n        if (previousVotingPower == 0) _mint(contributor);\n    }\n\n    /// @notice Claim a party card for a contributor if the crowdfund won. Can be called\n    ///         to claim for self or on another's behalf.\n    /// @param contributor The contributor to claim for.\n    function claim(address contributor) external {\n        claim(\n            0, // Mint a new party card.\n            contributor\n        );\n    }\n\n    /// @notice Claim a party card for a contributor if the crowdfund won. Can be called\n    ///         to claim for self or on another's behalf.\n    /// @param tokenId The ID of the party card to add voting power to. If 0, a\n    ///                new card will be minted.\n    /// @param contributor The contributor to claim for.\n    function claim(uint256 tokenId, address contributor) public {\n        // Check crowdfund lifecycle.\n        {\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\n            if (lc != CrowdfundLifecycle.Finalized) {\n                revert WrongLifecycleError(lc);\n            }\n        }\n\n        uint96 votingPower = pendingVotingPower[contributor];\n\n        if (votingPower == 0) return;\n\n        {\n            uint96 contribution = (votingPower * 1e4) / exchangeRateBps;\n            uint96 maxContribution_ = maxContribution;\n            // Check that the contribution equivalent of total pending voting\n            // power is not above the max contribution range. This can happen\n            // for contributors who contributed multiple times In this case, the\n            // `claimMultiple` function should be called instead. This is done\n            // so parties may use the minimum and maximum contribution values to\n            // limit the voting power of each card (e.g.  a party desiring a \"1\n            // card = 1 vote\"-like governance system where each card has equal\n            // voting power).\n            if (contribution > maxContribution_) {\n                revert AboveMaximumContributionsError(contribution, maxContribution_);\n            }\n        }\n\n        // Burn the crowdfund NFT.\n        _burn(contributor);\n\n        delete pendingVotingPower[contributor];\n\n        if (tokenId == 0) {\n            // Mint contributor a new party card.\n            tokenId = party.mint(contributor, votingPower, delegationsByContributor[contributor]);\n        } else if (disableContributingForExistingCard) {\n            revert ContributingForExistingCardDisabledError();\n        } else if (party.ownerOf(tokenId) == contributor) {\n            // Increase voting power of contributor's existing party card.\n            party.addVotingPower(tokenId, votingPower);\n        } else {\n            revert NotOwnerError();\n        }\n\n        emit Claimed(contributor, tokenId, votingPower);\n    }\n\n    /// @notice `claim()` in batch form.\n    ///         May not revert if any individual refund fails.\n    /// @param tokenIds The IDs of the party cards to add voting power to. If 0, a\n    ///                 new card will be minted.\n    /// @param contributors The contributors to claim for.\n    /// @param revertOnFailure If true, reverts if any individual claim fails.\n    function batchClaim(\n        uint256[] calldata tokenIds,\n        address[] calldata contributors,\n        bool revertOnFailure\n    ) external {\n        for (uint256 i; i < contributors.length; ++i) {\n            (bool s, bytes memory r) = address(this).call(\n                // Using `abi.encodeWithSignature()` instead of `abi.encodeCall()`\n                // because `abi.encodeCall()` doesn't support overloaded functions.\n                abi.encodeWithSignature(\"claim(uint256,address)\", tokenIds[i], contributors[i])\n            );\n            if (revertOnFailure && !s) {\n                r.rawRevert();\n            }\n        }\n    }\n\n    /// @notice Claim multiple party cards for a contributor if the crowdfund won. Can be called\n    ///         to claim for self or on another's behalf.\n    /// @param votingPowerByCard The voting power for each card claimed. Must add up to the\n    ///                          total pending voting power for the contributor.\n    /// @param contributor The contributor to claim for.\n    function claimMultiple(uint96[] memory votingPowerByCard, address contributor) external {\n        // Check crowdfund lifecycle.\n        {\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\n            if (lc != CrowdfundLifecycle.Finalized) {\n                revert WrongLifecycleError(lc);\n            }\n        }\n\n        uint256 votingPower = pendingVotingPower[contributor];\n\n        if (votingPower == 0) return;\n\n        // Burn the crowdfund NFT.\n        _burn(contributor);"
    }
  ]
}