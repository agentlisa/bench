{
  "Title": "[M-04] Yield distribution after large payout seems unfair",
  "Content": "_Submitted by gpersoon_\n\nWhen a large payout occurs, it will lower `unallocatedSherX`. This could mean some parties might not be able to get their Yield.\n\nThe first couple of users (for which harvest is called or which transfer tokens) will be able to get their full Yield, until the moment `unallocatedSherX` is depleted. The next users don't get any yield at all. This doesn't seem fair.\n\n```solidity\n// https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/SherX.sol#L309\nfunction doYield(ILock token,address from, address to, uint256 amount) private {\n...\nps.unallocatedSherX = ps.unallocatedSherX.sub(withdrawable_amount);\n\n//https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Payout.sol#L108\n function payout( address _payout, IERC20[] memory _tokens, uint256[] memory _firstMoneyOut, uint256[] memory _amounts, uint256[] memory _unallocatedSherX,  address _exclude ) external override onlyGovPayout {\n    // all pools (including SherX pool) can be deducted fmo and balance\n    // deducting balance will reduce the users underlying value of stake token\n    // for every pool, _unallocatedSherX can be deducted, this will decrease outstanding SherX rewards\n    // for users that did not claim them (e.g materialized them and included in SherX pool)\n....\n    // Subtract from unallocated, as the tokens are now allocated to this payout call\n        ps.unallocatedSherX = ps.unallocatedSherX.sub(unallocatedSherX);\n```\n\nRecommend that If `unallocatedSherX` is insufficient to provide for all the yields, only give the yields partly (so that each user gets their fair share).\n\n**[Evert0x (Sherlock) disputed](https://github.com/code-423n4/2021-07-sherlock-findings/issues/50#issuecomment-889996060):**\n > Not only `unallocatedSherX` is subtracted but also `sWeight`, which is used to calculate the reward. I wrote some extra tests and in my experience the remaining SherX (in the unallocatedSherX variable) is splitted in a fair way.\n\n**[Evert0x (Sherlock) confirmed](https://github.com/code-423n4/2021-07-sherlock-findings/issues/50#issuecomment-891724441):**\n > Together with gpersoon I discussed both issue #49 and #50 and based on both findings we found a med-risk issue. In case `payout()` is called with `_unallocatedSherX > 0` and a user called `harvest()` before the payout call. It blocks the user from calling `harvest()` again. + blocks the lock token transfer.\n>\n> Mitigations step is to stop calling `payout()` with `_unallocatedSherX > 0`\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2021-07-sherlock",
  "Code": [
    {
      "filename": "contracts/facets/SherX.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.7.4;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\nimport '../interfaces/ISherX.sol';\n\nimport '../storage/SherXERC20Storage.sol';\n\nimport '../libraries/LibPool.sol';\nimport '../libraries/LibSherX.sol';\nimport '../libraries/LibSherXERC20.sol';\n\ncontract SherX is ISherX {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n  //\n  // Modifiers\n  //\n\n  modifier onlyGovMain() {\n    require(msg.sender == GovStorage.gs().govMain, 'NOT_GOV_MAIN');\n    _;\n  }\n\n  //\n  // View methods\n  //\n\n  function getTotalUsdPerBlock() external view override returns (uint256) {\n    return SherXStorage.sx().totalUsdPerBlock;\n  }\n\n  function getTotalUsdPoolStored() external view override returns (uint256) {\n    return SherXStorage.sx().totalUsdPool;\n  }\n\n  function getTotalUsdPool() external view override returns (uint256) {\n    SherXStorage.Base storage sx = SherXStorage.sx();\n    return sx.totalUsdPool.add(block.number.sub(sx.totalUsdLastSettled).mul(sx.totalUsdPerBlock));\n  }\n\n  function getTotalUsdLastSettled() external view override returns (uint256) {\n    return SherXStorage.sx().totalUsdLastSettled;\n  }\n\n  function getStoredUsd(IERC20 _token) external view override returns (uint256) {\n    return SherXStorage.sx().tokenUSD[_token];\n  }\n\n  function getUnmintedSherX(IERC20 _token) internal view returns (uint256) {\n    PoolStorage.Base storage ps = PoolStorage.ps(_token);\n    SherXStorage.Base storage sx = SherXStorage.sx();\n\n    return\n      block.number.sub(ps.sherXLastAccrued).mul(sx.sherXPerBlock).mul(ps.sherXWeight).div(\n        uint16(-1)\n      );\n  }\n\n  function getTotalSherXUnminted() external view override returns (uint256) {\n    SherXStorage.Base storage sx = SherXStorage.sx();\n    GovStorage.Base storage gs = GovStorage.gs();\n\n    uint256 total =\n      block\n        .number\n        .sub(gs.watsonsSherxLastAccrued)\n        .mul(sx.sherXPerBlock)\n        .mul(gs.watsonsSherxWeight)\n        .div(uint16(-1));\n    for (uint256 i; i < gs.tokensStaker.length; i++) {\n      total = total.add(getUnmintedSherX(gs.tokensStaker[i]));\n    }\n    return total;\n  }\n\n  function getTotalSherX() external view override returns (uint256) {\n    return LibSherX.getTotalSherX();\n  }\n\n  function getSherXPerBlock() external view override returns (uint256) {\n    return SherXStorage.sx().sherXPerBlock;\n  }\n\n  function getSherXBalance() external view override returns (uint256) {\n    return getSherXBalance(msg.sender);\n  }\n\n  function getSherXBalance(address _user) public view override returns (uint256) {\n    SherXERC20Storage.Base storage sx20 = SherXERC20Storage.sx20();\n    uint256 balance = sx20.balances[_user];\n    GovStorage.Base storage gs = GovStorage.gs();\n    for (uint256 i; i < gs.tokensStaker.length; i++) {\n      balance = balance.add(LibPool.getUnallocatedSherXFor(_user, gs.tokensStaker[i]));\n    }\n    return balance;\n  }\n\n  function getInternalTotalSupply() external view override returns (uint256) {\n    return SherXStorage.sx().internalTotalSupply;\n  }\n\n  function getInternalTotalSupplySettled() external view override returns (uint256) {\n    return SherXStorage.sx().internalTotalSupplySettled;\n  }\n\n  function calcUnderlying()\n    external\n    view\n    override\n    returns (IERC20[] memory tokens, uint256[] memory amounts)\n  {\n    return calcUnderlying(msg.sender);\n  }\n\n  function calcUnderlying(address _user)\n    public\n    view\n    override\n    returns (IERC20[] memory tokens, uint256[] memory amounts)\n  {\n    return LibSherX.calcUnderlying(getSherXBalance(_user));\n  }\n\n  function calcUnderlying(uint256 _amount)\n    external\n    view\n    override\n    returns (IERC20[] memory tokens, uint256[] memory amounts)\n  {\n    return LibSherX.calcUnderlying(_amount);\n  }\n\n  function calcUnderlyingInStoredUSD() external view override returns (uint256) {\n    SherXERC20Storage.Base storage sx20 = SherXERC20Storage.sx20();\n    return calcUnderlyingInStoredUSD(sx20.balances[msg.sender]);\n  }\n\n  function calcUnderlyingInStoredUSD(uint256 _amount) public view override returns (uint256 usd) {\n    SherXStorage.Base storage sx = SherXStorage.sx();\n    GovStorage.Base storage gs = GovStorage.gs();\n\n    uint256 total = LibSherX.getTotalSherX();\n    if (total == 0) {\n      return 0;\n    }\n    for (uint256 i; i < gs.tokensSherX.length; i++) {\n      IERC20 token = gs.tokensSherX[i];\n\n      usd = usd.add(\n        PoolStorage\n          .ps(token)\n          .sherXUnderlying\n          .add(LibPool.getTotalAccruedDebt(token))\n          .mul(_amount)\n          .mul(sx.tokenUSD[token])\n          .div(10**18)\n          .div(total)\n      );\n    }\n  }\n\n  //\n  // State changing methods\n  //\n\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) external override {\n    doYield(ILock(msg.sender), from, to, amount);\n  }\n\n  function setInitialWeight() external override onlyGovMain {\n    GovStorage.Base storage gs = GovStorage.gs();\n    require(gs.watsonsAddress != address(0), 'WATS_UNSET');\n    require(gs.watsonsSherxWeight == 0, 'ALREADY_INIT');\n    for (uint256 i; i < gs.tokensStaker.length; i++) {\n      PoolStorage.Base storage ps = PoolStorage.ps(gs.tokensStaker[i]);\n      require(ps.sherXWeight == 0, 'ALREADY_INIT_2');\n    }\n\n    gs.watsonsSherxWeight = uint16(-1);\n  }\n\n  function setWeights(\n    IERC20[] memory _tokens,\n    uint256[] memory _weights,\n    uint256 _watsons\n  ) external override onlyGovMain {\n    require(_tokens.length == _weights.length, 'LENGTH');\n    // NOTE: can potentially be made more gas efficient\n    // Do not loop over all staker tokens\n    // But just over the tokens in the _tokens array\n    LibSherX.accrueSherX();\n\n    GovStorage.Base storage gs = GovStorage.gs();\n\n    uint256 weightAdd;\n    uint256 weightSub;\n\n    for (uint256 i; i < _tokens.length; i++) {\n      PoolStorage.Base storage ps = PoolStorage.ps(_tokens[i]);\n      // Disabled tokens can not have ps.sherXWeight > 0\n      require(ps.stakes, 'DISABLED');\n\n      weightAdd = weightAdd.add(_weights[i]);\n      weightSub = weightSub.add(ps.sherXWeight);\n      ps.sherXWeight = uint16(_weights[i]);\n    }\n    if (_watsons != uint256(-1)) {\n      weightAdd = weightAdd.add(_watsons);\n      weightSub = weightSub.add(gs.watsonsSherxWeight);\n\n      gs.watsonsSherxWeight = uint16(_watsons);\n    }\n\n    require(weightAdd == weightSub, 'SUM');\n  }\n\n  function harvest() external override {\n    harvestFor(msg.sender);\n  }\n\n  function harvest(ILock _token) external override {\n    harvestFor(msg.sender, _token);\n  }\n\n  function harvest(ILock[] calldata _tokens) external override {\n    for (uint256 i; i < _tokens.length; i++) {\n      harvestFor(msg.sender, _tokens[i]);\n    }\n  }\n\n  function harvestFor(address _user) public override {\n    GovStorage.Base storage gs = GovStorage.gs();\n    for (uint256 i; i < gs.tokensStaker.length; i++) {\n      PoolStorage.Base storage ps = PoolStorage.ps(gs.tokensStaker[i]);\n      harvestFor(_user, ps.lockToken);\n    }\n  }\n\n  function harvestFor(address _user, ILock _token) public override {\n    // could potentially call harvest function for token that are not in the pool\n    // if balance > 0, tx will revert\n    uint256 stakeBalance = _token.balanceOf(_user);\n    if (stakeBalance > 0) {\n      doYield(_token, _user, _user, 0);\n    }\n    emit Harvest(_user, _token);\n  }\n\n  function harvestFor(address _user, ILock[] calldata _tokens) external override {\n    for (uint256 i; i < _tokens.length; i++) {\n      harvestFor(_user, _tokens[i]);\n    }\n  }\n\n  function redeem(uint256 _amount, address _receiver) external override {\n    require(_amount > 0, 'AMOUNT');\n    require(_receiver != address(0), 'RECEIVER');\n\n    SherXStorage.Base storage sx = SherXStorage.sx();\n    LibSherX.accrueUSDPool();\n\n    // Note: LibSherX.accrueSherX() is removed as the calcUnderlying already takes it into consideration (without changing state)\n    // Calculate the current `amounts` of underlying `tokens` for `_amount` of SherX\n    (IERC20[] memory tokens, uint256[] memory amounts) = LibSherX.calcUnderlying(_amount);\n    LibSherXERC20.burn(msg.sender, _amount);\n\n    uint256 subUsdPool = 0;\n    for (uint256 i; i < tokens.length; i++) {\n      PoolStorage.Base storage ps = PoolStorage.ps(tokens[i]);\n\n      // Expensive operation, only execute to prevent tx reverts\n      if (amounts[i] > ps.sherXUnderlying) {\n        LibPool.payOffDebtAll(tokens[i]);\n      }\n      // Remove the token as underlying of SherX\n      ps.sherXUnderlying = ps.sherXUnderlying.sub(amounts[i]);\n      // As the tokens are transferred, remove from the current usdPool\n      // By summing the total that needs to be deducted in the `subUsdPool` value\n      subUsdPool = subUsdPool.add(amounts[i].mul(sx.tokenUSD[tokens[i]]).div(10**18));\n\n      tokens[i].safeTransfer(_receiver, amounts[i]);\n    }\n    sx.totalUsdPool = sx.totalUsdPool.sub(subUsdPool);\n    LibSherX.settleInternalSupply(_amount);\n  }\n\n  function accrueSherX() external override {\n    LibSherX.accrueSherX();\n  }\n\n  function accrueSherX(IERC20 _token) external override {\n    LibSherX.accrueSherX(_token);\n  }\n\n  function accrueSherXWatsons() external override {\n    LibSherX.accrueSherXWatsons();\n  }\n\n  function doYield(\n    ILock token,\n    address from,\n    address to,\n    uint256 amount\n  ) private {\n    IERC20 underlying = token.underlying();\n    PoolStorage.Base storage ps = PoolStorage.ps(underlying);\n    require(ps.lockToken == token, 'SENDER');\n\n    LibSherX.accrueSherX(underlying);\n    uint256 userAmount = ps.lockToken.balanceOf(from);\n    uint256 totalAmount = ps.lockToken.totalSupply();\n\n    uint256 ineglible_yield_amount;\n    if (totalAmount > 0) {\n      ineglible_yield_amount = ps.sWeight.mul(amount).div(totalAmount);\n    } else {\n      ineglible_yield_amount = amount;\n    }\n\n    if (from != address(0)) {\n      uint256 raw_amount = ps.sWeight.mul(userAmount).div(totalAmount);\n      uint256 withdrawable_amount = raw_amount.sub(ps.sWithdrawn[from]);\n      if (withdrawable_amount > 0) {\n        // store the data in a single calc\n        ps.sWithdrawn[from] = raw_amount.sub(ineglible_yield_amount);\n        // The `withdrawable_amount` is allocated to `from`, subtract from `unallocatedSherX`\n        ps.unallocatedSherX = ps.unallocatedSherX.sub(withdrawable_amount);\n        PoolStorage.Base storage psSherX = PoolStorage.ps(IERC20(address(this)));\n        if (from == address(this)) {\n          // add SherX harvested by the pool itself to first money out pool.\n          psSherX.stakeBalance = psSherX.stakeBalance.add(withdrawable_amount);\n          psSherX.firstMoneyOut = psSherX.firstMoneyOut.add(withdrawable_amount);\n        } else {\n          LibPool.stake(psSherX, withdrawable_amount, from);\n        }\n      } else {\n        ps.sWithdrawn[from] = ps.sWithdrawn[from].sub(ineglible_yield_amount);\n      }\n    } else {\n      ps.sWeight = ps.sWeight.add(ineglible_yield_amount);\n    }\n\n    if (to != address(0)) {\n      ps.sWithdrawn[to] = ps.sWithdrawn[to].add(ineglible_yield_amount);\n    } else {\n      ps.sWeight = ps.sWeight.sub(ineglible_yield_amount);\n    }\n  }\n}"
    },
    {
      "filename": "contracts/facets/Payout.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.7.4;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\nimport 'diamond-2/contracts/libraries/LibDiamond.sol';\n\nimport '../interfaces/IPayout.sol';\n\nimport '../storage/PayoutStorage.sol';\n\nimport '../libraries/LibSherX.sol';\nimport '../libraries/LibSherXERC20.sol';\n\ncontract Payout is IPayout {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n  //\n  // Modifiers\n  //\n\n  modifier onlyGovMain() {\n    require(msg.sender == GovStorage.gs().govMain, 'NOT_GOV_MAIN');\n    _;\n  }\n\n  modifier onlyGovPayout() {\n    require(msg.sender == PayoutStorage.ps().govPayout, 'NOT_GOV_PAY');\n    _;\n  }\n\n  //\n  // View methods\n  //\n\n  function getGovPayout() external view override returns (address) {\n    return PayoutStorage.ps().govPayout;\n  }\n\n  //\n  // State changing methods\n  //\n\n  function setInitialGovPayout(address _govPayout) external override {\n    PayoutStorage.Base storage ps = PayoutStorage.ps();\n\n    require(msg.sender == LibDiamond.contractOwner(), 'NOT_DEV');\n    require(_govPayout != address(0), 'ZERO_GOV');\n    require(ps.govPayout == address(0), 'ALREADY_SET');\n\n    ps.govPayout = _govPayout;\n  }\n\n  function transferGovPayout(address _govPayout) external override onlyGovMain {\n    PayoutStorage.Base storage ps = PayoutStorage.ps();\n\n    require(_govPayout != address(0), 'ZERO_GOV');\n    require(ps.govPayout != _govPayout, 'SAME_GOV');\n    ps.govPayout = _govPayout;\n  }\n\n  /// @notice Transfer certain amount of underlying tokens of unallocated SherX to `_payout`\n  /// @param _payout Account to receive underlying tokens\n  /// @param _exclude Token to exclude from payout\n  /// @param curTotalUsdPool The current `sx.totalUsdPool`\n  /// @param totalSherX The amount of SherX to use for payout\n  /// @return sherUsd Total amount of USD of the underlying tokens that are being transferred\n  function _doSherX(\n    address _payout,\n    address _exclude,\n    uint256 curTotalUsdPool,\n    uint256 totalSherX\n  ) private returns (uint256 sherUsd) {\n    SherXStorage.Base storage sx = SherXStorage.sx();\n    // Calculate the current `amounts` of underlying `tokens` for `totalSherX`\n    (IERC20[] memory tokens, uint256[] memory amounts) = LibSherX.calcUnderlying(totalSherX);\n    uint256 subUsdPool;\n\n    for (uint256 i; i < tokens.length; i++) {\n      PoolStorage.Base storage ps = PoolStorage.ps(tokens[i]);\n\n      // Expensive operation, only execute to prevent tx reverts\n      if (amounts[i] > ps.sherXUnderlying) {\n        LibPool.payOffDebtAll(tokens[i]);\n      }\n\n      if (address(tokens[i]) == _exclude) {\n        // Return USD value of token that is excluded from payout\n        sherUsd = amounts[i].mul(sx.tokenUSD[tokens[i]]);\n      } else {\n        // Remove the token as underlying of SherX\n        ps.sherXUnderlying = ps.sherXUnderlying.sub(amounts[i]);\n        // As the tokens are transferred, remove from the current usdPool\n        // By summing the total that needs to be deducted in the `subUsdPool` value\n        subUsdPool = subUsdPool.add(amounts[i].mul(sx.tokenUSD[tokens[i]]).div(10**18));\n        // NOTE: transfer can potentially be optimized, as payout call itself also does transfers\n        tokens[i].safeTransfer(_payout, amounts[i]);\n      }\n    }\n    // Subtract the total amount that needs to be subtracted from the `sx.totalUsdPool`\n    sx.totalUsdPool = curTotalUsdPool.sub(subUsdPool);\n  }\n\n  function payout(\n    address _payout,\n    IERC20[] memory _tokens,\n    uint256[] memory _firstMoneyOut,\n    uint256[] memory _amounts,\n    uint256[] memory _unallocatedSherX,\n    address _exclude\n  ) external override onlyGovPayout {\n    // all pools (including SherX pool) can be deducted fmo and balance\n    // deducting balance will reduce the users underlying value of stake token\n    // for every pool, _unallocatedSherX can be deducted, this will decrease outstanding SherX rewards\n    // for users that did not claim them (e.g materialized them and included in SherX pool)\n\n    require(address(_payout) != address(0), 'ZERO_PAY');\n    require(address(_payout) != address(this), 'THIS_PAY');\n    require(_tokens.length == _firstMoneyOut.length, 'LENGTH_1');\n    require(_tokens.length == _amounts.length, 'LENGTH_2');\n    require(_tokens.length == _unallocatedSherX.length, 'LENGTH_3');\n\n    LibSherX.accrueSherX();\n\n    uint256 totalUnallocatedSherX;\n    uint256 totalSherX;\n\n    for (uint256 i; i < _tokens.length; i++) {\n      IERC20 token = _tokens[i];\n      uint256 firstMoneyOut = _firstMoneyOut[i];\n      uint256 amounts = _amounts[i];\n      uint256 unallocatedSherX = _unallocatedSherX[i];\n\n      PoolStorage.Base storage ps = PoolStorage.ps(token);\n      require(ps.govPool != address(0), 'INIT');\n      require(ps.unallocatedSherX >= unallocatedSherX, 'ERR_UNALLOC_FEE');\n\n      if (unallocatedSherX > 0) {\n        // Subtract from `sWeight` as the tokens are not claimable anymore\n        ps.sWeight = ps.sWeight.sub(unallocatedSherX);\n        // Subtract from unallocated, as the tokens are now allocated to this payout call\n        ps.unallocatedSherX = ps.unallocatedSherX.sub(unallocatedSherX);\n        // Update the memory variable `totalUnallocatedSherX` to execute on `_doSherX` later\n        totalUnallocatedSherX = totalUnallocatedSherX.add(unallocatedSherX);\n      }\n\n      uint256 total = firstMoneyOut.add(amounts);\n      if (total == 0) {\n        continue;\n      }\n      if (firstMoneyOut > 0) {\n        ps.firstMoneyOut = ps.firstMoneyOut.sub(firstMoneyOut);\n      }\n      ps.stakeBalance = ps.stakeBalance.sub(total);\n\n      if (address(token) == address(this)) {\n        // If the token address == address(this), it's SherX\n        totalSherX = total;\n      } else {\n        // NOTE: Inside the _doSherX() call tokens are also transferred, potential gas optimalisation if tokens\n        // are transferred at once\n        token.safeTransfer(_payout, total);\n      }\n    }\n\n    if (totalUnallocatedSherX > 0) {\n      // Sum the SherX that is used from the pool + the SherX unallocated as rewards\n      totalSherX = totalSherX.add(totalUnallocatedSherX);\n    }\n    if (totalSherX == 0) {\n      return;\n    }\n\n    // NOTE: sx20().totalSupply is always > 0 when this codes hit.\n\n    uint256 curTotalUsdPool = LibSherX.viewAccrueUSDPool();\n    uint256 excludeUsd = _doSherX(_payout, _exclude, curTotalUsdPool, totalSherX);\n\n    // usd excluded, divided by the price per SherX token = amount of sherx to not burn.\n    uint256 deduction =\n      excludeUsd.div(curTotalUsdPool.div(SherXERC20Storage.sx20().totalSupply)).div(10e17);\n    // deduct that amount from the tokens being burned, to keep the same USD value\n    uint256 burnAmount = totalSherX.sub(deduction);\n\n    LibSherXERC20.burn(address(this), burnAmount);\n    LibSherX.settleInternalSupply(burnAmount);\n  }\n}"
    }
  ]
}