{
  "Title": "3S-LENFT-N03 libraries/logic /BorrowLogic.sol: Move GenesisNFT validation logic to GenesisNFT contract",
  "Content": "#### Description\nIn the current implementation, the [logic](https://github.com/leNFT/contracts/blob/master/contracts/libraries/logic/BorrowLogic.sol#L218-L245) to validate if a genesisNFT can be locked by the msg.sender on behalf of a user during loan creation is being executed on the BorrowLogic.sol contract.  This requires 5 calls to the genesisNFT to validate the parameters and lock the genesisNFT.\n\n#### Recommendation\nAll this logic could be placed inside a function `lockGenesisNFT()` inside the genesisNFT contract, preventing all those external calls. This function could be the first thing executed during the borrow validation and could also return the `maxLTVBoost` necessary for future validations. This change should therefore also involve the replacement of function `setLockedState()` with `lockGenesisNFT()` and `unlockGenesisNFT()`\n\nNote: We are aware that the GenesisNFT contract is already quiet large, so this optimization might not be possible to implement if it would cause the GenesisNFT contract to exceeed the maximum contract size.",
  "Impact": "GAS",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/libraries/logic/BorrowLogic.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.19;\n\nimport {DataTypes} from \"../types/DataTypes.sol\";\nimport {PercentageMath} from \"../utils/PercentageMath.sol\";\nimport {IAddressProvider} from \"../../interfaces/IAddressProvider.sol\";\nimport {ILoanCenter} from \"../../interfaces/ILoanCenter.sol\";\nimport {ITokenOracle} from \"../../interfaces/ITokenOracle.sol\";\nimport {INFTOracle} from \"../../interfaces/INFTOracle.sol\";\nimport {ILendingPool} from \"../../interfaces/ILendingPool.sol\";\nimport {IERC4626} from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport {IGenesisNFT} from \"../../interfaces/IGenesisNFT.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\n/// @title BorrowLogic\n/// @author leNFT\n/// @notice Contains the logic for the borrow and repay functions\n/// @dev Library dealing with the logic for the borrow and repay functions\nlibrary BorrowLogic {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @notice Creates a new loan, transfers the collateral to the loan center and mints the debt token\n    /// @param addressProvider The address of the addresses provider\n    /// @param lendingPool The address of the lending pool\n    /// @param params A struct with the parameters of the borrow function\n    /// @return loanId The id of the new loan\n    function borrow(\n        IAddressProvider addressProvider,\n        address lendingPool,\n        DataTypes.BorrowParams memory params\n    ) external returns (uint256 loanId) {\n        ILoanCenter loanCenter = ILoanCenter(addressProvider.getLoanCenter());\n\n        // If a genesis NFT was used with this loan we need to lock it\n        uint256 maxLTVBoost;\n        if (params.genesisNFTId != 0) {\n            maxLTVBoost = IGenesisNFT(addressProvider.getGenesisNFT())\n                .lockGenesisNFT(\n                    params.onBehalfOf,\n                    params.caller,\n                    params.genesisNFTId\n                );\n        }\n\n        // Validate the borrow parameters\n        _validateBorrow(\n            addressProvider,\n            lendingPool,\n            address(loanCenter),\n            maxLTVBoost,\n            params\n        );\n\n        // Transfer the collateral to the the lending market\n        for (uint256 i = 0; i < params.nftTokenIds.length; i++) {\n            IERC721Upgradeable(params.nftAddress).safeTransferFrom(\n                params.caller,\n                address(this),\n                params.nftTokenIds[i]\n            );\n        }\n\n        // Get the current borrow rate index\n        uint256 borrowRate = ILendingPool(lendingPool).getBorrowRate();\n\n        // Create the loan\n        loanId = loanCenter.createLoan(\n            params.onBehalfOf,\n            lendingPool,\n            params.amount,\n            params.genesisNFTId,\n            params.nftAddress,\n            params.nftTokenIds,\n            borrowRate\n        );\n\n        // Send the principal to the borrower\n        ILendingPool(lendingPool).transferUnderlying(\n            params.caller,\n            params.amount,\n            borrowRate\n        );\n    }\n\n    /// @notice Repays a loan, transfers the principal and interest to the lending pool and returns the collateral to the owner\n    /// @param addressProvider The address of the addresses provider\n    /// @param params A struct with the parameters of the repay function\n    function repay(\n        IAddressProvider addressProvider,\n        DataTypes.RepayParams memory params\n    ) external {\n        // Get the loan\n        ILoanCenter loanCenter = ILoanCenter(addressProvider.getLoanCenter());\n        DataTypes.LoanData memory loanData = loanCenter.getLoan(params.loanId);\n        uint256 interest = loanCenter.getLoanInterest(params.loanId);\n        uint256 loanDebt = interest + loanData.amount;\n\n        // Validate the repay parameters\n        _validateRepay(params.amount, loanData.state, loanDebt);\n\n        // If we are paying the entire loan debt\n        if (params.amount == loanDebt) {\n            // If the loan was being liquidated we send the liquidators payment back with a fee\n            if (loanData.state == DataTypes.LoanState.Auctioned) {\n                address asset = IERC4626(loanData.pool).asset();\n\n                DataTypes.LoanLiquidationData\n                    memory liquidationData = loanCenter.getLoanLiquidationData(\n                        params.loanId\n                    );\n\n                // Give max bid back to liquidator\n                IERC20Upgradeable(asset).safeTransfer(\n                    liquidationData.liquidator,\n                    liquidationData.auctionMaxBid\n                );\n                // Get the fee from the user and give it to the auctioneer\n                IERC20Upgradeable(asset).safeTransferFrom(\n                    params.caller,\n                    liquidationData.auctioneer,\n                    loanCenter.getLoanAuctioneerFee(params.loanId)\n                );\n            }\n\n            // Return the principal + interest\n            ILendingPool(loanData.pool).receiveUnderlying(\n                params.caller,\n                loanData.amount,\n                uint256(loanData.borrowRate),\n                interest\n            );\n\n            // Repay the loan through the loan center contract\n            loanCenter.repayLoan(params.loanId);\n\n            // If a genesis NFT was used with this loan we need to unlock it\n            if (loanData.genesisNFTId != 0) {\n                // Unlock Genesis NFT\n                IGenesisNFT(addressProvider.getGenesisNFT()).unlockGenesisNFT(\n                    uint256(loanData.genesisNFTId)\n                );\n            }\n\n            // Transfer the collateral back to the owner\n            for (uint256 i = 0; i < loanData.nftTokenIds.length; i++) {\n                IERC721Upgradeable(loanData.nftAsset).safeTransferFrom(\n                    address(this),\n                    loanData.owner,\n                    loanData.nftTokenIds[i]\n                );\n            }\n        }\n        // User is sending less than the total debt\n        else {\n            // User is sending less than interest or the interest entirely\n            if (params.amount <= interest) {\n                ILendingPool(loanData.pool).receiveUnderlying(\n                    params.caller,\n                    0,\n                    uint256(loanData.borrowRate),\n                    params.amount\n                );\n\n                // Calculate how much time the user has paid off with sent amount\n                loanCenter.updateLoanDebtTimestamp(\n                    params.loanId,\n                    uint256(loanData.debtTimestamp) +\n                        ((365 days *\n                            params.amount *\n                            PercentageMath.PERCENTAGE_FACTOR) /\n                            (loanData.amount * uint256(loanData.borrowRate)))\n                );\n            }\n            // User is sending the full interest and closing part of the loan\n            else {\n                ILendingPool(loanData.pool).receiveUnderlying(\n                    params.caller,\n                    params.amount - interest,\n                    uint256(loanData.borrowRate),\n                    interest\n                );\n                loanCenter.updateLoanDebtTimestamp(\n                    params.loanId,\n                    block.timestamp\n                );\n                loanCenter.updateLoanAmount(\n                    params.loanId,\n                    loanData.amount - params.amount + interest\n                );\n            }\n        }\n    }\n\n    /// @notice Validates the parameters of the borrow function\n    /// @param addressProvider The address of the addresses provider\n    /// @param lendingPool The address of the lending pool\n    /// @param loanCenter The address loan center\n    /// @param params A struct with the parameters of the borrow function\n    function _validateBorrow(\n        IAddressProvider addressProvider,\n        address lendingPool,\n        address loanCenter,\n        uint256 maxLTVBoost,\n        DataTypes.BorrowParams memory params\n    ) internal view {\n        // Check if borrow amount is bigger than 0\n        require(params.amount > 0, \"VL:VB:AMOUNT_0\");\n\n        // Check if theres at least one asset to use as collateral\n        require(params.nftTokenIds.length > 0, \"VL:VB:NO_NFTS\");\n\n        // Check if the lending pool exists\n        require(lendingPool != address(0), \"VL:VB:INVALID_LENDING_POOL\");\n\n        // Check if borrow amount exceeds allowed amount\n        (uint256 ethPrice, uint256 precision) = ITokenOracle(\n            addressProvider.getTokenOracle()\n        ).getTokenETHPrice(params.asset);\n\n        require(\n            params.amount <=\n                (PercentageMath.percentMul(\n                    INFTOracle(addressProvider.getNFTOracle())\n                        .getTokensETHPrice(\n                            params.nftAddress,\n                            params.nftTokenIds,\n                            params.request,\n                            params.packet\n                        ),\n                    ILoanCenter(loanCenter).getCollectionMaxLTV(\n                        params.nftAddress\n                    ) + maxLTVBoost\n                ) * precision) /\n                    ethPrice,\n            \"VL:VB:MAX_LTV_EXCEEDED\"\n        );\n\n        // Check if the pool has enough underlying to borrow\n        require(\n            params.amount <= ILendingPool(lendingPool).getUnderlyingBalance(),\n            \"VL:VB:INSUFFICIENT_UNDERLYING\"\n        );\n    }\n\n    /// @notice Validates the parameters of the repay function\n    /// @param repayAmount The amount to repay\n    /// @param loanState The state of the loan\n    /// @param loanDebt The debt of the loan\n    function _validateRepay(\n        uint256 repayAmount,\n        DataTypes.LoanState loanState,\n        uint256 loanDebt\n    ) internal pure {\n        // Validate the movement\n        // Check if borrow amount is bigger than 0\n        require(repayAmount > 0, \"VL:VR:AMOUNT_0\");\n\n        //Require that loan exists\n        require(\n            loanState == DataTypes.LoanState.Active ||\n                loanState == DataTypes.LoanState.Auctioned,\n            \"VL:VR:LOAN_NOT_FOUND\"\n        );\n\n        // Check if user is over-paying\n        require(repayAmount <= loanDebt, \"VL:VR:AMOUNT_EXCEEDS_DEBT\");\n\n        // Can only do partial repayments if the loan is not being auctioned\n        if (repayAmount < loanDebt) {\n            require(\n                loanState != DataTypes.LoanState.Auctioned,\n                \"VL:VR:PARTIAL_REPAY_AUCTIONED\"\n            );\n        }\n    }\n}"
    }
  ]
}