{
  "Title": "[02] Inability to remove suspended Yangs and zero prices can cause the protocol to freeze",
  "Content": "\nThe protocol only provides functionality to [add yangs](https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/sentinel.cairo#L174-L214), but there is no corresponding method for removal. Furthermore, the protocol allows to [suspend yangs](https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/sentinel.cairo#L236-L239), but even if a yang is [permanently  suspended](https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/types.cairo#L18) it cannot be removed.\n\nHowever, [all yangs ever added](https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/sentinel.cairo#L122-L133) (no matter if suspended) are [iterated by the `seer`](https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/seer.cairo#L202-L235) in order to query the orcale(s) for the underlying assets' prices.  \n\nConsider the following scenario:\n\nA collateral asset is hacked and/or there is a scandal about the project team (for example, Terra Luna). Therefore, the asset crashes. It gets delisted from major exchanges and suspended from Opus.\n\n### Impact\n\n- At some point, the orcale(s) might be unable to provide a price feed for the asset and therefore revert/panic. This causes DoS for all price updates of the protocol, consequently freezing the whole protocol.\n- There might still be a price feed, but the price is `0` (due to lack of data sources or the price is actually zero). However, the [`shrine` reverts due to an assertion](https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/shrine.cairo#L726) in case of [`0` price provided by the `seer`](https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/seer.cairo#L224). This causes DoS for all price updates of the protocol, consequently freezing the whole protocol.\n\n### Recommendation\n\nAllow the protocol's admin to remove yangs or at least exclude them from price updates. Furthermore, the [`0` price assertion](https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/shrine.cairo#L726) is dangerous, even during normal operation. Zero prices should be handled in a graceful way, especially in case of suspended assets, in order to avoid freezing the whole protocol.\n\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-01-opus",
  "Code": [
    {
      "filename": "src/core/sentinel.cairo",
      "content": "#[starknet::contract]\nmod sentinel {\n    use access_control::access_control_component;\n    use opus::core::roles::sentinel_roles;\n    use opus::interfaces::IERC20::{IERC20Dispatcher, IERC20DispatcherTrait};\n    use opus::interfaces::IGate::{IGateDispatcher, IGateDispatcherTrait};\n    use opus::interfaces::ISentinel::ISentinel;\n    use opus::interfaces::IShrine::{IShrineDispatcher, IShrineDispatcherTrait};\n    use opus::types::YangSuspensionStatus;\n    use opus::utils::math::fixed_point_to_wad;\n    use starknet::contract_address::{ContractAddress, ContractAddressZeroable};\n    use starknet::{get_block_timestamp, get_caller_address};\n    use wadray::{Ray, Wad, WadZeroable};\n\n    //\n    // Components\n    //\n\n    component!(path: access_control_component, storage: access_control, event: AccessControlEvent);\n\n    #[abi(embed_v0)]\n    impl AccessControlPublic = access_control_component::AccessControl<ContractState>;\n    impl AccessControlHelpers = access_control_component::AccessControlHelpers<ContractState>;\n\n    //\n    // Constants\n    //\n\n    // Helper constant to set the starting index for iterating over the\n    // yangs in the order they were added\n    const LOOP_START: u64 = 1;\n\n    const INITIAL_DEPOSIT_AMT: u128 = 1000;\n\n    //\n    // Storage\n    //\n\n    #[storage]\n    struct Storage {\n        // components\n        #[substorage(v0)]\n        access_control: access_control_component::Storage,\n        // mapping between a yang address and our deployed Gate\n        yang_to_gate: LegacyMap::<ContractAddress, IGateDispatcher>,\n        // length of the yang_addresses array\n        yang_addresses_count: u64,\n        // 0-based array of yang addresses added to the Shrine via this Sentinel\n        yang_addresses: LegacyMap::<u64, ContractAddress>,\n        // The Shrine associated with this Sentinel\n        shrine: IShrineDispatcher,\n        // mapping between a yang address and the cap on the yang's asset in the\n        // asset's decimals\n        yang_asset_max: LegacyMap::<ContractAddress, u128>,\n        // mapping between a yang address and whether its Gate is live\n        yang_is_live: LegacyMap::<ContractAddress, bool>,\n    }\n\n    //\n    // Events\n    //\n\n    #[event]\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    enum Event {\n        AccessControlEvent: access_control_component::Event,\n        YangAdded: YangAdded,\n        YangAssetMaxUpdated: YangAssetMaxUpdated,\n        GateKilled: GateKilled,\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct YangAdded {\n        #[key]\n        yang: ContractAddress,\n        gate: ContractAddress\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct YangAssetMaxUpdated {\n        #[key]\n        yang: ContractAddress,\n        old_max: u128,\n        new_max: u128\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct GateKilled {\n        #[key]\n        yang: ContractAddress,\n        gate: ContractAddress\n    }\n\n    //\n    // Constructor\n    //\n\n    #[constructor]\n    fn constructor(ref self: ContractState, admin: ContractAddress, shrine: ContractAddress) {\n        self.access_control.initializer(admin, Option::Some(sentinel_roles::default_admin_role()));\n        self.shrine.write(IShrineDispatcher { contract_address: shrine });\n    }\n\n    //\n    // External Sentinel functions\n    //\n\n    #[abi(embed_v0)]\n    impl ISentinelImpl of ISentinel<ContractState> {\n        //\n        // Getters\n        //\n\n        fn get_gate_address(self: @ContractState, yang: ContractAddress) -> ContractAddress {\n            self.yang_to_gate.read(yang).contract_address\n        }\n\n        fn get_gate_live(self: @ContractState, yang: ContractAddress) -> bool {\n            self.yang_is_live.read(yang)\n        }\n\n        fn get_yang_addresses(self: @ContractState) -> Span<ContractAddress> {\n            let mut idx: u64 = LOOP_START;\n            let loop_end: u64 = self.yang_addresses_count.read() + LOOP_START;\n            let mut addresses: Array<ContractAddress> = ArrayTrait::new();\n            loop {\n                if idx == loop_end {\n                    break addresses.span();\n                }\n                addresses.append(self.yang_addresses.read(idx));\n                idx += 1;\n            }\n        }\n\n        fn get_yang_addresses_count(self: @ContractState) -> u64 {\n            self.yang_addresses_count.read()\n        }\n\n        fn get_yang(self: @ContractState, idx: u64) -> ContractAddress {\n            self.yang_addresses.read(idx)\n        }\n\n        fn get_yang_asset_max(self: @ContractState, yang: ContractAddress) -> u128 {\n            self.yang_asset_max.read(yang)\n        }\n\n        fn get_asset_amt_per_yang(self: @ContractState, yang: ContractAddress) -> Wad {\n            let gate: IGateDispatcher = self.yang_to_gate.read(yang);\n            gate.get_asset_amt_per_yang()\n        }\n\n        //\n        // View functions\n        //\n\n        // This can be used to simulate the effects of `enter`.\n        fn convert_to_yang(self: @ContractState, yang: ContractAddress, asset_amt: u128) -> Wad {\n            let gate: IGateDispatcher = self.yang_to_gate.read(yang);\n            self.assert_can_enter(yang, gate, asset_amt);\n            gate.convert_to_yang(asset_amt)\n        }\n\n        // This can be used to simulate the effects of `exit`.\n        fn convert_to_assets(self: @ContractState, yang: ContractAddress, yang_amt: Wad) -> u128 {\n            let gate: IGateDispatcher = self.yang_to_gate.read(yang);\n            assert(gate.contract_address.is_non_zero(), 'SE: Yang not added');\n            gate.convert_to_assets(yang_amt)\n        }\n\n        //\n        // Setters\n        //\n\n        fn add_yang(\n            ref self: ContractState,\n            yang: ContractAddress,\n            yang_asset_max: u128,\n            yang_threshold: Ray,\n            yang_price: Wad,\n            yang_rate: Ray,\n            gate: ContractAddress\n        ) {\n            self.access_control.assert_has_role(sentinel_roles::ADD_YANG);\n            assert(yang.is_non_zero(), 'SE: Yang cannot be zero address');\n            assert(gate.is_non_zero(), 'SE: Gate cannot be zero address');\n            assert(self.yang_to_gate.read(yang).contract_address.is_zero(), 'SE: Yang already added');\n\n            let gate = IGateDispatcher { contract_address: gate };\n            assert(gate.get_asset() == yang, 'SE: Asset of gate is not yang');\n\n            let index: u64 = self.yang_addresses_count.read() + 1;\n            self.yang_addresses_count.write(index);\n            self.yang_addresses.write(index, yang);\n            self.yang_to_gate.write(yang, gate);\n            self.yang_is_live.write(yang, true);\n            self.yang_asset_max.write(yang, yang_asset_max);\n\n            // Require an initial deposit when adding a yang to prevent first depositor from front-running\n            let yang_erc20 = IERC20Dispatcher { contract_address: yang };\n            // scale `asset_amt` up by the difference to match `Wad` precision of yang\n            let initial_yang_amt: Wad = fixed_point_to_wad(INITIAL_DEPOSIT_AMT, yang_erc20.decimals());\n            let initial_deposit_amt: u256 = INITIAL_DEPOSIT_AMT.into();\n\n            let caller: ContractAddress = get_caller_address();\n            let success: bool = yang_erc20.transfer_from(caller, gate.contract_address, initial_deposit_amt);\n            assert(success, 'SE: Yang transfer failed');\n\n            let shrine: IShrineDispatcher = self.shrine.read();\n            shrine.add_yang(yang, yang_threshold, yang_price, yang_rate, initial_yang_amt);\n\n            // Events\n            self.emit(YangAdded { yang, gate: gate.contract_address });\n            self.emit(YangAssetMaxUpdated { yang, old_max: 0, new_max: yang_asset_max });\n        }\n\n        fn set_yang_asset_max(ref self: ContractState, yang: ContractAddress, new_asset_max: u128) {\n            self.access_control.assert_has_role(sentinel_roles::SET_YANG_ASSET_MAX);\n\n            let gate: IGateDispatcher = self.yang_to_gate.read(yang);\n            assert(gate.contract_address.is_non_zero(), 'SE: Yang not added');\n\n            let old_asset_max: u128 = self.yang_asset_max.read(yang);\n            self.yang_asset_max.write(yang, new_asset_max);\n\n            self.emit(YangAssetMaxUpdated { yang, old_max: old_asset_max, new_max: new_asset_max });\n        }\n\n        fn kill_gate(ref self: ContractState, yang: ContractAddress) {\n            self.access_control.assert_has_role(sentinel_roles::KILL_GATE);\n\n            self.yang_is_live.write(yang, false);\n\n            self.emit(GateKilled { yang, gate: self.yang_to_gate.read(yang).contract_address });\n        }\n\n        fn suspend_yang(ref self: ContractState, yang: ContractAddress) {\n            self.access_control.assert_has_role(sentinel_roles::UPDATE_YANG_SUSPENSION);\n            self.shrine.read().suspend_yang(yang);\n        }\n\n        fn unsuspend_yang(ref self: ContractState, yang: ContractAddress) {\n            self.access_control.assert_has_role(sentinel_roles::UPDATE_YANG_SUSPENSION);\n            self.shrine.read().unsuspend_yang(yang);\n        }\n\n        //\n        // Core functions\n        //\n\n        fn enter(\n            ref self: ContractState, yang: ContractAddress, user: ContractAddress, trove_id: u64, asset_amt: u128\n        ) -> Wad {\n            self.access_control.assert_has_role(sentinel_roles::ENTER);\n\n            let gate: IGateDispatcher = self.yang_to_gate.read(yang);\n\n            self.assert_can_enter(yang, gate, asset_amt);\n            gate.enter(user, trove_id, asset_amt)\n        }\n\n        fn exit(\n            ref self: ContractState, yang: ContractAddress, user: ContractAddress, trove_id: u64, yang_amt: Wad\n        ) -> u128 {\n            self.access_control.assert_has_role(sentinel_roles::EXIT);\n            let gate: IGateDispatcher = self.yang_to_gate.read(yang);\n            assert(gate.contract_address.is_non_zero(), 'SE: Yang not added');\n\n            gate.exit(user, trove_id, yang_amt)\n        }\n    }\n\n    //\n    // Internal Sentinel functions\n    //\n\n    #[generate_trait]\n    impl SentinelHelpers of SentinelHelpersTrait {\n        // Helper function to check that `enter` is a valid operation at the current\n        // on-chain conditions\n        #[inline(always)]\n        fn assert_can_enter(self: @ContractState, yang: ContractAddress, gate: IGateDispatcher, enter_amt: u128) {\n            assert(gate.contract_address.is_non_zero(), 'SE: Yang not added');\n            assert(self.yang_is_live.read(yang), 'SE: Gate is not live');\n            let suspension_status: YangSuspensionStatus = self.shrine.read().get_yang_suspension_status(yang);\n            assert(suspension_status == YangSuspensionStatus::None, 'SE: Yang suspended');\n            let current_total: u128 = gate.get_total_assets();\n            let max_amt: u128 = self.yang_asset_max.read(yang);\n            assert(current_total + enter_amt <= max_amt, 'SE: Exceeds max amount allowed');\n        }\n    }\n}"
    },
    {
      "filename": "src/core/sentinel.cairo",
      "content": "#[starknet::contract]\nmod sentinel {\n    use access_control::access_control_component;\n    use opus::core::roles::sentinel_roles;\n    use opus::interfaces::IERC20::{IERC20Dispatcher, IERC20DispatcherTrait};\n    use opus::interfaces::IGate::{IGateDispatcher, IGateDispatcherTrait};\n    use opus::interfaces::ISentinel::ISentinel;\n    use opus::interfaces::IShrine::{IShrineDispatcher, IShrineDispatcherTrait};\n    use opus::types::YangSuspensionStatus;\n    use opus::utils::math::fixed_point_to_wad;\n    use starknet::contract_address::{ContractAddress, ContractAddressZeroable};\n    use starknet::{get_block_timestamp, get_caller_address};\n    use wadray::{Ray, Wad, WadZeroable};\n\n    //\n    // Components\n    //\n\n    component!(path: access_control_component, storage: access_control, event: AccessControlEvent);\n\n    #[abi(embed_v0)]\n    impl AccessControlPublic = access_control_component::AccessControl<ContractState>;\n    impl AccessControlHelpers = access_control_component::AccessControlHelpers<ContractState>;\n\n    //\n    // Constants\n    //\n\n    // Helper constant to set the starting index for iterating over the\n    // yangs in the order they were added\n    const LOOP_START: u64 = 1;\n\n    const INITIAL_DEPOSIT_AMT: u128 = 1000;\n\n    //\n    // Storage\n    //\n\n    #[storage]\n    struct Storage {\n        // components\n        #[substorage(v0)]\n        access_control: access_control_component::Storage,\n        // mapping between a yang address and our deployed Gate\n        yang_to_gate: LegacyMap::<ContractAddress, IGateDispatcher>,\n        // length of the yang_addresses array\n        yang_addresses_count: u64,\n        // 0-based array of yang addresses added to the Shrine via this Sentinel\n        yang_addresses: LegacyMap::<u64, ContractAddress>,\n        // The Shrine associated with this Sentinel\n        shrine: IShrineDispatcher,\n        // mapping between a yang address and the cap on the yang's asset in the\n        // asset's decimals\n        yang_asset_max: LegacyMap::<ContractAddress, u128>,\n        // mapping between a yang address and whether its Gate is live\n        yang_is_live: LegacyMap::<ContractAddress, bool>,\n    }\n\n    //\n    // Events\n    //\n\n    #[event]\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    enum Event {\n        AccessControlEvent: access_control_component::Event,\n        YangAdded: YangAdded,\n        YangAssetMaxUpdated: YangAssetMaxUpdated,\n        GateKilled: GateKilled,\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct YangAdded {\n        #[key]\n        yang: ContractAddress,\n        gate: ContractAddress\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct YangAssetMaxUpdated {\n        #[key]\n        yang: ContractAddress,\n        old_max: u128,\n        new_max: u128\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct GateKilled {\n        #[key]\n        yang: ContractAddress,\n        gate: ContractAddress\n    }\n\n    //\n    // Constructor\n    //\n\n    #[constructor]\n    fn constructor(ref self: ContractState, admin: ContractAddress, shrine: ContractAddress) {\n        self.access_control.initializer(admin, Option::Some(sentinel_roles::default_admin_role()));\n        self.shrine.write(IShrineDispatcher { contract_address: shrine });\n    }\n\n    //\n    // External Sentinel functions\n    //\n\n    #[abi(embed_v0)]\n    impl ISentinelImpl of ISentinel<ContractState> {\n        //\n        // Getters\n        //\n\n        fn get_gate_address(self: @ContractState, yang: ContractAddress) -> ContractAddress {\n            self.yang_to_gate.read(yang).contract_address\n        }\n\n        fn get_gate_live(self: @ContractState, yang: ContractAddress) -> bool {\n            self.yang_is_live.read(yang)\n        }\n\n        fn get_yang_addresses(self: @ContractState) -> Span<ContractAddress> {\n            let mut idx: u64 = LOOP_START;\n            let loop_end: u64 = self.yang_addresses_count.read() + LOOP_START;\n            let mut addresses: Array<ContractAddress> = ArrayTrait::new();\n            loop {\n                if idx == loop_end {\n                    break addresses.span();\n                }\n                addresses.append(self.yang_addresses.read(idx));\n                idx += 1;\n            }\n        }\n\n        fn get_yang_addresses_count(self: @ContractState) -> u64 {\n            self.yang_addresses_count.read()\n        }\n\n        fn get_yang(self: @ContractState, idx: u64) -> ContractAddress {\n            self.yang_addresses.read(idx)\n        }\n\n        fn get_yang_asset_max(self: @ContractState, yang: ContractAddress) -> u128 {\n            self.yang_asset_max.read(yang)\n        }\n\n        fn get_asset_amt_per_yang(self: @ContractState, yang: ContractAddress) -> Wad {\n            let gate: IGateDispatcher = self.yang_to_gate.read(yang);\n            gate.get_asset_amt_per_yang()\n        }\n\n        //\n        // View functions\n        //\n\n        // This can be used to simulate the effects of `enter`.\n        fn convert_to_yang(self: @ContractState, yang: ContractAddress, asset_amt: u128) -> Wad {\n            let gate: IGateDispatcher = self.yang_to_gate.read(yang);\n            self.assert_can_enter(yang, gate, asset_amt);\n            gate.convert_to_yang(asset_amt)\n        }\n\n        // This can be used to simulate the effects of `exit`.\n        fn convert_to_assets(self: @ContractState, yang: ContractAddress, yang_amt: Wad) -> u128 {\n            let gate: IGateDispatcher = self.yang_to_gate.read(yang);\n            assert(gate.contract_address.is_non_zero(), 'SE: Yang not added');\n            gate.convert_to_assets(yang_amt)\n        }\n\n        //\n        // Setters\n        //\n\n        fn add_yang(\n            ref self: ContractState,\n            yang: ContractAddress,\n            yang_asset_max: u128,\n            yang_threshold: Ray,\n            yang_price: Wad,\n            yang_rate: Ray,\n            gate: ContractAddress\n        ) {\n            self.access_control.assert_has_role(sentinel_roles::ADD_YANG);\n            assert(yang.is_non_zero(), 'SE: Yang cannot be zero address');\n            assert(gate.is_non_zero(), 'SE: Gate cannot be zero address');\n            assert(self.yang_to_gate.read(yang).contract_address.is_zero(), 'SE: Yang already added');\n\n            let gate = IGateDispatcher { contract_address: gate };\n            assert(gate.get_asset() == yang, 'SE: Asset of gate is not yang');\n\n            let index: u64 = self.yang_addresses_count.read() + 1;\n            self.yang_addresses_count.write(index);\n            self.yang_addresses.write(index, yang);\n            self.yang_to_gate.write(yang, gate);\n            self.yang_is_live.write(yang, true);\n            self.yang_asset_max.write(yang, yang_asset_max);\n\n            // Require an initial deposit when adding a yang to prevent first depositor from front-running\n            let yang_erc20 = IERC20Dispatcher { contract_address: yang };\n            // scale `asset_amt` up by the difference to match `Wad` precision of yang\n            let initial_yang_amt: Wad = fixed_point_to_wad(INITIAL_DEPOSIT_AMT, yang_erc20.decimals());\n            let initial_deposit_amt: u256 = INITIAL_DEPOSIT_AMT.into();\n\n            let caller: ContractAddress = get_caller_address();\n            let success: bool = yang_erc20.transfer_from(caller, gate.contract_address, initial_deposit_amt);\n            assert(success, 'SE: Yang transfer failed');\n\n            let shrine: IShrineDispatcher = self.shrine.read();\n            shrine.add_yang(yang, yang_threshold, yang_price, yang_rate, initial_yang_amt);\n\n            // Events\n            self.emit(YangAdded { yang, gate: gate.contract_address });\n            self.emit(YangAssetMaxUpdated { yang, old_max: 0, new_max: yang_asset_max });\n        }\n\n        fn set_yang_asset_max(ref self: ContractState, yang: ContractAddress, new_asset_max: u128) {\n            self.access_control.assert_has_role(sentinel_roles::SET_YANG_ASSET_MAX);\n\n            let gate: IGateDispatcher = self.yang_to_gate.read(yang);\n            assert(gate.contract_address.is_non_zero(), 'SE: Yang not added');\n\n            let old_asset_max: u128 = self.yang_asset_max.read(yang);\n            self.yang_asset_max.write(yang, new_asset_max);\n\n            self.emit(YangAssetMaxUpdated { yang, old_max: old_asset_max, new_max: new_asset_max });\n        }\n\n        fn kill_gate(ref self: ContractState, yang: ContractAddress) {\n            self.access_control.assert_has_role(sentinel_roles::KILL_GATE);\n\n            self.yang_is_live.write(yang, false);\n\n            self.emit(GateKilled { yang, gate: self.yang_to_gate.read(yang).contract_address });\n        }\n\n        fn suspend_yang(ref self: ContractState, yang: ContractAddress) {\n            self.access_control.assert_has_role(sentinel_roles::UPDATE_YANG_SUSPENSION);\n            self.shrine.read().suspend_yang(yang);\n        }\n\n        fn unsuspend_yang(ref self: ContractState, yang: ContractAddress) {\n            self.access_control.assert_has_role(sentinel_roles::UPDATE_YANG_SUSPENSION);\n            self.shrine.read().unsuspend_yang(yang);\n        }\n\n        //\n        // Core functions\n        //\n\n        fn enter(\n            ref self: ContractState, yang: ContractAddress, user: ContractAddress, trove_id: u64, asset_amt: u128\n        ) -> Wad {\n            self.access_control.assert_has_role(sentinel_roles::ENTER);\n\n            let gate: IGateDispatcher = self.yang_to_gate.read(yang);\n\n            self.assert_can_enter(yang, gate, asset_amt);\n            gate.enter(user, trove_id, asset_amt)\n        }\n\n        fn exit(\n            ref self: ContractState, yang: ContractAddress, user: ContractAddress, trove_id: u64, yang_amt: Wad\n        ) -> u128 {\n            self.access_control.assert_has_role(sentinel_roles::EXIT);\n            let gate: IGateDispatcher = self.yang_to_gate.read(yang);\n            assert(gate.contract_address.is_non_zero(), 'SE: Yang not added');\n\n            gate.exit(user, trove_id, yang_amt)\n        }\n    }\n\n    //\n    // Internal Sentinel functions\n    //\n\n    #[generate_trait]\n    impl SentinelHelpers of SentinelHelpersTrait {\n        // Helper function to check that `enter` is a valid operation at the current\n        // on-chain conditions\n        #[inline(always)]\n        fn assert_can_enter(self: @ContractState, yang: ContractAddress, gate: IGateDispatcher, enter_amt: u128) {\n            assert(gate.contract_address.is_non_zero(), 'SE: Yang not added');\n            assert(self.yang_is_live.read(yang), 'SE: Gate is not live');\n            let suspension_status: YangSuspensionStatus = self.shrine.read().get_yang_suspension_status(yang);\n            assert(suspension_status == YangSuspensionStatus::None, 'SE: Yang suspended');\n            let current_total: u128 = gate.get_total_assets();\n            let max_amt: u128 = self.yang_asset_max.read(yang);\n            assert(current_total + enter_amt <= max_amt, 'SE: Exceeds max amount allowed');\n        }\n    }\n}"
    },
    {
      "filename": "src/core/shrine.cairo",
      "content": "#[starknet::contract]\nmod shrine {\n    use access_control::access_control_component;\n    use cmp::{max, min};\n    use core::starknet::event::EventEmitter;\n    use integer::{BoundedU256, U256Zeroable, u256_safe_div_rem};\n    use opus::core::roles::shrine_roles;\n    use opus::interfaces::IERC20::{IERC20, IERC20CamelOnly};\n    use opus::interfaces::ISRC5::ISRC5;\n    use opus::interfaces::IShrine::IShrine;\n    use opus::types::{\n        ExceptionalYangRedistribution, Health, Trove, YangBalance, YangRedistribution, YangSuspensionStatus\n    };\n    use opus::utils::exp::{exp, neg_exp};\n    use starknet::contract_address::{ContractAddress, ContractAddressZeroable};\n    use starknet::{get_block_timestamp, get_caller_address};\n    use wadray::{BoundedRay, Ray, RayZeroable, RAY_ONE, SignedWad, Wad, WadZeroable, WAD_DECIMALS, WAD_ONE, WAD_SCALE};\n\n    //\n    // Components\n    //\n\n    component!(path: access_control_component, storage: access_control, event: AccessControlEvent);\n\n    #[abi(embed_v0)]\n    impl AccessControlPublic = access_control_component::AccessControl<ContractState>;\n    impl AccessControlHelpers = access_control_component::AccessControlHelpers<ContractState>;\n\n    //\n    // Constants\n    //\n\n    // Initial multiplier value to ensure `get_recent_multiplier_from` terminates - (ray): RAY_ONE\n    const INITIAL_MULTIPLIER: u128 = 1000000000000000000000000000;\n    const MAX_MULTIPLIER: u128 = 10000000000000000000000000000; // Max of 10x (ray): 10 * RAY_ONE\n\n    const MAX_THRESHOLD: u128 = 1000000000000000000000000000; // (ray): RAY_ONE\n\n    // If a yang is deemed risky, it can be marked as suspended. During the\n    // SUSPENSION_GRACE_PERIOD, this decision can be reverted and the yang's status\n    // can be changed back to normal. If this does not happen, the yang is\n    // suspended permanently, i.e. can't be used in the system ever again.\n    // The start of a Yang's suspension period is tracked in `yang_suspension`\n    const SUSPENSION_GRACE_PERIOD: u64 =\n        consteval_int!((182 * 24 + 12) * 60 * 60); // 182.5 days, half a year, in seconds\n\n    // Length of a time interval in seconds\n    const TIME_INTERVAL: u64 = consteval_int!(30 * 60); // 30 minutes * 60 seconds per minute\n    const TIME_INTERVAL_DIV_YEAR: u128 =\n        57077625570776; // 1 / (48 30-minute intervals per day) / (365 days per year) = 0.000057077625 (wad)\n\n    // Threshold for rounding remaining debt during redistribution (wad): 10**9\n    const ROUNDING_THRESHOLD: u128 = 1000000000;\n\n    // Minimum amount of yang that must be in recipient troves for ordinary\n    // redistribution of yang to occur without overflow (wad): WAD_ONE\n    const MIN_RECIPIENT_POOL_YANG: u128 = 1000000000000000000;\n\n    // Maximum interest rate a yang can have (ray): RAY_ONE\n    const MAX_YANG_RATE: u128 = 1000000000000000000000000000;\n\n    // Flag for setting the yang's new base rate to its previous base rate in `update_rates`\n    // (ray): MAX_YANG_RATE + 1\n    const USE_PREV_BASE_RATE: u128 = 1000000000000000000000000001;\n\n    // Forge fee function parameters\n    const FORGE_FEE_A: u128 = 92103403719761827360719658187; // 92.103403719761827360719658187 (ray)\n    const FORGE_FEE_B: u128 = 55000000000000000; // 0.055 (wad)\n    // The lowest yin spot price where the forge fee will still be zero\n    const MIN_ZERO_FEE_YIN_PRICE: u128 = 995000000000000000; // 0.995 (wad)\n    // The maximum forge fee as a percentage of forge amount\n    const FORGE_FEE_CAP_PCT: u128 = 4000000000000000000; // 400% or 4 (wad)\n    // The maximum deviation before `FORGE_FEE_CAP_PCT` is reached\n    const FORGE_FEE_CAP_PRICE: u128 = 929900000000000000; // 0.9299 (wad)\n\n    // Convenience constant for upward iteration of yangs\n    const START_YANG_IDX: u32 = 1;\n\n    const RECOVERY_MODE_THRESHOLD_MULTIPLIER: u128 = 700000000000000000000000000; // 0.7 (ray)\n\n    // Factor that scales how much thresholds decline during recovery mode\n    const THRESHOLD_DECREASE_FACTOR: u128 = 1000000000000000000000000000; // 1 (ray)\n\n    // SRC5 interface constants\n    const ISRC5_ID: felt252 = 0x3f918d17e5ee77373b56385708f855659a07f75997f365cf87748628532a055;\n    const IERC20_ID: felt252 = 0x10a8f9ff27838cf36e9599878726d548a5c5c1acb0d7e04e99372cbb79f730b;\n    const IERC20_CAMEL_ID: felt252 = 0x2be91edd4cf1388a08c3612416baf85deb00e47d840e6d645f248c8ab64a4ab;\n\n    //\n    // Storage\n    //\n\n    #[storage]\n    struct Storage {\n        // components\n        #[substorage(v0)]\n        access_control: access_control_component::Storage,\n        // A trove can forge debt up to its threshold depending on the yangs deposited.\n        // (trove_id) -> (Trove)\n        troves: LegacyMap::<u64, Trove>,\n        // Stores the amount of the \"yin\" (synthetic) each user owns.\n        // (user_address) -> (Yin)\n        yin: LegacyMap::<ContractAddress, Wad>,\n        // Stores information about the total supply for each yang\n        // (yang_id) -> (Total Supply)\n        yang_total: LegacyMap::<u32, Wad>,\n        // Stores information about the initial yang amount minted to the system\n        initial_yang_amts: LegacyMap::<u32, Wad>,\n        // Number of collateral types accepted by the system.\n        // The return value is also the ID of the last added collateral.\n        yangs_count: u32,\n        // Mapping from yang ContractAddress to yang ID.\n        // Yang ID starts at 1.\n        // (yang_address) -> (yang_id)\n        yang_ids: LegacyMap::<ContractAddress, u32>,\n        // Keeps track of how much of each yang has been deposited into each Trove - Wad\n        // (yang_id, trove_id) -> (Amount Deposited)\n        deposits: LegacyMap::<(u32, u64), Wad>,\n        // Total amount of debt accrued for troves\n        // This includes any debt surplus already accounted for in the budget.\n        total_troves_debt: Wad,\n        // Total amount of synthetic forged and injected\n        total_yin: Wad,\n        // Current budget\n        // - If amount is negative, then there is a deficit i.e. `total_yin` > total debt\n        //   There is more yin in circulation than yin that needs to be repaid.\n        // - If amount is positive, then there is a surplus i.e. total debt > `total_yin`\n        //   There is more yin that needs to be repaid than in circulation.\n        // based on current on-chain conditions\n        budget: SignedWad,\n        // Keeps track of the price history of each Yang\n        // Stores both the actual price and the cumulative price of\n        // the yang at each time interval, both as Wads.\n        // - interval: timestamp divided by TIME_INTERVAL.\n        // (yang_id, interval) -> (price, cumulative_price)\n        yang_prices: LegacyMap::<(u32, u64), (Wad, Wad)>,\n        // Spot price of yin\n        yin_spot_price: Wad,\n        // Minimum value for a trove before a user can forge any debt\n        minimum_trove_value: Wad,\n        // Maximum amount of yin that can be generated. Once this ceiling is exceeded, the\n        // creation of new yin by users should be disallowed.\n        // - If the budget is positive, a user may create new yin only if the resulting total\n        //   yin amount and any debt surpluses is less than or equal to the ceiling.\n        // - If the budget is neutral or negative, a user may create new yin only if the resulting\n        //   total yin amount is less than the ceiling.\n        //\n        // Note that this does not  prevent interest from accruing or the budget from accruing\n        // a surplus, and positive budgets can still be minted as yin. Therefore, it is possible\n        // for the total amount of yin to exceed the debt ceiling.\n        debt_ceiling: Wad,\n        // Global interest rate multiplier\n        // stores both the actual multiplier, and the cumulative multiplier of\n        // the yang at each time interval, both as Rays\n        // (interval) -> (multiplier, cumulative_multiplier)\n        multiplier: LegacyMap::<u64, (Ray, Ray)>,\n        // Keeps track of the most recent rates index.\n        // Rate era starts at 1.\n        // Each index is associated with an update to the interest rates of all yangs.\n        rates_latest_era: u64,\n        // Keeps track of the interval at which the rate update at `era` was made.\n        // (era) -> (interval)\n        rates_intervals: LegacyMap::<u64, u64>,\n        // Keeps track of the interest rate of each yang at each era\n        // (yang_id, era) -> (Interest Rate)\n        yang_rates: LegacyMap::<(u32, u64), Ray>,\n        // Keeps track of when a yang was suspended\n        // 0 means it is not suspended\n        // (yang_id) -> (suspension timestamp)\n        yang_suspension: LegacyMap::<u32, u64>,\n        // Liquidation threshold per yang (as LTV) - Ray\n        // NOTE: don't read the value directly, instead use `get_yang_threshold_helper`\n        //       because a yang might be suspended; the function will return the correct\n        //       threshold value under all circumstances\n        // (yang_id) -> (Liquidation Threshold)\n        thresholds: LegacyMap::<u32, Ray>,\n        // Keeps track of how many redistributions have occurred\n        redistributions_count: u32,\n        // Last redistribution accounted for a trove\n        // (trove_id) -> (Last Redistribution ID)\n        trove_redistribution_id: LegacyMap::<u64, u32>,\n        // Keeps track of whether the redistribution involves at least one yang that\n        // no other troves has deposited.\n        // (redistribution_id) -> (Is exceptional redistribution)\n        is_exceptional_redistribution: LegacyMap::<u32, bool>,\n        // Mapping of yang ID and redistribution ID to\n        // 1. amount of debt in Wad to be redistributed to each Wad unit of yang\n        // 2. amount of debt to be added to the next redistribution to calculate (1)\n        // (yang_id, redistribution_id) -> YangRedistribution{debt_per_wad, debt_to_add_to_next}\n        yang_redistributions: LegacyMap::<(u32, u32), YangRedistribution>,\n        // Mapping of recipient yang ID, redistribution ID and redistributed yang ID to\n        // 1. amount of redistributed yang per Wad unit of recipient yang\n        // 2. amount of debt per Wad unit of recipient yang\n        yang_to_yang_redistribution: LegacyMap::<(u32, u32, u32), ExceptionalYangRedistribution>,\n        // Keeps track of whether shrine is live or killed\n        is_live: bool,\n        // Yin storage\n        yin_name: felt252,\n        yin_symbol: felt252,\n        yin_decimals: u8,\n        // Mapping of user's yin allowance for another user\n        // (user_address, spender_address) -> (Allowance)\n        yin_allowances: LegacyMap::<(ContractAddress, ContractAddress), u256>,\n    }\n\n    //\n    // Events\n    //\n\n    #[event]\n    #[derive(Copy, Drop, starknet::Event, Par"
    }
  ]
}