{
  "Title": "M-7: A single external protocol can DOS rebalancing process",
  "Content": "# Issue M-7: A single external protocol can DOS rebalancing process \n\nSource: https://github.com/sherlock-audit/2023-03-notional-judging/issues/175 \n\n## Found by \n0xGoodess, chaduke, xiaoming90\n## Summary\n\nA failure in an external money market can DOS the entire rebalance process in Notional.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/external/pCash/ProportionalRebalancingStrategy.sol#L23\n\n```solidity\nFile: ProportionalRebalancingStrategy.sol\n23:     function calculateRebalance(\n24:         IPrimeCashHoldingsOracle oracle,\n25:         uint8[] calldata rebalancingTargets\n26:     ) external view override onlyNotional returns (RebalancingData memory rebalancingData) {\n27:         address[] memory holdings = oracle.holdings();\n..SNIP..\n40:         for (uint256 i; i < holdings.length;) {\n41:             address holding = holdings[i];\n42:             uint256 targetAmount = totalValue * rebalancingTargets[i] / uint256(Constants.PERCENTAGE_DECIMALS);\n43:             uint256 currentAmount = values[i];\n44: \n45:             redeemHoldings[i] = holding;\n46:             depositHoldings[i] = holding;\n..SNIP..\n61:         }\n62: \n63:         rebalancingData.redeemData = oracle.getRedemptionCalldataForRebalancing(redeemHoldings, redeemAmounts);\n64:         rebalancingData.depositData = oracle.getDepositCalldataForRebalancing(depositHoldings, depositAmounts);\n65:     }\n```\n\nDuring a rebalance, the `ProportionalRebalancingStrategy` will loop through all the holdings and perform a deposit or redemption against the external market of the holdings.\n\nAssume that Notional integrates with four (4) external money markets (Aave V2, Aave V3, Compound V3, Morpho). In this case, whenever a rebalance is executed, Notional will interact with all four external money markets.\n\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/external/actions/TreasuryAction.sol#L304\n\n```solidity\nFile: TreasuryAction.sol\n304:     function _executeDeposits(Token memory underlyingToken, DepositData[] memory deposits) private {\n..SNIP..\n316:             for (uint256 j; j < depositData.targets.length; ++j) {\n317:                 // This will revert if the individual call reverts.\n318:                 GenericToken.executeLowLevelCall(\n319:                     depositData.targets[j], \n320:                     depositData.msgValue[j], \n321:                     depositData.callData[j]\n322:                 );\n323:             }\n```\n\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/internal/balances/TokenHandler.sol#L357\n\n```solidity\nFile: TokenHandler.sol\n357:     function executeMoneyMarketRedemptions(\n..SNIP..\n373:             for (uint256 j; j < data.targets.length; j++) {\n374:                 // This will revert if the individual call reverts.\n375:                 GenericToken.executeLowLevelCall(data.targets[j], 0, data.callData[j]);\n376:             }\n```\n\nHowever, as long as one external money market reverts, the entire rebalance process will be reverted and Notional would not be able to rebalance its underlying assets.\n\nThe call to the external money market can revert due to many reasons, which include the following:\n\n- Changes in the external protocol's interfaces (e.g. function signatures modified or functions added or removed)\n- The external protocol is paused\n- The external protocol has been compromised\n- The external protocol suffers from an upgrade failure causing an error in the new contract code.\n\n## Impact\n\nNotional would not be able to rebalance its underlying holding if one of the external money markets causes a revert. The probability of this issue occurring increases whenever Notional integrates with a new external money market\n\nThe key feature of Notional V3 is to allow its Treasury Manager to rebalance underlying holdings into various other money market protocols. \n\nThis makes Notional more resilient to issues in external protocols and future-proofs the protocol. If rebalancing does not work, Notional will be unable to move its fund out of a vulnerable external market, potentially draining protocol funds if this is not mitigated.\n\nAnother purpose of rebalancing is to allow Notional to allocate Notional V3â€™s capital to new opportunities or protocols that provide a good return. If rebalancing does not work, the protocol and its users will lose out on the gain from the investment.\n\nOn the other hand, if an external monkey market that Notional invested in is consistently underperforming or yielding negative returns, Notional will perform a rebalance to reallocate its funds to a better market. However, if rebalancing does not work, they will be stuck with a suboptimal asset allocation, and the protocol and its users will incur losses.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/external/pCash/ProportionalRebalancingStrategy.sol#L23\n\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/external/actions/TreasuryAction.sol#L304\n\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/internal/balances/TokenHandler.sol#L357\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider implementing a more resilient rebalancing process that allows for failures in individual external money markets. For instance, Notional could catch reverts from individual money markets and continue the rebalancing process with the remaining markets. \n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/59",
  "Code": [
    {
      "filename": "contracts-v2/contracts/external/pCash/ProportionalRebalancingStrategy.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.8.17;\n\nimport {NotionalProxy} from \"../../../interfaces/notional/NotionalProxy.sol\";\nimport {IPrimeCashHoldingsOracle, RedeemData, DepositData} from \"../../../interfaces/notional/IPrimeCashHoldingsOracle.sol\";\nimport {IRebalancingStrategy, RebalancingData} from \"../../../interfaces/notional/IRebalancingStrategy.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\n\ncontract ProportionalRebalancingStrategy is IRebalancingStrategy {\n    NotionalProxy internal immutable NOTIONAL;\n\n    error InvalidCaller(address sender);\n\n    constructor(NotionalProxy notional_) { NOTIONAL = notional_; }\n\n    modifier onlyNotional() {\n        if (msg.sender != address(NOTIONAL)) {\n            revert InvalidCaller(msg.sender);\n        }\n        _;\n    }\n\n    function calculateRebalance(\n        IPrimeCashHoldingsOracle oracle,\n        uint8[] calldata rebalancingTargets\n    ) external view override onlyNotional returns (RebalancingData memory rebalancingData) {\n        address[] memory holdings = oracle.holdings();\n        uint256[] memory values = oracle.holdingValuesInUnderlying();\n\n        (\n            uint256 totalValue,\n            /* uint256 internalPrecision */\n        ) = oracle.getTotalUnderlyingValueView();\n\n        address[] memory redeemHoldings = new address[](holdings.length);\n        uint256[] memory redeemAmounts = new uint256[](holdings.length);\n        address[] memory depositHoldings = new address[](holdings.length);\n        uint256[] memory depositAmounts = new uint256[](holdings.length);\n\n        for (uint256 i; i < holdings.length;) {\n            address holding = holdings[i];\n            uint256 targetAmount = totalValue * rebalancingTargets[i] / uint256(Constants.PERCENTAGE_DECIMALS);\n            uint256 currentAmount = values[i];\n\n            redeemHoldings[i] = holding;\n            depositHoldings[i] = holding;\n\n            if (targetAmount < currentAmount) {\n                unchecked {\n                    redeemAmounts[i] = currentAmount - targetAmount;\n                }\n            } else if (currentAmount < targetAmount) {\n                unchecked {\n                    depositAmounts[i] = targetAmount - currentAmount;\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        rebalancingData.redeemData = oracle.getRedemptionCalldataForRebalancing(redeemHoldings, redeemAmounts);\n        rebalancingData.depositData = oracle.getDepositCalldataForRebalancing(depositHoldings, depositAmounts);\n    }\n}"
    },
    {
      "filename": "contracts-v2/contracts/external/actions/TreasuryAction.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport {\n    Token,\n    PrimeRate,\n    PrimeCashFactors,\n    RebalancingContextStorage\n} from \"../../global/Types.sol\";\nimport {StorageLayoutV2} from \"../../global/StorageLayoutV2.sol\";\nimport {LibStorage} from \"../../global/LibStorage.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {SafeInt256} from \"../../math/SafeInt256.sol\";\nimport {SafeUint256} from \"../../math/SafeUint256.sol\";\n\nimport {BalanceHandler} from \"../../internal/balances/BalanceHandler.sol\";\nimport {PrimeRateLib} from \"../../internal/pCash/PrimeRateLib.sol\";\nimport {TokenHandler} from \"../../internal/balances/TokenHandler.sol\";\nimport {nTokenHandler} from \"../../internal/nToken/nTokenHandler.sol\";\nimport {nTokenSupply} from \"../../internal/nToken/nTokenSupply.sol\";\nimport {PrimeCashExchangeRate, PrimeCashFactors} from \"../../internal/pCash/PrimeCashExchangeRate.sol\";\nimport {GenericToken} from \"../../internal/balances/protocols/GenericToken.sol\";\n\nimport {ActionGuards} from \"./ActionGuards.sol\";\nimport {NotionalTreasury} from \"../../../interfaces/notional/NotionalTreasury.sol\";\nimport {Comptroller} from \"../../../interfaces/compound/ComptrollerInterface.sol\";\nimport {CErc20Interface} from \"../../../interfaces/compound/CErc20Interface.sol\";\nimport {IPrimeCashHoldingsOracle, DepositData, RedeemData} from \"../../../interfaces/notional/IPrimeCashHoldingsOracle.sol\";\nimport {IRebalancingStrategy, RebalancingData} from \"../../../interfaces/notional/IRebalancingStrategy.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\ncontract TreasuryAction is StorageLayoutV2, ActionGuards, NotionalTreasury {\n    using SafeUint256 for uint256;\n    using SafeInt256 for int256;\n    using SafeERC20 for IERC20;\n    using TokenHandler for Token;\n\n    IERC20 public immutable COMP;\n    Comptroller public immutable COMPTROLLER;\n    IRebalancingStrategy public immutable REBALANCING_STRATEGY;\n\n    /// @dev Harvest methods are only callable by the authorized treasury manager contract\n    modifier onlyManagerContract() {\n        require(treasuryManagerContract == msg.sender, \"Treasury manager required\");\n        _;\n    }\n\n    constructor(Comptroller _comptroller, IRebalancingStrategy _rebalancingStrategy) {\n        COMPTROLLER = _comptroller;\n        COMP = IERC20(_comptroller.getCompAddress());\n        REBALANCING_STRATEGY = _rebalancingStrategy;\n    }\n\n    /// @notice Sets the new treasury manager contract\n    function setTreasuryManager(address manager) external override onlyOwner {\n        emit TreasuryManagerChanged(treasuryManagerContract, manager);\n        treasuryManagerContract = manager;\n    }\n\n    /// @notice Sets the reserve buffer. This is the amount of reserve balance to keep denominated in 1e8\n    /// The reserve cannot be harvested if it's below this amount. This portion of the reserve will remain on\n    /// the contract to act as a buffer against potential insolvency.\n    /// @param currencyId refers to the currency of the reserve\n    /// @param bufferAmount reserve buffer amount to keep in internal token precision (1e8)\n    function setReserveBuffer(uint16 currencyId, uint256 bufferAmount) external override onlyOwner {\n        _checkValidCurrency(currencyId);\n        reserveBuffer[currencyId] = bufferAmount;\n        emit ReserveBufferUpdated(currencyId, bufferAmount);\n    }\n\n    /// @notice Updates the emission rate of incentives for a given currency\n    /// @dev emit:UpdateIncentiveEmissionRate\n    /// @param currencyId the currency id that the nToken references\n    /// @param newEmissionRate Target total incentives to emit for an nToken over an entire year\n    /// denominated in WHOLE TOKENS (i.e. setting this to 1 means 1e8 tokens). The rate will not be\n    /// exact due to multiplier effects and fluctuating token supply.\n    function updateIncentiveEmissionRate(uint16 currencyId, uint32 newEmissionRate)\n        external\n        override\n        onlyOwner\n    {\n        _checkValidCurrency(currencyId);\n        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);\n        require(nTokenAddress != address(0));\n        // Sanity check that emissions rate is not specified in 1e8 terms.\n        require(newEmissionRate < Constants.INTERNAL_TOKEN_PRECISION, \"Invalid rate\");\n\n        nTokenSupply.setIncentiveEmissionRate(nTokenAddress, newEmissionRate, block.timestamp);\n        emit UpdateIncentiveEmissionRate(currencyId, newEmissionRate);\n    }\n\n\n    /// @notice This is used in the case of insolvency. It allows the owner to re-align the reserve with its correct balance.\n    /// @param currencyId refers to the currency of the reserve\n    /// @param newBalance new reserve balance to set, must be less than the current balance\n    function setReserveCashBalance(uint16 currencyId, int256 newBalance)\n        external\n        override\n        onlyOwner\n    {\n        _checkValidCurrency(currencyId);\n        // newBalance cannot be negative and is checked inside BalanceHandler.setReserveCashBalance\n        BalanceHandler.setReserveCashBalance(currencyId, newBalance);\n    }\n\n    /// @notice Claims COMP incentives earned and transfers to the treasury manager contract.\n    /// @param cTokens a list of cTokens to claim incentives for\n    /// @return the balance of COMP claimed\n    function claimCOMPAndTransfer(address[] calldata cTokens)\n        external\n        override\n        onlyManagerContract\n        nonReentrant\n        returns (uint256)\n    {\n        uint256 balanceBefore = COMP.balanceOf(address(this));\n        COMPTROLLER.claimComp(address(this), cTokens);\n        uint256 balanceAfter = COMP.balanceOf(address(this));\n\n        // NOTE: the onlyManagerContract modifier prevents a transfer to address(0) here\n        uint256 netBalance = balanceAfter.sub(balanceBefore);\n        if (netBalance > 0) {\n            COMP.safeTransfer(msg.sender, netBalance);\n        }\n\n        // NOTE: TreasuryManager contract will emit a COMPHarvested event\n        return netBalance;\n    }\n\n    /// @notice redeems and transfers tokens to the treasury manager contract\n    function _redeemAndTransfer(uint16 currencyId, int256 primeCashRedeemAmount) private returns (uint256) {\n        PrimeRate memory primeRate = PrimeRateLib.buildPrimeRateStateful(currencyId);\n        int256 actualTransferExternal = TokenHandler.withdrawPrimeCash(\n            treasuryManagerContract,\n            currencyId,\n            primeCashRedeemAmount.neg(),\n            primeRate,\n            true // if ETH, transfers it as WETH\n        );\n\n        require(actualTransferExternal > 0);\n        return uint256(actualTransferExternal);\n    }\n\n    /// @notice Transfers some amount of reserve assets to the treasury manager contract to be invested\n    /// into the sNOTE pool.\n    /// @param currencies an array of currencies to transfer from Notional\n    function transferReserveToTreasury(uint16[] calldata currencies)\n        external\n        override\n        onlyManagerContract\n        nonReentrant\n        returns (uint256[] memory)\n    {\n        uint256[] memory amountsTransferred = new uint256[](currencies.length);\n\n        for (uint256 i; i < currencies.length; ++i) {\n            // Prevents duplicate currency IDs\n            if (i > 0) require(currencies[i] > currencies[i - 1], \"IDs must be sorted\");\n\n            uint16 currencyId = currencies[i];\n\n            _checkValidCurrency(currencyId);\n\n            // Reserve buffer amount in INTERNAL_TOKEN_PRECISION\n            int256 bufferInternal = SafeInt256.toInt(reserveBuffer[currencyId]);\n\n            // Reserve requirement not defined\n            if (bufferInternal == 0) continue;\n\n            int256 reserveInternal = BalanceHandler.getPositiveCashBalance(Constants.FEE_RESERVE, currencyId);\n\n            // Do not withdraw anything if reserve is below or equal to reserve requirement\n            if (reserveInternal <= bufferInternal) continue;\n\n            // Actual reserve amount allowed to be redeemed and transferred\n            // NOTE: overflow not possible with the check above\n            int256 primeCashRedeemed = reserveInternal - bufferInternal;\n\n            // Redeems prime cash and transfer underlying to treasury manager contract\n            amountsTransferred[i] = _redeemAndTransfer(currencyId, primeCashRedeemed);\n\n            // Updates the reserve balance\n            BalanceHandler.harvestExcessReserveBalance(\n                currencyId,\n                reserveInternal,\n                primeCashRedeemed\n            );\n        }\n\n        // NOTE: TreasuryManager contract will emit an AssetsHarvested event\n        return amountsTransferred;\n    }\n\n    function setRebalancingTargets(uint16 currencyId, RebalancingTargetConfig[] calldata targets) external override onlyOwner {\n        IPrimeCashHoldingsOracle oracle = PrimeCashExchangeRate.getPrimeCashHoldingsOracle(currencyId);\n        address[] memory holdings = oracle.holdings();\n\n        require(targets.length == holdings.length);\n\n        mapping(address => uint8) storage rebalancingTargets = LibStorage.getRebalancingTargets()[currencyId];\n        uint256 totalPercentage;\n        for (uint256 i; i < holdings.length; ++i) {\n            RebalancingTargetConfig calldata config = targets[i];\n            address holding = holdings[i];\n\n            require(config.holding == holding);\n            totalPercentage = totalPercentage.add(config.target);\n            rebalancingTargets[holding] = config.target;\n        }\n        require(totalPercentage <= uint256(Constants.PERCENTAGE_DECIMALS));\n\n        emit RebalancingTargetsUpdated(currencyId, targets);\n    }\n\n    function setRebalancingCooldown(uint16 currencyId, uint40 cooldownTimeInSeconds) external override onlyOwner {\n        mapping(uint16 => RebalancingContextStorage) storage store = LibStorage.getRebalancingContext();\n        store[currencyId].rebalancingCooldownInSeconds = cooldownTimeInSeconds;\n        emit RebalancingCooldownUpdated(currencyId, cooldownTimeInSeconds);\n    }\n\n    function rebalance(uint16[] calldata currencyId) external override onlyManagerContract {\n        for (uint256 i; i < currencyId.length; ++i) {\n            _rebalanceCurrency(currencyId[i]);\n        }\n    }\n\n    function _rebalanceCurrency(uint16 currencyId) private {\n        RebalancingContextStorage memory context = LibStorage.getRebalancingContext()[currencyId];\n\n        require(\n            uint256(context.lastRebalanceTimestampInSeconds).add(context.rebalancingCooldownInSeconds) < block.timestamp, \n            \"Rebalancing cooldown\"\n        );\n\n        // Accrues interest up to the current block before any rebalancing is executed\n        PrimeRateLib.buildPrimeRateStateful(currencyId);\n\n        PrimeCashFactors memory factors = PrimeCashExchangeRate.getPrimeCashFactors(currencyId);\n        _executeRebalance(currencyId);\n\n        // if previous underlying scalar at rebalance == 0, then it is the first rebalance and\n        // annualized interest rate will be left as zero. The previous underlying scalar will\n        // be set to the new factors.underlyingScalar.\n        uint256 annualizedInterestRate;\n        if (context.previousUnderlyingScalarAtRebalance != 0) {\n            uint256 interestRate = factors.underlyingScalar\n                .mul(Constants.SCALAR_PRECISION)\n                .div(context.previousUnderlyingScalarAtRebalance)\n                .sub(Constants.SCALAR_PRECISION) \n                .div(uint256(Constants.RATE_PRECISION));\n\n            annualizedInterestRate = interestRate\n                .mul(Constants.YEAR)\n                .div(block.timestamp.sub(context.lastRebalanceTimestampInSeconds));\n        }\n\n        _saveRebalancingContext(currencyId, factors.underlyingScalar, annualizedInterestRate);\n\n        emit CurrencyRebalanced(currencyId, factors.underlyingScalar, annualizedInterestRate);\n    }\n\n    function _saveRebalancingContext(uint16 currencyId, uint256 underlyingScalar, uint256 annualizedInterestRate) private {\n        mapping(uint16 => RebalancingContextStorage) storage store = LibStorage.getRebalancingContext();\n        store[currencyId].lastRebalanceTimestampInSeconds = block.timestamp.toUint40();\n        store[currencyId].previousUnderlyingScalarAtRebalance = underlyingScalar.toUint80();\n        store[currencyId].oracleMoneyMarketRate = annualizedInterestRate.toUint32();\n    }\n\n    function _getRebalancingTargets(uint16 currencyId, address[] memory holdings) private view returns (uint8[] memory targets) {\n        mapping(address => uint8) storage rebalancingTargets = LibStorage.getRebalancingTargets()[currencyId];\n        targets = new uint8[](holdings.length);\n        uint256 totalPercentage;\n        for (uint256 i; i < holdings.length; ++i) {\n            uint8 target = rebalancingTargets[holdings[i]];\n            targets[i] = target;\n            totalPercentage = totalPercentage.add(target);\n        }\n        require(totalPercentage <= uint256(Constants.PERCENTAGE_DECIMALS));\n    }\n\n    function _executeRebalance(uint16 currencyId) private {\n        IPrimeCashHoldingsOracle oracle = PrimeCashExchangeRate.getPrimeCashHoldingsOracle(currencyId);\n        uint8[] memory rebalancingTargets = _getRebalancingTargets(currencyId, oracle.holdings());\n        (RebalancingData memory data) = REBALANCING_STRATEGY.calculateRebalance(oracle, rebalancingTargets);\n\n        (/* */, uint256 totalUnderlyingValueBefore) = oracle.getTotalUnderlyingValueStateful();\n\n        // Process redemptions first\n        Token memory underlyingToken = TokenHandler.getUnderlyingToken(currencyId);\n        TokenHandler.executeMoneyMarketRedemptions(underlyingToken, data.redeemData);\n\n        // Process deposits\n        _executeDeposits(underlyingToken, data.depositData);\n\n        (/* */, uint256 totalUnderlyingValueAfter) = oracle.getTotalUnderlyingValueStateful();\n\n        int256 underlyingDelta = totalUnderlyingValueBefore.toInt().sub(totalUnderlyingValueAfter.toInt());\n        require(underlyingDelta.abs() < Constants.REBALANCING_UNDERLYING_DELTA);\n    }\n\n    function _executeDeposits(Token memory underlyingToken, DepositData[] memory deposits) private {\n        uint256 totalUnderlyingDepositAmount;\n        \n        for (uint256 i; i < deposits.length; i++) {\n            DepositData memory depositData = deposits[i];\n            // Measure the token balance change if the `assetToken` value is set in the\n            // current deposit data struct. \n            uint256 oldAssetBalance = IERC20(depositData.assetToken).balanceOf(address(this));\n\n            // Measure the underlying balance change before and after the call.\n            uint256 oldUnderlyingBalance = underlyingToken.balanceOf(address(this));\n\n            for (uint256 j; j < depositData.targets.length; ++j) {\n                // This will revert if the individual call reverts.\n                GenericToken.executeLowLevelCall(\n                    depositData.targets[j], \n                    depositData.msgValue[j], \n                    depositData.callData[j]\n                );\n            }\n\n            // Ensure that the underlying balance change matches the deposit amount\n            uint256 newUnderlyingBalance = underlyingToken.balanceOf(address(this));\n            uint256 underlyingBalanceChange = oldUnderlyingBalance.sub(newUnderlyingBalance);\n            // If the call is not the final deposit, then underlyingDepositAmount should\n            // be set to zero.\n            require(underlyingBalanceChange <= depositData.underlyingDepositAmount);\n        \n            // Measure and update the asset token\n            uint256 newAssetBalance = IERC20(depositData.assetToken).balanceOf(address(this));\n            require(oldAssetBalance <= newAssetBalance);\n            TokenHandler.updateStoredTokenBalance(depositData.assetToken, oldAssetBalance, newAssetBalance);\n\n            // Update the total value with the net change\n            totalUnderlyingDepositAmount = totalUnderlyingDepositAmount.add(underlyingBalanceChange);\n\n            // totalUnderlyingDepositAmount needs to be subtracted from the underlying balance because\n            // we are trading underlying cash for asset cash\n            TokenHandler.updateStoredTokenBalance(underlyingToken.tokenAddress, oldUnderlyingBalance, newUnderlyingBalance);\n        }\n    }\n}"
    },
    {
      "filename": "contracts-v2/contracts/internal/balances/TokenHandler.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport {\n    Token,\n    TokenType,\n    TokenStorage,\n    PrimeRate\n} from \"../../global/Types.sol\";\nimport {LibStorage} from \"../../global/LibStorage.sol\";\nimport {SafeInt256} from \"../../math/SafeInt256.sol\";\nimport {SafeUint256} from \"../../math/SafeUint256.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {Deployments} from \"../../global/Deployments.sol\";\n\nimport {Emitter} from \"../Emitter.sol\";\nimport {PrimeCashExchangeRate} from \"../pCash/PrimeCashExchangeRate.sol\";\nimport {PrimeRateLib} from \"../pCash/PrimeRateLib.sol\";\n\nimport {CompoundHandler} from \"./protocols/CompoundHandler.sol\";\nimport {GenericToken} from \"./protocols/GenericToken.sol\";\n\nimport {IERC20} from \"../../../interfaces/IERC20.sol\";\nimport {IPrimeCashHoldingsOracle, RedeemData} from \"../../../interfaces/notional/IPrimeCashHoldingsOracle.sol\";\n\n/// @notice Handles all external token transfers and events\nlibrary TokenHandler {\n    using SafeInt256 for int256;\n    using SafeUint256 for uint256;\n    using PrimeRateLib for PrimeRate;\n\n    function getDeprecatedAssetToken(uint256 currencyId) internal view returns (Token memory) {\n        return _getToken(currencyId, false);\n    }\n\n    function getUnderlyingToken(uint256 currencyId) internal view returns (Token memory) {\n        return _getToken(currencyId, true);\n    }\n\n    /// @notice Gets token data for a particular currency id, if underlying is set to true then returns\n    /// the underlying token. (These may not always exist)\n    function _getToken(uint256 currencyId, bool underlying) private view returns (Token memory) {\n        mapping(uint256 => mapping(bool => TokenStorage)) storage store = LibStorage.getTokenStorage();\n        TokenStorage storage tokenStorage = store[currencyId][underlying];\n\n        return\n            Token({\n                tokenAddress: tokenStorage.tokenAddress,\n                hasTransferFee: tokenStorage.hasTransferFee,\n                // No overflow, restricted on storage\n                decimals: int256(10**tokenStorage.decimalPlaces),\n                tokenType: tokenStorage.tokenType,\n                deprecated_maxCollateralBalance: 0\n            });\n    }\n\n    /// @notice Sets a token for a currency id. After the prime cash migration, only\n    /// underlying tokens may be set by this method.\n    function setToken(uint256 currencyId, TokenStorage memory tokenStorage) internal {\n        mapping(uint256 => mapping(bool => TokenStorage)) storage store = LibStorage.getTokenStorage();\n\n        if (tokenStorage.tokenType == TokenType.Ether && currencyId == Constants.ETH_CURRENCY_ID) {\n            // Hardcoded parameters for ETH just to make sure we don't get it wrong.\n            TokenStorage storage ts = store[currencyId][true];\n            ts.tokenAddress = address(0);\n            ts.hasTransferFee = false;\n            ts.tokenType = TokenType.Ether;\n            ts.decimalPlaces = Constants.ETH_DECIMAL_PLACES;\n\n            return;\n        }\n\n        // Check token address\n        require(tokenStorage.tokenAddress != address(0), \"TH: address is zero\");\n        // Once a token is set we cannot override it. In the case that we do need to do change a token address\n        // then we should explicitly upgrade this method to allow for a token to be changed.\n        Token memory token = _getToken(currencyId, true);\n        require(\n            token.tokenAddress == tokenStorage.tokenAddress || token.tokenAddress == address(0),\n            \"TH: token cannot be reset\"\n        );\n\n        require(0 < tokenStorage.decimalPlaces \n            && tokenStorage.decimalPlaces <= Constants.MAX_DECIMAL_PLACES, \"TH: invalid decimals\");\n\n        // Validate token type\n        require(tokenStorage.tokenType != TokenType.Ether); // dev: ether can only be set once\n        // Only underlying tokens allowed after migration\n        require(tokenStorage.tokenType == TokenType.UnderlyingToken); // dev: only underlying token\n\n        // Underlying is always true.\n        store[currencyId][true] = tokenStorage;\n    }\n\n    /**\n     * @notice Transfers a deprecated asset token into Notional and redeems it for underlying,\n     * updates prime cash supply and returns the total prime cash to add to the account.\n     * @param assetToken asset token to redeem\n     * @param currencyId the currency id of the token\n     * @param assetAmountExternal the amount to transfer in asset token denomination and external precision\n     * @param primeRate the prime rate for the given currency\n     * @param account the address of the account to transfer from\n     * @return primeCashDeposited the amount of prime cash to mint back to the account\n     */\n    function depositDeprecatedAssetToken(\n        Token memory assetToken,\n        uint16 currencyId,\n        uint256 assetAmountExternal,\n        address account,\n        PrimeRate memory primeRate\n    ) internal returns (int256 primeCashDeposited) {\n        // Transfer the asset token into the contract\n        assetAmountExternal = GenericToken.safeTransferIn(\n            assetToken.tokenAddress, account, assetAmountExternal\n        );\n\n        Token memory underlyingToken = getUnderlyingToken(currencyId);\n        int256 underlyingExternalAmount;\n        // Only cTokens will be listed at the time of the migration. Redeem\n        // those cTokens to underlying (to be held by the Notional contract)\n        // and then run the post transfer update\n        if (assetToken.tokenType == TokenType.cETH) {\n            underlyingExternalAmount = CompoundHandler.redeemCETH(\n                assetToken, assetAmountExternal\n            ).toInt();\n        } else if (assetToken.tokenType == TokenType.cToken) {\n            underlyingExternalAmount = CompoundHandler.redeem(\n                assetToken, underlyingToken, assetAmountExternal\n            ).toInt();\n        } else {\n            // No other asset token variants can be called here.\n            revert();\n        }\n        \n        primeCashDeposited = _postTransferPrimeCashUpdate(\n            account, currencyId, underlyingExternalAmount, underlyingToken, primeRate\n        );\n    }\n\n    /// @notice Deposits an exact amount of underlying tokens to mint the specified amount of prime cash.\n    /// @param account account to transfer tokens from\n    /// @param currencyId the associated currency id\n    /// @param primeCashToMint the amount of prime cash to mint\n    /// @param primeRate the current accrued prime rate\n    /// @param returnNativeTokenWrapped if true, return excess msg.value ETH payments as WETH\n    /// @return actualTransferExternal the actual amount of tokens transferred in external precision\n    function depositExactToMintPrimeCash(\n        address account,\n        uint16 currencyId,\n        int256 primeCashToMint,\n        PrimeRate memory primeRate,\n        bool returnNativeTokenWrapped\n    ) internal returns (int256 actualTransferExternal) {\n        if (primeCashToMint == 0) return 0;\n        require(primeCashToMint > 0);\n        Token memory underlying = getUnderlyingToken(currencyId);\n        int256 netTransferExternal = convertToUnderlyingExternalWithAdjustment(\n            underlying, \n            primeRate.convertToUnderlying(primeCashToMint) \n        );\n\n        (actualTransferExternal, /* */) = depositUnderlyingExternal(\n            account, currencyId, netTransferExternal, primeRate, returnNativeTokenWrapped\n        );\n    }\n\n    /// @notice Deposits an amount of underlying tokens to mint prime cash\n    /// @param account account to transfer tokens from\n    /// @param currencyId the associated currency id\n    /// @param _underlyingExternalDeposit the amount of underlying tokens to deposit\n    /// @param primeRate the current accrued prime rate\n    /// @param returnNativeTokenWrapped if true, return excess msg.value ETH payments as WETH\n    /// @return actualTransferExternal the actual amount of tokens transferred in external precision\n    /// @return netPrimeSupplyChange the amount of prime supply created\n    function depositUnderlyingExternal(\n        address account,\n        uint16 currencyId,\n        int256 _underlyingExternalDeposit,\n        PrimeRate memory primeRate,\n        bool returnNativeTokenWrapped\n    ) internal returns (int256 actualTransferExternal, int256 netPrimeSupplyChange) {\n        uint256 underlyingExternalDeposit = _underlyingExternalDeposit.toUint();\n        if (underlyingExternalDeposit == 0) return (0, 0);\n\n        Token memory underlying = getUnderlyingToken(currencyId);\n        if (underlying.tokenType == TokenType.Ether) {\n            // Underflow checked above\n            if (underlyingExternalDeposit < msg.value) {\n                // Transfer any excess ETH back to the account\n                GenericToken.transferNativeTokenOut(\n                    account, msg.value - underlyingExternalDeposit, returnNativeTokenWrapped\n                );\n            } else {\n                require(underlyingExternalDeposit == msg.value, \"ETH Balance\");\n            }\n\n            actualTransferExternal = _underlyingExternalDeposit;\n        } else {\n            // In the case of deposits, we use a balance before and after check\n            // to ensure that we record the proper balance change.\n            actualTransferExternal = GenericToken.safeTransferIn(\n                underlying.tokenAddress, account, underlyingExternalDeposit\n            ).toInt();\n        }\n\n        netPrimeSupplyChange = _postTransferPrimeCashUpdate(\n            account, currencyId, actualTransferExternal, underlying, primeRate\n        );\n    }\n\n    /// @notice Withdraws an amount of prime cash and returns it to the account as underlying tokens\n    /// @param account account to transfer tokens to\n    /// @param currencyId the associated currency id\n    /// @param primeCashToWithdraw the amount of prime cash to burn\n    /// @param primeRate the current accrued prime rate\n    /// @param withdrawWrappedNativeToken if true, return ETH as WETH\n    /// @return netTransferExternal the amount of underlying tokens withdrawn in native precision, this is\n    /// negative to signify that tokens have left the protocol\n    function withdrawPrimeCash(\n        address account,\n        uint16 currencyId,\n        int256 primeCashToWithdraw,\n        PrimeRate memory primeRate,\n        bool withdrawWrappedNativeToken\n    ) internal returns (int256 netTransferExternal) {\n        if (primeCashToWithdraw == 0) return 0;\n        require(primeCashToWithdraw < 0);\n\n        Token memory underlying = getUnderlyingToken(currencyId);\n        netTransferExternal = convertToExternal(\n            underlying, \n            primeRate.convertToUnderlying(primeCashToWithdraw) \n        );\n\n        // Overflow not possible due to int256\n        uint256 withdrawAmount = uint256(netTransferExternal.neg());\n        _redeemMoneyMarketIfRequired(currencyId, underlying, withdrawAmount);\n\n        if (underlying.tokenType == TokenType.Ether) {\n            GenericToken.transferNativeTokenOut(account, withdrawAmount, withdrawWrappedNativeToken);\n        } else {\n            GenericToken.safeTransferOut(underlying.tokenAddress, account, withdrawAmount);\n        }\n\n        _postTransferPrimeCashUpdate(account, currencyId, netTransferExternal, underlying, primeRate);\n    }\n\n    /// @notice Prime cash holdings may be in underlying tokens or they may be held in other money market\n    /// protocols like Compound, Aave or Euler. If there is insufficient underlying tokens to withdraw on\n    /// the contract, this method will redeem money market tokens in order to gain sufficient underlying\n    /// to withdraw from the contract.\n    /// @param currencyId associated currency id\n    /// @param underlying underlying token information\n    /// @param withdrawAmountExternal amount of underlying to withdraw in external token precision\n    function _redeemMoneyMarketIfRequired(\n        uint16 currencyId,\n        Token memory underlying,\n        uint256 withdrawAmountExternal\n    ) private {\n        // If there is sufficient balance of the underlying to withdraw from the contract\n        // immediately, just return.\n        mapping(address => uint256) storage store = LibStorage.getStoredTokenBalances();\n        uint256 currentBalance = store[underlying.tokenAddress];\n        if (withdrawAmountExternal <= currentBalance) return;\n\n        IPrimeCashHoldingsOracle oracle = PrimeCashExchangeRate.getPrimeCashHoldingsOracle(currencyId);\n        // Redemption data returns an array of contract calls to make from the Notional proxy (which\n        // is holding all of the money market tokens).\n        (RedeemData[] memory data) = oracle.getRedemptionCalldata(withdrawAmountExternal);\n\n        // This is the total expected underlying that we should redeem after all redemption calls\n        // are executed.\n        uint256 totalUnderlyingRedeemed = executeMoneyMarketRedemptions(underlying, data);\n\n        // Ensure that we have sufficient funds before we exit\n        require(withdrawAmountExternal <= currentBalance.add(totalUnderlyingRedeemed)); // dev: insufficient redeem\n    }\n\n    /// @notice Every time tokens are transferred into or out of the protocol, the prime supply\n    /// and total underlying held must be updated.\n    function _postTransferPrimeCashUpdate(\n        address account,\n        uint16 currencyId,\n        int256 netTransferUnderlyingExternal,\n        Token memory underlyingToken,\n        PrimeRate memory primeRate\n    ) private returns (int256 netPrimeS"
    }
  ]
}