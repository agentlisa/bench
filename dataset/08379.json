{
  "Title": "[G-11] Splitting `require()` statements that use `&&` saves gas",
  "Content": "Instead of using the `&&` operator in a single require statement to check multiple conditions, I suggest using multiple require statements with 1 condition per require statement (saving 3 gas per `&`).<br>\nSee [this issue](https://github.com/code-423n4/2022-01-xdefi-findings/issues/128) which describes the fact that there is a larger deployment gas cost, but with enough runtime calls, the change ends up being cheaper.\n\n*There are 4 instances of this issue:*\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowDelegation.sol#L239\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowDelegation.sol\n239: require(attachments[_tokenId] == 0 && !voted[_tokenId], 'attached');\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L538\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n538: require(attachments[_tokenId] == 0 && !voted[_tokenId], 'attached');\n894: require(attachments[_from] == 0 && !voted[_from], 'attached');\n1008: require(attachments[_tokenId] == 0 && !voted[_tokenId], 'attached');\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-07-golom-contest",
  "Code": [
    {
      "filename": "contracts/vote-escrow/VoteEscrowDelegation.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\n/// votescrow extended with delegation\n\n// import {Math} from '@openzeppelin-contracts/utils/math/SafeCast.sol';\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\n\nimport {VoteEscrowCore} from './VoteEscrowCore.sol';\n\ninterface IVoteEscrow {\n    function balanceOf(uint256) external view returns (uint256);\n\n    function balanceOfAtNFT(uint256, uint256) external view returns (uint256);\n\n    function ownerOf(uint256) external view returns (address);\n}\n\ncontract VoteEscrow is VoteEscrowCore, Ownable {\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(uint256 indexed tokenId, uint256 indexed toTokenId, address indexed currentOwner);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of votes.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /// @notice Delegate of the specific token\n    mapping(uint256 => uint256) public delegates;\n\n    /// @notice Total delegated tokens to specific token\n    mapping(uint256 => uint256[]) public delegatedTokenIds;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint256 fromBlock;\n        uint256[] delegatedTokenIds;\n    }\n\n    /// @notice A record of votes checkpoints for each tokenId, by index\n    mapping(uint256 => mapping(uint256 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each delegated tokenId\n    mapping(uint256 => uint256) public numCheckpoints;\n\n    /// @notice minimum voting power required for delegation\n    uint256 public MIN_VOTING_POWER_REQUIRED = 0;\n\n    constructor(address _token) {\n        token = _token;\n        voter = msg.sender;\n        point_history[0].blk = block.number;\n        point_history[0].ts = block.timestamp;\n\n        supportedInterfaces[ERC165_INTERFACE_ID] = true;\n        supportedInterfaces[ERC721_INTERFACE_ID] = true;\n        supportedInterfaces[ERC721_METADATA_INTERFACE_ID] = true;\n\n        // mint-ish\n        emit Transfer(address(0), address(this), tokenId);\n        // burn-ish\n        emit Transfer(address(this), address(0), tokenId);\n    }\n\n    /// @notice Explain to an end user what this does\n    /// @param tokenId token ID which is being delegated\n    /// @param toTokenId token ID to which the {tokenId} is being delegated\n    function delegate(uint256 tokenId, uint256 toTokenId) external {\n        require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');\n        require(this.balanceOfNFT(tokenId) >= MIN_VOTING_POWER_REQUIRED, 'VEDelegation: Need more voting power');\n\n        delegates[tokenId] = toTokenId;\n        uint256 nCheckpoints = numCheckpoints[toTokenId];\n\n        if (nCheckpoints > 0) {\n            Checkpoint storage checkpoint = checkpoints[toTokenId][nCheckpoints - 1];\n            checkpoint.delegatedTokenIds.push(tokenId);\n            _writeCheckpoint(toTokenId, nCheckpoints, checkpoint.delegatedTokenIds);\n        } else {\n            uint256[] memory array = new uint256[](1);\n            array[0] = tokenId;\n            _writeCheckpoint(toTokenId, nCheckpoints, array);\n        }\n\n        emit DelegateChanged(tokenId, toTokenId, msg.sender);\n    }\n\n    /**\n     * @notice Writes the checkpoint to store current NFTs in the specific block\n     */\n    function _writeCheckpoint(\n        uint256 toTokenId,\n        uint256 nCheckpoints,\n        uint256[] memory _delegatedTokenIds\n    ) internal {\n        require(_delegatedTokenIds.length < 500, 'VVDelegation: Cannot stake more');\n\n        Checkpoint memory oldCheckpoint = checkpoints[toTokenId][nCheckpoints - 1];\n\n        if (nCheckpoints > 0 && oldCheckpoint.fromBlock == block.number) {\n            oldCheckpoint.delegatedTokenIds = _delegatedTokenIds;\n        } else {\n            checkpoints[toTokenId][nCheckpoints] = Checkpoint(block.number, _delegatedTokenIds);\n            numCheckpoints[toTokenId] = nCheckpoints + 1;\n        }\n    }\n\n    /**\n     * @notice Gets the current delegated nfts array for `nftid`\n     * @param tokenId The address to get votes balance\n     * @return The current delegated nfts array for `account`\n     */\n    function _getCurrentDelegated(uint256 tokenId) internal view returns (uint256[] memory) {\n        uint256 nCheckpoints = numCheckpoints[tokenId];\n        uint256[] memory myArray;\n        return nCheckpoints > 0 ? checkpoints[tokenId][nCheckpoints - 1].delegatedTokenIds : myArray;\n    }\n\n    /**\n     * @notice Determine the prior delegated nfts array for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param nftId The id of the nft to check\n     * @param blockNumber The block number to get the delegate nft array at\n     * @return The number of delegated nfts the account had as of the given block\n     */\n    function _getPriorDelegated(uint256 nftId, uint256 blockNumber) internal view returns (uint256[] memory) {\n        require(blockNumber < block.number, 'VEDelegation: not yet determined');\n        uint256[] memory myArray;\n        uint256 nCheckpoints = numCheckpoints[nftId];\n        if (nCheckpoints == 0) {\n            return myArray;\n        }\n\n        // First check most recent balance\n        if (checkpoints[nftId][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[nftId][nCheckpoints - 1].delegatedTokenIds;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[nftId][0].fromBlock > blockNumber) {\n            return myArray;\n        }\n\n        uint256 lower = 0;\n        uint256 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[nftId][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.delegatedTokenIds;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[nftId][lower].delegatedTokenIds;\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param tokenId The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getVotes(uint256 tokenId) external view returns (uint256) {\n        uint256[] memory delegated = _getCurrentDelegated(tokenId);\n        uint256 votes = 0;\n        for (uint256 index = 0; index < delegated.length; index++) {\n            votes = votes + this.balanceOfNFT(delegated[index]);\n        }\n        return votes;\n    }\n\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param tokenId The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(uint256 tokenId, uint256 blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, 'VEDelegation: not yet determined');\n        uint256[] memory delegatednft = _getPriorDelegated(tokenId, blockNumber);\n        uint256 votes = 0;\n        for (uint256 index = 0; index < delegatednft.length; index++) {\n            votes = votes + this.balanceOfAtNFT(delegatednft[index], blockNumber);\n        }\n        return votes;\n    }\n\n    /// @notice Removes specific element from the array\n    /// @param _array Whole array\n    /// @param _element The element which we need to remove\n    function removeElement(uint256[] storage _array, uint256 _element) internal {\n        for (uint256 i; i < _array.length; i++) {\n            if (_array[i] == _element) {\n                _array[i] = _array[_array.length - 1];\n                _array.pop();\n                break;\n            }\n        }\n    }\n\n    /// @notice Remove delegation\n    /// @param tokenId TokenId of which delegation needs to be removed\n    function removeDelegation(uint256 tokenId) external {\n        require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');\n        uint256 nCheckpoints = numCheckpoints[tokenId];\n        Checkpoint storage checkpoint = checkpoints[tokenId][nCheckpoints - 1];\n        removeElement(checkpoint.delegatedTokenIds, tokenId);\n        _writeCheckpoint(tokenId, nCheckpoints, checkpoint.delegatedTokenIds);\n    }\n\n    // /// @notice Remove delegation by user\n    // function removeDelegationByOwner(uint256 delegatedTokenId, uint256 ownerTokenId) external {\n    //     require(ownerOf(ownerTokenId) == msg.sender, 'VEDelegation: Not allowed');\n    //     uint256 nCheckpoints = numCheckpoints[delegatedTokenId];\n    //     Checkpoint storage checkpoint = checkpoints[delegatedTokenId][nCheckpoints - 1];\n    //     removeElement(checkpoint.delegatedTokenIds, delegatedTokenId);\n    //     _writeCheckpoint(ownerTokenId, nCheckpoints, checkpoint.delegatedTokenIds);\n    // }\n\n    /// @dev Exeute transfer of a NFT.\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n    ///      address for this NFT. (NOTE: `msg.sender` not allowed in internal function so pass `_sender`.)\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    function _transferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        address _sender\n    ) internal override {\n        require(attachments[_tokenId] == 0 && !voted[_tokenId], 'attached');\n\n        // remove the delegation\n        this.removeDelegation(_tokenId);\n\n        // Check requirements\n        require(_isApprovedOrOwner(_sender, _tokenId));\n        // Clear approval. Throws if `_from` is not the current owner\n        _clearApproval(_from, _tokenId);\n        // Remove NFT. Throws if `_tokenId` is not a valid NFT\n        _removeTokenFrom(_from, _tokenId);\n        // Add NFT\n        _addTokenTo(_to, _tokenId);\n        // Set the block of ownership transfer (for Flash NFT protection)\n        ownership_change[_tokenId] = block.number;\n        // Log the transfer\n        emit Transfer(_from, _to, _tokenId);\n    }\n\n    /// @notice Changes minimum voting power required for delegation\n    /// @param _newMinVotingPower New minimum voting power required\n    function changeMinVotingPower(uint256 _newMinVotingPower) external onlyOwner {\n        MIN_VOTING_POWER_REQUIRED = _newMinVotingPower;\n    }\n}"
    },
    {
      "filename": "contracts/vote-escrow/VoteEscrowCore.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport './TokenUriHelper.sol';\n\n/**\n@title Voting Escrow\n@author Curve Finance\n@license MIT\n@notice Votes have a weight depending on time, so that users are\ncommitted to the future of (whatever they are voting for)\n@dev Vote weight decays linearly over time. Lock time cannot be\nmore than `MAXTIME` (4 years).\n\n# Voting escrow to have time-weighted votes\n# Votes have a weight depending on time, so that users are committed\n# to the future of (whatever they are voting for).\n# The weight in this implementation is linear, and lock cannot be more than maxtime:\n# w ^\n# 1 +        /\n#   |      /\n#   |    /\n#   |  /\n#   |/\n# 0 +--------+------> time\n#       maxtime (4 years?)\n*/\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n}\n\nstruct Point {\n    int128 bias;\n    int128 slope; // # -dweight / dt\n    uint256 ts;\n    uint256 blk; // block\n}\n/* We cannot really do block numbers per se b/c slope is per time, not per block\n * and per block could be fairly bad b/c Ethereum changes blocktimes.\n * What we can do is to extrapolate ***At functions */\n\nstruct LockedBalance {\n    int128 amount;\n    uint256 end;\n}\n\ncontract VoteEscrowCore is IERC721, IERC721Metadata {\n    enum DepositType {\n        DEPOSIT_FOR_TYPE,\n        CREATE_LOCK_TYPE,\n        INCREASE_LOCK_AMOUNT,\n        INCREASE_UNLOCK_TIME,\n        MERGE_TYPE\n    }\n\n    event Deposit(\n        address indexed provider,\n        uint256 tokenId,\n        uint256 value,\n        uint256 indexed locktime,\n        DepositType deposit_type,\n        uint256 ts\n    );\n    event Withdraw(address indexed provider, uint256 tokenId, uint256 value, uint256 ts);\n    event Supply(uint256 prevSupply, uint256 supply);\n\n    uint256 internal constant WEEK = 1 weeks;\n    uint256 internal constant MAXTIME = 4 * 365 * 86400;\n    int128 internal constant iMAXTIME = 4 * 365 * 86400;\n    uint256 internal constant MULTIPLIER = 1 ether;\n\n    address public token;\n    uint256 public supply;\n    mapping(uint256 => LockedBalance) public locked;\n\n    mapping(uint256 => uint256) public ownership_change;\n\n    uint256 public epoch;\n    mapping(uint256 => Point) public point_history; // epoch -> unsigned point\n    mapping(uint256 => Point[1000000000]) public user_point_history; // user -> Point[user_epoch]\n\n    mapping(uint256 => uint256) public user_point_epoch;\n    mapping(uint256 => int128) public slope_changes; // time -> signed slope change\n\n    mapping(uint256 => uint256) public attachments;\n    mapping(uint256 => bool) public voted;\n    address public voter;\n\n    string public constant name = 'veNFT';\n    string public constant symbol = 'veNFT';\n    string public constant version = '1.0.0';\n    uint8 public constant decimals = 18;\n\n    /// @dev Current count of token\n    uint256 internal tokenId;\n\n    /// @dev Mapping from NFT ID to the address that owns it.\n    mapping(uint256 => address) internal idToOwner;\n\n    /// @dev Mapping from NFT ID to approved address.\n    mapping(uint256 => address) internal idToApprovals;\n\n    /// @dev Mapping from owner address to count of his tokens.\n    mapping(address => uint256) internal ownerToNFTokenCount;\n\n    /// @dev Mapping from owner address to mapping of index to tokenIds\n    mapping(address => mapping(uint256 => uint256)) internal ownerToNFTokenIdList;\n\n    /// @dev Mapping from NFT ID to index of owner\n    mapping(uint256 => uint256) internal tokenToOwnerIndex;\n\n    /// @dev Mapping from owner address to mapping of operator addresses.\n    mapping(address => mapping(address => bool)) internal ownerToOperators;\n\n    /// @dev Mapping of interface id to bool about whether or not it's supported\n    mapping(bytes4 => bool) internal supportedInterfaces;\n\n    /// @dev ERC165 interface ID of ERC165\n    bytes4 internal constant ERC165_INTERFACE_ID = 0x01ffc9a7;\n\n    /// @dev ERC165 interface ID of ERC721\n    bytes4 internal constant ERC721_INTERFACE_ID = 0x80ac58cd;\n\n    /// @dev ERC165 interface ID of ERC721Metadata\n    bytes4 internal constant ERC721_METADATA_INTERFACE_ID = 0x5b5e139f;\n\n    /// @dev reentrancy guard\n    uint8 internal constant _not_entered = 1;\n    uint8 internal constant _entered = 2;\n    uint8 internal _entered_state = 1;\n    modifier nonreentrant() {\n        require(_entered_state == _not_entered);\n        _entered_state = _entered;\n        _;\n        _entered_state = _not_entered;\n    }\n\n    /// @dev Interface identification is specified in ERC-165.\n    /// @param _interfaceID Id of the interface\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\n        return supportedInterfaces[_interfaceID];\n    }\n\n    /// @notice Get the most recently recorded rate of voting power decrease for `_tokenId`\n    /// @param _tokenId token of the NFT\n    /// @return Value of the slope\n    function get_last_user_slope(uint256 _tokenId) external view returns (int128) {\n        uint256 uepoch = user_point_epoch[_tokenId];\n        return user_point_history[_tokenId][uepoch].slope;\n    }\n\n    /// @notice Get the timestamp for checkpoint `_idx` for `_tokenId`\n    /// @param _tokenId token of the NFT\n    /// @param _idx User epoch number\n    /// @return Epoch time of the checkpoint\n    function user_point_history__ts(uint256 _tokenId, uint256 _idx) external view returns (uint256) {\n        return user_point_history[_tokenId][_idx].ts;\n    }\n\n    /// @notice Get timestamp when `_tokenId`'s lock finishes\n    /// @param _tokenId User NFT\n    /// @return Epoch time of the lock end\n    function locked__end(uint256 _tokenId) external view returns (uint256) {\n        return locked[_tokenId].end;\n    }\n\n    /// @dev Returns the number of NFTs owned by `_owner`.\n    ///      Throws if `_owner` is the zero address. NFTs assigned to the zero address are considered invalid.\n    /// @param _owner Address for whom to query the balance.\n    function _balance(address _owner) internal view returns (uint256) {\n        return ownerToNFTokenCount[_owner];\n    }\n\n    /// @dev Returns the number of NFTs owned by `_owner`.\n    ///      Throws if `_owner` is the zero address. NFTs assigned to the zero address are considered invalid.\n    /// @param _owner Address for whom to query the balance.\n    function balanceOf(address _owner) external view returns (uint256) {\n        return _balance(_owner);\n    }\n\n    /// @dev Returns the address of the owner of the NFT.\n    /// @param _tokenId The identifier for an NFT.\n    function ownerOf(uint256 _tokenId) public view returns (address) {\n        return idToOwner[_tokenId];\n    }\n\n    /// @dev Get the approved address for a single NFT.\n    /// @param _tokenId ID of the NFT to query the approval of.\n    function getApproved(uint256 _tokenId) external view returns (address) {\n        return idToApprovals[_tokenId];\n    }\n\n    /// @dev Checks if `_operator` is an approved operator for `_owner`.\n    /// @param _owner The address that owns the NFTs.\n    /// @param _operator The address that acts on behalf of the owner.\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\n        return (ownerToOperators[_owner])[_operator];\n    }\n\n    /// @dev  Get token by index\n    function tokenOfOwnerByIndex(address _owner, uint256 _tokenIndex) external view returns (uint256) {\n        return ownerToNFTokenIdList[_owner][_tokenIndex];\n    }\n\n    /// @dev Returns whether the given spender can transfer a given token ID\n    /// @param _spender address of the spender to query\n    /// @param _tokenId uint ID of the token to be transferred\n    /// @return bool whether the msg.sender is approved for the given token ID, is an operator of the owner, or is the owner of the token\n    function _isApprovedOrOwner(address _spender, uint256 _tokenId) internal view returns (bool) {\n        address owner = idToOwner[_tokenId];\n        bool spenderIsOwner = owner == _spender;\n        bool spenderIsApproved = _spender == idToApprovals[_tokenId];\n        bool spenderIsApprovedForAll = (ownerToOperators[owner])[_spender];\n        return spenderIsOwner || spenderIsApproved || spenderIsApprovedForAll;\n    }\n\n    function isApprovedOrOwner(address _spender, uint256 _tokenId) external view returns (bool) {\n        return _isApprovedOrOwner(_spender, _tokenId);\n    }\n\n    /// @dev Add a NFT to an index mapping to a given address\n    /// @param _to address of the receiver\n    /// @param _tokenId uint ID Of the token to be added\n    function _addTokenToOwnerList(address _to, uint256 _tokenId) internal {\n        uint256 current_count = _balance(_to);\n\n        ownerToNFTokenIdList[_to][current_count] = _tokenId;\n        tokenToOwnerIndex[_tokenId] = current_count;\n    }\n\n    /// @dev Remove a NFT from an index mapping to a given address\n    /// @param _from address of the sender\n    /// @param _tokenId uint ID Of the token to be removed\n    function _removeTokenFromOwnerList(address _from, uint256 _tokenId) internal {\n        // Delete\n        uint256 current_count = _balance(_from) - 1;\n        uint256 current_index = tokenToOwnerIndex[_tokenId];\n\n        if (current_count == current_index) {\n            // update ownerToNFTokenIdList\n            ownerToNFTokenIdList[_from][current_count] = 0;\n            // update tokenToOwnerIndex\n            tokenToOwnerIndex[_tokenId] = 0;\n        } else {\n            uint256 lastTokenId = ownerToNFTokenIdList[_from][current_count];\n\n            // Add\n            // update ownerToNFTokenIdList\n            ownerToNFTokenIdList[_from][current_index] = lastTokenId;\n            // update tokenToOwnerIndex\n            tokenToOwnerIndex[lastTokenId] = current_index;\n\n            // Delete\n            // update ownerToNFTokenIdList\n            ownerToNFTokenIdList[_from][current_count] = 0;\n            // update tokenToOwnerIndex\n            tokenToOwnerIndex[_tokenId] = 0;\n        }\n    }\n\n    /// @dev Add a NFT to a given address\n    ///      Throws if `_tokenId` is owned by someone.\n    function _addTokenTo(address _to, uint256 _tokenId) internal {\n        // Throws if `_tokenId` is owned by someone\n        assert(idToOwner[_tokenId] == address(0));\n        // Change the owner\n        idToOwner[_tokenId] = _to;\n        // Update owner token index tracking\n        _addTokenToOwnerList(_to, _tokenId);\n        // Change count tracking\n        ownerToNFTokenCount[_to] += 1;\n    }\n\n    /// @dev Remove a NFT from a given address\n    ///      Throws if `_from` is not the current owner.\n    function _removeTokenFrom(address _from, uint256 _tokenId) internal {\n        // Throws if `_from` is not the current owner\n        assert(idToOwner[_tokenId] == _from);\n        // Change the owner\n        idToOwner[_tokenId] = address(0);\n        // Update owner token index tracking\n        _removeTokenFromOwnerList(_from, _tokenId);\n        // Change count tracking\n        ownerToNFTokenCount[_from] -= 1;\n    }\n\n    /// @dev Clear an approval of a given address\n    ///      Throws if `_owner` is not the current owner.\n    function _clearApproval(address _owner, uint256 _tokenId) internal {\n        // Throws if `_owner` is not the current owner\n        assert(idToOwner[_tokenId] == _owner);\n        if (idToApprovals[_tokenId] != address(0)) {\n            // Reset approvals\n            idToApprovals[_tokenId] = address(0);\n        }\n    }\n\n    /// @dev Exeute transfer of a NFT.\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n    ///      address for this NFT. (NOTE: `msg.sender` not allowed in internal function so pass `_sender`.)\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    function _transferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        address _sender\n    ) internal virtual {\n        require(attachments[_tokenId] == 0 && !voted[_tokenId], 'attached');\n        // Check requirements\n        require(_isApprovedOrOwner(_sender, _tokenId));\n        // Clear approval. Throws if `_from` is not the current owner\n        _clearApproval(_from, _tokenId);\n        // Remove NFT. Throws if `_tokenId` is not a valid NFT\n        _removeTokenFrom(_from, _tokenId);\n        // Add NFT\n        _addTokenTo(_to, _tokenId);\n        // Set the block of ownership transfer (for Flash NFT protection)\n        ownership_change[_tokenId] = block.number;\n        // Log the transfer\n        emit Transfer(_from, _to, _tokenId);\n    }\n\n    /* TRANSFER FUNCTIONS */\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved address for this NFT.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    /// @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\n    ///        they maybe be permanently lost.\n    /// @param _from The current owner of the NFT.\n    /// @param _to The new owner.\n    /// @param _tokenId The NFT to transfer.\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) external {\n        _transferFrom(_from, _to, _tokenId, msg.sender);\n    }\n\n    function _isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /// @dev Transfers the ownership of an NFT from one address to another address.\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the\n    ///      approved address for this NFT.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    ///      If `_to` is a smart contract, it calls `onERC721Received` on `_to` and throws if\n    ///      the return value is not `bytes4(keccak256(\"onERC721Received(address,address,uint,bytes)\"))`.\n    /// @param _from The current owner of the NFT.\n    /// @param _to The new owner.\n    /// @param _toke"
    }
  ]
}