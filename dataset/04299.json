{
  "Title": "[L05] Erroneous docstrings and comments",
  "Content": "Several docstrings and comments throughout the code base were found to be erroneous. In particular:\n\n\n* [Line 209](https://github.com/UMAprotocol/protocol/blob/e6eaa48124ae3f209fb117cf05eb18292cf26d21/core/contracts/financial-templates/implementation/FeePayer.sol#L209) of `FeePayer.sol` repeatedly mentions “collateralToRemove” instead of “collateralToAdd”.\n* [Line 213](https://github.com/UMAprotocol/protocol/blob/e6eaa48124ae3f209fb117cf05eb18292cf26d21/core/contracts/financial-templates/implementation/FeePayer.sol#L213) of `FeePayer.sol` should say “collateral added” instead of “collateral removed”.\n* [Line 215](https://github.com/UMAprotocol/protocol/blob/e6eaa48124ae3f209fb117cf05eb18292cf26d21/core/contracts/financial-templates/implementation/FeePayer.sol#L215) of `FeePayer.sol` references a non-existent `totalPositionCollateral` variable.\n* [Line 34](https://github.com/UMAprotocol/protocol/blob/e6eaa48124ae3f209fb117cf05eb18292cf26d21/core/contracts/financial-templates/implementation/PricelessPositionManager.sol#L34) of `PricelessPositionManager.sol` should mention the initial settlement as another state-changing event.\n* [Line 249](https://github.com/UMAprotocol/protocol/blob/e6eaa48124ae3f209fb117cf05eb18292cf26d21/core/contracts/financial-templates/implementation/PricelessPositionManager.sol#L249) of `PricelessPositionManager.sol` should clarify that the withdrawn amount might be reduced to the collateral left in the contract.\n* [Line 70](https://github.com/UMAprotocol/protocol/blob/e6eaa48124ae3f209fb117cf05eb18292cf26d21/core/contracts/financial-templates/implementation/Liquidatable.sol#L70) of `Liquidatable.sol` identifies `minSponsorTokens` as a parameter for the `Liquidatable` constructor, but it is actually a parameter for the constructor of the `PricelessPositionManager` contract.\n* [Line 415](https://github.com/UMAprotocol/protocol/blob/e6eaa48124ae3f209fb117cf05eb18292cf26d21/core/contracts/financial-templates/implementation/Liquidatable.sol#L415) of `Liquidatable.sol` says “the dispute failed”, even though there was no dispute.\n\n\n**Update:** *Fixed in [PR#1352](https://github.com/UMAprotocol/protocol/pull/1352).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "core/contracts/financial-templates/implementation/FeePayer.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../../common/implementation/FixedPoint.sol\";\nimport \"../../common/implementation/Testable.sol\";\nimport \"../../oracle/interfaces/StoreInterface.sol\";\nimport \"../../oracle/interfaces/FinderInterface.sol\";\n\n\n/**\n * @title FeePayer contract.\n * @notice Provides fee payment functionality for the ExpiringMultiParty contract.\n * contract is abstract as each derived contract that inherits `FeePayer` must implement `pfc()`.\n */\n\nabstract contract FeePayer is Testable {\n    using SafeMath for uint;\n    using FixedPoint for FixedPoint.Unsigned;\n    using SafeERC20 for IERC20;\n\n    /****************************************\n     *      FEE PAYER DATA STRUCTURES       *\n     ****************************************/\n\n    // The collateral currency used to back the positions in this contract.\n    IERC20 public collateralCurrency;\n\n    //  Finder contract used to look up addresses for UMA system contracts.\n    FinderInterface public finder;\n\n    // Tracks the last block time when the fees were paid.\n    uint public lastPaymentTime;\n\n    // Tracks the cumulative fees that have been paid by the contract for use by derived contracts.\n    // The multiplier starts at 1, and is updated by computing cumulativeFeeMultiplier * (1 - effectiveFee).\n    // Put another way, the cumulativeFeeMultiplier is (1 - effectiveFee1) * (1 - effectiveFee2) ...\n    // For example:\n    // The cumulativeFeeMultiplier should start at 1.\n    // If a 1% fee is charged, the multiplier should update to .99.\n    // If another 1% fee is charged, the multiplier should be 0.99^2 (0.9801).\n    FixedPoint.Unsigned public cumulativeFeeMultiplier;\n\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n\n    event RegularFeesPaid(uint indexed regularFee, uint indexed lateFee);\n    event FinalFeesPaid(uint indexed amount);\n\n    /****************************************\n     *              MODIFIERS               *\n     ****************************************/\n\n    // modifier that calls payFees().\n    modifier fees {\n        payFees();\n        _;\n    }\n\n    /**\n     * @notice Constructs the FeePayer contract. Called by child contracts.\n     * @param collateralAddress ERC20 token that is used as the underlying collateral for the synthetic.\n     * @param finderAddress UMA protocol Finder used to discover other protocol contracts.\n     * @param isTest whether this contract is being constructed for the purpose of running tests.\n     */\n    constructor(address collateralAddress, address finderAddress, bool isTest) public Testable(isTest) {\n        collateralCurrency = IERC20(collateralAddress);\n        finder = FinderInterface(finderAddress);\n        lastPaymentTime = getCurrentTime();\n        cumulativeFeeMultiplier = FixedPoint.fromUnscaledUint(1);\n    }\n\n    /****************************************\n     *        FEE PAYMENT FUNCTIONS         *\n     ****************************************/\n\n    /**\n     * @notice Pays UMA DVM regular fees to the Store contract.\n     * @dev These must be paid periodically for the life of the contract. If the contract has not paid its\n     * regular fee in a week or mre then a late penalty is applied which is sent to the caller.\n     * @return totalPaid The amount of collateral that the contract paid (sum of the amount paid to the Store and the caller).\n     */\n    function payFees() public returns (FixedPoint.Unsigned memory totalPaid) {\n        StoreInterface store = _getStore();\n        uint time = getCurrentTime();\n        FixedPoint.Unsigned memory _pfc = pfc();\n\n        // Exit early if there is no pfc (thus, no fees to be paid).\n        if (_pfc.isEqual(0)) {\n            return totalPaid;\n        }\n\n        (FixedPoint.Unsigned memory regularFee, FixedPoint.Unsigned memory latePenalty) = store.computeRegularFee(\n            lastPaymentTime,\n            time,\n            _pfc\n        );\n        lastPaymentTime = time;\n\n        if (regularFee.isGreaterThan(0)) {\n            collateralCurrency.safeIncreaseAllowance(address(store), regularFee.rawValue);\n            store.payOracleFeesErc20(address(collateralCurrency));\n        }\n\n        if (latePenalty.isGreaterThan(0)) {\n            collateralCurrency.safeTransfer(msg.sender, latePenalty.rawValue);\n        }\n\n        emit RegularFeesPaid(regularFee.rawValue, latePenalty.rawValue);\n\n        totalPaid = regularFee.add(latePenalty);\n        FixedPoint.Unsigned memory effectiveFee = totalPaid.divCeil(_pfc);\n        cumulativeFeeMultiplier = cumulativeFeeMultiplier.mul(FixedPoint.fromUnscaledUint(1).sub(effectiveFee));\n    }\n\n    /**\n     * @notice Pays UMA DVM final fees to the Store contract.\n     * @dev This is a flat fee charged for each price request.\n     * @param payer address of who is paying the fees.\n     * @param amount the amount of collateral to send as the final fee.\n     */\n    function _payFinalFees(address payer, FixedPoint.Unsigned memory amount) internal {\n        if (amount.isEqual(0)) {\n            return;\n        }\n\n        if (payer != address(this)) {\n            // If the payer is not the contract pull the collateral from the payer.\n            collateralCurrency.safeTransferFrom(payer, address(this), amount.rawValue);\n        } else {\n            // If the payer is the contract, adjust the cumulativeFeeMultiplier to compensate.\n            FixedPoint.Unsigned memory _pfc = pfc();\n\n            // The final fee must be < pfc or the fee will be larger than 100%.\n            require(_pfc.isGreaterThan(amount));\n\n            // Add the adjustment.\n            FixedPoint.Unsigned memory effectiveFee = amount.divCeil(pfc());\n            cumulativeFeeMultiplier = cumulativeFeeMultiplier.mul(FixedPoint.fromUnscaledUint(1).sub(effectiveFee));\n        }\n\n        emit FinalFeesPaid(amount.rawValue);\n\n        StoreInterface store = _getStore();\n        collateralCurrency.safeIncreaseAllowance(address(store), amount.rawValue);\n        store.payOracleFeesErc20(address(collateralCurrency));\n    }\n\n    /**\n     * @notice Gets the current profit from corruption for this contract in terms of the collateral currency.\n     * @dev Derived contracts are expected to implement this function so the payFees()\n     * method can correctly compute the owed regular fees.\n     */\n    function pfc() public virtual view returns (FixedPoint.Unsigned memory);\n\n    /****************************************\n     *         INTERNAL FUNCTIONS           *\n     ****************************************/\n\n    function _getStore() internal view returns (StoreInterface) {\n        bytes32 storeInterface = \"Store\";\n        return StoreInterface(finder.getImplementationAddress(storeInterface));\n    }\n\n    function _computeFinalFees() internal returns (FixedPoint.Unsigned memory finalFees) {\n        StoreInterface store = _getStore();\n        return store.computeFinalFee(address(collateralCurrency));\n    }\n\n    // Returns the user's collateral minus any fees that have been subtracted since it was originally\n    // deposited into the contract. Note: if the contract has paid fees since it was deployed, the raw\n    // value should be larger than the returned value.\n    function _getCollateral(FixedPoint.Unsigned memory rawCollateral)\n        internal\n        view\n        returns (FixedPoint.Unsigned memory collateral)\n    {\n        return rawCollateral.mul(cumulativeFeeMultiplier);\n    }\n\n    // Converts a user-readable collateral value into a raw value that accounts for already-assessed\n    // fees. If any fees have been taken from this contract in the past, then the raw value will be\n    // larger than the user-readable value.\n    function _convertCollateral(FixedPoint.Unsigned memory collateral)\n        internal\n        view\n        returns (FixedPoint.Unsigned memory rawCollateral)\n    {\n        return collateral.div(cumulativeFeeMultiplier);\n    }\n\n    // Decrease rawCollateral by a fee-adjusted collateralToRemove amount. Fee adjustment scales up collateralToRemove\n    // by dividing it by cumulativeFeeMutliplier. There is potential for this quotient to be floored, therefore rawCollateral\n    // is decreased by less than expected. Because this method is usually called in conjunction with an actual removal of collateral\n    // from this contract, return the fee-adjusted amount that the rawCollateral is decreased by so that the caller can\n    // minimize error between collateral removed and rawCollateral debited.\n    function _removeCollateral(FixedPoint.Unsigned storage rawCollateral, FixedPoint.Unsigned memory collateralToRemove)\n        internal\n        returns (FixedPoint.Unsigned memory removedCollateral)\n    {\n        FixedPoint.Unsigned memory initialBalance = _getCollateral(rawCollateral);\n        FixedPoint.Unsigned memory adjustedCollateral = _convertCollateral(collateralToRemove);\n        rawCollateral.rawValue = rawCollateral.sub(adjustedCollateral).rawValue;\n        removedCollateral = initialBalance.sub(_getCollateral(rawCollateral));\n    }\n\n    // Increase rawCollateral by a fee-adjusted collateralToRemove amount. Fee adjustment scales up collateralToRemove\n    // by dividing it by cumulativeFeeMutliplier. There is potential for this quotient to be floored, therefore rawCollateral\n    // is increased by less than expected. Because this method is usually called in conjunction with an actual addition of collateral\n    // to this contract, return the fee-adjusted amount that the rawCollateral is increased by so that the caller can\n    // minimize error between collateral removed and rawCollateral credited.\n    // @dev: This return value exists only for the sake of symmetry with `_removeCollateral`. We don't actually use it because\n    // we are OK if more collateral is stored in the contract than is represented by `totalPositionCollateral`.\n    function _addCollateral(FixedPoint.Unsigned storage rawCollateral, FixedPoint.Unsigned memory collateralToAdd)\n        internal\n        returns (FixedPoint.Unsigned memory addedCollateral)\n    {\n        FixedPoint.Unsigned memory initialBalance = _getCollateral(rawCollateral);\n        FixedPoint.Unsigned memory adjustedCollateral = _convertCollateral(collateralToAdd);\n        rawCollateral.rawValue = rawCollateral.add(adjustedCollateral).rawValue;\n        addedCollateral = _getCollateral(rawCollateral).sub(initialBalance);\n    }\n}"
    },
    {
      "filename": "core/contracts/financial-templates/implementation/FeePayer.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../../common/implementation/FixedPoint.sol\";\nimport \"../../common/implementation/Testable.sol\";\nimport \"../../oracle/interfaces/StoreInterface.sol\";\nimport \"../../oracle/interfaces/FinderInterface.sol\";\n\n\n/**\n * @title FeePayer contract.\n * @notice Provides fee payment functionality for the ExpiringMultiParty contract.\n * contract is abstract as each derived contract that inherits `FeePayer` must implement `pfc()`.\n */\n\nabstract contract FeePayer is Testable {\n    using SafeMath for uint;\n    using FixedPoint for FixedPoint.Unsigned;\n    using SafeERC20 for IERC20;\n\n    /****************************************\n     *      FEE PAYER DATA STRUCTURES       *\n     ****************************************/\n\n    // The collateral currency used to back the positions in this contract.\n    IERC20 public collateralCurrency;\n\n    //  Finder contract used to look up addresses for UMA system contracts.\n    FinderInterface public finder;\n\n    // Tracks the last block time when the fees were paid.\n    uint public lastPaymentTime;\n\n    // Tracks the cumulative fees that have been paid by the contract for use by derived contracts.\n    // The multiplier starts at 1, and is updated by computing cumulativeFeeMultiplier * (1 - effectiveFee).\n    // Put another way, the cumulativeFeeMultiplier is (1 - effectiveFee1) * (1 - effectiveFee2) ...\n    // For example:\n    // The cumulativeFeeMultiplier should start at 1.\n    // If a 1% fee is charged, the multiplier should update to .99.\n    // If another 1% fee is charged, the multiplier should be 0.99^2 (0.9801).\n    FixedPoint.Unsigned public cumulativeFeeMultiplier;\n\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n\n    event RegularFeesPaid(uint indexed regularFee, uint indexed lateFee);\n    event FinalFeesPaid(uint indexed amount);\n\n    /****************************************\n     *              MODIFIERS               *\n     ****************************************/\n\n    // modifier that calls payFees().\n    modifier fees {\n        payFees();\n        _;\n    }\n\n    /**\n     * @notice Constructs the FeePayer contract. Called by child contracts.\n     * @param collateralAddress ERC20 token that is used as the underlying collateral for the synthetic.\n     * @param finderAddress UMA protocol Finder used to discover other protocol contracts.\n     * @param isTest whether this contract is being constructed for the purpose of running tests.\n     */\n    constructor(address collateralAddress, address finderAddress, bool isTest) public Testable(isTest) {\n        collateralCurrency = IERC20(collateralAddress);\n        finder = FinderInterface(finderAddress);\n        lastPaymentTime = getCurrentTime();\n        cumulativeFeeMultiplier = FixedPoint.fromUnscaledUint(1);\n    }\n\n    /****************************************\n     *        FEE PAYMENT FUNCTIONS         *\n     ****************************************/\n\n    /**\n     * @notice Pays UMA DVM regular fees to the Store contract.\n     * @dev These must be paid periodically for the life of the contract. If the contract has not paid its\n     * regular fee in a week or mre then a late penalty is applied which is sent to the caller.\n     * @return totalPaid The amount of collateral that the contract paid (sum of the amount paid to the Store and the caller).\n     */\n    function payFees() public returns (FixedPoint.Unsigned memory totalPaid) {\n        StoreInterface store = _getStore();\n        uint time = getCurrentTime();\n        FixedPoint.Unsigned memory _pfc = pfc();\n\n        // Exit early if there is no pfc (thus, no fees to be paid).\n        if (_pfc.isEqual(0)) {\n            return totalPaid;\n        }\n\n        (FixedPoint.Unsigned memory regularFee, FixedPoint.Unsigned memory latePenalty) = store.computeRegularFee(\n            lastPaymentTime,\n            time,\n            _pfc\n        );\n        lastPaymentTime = time;\n\n        if (regularFee.isGreaterThan(0)) {\n            collateralCurrency.safeIncreaseAllowance(address(store), regularFee.rawValue);\n            store.payOracleFeesErc20(address(collateralCurrency));\n        }\n\n        if (latePenalty.isGreaterThan(0)) {\n            collateralCurrency.safeTransfer(msg.sender, latePenalty.rawValue);\n        }\n\n        emit RegularFeesPaid(regularFee.rawValue, latePenalty.rawValue);\n\n        totalPaid = regularFee.add(latePenalty);\n        FixedPoint.Unsigned memory effectiveFee = totalPaid.divCeil(_pfc);\n        cumulativeFeeMultiplier = cumulativeFeeMultiplier.mul(FixedPoint.fromUnscaledUint(1).sub(effectiveFee));\n    }\n\n    /**\n     * @notice Pays UMA DVM final fees to the Store contract.\n     * @dev This is a flat fee charged for each price request.\n     * @param payer address of who is paying the fees.\n     * @param amount the amount of collateral to send as the final fee.\n     */\n    function _payFinalFees(address payer, FixedPoint.Unsigned memory amount) internal {\n        if (amount.isEqual(0)) {\n            return;\n        }\n\n        if (payer != address(this)) {\n            // If the payer is not the contract pull the collateral from the payer.\n            collateralCurrency.safeTransferFrom(payer, address(this), amount.rawValue);\n        } else {\n            // If the payer is the contract, adjust the cumulativeFeeMultiplier to compensate.\n            FixedPoint.Unsigned memory _pfc = pfc();\n\n            // The final fee must be < pfc or the fee will be larger than 100%.\n            require(_pfc.isGreaterThan(amount));\n\n            // Add the adjustment.\n            FixedPoint.Unsigned memory effectiveFee = amount.divCeil(pfc());\n            cumulativeFeeMultiplier = cumulativeFeeMultiplier.mul(FixedPoint.fromUnscaledUint(1).sub(effectiveFee));\n        }\n\n        emit FinalFeesPaid(amount.rawValue);\n\n        StoreInterface store = _getStore();\n        collateralCurrency.safeIncreaseAllowance(address(store), amount.rawValue);\n        store.payOracleFeesErc20(address(collateralCurrency));\n    }\n\n    /**\n     * @notice Gets the current profit from corruption for this contract in terms of the collateral currency.\n     * @dev Derived contracts are expected to implement this function so the payFees()\n     * method can correctly compute the owed regular fees.\n     */\n    function pfc() public virtual view returns (FixedPoint.Unsigned memory);\n\n    /****************************************\n     *         INTERNAL FUNCTIONS           *\n     ****************************************/\n\n    function _getStore() internal view returns (StoreInterface) {\n        bytes32 storeInterface = \"Store\";\n        return StoreInterface(finder.getImplementationAddress(storeInterface));\n    }\n\n    function _computeFinalFees() internal returns (FixedPoint.Unsigned memory finalFees) {\n        StoreInterface store = _getStore();\n        return store.computeFinalFee(address(collateralCurrency));\n    }\n\n    // Returns the user's collateral minus any fees that have been subtracted since it was originally\n    // deposited into the contract. Note: if the contract has paid fees since it was deployed, the raw\n    // value should be larger than the returned value.\n    function _getCollateral(FixedPoint.Unsigned memory rawCollateral)\n        internal\n        view\n        returns (FixedPoint.Unsigned memory collateral)\n    {\n        return rawCollateral.mul(cumulativeFeeMultiplier);\n    }\n\n    // Converts a user-readable collateral value into a raw value that accounts for already-assessed\n    // fees. If any fees have been taken from this contract in the past, then the raw value will be\n    // larger than the user-readable value.\n    function _convertCollateral(FixedPoint.Unsigned memory collateral)\n        internal\n        view\n        returns (FixedPoint.Unsigned memory rawCollateral)\n    {\n        return collateral.div(cumulativeFeeMultiplier);\n    }\n\n    // Decrease rawCollateral by a fee-adjusted collateralToRemove amount. Fee adjustment scales up collateralToRemove\n    // by dividing it by cumulativeFeeMutliplier. There is potential for this quotient to be floored, therefore rawCollateral\n    // is decreased by less than expected. Because this method is usually called in conjunction with an actual removal of collateral\n    // from this contract, return the fee-adjusted amount that the rawCollateral is decreased by so that the caller can\n    // minimize error between collateral removed and rawCollateral debited.\n    function _removeCollateral(FixedPoint.Unsigned storage rawCollateral, FixedPoint.Unsigned memory collateralToRemove)\n        internal\n        returns (FixedPoint.Unsigned memory removedCollateral)\n    {\n        FixedPoint.Unsigned memory initialBalance = _getCollateral(rawCollateral);\n        FixedPoint.Unsigned memory adjustedCollateral = _convertCollateral(collateralToRemove);\n        rawCollateral.rawValue = rawCollateral.sub(adjustedCollateral).rawValue;\n        removedCollateral = initialBalance.sub(_getCollateral(rawCollateral));\n    }\n\n    // Increase rawCollateral by a fee-adjusted collateralToRemove amount. Fee adjustment scales up collateralToRemove\n    // by dividing it by cumulativeFeeMutliplier. There is potential for this quotient to be floored, therefore rawCollateral\n    // is increased by less than expected. Because this method is usually called in conjunction with an actual addition of collateral\n    // to this contract, return the fee-adjusted amount that the rawCollateral is increased by so that the caller can\n    // minimize error between collateral removed and rawCollateral credited.\n    // @dev: This return value exists only for the sake of symmetry with `_removeCollateral`. We don't actually use it because\n    // we are OK if more collateral is stored in the contract than is represented by `totalPositionCollateral`.\n    function _addCollateral(FixedPoint.Unsigned storage rawCollateral, FixedPoint.Unsigned memory collateralToAdd)\n        internal\n        returns (FixedPoint.Unsigned memory addedCollateral)\n    {\n        FixedPoint.Unsigned memory initialBalance = _getCollateral(rawCollateral);\n        FixedPoint.Unsigned memory adjustedCollateral = _convertCollateral(collateralToAdd);\n        rawCollateral.rawValue = rawCollateral.add(adjustedCollateral).rawValue;\n        addedCollateral = _getCollateral(rawCollateral).sub(initialBalance);\n    }\n}"
    },
    {
      "filename": "core/contracts/financial-templates/implementation/FeePayer.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../../common/implementation/FixedPoint.sol\";\nimport \"../../common/implementation/Testable.sol\";\nimport \"../../oracle/interfaces/StoreInterface.sol\";\nimport \"../../oracle/interfaces/FinderInterface.sol\";\n\n\n/**\n * @title FeePayer contract.\n * @notice Provides fee payment functionality for the ExpiringMultiParty contract.\n * contract is abstract as each derived contract that inherits `FeePayer` must implement `pfc()`.\n */\n\nabstract contract FeePayer is Testable {\n    using SafeMath for uint;\n    using FixedPoint for FixedPoint.Unsigned;\n    using SafeERC20 for IERC20;\n\n    /****************************************\n     *      FEE PAYER DATA STRUCTURES       *\n     ****************************************/\n\n    // The collateral currency used to back the positions in this contract.\n    IERC20 public collateralCurrency;\n\n    //  Finder contract used to look up addresses for UMA system contracts.\n    FinderInterface public finder;\n\n    // Tracks the last block time when the fees were paid.\n    uint public lastPaymentTime;\n\n    // Tracks the cumulative fees that have been paid by the contract for use by derived contracts.\n    // The multiplier starts at 1, and is updated by computing cumulativeFeeMultiplier * (1 - effectiveFee).\n    // Put another way, the cumulativeFeeMultiplier is (1 - effectiveFee1) * (1 - effectiveFee2) ...\n    // For example:\n    // The cumulativeFeeMultiplier should start at 1.\n    // If a 1% fee is charged, the multiplier should update to .99.\n    // If another 1% fee is charged, the multiplier should be 0.99^2 (0.9801).\n    FixedPoint.Unsigned public cumulativeFeeMultiplier;\n\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n\n    event RegularFeesPaid(uint indexed regularFee, uint indexed lateFee);\n    event FinalFeesPaid(uint indexed amount);\n\n    /****************************************\n     *              MODIFIERS               *\n     ****************************************/\n\n    // modifier that calls payFees().\n    modifier fees {\n        payFees();\n        _;\n    }\n\n    /**\n     * @notice Constructs the FeePayer contract. Called by child contracts.\n     * @param collateralAddress ERC20 token that is used as the underlying collateral for the synthetic.\n     * @param finderAddress UMA protocol Finder used to discover other protocol contracts.\n     * @param isTest whether this contract is being constructed for the purpose of running tests.\n     */\n    constructor(address collateralAddress, address finderAddress, bool isTest) public Testable(isTest) {\n        collateralCurrency = IERC20(collateralAddress);\n        finder = FinderInterface(finderAddress);\n        lastPaymentTime = getCurrentTime();\n        cumulativeFeeMultiplier = FixedPoint.fromUnscaledUint(1);\n    }\n\n    /****************************************\n     *        FEE PAYMENT FUNCTIONS         *\n     ****************************************/\n\n    /**\n     * @notice Pays UMA DVM regular fees to the Store contract.\n     * @dev These must be paid periodically for the life of the contract. If the contract has not paid its\n     * regular fee in a week or mre then a late penalty is applied which is sent to the caller.\n     * @return totalPaid The amount of collateral that the contract paid (sum of the amount paid to the Store and the caller).\n     */\n    function payFees() public returns (FixedPoint.Unsigned memory totalPaid) {\n        StoreInterface store = _getStore();\n        uint time = getCurrentTime();\n        FixedPoint.Unsigned memory _pfc = pfc();\n\n        // Exit early if there is no pfc (thus, no fees to be paid).\n        if (_pfc.isEqual(0)) {\n            return totalPaid;\n        }\n\n        (FixedPoint.Unsigned memory regularFee, FixedPoint.Unsigned memory latePenalty) = store.computeRegularFee(\n            lastPaymentTime,\n            time,\n            _pfc\n        );\n        lastPaymentTime = time;\n\n        if (regularFee.isGreaterThan(0)) {\n            collateralCurrency.safeIncreaseAllowance(address(store), regularFee.rawValue);\n            store.payOracleFeesErc20(address(collateralCurrency));\n        }\n\n        if (latePenalty.isGreaterThan(0)) {\n            collateralCurrency.safeTransfer(msg.sender, latePenalty.rawValue);\n        }\n\n        emit RegularFeesPaid(regularFee.rawValue, latePenalty.rawValue);\n\n        totalPaid = regularFee.add(latePenalty);\n        FixedPoint.Unsigned memory effectiveFee = totalPaid.divCeil(_pfc);\n        cumulativeFeeMultiplier = cumulativeFeeMultiplier.mul(FixedPoint.fromUnscaledUint(1).sub(effectiveFee));\n    }\n\n    /**\n     * @notice Pays UMA DVM final fees to the Store contract.\n     * @dev This is a flat fee charged for each price request.\n     * @param payer address of who is paying the fees.\n     * @param amount the amount of collateral to send as the final fee.\n     */\n    function _payFinalFees(address payer, FixedPoint.Unsigned memory amount) internal {\n        if (amount.isEqual(0)) {\n            return;\n        }\n\n        if (payer != address(this)) {\n            // If the payer is not the contract pull the collateral from the payer.\n            collateralCurrency.safeTransferFrom(payer, address(this), amount.rawValue);\n        } else {\n            // If the payer is the contract, adjust the cumulativeFeeMultiplier to compensate.\n            FixedPoint.Unsigned memory _pfc = pfc();\n\n            // The final fee must be < pfc or the fee will be larger than 100%.\n            require(_pfc.isGreaterThan(amount));\n\n            // Add the adjustment.\n            FixedPoint.Unsigned memory effectiveFee = amount.divCeil(pfc());\n            cumulativeFeeMultiplier = cumulativeFeeMultiplier.mul(FixedPoint.fromUnscaledUint(1).sub(effectiveFee));\n        }\n\n        emit FinalFeesPaid(amount.rawValue);\n\n        StoreInterface store = _getStore();\n        collateralCurrency.safeIncreaseAllowance(address(store), amount.rawValue);\n        store.payOracleFeesErc20(address(collateralCurrency));\n    }\n\n    /**\n     * @notice Gets the current profit from corruption for this contract in terms of the collateral currency.\n     * @dev Derived contracts are expected to implement this function so the payFees()\n     * method can correctly compute the owed regular fees.\n     */\n    function pfc() public virtual view returns (FixedPoint.Unsigned memory);\n\n    /****************************************\n     *         INTERNAL FUNCTIONS           *\n     ****************************************/\n\n    function _getStore() internal view returns (StoreInterface) {\n        bytes32 storeInterface = \"Store\";\n        return StoreInterface(finder.getImplementationAddress(storeInterface));\n    }\n\n    function _computeFinalFees() internal returns (FixedPoint.Unsigned memory finalFees) {\n        StoreInterface store = _getStore();\n        return store.computeFinalFee(address(collateralCurrency));\n    }\n\n    // Returns the user's collateral minus any fees that have been subtracted since it was originally\n    // deposited into the contract. Note: if the contract has paid fees since it was deployed, the raw\n    // value should be larger than the returned value.\n    function _getCollateral(FixedPoint.Unsigned memory rawCollateral)\n        internal\n        view\n        returns (FixedPoint.Unsigned memory collateral)\n    {\n        return rawCollateral.mul(cumulativeFeeMultiplier);\n    }\n\n    // Converts a user-readable collateral value into a raw value that accounts for already-assessed\n    // fees. If any fees have been taken from this contract in the past, then the raw value will be\n    // larger than the user-readable value.\n    function _convertCollateral(FixedPoint.Unsigned memory collateral)\n        internal\n        view\n        returns (FixedPoint.Unsigned memory rawCollateral)\n    {\n        return collateral.div(cumulativeFeeMultiplier);\n    }\n\n    // Decrease rawCollateral by a fee-adjusted collateralToRemove amount. Fee adjustment scales up collateralToRemove\n    // by dividing it by cumulativeFeeMutliplier. There is potential for this quotient to be floored, therefore rawCollateral\n    // is decreased by less than expected. Because this method is usually called in conjunction with an actual removal of collateral\n    // from this contract, return the fee-adjusted amount that the rawCollateral is decreased by so that the caller can\n    // minimize error between collateral removed and rawCollateral debited.\n    function _removeCollateral(FixedPoint.Unsigned storage rawCollateral, FixedPoint.Unsigned memory collateralToRemove)\n        internal\n        returns (FixedPoint.Unsigned memory removedCollateral)\n    {\n        FixedPoint.Unsigned memory initialBalance = _getCollateral(rawCollateral);\n        FixedPoint.Unsigned memory adjustedCollateral = _convertCollateral(collateralToRemove);\n        rawCollateral.rawValue = rawCollateral.sub(adjustedCollateral).rawValue;\n        removedCollateral = initialBalance.sub(_getCollateral(rawCollateral));\n    }\n\n    // Increase rawCollateral by a fee-adjusted collateralToRemove amount. Fee adjustment scales up collateralToRemove\n    // by dividing it by cumulativeFeeMutliplier. There is potential for this quotient to be floored, therefore rawCollateral\n    // is increased by less than expected. Because this method is usually called in conjunction with an actual addition of collateral\n    // to this contract, return the fee-adjusted amount that the rawCollateral is increased by so that the caller can\n    // minimize error between collateral removed and rawCollateral credited.\n    // @dev: This return value exists only for the sake of symmetry with `_removeCollateral`. We don't actually use it because\n    // we are OK if more collateral is stored in the contract than is represented by `totalPositionCollateral`.\n    function _addCollateral(FixedPoint.Unsigned storage rawCollateral, FixedPoint.Unsigned memory collateralToAdd)\n        internal\n        returns (FixedPoint.Unsigned memory addedCollateral)\n    {\n        FixedPoint.Unsigned memory initialBalance = _getCollateral(rawCollateral);\n        FixedPoint.Unsigned memory adjustedCollateral = _convertCollateral(collateralToAdd);\n        rawCollateral.rawValue = rawCollateral.add(adjustedCollateral).rawValue;\n        addedCollateral = _getCollateral(rawCollateral).sub(initialBalance);\n    }\n}"
    },
    {
      "filename": "core/contracts/financial-templates/implementation/PricelessPositionManager.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../../common/implementation/FixedPoint.sol\";\nimport \"../../common/implementation/Testable.sol\";\nimport \"../../common/interfaces/ExpandedIERC20.sol\";\nimport \"../../oracle/interfaces/OracleInterface.sol\";\nimport \"../../oracle/interfaces/IdentifierWhitelistInterface.sol\";\nimport \"../../oracle/interfaces/AdministrateeInterface.sol\";\nimport \"./TokenFactory.sol\";\nimport \"./FeePayer.sol\";\n\n\n/**\n * @title Financial contract with priceless position management.\n * @notice Handles positions for multiple sponsors in an optimistic (i.e., priceless) way without relying\n * on a price feed."
    }
  ]
}