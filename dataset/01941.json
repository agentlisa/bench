{
  "Title": "M-9: FlashLoanLiquidate.JOJOFlashLoan has no slippage control when swapping USDC",
  "Content": "# Issue M-9: FlashLoanLiquidate.JOJOFlashLoan has no slippage control when swapping USDC \n\nSource: https://github.com/sherlock-audit/2023-04-jojo-judging/issues/373 \n\n## Found by \n0x52, 0xStalin, Aymen0909, Bauer, Nyx, T1MOH, cccz, peakbolt, rvierdiiev\n## Summary\nFlashLoanLiquidate.JOJOFlashLoan has no slippage control when swapping USDC\n## Vulnerability Detail\nIn both GeneralRepay.repayJUSD and FlashLoanRepay.JOJOFlashLoan, the user-supplied minReceive parameter is used for slippage control when swapping USDC. \n```solidity\n    function JOJOFlashLoan(\n        address asset,\n        uint256 amount,\n        address to,\n        bytes calldata param\n    ) external {\n        (address approveTarget, address swapTarget, uint256 minReceive, bytes memory data) = abi\n            .decode(param, (address, address, uint256, bytes));\n        IERC20(asset).approve(approveTarget, amount);\n        (bool success, ) = swapTarget.call(data);\n        if (success == false) {\n            assembly {\n                let ptr := mload(0x40)\n                let size := returndatasize()\n                returndatacopy(ptr, 0, size)\n                revert(ptr, size)\n            }\n        }\n        uint256 USDCAmount = IERC20(USDC).balanceOf(address(this));\n        require(USDCAmount >= minReceive, \"receive amount is too small\");\n...\n    function repayJUSD(\n        address asset,\n        uint256 amount,\n        address to,\n        bytes memory param\n    ) external {\n        IERC20(asset).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 minReceive;\n        if (asset != USDC) {\n            (address approveTarget, address swapTarget, uint256 minAmount, bytes memory data) = abi\n                .decode(param, (address, address, uint256, bytes));\n            IERC20(asset).approve(approveTarget, amount);\n            (bool success, ) = swapTarget.call(data);\n            if (success == false) {\n                assembly {\n                    let ptr := mload(0x40)\n                    let size := returndatasize()\n                    returndatacopy(ptr, 0, size)\n                    revert(ptr, size)\n                }\n            }\n            minReceive = minAmount;\n        }\n\n        uint256 USDCAmount = IERC20(USDC).balanceOf(address(this));\n        require(USDCAmount >= minReceive, \"receive amount is too small\");\n```\nHowever, this is not done in FlashLoanLiquidate.JOJOFlashLoan, and the lack of slippage control may expose the user to sandwich attacks when swapping USDC.\n## Impact\nThe lack of slippage control may expose the user to sandwich attacks when swapping USDC.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-jojo/blob/main/JUSDV1/src/Impl/flashloanImpl/FlashLoanLiquidate.sol#L46-L78\n\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider making FlashLoanLiquidate.JOJOFlashLoan use the minReceive parameter for slippage control when swapping USDC.\n\n\n\n## Discussion\n\n**JoscelynFarr**\n\nfix link: https://github.com/JOJOexchange/JUSDV1/commit/b0e7d27cf484d9406a267a1b38ac253113101e8e\n\n**IAm0x52**\n\nFix looks good. JOJOFlashloan now validates minReceived when swapping\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/70",
  "Code": [
    {
      "filename": "JUSDV1/src/Impl/flashloanImpl/FlashLoanLiquidate.sol",
      "content": "/*\n    Copyright 2022 JOJO Exchange\n    SPDX-License-Identifier: BUSL-1.1*/\npragma solidity 0.8.9;\n\nimport \"../../../src/Interface/IJUSDBank.sol\";\nimport \"../../../src/Interface/IJUSDExchange.sol\";\nimport \"../../../src/Interface/IFlashLoanReceive.sol\";\nimport {DecimalMath} from \"../../lib/DecimalMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IPriceChainLink} from \"../../Interface/IPriceChainLink.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract FlashLoanLiquidate is IFlashLoanReceive {\n    using SafeERC20 for IERC20;\n    using DecimalMath for uint256;\n\n    address public jusdBank;\n    address public jusdExchange;\n    address public immutable USDC;\n    address public immutable JUSD;\n    address public insurance;\n\n    struct LiquidateData {\n        uint256 actualCollateral;\n        uint256 insuranceFee;\n        uint256 actualLiquidatedT0;\n        uint256 actualLiquidated;\n        uint256 liquidatedRemainUSDC;\n    }\n\n    constructor(\n        address _jusdBank,\n        address _jusdExchange,\n        address _USDC,\n        address _JUSD,\n        address _insurance\n    ) {\n        jusdBank = _jusdBank;\n        jusdExchange = _jusdExchange;\n        USDC = _USDC;\n        JUSD = _JUSD;\n        insurance = _insurance;\n    }\n\n    function JOJOFlashLoan(\n        address asset,\n        uint256 amount,\n        address to,\n        bytes calldata param\n    ) external {\n        //swapContract swap\n        (LiquidateData memory liquidateData, bytes memory originParam) = abi\n            .decode(param, (LiquidateData, bytes));\n        (\n            address approveTarget,\n            address swapTarget,\n            address liquidator,\n            bytes memory data\n        ) = abi.decode(originParam, (address, address, address, bytes));\n        IERC20(asset).approve(approveTarget, amount);\n        (bool success, ) = swapTarget.call(data);\n        if (success == false) {\n            assembly {\n                let ptr := mload(0x40)\n                let size := returndatasize()\n                returndatacopy(ptr, 0, size)\n                revert(ptr, size)\n            }\n        }\n\n        uint256 USDCAmount = IERC20(USDC).balanceOf(address(this));\n\n        IERC20(USDC).approve(jusdExchange, liquidateData.actualLiquidated);\n        IJUSDExchange(jusdExchange).buyJUSD(\n            liquidateData.actualLiquidated,\n            address(this)\n        );\n        IERC20(JUSD).approve(jusdBank, liquidateData.actualLiquidated);\n        IJUSDBank(jusdBank).repay(liquidateData.actualLiquidated, to);\n\n        // 2. insurance\n        IERC20(USDC).safeTransfer(insurance, liquidateData.insuranceFee);\n        // 3. liquidate usdc\n        if (liquidateData.liquidatedRemainUSDC != 0) {\n            IERC20(USDC).safeTransfer(to, liquidateData.liquidatedRemainUSDC);\n        }\n        // 4. transfer to liquidator\n        IERC20(USDC).safeTransfer(\n            liquidator,\n            USDCAmount -\n                liquidateData.insuranceFee -\n                liquidateData.actualLiquidated -\n                liquidateData.liquidatedRemainUSDC\n        );\n    }\n}"
    }
  ]
}