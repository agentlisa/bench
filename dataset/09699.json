{
  "Title": "[M-04] `msg.value` is Sent Multipletimes When Performing a Swap",
  "Content": "_Submitted by kirk-baird, also found by hyh, rayn, TomFrenchBlockchain, VAD37, WatchPug, and wuwe1_\n\n[LibSwap.sol#L42](https://github.com/code-423n4/2022-03-lifinance/blob/main/src/Libraries/LibSwap.sol#L42)<br>\n[Swapper.sol#L12-L23](https://github.com/code-423n4/2022-03-lifinance/blob/main/src/Facets/Swapper.sol#L12-L23)<br>\n\n`msg.value` is attached multiple times to external swap calls in `LibSwap.swap()`.\n\nIf `Swapper._executeSwaps()` is called with the native token as the `swapData.fromAssetId` more than once and `msg.value > 0` then more value will be transferred out of the contract than is received since `msg.value` will be transferred out `_swapData.length` times.\n\nThe impact is that the contract can have all the native token balance drained by an attacker who has makes repeated swap calls from the native token into any other ERC20 token. Each time the original `msg.value` of the sender will be swapped out of the contract. This attack essentially gives the attacker `_swapData.length * msg.value` worth of native tokens (swapped into another ERC20) when they should only get `msg.value`.\n\n### Proof of Concept\n\n`Swapper._executeSwaps()` iterates over a list of  `SwapData` calling `LibSwap.swap()` each time (note this is an internal call).\n\n```solidity\n    function _executeSwaps(LiFiData memory _lifiData, LibSwap.SwapData[] calldata _swapData) internal {\n        // Swap\n        for (uint8 i; i < _swapData.length; i++) {\n            require(\n                ls.dexWhitelist[_swapData[i].approveTo] == true && ls.dexWhitelist[_swapData[i].callTo] == true,\n                \"Contract call not allowed!\"\n            );\n\n            LibSwap.swap(_lifiData.transactionId, _swapData[i]);\n        }\n    }\n}\n```\n\nInside `LibSwap.swap()` we make an external call to `_swapData.callTo` with `value : msg.value`. Due to the loop in `Swapper._executeSwaps()` this repeatedly sends the original `msg.value` in the external call.\n\n```solidity\n        (bool success, bytes memory res) = _swapData.callTo.call{ value: msg.value }(_swapData.callData);\n```\n\n### Recommended Mitigation Steps\n\nThis issue may be mitigated by only allowing `fromAssetId` to be the native token once in `_swapData` in `Swapper._executeSwaps()`. If it occurs more than once the transaction should revert.\n\n**[H3xept (Li.Fi) acknowledged, but disagreed with High severity and commented](https://github.com/code-423n4/2022-03-lifinance-findings/issues/86#issuecomment-1096486215):**\n > We are aware that the contract allows users to use latent funds, although we disagree on it being an issue as no funds (ERC20 or native) should ever lay in the contract. To make sure that no value is ever kept by the diamond, we now provide refunds for outstanding user value (after bridges/swaps). \n> \n\n**[gzeon (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-03-lifinance-findings/issues/86#issuecomment-1100700006):**\n > Adjusting this as Medium Risk. There can be fund leftover in the contract under normal operation, for example [this tx](https://etherscan.io/tx/0xe78c36dd2c2f21cade00a4099701b9c9f82acc8da568e1048a4d7287ce2e45b0). In fact, ~\\$300 worth of token is left in the LI.Fi smart contract on ETH mainnet [0x5a9fd7c39a6c488e715437d7b1f3c823d5596ed1](https://etherscan.io/address/0x5a9fd7c39a6c488e715437d7b1f3c823d5596ed1) as of block 14597316. I don't think this is High Risk because the max amount lost is no more than allowed slippage, which can be loss to MEV too. Not a duplicate of M-02 since `msg.value` is the vector here.\n\n**[ezynda3 (Li.Fi) resolved and commented](https://github.com/code-423n4/2022-03-lifinance-findings/issues/86#issuecomment-1115936651):**\n > This has been fixed in the most recent version of `src/Helpers/Swapper.sol` which sweeps any latent funds back to the user's wallet.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-03-lifinance",
  "Code": [
    {
      "filename": "src/Libraries/LibSwap.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { LibAsset, IERC20 } from \"./LibAsset.sol\";\nimport { LibUtil } from \"./LibUtil.sol\";\n\nlibrary LibSwap {\n    uint256 private constant MAX_INT = 2**256 - 1;\n\n    struct SwapData {\n        address callTo;\n        address approveTo;\n        address sendingAssetId;\n        address receivingAssetId;\n        uint256 fromAmount;\n        bytes callData;\n    }\n\n    event AssetSwapped(\n        bytes32 transactionId,\n        address dex,\n        address fromAssetId,\n        address toAssetId,\n        uint256 fromAmount,\n        uint256 toAmount,\n        uint256 timestamp\n    );\n\n    function swap(bytes32 transactionId, SwapData calldata _swapData) internal {\n        uint256 fromAmount = _swapData.fromAmount;\n        uint256 toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId);\n        address fromAssetId = _swapData.sendingAssetId;\n        if (!LibAsset.isNativeAsset(fromAssetId) && LibAsset.getOwnBalance(fromAssetId) < fromAmount) {\n            LibAsset.transferFromERC20(fromAssetId, msg.sender, address(this), fromAmount);\n        }\n\n        if (!LibAsset.isNativeAsset(fromAssetId)) {\n            LibAsset.approveERC20(IERC20(fromAssetId), _swapData.approveTo, fromAmount);\n        }\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory res) = _swapData.callTo.call{ value: msg.value }(_swapData.callData);\n        if (!success) {\n            string memory reason = LibUtil.getRevertMsg(res);\n            revert(reason);\n        }\n\n        toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId) - toAmount;\n        emit AssetSwapped(\n            transactionId,\n            _swapData.callTo,\n            _swapData.sendingAssetId,\n            _swapData.receivingAssetId,\n            fromAmount,\n            toAmount,\n            block.timestamp\n        );\n    }\n}"
    },
    {
      "filename": "src/Facets/Swapper.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { LibStorage } from \"../Libraries/LibStorage.sol\";\n\ncontract Swapper is ILiFi {\n    /* ========== Storage ========== */\n    LibStorage internal ls;\n\n    function _executeSwaps(LiFiData memory _lifiData, LibSwap.SwapData[] calldata _swapData) internal {\n        // Swap\n        for (uint8 i; i < _swapData.length; i++) {\n            require(\n                ls.dexWhitelist[_swapData[i].approveTo] == true && ls.dexWhitelist[_swapData[i].callTo] == true,\n                \"Contract call not allowed!\"\n            );\n\n            LibSwap.swap(_lifiData.transactionId, _swapData[i]);\n        }\n    }\n}"
    }
  ]
}