{
  "Title": "[M-27] Unexecutable proposals when `Actions.MigrateKernel` is not last instruction",
  "Content": "_Submitted by Lambda_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/549b96bcf8b97807738572605f6b1e26b33ef411/src/modules/INSTR.sol#L61><br>\n\nIn `INSTR.sol`, it is correctly checked that a `ChangeExecutor` instruction only occurs at the last position to avoid situations where the other instructions are deemed as invalid.<br>\nHowever, the same problem can occur for `MigrateKernel`. For instance, let's say we have a `MigrateKernel` followed by a `DeactivatePolicy` action. The `MigrateKernel` action will change the value of `kernel` within the policy. The `DeactivatePolicy` action tries to call `setActiveStatus` on the policy. However, this has a `onlyKernel` modifier and the call will therefore fail when it is done after the value of `kernel` was changed.\n\n### Recommended Mitigation Steps\n\nPerform the same check for `MigrateKernel`.\n\n**[fullyallocated (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/51#issuecomment-1236245145):**\n > Thank you; good catch\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-08-olympus-dao-contest",
  "Code": [
    {
      "filename": "src/modules/INSTR.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"src/Kernel.sol\";\n\nerror INSTR_InstructionsCannotBeEmpty();\nerror INSTR_InvalidChangeExecutorAction();\n\n/// @notice Caches and executes batched instructions for protocol upgrades in the Kernel.\ncontract OlympusInstructions is Module {\n    event InstructionsStored(uint256 instructionsId);\n\n    uint256 public totalInstructions;\n    mapping(uint256 => Instruction[]) public storedInstructions;\n\n    /*//////////////////////////////////////////////////////////////\n                            MODULE INTERFACE\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(Kernel kernel_) Module(kernel_) {}\n\n    /// @inheritdoc Module\n    function KEYCODE() public pure override returns (Keycode) {\n        return toKeycode(\"INSTR\");\n    }\n\n    /// @inheritdoc Module\n    function VERSION() public pure override returns (uint8 major, uint8 minor) {\n        return (1, 0);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CORE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice View function for retrieving a list of Instructions in an outside contract.\n    function getInstructions(uint256 instructionsId_) public view returns (Instruction[] memory) {\n        return storedInstructions[instructionsId_];\n    }\n\n    /// @notice Store a list of Instructions to be executed in the future.\n    function store(Instruction[] calldata instructions_) external permissioned returns (uint256) {\n        uint256 length = instructions_.length;\n        uint256 instructionsId = ++totalInstructions;\n\n        Instruction[] storage instructions = storedInstructions[instructionsId];\n\n        if (length == 0) revert INSTR_InstructionsCannotBeEmpty();\n\n        for (uint256 i; i < length; ) {\n            Instruction calldata instruction = instructions_[i];\n            ensureContract(instruction.target);\n\n            // If the instruction deals with a module, make sure the module has a valid keycode (UPPERCASE A-Z ONLY)\n            if (\n                instruction.action == Actions.InstallModule ||\n                instruction.action == Actions.UpgradeModule\n            ) {\n                Module module = Module(instruction.target);\n                ensureValidKeycode(module.KEYCODE());\n            } else if (instruction.action == Actions.ChangeExecutor && i != length - 1) {\n                // Throw an error if ChangeExecutor exists and is not the last Action in the instruction list.\n                // This exists because if ChangeExecutor is not the last item in the list of instructions,\n                // the Kernel will not recognize any of the following instructions as valid, since the policy\n                // executing the list of instructions no longer has permissions in the Kernel. To avoid this issue\n                // and prevent invalid proposals from being saved, we perform this check.\n                revert INSTR_InvalidChangeExecutorAction();\n            }\n\n            instructions.push(instructions_[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit InstructionsStored(instructionsId);\n\n        return instructionsId;\n    }\n}"
    }
  ]
}