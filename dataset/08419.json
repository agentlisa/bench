{
  "Title": "[L-09]  Missing checks for `address(0x0)` when assigning values to `address` state variables",
  "Content": "\n*There are 7 instances of this issue:*\n```solidity\nFile: contracts/core/GolomTrader.sol\n\n448:              pendingDistributor = _distributor;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L448\n\n```solidity\nFile: contracts/governance/GolomToken.sol\n\n59:           pendingMinter = _minter;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/governance/GolomToken.sol#L59\n\n```solidity\nFile: contracts/rewards/RewardDistributor.sol\n\n81:           trader = _trader;\n\n287:          pendingTrader = _trader;\n\n303:              pendingVoteEscrow = _voteEscrow;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L81\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowCore.sol\n\n870:          voter = _voter;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L870\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowDelegation.sol\n\n53:           token = _token;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L53\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-07-golom",
  "Code": [
    {
      "filename": "contracts/core/GolomTrader.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\n\ninterface ERC721 {\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n}\n\ninterface ERC1155 {\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n}\n\ninterface ERC20 {\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external returns (bool);\n\n    function withdraw(uint256 wad) external;\n}\n\ninterface Distributor {\n    function addFee(address[2] calldata addr, uint256 fee) external;\n}\n\ncontract GolomTrader is Ownable, ReentrancyGuard {\n    bytes32 public immutable EIP712_DOMAIN_TYPEHASH;\n    mapping(address => uint256) public nonces; // all nonces other then this nonce\n    mapping(bytes32 => uint256) public filled;\n\n    ERC20 WETH = ERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    struct Order {\n        address collection; // NFT contract address\n        uint256 tokenId; // order for which tokenId of the collection\n        address signer; // maker of order address\n        uint256 orderType; // 0 if selling nft for eth , 1 if offering weth for nft,2 if offering weth for collection with special criteria root\n        uint256 totalAmt; // price value of the trade // total amt maker is willing to give up per unit of amount\n        Payment exchange; // payment agreed by maker of the order to pay on succesful filling of trade this amt is subtracted from totalamt\n        Payment prePayment; // another payment , can be used for royalty, facilating trades\n        bool isERC721; // standard of the collection , if 721 then true , if 1155 then false\n        uint256 tokenAmt; // token amt useful if standard is 1155 if >1 means whole order can be filled tokenAmt times\n        uint256 refererrAmt; // amt to pay to the address that helps in filling your order\n        bytes32 root; // A merkle root derived from each valid tokenId â€” set to 0 to indicate a collection-level or tokenId-specific order.\n        address reservedAddress; // if not address(0) , only this address can fill the order\n        uint256 nonce; // nonce of order usefull for cancelling in bulk\n        uint256 deadline; // timestamp till order is valid epoch timestamp in secs\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    struct Payment {\n        uint256 paymentAmt;\n        address paymentAddress;\n    }\n\n    address public governance;\n\n    Distributor public distributor;\n    address public pendingDistributor;\n    uint256 public distributorEnableDate;\n\n    // events\n    event NonceIncremented(address indexed maker, uint256 newNonce);\n\n    event OrderFilled(\n        address indexed maker,\n        address indexed taker,\n        uint256 indexed orderType,\n        bytes32 orderHash,\n        uint256 price\n    );\n\n    event OrderCancelled(bytes32 indexed orderHash);\n\n    /// @param _governance Address of the governance, responsible for setting distributor\n    constructor(address _governance) {\n        // sets governance as owner\n        _transferOwnership(_governance);\n\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n\n        EIP712_DOMAIN_TYPEHASH = keccak256(\n            abi.encode(\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n                keccak256(bytes('GOLOM.IO')),\n                keccak256(bytes('1')),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    function hashPayment(Payment calldata p) private pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256('payment(uint256 paymentAmt,address paymentAddress)'),\n                    p.paymentAmt,\n                    p.paymentAddress\n                )\n            );\n    }\n\n    function _hashOrder(Order calldata o) private pure returns (bytes32) {\n        return _hashOrderinternal(o, [o.nonce, o.deadline]);\n    }\n\n    function _hashOrderinternal(Order calldata o, uint256[2] memory extra) private pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        'order(address collection,uint256 tokenId,address signer,uint256 orderType,uint256 totalAmt,payment exchange,payment prePayment,bool isERC721,uint256 tokenAmt,uint256 refererrAmt,bytes32 root,address reservedAddress,uint256 nonce,uint256 deadline)payment(uint256 paymentAmt,address paymentAddress)'\n                    ),\n                    o.collection,\n                    o.tokenId,\n                    o.signer,\n                    o.orderType,\n                    o.totalAmt,\n                    hashPayment(o.exchange),\n                    hashPayment(o.prePayment),\n                    o.isERC721,\n                    o.tokenAmt,\n                    o.refererrAmt,\n                    o.root,\n                    o.reservedAddress,\n                    extra\n                )\n            );\n    }\n\n    function payEther(uint256 payAmt, address payAddress) internal {\n        if (payAmt > 0) {\n            // if royalty has to be paid\n            payable(payAddress).transfer(payAmt); // royalty transfer to royaltyaddress\n        }\n    }\n\n    /// @dev Validates Order and returns OrderStatus, hashedorder, amountRemaining to be filled\n    ///      OrderStatus = 0 , if signature is invalid\n    ///      OrderStatus = 1 , if deadline has been\n    ///      OrderStatus = 2 , order is filled or cancelled\n    ///      OrderStatus = 3 , valid order\n    /// @param o the Order struct to be validated\n    function validateOrder(Order calldata o)\n        public\n        view\n        returns (\n            uint256,\n            bytes32,\n            uint256\n        )\n    {\n        // match signature\n        bytes32 hashStruct = _hashOrder(o);\n        bytes32 hash = keccak256(abi.encodePacked('\\x19\\x01', EIP712_DOMAIN_TYPEHASH, hashStruct));\n        address signaturesigner = ecrecover(hash, o.v, o.r, o.s);\n        require(signaturesigner == o.signer, 'invalid signature');\n        if (signaturesigner != o.signer) {\n            return (0, hashStruct, 0);\n        }\n        //deadline\n        if (block.timestamp > o.deadline) {\n            return (1, hashStruct, 0);\n        }\n        // not cancelled by nonce or by hash\n        if (o.nonce != nonces[o.signer]) {\n            return (2, hashStruct, 0);\n        }\n        if (filled[hashStruct] >= o.tokenAmt) {\n            // handles erc1155\n            return (2, hashStruct, 0);\n        }\n        return (3, hashStruct, o.tokenAmt - filled[hashStruct]);\n    }\n\n    /// @dev function to fill a signed order of ordertype 0, also has a payment param in case the taker wants\n    ///      to send ether to that address on filling the order\n    /// @param o the Order struct to be filled must be orderType 0\n    /// @param amount the amount of times the order is to be filled(useful for ERC1155)\n    /// @param referrer referrer of the order\n    /// @param p any extra payment that the taker of this order wanna send on succesful execution of order\n    /// @param receiver address which will receive the NFT\n    function fillAsk(\n        Order calldata o,\n        uint256 amount,\n        address referrer,\n        Payment calldata p,\n        address receiver\n    ) public payable nonReentrant {\n        // check if the signed total amount has all the amounts as well as 50 basis points fee\n        require(\n            o.totalAmt >= o.exchange.paymentAmt + o.prePayment.paymentAmt + o.refererrAmt + (o.totalAmt * 50) / 10000,\n            'amt not matching'\n        );\n\n        // attached ETH value should be greater than total value of one NFT * total number of NFTs + any extra payment to be given\n        require(msg.value >= o.totalAmt * amount + p.paymentAmt, 'mgmtm');\n\n        if (o.reservedAddress != address(0)) {\n            require(msg.sender == o.reservedAddress);\n        }\n        require(o.orderType == 0, 'invalid orderType');\n\n        (uint256 status, bytes32 hashStruct, uint256 amountRemaining) = validateOrder(o);\n\n        require(status == 3, 'order not valid');\n        require(amountRemaining >= amount, 'order already filled');\n\n        filled[hashStruct] = filled[hashStruct] + amount;\n\n        if (receiver == address(0)) {\n            receiver = msg.sender;\n        }\n        if (o.isERC721) {\n            require(amount == 1, 'only 1 erc721 at 1 time');\n            ERC721(o.collection).transferFrom(o.signer, receiver, o.tokenId);\n        } else {\n            ERC1155(o.collection).safeTransferFrom(o.signer, receiver, o.tokenId, amount, '');\n        }\n\n        // pay fees of 50 basis points to the distributor\n        payEther(((o.totalAmt * 50) / 10000) * amount, address(distributor));\n\n        // pay the exchange share\n        payEther(o.exchange.paymentAmt * amount, o.exchange.paymentAddress);\n\n        // pay the pre payment\n        payEther(o.prePayment.paymentAmt * amount, o.prePayment.paymentAddress);\n\n        if (o.refererrAmt > 0 && referrer != address(0)) {\n            payEther(o.refererrAmt * amount, referrer);\n            payEther(\n                (o.totalAmt -\n                    (o.totalAmt * 50) /\n                    10000 -\n                    o.exchange.paymentAmt -\n                    o.prePayment.paymentAmt -\n                    o.refererrAmt) * amount,\n                o.signer\n            );\n        } else {\n            payEther(\n                (o.totalAmt - (o.totalAmt * 50) / 10000 - o.exchange.paymentAmt - o.prePayment.paymentAmt) * amount,\n                o.signer\n            );\n        }\n        payEther(p.paymentAmt, p.paymentAddress);\n\n        distributor.addFee([o.signer, o.exchange.paymentAddress], ((o.totalAmt * 50) / 10000) * amount);\n        emit OrderFilled(o.signer, msg.sender, 0, hashStruct, o.totalAmt * amount);\n    }\n\n    /// @dev function to fill a signed order of ordertype 1 also has a payment param in case the taker wants\n    ///      to send ether to that address on filling the order\n    /// @param o the Order struct to be filled must be orderType 1\n    /// @param amount the amount of times the order is to be filled(useful for ERC1155)\n    /// @param referrer referrer of the order\n    /// @param p any extra payment that the taker of this order wanna send on succesful execution of order\n    function fillBid(\n        Order calldata o,\n        uint256 amount,\n        address referrer,\n        Payment calldata p\n    ) public nonReentrant {\n        require(\n            o.totalAmt * amount >\n                (o.exchange.paymentAmt + o.prePayment.paymentAmt + o.refererrAmt) * amount + p.paymentAmt\n        ); // cause bidder eth is paying for seller payment p , dont take anything extra from seller\n        // require eth amt is sufficient\n        if (o.reservedAddress != address(0)) {\n            require(msg.sender == o.reservedAddress);\n        }\n        require(o.orderType == 1);\n        (uint256 status, bytes32 hashStruct, uint256 amountRemaining) = validateOrder(o);\n        require(status == 3);\n        require(amountRemaining >= amount);\n        filled[hashStruct] = filled[hashStruct] + amount;\n        if (o.isERC721) {\n            require(amount == 1, 'only 1 erc721 at 1 time');\n            ERC721 nftcontract = ERC721(o.collection);\n            nftcontract.transferFrom(msg.sender, o.signer, o.tokenId);\n        } else {\n            ERC1155 nftcontract = ERC1155(o.collection);\n            nftcontract.safeTransferFrom(msg.sender, o.signer, o.tokenId, amount, '');\n        }\n        emit OrderFilled(msg.sender, o.signer, 1, hashStruct, o.totalAmt * amount);\n        _settleBalances(o, amount, referrer, p);\n    }\n\n    // cancel by nonce and by individual order\n\n    function cancelOrder(Order calldata o) public nonReentrant {\n        require(o.signer == msg.sender);\n        (, bytes32 hashStruct, ) = validateOrder(o);\n        filled[hashStruct] = o.tokenAmt + 1;\n        emit OrderCancelled(hashStruct);\n    }\n\n    /**\n     * Increment a particular maker's nonce, thereby invalidating all orders that were not signed\n     * with the original nonce.\n     */\n    function incrementNonce() external nonReentrant {\n        uint256 newNonce = ++nonces[msg.sender];\n        emit NonceIncremented(msg.sender, newNonce);\n    }\n\n    /// @dev function to fill a signed order of ordertype 2 also has a payment param in case the taker wants\n    ///      to send ether to that address on filling the order, Match an criteria order, ensuring that the supplied proof demonstrates inclusion of the tokenId in the associated merkle root, if root is 0 then any token can be used to fill the order\n    /// @param o the Order struct to be filled must be orderType 2\n    /// @param amount the amount of times the order is to be filled(useful for ERC1155)\n    /// @param referrer referrer of the order\n    /// @param p any extra payment that the taker of this order wanna send on succesful execution of order\n    function fillCriteriaBid(\n        Order calldata o,\n        uint256 amount,\n        uint256 tokenId,\n        bytes32[] calldata proof,\n        address referrer,\n        Payment calldata p\n    ) public nonReentrant {\n        require(o.totalAmt >= o.exchange.paymentAmt + o.prePayment.paymentAmt + o.refererrAmt);\n        // require eth amt is sufficient\n        if (o.reservedAddress != address(0)) {\n            require(msg.sender == o.reservedAddress);\n        }\n        require(o.orderType == 2);\n        (uint256 status, bytes32 hashStruct, uint256 amountRemaining) = validateOrder(o);\n        require(status == 3);\n        require(amountRemaining >= amount);\n\n        filled[hashStruct] = filled[hashStruct] + amount;\n        // Proof verification is performed when there's a non-zero root.\n        if (o.root != bytes32(0)) {\n            _verifyProof(tokenId, o.root, proof);\n        }\n\n        if (o.isERC721) {\n            require(amount == 1, 'only 1 erc721 at 1 time');\n            ERC721 nftcontract = ERC721(o.collection);\n            nftcontract.transferFrom(msg.sender, o.signer, tokenId);\n        } else {\n            ERC1155 nftcontract = ERC1155(o.collection);\n            nftcontract.safeTransferFrom(msg.sender, o.signer, tokenId, amount, '');\n        }\n        emit OrderFilled(msg.sender, o.signer, 2, hashStruct, o.totalAmt * amount);\n        _settleBalances(o, amount, referrer, p);\n    }\n\n    /// @dev function to settle balances when a bid is filled succesfully\n    /// @param o the Order struct to be filled must be orderType 1\n    /// @param amount the amount of times the order is to be filled(useful for ERC1155)\n    /// @param referrer referrer of the order\n    /// @param p any extra payment that the taker of this order wanna send on succesful execution of order\n    function _settleBalances(\n        Order calldata o,\n        uint256 amount,\n        address referrer,\n        Payment calldata p\n    ) internal {\n        uint256 protocolfee = ((o.totalAmt * 50) / 10000) * amount;\n        WETH.transferFrom(o.signer, address(this), o.totalAmt * amount);\n        WETH.withdraw(o.totalAmt * amount);\n        payEther(protocolfee, address(distributor));\n        payEther(o.exchange.paymentAmt * amount, o.exchange.paymentAddress);\n        payEther(o.prePayment.paymentAmt * amount, o.prePayment.paymentAddress);\n        if (o.refererrAmt > 0 && referrer != address(0)) {\n            payEther(o.refererrAmt * amount, referrer);\n            payEther(\n                (o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt - o.refererrAmt) *\n                    amount -\n                    p.paymentAmt,\n                msg.sender\n            );\n        } else {\n            payEther(\n                (o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt) * amount - p.paymentAmt,\n                msg.sender\n            );\n        }\n        payEther(p.paymentAmt, p.paymentAddress);\n        distributor.addFee([msg.sender, o.exchange.paymentAddress], protocolfee);\n    }\n\n    /// @dev Ensure that a given tokenId is contained within a supplied merkle root using a supplied proof.\n    /// @param leaf The tokenId.\n    /// @param root A merkle root derived from each valid tokenId.\n    /// @param proof A proof that the supplied tokenId is contained within the associated merkle root.\n    function _verifyProof(\n        uint256 leaf,\n        bytes32 root,\n        bytes32[] memory proof\n    ) public pure {\n        bytes32 computedHash = keccak256(abi.encode(leaf));\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = _efficientHash(computedHash, proofElement);\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = _efficientHash(proofElement, computedHash);\n            }\n        }\n        if (computedHash != root) {\n            revert('invalid proof');\n        }\n    }\n\n    /// @dev Efficiently hash two bytes32 elements using memory scratch space.\n    /// @param a The first element included in the hash.\n    /// @param b The second element included in the hash.\n    /// @return value The resultant hash of the two bytes32 elements.\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n\n    /// @notice Sets the distributor contract\n    /// @param _distributor Address of the distributor\n    function setDistributor(address _distributor) external onlyOwner {\n        if (address(distributor) == address(0)) {\n            distributor = Distributor(_distributor);\n        } else {\n            pendingDistributor = _distributor;\n            distributorEnableDate = block.timestamp + 1 days;\n        }\n    }\n\n    /// @notice Executes the set distributor function after the timelock\n    function executeSetDistributor() external onlyOwner {\n        require(distributorEnableDate <= block.timestamp, 'not allowed');\n        distributor = Distributor(pendingDistributor);\n    }\n\n    fallback() external payable {}\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/governance/GolomToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\n/// @title Golom ERC20 governance token\n/// @notice Explain to an end user what this does\n/// @dev Implements ERC20, ERC20Votes and ERC20Permits from OpenZepellin\n\n// Tokens are minted on the initial mint\n// Additionally mint function is called to mint the tokens, only the reward distributor contract will be able to mint the token\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol';\n\ncontract GolomToken is ERC20Votes, Ownable {\n    address public minter;\n\n    uint256 public minterEnableDate;\n    address public pendingMinter;\n\n    bool public isAirdropMinted;\n    bool public isGenesisRewardMinted;\n\n    modifier onlyMinter() {\n        require(msg.sender == minter, 'GolomToken: only reward distributor can enable');\n        _;\n    }\n\n    constructor(address _governance) ERC20('Golom', 'GOL') ERC20Permit('Golom') {\n        _transferOwnership(_governance); // set the new owner\n    }\n\n    /// @notice Mints the tokens\n    /// @dev only minter can mint the tokens, minter will be RewardDistributor.sol\n    /// @param _account Address where the tokens will be minted\n    /// @param _amount Number of tokens to be minted\n    function mint(address _account, uint256 _amount) external onlyMinter {\n        _mint(_account, _amount);\n    }\n\n    /// @notice Mints 150M for the airdrop\n    /// @param _airdrop Airdrop contract\n    function mintAirdrop(address _airdrop) external onlyOwner {\n        require(!isAirdropMinted, 'already minted');\n        _mint(_airdrop, 150_000_000 * 1e18);\n        isAirdropMinted = true;\n    }\n\n    /// @notice Mint Genesis Reward\n    /// @param _rewardDistributor Address of the rewardDistributor\n    function mintGenesisReward(address _rewardDistributor) external onlyOwner {\n        require(!isGenesisRewardMinted, 'already minted');\n        _mint(_rewardDistributor, 62_500_000 * 1e18);\n        isGenesisRewardMinted = true;\n    }\n\n    /// @notice sets the minter with timelock, once setup admin needs to call executeSetMinter()\n    /// @param _minter Address of the new minter\n    function setMinter(address _minter) external onlyOwner {\n        pendingMinter = _minter;\n        minterEnableDate = block.timestamp + 1 days;\n    }\n\n    /// @notice Executes the set minter function after the timelock\n    /// @dev If being called first time, there won't be any timelock\n    function executeSetMinter() external onlyOwner {\n        if (minter == address(0)) {\n            minter = pendingMinter;\n        } else {\n            require(minterEnableDate <= block.timestamp, 'GolomToken: wait for timelock');\n            minter = pendingMinter;\n        }\n    }\n}"
    },
    {
      "filename": "contracts/rewards/RewardDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\n// stores daily trades\n// is minter of token, first interaction mints tokens and distributes tokens\n// gives prorata tokens to traders and exchange daily\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport 'hardhat/console.sol';\n\ninterface ERC20 {\n    function totalSupply() external returns (uint256);\n\n    function balanceOf(address account) external returns (uint256);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external returns (bool);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function mint(address account, uint256 amount) external;\n\n    function balanceOfNFTAt(uint256 _tokenId, uint256 _t) external view returns (uint256);\n\n    function deposit() external payable;\n}\n\ninterface VE {\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    function totalSupplyAtT(uint256 t) external view returns (uint256);\n\n    function balanceOfNFTAt(uint256 _tokenId, uint256 _t) external view returns (uint256);\n\n    function totalSupplyAt(uint256 _block) external view returns (uint256);\n\n    function balanceOfAtNFT(uint256 _tokenId, uint256 _block) external view returns (uint256);\n}\n\ncontract RewardDistributor is Ownable {\n    address public trader;\n    uint256 public epoch = 0;\n    uint256 public startTime; // timestamp at which the contracts need to be activated\n\n    uint256 constant dailyEmission = 600000 * 10**18;\n\n    address public pendingTrader;\n    uint256 public traderEnableDate;\n\n    address public pendingVoteEscrow;\n    uint256 public voteEscrowEnableDate;\n    VE public ve;\n\n    uint256 constant secsInDay = 24 * 60 * 60;\n    mapping(address => mapping(uint256 => uint256)) public feesTrader; // fees accumulated by address of trader per epoch\n    mapping(address => mapping(uint256 => uint256)) public feesExchange; // fees accumulated by exchange of trader per epoch\n    mapping(uint256 => uint256) public epochTotalFee; // total fee of epoch\n    mapping(uint256 => uint256) public rewardTrader; // reward minted each epoc for trader\n    mapping(uint256 => uint256) public rewardExchange; // reward minted each epoc for exhange\n    mapping(uint256 => uint256) public rewardLP; // reward minted each epoc for LP\n    mapping(uint256 => uint256) public rewardStaker; // reward minted each epoc for stakers\n    mapping(uint256 => uint256) public epochBeginTime; // what time previous epoch ended\n    mapping(uint256 => uint256) public claimedUpto; // epoch upto which tokenid has claimed\n    mapping(uint256 => mapping(uint256 => uint256)) public claimed; // epoch upto which tokenid has claimed\n    ERC20 public rewardToken;\n    ERC20 public weth;\n    event NewEpoch(uint256 indexed epochNo, uint256 tokenMinted, uint256 rewardStaker, uint256 previousEpochFee);\n\n    // epochs,trader, token\n\n    constructor(\n        address _weth,\n        address _trader,\n        address _token,\n        address _governance\n    ) {\n        weth = ERC20(_weth);\n        trader = _trader;\n        rewardToken = ERC20(_token);\n        _transferOwnership(_governance); // set the new owner\n        startTime = 1659211200;\n    }\n\n    modifier onlyTrader() {\n        require(msg.sender == trader);\n        _;\n    }\n\n    // at starttime epoch 1 starts , first trade changes epoch from 0 to 1 , emits tokens stores the rewards for epoch 1 ,\n    // after 1 day , first trade changes epoch from 1 to 2, changes eth in contract to weth and stores rewardstakedeth , emits tokens stores the rewards for epoch 2\n\n    /// @dev Add fees contributed by the Seller of nft and the exchange/frontend that facilated the trade\n    /// @param addr the address that contributed in fees\n    /// @param fee the fee contributed by these addresses\n    function addFee(address[2] memory addr, uint256 fee) public onlyTrader {\n        //console.log(block.timestamp,epoch,fee);\n        if (rewardToken.totalSupply() > 1000000000 * 10**18) {\n            // if supply is greater then a billion dont mint anything, dont add trades\n            return;\n        }\n\n        // if 24 hours have passed since last epoch change\n        if (block.timestamp > startTime + (epoch) * secsInDay) {\n            // this assumes atleast 1 trade is done daily??????\n            // logic to decide how much token to emit\n            // emission = daily * (1 - (balance of locker/ total supply))  full if 0 locked and 0 if all locked\n            // uint256 tokenToEmit = dailyEmission * rewardToken.balanceOf()/\n            // emissions is decided by epoch begiining locked/circulating , and amount each nft gets also decided at epoch begining\n            uint256 tokenToEmit = (dailyEmission * (rewardToken.totalSupply() - rewardToken.balanceOf(address(ve)))) /\n                rewardToken.totalSupply();\n            uint256 stakerReward = (tokenToEmit * rewardToken.balanceOf(address(ve))) / rewardToken.totalSupply();\n            // deposit previous epoch fee to weth for distribution to stakers\n\n            uint256 previousEpochFee = epochTotalFee[epoch];\n            epoch = epoch + 1;\n            rewardStaker[epoch] = stakerReward;\n            rewardTrader[epoch] = ((tokenToEmit - stakerReward) * 67) / 100;\n            rewardExchange[epoch] = ((tokenToEmit - stakerReward) * 33) / 100;\n            rewardToken.mint(address(this), tokenToEmit);\n            epochBeginTime[epoch] = block.number;\n            if (previousEpochFee > 0) {\n                if (epoch == 1){\n                    epochTotalFee[0] =  address(this).balance; // staking and trading rewards start at epoch 1, for epoch 0 all contract ETH balance is converted to staker rewards rewards.\n                    weth.deposit{value: address(this).balance}();  \n                }else{\n                    weth.deposit{value: previousEpochFee}();\n                }\n            }\n            emit NewEpoch(epoch, tokenToEmit, stakerReward, previousEpochFee);\n        }\n        feesTrader[addr[0]][epoch] = feesTrader[addr[0]][epoch] + fee;\n        feesExchange[addr[1]][epoch] = feesExchange[addr[1]][epoch] + fee;\n        epochTotalFee[epoch] = epochTotalFee[epoch] + fee;\n        return;\n    }\n\n    // allows sellers of nft to claim there previous epoch rewards\n    function traderClaim(address addr, uint256[] memory epochs) public {\n        uint256 reward = 0;\n        for (uint256 index = 0; index < epochs.length; index++) {\n            require(epochs[index] < epoch);\n            reward =\n                reward +\n                (rewardTrader[epochs[index]] * feesTrader[addr][epochs[index]]) /\n                epochTotalFee[epochs[index]];\n            feesTrader[addr][epochs[index]] = 0;\n        }\n        rewardToken.transfer(addr, reward);\n    }\n\n    // allows exchange that facilated the nft trades to claim there previous epoch rewards\n    function exchangeClaim(address addr, uint256[] memory epochs) public {\n        uint256 reward = 0;\n        for (uint256 index = 0; index < epochs.length; index++) {\n            require(epochs[index] < epoch);\n            reward =\n                reward +\n                (rewardExchange[epochs[index]] * feesExchange[addr][epochs[index]]) /\n                epochTotalFee[epochs[index]];\n            feesExchange[addr][epochs[index]] = 0;\n        }\n        rewardToken.transfer(addr, reward);\n    }\n\n    /// @dev allows VeNFT holders to claim there token and eth rewards\n    ///      all tokenids must have a common owner\n    /// @param tokenids the nft ids to claim rewards for all ids in the list must belong to 1 address\n    /// @param epochs the list of epochs to claim rewards\n    function multiStakerClaim(uint256[] memory tokenids, uint256[] memory epochs) public {\n        require(address(ve) != address(0), ' VE not added yet');\n\n        uint256 reward = 0;\n        uint256 rewardEth = 0;\n        address tokenowner = ve.ownerOf(tokenids[0]);\n\n        // for each tokenid\n        for (uint256 tindex = 0; tindex < tokenids.length; tindex++) {\n            require(tokenowner == ve.ownerOf(tokenids[tindex]), 'Can only claim for a single Address together');\n            // for each epoch\n            for (uint256 index = 0; index < epochs.length; index++) {\n                require(epochs[index] < epoch, 'cant claim for future epochs');\n                require(claimed[tokenids[tindex]][epochs[index]] == 0, 'cant claim if already claimed');\n                claimed[tokenids[tindex]][epochs[index]] = 1;\n                if (epochs[index] == 0){\n                    rewardEth =\n                        rewardEth +\n                        (epochTotalFee[0] *\n                            ve.balanceOfAtNFT(tokenids[tindex], epochBeginTime[1])) /\n                        ve.totalSupplyAt(epochBeginTime[1]);\n\n                }else{\n                    reward =\n                        reward +\n                        (rewardStaker[epochs[index]] * ve.balanceOfAtNFT(tokenids[tindex], epochBeginTime[epochs[index]])) /\n                        ve.totalSupplyAt(epochBeginTime[epochs[index]]);\n                    rewardEth =\n                        rewardEth +\n                        (epochTotalFee[epochs[index]] *\n                            ve.balanceOfAtNFT(tokenids[tindex], epochBeginTime[epochs[index]])) /\n                        ve.totalSupplyAt(epochBeginTime[epochs[index]]);\n                }\n\n            }\n        }\n        rewardToken.transfer(tokenowner, reward);\n        weth.transfer(tokenowner, rewardEth);\n    }\n\n\n    /// @dev returns unclaimed rewards of an NFT, returns (unclaimed golom rewards, unclaimed eth rewards, unclaimed epochs)\n    /// @param tokenid the nft id to claim rewards for all ids in the list must belong to 1 address\n    function stakerRewards(uint256 tokenid) public view returns (\n            uint256,\n            uint256,\n            uint256[] memory\n        ){\n        require(address(ve) != address(0), ' VE not added yet');\n\n        uint256 reward = 0;\n        uint256 rewardEth = 0;\n        uint256[] memory unclaimedepochs = new uint256[](epoch);\n        // for each epoch\n        for (uint256 index = 0; index < epoch; index++) {\n            unclaimedepochs[index]=claimed[tokenid][index];\n            if (claimed[tokenid][index] == 0){\n                if (index == 0){\n                    rewardEth =\n                        rewardEth +\n                        (epochTotalFee[0] *\n                            ve.balanceOfAtNFT(tokenid, epochBeginTime[1])) /\n                        ve.totalSupplyAt(epochBeginTime[1]);\n\n                }else{\n                    reward =\n                        reward +\n                        (rewardStaker[index] * ve.balanceOfAtNFT(tokenid, epochBeginTime[index])) /\n                        ve.totalSupplyAt(epochBeginTime[index]);\n                    rewardEth =\n                        rewardEth +\n                        (epochTotalFee[index] *\n                            ve.balanceOfAtNFT(tokenid, epochBeginTime[index])) /\n                        ve.totalSupplyAt(epochBeginTime[index]);\n                }\n            }\n        }\n        return (reward, rewardEth, unclaimedepochs);\n    }\n\n    /// @dev returns unclaimed rewards of an NFT, returns (unclaimed golom rewards, unclaimed eth rewards, unclaimed epochs)\n    /// @param addr the nft id to claim rewards for all ids in the list must belong to 1"
    }
  ]
}