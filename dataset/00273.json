{
  "Title": "Queued transfers can become stuck on the source chain if Transceiver instructions are encoded in the incorrect order",
  "Content": "**Description:** In the case of multiple Transceivers, the current logic expects that a sender encodes Transceiver instructions in order of increasing Transceiver registration index, as validated in [`TransceiverStructs::parseTransceiverInstructions`](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/libraries/TransceiverStructs.sol#L326-L359). Under normal circumstances, this logic works as expected, and the transaction fails when the user packs transceiver instructions in the incorrect order.\n\n```solidity\n/* snip */\nfor (uint256 i = 0; i < instructionsLength; i++) {\n    TransceiverInstruction memory instruction;\n    (instruction, offset) = parseTransceiverInstructionUnchecked(encoded, offset);\n\n    uint8 instructionIndex = instruction.index;\n\n    // The instructions passed in have to be strictly increasing in terms of transceiver index\n    if (i != 0 && instructionIndex <= lastIndex) {\n        revert UnorderedInstructions();\n    }\n    lastIndex = instructionIndex;\n\n    instructions[instructionIndex] = instruction;\n}\n/* snip */\n```\n\nHowever, this requirement on the order of Transceiver indices is not checked when transfers are initially queued for delayed execution. As a result, a transaction where this is the case will fail when the user calls `NttManager::completeOutboundQueuedTransfer` to execute a queued transfer.\n\n**Impact:** The sender's funds are transferred to the NTT Manager when messages are queued. However, this queued message can never be executed if the Transceiver indices are incorrectly ordered and, as a result, the user funds remain stuck in the NTT Manager.\n\n**Proof of Concept:** Run the following test:\n\n```solidity\ncontract TestWrongTransceiverOrder is Test, INttManagerEvents, IRateLimiterEvents {\n    NttManager nttManagerChain1;\n    NttManager nttManagerChain2;\n\n    using TrimmedAmountLib for uint256;\n    using TrimmedAmountLib for TrimmedAmount;\n\n    uint16 constant chainId1 = 7;\n    uint16 constant chainId2 = 100;\n    uint8 constant FAST_CONSISTENCY_LEVEL = 200;\n    uint256 constant GAS_LIMIT = 500000;\n\n    uint16 constant SENDING_CHAIN_ID = 1;\n    uint256 constant DEVNET_GUARDIAN_PK =\n        0xcfb12303a19cde580bb4dd771639b0d26bc68353645571a8cff516ab2ee113a0;\n    WormholeSimulator guardian;\n    uint256 initialBlockTimestamp;\n\n    WormholeTransceiver wormholeTransceiverChain1;\n    WormholeTransceiver wormholeTransceiver2Chain1;\n\n    WormholeTransceiver wormholeTransceiverChain2;\n    address userA = address(0x123);\n    address userB = address(0x456);\n    address userC = address(0x789);\n    address userD = address(0xABC);\n\n    address relayer = address(0x28D8F1Be96f97C1387e94A53e00eCcFb4E75175a);\n    IWormhole wormhole = IWormhole(0x706abc4E45D419950511e474C7B9Ed348A4a716c);\n\n    function setUp() public {\n        string memory url = \"https://goerli.blockpi.network/v1/rpc/public\";\n        vm.createSelectFork(url);\n        initialBlockTimestamp = vm.getBlockTimestamp();\n\n        guardian = new WormholeSimulator(address(wormhole), DEVNET_GUARDIAN_PK);\n\n        vm.chainId(chainId1);\n        DummyToken t1 = new DummyToken();\n        NttManager implementation =\n            new MockNttManagerContract(address(t1), INttManager.Mode.LOCKING, chainId1, 1 days);\n\n        nttManagerChain1 =\n            MockNttManagerContract(address(new ERC1967Proxy(address(implementation), \"\")));\n        nttManagerChain1.initialize();\n\n        WormholeTransceiver wormholeTransceiverChain1Implementation = new MockWormholeTransceiverContract(\n            address(nttManagerChain1),\n            address(wormhole),\n            address(relayer),\n            address(0x0),\n            FAST_CONSISTENCY_LEVEL,\n            GAS_LIMIT\n        );\n        wormholeTransceiverChain1 = MockWormholeTransceiverContract(\n            address(new ERC1967Proxy(address(wormholeTransceiverChain1Implementation), \"\"))\n        );\n\n        WormholeTransceiver wormholeTransceiverChain1Implementation2 = new MockWormholeTransceiverContract(\n            address(nttManagerChain1),\n            address(wormhole),\n            address(relayer),\n            address(0x0),\n            FAST_CONSISTENCY_LEVEL,\n            GAS_LIMIT\n        );\n        wormholeTransceiver2Chain1 = MockWormholeTransceiverContract(\n            address(new ERC1967Proxy(address(wormholeTransceiverChain1Implementation2), \"\"))\n        );\n\n\n        // Actually initialize properly now\n        wormholeTransceiverChain1.initialize();\n        wormholeTransceiver2Chain1.initialize();\n\n\n        nttManagerChain1.setTransceiver(address(wormholeTransceiverChain1));\n        nttManagerChain1.setTransceiver(address(wormholeTransceiver2Chain1));\n        nttManagerChain1.setOutboundLimit(type(uint64).max);\n        nttManagerChain1.setInboundLimit(type(uint64).max, chainId2);\n\n        // Chain 2 setup\n        vm.chainId(chainId2);\n        DummyToken t2 = new DummyTokenMintAndBurn();\n        NttManager implementationChain2 =\n            new MockNttManagerContract(address(t2), INttManager.Mode.BURNING, chainId2, 1 days);\n\n        nttManagerChain2 =\n            MockNttManagerContract(address(new ERC1967Proxy(address(implementationChain2), \"\")));\n        nttManagerChain2.initialize();\n\n        WormholeTransceiver wormholeTransceiverChain2Implementation = new MockWormholeTransceiverContract(\n            address(nttManagerChain2),\n            address(wormhole),\n            address(relayer),\n            address(0x0),\n            FAST_CONSISTENCY_LEVEL,\n            GAS_LIMIT\n        );\n\n        wormholeTransceiverChain2 = MockWormholeTransceiverContract(\n            address(new ERC1967Proxy(address(wormholeTransceiverChain2Implementation), \"\"))\n        );\n        wormholeTransceiverChain2.initialize();\n\n        nttManagerChain2.setTransceiver(address(wormholeTransceiverChain2));\n        nttManagerChain2.setOutboundLimit(type(uint64).max);\n        nttManagerChain2.setInboundLimit(type(uint64).max, chainId1);\n\n        // Register peer contracts for the nttManager and transceiver. Transceivers and nttManager each have the concept of peers here.\n        nttManagerChain1.setPeer(chainId2, bytes32(uint256(uint160(address(nttManagerChain2)))), 9);\n        nttManagerChain2.setPeer(chainId1, bytes32(uint256(uint160(address(nttManagerChain1)))), 7);\n\n        // Set peers for the transceivers\n        wormholeTransceiverChain1.setWormholePeer(\n            chainId2, bytes32(uint256(uint160(address(wormholeTransceiverChain2))))\n        );\n\n       wormholeTransceiver2Chain1.setWormholePeer(\n            chainId2, bytes32(uint256(uint160(address(wormholeTransceiverChain2))))\n        );\n\n        wormholeTransceiverChain2.setWormholePeer(\n            chainId1, bytes32(uint256(uint160(address(wormholeTransceiverChain1))))\n        );\n\n        require(nttManagerChain1.getThreshold() != 0, \"Threshold is zero with active transceivers\");\n\n        // Actually set it\n        nttManagerChain1.setThreshold(2);\n        nttManagerChain2.setThreshold(1);\n    }\n\n    function testWrongTransceiverOrder() external {\n        vm.chainId(chainId1);\n\n        // Setting up the transfer\n        DummyToken token1 = DummyToken(nttManagerChain1.token());\n        uint8 decimals = token1.decimals();\n\n        token1.mintDummy(address(userA), 5 * 10 ** decimals);\n        uint256 outboundLimit = 4 * 10 ** decimals;\n        nttManagerChain1.setOutboundLimit(outboundLimit);\n\n        vm.startPrank(userA);\n\n        uint256 transferAmount = 5 * 10 ** decimals;\n        token1.approve(address(nttManagerChain1), transferAmount);\n\n        // transfer with shouldQueue == true\n        uint64 qSeq = nttManagerChain1.transfer(\n            transferAmount, chainId2, toWormholeFormat(userB), true, encodeTransceiverInstructionsJumbled(true)\n        );\n\n        assertEq(qSeq, 0);\n        IRateLimiter.OutboundQueuedTransfer memory qt = nttManagerChain1.getOutboundQueuedTransfer(0);\n        assertEq(qt.amount.getAmount(), transferAmount.trim(decimals, decimals).getAmount());\n        assertEq(qt.recipientChain, chainId2);\n        assertEq(qt.recipient, toWormholeFormat(userB));\n        assertEq(qt.txTimestamp, initialBlockTimestamp);\n\n        // assert that the contract also locked funds from the user\n        assertEq(token1.balanceOf(address(userA)), 0);\n        assertEq(token1.balanceOf(address(nttManagerChain1)), transferAmount);\n\n         // elapse rate limit duration - 1\n        uint256 durationElapsedTime = initialBlockTimestamp + nttManagerChain1.rateLimitDuration();\n\n        vm.warp(durationElapsedTime);\n\n        vm.expectRevert(0x71f23ef2); //UnorderedInstructions() selector\n        nttManagerChain1.completeOutboundQueuedTransfer(0);\n    }\n\n    // Encode an instruction for each of the relayers\n    function encodeTransceiverInstructionsJumbled(bool relayer_off) public view returns (bytes memory) {\n        WormholeTransceiver.WormholeTransceiverInstruction memory instruction =\n            IWormholeTransceiver.WormholeTransceiverInstruction(relayer_off);\n\n        bytes memory encodedInstructionWormhole =\n            wormholeTransceiverChain1.encodeWormholeTransceiverInstruction(instruction);\n\n        TransceiverStructs.TransceiverInstruction memory TransceiverInstruction1 =\n        TransceiverStructs.TransceiverInstruction({index: 0, payload: encodedInstructionWormhole});\n        TransceiverStructs.TransceiverInstruction memory TransceiverInstruction2 =\n        TransceiverStructs.TransceiverInstruction({index: 1, payload: encodedInstructionWormhole});\n\n        TransceiverStructs.TransceiverInstruction[] memory TransceiverInstructions =\n            new TransceiverStructs.TransceiverInstruction[](2);\n\n        TransceiverInstructions[0] = TransceiverInstruction2;\n        TransceiverInstructions[1] = TransceiverInstruction1;\n\n        return TransceiverStructs.encodeTransceiverInstructions(TransceiverInstructions);\n    }\n}\n```\n\n**Recommended Mitigation:** When the transfer amount exceeds the current outbound capacity, verify the Transceiver instructions are ordered correctly before adding a message to the list of queued transfers.\n\n**Wormhole Foundation:** Fixed in [PR \\#368](https://github.com/wormhole-foundation/example-native-token-transfers/pull/368). With the cancel logic addition, we elected not to pre-validate in order to save gas.\n\n**Cyfrin:** Verified. Cancellation of queued transfers appears to have been implemented correctly; however, validation of the Transceiver instructions remains deferred to the completion step.",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "evm/src/libraries/TransceiverStructs.sol",
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity >=0.8.8 <0.9.0;\n\nimport \"wormhole-solidity-sdk/libraries/BytesParsing.sol\";\nimport \"./TrimmedAmount.sol\";\n\nlibrary TransceiverStructs {\n    using BytesParsing for bytes;\n    using TrimmedAmountLib for TrimmedAmount;\n\n    /// @notice Error thrown when the payload length exceeds the allowed maximum.\n    /// @dev Selector 0xa3419691.\n    /// @param size The size of the payload.\n    error PayloadTooLong(uint256 size);\n\n    /// @notice Error thrown when the prefix of an encoded message\n    ///         does not match the expected value.\n    /// @dev Selector 0x56d2569d.\n    /// @param prefix The prefix that was found in the encoded message.\n    error IncorrectPrefix(bytes4 prefix);\n    error UnorderedInstructions();\n\n    /// @dev Prefix for all NativeTokenTransfer payloads\n    ///      This is 0x99'N''T''T'\n    bytes4 constant NTT_PREFIX = 0x994E5454;\n\n    /// @dev Message emitted and received by the nttManager contract.\n    ///      The wire format is as follows:\n    ///      - sequence - 8 bytes\n    ///      - sender - 32 bytes\n    ///      - payloadLength - 2 bytes\n    ///      - payload - `payloadLength` bytes\n    struct NttManagerMessage {\n        /// @notice unique sequence number\n        uint64 sequence;\n        /// @notice original message sender address.\n        bytes32 sender;\n        /// @notice payload that corresponds to the type.\n        bytes payload;\n    }\n\n    function nttManagerMessageDigest(\n        uint16 sourceChainId,\n        NttManagerMessage memory m\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(sourceChainId, encodeNttManagerMessage(m)));\n    }\n\n    function encodeNttManagerMessage(NttManagerMessage memory m)\n        public\n        pure\n        returns (bytes memory encoded)\n    {\n        if (m.payload.length > type(uint16).max) {\n            revert PayloadTooLong(m.payload.length);\n        }\n        uint16 payloadLength = uint16(m.payload.length);\n        return abi.encodePacked(m.sequence, m.sender, payloadLength, m.payload);\n    }\n\n    /// @notice Parse a NttManagerMessage.\n    /// @param encoded The byte array corresponding to the encoded message\n    /// @return nttManagerMessage The parsed NttManagerMessage struct.\n    function parseNttManagerMessage(bytes memory encoded)\n        public\n        pure\n        returns (NttManagerMessage memory nttManagerMessage)\n    {\n        uint256 offset = 0;\n        (nttManagerMessage.sequence, offset) = encoded.asUint64Unchecked(offset);\n        (nttManagerMessage.sender, offset) = encoded.asBytes32Unchecked(offset);\n        uint256 payloadLength;\n        (payloadLength, offset) = encoded.asUint16Unchecked(offset);\n        (nttManagerMessage.payload, offset) = encoded.sliceUnchecked(offset, payloadLength);\n        encoded.checkLength(offset);\n    }\n\n    /// @dev Native Token Transfer payload.\n    ///      The wire format is as follows:\n    ///      - NTT_PREFIX - 4 bytes\n    ///      - numDecimals - 1 byte\n    ///      - amount - 8 bytes\n    ///      - sourceToken - 32 bytes\n    ///      - to - 32 bytes\n    ///      - toChain - 2 bytes\n    struct NativeTokenTransfer {\n        /// @notice Amount being transferred (big-endian u64 and u8 for decimals)\n        TrimmedAmount amount;\n        /// @notice Source chain token address.\n        bytes32 sourceToken;\n        /// @notice Address of the recipient.\n        bytes32 to;\n        /// @notice Chain ID of the recipient\n        uint16 toChain;\n    }\n\n    function encodeNativeTokenTransfer(NativeTokenTransfer memory m)\n        public\n        pure\n        returns (bytes memory encoded)\n    {\n        TrimmedAmount memory transferAmount = m.amount;\n        return abi.encodePacked(\n            NTT_PREFIX,\n            transferAmount.getDecimals(),\n            transferAmount.getAmount(),\n            m.sourceToken,\n            m.to,\n            m.toChain\n        );\n    }\n\n    /// @dev Parse a NativeTokenTransfer.\n    /// @param encoded The byte array corresponding to the encoded message\n    /// @return nativeTokenTransfer The parsed NativeTokenTransfer struct.\n    function parseNativeTokenTransfer(bytes memory encoded)\n        public\n        pure\n        returns (NativeTokenTransfer memory nativeTokenTransfer)\n    {\n        uint256 offset = 0;\n        bytes4 prefix;\n        (prefix, offset) = encoded.asBytes4Unchecked(offset);\n        if (prefix != NTT_PREFIX) {\n            revert IncorrectPrefix(prefix);\n        }\n\n        uint8 numDecimals;\n        (numDecimals, offset) = encoded.asUint8Unchecked(offset);\n        uint64 amount;\n        (amount, offset) = encoded.asUint64Unchecked(offset);\n        nativeTokenTransfer.amount = TrimmedAmount(amount, numDecimals);\n\n        (nativeTokenTransfer.sourceToken, offset) = encoded.asBytes32Unchecked(offset);\n        (nativeTokenTransfer.to, offset) = encoded.asBytes32Unchecked(offset);\n        (nativeTokenTransfer.toChain, offset) = encoded.asUint16Unchecked(offset);\n        encoded.checkLength(offset);\n    }\n\n    /// @dev Message emitted by Transceiver implementations.\n    ///      Each message includes an Transceiver-specified 4-byte prefix.\n    ///      The wire format is as follows:\n    ///      - prefix - 4 bytes\n    ///      - sourceNttManagerAddress - 32 bytes\n    ///      - recipientNttManagerAddress - 32 bytes\n    ///      - nttManagerPayloadLength - 2 bytes\n    ///      - nttManagerPayload - `nttManagerPayloadLength` bytes\n    ///      - transceiverPayloadLength - 2 bytes\n    ///      - transceiverPayload - `transceiverPayloadLength` bytes\n    struct TransceiverMessage {\n        /// @notice Address of the NttManager contract that emitted this message.\n        bytes32 sourceNttManagerAddress;\n        /// @notice Address of the NttManager contract that receives this message.\n        bytes32 recipientNttManagerAddress;\n        /// @notice Payload provided to the Transceiver contract by the NttManager contract.\n        bytes nttManagerPayload;\n        /// @notice Optional payload that the transceiver can encode and use for its own message passing purposes.\n        bytes transceiverPayload;\n    }\n\n    // @notice Encodes an Transceiver message for communication between the\n    //         NttManager and the Transceiver.\n    // @param m The TransceiverMessage struct containing the message details.\n    // @return encoded The byte array corresponding to the encoded message.\n    // @custom:throw PayloadTooLong if the length of transceiverId, nttManagerPayload,\n    //         or transceiverPayload exceeds the allowed maximum.\n    function encodeTransceiverMessage(\n        bytes4 prefix,\n        TransceiverMessage memory m\n    ) public pure returns (bytes memory encoded) {\n        if (m.nttManagerPayload.length > type(uint16).max) {\n            revert PayloadTooLong(m.nttManagerPayload.length);\n        }\n        uint16 nttManagerPayloadLength = uint16(m.nttManagerPayload.length);\n\n        if (m.transceiverPayload.length > type(uint16).max) {\n            revert PayloadTooLong(m.transceiverPayload.length);\n        }\n        uint16 transceiverPayloadLength = uint16(m.transceiverPayload.length);\n\n        return abi.encodePacked(\n            prefix,\n            m.sourceNttManagerAddress,\n            m.recipientNttManagerAddress,\n            nttManagerPayloadLength,\n            m.nttManagerPayload,\n            transceiverPayloadLength,\n            m.transceiverPayload\n        );\n    }\n\n    function buildAndEncodeTransceiverMessage(\n        bytes4 prefix,\n        bytes32 sourceNttManagerAddress,\n        bytes32 recipientNttManagerAddress,\n        bytes memory nttManagerMessage,\n        bytes memory transceiverPayload\n    ) public pure returns (TransceiverMessage memory, bytes memory) {\n        TransceiverMessage memory transceiverMessage = TransceiverMessage({\n            sourceNttManagerAddress: sourceNttManagerAddress,\n            recipientNttManagerAddress: recipientNttManagerAddress,\n            nttManagerPayload: nttManagerMessage,\n            transceiverPayload: transceiverPayload\n        });\n        bytes memory encoded = encodeTransceiverMessage(prefix, transceiverMessage);\n        return (transceiverMessage, encoded);\n    }\n\n    /// @dev Parses an encoded message and extracts information into an TransceiverMessage struct.\n    /// @param encoded The encoded bytes containing information about the TransceiverMessage.\n    /// @return transceiverMessage The parsed TransceiverMessage struct.\n    /// @custom:throw IncorrectPrefix if the prefix of the encoded message does not\n    ///         match the expected prefix.\n    function parseTransceiverMessage(\n        bytes4 expectedPrefix,\n        bytes memory encoded\n    ) internal pure returns (TransceiverMessage memory transceiverMessage) {\n        uint256 offset = 0;\n        bytes4 prefix;\n\n        (prefix, offset) = encoded.asBytes4Unchecked(offset);\n\n        if (prefix != expectedPrefix) {\n            revert IncorrectPrefix(prefix);\n        }\n\n        (transceiverMessage.sourceNttManagerAddress, offset) = encoded.asBytes32Unchecked(offset);\n        (transceiverMessage.recipientNttManagerAddress, offset) = encoded.asBytes32Unchecked(offset);\n        uint16 nttManagerPayloadLength;\n        (nttManagerPayloadLength, offset) = encoded.asUint16Unchecked(offset);\n        (transceiverMessage.nttManagerPayload, offset) =\n            encoded.sliceUnchecked(offset, nttManagerPayloadLength);\n        uint16 transceiverPayloadLength;\n        (transceiverPayloadLength, offset) = encoded.asUint16Unchecked(offset);\n        (transceiverMessage.transceiverPayload, offset) =\n            encoded.sliceUnchecked(offset, transceiverPayloadLength);\n\n        // Check if the entire byte array has been processed\n        encoded.checkLength(offset);\n    }\n\n    /// @dev Parses the payload of an Transceiver message and returns\n    ///      the parsed NttManagerMessage struct.\n    /// @param expectedPrefix The prefix that should be encoded in the nttManager message.\n    /// @param payload The payload sent across the wire.\n    function parseTransceiverAndNttManagerMessage(\n        bytes4 expectedPrefix,\n        bytes memory payload\n    ) public pure returns (TransceiverMessage memory, NttManagerMessage memory) {\n        // parse the encoded message payload from the Transceiver\n        TransceiverMessage memory parsedTransceiverMessage =\n            parseTransceiverMessage(expectedPrefix, payload);\n\n        // parse the encoded message payload from the NttManager\n        NttManagerMessage memory parsedNttManagerMessage =\n            parseNttManagerMessage(parsedTransceiverMessage.nttManagerPayload);\n\n        return (parsedTransceiverMessage, parsedNttManagerMessage);\n    }\n\n    /// @dev Variable-length transceiver-specific instruction that can be passed by the caller to the nttManager.\n    ///      The index field refers to the index of the registeredTransceiver that this instruction should be passed to.\n    ///      The serialization format is:\n    ///      - index - 1 byte\n    ///      - payloadLength - 1 byte\n    ///      - payload - `payloadLength` bytes\n    struct TransceiverInstruction {\n        uint8 index;\n        bytes payload;\n    }\n\n    function encodeTransceiverInstruction(TransceiverInstruction memory instruction)\n        public\n        pure\n        returns (bytes memory)\n    {\n        if (instruction.payload.length > type(uint8).max) {\n            revert PayloadTooLong(instruction.payload.length);\n        }\n        uint8 payloadLength = uint8(instruction.payload.length);\n        return abi.encodePacked(instruction.index, payloadLength, instruction.payload);\n    }\n\n    function parseTransceiverInstructionUnchecked(\n        bytes memory encoded,\n        uint256 offset\n    ) public pure returns (TransceiverInstruction memory instruction, uint256 nextOffset) {\n        (instruction.index, nextOffset) = encoded.asUint8Unchecked(offset);\n        uint8 instructionLength;\n        (instructionLength, nextOffset) = encoded.asUint8Unchecked(nextOffset);\n        (instruction.payload, nextOffset) = encoded.sliceUnchecked(nextOffset, instructionLength);\n    }\n\n    function parseTransceiverInstructionChecked(bytes memory encoded)\n        public\n        pure\n        returns (TransceiverInstruction memory instruction)\n    {\n        uint256 offset = 0;\n        (instruction, offset) = parseTransceiverInstructionUnchecked(encoded, offset);\n        encoded.checkLength(offset);\n    }\n\n    /// @dev Encode an array of multiple variable-length transceiver-specific instructions.\n    ///      The serialization format is:\n    ///      - instructionsLength - 1 byte\n    ///      - `instructionsLength` number of serialized `TransceiverInstruction` types.\n    function encodeTransceiverInstructions(TransceiverInstruction[] memory instructions)\n        public\n        pure\n        returns (bytes memory)\n    {\n        if (instructions.length > type(uint8).max) {\n            revert PayloadTooLong(instructions.length);\n        }\n        uint256 instructionsLength = instructions.length;\n\n        bytes memory encoded;\n        for (uint256 i = 0; i < instructionsLength; i++) {\n            bytes memory innerEncoded = encodeTransceiverInstruction(instructions[i]);\n            encoded = bytes.concat(encoded, innerEncoded);\n        }\n        return abi.encodePacked(uint8(instructionsLength), encoded);\n    }\n\n    function parseTransceiverInstructions(\n        bytes memory encoded,\n        uint256 numEnabledTransceivers\n    ) public pure returns (TransceiverInstruction[] memory) {\n        uint256 offset = 0;\n        uint256 instructionsLength;\n        (instructionsLength, offset) = encoded.asUint8Unchecked(offset);\n\n        // We allocate an array with the length of the number of enabled transceivers\n        // This gives us the flexibility to not have to pass instructions for transceivers that\n        // don't need them\n        TransceiverInstruction[] memory instructions =\n            new TransceiverInstruction[](numEnabledTransceivers);\n\n        uint256 lastIndex = 0;\n        for (uint256 i = 0; i < instructionsLength; i++) {\n            TransceiverInstruction memory instruction;\n            (instruction, offset) = parseTransceiverInstructionUnchecked(encoded, offset);\n\n            uint8 instructionIndex = instruction.index;\n\n            // The instructions passed in have to be strictly increasing in terms of transceiver index\n            if (i != 0 && instructionIndex <= lastIndex) {\n                revert UnorderedInstructions();\n            }\n            lastIndex = instructionIndex;\n\n            instructions[instructionIndex] = instruction;\n        }\n\n        encoded.checkLength(offset);\n\n        return instructions;\n    }\n\n    struct TransceiverInit {\n        bytes4 transceiverIdentifier;\n        bytes32 nttManagerAddress;\n        uint8 nttManagerMode;\n        bytes32 tokenAddress;\n        uint8 tokenDecimals;\n    }\n\n    function encodeTransceiverInit(TransceiverInit memory init)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(\n            init.transceiverIdentifier,\n            init.nttManagerAddress,\n            init.nttManagerMode,\n            init.tokenAddress,\n            init.tokenDecimals\n        );\n    }\n\n    function decodeTransceiverInit(bytes memory encoded)\n        public\n        pure\n        returns (TransceiverInit memory init)\n    {\n        uint256 offset = 0;\n        (init.transceiverIdentifier, offset) = encoded.asBytes4Unchecked(offset);\n        (init.nttManagerAddress, offset) = encoded.asBytes32Unchecked(offset);\n        (init.nttManagerMode, offset) = encoded.asUint8Unchecked(offset);\n        (init.tokenAddress, offset) = encoded.asBytes32Unchecked(offset);\n        (init.tokenDecimals, offset) = encoded.asUint8Unchecked(offset);\n        encoded.checkLength(offset);\n    }\n\n    struct TransceiverRegistration {\n        bytes4 transceiverIdentifier;\n        uint16 transceiverChainId;\n        bytes32 transceiverAddress;\n    }\n\n    function encodeTransceiverRegistration(TransceiverRegistration memory registration)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(\n            registration.transceiverIdentifier,\n            registration.transceiverChainId,\n            registration.transceiverAddress\n        );\n    }\n\n    function decodeTransceiverRegistration(bytes memory encoded)\n        public\n        pure\n        returns (TransceiverRegistration memory registration)\n    {\n        uint256 offset = 0;\n        (registration.transceiverIdentifier, offset) = encoded.asBytes4Unchecked(offset);\n        (registration.transceiverChainId, offset) = encoded.asUint16Unchecked(offset);\n        (registration.transceiverAddress, offset) = encoded.asBytes32Unchecked(offset);\n        encoded.checkLength(offset);\n    }\n}"
    }
  ]
}