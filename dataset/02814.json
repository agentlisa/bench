{
  "Title": "M-7: Notional PT redemptions do not use flash-resistant prices",
  "Content": "# Issue M-7: Notional PT redemptions do not use flash-resistant prices \n\nSource: https://github.com/sherlock-audit/2022-10-illuminate-judging/issues/110 \n\n## Found by \nIllIllI\n\n## Summary\n\nNotional PT redemptions do not use the correct function for determining balances, which will lead to principal losses\n\n\n## Vulnerability Detail\n\nEIP-4626 states the following about `maxRedeem()`:\n```markdown\nMUST return the maximum amount of shares that could be transferred from `owner` through `redeem` and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary).\n\nMUST factor in both global and user-specific limits, like if redemption is entirely disabled (even temporarily) it MUST return 0.\n```\nhttps://github.com/ethereum/EIPs/blob/12fb4072a8204ae89c384a5562dedfdac32a3bec/EIPS/eip-4626.md?plain=1#L414-L416\n\n\nThe above means that the implementer is free to return less than the actual balance, and is in fact _required_ to return zero if the token's backing store is paused, and Notional's [can be paused](https://docs.notional.finance/developer-documentation/on-chain/notional-governance-reference#pauseability). While neither of these conditions currently apply to the existing [wfCashERC4626 implementation](https://github.com/notional-finance/wrapped-fcash/blob/ad5c145d9988eeee6e36cf93cc3412449e4e7eba/contracts/wfCashERC4626.sol#L89-L92), there is nothing stopping Notional from implementing the MUST-return-zero-if-paused fix tomorrow, or from changing their implementation to one that requires `maxRedeem()` to return something other than the current balance. \n\n\n## Impact\n\n_Permanent freezing of funds_\n\nIf `maxRedeem()` were to return zero, or some other non-exact value, fewer Notional PTs would be redeemed than are available, and users that `redeem()`ed their shares, would receive fewer underlying (principal if they minted Illuminate PTs with Notional PTs, e.g. to be an LP in the pool) than they are owed. The Notional PTs that weren't redeemed would still be available for a subsequent call, but if a user already redeemed their Illuminate PTs, their loss will already be locked in, since their Illuminate PTs will have been burned. This would affect _ALL_ Illuminate PT holders of a specific market, not just the ones that provided the Notional PTs, because Illuminate PT redemptions are an a share-of-underlying basis, not on the basis of the originally-provided token. Markets that are already live with Notional set cannot be protected via a redemption pause by the Illuminate admin, because redemption of `Lender`'s external PTs for underlying does not use the `unpaused` modifier, and does have any access control.\n\n\n## Code Snippet\n\n```solidity\n// File: src/Redeemer.sol : Redeemer.redeem()   #1\n\n309                // Retrieve the pool for the principal token\n310                address pool = ITempusToken(principal).pool();\n311    \n312                // Redeems principal tokens from Tempus\n313                ITempus(tempusAddr).redeemToBacking(pool, amount, 0, address(this));\n314            } else if (p == uint8(MarketPlace.Principals.Apwine)) {\n315                apwineWithdraw(principal, u, amount);\n316            } else if (p == uint8(MarketPlace.Principals.Notional)) {\n317                // Redeems principal tokens from Notional\n318                INotional(principal).redeem(\n319 @>                 INotional(principal).maxRedeem(address(this)),\n320                    address(this),\n321                    address(this)\n322                );\n323            }\n324    \n325            // Calculate how much underlying was redeemed\n326            uint256 redeemed = IERC20(u).balanceOf(address(this)) - starting;\n327    \n328            // Update the holding for this market\n329:           holdings[u][m] = holdings[u][m] + redeemed;\n```\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Redeemer.sol#L309-L329\n\n\nRedemptions of Illuminate PTs for underlyings is based on shares of each Illuminate PT's `totalSupply()` of the _available_ underlying, not the expect underlying total:\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Redeemer.sol#L422\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Redeemer.sol#L464\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Redeemer.sol#L517\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nUse `balanceOf()` rather than `maxRedeem()` in the call to `INotional.redeem()`, and make sure that Illuminate PTs can't be burned if `Lender` still has Notional PTs that it needs to redeem (based on its own accounting of what is remaining, not based on balance checks, so that it can't be griefed with dust).\n\n\n## Discussion\n\n**0x00052**\n\nEscalate for 25 USDC\n\n`While neither of these conditions currently apply to the existing wfCashERC4626 implementation, there is nothing stopping Notional from implementing the MUST-return-zero-if-paused fix tomorrow, or from changing their implementation to one that requires maxRedeem() to return something other than the current balance.`\n\nWatson clearly acknowledges external factors required for loss of funds. There are so many upgradable contracts that Illuminate integrates with. Seems crazy to me to submit a report for every way that any integrated protocol could upgrade to brick/damage this contract. I think low is most appropriate given the requirement that an underlying protocol has to upgrade to cause damage. Worst case medium but I think that is generous.\n\n**sherlock-admin**\n\n > Escalate for 25 USDC\n> \n> `While neither of these conditions currently apply to the existing wfCashERC4626 implementation, there is nothing stopping Notional from implementing the MUST-return-zero-if-paused fix tomorrow, or from changing their implementation to one that requires maxRedeem() to return something other than the current balance.`\n> \n> Watson clearly acknowledges external factors required for loss of funds. There are so many upgradable contracts that Illuminate integrates with. Seems crazy to me to submit a report for every way that any integrated protocol could upgrade to brick/damage this contract. I think low is most appropriate given the requirement that an underlying protocol has to upgrade to cause damage. Worst case medium but I think that is generous.\n\nYou've created a valid escalation for 25 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**KenzoAgada**\n\nEscalate for 50 USDC\nSee 52's comments above. At the moment no issue is there, the issue is only if Notional's implementation is changed. Might be considered medium severity.\n\n**sherlock-admin**\n\n > Escalate for 50 USDC\n> See 52's comments above. At the moment no issue is there, the issue is only if Notional's implementation is changed. Might be considered medium severity.\n\nYou've created a valid escalation for 50 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation accepted\n\n**sherlock-admin**\n\n> Escalation accepted\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/12",
  "Code": [
    {
      "filename": "EIPS/eip-4626.md?plain=1",
      "content": "---\neip: 4626\ntitle: Tokenized Vaults\ndescription: Tokenized Vaults with a single underlying EIP-20 token.\nauthor: Joey Santoro (@joeysantoro), t11s (@transmissions11), Jet Jadeja (@JetJadeja), Alberto Cuesta Cañada (@alcueca), Señor Doggo (@fubuloubu)\ndiscussions-to: https://ethereum-magicians.org/t/eip-4626-yield-bearing-vault-standard/7900\nstatus: Final\ntype: Standards Track\ncategory: ERC\ncreated: 2021-12-22\nrequires: 20, 2612\n---\n\n## Abstract\n\nThe following standard allows for the implementation of a standard API for tokenized Vaults\nrepresenting shares of a single underlying [EIP-20](./eip-20.md) token.\nThis standard is an extension on the EIP-20 token that provides basic functionality for depositing\nand withdrawing tokens and reading balances.\n\n## Motivation\n\nTokenized Vaults have a lack of standardization leading to diverse implementation details.\nSome various examples include lending markets, aggregators, and intrinsically interest bearing tokens.\nThis makes integration difficult at the aggregator or plugin layer for protocols which need to conform to many standards, and forces each protocol to implement their own adapters which are error prone and waste development resources.\n\nA standard for tokenized Vaults will lower the integration effort for yield-bearing vaults, while creating more consistent and robust implementation patterns.\n\n## Specification\n\nAll [EIP-4626](./eip-4626.md) tokenized Vaults MUST implement EIP-20 to represent shares.\nIf a Vault is to be non-transferrable, it MAY revert on calls to `transfer` or `transferFrom`.\nThe EIP-20 operations `balanceOf`, `transfer`, `totalSupply`, etc. operate on the Vault \"shares\"\nwhich represent a claim to ownership on a fraction of the Vault's underlying holdings.\n\nAll EIP-4626 tokenized Vaults MUST implement EIP-20's optional metadata extensions.\nThe `name` and `symbol` functions SHOULD reflect the underlying token's `name` and `symbol` in some way.\n\nEIP-4626 tokenized Vaults MAY implement [EIP-2612](./eip-2612.md) to improve the UX of approving shares on various integrations.\n\n### Definitions:\n\n- asset: The underlying token managed by the Vault.\n  Has units defined by the corresponding EIP-20 contract.\n- share: The token of the Vault. Has a ratio of underlying assets\n  exchanged on mint/deposit/withdraw/redeem (as defined by the Vault).\n- fee: An amount of assets or shares charged to the user by the Vault. Fees can exists for\n  deposits, yield, AUM, withdrawals, or anything else prescribed by the Vault.\n- slippage: Any difference between advertised share price and economic realities of\n  deposit to or withdrawal from the Vault, which is not accounted by fees.\n\n### Methods\n\n#### asset\n\nThe address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n\nMUST be an EIP-20 token contract.\n\nMUST _NOT_ revert.\n\n```yaml\n- name: asset\n  type: function\n  stateMutability: view\n\n  inputs: []\n\n  outputs:\n    - name: assetTokenAddress\n      type: address\n```\n\n#### totalAssets\n\nTotal amount of the underlying asset that is \"managed\" by Vault.\n\nSHOULD include any compounding that occurs from yield.\n\nMUST be inclusive of any fees that are charged against assets in the Vault.\n\nMUST _NOT_ revert.\n\n```yaml\n- name: totalAssets\n  type: function\n  stateMutability: view\n\n  inputs: []\n\n  outputs:\n    - name: totalManagedAssets\n      type: uint256\n```\n\n#### convertToShares\n\nThe amount of shares that the Vault would exchange for the amount of assets provided, in an ideal scenario where all the conditions are met.\n\nMUST NOT be inclusive of any fees that are charged against assets in the Vault.\n\nMUST NOT show any variations depending on the caller.\n\nMUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n\nMUST NOT revert unless due to integer overflow caused by an unreasonably large input.\n\nMUST round down towards 0.\n\nThis calculation MAY NOT reflect the \"per-user\" price-per-share, and instead should reflect the \"average-user's\" price-per-share, meaning what the average user should expect to see when exchanging to and from.\n\n```yaml\n- name: convertToShares\n  type: function\n  stateMutability: view\n\n  inputs:\n    - name: assets\n      type: uint256\n\n  outputs:\n    - name: shares\n      type: uint256\n```\n\n#### convertToAssets\n\nThe amount of assets that the Vault would exchange for the amount of shares provided, in an ideal scenario where all the conditions are met.\n\nMUST NOT be inclusive of any fees that are charged against assets in the Vault.\n\nMUST NOT show any variations depending on the caller.\n\nMUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n\nMUST NOT revert unless due to integer overflow caused by an unreasonably large input.\n\nMUST round down towards 0.\n\nThis calculation MAY NOT reflect the \"per-user\" price-per-share, and instead should reflect the \"average-user's\" price-per-share, meaning what the average user should expect to see when exchanging to and from.\n\n```yaml\n- name: convertToAssets\n  type: function\n  stateMutability: view\n\n  inputs:\n    - name: shares\n      type: uint256\n\n  outputs:\n    - name: assets\n      type: uint256\n```\n\n#### maxDeposit\n\nMaximum amount of the underlying asset that can be deposited into the Vault for the `receiver`, through a `deposit` call.\n\nMUST return the maximum amount of assets `deposit` would allow to be deposited for `receiver` and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary). This assumes that the user has infinite assets, i.e. MUST NOT rely on `balanceOf` of `asset`.\n\nMUST factor in both global and user-specific limits, like if deposits are entirely disabled (even temporarily) it MUST return 0.\n\nMUST return `2 ** 256 - 1` if there is no limit on the maximum amount of assets that may be deposited.\n\nMUST NOT revert.\n\n```yaml\n- name: maxDeposit\n  type: function\n  stateMutability: view\n\n  inputs:\n    - name: receiver\n      type: address\n\n  outputs:\n    - name: maxAssets\n      type: uint256\n```\n\n#### previewDeposit\n\nAllows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given current on-chain conditions.\n\nMUST return as close to and no more than the exact amount of Vault shares that would be minted in a `deposit` call in the same transaction. I.e. `deposit` should return the same or more `shares` as `previewDeposit` if called in the same transaction.\n\nMUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the deposit would be accepted, regardless if the user has enough tokens approved, etc.\n\nMUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n\nMUST NOT revert due to vault specific user/global limits. MAY revert due to other conditions that would also cause `deposit` to revert.\n\nNote that any unfavorable discrepancy between `convertToShares` and `previewDeposit` SHOULD be considered slippage in share price or some other type of condition, meaning the depositor will lose assets by depositing.\n\n```yaml\n- name: previewDeposit\n  type: function\n  stateMutability: view\n\n  inputs:\n    - name: assets\n      type: uint256\n\n  outputs:\n    - name: shares\n      type: uint256\n```\n\n#### deposit\n\nMints `shares` Vault shares to `receiver` by depositing exactly `assets` of underlying tokens.\n\nMUST emit the `Deposit` event.\n\nMUST support EIP-20 `approve` / `transferFrom` on `asset` as a deposit flow.\nMAY support an additional flow in which the underlying tokens are owned by the Vault contract before the `deposit` execution, and are accounted for during `deposit`.\n\nMUST revert if all of `assets` cannot be deposited (due to deposit limit being reached, slippage, the user not approving enough underlying tokens to the Vault contract, etc).\n\nNote that most implementations will require pre-approval of the Vault with the Vault's underlying `asset` token.\n\n```yaml\n- name: deposit\n  type: function\n  stateMutability: nonpayable\n\n  inputs:\n    - name: assets\n      type: uint256\n    - name: receiver\n      type: address\n\n  outputs:\n    - name: shares\n      type: uint256\n```\n\n#### maxMint\n\nMaximum amount of shares that can be minted from the Vault for the `receiver`, through a `mint` call.\n\nMUST return the maximum amount of shares `mint` would allow to be deposited to `receiver` and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary). This assumes that the user has infinite assets, i.e. MUST NOT rely on `balanceOf` of `asset`.\n\nMUST factor in both global and user-specific limits, like if mints are entirely disabled (even temporarily) it MUST return 0.\n\nMUST return `2 ** 256 - 1` if there is no limit on the maximum amount of shares that may be minted.\n\nMUST NOT revert.\n\n```yaml\n- name: maxMint\n  type: function\n  stateMutability: view\n\n  inputs:\n    - name: receiver\n      type: address\n\n  outputs:\n    - name: maxShares\n      type: uint256\n```\n\n#### previewMint\n\nAllows an on-chain or off-chain user to simulate the effects of their mint at the current block, given current on-chain conditions.\n\nMUST return as close to and no fewer than the exact amount of assets that would be deposited in a `mint` call in the same transaction. I.e. `mint` should return the same or fewer `assets` as `previewMint` if called in the same transaction.\n\nMUST NOT account for mint limits like those returned from maxMint and should always act as though the mint would be accepted, regardless if the user has enough tokens approved, etc.\n\nMUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n\nMUST NOT revert due to vault specific user/global limits. MAY revert due to other conditions that would also cause `mint` to revert.\n\nNote that any unfavorable discrepancy between `convertToAssets` and `previewMint` SHOULD be considered slippage in share price or some other type of condition, meaning the depositor will lose assets by minting.\n\n```yaml\n- name: previewMint\n  type: function\n  stateMutability: view\n\n  inputs:\n    - name: shares\n      type: uint256\n\n  outputs:\n    - name: assets\n      type: uint256\n```\n\n#### mint\n\nMints exactly `shares` Vault shares to `receiver` by depositing `assets` of underlying tokens.\n\nMUST emit the `Deposit` event.\n\nMUST support EIP-20 `approve` / `transferFrom` on `asset` as a mint flow.\nMAY support an additional flow in which the underlying tokens are owned by the Vault contract before the `mint` execution, and are accounted for during `mint`.\n\nMUST revert if all of `shares` cannot be minted (due to deposit limit being reached, slippage, the user not approving enough underlying tokens to the Vault contract, etc).\n\nNote that most implementations will require pre-approval of the Vault with the Vault's underlying `asset` token.\n\n```yaml\n- name: mint\n  type: function\n  stateMutability: nonpayable\n\n  inputs:\n    - name: shares\n      type: uint256\n    - name: receiver\n      type: address\n\n  outputs:\n    - name: assets\n      type: uint256\n```\n\n#### maxWithdraw\n\nMaximum amount of the underlying asset that can be withdrawn from the `owner` balance in the Vault, through a `withdraw` call.\n\nMUST return the maximum amount of assets that could be transferred from `owner` through `withdraw` and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary).\n\nMUST factor in both global and user-specific limits, like if withdrawals are entirely disabled (even temporarily) it MUST return 0.\n\nMUST NOT revert.\n\n```yaml\n- name: maxWithdraw\n  type: function\n  stateMutability: view\n\n  inputs:\n    - name: owner\n      type: address\n\n  outputs:\n    - name: maxAssets\n      type: uint256\n```\n\n#### previewWithdraw\n\nAllows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block, given current on-chain conditions.\n\nMUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a `withdraw` call in the same transaction. I.e. `withdraw` should return the same or fewer `shares` as `previewWithdraw` if called in the same transaction.\n\nMUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though the withdrawal would be accepted, regardless if the user has enough shares, etc.\n\nMUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n\nMUST NOT revert due to vault specific user/global limits. MAY revert due to other conditions that would also cause `withdraw` to revert.\n\nNote that any unfavorable discrepancy between `convertToShares` and `previewWithdraw` SHOULD be considered slippage in share price or some other type of condition, meaning the depositor will lose assets by depositing.\n\n```yaml\n- name: previewWithdraw\n  type: function\n  stateMutability: view\n\n  inputs:\n    - name: assets\n      type: uint256\n\n  outputs:\n    - name: shares\n      type: uint256\n```\n\n#### withdraw\n\nBurns `shares` from `owner` and sends exactly `assets` of underlying tokens to `receiver`.\n\nMUST emit the `Withdraw` event.\n\nMUST support a withdraw flow where the shares are burned from `owner` directly where `owner` is `msg.sender`.\n\nMUST support a withdraw flow where the shares are burned from `owner` directly where `msg.sender` has EIP-20 approval over the shares of `owner`.\n\nMAY support an additional flow in which the shares are transferred to the Vault contract before the `withdraw` execution, and are accounted for during `withdraw`.\n\nSHOULD check `msg.sender` can spend owner funds, assets needs to be converted to shares and shares should be checked for allowance.\n\nMUST revert if all of `assets` cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner not having enough shares, etc).\n\nNote that some implementations will require pre-requesting to the Vault before a withdrawal may be performed. Those methods should be performed separately.\n\n```yaml\n- name: withdraw\n  type: function\n  stateMutability: nonpayable\n\n  inputs:\n    - name: assets\n      type: uint256\n    - name: receiver\n      type: address\n    - name: owner\n      type: address\n\n  outputs:\n    - name: shares\n      type: uint256\n```\n\n#### maxRedeem\n\nMaximum amount of Vault shares that can be redeemed from the `owner` balance in the Vault, through a `redeem` call.\n\nMUST return the maximum amount of shares that could be transferred from `owner` through `redeem` and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary).\n\nMUST factor in both global and user-specific limits, like if redemption is entirely disabled (even temporarily) it MUST return 0.\n\nMUST NOT revert.\n\n```yaml\n- name: maxRedeem\n  type: function\n  stateMutability: view\n\n  inputs:\n    - name: owner\n      type: address\n\n  outputs:\n    - name: maxShares\n      type: uint256\n```\n\n#### previewRedeem\n\nAllows an on-chain or off-chain user to simulate the effects of their redeemption at the current block, given current on-chain conditions.\n\nMUST return as close to and no more than the exact amount of assets that would be withdrawn in a `redeem` call in the same transaction. I.e. `redeem` should return the same or more `assets` as `previewRedeem` if called in the same transaction.\n\nMUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the redemption would be accepted, regardless if the user has enough shares, etc.\n\nMUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n\nMUST NOT revert due to vault specific user/global limits. MAY revert due to other conditions that would also cause `redeem` to revert.\n\nNote that any unfavorable discrepancy between `convertToAssets` and `previewRedeem` SHOULD be considered slippage in share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n\n```yaml\n- name: previewRedeem\n  type: function\n  stateMutability: view\n\n  inputs:\n    - name: shares\n      type: uint256\n\n  outputs:\n    - name: assets\n      type: uint256\n```\n\n#### redeem\n\nBurns exactly `shares` from `owner` and sends `assets` of underlying tokens to `receiver`.\n\nMUST emit the `Withdraw` event.\n\nMUST support a redeem flow where the shares are burned from `owner` directly where `owner` is `msg.sender`.\n\nMUST support a redeem flow where the shares are burned from `owner` directly where `msg.sender` has EIP-20 approval over the shares of `owner`.\n\nMAY support an additional flow in which the shares are transferred to the Vault contract before the `redeem` execution, and are accounted for during `redeem`.\n\nSHOULD check `msg.sender` can spend owner funds using allowance.\n\nMUST revert if all of `shares` cannot be redeemed (due to withdrawal limit being reached, slippage, the owner not having enough shares, etc).\n\nNote that some implementations will require pre-requesting to the Vault before a withdrawal may be performed. Those methods should be performed separately.\n\n```yaml\n- name: redeem\n  type: function\n  stateMutability: nonpayable\n\n  inputs:\n    - name: shares\n      type: uint256\n    - name: receiver\n      type: address\n    - name: owner\n      type: address\n\n  outputs:\n    - name: assets\n      type: uint256\n```\n\n### Events\n\n#### Deposit\n\n`sender` has exchanged `assets` for `shares`, and transferred those `shares` to `owner`.\n\nMUST be emitted when tokens are deposited into the Vault via the `mint` and `deposit` methods.\n\n```yaml\n- name: Deposit\n  type: event\n\n  inputs:\n    - name: sender\n      indexed: true\n      type: address\n    - name: owner\n      indexed: true\n      type: address\n    - name: assets\n      indexed: false\n      type: uint256\n    - name: shares\n      indexed: false\n      type: uint256\n```\n\n#### Withdraw\n\n`sender` has exchanged `shares`, owned by `owner`, for `assets`, and transferred those `assets` to `receiver`.\n\nMUST be emitted when shares are withdrawn from the Vault in `EIP-4626.redeem` or `EIP-4626.withdraw` methods.\n\n```yaml\n- name: Withdraw\n  type: event\n\n  inputs:\n    - name: sender\n      indexed: true\n      type: address\n    - name: receiver\n      indexed: true\n      type: address\n    - name: owner\n      indexed: true\n      type: address\n    - name: assets\n      indexed: false\n      type: uint256\n    - name: shares\n      indexed: false\n      type: uint256\n```\n\n## Rationale\n\nThe Vault interface is designed to be optimized for integrators with a feature complete yet minimal interface.\nDetails such as accounting and allocation of deposited tokens are intentionally not specified,\nas Vaults are expected to be treated as black boxes on-chain and inspected off-chain before use.\n\nEIP-20 is enforced because implementation details like token approval\nand balance calculation directly carry over to the shares accounting.\nThis standardization makes the Vaults immediately compatible with all EIP-20 use cases in addition to EIP-4626.\n\nThe mint method was included for symmetry and feature completeness.\nMost current use cases of share-based Vaults do not ascribe special meaning to the shares such that\na user would optimize for a specific number of shares (`mint`) rather than specific amount of underlying (`deposit`).\nHowever, it is easy to imagine future Vault strategies which would have unique and independently useful share representations.\n\nThe `convertTo` functions serve as rough estimates that do not account for operation specific details like withdrawal fees, etc.\nThey were included for frontends and applications that need an average value of shares or assets, not an exact value possibly including slippage or other fees.\nFor applications that need an exact value that attempts to account for fees and slippage we have included a corresponding `preview` function to match each mutable function. These functions must not account for deposit or withdrawal limits, to ensure they are easily composable, the `max` functions are provided for that purpose.\n\n## Backwards Compatibility\n\nEIP-4626 is fully backward compatible with the EIP-20 standard and has no known compatibility issues with other standards.\nFor production implementations of Vaults which do not use EIP-4626, wrapper adapters can be developed and used.\n\n## Reference Implementation\n\nSee [Solmate EIP-4626](https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol):\na minimal and opinionated implementation of the standard with hooks for developers to easily insert custom logic into deposits and withdrawals.\n\nSee [Vyper EIP-4626](https://github.com/fubuloubu/ERC4626):\na demo implementation of the standard in Vyper, with hooks for share price manipulation and other testing needs.\n\n## Security Considerations\n\nFully permissionless use cases could fall prey to malicious implementations which only conform to the interface but not the specification.\nIt is recommended that all integrators review the implementation for potential ways of losing user deposits before integrating.\n\nIf implementors intend to support EOA account access directly, they should consider adding an additional function call for `deposit`/`mint`/`withdraw`/`redeem` with the means to accommodate slippage loss or unexpected deposit/withdrawal limits, since they have no other means to revert the transaction if the exact output amount is not achieved.\n\nThe methods `totalAssets`, `convertToShares` and `convertToAssets` are estimates useful for display purposes,\nand do _not_ have to confer the _exact_ amount of underlying assets their context suggests.\n\nThe `preview` methods return values that are as close as possible to exact as possible. For that reason, they are manipulable by altering the on-chain conditions and are not always safe to be used as price oracles. This specification includes `convert` methods that are allowed to be inexact and therefore can be implemented as robust price oracles. For example, it would be correct to implement the `convert` methods as using a time-weighted average price in converting between assets and shares.\n\nIntegrators of EIP-4626 Vaults should be aware of the difference between these view methods when integrating with this standard. Additionally, note that the amount of underlying assets a user may receive from redeeming their Vault shares (`previewRedeem`) can be significantly different than the amount that would be taken from them when minting the same quantity of shares (`previewMint`). The differences may be small (like if due to rounding error), or very significant (like if a Vault implements withdrawal or deposit fees, etc). Therefore integrators should always take care to use the preview function most relevant to their use case, and never assume they are interchangeable.\n\nFinally, EIP-4626 Vault implementers should be aware of the need for specific, opposing rounding directions across the different mutable and view methods, as it is considered most secure to favor the Vault itself during calculations over its users:\n\n- If (1) it's calculating how many shares to issue to a user for a certain amount of the underlying tokens they provide or (2) it's determining the amount of the underlying tokens to transfer to them for returning a certain amount of shares, it should round _down_.\n\n- If (1) it's calculating the amount of shares a user has to supply to receive a given amount of the underlying tokens or (2) it's calculating the amount of underlying tokens a user has to provide to receive a certain amount of shares, it should round _up_.\n\nThe only functions where the preferred rounding direction would be ambiguous are the `convertTo` functions. To ensure consistency across all EIP-4626 Vault implementations it is specified that these functions MUST both always round _down_. Integrators may wish to mimic rounding up versions of these functions themselves, like by adding 1 wei to the result.\n\nAlthough the `convertTo` functions should eliminate the need for any use of an EIP-4626 Vault's `decimals` variable, it is still strongly recommended to mirror\nthe underlying token's `decimals` if at all possible, to eliminate possible sources of confusion and simplify integration across front-ends and for other off-chain users.\n\n## Copyright\n\nCopyright and related rights waived via [CC0](../LICENSE.md)."
    },
    {
      "filename": "contracts/wfCashERC4626.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"./wfCashLogic.sol\";\nimport \"../interfaces/IERC4626.sol\";\n\ncontract wfCashERC4626 is IERC4626, wfCashLogic {\n    constructor(INotionalV2 _notional, WETH9 _weth) wfCashLogic(_notional, _weth) {}\n\n    /** @dev See {IERC4626-asset} */\n    function asset() public view override returns (address) {\n        (IERC20 underlyingToken, bool isETH) = getToken(true);\n        return isETH ? address(WETH) : address(underlyingToken);\n    }\n\n    function _getMaturedValue() private view returns (uint256) {\n        // If the fCash has matured we use the cash balance instead.\n        uint16 currencyId = getCurrencyId();\n        // We cannot settle an account in a view method, so this may fail if the account has not been settled\n        // after maturity. This can be done by anyone so it should not be an issue\n        (int256 cashBalance, /* */, /* */) = NotionalV2.getAccountBalance(currencyId, address(this));\n        int256 underlyingExternal = NotionalV2.convertCashBalanceToExternal(currencyId, cashBalance, true);\n        require(underlyingExternal > 0, \"Must Settle\");\n\n        return uint256(underlyingExternal);\n    }\n\n    function _getPresentValue(uint256 fCashAmount) private view returns (uint256) {\n        (/* */, int256 precision) = getUnderlyingToken();\n        // Get the present value of the fCash held by the contract, this is returned in 8 decimal precision\n        (uint16 currencyId, uint40 maturity) = getDecodedID();\n        int256 pvInternal = NotionalV2.getPresentfCashValue(\n            currencyId,\n            maturity,\n            int256(fCashAmount), // total supply cannot overflow as fCash overflows at uint88\n            block.timestamp,\n            false\n        );\n\n        int256 pvExternal = (pvInternal * precision) / Constants.INTERNAL_TOKEN_PRECISION;\n        // PV should always be >= 0 since we are lending\n        require(pvExternal >= 0);\n        return uint256(pvExternal);\n    }\n\n    /** @dev See {IERC4626-totalAssets} */\n    function totalAssets() public view override returns (uint256) {\n        return hasMatured() ?  _getMaturedValue() : _getPresentValue(totalSupply());\n    }\n\n    /** @dev See {IERC4626-convertToShares} */\n    function convertToShares(uint256 assets) public view override returns (uint256 shares) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            // Scales assets by the value of a single unit of fCash\n            uint256 unitfCashValue = _getPresentValue(uint256(Constants.INTERNAL_TOKEN_PRECISION));\n            return (assets * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / unitfCashValue;\n        }\n\n        return (assets * supply) / totalAssets();\n    }\n\n    /** @dev See {IERC4626-convertToAssets} */\n    function convertToAssets(uint256 shares) public view override returns (uint256 assets) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            // Catch the edge case where totalSupply causes a divide by zero error\n            return _getPresentValue(shares);\n        }\n\n        return (shares * totalAssets()) / supply;\n    }\n\n    /** @dev See {IERC4626-maxDeposit} */\n    function maxDeposit(address) external view override returns (uint256) {\n        return hasMatured() ? 0 : type(uint256).max;\n    }\n\n    /** @dev See {IERC4626-maxMint} */\n    function maxMint(address) external view override returns (uint256) {\n        return hasMatured() ? 0 : type(uint88).max;\n    }\n\n    /** @dev See {IERC4626-maxWithdraw} */\n    function maxWithdraw(address owner) external view override returns (uint256) {\n        return previewWithdraw(balanceOf(owner));\n    }\n\n    /** @dev See {IERC4626-maxRedeem} */\n    function maxRedeem(address owner) external view override returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /** @dev See {IERC4626-previewDeposit} */\n    function previewDeposit(uint256 assets) public view override returns (uint256) {\n        if (hasMatured()) {\n            return 0;\n        } else {\n            // This is how much fCash received from depositing assets\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (uint256 fCashAmount, /* */, /* */) = NotionalV2.getfCashLendFromDeposit(\n                currencyId,\n                assets,\n                maturity,\n                0,\n                block.timestamp,\n                true\n            );\n\n            return fCashAmount;\n        }\n    }\n\n    /** @dev See {IERC4626-previewMint} */\n    function previewMint(uint256 shares) public view override returns (uint256) {\n        if (hasMatured()) {\n            return 0;\n        } else {\n            // This is how much fCash received from depositing assets\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            // This method will round up when calculating the depositAmountUnderlying (happens inside\n            // CalculationViews._convertToAmountExternal).\n            (uint256 depositAmountUnderlying, /* */, /* */, /* */) = NotionalV2.getDepositFromfCashLend(\n                currencyId,\n                shares,\n                maturity,\n                0,\n                block.timestamp\n            );\n\n            return depositAmountUnderlying;\n        }\n    }\n\n    /** @dev See {IERC4626-previewWithdraw} */\n    function previewWithdraw(uint256 assets) public view override returns (uint256 shares) {\n        // Although the ERC4626 standard suggests that shares is rounded up in this calculation,\n        // it would not have much of an effect for wrapped fCash in practice. The actual amount\n        // of assets returned to the user is not dictated by the `assets` parameter supplied here\n        // but is actually calculated inside _burnInternal (rounding against the user) when fCash\n        // has matured or inside the NotionalV2 AMM when withdrawing fCash early. In either case,\n        // the number of shares returned here will be burned exactly and the user will receive close\n        // to the assets input, but not exactly.\n        if (hasMatured()) {\n            shares = convertToShares(assets);\n        } else {\n            // If withdrawing non-matured assets, we sell them on the market (i.e. borrow)\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (shares, /* */, /* */) = NotionalV2.getfCashBorrowFromPrincipal(\n                currencyId,\n                assets,\n                maturity,\n                0,\n                block.timestamp,\n                true\n            );\n        }\n    }\n\n    /** @dev See {IERC4626-previewRedeem} */\n    function previewRedeem(uint256 shares) public view override returns (uint256 assets) {\n        if (hasMatured()) {\n            assets = convertToAssets(shares);\n        } else {\n            // If withdrawing non-matured assets, we sell them on the market (i.e. borrow)\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (assets, /* */, /* */, /* */) = NotionalV2.getPrincipalFromfCashBorrow(\n                currencyId,\n                shares,\n                maturity,\n                0,\n                block.timestamp\n            );\n        }\n    }\n\n    /** @dev See {IERC4626-deposit} */\n    function deposit(uint256 assets, address receiver) external override returns (uint256) {\n        uint256 shares = previewDeposit(assets);\n        // Will revert if matured\n        _mintInternal(assets, _safeUint88(shares), receiver, 0, true);\n        emit Deposit(msg.sender, receiver, assets, shares);\n        return shares;\n    }\n\n    /** @dev See {IERC4626-mint} */\n    function mint(uint256 shares, address receiver) external override returns (uint256) {\n        uint256 assets = previewMint(shares);\n        // Will revert if matured\n        _mintInternal(assets, _safeUint88(shares), receiver, 0, true);\n        emit Deposit(msg.sender, receiver, assets, shares);\n        return assets;\n    }\n\n    /** @dev See {IERC4626-withdraw} */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external override returns (uint256) {\n        // This is a noop if the account has already been settled, cheaper to call this than cache\n        // it locally in storage.\n        NotionalV2.settleAccount(address(this));\n\n        uin"
    }
  ]
}