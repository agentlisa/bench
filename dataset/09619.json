{
  "Title": "[M-04] createProject can be frontrun",
  "Content": "_Submitted by wuwe1, also found by defsec, and kirk-baird_\n\nThis is dangerous in scam senario because the malicious user can frontrun and become the owner of the collection. As owner, one can withdraw `paymentToken`. (note that \\_collections.isForSale can be change by frontrunner)\n\n### Proof of Concept\n\n1.  Anyone can call `createProject`.\n\n<https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreFactory.sol#L70-L77>\n\n```solidity\n  function createProject(\n    string memory _projectId,\n    Collection[] memory _collections\n  ) external onlyAvailableProject(_projectId) {\n    require(\n      _collections.length > 0,\n      'CoreFactory: should have more at least one collection'\n    );\n```\n\n### Recommended Mitigation Steps\n\nTwo ways to mitigate.\n\n1.  Consider use white list on project creation.\n2.  Ask user to sign their address and check the signature against `msg.sender`.  <https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol#L102>\n\n\n**[sofianeOuafir (Joyn) confirmed and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/26#issuecomment-1099700412):**\n > This is an issue and we intend to fix it!\n\n**[deluca-mike (judge) commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/26#issuecomment-1105980217):**\n > The solutions listed in #34 and #35 are better.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-03-joyn-contest",
  "Code": [
    {
      "filename": "core-contracts/contracts/CoreFactory.sol",
      "content": "//SPDX-License-Identifier: Unlicense\r\npragma solidity ^0.8.0;\r\n\r\nimport {CoreProxy} from './CoreProxy.sol';\r\nimport './utils/structs/Collection.sol';\r\nimport {CoreCollection} from './CoreCollection.sol';\r\nimport {ICoreCollection} from '../interfaces/ICoreCollection.sol';\r\n\r\ncontract CoreFactory {\r\n  struct Project {\r\n    string id;\r\n    address creator;\r\n  }\r\n\r\n  event NewProject(string id, address creator);\r\n  event NewCollection(\r\n    string collectionId,\r\n    address collection,\r\n    string projectId\r\n  );\r\n\r\n  address public immutable collection;\r\n  address public immutable splitFactory;\r\n  mapping(string => Project) public projects;\r\n  mapping(string => address) public collections;\r\n\r\n  constructor(address _collection, address _splitFactory) {\r\n    collection = _collection;\r\n    splitFactory = _splitFactory;\r\n  }\r\n\r\n  // ---------------- MODIFIER ----------------\r\n\r\n  modifier onlyAvailableProject(string memory _projectId) {\r\n    require(\r\n      projects[_projectId].creator == address(0),\r\n      'CoreFactory: Unavailable project id'\r\n    );\r\n    _;\r\n  }\r\n\r\n  modifier onlyProjectOwner(string memory _projectId) {\r\n    require(\r\n      projects[_projectId].creator == msg.sender,\r\n      'CoreFactory: Not an owner of the project'\r\n    );\r\n    _;\r\n  }\r\n\r\n  modifier onlyAvailableCollection(string memory _collectionId) {\r\n    require(\r\n      collections[_collectionId] == address(0),\r\n      'CoreFactory: Unavailable collection id'\r\n    );\r\n    _;\r\n  }\r\n\r\n  // ---------------- EXTERNAL ----------------\r\n\r\n  /**\r\n   * @notice Allows to create a project as well as deploy its collection(s)\r\n   * For adding a collection to a project, use the addCollection() method.\r\n   * @dev Projects have unique identifiers.\r\n   * Collections are deployed using a proxy pattern. This is mainly for gas optimization purposes\r\n   * and to support future contract upgrades.\r\n   * Collections ownership are transferred to the caller.\r\n   * @param _projectId Project id which is a unique identifier\r\n   * @param _collections An array of Collection that needs to be deployed\r\n   */\r\n  function createProject(\r\n    string memory _projectId,\r\n    Collection[] memory _collections\r\n  ) external onlyAvailableProject(_projectId) {\r\n    require(\r\n      _collections.length > 0,\r\n      'CoreFactory: should have more at least one collection'\r\n    );\r\n\r\n    for (uint256 i; i < _collections.length; i++) {\r\n      Collection memory _collection = _collections[i];\r\n      address coreCollection = _createCollection(_collection);\r\n\r\n      if (_collection.claimsMerkleRoot != bytes32(0)) {\r\n        ICoreCollection(coreCollection).initializeClaims(\r\n          _collection.claimsMerkleRoot\r\n        );\r\n      }\r\n\r\n      emit NewCollection(_collection.id, coreCollection, _projectId);\r\n\r\n      ICoreCollection(coreCollection).transferOwnership(msg.sender);\r\n    }\r\n    Project memory project;\r\n    project.id = _projectId;\r\n    project.creator = msg.sender;\r\n    projects[_projectId] = project;\r\n\r\n    emit NewProject(_projectId, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @notice Allows to add a collection to a project\r\n   * @dev Can only be called by project creator\r\n   * Collection's ownership is transferred to the caller\r\n   * @param _projectId Project id which is a unique identifier\r\n   * @param _collection Collection that needs to be deployed\r\n   */\r\n  function addCollection(\r\n    string memory _projectId,\r\n    Collection memory _collection\r\n  ) external onlyProjectOwner(_projectId) returns (address) {\r\n    address coreCollection = _createCollection(_collection);\r\n\r\n    if (_collection.claimsMerkleRoot != bytes32(0)) {\r\n      ICoreCollection(coreCollection).initializeClaims(\r\n        _collection.claimsMerkleRoot\r\n      );\r\n    }\r\n\r\n    emit NewCollection(_collection.id, coreCollection, _projectId);\r\n\r\n    ICoreCollection(coreCollection).transferOwnership(msg.sender);\r\n    return coreCollection;\r\n  }\r\n\r\n  // ---------------- VIEW ----------------\r\n\r\n  function getProject(string memory _projectId)\r\n    external\r\n    view\r\n    returns (Project memory)\r\n  {\r\n    return projects[_projectId];\r\n  }\r\n\r\n  // ---------------- PRIVATE ----------------\r\n\r\n  /**\r\n   * @notice Instanciates/Deploys a collection\r\n   * @param _collection Collection that needs to be deployed\r\n   */\r\n  function _createCollection(Collection memory _collection)\r\n    private\r\n    onlyAvailableCollection(_collection.id)\r\n    returns (address)\r\n  {\r\n    address coreCollection = address(\r\n      new CoreProxy{salt: keccak256(abi.encodePacked(_collection.id))}(\r\n        collection\r\n      )\r\n    );\r\n\r\n    ICoreCollection(coreCollection).initialize(\r\n      _collection.name,\r\n      _collection.symbol,\r\n      _collection.baseURI,\r\n      _collection.maxSupply,\r\n      _collection.mintFee,\r\n      _collection.payableToken,\r\n      _collection.isForSale,\r\n      splitFactory\r\n    );\r\n\r\n    collections[_collection.id] = coreCollection;\r\n    return coreCollection;\r\n  }\r\n}"
    },
    {
      "filename": "contracts/utils/cryptography/ECDSA.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[ERC-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}"
    }
  ]
}