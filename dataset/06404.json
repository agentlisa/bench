{
  "Title": "[H-01] In `LlamaRelativeQuorum`, the governance result might be incorrect as it counts the wrong approval/disapproval",
  "Content": "\n<https://github.com/code-423n4/2023-06-llama/blob/9d641b32e3f4092cc81dbac7b1c451c695e78983/src/strategies/LlamaRelativeQuorum.sol#L223> <br><https://github.com/code-423n4/2023-06-llama/blob/9d641b32e3f4092cc81dbac7b1c451c695e78983/src/strategies/LlamaRelativeQuorum.sol#L242>\n\n### Proof of Concept\n\nThe `LlamaRelativeQuorum` uses approval/disapproval thresholds that are specified as percentages of total supply and the approval/disapproval supplies are set at `validateActionCreation()` during the action creation.\n\n```solidity\n  function validateActionCreation(ActionInfo calldata actionInfo) external {\n    LlamaPolicy llamaPolicy = policy; // Reduce SLOADs.\n    uint256 approvalPolicySupply = llamaPolicy.getRoleSupplyAsNumberOfHolders(approvalRole);\n    if (approvalPolicySupply == 0) revert RoleHasZeroSupply(approvalRole);\n\n    uint256 disapprovalPolicySupply = llamaPolicy.getRoleSupplyAsNumberOfHolders(disapprovalRole);\n    if (disapprovalPolicySupply == 0) revert RoleHasZeroSupply(disapprovalRole);\n\n    // Save off the supplies to use for checking quorum.\n    actionApprovalSupply[actionInfo.id] = approvalPolicySupply;\n    actionDisapprovalSupply[actionInfo.id] = disapprovalPolicySupply;\n  }\n```\n\nAs we can see, `actionApprovalSupply` and `actionDisapprovalSupply` are set using `getRoleSupplyAsNumberOfHolders` which means the total number of role holders.\n\nBut while counting for `totalApprovals/totalDisapprovals` in `getApprovalQuantityAt()/getDisapprovalQuantityAt()`, it adds the quantity instead of role holders(1 for each holder).\n\n```solidity\nfunction getApprovalQuantityAt(address policyholder, uint8 role, uint256 timestamp) external view returns (uint128) {\n    if (role != approvalRole && !forceApprovalRole[role]) return 0;\n    uint128 quantity = policy.getPastQuantity(policyholder, role, timestamp);\n    return quantity > 0 && forceApprovalRole[role] ? type(uint128).max : quantity; //@audit should return supply, not quantity\n}\n```\n\nSo the governance result would be wrong with the below example.\n\n1.  There are 3 role holders(Alice, Bob, Charlie) and Alice has 2 quantities, others have 1.\n2.  During the action creation with the `LlamaRelativeQuorum` strategy, `actionApprovalSupply = 3` and there should be 2 approved holders at least when `minApprovalPct = 51%`.\n3.  But if Alice approves the action, the result of `getApprovalQuantityAt()` will be 2 and the action will be approved with only one approval.\n\nIt's because `getApprovalQuantityAt()` return the quantity although `actionApprovalSupply` equals `NumberOfHolders`.\n\n### Recommended Mitigation Steps\n\n`getApprovalQuantityAt()` and `getDisapprovalQuantityAt()` should return 1 instead of `quantity` for the positive quantity.\n\nI think we can modify these functions like below.\n\n```solidity\n  function getApprovalQuantityAt(address policyholder, uint8 role, uint256 timestamp) external view returns (uint128) {\n    if (role != approvalRole && !forceApprovalRole[role]) return 0;\n    uint128 quantity = policy.getPastQuantity(policyholder, role, timestamp);\n    \n    if (quantity > 1) quantity = 1;\n\n    return quantity > 0 && forceApprovalRole[role] ? type(uint128).max : quantity;\n  }\n\n  function getDisapprovalQuantityAt(address policyholder, uint8 role, uint256 timestamp)\n    external\n    view\n    returns (uint128)\n  {\n    if (role != disapprovalRole && !forceDisapprovalRole[role]) return 0;\n    uint128 quantity = policy.getPastQuantity(policyholder, role, timestamp);\n\n    if (quantity > 1) quantity = 1;\n\n    return quantity > 0 && forceDisapprovalRole[role] ? type(uint128).max : quantity;\n  }\n```\n\n**[AustinGreen (Llama) disputed and commented](https://github.com/code-423n4/2023-06-llama-findings/issues/203#issuecomment-1601169669):**\n > This is actually how we intend this strategy to work but we're open to feedback! Here's an example:\n> \n> - An instance has 10 role holders and a 50% min approval percentage. Each role holder's quantity is 1, so 5 role holders can approve this action.\n> - 2 of the role holders have their quantity increased to 2.\n> - This means that if each of these role holders cast approvals, then their approval power will count as 4. That means just one other role holder is needed to cast approval to approve the action.\n> \n> In this system quantity can be used to provide granular approval weights to role holders.\n\n**[gzeon (Judge) commented](https://github.com/code-423n4/2023-06-llama-findings/issues/203#issuecomment-1616683309):**\n> @AustinGreen- I don't think this make sense. Sure, if each holder's quantity is 1, then `getRoleSupply` is same as `getRoleSupplyAsNumberOfHolders` and what you said is valid. However, if you have 10 holders each with quantity 10 at snapshot, then your `actionApprovalSupply` is set to 10 (number of holder) and any of their approval (10 quantity) would hit quorum.\n\n**[AustinGreen (Llama) commented](https://github.com/code-423n4/2023-06-llama-findings/issues/203#issuecomment-1616796649):**\n> @gzeon- Yes thatâ€™s exactly how the design is intended to work!\n\n**[gzeon (Judge) commented](https://github.com/code-423n4/2023-06-llama-findings/issues/203#issuecomment-1617278035):**\n> @AustinGreen- This sounds weird, is this design documented anywhere? From what I can see in the code comments it seems to be hard for anyone (including potential user/dao) to understand such logic. \n> \n> In the code, there is a comment\n> >  Minimum percentage of `totalApprovalQuantity / totalApprovalSupplyAtCreationTime` required for the action to be queued\n> \n> I think it is fair for one to assume `totalApprovalQuantity` and `totalApprovalSupplyAtCreationTime` would be using the same metric, instead of one using the raw count and the other using `AsNumberOfHolders`.\n\n**[AustinGreen (Llama) commented](https://github.com/code-423n4/2023-06-llama-findings/issues/203):**\n>Although this is the intended design for this strategy, we decided to create an additional strategy that Llama instances can adopt that follows the warden's recommendations. It uses total (dis)approval quantity for the quorum calculation as specified.\n\n***\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-06-llama",
  "Code": [
    {
      "filename": "src/strategies/LlamaRelativeQuorum.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {Initializable} from \"@openzeppelin/proxy/utils/Initializable.sol\";\n\nimport {FixedPointMathLib} from \"@solmate/utils/FixedPointMathLib.sol\";\n\nimport {ILlamaStrategy} from \"src/interfaces/ILlamaStrategy.sol\";\nimport {ActionState} from \"src/lib/Enums.sol\";\nimport {LlamaUtils} from \"src/lib/LlamaUtils.sol\";\nimport {Action, ActionInfo} from \"src/lib/Structs.sol\";\nimport {LlamaCore} from \"src/LlamaCore.sol\";\nimport {LlamaPolicy} from \"src/LlamaPolicy.sol\";\n\n/// @title Llama Relative Quorum Strategy\n/// @author Llama (devsdosomething@llama.xyz)\n/// @notice This is a Llama strategy which has the following properties:\n///   - Approval/disapproval thresholds are specified as percentages of total supply.\n///   - Action creators are allowed to cast approvals or disapprovals on their own actions within this strategy.\ncontract LlamaRelativeQuorum is ILlamaStrategy, Initializable {\n  // =========================\n  // ======== Structs ========\n  // =========================\n\n  struct Config {\n    uint64 approvalPeriod; // The length of time of the approval period.\n    uint64 queuingPeriod; // The length of time of the queuing period. The disapproval period is the queuing period when\n      // enabled.\n    uint64 expirationPeriod; // The length of time an action can be executed before it expires.\n    uint16 minApprovalPct; // Minimum percentage of total approval quantity / total approval supply.\n    uint16 minDisapprovalPct; // Minimum percentage of total disapproval quantity / total disapproval supply.\n    bool isFixedLengthApprovalPeriod; // Determines if an action be queued before approvalEndTime.\n    uint8 approvalRole; // Anyone with this role can cast approval of an action.\n    uint8 disapprovalRole; // Anyone with this role can cast disapproval of an action.\n    uint8[] forceApprovalRoles; // Anyone with this role can single-handedly approve an action.\n    uint8[] forceDisapprovalRoles; // Anyone with this role can single-handedly disapprove an action.\n  }\n\n  // ========================\n  // ======== Errors ========\n  // ========================\n\n  /// @dev The action cannot be canceled if it's already in a terminal state.\n  /// @param currentState The current state of the action.\n  error CannotCancelInState(ActionState currentState);\n\n  /// @dev The strategy has disabled disapprovals.\n  error DisapprovalDisabled();\n\n  /// @dev The action cannot be created because the minimum approval percentage cannot be greater than 100%.\n  /// @param minApprovalPct The provided minApprovalPct.\n  error InvalidMinApprovalPct(uint256 minApprovalPct);\n\n  /// @dev The role is not eligible to participate in this strategy in the specified way.\n  /// @param role The role being used.\n  error InvalidRole(uint8 role);\n\n  /// @dev Only the action creator can cancel an action.\n  error OnlyActionCreator();\n\n  /// @dev The action cannot be created if the approval or disapproval supply is 0.\n  /// @param role The role being used.\n  error RoleHasZeroSupply(uint8 role);\n\n  /// @dev The provided role is not initialized by the `LlamaPolicy`.\n  /// @param role The role being used.\n  error RoleNotInitialized(uint8 role);\n\n  // ========================\n  // ======== Events ========\n  // ========================\n\n  /// @dev Emitted when a force approval role is added to the strategy. This can only happen at strategy deployment\n  /// time during initialization.\n  event ForceApprovalRoleAdded(uint8 role);\n\n  /// @dev Emitted when a force disapproval role is added to the strategy. This can only happen at strategy deployment\n  /// time during initialization.\n  event ForceDisapprovalRoleAdded(uint8 role);\n\n  /// @dev Emitted when a strategy is created referencing the core and policy.\n  event StrategyCreated(LlamaCore llamaCore, LlamaPolicy policy);\n\n  // =================================================\n  // ======== Constants and Storage Variables ========\n  // =================================================\n\n  // -------- Interface Requirements --------\n\n  /// @inheritdoc ILlamaStrategy\n  LlamaCore public llamaCore;\n\n  /// @inheritdoc ILlamaStrategy\n  LlamaPolicy public policy;\n\n  // -------- Strategy Configuration --------\n\n  /// @dev Equivalent to 100%, but in basis points.\n  uint256 internal constant ONE_HUNDRED_IN_BPS = 10_000;\n\n  /// @notice If `false`, action be queued before approvalEndTime.\n  bool public isFixedLengthApprovalPeriod;\n\n  /// @notice Length of approval period in seconds.\n  uint64 public approvalPeriod;\n\n  /// @notice Minimum time, in seconds, between queueing and execution of action.\n  uint64 public queuingPeriod;\n\n  /// @notice Time, in seconds, after `minExecutionTime` that action can be executed before permanently expiring.\n  uint64 public expirationPeriod;\n\n  /// @notice Minimum percentage of `totalApprovalQuantity / totalApprovalSupplyAtCreationTime` required for the\n  /// action to be queued. In bps, where 10,000 == 100%.\n  /// @dev We use `uint16` because it's the smallest integer type that can hold 10,000.\n  uint16 public minApprovalPct;\n\n  /// @notice Minimum percentage of `totalDisapprovalQuantity / totalDisapprovalSupplyAtCreationTime` required of the\n  /// action for it to be canceled. In bps, 10,000 == 100%.\n  /// @dev We use `uint16` because it's the smallest integer type that can hold 10,000.\n  uint16 public minDisapprovalPct;\n\n  /// @notice The role that can approve an action.\n  uint8 public approvalRole;\n\n  /// @notice The role that can disapprove an action.\n  uint8 public disapprovalRole;\n\n  /// @notice Mapping of roles that can force an action to be approved.\n  mapping(uint8 => bool) public forceApprovalRole;\n\n  /// @notice Mapping of roles that can force an action to be disapproved.\n  mapping(uint8 => bool) public forceDisapprovalRole;\n\n  /// @notice Mapping of action ID to the supply of the approval role at the time the action was created.\n  mapping(uint256 => uint256) public actionApprovalSupply;\n\n  /// @notice Mapping of action ID to the supply of the disapproval role at the time the action was created.\n  mapping(uint256 => uint256) public actionDisapprovalSupply;\n\n  // =============================\n  // ======== Constructor ========\n  // =============================\n\n  constructor() {\n    _disableInitializers();\n  }\n\n  // ==========================================\n  // ======== Interface Implementation ========\n  // ==========================================\n\n  // -------- At Strategy Creation --------\n\n  /// @inheritdoc ILlamaStrategy\n  function initialize(bytes memory config) external initializer {\n    Config memory strategyConfig = abi.decode(config, (Config));\n    llamaCore = LlamaCore(msg.sender);\n    policy = llamaCore.policy();\n    queuingPeriod = strategyConfig.queuingPeriod;\n    expirationPeriod = strategyConfig.expirationPeriod;\n    isFixedLengthApprovalPeriod = strategyConfig.isFixedLengthApprovalPeriod;\n    approvalPeriod = strategyConfig.approvalPeriod;\n\n    if (strategyConfig.minApprovalPct > ONE_HUNDRED_IN_BPS) revert InvalidMinApprovalPct(minApprovalPct);\n    minApprovalPct = strategyConfig.minApprovalPct;\n    minDisapprovalPct = strategyConfig.minDisapprovalPct;\n\n    uint8 numRoles = policy.numRoles();\n\n    approvalRole = strategyConfig.approvalRole;\n    _assertValidRole(strategyConfig.approvalRole, numRoles);\n\n    disapprovalRole = strategyConfig.disapprovalRole;\n    _assertValidRole(strategyConfig.disapprovalRole, numRoles);\n\n    for (uint256 i = 0; i < strategyConfig.forceApprovalRoles.length; i = LlamaUtils.uncheckedIncrement(i)) {\n      uint8 role = strategyConfig.forceApprovalRoles[i];\n      if (role == 0) revert InvalidRole(0);\n      _assertValidRole(role, numRoles);\n      forceApprovalRole[role] = true;\n      emit ForceApprovalRoleAdded(role);\n    }\n\n    for (uint256 i = 0; i < strategyConfig.forceDisapprovalRoles.length; i = LlamaUtils.uncheckedIncrement(i)) {\n      uint8 role = strategyConfig.forceDisapprovalRoles[i];\n      if (role == 0) revert InvalidRole(0);\n      _assertValidRole(role, numRoles);\n      forceDisapprovalRole[role] = true;\n      emit ForceDisapprovalRoleAdded(role);\n    }\n\n    emit StrategyCreated(llamaCore, policy);\n  }\n\n  // -------- At Action Creation --------\n\n  /// @inheritdoc ILlamaStrategy\n  function validateActionCreation(ActionInfo calldata actionInfo) external {\n    LlamaPolicy llamaPolicy = policy; // Reduce SLOADs.\n    uint256 approvalPolicySupply = llamaPolicy.getRoleSupplyAsNumberOfHolders(approvalRole);\n    if (approvalPolicySupply == 0) revert RoleHasZeroSupply(approvalRole);\n\n    uint256 disapprovalPolicySupply = llamaPolicy.getRoleSupplyAsNumberOfHolders(disapprovalRole);\n    if (disapprovalPolicySupply == 0) revert RoleHasZeroSupply(disapprovalRole);\n\n    // Save off the supplies to use for checking quorum.\n    actionApprovalSupply[actionInfo.id] = approvalPolicySupply;\n    actionDisapprovalSupply[actionInfo.id] = disapprovalPolicySupply;\n  }\n\n  // -------- When Casting Approval --------\n\n  /// @inheritdoc ILlamaStrategy\n  function isApprovalEnabled(ActionInfo calldata, address, uint8 role) external view {\n    if (role != approvalRole && !forceApprovalRole[role]) revert InvalidRole(approvalRole);\n  }\n\n  /// @inheritdoc ILlamaStrategy\n  function getApprovalQuantityAt(address policyholder, uint8 role, uint256 timestamp) external view returns (uint128) {\n    if (role != approvalRole && !forceApprovalRole[role]) return 0;\n    uint128 quantity = policy.getPastQuantity(policyholder, role, timestamp);\n    return quantity > 0 && forceApprovalRole[role] ? type(uint128).max : quantity;\n  }\n\n  // -------- When Casting Disapproval --------\n\n  /// @inheritdoc ILlamaStrategy\n  function isDisapprovalEnabled(ActionInfo calldata, address, uint8 role) external view {\n    if (minDisapprovalPct > ONE_HUNDRED_IN_BPS) revert DisapprovalDisabled();\n    if (role != disapprovalRole && !forceDisapprovalRole[role]) revert InvalidRole(disapprovalRole);\n  }\n\n  /// @inheritdoc ILlamaStrategy\n  function getDisapprovalQuantityAt(address policyholder, uint8 role, uint256 timestamp)\n    external\n    view\n    returns (uint128)\n  {\n    if (role != disapprovalRole && !forceDisapprovalRole[role]) return 0;\n    uint128 quantity = policy.getPastQuantity(policyholder, role, timestamp);\n    return quantity > 0 && forceDisapprovalRole[role] ? type(uint128).max : quantity;\n  }\n\n  // -------- When Queueing --------\n\n  /// @inheritdoc ILlamaStrategy\n  function minExecutionTime(ActionInfo calldata) external view returns (uint64) {\n    return LlamaUtils.toUint64(block.timestamp + queuingPeriod);\n  }\n\n  // -------- When Canceling --------\n\n  /// @inheritdoc ILlamaStrategy\n  function validateActionCancelation(ActionInfo calldata actionInfo, address caller) external view {\n    // The rules for cancelation are:\n    //   1. The action cannot be canceled if it's state is any of the following: Executed, Canceled,\n    //      Expired, Failed.\n    //   2. For all other states (Active, Approved, Queued) the action can be canceled if the caller\n    //      is the action creator.\n\n    // Check 1.\n    ActionState state = llamaCore.getActionState(actionInfo);\n    if (\n      state == ActionState.Executed || state == ActionState.Canceled || state == ActionState.Expired\n        || state == ActionState.Failed\n    ) revert CannotCancelInState(state);\n\n    // Check 2.\n    if (caller != actionInfo.creator) revert OnlyActionCreator();\n  }\n\n  // -------- When Determining Action State --------\n\n  /// @inheritdoc ILlamaStrategy\n  function isActive(ActionInfo calldata actionInfo) external view returns (bool) {\n    return\n      block.timestamp <= approvalEndTime(actionInfo) && (isFixedLengthApprovalPeriod || !isActionApproved(actionInfo));\n  }\n\n  /// @inheritdoc ILlamaStrategy\n  function isActionApproved(ActionInfo calldata actionInfo) public view returns (bool) {\n    Action memory action = llamaCore.getAction(actionInfo.id);\n    return action.totalApprovals >= _getMinimumAmountNeeded(actionApprovalSupply[actionInfo.id], minApprovalPct);\n  }\n\n  /// @inheritdoc ILlamaStrategy\n  function isActionDisapproved(ActionInfo calldata actionInfo) public view returns (bool) {\n    Action memory action = llamaCore.getAction(actionInfo.id);\n    return\n      action.totalDisapprovals >= _getMinimumAmountNeeded(actionDisapprovalSupply[actionInfo.id], minDisapprovalPct);\n  }\n\n  /// @inheritdoc ILlamaStrategy\n  function isActionExpired(ActionInfo calldata actionInfo) external view returns (bool) {\n    Action memory action = llamaCore.getAction(actionInfo.id);\n    return block.timestamp > action.minExecutionTime + expirationPeriod;\n  }\n\n  // ========================================\n  // ======== Other Public Functions ========\n  // ========================================\n\n  /// @notice Returns the timestamp at which the approval period ends.\n  function approvalEndTime(ActionInfo calldata actionInfo) public view returns (uint256) {\n    Action memory action = llamaCore.getAction(actionInfo.id);\n    return action.creationTime + approvalPeriod;\n  }\n\n  // ================================\n  // ======== Internal Logic ========\n  // ================================\n\n  /// @dev Determine the minimum quantity needed for an action to reach quorum.\n  /// @param supply Total number of policyholders eligible for participation.\n  /// @param minPct Minimum percentage needed to reach quorum.\n  /// @return The total quantity needed to reach quorum.\n  function _getMinimumAmountNeeded(uint256 supply, uint256 minPct) internal pure returns (uint256) {\n    // Rounding Up\n    return FixedPointMathLib.mulDivUp(supply, minPct, ONE_HUNDRED_IN_BPS);\n  }\n\n  /// @dev Reverts if the given `role` is greater than `numRoles`.\n  function _assertValidRole(uint8 role, uint8 numRoles) internal pure {\n    if (role > numRoles) revert RoleNotInitialized(role);\n  }\n}"
    }
  ]
}