{
  "Title": "Constructor parameter validation",
  "Content": "Consider performing sanity checks to validate `RCNCrowdsale`â€™s [constructor parameters](https://github.com/ripio/rcn-token/blob/4bf441ae919f2580dcfeca59917b81bb30d2b856/contracts/RCNCrowdsale.sol#L43-L46). Check that `_fundingStartBlock &lt; _fundingEndBlock` and that the addresses `_ethFundDeposit` and `_rcnFundDeposit` are not `0x0`.\n\n\n***Update:** Fixed in [`70a42f2`](https://github.com/ripio/rcn-token/commit/70a42f2e209a4d556eb2be8c8dfc6cf2be468778)*.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/RCNCrowdsale.sol",
      "content": "pragma solidity ^0.4.11;\n\nimport \"./StandardToken.sol\";\nimport \"./zeppelin/SafeMath.sol\";\nimport \"./Crowdsale.sol\";\nimport \"./CapWhitelist.sol\";\nimport \"./MintableToken.sol\";\n\ncontract RCNCrowdsale is Crowdsale {\n    using SafeMath for uint256;\n\n    // metadata\n    string public constant name = \"Ripio Credit Network Token\";\n    string public constant symbol = \"RCN\";\n    uint256 public constant decimals = 18;\n    string public version = \"1.0\";\n\n    // contracts\n    address public ethFundDeposit;      // deposit address for ETH for Ripio\n    address public rcnFundDeposit;      // deposit address for Ripio use and RCN User Fund\n\n    // crowdsale parameters\n    bool public isFinalized;              // switched to true in operational state\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n    uint256 public constant rcnFund = 490 * (10**6) * 10**decimals;   // 490m RCN reserved for Ripio use\n    uint256 public constant tokenExchangeRate = 4000; // 4000 RCN tokens per 1 ETH\n    uint256 public constant tokenCreationCap =  1000 * (10**6) * 10**decimals;\n    uint256 public constant minBuyTokens = 400 * 10**decimals; // 0.1 ETH\n\n    // events\n    event LogRefund(address indexed _to, uint256 _value);\n    event CreateRCN(address indexed _to, uint256 _value);\n\n    mapping (address => uint256) bought; // cap map\n\n    uint256 public raised;\n\n    CapWhitelist public whiteList;\n    MintableToken public token;\n\n    // constructor\n    function RCNCrowdsale(address _ethFundDeposit,\n          address _rcnFundDeposit,\n          uint256 _fundingStartBlock,\n          uint256 _fundingEndBlock) {\n      token = new MintableToken();\n      whiteList = new CapWhitelist();\n      isFinalized = false;                   //controls pre through crowdsale state\n      ethFundDeposit = _ethFundDeposit;\n      rcnFundDeposit = _rcnFundDeposit;\n      fundingStartBlock = _fundingStartBlock;\n      fundingEndBlock = _fundingEndBlock;\n      token.mint(rcnFundDeposit, rcnFund);\n      raised = rcnFund;\n      CreateRCN(rcnFundDeposit, rcnFund);  // logs Ripio Intl fund\n    }\n\n    /// @dev Accepts ether and creates new RCN tokens.\n    function createTokens() payable external {\n      buyTokens(msg.sender);\n    }\n\n    // low level token purchase function\n    function buyTokens(address beneficiary) payable {\n      if (isFinalized) throw;\n      if (block.number < fundingStartBlock) throw;\n      if (block.number > fundingEndBlock) throw;\n      if (msg.value == 0) throw;\n      if (beneficiary == 0x0) throw;\n\n      uint256 tokens = msg.value.mul(tokenExchangeRate); // check that we're not over totals\n      uint256 checkedSupply = raised.add(tokens);\n\n      // if sender is not whitelisted and exceeds the cap, cancel the transaction\n      if (bought[msg.sender] + tokens > whiteList.whitelist(msg.sender)) throw;\n\n      // return money if something goes wrong\n      if (tokenCreationCap < checkedSupply) throw;  // odd fractions won't be found\n\n      // return money if tokens is less than the min amount and the token is not finalizing\n      // the min amount does not apply if the availables tokens are less than the min amount.\n      if (tokens < minBuyTokens && (tokenCreationCap - raised) > minBuyTokens) throw;\n\n      raised = checkedSupply;\n      token.mint(beneficiary, tokens);\n      bought[msg.sender] += tokens;\n      CreateRCN(beneficiary, tokens);  // logs token creation\n\n      forwardFunds();\n    }\n\n    function finalize() {\n      if (isFinalized) throw;\n      if (block.number <= fundingEndBlock && raised != tokenCreationCap) throw;\n      if (msg.sender != ethFundDeposit) throw;\n      isFinalized = true;\n      token.finishMinting();\n      whiteList.destruct();\n    }\n\n    // send ether to the fund collection wallet\n    function forwardFunds() internal {\n      ethFundDeposit.transfer(msg.value);\n    }\n\n    function setWhitelist(address _address, uint256 _amount) {\n      if (msg.sender != ethFundDeposit) throw;\n      whiteList.setWhitelisted(_address, _amount);\n    }\n}"
    }
  ]
}