{
  "Title": "Check that the address is not zero",
  "Content": "##### Description\nThe following lines use address variables. But if the value turns out to be zero, funds will be lost:\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCTreasury.sol#L163\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyMainnet.sol#L70\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyMainnet.sol#L75\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyMainnet.sol#L80\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyMainnet.sol#L85\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyMainnet.sol#L90\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyMainnet.sol#L100\n- https://github.com/RealityCards/RealityCards-Contracts/blob/fd3b713d1a15f92ebc329f85038b76563f1587b8/contracts/bridgeproxies/RCProxyMainnet.sol#L104\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyXdai.sol#L95\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyXdai.sol#L100\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyXdai.sol#L105\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyXdai.sol#L110\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyXdai.sol#L120\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyXdai.sol#L142-L149\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyXdai.sol#L182\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/nfthubs/RCNftHubMainnet.sol#L29\n\n##### Recommendation\nIt is recommended to add a check that address is valid.\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/RCTreasury.sol",
      "content": "pragma solidity 0.5.13;\n\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"hardhat/console.sol\";\nimport './lib/NativeMetaTransaction.sol';\n\n/// @title Reality Cards Treasury\n/// @author Andrew Stanger\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCTreasury is Ownable, NativeMetaTransaction {\n\n    using SafeMath for uint256;\n\n    ////////////////////////////////////\n    //////// VARIABLES /////////////////\n    ////////////////////////////////////\n\n    /// @dev address of the Factory so only the Factory can add new markets\n    address public factoryAddress;\n    /// @dev so only markets can use certain functions\n    mapping (address => bool) public isMarket;\n    /// @dev the deposit balance of each user\n    mapping (address => uint256) public deposits;\n    /// @dev sum of all deposits \n    uint256 public totalDeposits;\n    /// @dev the rental payments made in each market\n    mapping (address => uint256) public marketPot;\n    /// @dev sum of all market pots \n    uint256 public totalMarketPots;\n    /// @dev sum of prices of all Cards a user is renting\n    mapping (address => uint256) public userTotalRentals;\n    /// @dev when a user most recently rented (to prevent users withdrawing within minRentalTime)\n    mapping (address => uint256) public lastRentalTime;\n\n     ///// GOVERNANCE VARIABLES /////\n    /// @dev only parameters that need to be are here, the rest are in the Factory\n    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)\n    uint256 public minRentalDivisor;\n    /// @dev max deposit balance, to minimise funds at risk\n    uint256 public maxContractBalance;\n\n    ///// SAFETY /////\n    /// @dev if true, cannot deposit, withdraw or rent any cards across all events\n    bool public globalPause;\n    /// @dev if true, cannot rent any cards for specific market\n    mapping (address => bool) public marketPaused;\n\n    ///// UBER OWNER /////\n    /// @dev high level owner who can change the factory address\n    address public uberOwner;\n\n    ////////////////////////////////////\n    //////// EVENTS ////////////////////\n    ////////////////////////////////////\n\n    event LogDepositIncreased(address indexed sentBy, uint256 indexed daiDeposited);\n    event LogDepositWithdrawal(address indexed returnedTo, uint256 indexed daiWithdrawn);\n    event LogAdjustDeposit(address indexed user, uint256 indexed amount, bool increase);\n    event LogHotPotatoPayment(address from, address to, uint256 amount);\n\n    ////////////////////////////////////\n    //////// CONSTRUCTOR ///////////////\n    ////////////////////////////////////\n\n    constructor() public {\n        // initialise MetaTransactions\n        _initializeEIP712(\"RealityCardsTreasury\",\"1\");\n\n        // at initiation, uberOwner and owner will be the same\n        uberOwner = msg.sender;\n\n        // initialise adjustable parameters\n        setMinRental(24*6); // ten mins\n        setMaxContractBalance(1000000 ether); // 1m\n    }\n\n    ////////////////////////////////////\n    /////////// MODIFIERS //////////////\n    ////////////////////////////////////\n\n    modifier balancedBooks {\n        _;\n        // using >= not == because forced Ether send via selfdestruct will not trigger a deposit via the fallback\n        assert(address(this).balance >= totalDeposits + totalMarketPots);\n    }\n\n    modifier onlyMarkets {\n        require(isMarket[msg.sender], \"Not authorised\");\n        _;\n    }\n\n    ////////////////////////////////////\n    //////////// ADD MARKETS ///////////\n    ////////////////////////////////////\n\n    /// @dev so only markets can move funds from deposits to marketPots and vice versa\n    function addMarket(address _newMarket) external returns(bool) {\n        require(msg.sender == factoryAddress, \"Not factory\");\n        isMarket[_newMarket] = true;\n        return true;\n    }\n\n    ////////////////////////////////////\n    /////// GOVERNANCE- OWNER //////////\n    ////////////////////////////////////\n    /// @dev all functions should be onlyOwner\n    // min rental event emitted by market. Nothing else need be emitted.\n\n    /// CALLED WITHIN CONSTRUCTOR (public)\n\n    /// @notice minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)\n    function setMinRental(uint256 _newDivisor) public onlyOwner {\n        minRentalDivisor = _newDivisor;\n    }\n\n    /// @dev max deposit balance, to minimise funds at risk\n    function setMaxContractBalance(uint256 _newBalanceLimit) public onlyOwner {\n        maxContractBalance = _newBalanceLimit;\n    }\n\n    /// NOT CALLED WITHIN CONSTRUCTOR (external)\n\n    /// @dev if true, cannot deposit, withdraw or rent any cards\n    function setGlobalPause() external onlyOwner {\n        globalPause = globalPause ? false : true;\n    }\n\n    /// @dev if true, cannot rent any cards for specific market\n    function setPauseMarket(address _market) external onlyOwner {\n        marketPaused[_market] = marketPaused[_market] ? false : true;\n    }\n\n    ////////////////////////////////////\n    ////// GOVERNANCE- UBER OWNER //////\n    ////////////////////////////////////\n    //// ******** DANGER ZONE ******** ////\n    /// @dev uber owner required for upgrades\n    /// @dev deploying and setting a new factory is effectively an upgrade\n    /// @dev this is seperated so owner so can be set to multisig, or burn address to relinquish upgrade ability\n    /// @dev ... while maintaining governance over other governanace functions\n\n    function setFactoryAddress(address _newFactory) external {\n        require(msg.sender == uberOwner, \"Extremely Verboten\");\n        factoryAddress = _newFactory;\n    }\n\n    function changeUberOwner(address _newUberOwner) external {\n        require(msg.sender == uberOwner, \"Extremely Verboten\");\n        uberOwner = _newUberOwner;\n    }\n\n    ////////////////////////////////////\n    /// DEPOSIT & WITHDRAW FUNCTIONS ///\n    ////////////////////////////////////\n\n    /// @dev it is passed the user instead of using msg.sender because might be called\n    /// @dev ... via contract (fallback, newRental) or dai->xdai bot\n    function deposit(address _user) public payable balancedBooks returns(bool) {\n        require(!globalPause, \"Deposits are disabled\");\n        require(msg.value > 0, \"Must deposit something\");\n        require(address(this).balance <= maxContractBalance, \"Limit hit\");\n\n        deposits[_user] = deposits[_user].add(msg.value);\n        totalDeposits = totalDeposits.add(msg.value);\n        emit LogDepositIncreased(_user, msg.value);\n        emit LogAdjustDeposit(_user, msg.value, true);\n        return true;\n    }\n\n    /// @dev this is the only function where funds leave the contract\n    function withdrawDeposit(uint256 _dai) external balancedBooks  {\n        require(!globalPause, \"Withdrawals are disabled\");\n        require(deposits[msgSender()] > 0, \"Nothing to withdraw\");\n        require(now.sub(lastRentalTime[msgSender()]) > uint256(1 days).div(minRentalDivisor), \"Too soon\");\n\n        if (_dai > deposits[msgSender()]) {\n            _dai = deposits[msgSender()];\n        }\n        deposits[msgSender()] = deposits[msgSender()].sub(_dai);\n        totalDeposits = totalDeposits.sub(_dai);\n        address _thisAddressNotPayable = msgSender();\n        address payable _recipient = address(uint160(_thisAddressNotPayable));\n        (bool _success, ) = _recipient.call.value(_dai)(\"\");\n        require(_success, \"Transfer failed\");\n        emit LogDepositWithdrawal(msgSender(), _dai);\n        emit LogAdjustDeposit(msgSender(), _dai, false);\n    }\n\n    ////////////////////////////////////\n    //////    MARKET CALLABLE     //////\n    ////////////////////////////////////\n    /// only markets can call these functions\n\n    /// @dev a rental payment is equivalent to moving to market pot from user's deposit, called by _collectRent in the market\n    function payRent(address _user, uint256 _dai) external balancedBooks onlyMarkets returns(bool) {\n        require(!globalPause, \"Rentals are disabled\");\n        require(!marketPaused[msg.sender], \"Rentals are disabled\");\n        assert(deposits[_user] >= _dai); // assert because should have been reduced to user's deposit already\n        deposits[_user] = deposits[_user].sub(_dai);\n        marketPot[msg.sender] = marketPot[msg.sender].add(_dai);\n        totalMarketPots = totalMarketPots.add(_dai);\n        totalDeposits = totalDeposits.sub(_dai);\n        emit LogAdjustDeposit(_user, _dai, false);\n        return true;\n    }\n\n    /// @dev a payout is equivalent to moving from market pot to user's deposit (the opposite of payRent)\n    function payout(address _user, uint256 _dai) external balancedBooks onlyMarkets returns(bool) {\n        assert(marketPot[msg.sender] >= _dai); \n        deposits[_user] = deposits[_user].add(_dai);\n        marketPot[msg.sender] = marketPot[msg.sender].sub(_dai);\n        totalMarketPots = totalMarketPots.sub(_dai);\n        totalDeposits = totalDeposits.add(_dai);\n        emit LogAdjustDeposit(_user, _dai, true);\n        return true;\n    }\n\n    /// @notice ability to add liqudity to the pot without being able to win (called by market sponsor function). \n    function sponsor() external payable balancedBooks onlyMarkets returns(bool) {\n        marketPot[msg.sender] = marketPot[msg.sender].add(msg.value);\n        totalMarketPots = totalMarketPots.add(msg.value);\n        return true;\n    }\n\n    /// @dev new owner pays current owner for hot potato mode\n    function processHarbergerPayment(address _newOwner, address _currentOwner, uint256 _requiredPayment) external balancedBooks onlyMarkets returns(bool) {\n        require(deposits[_newOwner] >= _requiredPayment, \"Insufficient deposit\");\n        deposits[_newOwner] = deposits[_newOwner].sub(_requiredPayment);\n        deposits[_currentOwner] = deposits[_currentOwner].add(_requiredPayment);\n        emit LogAdjustDeposit(_newOwner, _requiredPayment, false);\n        emit LogAdjustDeposit(_currentOwner, _requiredPayment, true);\n        emit LogHotPotatoPayment(_newOwner, _currentOwner, _requiredPayment);\n        return true;\n    }\n\n    /// @dev tracks when the user last rented- so they cannot rent and immediately withdraw, thus bypassing minimum rental duration\n    function updateLastRentalTime(address _user) external onlyMarkets returns(bool) {\n        lastRentalTime[_user] = now;\n        return true;\n    }\n\n    /// @dev tracks the total rental payments across all Cards, to enforce minimum rental duration\n    function updateTotalRental(address _user, uint256 _newPrice, bool _add) external onlyMarkets returns(bool) {\n        if (_add) {\n            userTotalRentals[_user] = userTotalRentals[_user].add(_newPrice);\n        } else {\n            userTotalRentals[_user] = userTotalRentals[_user].sub(_newPrice);\n        }\n        return true;\n    }\n\n    ////////////////////////////////////\n    //////////    FALLBACK     /////////\n    ////////////////////////////////////\n \n    /// @dev sending ether/xdai direct is equal to a deposit\n    function() external payable {\n        assert(deposit(msgSender()));\n    }\n\n}"
    },
    {
      "filename": "contracts/bridgeproxies/RCProxyMainnet.sol",
      "content": "pragma solidity 0.5.13;\n\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport '../interfaces/IRealitio.sol';\nimport '../interfaces/IRCProxyXdai.sol';\nimport '../interfaces/IBridge.sol';\nimport '../interfaces/IAlternateReceiverBridge.sol';\nimport '../interfaces/IERC20Dai.sol';\nimport '../interfaces/IERC721.sol';\n\n/// @title Reality Cards Proxy- Mainnet side\n/// @author Andrew Stanger & Marvin Kruse\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCProxyMainnet is Ownable\n{\n    ////////////////////////////////////\n    //////// VARIABLES /////////////////\n    ////////////////////////////////////\n\n    /// @dev contract variables\n    IRealitio public realitio;\n    IBridge public bridge;\n    IAlternateReceiverBridge public alternateReceiverBridge;\n    IERC20Dai public dai;\n    IERC721 public nfthub;\n\n    /// @dev governance variables\n    address public proxyXdaiAddress;\n    address public nftHubAddress;\n    address public arbitrator;\n    uint32 public timeout;\n    \n    /// @dev market resolution variables\n    mapping (address => bytes32) public questionIds;\n\n    /// @dev dai deposits\n    uint256 internal depositNonce;\n    bool depositsEnabled = true;\n\n    ////////////////////////////////////\n    ////////// CONSTRUCTOR /////////////\n    ////////////////////////////////////\n\n    constructor(address _bridgeMainnetAddress, address _realitioAddress, address _nftHubAddress, address _alternateReceiverAddress, address _daiAddress) public {\n        setBridgeMainnetAddress(_bridgeMainnetAddress);\n        setRealitioAddress(_realitioAddress);\n        setNftHubAddress(_nftHubAddress);\n        setAlternateReceiverAddress(_alternateReceiverAddress);\n        setDaiAddress(_daiAddress); \n        setArbitrator(0xd47f72a2d1d0E91b0Ec5e5f5d02B2dc26d00A14D); // kleros\n        setTimeout(86400); // 24 hours\n    }\n\n    ////////////////////////////////////\n    //////////// EVENTS ////////////////\n    ////////////////////////////////////\n\n    event LogQuestionPostedToOracle(address indexed marketAddress, bytes32 indexed questionId);\n    event DaiDeposited(address indexed user, uint256 amount, uint256 nonce);\n\n    ////////////////////////////////////\n    /////// GOVERNANCE - SETUP /////////\n    ////////////////////////////////////\n    \n    /// @dev address of xdai oracle proxy, called by the xdai side of the arbitrary message bridge\n    /// @dev not set in constructor, address not known at deployment\n    function setProxyXdaiAddress(address _newAddress) onlyOwner external {\n        proxyXdaiAddress = _newAddress;\n    }\n\n    /// @dev address of arbitrary message bridge, mainnet side\n    function setBridgeMainnetAddress(address _newAddress) onlyOwner public {\n        bridge = IBridge(_newAddress);\n    }\n\n    /// @dev address of alternate receiver bridge, mainnet side\n    function setNftHubAddress(address _newAddress) onlyOwner public {\n        nfthub = IERC721(_newAddress);\n    }\n\n    /// @dev address of alternate receiver bridge, mainnet side\n    function setAlternateReceiverAddress(address _newAddress) onlyOwner public {\n        alternateReceiverBridge = IAlternateReceiverBridge(_newAddress);\n    }\n\n    /// @dev address of dai contract, must also approve the ARB\n    function setDaiAddress(address _newAddress) onlyOwner public {\n        dai = IERC20Dai(_newAddress);\n        dai.approve(address(alternateReceiverBridge), 2**256 - 1);\n    }\n\n    ////////////////////////////////////\n    /////// GOVERNANCE - ORACLE ////////\n    ////////////////////////////////////\n\n    /// @dev address reality.eth contracts\n    function setRealitioAddress(address _newAddress) onlyOwner public {\n        realitio = IRealitio(_newAddress);\n    }\n\n    /// @dev address of arbitrator, in case of continued disputes on reality.eth\n    function setArbitrator(address _newAddress) onlyOwner public {\n        arbitrator = _newAddress;\n    }\n\n    /// @dev how long reality.eth waits for disputes before finalising\n    function setTimeout(uint32 _newTimeout) onlyOwner public {\n        timeout = _newTimeout;\n    }\n\n    /// @dev admin can post question if not already posted\n    /// @dev for situations where bridge failed\n    function postQuestionToOracleAdmin(address _marketAddress, string calldata _question, uint32 _oracleResolutionTime) onlyOwner external {\n        require(questionIds[_marketAddress] == 0, \"Already posted\");\n        bytes32 _questionId = realitio.askQuestion(2, _question, arbitrator, timeout, _oracleResolutionTime, 0);\n        questionIds[_marketAddress] = _questionId;\n        emit LogQuestionPostedToOracle(_marketAddress, _questionId);\n    }\n\n    ////////////////////////////////////\n    //// GOVERNANCE - NFT UPGRADES /////\n    ////////////////////////////////////\n\n    /// @dev admin can create NFTs\n    /// @dev for situations where bridge failed\n    function upgradeCardAdmin(uint256 _newTokenId, string calldata _tokenUri, address _owner) onlyOwner external {\n        nfthub.mintNft(_newTokenId, _tokenUri, _owner);\n    }  \n\n    ////////////////////////////////////\n    ///// GOVERNANCE - DAI BRIDGE //////\n    ////////////////////////////////////\n\n    function enableOrDisableDeposits() onlyOwner external {\n        depositsEnabled = depositsEnabled ? false : true;\n    }\n    \n    ////////////////////////////////////\n    ///// CORE FUNCTIONS - ORACLE //////\n    ////////////////////////////////////\n    \n    ///@notice called by xdai proxy via bridge, posts question to Oracle\n    function postQuestionToOracle(address _marketAddress, string calldata _question, uint32 _oracleResolutionTime) external {\n        require(msg.sender == address(bridge), \"Not bridge\");\n        require(bridge.messageSender() == proxyXdaiAddress, \"Not proxy\");\n        require(questionIds[_marketAddress] == 0, \"Already posted\");\n        bytes32 _questionId = realitio.askQuestion(2, _question, arbitrator, timeout, _oracleResolutionTime, 0);\n        questionIds[_marketAddress] = _questionId;\n        emit LogQuestionPostedToOracle(_marketAddress, _questionId);\n    }\n\n    /// @notice has the oracle finalised \n    function isFinalized(address _marketAddress) public view returns(bool) {\n        bytes32 _questionId = questionIds[_marketAddress];\n        bool _isFinalized = realitio.isFinalized(_questionId);\n        return _isFinalized;\n    }\n\n    /// @dev can be called by anyone, reads winner from Oracle and sends to xdai proxy via bridge\n    /// @dev can be called more than once in case bridge fails, xdai proxy will reject a second successful call\n    function getWinnerFromOracle(address _marketAddress) external {\n        require(isFinalized(_marketAddress), \"Oracle not finalised\");\n        bytes32 _questionId = questionIds[_marketAddress];\n        bytes32 _winningOutcome = realitio.resultFor(_questionId);\n        bytes4 _methodSelector = IRCProxyXdai(address(0)).setWinner.selector;\n        bytes memory data = abi.encodeWithSelector(_methodSelector, _marketAddress, _winningOutcome);\n        bridge.requireToPassMessage(proxyXdaiAddress,data,400000);\n    }\n\n    ////////////////////////////////////\n    /// CORE FUNCTIONS - NFT UPGRADES //\n    ////////////////////////////////////\n\n    /// @notice mints NFT with metadata as sent by proxy\n    function upgradeCard(uint256 _newTokenId, string calldata _tokenUri, address _owner) external {\n        require(msg.sender == address(bridge), \"Not bridge\");\n        require(bridge.messageSender() == proxyXdaiAddress, \"Not proxy\");\n        nfthub.mintNft(_newTokenId, _tokenUri, _owner);\n    }  \n\n    ////////////////////////////////////\n    //// CORE FUNCTIONS - DAI BRIDGE ///\n    ////////////////////////////////////\n\n    /// @dev user deposit assuming prior approval\n    function depositDai(uint256 _amount) external {\n        _depositDai(msg.sender, _amount); \n    }\n\n    /// @dev user deposit without prior approval\n    function permitAndDepositDai(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s, uint256 _amount) external {\n        require(allowed, \"only possible if allowance is set\");\n        dai.permit(holder, spender, nonce, expiry, allowed, v, r, s);\n        _depositDai(holder, _amount);\n    }\n\n    /// @dev send Dai to xDai proxy and emit event for offchain validator \n    function _depositDai(address _sender, uint256 _amount) internal {\n        require(depositsEnabled, \"Deposits disabled\");\n        require(dai.transferFrom(_sender, address(this), _amount), \"Token transfer failed\");\n        alternateReceiverBridge.relayTokens(address(this), proxyXdaiAddress, _amount);\n        emit DaiDeposited(_sender, _amount, depositNonce++);\n    }\n}"
    },
    {
      "filename": "contracts/bridgeproxies/RCProxyMainnet.sol",
      "content": "pragma solidity 0.5.13;\n\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport '../interfaces/IRealitio.sol';\nimport '../interfaces/IRCProxyXdai.sol';\nimport '../interfaces/IBridge.sol';\nimport '../interfaces/IAlternateReceiverBridge.sol';\nimport '../interfaces/IERC20Dai.sol';\nimport '../interfaces/IERC721.sol';\n\n/// @title Reality Cards Proxy- Mainnet side\n/// @author Andrew Stanger & Marvin Kruse\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCProxyMainnet is Ownable\n{\n    ////////////////////////////////////\n    //////// VARIABLES /////////////////\n    ////////////////////////////////////\n\n    /// @dev contract variables\n    IRealitio public realitio;\n    IBridge public bridge;\n    IAlternateReceiverBridge public alternateReceiverBridge;\n    IERC20Dai public dai;\n    IERC721 public nfthub;\n\n    /// @dev governance variables\n    address public proxyXdaiAddress;\n    address public nftHubAddress;\n    address public arbitrator;\n    uint32 public timeout;\n    \n    /// @dev market resolution variables\n    mapping (address => bytes32) public questionIds;\n\n    /// @dev dai deposits\n    uint256 internal depositNonce;\n    bool depositsEnabled = true;\n\n    ////////////////////////////////////\n    ////////// CONSTRUCTOR /////////////\n    ////////////////////////////////////\n\n    constructor(address _bridgeMainnetAddress, address _realitioAddress, address _nftHubAddress, address _alternateReceiverAddress, address _daiAddress) public {\n        setBridgeMainnetAddress(_bridgeMainnetAddress);\n        setRealitioAddress(_realitioAddress);\n        setNftHubAddress(_nftHubAddress);\n        setAlternateReceiverAddress(_alternateReceiverAddress);\n        setDaiAddress(_daiAddress); \n        setArbitrator(0xd47f72a2d1d0E91b0Ec5e5f5d02B2dc26d00A14D); // kleros\n        setTimeout(86400); // 24 hours\n    }\n\n    ////////////////////////////////////\n    //////////// EVENTS ////////////////\n    ////////////////////////////////////\n\n    event LogQuestionPostedToOracle(address indexed marketAddress, bytes32 indexed questionId);\n    event DaiDeposited(address indexed user, uint256 amount, uint256 nonce);\n\n    ////////////////////////////////////\n    /////// GOVERNANCE - SETUP /////////\n    ////////////////////////////////////\n    \n    /// @dev address of xdai oracle proxy, called by the xdai side of the arbitrary message bridge\n    /// @dev not set in constructor, address not known at deployment\n    function setProxyXdaiAddress(address _newAddress) onlyOwner external {\n        proxyXdaiAddress = _newAddress;\n    }\n\n    /// @dev address of arbitrary message bridge, mainnet side\n    function setBridgeMainnetAddress(address _newAddress) onlyOwner public {\n        bridge = IBridge(_newAddress);\n    }\n\n    /// @dev address of alternate receiver bridge, mainnet side\n    function setNftHubAddress(address _newAddress) onlyOwner public {\n        nfthub = IERC721(_newAddress);\n    }\n\n    /// @dev address of alternate receiver bridge, mainnet side\n    function setAlternateReceiverAddress(address _newAddress) onlyOwner public {\n        alternateReceiverBridge = IAlternateReceiverBridge(_newAddress);\n    }\n\n    /// @dev address of dai contract, must also approve the ARB\n    function setDaiAddress(address _newAddress) onlyOwner public {\n        dai = IERC20Dai(_newAddress);\n        dai.approve(address(alternateReceiverBridge), 2**256 - 1);\n    }\n\n    ////////////////////////////////////\n    /////// GOVERNANCE - ORACLE ////////\n    ////////////////////////////////////\n\n    /// @dev address reality.eth contracts\n    function setRealitioAddress(address _newAddress) onlyOwner public {\n        realitio = IRealitio(_newAddress);\n    }\n\n    /// @dev address of arbitrator, in case of continued disputes on reality.eth\n    function setArbitrator(address _newAddress) onlyOwner public {\n        arbitrator = _newAddress;\n    }\n\n    /// @dev how long reality.eth waits for disputes before finalising\n    function setTimeout(uint32 _newTimeout) onlyOwner public {\n        timeout = _newTimeout;\n    }\n\n    /// @dev admin can post question if not already posted\n    /// @dev for situations where bridge failed\n    function postQuestionToOracleAdmin(address _marketAddress, string calldata _question, uint32 _oracleResolutionTime) onlyOwner external {\n        require(questionIds[_marketAddress] == 0, \"Already posted\");\n        bytes32 _questionId = realitio.askQuestion(2, _question, arbitrator, timeout, _oracleResolutionTime, 0);\n        questionIds[_marketAddress] = _questionId;\n        emit LogQuestionPostedToOracle(_marketAddress, _questionId);\n    }\n\n    ////////////////////////////////////\n    //// GOVERNANCE - NFT UPGRADES /////\n    ////////////////////////////////////\n\n    /// @dev admin can create NFTs\n    /// @dev for situations where bridge failed\n    function upgradeCardAdmin(uint256 _newTokenId, string calldata _tokenUri, address _owner) onlyOwner external {\n        nfthub.mintNft(_newTokenId, _tokenUri, _owner);\n    }  \n\n    ////////////////////////////////////\n    ///// GOVERNANCE - DAI BRIDGE //////\n    ////////////////////////////////////\n\n    function enableOrDisableDeposits() onlyOwner external {\n        depositsEnabled = depositsEnabled ? false : true;\n    }\n    \n    ////////////////////////////////////\n    ///// CORE FUNCTIONS - ORACLE //////\n    ////////////////////////////////////\n    \n    ///@notice called by xdai proxy via bridge, posts question to Oracle\n    function postQuestionToOracle(address _marketAddress, string calldata _question, uint32 _oracleResolutionTime) external {\n        require(msg.sender == address(bridge), \"Not bridge\");\n        require(bridge.messageSender() == proxyXdaiAddress, \"Not proxy\");\n        require(questionIds[_marketAddress] == 0, \"Already posted\");\n        bytes32 _questionId = realitio.askQuestion(2, _question, arbitrator, timeout, _oracleResolutionTime, 0);\n        questionIds[_marketAddress] = _questionId;\n        emit LogQuestionPostedToOracle(_marketAddress, _questionId);\n    }\n\n    /// @notice has the oracle finalised \n    function isFinalized(address _marketAddress) public view returns(bool) {\n        bytes32 _questionId = questionIds[_marketAddress];\n        bool _isFinalized = realitio.isFinalized(_questionId);\n        return _isFinalized;\n    }\n\n    /// @dev can be called by anyone, reads winner from Oracle and sends to xdai proxy via bridge\n    /// @dev can be called more than once in case bridge fails, xdai proxy will reject a second successful call\n    function getWinnerFromOracle(address _marketAddress) external {\n        require(isFinalized(_marketAddress), \"Oracle not finalised\");\n        bytes32 _questionId = questionIds[_marketAddress];\n        bytes32 _winningOutcome = realitio.resultFor(_questionId);\n        bytes4 _methodSelector = IRCProxyXdai(address(0)).setWinner.selector;\n        bytes memory data = abi.encodeWithSelector(_methodSelector, _marketAddress, _winningOutcome);\n        bridge.requireToPassMessage(proxyXdaiAddress,data,400000);\n    }\n\n    ////////////////////////////////////\n    /// CORE FUNCTIONS - NFT UPGRADES //\n    ////////////////////////////////////\n\n    /// @notice mints NFT with metadata as sent by proxy\n    function upgradeCard(uint256 _newTokenId, string calldata _tokenUri, address _owner) external {\n        require(msg.sender == address(bridge), \"Not bridge\");\n        require(bridge.messageSender() == proxyXdaiAddress, \"Not proxy\");\n        nfthub.mintNft(_newTokenId, _tokenUri, _owner);\n    }  \n\n    ////////////////////////////////////\n    //// CORE FUNCTIONS - DAI BRIDGE ///\n    ////////////////////////////////////\n\n    /// @dev user deposit assuming prior approval\n    function depositDai(uint256 _amount) external {\n        _depositDai(msg.sender, _amount); \n    }\n\n    /// @dev user deposit without prior approval\n    function permitAndDepositDai(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s, uint256 _amount) external {\n        require(allowed, \"only possible if allowance is set\");\n        dai.permit(holder, spender, nonce, expiry, allowed, v, r, s);\n        _depositDai(holder, _amount);\n    }\n\n    /// @dev send Dai to xDai proxy and emit event for offchain validator \n    function _depositDai(address _sender, uint256 _amount) internal {\n        require(depositsEnabled, \"Deposits disabled\");\n        require(dai.transferFrom(_sender, address(this), _amount), \"Token transfer failed\");\n        alternateReceiverBridge.relayTokens(address(this), proxyXdaiAddress, _amount);\n        emit DaiDeposited(_sender, _amount, depositNonce++);\n    }\n}"
    },
    {
      "filename": "contracts/bridgeproxies/RCProxyMainnet.sol",
      "content": "pragma solidity 0.5.13;\n\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport '../interfaces/IRealitio.sol';\nimport '../interfaces/IRCProxyXdai.sol';\nimport '../interfaces/IBridge.sol';\nimport '../interfaces/IAlternateReceiverBridge.sol';\nimport '../interfaces/IERC20Dai.sol';\nimport '../interfaces/IERC721.sol';\n\n/// @title Reality Cards Proxy- Mainnet side\n/// @author Andrew Stanger & Marvin Kruse\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCProxyMainnet is Ownable\n{\n    ////////////////////////////////////\n    //////// VARIABLES /////////////////\n    ////////////////////////////////////\n\n    /// @dev contract variables\n    IRealitio public realitio;\n    IBridge public bridge;\n    IAlternateReceiverBridge public alternateReceiverBridge;\n    IERC20Dai public dai;\n    IERC721 public nfthub;\n\n    /// @dev governance variables\n    address public proxyXdaiAddress;\n    address public nftHubAddress;\n    address public arbitrator;\n    uint32 public timeout;\n    \n    /// @dev market resolution variables\n    mapping (address => bytes32) public questionIds;\n\n    /// @dev dai deposits\n    uint256 internal depositNonce;\n    bool depositsEnabled = true;\n\n    ////////////////////////////////////\n    ////////// CONSTRUCTOR /////////////\n    ////////////////////////////////////\n\n    constructor(address _bridgeMainnetAddress, address _realitioAddress, address _nftHubAddress, address _alternateReceiverAddress, address _daiAddress) public {\n        setBridgeMainnetAddress(_bridgeMainnetAddress);\n        setRealitioAddress(_realitioAddress);\n        setNftHubAddress(_nftHubAddress);\n        setAlternateReceiverAddress(_alternateReceiverAddress);\n        setDaiAddress(_daiAddress); \n        setArbitrator(0xd47f72a2d1d0E91b0Ec5e5f5d02B2dc26d00A14D); // kleros\n        setTimeout(86400); // 24 hours\n    }\n\n    ////////////////////////////////////\n    //////////// EVENTS ////////////////\n    ////////////////////////////////////\n\n    event LogQuestionPostedToOracle(address indexed marketAddress, bytes32 indexed questionId);\n    event DaiDeposited(address indexed user, uint256 amount, uint256 nonce);\n\n    ////////////////////////////////////\n    /////// GOVERNANCE - SETUP /////////\n    ////////////////////////////////////\n    \n    /// @dev address of xdai oracle proxy, called by the xdai side of the arbitrary message bridge\n    /// @dev not set in constructor, address not known at deployment\n    function setProxyXdaiAddress(address _newAddress) onlyOwner external {\n        proxyXdaiAddress = _newAddress;\n    }\n\n    /// @dev address of arbitrary message bridge, mainnet side\n    function setBridgeMainnetAddress(address _newAddress) onlyOwner public {\n        bridge = IBridge(_newAddress);\n    }\n\n    /// @dev address of alternate receiver bridge, mainnet side\n    function setNftHubAddress(address _newAddress) onlyOwner public {\n        nfthub = IERC721(_newAddress);\n    }\n\n    /// @dev address of alternate receiver bridge, mainnet side\n    function setAlternateReceiverAddress(address _newAddress) onlyOwner public {\n        alternateReceiverBridge = IAlternateReceiverBridge(_newAddress);\n    }\n\n    /// @dev address of dai contract, must also approve the ARB\n    function setDaiAddress(address _newAddress) onlyOwner public {\n        dai = IERC20Dai(_newAddress);\n        dai.approve(address(alternateReceiverBridge), 2**256 - 1);\n    }\n\n    ////////////////////////////////////\n    /////// GOVERNANCE - ORACLE ////////\n    ////////////////////////////////////\n\n    /// @dev address reality.eth contracts\n    function setRealitioAddress(address _newAddress) onlyOwner public {\n        realitio = IRealitio(_newAddress);\n    }\n\n    /// @dev address of arbitrator, in case of continued disputes on reality.eth\n    function setArbitrator(address _newAddress) onlyOwner public {\n        arbitrator = _newAddress;\n    }\n\n    /// @dev how long re"
    }
  ]
}