{
  "Title": "[G-09] Using unchecked blocks to save gas - Increments in for loop can be unchecked  ( save 30-40 gas per loop iteration)",
  "Content": "\nThe majority of Solidity for loops increment a uint256 variable that starts at 0. These increment operations never need to be checked for over/underflow because the variable will never reach the max number of uint256 (will run out of gas long before that happens). The default over/underflow check wastes gas in every iteration of virtually every for loop . eg.\n\ne.g Let's work with a sample loop below.\n\n```\nfor(uint256 i; i < 10; i++){\n//doSomething\n}\n\n```\n\ncan be written as shown below.\n\n    for(uint256 i; i < 10;) {\n      // loop logic\n      unchecked { i++; }\n    }\n\nWe can also write it as an inlined function like below.\n\n    function inc(i) internal pure returns (uint256) {\n      unchecked { return i + 1; }\n    }\n    for(uint256 i; i < 10; i = inc(i)) {\n      // doSomething\n    }\n\n**Affected code**<br>\nFile: HomeFiProxy.sol [line 87](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/HomeFiProxy.sol#L87-L89)\n\n```solidity\n        for (uint256 i = 0; i < _length; i++) {\n            _generateProxy(allContractNames[i], _implementations[i]);\n        }\n```\n\nThe above should be modified to:\n\n```solidity\n        for (uint256 i = 0; i < _length;) {\n            _generateProxy(allContractNames[i], _implementations[i]);\n\t\tunchecked {\n\t\t\t++i;\n\t\t}\n        }\n```\n\n**Other Instances to modify**<br>\nFile: Project.sol [Line 248](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L248)\n\n```solidity\n        for (uint256 i = 0; i < _length; i++) {\n```\n\nFile: Project.sol [Line 311](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L311-L313)\n\n```solidity\n        for (uint256 i = 0; i < _length; i++) {\n            _inviteSC(_taskList[i], _scList[i], false);\n        }\n```\n\nFile: Project.sol [Line 322](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/Project.sol#L322)\n\n```solidity\n        for (uint256 i = 0; i < _length; i++) {\n```\n\nFile: Tasks.sol [Line 181](https://github.com/code-423n4/2022-08-rigor/blob/b17b2a11d04289f9e927c71703b42771dd7b86a4/contracts/libraries/Tasks.sol#L181)\n\n```solidity\n        for (uint256 i = 0; i < _length; i++) _alerts[i] = _self.alerts[i];\n```\n\n[see resource](https://github.com/ethereum/solidity/issues/10695)\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-08-rigor-protocol-contest",
  "Code": [
    {
      "filename": "contracts/HomeFiProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {TransparentUpgradeableProxy} from \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport {ProxyAdmin} from \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/**\n * @title HomeFiProxy Contract for HomeFi v2.5.0\n\n * @dev This contract provided functionality to update the core HomeFi contracts.\n */\ncontract HomeFiProxy is OwnableUpgradeable {\n    /*******************************************************************************\n     * -------------------------PUBLIC STORED PROPERTIES-------------------------- *\n     *******************************************************************************/\n\n    /// @notice Address of proxy admin\n    ProxyAdmin public proxyAdmin;\n\n    /// @notice bytes2 array of upgradable contracts initials\n    bytes2[] public allContractNames;\n\n    /*******************************************************************************\n     * ------------------------INTERNAL STORED PROPERTIES------------------------- *\n     *******************************************************************************/\n\n    /// @dev mapping that tell if a particular address is active(latest version of contract)\n    mapping(address => bool) internal contractsActive;\n\n    /// @dev mapping that maps contract initials with there implementation address\n    mapping(bytes2 => address payable) internal contractAddress;\n\n    /*******************************************************************************\n     * ---------------------------------MODIFIERS--------------------------------- *\n     *******************************************************************************/\n\n    /// @dev check _address should not be zero address\n    modifier nonZero(address _address) {\n        require(_address != address(0), \"Proxy::0 address\");\n        _;\n    }\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @notice Initialize all the homeFi contract in the correct sequential order and generate upgradable proxy for them.\n\n     * @dev Can only be called by HomeFiProxy owner.\n     * @dev modifier initializer\n     * @dev if more contract are added in homeFi, then their entry can be done here. \n\n     * @param _implementations the implementation address of homeFi smart contract in correct sequence.\n     */\n    function initiateHomeFi(address[] calldata _implementations)\n        external\n        initializer\n    {\n        // Initialize ownable\n        __Ownable_init();\n\n        // Create new proxy admin contract\n        proxyAdmin = new ProxyAdmin();\n\n        // Initial contract names\n        allContractNames.push(\"HF\"); // HomeFi\n        allContractNames.push(\"CN\"); // Community\n        allContractNames.push(\"DP\"); // Disputes\n        allContractNames.push(\"PF\"); // Project Factory\n        allContractNames.push(\"DA\"); // rDAI\n        allContractNames.push(\"US\"); // rUSDC\n        allContractNames.push(\"NT\"); // native token rETH - rXDAI\n\n        // Local instance of variable. For saving gas.\n        uint256 _length = allContractNames.length;\n\n        // Revert if _implementations length is wrong. Indicating wrong set of _implementations.\n        require(_length == _implementations.length, \"Proxy::Lengths !match\");\n\n        // Mark this contract as active\n        contractsActive[address(this)] = true;\n\n        // Generate proxy for all implementation\n        for (uint256 i = 0; i < _length; i++) {\n            _generateProxy(allContractNames[i], _implementations[i]);\n        }\n    }\n\n    /**\n     * @notice Adds a new contract type/implementation to HomeFi\n\n     * @dev modifier onlyOwner\n\n     * @param _contractName initial of contract to be added\n     * @param _contractAddress address of contract implementation to be added.\n     */\n    function addNewContract(bytes2 _contractName, address _contractAddress)\n        external\n        onlyOwner\n    {\n        // Revert if _contractName is already in use.\n        require(\n            contractAddress[_contractName] == address(0),\n            \"Proxy::Name !OK\"\n        );\n\n        // Add to allContractNames\n        allContractNames.push(_contractName);\n\n        // Generate proxy\n        _generateProxy(_contractName, _contractAddress);\n    }\n\n    /**\n     * @notice Upgrades a multiple contract implementations. Replaces old implementation with new.\n\n     * @dev modifier onlyOwner\n\n     * @param _contractNames bytes2 array of contract initials that needs to be upgraded\n     * @param _contractAddresses address array of contract implementation address that needs to be upgraded\n     */\n    function upgradeMultipleImplementations(\n        bytes2[] calldata _contractNames,\n        address[] calldata _contractAddresses\n    ) external onlyOwner {\n        // Local instance of variable. For saving gas.\n        uint256 _length = _contractNames.length;\n\n        // Revert if _contractNames and _contractAddresses length mismatch\n        require(_length == _contractAddresses.length, \"Proxy::Lengths !match\");\n\n        // Replace implementations\n        for (uint256 i = 0; i < _length; i++) {\n            _replaceImplementation(_contractNames[i], _contractAddresses[i]);\n        }\n    }\n\n    /**\n     * @notice Allows HomeFiProxy owner to change the owner of proxyAdmin contract.\n     * This can be useful when trying to deploy new version of HomeFiProxy\n\n     * @dev modifier onlyOwner\n     * @dev modifier nonZero with _newAdmin\n\n     * @param _newAdmin address of new proxyAdmin owner / new version of HomeFiProxy\n     */\n    function changeProxyAdminOwner(address _newAdmin)\n        external\n        onlyOwner\n        nonZero(_newAdmin)\n    {\n        // Transfer ownership to new admin.\n        proxyAdmin.transferOwnership(_newAdmin);\n    }\n\n    /*******************************************************************************\n     * ------------------------------EXTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @notice To check if we use the particular contract.\n     * @param _address The contract address to check if it is active or not.\n     * @return true if _address is active else false\n     */\n    function isActive(address _address) external view returns (bool) {\n        return contractsActive[_address];\n    }\n\n    /**\n     * @notice Gets latest contract address\n     * @param _contractName Contract name to fetch\n     * @return current implementation address corresponding to _contractName\n     */\n    function getLatestAddress(bytes2 _contractName)\n        external\n        view\n        returns (address)\n    {\n        return contractAddress[_contractName];\n    }\n\n    /*******************************************************************************\n     * ---------------------------INTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @dev Replaces the implementations of the contract.\n     * @dev modifier nonZero with _contractAddress\n\n     * @param _contractName The name of the contract.\n\n     * @param _contractAddress The address of the contract to replace the implementations for.\n     */\n    function _replaceImplementation(\n        bytes2 _contractName,\n        address _contractAddress\n    ) internal nonZero(_contractAddress) {\n        // Upgrade proxy\n        proxyAdmin.upgrade(\n            TransparentUpgradeableProxy(contractAddress[_contractName]),\n            _contractAddress\n        );\n    }\n\n    /**\n     * @dev generates upgradable proxy\n     * @dev modifier nonZero with _contractAddress\n\n     * @param _contractName initial of the contract\n\n     * @param _contractAddress of the proxy\n     */\n    function _generateProxy(bytes2 _contractName, address _contractAddress)\n        internal\n        nonZero(_contractAddress)\n    {\n        // Deploys new TransparentUpgradeableProxy for implementation\n        TransparentUpgradeableProxy tempInstance = new TransparentUpgradeableProxy(\n                _contractAddress,\n                address(proxyAdmin),\n                bytes(\"\")\n            );\n\n        // Store details\n        contractAddress[_contractName] = payable(address(tempInstance));\n        contractsActive[address(tempInstance)] = true;\n    }\n}"
    },
    {
      "filename": "contracts/Project.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {IHomeFi} from \"./interfaces/IHomeFi.sol\";\nimport {IProject} from \"./interfaces/IProject.sol\";\nimport {IDebtToken} from \"./interfaces/IDebtToken.sol\";\nimport {IDisputes} from \"./interfaces/IDisputes.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ERC2771ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {Tasks, Task, TaskStatus} from \"./libraries/Tasks.sol\";\nimport {SignatureDecoder} from \"./libraries/SignatureDecoder.sol\";\n\n/**\n * @title Deployable Project Contract for HomeFi v2.5.0\n\n * @notice contains the primary logic around construction project management. \n * Onboarding contractors, fund escrow, and completion tracking are all managed here. \n * Significant multi-signature and meta-transaction functionality is included here.\n\n * @dev This contract is created as a clone copy for the end user\n */\ncontract Project is\n    IProject,\n    ReentrancyGuardUpgradeable,\n    ERC2771ContextUpgradeable\n{\n    // Using Tasks library for Task struct\n    using Tasks for Task;\n\n    // Using SafeERC20Upgradeable library for IDebtToken\n    using SafeERC20Upgradeable for IDebtToken;\n\n    /*******************************************************************************\n     * ------------------------FIXED INTERNAL STORED PROPERTIES------------------------- *\n     *******************************************************************************/\n\n    /// @notice Disputes contract instance\n    address internal disputes;\n\n    /// @notice mapping of tasks index to Task struct.\n    mapping(uint256 => Task) internal tasks;\n\n    /// @notice array of indexes of change ordered tasks\n    uint256[] internal _changeOrderedTask;\n\n    /*******************************************************************************\n     * ----------------------FIXED PUBLIC STORED PROPERTIES----------------------- *\n     *******************************************************************************/\n    /// @inheritdoc IProject\n    IHomeFi public override homeFi;\n    /// @inheritdoc IProject\n    IDebtToken public override currency;\n    /// @inheritdoc IProject\n    uint256 public override lenderFee;\n    /// @inheritdoc IProject\n    address public override builder;\n    /// @inheritdoc IProject\n    uint256 public constant override VERSION = 25000;\n\n    /*******************************************************************************\n     * ---------------------VARIABLE PUBLIC STORED PROPERTIES--------------------- *\n     *******************************************************************************/\n    /// @inheritdoc IProject\n    address public override contractor;\n    /// @inheritdoc IProject\n    bool public override contractorConfirmed;\n    /// @inheritdoc IProject\n    uint256 public override hashChangeNonce;\n    /// @inheritdoc IProject\n    uint256 public override totalLent;\n    /// @inheritdoc IProject\n    uint256 public override totalAllocated;\n    /// @inheritdoc IProject\n    uint256 public override taskCount;\n    /// @inheritdoc IProject\n    bool public override contractorDelegated;\n    /// @inheritdoc IProject\n    uint256 public override lastAllocatedTask;\n    /// @inheritdoc IProject\n    uint256 public override lastAllocatedChangeOrderTask;\n    /// @inheritdoc IProject\n    mapping(address => mapping(bytes32 => bool)) public override approvedHashes;\n\n    /// @dev Added to make sure master implementation cannot be initialized\n    // solhint-disable-next-line no-empty-blocks\n    constructor() initializer {}\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTION---------------------------- *\n     *******************************************************************************/\n    /// @inheritdoc IProject\n    function initialize(\n        address _currency,\n        address _sender,\n        address _homeFiAddress\n    ) external override initializer {\n        // Initialize variables\n        homeFi = IHomeFi(_homeFiAddress);\n        disputes = homeFi.disputesContract();\n        lenderFee = homeFi.lenderFee();\n        builder = _sender;\n        currency = IDebtToken(_currency);\n    }\n\n    /// @inheritdoc IProject\n    function approveHash(bytes32 _hash) external override {\n        address _sender = _msgSender();\n        // Allowing anyone to sign, as its hard to add restrictions here.\n        // Store _hash as signed for sender.\n        approvedHashes[_sender][_hash] = true;\n\n        emit ApproveHash(_hash, _sender);\n    }\n\n    /// @inheritdoc IProject\n    function inviteContractor(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Revert if contractor has already confirmed his invitation\n        require(!contractorConfirmed, \"Project::GC accepted\");\n\n        // Decode params from _data\n        (address _contractor, address _projectAddress) = abi.decode(\n            _data,\n            (address, address)\n        );\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_projectAddress == address(this), \"Project::!projectAddress\");\n\n        // Revert if contractor address is invalid.\n        require(_contractor != address(0), \"Project::0 address\");\n\n        // Store new contractor\n        contractor = _contractor;\n        contractorConfirmed = true;\n\n        // Check signature for builder and contractor\n        checkSignature(_data, _signature);\n\n        emit ContractorInvited(contractor);\n    }\n\n    /// @inheritdoc IProject\n    function delegateContractor(bool _bool) external override {\n        // Revert if sender is not builder\n        require(_msgSender() == builder, \"Project::!B\");\n\n        // Revert if contract not assigned\n        require(contractor != address(0), \"Project::0 address\");\n\n        // Store new bool for contractorDelegated\n        contractorDelegated = _bool;\n\n        emit ContractorDelegated(_bool);\n    }\n\n    /// @inheritdoc IProject\n    function updateProjectHash(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Check for required signatures\n        checkSignature(_data, _signature);\n\n        // Decode params from _data\n        (bytes memory _hash, uint256 _nonce) = abi.decode(\n            _data,\n            (bytes, uint256)\n        );\n\n        // Revert if decoded nonce is incorrect. This indicates wrong _data.\n        require(_nonce == hashChangeNonce, \"Project::!Nonce\");\n\n        // Increment to ensure a set of data and signature cannot be re-used.\n        hashChangeNonce += 1;\n\n        emit HashUpdated(_hash);\n    }\n\n    /// @inheritdoc IProject\n    function lendToProject(uint256 _cost) external override nonReentrant {\n        address _sender = _msgSender();\n\n        // Revert if sender is not builder or Community Contract (lender)\n        require(\n            _sender == builder || _sender == homeFi.communityContract(),\n            \"Project::!Builder&&!Community\"\n        );\n\n        // Revert if try to lend 0\n        require(_cost > 0, \"Project::!value>0\");\n\n        // Revert if try to lend more than project cost\n        uint256 _newTotalLent = totalLent + _cost;\n        require(\n            projectCost() >= uint256(_newTotalLent),\n            \"Project::value>required\"\n        );\n\n        if (_sender == builder) {\n            // Transfer assets from builder to this contract\n            currency.safeTransferFrom(_sender, address(this), _cost);\n        }\n\n        // Update total lent with added lend\n        totalLent = _newTotalLent;\n\n        emit LendToProject(_cost);\n\n        // Allocate funds to tasks and mark then as allocated\n        allocateFunds();\n    }\n\n    /// @inheritdoc IProject\n    function addTasks(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // If the sender is disputes contract, then do not check for signatures.\n        if (_msgSender() != disputes) {\n            // Check for required signatures\n            checkSignature(_data, _signature);\n        }\n\n        // Decode params from _data\n        (\n            bytes[] memory _hash,\n            uint256[] memory _taskCosts,\n            uint256 _taskCount,\n            address _projectAddress\n        ) = abi.decode(_data, (bytes[], uint256[], uint256, address));\n\n        // Revert if decoded taskCount is incorrect. This indicates wrong data.\n        require(_taskCount == taskCount, \"Project::!taskCount\");\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_projectAddress == address(this), \"Project::!projectAddress\");\n\n        // Revert if IPFS hash array length is not equal to task cost array length.\n        uint256 _length = _hash.length;\n        require(_length == _taskCosts.length, \"Project::Lengths !match\");\n\n        // Loop over all the new tasks.\n        for (uint256 i = 0; i < _length; i++) {\n            // Increment local task counter.\n            _taskCount += 1;\n\n            // Check task cost precision. Revert if too precise.\n            checkPrecision(_taskCosts[i]);\n\n            // Initialize task.\n            tasks[_taskCount].initialize(_taskCosts[i]);\n        }\n\n        // Update task counter equal to local task counter.\n        taskCount = _taskCount;\n\n        emit TasksAdded(_taskCosts, _hash);\n    }\n\n    /// @inheritdoc IProject\n    function updateTaskHash(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Decode params from _data\n        (bytes memory _taskHash, uint256 _nonce, uint256 _taskID) = abi.decode(\n            _data,\n            (bytes, uint256, uint256)\n        );\n\n        // Revert if decoded nonce is incorrect. This indicates wrong data.\n        require(_nonce == hashChangeNonce, \"Project::!Nonce\");\n\n        // If subcontractor has confirmed then check signature using `checkSignatureTask`.\n        // Else check signature using `checkSignature`.\n        if (getAlerts(_taskID)[2]) {\n            // If subcontractor has confirmed.\n            checkSignatureTask(_data, _signature, _taskID);\n        } else {\n            // If subcontractor not has confirmed.\n            checkSignature(_data, _signature);\n        }\n\n        // Increment to ensure a set of data and signature cannot be re-used.\n        hashChangeNonce += 1;\n\n        emit TaskHashUpdated(_taskID, _taskHash);\n    }\n\n    /// @inheritdoc IProject\n    function inviteSC(uint256[] calldata _taskList, address[] calldata _scList)\n        external\n        override\n    {\n        // Revert if sender is neither builder nor contractor.\n        require(\n            _msgSender() == builder || _msgSender() == contractor,\n            \"Project::!Builder||!GC\"\n        );\n\n        // Revert if taskList array length not equal to scList array length.\n        uint256 _length = _taskList.length;\n        require(_length == _scList.length, \"Project::Lengths !match\");\n\n        // Invite subcontractor for each task.\n        for (uint256 i = 0; i < _length; i++) {\n            _inviteSC(_taskList[i], _scList[i], false);\n        }\n\n        emit MultipleSCInvited(_taskList, _scList);\n    }\n\n    /// @inheritdoc IProject\n    function acceptInviteSC(uint256[] calldata _taskList) external override {\n        // Accept invitation for each task in taskList.\n        uint256 _length = _taskList.length;\n        for (uint256 i = 0; i < _length; i++) {\n            tasks[_taskList[i]].acceptInvitation(_msgSender());\n        }\n\n        emit SCConfirmed(_taskList);\n    }\n\n    /// @inheritdoc IProject\n    function setComplete(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Decode params from _data\n        (uint256 _taskID, address _projectAddress) = abi.decode(\n            _data,\n            (uint256, address)\n        );\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_projectAddress == address(this), \"Project::!Project\");\n\n        // If the sender is disputes contract, then do not check for signatures.\n        if (_msgSender() != disputes) {\n            // Check signatures.\n            checkSignatureTask(_data, _signature, _taskID);\n        }\n\n        // Mark task as complete. Only works when task is active.\n        tasks[_taskID].setComplete();\n\n        // Transfer funds to subcontractor.\n        currency.safeTransfer(\n            tasks[_taskID].subcontractor,\n            tasks[_taskID].cost\n        );\n\n        emit TaskComplete(_taskID);\n    }\n\n    /// @inheritdoc IProject\n    function recoverTokens(address _tokenAddress) external override {\n        /* If the token address is same as currency of this project,\n            then first check if all tasks are complete */\n        if (_tokenAddress == address(currency)) {\n            // Iterate for each task and check if it is complete.\n            uint256 _length = taskCount;\n            for (uint256 _taskID = 1; _taskID <= _length; _taskID++) {\n                require(tasks[_taskID].getState() == 3, \"Project::!Complete\");\n            }\n        }\n\n        // Create token instance.\n        IDebtToken _token = IDebtToken(_tokenAddress);\n\n        // Check the balance of _token in this contract.\n        uint256 _leftOutTokens = _token.balanceOf(address(this));\n\n        // If balance is present then it to the builder.\n        if (_leftOutTokens > 0) {\n            _token.safeTransfer(builder, _leftOutTokens);\n        }\n    }\n\n    /// @inheritdoc IProject\n    function changeOrder(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n        nonReentrant\n    {\n        // Decode params from _data\n        (\n            uint256 _taskID,\n            address _newSC,\n            uint256 _newCost,\n            address _project\n        ) = abi.decode(_data, (uint256, address, uint256, address));\n\n        // If the sender is disputes contract, then do not check for signatures.\n        if (_msgSender() != disputes) {\n            // Check for required signatures.\n            checkSignatureTask(_data, _signature, _taskID);\n        }\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_project == address(this), \"Project::!projectAddress\");\n\n        // Local variable for task cost. For gas saving.\n        uint256 _taskCost = tasks[_taskID].cost;\n\n        // Local variable indicating if subcontractor is already unapproved.\n        bool _unapproved = false;\n\n        // If task cost is to be changed.\n        if (_newCost != _taskCost) {\n            // Check new task cost precision. Revert if too precise.\n            checkPrecision(_newCost);\n\n            // Local variable for total cost allocated. For gas saving.\n            uint256 _totalAllocated = totalAllocated;\n\n            // If tasks are already allocated with old cost.\n            if (tasks[_taskID].alerts[1]) {\n                // If new task cost is less than old task cost.\n                if (_newCost < _taskCost) {\n                    // Find the difference between old - new.\n                    uint256 _withdrawDifference = _taskCost - _newCost;\n\n                    // Reduce this difference from total cost allocated.\n                    // As the same task is now allocated with lesser cost.\n                    totalAllocated -= _withdrawDifference;\n\n                    // Withdraw the difference back to builder's account.\n                    // As this additional amount may not be required by the project.\n                    autoWithdraw(_withdrawDifference);\n                }\n                // If new cost is more than task cost but total lent is enough to cover for it.\n                else if (totalLent - _totalAllocated >= _newCost - _taskCost) {\n                    // Increase the difference of new cost and old cost to total allocated.\n                    totalAllocated += _newCost - _taskCost;\n                }\n                // If new cost is more than task cost and totalLent is not enough.\n                else {\n                    // Un-confirm SC, mark task as inactive, mark allocated as false, mark lifecycle as None\n\n                    // Mark task as inactive by unapproving subcontractor.\n                    // As subcontractor can only be approved if task is allocated\n                    _unapproved = true;\n                    tasks[_taskID].unApprove();\n\n                    // Mark task as not allocated.\n                    tasks[_taskID].unAllocateFunds();\n\n                    // Reduce total allocation by old task cost.\n                    // As as needs to go though funding process again.\n                    totalAllocated -= _taskCost;\n\n                    // Add this task to _changeOrderedTask array. These tasks will be allocated first.\n                    _changeOrderedTask.push(_taskID);\n                }\n            }\n\n            // Store new cost for the task\n            tasks[_taskID].cost = _newCost;\n\n            emit ChangeOrderFee(_taskID, _newCost);\n        }\n\n        // If task subcontractor is to be changed.\n        if (_newSC != tasks[_taskID].subcontractor) {\n            // If task is not already unapproved, then un-approve it.\n            // Un-approving task means marking subcontractor as unconfirmed.\n            if (!_unapproved) {\n                tasks[_taskID].unApprove();\n            }\n\n            // If new subcontractor is not zero address.\n            if (_newSC != address(0)) {\n                // Invite the new subcontractor for the task.\n                _inviteSC(_taskID, _newSC, true);\n            }\n            // Else store zero address for the task subcontractor.\n            // This implies that a subcontractor is not invited from the task.\n            else {\n                tasks[_taskID].subcontractor = address(0);\n            }\n\n            emit ChangeOrderSC(_taskID, _newSC);\n        }\n    }\n\n    /// @inheritdoc IProject\n    function raiseDispute(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Recover the signer from the signature\n        address signer = SignatureDecoder.recoverKey(\n            keccak256(_data),\n            _signature,\n            0\n        );\n\n        // Decode params from _data\n        (address _project, uint256 _task, , , ) = abi.decode(\n            _data,\n            (address, uint256, uint8, bytes, bytes)\n        );\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_project == address(this), \"Project::!projectAddress\");\n\n        if (_task == 0) {\n            // Revet if sender is not builder or contractor\n            require(\n                signer == builder || signer == contractor,\n                \"Project::!(GC||Builder)\"\n            );\n        } else {\n            // Revet if sender is not builder, contractor or task's subcontractor\n            require(\n                signer == builder ||\n                    signer == contractor ||\n                    signer == tasks[_task].subcontractor,\n                \"Project::!(GC||Builder||SC)\"\n            );\n\n            if (signer == tasks[_task].subcontractor) {\n                // If sender is task's subcontractor, revert if invitation is not accepted.\n                require(getAlerts(_task)[2], \"Project::!SCConfirmed\");\n            }\n        }\n\n        // Make a call to Disputes contract raiseDisputes.\n        IDisputes(disputes).raiseDispute(_data, _signature);\n    }\n\n    /*******************************************************************************\n     * ------------------------------EXTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IProject\n    function getTask(uint256 id)\n        external\n        view\n        override\n        returns (\n            uint256 cost,\n            address subcontractor,\n            TaskStatus state\n        )\n    {\n        cost = tasks[id].cost;\n        subcontractor = tasks[id].subcontractor;\n        state = tasks[id].state;\n    }\n\n    /// @inheritdoc IProject\n    function changeOrderedTask()\n        external\n        view\n        override\n        returns (uint256[] memory)\n    {\n        return _changeOrderedTask;\n    }\n\n    /*******************************************************************************\n     * ----------------------------PUBLIC TRANSACTIONS---------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IProject\n    function allocateFunds() public override {\n        // Max amount out times this loop will run\n        // This is to ensure the transaction do not run out of gas (max gas limit)\n        uint256 _maxLoop = 50;\n\n        // Difference of totalLent and totalAllocated is what can be used to allocate new tasks\n        uint256 _costToAllocate = totalLent - totalAllocated;\n\n        // Bool if max loop limit is exceeded\n        bool _exceedLimit;\n\n        // Local instance of lastAllocatedChangeOrderTask. To save gas.\n        uint256 i = lastAllocatedChangeOrderTask;\n\n        // Local instance of lastAllocatedTask. To save gas.\n        uint256 j = lastAllocatedTask;\n\n        // Initialize empty array in which allocated tasks will be added.\n        uint256[] memory _tasksAllocated = new uint256[](\n            taskCount - j + _changeOrderedTask.length - i\n        );\n\n        // Number of times a loop has run.\n        uint256 _loopCount;\n\n        /// CHANGE ORDERED TASK FUNDING ///\n\n        // Any tasks added to _changeOrderedTask will be allocated first\n        if (_changeOrderedTask.length > 0) {\n            // Loop from lastAllocatedChangeOrderTask to _changeOrderedTask length (until _maxLoop)\n            for (; i < _changeOrderedTask.length; i++) {\n                // Local instance of task cost. To save gas.\n                uint256 _taskCost = tasks[_changeOrderedTask[i]].cost;\n\n                // If _maxLoop limit is reached then stop looping\n                if (_loopCount >= _maxLoop) {\n                    _exceedLimit = true;\n                    break;\n                }\n\n                // If there is enough funds to allocate this task\n                if (_costToAllocate >= _taskCost) {\n                    // Reduce task cost from _costToAllocate\n                    _costToAllocate -= _taskCost;\n\n                    // Mark the task as allocated\n                    tasks[_changeOrderedTask[i]].fundTask();\n\n                    // Add task to _tasksAllocated array\n                    _tasksAllocated[_loopCount] = _changeOrderedTask[i];\n\n                    // Increment loop counter\n                    _loopCount++;\n                }\n                // If there are not enough funds to allocate this task then stop looping\n                else {\n                    break;\n                }\n            }\n\n            // If all the change ordered tasks are allocated, then delete\n            // the changeOrderedTask array and reset lastAllocatedChangeOrderTask.\n            if (i == _changeOrderedTask.length) {\n                lastAllocatedChangeOrderTask = 0;\n                delete _changeOrderedTask;\n            }\n            // Else store the last allocated change order task index.\n            else {\n                lastAllocatedChangeOrderTask = i;\n            }\n        }\n\n        /// TASK FUNDING ///\n\n        // If lastAllocatedTask is lesser than taskCount, that means there are un-allocated tasks\n        if (j < taskCount) {\n            // Loop from lastAllocatedTask + 1 to taskCount (until _maxLoop)\n            for (++j; j <= taskCount; j++) {\n                // Local instance of task cost. To save gas.\n                uint256 _taskCost = tasks[j].cost;"
    }
  ]
}