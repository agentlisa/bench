{
  "Title": "M-12: Loan duration can exceed the end of the next epoch",
  "Content": "# Issue M-12: Loan duration can exceed the end of the next epoch \n\nSource: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/170 \n\n## Found by \n0xRajeev\n\n## Summary\n\nLoan duration can exceed the end of the next epoch, which deviates from the protocol specification.\n\n## Vulnerability Detail\n\nFrom the specs: \"The duration of new loans is restricted to not exceed the end of the next epoch. For example, if a PublicVault is 15 days into a 30-day epoch, new loans must not be longer than 45 days.\"\n\nHowever, there's no enforcement of this requirement. \n\n## Impact\n\nThe implementation does not adhere to the spec: Loan duration can exceed the end of the next epoch, which breaks protocol specification and therefore lead to miscalculations and potential fund loss.\n\n\n## Code Snippet\n\n1. https://docs.astaria.xyz/docs/protocol-mechanics/epochs\n2. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/VaultImplementation.sol#L146-L228\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nImplement as per specification or revisit the specification.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/8",
  "Code": [
    {
      "filename": "src/VaultImplementation.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n/**\n *       __  ___       __\n *  /\\  /__'  |   /\\  |__) |  /\\\n * /~~\\ .__/  |  /~~\\ |  \\ | /~~\\\n *\n * Copyright (c) Astaria Labs, Inc\n */\n\npragma solidity ^0.8.17;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC721, ERC721TokenReceiver} from \"solmate/tokens/ERC721.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n\nimport {IAuctionHouse} from \"gpl/interfaces/IAuctionHouse.sol\";\nimport {IVault, AstariaVaultBase} from \"gpl/ERC4626-Cloned.sol\";\n\nimport {CollateralLookup} from \"./libraries/CollateralLookup.sol\";\n\nimport {IAstariaRouter} from \"./interfaces/IAstariaRouter.sol\";\nimport {ICollateralToken} from \"./interfaces/ICollateralToken.sol\";\nimport {ILienBase, ILienToken} from \"./interfaces/ILienToken.sol\";\nimport {ILienToken} from \"./interfaces/ILienToken.sol\";\n\n/**\n * @title VaultImplementation\n * @author androolloyd\n * @notice A base implementation for the minimal features of an Astaria Vault.\n */\nabstract contract VaultImplementation is ERC721TokenReceiver, AstariaVaultBase {\n  using SafeTransferLib for ERC20;\n  using CollateralLookup for address;\n  using FixedPointMathLib for uint256;\n\n  address public delegate; //account connected to the daemon\n\n  event NewLien(\n    bytes32 strategyRoot,\n    address tokenContract,\n    uint256 tokenId,\n    uint256 amount\n  );\n\n  event NewVault(address appraiser, address vault);\n\n  /**\n   * @notice receive hook for ERC721 tokens, nothing special done\n   */\n  function onERC721Received(\n    address operator_,\n    address from_,\n    uint256 tokenId_,\n    bytes calldata data_\n  ) external pure override returns (bytes4) {\n    return ERC721TokenReceiver.onERC721Received.selector;\n  }\n\n  modifier whenNotPaused() {\n    if (IAstariaRouter(ROUTER()).paused()) {\n      revert(\"protocol is paused\");\n    }\n    _;\n  }\n\n  function domainSeparator() public view virtual returns (bytes32) {\n    return\n      keccak256(\n        abi.encode(\n          keccak256(\n            \"EIP712Domain(string version,uint256 chainId,address verifyingContract)\"\n          ),\n          keccak256(\"0\"),\n          block.chainid,\n          address(this)\n        )\n      );\n  }\n\n  /*\n   * @notice encodes the data for a 712 signature\n   * @param tokenContract The address of the token contract\n   * @param tokenId The id of the token\n   * @param amount The amount of the token\n   */\n\n  // cast k \"StrategyDetails(uint256 nonce,uint256 deadline,bytes32 root)\"\n  bytes32 private constant STRATEGY_TYPEHASH =\n    0x679f3933bd13bd2e4ec6e9cde341ede07736ad7b635428a8a211e9cccb4393b0;\n\n  function encodeStrategyData(\n    IAstariaRouter.StrategyDetails calldata strategy,\n    bytes32 root\n  ) public view returns (bytes memory) {\n    bytes32 hash = keccak256(\n      abi.encode(\n        STRATEGY_TYPEHASH,\n        IAstariaRouter(ROUTER()).strategistNonce(strategy.strategist),\n        strategy.deadline,\n        root\n      )\n    );\n    return\n      abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), hash);\n  }\n\n  /**\n   * @dev hook to allow inheriting contracts to perform payout for strategist\n   */\n  function _handleStrategistInterestReward(uint256, uint256) internal virtual {}\n\n  struct InitParams {\n    address delegate;\n  }\n\n  function init(InitParams calldata params) external virtual {\n    require(msg.sender == address(ROUTER()), \"only router\");\n\n    if (params.delegate != address(0)) {\n      delegate = params.delegate;\n    }\n  }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner(), \"only strategist\");\n    _;\n  }\n\n  function setDelegate(address delegate_) public onlyOwner {\n    delegate = delegate_;\n  }\n\n  /**\n   * @dev Validates the terms for a requested loan.\n   * Who is requesting the borrow, is it a smart contract? or is it a user?\n   * if a smart contract, then ensure that the contract is approved to borrow and is also receiving the funds.\n   * if a user, then ensure that the user is approved to borrow and is also receiving the funds.\n   * The terms are hashed and signed by the borrower, and the signature validated against the strategist's address\n   * lien details are decoded from the obligation data and validated the collateral\n   *\n   * @param params The Commitment information containing the loan parameters and the merkle proof for the strategy supporting the requested loan.\n   * @param receiver The address of the prospective borrower.\n   */\n  function _validateCommitment(\n    IAstariaRouter.Commitment calldata params,\n    address receiver\n  ) internal returns (IAstariaRouter.LienDetails memory) {\n    uint256 collateralId = params.tokenContract.computeId(params.tokenId);\n\n    address operator = ERC721(COLLATERAL_TOKEN()).getApproved(collateralId);\n\n    address holder = ERC721(COLLATERAL_TOKEN()).ownerOf(collateralId);\n\n    if (msg.sender != holder) {\n      require(msg.sender == operator, \"invalid request\");\n    }\n\n    if (receiver != holder) {\n      require(\n        receiver == operator || IAstariaRouter(ROUTER()).isValidVault(receiver),\n        \"can only issue funds to an vault or operator if not the holder\"\n      );\n    }\n\n    address recovered = ecrecover(\n      keccak256(\n        encodeStrategyData(\n          params.lienRequest.strategy,\n          params.lienRequest.merkle.root\n        )\n      ),\n      params.lienRequest.v,\n      params.lienRequest.r,\n      params.lienRequest.s\n    );\n    require(\n      recovered == params.lienRequest.strategy.strategist,\n      \"strategist must match signature\"\n    );\n    require(\n      recovered == owner() || recovered == delegate,\n      \"invalid strategist\"\n    );\n\n    (bool valid, IAstariaRouter.LienDetails memory ld) = IAstariaRouter(\n      ROUTER()\n    ).validateCommitment(params);\n\n    require(\n      valid,\n      \"Vault._validateCommitment(): Verification of provided merkle branch failed for the vault and parameters\"\n    );\n\n    require(\n      ld.rate > 0,\n      \"Vault._validateCommitment(): Cannot have a 0 interest rate\"\n    );\n\n    require(\n      ld.rate < IAstariaRouter(ROUTER()).maxInterestRate(),\n      \"Vault._validateCommitment(): Rate is above maximum\"\n    );\n\n    require(\n      ld.maxAmount >= params.lienRequest.amount,\n      \"Vault._validateCommitment(): Attempting to borrow more than maxAmount available for this asset\"\n    );\n\n    uint256 seniorDebt = IAstariaRouter(ROUTER())\n      .LIEN_TOKEN()\n      .getTotalDebtForCollateralToken(\n        params.tokenContract.computeId(params.tokenId)\n      );\n    require(\n      params.lienRequest.amount <= ERC20(underlying()).balanceOf(address(this)),\n      \"Vault._validateCommitment():  Attempting to borrow more than available in the specified vault\"\n    );\n\n    uint256 potentialDebt = seniorDebt * (ld.rate + 1) * ld.duration;\n    require(\n      potentialDebt <= ld.maxPotentialDebt,\n      \"Vault._validateCommitment(): Attempting to initiate a loan with debt potentially higher than maxPotentialDebt\"\n    );\n\n    return ld;\n  }\n\n  function _afterCommitToLien(uint256 lienId, uint256 amount)\n    internal\n    virtual\n  {}\n\n  /**\n   * @notice Pipeline for lifecycle of new loan origination.\n   * Origination consists of a few phases: pre-commitment validation, lien token issuance, strategist reward, and after commitment actions\n   * Starts by depositing collateral and take out a lien against it. Next, verifies the merkle proof for a loan commitment. Vault owners are then rewarded fees for successful loan origination.\n   * @param params Commitment data for the incoming lien request\n   * @param receiver The borrower receiving the loan.\n   */\n  function commitToLien(\n    IAstariaRouter.Commitment calldata params,\n    address receiver\n  ) external whenNotPaused {\n    IAstariaRouter.LienDetails memory ld = _validateCommitment(\n      params,\n      receiver\n    );\n    uint256 lienId = _requestLienAndIssuePayout(ld, params, receiver);\n    _afterCommitToLien(lienId, params.lienRequest.amount);\n    emit NewLien(\n      params.lienRequest.merkle.root,\n      params.tokenContract,\n      params.tokenId,\n      params.lienRequest.amount\n    );\n  }\n\n  /**\n   * @notice Returns whether a specific lien can be liquidated.\n   * @param collateralId The ID of the underlying CollateralToken.\n   * @param position The specified lien position.\n   * @return A boolean value indicating whether the specified lien can be liquidated.\n   */\n  function canLiquidate(uint256 collateralId, uint256 position)\n    public\n    view\n    returns (bool)\n  {\n    return IAstariaRouter(ROUTER()).canLiquidate(collateralId, position);\n  }\n\n  /**\n   * @notice Buy out a lien to replace it with new terms.\n   * @param collateralId The ID of the underlying CollateralToken.\n   * @param position The position of the specified lien.\n   * @param incomingTerms The loan terms of the new lien.\n   */\n  function buyoutLien(\n    uint256 collateralId,\n    uint256 position,\n    IAstariaRouter.Commitment calldata incomingTerms\n  ) external whenNotPaused {\n    (, uint256 buyout) = IAstariaRouter(ROUTER()).LIEN_TOKEN().getBuyout(\n      collateralId,\n      position\n    );\n\n    require(\n      buyout <= ERC20(underlying()).balanceOf(address(this)),\n      \"not enough balance to buy out loan\"\n    );\n\n    _validateCommitment(incomingTerms, recipient());\n\n    ERC20(underlying()).safeApprove(\n      address(IAstariaRouter(ROUTER()).TRANSFER_PROXY()),\n      buyout\n    );\n    IAstariaRouter(ROUTER()).LIEN_TOKEN().buyoutLien(\n      ILienBase.LienActionBuyout(incomingTerms, position, recipient())\n    );\n  }\n\n  /**\n   * @notice Retrieves the recipient of loan repayments. For PublicVaults (VAULT_TYPE 2), this is always the vault address. For PrivateVaults, retrieves the owner() of the vault.\n   * @return The address of the recipient.\n   */\n  function recipient() public view returns (address) {\n    if (VAULT_TYPE() == uint8(IAstariaRouter.VaultType.PUBLIC)) {\n      return address(this);\n    } else {\n      return owner();\n    }\n  }\n\n  /**\n   * @dev Generates a Lien for a valid loan commitment proof and sends the loan amount to the borrower.\n   * @param c The Commitment information containing the loan parameters and the merkle proof for the strategy supporting the requested loan.\n   * @param receiver The borrower requesting the loan.\n   * @return The ID of the created Lien.\n   */\n  function _requestLienAndIssuePayout(\n    IAstariaRouter.LienDetails memory ld,\n    IAstariaRouter.Commitment calldata c,\n    address receiver\n  ) internal returns (uint256) {\n    uint256 newLienId = IAstariaRouter(ROUTER()).requestLienPosition(ld, c);\n\n    uint256 payout = _handleProtocolFee(c.lienRequest.amount);\n    ERC20(underlying()).safeTransfer(receiver, payout);\n    return newLienId;\n  }\n\n  function _handleProtocolFee(uint256 amount) internal returns (uint256) {\n    address feeTo = IAstariaRouter(ROUTER()).feeTo();\n    bool feeOn = feeTo != address(0);\n    if (feeOn) {\n      uint256 fee = IAstariaRouter(ROUTER()).getProtocolFee(amount);\n\n      unchecked {\n        amount -= fee;\n      }\n      ERC20(underlying()).safeTransfer(feeTo, fee);\n    }\n    return amount;\n  }\n}"
    }
  ]
}