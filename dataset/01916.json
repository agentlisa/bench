{
  "Title": "M-12: Debt cannot be repaid without redeeming vault share",
  "Content": "# Issue M-12: Debt cannot be repaid without redeeming vault share \n\nSource: https://github.com/sherlock-audit/2023-03-notional-judging/issues/191 \n\n## Found by \nxiaoming90\n## Summary\n\nDebt cannot be repaid without redeeming the vault share. As such, users have to redeem a certain amount of vault shares/strategy tokens at the current market price to work around this issue, which deprives users of potential gains from their vault shares if they maintain ownership until the end.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/external/actions/VaultAccountAction.sol#L277\n\n```solidity\nFile: VaultAccountAction.sol\n224:     function exitVault(\n225:         address account,\n226:         address vault,\n227:         address receiver,\n228:         uint256 vaultSharesToRedeem,\n229:         uint256 lendAmount,\n230:         uint32 minLendRate,\n231:         bytes calldata exitVaultData\n232:     ) external payable override nonReentrant returns (uint256 underlyingToReceiver) {\n..SNIP..\n261:         // If insufficient strategy tokens are redeemed (or if it is set to zero), then\n262:         // redeem with debt repayment will recover the repayment from the account's wallet\n263:         // directly.\n264:         underlyingToReceiver = underlyingToReceiver.add(vaultConfig.redeemWithDebtRepayment(\n265:             vaultAccount, receiver, vaultSharesToRedeem, exitVaultData\n266:         ));\n```\n\nThere is a valid scenario where users want to repay debt without redeeming their vault shares/strategy tokens (mentioned in the comments above \"or if it is set to zero\" at Line 251-263). In this case, the users will call `exitVault` with `vaultSharesToRedeem` parameter set to zero. The entire debt to be repaid will then be recovered directly from the account's wallet.\n\nFollowing is the function trace of the `VaultAccountAction.exitVault`:\n\n```bash\nVaultAccountAction.exitVault\n└─VaultConfiguration.redeemWithDebtRepayment\n  └─VaultConfiguration._redeem\n    └─IStrategyVault.redeemFromNotional\n      └─MetaStable2TokenAuraVault._redeemFromNotional\n        └─MetaStable2TokenAuraHelper.redeem\n          └─Balancer2TokenPoolUtils._redeem\n            └─StrategyUtils._redeemStrategyTokens\n```\n\nhttps://github.com/notional-finance/leveraged-vaults/blob/c707f7781e36d7a1259214dde2221f892a81a9c1/contracts/vaults/common/internal/strategy/StrategyUtils.sol#L153\n\n```solidity\nFile: StrategyUtils.sol\n147:     function _redeemStrategyTokens(\n148:         StrategyContext memory strategyContext,\n149:         uint256 strategyTokens\n150:     ) internal returns (uint256 poolClaim) {\n151:         poolClaim = _convertStrategyTokensToPoolClaim(strategyContext, strategyTokens);\n152: \n153:         if (poolClaim == 0) {\n154:             revert Errors.ZeroPoolClaim();\n155:         }\n```\n\nThe problem is that if the vault shares/strategy tokens to be redeemed are zero, the `poolClaim` will be zero and cause a revert within the `StrategyUtils._redeemStrategyTokens` function call. Thus, users who want to repay debt without redeeming their vault shares/strategy tokens will be unable to do so.\n\n## Impact\n\nUsers cannot repay debt without redeeming their vault shares/strategy tokens. To do so, they have to redeem a certain amount of vault shares/strategy tokens at the current market price to work around this issue so that `poolClaim > 0`, which deprives users of potential gains from their vault shares if they maintain ownership until the end.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/external/actions/VaultAccountAction.sol#L277\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWithin the `VaultConfiguration.redeemWithDebtRepayment` function, skip the vault share redemption if `vaultShares` is zero. In this case, the `amountTransferred` will be zero, and the subsequent code will attempt to recover the entire `underlyingExternalToRepay` amount directly from account's wallet.\n\n```diff\nfunction redeemWithDebtRepayment(\n\tVaultConfig memory vaultConfig,\n\tVaultAccount memory vaultAccount,\n\taddress receiver,\n\tuint256 vaultShares,\n\tbytes calldata data\n) internal returns (uint256 underlyingToReceiver) {\n\tuint256 amountTransferred;\n\tuint256 underlyingExternalToRepay;\n\t{\n..SNIP..\n+\t\tif (vaultShares > 0) {\n\t\t\t// Repayment checks operate entirely on the underlyingExternalToRepay, the amount of\n\t\t\t// prime cash raised is irrelevant here since tempCashBalance is cleared to zero as\n\t\t\t// long as sufficient underlying has been returned to the protocol.\n\t\t\t(amountTransferred, underlyingToReceiver, /* primeCashRaised */) = _redeem(\n\t\t\t\tvaultConfig,\n\t\t\t\tunderlyingToken,\n\t\t\t\tvaultAccount.account,\n\t\t\t\treceiver,\n\t\t\t\tvaultShares,\n\t\t\t\tvaultAccount.maturity,\n\t\t\t\tunderlyingExternalToRepay,\n\t\t\t\tdata\n\t\t\t); \n+\t\t}\n..Recover any unpaid debt amount from the account directly..\n..SNIP..\n```\n\nAlternatively, update the `StrategyUtils._redeemStrategyTokens` function to handle zero vault share appropriately. However, note that the revert at Line 154 is added as part of mitigation to the \"minting zero-share\" bug in the past audit. Therefore, any changes to this part of the code must ensure that the \"minting zero-share\" bug is not being re-introduced. Removing the code at 153-155 might result in the user's vault share being \"burned\" but no assets in return under certain conditions.\n\n```solidity\nFile: StrategyUtils.sol\n147:     function _redeemStrategyTokens(\n148:         StrategyContext memory strategyContext,\n149:         uint256 strategyTokens\n150:     ) internal returns (uint256 poolClaim) {\n151:         poolClaim = _convertStrategyTokensToPoolClaim(strategyContext, strategyTokens);\n152: \n153:         if (poolClaim == 0) {\n154:             revert Errors.ZeroPoolClaim();\n155:         }\n```\n\n\n\n## Discussion\n\n**jeffywu**\n\nAgree with the issue, however, the fix will be to remove the error from _redeemStrategyTokens. We should always call the vault in case there is something it needs to do during the vault action.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/59",
  "Code": [
    {
      "filename": "contracts-v2/contracts/external/actions/VaultAccountAction.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport {\n    VaultAccount,\n    VaultState,\n    PrimeRate,\n    VaultConfig\n} from \"../../global/Types.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {SafeUint256} from \"../../math/SafeUint256.sol\";\nimport {SafeInt256} from \"../../math/SafeInt256.sol\";\n\nimport {PrimeRateLib} from \"../../internal/pCash/PrimeRateLib.sol\";\nimport {VaultConfiguration} from \"../../internal/vaults/VaultConfiguration.sol\";\nimport {VaultAccountLib} from \"../../internal/vaults/VaultAccount.sol\";\nimport {VaultValuation} from \"../../internal/vaults/VaultValuation.sol\";\nimport {VaultStateLib, VaultState} from \"../../internal/vaults/VaultState.sol\";\n\nimport {ActionGuards} from \"./ActionGuards.sol\";\nimport {TradingAction} from \"./TradingAction.sol\";\nimport {IVaultAccountAction, IVaultAccountHealth} from \"../../../interfaces/notional/IVaultController.sol\";\n\ncontract VaultAccountAction is ActionGuards, IVaultAccountAction {\n    using VaultConfiguration for VaultConfig;\n    using VaultAccountLib for VaultAccount;\n    using VaultStateLib for VaultState;\n    using PrimeRateLib for PrimeRate;\n    using SafeInt256 for int256;\n    using SafeUint256 for uint256;\n\n    /// @notice Settles a matured vault account by transforming it from an fCash maturity into\n    /// a prime cash account. This method is not authenticated, anyone can settle a vault account\n    /// without permission. Generally speaking, this action is economically equivalent no matter\n    /// when it is called. In some edge conditions when the vault is holding prime cash, it is\n    /// advantageous for the vault account to have this called sooner. All vault account actions\n    /// will first settle the vault account before taking any further actions.\n    /// @param account the address to settle\n    /// @param vault the vault the account is in\n    function settleVaultAccount(address account, address vault) external override nonReentrant {\n        requireValidAccount(account);\n        require(account != vault);\n\n        VaultConfig memory vaultConfig = VaultConfiguration.getVaultConfigStateful(vault);\n        VaultAccount memory vaultAccount = VaultAccountLib.getVaultAccount(account, vaultConfig);\n        \n        // Require that the account settled, otherwise we may leave the account in an unintended\n        // state in this method because we allow it to skip the min borrow check in the next line.\n        (bool didSettle, bool didTransfer) = vaultAccount.settleVaultAccount(vaultConfig);\n        require(didSettle, \"No Settle\");\n\n        vaultAccount.accruePrimeCashFeesToDebt(vaultConfig);\n\n        // Skip Min Borrow Check so that accounts can always be settled\n        vaultAccount.setVaultAccount({vaultConfig: vaultConfig, checkMinBorrow: false});\n\n        if (didTransfer) {\n            // If the vault did a transfer (i.e. withdrew cash) we have to check their collateral ratio. There\n            // is an edge condition where a vault with secondary borrows has an emergency exit. During that process\n            // an account will be left some cash balance in both currencies. It may have excess cash in one and\n            // insufficient cash in the other. A withdraw of the excess in one side will cause the vault account to\n            // be insolvent if we do not run this check. If this scenario indeed does occur, the vault itself must\n            // be upgraded in order to facilitate orderly exits for all of the accounts since they will be prevented\n            // from settling.\n            IVaultAccountHealth(address(this)).checkVaultAccountCollateralRatio(vault, account);\n        }\n    }\n\n    /// @notice Borrows a specified amount of fCash in the vault's borrow currency and deposits it\n    /// all plus the depositAmountExternal into the vault to mint strategy tokens.\n    /// @param account the address that will enter the vault\n    /// @param vault the vault to enter\n    /// @param depositAmountExternal some amount of additional collateral in the borrowed currency\n    /// to be transferred to vault\n    /// @param maturity the maturity to borrow at\n    /// @param borrowAmount amount to borrow, for fCash maturities this is the fCash amount. For pCash\n    /// maturities this is the underlying borrowed.\n    /// @param maxBorrowRate maximum interest rate to borrow at, only applies as a slippage limit for\n    /// fCash maturities\n    /// @param vaultData additional data to pass to the vault contract\n    /// @return vaultSharesAdded the total vault shares tokens added to the maturity. Allows enterVault\n    /// to be used by off-chain methods to get an accurate simulation of the strategy tokens minted.\n    function enterVault(\n        address account,\n        address vault,\n        uint256 depositAmountExternal,\n        uint256 maturity,\n        uint256 borrowAmount,\n        uint32 maxBorrowRate,\n        bytes calldata vaultData\n    ) external payable override nonReentrant returns (uint256 vaultSharesAdded) { \n        // Ensure that system level accounts cannot enter vaults\n        requireValidAccount(account);\n        require(account != vault);\n\n        VaultConfig memory vaultConfig = VaultConfiguration.getVaultConfigStateful(vault);\n        vaultConfig.authorizeCaller(account, VaultConfiguration.ONLY_VAULT_ENTRY);\n\n        // If the vault allows further re-entrancy then set the status back to the default\n        if (vaultConfig.getFlag(VaultConfiguration.ALLOW_REENTRANCY)) {\n            reentrancyStatus = _NOT_ENTERED;\n        }\n\n        // Vaults cannot be entered if they are paused or matured\n        require(vaultConfig.getFlag(VaultConfiguration.ENABLED));\n        require(block.timestamp < maturity);\n\n        VaultAccount memory vaultAccount = VaultAccountLib.getVaultAccount(account, vaultConfig);\n        vaultAccount.settleAccountOrAccruePrimeCashFees(vaultConfig);\n\n        // Accounts can only call enter vault when establishing a new account or increasing an existing\n        // position. Accounts that have matured fCash positions can increase their prime cash position.\n        require(vaultAccount.maturity == 0 || vaultAccount.maturity == maturity); // dev: cannot enter with matured position\n\n        // Deposits some amount of tokens into as margin for the vault. The tokens are first transferred into Notional\n        // and then withdrawn as prime cash when entering the vault\n        vaultConfig.depositMarginForVault(vaultAccount, depositAmountExternal);\n\n        vaultSharesAdded = vaultAccount.borrowAndEnterVault(\n            vaultConfig, maturity, borrowAmount, maxBorrowRate, vaultData, 0\n        );\n\n        IVaultAccountHealth(address(this)).checkVaultAccountCollateralRatio(vault, account);\n    }\n\n    /// @notice Re-enters the vault at a different maturity. The account's existing borrow position will be closed\n    /// and a new borrow position at the specified maturity will be opened. Strategy token holdings will transfer\n    /// to the new maturity. Accounts can roll to longer or shorter dated maturities.\n    /// @param account the address that will reenter the vault\n    /// @param vault the vault to reenter\n    /// @param newBorrowAmount amount of fCash to borrow in the next maturity\n    /// @param maturity new maturity to borrow at\n    /// @param depositAmountExternal amount to deposit into the new maturity\n    /// @param minLendRate slippage protection for repaying debts\n    /// @param maxBorrowRate slippage protection for new borrow position\n    /// @return vaultSharesAdded the total strategy tokens added to the maturity, including any tokens\n    /// rolled from the previous maturity. Allows rollVaultPosition to be used by off-chain methods to get\n    /// an accurate simulation of the strategy tokens minted.\n    function rollVaultPosition(\n        address account,\n        address vault,\n        uint256 newBorrowAmount,\n        uint256 maturity,\n        uint256 depositAmountExternal,\n        uint32 minLendRate,\n        uint32 maxBorrowRate,\n        bytes calldata enterVaultData\n    ) external payable override nonReentrant returns (uint256 vaultSharesAdded) {\n        VaultConfig memory vaultConfig = VaultConfiguration.getVaultConfigStateful(vault);\n        vaultConfig.authorizeCaller(account, VaultConfiguration.ONLY_VAULT_ROLL);\n\n        // If the vault allows further re-entrancy then set the status back to the default\n        if (vaultConfig.getFlag(VaultConfiguration.ALLOW_REENTRANCY)) {\n            reentrancyStatus = _NOT_ENTERED;\n        }\n\n        // If the vault account has matured, this will return a vault account in the prime cash\n        // maturity. The vault account may have some temporary cash balance that will be applied\n        // to lending or borrowing.\n        VaultAccount memory vaultAccount = VaultAccountLib.getVaultAccount(account, vaultConfig);\n        vaultAccount.settleAccountOrAccruePrimeCashFees(vaultConfig);\n\n        // Cannot roll unless all of these requirements are met\n        require(vaultConfig.getFlag(VaultConfiguration.ENABLED));\n        require(vaultConfig.getFlag(VaultConfiguration.ALLOW_ROLL_POSITION));\n        // Must borrow into the new maturity, otherwise account should exit\n        require(newBorrowAmount > 0);\n        // Cannot roll into the existing maturity, after settlement this will be the prime cash maturity\n        require(vaultAccount.maturity != maturity);\n\n        // VaultState must be loaded after settleAccountOrAccruePrimeCashFees\n        VaultState memory vaultState = VaultStateLib.getVaultState(vaultConfig, vaultAccount.maturity);\n        // Exit the maturity pool by removing all the vault shares.\n        vaultSharesAdded = vaultAccount.vaultShares;\n        vaultState.exitMaturity(vaultAccount, vaultConfig, vaultAccount.vaultShares);\n\n        // Exit the vault first and debit the temporary cash balance with the cost to exit\n        vaultAccount.lendToExitVault(\n            vaultConfig,\n            vaultState,\n            vaultAccount.accountDebtUnderlying.neg(), // must fully exit the fCash position\n            minLendRate,\n            block.timestamp\n        );\n\n        // This should never be the case for a healthy vault account due to the mechanics of exiting the vault\n        // above but we check it for safety here.\n        require(vaultAccount.accountDebtUnderlying == 0);\n        vaultState.setVaultState(vaultConfig);\n\n        // Takes a deposit from the user as repayment for the lending, allows an account to roll their position\n        // even if they are close to the max borrow capacity.\n        vaultConfig.depositMarginForVault(vaultAccount, depositAmountExternal);\n\n        // Enters the vault at the longer dated maturity. The account is required to borrow at this\n        // point due  to the requirement earlier in this method, they cannot enter the maturity\n        // with below minAccountBorrowSize\n        vaultSharesAdded = vaultAccount.borrowAndEnterVault(\n            vaultConfig,\n            maturity, // This is the new maturity to enter\n            newBorrowAmount,\n            maxBorrowRate,\n            enterVaultData,\n            vaultSharesAdded\n        );\n\n        // emit VaultRollPosition(vault, account, maturity, newBorrowAmount);\n        IVaultAccountHealth(address(this)).checkVaultAccountCollateralRatio(vault, account);\n    }\n\n    /// @notice Allows an account to withdraw their position from the vault at any time. Will\n    /// redeem some number of vault shares to the borrow currency and close the borrow position by\n    /// lending. Any shortfall in cash from lending will be transferred from the account, any excess\n    /// profits will be transferred to the account.\n    /// @param account the address that will exit the vault\n    /// @param vault the vault to enter\n    /// @param receiver the address that will receive profits\n    /// @param vaultSharesToRedeem amount of vault tokens to exit, only relevant when exiting pre-maturity\n    /// @param lendAmount amount of fCash to lend if fixed, amount of underlying to lend if in pCash\n    /// @param minLendRate the minimum rate to lend at\n    /// @param exitVaultData passed to the vault during exit\n    /// @return underlyingToReceiver amount of underlying tokens returned to the receiver on exit\n    function exitVault(\n        address account,\n        address vault,\n        address receiver,\n        uint256 vaultSharesToRedeem,\n        uint256 lendAmount,\n        uint32 minLendRate,\n        bytes calldata exitVaultData\n    ) external payable override nonReentrant returns (uint256 underlyingToReceiver) {\n        VaultConfig memory vaultConfig = VaultConfiguration.getVaultConfigStateful(vault);\n        vaultConfig.authorizeCaller(account, VaultConfiguration.ONLY_VAULT_EXIT);\n\n        // If the vault allows further re-entrancy then set the status back to the default\n        if (vaultConfig.getFlag(VaultConfiguration.ALLOW_REENTRANCY)) {\n            reentrancyStatus = _NOT_ENTERED;\n        }\n\n        VaultAccount memory vaultAccount = VaultAccountLib.getVaultAccount(account, vaultConfig);\n        require(vaultAccount.lastUpdateBlockTime + Constants.VAULT_ACCOUNT_MIN_TIME <= block.timestamp);\n\n        // Do this after the check above to ensure that the lastUpdateBlockTime is enforced\n        vaultAccount.settleAccountOrAccruePrimeCashFees(vaultConfig);\n\n        // Vault state must be loaded after settleAccountOrAccruePrimeCashFees\n        VaultState memory vaultState = VaultStateLib.getVaultState(vaultConfig, vaultAccount.maturity);\n        if (vaultAccount.maturity == Constants.PRIME_CASH_VAULT_MATURITY && lendAmount == type(uint256).max) {\n            // Since prime cash values are rebasing it is difficult to calculate a full repayment off chain. If\n            // the vault account is in the prime cash maturity the uint256 max value signifies a full repayment\n            lendAmount = vaultAccount.accountDebtUnderlying.neg().toUint();\n        }\n\n        // Puts a negative cash balance on the vault's temporary cash balance\n        vaultAccount.lendToExitVault(\n            vaultConfig, vaultState, lendAmount.toInt(), minLendRate, block.timestamp\n        );\n        vaultState.exitMaturity(vaultAccount, vaultConfig, vaultSharesToRedeem);\n\n        // If insufficient strategy tokens are redeemed (or if it is set to zero), then\n        // redeem with debt repayment will recover the repayment from the account's wallet\n        // directly.\n        underlyingToReceiver = underlyingToReceiver.add(vaultConfig.redeemWithDebtRepayment(\n            vaultAccount, receiver, vaultSharesToRedeem, exitVaultData\n        ));\n\n        // Set the vault state after redemption completes\n        vaultState.setVaultState(vaultConfig);\n\n        if (vaultAccount.accountDebtUnderlying == 0 && vaultAccount.vaultShares == 0) {\n            // If the account has no position in the vault at this point, set the maturity to zero as well\n            vaultAccount.maturity = 0;\n        }\n        vaultAccount.setVaultAccount({vaultConfig: vaultConfig, checkMinBorrow: true});\n\n        // It's possible that the user redeems more vault shares than they lend (it is not always the case\n        // that they will be increasing their collateral ratio here, so we check that this is the case). No\n        // need to check if the account has exited in full (maturity == 0).\n        if (vaultAccount.maturity != 0) {\n            IVaultAccountHealth(address(this)).checkVaultAccountCollateralRatio(vault, account);\n        }\n    }\n\n    function getLibInfo() external pure returns (address) {\n        return address(TradingAction);\n    }\n}"
    },
    {
      "filename": "contracts/vaults/common/internal/strategy/StrategyUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {VaultConstants} from \"../../VaultConstants.sol\";\nimport {StrategyContext, TradeParams, StrategyVaultState} from \"../../VaultTypes.sol\";\nimport {TokenUtils, IERC20} from \"../../../../utils/TokenUtils.sol\";\nimport {TradeHandler} from \"../../../../trading/TradeHandler.sol\";\nimport {Deployments} from \"../../../../global/Deployments.sol\";\nimport {Constants} from \"../../../../global/Constants.sol\";\nimport {ITradingModule, Trade, TradeType} from \"../../../../../interfaces/trading/ITradingModule.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {VaultStorage} from \"../../VaultStorage.sol\";\n\nlibrary StrategyUtils {\n    using TradeHandler for Trade;\n    using TokenUtils for IERC20;\n    using TypeConvert for uint256;\n    using VaultStorage for StrategyVaultState;\n\n    function _checkPriceLimit(\n        StrategyContext memory strategyContext,\n        uint256 oraclePrice,\n        uint256 poolPrice\n    ) internal pure {\n        uint256 lowerLimit = (oraclePrice * \n            (VaultConstants.VAULT_PERCENT_BASIS - strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            VaultConstants.VAULT_PERCENT_BASIS;\n        uint256 upperLimit = (oraclePrice * \n            (VaultConstants.VAULT_PERCENT_BASIS + strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            VaultConstants.VAULT_PERCENT_BASIS;\n\n        if (poolPrice < lowerLimit || upperLimit < poolPrice) {\n            revert Errors.InvalidPrice(oraclePrice, poolPrice);\n        }\n    }\n\n    /// @notice Converts strategy tokens to LP tokens\n    function _convertStrategyTokensToPoolClaim(StrategyContext memory context, uint256 strategyTokenAmount)\n        internal pure returns (uint256 bptClaim) {\n        require(strategyTokenAmount <= context.vaultState.totalStrategyTokenGlobal);\n        if (context.vaultState.totalStrategyTokenGlobal > 0) {\n            bptClaim = (strategyTokenAmount * context.vaultState.totalPoolClaim) / context.vaultState.totalStrategyTokenGlobal;\n        }\n    }\n\n    /// @notice Converts LP tokens to strategy tokens\n    function _convertPoolClaimToStrategyTokens(StrategyContext memory context, uint256 bptClaim)\n        internal pure returns (uint256 strategyTokenAmount) {\n        if (context.vaultState.totalPoolClaim == 0) {\n            // Strategy tokens are in 8 decimal precision. Scale the minted amount according to pool claim precision.\n            return (bptClaim * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / \n                context.poolClaimPrecision;\n        }\n\n        // Pool claim in maturity is calculated before the new pool tokens are minted, so this calculation\n        // is the tokens minted that will give the account a corresponding share of the new pool balance held.\n        // The precision here will be the same as strategy token supply.\n        strategyTokenAmount = (bptClaim * context.vaultState.totalStrategyTokenGlobal) / context.vaultState.totalPoolClaim;\n    }\n\n    function _executeTradeExactIn(\n        TradeParams memory params,\n        ITradingModule tradingModule,\n        address sellToken,\n        address buyToken,\n        uint256 amount,\n        bool useDynamicSlippage\n    ) internal returns (uint256 amountSold, uint256 amountBought) {\n        require(\n            params.tradeType == TradeType.EXACT_IN_SINGLE || params.tradeType == TradeType.EXACT_IN_BATCH\n        );\n        if (useDynamicSlippage) {\n            require(params.oracleSlippagePercentOrLimit <= Constants.SLIPPAGE_LIMIT_PRECISION);\n        }\n\n        // Sell residual secondary balance\n        Trade memory trade = Trade(\n            params.tradeType,\n            sellToken,\n            buyToken,\n            amount,\n            useDynamicSlippage ? 0 : params.oracleSlippagePercentOrLimit,\n            block.timestamp, // deadline\n            params.exchangeData\n        );\n\n        // stETH generally has deeper liquidity than wstETH, setting tradeUnwrapped\n        // to lets the contract trade in stETH instead of wstETH\n        if (params.tradeUnwrapped) {\n            if (sellToken == address(Deployments.WRAPPED_STETH)) {\n                trade.sellToken = Deployments.WRAPPED_STETH.stETH();\n                uint256 amountBeforeUnwrap = IERC20(trade.sellToken).balanceOf(address(this));\n                // NOTE: the amount returned by unwrap is not always accurate for some reason\n                Deployments.WRAPPED_STETH.unwrap(trade.amount);\n                trade.amount = IERC20(trade.sellToken).balanceOf(address(this)) - amountBeforeUnwrap;\n            }\n            if (buyToken == address(Deployments.WRAPPED_STETH)) {\n                trade.buyToken = Deployments.WRAPPED_STETH.stETH();\n            }\n        }\n\n        if (useDynamicSlippage) {\n            /// @dev params.oracleSlippagePercentOrLimit checked above\n            (amountSold, amountBought) = trade._executeTradeWithDynamicSlippage(\n                params.dexId, tradingModule, uint32(params.oracleSlippagePercentOrLimit)\n            );\n        } else {\n            (amountSold, amountBought) = trade._executeTrade(\n                params.dexId, tradingModule\n            );\n        }\n\n        if (params.tradeUnwrapped) {\n            if (sellToken == address(Deployments.WRAPPED_STETH)) {\n                // Setting amountSold to the original wstETH amount because _executeTradeWithDynamicSlippage\n                // returns the amount of stETH sold in this case\n                /// @notice amountSold == amount because this function only supports EXACT_IN trades\n                amountSold = amount;\n            }\n            if (buyToken == address(Deployments.WRAPPED_STETH) && amountBought > 0) {\n                // trade.buyToken == stETH here\n                IERC20(trade.buyToken).checkApprove(address(Deployments.WRAPPED_STETH), amountBought);\n                uint256 amountBeforeWrap = Deployments.WRAPPED_STETH.balanceOf(address(this));\n                /// @notice the amount returned by wrap is not always accurate for some reason\n                Deployments.WRAPPED_STETH.wrap(amountBought);\n                amountBought = Deployments.WRAPPED_STETH.balanceOf(address(this)) - amountBeforeWrap;\n            }\n        }\n    }\n\n    function _mintStrategyTokens(\n        StrategyContext memory strategyContext,\n        uint256 poolClaimMinted\n    ) internal returns (uint256 strategyTokensMinted) {\n        strategyTokensMinted = _convertPoolClaimToStrategyTokens(strategyContext, poolClaimMinted);\n\n        if (strategyTokensMinted == 0) {\n            revert Errors.ZeroStrategyTokens();\n        }\n\n        strategyContext.vaultState.totalPoolClaim += poolClaimMinted;\n        strategyContext.vaultState.totalStrategyTokenGlobal += strategyTokensMinted.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n\n    function _redeemStrategyTokens(\n        StrategyContext memory strategyContext,\n        uint256 strategyTokens\n    ) internal returns (uint256 poolClaim) {\n        poolClaim = _convertStrategyTokensToPoolClaim(strategyContext, strategyTokens);\n\n        if (poolClaim == 0) {\n            revert Errors.ZeroPoolClaim();\n        }\n\n        strategyContext.vaultState.totalPoolClaim -= poolClaim;\n        strategyContext.vaultState.totalStrategyTokenGlobal -= strategyTokens.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n}"
    },
    {
      "filename": "contracts-v2/contracts/external/actions/VaultAccountAction.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport {\n    VaultAccount,\n    VaultState,\n    PrimeRate,\n    VaultConfig\n} from \"../../global/Types.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {SafeUint256} from \"../../math/SafeUint256.sol\";\nimport {SafeInt256} from \"../../math/SafeInt256.sol\";\n\nimport {PrimeRateLib} from \"../../internal/pCash/PrimeRateLib.sol\";\nimport {VaultConfiguration} from \"../../internal/vaults/VaultConfiguration.sol\";\nimport {VaultAccountLib} from \"../../internal/vaults/VaultAccount.sol\";\nimport {VaultValuation} from \"../../internal/vaults/VaultValuation.sol\";\nimport {VaultStateLib, VaultState} from \"../../internal/vaults/VaultState.sol\";\n\nimport {ActionGuards} from \"./ActionGuards.sol\";\nimport {TradingAction} from \"./TradingAction.sol\";\nimport {IVaultAccountAction, IVaultAccountHealth} from \"../../../interfaces/notional/IVaultController.sol\";\n\ncontract VaultAccountAction is ActionGuards, IVaultAccountAction {\n    using VaultConfiguration for VaultConfig;\n    using VaultAccountLib for VaultAccount;\n    using VaultStateLib for VaultState;\n    using PrimeRateLib for PrimeRate;\n    using SafeInt256 for int256;\n    using SafeUint256 for uint256;\n\n    /// @notice Settles a matured vault account by transforming it from an fCash maturity into\n    /// a prime cash account. This method is not authenticated, anyone can settle a vault account\n    /// without permission. Generally speaking, this action is economically equivalent no matter\n    /// when it is called. In some edge conditions when the vault is holding prime cash, it is\n    /// advantageous for the vault account to have this called sooner. All vault account actions\n    /// will first settle the vault account before taking any further actions.\n    /// @param account the address to settle\n    /// @param vault the vault the account is in\n    function settleVaultAccount(address account, address vault) external override nonReentrant {\n        requireValidAccount(account);\n        require(account != vault);\n\n        VaultConfig memory vaultConfig = VaultConfiguration.getVaultConfigStateful(vault);\n        VaultAccount memory vaultAccount = VaultAccountLib.getVaultAccount(account, vaultConfig);\n        \n        // Require that the account settled, otherwise we may leave the account in an unintended\n        // state in this method because we allow it to skip the min borrow check in the next line.\n        (bool didSettle, bool didTransfer) = vaultAccount.settleVaultAccount(vaultConfig);\n        require(didSettle, \"No Settle\");\n\n        vaultAccount.accruePrimeCashFeesToDebt(vaultConfig);\n\n        // Skip Min Borrow Check so that accounts can always be settled\n        vaultAccount.setVaultAccount({vaultConfig: vaultConfig, checkMinBorrow: false});\n\n        if (didTransfer) {\n            // If the vault did a transfer (i.e. withdrew cash) we have to check their collateral ratio. There\n            // is an edge condition where a vault with secondary borrows has an emergency exit. During that process\n            // an account will be left some cash balance in both currencies. It may have excess cash in one and\n            // insufficient cash in the other. A withdraw of the excess in one side will cause the vault account to\n            // be insolvent if we do not run this check. If this scenario indeed does occur, the vault itself must\n            // be upgraded in order to facilitate orderly exits for all of the accounts since they will be prevented\n            // from settling.\n            IVaultAccountHealth(address(this)).checkVaultAccountCollateralRatio(vault, account);\n        }\n    }\n\n    /// @notice Borrows a specified amount of fCash in the vault's borrow currency and deposits it\n    /// all plus the depositAmountExternal into the vault to mint strategy tokens.\n    /// @param account the address that will enter the vault\n    /// @param vault the vault to enter\n    /// @param depositAmountExternal some amount of additional collateral in the borrowed currency\n    /// to be transferred to vault\n    /// @param maturity the maturity to borrow at\n    /// @param borrowAmount amount to borrow, for fCash maturities this is the fCash amount. For pCash\n    /// maturities this is the underlying borrowed.\n    /// @param maxBorrowRate maximum interest rate to borrow at, only applies as a slippage limit for\n    /// fCash maturities\n    /// @param vaultData additional data to pass to the vault contract\n    /// @return vaultSharesAdded the total vault shares tokens added to the maturity. Allows enterVault\n    /// to be used by off-chain methods to get an accurate simulation of the strategy tokens minted.\n    function enterVault(\n        address account,\n        address vault,\n        uint256 depositAmountExternal,\n        uint256 maturity,\n        uint256 borrowAmount,\n        uint32 maxBorrowRate,\n        bytes calldata vaultData\n    ) external payable override nonReentrant returns (uint256 vaultSharesAdded) { \n        // Ensure that system level accounts cannot enter vaults\n        requireValidAccount(account);\n        require(account != vault);\n\n        VaultConfig memory vaultConfig = VaultConfiguration.getVaultConfigStateful(vault);\n        vaultConfig.authorizeCaller(account, VaultConfiguration.ONLY_VAULT_ENTRY);\n\n        // If the vault allows further re-entrancy then set the status back to the default\n        if (vaultConfig.getFlag(VaultConfiguration.ALLOW_REENTRANCY)) {\n            reentrancyStatus = _NOT_ENTERED;\n        }\n\n        // Vaults cannot be entered if they are paused or matured\n        require(vaultConfig.getFlag(VaultConfiguration.ENABLED));\n        require(block.timestamp < maturity);\n\n        VaultAccount memory vaultAccount = VaultAccountLib.getVaultAccount(account, vaultConfig);\n        vaultAccount.settleAccountOrAccruePrimeCashFees(vaultConfig);\n\n        // Accounts can only call enter vault when establishing a new account or increasing an existing\n        // position. Accounts that have matured fCash positions can increase their prime cash position.\n        require(vaultAccount.maturity == 0 || vaultAccount.maturity == maturity); // dev: cannot enter with matured position\n\n        // Deposits some amount of tokens into as margin for the vault. The tokens are first transferred into Notional\n        // and then withdrawn as prime cash when entering the vault\n        vaultConfig.depositMarginForVault(vaultAccount, depositAmountExternal);\n\n        vaultSharesAdded = vaultAccount.borrowAndEnterVault(\n            vaultConfig, maturity, borrowAmount, maxBorrowRate, vaultData, 0\n        );\n\n        IVaultAccountHealth(address(this)).checkVaultAccountCollateralRatio(vault, account);\n    }\n\n    /// @notice Re-enters the vault at a different maturity. The account's existing borrow position will be closed\n    /// and a new borrow position at the specified maturity will be opened. Strategy token holdings will transfer\n    /// to the new maturity. Accounts can roll to longer or shorter dated maturities.\n    /// @param account the address that will reenter the vault\n    /// @param vault the vault to reenter\n    /// @param newBorrowAmount amount of fCash to borrow in the next maturity\n    /// @param maturity new maturity to borrow at\n    /// @param depositAmountExternal amount to deposit into the new maturity\n    /// @param minLendRate slippage protection for repaying debts\n    /// @param maxBorrowRate slippage protection for new borrow position\n    /// @return vaultSharesAdded the total strategy tokens added to the maturity, including any tokens\n    /// rolled from the previous maturity. Allows rollVaultPosition to be used by off-chain methods to get\n    /// an accurate simulation of the strategy tokens minted.\n    function rollVaultPosition(\n        address account,\n        address vault,\n        uint256 newBorrowAmount,\n        uint256 maturity,\n        uint256 depositAmountExternal,\n        uint32 minLendRate,\n        uint32 maxBorrowRate,\n        bytes calldata enterVaultData\n    ) external payable override nonReentrant returns (uint256 vaultSharesAdded) {\n        VaultConfig memory vaultConfig = VaultConfiguration.getVaultConfigStateful(vault);\n        vaultConfig.authorizeCaller(account, VaultConfiguration.ONLY_VAULT_ROLL);\n\n        // If the vault allows further re-entrancy then set the status back to the default\n        if (vaultConfig.getFlag(VaultConfiguration.ALLOW_REENTRANCY)) {\n            reentrancyStatus = _NOT_ENTERED;\n        }\n\n        // If the vault account has matured, this will return a vault account in the prime cash\n        // maturity. The vault account may have some temporary cash balance that will be applied\n        // to lending or borrowing.\n        VaultAccount memory vaultAccount = VaultAccountLib.getVaultAccount(account, vaultConfig);\n        vaultAccount.settleAccountOrAccruePrimeCashFees(vaultConfig);\n\n        // Cannot roll unless all of these requirements are met\n        require(vaultConfig.getFlag(VaultConfiguration.ENABLED));\n        require(vaultConfig.getFlag(VaultConfiguration.ALLOW_ROLL_POSITION));\n        // Must borrow into the new maturity, otherwise account should exit\n        require(newBorrowAmount > 0);\n        // Cannot roll into the existing maturity, after settlement this will be the prime cash maturity\n        require(vaultAccount.maturity != maturity);\n\n        // VaultState must be loa"
    }
  ]
}