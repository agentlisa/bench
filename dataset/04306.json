{
  "Title": "[M04] Financial contract registration with repeated parties might lead to inconsistent behaviors",
  "Content": "The [`registerContract` function](https://github.com/UMAprotocol/protocol/blob/9d403ddb5f2f07194daefe7da51e0e0a6306f2c4/core/contracts/oracle/implementation/Registry.sol#L80) of the `Registry` contract takes an array `parties` containing a list of addresses. However, the function never validates whether the passed array contains the same party address multiple times. This means that the [`for` loop in lines 96 to 100](https://github.com/UMAprotocol/protocol/blob/9d403ddb5f2f07194daefe7da51e0e0a6306f2c4/core/contracts/oracle/implementation/Registry.sol#L96-L100) can register the same contract address multiple times for a party in its corresponding `partyMap[parties[i]].contracts` array (see [line 97](https://github.com/UMAprotocol/protocol/blob/9d403ddb5f2f07194daefe7da51e0e0a6306f2c4/core/contracts/oracle/implementation/Registry.sol#L97)), though only registering the index of the *last* added contract address in the `partyMap[parties[i]].contractIndex` mapping (see [line 99](https://github.com/UMAprotocol/protocol/blob/9d403ddb5f2f07194daefe7da51e0e0a6306f2c4/core/contracts/oracle/implementation/Registry.sol#L99)).\n\n\nThe described behavior can be leveraged to take the `Registry` contract to an inconsistent state, where if multiple repeated parties appear in financial contracts, it may become impossible to fully remove a registered party. Refer to [this unit test](https://gist.github.com/tinchoabbate/1a2120e37b141f63d9e6e3ce9cde23ff) for a step-by-step reproduction of the issue. Note that in the showcased example, the `Register` contract [ends up in an inconsistent state](https://gist.github.com/tinchoabbate/1a2120e37b141f63d9e6e3ce9cde23ff#file-registry-js-L49-L63) where:\n\n\n1. When querying the registered contracts for a party, a contract `contract1` appears as registered.\n2. When querying the `isPartyMemberOfContract` for the same party and contract `contract1`, the party *does not* appear as a member of the contract.\n3. When trying to remove the party from the contract, the transaction is reverted, even if the party has that contract registered as shown in (1).\n\n\nFinancial contract registration in the `Registry` is restricted to known accounts with the `ContractCreator` role, so it would not be possible for everyone to leverage the described behavior maliciously. Nevertheless, the systemâ€™s behavior might be affected if repeated parties are registered accidentally.\n\n\nConsider replacing the body of the loop with a call to the [`addPartyToContract` function](https://github.com/UMAprotocol/protocol/blob/9d403ddb5f2f07194daefe7da51e0e0a6306f2c4/core/contracts/oracle/implementation/Registry.sol#L112). This would perform the consistency checks and avoid duplicating logic across the `registerContract` and `addPartyToContract` functions. It would also ensure the `PartyAdded` event is emitted for the initial parties as well. Afterwards, related unit tests should be added to ensure the system behaves as intended.\n\n\n**Update**: *Fixed in [PR#1194](https://github.com/UMAprotocol/protocol/pull/1194). An internal `_addPartyToContract` function has been added, which is called when a contract is registered and when a new party is added to an existing contract. Related unit tests have been added as well.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "core/contracts/oracle/implementation/Registry.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../common/implementation/MultiRole.sol\";\nimport \"../interfaces/RegistryInterface.sol\";\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n\n/**\n * @title Registry for financial contracts and approved financial contract creators.\n * @dev Maintains a whitelist of financial contract creators that are allowed\n * to register new financial contracts and stores party members of a financial contract.\n */\ncontract Registry is RegistryInterface, MultiRole {\n    using SafeMath for uint;\n\n    /****************************************\n     *    INTERNAL VARIABLES AND STORAGE    *\n     ****************************************/\n\n    enum Roles {\n        Owner, // The owner manages the set of ContractCreators.\n        ContractCreator // Can register financial contracts.\n    }\n\n    // This enum is required because a WasValid state is required to ensure that financial contracts cannot be re-registered.\n    enum Validity { Invalid, Valid }\n\n    // Local information about a contract.\n    struct FinancialContract {\n        Validity valid;\n        uint128 index;\n    }\n\n    struct Party {\n        address[] contracts; // Each financial contract address is stored in this array.\n        // The index of each financial contract is mapped to it's address for constant time look up and deletion.\n        mapping(address => uint) contractIndex;\n    }\n\n    // Array of all contracts that are approved to use the UMA Oracle.\n    address[] public registeredContracts;\n\n    // Map of financial contract contracts to the associated FinancialContract struct.\n    mapping(address => FinancialContract) public contractMap;\n\n    // Map each party member to their associated FinancialContract struct.\n    mapping(address => Party) private partyMap;\n\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n\n    event NewContractRegistered(address indexed contractAddress, address indexed creator, address[] parties);\n    event PartyAdded(address indexed contractAddress, address indexed party);\n    event PartyRemoved(address indexed contractAddress, address indexed party);\n\n    /**\n     * @notice Construct the Registry contract.\n     */\n    constructor() public {\n        _createExclusiveRole(uint(Roles.Owner), uint(Roles.Owner), msg.sender);\n        // Start with no contract creators registered.\n        _createSharedRole(uint(Roles.ContractCreator), uint(Roles.Owner), new address[](0));\n    }\n\n    /****************************************\n     *        REGISTRATION FUNCTIONS        *\n     ****************************************/\n\n    /**\n     * @notice Registers a new financial contract.\n     * @dev Only authorized contract creators can call this method.\n     * @param parties an array of addresses who become parties in the contract.\n     * @param contractAddress defines the address of the deployed finan.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function registerContract(address[] calldata parties, address contractAddress)\n        external\n        override\n        onlyRoleHolder(uint(Roles.ContractCreator))\n    {\n        FinancialContract storage financialContract = contractMap[contractAddress];\n        require(contractMap[contractAddress].valid == Validity.Invalid, \"Can only register once\");\n\n        // Store contract address as a registered contract.\n        registeredContracts.push(contractAddress);\n\n        // No length check necessary because we should never hit (2^127 - 1) contracts.\n        financialContract.index = uint128(registeredContracts.length.sub(1));\n\n        // For all parties in the array add them to the contract's parties.\n        financialContract.valid = Validity.Valid;\n        for (uint i = 0; i < parties.length; i = i.add(1)) {\n            partyMap[parties[i]].contracts.push(contractAddress);\n            uint newLength = partyMap[parties[i]].contracts.length;\n            partyMap[parties[i]].contractIndex[contractAddress] = newLength - 1;\n        }\n\n        emit NewContractRegistered(contractAddress, msg.sender, parties);\n    }\n\n    /**\n     * @notice Adds a party member to the calling contract.\n     * @dev msg.sender will be used to determine the contract that this party is added to.\n     * @param party new party for the calling contract.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function addPartyToContract(address party) external override {\n        address contractAddress = msg.sender;\n\n        require(contractMap[contractAddress].valid == Validity.Valid, \"Can only add to valid contract\");\n        require(!isPartyMemberOfContract(party, contractAddress), \"Can only register a party once\");\n\n        // Push the contract address and store the index.\n        uint contractIndex = partyMap[party].contracts.length;\n        partyMap[party].contracts.push(contractAddress);\n        partyMap[party].contractIndex[contractAddress] = contractIndex;\n\n        emit PartyAdded(contractAddress, party);\n    }\n\n    /**\n     * @notice Removes a party member to the calling contract.\n     * @dev msg.sender will be used to determine the contract that this party is removed from.\n     * @param partyAddress address to be removed from the calling contract.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function removePartyFromContract(address partyAddress) external override {\n        address contractAddress = msg.sender;\n        Party storage party = partyMap[partyAddress];\n        uint256 numberOfContracts = party.contracts.length;\n\n        require(numberOfContracts != 0, \"Can't remove if party has no contracts\");\n        require(contractMap[contractAddress].valid == Validity.Valid, \"Remove only from valid contract\");\n        require(isPartyMemberOfContract(partyAddress, contractAddress), \"Can only remove an existing party\");\n\n        // Index of the current location of the contract to remove.\n        uint deleteIndex = party.contractIndex[contractAddress];\n\n        // Store the last contract's address to update the lookup map.\n        address lastContractAddress = party.contracts[numberOfContracts - 1];\n\n        // Swap the contract to be removed with the last contract.\n        party.contracts[deleteIndex] = lastContractAddress;\n\n        // Update the lookup index with the new location.\n        party.contractIndex[lastContractAddress] = deleteIndex;\n\n        // Pop the last contract from the array and update the lookup map.\n        party.contracts.pop();\n        delete party.contractIndex[contractAddress];\n\n        emit PartyRemoved(contractAddress, partyAddress);\n    }\n\n    /****************************************\n     *         REGISTRY STATE GETTERS       *\n     ****************************************/\n\n    /**\n     * @notice Returns whether the contract has been registered with the registry.\n     * @dev If it is registered, it is an authorized participant in the UMA system.\n     * @param contractAddress address of the financial contract.\n     * @return bool indicates whether the contract is registered.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function isContractRegistered(address contractAddress) external override view returns (bool) {\n        return contractMap[contractAddress].valid == Validity.Valid;\n    }\n\n    /**\n     * @notice Returns a list of all contracts that are associated with a particular party.\n     * @param party address of the party.\n     * @return an array of the contracts the party is registered to.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function getRegisteredContracts(address party) external override view returns (address[] memory) {\n        return partyMap[party].contracts;\n    }\n\n    /**\n     * @notice Returns all registered contracts.\n     * @return all registered contract addresses within the system.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function getAllRegisteredContracts() external override view returns (address[] memory) {\n        return registeredContracts;\n    }\n\n    /**\n     * @notice checks if an address is a party of a contract.\n     * @param party party to check.\n     * @param contractAddress address to check against the party.\n     * @return bool indicating if the address is a party of the contract.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function isPartyMemberOfContract(address party, address contractAddress) public override view returns (bool) {\n        uint index = partyMap[party].contractIndex[contractAddress];\n        return partyMap[party].contracts.length > index && partyMap[party].contracts[index] == contractAddress;\n    }\n}"
    },
    {
      "filename": "core/contracts/oracle/implementation/Registry.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../common/implementation/MultiRole.sol\";\nimport \"../interfaces/RegistryInterface.sol\";\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n\n/**\n * @title Registry for financial contracts and approved financial contract creators.\n * @dev Maintains a whitelist of financial contract creators that are allowed\n * to register new financial contracts and stores party members of a financial contract.\n */\ncontract Registry is RegistryInterface, MultiRole {\n    using SafeMath for uint;\n\n    /****************************************\n     *    INTERNAL VARIABLES AND STORAGE    *\n     ****************************************/\n\n    enum Roles {\n        Owner, // The owner manages the set of ContractCreators.\n        ContractCreator // Can register financial contracts.\n    }\n\n    // This enum is required because a WasValid state is required to ensure that financial contracts cannot be re-registered.\n    enum Validity { Invalid, Valid }\n\n    // Local information about a contract.\n    struct FinancialContract {\n        Validity valid;\n        uint128 index;\n    }\n\n    struct Party {\n        address[] contracts; // Each financial contract address is stored in this array.\n        // The index of each financial contract is mapped to it's address for constant time look up and deletion.\n        mapping(address => uint) contractIndex;\n    }\n\n    // Array of all contracts that are approved to use the UMA Oracle.\n    address[] public registeredContracts;\n\n    // Map of financial contract contracts to the associated FinancialContract struct.\n    mapping(address => FinancialContract) public contractMap;\n\n    // Map each party member to their associated FinancialContract struct.\n    mapping(address => Party) private partyMap;\n\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n\n    event NewContractRegistered(address indexed contractAddress, address indexed creator, address[] parties);\n    event PartyAdded(address indexed contractAddress, address indexed party);\n    event PartyRemoved(address indexed contractAddress, address indexed party);\n\n    /**\n     * @notice Construct the Registry contract.\n     */\n    constructor() public {\n        _createExclusiveRole(uint(Roles.Owner), uint(Roles.Owner), msg.sender);\n        // Start with no contract creators registered.\n        _createSharedRole(uint(Roles.ContractCreator), uint(Roles.Owner), new address[](0));\n    }\n\n    /****************************************\n     *        REGISTRATION FUNCTIONS        *\n     ****************************************/\n\n    /**\n     * @notice Registers a new financial contract.\n     * @dev Only authorized contract creators can call this method.\n     * @param parties an array of addresses who become parties in the contract.\n     * @param contractAddress defines the address of the deployed finan.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function registerContract(address[] calldata parties, address contractAddress)\n        external\n        override\n        onlyRoleHolder(uint(Roles.ContractCreator))\n    {\n        FinancialContract storage financialContract = contractMap[contractAddress];\n        require(contractMap[contractAddress].valid == Validity.Invalid, \"Can only register once\");\n\n        // Store contract address as a registered contract.\n        registeredContracts.push(contractAddress);\n\n        // No length check necessary because we should never hit (2^127 - 1) contracts.\n        financialContract.index = uint128(registeredContracts.length.sub(1));\n\n        // For all parties in the array add them to the contract's parties.\n        financialContract.valid = Validity.Valid;\n        for (uint i = 0; i < parties.length; i = i.add(1)) {\n            partyMap[parties[i]].contracts.push(contractAddress);\n            uint newLength = partyMap[parties[i]].contracts.length;\n            partyMap[parties[i]].contractIndex[contractAddress] = newLength - 1;\n        }\n\n        emit NewContractRegistered(contractAddress, msg.sender, parties);\n    }\n\n    /**\n     * @notice Adds a party member to the calling contract.\n     * @dev msg.sender will be used to determine the contract that this party is added to.\n     * @param party new party for the calling contract.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function addPartyToContract(address party) external override {\n        address contractAddress = msg.sender;\n\n        require(contractMap[contractAddress].valid == Validity.Valid, \"Can only add to valid contract\");\n        require(!isPartyMemberOfContract(party, contractAddress), \"Can only register a party once\");\n\n        // Push the contract address and store the index.\n        uint contractIndex = partyMap[party].contracts.length;\n        partyMap[party].contracts.push(contractAddress);\n        partyMap[party].contractIndex[contractAddress] = contractIndex;\n\n        emit PartyAdded(contractAddress, party);\n    }\n\n    /**\n     * @notice Removes a party member to the calling contract.\n     * @dev msg.sender will be used to determine the contract that this party is removed from.\n     * @param partyAddress address to be removed from the calling contract.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function removePartyFromContract(address partyAddress) external override {\n        address contractAddress = msg.sender;\n        Party storage party = partyMap[partyAddress];\n        uint256 numberOfContracts = party.contracts.length;\n\n        require(numberOfContracts != 0, \"Can't remove if party has no contracts\");\n        require(contractMap[contractAddress].valid == Validity.Valid, \"Remove only from valid contract\");\n        require(isPartyMemberOfContract(partyAddress, contractAddress), \"Can only remove an existing party\");\n\n        // Index of the current location of the contract to remove.\n        uint deleteIndex = party.contractIndex[contractAddress];\n\n        // Store the last contract's address to update the lookup map.\n        address lastContractAddress = party.contracts[numberOfContracts - 1];\n\n        // Swap the contract to be removed with the last contract.\n        party.contracts[deleteIndex] = lastContractAddress;\n\n        // Update the lookup index with the new location.\n        party.contractIndex[lastContractAddress] = deleteIndex;\n\n        // Pop the last contract from the array and update the lookup map.\n        party.contracts.pop();\n        delete party.contractIndex[contractAddress];\n\n        emit PartyRemoved(contractAddress, partyAddress);\n    }\n\n    /****************************************\n     *         REGISTRY STATE GETTERS       *\n     ****************************************/\n\n    /**\n     * @notice Returns whether the contract has been registered with the registry.\n     * @dev If it is registered, it is an authorized participant in the UMA system.\n     * @param contractAddress address of the financial contract.\n     * @return bool indicates whether the contract is registered.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function isContractRegistered(address contractAddress) external override view returns (bool) {\n        return contractMap[contractAddress].valid == Validity.Valid;\n    }\n\n    /**\n     * @notice Returns a list of all contracts that are associated with a particular party.\n     * @param party address of the party.\n     * @return an array of the contracts the party is registered to.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function getRegisteredContracts(address party) external override view returns (address[] memory) {\n        return partyMap[party].contracts;\n    }\n\n    /**\n     * @notice Returns all registered contracts.\n     * @return all registered contract addresses within the system.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function getAllRegisteredContracts() external override view returns (address[] memory) {\n        return registeredContracts;\n    }\n\n    /**\n     * @notice checks if an address is a party of a contract.\n     * @param party party to check.\n     * @param contractAddress address to check against the party.\n     * @return bool indicating if the address is a party of the contract.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function isPartyMemberOfContract(address party, address contractAddress) public override view returns (bool) {\n        uint index = partyMap[party].contractIndex[contractAddress];\n        return partyMap[party].contracts.length > index && partyMap[party].contracts[index] == contractAddress;\n    }\n}"
    }
  ]
}