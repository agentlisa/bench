{
  "Title": "[L-01] `computePhase0Eth1DataRoot` always returns an incorrect Merkle tree",
  "Content": "\nThe Merkle tree creation inside the `computePhase0Eth1DataRoot` function is incorrect.\n\n### Proof of Concept\n\nProvide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept. Not all fields of `eth1DataFields` are being used in an array due to the usage of `i < ETH1_DATA_FIELD_TREE_HEIGHT` instead of `i<NUM_ETH1_DATA_FIELDS`. Check other similar functions.\n\n[src/contracts/libraries/BeaconChainProofs.sol#L160](https://github.com/Layr-Labs/eigenlayer-contracts/blob/eccdfd43bb882d66a68cad8875dde2979e204546/src/contracts/libraries/BeaconChainProofs.sol#L160)\n\n```solidity\n    function computePhase0Eth1DataRoot(bytes32[NUM_ETH1_DATA_FIELDS] calldata eth1DataFields) internal pure returns(bytes32) {  \n        bytes32[] memory paddedEth1DataFields = new bytes32[](2**ETH1_DATA_FIELD_TREE_HEIGHT);\n        \n        for (uint256 i = 0; i < ETH1_DATA_FIELD_TREE_HEIGHT; ++i) {\n            paddedEth1DataFields[i] = eth1DataFields[i];\n        }\n\n        return Merkle.merkleizeSha256(paddedEth1DataFields);\n    }\n\n```\n\n### Recommended Mitigation Steps\n\n```diff\n    function computePhase0Eth1DataRoot(bytes32[NUM_ETH1_DATA_FIELDS] calldata eth1DataFields) internal pure returns(bytes32) {  \n        bytes32[] memory paddedEth1DataFields = new bytes32[](2**ETH1_DATA_FIELD_TREE_HEIGHT);\n        \n_        for (uint256 i = 0; i < ETH1_DATA_FIELD_TREE_HEIGHT; ++i) {\n+        for (uint256 i = 0; i < NUM_ETH1_DATA_FIELDS; ++i) {\n           paddedEth1DataFields[i] = eth1DataFields[i];\n        }\n\n        return Merkle.merkleizeSha256(paddedEth1DataFields);\n    }\n\n```\n\n### Assessed type\n\nMath\n\n**[Sidu28 (EigenLayer) disagreed with severity and commented](https://github.com/code-423n4/2023-04-eigenlayer-findings/issues/63#issuecomment-1545172210):**\n > We believe this is low severity. The code is unused and informally deprecated, but it is indeed technically incorrect.\n\n**[Alex the Entreprenerd (judge) decreased severity to QA and commented](https://github.com/code-423n4/2023-04-eigenlayer-findings/issues/63#issuecomment-1567105145):**\n > Agree with the Sponsor, because the code is unused.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-04-eigenlayer-findings/issues/63#issuecomment-1582482224):**\n>Consistently high quality submissions. After grading the QAs I believe the Warden deserves the best place.\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-04-eigenlayer",
  "Code": [
    {
      "filename": "src/contracts/libraries/BeaconChainProofs.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity =0.8.12;\n\nimport \"./Merkle.sol\";\nimport \"../libraries/Endian.sol\";\n\n//Utility library for parsing and PHASE0 beacon chain block headers\n//SSZ Spec: https://github.com/ethereum/consensus-specs/blob/dev/ssz/simple-serialize.md#merkleization\n//BeaconBlockHeader Spec: https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#beaconblockheader\n//BeaconState Spec: https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#beaconstate\nlibrary BeaconChainProofs {\n    // constants are the number of fields and the heights of the different merkle trees used in merkleizing beacon chain containers\n    uint256 internal constant NUM_BEACON_BLOCK_HEADER_FIELDS = 5;\n    uint256 internal constant BEACON_BLOCK_HEADER_FIELD_TREE_HEIGHT = 3;\n\n    uint256 internal constant NUM_BEACON_BLOCK_BODY_FIELDS = 11;\n    uint256 internal constant BEACON_BLOCK_BODY_FIELD_TREE_HEIGHT = 4;\n\n    uint256 internal constant NUM_BEACON_STATE_FIELDS = 21;\n    uint256 internal constant BEACON_STATE_FIELD_TREE_HEIGHT = 5;\n\n    uint256 internal constant NUM_ETH1_DATA_FIELDS = 3;\n    uint256 internal constant ETH1_DATA_FIELD_TREE_HEIGHT = 2;\n\n    uint256 internal constant NUM_VALIDATOR_FIELDS = 8;\n    uint256 internal constant VALIDATOR_FIELD_TREE_HEIGHT = 3;\n\n    uint256 internal constant NUM_EXECUTION_PAYLOAD_HEADER_FIELDS = 15;\n    uint256 internal constant EXECUTION_PAYLOAD_HEADER_FIELD_TREE_HEIGHT = 4;\n\n\n    uint256 internal constant NUM_EXECUTION_PAYLOAD_FIELDS = 15;\n    uint256 internal constant EXECUTION_PAYLOAD_FIELD_TREE_HEIGHT = 4;\n\n\n    // HISTORICAL_ROOTS_LIMIT\t = 2**24, so tree height is 24\n    uint256 internal constant HISTORICAL_ROOTS_TREE_HEIGHT = 24;\n\n    // HISTORICAL_BATCH is root of state_roots and block_root, so number of leaves =  2^1\n    uint256 internal constant HISTORICAL_BATCH_TREE_HEIGHT = 1;\n\n    // SLOTS_PER_HISTORICAL_ROOT = 2**13, so tree height is 13\n    uint256 internal constant STATE_ROOTS_TREE_HEIGHT = 13;\n    uint256 internal constant BLOCK_ROOTS_TREE_HEIGHT = 13;\n\n\n    uint256 internal constant NUM_WITHDRAWAL_FIELDS = 4;\n    // tree height for hash tree of an individual withdrawal container\n    uint256 internal constant WITHDRAWAL_FIELD_TREE_HEIGHT = 2;\n\n    uint256 internal constant VALIDATOR_TREE_HEIGHT = 40;\n    //refer to the eigenlayer-cli proof library.  Despite being the same dimensions as the validator tree, the balance tree is merkleized differently\n    uint256 internal constant BALANCE_TREE_HEIGHT = 38;\n\n    // MAX_WITHDRAWALS_PER_PAYLOAD = 2**4, making tree height = 4\n    uint256 internal constant WITHDRAWALS_TREE_HEIGHT = 4;\n\n    //in beacon block body\n    uint256 internal constant EXECUTION_PAYLOAD_INDEX = 9;\n\n    // in beacon block header\n    uint256 internal constant STATE_ROOT_INDEX = 3;\n    uint256 internal constant PROPOSER_INDEX_INDEX = 1;\n    uint256 internal constant SLOT_INDEX = 0;\n    uint256 internal constant BODY_ROOT_INDEX = 4;\n    // in beacon state\n    uint256 internal constant STATE_ROOTS_INDEX = 6;\n    uint256 internal constant BLOCK_ROOTS_INDEX = 5;\n    uint256 internal constant HISTORICAL_ROOTS_INDEX = 7;\n    uint256 internal constant ETH_1_ROOT_INDEX = 8;\n    uint256 internal constant VALIDATOR_TREE_ROOT_INDEX = 11;\n    uint256 internal constant BALANCE_INDEX = 12;\n    uint256 internal constant EXECUTION_PAYLOAD_HEADER_INDEX = 24;\n    uint256 internal constant HISTORICAL_BATCH_STATE_ROOT_INDEX = 1;\n\n    // in validator\n    uint256 internal constant VALIDATOR_WITHDRAWAL_CREDENTIALS_INDEX = 1;\n    uint256 internal constant VALIDATOR_BALANCE_INDEX = 2;\n    uint256 internal constant VALIDATOR_SLASHED_INDEX = 3;\n    uint256 internal constant VALIDATOR_WITHDRAWABLE_EPOCH_INDEX = 7;\n    \n    // in exection payload header\n    uint256 internal constant BLOCK_NUMBER_INDEX = 6;\n    uint256 internal constant WITHDRAWALS_ROOT_INDEX = 14;\n\n    //in execution payload\n    uint256 internal constant WITHDRAWALS_INDEX = 14;\n\n    // in withdrawal\n    uint256 internal constant WITHDRAWAL_VALIDATOR_INDEX_INDEX = 1;\n    uint256 internal constant WITHDRAWAL_VALIDATOR_AMOUNT_INDEX = 3;\n\n    //In historicalBatch\n    uint256 internal constant HISTORICALBATCH_STATEROOTS_INDEX = 1;\n\n    //Misc Constants\n    uint256 internal constant SLOTS_PER_EPOCH = 32;\n\n    bytes8 internal constant UINT64_MASK = 0xffffffffffffffff;\n\n\n\n    struct WithdrawalProofs {\n        bytes blockHeaderProof;\n        bytes withdrawalProof;\n        bytes slotProof;\n        bytes executionPayloadProof;\n        bytes blockNumberProof;\n        uint64 blockHeaderRootIndex;\n        uint64 withdrawalIndex;\n        bytes32 blockHeaderRoot;\n        bytes32 blockBodyRoot;\n        bytes32 slotRoot;\n        bytes32 blockNumberRoot;\n        bytes32 executionPayloadRoot;\n    }\n\n    struct ValidatorFieldsAndBalanceProofs {\n        bytes validatorFieldsProof;\n        bytes validatorBalanceProof;\n        bytes32 balanceRoot;\n    }\n\n    struct ValidatorFieldsProof {\n        bytes validatorProof;\n        uint40 validatorIndex;\n    }\n\n    function computePhase0BeaconBlockHeaderRoot(bytes32[NUM_BEACON_BLOCK_HEADER_FIELDS] calldata blockHeaderFields) internal pure returns(bytes32) {\n        bytes32[] memory paddedHeaderFields = new bytes32[](2**BEACON_BLOCK_HEADER_FIELD_TREE_HEIGHT);\n        \n        for (uint256 i = 0; i < NUM_BEACON_BLOCK_HEADER_FIELDS; ++i) {\n            paddedHeaderFields[i] = blockHeaderFields[i];\n        }\n\n        return Merkle.merkleizeSha256(paddedHeaderFields);\n    }\n\n    function computePhase0BeaconStateRoot(bytes32[NUM_BEACON_STATE_FIELDS] calldata beaconStateFields) internal pure returns(bytes32) {\n        bytes32[] memory paddedBeaconStateFields = new bytes32[](2**BEACON_STATE_FIELD_TREE_HEIGHT);\n        \n        for (uint256 i = 0; i < NUM_BEACON_STATE_FIELDS; ++i) {\n            paddedBeaconStateFields[i] = beaconStateFields[i];\n        }\n        \n        return Merkle.merkleizeSha256(paddedBeaconStateFields);\n    }\n\n    function computePhase0ValidatorRoot(bytes32[NUM_VALIDATOR_FIELDS] calldata validatorFields) internal pure returns(bytes32) {  \n        bytes32[] memory paddedValidatorFields = new bytes32[](2**VALIDATOR_FIELD_TREE_HEIGHT);\n        \n        for (uint256 i = 0; i < NUM_VALIDATOR_FIELDS; ++i) {\n            paddedValidatorFields[i] = validatorFields[i];\n        }\n\n        return Merkle.merkleizeSha256(paddedValidatorFields);\n    }\n\n    function computePhase0Eth1DataRoot(bytes32[NUM_ETH1_DATA_FIELDS] calldata eth1DataFields) internal pure returns(bytes32) {  \n        bytes32[] memory paddedEth1DataFields = new bytes32[](2**ETH1_DATA_FIELD_TREE_HEIGHT);\n        \n        for (uint256 i = 0; i < ETH1_DATA_FIELD_TREE_HEIGHT; ++i) {\n            paddedEth1DataFields[i] = eth1DataFields[i];\n        }\n\n        return Merkle.merkleizeSha256(paddedEth1DataFields);\n    }\n\n    /**\n     * \n     * @notice This function is parses the balanceRoot to get the uint64 balance of a validator.  During merkleization of the\n     * beacon state balance tree, four uint64 values (making 32 bytes) are grouped together and treated as a single leaf in the merkle tree. Thus the\n     * validatorIndex mod 4 is used to determine which of the four uint64 values to extract from the balanceRoot.\n     * @param validatorIndex is the index of the validator being proven for.\n     * @param balanceRoot is the combination of 4 validator balances being proven for.\n     */\n   function getBalanceFromBalanceRoot(uint40 validatorIndex, bytes32 balanceRoot) internal pure returns (uint64) {\n        uint256 bitShiftAmount = (validatorIndex % 4) * 64;\n        bytes32 validatorBalanceLittleEndian = bytes32((uint256(balanceRoot) << bitShiftAmount));\n        uint64 validatorBalance = Endian.fromLittleEndianUint64(validatorBalanceLittleEndian);\n        return validatorBalance;\n    }\n\n    /**\n     * @notice This function verifies merkle proofs of the fields of a certain validator against a beacon chain state root\n     * @param validatorIndex the index of the proven validator\n     * @param beaconStateRoot is the beacon chain state root to be proven against.\n     * @param proof is the data used in proving the validator's fields\n     * @param validatorFields the claimed fields of the validator\n     */\n    function verifyValidatorFields(\n        uint40 validatorIndex,\n        bytes32 beaconStateRoot,\n        bytes calldata proof, \n        bytes32[] calldata validatorFields\n    ) internal view {\n        \n        require(validatorFields.length == 2**VALIDATOR_FIELD_TREE_HEIGHT, \"BeaconChainProofs.verifyValidatorFields: Validator fields has incorrect length\");\n\n        /**\n         * Note: the length of the validator merkle proof is BeaconChainProofs.VALIDATOR_TREE_HEIGHT + 1.\n         * There is an additional layer added by hashing the root with the length of the validator list\n         */\n        require(proof.length == 32 * ((VALIDATOR_TREE_HEIGHT + 1) + BEACON_STATE_FIELD_TREE_HEIGHT), \"BeaconChainProofs.verifyValidatorFields: Proof has incorrect length\");\n        uint256 index = (VALIDATOR_TREE_ROOT_INDEX << (VALIDATOR_TREE_HEIGHT + 1)) | uint256(validatorIndex);\n        // merkleize the validatorFields to get the leaf to prove\n        bytes32 validatorRoot = Merkle.merkleizeSha256(validatorFields);\n\n        // verify the proof of the validatorRoot against the beaconStateRoot\n        require(Merkle.verifyInclusionSha256(proof, beaconStateRoot, validatorRoot, index), \"BeaconChainProofs.verifyValidatorFields: Invalid merkle proof\");\n    }\n\n    /**\n     * @notice This function verifies merkle proofs of the balance of a certain validator against a beacon chain state root\n     * @param validatorIndex the index of the proven validator\n     * @param beaconStateRoot is the beacon chain state root to be proven against.\n     * @param proof is the proof of the balance against the beacon chain state root\n     * @param balanceRoot is the serialized balance used to prove the balance of the validator (refer to `getBalanceFromBalanceRoot` above for detailed explanation)\n     */\n    function verifyValidatorBalance(\n        uint40 validatorIndex,\n        bytes32 beaconStateRoot,\n        bytes calldata proof,\n        bytes32 balanceRoot\n    ) internal view {\n        require(proof.length == 32 * ((BALANCE_TREE_HEIGHT + 1) + BEACON_STATE_FIELD_TREE_HEIGHT), \"BeaconChainProofs.verifyValidatorBalance: Proof has incorrect length\");\n\n        /**\n        * the beacon state's balance list is a list of uint64 values, and these are grouped together in 4s when merkleized.  \n        * Therefore, the index of the balance of a validator is validatorIndex/4\n        */\n        uint256 balanceIndex = uint256(validatorIndex/4);\n        balanceIndex = (BALANCE_INDEX << (BALANCE_TREE_HEIGHT + 1)) | balanceIndex;\n\n        require(Merkle.verifyInclusionSha256(proof, beaconStateRoot, balanceRoot, balanceIndex), \"BeaconChainProofs.verifyValidatorBalance: Invalid merkle proof\");\n    }\n\n    /**\n     * @notice This function verifies the slot and the withdrawal fields for a given withdrawal\n     * @param beaconStateRoot is the beacon chain state root to be proven against.\n     * @param proofs is the provided set of merkle proofs\n     * @param withdrawalFields is the serialized withdrawal container to be proven\n     */\n    function verifyWithdrawalProofs(\n        bytes32 beaconStateRoot,\n        WithdrawalProofs calldata proofs,\n        bytes32[] calldata withdrawalFields\n    ) internal view {\n        require(withdrawalFields.length == 2**WITHDRAWAL_FIELD_TREE_HEIGHT, \"BeaconChainProofs.verifyWithdrawalProofs: withdrawalFields has incorrect length\");\n\n        require(proofs.blockHeaderRootIndex < 2**BLOCK_ROOTS_TREE_HEIGHT, \"BeaconChainProofs.verifyWithdrawalProofs: blockRootIndex is too large\");\n        require(proofs.withdrawalIndex < 2**WITHDRAWALS_TREE_HEIGHT, \"BeaconChainProofs.verifyWithdrawalProofs: withdrawalIndex is too large\");\n       \n        // verify the block header proof length\n        require(proofs.blockHeaderProof.length == 32 * (BEACON_STATE_FIELD_TREE_HEIGHT + BLOCK_ROOTS_TREE_HEIGHT),\n            \"BeaconChainProofs.verifyWithdrawalProofs: blockHeaderProof has incorrect length\");\n        require(proofs.withdrawalProof.length == 32 * (EXECUTION_PAYLOAD_HEADER_FIELD_TREE_HEIGHT + WITHDRAWALS_TREE_HEIGHT + 1),\n            \"BeaconChainProofs.verifyWithdrawalProofs: withdrawalProof has incorrect length\");\n        require(proofs.executionPayloadProof.length == 32 * (BEACON_BLOCK_HEADER_FIELD_TREE_HEIGHT + BEACON_BLOCK_BODY_FIELD_TREE_HEIGHT),\n            \"BeaconChainProofs.verifyWithdrawalProofs: executionPayloadProof has incorrect length\");\n\n        /**\n         * Computes the block_header_index relative to the beaconStateRoot.  It concatenates the indexes of all the\n         * intermediate root indexes from the bottom of the sub trees (the block header container) to the top of the tree\n         */\n        uint256 blockHeaderIndex = BLOCK_ROOTS_INDEX << (BLOCK_ROOTS_TREE_HEIGHT)  | uint256(proofs.blockHeaderRootIndex);\n        // Verify the blockHeaderRoot against the beaconStateRoot\n        require(Merkle.verifyInclusionSha256(proofs.blockHeaderProof, beaconStateRoot, proofs.blockHeaderRoot, blockHeaderIndex),\n            \"BeaconChainProofs.verifyWithdrawalProofs: Invalid block header merkle proof\");\n\n        //Next we verify the slot against the blockHeaderRoot\n        require(Merkle.verifyInclusionSha256(proofs.slotProof, proofs.blockHeaderRoot, proofs.slotRoot, SLOT_INDEX), \"BeaconChainProofs.verifyWithdrawalProofs: Invalid slot merkle proof\");\n\n        // Next we verify the executionPayloadRoot against the blockHeaderRoot\n        uint256 executionPayloadIndex = BODY_ROOT_INDEX << (BEACON_BLOCK_BODY_FIELD_TREE_HEIGHT)| EXECUTION_PAYLOAD_INDEX ;\n        require(Merkle.verifyInclusionSha256(proofs.executionPayloadProof, proofs.blockHeaderRoot, proofs.executionPayloadRoot, executionPayloadIndex),\n            \"BeaconChainProofs.verifyWithdrawalProofs: Invalid executionPayload merkle proof\");\n\n        // Next we verify the blockNumberRoot against the executionPayload root\n        require(Merkle.verifyInclusionSha256(proofs.blockNumberProof, proofs.executionPayloadRoot, proofs.blockNumberRoot, BLOCK_NUMBER_INDEX),\n            \"BeaconChainProofs.verifyWithdrawalProofs: Invalid blockNumber merkle proof\");\n\n        /**\n         * Next we verify the withdrawal fields against the blockHeaderRoot:\n         * First we compute the withdrawal_index relative to the blockHeaderRoot by concatenating the indexes of all the \n         * intermediate root indexes from the bottom of the sub trees (the withdrawal container) to the top, the blockHeaderRoot.\n         * Then we calculate merkleize the withdrawalFields container to calculate the the withdrawalRoot.\n         * Finally we verify the withdrawalRoot against the executionPayloadRoot.\n         */\n        uint256 withdrawalIndex = WITHDRAWALS_INDEX << (WITHDRAWALS_TREE_HEIGHT + 1) | uint256(proofs.withdrawalIndex);\n        bytes32 withdrawalRoot = Merkle.merkleizeSha256(withdrawalFields);\n        require(Merkle.verifyInclusionSha256(proofs.withdrawalProof, proofs.executionPayloadRoot, withdrawalRoot, withdrawalIndex),\n            \"BeaconChainProofs.verifyWithdrawalProofs: Invalid withdrawal merkle proof\");\n    }\n\n}"
    }
  ]
}