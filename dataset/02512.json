{
  "Title": "M-9: [M] Incorrect Validation in `Pool.sol#transferLPs` lead to a DOS attack",
  "Content": "# Issue M-9: [M] Incorrect Validation in `Pool.sol#transferLPs` lead to a DOS attack \n\nSource: https://github.com/sherlock-audit/2023-01-ajna-judging/issues/116 \n\n## Found by \noxcm\n\n## Summary\n\nThe code in the transferLPs function has an incorrect validation check, where it requires `allowances_` to be strictly equal to `lenderLpBalance`, instead of just `allowances_` being greater than `transferAmount`.\n\n## Vulnerability Detail\n\nIn the `transferLPs()` function, `transferAmount` is being compared to `allowances_[owner_][newOwner_][index]` and `lenderLpBalance`. If the values are not strictly equal, the function will revert with a `NoAllowance` error. \n\nDue to the requirement of `transferLPs()` that `allowances_` must equal `lenderLpBalance`, the user can only enter `lpsAmountToApprove_` as the current `lenderLpBalance` when using `approveLpOwnership()`.\n\nThis results in `transferLPs()` reverting with `NoAllowance` if `lenderLpBalance` undergoes any change, allowing attackers to design a DOS attack.\n\nHowever, this validation is not necessary as it should only require `allowances_` to be greater than `transferAmount`.\n\n## Impact\n\nAn attacker could exploit this vulnerability by transferring a small amount of LP tokens to the owner before the transfer to the new owner is initiated. This would cause the `allowances_` value to be less than `lenderLpBalance`, causing the transfer to revert and the tokens to remain in the original owner's account.\n\n## Code Snippet\n\nRelevant code snippet from transferLPs function:\n \nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/base/Pool.sol#L238-L250\n\n```solidity=238\nfunction transferLPs(\n        address owner_,\n        address newOwner_,\n        uint256[] calldata indexes_\n    ) external override nonReentrant {\n        LenderActions.transferLPs(\n            buckets,\n            _lpTokenAllowances,\n            owner_,\n            newOwner_,\n            indexes_\n        );\n    }\n```\n\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/external/LenderActions.sol#L512-L558\n\n```solidity=512\nfunction transferLPs(\n        mapping(uint256 => Bucket) storage buckets_,\n        mapping(address => mapping(address => mapping(uint256 => uint256))) storage allowances_,\n        address owner_,\n        address newOwner_,\n        uint256[] calldata indexes_\n    ) external {\n        uint256 indexesLength = indexes_.length;\n\n        uint256 tokensTransferred;\n\n        for (uint256 i = 0; i < indexesLength; ) {\n            uint256 index = indexes_[i];\n            if (index > MAX_FENWICK_INDEX) revert InvalidIndex();\n\n            uint256 transferAmount = allowances_[owner_][newOwner_][index];\n\n            Bucket storage bucket = buckets_[index];\n            Lender storage lender = bucket.lenders[owner_];\n\n            uint256 lenderDepositTime = lender.depositTime;\n\n            uint256 lenderLpBalance;\n\n            if (bucket.bankruptcyTime < lenderDepositTime) lenderLpBalance = lender.lps;\n\n            if (transferAmount == 0 || transferAmount != lenderLpBalance) revert NoAllowance();\n\n            delete allowances_[owner_][newOwner_][index]; // delete allowance\n\n            // move lp tokens to the new owner address\n            Lender storage newLender = bucket.lenders[newOwner_];\n\n            newLender.lps += transferAmount;\n\n            newLender.depositTime = Maths.max(lenderDepositTime, newLender.depositTime);\n\n            // reset owner lp balance for this index\n            delete bucket.lenders[owner_];\n\n            tokensTransferred += transferAmount;\n\n            unchecked { ++i; }\n        }\n\n        emit TransferLPTokens(owner_, newOwner_, indexes_, tokensTransferred);\n    }\n```\n\n## Tool used\n\nManual Review / ChatGPT\n\n## Recommendation\n\nThe validation check in the transferLPs function should be updated to allow for allowances_ to be greater than transferAmount, rather than requiring them to be strictly equal. The updated code would look like this:\n\n```solidity\nif (transferAmount == 0 || allowances_[owner_][newOwner_][index] < transferAmount) revert NoAllowance();\n```\n\nand change  `approveLpOwnership()` to:\n\n```solidity\nfunction approveLpOwnership(\n    address allowedNewOwner_,\n    uint256 index_\n) external nonReentrant {\n    _lpTokenAllowances[msg.sender][allowedNewOwner_][index_] = type(uint256).max;\n}\n```\n\n## Discussion\n\n**grandizzy**\n\nremoving will fix, will be addressed after sherlock contest\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/32",
  "Code": [
    {
      "filename": "contracts/src/base/Pool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport { Clone }           from '@clones/Clone.sol';\nimport { ReentrancyGuard } from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport { Multicall }       from '@openzeppelin/contracts/utils/Multicall.sol';\nimport { SafeERC20 }       from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 }          from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {\n    IPool,\n    IPoolImmutables,\n    IPoolLenderActions,\n    IPoolState,\n    IPoolLiquidationActions,\n    IPoolReserveAuctionActions,\n    IPoolDerivedState,\n    IERC20Token\n}                                    from '../interfaces/pool/IPool.sol';\nimport {\n    PoolState,\n    AuctionsState,\n    DepositsState,\n    LoansState,\n    InflatorState,\n    InterestState,\n    PoolBalancesState,\n    ReserveAuctionState,\n    Bucket,\n    BurnEvent,\n    Liquidation\n}                                    from '../interfaces/pool/commons/IPoolState.sol';\nimport {\n    KickResult,\n    RemoveQuoteParams,\n    MoveQuoteParams,\n    AddQuoteParams\n}                                    from '../interfaces/pool/commons/IPoolInternals.sol';\nimport { StartReserveAuctionParams } from '../interfaces/pool/commons/IPoolReserveAuctionActions.sol';\n\nimport {\n    _priceAt,\n    _roundToScale\n}                               from '../libraries/helpers/PoolHelper.sol';\nimport {\n    _revertIfAuctionDebtLocked,\n    _revertIfAuctionClearable\n}                               from '../libraries/helpers/RevertsHelper.sol';\n\nimport { Buckets }  from '../libraries/internal/Buckets.sol';\nimport { Deposits } from '../libraries/internal/Deposits.sol';\nimport { Loans }    from '../libraries/internal/Loans.sol';\nimport { Maths }    from '../libraries/internal/Maths.sol';\n\nimport { Auctions }        from '../libraries/external/Auctions.sol';\nimport { BorrowerActions } from '../libraries/external/BorrowerActions.sol';\nimport { LenderActions }   from '../libraries/external/LenderActions.sol';\nimport { PoolCommons }     from '../libraries/external/PoolCommons.sol';\n\n/**\n *  @title  Pool Contract\n *  @dev    Base contract and entrypoint for commong logic of both ERC20 and ERC721 pools.\n */\nabstract contract Pool is Clone, ReentrancyGuard, Multicall, IPool {\n\n    using SafeERC20 for IERC20;\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    // immutable args offset\n    uint256 internal constant POOL_TYPE          = 0;\n    uint256 internal constant AJNA_ADDRESS       = 1;\n    uint256 internal constant COLLATERAL_ADDRESS = 21;\n    uint256 internal constant QUOTE_ADDRESS      = 41;\n    uint256 internal constant QUOTE_SCALE        = 61;\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    AuctionsState       internal auctions;\n    DepositsState       internal deposits;\n    LoansState          internal loans;\n    InflatorState       internal inflatorState;\n    InterestState       internal interestState;\n    PoolBalancesState   internal poolBalances;\n    ReserveAuctionState internal reserveAuction;\n\n    mapping(uint256 => Bucket) internal buckets;   // deposit index -> bucket\n\n    bool internal isPoolInitialized;\n\n    mapping(address => mapping(address => mapping(uint256 => uint256))) private _lpTokenAllowances; // owner address -> new owner address -> deposit index -> allowed amount\n\n    /******************/\n    /*** Immutables ***/\n    /******************/\n\n    /// @inheritdoc IPoolImmutables\n    function poolType() external pure override returns (uint8) {\n        return _getArgUint8(POOL_TYPE);\n    }\n\n    /// @inheritdoc IPoolImmutables\n    function collateralAddress() external pure override returns (address) {\n        return _getArgAddress(COLLATERAL_ADDRESS);\n    }\n\n    /// @inheritdoc IPoolImmutables\n    function quoteTokenAddress() external pure override returns (address) {\n        return _getArgAddress(QUOTE_ADDRESS);\n    }\n\n    /// @inheritdoc IPoolImmutables\n    function quoteTokenScale() external pure override returns (uint256) {\n        return _getArgUint256(QUOTE_SCALE);\n    }\n\n    function quoteTokenDust() external pure override returns (uint256) {\n        return _getArgUint256(QUOTE_SCALE);\n    }\n\n\n    /*********************************/\n    /*** Lender External Functions ***/\n    /*********************************/\n\n    /// @inheritdoc IPoolLenderActions\n    function addQuoteToken(\n        uint256 quoteTokenAmountToAdd_,\n        uint256 index_\n    ) external override nonReentrant returns (uint256 bucketLPs_) {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // round to token precision\n        quoteTokenAmountToAdd_ = _roundToScale(quoteTokenAmountToAdd_, poolState.quoteDustLimit);\n\n        uint256 newLup;\n        (bucketLPs_, newLup) = LenderActions.addQuoteToken(\n            buckets,\n            deposits,\n            poolState,\n            AddQuoteParams({\n                amount: quoteTokenAmountToAdd_,\n                index:  index_\n            })\n        );\n\n        // update pool interest rate state\n        _updateInterestState(poolState, newLup);\n\n        // move quote token amount from lender to pool\n        _transferQuoteTokenFrom(msg.sender, quoteTokenAmountToAdd_);\n    }\n\n    /**\n     *  @inheritdoc IPoolLenderActions\n     *  @dev write state:\n     *          - _lpTokenAllowances mapping\n     */\n    function approveLpOwnership(\n        address allowedNewOwner_,\n        uint256 index_,\n        uint256 lpsAmountToApprove_\n    ) external nonReentrant {\n        _lpTokenAllowances[msg.sender][allowedNewOwner_][index_] = lpsAmountToApprove_;\n    }\n\n    /// @inheritdoc IPoolLenderActions\n    function moveQuoteToken(\n        uint256 maxAmountToMove_,\n        uint256 fromIndex_,\n        uint256 toIndex_\n    ) external override nonReentrant returns (uint256 fromBucketLPs_, uint256 toBucketLPs_) {\n        PoolState memory poolState = _accruePoolInterest();\n\n        _revertIfAuctionDebtLocked(deposits, poolBalances, fromIndex_, poolState.inflator);\n\n        uint256 newLup;\n        (\n            fromBucketLPs_,\n            toBucketLPs_,\n            newLup\n        ) = LenderActions.moveQuoteToken(\n            buckets,\n            deposits,\n            poolState,\n            MoveQuoteParams({\n                maxAmountToMove: maxAmountToMove_,\n                fromIndex:       fromIndex_,\n                toIndex:         toIndex_,\n                thresholdPrice:  Loans.getMax(loans).thresholdPrice\n            })\n        );\n\n        // update pool interest rate state\n        _updateInterestState(poolState, newLup);\n    }\n\n    /// @inheritdoc IPoolLenderActions\n    function removeQuoteToken(\n        uint256 maxAmount_,\n        uint256 index_\n    ) external override nonReentrant returns (uint256 removedAmount_, uint256 redeemedLPs_) {\n        _revertIfAuctionClearable(auctions, loans);\n\n        PoolState memory poolState = _accruePoolInterest();\n\n        _revertIfAuctionDebtLocked(deposits, poolBalances, index_, poolState.inflator);\n\n        uint256 newLup;\n        (\n            removedAmount_,\n            redeemedLPs_,\n            newLup\n        ) = LenderActions.removeQuoteToken(\n            buckets,\n            deposits,\n            poolState,\n            RemoveQuoteParams({\n                maxAmount:      maxAmount_,\n                index:          index_,\n                thresholdPrice: Loans.getMax(loans).thresholdPrice\n            })\n        );\n\n        // update pool interest rate state\n        _updateInterestState(poolState, newLup);\n\n        // move quote token amount from pool to lender\n        _transferQuoteToken(msg.sender, removedAmount_);\n    }\n\n    /// @inheritdoc IPoolLenderActions\n    function transferLPs(\n        address owner_,\n        address newOwner_,\n        uint256[] calldata indexes_\n    ) external override nonReentrant {\n        LenderActions.transferLPs(\n            buckets,\n            _lpTokenAllowances,\n            owner_,\n            newOwner_,\n            indexes_\n        );\n    }\n\n    /*****************************/\n    /*** Liquidation Functions ***/\n    /*****************************/\n\n    /**\n     *  @inheritdoc IPoolLiquidationActions\n     *  @dev write state:\n     *       - increment poolBalances.t0DebtInAuction and poolBalances.t0Debt accumulators\n     */\n    function kick(\n        address borrowerAddress_\n    ) external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // kick auction\n        KickResult memory result = Auctions.kick(\n            auctions,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_\n        );\n\n        // update pool balances state\n        poolBalances.t0DebtInAuction += result.t0KickedDebt;\n        poolBalances.t0Debt          += result.t0KickPenalty;\n\n        // update pool interest rate state\n        poolState.debt += result.kickPenalty;\n        _updateInterestState(poolState, result.lup);\n\n        if(result.amountToCoverBond != 0) _transferQuoteTokenFrom(msg.sender, result.amountToCoverBond);\n    }\n\n    /**\n     *  @inheritdoc IPoolLiquidationActions\n     *  @dev write state:\n     *       - increment poolBalances.t0DebtInAuction and poolBalances.t0Debt accumulators\n     */\n    function kickWithDeposit(\n        uint256 index_\n    ) external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // kick auctions\n        KickResult memory result = Auctions.kickWithDeposit(\n            auctions,\n            deposits,\n            buckets,\n            loans,\n            poolState,\n            index_\n        );\n\n        // update pool balances state\n        poolBalances.t0Debt          += result.t0KickPenalty;\n        poolBalances.t0DebtInAuction += result.t0KickedDebt;\n\n        // update pool interest rate state\n        poolState.debt += result.kickPenalty;\n        _updateInterestState(poolState, result.lup);\n\n        // transfer from kicker to pool the difference to cover bond\n        if(result.amountToCoverBond != 0) _transferQuoteTokenFrom(msg.sender, result.amountToCoverBond);\n    }\n\n    /**\n     *  @inheritdoc IPoolLiquidationActions\n     *  @dev write state:\n     *       - reset kicker's claimable accumulator\n     */\n    function withdrawBonds() external {\n        uint256 claimable = auctions.kickers[msg.sender].claimable;\n        auctions.kickers[msg.sender].claimable = 0;\n        _transferQuoteToken(msg.sender, claimable);\n    }\n\n    /*********************************/\n    /*** Reserve Auction Functions ***/\n    /*********************************/\n\n    /**\n     *  @inheritdoc IPoolReserveAuctionActions\n     *  @dev  write state:\n     *          - increment latestBurnEpoch counter\n     *          - update reserveAuction.latestBurnEventEpoch and burn event timestamp state\n     *  @dev reverts on:\n     *          - 2 weeks not passed ReserveAuctionTooSoon()\n     *  @dev emit events:\n     *          - ReserveAuction\n     */\n    function startClaimableReserveAuction() external override nonReentrant {\n        // retrieve timestamp of latest burn event and last burn timestamp\n        uint256 latestBurnEpoch   = reserveAuction.latestBurnEventEpoch;\n        uint256 lastBurnTimestamp = reserveAuction.burnEvents[latestBurnEpoch].timestamp;\n\n        // check that at least two weeks have passed since the last reserve auction completed, and that the auction was not kicked within the past 72 hours\n        if (block.timestamp < lastBurnTimestamp + 2 weeks || block.timestamp - reserveAuction.kicked <= 72 hours) {\n            revert ReserveAuctionTooSoon();\n        }\n\n        // start a new claimable reserve auction, passing in relevant parameters such as the current pool size, debt, balance, and inflator value\n        uint256 kickerAward = Auctions.startClaimableReserveAuction(\n            auctions,\n            reserveAuction,\n            StartReserveAuctionParams({\n                poolSize:    Deposits.treeSum(deposits),\n                poolDebt:    poolBalances.t0Debt,\n                poolBalance: _getPoolQuoteTokenBalance(),\n                inflator:    inflatorState.inflator\n            })\n        );\n\n        // increment latest burn event epoch and update burn event timestamp\n        latestBurnEpoch += 1;\n\n        reserveAuction.latestBurnEventEpoch = latestBurnEpoch;\n        reserveAuction.burnEvents[latestBurnEpoch].timestamp = block.timestamp;\n\n        // transfer kicker award to msg.sender\n        _transferQuoteToken(msg.sender, kickerAward);\n    }\n\n    /**\n     *  @inheritdoc IPoolReserveAuctionActions\n     *  @dev  write state:\n     *          - increment reserveAuction.totalAjnaBurned accumulator\n     *          - update burn event totalInterest and totalBurned accumulators\n     */\n    function takeReserves(\n        uint256 maxAmount_\n    ) external override nonReentrant returns (uint256 amount_) {\n        uint256 ajnaRequired;\n        (amount_, ajnaRequired) = Auctions.takeReserves(\n            reserveAuction,\n            maxAmount_\n        );\n\n        uint256 totalBurned = reserveAuction.totalAjnaBurned + ajnaRequired;\n        \n        // accumulate additional ajna burned\n        reserveAuction.totalAjnaBurned = totalBurned;\n\n        uint256 burnEventEpoch = reserveAuction.latestBurnEventEpoch;\n\n        // record burn event information to enable querying by staking rewards\n        BurnEvent storage burnEvent = reserveAuction.burnEvents[burnEventEpoch];\n        burnEvent.totalInterest = reserveAuction.totalInterestEarned;\n        burnEvent.totalBurned   = totalBurned;\n\n        // burn required number of ajna tokens to take quote from reserves\n        IERC20(_getArgAddress(AJNA_ADDRESS)).safeTransferFrom(msg.sender, address(this), ajnaRequired);\n\n        IERC20Token(_getArgAddress(AJNA_ADDRESS)).burn(ajnaRequired);\n\n        // transfer quote token to caller\n        _transferQuoteToken(msg.sender, amount_);\n    }\n\n    /*****************************/\n    /*** Pool Helper Functions ***/\n    /*****************************/\n\n    /**\n     *  @notice Accrues pool interest in current block and returns pool details.\n     *  @dev    external libraries call:\n     *              - PoolCommons.accrueInterest   \n     *  @dev    write state:\n     *              - PoolCommons.accrueInterest:\n     *                  - Deposits.mult (scale Fenwick tree with new interest accrued):\n     *                      - update scaling array state \n     *              - increment reserveAuction.totalInterestEarned accumulator\n     *  @return poolState_ Struct containing pool details.\n     */\n    function _accruePoolInterest() internal returns (PoolState memory poolState_) {\n\t    // retrieve t0Debt amount from poolBalances struct\n        uint256 t0Debt = poolBalances.t0Debt;\n\n\t    // initialize fields of poolState_ struct with initial values\n        poolState_.collateral     = poolBalances.pledgedCollateral;\n        poolState_.inflator       = inflatorState.inflator;\n        poolState_.rate           = interestState.interestRate;\n        poolState_.poolType       = _getArgUint8(POOL_TYPE);\n        poolState_.quoteDustLimit = _getArgUint256(QUOTE_SCALE);\n\n\t    // check if t0Debt is not equal to 0, indicating that there is debt to be tracked for the pool\n        if (t0Debt != 0) {\n            // Calculate prior pool debt\n            poolState_.debt = Maths.wmul(t0Debt, poolState_.inflator);\n\n\t        // calculate elapsed time since inflator was last updated\n            uint256 elapsed = block.timestamp - inflatorState.inflatorUpdate;\n\n\t        // set isNewInterestAccrued field to true if elapsed time is not 0, indicating that new interest may have accrued\n            poolState_.isNewInterestAccrued = elapsed != 0;\n\n            // if new interest may have accrued, call accrueInterest function and update inflator and debt fields of poolState_ struct\n            if (poolState_.isNewInterestAccrued) {\n                (uint256 newInflator, uint256 newInterest) = PoolCommons.accrueInterest(\n                    deposits,\n                    poolState_,\n                    Loans.getMax(loans).thresholdPrice,\n                    elapsed\n                );\n                poolState_.inflator = newInflator;\n                // After debt owed to lenders has accrued, calculate current debt owed by borrowers\n                poolState_.debt = Maths.wmul(t0Debt, poolState_.inflator);\n\n                // update total interest earned accumulator with the newly accrued interest\n                reserveAuction.totalInterestEarned += newInterest;\n            }\n        }\n    }\n\n    /**\n     *  @notice Update interest rate and inflator of the pool.\n     *  @dev    external libraries call:\n     *              - PoolCommons.updateInterestRate     \n     *  @dev    write state:\n     *              - PoolCommons.updateInterestRate \n     *                  - interest debt and lup * collateral EMAs accumulators\n     *                  - interest rate accumulator and interestRateUpdate state\n     *              - pool inflator and inflatorUpdate state\n     *  @dev    emit events:\n     *              - PoolCommons.updateInterestRate:\n     *                  - UpdateInterestRate\n     *  @param  poolState_ Struct containing pool details.\n     *  @param  lup_       Current LUP in pool.\n     */\n    function _updateInterestState(\n        PoolState memory poolState_,\n        uint256 lup_\n    ) internal {\n        // if it has been more than 12 hours since the last interest rate update, call updateInterestRate function\n        if (block.timestamp - interestState.interestRateUpdate > 12 hours) {\n            PoolCommons.updateInterestRate(interestState, deposits, poolState_, lup_);\n        }\n\n        // update pool inflator\n        if (poolState_.isNewInterestAccrued) {\n            inflatorState.inflator       = uint208(poolState_.inflator);\n            inflatorState.inflatorUpdate = uint48(block.timestamp);\n        // if the debt in the current pool state is 0, also update the inflator and inflatorUpdate fields in inflatorState\n        // slither-disable-next-line incorrect-equality\n        } else if (poolState_.debt == 0) {\n            inflatorState.inflator       = uint208(Maths.WAD);\n            inflatorState.inflatorUpdate = uint48(block.timestamp);\n        }\n    }\n\n    function _transferQuoteTokenFrom(address from_, uint256 amount_) internal {\n        IERC20(_getArgAddress(QUOTE_ADDRESS)).safeTransferFrom(from_, address(this), amount_ / _getArgUint256(QUOTE_SCALE));\n    }\n\n    function _transferQuoteToken(address to_, uint256 amount_) internal {\n        IERC20(_getArgAddress(QUOTE_ADDRESS)).safeTransfer(to_, amount_ / _getArgUint256(QUOTE_SCALE));\n    }\n\n    function _getPoolQuoteTokenBalance() internal view returns (uint256) {\n        return IERC20(_getArgAddress(QUOTE_ADDRESS)).balanceOf(address(this));\n    }\n\n    function _lup(uint256 debt_) internal view returns (uint256) {\n        return _priceAt(Deposits.findIndexOfSum(deposits, debt_));\n    }\n\n    /**************************/\n    /*** External Functions ***/\n    /**************************/\n\n    /// @inheritdoc IPoolState\n    function auctionInfo(\n        address borrower_\n    ) external\n    view override returns (\n        address kicker,\n        uint256 bondFactor,\n        uint256 bondSize,\n        uint256 kickTime,\n        uint256 kickMomp,\n        uint256 neutralPrice,\n        address head,\n        address next,\n        address prev\n    ) {\n        Liquidation memory liquidation = auctions.liquidations[borrower_];\n        return (\n            liquidation.kicker,\n            liquidation.bondFactor,\n            liquidation.bondSize,\n            liquidation.kickTime,\n            liquidation.kickMomp,\n            liquidation.neutralPrice,\n            auctions.head,\n            liquidation.next,\n            liquidation.prev\n        );\n    }\n\n    /// @inheritdoc IPoolState\n    function borrowerInfo(\n        address borrower_\n    ) external view override returns (uint256, uint256, uint256) {\n        return (\n            loans.borrowers[borrower_].t0Debt,\n            loans.borrowers[borrower_].collateral,\n            loans.borrowers[borrower_].t0Np\n        );\n    }\n\n    /// @inheritdoc IPoolState\n    function bucketInfo(\n        uint256 index_\n    ) external view override returns (uint256, uint256, uint256, uint256, uint256) {\n        uint256 scale = Deposits.scale(deposits, index_);\n        return (\n            buckets[index_].lps,\n            buckets[index_].collateral,\n            buckets[index_].bankruptcyTime,\n            Maths.wmul(scale, Deposits.unscaledValueAt(deposits, index_)),\n            scale\n        );\n    }\n\n    /// @inheritdoc IPoolDerivedState\n    function bucketExchangeRate(\n        uint256 index_\n    ) external view returns (uint256 exchangeRate_) {\n        Bucket storage bucket = buckets[index_];\n\n        exchangeRate_ = Buckets.getExchangeRate(\n            bucket.collateral,\n            bucket.lps,\n            Deposits.valueAt(deposits, index_),\n            _priceAt(index_)\n        );\n    }\n\n    /// @inheritdoc IPoolState\n    function currentBurnEpoch() external view returns (uint256) {\n        return reserveAuction.latestBurnEventEpoch;\n    }\n\n    /// @inheritdoc IPoolState\n    function burnInfo(uint256 burnEventEpoch_) external view returns (uint256, uint256, uint256) {\n        BurnEvent memory burnEvent = reserveAuction.burnEvents[burnEventEpoch_];\n\n        return (\n            burnEvent.timestamp,\n            burnEvent.totalInterest,\n            burnEvent.totalBurned\n        );\n    }\n\n    /// @inheritdoc IPoolState\n    function debtInfo() external view returns (uint256, uint256, uint256) {\n        uint256 pendingInflator = PoolCommons.pendingInflator(\n            inflatorState.inflator,\n            inflatorState.inflatorUpdate,\n            interestState.interestRate\n        );\n        return (\n            Maths.wmul(poolBalances.t0Debt, pendingInflator),\n            Maths.wmul(poolBalances.t0Debt, inflatorState.inflator),\n            Maths.wmul(poolBalances.t0DebtInAuction, inflatorState.inflator)\n        );\n    }\n\n    /// @inheritdoc IPoolDerivedState\n    function depositIndex(uint256 debt_) external view override returns (uint256) {\n        return Deposits.findIndexOfSum(deposits, debt_);\n    }\n\n    /// @inheritdoc IPoolDerivedState\n    function depositSize() external view override returns (uint256) {\n        return Deposits.treeSum(deposits);\n    }\n\n    /// @inheritdoc IPoolDerivedState\n    function depositUtilization(\n        uint256 debt_,\n        uint256 collateral_\n    ) external view override returns (uint256) {\n        return PoolCommons.utilization(deposits, debt_, collateral_);\n    }\n\n    /// @inheritdoc IPoolState\n    function emasInfo() external view override returns (uint256, uint256) {\n        return (\n            interestState.debtEma,\n            interestState.lupColEma\n        );\n    }\n\n    /// @inheritdoc IPoolState\n    function inflatorInfo() external view override returns (uint256, uint256) {\n        return (\n            inflatorState.inflator,\n            inflatorState.inflatorUpdate\n        );\n    }\n\n    /// @inheritdoc IPoolState\n    function interestRateInfo() external view returns (uint256, uint256) {\n        return (\n            interestState.interestRate,\n            interestState.interestRateUpdate\n        );\n    }\n\n    /// @inheritdoc IPoolState\n    function kickerInfo(\n        address kicker_\n    ) external view override returns (uint256, uint256) {\n        return(\n            auctions.kickers[kicker_].claimable,\n            auctions.kickers[kicker_].locked\n        );\n    }\n\n    /// @inheritdoc IPoolState\n    function lenderInfo(\n        uint256 index_,\n        address lender_\n    ) external view override returns (uint256 lpBalance_, uint256 depositTime_) {\n        depositTime_ = buckets[index_].lenders[lender_].depositTime;\n        if (buckets[index_].bankruptcyTime < depositTime_) lpBalance_ = buckets[index_].lenders[lender_].lps;\n    }\n\n    /// @inheritdoc IPoolState\n    function loanInfo(\n        uint256 loanId_\n    ) external view override returns (address, uint256) {\n        return (\n            Loans.getByIndex(loans, loanId_).borrower,\n            Loans.getByIndex(loans, loanId_).thresholdPrice\n        );\n    }\n\n    /// @inheritdoc IPoolState\n    function loansInfo() external view override returns (address, uint256, uint256) {\n        return (\n            Loans.getMax(loans).borrower,\n            Maths.wmul(Loans.getMax(loans).thresholdPrice, inflatorState.inflator),\n            Loans.noOfLoans(loans)\n        );\n    }\n\n    /// @inheritdoc IPoolState\n    function pledgedCollateral() external view override returns (uint256) {\n        return poolBalances.pledgedCollateral;\n    }\n\n    /// @inheritdoc IPoolState\n    function reservesInfo() external view override returns (uint256, uint256, uint256) {\n        return (\n            auctions.totalBondEscrowed,\n            reserveAuction.unclaimed,\n            reserveAuction.kicked\n        );\n    }\n}"
    },
    {
      "filename": "contracts/src/libraries/external/LenderActions.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport {\n    AddQuoteParams,\n    MoveQuoteParams,\n    RemoveQuoteParams\n}                     from '../../interfaces/pool/commons/IPoolInternals.sol';\nimport {\n    Bucket,\n    DepositsState,\n    Lender,\n    PoolState\n}                     from '../../interfaces/pool/commons/IPoolState.sol';\n\nimport { _feeRate, _priceAt, _ptp, MAX_FENWICK_INDEX } from '../helpers/PoolHelper.sol';\n\nimport { Deposits } from '../internal/Deposits.sol';\nimport { Buckets }  from '../internal/Buckets.sol';\nimport { Maths }    from '../internal/Maths.sol';\n\n\n/**\n    @title  LenderActions library\n    @notice External library containing logic for pool actors:\n            - Lenders: add, remove and move quote tokens; transfer LPs\n            - Traders: add, remove and move quote tokens; add and remove collateral\n */\nlibrary LenderActions {\n\n    /*************************/\n    /*** Local Var Structs ***/\n    /*************************/\n\n    struct MoveQuoteLocalVars {\n        uint256 amountToMove;           // [WAD] Quote token amount to move between indexes.\n        uint256 fromBucketPrice;        // [WAD] Price of the bucket to move amount from.\n        uint256 fromBucketLPs;          // [RAY] Amount of LPs in the bucket to move amount from.\n        uint256 fromBucketDepositTime;  // Time of lender deposit in the bucket to move amount from.\n        uint256 toBucketPrice;          // [WAD] Price of the bucket to move amount to.\n        uint256 toBucketBankruptcyTime; // Time the bucket to move amount to was marked as insolvent.\n        uint256 ptp;                    // [WAD] Pool Threshold Price.\n        uint256 htp;                    // [WAD] Highest Threshold Price.\n    }\n    struct RemoveDepositParams {\n        uint256 depositConstraint; // [WAD] Constraint on deposit in quote token.\n        uint256 lpConstraint;      // [RAY] Constraint in LPB terms.\n        uint256 bucketLPs;         // [RAY] Total LPB in the bucket.\n        uint256 bucketCollateral;  // [WAD] Claimable collateral in the bucket.\n        uint256 price;             // [WAD] Price of bucket.\n        uint256 index;             // Bucket index.\n        uint256 dustLimit;         // Minimum amount of deposit which may reside in a bucket.\n    }\n\n    /**************/\n    /*** Events ***/\n    /**************/\n\n    // See `IPoolEvents` for descriptions\n    event AddQuoteToken(address indexed lender, uint256 indexed price, uint256 amount, uint256 lpAwarded, uint256 lup);\n    event BucketBankruptcy(uint256 indexed index, uint256 lpForfeited);\n    event MoveQuoteToken(address indexed lender, uint256 indexed from, uint256 indexed to, uint256 amount, uint256 lpRedeemedFrom, uint256 lpAwardedTo, uint256 lup);\n    event RemoveQuoteToken(address indexed lender, uint256 indexed price, uint256 amount, uint256 lpRedeemed, uint256 lup);\n    event TransferLPTokens(address owner, address newOwner, uint256[] indexes, uint256 lpTokens);\n\n    /**************/\n    /*** Errors ***/\n    /**************/\n\n    // See `IPoolErrors` for descriptions\n    error BucketBankruptcyBlock();\n    error CannotMergeToHigherPrice();\n    error DustAmountNotExceeded();\n    error NoAllowance();\n    error InvalidIndex();\n    error LUPBelowHTP();\n    error NoClaim();\n    error InsufficientLPs();\n    error InsufficientLiquidity();\n    error InsufficientCollateral();\n    error MoveToSamePrice();\n\n    /***************************/\n    /***  External Functions ***/\n    /***************************/\n\n    /**\n     *  @notice See `IERC20PoolLenderActions` and `IERC721PoolLenderActions` for descriptions\n     *  @dev    write state:\n     *              - Buckets.addCollateral:\n     *                  - increment bucket.collateral and bucket.lps accumulator\n     *                  - addLenderLPs:\n     *                      - increment lender.lps accumulator and lender.depositTime state\n     *  @dev    reverts on:\n     *              - invalid bucket index InvalidIndex()\n     */\n    function addCollateral(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        uint256 collateralAmountToAdd_,\n        uint256 index_\n    ) external returns (uint256 bucketLPs_) {\n        if (index_ == 0 || index_ > MAX_FENWICK_INDEX) revert InvalidIndex();\n\n        uint256 bucketDeposit = Deposits.valueAt(deposits_, index_);\n        uint256 bucketPrice   = _priceAt(index_);\n\n        bucketLPs_ = Buckets.addCollateral(\n            buckets_[index_],\n            msg.sender,\n            bucketDeposit,\n            collateralAmountToAdd_,\n            bucketPrice\n        );\n    }\n\n    /**\n     *  @notice See `IPoolLenderActions` for descriptions\n     *  @dev    write state:\n     *              - Deposits.unscaledAdd (add new amount in Fenwick tree):\n     *                  - update values array state \n     *              - increment bucket.lps accumulator\n     *              - increment lender.lps accumulator and lender.depositTime state\n     *  @dev    reverts on:\n     *              - invalid bucket index InvalidIndex()\n     *              - same block when bucket becomes insolvent BucketBankruptcyBlock()\n     *  @dev    emit events:\n     *              - AddQuoteToken\n     */\n    function addQuoteToken(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        PoolState calldata poolState_,\n        AddQuoteParams calldata params_\n    ) external returns (uint256 bucketLPs_, uint256 lup_) {\n        if (params_.index == 0 || params_.index > MAX_FENWICK_INDEX) revert InvalidIndex();\n\n        Bucket storage bucket = buckets_[params_.index];\n\n        uint256 bankruptcyTime = bucket.bankruptcyTime;\n\n        // cannot deposit in the same block when bucket becomes insolvent\n        if (bankruptcyTime == block.timestamp) revert BucketBankruptcyBlock();\n\n        uint256 unscaledBucketDeposit = Deposits.unscaledValueAt(deposits_, params_.index);\n        uint256 bucketScale           = Deposits.scale(deposits_, params_.index);\n        uint256 bucketDeposit         = Maths.wmul(bucketScale, unscaledBucketDeposit);\n        uint256 bucketPrice           = _priceAt(params_.index);\n\n        bucketLPs_ = Buckets.quoteTokensToLPs(\n            bucket.collateral,\n            bucket.lps,\n            bucketDeposit,\n            params_.amount,\n            bucketPrice\n        );\n\n        Deposits.unscaledAdd(deposits_, params_.index, Maths.wdiv(params_.amount, bucketScale));\n\n        // update lender LPs\n        Lender storage lender = bucket.lenders[msg.sender];\n\n        if (bankruptcyTime >= lender.depositTime) lender.lps = bucketLPs_;\n        else lender.lps += bucketLPs_;\n\n        lender.depositTime = block.timestamp;\n\n        // update bucket LPs\n        bucket.lps += bucketLPs_;\n\n        lup_ = _lup(deposits_, poolState_.debt);\n\n        emit AddQuoteToken(msg.sender, params_.index, params_.amount, bucketLPs_, lup_);\n    }\n\n    /**\n     *  @notice See `IPoolLenderActions` for descriptions\n     *  @dev    write state:\n     *              - _removeMaxDeposit:\n     *                  - Deposits.unscaledRemove (remove amount in Fenwick tree, from index):\n     *                  - update values array state\n     *              - Deposits.unscaledAdd (add amount in Fenwick tree, to index):\n     *                  - update values array state\n     *              - decrement lender.lps accumulator for from bucket\n     *              - increment lender.lps accumulator and lender.depositTime state for to bucket\n     *              - decrement bucket.lps accumulator for from bucket\n     *              - incr"
    }
  ]
}