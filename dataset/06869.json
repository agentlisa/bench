{
  "Title": "[24] Add a limit for the maximum number of characters per line",
  "Content": "\nThe solidity [documentation](https://docs.soliditylang.org/en/v0.8.17/style-guide.html#maximum-line-length) recommends a maximum of 120 characters.\n\nConsider adding a limit of 120 characters or less to prevent large lines.\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/Reth.sol#L142\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-03-asymmetry",
  "Code": [
    {
      "filename": "contracts/SafEth/derivatives/Reth.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"../../interfaces/IDerivative.sol\";\nimport \"../../interfaces/frax/IsFrxEth.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../interfaces/rocketpool/RocketStorageInterface.sol\";\nimport \"../../interfaces/rocketpool/RocketTokenRETHInterface.sol\";\nimport \"../../interfaces/rocketpool/RocketDepositPoolInterface.sol\";\nimport \"../../interfaces/rocketpool/RocketDAOProtocolSettingsDepositInterface.sol\";\nimport \"../../interfaces/IWETH.sol\";\nimport \"../../interfaces/uniswap/ISwapRouter.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"../../interfaces/uniswap/IUniswapV3Factory.sol\";\nimport \"../../interfaces/uniswap/IUniswapV3Pool.sol\";\n\n/// @title Derivative contract for rETH\n/// @author Asymmetry Finance\ncontract Reth is IDerivative, Initializable, OwnableUpgradeable {\n    address public constant ROCKET_STORAGE_ADDRESS =\n        0x1d8f8f00cfa6758d7bE78336684788Fb0ee0Fa46;\n    address public constant W_ETH_ADDRESS =\n        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant UNISWAP_ROUTER =\n        0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45;\n    address public constant UNI_V3_FACTORY =\n        0x1F98431c8aD98523631AE4a59f267346ea31F984;\n\n    uint256 public maxSlippage;\n\n    // As recommended by https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n        @notice - Function to initialize values for the contracts\n        @dev - This replaces the constructor for upgradeable contracts\n        @param _owner - owner of the contract which handles stake/unstake\n    */\n    function initialize(address _owner) external initializer {\n        _transferOwnership(_owner);\n        maxSlippage = (1 * 10 ** 16); // 1%\n    }\n\n    /**\n        @notice - Return derivative name\n    */\n    function name() public pure returns (string memory) {\n        return \"RocketPool\";\n    }\n\n    /**\n        @notice - Owner only function to set max slippage for derivative\n        @param _slippage - new slippage amount in wei\n    */\n    function setMaxSlippage(uint256 _slippage) external onlyOwner {\n        maxSlippage = _slippage;\n    }\n\n    /**\n        @notice - Get rETH address\n        @dev - per RocketPool Docs query addresses each time it is used\n     */\n    function rethAddress() private view returns (address) {\n        return\n            RocketStorageInterface(ROCKET_STORAGE_ADDRESS).getAddress(\n                keccak256(\n                    abi.encodePacked(\"contract.address\", \"rocketTokenRETH\")\n                )\n            );\n    }\n\n    /**\n        @notice - Swap tokens through Uniswap\n        @param _tokenIn - token to swap from\n        @param _tokenOut - token to swap to\n        @param _poolFee - pool fee for particular swap\n        @param _amountIn - amount of token to swap from\n        @param _minOut - minimum amount of token to receive (slippage)\n     */\n    function swapExactInputSingleHop(\n        address _tokenIn,\n        address _tokenOut,\n        uint24 _poolFee,\n        uint256 _amountIn,\n        uint256 _minOut\n    ) private returns (uint256 amountOut) {\n        IERC20(_tokenIn).approve(UNISWAP_ROUTER, _amountIn);\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter\n            .ExactInputSingleParams({\n                tokenIn: _tokenIn,\n                tokenOut: _tokenOut,\n                fee: _poolFee,\n                recipient: address(this),\n                amountIn: _amountIn,\n                amountOutMinimum: _minOut,\n                sqrtPriceLimitX96: 0\n            });\n        amountOut = ISwapRouter(UNISWAP_ROUTER).exactInputSingle(params);\n    }\n\n    /**\n        @notice - Convert derivative into ETH\n     */\n    function withdraw(uint256 amount) external onlyOwner {\n        RocketTokenRETHInterface(rethAddress()).burn(amount);\n        // solhint-disable-next-line\n        (bool sent, ) = address(msg.sender).call{value: address(this).balance}(\n            \"\"\n        );\n        require(sent, \"Failed to send Ether\");\n    }\n\n    /**\n        @notice - Check whether or not rETH deposit pool has room users amount\n        @param _amount - amount that will be deposited\n     */\n    function poolCanDeposit(uint256 _amount) private view returns (bool) {\n        address rocketDepositPoolAddress = RocketStorageInterface(\n            ROCKET_STORAGE_ADDRESS\n        ).getAddress(\n                keccak256(\n                    abi.encodePacked(\"contract.address\", \"rocketDepositPool\")\n                )\n            );\n        RocketDepositPoolInterface rocketDepositPool = RocketDepositPoolInterface(\n                rocketDepositPoolAddress\n            );\n\n        address rocketProtocolSettingsAddress = RocketStorageInterface(\n            ROCKET_STORAGE_ADDRESS\n        ).getAddress(\n                keccak256(\n                    abi.encodePacked(\n                        \"contract.address\",\n                        \"rocketDAOProtocolSettingsDeposit\"\n                    )\n                )\n            );\n        RocketDAOProtocolSettingsDepositInterface rocketDAOProtocolSettingsDeposit = RocketDAOProtocolSettingsDepositInterface(\n                rocketProtocolSettingsAddress\n            );\n\n        return\n            rocketDepositPool.getBalance() + _amount <=\n            rocketDAOProtocolSettingsDeposit.getMaximumDepositPoolSize() &&\n            _amount >= rocketDAOProtocolSettingsDeposit.getMinimumDeposit();\n    }\n\n    /**\n        @notice - Deposit into derivative\n        @dev - will either get rETH on exchange or deposit into contract depending on availability\n     */\n    function deposit() external payable onlyOwner returns (uint256) {\n        // Per RocketPool Docs query addresses each time it is used\n        address rocketDepositPoolAddress = RocketStorageInterface(\n            ROCKET_STORAGE_ADDRESS\n        ).getAddress(\n                keccak256(\n                    abi.encodePacked(\"contract.address\", \"rocketDepositPool\")\n                )\n            );\n\n        RocketDepositPoolInterface rocketDepositPool = RocketDepositPoolInterface(\n                rocketDepositPoolAddress\n            );\n\n        if (!poolCanDeposit(msg.value)) {\n            uint rethPerEth = (10 ** 36) / poolPrice();\n\n            uint256 minOut = ((((rethPerEth * msg.value) / 10 ** 18) *\n                ((10 ** 18 - maxSlippage))) / 10 ** 18);\n\n            IWETH(W_ETH_ADDRESS).deposit{value: msg.value}();\n            uint256 amountSwapped = swapExactInputSingleHop(\n                W_ETH_ADDRESS,\n                rethAddress(),\n                500,\n                msg.value,\n                minOut\n            );\n\n            return amountSwapped;\n        } else {\n            address rocketTokenRETHAddress = RocketStorageInterface(\n                ROCKET_STORAGE_ADDRESS\n            ).getAddress(\n                    keccak256(\n                        abi.encodePacked(\"contract.address\", \"rocketTokenRETH\")\n                    )\n                );\n            RocketTokenRETHInterface rocketTokenRETH = RocketTokenRETHInterface(\n                rocketTokenRETHAddress\n            );\n            uint256 rethBalance1 = rocketTokenRETH.balanceOf(address(this));\n            rocketDepositPool.deposit{value: msg.value}();\n            uint256 rethBalance2 = rocketTokenRETH.balanceOf(address(this));\n            require(rethBalance2 > rethBalance1, \"No rETH was minted\");\n            uint256 rethMinted = rethBalance2 - rethBalance1;\n            return (rethMinted);\n        }\n    }\n\n    /**\n        @notice - Get price of derivative in terms of ETH\n        @dev - we need to pass amount so that it gets price from the same source that it buys or mints the rEth\n        @param _amount - amount to check for ETH price\n     */\n    function ethPerDerivative(uint256 _amount) public view returns (uint256) {\n        if (poolCanDeposit(_amount))\n            return\n                RocketTokenRETHInterface(rethAddress()).getEthValue(10 ** 18);\n        else return (poolPrice() * 10 ** 18) / (10 ** 18);\n    }\n\n    /**\n        @notice - Total derivative balance\n     */\n    function balance() public view returns (uint256) {\n        return IERC20(rethAddress()).balanceOf(address(this));\n    }\n\n    /**\n        @notice - Price of derivative in liquidity pool\n     */\n    function poolPrice() private view returns (uint256) {\n        address rocketTokenRETHAddress = RocketStorageInterface(\n            ROCKET_STORAGE_ADDRESS\n        ).getAddress(\n                keccak256(\n                    abi.encodePacked(\"contract.address\", \"rocketTokenRETH\")\n                )\n            );\n        IUniswapV3Factory factory = IUniswapV3Factory(UNI_V3_FACTORY);\n        IUniswapV3Pool pool = IUniswapV3Pool(\n            factory.getPool(rocketTokenRETHAddress, W_ETH_ADDRESS, 500)\n        );\n        (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();\n        return (sqrtPriceX96 * (uint(sqrtPriceX96)) * (1e18)) >> (96 * 2);\n    }\n\n    receive() external payable {}\n}"
    }
  ]
}