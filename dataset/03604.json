{
  "Title": "Possible events are not emitting",
  "Content": "##### Description\nIn the `trade()` function the state of smart contract is changed, but events are not emitted:\nhttps://github.com/1inch/fee-collector/blob/3c2626763fd829500496f15476d5e98fbdf4f574/contracts/FeeCollector.sol#L344\n##### Recommendation\nWe recommend to add emitting events for this function.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/FeeCollector.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"./utils/BalanceAccounting.sol\";\n\n\ncontract FeeCollector is Ownable, BalanceAccounting {\n    using SafeERC20 for IERC20;\n\n    struct EpochBalance {\n        mapping(address => uint256) balances;\n        uint256 totalSupply;\n        uint256 tokenSpent;\n        uint256 inchBalance;\n    }\n\n    struct TokenInfo {\n        uint40 lastTime;\n        uint216 lastValue;\n        mapping(uint256 => EpochBalance) epochBalance;\n        uint256 firstUnprocessedEpoch;\n        uint256 currentEpoch;\n        mapping(address => uint256) firstUserUnprocessedEpoch;\n    }\n\n    uint256 private immutable _k00;\n    uint256 private immutable _k01;\n    uint256 private immutable _k02;\n    uint256 private immutable _k03;\n    uint256 private immutable _k04;\n    uint256 private immutable _k05;\n    uint256 private immutable _k06;\n    uint256 private immutable _k07;\n    uint256 private immutable _k08;\n    uint256 private immutable _k09;\n    uint256 private immutable _k10;\n    uint256 private immutable _k11;\n    uint256 private immutable _k12;\n    uint256 private immutable _k13;\n    uint256 private immutable _k14;\n    uint256 private immutable _k15;\n    uint256 private immutable _k16;\n    uint256 private immutable _k17;\n    uint256 private immutable _k18;\n    uint256 private immutable _k19;\n\n    uint256 private constant _MAX_TIME = 0xfffff;\n\n    mapping(IERC20 => TokenInfo) public tokenInfo;\n    IERC20 public immutable token;\n    uint256 public immutable minValue;\n    uint8 public immutable decimals;\n\n    constructor(\n        IERC20 _token,\n        uint256 _minValue,\n        uint256 _deceleration\n    ) {\n        require(_deceleration > 0 && _deceleration < 1e36, \"Invalid deceleration\");\n\n        token = _token;\n        minValue = _minValue;\n        decimals = IERC20Metadata(address(_token)).decimals();\n\n        uint256 z;\n        _k00 = z = _deceleration;\n        _k01 = z = z * z / 1e36;\n        _k02 = z = z * z / 1e36;\n        _k03 = z = z * z / 1e36;\n        _k04 = z = z * z / 1e36;\n        _k05 = z = z * z / 1e36;\n        _k06 = z = z * z / 1e36;\n        _k07 = z = z * z / 1e36;\n        _k08 = z = z * z / 1e36;\n        _k09 = z = z * z / 1e36;\n        _k10 = z = z * z / 1e36;\n        _k11 = z = z * z / 1e36;\n        _k12 = z = z * z / 1e36;\n        _k13 = z = z * z / 1e36;\n        _k14 = z = z * z / 1e36;\n        _k15 = z = z * z / 1e36;\n        _k16 = z = z * z / 1e36;\n        _k17 = z = z * z / 1e36;\n        _k18 = z = z * z / 1e36;\n        _k19 = z = z * z / 1e36;\n        require(z * z < 1e36, \"Deceleration is too slow\");\n    }\n\n    function name() external view returns(string memory) {\n        return string(abi.encodePacked(\"FeeCollector: \", IERC20Metadata(address(token)).name()));\n    }\n\n    function symbol() external view returns(string memory) {\n        return string(abi.encodePacked(\"fee-\", IERC20Metadata(address(token)).symbol()));\n    }\n\n    function getEpochBalance(IERC20 _token, uint256 epoch) external view returns(uint256 totalSupply, uint256 tokenSpent, uint256 inchBalance) {\n        EpochBalance storage epochBalance = tokenInfo[_token].epochBalance[epoch];\n        (totalSupply, tokenSpent, inchBalance) = (epochBalance.totalSupply, epochBalance.tokenSpent, epochBalance.inchBalance);\n    }\n\n    function getUserEpochBalance(IERC20 _token, uint256 epoch, address user) external view returns(uint256 balance) {\n        balance = tokenInfo[_token].epochBalance[epoch].balances[user];\n    }\n\n    function getFirstUserUnprocessedEpoch(IERC20 _token, address user) external view returns(uint256 firstUserUnprocessedEpoch) {\n        firstUserUnprocessedEpoch = tokenInfo[_token].firstUserUnprocessedEpoch[user];\n    }\n\n    function decelerationTable() public view returns(uint256[20] memory) {\n        return [\n            _k00, _k01, _k02, _k03, _k04,\n            _k05, _k06, _k07, _k08, _k09,\n            _k10, _k11, _k12, _k13, _k14,\n            _k15, _k16, _k17, _k18, _k19\n        ];\n    }\n\n    function value(IERC20 _token) public view returns(uint256 result) {\n        return valueForTime(block.timestamp, _token);\n    }\n\n    function valueForTimeSimple(uint256 time, IERC20 _token) public view returns(uint256 result) {\n        uint256[20] memory table = decelerationTable();\n        uint256 lastTime = tokenInfo[_token].lastTime;\n        uint256 lastValue = tokenInfo[_token].lastValue;\n        uint256 secs = Math.min(time - lastTime, _MAX_TIME);\n        result = Math.max(lastValue, minValue);\n        for (uint i = 0; secs > 0 && i < table.length; i++) {\n            if (secs & 1 != 0) {\n                result = result * table[i] / 1e36;\n            }\n            if (result < minValue) return minValue;\n            secs >>= 1;\n        }\n    }\n\n    function valueForTime(uint256 time, IERC20 _token) public view returns(uint256 result) {\n        uint256 secs = tokenInfo[_token].lastTime;\n        result = tokenInfo[_token].lastValue;\n\n        secs = time - secs;\n        if (secs > _MAX_TIME) {\n            secs = _MAX_TIME;\n        }\n        if (result < minValue) {\n            result = minValue;\n        }\n\n        uint256 minValue_ = minValue;\n        assembly { // solhint-disable-line no-inline-assembly\n            if and(secs, 0x00000F) {\n                if and(secs, 0x000001) {\n                    result := div(mul(result, 999900000000000000000000000000000000), 1000000000000000000000000000000000000)\n                    if lt(result, minValue_) {\n                        result := minValue_\n                        secs := 0\n                    }\n                }\n\n                if and(secs, 0x000002) {\n                    result := div(mul(result, 999800010000000000000000000000000000), 1000000000000000000000000000000000000)\n                    if lt(result, minValue_) {\n                        result := minValue_\n                        secs := 0\n                    }\n                }\n\n                if and(secs, 0x000004) {\n                    result := div(mul(result, 999600059996000100000000000000000000), 1000000000000000000000000000000000000)\n                    if lt(result, minValue_) {\n                        result := minValue_\n                        secs := 0\n                    }\n                }\n\n                if and(secs, 0x000008) {\n                    result := div(mul(result, 999200279944006999440027999200010000), 1000000000000000000000000000000000000)\n                    if lt(result, minValue_) {\n                        result := minValue_\n                        secs := 0\n                    }\n                }\n            }\n\n            if and(secs, 0x0000F0) {\n                if and(secs, 0x000010) {\n                    result := div(mul(result, 998401199440181956328006856128688560), 1000000000000000000000000000000000000)\n                    if lt(result, minValue_) {\n                        result := minValue_\n                        secs := 0\n                    }\n                }\n\n                if and(secs, 0x000020) {\n                    result := div(mul(result, 996804955043593987145855519554957648), 1000000000000000000000000000000000000)\n                    if lt(result, minValue_) {\n                        result := minValue_\n                        secs := 0\n                    }\n                }\n\n                if and(secs, 0x000040) {\n                    result := div(mul(result, 993620118399461429792290614928235372), 1000000000000000000000000000000000000)\n                    if lt(result, minValue_) {\n                        result := minValue_\n                        secs := 0\n                    }\n                }\n\n                if and(secs, 0x000080) {\n                    result := div(mul(result, 987280939688159750172898466482272707), 1000000000000000000000000000000000000)\n                    if lt(result, minValue_) {\n                        result := minValue_\n                        secs := 0\n                    }\n                }\n            }\n\n            if and(secs, 0x000F00) {\n                if and(secs, 0x000100) {\n                    result := div(mul(result, 974723653871535730138973062438582481), 1000000000000000000000000000000000000)\n                    if lt(result, minValue_) {\n                        result := minValue_\n                        secs := 0\n                    }\n                }\n\n                if and(secs, 0x000200) {\n                    result := div(mul(result, 950086201416677390961738571086337286), 1000000000000000000000000000000000000)\n                    if lt(result, minValue_) {\n                        result := minValue_\n                        secs := 0\n                    }\n                }\n\n                if and(secs, 0x000400) {\n                    result := div(mul(result, 902663790122371280016479918855854806), 1000000000000000000000000000000000000)\n                    if lt(result, minValue_) {\n                        result := minValue_\n                        secs := 0\n                    }\n                }\n\n                if and(secs, 0x000800) {\n                    result := div(mul(result, 814801917998084346828628782199508463), 1000000000000000000000000000000000000)\n                    if lt(result, minValue_) {\n                        result := minValue_\n                        secs := 0\n                    }\n                }\n            }\n\n            if and(secs, 0x00F000) {\n                if and(secs, 0x001000) {\n                    result := div(mul(result, 663902165573356968243491567819400493), 1000000000000000000000000000000000000)\n                    if lt(result, minValue_) {\n                        result := minValue_\n                        secs := 0\n                    }\n                }\n\n                if and(secs, 0x002000) {\n                    result := div(mul(result, 440766085452993090398118811102456830), 1000000000000000000000000000000000000)\n                    if lt(result, minValue_) {\n                        result := minValue_\n                        secs := 0\n                    }\n                }\n\n                if and(secs, 0x004000) {\n                    result := div(mul(result, 194274742085555207178862579417407102), 1000000000000000000000000000000000000)\n                    if lt(result, minValue_) {\n                        result := minValue_\n                        secs := 0\n                    }\n                }\n\n                if and(secs, 0x008000) {\n                    result := div(mul(result, 37742675412408995610179844414960649), 1000000000000000000000000000000000000)\n                    if lt(result, minValue_) {\n                        result := minValue_\n                        secs := 0\n                    }\n                }\n            }\n\n            if and(secs, 0x0F0000) {\n                if and(secs, 0x010000) {\n                    result := div(mul(result, 1424509547286462546864068778806188), 1000000000000000000000000000000000000)\n                    if lt(result, minValue_) {\n                        result := minValue_\n                        secs := 0\n                    }\n                }\n\n                if and(secs, 0x020000) {\n                    result := div(mul(result, 2029227450310282474813662564103), 1000000000000000000000000000000000000)\n                    if lt(result, minValue_) {\n                        result := minValue_\n                        secs := 0\n                    }\n                }\n\n                if and(secs, 0x040000) {\n                    result := div(mul(result, 4117764045092769930387910), 1000000000000000000000000000000000000)\n                    if lt(result, minValue_) {\n                        result := minValue_\n                        secs := 0\n                    }\n                }\n\n                if and(secs, 0x080000) {\n                    result := div(mul(result, 16955980731058), 1000000000000000000000000000000000000)\n                    if lt(result, minValue_) {\n                        result := minValue_\n                        secs := 0\n                    }\n                }\n            }\n        }\n    }\n\n    function updateRewards(address[] calldata receivers, uint256[] calldata amounts) external {\n        for (uint i = 0; i < receivers.length; i++) {\n            _updateReward(IERC20(msg.sender), receivers[i], amounts[i]);\n        }\n    }\n\n    function updateReward(address referral, uint256 amount) external {\n        _updateReward(IERC20(msg.sender), referral, amount);\n    }\n\n    function updateRewardNonLP(IERC20 erc20, address referral, uint256 amount) external {\n        erc20.safeTransferFrom(msg.sender, address(this), amount);\n        _updateReward(erc20, referral, amount);\n    }\n\n    function trade(IERC20 erc20, uint256 amount) external {\n        TokenInfo storage _token = tokenInfo[erc20];\n        uint256 currentEpoch = _token.currentEpoch;\n        uint256 firstUnprocessedEpoch = _token.firstUnprocessedEpoch;\n        EpochBalance storage epochBalance = _token.epochBalance[firstUnprocessedEpoch];\n        EpochBalance storage currentEpochBalance = _token.epochBalance[currentEpoch];\n\n        uint256 currentEpochStored = currentEpoch;\n\n        uint256 unprocessedTotalSupply = epochBalance.totalSupply;\n        uint256 unprocessedTokenBalance = unprocessedTotalSupply - epochBalance.tokenSpent;\n        uint256 tokenBalance = unprocessedTokenBalance;\n        if (firstUnprocessedEpoch != currentEpoch) {\n            tokenBalance += currentEpochBalance.totalSupply - currentEpochBalance.tokenSpent;\n        }\n\n        uint256 returnAmount = amount * tokenBalance / value(erc20);\n        require(tokenBalance >= returnAmount, \"not enough tokens\");\n\n        if (firstUnprocessedEpoch == currentEpoch) {\n            currentEpoch += 1;\n        }\n\n        _updateTokenState(erc20, -int256(returnAmount), currentEpochStored, firstUnprocessedEpoch);\n\n        if (returnAmount <= unprocessedTokenBalance) {\n            if (returnAmount == unprocessedTokenBalance) {\n                _token.firstUnprocessedEpoch += 1;\n            }\n\n            epochBalance.tokenSpent += returnAmount;\n            epochBalance.inchBalance += amount;\n        } else {\n            uint256 amountPart = unprocessedTokenBalance * amount / returnAmount;\n\n            epochBalance.tokenSpent = unprocessedTotalSupply;\n            epochBalance.inchBalance += amountPart;\n\n            currentEpochBalance.tokenSpent += returnAmount - unprocessedTokenBalance;\n            currentEpochBalance.inchBalance += amount - amountPart;\n\n            _token.firstUnprocessedEpoch += 1;\n            currentEpoch += 1;\n        }\n\n        if (currentEpoch != currentEpochStored) {\n            _token.currentEpoch = currentEpoch;\n        }\n\n        token.safeTransferFrom(msg.sender, address(this), amount);\n        erc20.safeTransfer(msg.sender, returnAmount);\n    }\n\n    function claim(IERC20[] memory pools) external {\n        for (uint256 i = 0; i < pools.length; ++i) {\n            TokenInfo storage _token = tokenInfo[pools[i]];\n            _collectProcessedEpochs(msg.sender, _token, _token.currentEpoch, _token.firstUnprocessedEpoch);\n        }\n\n        uint256 userBalance = balanceOf(msg.sender);\n        if (userBalance > 1) {\n            // Avoid erasing storage to decrease gas footprint for referral payments\n            unchecked {\n                uint256 withdrawn = userBalance - 1;\n                _burn(msg.sender, withdrawn);\n                token.safeTransfer(msg.sender, withdrawn);\n            }\n        }\n    }\n\n    function claimCurrentEpoch(IERC20 erc20) external {\n        TokenInfo storage _token = tokenInfo[erc20];\n        uint256 currentEpoch = _token.currentEpoch;\n        uint256 userBalance = _token.epochBalance[currentEpoch].balances[msg.sender];\n        if (userBalance > 0) {\n            _token.epochBalance[currentEpoch].balances[msg.sender] = 0;\n            _token.epochBalance[currentEpoch].totalSupply -= userBalance;\n            erc20.safeTransfer(msg.sender, userBalance);\n        }\n    }\n\n    function claimFrozenEpoch(IERC20 erc20) external {\n        TokenInfo storage _token = tokenInfo[erc20];\n        uint256 firstUnprocessedEpoch = _token.firstUnprocessedEpoch;\n        uint256 currentEpoch = _token.currentEpoch;\n\n        require(firstUnprocessedEpoch + 1 == currentEpoch, \"Epoch already finalized\");\n        require(_token.firstUserUnprocessedEpoch[msg.sender] == firstUnprocessedEpoch, \"Epoch funds already claimed\");\n\n        _token.firstUserUnprocessedEpoch[msg.sender] = currentEpoch;\n        EpochBalance storage epochBalance = _token.epochBalance[firstUnprocessedEpoch];\n        uint256 share = epochBalance.balances[msg.sender];\n\n        if (share > 0) {\n            uint256 totalSupply = epochBalance.totalSupply;\n            epochBalance.balances[msg.sender] = 0;\n            epochBalance.totalSupply = totalSupply - share;\n            epochBalance.inchBalance -= _transferTokenShare(token, epochBalance.inchBalance, share, totalSupply);\n            _transferTokenShare(erc20, epochBalance.tokenSpent, share, totalSupply);\n        }\n    }\n\n    function _updateReward(IERC20 erc20, address referral, uint256 amount) private {\n        TokenInfo storage _token = tokenInfo[erc20];\n        uint256 currentEpoch = _token.currentEpoch;\n        uint256 firstUnprocessedEpoch = _token.firstUnprocessedEpoch;\n\n        _updateTokenState(erc20, int256(amount), currentEpoch, firstUnprocessedEpoch);\n\n        // Add new reward to current epoch\n        _token.epochBalance[currentEpoch].balances[referral] += amount;\n        _token.epochBalance[currentEpoch].totalSupply += amount;\n\n        // Collect all processed epochs and advance user token epoch\n        _collectProcessedEpochs(referral, _token, currentEpoch, firstUnprocessedEpoch);\n    }\n\n    function _updateTokenState(IERC20 erc20, int256 amount, uint256 currentEpoch, uint256 firstUnprocessedEpoch) private {\n        TokenInfo storage _token = tokenInfo[erc20];\n\n        uint256 fee = _token.epochBalance[firstUnprocessedEpoch].totalSupply - _token.epochBalance[firstUnprocessedEpoch].tokenSpent;\n        if (firstUnprocessedEpoch != currentEpoch) {\n            fee += (_token.epochBalance[currentEpoch].totalSupply - _token.epochBalance[currentEpoch].tokenSpent);\n        }\n\n        uint256 feeWithAmount = (amount >= 0 ? fee + uint256(amount) : fee - uint256(-amount));\n        (\n            tokenInfo[erc20].lastTime,\n            tokenInfo[erc20].lastValue\n        ) = (\n            uint40(block.timestamp),\n            uint216(valueForTime(block.timestamp, erc20) * feeWithAmount / (fee == 0 ? 1 : fee))\n        );\n    }\n\n    function _transferTokenShare(IERC20 _token, uint256 balance, uint256 share, uint256 totalSupply) private returns(uint256 amount) {\n        amount = balance * share / totalSupply;\n        if (amount > 0) {\n            _token.safeTransfer(msg.sender, amount);\n        }\n    }\n\n    function _collectProcessedEpochs(address user, TokenInfo storage _token, uint256 currentEpoch, uint256 tokenEpoch) private {\n        uint256 userEpoch = _token.firstUserUnprocessedEpoch[user];\n\n        if (tokenEpoch <= userEpoch) {\n            return;\n        }\n\n        // Early return for the new users\n        if (_token.epochBalance[userEpoch].balances[user] == 0) {\n            _token.firstUserUnprocessedEpoch[user] = currentEpoch;\n            return;\n        }\n\n        uint256 epochCount = Math.min(2, tokenEpoch - userEpoch); // 0, 1 or 2 epochs\n\n        // Claim 1 or 2 processed epochs for the user\n        uint256 collected = _collectEpoch(user, _token, userEpoch);\n        if (epochCount > 1) {\n            collected += _collectEpoch(user, _token, userEpoch + 1);\n        }\n        _mint(user, collected);\n\n        // Update user token epoch counter\n        bool emptySecondEpoch = _token.epochBalance[userEpoch + 1].balances[user] == 0;\n        _token.firstUserUnprocessedEpoch[user] = (epochCount == 2 || emptySecondEpoch) ? currentEpoch : userEpoch + 1;\n    }\n\n    function _collectEpoch(address user, TokenInfo storage _token, uint256 epoch) private returns(uint256 collected) {\n        uint256 share = _token.epochBalance[epoch].balances[user];\n        if (share > 0) {\n            uint256 inchBalance = _token.epochBalance[epoch].inchBalance;\n            uint256 totalSupply = _token.epochBalance[epoch].totalSupply;\n\n            collected = inchBalance * share / totalSupply;\n\n            _token.epochBalance[epoch].balances[user] = 0;\n            _token.epochBalance[epoch].totalSupply = totalSupply - share;\n            _token.epochBalance[epoch].inchBalance = inchBalance - collected;\n        }\n    }\n}"
    }
  ]
}