{
  "Title": "M-18: TwoTokenPoolUtils's _getOraclePairPrice produces incorrect oraclePairPrice when balancerOracleWeight is set to be bigger than BALANCER_ORACLE_WEIGHT_PRECISION",
  "Content": "# Issue M-18: TwoTokenPoolUtils's _getOraclePairPrice produces incorrect oraclePairPrice when balancerOracleWeight is set to be bigger than BALANCER_ORACLE_WEIGHT_PRECISION \n\nSource: https://github.com/sherlock-audit/2022-09-notional-judging/issues/50 \n\n## Found by \nhyh\n\n## Summary\n\nTwoTokenPoolUtils's _getOraclePairPrice() will produce bloated oraclePairPrice as long as `oracleContext.balancerOracleWeight` is bigger than BALANCER_ORACLE_WEIGHT_PRECISION.\n\nAs TwoTokenPoolUtils is a helper contract, it accepts any settings from a Vault. However, _getOraclePairPrice() logic breaks up when `balancerOracleWeight > BALANCER_ORACLE_WEIGHT_PRECISION`. Currently there are no controls that ensures that this will not take place.\n\n## Vulnerability Detail\n\nWhenever `balancerOracleWeight` is initialized with value that exceeds `BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION`, the _getOraclePairPrice() returned price becomes greater than actual price by the `oracleContext.balancerOracleWeight / BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION` ratio.\n\nIn particular, it can be magnitudes higher than Oracle reported values as the most probable scenario here is using one precision instead of another. For example, if `balancerOracleWeight` be supplied out of 18 decimals precision, the _getOraclePairPrice() will be `10^10` higher than actual values.\n\n## Impact\n\n_getOraclePairPrice() is used to obtain a price of a strategy in the units of the underlying token, i.e. the function supplies the marker to market strategy price for subsequent decision making in the Vault. The impact of such price being magnitudes off will be the liquidations of the healthy positions and vice versa, the prohibition of the liquidations of the healthy ones, i.e. scenarios leading to direct losses for Vaults' users.\n\nThe probability of setting `oracleContext.balancerOracleWeight` without regard to `BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION` isn't too low as there are several precision bases used in the system that can be easily messed up (it's actually the case for one of the example Vaults in this repo as it's shown in an another issue). As this is still a precondition, setting the severity to be medium.\n\n## Code Snippet\n\n_getOraclePairPrice() logic is based on an assumption that `balancerOracleWeight` is a part of the whole `BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION`:\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/pool/TwoTokenPoolUtils.sol#L66-L114\n\n```solidity\n    /// @notice Gets the oracle price pair price between two tokens using a weighted\n    /// average between a chainlink oracle and the balancer TWAP oracle.\n    /// @param poolContext oracle context variables\n    /// @param oracleContext oracle context variables\n    /// @param tradingModule address of the trading module\n    /// @return oraclePairPrice oracle price for the pair in 18 decimals\n    function _getOraclePairPrice(\n        TwoTokenPoolContext memory poolContext,\n        OracleContext memory oracleContext, \n        ITradingModule tradingModule\n    ) internal view returns (uint256 oraclePairPrice) {\n        // NOTE: this balancer price is denominated in 18 decimal places\n        uint256 balancerWeightedPrice;\n        if (oracleContext.balancerOracleWeight > 0) {\n            uint256 balancerPrice = BalancerUtils._getTimeWeightedOraclePrice(\n                address(poolContext.basePool.pool),\n                IPriceOracle.Variable.PAIR_PRICE,\n                oracleContext.oracleWindowInSeconds\n            );\n\n            if (poolContext.primaryIndex == 1) {\n                // If the primary index is the second token, we need to invert\n                // the balancer price.\n                balancerPrice = BalancerConstants.BALANCER_PRECISION_SQUARED / balancerPrice;\n            }\n\n            balancerWeightedPrice = balancerPrice * oracleContext.balancerOracleWeight;\n        }\n\n        uint256 chainlinkWeightedPrice;\n        if (oracleContext.balancerOracleWeight < BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION) {\n            (int256 rate, int256 decimals) = tradingModule.getOraclePrice(\n                poolContext.primaryToken, poolContext.secondaryToken\n            );\n            require(rate > 0);\n            require(decimals >= 0);\n\n            if (uint256(decimals) != BalancerConstants.BALANCER_PRECISION) {\n                rate = (rate * int256(BalancerConstants.BALANCER_PRECISION)) / decimals;\n            }\n\n            // No overflow in rate conversion, checked above\n            chainlinkWeightedPrice = uint256(rate) * \n                (BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION - oracleContext.balancerOracleWeight);\n        }\n\n        oraclePairPrice = (balancerWeightedPrice + chainlinkWeightedPrice) / \n            BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION;\n    }\n```\n\nAs `BALANCER_ORACLE_WEIGHT_PRECISION = 1e8`, the `BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION > 0` check is satisfied.\n    \nDifferent cases here are:\n\n* balancerOracleWeight == 0: ok\n\n* 0 < balancerOracleWeight < BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION: ok\n\n* balancerOracleWeight == BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION: ok\n\n* balancerOracleWeight > BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION:\n    wrong as the price now is\n    `oraclePairPrice = (balancerWeightedPrice + chainlinkWeightedPrice) / \n            BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION`\n    while it needs to be\n    `oraclePairPrice = (balancerWeightedPrice + chainlinkWeightedPrice) / \n            oracleContext.balancerOracleWeight`\n    as while `chainlinkWeightedPrice == 0`, the `balancerWeightedPrice` is weighted with `oracleContext.balancerOracleWeight`.\n\nThe latter case is possible as `oracleContext.balancerOracleWeight` is set via BalancerVaultStorage's setStrategyVaultSettings, that controls its value with a caller-supplied argument:\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/BalancerVaultStorage.sol#L25-L47\n\n```solidity\n    function setStrategyVaultSettings(\n        StrategyVaultSettings memory settings, \n        uint32 maxOracleQueryWindow,\n        uint16 balancerOracleWeight\n    ) internal {\n        require(settings.oracleWindowInSeconds <= maxOracleQueryWindow);\n        require(settings.settlementCoolDownInMinutes <= BalancerConstants.MAX_SETTLEMENT_COOLDOWN_IN_MINUTES);\n        require(settings.postMaturitySettlementCoolDownInMinutes <= BalancerConstants.MAX_SETTLEMENT_COOLDOWN_IN_MINUTES);\n        require(settings.maxRewardTradeSlippageLimitPercent <= BalancerConstants.SLIPPAGE_LIMIT_PRECISION);\n        require(settings.balancerOracleWeight <= balancerOracleWeight);\n        require(settings.maxBalancerPoolShare <= BalancerConstants.VAULT_PERCENT_BASIS);\n        require(settings.settlementSlippageLimitPercent <= BalancerConstants.SLIPPAGE_LIMIT_PRECISION);\n        require(settings.postMaturitySettlementSlippageLimitPercent <= BalancerConstants.SLIPPAGE_LIMIT_PRECISION);\n        require(settings.emergencySettlementSlippageLimitPercent <= BalancerConstants.SLIPPAGE_LIMIT_PRECISION);\n        require(settings.feePercentage <= BalancerConstants.VAULT_PERCENT_BASIS);\n        require(settings.oraclePriceDeviationLimitPercent <= BalancerConstants.VAULT_PERCENT_BASIS);\n\n        mapping(uint256 => StrategyVaultSettings) storage store = _settings();\n        // Hardcode to the zero slot\n        store[0] = settings;\n\n        emit BalancerEvents.StrategyVaultSettingsUpdated(settings);\n    }\n```\n\nThe value of `balancerOracleWeight` argument isn't controlled, it is up to Vault designer to set any value.\n\nThis way if for any reason `settings.balancerOracleWeight` in setStrategyVaultSettings() be set to be greater than `BALANCER_ORACLE_WEIGHT_PRECISION`, the _getOraclePairPrice() become up to magnitudes wrong. Say if decimals got messed up to the upside, say `balancerOracleWeight` can be set out of `18` decimals, while `BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION` is only `8`:\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/BalancerConstants.sol#L7-L12\n\n```solidity\n    uint256 internal constant BALANCER_ORACLE_WEIGHT_PRECISION = 1e8;\n    uint32 internal constant SLIPPAGE_LIMIT_PRECISION = 1e8;\n\n    /// @notice Precision for all percentages used by the vault\n    /// 1e4 = 100% (i.e. maxBalancerPoolShare)\n    uint16 internal constant VAULT_PERCENT_BASIS = 1e4;\n```\n\nIn this case _getOraclePairPrice() price becomes circa `10^10` times greater than the actual price the oracles reported.\n\n_getOraclePairPrice() is used for the current strategy evaluation via the following call sequences:\n\n`convertStrategyToUnderlying -> _convertStrategyToUnderlying, _executeSettlement -> _getTimeWeightedPrimaryBalance -> _getOraclePairPrice`,\n\n`settleVault, settleVaultEmergency -> _executeSettlement -> _getTimeWeightedPrimaryBalance -> _getOraclePairPrice`.\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe usage of `BALANCER_ORACLE_WEIGHT_PRECISION` is fixed in the logic, so setting a `balancerOracleWeight` outside it can easily lead to the malfunction of the approach. As TwoTokenPoolUtils library logic above needs to be uniform, while the Vaults can vary, the only way to avoid this is to control the setting so it always matches the logic.\n\nConsider controlling the `balancerOracleWeight` limit in setStrategyVaultSettings()\n\nUpper limit is straightforward, while lower is a kind of useful heuristic:\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/BalancerVaultStorage.sol#L25-L35\n\n```solidity\n    function setStrategyVaultSettings(\n        StrategyVaultSettings memory settings, \n        uint32 maxOracleQueryWindow,\n        uint16 balancerOracleWeight\n    ) internal {\n+       require(balancerOracleWeight == 0 ||\n                (balancerOracleWeight >= BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION / 100 &&\n                 balancerOracleWeight <= BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION));\n        require(settings.oracleWindowInSeconds <= maxOracleQueryWindow);\n        require(settings.settlementCoolDownInMinutes <= BalancerConstants.MAX_SETTLEMENT_COOLDOWN_IN_MINUTES);\n        require(settings.postMaturitySettlementCoolDownInMinutes <= BalancerConstants.MAX_SETTLEMENT_COOLDOWN_IN_MINUTES);\n        require(settings.maxRewardTradeSlippageLimitPercent <= BalancerConstants.SLIPPAGE_LIMIT_PRECISION);\n        require(settings.balancerOracleWeight <= balancerOracleWeight);\n        require(settings.maxBalancerPoolShare <= BalancerConstants.VAULT_PERCENT_BASIS);\n```\n\n## Discussion\n\n**jeffywu**\n\n@weitianjie2000 \n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/2",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/internal/pool/TwoTokenPoolUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {\n    TwoTokenPoolContext, \n    OracleContext, \n    PoolParams,\n    DepositParams,\n    DynamicTradeParams,\n    DepositTradeParams,\n    RedeemParams,\n    AuraStakingContext,\n    StrategyContext,\n    StrategyVaultSettings,\n    StrategyVaultState\n} from \"../../BalancerVaultTypes.sol\";\nimport {Deployments} from \"../../../../global/Deployments.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {Constants} from \"../../../../global/Constants.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {IAsset} from \"../../../../../interfaces/balancer/IBalancerVault.sol\";\nimport {TradeHandler} from \"../../../../trading/TradeHandler.sol\";\nimport {BalancerUtils} from \"../pool/BalancerUtils.sol\";\nimport {AuraStakingUtils} from \"../staking/AuraStakingUtils.sol\";\nimport {BalancerVaultStorage} from \"../BalancerVaultStorage.sol\";\nimport {StrategyUtils} from \"../strategy/StrategyUtils.sol\";\nimport {TwoTokenPoolUtils} from \"../pool/TwoTokenPoolUtils.sol\";\nimport {ITradingModule, Trade} from \"../../../../../interfaces/trading/ITradingModule.sol\";\nimport {IPriceOracle} from \"../../../../../interfaces/balancer/IPriceOracle.sol\";\nimport {TokenUtils, IERC20} from \"../../../../utils/TokenUtils.sol\";\n\nlibrary TwoTokenPoolUtils {\n    using TokenUtils for IERC20;\n    using TwoTokenPoolUtils for TwoTokenPoolContext;\n    using TradeHandler for Trade;\n    using TypeConvert for uint256;\n    using StrategyUtils for StrategyContext;\n    using AuraStakingUtils for AuraStakingContext;\n    using BalancerVaultStorage for StrategyVaultSettings;\n    using BalancerVaultStorage for StrategyVaultState;\n\n    /// @notice Returns parameters for joining and exiting Balancer pools\n    function _getPoolParams(\n        TwoTokenPoolContext memory context,\n        uint256 primaryAmount,\n        uint256 secondaryAmount,\n        bool isJoin\n    ) internal pure returns (PoolParams memory) {\n        IAsset[] memory assets = new IAsset[](2);\n        assets[context.primaryIndex] = IAsset(context.primaryToken);\n        assets[context.secondaryIndex] = IAsset(context.secondaryToken);\n\n        uint256[] memory amounts = new uint256[](2);\n        amounts[context.primaryIndex] = primaryAmount;\n        amounts[context.secondaryIndex] = secondaryAmount;\n\n        uint256 msgValue;\n        if (isJoin && assets[context.primaryIndex] == IAsset(Deployments.ETH_ADDRESS)) {\n            msgValue = amounts[context.primaryIndex];\n        }\n\n        return PoolParams(assets, amounts, msgValue);\n    }\n\n    /// @notice Gets the oracle price pair price between two tokens using a weighted\n    /// average between a chainlink oracle and the balancer TWAP oracle.\n    /// @param poolContext oracle context variables\n    /// @param oracleContext oracle context variables\n    /// @param tradingModule address of the trading module\n    /// @return oraclePairPrice oracle price for the pair in 18 decimals\n    function _getOraclePairPrice(\n        TwoTokenPoolContext memory poolContext,\n        OracleContext memory oracleContext, \n        ITradingModule tradingModule\n    ) internal view returns (uint256 oraclePairPrice) {\n        // NOTE: this balancer price is denominated in 18 decimal places\n        uint256 balancerWeightedPrice;\n        if (oracleContext.balancerOracleWeight > 0) {\n            uint256 balancerPrice = BalancerUtils._getTimeWeightedOraclePrice(\n                address(poolContext.basePool.pool),\n                IPriceOracle.Variable.PAIR_PRICE,\n                oracleContext.oracleWindowInSeconds\n            );\n\n            if (poolContext.primaryIndex == 1) {\n                // If the primary index is the second token, we need to invert\n                // the balancer price.\n                balancerPrice = BalancerConstants.BALANCER_PRECISION_SQUARED / balancerPrice;\n            }\n\n            balancerWeightedPrice = balancerPrice * oracleContext.balancerOracleWeight;\n        }\n\n        uint256 chainlinkWeightedPrice;\n        if (oracleContext.balancerOracleWeight < BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION) {\n            (int256 rate, int256 decimals) = tradingModule.getOraclePrice(\n                poolContext.primaryToken, poolContext.secondaryToken\n            );\n            require(rate > 0);\n            require(decimals >= 0);\n\n            if (uint256(decimals) != BalancerConstants.BALANCER_PRECISION) {\n                rate = (rate * int256(BalancerConstants.BALANCER_PRECISION)) / decimals;\n            }\n\n            // No overflow in rate conversion, checked above\n            chainlinkWeightedPrice = uint256(rate) * \n                (BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION - oracleContext.balancerOracleWeight);\n        }\n\n        oraclePairPrice = (balancerWeightedPrice + chainlinkWeightedPrice) / \n            BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION;\n    }\n\n    /// @notice Gets the time-weighted primary token balance for a given bptAmount\n    /// @dev Balancer pool needs to be fully initialized with at least 1024 trades\n    /// @param poolContext pool context variables\n    /// @param oracleContext oracle context variables\n    /// @param bptAmount amount of balancer pool lp tokens\n    /// @return primaryAmount primary token balance\n    function _getTimeWeightedPrimaryBalance(\n        TwoTokenPoolContext memory poolContext,\n        OracleContext memory oracleContext,\n        StrategyContext memory strategyContext,\n        uint256 bptAmount\n    ) internal view returns (uint256 primaryAmount) {\n        // Gets the BPT token price denominated in token index = 0\n        uint256 bptPrice = BalancerUtils._getTimeWeightedOraclePrice(\n            address(poolContext.basePool.pool),\n            IPriceOracle.Variable.BPT_PRICE,\n            oracleContext.oracleWindowInSeconds\n        );\n\n        uint256 pairPrice = _getOraclePairPrice(poolContext, oracleContext, strategyContext.tradingModule);\n        uint256 primaryPrecision = 10 ** poolContext.primaryDecimals;\n\n        if (poolContext.primaryIndex == 0) {\n            // Since bptPrice is always denominated in the first token, we can just multiply by\n            // the amount in this case. Both bptPrice and bptAmount are in 1e18 but we need to scale\n            // this back to the primary token's native precision.\n            // underlyingValue = (bptPrice * bptAmount * primaryPrecision) / (1e18 * 1e18)\n            primaryAmount = (bptPrice * bptAmount * primaryPrecision) / \n                BalancerConstants.BALANCER_PRECISION_SQUARED;\n        } else {\n            // The second token in the BPT pool is the price that we want to get. In this case, we need to\n            // convert secondaryTokenValue to underlyingValue using the pairPrice.\n            // Both bptPrice and bptAmount are in 1e18\n            uint256 secondaryAmount = (bptPrice * bptAmount) / BalancerConstants.BALANCER_PRECISION;\n\n            // And then normalizing to primary token precision we add:\n            // PrimaryAmount = (SecondaryAmount * primaryPrecision) / PairPrice\n            primaryAmount = (secondaryAmount * primaryPrecision) / pairPrice;\n        }\n    }\n\n    function _approveBalancerTokens(TwoTokenPoolContext memory poolContext, address bptSpender) internal {\n        IERC20(poolContext.primaryToken).checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n        IERC20(poolContext.secondaryToken).checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n        // Allow BPT spender to pull BALANCER_POOL_TOKEN\n        IERC20(address(poolContext.basePool.pool)).checkApprove(bptSpender, type(uint256).max);\n    }\n\n    /// @notice Trade primary currency for secondary if the trade is specified\n    function _tradePrimaryForSecondary(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        bytes memory data\n    ) private returns (uint256 primarySold, uint256 secondaryBought) {\n        (DepositTradeParams memory params) = abi.decode(data, (DepositTradeParams));\n\n        (primarySold, secondaryBought) = StrategyUtils._executeDynamicTradeExactIn({\n            params: params.tradeParams, \n            tradingModule: strategyContext.tradingModule, \n            sellToken: poolContext.primaryToken, \n            buyToken: poolContext.secondaryToken, \n            amount: params.tradeAmount\n        });\n    }\n\n    function _deposit(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        uint256 deposit,\n        DepositParams memory params\n    ) internal returns (uint256 strategyTokensMinted) {\n        uint256 secondaryAmount;\n        if (params.tradeData.length != 0) {\n            // Allows users to trade on a different DEX instead of Balancer when joining\n            (uint256 primarySold, uint256 secondaryBought) = _tradePrimaryForSecondary({\n                poolContext: poolContext,\n                strategyContext: strategyContext,\n                data: params.tradeData\n            });\n            deposit -= primarySold;\n            secondaryAmount = secondaryBought;\n        }\n\n        uint256 bptMinted = poolContext._joinPoolAndStake({\n            strategyContext: strategyContext,\n            stakingContext: stakingContext,\n            primaryAmount: deposit,\n            secondaryAmount: secondaryAmount,\n            minBPT: params.minBPT\n        });\n\n        strategyTokensMinted = strategyContext._convertBPTClaimToStrategyTokens(bptMinted);\n\n        // Update global supply count\n        strategyContext.vaultState.totalStrategyTokenGlobal += strategyTokensMinted.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n\n    function _sellSecondaryBalance(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        RedeemParams memory params,\n        uint256 secondaryBalance\n    ) private returns (uint256 primaryPurchased) {\n        (DynamicTradeParams memory tradeParams) = abi.decode(\n            params.secondaryTradeParams, (DynamicTradeParams)\n        );\n\n        ( /*uint256 amountSold */, primaryPurchased) = \n            StrategyUtils._executeDynamicTradeExactIn({\n                params: tradeParams,\n                tradingModule: strategyContext.tradingModule,\n                sellToken: poolContext.secondaryToken,\n                buyToken: poolContext.primaryToken,\n                amount: secondaryBalance\n            });\n    }\n\n    function _redeem(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        address account,\n        uint256 strategyTokens,\n        uint256 maturity,\n        RedeemParams memory params\n    ) internal returns (uint256 finalPrimaryBalance) {\n        uint256 bptClaim = strategyContext._convertStrategyTokensToBPTClaim(strategyTokens);\n\n        if (bptClaim == 0) return 0;\n\n        // Underlying token balances from exiting the pool\n        (uint256 primaryBalance, uint256 secondaryBalance)\n            = _unstakeAndExitPool(\n                poolContext, stakingContext, bptClaim, params.minPrimary, params.minSecondary\n            );\n\n        finalPrimaryBalance = primaryBalance;\n        if (secondaryBalance > 0) {\n            uint256 primaryPurchased = _sellSecondaryBalance(\n                poolContext, strategyContext, params, secondaryBalance\n            );\n\n            finalPrimaryBalance += primaryPurchased;\n        }\n\n        // Update global strategy token balance\n        strategyContext.vaultState.totalStrategyTokenGlobal -= strategyTokens.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n\n    function _joinPoolAndStake(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        uint256 primaryAmount,\n        uint256 secondaryAmount,\n        uint256 minBPT\n    ) internal returns (uint256 bptMinted) {\n        // prettier-ignore\n        PoolParams memory poolParams = poolContext._getPoolParams( \n            primaryAmount, \n            secondaryAmount,\n            true // isJoin\n        );\n\n        bptMinted = BalancerUtils._joinPoolExactTokensIn({\n            context: poolContext.basePool,\n            params: poolParams,\n            minBPT: minBPT\n        });\n\n        // Check BPT threshold to make sure our share of the pool is\n        // below maxBalancerPoolShare\n        uint256 bptThreshold = strategyContext.vaultSettings._bptThreshold(\n            poolContext.basePool.pool.totalSupply()\n        );\n        uint256 bptHeldAfterJoin = strategyContext.totalBPTHeld + bptMinted;\n        if (bptHeldAfterJoin > bptThreshold)\n            revert Errors.BalancerPoolShareTooHigh(bptHeldAfterJoin, bptThreshold);\n\n        // Transfer token to Aura protocol for boosted staking\n        stakingContext.auraBooster.deposit(stakingContext.auraPoolId, bptMinted, true); // stake = true\n    }\n\n    function _unstakeAndExitPool(\n        TwoTokenPoolContext memory poolContext,\n        AuraStakingContext memory stakingContext,\n        uint256 bptClaim,\n        uint256 minPrimary,\n        uint256 minSecondary\n    ) internal returns (uint256 primaryBalance, uint256 secondaryBalance) {\n        // Withdraw BPT tokens back to the vault for redemption\n        stakingContext.auraRewardPool.withdrawAndUnwrap(bptClaim, false); // claimRewards = false\n\n        uint256[] memory exitBalances = BalancerUtils._exitPoolExactBPTIn({\n            context: poolContext.basePool,\n            params: poolContext._getPoolParams(minPrimary, minSecondary, false), // isJoin = false\n            bptExitAmount: bptClaim\n        });\n        \n        (primaryBalance, secondaryBalance) \n            = (exitBalances[poolContext.primaryIndex], exitBalances[poolContext.secondaryIndex]);\n    }\n\n    /// @notice We value strategy tokens in terms of the primary balance. The time weighted\n    /// primary balance is used in order to prevent pool manipulation.\n    /// @param poolContext pool context variables\n    /// @param oracleContext oracle context variables\n    /// @param strategyTokenAmount amount of strategy tokens\n    /// @return underlyingValue underlying value of strategy tokens\n    function _convertStrategyToUnderlying(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        OracleContext memory oracleContext,\n        uint256 strategyTokenAmount\n    ) internal view returns (int256 underlyingValue) {\n        \n        uint256 bptClaim \n            = strategyContext._convertStrategyTokensToBPTClaim(strategyTokenAmount);\n\n        underlyingValue \n            = poolContext._getTimeWeightedPrimaryBalance(oracleContext, strategyContext, bptClaim).toInt();\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/internal/BalancerVaultStorage.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {StrategyVaultSettings, StrategyVaultState} from \"../BalancerVaultTypes.sol\";\nimport {BalancerEvents} from \"../BalancerEvents.sol\";\nimport {BalancerConstants} from \"./BalancerConstants.sol\";\n\nlibrary BalancerVaultStorage {\n    uint256 private constant STRATEGY_VAULT_SETTINGS_SLOT = 1000001;\n    uint256 private constant STRATEGY_VAULT_STATE_SLOT    = 1000002;\n\n    function _settings() private pure returns (mapping(uint256 => StrategyVaultSettings) storage store) {\n        assembly { store.slot := STRATEGY_VAULT_SETTINGS_SLOT }\n    }\n\n    function _state() private pure returns (mapping(uint256 => StrategyVaultState) storage store) {\n        assembly { store.slot := STRATEGY_VAULT_STATE_SLOT }\n    }\n\n    function getStrategyVaultSettings() internal view returns (StrategyVaultSettings memory) {\n        // Hardcode to the zero slot\n        return _settings()[0];\n    }\n\n    function setStrategyVaultSettings(\n        StrategyVaultSettings memory settings, \n        uint32 maxOracleQueryWindow,\n        uint16 balancerOracleWeight\n    ) internal {\n        require(settings.oracleWindowInSeconds <= maxOracleQueryWindow);\n        require(settings.settlementCoolDownInMinutes <= BalancerConstants.MAX_SETTLEMENT_COOLDOWN_IN_MINUTES);\n        require(settings.postMaturitySettlementCoolDownInMinutes <= BalancerConstants.MAX_SETTLEMENT_COOLDOWN_IN_MINUTES);\n        require(settings.maxRewardTradeSlippageLimitPercent <= BalancerConstants.SLIPPAGE_LIMIT_PRECISION);\n        require(settings.balancerOracleWeight <= balancerOracleWeight);\n        require(settings.maxBalancerPoolShare <= BalancerConstants.VAULT_PERCENT_BASIS);\n        require(settings.settlementSlippageLimitPercent <= BalancerConstants.SLIPPAGE_LIMIT_PRECISION);\n        require(settings.postMaturitySettlementSlippageLimitPercent <= BalancerConstants.SLIPPAGE_LIMIT_PRECISION);\n        require(settings.emergencySettlementSlippageLimitPercent <= BalancerConstants.SLIPPAGE_LIMIT_PRECISION);\n        require(settings.feePercentage <= BalancerConstants.VAULT_PERCENT_BASIS);\n        require(settings.oraclePriceDeviationLimitPercent <= BalancerConstants.VAULT_PERCENT_BASIS);\n\n        mapping(uint256 => StrategyVaultSettings) storage store = _settings();\n        // Hardcode to the zero slot\n        store[0] = settings;\n\n        emit BalancerEvents.StrategyVaultSettingsUpdated(settings);\n    }\n\n    function getStrategyVaultState() internal view returns (StrategyVaultState memory) {\n        // Hardcode to the zero slot\n        return _state()[0];\n    }\n\n    function setStrategyVaultState(StrategyVaultState memory state) internal {\n        mapping(uint256 => StrategyVaultState) storage store = _state();\n        // Hardcode to the zero slot\n        store[0] = state;\n    }\n\n    function _bptThreshold(StrategyVaultSettings memory strategyVaultSettings, uint256 totalBPTSupply) \n        internal pure returns (uint256) {\n        return (totalBPTSupply * strategyVaultSettings.maxBalancerPoolShare) / BalancerConstants.VAULT_PERCENT_BASIS;\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/internal/BalancerConstants.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.8.15;\n\nlibrary BalancerConstants {\n    uint256 internal constant BALANCER_PRECISION = 1e18;\n    uint256 internal constant BALANCER_PRECISION_SQUARED = 1e36;\n    uint256 internal constant BALANCER_ORACLE_WEIGHT_PRECISION = 1e8;\n    uint32 internal constant SLIPPAGE_LIMIT_PRECISION = 1e8;\n\n    /// @notice Precision for all percentages used by the vault\n    /// 1e4 = 100% (i.e. maxBalancerPoolShare)\n    uint16 internal constant VAULT_PERCENT_BASIS = 1e4;\n    /// @notice Buffer percentage between the desired share of the Balancer pool\n    /// and the maximum share of the pool allowed by maxBalancerPoolShare 1e4 = 100%, 8e3 = 80%\n    uint16 internal constant BALANCER_POOL_SHARE_BUFFER = 8e3;\n    /// @notice Max settlement cool down period allowed (1 day)\n    uint16 internal constant MAX_SETTLEMENT_COOLDOWN_IN_MINUTES = 24 * 60;\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/internal/BalancerVaultStorage.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {StrategyVaultSettings, StrategyVaultState} from \"../BalancerVaultTypes.sol\";\nimport {BalancerEvents} from \"../BalancerEvents.sol\";\nimport {BalancerConstants} from \"./BalancerConstants.sol\";\n\nlibrary BalancerVaultStorage {\n    uint256 private constant STRATEGY_VAULT_SETTINGS_SLOT = 1000001;\n    uint256 private constant STRATEGY_VAULT_STATE_SLOT    = 1000002;\n\n    function _settings() private pure returns (mapping(uint256 => StrategyVaultSettings) storage store) {\n        assembly { store.slot := STRATEGY_VAULT_SETTINGS_SLOT }\n    }\n\n    function _state() private pure returns (mapping(uint256 => StrategyVaultState) storage store) {\n        assembly { store.slot := STRATEGY_VAULT_STATE_SLOT }\n    }\n\n    function getStrategyVaultSettings() internal view returns (StrategyVaultSettings memory) {\n        // Hardcode to the zero slot\n        return _settings()[0];\n    }\n\n    function setStrategyVaultSettings(\n        StrategyVaultSettings memory settings, \n        uint32 maxOracleQueryWindow,\n        uint16 balancerOracleWeight\n    ) internal {\n        require(settings.oracleWindowInSeconds <= maxOracleQueryWindow);\n        require(settings.settlementCoolDownInMinutes <= BalancerConstants.MAX_SETTLEMENT_COOLDOWN_IN_MINUTES);\n        require(settings.postMaturitySettlementCoolDownInMinutes <= BalancerConstants.MAX_SETTLEMENT_COOLDOWN_IN_MINUTES);\n        require(settings.maxRewardTradeSlippageLimitPercent <= BalancerConstants.SLIPPAGE_LIMIT_PRECISION);\n        require(settings.balancerOracleWeight <= balancerOracleWeight);\n        require(settings.maxBalancerPoolShare <= BalancerConstants.VAULT_PERCENT_BASIS);\n        require(settings.settlementSlippageLimitPercent <= BalancerConstants.SLIPPAGE_LIMIT_PRECISION);\n        require(settings.postMaturitySettlementSlippageLimitPercent <= BalancerConstants.SLIPPAGE_LIMIT_PRECISION);\n        require(settings.emergencySettlementSlippageLimitPercent <= BalancerConstants.SLIPPAGE_LIMIT_PRECISION);\n        require(settings.feePercentage <= BalancerConstants.VAULT_PERCENT_BASIS);\n        require(settings.oraclePriceDeviationLimitPercent <= BalancerConstants.VAULT_PERCENT_BASIS);\n\n        mapping(uint256 => StrategyVaultSettings) storage store = _settings();\n        // Hardcode to the zero slot\n        store[0] = settings;\n\n        emit BalancerEvents.StrategyVaultSettingsUpdated(settings);\n    }\n\n    function getStrategyVaultState() internal view returns (StrategyVaultState memory) {\n        // Hardcode to the zero slot\n        return _state()[0];\n    }\n\n    function setStrategyVaultState(StrategyVaultState memory state) internal {\n        mapping(uint256 => StrategyVaultState) storage store = _state();\n        // Hardcode to the zero slot\n        store[0] = state;\n    }\n\n    function _bptThreshold(StrategyVaultSettings memory strategyVaultSettings, uint256 totalBPTSupply) \n        internal pure returns (uint256) {\n        return (totalBPTSupply * strategyVaultSettings.maxBalancerPoolShare) / BalancerConstants.VAULT_PERCENT_BASIS;\n    }\n}"
    }
  ]
}