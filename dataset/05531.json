{
  "Title": "[M-12] User funds sent in excess are not refunded",
  "Content": "\n\n*Note: this finding was reported via the winning [Automated Findings report](https://gist.github.com/code423n4/b979a00ee3ea3f7d36ee39e2a536ba8a). It was declared out of scope for the audit, but is being included here for completeness.*\n\nThese functions lack a refund mechanism for excess Ether sent by the caller, resulting in locked funds within the contract. To rectify this, the function should be modified to implement a refund for any surplus amount.\n\n*There are 3 instances of this issue.*\n\n```solidity\nFile: smart-contracts/MinterContract.sol\n\n233: \t\t        require(msg.value >= (getPrice(col) * _numberOfTokens), \"Wrong ETH\");\n234: \t\t        for(uint256 i = 0; i < _numberOfTokens; i++) {\n235: \t\t            uint256 mintIndex = gencore.viewTokensIndexMin(col) + gencore.viewCirSupply(col);\n236: \t\t            gencore.mint(mintIndex, mintingAddress, _mintTo, tokData, _saltfun_o, col, phase);\n237: \t\t        }\n238: \t\t        collectionTotalAmount[col] = collectionTotalAmount[col] + msg.value;\n\n266: \t\t        require(msg.value >= getPrice(_mintCollectionID), \"Wrong ETH\");\n267: \t\t        uint256 mintIndex = gencore.viewTokensIndexMin(_mintCollectionID) + gencore.viewCirSupply(_mintCollectionID);\n268: \t\t        // burn and mint token\n269: \t\t        address burner = msg.sender;\n270: \t\t        gencore.burnToMint(mintIndex, _burnCollectionID, _tokenId, _mintCollectionID, _saltfun_o, burner);\n271: \t\t        collectionTotalAmount[_mintCollectionID] = collectionTotalAmount[_mintCollectionID] + msg.value;\n\n361: \t\t        require(msg.value >= (getPrice(col) * 1), \"Wrong ETH\");\n362: \t\t        uint256 mintIndex = gencore.viewTokensIndexMin(col) + gencore.viewCirSupply(col);\n363: \t\t        gencore.mint(mintIndex, mintingAddress, ownerOfToken, tokData, _saltfun_o, col, phase);\n364: \t\t        collectionTotalAmount[col] = collectionTotalAmount[col] + msg.value;\n```\n\n[[233-238](https://github.com/code-423n4/2023-10-nextgen/blob/08a56bacd286ee52433670f3bb73a0e4a4525dd4/smart-contracts/MinterContract.sol#L233-L238), [266-271](https://github.com/code-423n4/2023-10-nextgen/blob/08a56bacd286ee52433670f3bb73a0e4a4525dd4/smart-contracts/MinterContract.sol#L266-L271), [361-364](https://github.com/code-423n4/2023-10-nextgen/blob/08a56bacd286ee52433670f3bb73a0e4a4525dd4/smart-contracts/MinterContract.sol#L361-L364)]\n\n**[a2rocket (NextGen) confirmed](https://gist.github.com/code423n4/b979a00ee3ea3f7d36ee39e2a536ba8a?permalink_comment_id=4797585#gistcomment-4797585)**\n\n**[0xsomeone (judge) commented](https://gist.github.com/code423n4/b979a00ee3ea3f7d36ee39e2a536ba8a?permalink_comment_id=4797627#gistcomment-4797627):**\n> Important and valid.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-nextgen",
  "Code": [
    {
      "filename": "smart-contracts/MinterContract.sol",
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n *\n *  @title: NextGen Minter Contract\n *  @date: 18-October-2023 \n *  @version: 1.8\n *  @author: 6529 team\n */\n\npragma solidity ^0.8.19;\n\nimport \"./INextGenCore.sol\";\nimport \"./Ownable.sol\";\nimport \"./IDelegationManagementContract.sol\";\nimport \"./MerkleProof.sol\";\nimport \"./INextGenAdmins.sol\";\nimport \"./IERC721.sol\";\n\ncontract NextGenMinterContract is Ownable {\n\n    // total amount collected during minting from collections\n    mapping (uint256 => uint256) public collectionTotalAmount;\n\n    // sales Option3 timestamp of last mint\n    mapping (uint256 => uint) public lastMintDate;\n\n    // burn or swap address for external collections\n    mapping (bytes32 => address) public burnOrSwapAddress;\n\n    // burn or swap external collection ids\n    mapping (bytes32 => uint256[2]) private burnOrSwapIds;\n\n    // mint tokens on a specific collection after burning a token on a NextGen collection\n    mapping (uint256 => mapping (uint256 => bool)) public burnToMintCollections;\n\n    // mint tokens on a specific collection after burning a token on an external collection\n    mapping (bytes32 => mapping (uint256 => bool)) public burnExternalToMintCollections;\n\n    // check if minting costs were set\n    mapping (uint256 => bool) private setMintingCosts;\n\n    // collectionPhasesData struct declaration\n    struct collectionPhasesDataStructure {\n        uint allowlistStartTime;\n        uint allowlistEndTime;\n        uint publicStartTime;\n        uint publicEndTime;\n        bytes32 merkleRoot;\n        uint256 collectionMintCost;\n        uint256 collectionEndMintCost;\n        uint256 timePeriod;\n        uint256 rate;\n        uint8 salesOption;\n        address delAddress;\n    }\n\n    // mapping of collectionPhasesData struct\n    mapping (uint256 => collectionPhasesDataStructure) private collectionPhases;\n\n    // royalties primary splits structure\n\n    struct royaltiesPrimarySplits {\n        uint256 artistPercentage;\n        uint256 teamPercentage;\n    }\n\n    // mapping of royaltiesPrimarySplits struct\n\n    mapping (uint256 => royaltiesPrimarySplits) private collectionRoyaltiesPrimarySplits;\n\n    // artists primary Addresses\n    struct collectionPrimaryAddresses {\n        address primaryAdd1;\n        address primaryAdd2;\n        address primaryAdd3;\n        uint256 add1Percentage;\n        uint256 add2Percentage;\n        uint256 add3Percentage;\n        bool status;\n    }\n\n    // mapping of collectionPrimaryAndSecondaryAddresses struct\n    mapping (uint256 => collectionPrimaryAddresses) private collectionArtistPrimaryAddresses;\n\n    // royalties secondary splits structure\n\n    struct royaltiesSecondarySplits {\n        uint256 artistPercentage;\n        uint256 teamPercentage;\n    }\n\n    // mapping of royaltiesSecondarySplits struct\n\n    mapping (uint256 => royaltiesSecondarySplits) private collectionRoyaltiesSecondarySplits;\n\n    // artists secondary Addresses\n    struct collectionSecondaryAddresses {\n        address secondaryAdd1;\n        address secondaryAdd2;\n        address secondaryAdd3;\n        uint256 add1Percentage;\n        uint256 add2Percentage;\n        uint256 add3Percentage;\n        bool status;\n    }\n\n    // mapping of collectionSecondaryAddresses struct\n    mapping (uint256 => collectionSecondaryAddresses) private collectionArtistSecondaryAddresses;\n\n    // mapping of token id and auction end time\n    mapping (uint256 => uint) private mintToAuctionData;\n\n    // mapping of token id and status\n    mapping (uint256 => bool) private mintToAuctionStatus;\n\n    //external contracts declaration\n    INextGenCore public gencore;\n    IDelegationManagementContract private dmc;\n    INextGenAdmins private adminsContract;\n\n    // events\n\n    event PayArtist(address indexed _add, bool status, uint256 indexed funds);\n    event PayTeam(address indexed _add, bool status, uint256 indexed funds);\n    event Withdraw(address indexed _add, bool status, uint256 indexed funds);\n\n    // constructor\n    constructor (address _gencore, address _del, address _adminsContract) {\n        gencore = INextGenCore(_gencore);\n        dmc = IDelegationManagementContract(_del);\n        adminsContract = INextGenAdmins(_adminsContract);\n    }\n\n    // certain functions can only be called by an admin or the artist\n    modifier ArtistOrAdminRequired(uint256 _collectionID, bytes4 _selector) {\n      require(msg.sender == gencore.retrieveArtistAddress(_collectionID) || adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true, \"Not allowed\");\n      _;\n    }\n\n    // certain functions can only be called by a global or function admin\n\n    modifier FunctionAdminRequired(bytes4 _selector) {\n      require(adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true , \"Not allowed\");\n      _;\n    }\n\n    // certain functions can only be called by a collection, global or function admin\n\n    modifier CollectionAdminRequired(uint256 _collectionID, bytes4 _selector) {\n      require(adminsContract.retrieveCollectionAdmin(msg.sender,_collectionID) == true || adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true, \"Not allowed\");\n      _;\n    }\n\n    // function to add a collection's minting costs\n\n    function setCollectionCosts(uint256 _collectionID, uint256 _collectionMintCost, uint256 _collectionEndMintCost, uint256 _rate, uint256 _timePeriod, uint8 _salesOption, address _delAddress) public CollectionAdminRequired(_collectionID, this.setCollectionCosts.selector) {\n        require(gencore.retrievewereDataAdded(_collectionID) == true, \"Add data\");\n        collectionPhases[_collectionID].collectionMintCost = _collectionMintCost;\n        collectionPhases[_collectionID].collectionEndMintCost = _collectionEndMintCost;\n        collectionPhases[_collectionID].rate = _rate;\n        collectionPhases[_collectionID].timePeriod = _timePeriod;\n        collectionPhases[_collectionID].salesOption = _salesOption;\n        collectionPhases[_collectionID].delAddress = _delAddress;\n        setMintingCosts[_collectionID] = true;\n    }\n\n    // function to add a collection's start/end times and merkleroot\n\n    function setCollectionPhases(uint256 _collectionID, uint _allowlistStartTime, uint _allowlistEndTime, uint _publicStartTime, uint _publicEndTime, bytes32 _merkleRoot) public CollectionAdminRequired(_collectionID, this.setCollectionPhases.selector) {\n        require(setMintingCosts[_collectionID] == true, \"Set Minting Costs\");\n        collectionPhases[_collectionID].allowlistStartTime = _allowlistStartTime;\n        collectionPhases[_collectionID].allowlistEndTime = _allowlistEndTime;\n        collectionPhases[_collectionID].merkleRoot = _merkleRoot;\n        collectionPhases[_collectionID].publicStartTime = _publicStartTime;\n        collectionPhases[_collectionID].publicEndTime = _publicEndTime;\n    }\n\n    // airdrop function\n    \n    function airDropTokens(address[] memory _recipients, string[] memory _tokenData, uint256[] memory _saltfun_o, uint256 _collectionID, uint256[] memory _numberOfTokens) public FunctionAdminRequired(this.airDropTokens.selector) {\n        require(gencore.retrievewereDataAdded(_collectionID) == true, \"Add data\");\n        uint256 collectionTokenMintIndex;\n        for (uint256 y=0; y< _recipients.length; y++) {\n            collectionTokenMintIndex = gencore.viewTokensIndexMin(_collectionID) + gencore.viewCirSupply(_collectionID) + _numberOfTokens[y] - 1;\n            require(collectionTokenMintIndex <= gencore.viewTokensIndexMax(_collectionID), \"No supply\");\n            for(uint256 i = 0; i < _numberOfTokens[y]; i++) {\n                uint256 mintIndex = gencore.viewTokensIndexMin(_collectionID) + gencore.viewCirSupply(_collectionID);\n                gencore.airDropTokens(mintIndex, _recipients[y], _tokenData[y], _saltfun_o[y], _collectionID);\n            }\n        }\n    }\n\n    // mint function\n\n    function mint(uint256 _collectionID, uint256 _numberOfTokens, uint256 _maxAllowance, string memory _tokenData, address _mintTo, bytes32[] calldata merkleProof, address _delegator, uint256 _saltfun_o) public payable {\n        require(setMintingCosts[_collectionID] == true, \"Set Minting Costs\");\n        uint256 col = _collectionID;\n        address mintingAddress;\n        uint256 phase;\n        string memory tokData = _tokenData;\n        if (block.timestamp >= collectionPhases[col].allowlistStartTime && block.timestamp <= collectionPhases[col].allowlistEndTime) {\n            phase = 1;\n            bytes32 node;\n            if (_delegator != 0x0000000000000000000000000000000000000000) {\n                bool isAllowedToMint;\n                isAllowedToMint = dmc.retrieveGlobalStatusOfDelegation(_delegator, 0x8888888888888888888888888888888888888888, msg.sender, 1) || dmc.retrieveGlobalStatusOfDelegation(_delegator, 0x8888888888888888888888888888888888888888, msg.sender, 2);\n                if (isAllowedToMint == false) {\n                isAllowedToMint = dmc.retrieveGlobalStatusOfDelegation(_delegator, collectionPhases[col].delAddress, msg.sender, 1) || dmc.retrieveGlobalStatusOfDelegation(_delegator, collectionPhases[col].delAddress, msg.sender, 2);    \n                }\n                require(isAllowedToMint == true, \"No delegation\");\n                node = keccak256(abi.encodePacked(_delegator, _maxAllowance, tokData));\n                require(_maxAllowance >= gencore.retrieveTokensMintedALPerAddress(col, _delegator) + _numberOfTokens, \"AL limit\");\n                mintingAddress = _delegator;\n            } else {\n                node = keccak256(abi.encodePacked(msg.sender, _maxAllowance, tokData));\n                require(_maxAllowance >= gencore.retrieveTokensMintedALPerAddress(col, msg.sender) + _numberOfTokens, \"AL limit\");\n                mintingAddress = msg.sender;\n            }\n            require(MerkleProof.verifyCalldata(merkleProof, collectionPhases[col].merkleRoot, node), 'invalid proof');\n        } else if (block.timestamp >= collectionPhases[col].publicStartTime && block.timestamp <= collectionPhases[col].publicEndTime) {\n            phase = 2;\n            require(_numberOfTokens <= gencore.viewMaxAllowance(col), \"Change no of tokens\");\n            require(gencore.retrieveTokensMintedPublicPerAddress(col, msg.sender) + _numberOfTokens <= gencore.viewMaxAllowance(col), \"Max\");\n            mintingAddress = msg.sender;\n            tokData = '\"public\"';\n        } else {\n            revert(\"No minting\");\n        }\n        uint256 collectionTokenMintIndex;\n        collectionTokenMintIndex = gencore.viewTokensIndexMin(col) + gencore.viewCirSupply(col) + _numberOfTokens - 1;\n        require(collectionTokenMintIndex <= gencore.viewTokensIndexMax(col), \"No supply\");\n        require(msg.value >= (getPrice(col) * _numberOfTokens), \"Wrong ETH\");\n        for(uint256 i = 0; i < _numberOfTokens; i++) {\n            uint256 mintIndex = gencore.viewTokensIndexMin(col) + gencore.viewCirSupply(col);\n            gencore.mint(mintIndex, mintingAddress, _mintTo, tokData, _saltfun_o, col, phase);\n        }\n        collectionTotalAmount[col] = collectionTotalAmount[col] + msg.value;\n        // control mechanism for sale option 3\n        if (collectionPhases[col].salesOption == 3) {\n            uint timeOfLastMint;\n            if (lastMintDate[col] == 0) {\n                // for public sale set the allowlist the same time as publicsale\n                timeOfLastMint = collectionPhases[col].allowlistStartTime - collectionPhases[col].timePeriod;\n            } else {\n                timeOfLastMint =  lastMintDate[col];\n            }\n            // uint calculates if period has passed in order to allow minting\n            uint tDiff = (block.timestamp - timeOfLastMint) / collectionPhases[col].timePeriod;\n            // users are able to mint after a day passes\n            require(tDiff>=1 && _numberOfTokens == 1, \"1 mint/period\");\n            lastMintDate[col] = collectionPhases[col].allowlistStartTime + (collectionPhases[col].timePeriod * (gencore.viewCirSupply(col) - 1));\n        }\n    }\n\n    // burn to mint function (does not require contract approval)\n\n    function burnToMint(uint256 _burnCollectionID, uint256 _tokenId, uint256 _mintCollectionID, uint256 _saltfun_o) public payable {\n        require(burnToMintCollections[_burnCollectionID][_mintCollectionID] == true, \"Initialize burn\");\n        require(block.timestamp >= collectionPhases[_mintCollectionID].publicStartTime && block.timestamp<=collectionPhases[_mintCollectionID].publicEndTime,\"No minting\");\n        require ((_tokenId >= gencore.viewTokensIndexMin(_burnCollectionID)) && (_tokenId <= gencore.viewTokensIndexMax(_burnCollectionID)), \"col/token id error\");\n        // minting new token\n        uint256 collectionTokenMintIndex;\n        collectionTokenMintIndex = gencore.viewTokensIndexMin(_mintCollectionID) + gencore.viewCirSupply(_mintCollectionID);\n        require(collectionTokenMintIndex <= gencore.viewTokensIndexMax(_mintCollectionID), \"No supply\");\n        require(msg.value >= getPrice(_mintCollectionID), \"Wrong ETH\");\n        uint256 mintIndex = gencore.viewTokensIndexMin(_mintCollectionID) + gencore.viewCirSupply(_mintCollectionID);\n        // burn and mint token\n        address burner = msg.sender;\n        gencore.burnToMint(mintIndex, _burnCollectionID, _tokenId, _mintCollectionID, _saltfun_o, burner);\n        collectionTotalAmount[_mintCollectionID] = collectionTotalAmount[_mintCollectionID] + msg.value;\n    }\n\n    // mint and auction\n    \n    function mintAndAuction(address _recipient, string memory _tokenData, uint256 _saltfun_o, uint256 _collectionID, uint _auctionEndTime) public FunctionAdminRequired(this.mintAndAuction.selector) {\n        require(gencore.retrievewereDataAdded(_collectionID) == true, \"Add data\");\n        uint256 collectionTokenMintIndex;\n        collectionTokenMintIndex = gencore.viewTokensIndexMin(_collectionID) + gencore.viewCirSupply(_collectionID);\n        require(collectionTokenMintIndex <= gencore.viewTokensIndexMax(_collectionID), \"No supply\");\n        uint256 mintIndex = gencore.viewTokensIndexMin(_collectionID) + gencore.viewCirSupply(_collectionID);\n        gencore.airDropTokens(mintIndex, _recipient, _tokenData, _saltfun_o, _collectionID);\n        uint timeOfLastMint;\n        // check 1 per period\n        if (lastMintDate[_collectionID] == 0) {\n        // for public sale set the allowlist the same time as publicsale\n            timeOfLastMint = collectionPhases[_collectionID].allowlistStartTime - collectionPhases[_collectionID].timePeriod;\n        } else {\n            timeOfLastMint =  lastMintDate[_collectionID];\n        }\n        // uint calculates if period has passed in order to allow minting\n        uint tDiff = (block.timestamp - timeOfLastMint) / collectionPhases[_collectionID].timePeriod;\n        // users are able to mint after a day passes\n        require(tDiff>=1, \"1 mint/period\");\n        lastMintDate[_collectionID] = collectionPhases[_collectionID].allowlistStartTime + (collectionPhases[_collectionID].timePeriod * (gencore.viewCirSupply(_collectionID) - 1));\n        mintToAuctionData[mintIndex] = _auctionEndTime;\n        mintToAuctionStatus[mintIndex] = true;\n    }\n\n    // function to update allowlist mint delegation collection\n\n    function updateDelegationCollection(uint256 _collectionID, address _collectionAddress) public FunctionAdminRequired(this.updateDelegationCollection.selector) { \n        collectionPhases[_collectionID].delAddress = _collectionAddress;\n    }\n\n    // function to initialize burn to mint for NextGen collections\n\n    function initializeBurn(uint256 _burnCollectionID, uint256 _mintCollectionID, bool _status) public FunctionAdminRequired(this.initializeBurn.selector) { \n        require((gencore.retrievewereDataAdded(_burnCollectionID) == true) && (gencore.retrievewereDataAdded(_mintCollectionID) == true), \"No data\");\n        burnToMintCollections[_burnCollectionID][_mintCollectionID] = _status;\n    }\n\n    // function to initialize external burn or swap to mint (requires contract approval)\n\n    function initializeExternalBurnOrSwap(address _erc721Collection, uint256 _burnCollectionID, uint256 _mintCollectionID, uint256 _tokmin, uint256 _tokmax, address _burnOrSwapAddress, bool _status) public FunctionAdminRequired(this.initializeExternalBurnOrSwap.selector) { \n        bytes32 externalCol = keccak256(abi.encodePacked(_erc721Collection,_burnCollectionID));\n        require((gencore.retrievewereDataAdded(_mintCollectionID) == true), \"No data\");\n        burnExternalToMintCollections[externalCol][_mintCollectionID] = _status;\n        burnOrSwapAddress[externalCol] = _burnOrSwapAddress;\n        burnOrSwapIds[externalCol][0] = _tokmin;\n        burnOrSwapIds[externalCol][1] = _tokmax;\n    }\n\n    // burn or swap to mint (requires contract approval)\n\n    function burnOrSwapExternalToMint(address _erc721Collection, uint256 _burnCollectionID, uint256 _tokenId, uint256 _mintCollectionID, string memory _tokenData, bytes32[] calldata merkleProof, uint256 _saltfun_o) public payable {\n        bytes32 externalCol = keccak256(abi.encodePacked(_erc721Collection,_burnCollectionID));\n        require(burnExternalToMintCollections[externalCol][_mintCollectionID] == true, \"Initialize external burn\");\n        require(setMintingCosts[_mintCollectionID] == true, \"Set Minting Costs\");\n        address ownerOfToken = IERC721(_erc721Collection).ownerOf(_tokenId);\n        if (msg.sender != ownerOfToken) {\n            bool isAllowedToMint;\n            isAllowedToMint = dmc.retrieveGlobalStatusOfDelegation(ownerOfToken, 0x8888888888888888888888888888888888888888, msg.sender, 1) || dmc.retrieveGlobalStatusOfDelegation(ownerOfToken, 0x8888888888888888888888888888888888888888, msg.sender, 2);\n            if (isAllowedToMint == false) {\n            isAllowedToMint = dmc.retrieveGlobalStatusOfDelegation(ownerOfToken, _erc721Collection, msg.sender, 1) || dmc.retrieveGlobalStatusOfDelegation(ownerOfToken, _erc721Collection, msg.sender, 2);    \n            }\n            require(isAllowedToMint == true, \"No delegation\");\n        }\n        require(_tokenId >= burnOrSwapIds[externalCol][0] && _tokenId <= burnOrSwapIds[externalCol][1], \"Token id does not match\");\n        IERC721(_erc721Collection).safeTransferFrom(ownerOfToken, burnOrSwapAddress[externalCol], _tokenId);\n        uint256 col = _mintCollectionID;\n        address mintingAddress;\n        uint256 phase;\n        string memory tokData = _tokenData;\n        if (block.timestamp >= collectionPhases[col].allowlistStartTime && block.timestamp <= collectionPhases[col].allowlistEndTime) {\n            phase = 1;\n            bytes32 node;\n            node = keccak256(abi.encodePacked(_tokenId, tokData));\n            mintingAddress = ownerOfToken;\n            require(MerkleProof.verifyCalldata(merkleProof, collectionPhases[col].merkleRoot, node), 'invalid proof');            \n        } else if (block.timestamp >= collectionPhases[col].publicStartTime && block.timestamp <= collectionPhases[col].publicEndTime) {\n            phase = 2;\n            mintingAddress = ownerOfToken;\n            tokData = '\"public\"';\n        } else {\n            revert(\"No minting\");\n        }\n        uint256 collectionTokenMintIndex;\n        collectionTokenMintIndex = gencore.viewTokensIndexMin(col) + gencore.viewCirSupply(col);\n        require(collectionTokenMintIndex <= gencore.viewTokensIndexMax(col), \"No supply\");\n        require(msg.value >= (getPrice(col) * 1), \"Wrong ETH\");\n        uint256 mintIndex = gencore.viewTokensIndexMin(col) + gencore.viewCirSupply(col);\n        gencore.mint(mintIndex, mintingAddress, ownerOfToken, tokData, _saltfun_o, col, phase);\n        collectionTotalAmount[col] = collectionTotalAmount[col] + msg.value;\n    }\n\n    // function to set primary splits\n\n    function setPrimaryAndSecondarySplits(uint256 _collectionID, uint256 _artistPrSplit, uint256 _teamPrSplit, uint256 _artistSecSplit, uint256 _teamSecSplit) public FunctionAdminRequired(this.setPrimaryAndSecondarySplits.selector) {\n        require(_artistPrSplit + _teamPrSplit == 100, \"splits need to be 100%\");\n        require(_artistSecSplit + _teamSecSplit == 100, \"splits need to be 100%\");\n        collectionRoyaltiesPrimarySplits[_collectionID].artistPercentage = _artistPrSplit;\n        collectionRoyaltiesPrimarySplits[_collectionID].teamPercentage = _teamPrSplit;\n        collectionRoyaltiesSecondarySplits[_collectionID].artistPercentage = _artistSecSplit;\n        collectionRoyaltiesSecondarySplits[_collectionID].teamPercentage = _teamSecSplit;\n    }\n\n    // function to propose primary addresses and percentages for each address\n\n    function proposePrimaryAddressesAndPercentages(uint256 _collectionID, address _primaryAdd1, address _primaryAdd2, address _primaryAdd3, uint256 _add1Percentage, uint256 _add2Percentage, uint256 _add3Percentage) public ArtistOrAdminRequired(_collectionID, this.proposePrimaryAddressesAndPercentages.selector) {\n        require (collectionArtistPrimaryAddresses[_collectionID].status == false, \"Already approved\");\n        require (_add1Percentage + _add2Percentage + _add3Percentage == collectionRoyaltiesPrimarySplits[_collectionID].artistPercentage, \"Check %\");\n        collectionArtistPrimaryAddresses[_collectionID].primaryAdd1 = _primaryAdd1;\n        collectionArtistPrimaryAddresses[_collectionID].primaryAdd2 = _primaryAdd2;\n        collectionArtistPrimaryAddresses[_collectionID].primaryAdd3 = _primaryAdd3;\n        collectionArtistPrimaryAddresses[_collectionID].add1Percentage = _add1Percentage;\n        collectionArtistPrimaryAddresses[_collectionID].add2Percentage = _add2Percentage;\n        collectionArtistPrimaryAddresses[_collectionID].add3Percentage = _add3Percentage;\n        collectionArtistPrimaryAddresses[_collectionID].status = false;\n    }\n\n    // function to propose secondary addresses and percentages for each address\n\n    function proposeSecondaryAddressesAndPercentages(uint256 _collectionID, address _secondaryAdd1, address _secondaryAdd2, address _secondaryAdd3, uint256 _add1Percentage, uint256 _add2Percentage, uint256 _add3Percentage) public ArtistOrAdminRequired(_collectionID, this.proposeSecondaryAddressesAndPercentages.selector) {\n        require (collectionArtistSecondaryAddresses[_collectionID].status == false, \"Already approved\");\n        require (_add1Percentage + _add2Percentage + _add3Percentage == collectionRoyaltiesSecondarySplits[_collectionID].artistPercentage, \"Check %\");\n        collectionArtistSecondaryAddresses[_collectionID].secondaryAdd1 = _secondaryAdd1;\n        collectionArtistSecondaryAddresses[_collectionID].secondaryAdd2 = _secondaryAdd2;\n        collectionArtistSecondaryAddresses[_collectionID].secondaryAdd3 = _secondaryAdd3;\n        collectionArtistSecondaryAddresses[_collectionID].add1Percentage = _add1Percentage;\n        collectionArtistSecondaryAddresses[_collectionID].add2Percentage = _add2Percentage;\n        collectionArtistSecondaryAddresses[_collectionID].add3Percentage = _add3Percentage;\n        collectionArtistSecondaryAddresses[_collectionID].status = false;\n    }\n\n    // function to accept primary addresses and percentages\n\n    function acceptAddressesAndPercentages(uint256 _collectionID, bool _statusPrimary, bool _statusSecondary) public FunctionAdminRequired(this.acceptAddressesAndPercentages.selector) {\n        collectionArtistPrimaryAddresses[_collectionID].status = _statusPrimary;\n        collectionArtistSecondaryAddresses[_collectionID].status = _statusSecondary;\n    }\n\n    // function to pay the artist\n\n    function payArtist(uint256 _collectionID, address _team1, address _team2, uint256 _teamperc1, uint256 _teamperc2) public FunctionAdminRequired(this.payArtist.selector) {\n        require(collectionArtistPrimaryAddresses[_collectionID].status == true, \"Accept Royalties\");\n        require(collectionTotalAmount[_collectionID] > 0, \"Collection Balance must be grater than 0\");\n        require(collectionRoyaltiesPrimarySplits[_collectionID].artistPercentage + _teamperc1 + _teamperc2 == 100, \"Change percentages\");\n        uint256 royalties = collectionTotalAmount[_collectionID];\n        collectionTotalAmount[_collectionID] = 0;\n        address tm1 = _team1;\n        address tm2 = _team2;\n        uint256 colId = _collectionID;\n        uint256 artistRoyalties1;\n        uint256 artistRoyalties2;\n        uint256 artistRoyalties3;\n        uint256 teamRoyalties1;\n        uint256 teamRoyalties2;\n        artistRoyalties1 = royalties * collectionArtistPrimaryAddresses[colId].add1Percentage / 100;\n        artistRoyalties2 = royalties * collectionArtistPrimaryAddresses[colId].add2Percentage / 100;\n        artistRoyalties3 = royalties * collectionArtistPrimaryAddresses[colId].add3Percentage / 100;\n        teamRoyalties1 = royalties * _teamperc1 / 100;\n        teamRoyalties2 = royalties * _teamperc2 / 100;\n        (bool success1, ) = payable(collectionArtistPrimaryAddresses[colId].primaryAdd1).call{value: artistRoyalties1}(\"\");\n        (bool success2, ) = payable(collectionArtistPrimaryAddresses[colId].primaryAdd2).call{value: artistRoyalties2}(\"\");\n        (bool success3, ) = payable(collectionArtistPrimaryAddresses[colId].primaryAdd3).call{value: artistRoyalties3}(\"\");\n        (bool success4, ) = payable(tm1).call{value: teamRoyalties1}(\"\");\n        (bool success5, ) = payable(tm2).call{value: teamRoyalties2}(\"\");\n        emit PayArtist(collectionArtistPrimaryAddresses[colId].primaryAdd1, success1, artistRoyalties1);\n        emit PayArtist(collectionArtistPrimaryAddresses[colId].primaryAdd2, success2, artistRoyalties2);\n        emit PayArtist(collectionArtistPrimaryAddresses[colId].primaryAdd3, success3, artistRoyalties3);\n        emit PayTeam(tm1, success4, teamRoyalties1);\n        emit PayTeam(tm2, success5, teamRoyalties2);\n    }\n\n    // function to update core contract\n\n    function updateCoreContract(address _gencore) public FunctionAdminRequired(this.updateCoreContract.selector) { \n        gencore = INextGenCore(_gencore);\n    }\n\n    // function to update admin contract\n\n    function updateAdminContract(address _newadminsContract) public FunctionAdminRequired(this.updateAdminContract.selector) {\n        require(INextGenAdmins(_newadminsContract).isAdminContract() == true, \"Contract is not Admin\");\n        adminsContract = INextGenAdmins(_newadminsContract);\n    }\n\n    // function to withdraw any balance from the smart contract\n\n    function emergencyWithdraw() public FunctionAdminRequired(this.emergencyWithdraw.selector) {\n        uint balance = address(this).balance;\n        address admin = adminsContract.owner();\n        (bool success, ) = payable(admin).call{value: balance}(\"\");\n        emit Withdraw(msg.sender, success, balance);\n    }\n\n    // function to retrieve primary splits between artist and team\n\n    function retrievePrimarySplits(uint256 _collectionID) public view returns(uint256, uint256){\n        return (collectionRoyaltiesPrimarySplits[_collectionID].artistPercentage, collectionRoyaltiesPrimarySplits[_collectionID].teamPercentage);\n    }\n\n    // function to retrieve primary addresses and percentages\n\n    function retrievePrimaryAddressesAndPercentages(uint256 _collectionID) public view returns(address, address, address, uint256, uint256, uint256, bool){\n        return (collectionArtistPrimaryAddresses[_collectionID].primaryAdd1, collectionArtistPrimaryAddresses[_collectionID].primaryAdd2, collectionArtistPrimaryAddresses[_collectionID].primaryAdd3, collectionArtistPrimaryAddresses[_collectionID].add1Percentage, collectionArtistPrimaryAddresses[_collectionID].add2Percentage, collectionArtistPrimaryAddresses[_collectionID].add3Percentage, collectionArtistPrimaryAddresses[_collectionID].status);\n    }\n\n    // function to retrieve secondary splits between artist and team\n\n    function retrieveSecondarySplits(uint256 _collectionID) public view returns(uint256, uint256){\n        return (collectionRoyaltiesSecondarySplits[_collectionID].artistPercentage, collectionRoyaltiesSecondarySplits[_collectionID].teamPercentage);\n    }\n\n    // function to retrieve secondary addresses and percentages\n\n    function retrieveSecondaryAddressesAndPercentages(uint256 _collectionID) public view returns(address, address, address, uint256, uint256, uint256, bool){\n        return (collectionArtistSecondaryAddresses[_collectionID].secondaryAdd1, collectionArtistSecondaryAddresses[_collectionID].secondaryAdd2, collectionArtistSecondaryAddresses[_collectionID].secondaryAdd3, collectionArtistSecondaryAddresses[_collectionID].add1Percentage, collectionArtistSecondaryAddresses[_collectionID].add2Percentage, collectionArtistSecondaryAddresses[_collectionID].add3Percentage, collectionArtistSecondaryAddresses[_collectionID].status);\n    }\n\n    // function to retrieve the Collection phases times and merkle root of a collection\n\n    function retrieveCollectionPhases(uint256 _collectionID) public view returns(uint, uint, bytes32, uint, uint){\n        return (collectionPhases[_collectionID].allowlistStartTime, collectionPhases[_collectionID].allowlistEndTime, collectionPhases[_collectionID].merkleRoot, collectionPhases[_collectionID].publicStartTime, collectionPhases[_collectionID].publicEndTime);\n    }\n\n    // function to retrieve the minting details of a collection\n\n    function retrieveCollectionMintingDetails(uint256 _collectionID) public view returns(uint256, uint256, uint256, uint256, uint8, address){\n        return (collectionPhases[_collectionID].collectionMintCost, collectionPhases[_collectionID].collectionEndMintCost, collectionPhases[_collectionID].rate, collectionPhases[_collectionID].timePeriod, collectionPhases[_collectionID].salesOption, collectionPhases[_collectionID].delAddress);\n    }\n\n    // get minter contract status\n\n    function isMinterContract() external view returns (bool) {\n        return true;\n    }\n\n    // get minting end time\n\n    function getEndTime(uint256 _collectionID) external view returns (uint) {\n        return collectionPhases[_collectionID].publicEndTime;\n    }\n\n    // get auction end time\n\n    function getAuctionEndTime(uint256 _tokenId) external view returns (uint) {\n        return mintToAuctionData[_tokenId];\n    }\n\n    // get auction status\n\n    function getAuctionStatus(uint256 _tokenId) external view  returns (bool) {\n        return mintToAuctionStatus[_tokenId];\n    }\n\n    // get the minting price of collection\n\n    function getPrice(uint256 _collectionId) public view returns (uint256) {\n        uint tDiff;\n        if (collectionPhases[_collectionId].salesOption == 3) {\n            // increase minting price by mintcost / collectionPhases[_collectionId].rate every mint (1mint/period)\n            // to get the price rate needs to be set\n            if (collectionPhases[_collectionId].rate > 0) {\n                return collectionPhases[_collectionId].collectionMintCost + ((collectionPhases[_collectionId].collectionMintCost / collectionPhases[_collectionId].rate) * gencore.viewCirSupply(_collectionId));\n            } else {\n                return collectionPhases[_collectionId].collectionMintCost;\n            }\n        } else if (collectionPhases[_collectionId].salesOption == 2 && block.timestamp > collectionPhases[_collectionId].allowlistStartTime && block.timestamp < collectionPhases[_collectionId].publicEndTime){\n            // decreases exponentially every time period\n            // collectionPhases[_collectionId].timePeriod sets the time period for decreasing the mintcost\n            // if just public mint set the publicStartTime = allowlistStartTime\n            // if rate = 0 exponetialy decrease\n            // if rate is set the linear decrase each period per rate\n            tDiff = (block.timestamp - collectionPhases[_collectionId].allowlistStartTime) / collectionPhases[_collectionId].timePeriod;\n            uint256 price;\n            uint256 decreaserate;\n            if (collectionPhases[_collectionId].rate == 0) {\n                price = collectionPhases[_collectionId].collectionMintCost / (tDiff + 1);\n                decreaserate = ((price - (collectionPhases[_collectionId].collectionMintCost / (tDiff + 2))) / collectionPhases[_collectionId].timePeriod) * ((block.timestamp - (tDiff * collectionPhases[_collectionId].timePeriod) - collectionPhases[_collectionId].allowlistStartTime));\n            } else {\n                if (((collectionPhases[_collectionId].collectionMintCost - collectionPhases[_collectionId].collectionEndMintCost) / (collectionPhases[_collectionId].rate)) > tDiff) {\n                    price = collectionPhases[_collectionId].collectionMintC"
    }
  ]
}