{
  "Title": "M-4: Insufficient support for fee-on-transfer tokens",
  "Content": "# Issue M-4: Insufficient support for fee-on-transfer tokens \n\nSource: https://github.com/sherlock-audit/2022-11-buffer-judging/issues/76 \n\n## Found by \neierina, dipp, KingNFT, rvierdiiev, cccz, supernova, Deivitto, \\_\\_141345\\_\\_, jonatascm, pashov\n\n## Summary\n\nThe ```BufferBinaryPool.sol``` and ```BufferRouter.sol``` do not support fee-on-transfer tokens. If ```tokenX``` is a fee-on-transfer token, tokens received from users could be less than the amount specified in the transfer.\n\n## Vulnerability Detail\n\nThe ```initiateTrade``` function in ```BufferRouter.sol``` receives tokens from the user with amount set to ```initiateTrade```'s ```totalFee``` input. If tokenX is a fee-on-transfer token then the actual amount received by ```BufferRouter.sol``` is less than ```totalFee```. When a trade is opened, the protocol will [send a settlementFee to ```settlementFeeDisbursalContract```](https://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferBinaryOptions.sol#L137-L141) and a [premium to ```BufferBinaryPool.sol```](), where the settlementFee is calculated using the incorrect, inflated totalFee amount. When the totalFee is greater than the fee required [the user is reimbursed the difference](https://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferRouter.sol#L333-L339). Since the settlementFee is greater than it should be the user receives less reimbursement.\n\nIn ```BufferBinaryPool.sol```'s ```lock``` function, the premium for the order is sent from the Options contract to the Pool. The totalPremium state variable would be updated incorrectly if fee-on-transfer tokens were used.\n\nThe ```_provide``` function in ```BufferBinaryPool.sol```receives tokenXAmount of tokenX tokens from the user and calculates the amount of shares to mint using the tokenXAmount. If fee-on-transfer tokens are used then the user would receive more shares than they should.\n\n## Impact\n\nThe protocol and users could suffer a loss of funds.\n\n## Code Snippet\n\n[BufferRouter.sol#L86-L90](https://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferRouter.sol#L86-L90)\n\n[BufferBinaryPool.sol#L161](https://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferBinaryPool.sol#L161)\n\n[BufferBinaryPool.sol#L236-L240](https://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferBinaryPool.sol#L161)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider checking the balance of the contract before and after token transfers and using instead of the amount specified in the contract.\n\n## Discussion\n\n**0x00052**\n\nOnly an issue if project intends to support fee-on-transfer tokens as underlying\n\n**bufferfinance**\n\nNot supporting fee-on-transfer tokens for now.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/24",
  "Code": [
    {
      "filename": "contracts/contracts/core/BufferBinaryOptions.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"../interfaces/Interfaces.sol\";\n\n/**\n * @author Heisenberg\n * @title Buffer Options\n * @notice Creates ERC721 Options\n */\n\ncontract BufferBinaryOptions is\n    IBufferBinaryOptions,\n    ReentrancyGuard,\n    ERC721,\n    AccessControl\n{\n    uint256 public nextTokenId = 0;\n    uint256 public totalLockedAmount;\n    bool public isPaused;\n    uint16 public baseSettlementFeePercentageForAbove; // Factor of 1e2\n    uint16 public baseSettlementFeePercentageForBelow; // Factor of 1e2\n    uint16 public stepSize = 250; // Factor of 1e2\n    string public assetPair;\n\n    ILiquidityPool public override pool;\n    IOptionsConfig public override config;\n    IReferralStorage public referral;\n    AssetCategory public assetCategory;\n    ERC20 public override tokenX;\n\n    mapping(uint256 => Option) public override options;\n    mapping(address => uint256[]) public userOptionIds;\n    mapping(uint8 => uint8) public nftTierStep;\n\n    bytes32 public constant ROUTER_ROLE = keccak256(\"ROUTER_ROLE\");\n\n    /************************************************\n     *  INITIALIZATION FUNCTIONS\n     ***********************************************/\n\n    constructor(\n        ERC20 _tokenX,\n        ILiquidityPool _pool,\n        IOptionsConfig _config,\n        IReferralStorage _referral,\n        AssetCategory _category,\n        string memory _assetPair\n    ) ERC721(\"Buffer\", \"BFR\") {\n        tokenX = _tokenX;\n        pool = _pool;\n        config = _config;\n        referral = _referral;\n        assetPair = _assetPair;\n        assetCategory = _category;\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /**\n     * @notice Used to configure the contracts\n     */\n    function configure(\n        uint16 _baseSettlementFeePercentageForAbove,\n        uint16 _baseSettlementFeePercentageForBelow,\n        uint8[4] calldata _nftTierStep\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(10e2 <= _baseSettlementFeePercentageForAbove, \"O27\");\n        require(_baseSettlementFeePercentageForAbove <= 50e2, \"O28\");\n        baseSettlementFeePercentageForAbove = _baseSettlementFeePercentageForAbove; // Percent with a factor of 1e2\n\n        require(10e2 <= _baseSettlementFeePercentageForBelow, \"O27\");\n        require(_baseSettlementFeePercentageForBelow <= 50e2, \"O28\");\n        baseSettlementFeePercentageForBelow = _baseSettlementFeePercentageForBelow;\n\n        for (uint8 i; i < 4; i++) {\n            nftTierStep[i] = _nftTierStep[i];\n        }\n    }\n\n    /**\n     * @notice Grants complete approval from the pool\n     */\n    function approvePoolToTransferTokenX() public {\n        tokenX.approve(address(pool), ~uint256(0));\n    }\n\n    /**\n     * @notice Pauses/Unpauses the option creation\n     */\n    function toggleCreation() public onlyRole(DEFAULT_ADMIN_ROLE) {\n        isPaused = !isPaused;\n        emit Pause(isPaused);\n    }\n\n    /************************************************\n     *  ROUTER ONLY FUNCTIONS\n     ***********************************************/\n\n    /**\n     * @notice Creates an option with the specified parameters\n     * @dev Can only be called by router\n     */\n    function createFromRouter(\n        OptionParams calldata optionParams,\n        bool isReferralValid\n    ) external override onlyRole(ROUTER_ROLE) returns (uint256 optionID) {\n        Option memory option = Option(\n            State.Active,\n            optionParams.strike,\n            optionParams.amount,\n            optionParams.amount,\n            optionParams.amount / 2,\n            block.timestamp + optionParams.period,\n            optionParams.isAbove,\n            optionParams.totalFee,\n            block.timestamp\n        );\n        totalLockedAmount += optionParams.amount;\n        optionID = _generateTokenId();\n        userOptionIds[optionParams.user].push(optionID);\n        options[optionID] = option;\n        _mint(optionParams.user, optionID);\n\n        uint256 referrerFee = _processReferralRebate(\n            optionParams.user,\n            optionParams.totalFee,\n            optionParams.amount,\n            optionParams.referralCode,\n            optionParams.isAbove,\n            isReferralValid\n        );\n\n        uint256 settlementFee = optionParams.totalFee -\n            option.premium -\n            referrerFee;\n\n        tokenX.transfer(config.settlementFeeDisbursalContract(), settlementFee);\n        pool.lock(optionID, option.lockedAmount, option.premium);\n        emit Create(\n            optionParams.user,\n            optionID,\n            settlementFee,\n            optionParams.totalFee\n        );\n    }\n\n    /**\n     * @notice Unlocks/Exercises the active options\n     * @dev Can only be called router\n     */\n    function unlock(uint256 optionID, uint256 priceAtExpiration)\n        external\n        override\n        onlyRole(ROUTER_ROLE)\n    {\n        require(_exists(optionID), \"O10\");\n        Option storage option = options[optionID];\n        require(option.expiration <= block.timestamp, \"O4\");\n        require(option.state == State.Active, \"O5\");\n\n        if (\n            (option.isAbove && priceAtExpiration > option.strike) ||\n            (!option.isAbove && priceAtExpiration < option.strike)\n        ) {\n            _exercise(optionID, priceAtExpiration);\n        } else {\n            option.state = State.Expired;\n            pool.unlock(optionID);\n            _burn(optionID);\n            emit Expire(optionID, option.premium, priceAtExpiration);\n        }\n        totalLockedAmount -= option.lockedAmount;\n    }\n\n    /************************************************\n     *  READ ONLY FUNCTIONS\n     ***********************************************/\n\n    /**\n     * @notice Returns decimals of the pool token\n     */\n    function decimals() public view returns (uint256) {\n        return tokenX.decimals();\n    }\n\n    /**\n     * @notice Calculates the fees for buying an option\n     */\n    function fees(\n        uint256 amount,\n        address user,\n        bool isAbove,\n        string calldata referralCode,\n        uint256 traderNFTId\n    )\n        public\n        view\n        returns (\n            uint256 total,\n            uint256 settlementFee,\n            uint256 premium\n        )\n    {\n        (uint256 settlementFeePercentage, ) = _getSettlementFeePercentage(\n            referral.codeOwner(referralCode),\n            user,\n            _getbaseSettlementFeePercentage(isAbove),\n            traderNFTId\n        );\n        (total, settlementFee, premium) = _fees(\n            amount,\n            settlementFeePercentage\n        );\n    }\n\n    /**\n     * @notice Checks if the strike price at which the trade is opened lies within the slippage bounds\n     */\n    function isStrikeValid(\n        uint256 slippage,\n        uint256 strike,\n        uint256 expectedStrike\n    ) external pure override returns (bool) {\n        if (\n            (strike <= (expectedStrike * (1e4 + slippage)) / 1e4) &&\n            (strike >= (expectedStrike * (1e4 - slippage)) / 1e4)\n        ) {\n            return true;\n        } else return false;\n    }\n\n    /**\n     * @notice Checks if the market is open at the time of option creation and execution.\n     * Used only for forex options\n     */\n    function isInCreationWindow(uint256 period) public view returns (bool) {\n        uint256 currentTime = block.timestamp;\n        uint256 currentDay = ((currentTime / 86400) + 4) % 7;\n        uint256 expirationDay = (((currentTime + period) / 86400) + 4) % 7;\n\n        if (currentDay == expirationDay) {\n            uint256 currentHour = (currentTime / 3600) % 24;\n            uint256 currentMinute = (currentTime % 3600) / 60;\n            uint256 expirationHour = ((currentTime + period) / 3600) % 24;\n            uint256 expirationMinute = ((currentTime + period) % 3600) / 60;\n            (\n                uint256 startHour,\n                uint256 startMinute,\n                uint256 endHour,\n                uint256 endMinute\n            ) = config.marketTimes(uint8(currentDay));\n\n            if (\n                (currentHour > startHour ||\n                    (currentHour == startHour &&\n                        currentMinute >= startMinute)) &&\n                (currentHour < endHour ||\n                    (currentHour == endHour && currentMinute < endMinute)) &&\n                (expirationHour < endHour ||\n                    (expirationHour == endHour && expirationMinute < endMinute))\n            ) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @notice Runs the basic checks for option creation\n     */\n    function runInitialChecks(\n        uint256 slippage,\n        uint256 period,\n        uint256 totalFee\n    ) external view override {\n        require(!isPaused, \"O33\");\n        require(slippage <= 5e2, \"O34\"); // 5% is the max slippage a user can use\n        require(period >= config.minPeriod(), \"O21\");\n        require(period <= config.maxPeriod(), \"O25\");\n        require(totalFee >= config.minFee(), \"O35\");\n    }\n\n    /**\n     * @notice Calculates max option amount based on the pool's capacity\n     */\n    function getMaxUtilization() public view returns (uint256 maxAmount) {\n        // Calculate the max option size due to asset wise pool utilization limit\n        uint256 totalPoolBalance = pool.totalTokenXBalance();\n        uint256 availableBalance = totalPoolBalance - totalLockedAmount;\n        uint256 utilizationLimit = config.assetUtilizationLimit();\n        uint256 maxAssetWiseUtilizationAmount = _getMaxUtilization(\n            totalPoolBalance,\n            availableBalance,\n            utilizationLimit\n        );\n\n        // Calculate the max option size due to overall pool utilization limit\n        utilizationLimit = config.overallPoolUtilizationLimit();\n        availableBalance = pool.availableBalance();\n        uint256 maxUtilizationAmount = _getMaxUtilization(\n            totalPoolBalance,\n            availableBalance,\n            utilizationLimit\n        );\n\n        // Take the min of the above 2 values\n        maxAmount = min(maxUtilizationAmount, maxAssetWiseUtilizationAmount);\n    }\n\n    /**\n     * @notice Runs all the checks on the option parameters and\n     * returns the revised amount and fee\n     */\n    function checkParams(OptionParams calldata optionParams)\n        external\n        view\n        override\n        returns (\n            uint256 amount,\n            uint256 revisedFee,\n            bool isReferralValid\n        )\n    {\n        require(\n            assetCategory != AssetCategory.Forex ||\n                isInCreationWindow(optionParams.period),\n            \"O30\"\n        );\n\n        uint256 maxAmount = getMaxUtilization();\n\n        // Calculate the max fee due to the max txn limit\n        uint256 maxPerTxnFee = ((pool.availableBalance() *\n            config.optionFeePerTxnLimitPercent()) / 100e2);\n        uint256 newFee = min(optionParams.totalFee, maxPerTxnFee);\n\n        // Calculate the amount here from the new fees\n        uint256 settlementFeePercentage;\n        (\n            settlementFeePercentage,\n            isReferralValid\n        ) = _getSettlementFeePercentage(\n            referral.codeOwner(optionParams.referralCode),\n            optionParams.user,\n            _getbaseSettlementFeePercentage(optionParams.isAbove),\n            optionParams.traderNFTId\n        );\n        (uint256 unitFee, , ) = _fees(10**decimals(), settlementFeePercentage);\n        amount = (newFee * 10**decimals()) / unitFee;\n\n        // Recalculate the amount and the fees if values are greater than the max and partial fill is allowed\n        if (amount > maxAmount || newFee < optionParams.totalFee) {\n            require(optionParams.allowPartialFill, \"O29\");\n            amount = min(amount, maxAmount);\n            (revisedFee, , ) = _fees(amount, settlementFeePercentage);\n        } else {\n            revisedFee = optionParams.totalFee;\n        }\n    }\n\n    /************************************************\n     * ERC721 FUNCTIONS\n     ***********************************************/\n\n    function _generateTokenId() internal returns (uint256) {\n        return nextTokenId++;\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721, AccessControl)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    /************************************************\n     *  INTERNAL OPTION UTILITY FUNCTIONS\n     ***********************************************/\n\n    /**\n     * @notice Returns the base settlement fee based on option type\n     */\n    function _getbaseSettlementFeePercentage(bool isAbove)\n        internal\n        view\n        returns (uint16 baseSettlementFeePercentage)\n    {\n        baseSettlementFeePercentage = isAbove\n            ? baseSettlementFeePercentageForAbove\n            : baseSettlementFeePercentageForBelow;\n    }\n\n    /**\n     * @notice Calculates the max utilization\n     */\n    function _getMaxUtilization(\n        uint256 totalPoolBalance,\n        uint256 availableBalance,\n        uint256 utilizationLimit\n    ) internal pure returns (uint256) {\n        require(\n            availableBalance >\n                (((1e4 - utilizationLimit) * totalPoolBalance) / 1e4),\n            \"O31\"\n        );\n        return\n            availableBalance -\n            (((1e4 - utilizationLimit) * totalPoolBalance) / 1e4);\n    }\n\n    /**\n     * @notice Calculates the fees for buying an option\n     */\n    function _fees(uint256 amount, uint256 settlementFeePercentage)\n        internal\n        pure\n        returns (\n            uint256 total,\n            uint256 settlementFee,\n            uint256 premium\n        )\n    {\n        // Probability for ATM options will always be 0.5 due to which we can skip using BSM\n        premium = amount / 2;\n        settlementFee = (amount * settlementFeePercentage) / 1e4;\n        total = settlementFee + premium;\n    }\n\n    /**\n     * @notice Exercises the ITM options\n     */\n    function _exercise(uint256 optionID, uint256 priceAtExpiration)\n        internal\n        returns (uint256 profit)\n    {\n        Option storage option = options[optionID];\n        address user = ownerOf(optionID);\n        profit = option.lockedAmount;\n        pool.send(optionID, user, profit);\n\n        // Burn the option\n        _burn(optionID);\n        option.state = State.Exercised;\n        emit Exercise(user, optionID, profit, priceAtExpiration);\n    }\n\n    /**\n     * @notice Sends the referral rebate to the referrer and\n     * updates the stats in the referral storage contract\n     */\n    function _processReferralRebate(\n        address user,\n        uint256 totalFee,\n        uint256 amount,\n        string calldata referralCode,\n        bool isAbove,\n        bool isReferralValid\n    ) internal returns (uint256 referrerFee) {\n        address referrer = referral.codeOwner(referralCode);\n\n        if (referrer != user && referrer != address(0)) {\n            referrerFee = ((totalFee *\n                referral.referrerTierDiscount(\n                    referral.referrerTier(referrer)\n                )) / (1e4 * 1e3));\n            if (referrerFee > 0) {\n                tokenX.transfer(referrer, referrerFee);\n\n                (uint256 formerUnitFee, , ) = _fees(\n                    10**decimals(),\n                    _getbaseSettlementFeePercentage(isAbove)\n                );\n                emit UpdateReferral(\n                    referrer,\n                    isReferralValid,\n                    totalFee,\n                    referrerFee,\n                    ((formerUnitFee * amount) - totalFee),\n                    referralCode\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Calculates the discount to be applied on settlement fee based on\n     * NFT and referrer tiers\n     */\n    function _getSettlementFeeDiscount(\n        address referrer,\n        address user,\n        uint256 traderNFTId\n    ) public view returns (bool isReferralValid, uint8 maxStep) {\n        if (config.traderNFTContract() != address(0)) {\n            ITraderNFT nftContract = ITraderNFT(config.traderNFTContract());\n            if (nftContract.tokenOwner(traderNFTId) == user)\n                maxStep = nftTierStep[\n                    nftContract.tokenTierMappings(traderNFTId)\n                ];\n        }\n        if (referrer != user && referrer != address(0)) {\n            uint8 step = referral.referrerTierStep(\n                referral.referrerTier(referrer)\n            );\n            if (step > maxStep) {\n                maxStep = step;\n                isReferralValid = true;\n            }\n        }\n    }\n\n    /**\n     * @notice Returns the discounted settlement fee\n     */\n    function _getSettlementFeePercentage(\n        address referrer,\n        address user,\n        uint16 baseSettlementFeePercentage,\n        uint256 traderNFTId\n    )\n        internal\n        view\n        returns (uint256 settlementFeePercentage, bool isReferralValid)\n    {\n        settlementFeePercentage = baseSettlementFeePercentage;\n        uint256 maxStep;\n        (isReferralValid, maxStep) = _getSettlementFeeDiscount(\n            referrer,\n            user,\n            traderNFTId\n        );\n        settlementFeePercentage =\n            settlementFeePercentage -\n            (stepSize * maxStep);\n    }\n}"
    },
    {
      "filename": "contracts/contracts/core/BufferRouter.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"../interfaces/Interfaces.sol\";\n\n/**\n * @author Heisenberg\n * @notice Buffer Options Router Contract\n */\ncontract BufferRouter is AccessControl, IBufferRouter {\n    uint16 MAX_WAIT_TIME = 1 minutes;\n    uint256 public nextQueueId = 0;\n    address public publisher;\n    uint256 public nextQueueIdToProcess = 0;\n    bool public isInPrivateKeeperMode = true;\n\n    mapping(address => uint256[]) public userQueuedIds;\n    mapping(address => uint256[]) public userCancelledQueuedIds;\n    mapping(address => uint256) public userNextQueueIndexToProcess;\n    mapping(uint256 => QueuedTrade) public queuedTrades;\n    mapping(address => bool) public contractRegistry;\n    mapping(address => bool) public isKeeper;\n\n    constructor(address _publisher) {\n        publisher = _publisher;\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /************************************************\n     *  ADMIN ONLY FUNCTIONS\n     ***********************************************/\n\n    function setContractRegistry(address targetContract, bool register)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        contractRegistry[targetContract] = register;\n    }\n\n    function setKeeper(address _keeper, bool _isActive)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        isKeeper[_keeper] = _isActive;\n    }\n\n    function setInPrivateKeeperMode() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        isInPrivateKeeperMode = !isInPrivateKeeperMode;\n    }\n\n    /************************************************\n     *  USER WRITE FUNCTIONS\n     ***********************************************/\n\n    /**\n     * @notice Adds an option creation request in the queue\n     */\n    function initiateTrade(\n        uint256 totalFee,\n        uint256 period,\n        bool isAbove,\n        address targetContract,\n        uint256 expectedStrike,\n        uint256 slippage,\n        bool allowPartialFill,\n        string memory referralCode,\n        uint256 traderNFTId\n    ) external returns (uint256 queueId) {\n        // Checks if the target contract has been registered\n        require(\n            contractRegistry[targetContract],\n            \"Router: Unauthorized contract\"\n        );\n        IBufferBinaryOptions optionsContract = IBufferBinaryOptions(\n            targetContract\n        );\n\n        optionsContract.runInitialChecks(slippage, period, totalFee);\n\n        // Transfer the fee specified from the user to this contract.\n        // User has to approve first inorder to execute this function\n        IERC20(optionsContract.tokenX()).transferFrom(\n            msg.sender,\n            address(this),\n            totalFee\n        );\n        queueId = nextQueueId;\n        nextQueueId++;\n\n        QueuedTrade memory queuedTrade = QueuedTrade(\n            queueId,\n            userQueueCount(msg.sender),\n            msg.sender,\n            totalFee,\n            period,\n            isAbove,\n            targetContract,\n            expectedStrike,\n            slippage,\n            allowPartialFill,\n            block.timestamp,\n            true,\n            referralCode,\n            traderNFTId\n        );\n\n        queuedTrades[queueId] = queuedTrade;\n\n        userQueuedIds[msg.sender].push(queueId);\n\n        emit InitiateTrade(msg.sender, queueId, block.timestamp);\n    }\n\n    /**\n     * @notice Cancels a queued traded. Can only be called by the trade owner\n     */\n    function cancelQueuedTrade(uint256 queueId) external {\n        QueuedTrade memory queuedTrade = queuedTrades[queueId];\n        require(msg.sender == queuedTrade.user, \"Router: Forbidden\");\n        require(queuedTrade.isQueued, \"Router: Trade has already been opened\");\n        _cancelQueuedTrade(queueId);\n        emit CancelTrade(queuedTrade.user, queueId, \"User Cancelled\");\n    }\n\n    /************************************************\n     *  KEEPER ONLY FUNCTIONS\n     ***********************************************/\n\n    /**\n     * @notice Verifies the trade parameter via the signature and resolves all the valid queued trades\n     */\n    function resolveQueuedTrades(OpenTradeParams[] calldata params) external {\n        _validateKeeper();\n        for (uint32 index = 0; index < params.length; index++) {\n            OpenTradeParams memory currentParams = params[index];\n            QueuedTrade memory queuedTrade = queuedTrades[\n                currentParams.queueId\n            ];\n            bool isSignerVerifed = _validateSigner(\n                currentParams.timestamp,\n                currentParams.asset,\n                currentParams.price,\n                currentParams.signature\n            );\n            // Silently fail if the signature doesn't match\n            if (!isSignerVerifed) {\n                emit FailResolve(\n                    currentParams.queueId,\n                    \"Router: Signature didn't match\"\n                );\n                continue;\n            }\n            if (\n                !queuedTrade.isQueued ||\n                currentParams.timestamp != queuedTrade.queuedTime\n            ) {\n                // Trade has already been opened or cancelled or the timestamp is wrong.\n                // So ignore this trade.\n                continue;\n            }\n\n            // If the opening time is much greater than the queue time then cancel the trade\n            if (block.timestamp - queuedTrade.queuedTime <= MAX_WAIT_TIME) {\n                _openQueuedTrade(currentParams.queueId, currentParams.price);\n            } else {\n                _cancelQueuedTrade(currentParams.queueId);\n                emit CancelTrade(\n                    queuedTrade.user,\n                    currentParams.queueId,\n                    \"Wait time too high\"\n                );\n            }\n\n            // Track the next queueIndex to be processed for user\n            userNextQueueIndexToProcess[queuedTrade.user] =\n                queuedTrade.userQueueIndex +\n                1;\n        }\n        // Track the next queueIndex to be processed overall\n        nextQueueIdToProcess = params[params.length - 1].queueId + 1;\n    }\n\n    /**\n     * @notice Verifies the option parameter via the signature and unlocks an array of options\n     */\n    function unlockOptions(CloseTradeParams[] calldata optionData) external {\n        _validateKeeper();\n\n        uint32 arrayLength = uint32(optionData.length);\n        for (uint32 i = 0; i < arrayLength; i++) {\n            CloseTradeParams memory params = optionData[i];\n            IBufferBinaryOptions optionsContract = IBufferBinaryOptions(\n                params.asset\n            );\n            (, , , , , uint256 expiration, , , ) = optionsContract.options(\n                params.optionId\n            );\n\n            bool isSignerVerifed = _validateSigner(\n                params.expiryTimestamp,\n                params.asset,\n                params.priceAtExpiry,\n                params.signature\n            );\n\n            // Silently fail if the timestamp of the signature is wrong\n            if (expiration != params.expiryTimestamp) {\n                emit FailUnlock(params.optionId, \"Router: Wrong price\");\n                continue;\n            }\n\n            // Silently fail if the signature doesn't match\n            if (!isSignerVerifed) {\n                emit FailUnlock(\n                    params.optionId,\n                    \"Router: Signature didn't match\"\n                );\n                continue;\n            }\n\n            try\n                optionsContract.unlock(params.optionId, params.priceAtExpiry)\n            {} catch Error(string memory reason) {\n                emit FailUnlock(params.optionId, reason);\n                continue;\n            }\n        }\n    }\n\n    /************************************************\n     *  READ ONLY FUNCTIONS\n     ***********************************************/\n\n    function userQueueCount(address user) public view returns (uint256) {\n        return userQueuedIds[user].length;\n    }\n\n    function userCancelledQueueCount(address user)\n        external\n        view\n        returns (uint256)\n    {\n        return userCancelledQueuedIds[user].length;\n    }\n\n    /************************************************\n     *  INTERNAL FUNCTIONS\n     ***********************************************/\n    function _validateKeeper() private view {\n        require(\n            !isInPrivateKeeperMode || isKeeper[msg.sender],\n            \"Keeper: forbidden\"\n        );\n    }\n\n    function _validateSigner(\n        uint256 timestamp,\n        address asset,\n        uint256 price,\n        bytes memory signature\n    ) internal view returns (bool) {\n        bytes32 digest = ECDSA.toEthSignedMessageHash(\n            keccak256(abi.encodePacked(timestamp, asset, price))\n        );\n        address recoveredSigner = ECDSA.recover(digest, signature);\n        return recoveredSigner == publisher;\n    }\n\n    function _openQueuedTrade(uint256 queueId, uint256 price) internal {\n        QueuedTrade storage queuedTrade = queuedTrades[queueId];\n        IBufferBinaryOptions optionsContract = IBufferBinaryOptions(\n            queuedTrade.targetContract\n        );\n\n        // Check if slippage lies within the bounds\n        bool isSlippageWithinRange = optionsContract.isStrikeValid(\n            queuedTrade.slippage,\n            price,\n            queuedTrade.expectedStrike\n        );\n\n        if (!isSlippageWithinRange) {\n            _cancelQueuedTrade(queueId);\n            emit CancelTrade(\n                queuedTrade.user,\n                queueId,\n                \"Slippage limit exceeds\"\n            );\n\n            return;\n        }\n\n        // Check all the parameters and compute the amount and revised fee\n        uint256 amount;\n        uint256 revisedFee;\n        bool isReferralValid;\n        IBufferBinaryOptions.OptionParams\n            memory optionParams = IBufferBinaryOptions.OptionParams(\n                queuedTrade.expectedStrike,\n                0,\n                queuedTrade.period,\n                queuedTrade.isAbove,\n                queuedTrade.allowPartialFill,\n                queuedTrade.totalFee,\n                queuedTrade.user,\n                queuedTrade.referralCode,\n                queuedTrade.traderNFTId\n            );\n        try optionsContract.checkParams(optionParams) returns (\n            uint256 _amount,\n            uint256 _revisedFee,\n            bool _isReferralValid\n        ) {\n            (amount, revisedFee, isReferralValid) = (\n                _amount,\n                _revisedFee,\n                _isReferralValid\n            );\n        } catch Error(string memory reason) {\n            _cancelQueuedTrade(queueId);\n            emit CancelTrade(queuedTrade.user, queueId, reason);\n            return;\n        }\n\n        // Transfer the fee to the target options contract\n        IERC20 tokenX = IERC20(optionsContract.tokenX());\n        tokenX.transfer(queuedTrade.targetContract, revisedFee);\n\n        // Refund the user in case the trade amount was lesser\n        if (revisedFee < queuedTrade.totalFee) {\n            tokenX.transfer(\n                queuedTrade.user,\n                queuedTrade.totalFee - revisedFee\n            );\n        }\n\n        optionParams.totalFee = revisedFee;\n        optionParams.strike = price;\n        optionParams.amount = amount;\n\n        uint256 optionId = optionsContract.createFromRouter(\n            optionParams,\n            isReferralValid\n        );\n\n        queuedTrade.isQueued = false;\n\n        emit OpenTrade(queuedTrade.user, queueId, optionId);\n    }\n\n    function _cancelQueuedTrade(uint256 queueId) internal {\n        QueuedTrade storage queuedTrade = queuedTrades[queueId];\n        IBufferBinaryOptions optionsContract = IBufferBinaryOptions(\n            queuedTrade.targetContract\n        );\n        queuedTrade.isQueued = false;\n        IERC20(optionsContract.tokenX()).transfer(\n            queuedTrade.user,\n            queuedTrade.totalFee\n        );\n\n        userCancelledQueuedIds[queuedTrade.user].push(queueId);\n    }\n}"
    },
    {
      "filename": "contracts/contracts/core/BufferBinaryPool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.4;\n\nimport \"../interfaces/Interfaces.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n/**\n * @author Heisenberg\n * @title Buffer TokenX Liquidity Pool\n * @notice Accumulates liquidity in TokenX from LPs and distributes P&L in TokenX\n */\ncontract BufferBinaryPool is\n    ERC20(\"Buffer LP Token\", \"BLP\"),\n    AccessControl,\n    ILiquidityPool\n{\n    ERC20 public tokenX;\n    uint16 public constant ACCURACY = 1e3;\n    uint32 public constant INITIAL_RATE = 1;\n    uint32 public lockupPeriod = 10 minutes;\n    uint256 public lockedAmount;\n    uint256 public lockedPremium;\n    uint256 public maxLiquidity;\n    address public owner;\n    bytes32 public constant OPTION_ISSUER_ROLE =\n        keccak256(\"OPTION_ISSUER_ROLE\");\n\n    mapping(address => LockedLiquidity[]) public lockedLiquidity;\n    mapping(address => bool) public isHandler;\n    mapping(address => ProvidedLiquidity) public liquidityPerUser;\n\n    constructor(ERC20 _tokenX) {\n        tokenX = _tokenX;\n        owner = msg.sender;\n        maxLiquidity = 5000000 * 10**_tokenX.decimals();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /************************************************\n     *  ADMIN ONLY FUNCTIONS\n     ***********************************************/\n\n    /**\n     * @notice Used for adding or removing handlers\n     */\n    function setHandler(address _handler, bool _isActive)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        isHandler[_handler] = _isActive;\n    }\n\n    /**\n     * @notice Used for adjusting the max limit of the pool\n     */\n    function setMaxLiquidity(uint256 _maxLiquidity)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        maxLiquidity = _maxLiquidity;\n        emit UpdateMaxLiquidity(_maxLiquidity);\n    }\n\n    /************************************************\n     *  EXTERNAL/PUBLIC FUNCTIONS\n     ***********************************************/\n\n    /**\n     * @notice ERC20 transferFrom. Overridden to allow handler to transfer without approval\n     */\n    function transferFrom(\n        address _sender,\n        address _recipient,\n        uint256 _amount\n    ) public virtual override returns (bool) {\n        if (isHandler[msg.sender]) {\n            _transfer(_sender, _recipient, _amount);\n            return true;\n        }\n\n        uint256 currentAllowance = allowance(_sender, msg.sender);\n        require(\n            currentAllowance >= _amount,\n            \"Pool: transfer amount exceeds allowance\"\n        );\n        unchecked {\n            _approve(_sender, msg.sender, currentAllowance - _amount);\n        }\n        _transfer(_sender, _recip"
    }
  ]
}