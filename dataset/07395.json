{
  "Title": "[G-05]  Optimize names to save gas",
  "Content": "\n`public`/`external` function names and `public` member variable names can be optimized to save gas. See [this](https://gist.github.com/IllIllI000/a5d8b486a8259f9f77891a919febd1a9) link for an example of how it works. Below are the interfaces/abstract contracts that can be optimized so that the most frequently-called functions use the least amount of gas possible during method lookup. Method IDs that have two leading zero bytes can save **128 gas** each during deployment, and renaming functions to have lower method IDs will save **22 gas** per call, [per sorted position shifted](https://medium.com/joyso/solidity-how-does-function-name-affect-gas-consumption-in-smart-contract-47d270d8ac92).\n\n*There are 8 instances of this issue:*\n\n```solidity\nFile: src/interfaces/IFundingRateController.sol\n\n/// @audit updateTarget(), lastUpdated(), target(), newTarget(), mark(), papr(), fundingPeriod()\n6:    interface IFundingRateController {\n\n```\nhttps://github.com/with-backed/papr/blob/1933da2e38ff9d47c17e2749d6088bbbd40bfa68/src/interfaces/IFundingRateController.sol#L6\n\n```solidity\nFile: src/interfaces/IPaprController.sol\n\n/// @audit addCollateral(), removeCollateral(), increaseDebt(), reduceDebt(), increaseDebtAndSell(), buyAndReduceDebt(), purchaseLiquidationAuctionNFT(), startLiquidationAuction(), setPool(), setFundingPeriod(), setLiquidationsLocked(), setAllowedCollateral(), sendPaprFromAuctionFees(), burnPaprFromAuctionFees(), collateralOwner(), isAllowed(), liquidationsLocked(), token0IsUnderlying(), maxLTV(), liquidationAuctionMinSpacing(), perPeriodAuctionDecayWAD(), auctionDecayPeriod(), auctionStartPriceMultiplier(), liquidationPenaltyBips(), maxDebt(), vaultInfo()\n9:    interface IPaprController {\n\n```\nhttps://github.com/with-backed/papr/blob/1933da2e38ff9d47c17e2749d6088bbbd40bfa68/src/interfaces/IPaprController.sol#L9\n\n```solidity\nFile: src/interfaces/IUniswapOracleFundingRateController.sol\n\n/// @audit pool()\n6:    interface IUniswapOracleFundingRateController is IFundingRateController {\n\n```\nhttps://github.com/with-backed/papr/blob/1933da2e38ff9d47c17e2749d6088bbbd40bfa68/src/interfaces/IUniswapOracleFundingRateController.sol#L6\n\n```solidity\nFile: src/NFTEDA/interfaces/INFTEDA.sol\n\n/// @audit auctionCurrentPrice(), auctionID(), auctionStartTime()\n7:    interface INFTEDA {\n\n```\nhttps://github.com/with-backed/papr/blob/1933da2e38ff9d47c17e2749d6088bbbd40bfa68/src/NFTEDA/interfaces/INFTEDA.sol#L7\n\n```solidity\nFile: src/NFTEDA/NFTEDA.sol\n\n/// @audit auctionCurrentPrice(), auctionID(), auctionStartTime()\n11:   abstract contract NFTEDA is INFTEDA {\n\n```\nhttps://github.com/with-backed/papr/blob/1933da2e38ff9d47c17e2749d6088bbbd40bfa68/src/NFTEDA/NFTEDA.sol#L11\n\n```solidity\nFile: src/PaprController.sol\n\n/// @audit uniswapV3SwapCallback()\n18:   contract PaprController is\n\n```\nhttps://github.com/with-backed/papr/blob/1933da2e38ff9d47c17e2749d6088bbbd40bfa68/src/PaprController.sol#L18\n\n```solidity\nFile: src/ReservoirOracleUnderwriter.sol\n\n/// @audit underwritePriceForCollateral()\n7:    contract ReservoirOracleUnderwriter {\n\n```\nhttps://github.com/with-backed/papr/blob/1933da2e38ff9d47c17e2749d6088bbbd40bfa68/src/ReservoirOracleUnderwriter.sol#L7\n\n```solidity\nFile: src/UniswapOracleFundingRateController.sol\n\n/// @audit mark()\n15:   contract UniswapOracleFundingRateController is IUniswapOracleFundingRateController {\n\n```\nhttps://github.com/with-backed/papr/blob/1933da2e38ff9d47c17e2749d6088bbbd40bfa68/src/UniswapOracleFundingRateController.sol#L15\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-12-backed",
  "Code": [
    {
      "filename": "src/interfaces/IFundingRateController.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\ninterface IFundingRateController {\n    /// @notice emitted when target is updated\n    /// @param newTarget the new target value\n    event UpdateTarget(uint256 newTarget);\n\n    event SetFundingPeriod(uint256 fundingPeriod);\n\n    error AlreadyInitialized();\n    error FundingPeriodTooShort();\n    error FundingPeriodTooLong();\n\n    /// @notice Updates target and returns new target\n    /// @dev if block.timestamp == lastUpdated() then just returns target()\n    /// @return Target the new target value\n    function updateTarget() external returns (uint256);\n\n    /// @notice The timestamp at which target was last updated\n    /// @return lastUpdated the timestamp (in seconds) at which target was last updated\n    function lastUpdated() external view returns (uint256);\n\n    /// @notice The target value of one whole unit of papr in underlying units.\n    /// @dev Target represents the 0% funding rate value. If mark() is equal to this\n    /// value, then funding rates are 0 and newTarget() will equal target().\n    /// @return target The value of one whole unit of papr in underlying units.\n    /// Example: if papr has 18 decimals and underlying 6 decimals, then\n    ///  target = 1e6 means 1e18 papr is worth 1e6 underlying, according to target\n    function target() external view returns (uint256);\n\n    /// @notice The value of new value of target() if updateTarget() were called right now\n    /// @dev If mark() > target(), newTarget() will be less than target(), positive funding/negative interest\n    /// @dev If mark() < target(), newTarget() will be greater than target(), negative funding/positive interest\n    /// @return newTarget The up to date target value for this block\n    function newTarget() external view returns (uint256);\n\n    /// @notice The market value of a whole unit of papr in underlying units\n    /// @return mark market papr price, quoted in underlying\n    function mark() external view returns (uint256);\n\n    /// @notice The papr token, the value of which is intended to\n    /// reflect in-kind funding payments via target() changing in value\n    /// @return papr the ERC20 token (address)\n    function papr() external view returns (ERC20);\n\n    /// @notice The underlying token that is used to quote the value of papr\n    /// @return underlying the ERC20 token (address)\n    function underlying() external view returns (ERC20);\n\n    /// @notice The period over which funding is paid\n    /// @dev a shorter funding period means volatility has a greater impact\n    /// on funding => target, longer period means the inverse\n    /// @return fundingPeriod in seconds over which funding is paid\n    function fundingPeriod() external view returns (uint256);\n}"
    },
    {
      "filename": "src/interfaces/IPaprController.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {ReservoirOracleUnderwriter} from \"src/ReservoirOracleUnderwriter.sol\";\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {INFTEDA} from \"src/NFTEDA/extensions/NFTEDAStarterIncentive.sol\";\n\ninterface IPaprController {\n    /// @notice collateral for a vault\n    struct Collateral {\n        /// @dev address of the collateral, cast to ERC721\n        ERC721 addr;\n        /// @dev tokenId of the collateral\n        uint256 id;\n    }\n\n    /// @notice vault information for a vault\n    struct VaultInfo {\n        /// @dev number of collateral tokens in the vault\n        uint16 count;\n        /// @dev start time of last auction the vault underwent, 0 if no auction has been started\n        uint40 latestAuctionStartTime;\n        /// @dev debt of the vault, expressed in papr token units\n        uint200 debt;\n    }\n\n    /// @notice parameters describing a swap\n    /// @dev increaseDebtAndSell has the input token as papr and output token as the underlying\n    /// @dev buyAndReduceDebt has the input token as the underlying and output token as papr\n    struct SwapParams {\n        /// @dev amount of input token to swap\n        uint256 amount;\n        /// @dev minimum amount of output token to be received\n        uint256 minOut;\n        /// @dev sqrt price limit for the swap\n        uint160 sqrtPriceLimitX96;\n        /// @dev optional address to receive swap fees\n        address swapFeeTo;\n        /// @dev optional swap fee in bips\n        uint256 swapFeeBips;\n    }\n\n    /// @notice parameters to be encoded in safeTransferFrom collateral addition\n    struct OnERC721ReceivedArgs {\n        /// @dev address to send proceeds to if minting debt or swapping\n        address proceedsTo;\n        /// @dev debt is ignored in favor of `swapParams.amount` of minOut > 0\n        uint256 debt;\n        /// @dev optional swapParams\n        SwapParams swapParams;\n        /// @dev oracle information associated with collateral being sent\n        ReservoirOracleUnderwriter.OracleInfo oracleInfo;\n    }\n\n    /// @notice parameters to change what collateral addresses can be used for a vault\n    struct CollateralAllowedConfig {\n        address collateral;\n        bool allowed;\n    }\n\n    /// @notice emitted when an address increases the debt balance of their vault\n    /// @param account address increasing their debt\n    /// @param collateralAddress address of the collateral token\n    /// @param amount amount of debt added\n    /// @dev vaults are uniquely identified by the address of the vault owner and the address of the collateral token used in the vault\n    event IncreaseDebt(address indexed account, ERC721 indexed collateralAddress, uint256 amount);\n\n    /// @notice emitted when a user adds collateral to their vault\n    /// @param account address adding collateral\n    /// @param collateralAddress contract address of the ERC721 collateral added\n    /// @param tokenId token id of the ERC721 collateral added\n    event AddCollateral(address indexed account, ERC721 indexed collateralAddress, uint256 indexed tokenId);\n\n    /// @notice emitted when a user removes collateral from their vault\n    /// @param account address removing collateral\n    /// @param collateralAddress contract address of the ERC721 collateral removed\n    /// @param tokenId token id of the ERC721 collateral removed\n    event RemoveCollateral(address indexed account, ERC721 indexed collateralAddress, uint256 indexed tokenId);\n\n    /// @notice emitted when a user reduces the debt balance of their vault\n    /// @param account address reducing their debt\n    /// @param collateralAddress address of the collateral token\n    /// @param amount amount of debt removed\n    event ReduceDebt(address indexed account, ERC721 indexed collateralAddress, uint256 amount);\n\n    /// @notice emitted when the owner sets whether a token address is allowed to serve as collateral for a vault\n    /// @param collateral address of the collateral token\n    /// @param isAllowed whether the collateral is allowed\n    event AllowCollateral(address indexed collateral, bool isAllowed);\n\n    /// @param vaultDebt how much debt the vault has\n    /// @param maxDebt the max debt the vault is allowed to have\n    error ExceedsMaxDebt(uint256 vaultDebt, uint256 maxDebt);\n\n    error InvalidCollateral();\n\n    error MinAuctionSpacing();\n\n    error NotLiquidatable();\n\n    error InvalidCollateralAccountPair();\n\n    error AccountHasNoDebt();\n\n    error OnlyCollateralOwner();\n\n    error DebtAmountExceedsUint200();\n\n    error CollateralAddressesDoNotMatch();\n\n    error LiquidationsLocked();\n\n    /// @notice adds collateral to msg.senders vault for collateral.addr\n    /// @dev use safeTransferFrom to save gas if only sending one NFT\n    /// @param collateral collateral to add\n    function addCollateral(IPaprController.Collateral[] calldata collateral) external;\n\n    /// @notice removes collateral from msg.senders vault\n    /// @dev all collateral must be from same contract address\n    /// @dev oracleInfo price must be type LOWER\n    /// @param sendTo address to send the collateral to when removed\n    /// @param collateralArr array of IPaprController.Collateral to be removed\n    /// @param oracleInfo oracle information for the collateral being removed\n    function removeCollateral(\n        address sendTo,\n        IPaprController.Collateral[] calldata collateralArr,\n        ReservoirOracleUnderwriter.OracleInfo calldata oracleInfo\n    ) external;\n\n    /// @notice increases debt balance of the vault uniquely identified by msg.sender and the collateral address\n    /// @dev oracleInfo price must be type LOWER\n    /// @param mintTo address to mint the debt to\n    /// @param asset address of the collateral token used to mint the debt\n    /// @param amount amount of debt to mint\n    /// @param oracleInfo oracle information for the collateral being used to mint debt\n    function increaseDebt(\n        address mintTo,\n        ERC721 asset,\n        uint256 amount,\n        ReservoirOracleUnderwriter.OracleInfo calldata oracleInfo\n    ) external;\n\n    /// @notice removes and burns debt from the vault uniquely identified by account and the collateral address\n    /// @param account address reducing their debt\n    /// @param asset address of the collateral token the user would like to remove debt from\n    /// @param amount amount of debt to remove\n    function reduceDebt(address account, ERC721 asset, uint256 amount) external;\n\n    /// @notice mints debt and swaps the debt for the controller's underlying token on Uniswap\n    /// @dev oracleInfo price must be type LOWER\n    /// @param proceedsTo address to send the proceeds to\n    /// @param collateralAsset address of the collateral token used to mint the debt\n    /// @param params parameters for the swap\n    /// @param oracleInfo oracle information for the collateral being used to mint debt\n    /// @return amount amount of underlying token received by the user\n    function increaseDebtAndSell(\n        address proceedsTo,\n        ERC721 collateralAsset,\n        IPaprController.SwapParams calldata params,\n        ReservoirOracleUnderwriter.OracleInfo calldata oracleInfo\n    ) external returns (uint256);\n\n    /// @notice removes debt from a vault and burns it by buying it on Uniswap in exchange for the controller's underlying token\n    /// @param account address reducing their debt\n    /// @param collateralAsset address of the collateral token the user would like to remove debt from\n    /// @param params parameters for the swap\n    /// @return amount amount of debt received from the swap and burned\n    function buyAndReduceDebt(address account, ERC721 collateralAsset, IPaprController.SwapParams calldata params)\n        external\n        returns (uint256);\n\n    /// @notice purchases a liquidation auction with the controller's papr token\n    /// @dev oracleInfo price must be type TWAP\n    /// @param auction auction to purchase\n    /// @param maxPrice maximum price to pay for the auction\n    /// @param sendTo address to send the collateral to if auction is won\n    function purchaseLiquidationAuctionNFT(\n        INFTEDA.Auction calldata auction,\n        uint256 maxPrice,\n        address sendTo,\n        ReservoirOracleUnderwriter.OracleInfo calldata oracleInfo\n    ) external;\n\n    /// @notice starts a liquidation auction for a vault if it is liquidatable\n    /// @dev oracleInfo price must be type TWAP\n    /// @param account address of the user who's vault to liquidate\n    /// @param collateral collateral to liquidate\n    /// @param oracleInfo oracle information for the collateral being liquidated\n    /// @return auction auction that was started\n    function startLiquidationAuction(\n        address account,\n        IPaprController.Collateral calldata collateral,\n        ReservoirOracleUnderwriter.OracleInfo calldata oracleInfo\n    ) external returns (INFTEDA.Auction memory auction);\n\n    /// @notice sets the Uniswap V3 pool that is used to determine mark\n    /// @dev owner function\n    /// @param _pool address of the Uniswap V3 pool\n    function setPool(address _pool) external;\n\n    /// @notice sets the funding period for interest payments\n    /// @param _fundingPeriod new funding period in seconds\n    function setFundingPeriod(uint256 _fundingPeriod) external;\n\n    /// @notice sets value of liquidationsLocked\n    /// @dev owner function for use in emergencies\n    /// @param locked new value for liquidationsLocked\n    function setLiquidationsLocked(bool locked) external;\n\n    /// @notice sets whether a collateral is allowed to be used to mint debt\n    /// @dev owner function\n    /// @param collateralConfigs configuration settings indicating whether a collateral is allowed or not\n    function setAllowedCollateral(IPaprController.CollateralAllowedConfig[] calldata collateralConfigs) external;\n\n    /// @notice transfers papr tokens held in controller from auction fees\n    /// @dev owner function\n    /// @param to address to send papr tokens to\n    /// @param amount amount of papr to send\n    /// @dev only controller owner will be able to execute this function\n    function sendPaprFromAuctionFees(address to, uint256 amount) external;\n\n    /// @notice burns papr tokens held in controller from auction fees\n    /// @param amount amount of papr to burn\n    /// @dev only controller owner will be able to execute this function\n    function burnPaprFromAuctionFees(uint256 amount) external;\n\n    /// @notice returns who owns a collateral token in a vault\n    /// @param collateral address of the collateral\n    /// @param tokenId tokenId of the collateral\n    function collateralOwner(ERC721 collateral, uint256 tokenId) external view returns (address);\n\n    /// @notice returns whether a token address is allowed to serve as collateral for a vault\n    /// @param collateral address of the collateral token\n    function isAllowed(address collateral) external view returns (bool);\n\n    /// @notice if liquidations are currently locked, meaning startLiquidationAuciton will revert\n    /// @dev for use in case of emergencies\n    /// @return liquidationsLocked whether liquidations are locked\n    function liquidationsLocked() external view returns (bool);\n\n    /// @notice boolean indicating whether token0 in pool is the underlying token\n    function token0IsUnderlying() external view returns (bool);\n\n    /// @notice maximum LTV a vault can have, expressed as a decimal scaled by 1e18\n    function maxLTV() external view returns (uint256);\n\n    /// @notice minimum time that must pass before consecutive collateral is liquidated from the same vault\n    function liquidationAuctionMinSpacing() external view returns (uint256);\n\n    /// @notice amount the price of an auction decreases by per auctionDecayPeriod, expressed as a decimal scaled by 1e18\n    function perPeriodAuctionDecayWAD() external view returns (uint256);\n\n    /// @notice amount of time that perPeriodAuctionDecayWAD is applied to, expressed in seconds\n    function auctionDecayPeriod() external view returns (uint256);\n\n    /// @notice the multiplier for the starting price of an auction, applied to the current price of the collateral in papr tokens\n    function auctionStartPriceMultiplier() external view returns (uint256);\n\n    /// @notice fee paid by the vault owner when their vault is liquidated if there was excess debt credited to their vault, in bips\n    function liquidationPenaltyBips() external view returns (uint256);\n\n    /// @notice returns the maximum debt that can be minted for a given collateral value\n    /// @param totalCollateraValue total value of the collateral\n    /// @return maxDebt maximum debt that can be minted, expressed in terms of the papr token\n    function maxDebt(uint256 totalCollateraValue) external view returns (uint256);\n\n    /// @notice returns information about a vault\n    /// @param account address of the vault owner\n    /// @param asset address of the collateral token associated with the vault\n    /// @return vaultInfo VaultInfo struct representing information about a vault\n    function vaultInfo(address account, ERC721 asset) external view returns (IPaprController.VaultInfo memory);\n}"
    },
    {
      "filename": "src/interfaces/IUniswapOracleFundingRateController.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {IFundingRateController} from \"./IFundingRateController.sol\";\n\ninterface IUniswapOracleFundingRateController is IFundingRateController {\n    /// @notice emitted when pool is set\n    /// @param pool the new pool value\n    event SetPool(address indexed pool);\n\n    /// @notice emitted if _setPool is called with a pool\n    /// that's tokens do not match pool()\n    error PoolTokensDoNotMatch();\n    error InvalidUniswapV3Pool();\n\n    /// @notice The address of the Uniswap pool used for mark()\n    /// @return pool address of the pool\n    function pool() external returns (address);\n}"
    },
    {
      "filename": "src/NFTEDA/interfaces/INFTEDA.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\ninterface INFTEDA {\n    /// @notice struct containing all auction info\n    /// @dev this struct is never stored, only a hash of it\n    struct Auction {\n        // the nft owner\n        address nftOwner;\n        // the nft token id\n        uint256 auctionAssetID;\n        // the nft contract address\n        ERC721 auctionAssetContract;\n        // How much the auction price will decay in each period\n        // expressed as percent scaled by 1e18, i.e. 1e18 = 100%\n        uint256 perPeriodDecayPercentWad;\n        // the number of seconds in the period over which perPeriodDecay occurs\n        uint256 secondsInPeriod;\n        // the auction start price\n        uint256 startPrice;\n        // the payment asset and quote asset for startPrice\n        ERC20 paymentAsset;\n    }\n\n    /// @notice emitted when an auction is started\n    /// @param auctionID the id of the auction that was started\n    /// @param auctionAssetID the token id of the ERC721 asset being auctioned\n    /// @param auctionAssetContract the contract address of the ERC721 asset being auctioned\n    /// @param nftOwner the owner of the ERC721 asset being auctioned\n    /// @param perPeriodDecayPercentWad How much the auction price will decay in each period\n    /// @param secondsInPeriod the number of seconds in the period over which perPeriodDecay occurs\n    /// @param startPrice the starting price of the auction\n    /// @param paymentAsset the payment asset and quote asset for startPrice\n    event StartAuction(\n        uint256 indexed auctionID,\n        uint256 indexed auctionAssetID,\n        ERC721 indexed auctionAssetContract,\n        address nftOwner,\n        uint256 perPeriodDecayPercentWad,\n        uint256 secondsInPeriod,\n        uint256 startPrice,\n        ERC20 paymentAsset\n    );\n\n    /// @param auctionID the id of the auction that has ended\n    /// @param price the price that the purchaser paid to receive the ERC721 asset being auctioned\n    event EndAuction(uint256 indexed auctionID, uint256 price);\n\n    /// @notice Returns the current price of the passed auction, reverts if no such auction exists\n    /// @param auction The auction for which the caller wants to know the current price\n    /// @return price the current amount required to purchase the NFT being sold in this auction\n    function auctionCurrentPrice(Auction calldata auction) external view returns (uint256);\n\n    /// @notice Returns a uint256 used to identify the auction\n    /// @dev Derived from the auction. Identitical auctions cannot exist simultaneously\n    /// @param auction The auction to get an ID for\n    /// @return id the id of this auction\n    function auctionID(Auction memory auction) external pure returns (uint256);\n\n    /// @notice Returns the time at which startAuction was most recently successfully called for the given auction id\n    /// @param id The id of the auction\n    function auctionStartTime(uint256 id) external view returns (uint256);\n}"
    },
    {
      "filename": "src/NFTEDA/NFTEDA.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n\nimport {INFTEDA} from \"./interfaces/INFTEDA.sol\";\nimport {EDAPrice} from \"./libraries/EDAPrice.sol\";\n\nabstract contract NFTEDA is INFTEDA {\n    using SafeTransferLib for ERC20;\n\n    error AuctionExists();\n    error InvalidAuction();\n    /// @param received The amount of payment received\n    /// @param expected The expected payment amount\n    error InsufficientPayment(uint256 received, uint256 expected);\n    /// @param currentPrice The current auction price\n    /// @param maxPrice The passed max price the purchaser is willing to pay\n    error MaxPriceTooLow(uint256 currentPrice, uint256 maxPrice);\n\n    /// @inheritdoc INFTEDA\n    function auctionCurrentPrice(INFTEDA.Auction calldata auction) public view virtual returns (uint256) {\n        uint256 id = auctionID(auction);\n        uint256 startTime = auctionStartTime(id);\n        if (startTime == 0) {\n            revert InvalidAuction();\n        }\n\n        return _auctionCurrentPrice(id, startTime, auction);\n    }\n\n    /// @inheritdoc INFTEDA\n    function auctionID(INFTEDA.Auction memory auction) public pure virtual returns (uint256) {\n        return uint256(keccak256(abi.encode(auction)));\n    }\n\n    /// @inheritdoc INFTEDA\n    function auctionStartTime(uint256 id) public view virtual returns (uint256);\n\n    /// @notice Creates an auction defined by the passed `auction`\n    /// @dev assumes the nft being sold is already controlled by the auction contract\n    /// @dev does no validation the auction, aside that it does not exist.\n    /// @dev if paymentAsset = address(0), purchase will not revert\n    /// @param auction The defintion of the auction\n    /// @return id the id of the auction\n    function _startAuction(INFTEDA.Auction memory auction) internal virtual returns (uint256 id) {\n        id = auctionID(auction);\n\n        if (auctionStartTime(id) != 0) {\n            revert AuctionExists();\n        }\n\n        _setAuctionStartTime(id);\n\n        emit StartAuction(\n            id,\n            auction.auctionAssetID,\n            auction.auctionAssetContract,\n            auction.nftOwner,\n            auction.perPeriodDecayPercentWad,\n            auction.secondsInPeriod,\n            auction.startPrice,\n            auction.paymentAsset\n            );\n    }\n\n    /// @notice purchases the NFT being sold in `auction`, reverts if current auction price exceed maxPrice\n    /// @param auction The auction selling the NFT\n    /// @param maxPrice The maximum the caller is willing to pay\n    function _purchaseNFT(INFTEDA.Auction memory auction, uint256 maxPrice, address sendTo)\n        internal\n        virtual\n        returns (uint256 startTime, uint256 price)\n    {\n        uint256 id = auctionID(auction);\n        startTime = auctionStartTime(id);\n\n        if (startTime == 0) {\n            revert InvalidAuction();\n        }\n        price = _auctionCurrentPrice(id, startTime, auction);\n\n        if (price > maxPrice) {\n            revert MaxPriceTooLow(price, maxPrice);\n        }\n\n        _clearAuctionState(id);\n\n        auction.auctionAssetContract.safeTransferFrom(address(this), sendTo, auction.auctionAssetID);\n\n        auction.paymentAsset.safeTransferFrom(msg.sender, address(this), price);\n\n        emit EndAuction(id, price);\n    }\n\n    /// @notice Sets the time at which the auction was started\n    /// @dev abstracted to a function to allow developer some freedom with how to store auction state\n    /// @param id The id of the auction\n    function _setAuctionStartTime(uint256 id) internal virtual;\n\n    /// @notice Clears all stored state for the auction\n    /// @dev abstracted to a function to allow developer some freedom with how to store auction state\n    /// @param id The id of the auction\n    function _clearAuctionState(uint256 id) internal virtual;\n\n    /// @notice Returns the current price of the passed auction, reverts if no such auction exists\n    /// @dev startTime is passed, optimized for cases where the auctionId has already been computed\n    /// @dev and startTime looked it up\n    /// @param startTime The start time of the auction\n    /// @param auction The auction for which the caller wants to know the current price\n    /// @return price the current amount required to purchase the NFT being sold in this auction\n    function _auctionCurrentPrice(uint256 id, uint256 startTime, INFTEDA.Auction memory auction)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        return EDAPrice.currentPrice(\n            auction.startPrice, block.timestamp - startTime, auction.secondsInPeriod, auction.perPeriodDecayPercentWad\n        );\n    }\n}"
    },
    {
      "filename": "src/PaprController.sol",
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.17;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC721, ERC721TokenReceiver} from \"solmate/tokens/ERC721.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {INFTEDA, NFTEDAStarterIncentive} from \"src/NFTEDA/extensions/NFTEDAStarterIncentive.sol\";\nimport {Ownable2Step} from \"openzeppelin-contracts/access/Ownable2Step.sol\";\nimport {Multicallable} from \"solady/utils/Multicallable.sol\";\n\nimport {PaprToken} from \"./PaprToken.sol\";\nimport {UniswapOracleFundingRateController} from \"./UniswapOracleFundingRateController.sol\";\nimport {ReservoirOracleUnderwriter} from \"src/ReservoirOracleUnderwriter.sol\";\nimport {IPaprController} from \"src/interfaces/IPaprController.sol\";\nimport {UniswapHelpers} from \"src/libraries/UniswapHelpers.sol\";\n\ncontract PaprController is\n    IPaprController,\n    UniswapOracleFundingRateController,\n    ERC721TokenReceiver,\n    Multicallable,\n    Ownable2Step,\n    ReservoirOracleUnderwriter,\n    NFTEDAStarterIncentive\n{\n    using SafeTransferLib for ERC20;\n\n    /// @dev what 1 = 100% is in basis points (bips)\n    uint256 public constant BIPS_ONE = 1e4;\n\n    bool public override liquidationsLocked;\n\n    /// @inheritdoc IPaprController\n    bool public immutable override token0IsUnderlying;\n\n    /// @inheritdoc IPaprController\n    uint256 public immutable override maxLTV;\n\n    /// @inheritdoc IPaprController\n    uint256 public immutable override liquidationAuctionMinSpacing = 2 days;\n\n    /// @inheritdoc IPaprController\n    uint256 public immutable override perPeriodAuctionDecayWAD = 0.7e18;\n\n    /// @inheritdoc IPaprController\n    uint256 public immutable override auctionDecayPeriod = 1 days;\n\n    /// @inheritdoc IPaprController\n    uint256 public immutable override auctionStartPriceMultiplier = 3;\n\n    /// @inheritdoc IPaprController\n    /// @dev Set to 10%\n    uint256 public immutable override liquidationPenaltyBips = 1000;\n\n    /// @inheritdoc IPaprController\n    mapping(ERC721 => mapping(uint256 => address)) public override collateralOwner;\n\n    /// @inheritdoc IPaprController\n    mapping(address => bool) public override isAllowed;\n\n    /// @dev account => asset => vaultInfo\n    mapping(address => mapping(ERC721 => IPaprController.VaultInfo)) private _vaultInfo;\n\n    /// @dev does not validate args\n    /// e.g. does not check whether underlying or oracleSigner are address(0)\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256 _maxLTV,\n        uint256 indexMarkRatioMax,\n        uint256 indexMarkRatioMin,\n        ERC20 underlying,\n        address oracleSigner\n    )\n        NFTEDAStarterIncentive(1e17)\n        UniswapOracleFundingRateController(underlying, new PaprToken(name, symbol), indexMarkRatioMax, indexMarkRatioMin)\n        ReservoirOracleUnderwriter(oracleSigner, address(underlying))\n    {\n        maxLTV = _maxLTV;\n        token0IsUnderlying = address(underlying) < address(papr);\n        uint256 underlyingONE = 10 ** underlying.decimals();\n        uint160 initSqrtRatio;\n\n        // initialize the pool at 1:1\n        if (token0IsUnderlying) {\n            initSqrtRatio = UniswapHelpers.oneToOneSqrtRatio(underlyingONE, 10 ** 18);\n        } else {\n            initSqrtRatio = UniswapHelpers.oneToOneSqrtRatio(10 ** 18, underlyingONE);\n        }\n\n        address _pool = UniswapHelpers.deployAndInitPool(address(underlying), address(papr), 10000, initSqrtRatio);\n\n        _init(underlyingONE, _pool);\n    }\n\n    /// @inheritdoc IPaprController\n    function addCollateral(IPaprController.Collateral[] calldata collateralArr) external override {\n        for (uint256 i = 0; i < collateralArr.length;) {\n            _addCollateralToVault(msg.sender, collateralArr[i]);\n            collateralArr[i].addr.transferFrom(msg.sender, address(this), collateralArr[i].id);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @inheritdoc IPaprController\n    function removeCollateral(\n        address sendTo,\n        IPaprController.Collateral[] calldata collateralArr,\n        ReservoirOracleUnderwriter.OracleInfo calldata oracleInfo\n    ) external override {\n        uint256 cachedTarget = updateTarget();\n        uint256 oraclePrice;\n        ERC721 collateralAddr;\n\n        for (uint256 i = 0; i < collateralArr.length;) {\n            if (i == 0) {\n                collateralAddr = collateralArr[i].addr;\n                oraclePrice =\n                    underwritePriceForCollateral(collateralAddr, ReservoirOracleUnderwriter.PriceKind.LOWER, oracleInfo);\n            } else {\n                if (collateralAddr != collateralArr[i].addr) {\n                    revert CollateralAddressesDoNotMatch();\n                }\n            }\n\n            _removeCollateral(sendTo, collateralArr[i], oraclePrice, cachedTarget);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @inheritdoc IPaprController\n    function increaseDebt(\n        address mintTo,\n        ERC721 asset,\n        uint256 amount,\n        ReservoirOracleUnderwriter.OracleInfo calldata oracleInfo\n    ) external override {\n        _increaseDebt({account: msg.sender, asset: asset, mintTo: mintTo, amount: amount, oracleInfo: oracleInfo});\n    }\n\n    /// @inheritdoc IPaprController\n    function reduceDebt(address account, ERC721 asset, uint256 amount) external override {\n        _reduceDebt({account: account, asset: asset, burnFrom: msg.sender, amount: amount});\n    }\n\n    /// @notice Handler for safeTransferFrom of an NFT\n    /// @dev Should be preferred to `addCollateral` if only one NFT is being added\n    /// to avoid approval call and save gas\n    /// @param from the current owner of the nft\n    /// @param _id the id of the NFT\n    /// @param data encoded IPaprController.OnERC721ReceivedArgs\n    /// @return selector indicating succesful receiving of the NFT\n    function onERC721Received(address from, address, uint256 _id, bytes calldata data)\n        external\n        override\n        returns (bytes4)\n    {\n        IPaprController.OnERC721ReceivedArgs memory request = abi.decode(data, (IPaprController.OnERC721ReceivedArgs));\n\n        IPaprController.Collateral memory collateral = IPaprController.Collateral(ERC721(msg.sender), _id);\n\n        _addCollateralToVault(from, collateral);\n\n        if (request.swapParams.minOut > 0) {\n            _increaseDebtAndSell(from, request.proceedsTo, ERC721(msg.sender), request.swapParams, request.oracleInfo);\n        } else if (request.debt > 0) {\n            _increaseDebt(from, collateral.addr, request.proceedsTo, request.debt, request.oracleInfo);\n        }\n\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n\n    /// CONVENIENCE SWAP FUNCTIONS ///\n\n    /// @inheritdoc IPaprController\n    function increaseDebtAndSell(\n        address proceedsTo,\n        ERC721 collateralAsset,\n        IPaprController.SwapParams calldata params,\n        ReservoirOracleUnderwriter.OracleInfo calldata oracleInfo\n    ) external override returns (uint256 amountOut) {\n        bool hasFee = params.swapFeeBips != 0;\n\n        (amountOut,) = UniswapHelpers.swap(\n            pool,\n            hasFee ? address(this) : proceedsTo,\n            !token0IsUnderlying,\n            params.amount,\n            params.minOut,\n            params.sqrtPriceLimitX96,\n            abi.encode(msg.sender, collateralAsset, oracleInfo)\n        );\n\n        if (hasFee) {\n            uint256 fee = amountOut * params.swapFeeBips / BIPS_ONE;\n            underlying.transfer(params.swapFeeTo, fee);\n            underlying.transfer(proceedsTo, amountOut - fee);\n        }\n    }\n\n    /// @inheritdoc IPaprController\n    function buyAndReduceDebt(address account, ERC721 collateralAsset, IPaprController.SwapParams calldata params)\n        external\n        override\n        returns (uint256)\n    {\n        bool h"
    }
  ]
}