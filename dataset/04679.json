{
  "Title": "Remove unnecessary code",
  "Content": "* ***duringVote function modifier***  \n\nThe [**duringVote** function modifier](https://github.com/ether-camp/virtual-accelerator/blob/6665fdd4b71088443a74d1ed9fda52c6a8c8b975/contracts/ProjectKudos.sol#L330) is only used once. Consider removing it and adding the checks [at the start of **giveKudos** function](https://github.com/ether-camp/virtual-accelerator/blob/6665fdd4b71088443a74d1ed9fda52c6a8c8b975/contracts/ProjectKudos.sol#L126). Having unneeded extra variables and code increases risk and attack surface for contract’s invariants to be broken.  \n\nEDIT: EtherCamp fixed this problem [on these commits](https://github.com/ether-camp/virtual-accelerator/compare/6665fdd4b71088443a74d1ed9fda52c6a8c8b975...9a2291ac505e3b92fa44a06658ac940fb8fc49e6).\n* ***GrantReason enum***  \n\n[The GrantReason enum](https://github.com/ether-camp/virtual-accelerator/blob/6665fdd4b71088443a74d1ed9fda52c6a8c8b975/contracts/ProjectKudos.sol#L20) is not needed and adds extra complexity with no benefit. The same clarity can be obtained by having two uint constants called `uint constant GRANT_REASON_FACEBOOK = 0;` and `uint constant GRANT_REASON_TWITTER = 1;`. This would allow removing [the grantUintToReason and grantReasonToUint functions](https://github.com/ether-camp/virtual-accelerator/blob/6665fdd4b71088443a74d1ed9fda52c6a8c8b975/contracts/ProjectKudos.sol#L281-L303).  \n\nEDIT: EtherCamp fixed this problem [on these commits](https://github.com/ether-camp/virtual-accelerator/compare/6665fdd4b71088443a74d1ed9fda52c6a8c8b975...9a2291ac505e3b92fa44a06658ac940fb8fc49e6).\n* ***strToBytes function***  \n\nThe function is used to convert strings to byte arrays. It’s only used to convert from project string codes into project byte32 codes. Consider removing the function and requiring caller of contract send byte32 codes directly (handle conversions in Dapp UX). Even more, consider using strings directly inside the contract, changing the `projects` mapping from `mapping(bytes32 =&gt; ProjectInfo)` to `mapping(string =&gt; ProjectInfo)` to improve code readability and reduce complexity.  \n\nEDIT: EtherCamp fixed this problem [on these commits](https://github.com/ether-camp/virtual-accelerator/compare/6665fdd4b71088443a74d1ed9fda52c6a8c8b975...9a2291ac505e3b92fa44a06658ac940fb8fc49e6).\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/ProjectKudos.sol",
      "content": "pragma solidity ^0.4.0;\r\n\r\n/**\r\n * @title Project Kudos\r\n * \r\n * Events voting system of the Virtual Accelerator.\r\n * Includes the voting for both judges and fans.\r\n * \r\n */\r\ncontract ProjectKudos {\r\n    \r\n    // votes limit for judge\r\n    uint KUDOS_LIMIT_JUDGE = 1000;\r\n\r\n    // votes limit for regular user\r\n    uint KUDOS_LIMIT_USER  = 10;\r\n\r\n    // enumerates reasons \r\n    // which additional votes can be granted for\r\n    enum GrantReason {\r\n        Facebook,\r\n        Twitter, \r\n        Fake\r\n    }\r\n\r\n    // keeps project votes data\r\n    struct ProjectInfo {\r\n        mapping(address => uint) kudosByUser;\r\n        uint kudosTotal;\r\n    }\r\n\r\n    // keeps user votes data\r\n    struct UserInfo {\r\n        uint kudosLimit;\r\n        uint kudosGiven;\r\n        bool isJudge;\r\n        mapping(uint => bool) grant;\r\n    }\r\n\r\n    // keeps links between user's votes \r\n    // and projects he voted for\r\n    struct UserIndex {\r\n        bytes32[] projects;\r\n        uint[] kudos;\r\n        mapping(bytes32 => uint) kudosIdx;\r\n    }\r\n    \r\n    // keeps time frames for vote period \r\n    struct VotePeriod {\r\n        uint start;\r\n        uint end;\r\n    }\r\n    \r\n    // contract creator's address\r\n    address owner;\r\n    \r\n    // vote period\r\n    VotePeriod votePeriod;\r\n\r\n    // user votes mapping\r\n    mapping(address => UserInfo) users;\r\n\r\n    // user index, \r\n    // helps to get votes given by one user for every project\r\n    mapping(address => UserIndex) usersIndex;\r\n\r\n    // project votes mapping\r\n    mapping(bytes32 => ProjectInfo) projects;\r\n    \r\n    // emitted when vote is done\r\n    event Vote(\r\n        // address of voter\r\n        address indexed voter,\r\n        // sha3 of project code\r\n        bytes32 indexed projectCode,\r\n        // votes given\r\n        uint indexed count\r\n    );\r\n    \r\n    /**\r\n     * @dev Contract's constructor.\r\n     * Stores contract's owner and sets up vote period\r\n     */\r\n    function ProjectKudos() {\r\n        \r\n        owner = msg.sender;\r\n        \r\n        votePeriod = VotePeriod(\r\n            1479996000,     // GMT: 24-Nov-2016 14:00, Voting starts, 1st week passed\r\n            1482415200      // GMT: 22-Dec-2016 14:00, Voting ends, Hackathon ends\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Registers voter to the event.\r\n     * Executable only by contract's owner.\r\n     *\r\n     * @param userAddres address of the user to register\r\n     * @param isJudge should be true if user is judge, false otherwise\r\n     */\r\n    function register(address userAddres, bool isJudge) onlyOwner {\r\n                            \r\n        UserInfo user = users[userAddres];\r\n\r\n        if (user.kudosLimit > 0) throw;\r\n\r\n        if (isJudge)\r\n            user.kudosLimit = KUDOS_LIMIT_JUDGE;\r\n        else \r\n            user.kudosLimit = KUDOS_LIMIT_USER;\r\n        \r\n        user.isJudge = isJudge;\r\n        \r\n        users[userAddres] = user;\r\n    }\r\n    \r\n    /**\r\n     *  @dev Gives votes to the project.\r\n     *  Can only be executed within vote period.\r\n     *  User signed the Tx becomes votes giver.\r\n     *\r\n     *  @param projectCode code of the project, must be less than or equal to 32 bytes\r\n     *  @param kudos - votes to be given\r\n     */\r\n    function giveKudos(string projectCode, uint kudos) duringVote {\r\n        \r\n        UserInfo giver = users[msg.sender];\r\n\r\n        if (giver.kudosGiven + kudos > giver.kudosLimit) throw;\r\n        \r\n        bytes32 code = strToBytes(projectCode);\r\n        ProjectInfo project = projects[code];\r\n\r\n        giver.kudosGiven += kudos;\r\n        project.kudosTotal += kudos;\r\n        project.kudosByUser[msg.sender] += kudos;\r\n\r\n        // save index of user voting history\r\n        updateUsersIndex(code, project.kudosByUser[msg.sender]);\r\n        \r\n        Vote(msg.sender, sha3(projectCode), kudos);\r\n    }\r\n\r\n    /**\r\n     * @dev Grants extra kudos for identity proof.\r\n     *\r\n     * @param userToGrant address of user to grant additional \r\n     * votes for social proof\r\n     * \r\n     * @param reason granting reason, \r\n     * possible reasons are listed in GrantReason enum\r\n     */         \r\n    function grantKudos(address userToGrant, uint reason) onlyOwner {\r\n    \r\n        UserInfo user = users[userToGrant];\r\n    \r\n        GrantReason grantReason = grantUintToReason(reason);\r\n        \r\n        if (grantReason != GrantReason.Facebook &&\r\n            grantReason != GrantReason.Twitter) throw;\r\n    \r\n        // if user is judge his identity is known\r\n        // not reasonble to grant more kudos for social \r\n        // proof.\r\n        if (user.isJudge) throw;\r\n        \r\n        // if not granted for that reason yet\r\n        if (user.grant[reason]) throw;\r\n        \r\n        // grant 100 votes\r\n        user.kudosLimit += 100;\r\n        \r\n        // mark reason \r\n        user.grant[reason] = true;\r\n    }\r\n    \r\n    \r\n    // ********************* //\r\n    // *   Constant Calls  * //\r\n    // ********************* //\r\n    \r\n    /**\r\n     * @dev Returns total votes given to the project\r\n     * \r\n     * @param projectCode project's code\r\n     * \r\n     * @return number of give votes\r\n     */\r\n    function getProjectKudos(string projectCode) constant returns(uint) {\r\n        bytes32 code = strToBytes(projectCode);\r\n        ProjectInfo project = projects[code];\r\n        return project.kudosTotal;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an array of votes given to the project\r\n     * corresponding to array of users passed in function call\r\n     * \r\n     * @param projectCode project's code\r\n     * @param users array of user addresses\r\n     * \r\n     * @return array of votes given by passed users\r\n     */\r\n    function getProjectKudosByUsers(string projectCode, address[] users) constant returns(uint[]) {\r\n        bytes32 code = strToBytes(projectCode);\r\n        ProjectInfo project = projects[code];\r\n        mapping(address => uint) kudosByUser = project.kudosByUser;\r\n        uint[] memory userKudos = new uint[](users.length);\r\n        for (uint i = 0; i < users.length; i++) {\r\n            userKudos[i] = kudosByUser[users[i]];    \r\n       }\r\n       \r\n       return userKudos;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns votes given by speicified user \r\n     * to the list of projects ever voted by that user\r\n     * \r\n     * @param giver user's address\r\n     * @return projects array of project codes represented by bytes32 array\r\n     * @return kudos array of votes given by user, \r\n     *         index of vote corresponds to index of project from projects array\r\n     */\r\n    function getKudosPerProject(address giver) constant returns (bytes32[] projects, uint[] kudos) {\r\n        UserIndex idx = usersIndex[giver];\r\n        projects = idx.projects;\r\n        kudos = idx.kudos;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns votes allowed to be given by user\r\n     * \r\n     * @param addr user's address\r\n     * @return number of votes left\r\n     */\r\n    function getKudosLeft(address addr) constant returns(uint) {\r\n        UserInfo user = users[addr];\r\n        return user.kudosLimit - user.kudosGiven;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns votes given by user\r\n     * \r\n     * @param addr user's address\r\n     * @return number of votes given\r\n     */\r\n    function getKudosGiven(address addr) constant returns(uint) {\r\n        UserInfo user = users[addr];\r\n        return user.kudosGiven;\r\n    }\r\n\r\n   \r\n    // ********************* //\r\n    // *   Private Calls   * //\r\n    // ********************* //\r\n    \r\n    /**\r\n     * @dev Private function. Updates users index\r\n     * \r\n     * @param code project code represented by bytes32 array\r\n     * @param kudos votes total given to the project by sender\r\n     */\r\n    function updateUsersIndex(bytes32 code, uint kudos) private {\r\n        \r\n        UserIndex idx = usersIndex[msg.sender];\r\n        uint i = idx.kudosIdx[code];\r\n        \r\n        // add new entry to index\r\n        if (i == 0) {\r\n            i = idx.projects.length + 1;\r\n            idx.projects.length += 1;\r\n            idx.kudos.length += 1;\r\n            idx.projects[i - 1] = code;\r\n            idx.kudosIdx[code] = i;\r\n        }\r\n\r\n        idx.kudos[i - 1] = kudos;\r\n    }\r\n    \r\n    /**\r\n     * @dev Translates GrantReason code to GrantReason\r\n     * \r\n     * @param reason the code of the reason\r\n     * @return GrantReason corresponding to the code\r\n     */\r\n    function grantUintToReason(uint reason) private returns (GrantReason result) {\r\n        if (reason == 0)  return GrantReason.Facebook;\r\n        if (reason == 1)  return GrantReason.Twitter;\r\n        return GrantReason.Fake;\r\n    }\r\n    \r\n    /**\r\n     * @dev Translates GrantReason to its code\r\n     * \r\n     * @param reason GrantReason instance\r\n     * @return corresponding reason code\r\n     */\r\n    function grantReasonToUint(GrantReason reason) private returns (uint result) {\r\n        if (reason == GrantReason.Facebook) return 0;\r\n        if (reason == GrantReason.Twitter)  return 1;\r\n        return 3;\r\n    }\r\n    \r\n    /**\r\n     * @dev Low level function.\r\n     * Converts string to bytes32 array.\r\n     * Throws if string length is more than 32 bytes\r\n     * \r\n     * @param str string\r\n     * @return bytes32 representation of str\r\n     */\r\n    function strToBytes(string str) private returns (bytes32 ret) {\r\n        \r\n        if (bytes(str).length > 32) throw;\r\n        \r\n        assembly {\r\n            ret := mload(add(str, 32))\r\n        }\r\n    } \r\n\r\n    \r\n    // ********************* //\r\n    // *     Modifiers     * //\r\n    // ********************* //\r\n    \r\n    /**\r\n     * @dev Throws if called not during the vote period\r\n     */\r\n    modifier duringVote() {\r\n        if (now < votePeriod.start) throw;\r\n        if (now >= votePeriod.end) throw;\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Throws if called not by contract's owner\r\n     */\r\n    modifier onlyOwner() { \r\n        if (msg.sender != owner) throw;\r\n        _;\r\n    }\r\n}"
    },
    {
      "filename": "contracts/ProjectKudos.sol",
      "content": "pragma solidity ^0.4.0;\r\n\r\n/**\r\n * @title Project Kudos\r\n * \r\n * Events voting system of the Virtual Accelerator.\r\n * Includes the voting for both judges and fans.\r\n * \r\n */\r\ncontract ProjectKudos {\r\n    \r\n    // votes limit for judge\r\n    uint KUDOS_LIMIT_JUDGE = 1000;\r\n\r\n    // votes limit for regular user\r\n    uint KUDOS_LIMIT_USER  = 10;\r\n\r\n    // enumerates reasons \r\n    // which additional votes can be granted for\r\n    enum GrantReason {\r\n        Facebook,\r\n        Twitter, \r\n        Fake\r\n    }\r\n\r\n    // keeps project votes data\r\n    struct ProjectInfo {\r\n        mapping(address => uint) kudosByUser;\r\n        uint kudosTotal;\r\n    }\r\n\r\n    // keeps user votes data\r\n    struct UserInfo {\r\n        uint kudosLimit;\r\n        uint kudosGiven;\r\n        bool isJudge;\r\n        mapping(uint => bool) grant;\r\n    }\r\n\r\n    // keeps links between user's votes \r\n    // and projects he voted for\r\n    struct UserIndex {\r\n        bytes32[] projects;\r\n        uint[] kudos;\r\n        mapping(bytes32 => uint) kudosIdx;\r\n    }\r\n    \r\n    // keeps time frames for vote period \r\n    struct VotePeriod {\r\n        uint start;\r\n        uint end;\r\n    }\r\n    \r\n    // contract creator's address\r\n    address owner;\r\n    \r\n    // vote period\r\n    VotePeriod votePeriod;\r\n\r\n    // user votes mapping\r\n    mapping(address => UserInfo) users;\r\n\r\n    // user index, \r\n    // helps to get votes given by one user for every project\r\n    mapping(address => UserIndex) usersIndex;\r\n\r\n    // project votes mapping\r\n    mapping(bytes32 => ProjectInfo) projects;\r\n    \r\n    // emitted when vote is done\r\n    event Vote(\r\n        // address of voter\r\n        address indexed voter,\r\n        // sha3 of project code\r\n        bytes32 indexed projectCode,\r\n        // votes given\r\n        uint indexed count\r\n    );\r\n    \r\n    /**\r\n     * @dev Contract's constructor.\r\n     * Stores contract's owner and sets up vote period\r\n     */\r\n    function ProjectKudos() {\r\n        \r\n        owner = msg.sender;\r\n        \r\n        votePeriod = VotePeriod(\r\n            1479996000,     // GMT: 24-Nov-2016 14:00, Voting starts, 1st week passed\r\n            1482415200      // GMT: 22-Dec-2016 14:00, Voting ends, Hackathon ends\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Registers voter to the event.\r\n     * Executable only by contract's owner.\r\n     *\r\n     * @param userAddres address of the user to register\r\n     * @param isJudge should be true if user is judge, false otherwise\r\n     */\r\n    function register(address userAddres, bool isJudge) onlyOwner {\r\n                            \r\n        UserInfo user = users[userAddres];\r\n\r\n        if (user.kudosLimit > 0) throw;\r\n\r\n        if (isJudge)\r\n            user.kudosLimit = KUDOS_LIMIT_JUDGE;\r\n        else \r\n            user.kudosLimit = KUDOS_LIMIT_USER;\r\n        \r\n        user.isJudge = isJudge;\r\n        \r\n        users[userAddres] = user;\r\n    }\r\n    \r\n    /**\r\n     *  @dev Gives votes to the project.\r\n     *  Can only be executed within vote period.\r\n     *  User signed the Tx becomes votes giver.\r\n     *\r\n     *  @param projectCode code of the project, must be less than or equal to 32 bytes\r\n     *  @param kudos - votes to be given\r\n     */\r\n    function giveKudos(string projectCode, uint kudos) duringVote {\r\n        \r\n        UserInfo giver = users[msg.sender];\r\n\r\n        if (giver.kudosGiven + kudos > giver.kudosLimit) throw;\r\n        \r\n        bytes32 code = strToBytes(projectCode);\r\n        ProjectInfo project = projects[code];\r\n\r\n        giver.kudosGiven += kudos;\r\n        project.kudosTotal += kudos;\r\n        project.kudosByUser[msg.sender] += kudos;\r\n\r\n        // save index of user voting history\r\n        updateUsersIndex(code, project.kudosByUser[msg.sender]);\r\n        \r\n        Vote(msg.sender, sha3(projectCode), kudos);\r\n    }\r\n\r\n    /**\r\n     * @dev Grants extra kudos for identity proof.\r\n     *\r\n     * @param userToGrant address of user to grant additional \r\n     * votes for social proof\r\n     * \r\n     * @param reason granting reason, \r\n     * possible reasons are listed in GrantReason enum\r\n     */         \r\n    function grantKudos(address userToGrant, uint reason) onlyOwner {\r\n    \r\n        UserInfo user = users[userToGrant];\r\n    \r\n        GrantReason grantReason = grantUintToReason(reason);\r\n        \r\n        if (grantReason != GrantReason.Facebook &&\r\n            grantReason != GrantReason.Twitter) throw;\r\n    \r\n        // if user is judge his identity is known\r\n        // not reasonble to grant more kudos for social \r\n        // proof.\r\n        if (user.isJudge) throw;\r\n        \r\n        // if not granted for that reason yet\r\n        if (user.grant[reason]) throw;\r\n        \r\n        // grant 100 votes\r\n        user.kudosLimit += 100;\r\n        \r\n        // mark reason \r\n        user.grant[reason] = true;\r\n    }\r\n    \r\n    \r\n    // ********************* //\r\n    // *   Constant Calls  * //\r\n    // ********************* //\r\n    \r\n    /**\r\n     * @dev Returns total votes given to the project\r\n     * \r\n     * @param projectCode project's code\r\n     * \r\n     * @return number of give votes\r\n     */\r\n    function getProjectKudos(string projectCode) constant returns(uint) {\r\n        bytes32 code = strToBytes(projectCode);\r\n        ProjectInfo project = projects[code];\r\n        return project.kudosTotal;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an array of votes given to the project\r\n     * corresponding to array of users passed in function call\r\n     * \r\n     * @param projectCode project's code\r\n     * @param users array of user addresses\r\n     * \r\n     * @return array of votes given by passed users\r\n     */\r\n    function getProjectKudosByUsers(string projectCode, address[] users) constant returns(uint[]) {\r\n        bytes32 code = strToBytes(projectCode);\r\n        ProjectInfo project = projects[code];\r\n        mapping(address => uint) kudosByUser = project.kudosByUser;\r\n        uint[] memory userKudos = new uint[](users.length);\r\n        for (uint i = 0; i < users.length; i++) {\r\n            userKudos[i] = kudosByUser[users[i]];    \r\n       }\r\n       \r\n       return userKudos;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns votes given by speicified user \r\n     * to the list of projects ever voted by that user\r\n     * \r\n     * @param giver user's address\r\n     * @return projects array of project codes represented by bytes32 array\r\n     * @return kudos array of votes given by user, \r\n     *         index of vote corresponds to index of project from projects array\r\n     */\r\n    function getKudosPerProject(address giver) constant returns (bytes32[] projects, uint[] kudos) {\r\n        UserIndex idx = usersIndex[giver];\r\n        projects = idx.projects;\r\n        kudos = idx.kudos;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns votes allowed to be given by user\r\n     * \r\n     * @param addr user's address\r\n     * @return number of votes left\r\n     */\r\n    function getKudosLeft(address addr) constant returns(uint) {\r\n        UserInfo user = users[addr];\r\n        return user.kudosLimit - user.kudosGiven;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns votes given by user\r\n     * \r\n     * @param addr user's address\r\n     * @return number of votes given\r\n     */\r\n    function getKudosGiven(address addr) constant returns(uint) {\r\n        UserInfo user = users[addr];\r\n        return user.kudosGiven;\r\n    }\r\n\r\n   \r\n    // ********************* //\r\n    // *   Private Calls   * //\r\n    // ********************* //\r\n    \r\n    /**\r\n     * @dev Private function. Updates users index\r\n     * \r\n     * @param code project code represented by bytes32 array\r\n     * @param kudos votes total given to the project by sender\r\n     */\r\n    function updateUsersIndex(bytes32 code, uint kudos) private {\r\n        \r\n        UserIndex idx = usersIndex[msg.sender];\r\n        uint i = idx.kudosIdx[code];\r\n        \r\n        // add new entry to index\r\n        if (i == 0) {\r\n            i = idx.projects.length + 1;\r\n            idx.projects.length += 1;\r\n            idx.kudos.length += 1;\r\n            idx.projects[i - 1] = code;\r\n            idx.kudosIdx[code] = i;\r\n        }\r\n\r\n        idx.kudos[i - 1] = kudos;\r\n    }\r\n    \r\n    /**\r\n     * @dev Translates GrantReason code to GrantReason\r\n     * \r\n     * @param reason the code of the reason\r\n     * @return GrantReason corresponding to the code\r\n     */\r\n    function grantUintToReason(uint reason) private returns (GrantReason result) {\r\n        if (reason == 0)  return GrantReason.Facebook;\r\n        if (reason == 1)  return GrantReason.Twitter;\r\n        return GrantReason.Fake;\r\n    }\r\n    \r\n    /**\r\n     * @dev Translates GrantReason to its code\r\n     * \r\n     * @param reason GrantReason instance\r\n     * @return corresponding reason code\r\n     */\r\n    function grantReasonToUint(GrantReason reason) private returns (uint result) {\r\n        if (reason == GrantReason.Facebook) return 0;\r\n        if (reason == GrantReason.Twitter)  return 1;\r\n        return 3;\r\n    }\r\n    \r\n    /**\r\n     * @dev Low level function.\r\n     * Converts string to bytes32 array.\r\n     * Throws if string length is more than 32 bytes\r\n     * \r\n     * @param str string\r\n     * @return bytes32 representation of str\r\n     */\r\n    function strToBytes(string str) private returns (bytes32 ret) {\r\n        \r\n        if (bytes(str).length > 32) throw;\r\n        \r\n        assembly {\r\n            ret := mload(add(str, 32))\r\n        }\r\n    } \r\n\r\n    \r\n    // ********************* //\r\n    // *     Modifiers     * //\r\n    // ********************* //\r\n    \r\n    /**\r\n     * @dev Throws if called not during the vote period\r\n     */\r\n    modifier duringVote() {\r\n        if (now < votePeriod.start) throw;\r\n        if (now >= votePeriod.end) throw;\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Throws if called not by contract's owner\r\n     */\r\n    modifier onlyOwner() { \r\n        if (msg.sender != owner) throw;\r\n        _;\r\n    }\r\n}"
    }
  ]
}