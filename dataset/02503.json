{
  "Title": "H-8: Remaining collateral used by ERC721Pool is missed in Auctions take and bucketTake return structures",
  "Content": "# Issue H-8: Remaining collateral used by ERC721Pool is missed in Auctions take and bucketTake return structures \n\nSource: https://github.com/sherlock-audit/2023-01-ajna-judging/issues/103 \n\n## Found by \nhyh\n\n## Summary\n\nERC721Pool's take() and bucketTake() use remaining collateral variable to adjust borrower's collateral ids array after their debt is settled in an auction. In both cases this variable isn't initialized in Auctions's take() and bucketTake() and all collateral of the borrower ends up being frozen in the pool.\n\n## Vulnerability Detail\n\nBeing run with uninitialized zero `result.remainingCollateral`, _rebalanceTokens() will remove all the collateral ids from the borrower and place them into `bucketTokenIds`, i.e. move all borrowers collateral to the LP's cumulative collateral account. Those funds will be permanently frozen as other accounting parts will not have them recorded in any bucket, so no LP be able to withdraw extra funds.\n\n## Impact\n\nBorrower's collateral funds will be permanently frozen in full whenever take() and bucketTake() result in auction settlement.\n\nThis takes place as after those ids was removed from `borrowerTokenIds` any operation of the borrower that should result in collateral being returned to them will be reverted instead.\n\n## Code Snippet\n\nWhile being used in `_rebalanceTokens(borrowerAddress_, result.remainingCollateral)` call, the `result.remainingCollateral` isn't initialized and is always zero:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/ERC721Pool.sol#L405-L460\n\n```solidity\n    function take(\n        address        borrowerAddress_,\n        uint256        collateral_,\n        address        callee_,\n        bytes calldata data_\n    ) external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        TakeResult memory result = Auctions.take(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_,\n            Maths.wad(collateral_),\n            1\n        );\n\n        // update pool balances state\n        uint256 t0PoolDebt      = poolBalances.t0Debt;\n        uint256 t0DebtInAuction = poolBalances.t0DebtInAuction;\n\n        if (result.t0DebtPenalty != 0) {\n            t0PoolDebt      += result.t0DebtPenalty;\n            t0DebtInAuction += result.t0DebtPenalty;\n        }\n\n        t0PoolDebt      -= result.t0RepayAmount;\n        t0DebtInAuction -= result.t0DebtInAuctionChange;\n\n        poolBalances.t0Debt            =  t0PoolDebt;\n        poolBalances.t0DebtInAuction   =  t0DebtInAuction;\n        poolBalances.pledgedCollateral -= result.collateralAmount;\n\n        // update pool interest rate state\n        poolState.debt       =  result.poolDebt;\n        poolState.collateral -= result.collateralAmount;\n        _updateInterestState(poolState, result.newLup);\n\n        // transfer rounded collateral from pool to taker\n        uint256[] memory tokensTaken = _transferFromPoolToAddress(\n            callee_,\n            borrowerTokenIds[borrowerAddress_],\n            result.collateralAmount / 1e18\n        );\n\n        if (data_.length != 0) {\n            IERC721Taker(callee_).atomicSwapCallback(\n                tokensTaken,\n                result.quoteTokenAmount / _getArgUint256(QUOTE_SCALE), \n                data_\n            );\n        }\n\n        if (result.settledAuction) _rebalanceTokens(borrowerAddress_, result.remainingCollateral);\n```\n\nThe reason is take doesn't fill `result.remainingCollateral = borrower.collateral` in the end of function:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/external/Auctions.sol#L538-L594\n\n```solidity\n    function take(\n        AuctionsState storage auctions_,\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        LoansState storage loans_,\n        PoolState memory poolState_,\n        address borrowerAddress_,\n        uint256 collateral_,\n        uint256 collateralScale_\n    ) external returns (TakeResult memory result_) {\n        Borrower memory borrower = loans_.borrowers[borrowerAddress_];\n\n        // revert if borrower's collateral is 0 or if maxCollateral to be taken is 0\n        if (borrower.collateral == 0 || collateral_ == 0) revert InsufficientCollateral();\n\n        (\n            result_.collateralAmount,\n            result_.quoteTokenAmount,\n            result_.t0RepayAmount,\n            borrower.t0Debt,\n            result_.t0DebtPenalty,\n            result_.excessQuoteToken\n        ) = _take(\n            auctions_,\n            TakeParams({\n                borrower:        borrowerAddress_,\n                collateral:      borrower.collateral,\n                t0Debt:          borrower.t0Debt,\n                takeCollateral:  collateral_,\n                inflator:        poolState_.inflator,\n                poolType:        poolState_.poolType,\n                collateralScale: collateralScale_\n            })\n        );\n\n        borrower.collateral -= result_.collateralAmount;\n\n        if (result_.t0DebtPenalty != 0) {\n            poolState_.debt += Maths.wmul(result_.t0DebtPenalty, poolState_.inflator);\n        }\n\n        (\n            result_.poolDebt,\n            result_.newLup,\n            result_.t0DebtInAuctionChange,\n            result_.settledAuction\n        ) = _takeLoan(\n            auctions_,\n            buckets_,\n            deposits_,\n            loans_,\n            poolState_,\n            borrower,\n            borrowerAddress_,\n            result_.t0RepayAmount\n        );\n    }\n```\n\nSame for bucketTake(), it's used, but not filled, so `result.remainingCollateral` is always uninitialized zero:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/ERC721Pool.sol#L476-L518\n\n```solidity\n    function bucketTake(\n        address borrowerAddress_,\n        bool    depositTake_,\n        uint256 index_\n    ) external override nonReentrant {\n\n        PoolState memory poolState = _accruePoolInterest();\n\n        BucketTakeResult memory result = Auctions.bucketTake(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_,\n            depositTake_,\n            index_,\n            1\n        );\n\n        // update pool balances state\n        uint256 t0PoolDebt      = poolBalances.t0Debt;\n        uint256 t0DebtInAuction = poolBalances.t0DebtInAuction;\n\n        if (result.t0DebtPenalty != 0) {\n            t0PoolDebt      += result.t0DebtPenalty;\n            t0DebtInAuction += result.t0DebtPenalty;\n        }\n\n        t0PoolDebt      -= result.t0RepayAmount;\n        t0DebtInAuction -= result.t0DebtInAuctionChange;\n\n        poolBalances.t0Debt            =  t0PoolDebt;\n        poolBalances.t0DebtInAuction   =  t0DebtInAuction;\n        poolBalances.pledgedCollateral -= result.collateralAmount;\n\n        // update pool interest rate state\n        poolState.debt       = result.poolDebt;\n        poolState.collateral -= result.collateralAmount;\n        _updateInterestState(poolState, result.newLup);\n\n        if (result.settledAuction) _rebalanceTokens(borrowerAddress_, result.remainingCollateral);\n    }\n```\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/external/Auctions.sol#L463-L528\n\n```solidity\n    /**\n     *  @notice Performs bucket take collateral on an auction, rewards taker and kicker (if case) and updates loan info (settles auction if case).\n     *  @dev    reverts on:\n     *              - insufficient collateral InsufficientCollateral()\n     *  @param  borrowerAddress_ Borrower address to take.\n     *  @param  depositTake_     If true then the take will happen at an auction price equal with bucket price. Auction price is used otherwise.\n     *  @param  index_           Index of a bucket, likely the HPB, in which collateral will be deposited.\n     *  @return result_          BucketTakeResult struct containing details of take.\n    */\n    function bucketTake(\n        AuctionsState storage auctions_,\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        LoansState storage loans_,\n        PoolState memory poolState_,\n        address borrowerAddress_,\n        bool    depositTake_,\n        uint256 index_,\n        uint256 collateralScale_\n    ) external returns (BucketTakeResult memory result_) {\n        Borrower memory borrower = loans_.borrowers[borrowerAddress_];\n\n        if (borrower.collateral == 0) revert InsufficientCollateral(); // revert if borrower's collateral is 0\n\n        (\n            result_.collateralAmount,\n            result_.t0RepayAmount,\n            borrower.t0Debt,\n            result_.t0DebtPenalty \n        ) = _takeBucket(\n            auctions_,\n            buckets_,\n            deposits_,\n            BucketTakeParams({\n                borrower:        borrowerAddress_,\n                collateral:      borrower.collateral,\n                t0Debt:          borrower.t0Debt,\n                inflator:        poolState_.inflator,\n                depositTake:     depositTake_,\n                index:           index_,\n                collateralScale: collateralScale_\n            })\n        );\n\n        borrower.collateral -= result_.collateralAmount;\n\n        if (result_.t0DebtPenalty != 0) {\n            poolState_.debt += Maths.wmul(result_.t0DebtPenalty, poolState_.inflator);\n        }\n\n        (\n            result_.poolDebt,\n            result_.newLup,\n            result_.t0DebtInAuctionChange,\n            result_.settledAuction\n        ) = _takeLoan(\n            auctions_,\n            buckets_,\n            deposits_,\n            loans_,\n            poolState_,\n            borrower,\n            borrowerAddress_,\n            result_.t0RepayAmount\n        );\n    }\n```\n\nAs a result _rebalanceTokens() will leave only `borrowerCollateral_ = result.remainingCollateral = 0` in the borrower's collateral ids account:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/ERC721Pool.sol#L533-L550\n\n```solidity\n    function _rebalanceTokens(\n        address borrowerAddress_,\n        uint256 borrowerCollateral_\n    ) internal {\n        // rebalance borrower's collateral, transfer difference to floor collateral from borrower to pool claimable array\n        uint256[] storage borrowerTokens = borrowerTokenIds[borrowerAddress_];\n\n        uint256 noOfTokensPledged    = borrowerTokens.length;\n        uint256 noOfTokensToTransfer = borrowerCollateral_ != 0 ? noOfTokensPledged - borrowerCollateral_ / 1e18 : noOfTokensPledged;\n\n        for (uint256 i = 0; i < noOfTokensToTransfer;) {\n            uint256 tokenId = borrowerTokens[--noOfTokensPledged]; // start with moving the last token pledged by borrower\n            borrowerTokens.pop();                                  // remove token id from borrower\n            bucketTokenIds.push(tokenId);                          // add token id to pool claimable tokens\n\n            unchecked { ++i; }\n        }\n    }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider filling the variable with the resulting collateral of the borrower by placing `result.remainingCollateral = borrower.collateral` in the very end of Auctions's take() and bucketTake().\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/32",
  "Code": [
    {
      "filename": "contracts/src/ERC721Pool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport {\n    IERC721Token,\n    IPoolErrors,\n    IPoolLenderActions,\n    IPoolLiquidationActions\n}                           from './interfaces/pool/IPool.sol';\nimport {\n    BucketTakeResult,\n    DrawDebtResult,\n    RepayDebtResult,\n    SettleParams,\n    TakeResult\n}                           from './interfaces/pool/commons/IPoolInternals.sol';\nimport { PoolState }        from './interfaces/pool/commons/IPoolState.sol';\n\nimport {\n    IERC721Pool,\n    IERC721PoolBorrowerActions,\n    IERC721PoolImmutables,\n    IERC721PoolLenderActions\n}                               from './interfaces/pool/erc721/IERC721Pool.sol';\nimport { IERC721Taker }         from './interfaces/pool/erc721/IERC721Taker.sol';\nimport {\n    ICryptoPunks,\n    ICryptoKitties,\n    NFTTypes\n}                               from './interfaces/pool/erc721/IERC721NonStandard.sol';\n\nimport { FlashloanablePool } from './base/FlashloanablePool.sol';\n\nimport { _revertIfAuctionClearable } from './libraries/helpers/RevertsHelper.sol';\n\nimport { Maths }    from './libraries/internal/Maths.sol';\nimport { Deposits } from './libraries/internal/Deposits.sol';\nimport { Loans }    from './libraries/internal/Loans.sol';\n\nimport { Auctions }        from './libraries/external/Auctions.sol';\nimport { LenderActions }   from './libraries/external/LenderActions.sol';\nimport { BorrowerActions } from './libraries/external/BorrowerActions.sol';\n\n/**\n *  @title  ERC721 Pool contract\n *  @notice Entrypoint of ERC721 Pool actions for pool actors:\n *          - Lenders: add, remove and move quote tokens; transfer LPs\n *          - Borrowers: draw and repay debt\n *          - Traders: add, remove and move quote tokens; add and remove collateral\n *          - Kickers: auction undercollateralized loans; settle auctions; claim bond rewards\n *          - Bidders: take auctioned collateral\n *          - Reserve purchasers: start auctions; take reserves\n *          - Flash borrowers: initiate flash loans on ERC20 quote tokens\n *  @dev    Contract is FlashloanablePool with flash loan logic.\n *  @dev    Contract is base Pool with logic to handle ERC721 collateral.\n *  @dev    Calls logic from external PoolCommons, LenderActions, BorrowerActions and Auctions libraries.\n */\ncontract ERC721Pool is FlashloanablePool, IERC721Pool {\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    // immutable args offset\n    uint256 internal constant SUBSET   = 93;\n    uint256 internal constant NFT_TYPE = 125;\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    mapping(uint256 => bool)      public tokenIdsAllowed;  // set of tokenIds that can be used for a given NFT Subset type pool\n    mapping(address => uint256[]) public borrowerTokenIds; // borrower address => array of tokenIds pledged by borrower\n    uint256[]                     public bucketTokenIds;   // array of tokenIds added in pool buckets\n\n    /****************************/\n    /*** Initialize Functions ***/\n    /****************************/\n\n    /// @inheritdoc IERC721Pool\n    function initialize(\n        uint256[] memory tokenIds_,\n        uint256 rate_\n    ) external override {\n        if (isPoolInitialized) revert AlreadyInitialized();\n\n        inflatorState.inflator       = uint208(1e18);\n        inflatorState.inflatorUpdate = uint48(block.timestamp);\n\n        interestState.interestRate       = uint208(rate_);\n        interestState.interestRateUpdate = uint48(block.timestamp);\n\n        uint256 noOfTokens = tokenIds_.length;\n\n        if (noOfTokens != 0) {\n            // add subset of tokenIds allowed in the pool\n            for (uint256 id = 0; id < noOfTokens;) {\n                tokenIdsAllowed[tokenIds_[id]] = true;\n\n                unchecked { ++id; }\n            }\n        }\n\n        Loans.init(loans);\n\n        // increment initializations count to ensure these values can't be updated\n        isPoolInitialized = true;\n    }\n\n    /******************/\n    /*** Immutables ***/\n    /******************/\n\n    /// @inheritdoc IERC721PoolImmutables\n    function isSubset() external pure override returns (bool) {\n        return _getArgUint256(SUBSET) != 0;\n    }\n\n    /***********************************/\n    /*** Borrower External Functions ***/\n    /***********************************/\n\n    /**\n     *  @inheritdoc IERC721PoolBorrowerActions\n     *  @dev write state:\n     *          - decrement poolBalances.t0DebtInAuction accumulator\n     *          - increment poolBalances.pledgedCollateral accumulator\n     *          - increment poolBalances.t0Debt accumulator\n     *          - update borrowerTokenIds and bucketTokenIds arrays\n     *  @dev emit events:\n     *          - DrawDebtNFT\n     */\n    function drawDebt(\n        address borrowerAddress_,\n        uint256 amountToBorrow_,\n        uint256 limitIndex_,\n        uint256[] calldata tokenIdsToPledge_\n    ) external nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        DrawDebtResult memory result = BorrowerActions.drawDebt(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_,\n            amountToBorrow_,\n            limitIndex_,\n            Maths.wad(tokenIdsToPledge_.length)\n        );\n\n        emit DrawDebtNFT(borrowerAddress_, amountToBorrow_, tokenIdsToPledge_, result.newLup);\n\n        // update pool interest rate state\n        poolState.debt       = result.poolDebt;\n        poolState.collateral = result.poolCollateral;\n        _updateInterestState(poolState, result.newLup);\n\n        if (tokenIdsToPledge_.length != 0) {\n            // update pool balances state\n            if (result.t0DebtInAuctionChange != 0) {\n                poolBalances.t0DebtInAuction -= result.t0DebtInAuctionChange;\n            }\n            poolBalances.pledgedCollateral += Maths.wad(tokenIdsToPledge_.length);\n\n            // move collateral from sender to pool\n            _transferFromSenderToPool(borrowerTokenIds[borrowerAddress_], tokenIdsToPledge_);\n        }\n\n        if (result.settledAuction) _rebalanceTokens(borrowerAddress_, result.remainingCollateral);\n\n        // move borrowed amount from pool to sender\n        if (amountToBorrow_ != 0) {\n            // update pool balances state\n            poolBalances.t0Debt += result.t0DebtChange;\n\n            // move borrowed amount from pool to sender\n            _transferQuoteToken(msg.sender, amountToBorrow_);\n        }\n    }\n\n    /**\n     *  @inheritdoc IERC721PoolBorrowerActions\n     *  @dev write state:\n     *          - decrement poolBalances.t0Debt accumulator\n     *          - decrement poolBalances.t0DebtInAuction accumulator\n     *          - decrement poolBalances.pledgedCollateral accumulator\n     *          - update borrowerTokenIds arrays\n     *  @dev emit events:\n     *          - RepayDebt\n     */\n    function repayDebt(\n        address borrowerAddress_,\n        uint256 maxQuoteTokenAmountToRepay_,\n        uint256 noOfNFTsToPull_\n    ) external nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        RepayDebtResult memory result = BorrowerActions.repayDebt(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_,\n            maxQuoteTokenAmountToRepay_,\n            Maths.wad(noOfNFTsToPull_)\n        );\n\n        emit RepayDebt(borrowerAddress_, result.quoteTokenToRepay, noOfNFTsToPull_, result.newLup);\n\n        if (result.settledAuction) _rebalanceTokens(borrowerAddress_, result.remainingCollateral);\n\n        // update pool interest rate state\n        poolState.debt       = result.poolDebt;\n        poolState.collateral = result.poolCollateral;\n        _updateInterestState(poolState, result.newLup);\n\n        if (result.quoteTokenToRepay != 0) {\n            // update pool balances state\n            poolBalances.t0Debt -= result.t0RepaidDebt;\n            if (result.t0DebtInAuctionChange != 0) {\n                poolBalances.t0DebtInAuction -= result.t0DebtInAuctionChange;\n            }\n\n            // move amount to repay from sender to pool\n            _transferQuoteTokenFrom(msg.sender, result.quoteTokenToRepay);\n        }\n        if (noOfNFTsToPull_ != 0) {\n            // update pool balances state\n            poolBalances.pledgedCollateral = result.poolCollateral;\n\n            // move collateral from pool to sender\n            _transferFromPoolToAddress(msg.sender, borrowerTokenIds[msg.sender], noOfNFTsToPull_);\n        }\n    }\n\n    /*********************************/\n    /*** Lender External Functions ***/\n    /*********************************/\n\n    /**\n     *  @inheritdoc IERC721PoolLenderActions\n     *  @dev write state:\n     *          - update borrowerTokenIds arrays\n     *  @dev emit events:\n     *          - AddCollateralNFT\n     */\n    function addCollateral(\n        uint256[] calldata tokenIdsToAdd_,\n        uint256 index_\n    ) external override nonReentrant returns (uint256 bucketLPs_) {\n        PoolState memory poolState = _accruePoolInterest();\n\n        bucketLPs_ = LenderActions.addCollateral(\n            buckets,\n            deposits,\n            Maths.wad(tokenIdsToAdd_.length),\n            index_\n        );\n\n        emit AddCollateralNFT(msg.sender, index_, tokenIdsToAdd_, bucketLPs_);\n\n        // update pool interest rate state\n        _updateInterestState(poolState, _lup(poolState.debt));\n\n        // move required collateral from sender to pool\n        _transferFromSenderToPool(bucketTokenIds, tokenIdsToAdd_);\n    }\n\n    /**\n     *  @inheritdoc IERC721PoolLenderActions\n     *  @dev write state:\n     *          - update bucketTokenIds arrays\n     *  @dev emit events:\n     *          - MergeOrRemoveCollateralNFT\n     */\n    function mergeOrRemoveCollateral(\n        uint256[] calldata removalIndexes_,\n        uint256 noOfNFTsToRemove_,\n        uint256 toIndex_\n    ) external override nonReentrant returns (uint256 collateralMerged_, uint256 bucketLPs_) {\n        PoolState memory poolState = _accruePoolInterest();\n        uint256 collateralAmount = Maths.wad(noOfNFTsToRemove_);\n\n        (\n            collateralMerged_,\n            bucketLPs_\n        ) = LenderActions.mergeOrRemoveCollateral(\n            buckets,\n            deposits,\n            removalIndexes_,\n            collateralAmount,\n            toIndex_\n        );\n\n        emit MergeOrRemoveCollateralNFT(msg.sender, collateralMerged_, bucketLPs_);\n\n        // update pool interest rate state\n        _updateInterestState(poolState, _lup(poolState.debt));\n\n        if (collateralMerged_ == collateralAmount) {\n            // Total collateral in buckets meets the requested removal amount, noOfNFTsToRemove_\n            _transferFromPoolToAddress(msg.sender, bucketTokenIds, noOfNFTsToRemove_);\n        }\n\n    }\n\n    /**\n     *  @inheritdoc IPoolLenderActions\n     *  @dev write state:\n     *          - update bucketTokenIds arrays\n     *  @dev emit events:\n     *          - RemoveCollateral\n     */\n    function removeCollateral(\n        uint256 noOfNFTsToRemove_,\n        uint256 index_\n    ) external override nonReentrant returns (uint256 collateralAmount_, uint256 lpAmount_) {\n        _revertIfAuctionClearable(auctions, loans);\n\n        PoolState memory poolState = _accruePoolInterest();\n\n        collateralAmount_ = Maths.wad(noOfNFTsToRemove_);\n        lpAmount_ = LenderActions.removeCollateral(\n            buckets,\n            deposits,\n            collateralAmount_,\n            index_\n        );\n\n        emit RemoveCollateral(msg.sender, index_, noOfNFTsToRemove_, lpAmount_);\n\n        // update pool interest rate state\n        _updateInterestState(poolState, _lup(poolState.debt));\n\n        _transferFromPoolToAddress(msg.sender, bucketTokenIds, noOfNFTsToRemove_);\n    }\n\n    /*******************************/\n    /*** Pool Auctions Functions ***/\n    /*******************************/\n\n    /**\n     *  @inheritdoc IPoolLiquidationActions\n     *  @dev write state:\n     *          - decrement poolBalances.t0Debt accumulator\n     *          - decrement poolBalances.t0DebtInAuction accumulator\n     *          - decrement poolBalances.pledgedCollateral accumulator\n     */\n    function settle(\n        address borrowerAddress_,\n        uint256 maxDepth_\n    ) external nonReentrant override {\n        PoolState memory poolState = _accruePoolInterest();\n\n        uint256 assets = Maths.wmul(poolBalances.t0Debt, poolState.inflator) + _getPoolQuoteTokenBalance();\n        uint256 liabilities = Deposits.treeSum(deposits) + auctions.totalBondEscrowed + reserveAuction.unclaimed;\n\n        SettleParams memory params = SettleParams(\n            {\n                borrower:    borrowerAddress_,\n                reserves:    (assets > liabilities) ? (assets-liabilities) : 0,\n                inflator:    poolState.inflator,\n                bucketDepth: maxDepth_,\n                poolType:    poolState.poolType\n            }\n        );\n        (\n            uint256 collateralRemaining,\n            uint256 t0DebtRemaining,\n            uint256 collateralSettled,\n            uint256 t0DebtSettled\n        ) = Auctions.settlePoolDebt(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            params\n        );\n\n        // slither-disable-next-line incorrect-equality\n        if (t0DebtRemaining == 0) _rebalanceTokens(params.borrower, collateralRemaining);\n\n        // update pool balances state\n        poolBalances.t0Debt            -= t0DebtSettled;\n        poolBalances.t0DebtInAuction   -= t0DebtSettled;\n        poolBalances.pledgedCollateral -= collateralSettled;\n\n        // update pool interest rate state\n        poolState.debt       -= Maths.wmul(t0DebtSettled, poolState.inflator);\n        poolState.collateral -= collateralSettled;\n        _updateInterestState(poolState, _lup(poolState.debt));\n    }\n\n    /**\n     *  @inheritdoc IPoolLiquidationActions\n     *  @dev write state:\n     *          - decrement poolBalances.t0Debt accumulator\n     *          - decrement poolBalances.t0DebtInAuction accumulator\n     *          - decrement poolBalances.pledgedCollateral accumulator\n     */\n    function take(\n        address        borrowerAddress_,\n        uint256        collateral_,\n        address        callee_,\n        bytes calldata data_\n    ) external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        TakeResult memory result = Auctions.take(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_,\n            Maths.wad(collateral_),\n            1\n        );\n\n        // update pool balances state\n        uint256 t0PoolDebt      = poolBalances.t0Debt;\n        uint256 t0DebtInAuction = poolBalances.t0DebtInAuction;\n\n        if (result.t0DebtPenalty != 0) {\n            t0PoolDebt      += result.t0DebtPenalty;\n            t0DebtInAuction += result.t0DebtPenalty;\n        }\n\n        t0PoolDebt      -= result.t0RepayAmount;\n        t0DebtInAuction -= result.t0DebtInAuctionChange;\n\n        poolBalances.t0Debt            =  t0PoolDebt;\n        poolBalances.t0DebtInAuction   =  t0DebtInAuction;\n        poolBalances.pledgedCollateral -= result.collateralAmount;\n\n        // update pool interest rate state\n        poolState.debt       =  result.poolDebt;\n        poolState.collateral -= result.collateralAmount;\n        _updateInterestState(poolState, result.newLup);\n\n        // transfer rounded collateral from pool to taker\n        uint256[] memory tokensTaken = _transferFromPoolToAddress(\n            callee_,\n            borrowerTokenIds[borrowerAddress_],\n            result.collateralAmount / 1e18\n        );\n\n        if (data_.length != 0) {\n            IERC721Taker(callee_).atomicSwapCallback(\n                tokensTaken,\n                result.quoteTokenAmount / _getArgUint256(QUOTE_SCALE), \n                data_\n            );\n        }\n\n        if (result.settledAuction) _rebalanceTokens(borrowerAddress_, result.remainingCollateral);\n\n        // transfer from taker to pool the amount of quote tokens needed to cover collateral auctioned (including excess for rounded collateral)\n        _transferQuoteTokenFrom(callee_, result.quoteTokenAmount + result.excessQuoteToken);\n\n        // transfer from pool to borrower the excess of quote tokens after rounding collateral auctioned\n        if (result.excessQuoteToken != 0) _transferQuoteToken(borrowerAddress_, result.excessQuoteToken);\n    }\n\n    /**\n     *  @inheritdoc IPoolLiquidationActions\n     *  @dev write state:\n     *          - decrement poolBalances.t0Debt accumulator\n     *          - decrement poolBalances.t0DebtInAuction accumulator\n     *          - decrement poolBalances.pledgedCollateral accumulator\n     */\n    function bucketTake(\n        address borrowerAddress_,\n        bool    depositTake_,\n        uint256 index_\n    ) external override nonReentrant {\n\n        PoolState memory poolState = _accruePoolInterest();\n\n        BucketTakeResult memory result = Auctions.bucketTake(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_,\n            depositTake_,\n            index_,\n            1\n        );\n\n        // update pool balances state\n        uint256 t0PoolDebt      = poolBalances.t0Debt;\n        uint256 t0DebtInAuction = poolBalances.t0DebtInAuction;\n\n        if (result.t0DebtPenalty != 0) {\n            t0PoolDebt      += result.t0DebtPenalty;\n            t0DebtInAuction += result.t0DebtPenalty;\n        }\n\n        t0PoolDebt      -= result.t0RepayAmount;\n        t0DebtInAuction -= result.t0DebtInAuctionChange;\n\n        poolBalances.t0Debt            =  t0PoolDebt;\n        poolBalances.t0DebtInAuction   =  t0DebtInAuction;\n        poolBalances.pledgedCollateral -= result.collateralAmount;\n\n        // update pool interest rate state\n        poolState.debt       = result.poolDebt;\n        poolState.collateral -= result.collateralAmount;\n        _updateInterestState(poolState, result.newLup);\n\n        if (result.settledAuction) _rebalanceTokens(borrowerAddress_, result.remainingCollateral);\n    }\n\n    /**************************/\n    /*** Internal Functions ***/\n    /**************************/\n\n    /**\n     *  @notice Rebalance NFT token and transfer difference to floor collateral from borrower to pool claimable array\n     *  @dev    write state:\n     *              - update borrowerTokens and bucketTokenIds arrays\n     *  @dev    emit events:\n     *              - RemoveCollateral\n     *  @param  borrowerAddress_    Address of borrower.\n     *  @param  borrowerCollateral_ Current borrower collateral to be rebalanced.\n     */\n    function _rebalanceTokens(\n        address borrowerAddress_,\n        uint256 borrowerCollateral_\n    ) internal {\n        // rebalance borrower's collateral, transfer difference to floor collateral from borrower to pool claimable array\n        uint256[] storage borrowerTokens = borrowerTokenIds[borrowerAddress_];\n\n        uint256 noOfTokensPledged    = borrowerTokens.length;\n        uint256 noOfTokensToTransfer = borrowerCollateral_ != 0 ? noOfTokensPledged - borrowerCollateral_ / 1e18 : noOfTokensPledged;\n\n        for (uint256 i = 0; i < noOfTokensToTransfer;) {\n            uint256 tokenId = borrowerTokens[--noOfTokensPledged]; // start with moving the last token pledged by borrower\n            borrowerTokens.pop();                                  // remove token id from borrower\n            bucketTokenIds.push(tokenId);                          // add token id to pool claimable tokens\n\n            unchecked { ++i; }\n        }\n    }\n\n    /**\n     *  @notice Helper function for transferring multiple NFT tokens from msg.sender to pool.\n     *  @notice Reverts in case token id is not supported by subset pool.\n     *  @param  poolTokens_ Array in pool that tracks NFT ids (could be tracking NFTs pledged by borrower or NFTs added by a lender in a specific bucket).\n     *  @param  tokenIds_   Array of NFT token ids to transfer from msg.sender to pool.\n     */\n    function _transferFromSenderToPool(\n        uint256[] storage poolTokens_,\n        uint256[] calldata tokenIds_\n    ) internal {\n        bool subset   = _getArgUint256(SUBSET) != 0;\n        uint8 nftType = _getArgUint8(NFT_TYPE);\n\n        for (uint256 i = 0; i < tokenIds_.length;) {\n            uint256 tokenId = tokenIds_[i];\n            if (subset && !tokenIdsAllowed[tokenId]) revert OnlySubset();\n            poolTokens_.push(tokenId);\n\n            if (nftType == uint8(NFTTypes.STANDARD_ERC721)){\n                _transferNFT(msg.sender, address(this), tokenId);\n            }\n            else if (nftType == uint8(NFTTypes.CRYPTOKITTIES)) {\n                ICryptoKitties(_getArgAddress(COLLATERAL_ADDRESS)).transferFrom(msg.sender ,address(this), tokenId);\n            }\n            else{\n                ICryptoPunks(_getArgAddress(COLLATERAL_ADDRESS)).buyPunk(tokenId);\n            }\n\n            unchecked { ++i; }\n        }\n    }\n\n    /**\n     *  @notice Helper function for transferring multiple NFT tokens from pool to given address.\n     *  @notice It transfers NFTs from the most recent one added into the pool (pop from array tracking NFTs in pool).\n     *  @param  toAddress_      Address where pool should transfer tokens to.\n     *  @param  poolTokens_     Array in pool that tracks NFT ids (could be tracking NFTs pledged by borrower or NFTs added by a lender in a specific bucket).\n     *  @param  amountToRemove_ Number of NFT tokens to transfer from pool to given address.\n     *  @return Array containing token ids that were transferred from pool to address.\n     */\n    function _transferFromPoolToAddress(\n        address toAddress_,\n        uint256[] storage poolTokens_,\n        uint256 amountToRemove_\n    ) internal returns (uint256[] memory) {\n        uint256[] memory tokensTransferred = new uint256[](amountToRemove_);\n\n        uint256 noOfNFTsInPool = poolTokens_.length;\n\n        uint8 nftType = _getArgUint8(NFT_TYPE);\n\n        for (uint256 i = 0; i < amountToRemove_;) {\n            uint256 tokenId = poolTokens_[--noOfNFTsInPool]; // start with transferring the last token added in bucket\n            poolTokens_.pop();\n\n            if (nftType == uint8(NFTTypes.STANDARD_ERC721)){\n                _transferNFT(address(this), toAddress_, tokenId);\n            }\n            else if (nftType == uint8(NFTTypes.CRYPTOKITTIES)) {\n                ICryptoKitties(_getArgAddress(COLLATERAL_ADDRESS)).transfer(toAddress_, tokenId);\n            }\n            else {\n                ICryptoPunks(_getArgAddress(COLLATERAL_ADDRESS)).transferPunk(toAddress_, tokenId);\n            }\n\n            tokensTransferred[i] = tokenId;\n\n            unchecked { ++i; }\n        }\n\n        return tokensTransferred;\n    }\n\n    /**\n     *  @dev Helper function to transfer an NFT from owner to target address (reused in code to reduce contract deployment bytecode size).\n     *  @param from_    NFT owner address.\n     *  @param to_      New NFT owner address.\n     *  @param tokenId_ NFT token id to be transferred.\n     */\n    function _transferNFT(address from_, address to_, uint256 tokenId_) internal {\n        // slither-disable-next-line calls-loop\n        IERC721Token(_getArgAddress(COLLATERAL_ADDRESS)).safeTransferFrom(from_, to_, tokenId_);\n    }\n\n    /************************/\n    /*** Helper Functions ***/\n    /************************/\n\n    /** @notice Implementing this method allows contracts to receive ERC721 tokens\n     *  @dev https://forum.openzeppelin.com/t/erc721holder-ierc721receiver-and-onerc721received/11828\n     */\n    function onERC721Received(address, address, uint256, bytes memory) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n}"
    },
    {
      "filename": "contracts/src/libraries/external/Auctions.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport { PRBMathSD59x18 } from \"@prb-math/contracts/PRBMathSD59x18.sol\";\n\nimport { PoolType } from '../../interfaces/pool/IPool.sol';\n\nimport {\n    AuctionsState,\n    Borrower,\n    Bucket,\n    DepositsState,\n    Kicker,\n    Lender,\n    Liquidation,\n    LoansState,\n    PoolState,\n    ReserveAuctionState\n}                                    from '../../interfaces/pool/commons/IPoolState.sol';\nimport {\n    BucketTakeResult,\n    KickResult,\n    SettleParams,\n    TakeResult\n}                                    from '../../interfaces/pool/commons/IPoolInternals.sol';\nimport { StartReserveAuctionParams } from '../../interfaces/pool/commons/IPoolReserveAuctionActions.sol';\n\nimport {\n    _claimableReserves,\n    _indexOf,\n    _isCollateralized,\n    _priceAt,\n    _reserveAuctionPrice,\n    _roundToScale,\n    MAX_FENWICK_INDEX,\n    MAX_PRICE,\n    MIN_PRICE\n}                           from '../helpers/PoolHelper.sol';\nimport { _revertOnMinDebt } from '../helpers/RevertsHelper.sol';\n\nimport { Buckets }  from '../internal/Buckets.sol';\nimport { Deposits } from '../internal/Deposits.sol';\nimport { Loans }    from '../internal/Loans.sol';\nimport { Maths }    from '../internal/Maths.sol';\n\n/**\n    @title  Auctions library\n    @notice External library containing actions involving auctions within pool:\n            - Kickers: kick undercollateralized loans; settle auctions; claim bond rewards\n            - Bidders: take auctioned collateral\n            - Reserve purchasers: start auctions; take reserves\n */\nlibrary Auctions {\n\n    /*******************************/\n    /*** Function Params Structs ***/\n    /*******************************/\n\n    struct BucketTakeParams {\n        address borrower;        // borrower address to take from\n        uint256 collateral;      // [WAD] borrower available collateral to take\n        bool    depositTake;     // deposit or arb take, used by bucket take\n        uint256 index;           // bucket index, used by bucket take\n        uint256 inflator;        // [WAD] current pool inflator\n        uint256 t0Debt;          // [WAD] borrower t0 debt\n        uint256 collateralScale; // precision of collateral token based on decimals\n    }\n    struct TakeParams {\n        address borrower;        // borrower address to take from\n        uint256 collateral;      // [WAD] borrower available collateral to take\n        uint256 t0Debt;          // [WAD] borrower t0 debt\n        uint256 takeCollateral;  // [WAD] desired amount to take\n        uint256 inflator;        // [WAD] current pool inflator\n        uint256 poolType;        // pool type (ERC20 or NFT)\n        uint256 collateralScale; // precision of collateral token based on decimals\n    }\n\n    /*************************/\n    /*** Local Var Structs ***/\n    /*************************/\n\n    struct KickWithDepositLocalVars {\n        uint256 amountToDebitFromDeposit; // [WAD] the amount of quote tokens used to kick and debited from lender deposit\n        uint256 bucketCollateral;         // [WAD] amount of collateral in bucket\n        uint256 bucketDeposit;            // [WAD] amount of quote tokens in bucket\n        uint256 bucketLPs;                // [RAY] LPs of the bucket\n        uint256 bucketPrice;              // [WAD] bucket price\n        uint256 bucketRate;               // [RAY] bucket exchange rate\n        uint256 bucketScale;              // [WAD] bucket scales\n        uint256 bucketUnscaledDeposit;    // [WAD] unscaled amount of quote tokens in bucket\n        uint256 lenderLPs;                // [RAY] LPs of lender in bucket\n        uint256 redeemedLPs;              // [RAY] LPs used by kick action\n    }\n    struct SettleLocalVars {\n        uint256 collateralUsed;    // [WAD] collateral used to settle debt\n        uint256 debt;              // [WAD] debt to settle\n        uint256 depositToRemove;   // [WAD] deposit used by settle auction\n        uint256 index;             // index of settling bucket\n        uint256 maxSettleableDebt; // [WAD] max amount that can be settled with existing collateral\n        uint256 price;             // [WAD] price of settling bucket\n        uint256 scaledDeposit;     // [WAD] scaled amount of quote tokens in bucket\n        uint256 scale;             // [WAD] scale of settling bucket\n        uint256 unscaledDeposit;   // [WAD] unscaled amount of quote tokens in bucket\n    }\n    struct TakeLocalVars {\n        uint256 auctionPrice;             // [WAD] The price of auction.\n        uint256 bondChange;               // [WAD] The change made on the bond size (beeing reward or penalty).\n        uint256 borrowerDebt;             // [WAD] The accrued debt of auctioned borrower.\n        int256  bpf;                      // The bond penalty factor.\n        uint256 bucketPrice;              // [WAD] The bucket price.\n        uint256 bucketScale;              // [WAD] The bucket scale.\n        uint256 collateralAmount;         // [WAD] The amount of collateral taken.\n        uint256 excessQuoteToken;         // [WAD] Difference of quote token that borrower receives after take (for fractional NFT only)\n        uint256 factor;                   // The take factor, calculated based on bond penalty factor.\n        bool    isRewarded;               // True if kicker is rewarded (auction price lower than neutral price), false if penalized (auction price greater than neutral price).\n        address kicker;                   // Address of auction kicker.\n        uint256 scaledQuoteTokenAmount;   // [WAD] Unscaled quantity in Fenwick tree and before 1-bpf factor, paid for collateral\n        uint256 t0RepayAmount;            // [WAD] The amount of debt (quote tokens) that is recovered / repayed by take t0 terms.\n        uint256 t0Debt;                   // [WAD] Borrower's t0 debt.\n        uint256 t0DebtPenalty;            // [WAD] Borrower's t0 penalty - 7% from current debt if intial take, 0 otherwise.\n        uint256 unscaledDeposit;          // [WAD] Unscaled bucket quantity\n        uint256 unscaledQuoteTokenAmount; // [WAD] The unscaled token amount that taker should pay for collateral taken.\n    }\n    struct TakeLoanLocalVars {\n        uint256 repaidDebt;   // [WAD] the amount of debt repaid to th epool by take auction\n        uint256 borrowerDebt; // [WAD] the amount of borrower debt\n        bool    inAuction;    // true if loan in auction\n    }\n    struct TakeFromLoanLocalVars {\n        uint256 borrowerDebt;          // [WAD] borrower's accrued debt\n        bool    inAuction;             // true if loan still in auction after auction is taken, false otherwise\n        uint256 newLup;                // [WAD] LUP after auction is taken\n        uint256 repaidDebt;            // [WAD] debt repaid when auction is taken\n        uint256 t0DebtInAuction;       // [WAD] t0 pool debt in auction\n        uint256 t0DebtInAuctionChange; // [WAD] t0 change amount of debt after auction is taken\n        uint256 t0PoolDebt;            // [WAD] t0 pool debt\n    }\n\n    /**************/\n    /*** Events ***/\n    /**************/\n\n    // See `IPoolEvents` for descriptions\n    event AuctionSettle(address indexed borrower, uint256 collateral);\n    event AuctionNFTSettle(address indexed borrower, uint256 collateral, uint256 lps, uint256 index);\n    event BucketTake(address indexed borrower, uint256 index, uint256 amount, uint256 collateral, uint256 bondChange, bool isReward);\n    event BucketTakeLPAwarded(address indexed taker, address indexed kicker, uint256 lpAwardedTaker, uint256 lpAwardedKicker);\n    event Kick(address indexed borrower, uint256 debt, uint256 collateral, uint256 bond);\n    event Take(address indexed borrower, uint256 amount, uint256 collateral, uint256 bondChange, bool isReward);\n    event RemoveQuoteToken(address indexed lender, uint256 indexed price, uint256 amount, uint256 lpRedeemed, uint256 lup);\n    event ReserveAuction(uint256 claimableReservesRemaining, uint256 auctionPrice);\n    event Settle(address indexed borrower, uint256 settledDebt);\n\n    /**************/\n    /*** Errors ***/\n    /**************/\n\n    // See `IPoolErrors` for descriptions\n    event BucketBankruptcy(uint256 indexed index, uint256 lpForfeited);\n    error AuctionActive();\n    error AuctionNotClearable();\n    error AuctionPriceGtBucketPrice();\n    error BorrowerOk();\n    error InsufficientLiquidity();\n    error InsufficientCollateral();\n    error NoAuction();\n    error NoReserves();\n    error NoReservesAuction();\n    error PriceBelowLUP();\n    error TakeNotPastCooldown();\n\n    /***************************/\n    /***  External Functions ***/\n    /***************************/\n\n    /**\n     *  @notice Settles the debt of the given loan / borrower.\n     *  @dev    write state"
    }
  ]
}