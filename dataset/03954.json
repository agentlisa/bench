{
  "Title": "[M06] Lack of input validations",
  "Content": "Across the repository, there have been multiple situations where the input has not been checked before using it in a function. In particular:\n\n\n* The [`_setOwner` function in the `Proxy` contract](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/Proxy.sol#L145) does not check that the new owner of the proxy is not the zero address. This would result in the permanent loss of control over the proxy ownership if the zero address is passed by mistake. Also note that some Ethereum clients may default to sending null parameters if none are specified.\n* The [`setWalletAddress` function in the `Accounts` contract](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/Accounts.sol#L108) allows to change the `walletAddress` for the owned account. The issue is that there are no checks about the address passed as parameter, which could be the zero address too.\n* The `increaseAllowance`, `decreaseAllowance` and `approve` functions in the [`StableToken`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/StableToken.sol) and the [`GoldToken`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/GoldToken.sol) contracts do not check that the spender is not the zero address, and the `transferFrom` function in both contracts does not check that the zero address, which in Celo represents the VM, will not transfer tokens on otherâ€™s behalf.\n* The [`Governance` contract](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Governance.sol#L21) is in charge of important parameters of the Celo blockchain. In particular, the [`minDeposit` variable](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Governance.sol#L91) holds the value of the minimum amount of Gold to submit a proposal. Although in the [`initialize` function](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Governance.sol#L208) the `minDeposit` variable is checked not to be 0, the same condition is not checked in the [`setMinDeposit` function](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Governance.sol#L260). If the `minDeposit` is set to `0` by the administrator, it could lead to an insecure blockchain state where an attacker can send a lot of proposals to the network without having to spend Celo Gold.\n\n\nConsider requiring that these addresses are not the zero address, restricting integer values when appropriate, and consider adding more checks along the code for proper input validation.\n\n\n****Update:*** Fixed in [pull request #2807](https://github.com/celo-org/celo-monorepo/pull/2807/files). The cLabs team has implemented input validation for functions `increaseAllowance()` and `approve()`, which together prevent setting an allowance greater than 0 for `address(0)`. `decreaseAllowance()` and `transferFrom()` can then no longer be used by `address(0)` to spend any amount. The cLabs team has also implemented the recommended fixes for `Proxy.sol` and `Governance.sol`. They have [added a comment in `setWalletAddress` explaining what it means for a wallet address to be set to 0](https://github.com/celo-org/celo-monorepo/pull/2807/files#diff-9273508ae9483e74d97b79d7bf83202bR110-R112).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/common/Proxy.sol",
      "content": "pragma solidity ^0.5.3;\n/* solhint-disable no-inline-assembly, no-complex-fallback, avoid-low-level-calls */\n\nimport \"./libraries/AddressesHelper.sol\";\n\n/**\n * @title A Proxy utilizing the Unstructured Storage pattern.\n */\ncontract Proxy {\n  // Used to store the address of the owner.\n  bytes32 private constant OWNER_POSITION = keccak256(\"org.celo.owner\");\n  // Used to store the address of the implementation contract.\n  bytes32 private constant IMPLEMENTATION_POSITION = keccak256(\"org.celo.implementation\");\n\n  event OwnerSet(address indexed owner);\n  event ImplementationSet(address indexed implementation);\n\n  constructor() public {\n    _setOwner(msg.sender);\n  }\n\n  /**\n   * @notice Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == _getOwner(), \"sender was not owner\");\n    _;\n  }\n\n  /**\n   * @notice Delegates calls to the implementation contract.\n   */\n  function() external payable {\n    bytes32 implementationPosition = IMPLEMENTATION_POSITION;\n\n    address implementationAddress;\n\n    assembly {\n      implementationAddress := sload(implementationPosition)\n    }\n\n    // Avoid checking if address is a contract or executing delegated call when\n    // implementation address is 0x0\n    if (implementationAddress == address(0)) return;\n\n    require(AddressesHelper.isContract(implementationAddress), \"Invalid contract address\");\n\n    assembly {\n      let newCallDataPosition := mload(0x40)\n      mstore(0x40, add(newCallDataPosition, calldatasize))\n\n      calldatacopy(newCallDataPosition, 0, calldatasize)\n\n      let delegatecallSuccess := delegatecall(\n        gas,\n        implementationAddress,\n        newCallDataPosition,\n        calldatasize,\n        0,\n        0\n      )\n\n      let returnDataSize := returndatasize\n      let returnDataPosition := mload(0x40)\n      mstore(0x40, add(returnDataPosition, returnDataSize))\n      returndatacopy(returnDataPosition, 0, returnDataSize)\n\n      switch delegatecallSuccess\n        case 0 {\n          revert(returnDataPosition, returnDataSize)\n        }\n        default {\n          return(returnDataPosition, returnDataSize)\n        }\n    }\n  }\n\n  /**\n   * @notice Transfers ownership of Proxy to a new owner.\n   * @param newOwner Address of the new owner account.\n   */\n  function _transferOwnership(address newOwner) external onlyOwner {\n    _setOwner(newOwner);\n  }\n\n  /**\n   * @notice Sets the address of the implementation contract and calls into it.\n   * @param implementation Address of the new target contract.\n   * @param callbackData The abi-encoded function call to perform in the implementation\n   * contract.\n   * @dev Throws if the initialization callback fails.\n   * @dev If the target contract does not need initialization, use\n   * setImplementation instead.\n   */\n  function _setAndInitializeImplementation(address implementation, bytes calldata callbackData)\n    external\n    payable\n    onlyOwner\n  {\n    _setImplementation(implementation);\n    bool success;\n    bytes memory returnValue;\n    (success, returnValue) = implementation.delegatecall(callbackData);\n    require(success, \"initialization callback failed\");\n  }\n\n  /**\n   * @notice Returns the implementation address.\n   */\n  function _getImplementation() external view returns (address implementation) {\n    bytes32 implementationPosition = IMPLEMENTATION_POSITION;\n    assembly {\n      implementation := sload(implementationPosition)\n    }\n  }\n\n  /**\n   * @notice Sets the address of the implementation contract.\n   * @param implementation Address of the new target contract.\n   * @dev If the target contract needs to be initialized, call\n   * setAndInitializeImplementation instead.\n   */\n  function _setImplementation(address implementation) public onlyOwner {\n    bytes32 implementationPosition = IMPLEMENTATION_POSITION;\n\n    require(AddressesHelper.isContract(implementation), \"Invalid contract address\");\n\n    assembly {\n      sstore(implementationPosition, implementation)\n    }\n\n    emit ImplementationSet(implementation);\n  }\n\n  /**\n   * @notice Returns the Proxy owner's address.\n   */\n  function _getOwner() public view returns (address owner) {\n    bytes32 position = OWNER_POSITION;\n    assembly {\n      owner := sload(position)\n    }\n  }\n\n  function _setOwner(address newOwner) private {\n    bytes32 position = OWNER_POSITION;\n    assembly {\n      sstore(position, newOwner)\n    }\n    emit OwnerSet(newOwner);\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/common/Accounts.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\";\n\nimport \"./interfaces/IAccounts.sol\";\n\nimport \"../common/Initializable.sol\";\nimport \"../common/Signatures.sol\";\nimport \"../common/UsingRegistry.sol\";\n\ncontract Accounts is IAccounts, Ownable, ReentrancyGuard, Initializable, UsingRegistry {\n  using SafeMath for uint256;\n\n  struct Signers {\n    // The address that is authorized to vote in governance and validator elections on behalf of the\n    // account. The account can vote as well, whether or not a vote signing key has been specified.\n    address vote;\n    // The address that is authorized to manage a validator or validator group and sign consensus\n    // messages on behalf of the account. The account can manage the validator, whether or not a\n    // validator signing key has been specified. However, if a validator signing key has been\n    // specified, only that key may actually participate in consensus.\n    address validator;\n    // The address of the key with which this account wants to sign attestations on the Attestations\n    // contract\n    address attestation;\n  }\n\n  struct Account {\n    bool exists;\n    // Each account may authorize signing keys to use for voting, valdiating or attestation.\n    // These keys may not be keys of other accounts, and may not be authorized by any other\n    // account for any purpose.\n    Signers signers;\n    // The address at which the account expects to receive transfers. If it's empty/0x0, the\n    // account indicates that an address exchange should be initiated with the dataEncryptionKey\n    address walletAddress;\n    // An optional human readable identifier for the account\n    string name;\n    // The ECDSA public key used to encrypt and decrypt data for this account\n    bytes dataEncryptionKey;\n    // The URL under which an account adds metadata and claims\n    string metadataURL;\n  }\n\n  mapping(address => Account) private accounts;\n  // Maps authorized signers to the account that provided the authorization.\n  mapping(address => address) public authorizedBy;\n\n  event AttestationSignerAuthorized(address indexed account, address signer);\n  event VoteSignerAuthorized(address indexed account, address signer);\n  event ValidatorSignerAuthorized(address indexed account, address signer);\n  event AccountDataEncryptionKeySet(address indexed account, bytes dataEncryptionKey);\n  event AccountNameSet(address indexed account, string name);\n  event AccountMetadataURLSet(address indexed account, string metadataURL);\n  event AccountWalletAddressSet(address indexed account, address walletAddress);\n  event AccountCreated(address indexed account);\n\n  function initialize(address registryAddress) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n  }\n\n  /**\n   * @notice Convenience Setter for the dataEncryptionKey and wallet address for an account\n   * @param name A string to set as the name of the account\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   * @param walletAddress The wallet address to set for the account\n   */\n  function setAccount(string calldata name, bytes calldata dataEncryptionKey, address walletAddress)\n    external\n  {\n    if (!isAccount(msg.sender)) {\n      createAccount();\n    }\n    setName(name);\n    setAccountDataEncryptionKey(dataEncryptionKey);\n    setWalletAddress(walletAddress);\n  }\n\n  /**\n   * @notice Creates an account.\n   * @return True if account creation succeeded.\n   */\n  function createAccount() public returns (bool) {\n    require(isNotAccount(msg.sender) && isNotAuthorizedSigner(msg.sender), \"Account exists\");\n    Account storage account = accounts[msg.sender];\n    account.exists = true;\n    emit AccountCreated(msg.sender);\n    return true;\n  }\n\n  /**\n   * @notice Setter for the name of an account.\n   * @param name The name to set.\n   */\n  function setName(string memory name) public {\n    require(isAccount(msg.sender), \"Unknown account\");\n    accounts[msg.sender].name = name;\n    emit AccountNameSet(msg.sender, name);\n  }\n\n  /**\n   * @notice Setter for the wallet address for an account\n   * @param walletAddress The wallet address to set for the account\n   */\n  function setWalletAddress(address walletAddress) public {\n    require(isAccount(msg.sender), \"Unknown account\");\n    accounts[msg.sender].walletAddress = walletAddress;\n    emit AccountWalletAddressSet(msg.sender, walletAddress);\n  }\n\n  /**\n   * @notice Setter for the data encryption key and version.\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function setAccountDataEncryptionKey(bytes memory dataEncryptionKey) public {\n    require(dataEncryptionKey.length >= 33, \"data encryption key length <= 32\");\n    accounts[msg.sender].dataEncryptionKey = dataEncryptionKey;\n    emit AccountDataEncryptionKeySet(msg.sender, dataEncryptionKey);\n  }\n\n  /**\n   * @notice Setter for the metadata of an account.\n   * @param metadataURL The URL to access the metadata.\n   */\n  function setMetadataURL(string calldata metadataURL) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    accounts[msg.sender].metadataURL = metadataURL;\n    emit AccountMetadataURLSet(msg.sender, metadataURL);\n  }\n\n  /**\n   * @notice Authorizes an address to sign votes on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeVoteSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    Account storage account = accounts[msg.sender];\n    authorize(signer, v, r, s);\n    account.signers.vote = signer;\n    emit VoteSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    Account storage account = accounts[msg.sender];\n    authorize(signer, v, r, s);\n    account.signers.validator = signer;\n    require(!getValidators().isValidator(msg.sender), \"Cannot authorize validator signer\");\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSigner(\n    address signer,\n    bytes calldata ecdsaPublicKey,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external nonReentrant {\n    Account storage account = accounts[msg.sender];\n    authorize(signer, v, r, s);\n    account.signers.validator = signer;\n    require(\n      getValidators().updateEcdsaPublicKey(msg.sender, signer, ecdsaPublicKey),\n      \"Failed to update ECDSA public key\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign attestations on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeAttestationSigner(address signer, uint8 v, bytes32 r, bytes32 s) public {\n    Account storage account = accounts[msg.sender];\n    authorize(signer, v, r, s);\n    account.signers.attestation = signer;\n    emit AttestationSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized attestation signer.\n   * @dev Fails if the `signer` is not an account or currently authorized attestation signer.\n   * @return The associated account.\n   */\n  function attestationSignerToAccount(address signer) external view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      require(\n        accounts[authorizingAccount].signers.attestation == signer,\n        \"not active authorized attestation signer\"\n      );\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"not an account\");\n      return signer;\n    }\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of an account or currently authorized validator signer.\n   * @dev Fails if the `signer` is not an account or currently authorized validator.\n   * @return The associated account.\n   */\n  function validatorSignerToAccount(address signer) public view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      require(\n        accounts[authorizingAccount].signers.validator == signer,\n        \"not active authorized validator signer\"\n      );\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"not an account\");\n      return signer;\n    }\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized vote signer.\n   * @dev Fails if the `signer` is not an account or currently authorized vote signer.\n   * @return The associated account.\n   */\n  function voteSignerToAccount(address signer) external view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      require(\n        accounts[authorizingAccount].signers.vote == signer,\n        \"not active authorized vote signer\"\n      );\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"not an account\");\n      return signer;\n    }\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or previously authorized signer.\n   * @dev Fails if the `signer` is not an account or previously authorized signer.\n   * @return The associated account.\n   */\n  function signerToAccount(address signer) external view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"Not an account\");\n      return signer;\n    }\n  }\n\n  /**\n   * @notice Returns the vote signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign votes.\n   */\n  function getVoteSigner(address account) public view returns (address) {\n    require(isAccount(account), \"Unknown account\");\n    address signer = accounts[account].signers.vote;\n    return signer == address(0) ? account : signer;\n  }\n\n  /**\n   * @notice Returns the validator signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can register a validator or group.\n   */\n  function getValidatorSigner(address account) public view returns (address) {\n    require(isAccount(account), \"Unknown account\");\n    address signer = accounts[account].signers.validator;\n    return signer == address(0) ? account : signer;\n  }\n\n  /**\n   * @notice Returns the attestation signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign attestations.\n   */\n  function getAttestationSigner(address account) public view returns (address) {\n    require(isAccount(account), \"Unknown account\");\n    address signer = accounts[account].signers.attestation;\n    return signer == address(0) ? account : signer;\n  }\n\n  /**\n   * @notice Getter for the name of an account.\n   * @param account The address of the account to get the name for.\n   * @return name The name of the account.\n   */\n  function getName(address account) external view returns (string memory) {\n    return accounts[account].name;\n  }\n\n  /**\n   * @notice Getter for the metadata of an account.\n   * @param account The address of the account to get the metadata for.\n   * @return metadataURL The URL to access the metadata.\n   */\n  function getMetadataURL(address account) external view returns (string memory) {\n    return accounts[account].metadataURL;\n  }\n\n  /**\n   * @notice Getter for the metadata of multiple accounts.\n   * @param accountsToQuery The addresses of the accounts to get the metadata for.\n   * @return (stringLengths[] - the length of each string in bytes\n   *          data - all strings concatenated\n   *         )\n   */\n  function batchGetMetadataURL(address[] calldata accountsToQuery)\n    external\n    view\n    returns (uint256[] memory, bytes memory)\n  {\n    uint256 totalSize = 0;\n    uint256[] memory sizes = new uint256[](accountsToQuery.length);\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      sizes[i] = bytes(accounts[accountsToQuery[i]].metadataURL).length;\n      totalSize = totalSize.add(sizes[i]);\n    }\n\n    bytes memory data = new bytes(totalSize);\n    uint256 pointer = 0;\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      for (uint256 j = 0; j < sizes[i]; j = j.add(1)) {\n        data[pointer] = bytes(accounts[accountsToQuery[i]].metadataURL)[j];\n        pointer = pointer.add(1);\n      }\n    }\n    return (sizes, data);\n  }\n\n  /**\n   * @notice Getter for the data encryption key and version.\n   * @param account The address of the account to get the key for\n   * @return dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function getDataEncryptionKey(address account) external view returns (bytes memory) {\n    return accounts[account].dataEncryptionKey;\n  }\n\n  /**\n   * @notice Getter for the wallet address for an account\n   * @param account The address of the account to get the wallet address for\n   * @return Wallet address\n   */\n  function getWalletAddress(address account) external view returns (address) {\n    return accounts[account].walletAddress;\n  }\n\n  /**\n   * @notice Check if an account already exists.\n   * @param account The address of the account\n   * @return Returns `true` if account exists. Returns `false` otherwise.\n   */\n  function isAccount(address account) public view returns (bool) {\n    return (accounts[account].exists);\n  }\n\n  /**\n   * @notice Check if an account already exists.\n   * @param account The address of the account\n   * @return Returns `false` if account exists. Returns `true` otherwise.\n   */\n  function isNotAccount(address account) internal view returns (bool) {\n    return (!accounts[account].exists);\n  }\n\n  /**\n   * @notice Check if an address has been an authorized signer for an account.\n   * @param signer The possibly authorized address.\n   * @return Returns `true` if authorized. Returns `false` otherwise.\n   */\n  function isAuthorizedSigner(address signer) external view returns (bool) {\n    return (authorizedBy[signer] != address(0));\n  }\n\n  /**\n   * @notice Check if an address has been an authorized signer for an account.\n   * @param signer The possibly authorized address.\n   * @return Returns `false` if authorized. Returns `true` otherwise.\n   */\n  function isNotAuthorizedSigner(address signer) internal view returns (bool) {\n    return (authorizedBy[signer] == address(0));\n  }\n\n  /**\n   * @notice Authorizes some role of of `msg.sender`'s account to another address.\n   * @param authorized The address to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Fails if the address is already authorized or is an account.\n   * @dev Note that once an address is authorized, it may never be authorized again.\n   * @dev v, r, s constitute `current`'s signature on `msg.sender`.\n   */\n  function authorize(address authorized, uint8 v, bytes32 r, bytes32 s) private {\n    require(isAccount(msg.sender), \"Unknown account\");\n    require(\n      isNotAccount(authorized) && isNotAuthorizedSigner(authorized),\n      \"delegate or account exists\"\n    );\n\n    address signer = Signatures.getSignerOfAddress(msg.sender, v, r, s);\n    require(signer == authorized, \"Invalid signature\");\n\n    authorizedBy[authorized] = msg.sender;\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/governance/Governance.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/math/Math.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\nimport \"./interfaces/IGovernance.sol\";\nimport \"./Proposals.sol\";\nimport \"../common/ExtractFunctionSignature.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/FixidityLib.sol\";\nimport \"../common/linkedlists/IntegerSortedLinkedList.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/UsingPrecompiles.sol\";\n\n// TODO(asa): Hardcode minimum times for queueExpiry, etc.\n/**\n * @title A contract for making, passing, and executing on-chain governance proposals.\n */\ncontract Governance is\n  IGovernance,\n  Ownable,\n  Initializable,\n  ReentrancyGuard,\n  UsingRegistry,\n  UsingPrecompiles\n{\n  using Proposals for Proposals.Proposal;\n  using FixidityLib for FixidityLib.Fraction;\n  using SafeMath for uint256;\n  using IntegerSortedLinkedList for SortedLinkedList.List;\n  using BytesLib for bytes;\n\n  uint256 private constant FIXED_HALF = 500000000000000000000000;\n\n  enum VoteValue { None, Abstain, No, Yes }\n\n  struct UpvoteRecord {\n    uint256 proposalId;\n    uint256 weight;\n  }\n\n  struct VoteRecord {\n    Proposals.VoteValue value;\n    uint256 proposalId;\n    uint256 weight;\n  }\n\n  struct Voter {\n    // Key of the proposal voted for in the proposal queue\n    UpvoteRecord upvote;\n    uint256 mostRecentReferendumProposal;\n    // Maps a `dequeued` index to a voter's vote record.\n    mapping(uint256 => VoteRecord) referendumVotes;\n  }\n\n  struct ContractConstitution {\n    FixidityLib.Fraction defaultThreshold;\n    // Maps a function ID to a corresponding threshold, overriding the default.\n    mapping(bytes4 => FixidityLib.Fraction) functionThresholds;\n  }\n\n  struct HotfixRecord {\n    bool executed;\n    bool approved;\n    uint256 preparedEpoch;\n    mapping(address => bool) whitelisted;\n  }\n\n  // The baseline is updated as\n  // max{floor, (1 - baselineUpdateFactor) * baseline + baselineUpdateFactor * participation}\n  struct ParticipationParameters {\n    // The average network participation in governance, weighted toward recent proposals.\n    FixidityLib.Fraction baseline;\n    // The lower bound on the participation baseline.\n    FixidityLib.Fraction baselineFloor;\n    // The weight of the most recent proposal's participation on the baseline.\n    FixidityLib.Fraction baselineUpdateFactor;\n    // The proportion of the baseline that constitutes quorum.\n    FixidityLib.Fraction baselineQuorumFactor;\n  }\n\n  Proposals.StageDurations public stageDurations;\n  uint256 public queueExpiry;\n  uint256 public dequeueFrequency;\n  address public approver;\n  uint256 public lastDequeue;\n  uint256 public concurrentProposals;\n  uint256 public proposalCount;\n  uint256 public minDeposit;\n  mapping(address => uint256) public refundedDeposits;\n  mapping(address => ContractConstitution) private constitution;\n  mapping(uint256 => Proposals.Proposal) private proposals;\n  mapping(address => Voter) private voters;\n  mapping(bytes32 => HotfixRecord) public hotfixes;\n  SortedLinkedList.List private queue;\n  uint256[] public dequeued;\n  uint256[] public emptyIndices;\n  ParticipationParameters private participationParameters;\n\n  event ApproverSet(address approver);\n\n  event ConcurrentProposalsSet(uint256 concurrentProposals);\n\n  event MinDepositSet(uint256 minDeposit);\n\n  event QueueExpirySet(uint256 queueExpiry);\n\n  event DequeueFrequencySet(uint256 dequeueFrequency);\n\n  event ApprovalStageDurationSet(uint256 approvalStageDuration);\n\n  event ReferendumStageDurationSet(uint256 referendumStageDuration);\n\n  event ExecutionStageDurationSet(uint256 executionStageDuration);\n\n  event ConstitutionSet(address indexed destination, bytes4 indexed functionId, uint256 threshold);\n\n  event ProposalQueued(\n    uint256 indexed proposalId,\n    address indexed proposer,\n    uint256 transactionCount,\n    uint256 deposit,\n    uint256 timestamp\n  );\n\n  event ProposalUpvoted(uint256 indexed proposalId, address indexed account, uint256 upvotes);\n\n  event ProposalUpvoteRevoked(\n    uint256 indexed proposalId,\n    address indexed account,\n    uint256 revokedUpvotes\n  );\n\n  event ProposalDequeued(uint256 indexed proposalId, uint256 timestamp);\n\n  event ProposalApproved(uint256 indexed proposalId);\n\n  event ProposalVoted(\n    uint256 indexed proposalId,\n    address indexed account,\n    uint256 value,\n    uint256 weight\n  );\n\n  event ProposalExecuted(uint256 indexed proposalId);\n\n  event ProposalExpired(uint256 proposalId);\n\n  event ParticipationBaselineUpdated(uint256 participationBaseline);\n\n  event ParticipationFloorSet(uint256 participationFloor);\n\n  event ParticipationBaselineUpdateFactorSet(uint256 baselineUpdateFactor);\n\n  event ParticipationBaselineQuorumFactorSet(uint256 baselineQuorumFactor);\n\n  event HotfixWhitelisted(bytes32 indexed hash, address whitelister);\n\n  event HotfixApproved(bytes32 indexed hash);\n\n  event HotfixPrepared(bytes32 indexed hash, uint256 indexed epoch);\n\n  event HotfixExecuted(bytes32 indexed hash);\n\n  function() external payable {} // solhint-disable no-empty-blocks\n\n  /**\n   * @notice Initializes critical variables.\n   * @param registryAddress The address of the registry contract.\n   * @param _approver The address that needs to approve proposals to move to the referendum stage.\n   * @param _concurrentProposals The number of proposals to dequeue at once.\n   * @param _minDeposit The minimum Celo Gold deposit needed to make a proposal.\n   * @param _queueExpiry The number of seconds a proposal can stay in the queue before expiring.\n   * @param _dequeueFrequency The number of seconds before the next batch of proposals can be\n   *   dequeued.\n   * @param approvalStageDuration The number of seconds the approver has to approve a proposal\n   *   after it is dequeued.\n   * @param referendumStageDuration The number of seconds users have to vote on a dequeued proposal\n   *   after the approval stage ends.\n   * @param executionStageDuration The number of seconds users have to execute a passed proposal\n   *   after the referendum stage ends.\n   * @param participationBaseline The initial value of the participation baseline.\n   * @param participationFloor The participation floor.\n   * @param baselineUpdateFactor The weight of the new participation in the baseline update rule.\n   * @param baselineQuorumFactor The proportion of the baseline that constitutes quorum.\n   * @dev Should be called only once.\n   */\n  function initialize(\n    address registryAddress,\n    address _approver,\n    uint256 _concurrentProposals,\n    uint256 _minDeposit,\n    uint256 _queueExpiry,\n    uint256 _dequeueFrequency,\n    uint256 approvalStageDuration,\n    uint256 referendumStageDuration,\n    uint256 executionStageDuration,\n    uint256 participationBaseline,\n    uint256 participationFloor,\n    uint256 baselineUpdateFactor,\n    uint256 baselineQuorumFactor\n  ) external initializer {\n    require(\n      _approver != address(0) &&\n        _concurrentProposals != 0 &&\n        _minDeposit != 0 &&\n        _queueExpiry != 0 &&\n        _dequeueFrequency != 0 &&\n        approvalStageDuration != 0 &&\n        referendumStageDuration != 0 &&\n        executionStageDuration != 0,\n      \"Bad input\"\n    );\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    approver = _approver;\n    concurrentProposals = _concurrentProposals;\n    minDeposit = _minDeposit;\n    queueExpiry = _queueExpiry;\n    dequeueFrequency = _dequeueFrequency;\n    stageDurations.approval = approvalStageDuration;\n    stageDurations.referendum = referendumStageDuration;\n    stageDurations.execution = executionStageDuration;\n    setParticipationBaseline(participationBaseline);\n    setParticipationFloor(participationFloor);\n    setBaselineUpdateFactor(baselineUpdateFactor);\n    setBaselineQuorumFactor(baselineQuorumFactor);\n    // solhint-disable-next-line not-rely-on-time\n    lastDequeue = now;\n  }\n\n  /**\n   * @notice Updates the address that has permission to approve proposals in the approval stage.\n   * @param _approver The address that has permission to approve proposals in the approval stage.\n   */\n  function setApprover(address _approver) external onlyOwner {\n    require(_approver != address(0), \"Approver cannot be 0\");\n    require(_approver != approver, \"Approver unchanged\");\n    approver = _approver;\n    emit ApproverSet(_approver);\n  }\n\n  /**\n   * @notice Updates the number of proposals to dequeue at a time.\n   * @param _concurrentProposals The number of proposals to dequeue at at a time.\n   */\n  function setConcurrentProposals(uint256 _concurrentProposals) external onlyOwner {\n    require(_concurrentProposals > 0, \"Number of proposals must be larger than zero\");\n    require(_concurrentProposals != concurrentProposals, \"Number of proposals unchanged\");\n    concurrentProposals = _concurrentProposals;\n    emit ConcurrentProposalsSet(_concurrentProposals);\n  }\n\n  /**\n   * @notice Updates the minimum deposit needed to make a proposal.\n   * @param _minDeposit The minimum Celo Gold deposit needed to make a proposal.\n   */\n  function setMinDeposit(uint256 _minDeposit) external onlyOwner {\n    require(_minDeposit != minDeposit, \"Minimum deposit unchanged\");\n    minDeposit = _minDeposit;\n    emit MinDepositSet(_minDeposit);\n  }\n\n  /**\n   * @notice Updates the number of seconds before a queued proposal expires.\n   * @param _queueExpiry The number of seconds a proposal can stay in the queue before expiring.\n   */\n  function setQueueExpiry(uint256 _queueExpiry) external onlyOwner {\n    require(_queueExpiry > 0, \"QueueExpiry must be larger than 0\");\n    require(_queueExpiry != queueExpiry, \"QueueExpiry unchanged\");\n    queueExpiry = _queueExpiry;\n    emit QueueExpirySet(_queueExpiry);\n  }\n\n  /**\n   * @notice Updates the minimum number of seconds before the next batch of proposals can be\n   *   dequeued.\n   * @param _dequeueFrequency The number of seconds before the next batch of proposals can be\n   *   dequeued.\n   */\n  function setDequeueFrequency(uint256 _dequeueFrequency) external onlyOwner {\n    require(_dequeueFrequency > 0, \"dequeueFrequency must be larger than 0\");\n    require(_dequeueFrequency != dequeueFrequency, \"dequeueFrequency unchanged\");\n    dequeueFrequency = _dequeueFrequency;\n    emit DequeueFrequencySet(_dequeueFrequency);\n  }\n\n  /**\n   * @notice Updates the number of seconds proposals stay in the approval stage.\n   * @param approvalStageDuration The number of seconds proposals stay in the approval stage.\n   */\n  function setApprovalStageDuration(uint256 approvalStageDuration) external onlyOwner {\n    require(approvalStageDuration > 0, \"Duration must be larger than 0\");\n    require(approvalStageDuration != stageDurations.approval, \"Duration unchanged\");\n    stageDurations.approval = approvalStageDuration;\n    emit ApprovalStageDurationSet(app"
    }
  ]
}