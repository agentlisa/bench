{
  "Title": "[N-12] NatSpec is incomplete",
  "Content": "\n*There is 1 instance of this issue:*\n\n```\nFile: contracts/VoterProxy.sol   \\#1\n\n/// @audit Missing: '@param bytes'\n191       /**\n192        * @notice  Verifies that the hash is valid\n193        * @dev     Snapshot Hub will call this function when a vote is submitted using\n194        *          snapshot.js on behalf of this contract. Snapshot Hub will call this\n195        *          function with the hash and the signature of the vote that was cast.\n196        * @param _hash Hash of the message that was sent to Snapshot Hub to cast a vote\n197        * @return EIP1271 magic value if the signature is value\n198        */\n199:      function isValidSignature(bytes32 _hash, bytes memory) public view returns (bytes4) {\n```\n\n<https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VoterProxy.sol#L191-L199>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-05-vetoken",
  "Code": [
    {
      "filename": "contracts/VoterProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Interfaces/IGauge.sol\";\nimport \"./Interfaces/IVoteEscrow.sol\";\nimport \"./Interfaces/IDeposit.sol\";\nimport \"./Interfaces/IFeeDistro.sol\";\nimport \"./Interfaces/IVoting.sol\";\nimport \"./Interfaces/ITokenMinter.sol\";\n\ncontract VoterProxy {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address public immutable veAsset;\n    address public immutable escrow;\n    address public immutable gaugeProxy;\n\n    address public immutable minter;\n\n    address public owner;\n    address public operator;\n    address public depositor;\n    string public name;\n    IVoteEscrow.EscrowModle public escrowModle;\n\n    mapping(address => bool) private protectedTokens;\n    mapping(address => bool) private stashPool;\n    mapping(bytes32 => bool) private votes;\n\n    bytes4 internal constant EIP1271_MAGIC_VALUE = 0x1626ba7e;\n\n    event VoteSet(bytes32 hash, bool valid);\n\n    constructor(\n        string memory _name,\n        address _veAsset,\n        address _escrow,\n        address _gaugeProxy,\n        address _minter,\n        IVoteEscrow.EscrowModle _escrowModle\n    ) {\n        name = _name;\n        veAsset = _veAsset;\n        escrow = _escrow;\n        gaugeProxy = _gaugeProxy;\n        owner = msg.sender;\n        minter = _minter;\n        escrowModle = _escrowModle;\n    }\n\n    function getName() external view returns (string memory) {\n        return name;\n    }\n\n    function setOwner(address _owner) external {\n        require(msg.sender == owner, \"!auth\");\n        owner = _owner;\n    }\n\n    function setOperator(address _operator) external {\n        require(msg.sender == owner, \"!auth\");\n        require(\n            operator == address(0) || IDeposit(operator).isShutdown() == true,\n            \"needs shutdown\"\n        );\n\n        operator = _operator;\n    }\n\n    function setDepositor(address _depositor) external {\n        require(msg.sender == owner, \"!auth\");\n\n        depositor = _depositor;\n    }\n\n    function setStashAccess(address _stash, bool _status) external returns (bool) {\n        require(msg.sender == operator, \"!auth\");\n        if (_stash != address(0)) {\n            stashPool[_stash] = _status;\n        }\n        return true;\n    }\n\n    function deposit(address _token, address _gauge) external returns (bool) {\n        require(msg.sender == operator, \"!auth\");\n        if (protectedTokens[_token] == false) {\n            protectedTokens[_token] = true;\n        }\n        if (protectedTokens[_gauge] == false) {\n            protectedTokens[_gauge] = true;\n        }\n        uint256 balance = IERC20(_token).balanceOf(address(this));\n        if (balance > 0) {\n            IERC20(_token).safeApprove(_gauge, 0);\n            IERC20(_token).safeApprove(_gauge, balance);\n            IGauge(_gauge).deposit(balance);\n        }\n        return true;\n    }\n\n    //stash only function for pulling extra incentive reward tokens out\n    function withdraw(IERC20 _asset) external returns (uint256 balance) {\n        require(stashPool[msg.sender] == true, \"!auth\");\n\n        //check protection\n        if (protectedTokens[address(_asset)] == true) {\n            return 0;\n        }\n\n        balance = _asset.balanceOf(address(this));\n        _asset.safeTransfer(msg.sender, balance);\n        return balance;\n    }\n\n    // Withdraw partial funds\n    function withdraw(\n        address _token,\n        address _gauge,\n        uint256 _amount\n    ) public returns (bool) {\n        require(msg.sender == operator, \"!auth\");\n        uint256 _balance = IERC20(_token).balanceOf(address(this));\n        if (_balance < _amount) {\n            _amount = _withdrawSome(_gauge, _amount.sub(_balance));\n            _amount = _amount.add(_balance);\n        }\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n        return true;\n    }\n\n    function withdrawAll(address _token, address _gauge) external returns (bool) {\n        require(msg.sender == operator, \"!auth\");\n        uint256 amount = balanceOfPool(_gauge).add(IERC20(_token).balanceOf(address(this)));\n        withdraw(_token, _gauge, amount);\n        return true;\n    }\n\n    function _withdrawSome(address _gauge, uint256 _amount) internal returns (uint256) {\n        IGauge(_gauge).withdraw(_amount);\n        return _amount;\n    }\n\n    function createLock(uint256 _value, uint256 _unlockTime) external returns (bool) {\n        require(msg.sender == depositor, \"!auth\");\n        IERC20(veAsset).safeApprove(escrow, 0);\n        IERC20(veAsset).safeApprove(escrow, _value);\n        IVoteEscrow(escrow).create_lock(_value, _unlockTime);\n        return true;\n    }\n\n    function increaseAmount(uint256 _value) external returns (bool) {\n        require(msg.sender == depositor, \"!auth\");\n        IERC20(veAsset).safeApprove(escrow, 0);\n        IERC20(veAsset).safeApprove(escrow, _value);\n        IVoteEscrow(escrow).increase_amount(_value);\n        return true;\n    }\n\n    function increaseTime(uint256 _value) external returns (bool) {\n        require(msg.sender == depositor, \"!auth\");\n        IVoteEscrow(escrow).increase_unlock_time(_value);\n        return true;\n    }\n\n    function release() external returns (bool) {\n        require(msg.sender == depositor, \"!auth\");\n        IVoteEscrow(escrow).withdraw();\n        return true;\n    }\n\n    /**\n     * @notice Save a vote hash so when snapshot.org asks this contract if\n     *          a vote signature is valid we are able to check for a valid hash\n     *          and return the appropriate response inline with EIP 1721\n     * @param _hash  Hash of vote signature that was sent to snapshot.org\n     * @param _valid Is the hash valid\n     */\n    function setVote(bytes32 _hash, bool _valid) external {\n        require(msg.sender == operator, \"!auth\");\n        votes[_hash] = _valid;\n        emit VoteSet(_hash, _valid);\n    }\n\n    /**\n     * @notice  Verifies that the hash is valid\n     * @dev     Snapshot Hub will call this function when a vote is submitted using\n     *          snapshot.js on behalf of this contract. Snapshot Hub will call this\n     *          function with the hash and the signature of the vote that was cast.\n     * @param _hash Hash of the message that was sent to Snapshot Hub to cast a vote\n     * @return EIP1271 magic value if the signature is value\n     */\n    function isValidSignature(bytes32 _hash, bytes memory) public view returns (bytes4) {\n        if (votes[_hash]) {\n            return EIP1271_MAGIC_VALUE;\n        } else {\n            return 0xffffffff;\n        }\n    }\n\n    function voteGaugeWeight(address[] calldata _tokenVote, uint256[] calldata _weight)\n        external\n        returns (bool)\n    {\n        require(msg.sender == operator, \"!auth\");\n\n        if (escrowModle == IVoteEscrow.EscrowModle.PICKLE) {\n            //vote\n            IVoting(gaugeProxy).vote(_tokenVote, _weight);\n        } else {\n            for (uint256 i = 0; i < _tokenVote.length; i++) {\n                IVoting(gaugeProxy).vote_for_gauge_weights(_tokenVote[i], _weight[i]);\n            }\n        }\n        return true;\n    }\n\n    function claimVeAsset(address _gauge) external returns (uint256) {\n        require(msg.sender == operator, \"!auth\");\n\n        uint256 _balance = 0;\n\n        if (escrowModle == IVoteEscrow.EscrowModle.PICKLE) {\n            try IGauge(_gauge).getReward() {} catch {\n                return _balance;\n            }\n        } else if (\n            escrowModle == IVoteEscrow.EscrowModle.CURVE ||\n            escrowModle == IVoteEscrow.EscrowModle.RIBBON\n        ) {\n            try ITokenMinter(minter).mint(_gauge) {} catch {\n                return _balance;\n            }\n        } else if (escrowModle == IVoteEscrow.EscrowModle.IDLE) {\n            try ITokenMinter(minter).distribute(_gauge) {} catch {\n                return _balance;\n            }\n        } else if (escrowModle == IVoteEscrow.EscrowModle.ANGLE) {\n            try IGauge(_gauge).claim_rewards() {} catch {\n                return _balance;\n            }\n        }\n\n        _balance = IERC20(veAsset).balanceOf(address(this));\n        IERC20(veAsset).safeTransfer(operator, _balance);\n\n        return _balance;\n    }\n\n    function claimRewards(address _gauge) external returns (bool) {\n        require(msg.sender == operator, \"!auth\");\n        IGauge(_gauge).claim_rewards();\n        return true;\n    }\n\n    function claimFees(address _distroContract, address _token) external returns (uint256) {\n        require(msg.sender == operator, \"!auth\");\n        IFeeDistro(_distroContract).claim();\n        uint256 _balance = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransfer(operator, _balance);\n        return _balance;\n    }\n\n    function balanceOfPool(address _gauge) public view returns (uint256) {\n        return IGauge(_gauge).balanceOf(address(this));\n    }\n\n    function execute(\n        address _to,\n        uint256 _value,\n        bytes calldata _data\n    ) external returns (bool, bytes memory) {\n        require(msg.sender == operator, \"!auth\");\n\n        (bool success, bytes memory result) = _to.call{value: _value}(_data);\n        require(success, \"!success\");\n\n        return (success, result);\n    }\n}"
    }
  ]
}