{
  "Title": "[M-05] Whitelisted profile creators could accidentally break migration for V1 profiles",
  "Content": "\nProfiles that exist before the V2 upgrade are migrated using the [`batchMigrateProfiles()`](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/misc/LensV2Migration.sol#L33-L35) function, which works by minting the profile's handle and linking it to their profile:\n\n[MigrationLib.sol#L69-L85](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/libraries/MigrationLib.sol#L69-L85)\n\n```solidity\n            string memory handle = StorageLib.getProfile(profileId).__DEPRECATED__handle;\n            if (bytes(handle).length == 0) {\n                return; // Already migrated\n            }\n            bytes32 handleHash = keccak256(bytes(handle));\n            // We check if the profile is the \"lensprotocol\" profile by checking profileId != 1.\n            // \"lensprotocol\" is the only edge case without the .lens suffix:\n            if (profileId != LENS_PROTOCOL_PROFILE_ID) {\n                assembly {\n                    let handle_length := mload(handle)\n                    mstore(handle, sub(handle_length, DOT_LENS_SUFFIX_LENGTH)) // Cut 5 chars (.lens) from the end\n                }\n            }\n            // We mint a new handle on the LensHandles contract. The resulting handle NFT is sent to the profile owner.\n            uint256 handleId = lensHandles.migrateHandle(profileOwner, handle);\n            // We link it to the profile in the TokenHandleRegistry contract.\n            tokenHandleRegistry.migrationLink(handleId, profileId);\n```\n\nFor example, a profile with the handle \"alice.lens\" will receive an \"alice\" LensHandles NFT post-migration.\n\nHowever, whitelisted profile creators are able to mint any handle using [`mintHandle()`](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/namespaces/LensHandles.sol#L87-L94) in the `LensHandles` contract. This makes it possible for any whitelisted profile creator to mint a handle corresponding to a V1 profile before the profile is migrated.\n\nIf this occurs, `batchMigrateProfiles()` will always revert for the corresponding V1 profile as the same handle cannot be minted twice, thereby breaking migration for that profile.\n\n### Impact\n\nIf a whitelisted profile creator accidentally mints a handle that already belongs to a V1 profile, that profile cannot be migrated.\n\n### Proof of Concept\n\nThe Foundry test below demonstrates how `batchMigrateProfiles()` will revert if a V1 profile's handle has already been minted. It can be run with the following command:\n\n    forge test --match-test testProfileCreatorCanBreakProfileMigration -vvv\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport 'test/base/BaseTest.t.sol';\n\ncontract ProfileMigration_POC is BaseTest {\n    LensHubHelper hubProxy;\n\n    function setUp() public override {\n        super.setUp();\n        \n        // Add toLegacyV1Profile() function to LensHub\n        LensHubHelper implementation = new LensHubHelper({\n            lensHandlesAddress: address(lensHandles),\n            tokenHandleRegistryAddress: address(tokenHandleRegistry),\n            tokenGuardianCooldown: PROFILE_GUARDIAN_COOLDOWN\n        });\n        vm.prank(deployer);\n        hubAsProxy.upgradeTo(address(implementation));\n\n        // Cast proxy to LensHubHelper interface\n        hubProxy = LensHubHelper(address(hubAsProxy));\n    }\n\n    function testProfileCreatorCanBreakProfileMigration() public {\n        // Create a v1 profile with the handle \"alice.lens\"\n        uint256 profileId = _createProfile(address(this));\n        hubProxy.toLegacyV1Profile(profileId, \"alice.lens\");\n\n        // Whitelisted profile creator accidentally mints a \"alice.lens\" handle\n        vm.prank(lensHandles.OWNER());\n        lensHandles.mintHandle(address(this), \"alice\");\n\n        // V1 profile will revert when migrated as the handle already exists\n        vm.expectRevert(\"ERC721: token already minted\");\n        hubProxy.batchMigrateProfiles(_toUint256Array(profileId));\n    }\n}\n\ncontract LensHubHelper is LensHub {\n    constructor(\n        address lensHandlesAddress,\n        address tokenHandleRegistryAddress,\n        uint256 tokenGuardianCooldown\n    ) LensHub(\n        address(0),\n        address(0),\n        address(0),\n        lensHandlesAddress,\n        tokenHandleRegistryAddress,\n        address(0),\n        address(0),\n        address(0),\n        tokenGuardianCooldown\n    ) {}\n\n\n    function toLegacyV1Profile(uint256 profileId, string memory handle) external {\n        Types.Profile storage profile = StorageLib.getProfile(profileId);\n        profile.__DEPRECATED__handle = handle;\n        delete profile.metadataURI;\n    }\n}\n```\n\n### Recommended Mitigation\n\nEnsure that the handle of a V1 profile cannot be minted through `mintHandle()`. This validation will probably have to be done off-chain, as it is unfeasible to check all existing handles on-chain with a reasonable gas cost.\n\n### Assessed type\n\nUpgradable\n\n**[donosonaumczuk (Lens) confirmed commented](https://github.com/code-423n4/2023-07-lens-findings/issues/143#issuecomment-1668126368):**\n > We found this issue once the audit was already in progress, so we weren't allowed to push it, but we already mitigated it by adding this function in the LensHub:\n> \n> ```solidity\n>     function getProfileIdByHandleHash(bytes32 handleHash) external view returns (uint256) {\n>         return StorageLib.profileIdByHandleHash()[handleHash];\n>     }\n> ```\n> \n> And then making the ProfileCreationProxy to validate against it:\n> ```solidity\n>     function proxyCreateProfileWithHandle(\n>         Types.CreateProfileParams memory createProfileParams,\n>         string calldata handle\n>     ) external onlyOwner returns (uint256, uint256) {\n>         // Check if LensHubV1 already has a profile with this handle that was not migrated yet:\n>         bytes32 handleHash = keccak256(bytes(string.concat(handle, '.lens')));\n>         if (LensV2Migration(LENS_HUB).getProfileIdByHandleHash(handleHash) != 0) {\n>             revert ProfileAlreadyExists();\n>         }\n>         \n>         // ...\n>      }\n> ```\n> \n> Note that we add the validation at ProfileCreationProxy instead of LensHub, as we don't want LensHub to \"be aware\" of the Handles, architecturally-wise.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-07-lens",
  "Code": [
    {
      "filename": "contracts/misc/LensV2Migration.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {MigrationLib} from 'contracts/libraries/MigrationLib.sol';\n\n// Handles\nimport {LensHandles} from 'contracts/namespaces/LensHandles.sol';\nimport {TokenHandleRegistry} from 'contracts/namespaces/TokenHandleRegistry.sol';\n\ncontract LensV2Migration {\n    address internal immutable FEE_FOLLOW_MODULE;\n    address internal immutable PROFILE_FOLLOW_MODULE;\n    address internal immutable NEW_FEE_FOLLOW_MODULE;\n\n    LensHandles internal immutable lensHandles;\n    TokenHandleRegistry internal immutable tokenHandleRegistry;\n\n    constructor(\n        address legacyFeeFollowModule,\n        address legacyProfileFollowModule,\n        address newFeeFollowModule,\n        address lensHandlesAddress,\n        address tokenHandleRegistryAddress\n    ) {\n        FEE_FOLLOW_MODULE = legacyFeeFollowModule;\n        PROFILE_FOLLOW_MODULE = legacyProfileFollowModule;\n        NEW_FEE_FOLLOW_MODULE = newFeeFollowModule;\n        lensHandles = LensHandles(lensHandlesAddress);\n        tokenHandleRegistry = TokenHandleRegistry(tokenHandleRegistryAddress);\n    }\n\n    function batchMigrateProfiles(uint256[] calldata profileIds) external {\n        MigrationLib.batchMigrateProfiles(profileIds, lensHandles, tokenHandleRegistry);\n    }\n\n    function batchMigrateFollows(\n        uint256[] calldata followerProfileIds,\n        uint256[] calldata idsOfProfileFollowed,\n        uint256[] calldata followTokenIds\n    ) external {\n        MigrationLib.batchMigrateFollows(followerProfileIds, idsOfProfileFollowed, followTokenIds);\n    }\n\n    function batchMigrateFollowModules(uint256[] calldata profileIds) external {\n        MigrationLib.batchMigrateFollowModules(\n            profileIds,\n            FEE_FOLLOW_MODULE,\n            PROFILE_FOLLOW_MODULE,\n            NEW_FEE_FOLLOW_MODULE\n        );\n    }\n}"
    },
    {
      "filename": "contracts/libraries/MigrationLib.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.19;\n\nimport {Events} from 'contracts/libraries/constants/Events.sol';\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\nimport {StorageLib} from 'contracts/libraries/StorageLib.sol';\nimport {FollowNFT} from 'contracts/FollowNFT.sol';\nimport {LensHandles} from 'contracts/namespaces/LensHandles.sol';\nimport {TokenHandleRegistry} from 'contracts/namespaces/TokenHandleRegistry.sol';\nimport {IFollowModule} from 'contracts/interfaces/IFollowModule.sol';\n\ninterface ILegacyFeeFollowModule {\n    struct ProfileData {\n        address currency;\n        uint256 amount;\n        address recipient;\n    }\n\n    function getProfileData(uint256 profileId) external view returns (ProfileData memory);\n}\n\nlibrary MigrationLib {\n    uint256 internal constant LENS_PROTOCOL_PROFILE_ID = 1;\n    uint256 internal constant DOT_LENS_SUFFIX_LENGTH = 5;\n\n    // Profiles Handles Migration:\n\n    event ProfileMigrated(uint256 profileId, address profileDestination, string handle, uint256 handleId);\n\n    /**\n     * @notice Migrates an array of profiles from V1 to V2. This function can be callable by anyone.\n     * We would still perform the migration in batches by ourselves, but good to allow users to migrate on their own if they want to.\n     *\n     * @param profileIds The array of profile IDs to migrate.\n     */\n    function batchMigrateProfiles(\n        uint256[] calldata profileIds,\n        LensHandles lensHandles,\n        TokenHandleRegistry tokenHandleRegistry\n    ) external {\n        uint256 i;\n        while (i < profileIds.length) {\n            _migrateProfile(profileIds[i], lensHandles, tokenHandleRegistry);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Migrates a profile from V1 to V2.\n     *\n     * @dev We do not revert in any case, as we want to allow the migration to continue even if one profile fails\n     *      (and it usually fails if already migrated or profileNFT moved).\n     * @dev Estimated gas cost of one profile migration is around 178k gas.\n     *\n     * @param profileId The profile ID to migrate.\n     */\n    function _migrateProfile(\n        uint256 profileId,\n        LensHandles lensHandles,\n        TokenHandleRegistry tokenHandleRegistry\n    ) private {\n        address profileOwner = StorageLib.getTokenData(profileId).owner;\n        // We check if the profile exists by checking owner != address(0).\n        if (profileOwner != address(0)) {\n            // We check if the profile has already been migrated by checking __DEPRECATED__handle != \"\".\n            string memory handle = StorageLib.getProfile(profileId).__DEPRECATED__handle;\n            if (bytes(handle).length == 0) {\n                return; // Already migrated\n            }\n            bytes32 handleHash = keccak256(bytes(handle));\n            // We check if the profile is the \"lensprotocol\" profile by checking profileId != 1.\n            // \"lensprotocol\" is the only edge case without the .lens suffix:\n            if (profileId != LENS_PROTOCOL_PROFILE_ID) {\n                assembly {\n                    let handle_length := mload(handle)\n                    mstore(handle, sub(handle_length, DOT_LENS_SUFFIX_LENGTH)) // Cut 5 chars (.lens) from the end\n                }\n            }\n            // We mint a new handle on the LensHandles contract. The resulting handle NFT is sent to the profile owner.\n            uint256 handleId = lensHandles.migrateHandle(profileOwner, handle);\n            // We link it to the profile in the TokenHandleRegistry contract.\n            tokenHandleRegistry.migrationLink(handleId, profileId);\n            emit ProfileMigrated(profileId, profileOwner, handle, handleId);\n            delete StorageLib.getProfile(profileId).__DEPRECATED__handle;\n            delete StorageLib.profileIdByHandleHash()[handleHash];\n        }\n    }\n\n    // FollowNFT Migration:\n\n    function batchMigrateFollows(\n        uint256[] calldata followerProfileIds,\n        uint256[] calldata idsOfProfileFollowed,\n        uint256[] calldata followTokenIds\n    ) external {\n        if (\n            followerProfileIds.length != idsOfProfileFollowed.length ||\n            followerProfileIds.length != followTokenIds.length\n        ) {\n            revert Errors.ArrayMismatch();\n        }\n        uint256 i;\n        while (i < followerProfileIds.length) {\n            _migrateFollow(followerProfileIds[i], idsOfProfileFollowed[i], followTokenIds[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _migrateFollow(\n        uint256 followerProfileId,\n        uint256 idOfProfileFollowed,\n        uint256 followTokenId\n    ) private {\n        uint48 mintTimestamp = FollowNFT(StorageLib.getProfile(idOfProfileFollowed).followNFT).tryMigrate({\n            followerProfileId: followerProfileId,\n            followerProfileOwner: StorageLib.getTokenData(followerProfileId).owner,\n            idOfProfileFollowed: idOfProfileFollowed,\n            followTokenId: followTokenId\n        });\n        // `mintTimestamp` will be 0 if:\n        // - Follow NFT was already migrated\n        // - Follow NFT does not exist or was burnt\n        // - Follower profile Owner is different from Follow NFT Owner\n        if (mintTimestamp != 0) {\n            emit Events.Followed({\n                followerProfileId: followerProfileId,\n                idOfProfileFollowed: idOfProfileFollowed,\n                followTokenIdAssigned: followTokenId,\n                followModuleData: '',\n                processFollowModuleReturnData: '',\n                timestamp: mintTimestamp // The only case where this won't match block.timestamp is during the migration\n            });\n        }\n    }\n\n    function batchMigrateFollowModules(\n        uint256[] calldata profileIds,\n        address legacyFeeFollowModule,\n        address legacyProfileFollowModule,\n        address newFeeFollowModule\n    ) external {\n        uint256 i;\n        while (i < profileIds.length) {\n            address currentFollowModule = StorageLib.getProfile(profileIds[i]).followModule;\n            if (currentFollowModule == legacyFeeFollowModule) {\n                // If the profile had the legacy 'feeFollowModule' set, we need to read its parameters\n                // and initialize the new feeFollowModule with them.\n                StorageLib.getProfile(profileIds[i]).followModule = newFeeFollowModule;\n                ILegacyFeeFollowModule.ProfileData memory feeFollowModuleData = ILegacyFeeFollowModule(\n                    legacyFeeFollowModule\n                ).getProfileData(profileIds[i]);\n                IFollowModule(newFeeFollowModule).initializeFollowModule({\n                    profileId: profileIds[i],\n                    transactionExecutor: msg.sender,\n                    data: abi.encode(\n                        feeFollowModuleData.currency,\n                        feeFollowModuleData.amount,\n                        feeFollowModuleData.recipient\n                    )\n                });\n            } else if (currentFollowModule == legacyProfileFollowModule) {\n                // If the profile had `ProfileFollowModule` set, we just remove the follow module, as in Lens V2\n                // you can only follow with a Lens profile.\n                delete StorageLib.getProfile(profileIds[i]).followModule;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/namespaces/LensHandles.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\nimport {ERC721} from '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport {ImmutableOwnable} from 'contracts/misc/ImmutableOwnable.sol';\nimport {ILensHandles} from 'contracts/interfaces/ILensHandles.sol';\nimport {HandlesEvents} from 'contracts/namespaces/constants/Events.sol';\nimport {HandlesErrors} from 'contracts/namespaces/constants/Errors.sol';\nimport {HandleTokenURILib} from 'contracts/libraries/token-uris/HandleTokenURILib.sol';\nimport {ILensHub} from 'contracts/interfaces/ILensHub.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * A handle is defined as a local name inside a namespace context. A handle is represented as the local name with its\n * namespace applied as a suffix, using the dot symbol as separator.\n *\n *      handle = ${localName}.${namespace}\n *\n * Handle and local name can be used interchangeably once you are in a context of a namespace, as it became redundant.\n *\n *      handle === ${localName} ; inside some namespace.\n */\ncontract LensHandles is ERC721, ImmutableOwnable, ILensHandles {\n    using Address for address;\n\n    uint256 internal constant MAX_HANDLE_LENGTH = 31;\n    string internal constant NAMESPACE = 'lens';\n    uint256 internal immutable NAMESPACE_LENGTH = bytes(NAMESPACE).length;\n    uint256 internal constant SEPARATOR_LENGTH = 1; // bytes('.').length;\n    bytes32 internal constant NAMESPACE_HASH = keccak256(bytes(NAMESPACE));\n    uint256 internal immutable TOKEN_GUARDIAN_COOLDOWN;\n\n    mapping(address => uint256) internal _tokenGuardianDisablingTimestamp;\n\n    mapping(uint256 tokenId => string localName) internal _localNames;\n\n    modifier onlyOwnerOrWhitelistedProfileCreator() {\n        if (\n            msg.sender != OWNER && !ILensHub(LENS_HUB).isProfileCreatorWhitelisted(msg.sender)\n        ) {\n            revert HandlesErrors.NotOwnerNorWhitelisted();\n        }\n        _;\n    }\n\n    modifier onlyEOA() {\n        if (msg.sender.isContract()) {\n            revert HandlesErrors.NotEOA();\n        }\n        _;\n    }\n\n    modifier onlyHub() {\n        if (msg.sender != LENS_HUB) {\n            revert HandlesErrors.NotHub();\n        }\n        _;\n    }\n\n    constructor(\n        address owner,\n        address lensHub,\n        uint256 tokenGuardianCooldown\n    ) ERC721('', '') ImmutableOwnable(owner, lensHub) {\n        TOKEN_GUARDIAN_COOLDOWN = tokenGuardianCooldown;\n    }\n\n    function name() public pure override returns (string memory) {\n        return string.concat(symbol(), ' Handles');\n    }\n\n    function symbol() public pure override returns (string memory) {\n        return string.concat('.', NAMESPACE);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        _requireMinted(tokenId);\n        return HandleTokenURILib.getTokenURI(tokenId, _localNames[tokenId]);\n    }\n\n    /// @inheritdoc ILensHandles\n    function mintHandle(address to, string calldata localName)\n        external\n        onlyOwnerOrWhitelistedProfileCreator\n        returns (uint256)\n    {\n        _validateLocalName(localName);\n        return _mintHandle(to, localName);\n    }\n\n    function migrateHandle(address to, string calldata localName) external onlyHub returns (uint256) {\n        _validateLocalNameMigration(localName);\n        return _mintHandle(to, localName);\n    }\n\n    function burn(uint256 tokenId) external {\n        if (msg.sender != ownerOf(tokenId)) {\n            revert HandlesErrors.NotOwner();\n        }\n        _burn(tokenId);\n        delete _localNames[tokenId];\n    }\n\n    /// ************************************\n    /// ****  TOKEN GUARDIAN FUNCTIONS  ****\n    /// ************************************\n\n    function DANGER__disableTokenGuardian() external onlyEOA {\n        if (_tokenGuardianDisablingTimestamp[msg.sender] != 0) {\n            revert HandlesErrors.DisablingAlreadyTriggered();\n        }\n        _tokenGuardianDisablingTimestamp[msg.sender] = block.timestamp + TOKEN_GUARDIAN_COOLDOWN;\n        emit HandlesEvents.TokenGuardianStateChanged({\n            wallet: msg.sender,\n            enabled: false,\n            tokenGuardianDisablingTimestamp: block.timestamp + TOKEN_GUARDIAN_COOLDOWN,\n            timestamp: block.timestamp\n        });\n    }\n\n    function enableTokenGuardian() external onlyEOA {\n        if (_tokenGuardianDisablingTimestamp[msg.sender] == 0) {\n            revert HandlesErrors.AlreadyEnabled();\n        }\n        _tokenGuardianDisablingTimestamp[msg.sender] = 0;\n        emit HandlesEvents.TokenGuardianStateChanged({\n            wallet: msg.sender,\n            enabled: true,\n            tokenGuardianDisablingTimestamp: 0,\n            timestamp: block.timestamp\n        });\n    }\n\n    function approve(address to, uint256 tokenId) public override(IERC721, ERC721) {\n        // We allow removing approvals even if the wallet has the token guardian enabled\n        if (to != address(0) && _hasTokenGuardianEnabled(msg.sender)) {\n            revert HandlesErrors.GuardianEnabled();\n        }\n        super.approve(to, tokenId);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public override(IERC721, ERC721) {\n        // We allow removing approvals even if the wallet has the token guardian enabled\n        if (approved && _hasTokenGuardianEnabled(msg.sender)) {\n            revert HandlesErrors.GuardianEnabled();\n        }\n        super.setApprovalForAll(operator, approved);\n    }\n\n    function exists(uint256 tokenId) external view returns (bool) {\n        return _exists(tokenId);\n    }\n\n    function getNamespace() external pure returns (string memory) {\n        return NAMESPACE;\n    }\n\n    function getNamespaceHash() external pure returns (bytes32) {\n        return NAMESPACE_HASH;\n    }\n\n    // TODO: Should we revert if it doesn't exist?\n    function getLocalName(uint256 tokenId) public view returns (string memory) {\n        string memory localName = _localNames[tokenId];\n        if (bytes(localName).length == 0) {\n            revert HandlesErrors.DoesNotExist();\n        }\n        return _localNames[tokenId];\n    }\n\n    // TODO: Should we revert if it doesn't exist?\n    function getHandle(uint256 tokenId) public view returns (string memory) {\n        string memory localName = getLocalName(tokenId);\n        return string.concat(localName, '.', NAMESPACE);\n    }\n\n    function getTokenId(string memory localName) public pure returns (uint256) {\n        return uint256(keccak256(bytes(localName)));\n    }\n\n    function getTokenGuardianDisablingTimestamp(address wallet) external view returns (uint256) {\n        return _tokenGuardianDisablingTimestamp[wallet];\n    }\n\n    //////////////////////////////////////\n    ///        INTERNAL FUNCTIONS      ///\n    //////////////////////////////////////\n\n    function _mintHandle(address to, string calldata localName) internal returns (uint256) {\n        uint256 tokenId = getTokenId(localName);\n        _mint(to, tokenId);\n        _localNames[tokenId] = localName;\n        emit HandlesEvents.HandleMinted(localName, NAMESPACE, tokenId, to, block.timestamp);\n        return tokenId;\n    }\n\n    function _validateLocalNameMigration(string memory localName) internal view {\n        bytes memory localNameAsBytes = bytes(localName);\n        uint256 localNameLength = localNameAsBytes.length;\n\n        if (localNameLength == 0 || localNameLength + SEPARATOR_LENGTH + NAMESPACE_LENGTH > MAX_HANDLE_LENGTH) {\n            revert HandlesErrors.HandleLengthInvalid();\n        }\n\n        bytes1 firstByte = localNameAsBytes[0];\n        if (firstByte == '-' || firstByte == '_') {\n            revert HandlesErrors.HandleFirstCharInvalid();\n        }\n\n        uint256 i;\n        while (i < localNameLength) {\n            if (!_isAlphaNumeric(localNameAsBytes[i]) && localNameAsBytes[i] != '-' && localNameAsBytes[i] != '_') {\n                revert HandlesErrors.HandleContainsInvalidCharacters();\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _validateLocalName(string memory localName) internal view {\n        bytes memory localNameAsBytes = bytes(localName);\n        uint256 localNameLength = localNameAsBytes.length;\n\n        if (localNameLength == 0 || localNameLength + SEPARATOR_LENGTH + NAMESPACE_LENGTH > MAX_HANDLE_LENGTH) {\n            revert HandlesErrors.HandleLengthInvalid();\n        }\n\n        if (localNameAsBytes[0] == '_') {\n            revert HandlesErrors.HandleFirstCharInvalid();\n        }\n\n        uint256 i;\n        while (i < localNameLength) {\n            if (!_isAlphaNumeric(localNameAsBytes[i]) && localNameAsBytes[i] != '_') {\n                revert HandlesErrors.HandleContainsInvalidCharacters();\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _isAlphaNumeric(bytes1 char) internal pure returns (bool) {\n        return (char >= '0' && char <= '9') || (char >= 'a' && char <= 'z');\n    }\n\n    function _hasTokenGuardianEnabled(address wallet) internal view returns (bool) {\n        return\n            !wallet.isContract() &&\n            (_tokenGuardianDisablingTimestamp[wallet] == 0 ||\n                block.timestamp < _tokenGuardianDisablingTimestamp[wallet]);\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 /* firstTokenId */,\n        uint256 batchSize\n    ) internal override {\n        if (from != address(0) && _hasTokenGuardianEnabled(from)) {\n            // Cannot transfer handle if the guardian is enabled, except at minting time.\n            revert HandlesErrors.GuardianEnabled();\n        }\n\n        super._beforeTokenTransfer(from, to, 0, batchSize);\n    }\n}"
    }
  ]
}