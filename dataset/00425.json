{
  "Title": "M-6: BBLeverage::sellCollateral is unusable due to wrong asset deposit attempt in YieldBox",
  "Content": "# Issue M-6: BBLeverage::sellCollateral is unusable due to wrong asset deposit attempt in YieldBox \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/42 \n\n## Found by \n0xadrii, bin2chen, cergyk, duc\n## Summary\n`sellCollateral` enable to leverage up on a borrow position in a BigBang market. However the endpoint is unusable as is due to `collateralId` used to deposit in YieldBox, instead of `assetId`\n\n## Vulnerability Detail\nWe can see here that after withdrawing `collateral`, and swapping it for `asset`, `BBLeverage::sellCollateral` attempts to deposit `collateralId` into YieldBox:\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/bigBang/BBLeverage.sol#L149\n\nWhich will always revert, since at that point we always have `asset` and not `collateral`.\n\nThis function is thus unusable\n\n## Impact\nThe function `BBLeverage::sellCollateral` will always revert and is unusable\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\nChange the deposit to use `assetId`, as is correctly done in SGLLeverage:\n```diff\n-        yieldBox.depositAsset(collateralId, address(this), address(this), 0, memoryData.shareOut); // TODO Check for rounding attack?\n+        yieldBox.depositAsset(assetId, address(this), address(this), 0, memoryData.shareOut); // TODO Check for rounding attack?\n```\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/singularity/SGLLeverage.sol#L135\n\n\n\n## Discussion\n\n**cryptotechmaker**\n\nSame for SGLLeverage.sellCollateral\n\n\n**cryptotechmaker**\n\nFixed in https://github.com/Tapioca-DAO/Tapioca-bar/pull/352\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Tapioca-DAO/Tapioca-bar/pull/352.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "Tapioca-bar/contracts/markets/bigBang/BBLeverage.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {BoringERC20} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport {IERC20} from \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\n\n// Tapioca\nimport {SafeApprove} from \"../../libraries/SafeApprove.sol\";\nimport {BBLendingCommon} from \"./BBLendingCommon.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract BBLeverage is BBLendingCommon {\n    using RebaseLibrary for Rebase;\n    using SafeApprove for address;\n    using BoringERC20 for IERC20;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error LeverageExecutorNotValid();\n    error CollateralShareNotValid();\n\n    struct _BuyCollateralCalldata {\n        address from;\n        uint256 borrowAmount;\n        uint256 supplyAmount;\n        bytes data;\n    }\n\n    struct _BuyCollateralMemoryData {\n        uint256 supplyShareToAmount;\n        uint256 borrowShareToAmount;\n    }\n\n    /// @notice Lever up: Borrow more and buy collateral with it.\n    /// @param from The user who buys\n    /// @param borrowAmount Amount of extra asset borrowed\n    /// @param supplyAmount Amount of asset supplied (down payment)\n    /// @param data LeverageExecutor data\n    /// @return amountOut Actual collateral amount purchased\n    function buyCollateral(address from, uint256 borrowAmount, uint256 supplyAmount, bytes calldata data)\n        external\n        optionNotPaused(PauseType.LeverageBuy)\n        solvent(from, false)\n        notSelf(from)\n        returns (uint256 amountOut)\n    {\n        if (address(leverageExecutor) == address(0)) {\n            revert LeverageExecutorNotValid();\n        }\n\n        // Stack too deep fix\n        _BuyCollateralCalldata memory calldata_;\n        _BuyCollateralMemoryData memory memoryData;\n        {\n            calldata_.from = from;\n            calldata_.borrowAmount = borrowAmount;\n            calldata_.supplyAmount = supplyAmount;\n            calldata_.data = data;\n        }\n\n        {\n            uint256 supplyShare = yieldBox.toShare(assetId, calldata_.supplyAmount, true);\n            if (supplyShare > 0) {\n                (memoryData.supplyShareToAmount,) =\n                    yieldBox.withdraw(assetId, calldata_.from, address(leverageExecutor), 0, supplyShare);\n            }\n        }\n\n        {\n            (, uint256 borrowShare) = _borrow(\n                calldata_.from,\n                address(this),\n                calldata_.borrowAmount,\n                _computeVariableOpeningFee(calldata_.borrowAmount)\n            );\n            (memoryData.borrowShareToAmount,) =\n                yieldBox.withdraw(assetId, address(this), address(leverageExecutor), 0, borrowShare);\n        }\n        {\n            amountOut = leverageExecutor.getCollateral(\n                collateralId,\n                address(asset),\n                address(collateral),\n                memoryData.supplyShareToAmount + memoryData.borrowShareToAmount,\n                calldata_.from,\n                calldata_.data\n            );\n        }\n        uint256 collateralShare = yieldBox.toShare(collateralId, amountOut, false);\n        address(asset).safeApprove(address(yieldBox), type(uint256).max);\n        yieldBox.depositAsset(collateralId, address(this), address(this), 0, collateralShare); // TODO Check for rounding attack?\n        address(asset).safeApprove(address(yieldBox), 0);\n\n        if (collateralShare == 0) revert CollateralShareNotValid();\n        _allowedBorrow(calldata_.from, collateralShare);\n        _addCollateral(calldata_.from, calldata_.from, false, 0, collateralShare);\n    }\n\n    struct _SellCollateralMemoryData {\n        uint256 obtainedShare;\n        uint256 leverageAmount;\n        uint256 shareOut;\n        uint256 partOwed;\n        uint256 amountOwed;\n        uint256 shareOwed;\n    }\n\n    /// @notice Lever down: Sell collateral to repay debt; excess goes to YB\n    /// @param from The user who sells\n    /// @param share Collateral YieldBox-shares to sell\n    /// @param data LeverageExecutor data\n    /// @return amountOut Actual asset amount received in the sale\n    function sellCollateral(address from, uint256 share, bytes calldata data)\n        external\n        optionNotPaused(PauseType.LeverageSell)\n        solvent(from, false)\n        notSelf(from)\n        returns (uint256 amountOut)\n    {\n        if (address(leverageExecutor) == address(0)) {\n            revert LeverageExecutorNotValid();\n        }\n        _allowedBorrow(from, share);\n        _removeCollateral(from, address(this), share);\n\n        _SellCollateralMemoryData memory memoryData;\n\n        (, memoryData.obtainedShare) =\n            yieldBox.withdraw(collateralId, address(this), address(leverageExecutor), 0, share);\n        memoryData.leverageAmount = yieldBox.toAmount(collateralId, memoryData.obtainedShare, false);\n        amountOut = leverageExecutor.getAsset(\n            assetId, address(collateral), address(asset), memoryData.leverageAmount, from, data\n        );\n        memoryData.shareOut = yieldBox.toShare(assetId, amountOut, false);\n        address(asset).safeApprove(address(yieldBox), type(uint256).max);\n        yieldBox.depositAsset(collateralId, address(this), address(this), 0, memoryData.shareOut); // TODO Check for rounding attack?\n        address(asset).safeApprove(address(yieldBox), 0);\n\n        memoryData.partOwed = userBorrowPart[from];\n        memoryData.amountOwed = totalBorrow.toElastic(memoryData.partOwed, true);\n        memoryData.shareOwed = yieldBox.toShare(assetId, memoryData.amountOwed, true);\n        if (memoryData.shareOwed <= memoryData.shareOut) {\n            _repay(from, from, memoryData.partOwed);\n        } else {\n            //repay as much as we can\n            uint256 partOut = totalBorrow.toBase(amountOut, false);\n            _repay(from, from, partOut);\n        }\n    }\n}"
    },
    {
      "filename": "Tapioca-bar/contracts/markets/singularity/SGLLeverage.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {BoringERC20, IERC20} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\n\n// Tapioca\nimport {SafeApprove} from \"../../libraries/SafeApprove.sol\";\nimport {SGLLendingCommon} from \"./SGLLendingCommon.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract SGLLeverage is SGLLendingCommon {\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n    using SafeApprove for address;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error LeverageExecutorNotValid();\n    error CollateralShareNotValid();\n\n    struct _BuyCollateralCalldata {\n        address from;\n        uint256 borrowAmount;\n        uint256 supplyAmount;\n        bytes data;\n    }\n\n    /// @notice Lever up: Borrow more and buy collateral with it.\n    /// @param from The user who buys\n    /// @param borrowAmount Amount of extra asset borrowed\n    /// @param supplyAmount Amount of asset supplied (down payment)\n    /// @param data LeverageExecutor data\n    /// @return amountOut Actual collateral amount purchased\n    function buyCollateral(address from, uint256 borrowAmount, uint256 supplyAmount, bytes calldata data)\n        external\n        optionNotPaused(PauseType.LeverageBuy)\n        solvent(from, false)\n        notSelf(from)\n        returns (uint256 amountOut)\n    {\n        if (address(leverageExecutor) == address(0)) {\n            revert LeverageExecutorNotValid();\n        }\n        // Stack too deep fix\n        _BuyCollateralCalldata memory calldata_;\n        {\n            calldata_.from = from;\n            calldata_.borrowAmount = borrowAmount;\n            calldata_.supplyAmount = supplyAmount;\n            calldata_.data = data;\n        }\n\n        // Let this fail first to save gas:\n        uint256 supplyShare = yieldBox.toShare(assetId, calldata_.supplyAmount, true);\n        uint256 supplyShareToAmount;\n        if (supplyShare > 0) {\n            (supplyShareToAmount,) =\n                yieldBox.withdraw(assetId, calldata_.from, address(leverageExecutor), 0, supplyShare);\n        }\n        (, uint256 borrowShare) = _borrow(calldata_.from, address(this), calldata_.borrowAmount);\n\n        (uint256 borrowShareToAmount,) =\n            yieldBox.withdraw(assetId, address(this), address(leverageExecutor), 0, borrowShare);\n        amountOut = leverageExecutor.getCollateral(\n            collateralId,\n            address(asset),\n            address(collateral),\n            supplyShareToAmount + borrowShareToAmount,\n            calldata_.from,\n            calldata_.data\n        );\n        uint256 collateralShare = yieldBox.toShare(collateralId, amountOut, false);\n        if (collateralShare == 0) revert CollateralShareNotValid();\n        address(asset).safeApprove(address(yieldBox), type(uint256).max);\n        yieldBox.depositAsset(collateralId, address(this), address(this), 0, collateralShare); // TODO Check for rounding attack?\n        address(asset).safeApprove(address(yieldBox), 0);\n\n        _allowedBorrow(calldata_.from, collateralShare);\n        _addCollateral(calldata_.from, calldata_.from, false, 0, collateralShare);\n    }\n\n    struct _SellCollateralCalldata {\n        address from;\n        uint256 share;\n        bytes data;\n    }\n\n    /// @notice Lever down: Sell collateral to repay debt; excess goes to YB\n    /// @param from The user who sells\n    /// @param share Collateral YieldBox-shares to sell\n    /// @param data LeverageExecutor data\n    /// @return amountOut Actual asset amount received in the sale\n    function sellCollateral(address from, uint256 share, bytes calldata data)\n        external\n        optionNotPaused(PauseType.LeverageSell)\n        solvent(from, false)\n        notSelf(from)\n        returns (uint256 amountOut)\n    {\n        if (address(leverageExecutor) == address(0)) {\n            revert LeverageExecutorNotValid();\n        }\n        // Stack too deep fix\n        _SellCollateralCalldata memory calldata_;\n        {\n            calldata_.from = from;\n            calldata_.share = share;\n            calldata_.data = data;\n        }\n\n        _allowedBorrow(calldata_.from, calldata_.share);\n        _removeCollateral(calldata_.from, address(this), calldata_.share);\n\n        yieldBox.withdraw(collateralId, address(this), address(leverageExecutor), 0, calldata_.share);\n        uint256 leverageAmount = yieldBox.toAmount(collateralId, calldata_.share, false);\n        amountOut = leverageExecutor.getAsset(\n            assetId, address(collateral), address(asset), leverageAmount, calldata_.from, calldata_.data\n        );\n        uint256 shareOut = yieldBox.toShare(assetId, amountOut, false);\n\n        address(asset).safeApprove(address(yieldBox), type(uint256).max);\n        yieldBox.depositAsset(assetId, address(this), address(this), 0, shareOut);\n        address(asset).safeApprove(address(yieldBox), 0);\n\n        uint256 partOwed = userBorrowPart[calldata_.from];\n        uint256 amountOwed = totalBorrow.toElastic(partOwed, true);\n        uint256 shareOwed = yieldBox.toShare(assetId, amountOwed, true);\n        if (shareOwed <= shareOut) {\n            _repay(calldata_.from, calldata_.from, false, partOwed);\n        } else {\n            //repay as much as we can\n            uint256 partOut = totalBorrow.toBase(amountOut, false);\n            _repay(calldata_.from, calldata_.from, false, partOut);\n        }\n    }\n}"
    }
  ]
}