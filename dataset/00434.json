{
  "Title": "M-15: Stargate Pools conversion rate leads to token accumulation inside the Balancer contract",
  "Content": "# Issue M-15: Stargate Pools conversion rate leads to token accumulation inside the Balancer contract \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/71 \n\n## Found by \nGiuseppeDeLaZara\n## Summary\nStargate pools conversion rate leads to token accumulation inside the `Balancer` contract and dangling allowances to the StargateRouter contract. This breaks the expected behavior of the rebalancing process and can result in a loss of tokens.\n\n## Vulnerability Detail\nStargate pools have a concept of convert rate. It's calculated based on the `sharedDecimals` and `localDecimals` for a specific pool. For example, the DAI Pool has the `sharedDecimals` set to 6 while `localDecimals` is 18.\n\nThe convert rate is then: `10^(localDecimals - sharedDecimals) = 10^12`.\n\nHere is the [DAI Pool](https://etherscan.io/address/0x0Faf1d2d3CED330824de3B8200fc8dc6E397850d#readContract) on Ethereum and the convert rate logic inside the [Pool contract](https://github.com/stargate-protocol/stargate/blob/5f0dfd2/contracts/Pool.sol#L140).\n\nDuring the rebalancing process:\n- the specified amount is extracted from the `mTOFT`\n- allowance is set for that amount to the StargateRouter contract\n- the rebalance amount is deducted \n- Stargate transfer is invoked.\n\nHowever, if the specified amount is not a multiple of the conversion rate, which in the case of DAI pool is `10^12`, the consequence is:\n\n- There will be an unspent allowance from Balancer to the StargateRouter contract.\n- The remaining amount of tokens will accumulate inside the Balancer contract.\n\nRepeatedly calling the `rebalance` function will leave more and more tokens inside the `Balancer` contract while leaving dangling allowances to the StargateRouter contract.\n\nIn case there is an issue upstream inside the StargateRouter contract it could result in a loss of tokens accumulated inside the Balancer contract. \n\n## Impact\nERC20 tokens will accumulate inside the Balancer contract with dangling allowances left to the StargateRouter contract. Under certain conditions, this can result in a loss of tokens.\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\nThe recommendation is to add a check for the conversion rate and adjust the amount to be rebalanced accordingly.\n\n```diff\n+\n+\n+interface IStargatePool {\n+    function convertRate() external view returns (uint256);\n+}\n+\n+interface IStargateFactory {\n+    function getPool(uint256 _poolId) external view returns (address);\n+}\n+\n contract Balancer is Ownable {\n     using SafeERC20 for IERC20;\n \n     IStargateRouter public immutable routerETH;\n     IStargateRouter public immutable router;\n+    IStargateFactory public immutable stargateFactory;\n \n-    constructor(address _routerETH, address _router, address _owner) {\n+    constructor(address _routerETH, address _router, address sgFactory, address _owner) {\n         if (_router == address(0)) revert RouterNotValid();\n         if (_routerETH == address(0)) revert RouterNotValid();\n         routerETH = IStargateRouter(_routerETH);\n         router = IStargateRouter(_router);\n+        stargateFactory = IStargateFactory(sgFactory);\n \n         transferOwnership(_owner);\n         rebalancer = _owner;\n@@ -179,8 +191,14 @@ contract Balancer is Ownable {\n             revert RebalanceAmountNotSet();\n         }\n \n+        uint256 convertedAmount = _amount;\n+        uint256 srcPoolId = connectedOFTs[_srcOft][_dstChainId].srcPoolId;\n+        address stargatePool = stargateFactory.getPool(srcPoolId);\n+        uint256 convertRate = IStargatePool(stargatePool).convertRate();\n+        if (convertRate != 1) { convertedAmount = (_amount / convertRate) * convertRate; }\n+\n         //extract\n-        ITOFT(_srcOft).extractUnderlying(_amount);\n+        ITOFT(_srcOft).extractUnderlying(convertedAmount);\n \n             if (msg.value == 0) revert FeeAmountNotSet();\n             if (_isNative) {\n                 if (disableEth) revert SwapNotEnabled();\n-                _sendNative(_srcOft, _amount, _dstChainId, _slippage);\n+                _sendNative(_srcOft, convertedAmount, _dstChainId, _slippage);\n             } else {\n-                _sendToken(_srcOft, _amount, _dstChainId, _slippage, _ercData);\n+                _sendToken(_srcOft, convertedAmount, _dstChainId, _slippage, _ercData);\n             }\n \n-            connectedOFTs[_srcOft][_dstChainId].rebalanceable -= _amount;\n-            emit Rebalanced(_srcOft, _dstChainId, _slippage, _amount, _isNative);\n+            connectedOFTs[_srcOft][_dstChainId].rebalanceable -= convertedAmount;\n+            emit Rebalanced(_srcOft, _dstChainId, _slippage, convertedAmount, _isNative);\n         }\n     }\n\n```\n\n\n\n## Discussion\n\n**cryptotechmaker**\n\nI think the proposed solution is wrong.\n\n**cryptotechmaker**\n\nDid a fix here https://github.com/Tapioca-DAO/TapiocaZ/pull/176; https://github.com/Tapioca-DAO/tapioca-periph/pull/199\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Tapioca-DAO/TapiocaZ/pull/176; https://github.com/Tapioca-DAO/tapioca-periph/pull/199.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "contracts/Pool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\n// imports\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./LPTokenERC20.sol\";\nimport \"./interfaces/IStargateFeeLibrary.sol\";\n\n// libraries\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n/// Pool contracts on other chains and managed by the Stargate protocol.\ncontract Pool is LPTokenERC20, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    //---------------------------------------------------------------------------\n    // CONSTANTS\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n    uint256 public constant BP_DENOMINATOR = 10000;\n\n    //---------------------------------------------------------------------------\n    // STRUCTS\n    struct ChainPath {\n        bool ready; // indicate if the counter chainPath has been created.\n        uint16 dstChainId;\n        uint256 dstPoolId;\n        uint256 weight;\n        uint256 balance;\n        uint256 lkb;\n        uint256 credits;\n        uint256 idealBalance;\n    }\n\n    struct SwapObj {\n        uint256 amount;\n        uint256 eqFee;\n        uint256 eqReward;\n        uint256 lpFee;\n        uint256 protocolFee;\n        uint256 lkbRemove;\n    }\n\n    struct CreditObj {\n        uint256 credits;\n        uint256 idealBalance;\n    }\n\n    //---------------------------------------------------------------------------\n    // VARIABLES\n\n    // chainPath\n    ChainPath[] public chainPaths; // list of connected chains with shared pools\n    mapping(uint16 => mapping(uint256 => uint256)) public chainPathIndexLookup; // lookup for chainPath by chainId => poolId =>index\n\n    // metadata\n    uint256 public immutable poolId; // shared id between chains to represent same pool\n    uint256 public sharedDecimals; // the shared decimals (lowest common decimals between chains)\n    uint256 public localDecimals; // the decimals for the token\n    uint256 public immutable convertRate; // the decimals for the token\n    address public immutable token; // the token for the pool\n    address public immutable router; // the token for the pool\n\n    bool public stopSwap; // flag to stop swapping in extreme cases\n\n    // Fee and Liquidity\n    uint256 public totalLiquidity; // the total amount of tokens added on this side of the chain (fees + deposits - withdrawals)\n    uint256 public totalWeight; // total weight for pool percentages\n    uint256 public mintFeeBP; // fee basis points for the mint/deposit\n    uint256 public protocolFeeBalance; // fee balance created from dao fee\n    uint256 public mintFeeBalance; // fee balance created from mint fee\n    uint256 public eqFeePool; // pool rewards in Shared Decimal format. indicate the total budget for reverse swap incentive\n    address public feeLibrary; // address for retrieving fee params for swaps\n\n    // Delta related\n    uint256 public deltaCredit; // credits accumulated from txn\n    bool public batched; // flag to indicate if we want batch processing.\n    bool public defaultSwapMode; // flag for the default mode for swap\n    bool public defaultLPMode; // flag for the default mode for lp\n    uint256 public swapDeltaBP; // basis points of poolCredits to activate Delta in swap\n    uint256 public lpDeltaBP; // basis points of poolCredits to activate Delta in liquidity events\n\n    //---------------------------------------------------------------------------\n    // EVENTS\n    event Mint(address to, uint256 amountLP, uint256 amountSD, uint256 mintFeeAmountSD);\n    event Burn(address from, uint256 amountLP, uint256 amountSD);\n    event RedeemLocalCallback(address _to, uint256 _amountSD, uint256 _amountToMintSD);\n    event Swap(\n        uint16 chainId,\n        uint256 dstPoolId,\n        address from,\n        uint256 amountSD,\n        uint256 eqReward,\n        uint256 eqFee,\n        uint256 protocolFee,\n        uint256 lpFee\n    );\n    event SendCredits(uint16 dstChainId, uint256 dstPoolId, uint256 credits, uint256 idealBalance);\n    event RedeemRemote(uint16 chainId, uint256 dstPoolId, address from, uint256 amountLP, uint256 amountSD);\n    event RedeemLocal(address from, uint256 amountLP, uint256 amountSD, uint16 chainId, uint256 dstPoolId, bytes to);\n    event InstantRedeemLocal(address from, uint256 amountLP, uint256 amountSD, address to);\n    event CreditChainPath(uint16 chainId, uint256 srcPoolId, uint256 amountSD, uint256 idealBalance);\n    event SwapRemote(address to, uint256 amountSD, uint256 protocolFee, uint256 dstFee);\n    event WithdrawRemote(uint16 srcChainId, uint256 srcPoolId, uint256 swapAmount, uint256 mintAmount);\n    event ChainPathUpdate(uint16 dstChainId, uint256 dstPoolId, uint256 weight);\n    event FeesUpdated(uint256 mintFeeBP);\n    event FeeLibraryUpdated(address feeLibraryAddr);\n    event StopSwapUpdated(bool swapStop);\n    event WithdrawProtocolFeeBalance(address to, uint256 amountSD);\n    event WithdrawMintFeeBalance(address to, uint256 amountSD);\n    event DeltaParamUpdated(bool batched, uint256 swapDeltaBP, uint256 lpDeltaBP, bool defaultSwapMode, bool defaultLPMode);\n\n    //---------------------------------------------------------------------------\n    // MODIFIERS\n    modifier onlyRouter() {\n        require(msg.sender == router, \"Stargate: only the router can call this method\");\n        _;\n    }\n\n    constructor(\n        uint256 _poolId,\n        address _router,\n        address _token,\n        uint256 _sharedDecimals,\n        uint256 _localDecimals,\n        address _feeLibrary,\n        string memory _name,\n        string memory _symbol\n    ) LPTokenERC20(_name, _symbol) {\n        require(_token != address(0x0), \"Stargate: _token cannot be 0x0\");\n        require(_router != address(0x0), \"Stargate: _router cannot be 0x0\");\n        poolId = _poolId;\n        router = _router;\n        token = _token;\n        sharedDecimals = _sharedDecimals;\n        decimals = uint8(_sharedDecimals);\n        localDecimals = _localDecimals;\n        convertRate = 10**(uint256(localDecimals).sub(sharedDecimals));\n        totalWeight = 0;\n        feeLibrary = _feeLibrary;\n\n        //delta algo related\n        batched = false;\n        defaultSwapMode = true;\n        defaultLPMode = true;\n    }\n\n    function getChainPathsLength() public view returns (uint256) {\n        return chainPaths.length;\n    }\n\n    //---------------------------------------------------------------------------\n    // LOCAL CHAIN FUNCTIONS\n\n    function mint(address _to, uint256 _amountLD) external nonReentrant onlyRouter returns (uint256) {\n        return _mintLocal(_to, _amountLD, true, true);\n    }\n\n    // Local                                    Remote\n    // -------                                  ---------\n    // swap             ->                      swapRemote\n    function swap(\n        uint16 _dstChainId,\n        uint256 _dstPoolId,\n        address _from,\n        uint256 _amountLD,\n        uint256 _minAmountLD,\n        bool newLiquidity\n    ) external nonReentrant onlyRouter returns (SwapObj memory) {\n        require(!stopSwap, \"Stargate: swap func stopped\");\n        ChainPath storage cp = getAndCheckCP(_dstChainId, _dstPoolId);\n        require(cp.ready == true, \"Stargate: counter chainPath is not ready\");\n\n        uint256 amountSD = amountLDtoSD(_amountLD);\n        uint256 minAmountSD = amountLDtoSD(_minAmountLD);\n\n        // request fee params from library\n        SwapObj memory s = IStargateFeeLibrary(feeLibrary).getFees(poolId, _dstPoolId, _dstChainId, _from, amountSD);\n\n        // equilibrium fee and reward. note eqFee/eqReward are separated from swap liquidity\n        eqFeePool = eqFeePool.sub(s.eqReward);\n        // update the new amount the user gets minus the fees\n        s.amount = amountSD.sub(s.eqFee).sub(s.protocolFee).sub(s.lpFee);\n        // users will also get the eqReward\n        require(s.amount.add(s.eqReward) >= minAmountSD, \"Stargate: slippage too high\");\n\n        // behaviours\n        //     - protocolFee: booked, stayed and withdrawn at remote.\n        //     - eqFee: booked, stayed and withdrawn at remote.\n        //     - lpFee: booked and stayed at remote, can be withdrawn anywhere\n\n        s.lkbRemove = amountSD.sub(s.lpFee).add(s.eqReward);\n        // check for transfer solvency.\n        require(cp.balance >= s.lkbRemove, \"Stargate: dst balance too low\");\n        cp.balance = cp.balance.sub(s.lkbRemove);\n\n        if (newLiquidity) {\n            deltaCredit = deltaCredit.add(amountSD).add(s.eqReward);\n        } else if (s.eqReward > 0) {\n            deltaCredit = deltaCredit.add(s.eqReward);\n        }\n\n        // distribute credits on condition.\n        if (!batched || deltaCredit >= totalLiquidity.mul(swapDeltaBP).div(BP_DENOMINATOR)) {\n            _delta(defaultSwapMode);\n        }\n\n        emit Swap(_dstChainId, _dstPoolId, _from, s.amount, s.eqReward, s.eqFee, s.protocolFee, s.lpFee);\n        return s;\n    }\n\n    // Local                                    Remote\n    // -------                                  ---------\n    // sendCredits      ->                      creditChainPath\n    function sendCredits(uint16 _dstChainId, uint256 _dstPoolId) external nonReentrant onlyRouter returns (CreditObj memory c) {\n        ChainPath storage cp = getAndCheckCP(_dstChainId, _dstPoolId);\n        require(cp.ready == true, \"Stargate: counter chainPath is not ready\");\n        cp.lkb = cp.lkb.add(cp.credits);\n        c.idealBalance = totalLiquidity.mul(cp.weight).div(totalWeight);\n        c.credits = cp.credits;\n        cp.credits = 0;\n        emit SendCredits(_dstChainId, _dstPoolId, c.credits, c.idealBalance);\n    }\n\n    // Local                                    Remote\n    // -------                                  ---------\n    // redeemRemote   ->                        swapRemote\n    function redeemRemote(\n        uint16 _dstChainId,\n        uint256 _dstPoolId,\n        address _from,\n        uint256 _amountLP\n    ) external nonReentrant onlyRouter {\n        require(_from != address(0x0), \"Stargate: _from cannot be 0x0\");\n        uint256 amountSD = _burnLocal(_from, _amountLP);\n        //run Delta\n        if (!batched || deltaCredit > totalLiquidity.mul(lpDeltaBP).div(BP_DENOMINATOR)) {\n            _delta(defaultLPMode);\n        }\n        uint256 amountLD = amountSDtoLD(amountSD);\n        emit RedeemRemote(_dstChainId, _dstPoolId, _from, _amountLP, amountLD);\n    }\n\n    function instantRedeemLocal(\n        address _from,\n        uint256 _amountLP,\n        address _to\n    ) external nonReentrant onlyRouter returns (uint256 amountSD) {\n        require(_from != address(0x0), \"Stargate: _from cannot be 0x0\");\n        uint256 _deltaCredit = deltaCredit; // sload optimization.\n        uint256 _capAmountLP = _amountSDtoLP(_deltaCredit);\n\n        if (_amountLP > _capAmountLP) _amountLP = _capAmountLP;\n\n        amountSD = _burnLocal(_from, _amountLP);\n        deltaCredit = _deltaCredit.sub(amountSD);\n        uint256 amountLD = amountSDtoLD(amountSD);\n        _safeTransfer(token, _to, amountLD);\n        emit InstantRedeemLocal(_from, _amountLP, amountSD, _to);\n    }\n\n    // Local                                    Remote\n    // -------                                  ---------\n    // redeemLocal   ->                         redeemLocalCheckOnRemote\n    // redeemLocalCallback             <-\n    function redeemLocal(\n        address _from,\n        uint256 _amountLP,\n        uint16 _dstChainId,\n        uint256 _dstPoolId,\n        bytes calldata _to\n    ) external nonReentrant onlyRouter returns (uint256 amountSD) {\n        require(_from != address(0x0), \"Stargate: _from cannot be 0x0\");\n\n        // safeguard.\n        require(chainPaths[chainPathIndexLookup[_dstChainId][_dstPoolId]].ready == true, \"Stargate: counter chainPath is not ready\");\n        amountSD = _burnLocal(_from, _amountLP);\n\n        // run Delta\n        if (!batched || deltaCredit > totalLiquidity.mul(lpDeltaBP).div(BP_DENOMINATOR)) {\n            _delta(false);\n        }\n        emit RedeemLocal(_from, _amountLP, amountSD, _dstChainId, _dstPoolId, _to);\n    }\n\n    //---------------------------------------------------------------------------\n    // REMOTE CHAIN FUNCTIONS\n\n    // Local                                    Remote\n    // -------                                  ---------\n    // sendCredits      ->                      creditChainPath\n    function creditChainPath(\n        uint16 _dstChainId,\n        uint256 _dstPoolId,\n        CreditObj memory _c\n    ) external nonReentrant onlyRouter {\n        ChainPath storage cp = chainPaths[chainPathIndexLookup[_dstChainId][_dstPoolId]];\n        cp.balance = cp.balance.add(_c.credits);\n        if (cp.idealBalance != _c.idealBalance) {\n            cp.idealBalance = _c.idealBalance;\n        }\n        emit CreditChainPath(_dstChainId, _dstPoolId, _c.credits, _c.idealBalance);\n    }\n\n    // Local                                    Remote\n    // -------                                  ---------\n    // swap             ->                      swapRemote\n    function swapRemote(\n        uint16 _srcChainId,\n        uint256 _srcPoolId,\n        address _to,\n        SwapObj memory _s\n    ) external nonReentrant onlyRouter returns (uint256 amountLD) {\n        // booking lpFee\n        totalLiquidity = totalLiquidity.add(_s.lpFee);\n        // booking eqFee\n        eqFeePool = eqFeePool.add(_s.eqFee);\n        // booking stargateFee\n        protocolFeeBalance = protocolFeeBalance.add(_s.protocolFee);\n\n        // update LKB\n        uint256 chainPathIndex = chainPathIndexLookup[_srcChainId][_srcPoolId];\n        chainPaths[chainPathIndex].lkb = chainPaths[chainPathIndex].lkb.sub(_s.lkbRemove);\n\n        // user receives the amount + the srcReward\n        amountLD = amountSDtoLD(_s.amount.add(_s.eqReward));\n        _safeTransfer(token, _to, amountLD);\n        emit SwapRemote(_to, _s.amount.add(_s.eqReward), _s.protocolFee, _s.eqFee);\n    }\n\n    // Local                                    Remote\n    // -------                                  ---------\n    // redeemLocal   ->                         redeemLocalCheckOnRemote\n    // redeemLocalCallback             <-\n    function redeemLocalCallback(\n        uint16 _srcChainId,\n        uint256 _srcPoolId,\n        address _to,\n        uint256 _amountSD,\n        uint256 _amountToMintSD\n    ) external nonReentrant onlyRouter {\n        if (_amountToMintSD > 0) {\n            _mintLocal(_to, amountSDtoLD(_amountToMintSD), false, false);\n        }\n\n        ChainPath storage cp = getAndCheckCP(_srcChainId, _srcPoolId);\n        cp.lkb = cp.lkb.sub(_amountSD);\n\n        uint256 amountLD = amountSDtoLD(_amountSD);\n        _safeTransfer(token, _to, amountLD);\n        emit RedeemLocalCallback(_to, _amountSD, _amountToMintSD);\n    }\n\n    // Local                                    Remote\n    // -------                                  ---------\n    // redeemLocal(amount)   ->               redeemLocalCheckOnRemote\n    // redeemLocalCallback             <-\n    function redeemLocalCheckOnRemote(\n        uint16 _srcChainId,\n        uint256 _srcPoolId,\n        uint256 _amountSD\n    ) external nonReentrant onlyRouter returns (uint256 swapAmount, uint256 mintAmount) {\n        ChainPath storage cp = getAndCheckCP(_srcChainId, _srcPoolId);\n        if (_amountSD > cp.balance) {\n            mintAmount = _amountSD - cp.balance;\n            swapAmount = cp.balance;\n            cp.balance = 0;\n        } else {\n            cp.balance = cp.balance.sub(_amountSD);\n            swapAmount = _amountSD;\n            mintAmount = 0;\n        }\n        emit WithdrawRemote(_srcChainId, _srcPoolId, swapAmount, mintAmount);\n    }\n\n    //---------------------------------------------------------------------------\n    // DAO Calls\n    function createChainPath(\n        uint16 _dstChainId,\n        uint256 _dstPoolId,\n        uint256 _weight\n    ) external onlyRouter {\n        for (uint256 i = 0; i < chainPaths.length; ++i) {\n            ChainPath memory cp = chainPaths[i];\n            bool exists = cp.dstChainId == _dstChainId && cp.dstPoolId == _dstPoolId;\n            require(!exists, \"Stargate: cant createChainPath of existing dstChainId and _dstPoolId\");\n        }\n        totalWeight = totalWeight.add(_weight);\n        chainPathIndexLookup[_dstChainId][_dstPoolId] = chainPaths.length;\n        chainPaths.push(ChainPath(false, _dstChainId, _dstPoolId, _weight, 0, 0, 0, 0));\n        emit ChainPathUpdate(_dstChainId, _dstPoolId, _weight);\n    }\n\n    function setWeightForChainPath(\n        uint16 _dstChainId,\n        uint256 _dstPoolId,\n        uint16 _weight\n    ) external onlyRouter {\n        ChainPath storage cp = getAndCheckCP(_dstChainId, _dstPoolId);\n        totalWeight = totalWeight.sub(cp.weight).add(_weight);\n        cp.weight = _weight;\n        emit ChainPathUpdate(_dstChainId, _dstPoolId, _weight);\n    }\n\n    function setFee(uint256 _mintFeeBP) external onlyRouter {\n        require(_mintFeeBP <= BP_DENOMINATOR, \"Bridge: cum fees > 100%\");\n        mintFeeBP = _mintFeeBP;\n        emit FeesUpdated(mintFeeBP);\n    }\n\n    function setFeeLibrary(address _feeLibraryAddr) external onlyRouter {\n        require(_feeLibraryAddr != address(0x0), \"Stargate: fee library cant be 0x0\");\n        feeLibrary = _feeLibraryAddr;\n        emit FeeLibraryUpdated(_feeLibraryAddr);\n    }\n\n    function setSwapStop(bool _swapStop) external onlyRouter {\n        stopSwap = _swapStop;\n        emit StopSwapUpdated(_swapStop);\n    }\n\n    function setDeltaParam(\n        bool _batched,\n        uint256 _swapDeltaBP,\n        uint256 _lpDeltaBP,\n        bool _defaultSwapMode,\n        bool _defaultLPMode\n    ) external onlyRouter {\n        require(_swapDeltaBP <= BP_DENOMINATOR && _lpDeltaBP <= BP_DENOMINATOR, \"Stargate: wrong Delta param\");\n        batched = _batched;\n        swapDeltaBP = _swapDeltaBP;\n        lpDeltaBP = _lpDeltaBP;\n        defaultSwapMode = _defaultSwapMode;\n        defaultLPMode = _defaultLPMode;\n        emit DeltaParamUpdated(_batched, _swapDeltaBP, _lpDeltaBP, _defaultSwapMode, _defaultLPMode);\n    }\n\n    function callDelta(bool _fullMode) external onlyRouter {\n        _delta(_fullMode);\n    }\n\n    function activateChainPath(uint16 _dstChainId, uint256 _dstPoolId) external onlyRouter {\n        ChainPath storage cp = getAndCheckCP(_dstChainId, _dstPoolId);\n        require(cp.ready == false, \"Stargate: chainPath is already active\");\n        // this func will only be called once\n        cp.ready = true;\n    }\n\n    function withdrawProtocolFeeBalance(address _to) external onlyRouter {\n        if (protocolFeeBalance > 0) {\n            uint256 amountOfLD = amountSDtoLD(protocolFeeBalance);\n            protocolFeeBalance = 0;\n            _safeTransfer(token, _to, amountOfLD);\n            emit WithdrawProtocolFeeBalance(_to, amountOfLD);\n        }\n    }\n\n    function withdrawMintFeeBalance(address _to) external onlyRouter {\n        if (mintFeeBalance > 0) {\n            uint256 amountOfLD = amountSDtoLD(mintFeeBalance);\n            mintFeeBalance = 0;\n            _safeTransfer(token, _to, amountOfLD);\n            emit WithdrawMintFeeBalance(_to, amountOfLD);\n        }\n    }\n\n    //---------------------------------------------------------------------------\n    // INTERNAL\n    // Conversion Helpers\n    //---------------------------------------------------------------------------\n    function amountLPtoLD(uint256 _amountLP) external view returns (uint256) {\n        return amountSDtoLD(_amountLPtoSD(_amountLP));\n    }\n\n    function _amountLPtoSD(uint256 _amountLP) internal view returns (uint256) {\n        require(totalSupply > 0, \"Stargate: cant convert LPtoSD when totalSupply == 0\");\n        return _amountLP.mul(totalLiquidity).div(totalSupply);\n    }\n\n    function _amountSDtoLP(uint256 _amountSD) internal view returns (uint256) {\n        require(totalLiquidity > 0, \"Stargate: cant convert SDtoLP when totalLiq == 0\");\n        return _amountSD.mul(totalSupply).div(totalLiquidity);\n    }\n\n    function amountSDtoLD(uint256 _amount) internal view returns (uint256) {\n        return _amount.mul(convertRate);\n    }\n\n    function amountLDtoSD(uint256 _amount) internal view returns (uint256) {\n        return _amount.div(convertRate);\n    }\n\n    function getAndCheckCP(uint16 _dstChainId, uint256 _dstPoolId) internal view returns (ChainPath storage) {\n        require(chainPaths.length > 0, \"Stargate: no chainpaths exist\");\n        ChainPath storage cp = chainPaths[chainPathIndexLookup[_dstChainId][_dstPoolId]];\n        require(cp.dstChainId == _dstChainId && cp.dstPoolId == _dstPoolId, \"Stargate: local chainPath does not exist\");\n        return cp;\n    }\n\n    function getChainPath(uint16 _dstChainId, uint256 _dstPoolId) external view returns (ChainPath memory) {\n        ChainPath memory cp = chainPaths[chainPathIndexLookup[_dstChainId][_dstPoolId]];\n        require(cp.dstChainId == _dstChainId && cp.dstPoolId == _dstPoolId, \"Stargate: local chainPath does not exist\");\n        return cp;\n    }\n\n    function _burnLocal(address _from, uint256 _amountLP) internal returns (uint256) {\n        require(totalSupply > 0, \"Stargate: cant burn when totalSupply == 0\");\n        uint256 amountOfLPTokens = balanceOf[_from];\n        require(amountOfLPTokens >= _amountLP, \"Stargate: not enough LP tokens to burn\");\n\n        uint256 amountSD = _amountLP.mul(totalLiquidity).div(totalSupply);\n        //subtract totalLiquidity accordingly\n        totalLiquidity = totalLiquidity.sub(amountSD);\n\n        _burn(_from, _amountLP);\n        emit Burn(_from, _amountLP, amountSD);\n        return amountSD;\n    }\n\n    function _delta(bool fullMode) internal {\n        if (deltaCredit > 0 && totalWeight > 0) {\n            uint256 cpLength = chainPaths.length;\n            uint256[] memory deficit = new uint256[](cpLength);\n            uint256 totalDeficit = 0;\n\n            // algorithm steps 6-9: calculate the total and the amounts required to get to balance state\n            for (uint256 i = 0; i < cpLength; ++i) {\n                ChainPath storage cp = chainPaths[i];\n                // (liquidity * (weight/totalWeight)) - (lkb+credits)\n                uint256 balLiq = totalLiquidity.mul(cp.weight).div(totalWeight);\n                uint256 currLiq = cp.lkb.add(cp.credits);\n                if (balLiq > currLiq) {\n                    // save gas since we know balLiq > currLiq and we know deficit[i] > 0\n                    deficit[i] = balLiq - currLiq;\n                    totalDeficit = totalDeficit.add(deficit[i]);\n                }\n            }\n\n            // indicates how much delta credit is distributed\n            uint256 spent;\n\n            // handle credits with 2 tranches. the [ < totalDeficit] [excessCredit]\n            // run full Delta, allocate all credits\n            if (totalDeficit == 0) {\n                // only fullMode delta will allocate excess credits\n                if (fullMode && deltaCredit > 0) {\n                    // credit ChainPath by weights\n                    for (uint256 i = 0; i < cpLength; ++i) {\n                        ChainPath storage cp = chainPaths[i];\n                        // credits = credits + toBalanceChange + remaining allocation based on weight\n                        uint256 amtToCredit = deltaCredit.mul(cp.weight).div(totalWeight);\n                        spent = spent.add(amtToCredit);\n                        cp.credits = cp.credits.add(amtToCredit);\n                    }\n                } // else do nth\n            } else if (totalDeficit <= deltaCredit) {\n                if (fullMode) {\n                    // algorithm step 13: calculate amount to disperse to bring to balance state or as close as possible\n                    uint256 excessCredit = deltaCredit - totalDeficit;\n                    // algorithm steps 14-16: calculate credits\n                    for (uint256 i = 0; i < cpLength; ++i) {\n                        if (deficit[i] > 0) {\n                            ChainPath storage cp = chainPaths[i];\n                            // credits = credits + deficit + remaining allocation based on weight\n                            uint256 amtToCredit = deficit[i].add(excessCredit.mul(cp.weight).div(totalWeight));\n                            spent = spent.add(amtToCredit);\n                            cp.credits = cp.credits.add(amtToCredit);\n                        }\n                    }\n                } else {\n                    // totalDeficit <= deltaCredit but not running fullMode\n                    // credit chainPaths as is if any deficit, not using all deltaCredit\n                    for (uint256 i = 0; i < cpLength; ++i) {\n                        if (deficit[i] > 0) {\n                            ChainPath storage cp = chainPaths[i];\n                            uint256 amtToCredit = deficit[i];\n                            spent = spent.add(amtToCredit);\n                            cp.credits = cp.credits.add(amtToCredit);\n                        }\n                    }\n                }\n            } else {\n                // totalDeficit > deltaCredit, fullMode or not, normalize the deficit by deltaCredit\n                for (uint256 i = 0; i < cpLength; ++i) {\n                    if (deficit[i] > 0) {\n                        ChainPath storage cp = chainPaths[i];\n                        uint256 proportionalDeficit = deficit[i].mul(deltaCredit).div(totalDeficit);\n                        spent = spent.add(proportionalDeficit);\n                        cp.credits = cp.credits.add(proportionalDeficit);\n                    }\n                }\n            }\n\n            // deduct the amount of credit sent\n            deltaCredit = deltaCredit.sub(spent);\n        }\n    }\n\n    function _mintLocal(\n        address _to,\n        uint256 _amountLD,\n        bool _feesEnabled,\n        bool _creditDelta\n    ) internal returns (uint256 amountSD) {\n        require(totalWeight > 0, \"Stargate: No ChainPaths exist\");\n        amountSD = amountLDtoSD(_amountLD);\n\n        uint256 mintFeeSD = 0;\n        if (_feesEnabled) {\n            mintFeeSD = amountSD.mul(mintFeeBP).div(BP_DENOMINATOR);\n            amountSD = amountSD.sub(mintFeeSD);\n            mintFeeBalance = mintFeeBalance.add(mintFeeSD);\n        }\n\n        if (_creditDelta) {\n            deltaCredit = deltaCredit.add(amountSD);\n        }\n\n        uint256 amountLPTokens = amountSD;\n        if (totalSupply != 0) {\n            amountLPTokens = amountSD.mul(totalSupply).div(totalLiquidity);\n        }\n        totalLiquidity = totalLiquidity.add(amountSD);\n\n        _mint(_to, amountLPTokens);\n        emit Mint(_to, amountLPTokens, amountSD, mintFeeSD);\n\n        // add to credits and call delta. short circuit to save gas\n        if (!batched || deltaCredit > totalLiquidity.mul(lpDeltaBP).div(BP_DENOMINATOR)) {\n            _delta(defaultLPMode);\n        }\n    }\n\n    function _safeTransfer(\n        address _token,\n        address _to,\n        uint256 _value\n    ) private {\n        (bool success, bytes memory data) = _token.call(abi.encodeWithSelector(SELECTOR, _to, _value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"Stargate: TRANSFER_FAILED\");\n    }\n}"
    }
  ]
}