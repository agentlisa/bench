{
  "Title": "[N-02] Avoid naming mappings with `get` in the beginning",
  "Content": "\nMapping names starting with \"get\" can be misleading since \"get\" is usually used for getters that do not make any state changes and only read state. Thus, if we have a statement like `getTokenBalance[chainId] += amount;`, it can be potentially misleading since we make state changes to a mapping which seems like a getter on first sight.\n\n*There are 2 instances of this issue*.\n\n*Note: Most bridgeAgent and Port contracts have this issue as well but I have not mentioned them here explicitly:*\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/token/ERC20hTokenRoot.sol#L58\n\n```solidity\nFile: src/token/ERC20hTokenRoot.sol\n58:    getTokenBalance[chainId] += amount;\n```\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/token/ERC20hTokenRoot.sol#L70\n\n```solidity\nFile: src/token/ERC20hTokenRoot.sol\n58:    getTokenBalance[chainId] -= amount;\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-09-maia",
  "Code": [
    {
      "filename": "src/token/ERC20hTokenRoot.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IERC20hTokenRoot} from \"../interfaces/IERC20hTokenRoot.sol\";\n\n/// @title ERC20 hToken Contract\n/// @author MaiaDAO\ncontract ERC20hTokenRoot is ERC20, Ownable, IERC20hTokenRoot {\n    /// @inheritdoc IERC20hTokenRoot\n    uint16 public immutable override localChainId;\n\n    /// @inheritdoc IERC20hTokenRoot\n    address public immutable override factoryAddress;\n\n    /// @inheritdoc IERC20hTokenRoot\n    mapping(uint256 chainId => uint256 balance) public override getTokenBalance;\n\n    /**\n     * @notice Constructor for the ERC20hTokenRoot Contract.\n     *     @param _localChainId Local Network Identifier.\n     *     @param _factoryAddress Address of the Factory Contract.\n     *     @param _rootPortAddress Address of the Root Port Contract.\n     *     @param _name Name of the Token.\n     *     @param _symbol Symbol of the Token.\n     *     @param _decimals Decimals of the Token.\n     */\n    constructor(\n        uint16 _localChainId,\n        address _factoryAddress,\n        address _rootPortAddress,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) ERC20(string(string.concat(_name)), string(string.concat(_symbol)), _decimals) {\n        require(_rootPortAddress != address(0), \"Root Port Address cannot be 0\");\n        require(_factoryAddress != address(0), \"Factory Address cannot be 0\");\n\n        localChainId = _localChainId;\n        factoryAddress = _factoryAddress;\n        _initializeOwner(_rootPortAddress);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Mints new tokens and updates the total supply for the given chain.\n     * @param to Address to mint tokens to.\n     * @param amount Amount of tokens to mint.\n     * @param chainId Chain Id of the chain to mint tokens to.\n     */\n    function mint(address to, uint256 amount, uint256 chainId) external onlyOwner returns (bool) {\n        getTokenBalance[chainId] += amount;\n        _mint(to, amount);\n        return true;\n    }\n\n    /**\n     * @notice Burns new tokens and updates the total supply for the given chain.\n     * @param from Address to burn tokens from.\n     * @param amount Amount of tokens to burn.\n     * @param chainId Chain Id of the chain to burn tokens to.\n     */\n    function burn(address from, uint256 amount, uint256 chainId) external onlyOwner {\n        getTokenBalance[chainId] -= amount;\n        _burn(from, amount);\n    }\n}"
    },
    {
      "filename": "src/token/ERC20hTokenRoot.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IERC20hTokenRoot} from \"../interfaces/IERC20hTokenRoot.sol\";\n\n/// @title ERC20 hToken Contract\n/// @author MaiaDAO\ncontract ERC20hTokenRoot is ERC20, Ownable, IERC20hTokenRoot {\n    /// @inheritdoc IERC20hTokenRoot\n    uint16 public immutable override localChainId;\n\n    /// @inheritdoc IERC20hTokenRoot\n    address public immutable override factoryAddress;\n\n    /// @inheritdoc IERC20hTokenRoot\n    mapping(uint256 chainId => uint256 balance) public override getTokenBalance;\n\n    /**\n     * @notice Constructor for the ERC20hTokenRoot Contract.\n     *     @param _localChainId Local Network Identifier.\n     *     @param _factoryAddress Address of the Factory Contract.\n     *     @param _rootPortAddress Address of the Root Port Contract.\n     *     @param _name Name of the Token.\n     *     @param _symbol Symbol of the Token.\n     *     @param _decimals Decimals of the Token.\n     */\n    constructor(\n        uint16 _localChainId,\n        address _factoryAddress,\n        address _rootPortAddress,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) ERC20(string(string.concat(_name)), string(string.concat(_symbol)), _decimals) {\n        require(_rootPortAddress != address(0), \"Root Port Address cannot be 0\");\n        require(_factoryAddress != address(0), \"Factory Address cannot be 0\");\n\n        localChainId = _localChainId;\n        factoryAddress = _factoryAddress;\n        _initializeOwner(_rootPortAddress);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Mints new tokens and updates the total supply for the given chain.\n     * @param to Address to mint tokens to.\n     * @param amount Amount of tokens to mint.\n     * @param chainId Chain Id of the chain to mint tokens to.\n     */\n    function mint(address to, uint256 amount, uint256 chainId) external onlyOwner returns (bool) {\n        getTokenBalance[chainId] += amount;\n        _mint(to, amount);\n        return true;\n    }\n\n    /**\n     * @notice Burns new tokens and updates the total supply for the given chain.\n     * @param from Address to burn tokens from.\n     * @param amount Amount of tokens to burn.\n     * @param chainId Chain Id of the chain to burn tokens to.\n     */\n    function burn(address from, uint256 amount, uint256 chainId) external onlyOwner {\n        getTokenBalance[chainId] -= amount;\n        _burn(from, amount);\n    }\n}"
    }
  ]
}