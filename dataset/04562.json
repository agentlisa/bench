{
  "Title": "Unchecked assumption that trustee and token have the sameÂ owner",
  "Content": "In the[`reclaimTokens`](https://github.com/OpenSTFoundation/SimpleTokenSale/blob/1a1e863441ba0149d7585203f5dbc6e800af00cf/contracts/Trustee.sol#L198) function, there is a token transfer to the `trustee`contract owner, but according to [the comment above](https://github.com/OpenSTFoundation/SimpleTokenSale/blob/1a1e863441ba0149d7585203f5dbc6e800af00cf/contracts/Trustee.sol#L197) it should be transferred to the `tokenContract` owner: *Note that the trustee should be able to move tokens even before the token is finalised because SimpleToken allows sending back to owner specifically.* This statement is only true if the token contract owner is the same as trustee owner, but this precondition is not enforced anywhere.\n\n\nWe recommend replacing `owner` with `tokenContract.owner` [in line 206](https://github.com/OpenSTFoundation/SimpleTokenSale/blob/1a1e863441ba0149d7585203f5dbc6e800af00cf/contracts/Trustee.sol#L206) to specify the transfer target precisely.\n\n\n**Update**: *Fixed in [this](https://github.com/OpenSTFoundation/SimpleTokenSale/commit/dab5d0488bd08b7206813f7c8be5d97191e79bae) commit improving both the [TokenSale](https://github.com/OpenSTFoundation/SimpleTokenSale/commit/dab5d0488bd08b7206813f7c8be5d97191e79bae#diff-2433a0604f99868d5cc0b4064df7ae93R438) and [Trustee](https://github.com/OpenSTFoundation/SimpleTokenSale/commit/dab5d0488bd08b7206813f7c8be5d97191e79bae#diff-ecf32016a92b8b06ac2a5eb583cc4ad1R201)contracts.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Trustee.sol",
      "content": "pragma solidity ^0.4.17;\n\n// ----------------------------------------------------------------------------\n// Simple Token - Token Trustee Implementation\n//\n// Copyright (c) 2017 Simple Token and Enuma Technologies.\n// http://www.simpletoken.com/\n//\n// The MIT Licence.\n// ----------------------------------------------------------------------------\n\n\nimport './SimpleToken.sol';\nimport './OpsManaged.sol';\n\nimport './SafeMath.sol';\n\n\n//\n// Implements a simple trustee which can release tokens based on\n// an explicit call from the owner.\n//\n\n//\n// Permissions, according to the ST key management specification.\n//\n//                                Owner    Admin   Ops   Revoke\n// grantAllocation                           x      x\n// revokeAllocation                                        x\n// processAllocation                                x\n// reclaimTokens                             x\n// setRevokeAddress                 x                      x\n//\n\ncontract Trustee is OpsManaged {\n\n    using SafeMath for uint256;\n\n\n    SimpleToken public tokenContract;\n\n    struct Allocation {\n        uint256 amountGranted;\n        uint256 amountTransferred;\n        bool    revokable;\n    }\n\n    // The trustee has a special 'revoke' key which is allowed to revoke allocations.\n    address public revokeAddress;\n\n    // Total number of tokens that are currently allocated.\n    // This does not include tokens that have been processed (sent to an address) already or\n    // the ones in the trustee's account that have not been allocated yet.\n    uint256 public totalLocked;\n\n    mapping (address => Allocation) public allocations;\n\n\n    //\n    // Events\n    //\n    event AllocationGranted(address indexed _from, address indexed _account, uint256 _amount, bool _revokable);\n    event AllocationRevoked(address indexed _from, address indexed _account, uint256 _amountRevoked);\n    event AllocationProcessed(address indexed _from, address indexed _account, uint256 _amount);\n    event RevokeAddressChanged(address indexed _newAddress);\n    event TokensReclaimed(uint256 _amount);\n\n\n    function Trustee(SimpleToken _tokenContract) public\n        OpsManaged()\n    {\n        require(address(_tokenContract) != address(0));\n\n        tokenContract = _tokenContract;\n    }\n\n\n    modifier onlyOwnerOrRevoke() {\n        require(isOwner(msg.sender) || isRevoke(msg.sender));\n        _;\n    }\n\n\n    modifier onlyRevoke() {\n        require(isRevoke(msg.sender));\n        _;\n    }\n\n\n    function isRevoke(address _address) private view returns (bool) {\n        return (revokeAddress != address(0) && _address == revokeAddress);\n    }\n\n\n    // Owner and revoke can change the revoke address. Address can also be set to 0 to 'disable' it.\n    function setRevokeAddress(address _revokeAddress) external onlyOwnerOrRevoke returns (bool) {\n        require(_revokeAddress != owner);\n        require(!isAdmin(_revokeAddress));\n        require(!isOps(_revokeAddress));\n\n        revokeAddress = _revokeAddress;\n\n        RevokeAddressChanged(_revokeAddress);\n\n        return true;\n    }\n\n\n    // Allows admin or ops to create new allocations for a specific account.\n    function grantAllocation(address _account, uint256 _amount, bool _revokable) public onlyAdminOrOps returns (bool) {\n        require(_account != address(0));\n        require(_account != address(this));\n        require(_amount > 0);\n\n        // Can't create an allocation if there is already one for this acount.\n        require(allocations[_account].amountGranted == 0);\n\n        if (isOps(msg.sender)) {\n            // Once the token contract is finalized, the ops key should not be able to grant allocations any longer.\n            // Before finalized, it is used by the TokenSale contract to allocate pre-sales.\n            require(!tokenContract.finalized());\n        }\n\n        totalLocked = totalLocked.add(_amount);\n        require(totalLocked <= tokenContract.balanceOf(address(this)));\n\n        allocations[_account] = Allocation({\n            amountGranted     : _amount,\n            amountTransferred : 0,\n            revokable         : _revokable\n        });\n\n        AllocationGranted(msg.sender, _account, _amount, _revokable);\n\n        return true;\n    }\n\n\n    // Allows the revoke key to revoke allocations, if revoke is allowed.\n    function revokeAllocation(address _account) external onlyRevoke returns (bool) {\n        require(_account != address(0));\n\n        Allocation memory allocation = allocations[_account];\n\n        require(allocation.revokable);\n\n        uint256 ownerRefund = allocation.amountGranted.sub(allocation.amountTransferred);\n\n        delete allocations[_account];\n\n        totalLocked = totalLocked.sub(ownerRefund);\n\n        AllocationRevoked(msg.sender, _account, ownerRefund);\n\n        return true;\n    }\n\n\n    // Push model which allows the owner to transfer tokens to the beneficiary.\n    // The exact amount to transfer is calculated by owner based on agreements with\n    // the beneficiaries. Here we only restrict that the total amount transfered cannot\n    // exceed what has been granted.\n    function processAllocation(address _account, uint256 _amount) external onlyOps returns (bool) {\n        require(_account != address(0));\n        require(_amount > 0);\n\n        if (!tokenContract.finalized()) {\n            // We don't allow ops to process allocations before the token contract has been finalized.\n            require(isOwner(msg.sender) || isAdmin(msg.sender));\n        }\n\n        Allocation storage allocation = allocations[_account];\n\n        require(allocation.amountGranted > 0);\n\n        uint256 transferable = allocation.amountGranted.sub(allocation.amountTransferred);\n\n        if (transferable < _amount) {\n            return false;\n        }\n\n        allocation.amountTransferred = allocation.amountTransferred.add(_amount);\n\n        // Note that transfer will fail if the token contract has not been finalized yet.\n        require(tokenContract.transfer(_account, _amount));\n\n        totalLocked = totalLocked.sub(_amount);\n\n        AllocationProcessed(msg.sender, _account, _amount);\n\n        return true;\n    }\n\n\n    // Allows the admin to claim back all tokens that are not currently allocated.\n    // Note that the trustee should be able to move tokens even before the token is\n    // finalized because SimpleToken allows sending back to owner specifically.\n    function reclaimTokens() external onlyAdmin returns (bool) {\n        uint256 ownBalance = tokenContract.balanceOf(address(this));\n\n        // If balance <= amount locked, there is nothing to reclaim.\n        require(ownBalance > totalLocked);\n\n        uint256 amountReclaimed = ownBalance.sub(totalLocked);\n\n        require(tokenContract.transfer(owner, amountReclaimed));\n\n        TokensReclaimed(amountReclaimed);\n\n        return true;\n    }\n}"
    },
    {
      "filename": "contracts/Trustee.sol",
      "content": "pragma solidity ^0.4.17;\n\n// ----------------------------------------------------------------------------\n// Simple Token - Token Trustee Implementation\n//\n// Copyright (c) 2017 Simple Token and Enuma Technologies.\n// http://www.simpletoken.com/\n//\n// The MIT Licence.\n// ----------------------------------------------------------------------------\n\n\nimport './SimpleToken.sol';\nimport './OpsManaged.sol';\n\nimport './SafeMath.sol';\n\n\n//\n// Implements a simple trustee which can release tokens based on\n// an explicit call from the owner.\n//\n\n//\n// Permissions, according to the ST key management specification.\n//\n//                                Owner    Admin   Ops   Revoke\n// grantAllocation                           x      x\n// revokeAllocation                                        x\n// processAllocation                                x\n// reclaimTokens                             x\n// setRevokeAddress                 x                      x\n//\n\ncontract Trustee is OpsManaged {\n\n    using SafeMath for uint256;\n\n\n    SimpleToken public tokenContract;\n\n    struct Allocation {\n        uint256 amountGranted;\n        uint256 amountTransferred;\n        bool    revokable;\n    }\n\n    // The trustee has a special 'revoke' key which is allowed to revoke allocations.\n    address public revokeAddress;\n\n    // Total number of tokens that are currently allocated.\n    // This does not include tokens that have been processed (sent to an address) already or\n    // the ones in the trustee's account that have not been allocated yet.\n    uint256 public totalLocked;\n\n    mapping (address => Allocation) public allocations;\n\n\n    //\n    // Events\n    //\n    event AllocationGranted(address indexed _from, address indexed _account, uint256 _amount, bool _revokable);\n    event AllocationRevoked(address indexed _from, address indexed _account, uint256 _amountRevoked);\n    event AllocationProcessed(address indexed _from, address indexed _account, uint256 _amount);\n    event RevokeAddressChanged(address indexed _newAddress);\n    event TokensReclaimed(uint256 _amount);\n\n\n    function Trustee(SimpleToken _tokenContract) public\n        OpsManaged()\n    {\n        require(address(_tokenContract) != address(0));\n\n        tokenContract = _tokenContract;\n    }\n\n\n    modifier onlyOwnerOrRevoke() {\n        require(isOwner(msg.sender) || isRevoke(msg.sender));\n        _;\n    }\n\n\n    modifier onlyRevoke() {\n        require(isRevoke(msg.sender));\n        _;\n    }\n\n\n    function isRevoke(address _address) private view returns (bool) {\n        return (revokeAddress != address(0) && _address == revokeAddress);\n    }\n\n\n    // Owner and revoke can change the revoke address. Address can also be set to 0 to 'disable' it.\n    function setRevokeAddress(address _revokeAddress) external onlyOwnerOrRevoke returns (bool) {\n        require(_revokeAddress != owner);\n        require(!isAdmin(_revokeAddress));\n        require(!isOps(_revokeAddress));\n\n        revokeAddress = _revokeAddress;\n\n        RevokeAddressChanged(_revokeAddress);\n\n        return true;\n    }\n\n\n    // Allows admin or ops to create new allocations for a specific account.\n    function grantAllocation(address _account, uint256 _amount, bool _revokable) public onlyAdminOrOps returns (bool) {\n        require(_account != address(0));\n        require(_account != address(this));\n        require(_amount > 0);\n\n        // Can't create an allocation if there is already one for this acount.\n        require(allocations[_account].amountGranted == 0);\n\n        if (isOps(msg.sender)) {\n            // Once the token contract is finalized, the ops key should not be able to grant allocations any longer.\n            // Before finalized, it is used by the TokenSale contract to allocate pre-sales.\n            require(!tokenContract.finalized());\n        }\n\n        totalLocked = totalLocked.add(_amount);\n        require(totalLocked <= tokenContract.balanceOf(address(this)));\n\n        allocations[_account] = Allocation({\n            amountGranted     : _amount,\n            amountTransferred : 0,\n            revokable         : _revokable\n        });\n\n        AllocationGranted(msg.sender, _account, _amount, _revokable);\n\n        return true;\n    }\n\n\n    // Allows the revoke key to revoke allocations, if revoke is allowed.\n    function revokeAllocation(address _account) external onlyRevoke returns (bool) {\n        require(_account != address(0));\n\n        Allocation memory allocation = allocations[_account];\n\n        require(allocation.revokable);\n\n        uint256 ownerRefund = allocation.amountGranted.sub(allocation.amountTransferred);\n\n        delete allocations[_account];\n\n        totalLocked = totalLocked.sub(ownerRefund);\n\n        AllocationRevoked(msg.sender, _account, ownerRefund);\n\n        return true;\n    }\n\n\n    // Push model which allows the owner to transfer tokens to the beneficiary.\n    // The exact amount to transfer is calculated by owner based on agreements with\n    // the beneficiaries. Here we only restrict that the total amount transfered cannot\n    // exceed what has been granted.\n    function processAllocation(address _account, uint256 _amount) external onlyOps returns (bool) {\n        require(_account != address(0));\n        require(_amount > 0);\n\n        if (!tokenContract.finalized()) {\n            // We don't allow ops to process allocations before the token contract has been finalized.\n            require(isOwner(msg.sender) || isAdmin(msg.sender));\n        }\n\n        Allocation storage allocation = allocations[_account];\n\n        require(allocation.amountGranted > 0);\n\n        uint256 transferable = allocation.amountGranted.sub(allocation.amountTransferred);\n\n        if (transferable < _amount) {\n            return false;\n        }\n\n        allocation.amountTransferred = allocation.amountTransferred.add(_amount);\n\n        // Note that transfer will fail if the token contract has not been finalized yet.\n        require(tokenContract.transfer(_account, _amount));\n\n        totalLocked = totalLocked.sub(_amount);\n\n        AllocationProcessed(msg.sender, _account, _amount);\n\n        return true;\n    }\n\n\n    // Allows the admin to claim back all tokens that are not currently allocated.\n    // Note that the trustee should be able to move tokens even before the token is\n    // finalized because SimpleToken allows sending back to owner specifically.\n    function reclaimTokens() external onlyAdmin returns (bool) {\n        uint256 ownBalance = tokenContract.balanceOf(address(this));\n\n        // If balance <= amount locked, there is nothing to reclaim.\n        require(ownBalance > totalLocked);\n\n        uint256 amountReclaimed = ownBalance.sub(totalLocked);\n\n        require(tokenContract.transfer(owner, amountReclaimed));\n\n        TokensReclaimed(amountReclaimed);\n\n        return true;\n    }\n}"
    }
  ]
}