{
  "Title": "[N-06] Variable names that consist of all capital letters should be reserved for `const`/`immutable` variables",
  "Content": "\nIf the variable needs to be different based on which class it comes from, a `view`/`pure` *function* should be used instead (e.g. like [this](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/76eee35971c2541585e05cbf258510dda7b2fbc6/contracts/token/ERC20/extensions/draft-IERC20Permit.sol#L59)).\n\n1.  File: src/ERC20Permit.sol (line [8](https://github.com/code-423n4/2022-04-axelar/blob/f1c8bfc16f82a27797f61cb3a310c0f936dce567/src/ERC20Permit.sol#L8))\n\n```solidity\n    bytes32 public DOMAIN_SEPARATOR;\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-04-axelar",
  "Code": [
    {
      "filename": "contracts/token/ERC20/extensions/draft-IERC20Permit.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}"
    },
    {
      "filename": "src/ERC20Permit.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { ERC20 } from './ERC20.sol';\n\nabstract contract ERC20Permit is ERC20 {\n    bytes32 public DOMAIN_SEPARATOR;\n\n    string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = '\\x19\\x01';\n\n    // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')\n    bytes32 private constant DOMAIN_TYPE_SIGNATURE_HASH =\n        bytes32(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f);\n\n    // keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)')\n    bytes32 private constant PERMIT_SIGNATURE_HASH =\n        bytes32(0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9);\n\n    mapping(address => uint256) public nonces;\n\n    constructor(string memory name) {\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                DOMAIN_TYPE_SIGNATURE_HASH,\n                keccak256(bytes(name)),\n                keccak256(bytes('1')),\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n\n    function permit(\n        address issuer,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(block.timestamp < deadline, 'EXPIRED');\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, 'INV_S');\n        require(v == 27 || v == 28, 'INV_V');\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA,\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_SIGNATURE_HASH, issuer, spender, value, nonces[issuer]++, deadline))\n            )\n        );\n\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress == issuer, 'INV_SIG');\n\n        // _approve will revert if issuer is address(0x0)\n        _approve(issuer, spender, value);\n    }\n}"
    }
  ]
}