{
  "Title": "Potentially Misleading Verifier Event",
  "Content": "The `MultipleVersionRollupVerifier` contract maps the batch index to the address of the verifier that was used. The owner of this contract can call the [`updateVerifier`](https://github.com/scroll-tech/scroll/blob/2eb458cf4224d82fc56254e91e297a9ed261cefb/contracts/src/L1/rollup/MultipleVersionRollupVerifier.sol#L103) function in order to update the verifier. For this update to succeed, it [requires that the provided `startBatchIndex` is greater than or equal to the previous verifier's `startBatchIndex`](https://github.com/scroll-tech/scroll/blob/2eb458cf4224d82fc56254e91e297a9ed261cefb/contracts/src/L1/rollup/MultipleVersionRollupVerifier.sol#L105).\n\n\nHowever, it does not check if that batch number has already been verified by the current verifier, which could be confusing. For example, if the current verifier's start index is 100, and it has verified batches up to batch 105, the new verifier could be set with a start index of 102. The [event emitted](https://github.com/scroll-tech/scroll/blob/2eb458cf4224d82fc56254e91e297a9ed261cefb/contracts/src/L1/rollup/MultipleVersionRollupVerifier.sol#L116) would contain the index of 102, which would be confusing because it would appear to a user monitoring the events as though the new verifier was used to verify the batches 102-105 when in reality it was not. This could even be used maliciously by the owner to hide information relating to a faulty verifier.\n\n\nConsider enforcing that the start index must be greater than the [`lastFinalizedBatchIndex`](https://github.com/scroll-tech/scroll/blob/2eb458cf4224d82fc56254e91e297a9ed261cefb/contracts/src/L1/rollup/ScrollChain.sol#L70).\n\n\n***Update:** Resolved in [pull request #849](https://github.com/scroll-tech/scroll/pull/849) at commit [6527331](https://github.com/scroll-tech/scroll/pull/849/commits/6527331f9ec01e536da328a91880dd16ce6b67e4).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/L1/rollup/MultipleVersionRollupVerifier.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.16;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {IRollupVerifier} from \"../../libraries/verifier/IRollupVerifier.sol\";\nimport {IZkEvmVerifier} from \"../../libraries/verifier/IZkEvmVerifier.sol\";\n\ncontract MultipleVersionRollupVerifier is IRollupVerifier, Ownable {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when the address of verifier is updated.\n    /// @param startBatchIndex The start batch index when the verifier will be used.\n    /// @param verifier The address of new verifier.\n    event UpdateVerifier(uint256 startBatchIndex, address verifier);\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct Verifier {\n        // The start batch index for the verifier.\n        uint64 startBatchIndex;\n        // The address of zkevm verifier.\n        address verifier;\n    }\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The list of legacy zkevm verifier, sorted by batchIndex in increasing order.\n    Verifier[] public legacyVerifiers;\n\n    /// @notice The lastest used zkevm verifier.\n    Verifier public latestVerifier;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(address _verifier) {\n        require(_verifier != address(0), \"zero verifier address\");\n\n        latestVerifier.verifier = _verifier;\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Return the number of legacy verifiers.\n    function legacyVerifiersLength() external view returns (uint256) {\n        return legacyVerifiers.length;\n    }\n\n    /// @notice Compute the verifier should be used for specific batch.\n    /// @param _batchIndex The batch index to query.\n    function getVerifier(uint256 _batchIndex) public view returns (address) {\n        // Normally, we will use the latest verifier.\n        Verifier memory _verifier = latestVerifier;\n\n        if (_verifier.startBatchIndex > _batchIndex) {\n            uint256 _length = legacyVerifiers.length;\n            // In most case, only last few verifier will be used by `ScrollChain`.\n            // So, we use linear search instead of binary search.\n            unchecked {\n                for (uint256 i = _length; i > 0; --i) {\n                    _verifier = legacyVerifiers[i - 1];\n                    if (_verifier.startBatchIndex <= _batchIndex) break;\n                }\n            }\n        }\n\n        return _verifier.verifier;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IRollupVerifier\n    function verifyAggregateProof(\n        uint256 _batchIndex,\n        bytes calldata _aggrProof,\n        bytes32 _publicInputHash\n    ) external view override {\n        address _verifier = getVerifier(_batchIndex);\n\n        IZkEvmVerifier(_verifier).verify(_aggrProof, _publicInputHash);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update the address of zkevm verifier.\n    /// @param _startBatchIndex The start batch index when the verifier will be used.\n    /// @param _verifier The address of new verifier.\n    function updateVerifier(uint64 _startBatchIndex, address _verifier) external onlyOwner {\n        Verifier memory _latestVerifier = latestVerifier;\n        require(_startBatchIndex >= _latestVerifier.startBatchIndex, \"start batch index too small\");\n        require(_verifier != address(0), \"zero verifier address\");\n\n        if (_latestVerifier.startBatchIndex < _startBatchIndex) {\n            legacyVerifiers.push(_latestVerifier);\n            _latestVerifier.startBatchIndex = _startBatchIndex;\n        }\n        _latestVerifier.verifier = _verifier;\n\n        latestVerifier = _latestVerifier;\n\n        emit UpdateVerifier(_startBatchIndex, _verifier);\n    }\n}"
    },
    {
      "filename": "contracts/src/L1/rollup/MultipleVersionRollupVerifier.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.16;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {IRollupVerifier} from \"../../libraries/verifier/IRollupVerifier.sol\";\nimport {IZkEvmVerifier} from \"../../libraries/verifier/IZkEvmVerifier.sol\";\n\ncontract MultipleVersionRollupVerifier is IRollupVerifier, Ownable {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when the address of verifier is updated.\n    /// @param startBatchIndex The start batch index when the verifier will be used.\n    /// @param verifier The address of new verifier.\n    event UpdateVerifier(uint256 startBatchIndex, address verifier);\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct Verifier {\n        // The start batch index for the verifier.\n        uint64 startBatchIndex;\n        // The address of zkevm verifier.\n        address verifier;\n    }\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The list of legacy zkevm verifier, sorted by batchIndex in increasing order.\n    Verifier[] public legacyVerifiers;\n\n    /// @notice The lastest used zkevm verifier.\n    Verifier public latestVerifier;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(address _verifier) {\n        require(_verifier != address(0), \"zero verifier address\");\n\n        latestVerifier.verifier = _verifier;\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Return the number of legacy verifiers.\n    function legacyVerifiersLength() external view returns (uint256) {\n        return legacyVerifiers.length;\n    }\n\n    /// @notice Compute the verifier should be used for specific batch.\n    /// @param _batchIndex The batch index to query.\n    function getVerifier(uint256 _batchIndex) public view returns (address) {\n        // Normally, we will use the latest verifier.\n        Verifier memory _verifier = latestVerifier;\n\n        if (_verifier.startBatchIndex > _batchIndex) {\n            uint256 _length = legacyVerifiers.length;\n            // In most case, only last few verifier will be used by `ScrollChain`.\n            // So, we use linear search instead of binary search.\n            unchecked {\n                for (uint256 i = _length; i > 0; --i) {\n                    _verifier = legacyVerifiers[i - 1];\n                    if (_verifier.startBatchIndex <= _batchIndex) break;\n                }\n            }\n        }\n\n        return _verifier.verifier;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IRollupVerifier\n    function verifyAggregateProof(\n        uint256 _batchIndex,\n        bytes calldata _aggrProof,\n        bytes32 _publicInputHash\n    ) external view override {\n        address _verifier = getVerifier(_batchIndex);\n\n        IZkEvmVerifier(_verifier).verify(_aggrProof, _publicInputHash);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update the address of zkevm verifier.\n    /// @param _startBatchIndex The start batch index when the verifier will be used.\n    /// @param _verifier The address of new verifier.\n    function updateVerifier(uint64 _startBatchIndex, address _verifier) external onlyOwner {\n        Verifier memory _latestVerifier = latestVerifier;\n        require(_startBatchIndex >= _latestVerifier.startBatchIndex, \"start batch index too small\");\n        require(_verifier != address(0), \"zero verifier address\");\n\n        if (_latestVerifier.startBatchIndex < _startBatchIndex) {\n            legacyVerifiers.push(_latestVerifier);\n            _latestVerifier.startBatchIndex = _startBatchIndex;\n        }\n        _latestVerifier.verifier = _verifier;\n\n        latestVerifier = _latestVerifier;\n\n        emit UpdateVerifier(_startBatchIndex, _verifier);\n    }\n}"
    },
    {
      "filename": "contracts/src/L1/rollup/ScrollChain.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.16;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport {IL1MessageQueue} from \"./IL1MessageQueue.sol\";\nimport {IScrollChain} from \"./IScrollChain.sol\";\nimport {BatchHeaderV0Codec} from \"../../libraries/codec/BatchHeaderV0Codec.sol\";\nimport {ChunkCodec} from \"../../libraries/codec/ChunkCodec.sol\";\nimport {IRollupVerifier} from \"../../libraries/verifier/IRollupVerifier.sol\";\n\n// solhint-disable no-inline-assembly\n// solhint-disable reason-string\n\n/// @title ScrollChain\n/// @notice This contract maintains data for the Scroll rollup.\ncontract ScrollChain is OwnableUpgradeable, IScrollChain {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when owner updates the status of sequencer.\n    /// @param account The address of account updated.\n    /// @param status The status of the account updated.\n    event UpdateSequencer(address indexed account, bool status);\n\n    /// @notice Emitted when owner updates the status of prover.\n    /// @param account The address of account updated.\n    /// @param status The status of the account updated.\n    event UpdateProver(address indexed account, bool status);\n\n    /// @notice Emitted when the address of rollup verifier is updated.\n    /// @param oldVerifier The address of old rollup verifier.\n    /// @param newVerifier The address of new rollup verifier.\n    event UpdateVerifier(address oldVerifier, address newVerifier);\n\n    /// @notice Emitted when the value of `maxNumL2TxInChunk` is updated.\n    /// @param oldMaxNumL2TxInChunk The old value of `maxNumL2TxInChunk`.\n    /// @param newMaxNumL2TxInChunk The new value of `maxNumL2TxInChunk`.\n    event UpdateMaxNumL2TxInChunk(uint256 oldMaxNumL2TxInChunk, uint256 newMaxNumL2TxInChunk);\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The chain id of the corresponding layer 2 chain.\n    uint64 public immutable layer2ChainId;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The maximum number of transactions allowed in each chunk.\n    uint256 public maxNumL2TxInChunk;\n\n    /// @notice The address of L1MessageQueue.\n    address public messageQueue;\n\n    /// @notice The address of RollupVerifier.\n    address public verifier;\n\n    /// @notice Whether an account is a sequencer.\n    mapping(address => bool) public isSequencer;\n\n    /// @notice Whether an account is a prover.\n    mapping(address => bool) public isProver;\n\n    /// @notice The latest finalized batch index.\n    uint256 public lastFinalizedBatchIndex;\n\n    /// @inheritdoc IScrollChain\n    mapping(uint256 => bytes32) public override committedBatches;\n\n    /// @inheritdoc IScrollChain\n    mapping(uint256 => bytes32) public override finalizedStateRoots;\n\n    /// @inheritdoc IScrollChain\n    mapping(uint256 => bytes32) public override withdrawRoots;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier OnlySequencer() {\n        // @note In the decentralized mode, it should be only called by a list of validator.\n        require(isSequencer[msg.sender], \"caller not sequencer\");\n        _;\n    }\n\n    modifier OnlyProver() {\n        require(isProver[msg.sender], \"caller not prover\");\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(uint64 _chainId) {\n        _disableInitializers();\n\n        layer2ChainId = _chainId;\n    }\n\n    function initialize(\n        address _messageQueue,\n        address _verifier,\n        uint256 _maxNumL2TxInChunk\n    ) public initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        messageQueue = _messageQueue;\n        verifier = _verifier;\n        maxNumL2TxInChunk = _maxNumL2TxInChunk;\n\n        emit UpdateVerifier(address(0), _verifier);\n        emit UpdateMaxNumL2TxInChunk(0, _maxNumL2TxInChunk);\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IScrollChain\n    function isBatchFinalized(uint256 _batchIndex) external view override returns (bool) {\n        return _batchIndex <= lastFinalizedBatchIndex;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Import layer 2 genesis block\n    function importGenesisBatch(bytes calldata _batchHeader, bytes32 _stateRoot) external {\n        // check genesis batch header length\n        require(_stateRoot != bytes32(0), \"zero state root\");\n\n        // check whether the genesis batch is imported\n        require(finalizedStateRoots[0] == bytes32(0), \"Genesis batch imported\");\n\n        (uint256 memPtr, bytes32 _batchHash) = _loadBatchHeader(_batchHeader);\n\n        // check all fields except `dataHash` and `lastBlockHash` are zero\n        unchecked {\n            uint256 sum = BatchHeaderV0Codec.version(memPtr) +\n                BatchHeaderV0Codec.batchIndex(memPtr) +\n                BatchHeaderV0Codec.l1MessagePopped(memPtr) +\n                BatchHeaderV0Codec.totalL1MessagePopped(memPtr);\n            require(sum == 0, \"not all fields are zero\");\n        }\n        require(BatchHeaderV0Codec.dataHash(memPtr) != bytes32(0), \"zero data hash\");\n        require(BatchHeaderV0Codec.parentBatchHash(memPtr) == bytes32(0), \"nonzero parent batch hash\");\n\n        committedBatches[0] = _batchHash;\n        finalizedStateRoots[0] = _stateRoot;\n\n        emit CommitBatch(0, _batchHash);\n        emit FinalizeBatch(0, _batchHash, _stateRoot, bytes32(0));\n    }\n\n    /// @inheritdoc IScrollChain\n    function commitBatch(\n        uint8 _version,\n        bytes calldata _parentBatchHeader,\n        bytes[] memory _chunks,\n        bytes calldata _skippedL1MessageBitmap\n    ) external override OnlySequencer {\n        require(_version == 0, \"invalid version\");\n\n        // check whether the batch is empty\n        uint256 _chunksLength = _chunks.length;\n        require(_chunksLength > 0, \"batch is empty\");\n\n        // The overall memory layout in this function is organized as follows\n        // +---------------------+-------------------+------------------+\n        // | parent batch header | chunk data hashes | new batch header |\n        // +---------------------+-------------------+------------------+\n        // ^                     ^                   ^\n        // batchPtr              dataPtr             newBatchPtr (re-use var batchPtr)\n        //\n        // 1. We copy the parent batch header from calldata to memory starting at batchPtr\n        // 2. We store `_chunksLength` number of Keccak hashes starting at `dataPtr`. Each Keccak\n        //    hash corresponds to the data hash of a chunk. So we reserve the memory region from\n        //    `dataPtr` to `dataPtr + _chunkLength * 32` for the chunk data hashes.\n        // 3. The memory starting at `newBatchPtr` is used to store the new batch header and compute\n        //    the batch hash.\n\n        // the variable `batchPtr` will be reused later for the current batch\n        (uint256 batchPtr, bytes32 _parentBatchHash) = _loadBatchHeader(_parentBatchHeader);\n\n        uint256 _batchIndex = BatchHeaderV0Codec.batchIndex(batchPtr);\n        uint256 _totalL1MessagesPoppedOverall = BatchHeaderV0Codec.totalL1MessagePopped(batchPtr);\n        require(committedBatches[_batchIndex] == _parentBatchHash, \"incorrect parent batch hash\");\n        require(committedBatches[_batchIndex + 1] == 0, \"batch already committed\");\n\n        // load `dataPtr` and reserve the memory region for chunk data hashes\n        uint256 dataPtr;\n        assembly {\n            dataPtr := mload(0x40)\n            mstore(0x40, add(dataPtr, mul(_chunksLength, 32)))\n        }\n\n        // compute the data hash for each chunk\n        uint256 _totalL1MessagesPoppedInBatch;\n        for (uint256 i = 0; i < _chunksLength; i++) {\n            uint256 _totalNumL1MessagesInChunk = _commitChunk(\n                dataPtr,\n                _chunks[i],\n                _totalL1MessagesPoppedInBatch,\n                _totalL1MessagesPoppedOverall,\n                _skippedL1MessageBitmap\n            );\n\n            unchecked {\n                _totalL1MessagesPoppedInBatch += _totalNumL1MessagesInChunk;\n                _totalL1MessagesPoppedOverall += _totalNumL1MessagesInChunk;\n                dataPtr += 32;\n            }\n        }\n\n        // check the length of bitmap\n        unchecked {\n            require(\n                ((_totalL1MessagesPoppedInBatch + 255) / 256) * 32 == _skippedL1MessageBitmap.length,\n                \"wrong bitmap length\"\n            );\n        }\n\n        // compute the data hash for current batch\n        bytes32 _dataHash;\n        assembly {\n            let dataLen := mul(_chunksLength, 0x20)\n            _dataHash := keccak256(sub(dataPtr, dataLen), dataLen)\n\n            batchPtr := mload(0x40) // reset batchPtr\n            _batchIndex := add(_batchIndex, 1) // increase batch index\n        }\n\n        // store entries, the order matters\n        BatchHeaderV0Codec.storeVersion(batchPtr, _version);\n        BatchHeaderV0Codec.storeBatchIndex(batchPtr, _batchIndex);\n        BatchHeaderV0Codec.storeL1MessagePopped(batchPtr, _totalL1MessagesPoppedInBatch);\n        BatchHeaderV0Codec.storeTotalL1MessagePopped(batchPtr, _totalL1MessagesPoppedOverall);\n        BatchHeaderV0Codec.storeDataHash(batchPtr, _dataHash);\n        BatchHeaderV0Codec.storeParentBatchHash(batchPtr, _parentBatchHash);\n        BatchHeaderV0Codec.storeSkippedBitmap(batchPtr, _skippedL1MessageBitmap);\n\n        // compute batch hash\n        bytes32 _batchHash = BatchHeaderV0Codec.computeBatchHash(batchPtr, 89 + _skippedL1MessageBitmap.length);\n\n        committedBatches[_batchIndex] = _batchHash;\n        emit CommitBatch(_batchIndex, _batchHash);\n    }\n\n    /// @inheritdoc IScrollChain\n    /// @dev If the owner want to revert a sequence of batches by sending multiple transactions,\n    ///      make sure to revert recent batches first.\n    function revertBatch(bytes calldata _batchHeader, uint256 _count) external onlyOwner {\n        require(_count > 0, \"count must be nonzero\");\n\n        (uint256 memPtr, bytes32 _batchHash) = _loadBatchHeader(_batchHeader);\n\n        // check batch hash\n        uint256 _batchIndex = BatchHeaderV0Codec.batchIndex(memPtr);\n        require(committedBatches[_batchIndex] == _batchHash, \"incorrect batch hash\");\n        // make sure no gap is left when reverting from the ending to the beginning.\n        require(committedBatches[_batchIndex + _count] == bytes32(0), \"reverting must start from the ending\");\n\n        // check finalization\n        require(_batchIndex > lastFinalizedBatchIndex, \"can only revert unfinalized batch\");\n\n        while (_count > 0) {\n            emit RevertBatch(_batchIndex, _batchHash);\n\n            committedBatches[_batchIndex] = bytes32(0);\n            unchecked {\n                _batchIndex += 1;\n                _count -= 1;\n            }\n\n            _batchHash = committedBatches[_batchIndex];\n            if (_batchHash == bytes32(0)) break;\n        }\n    }\n\n    /// @inheritdoc IScrollChain\n    function finalizeBatchWithProof(\n        bytes calldata _batchHeader,\n        bytes32 _prevStateRoot,\n        bytes32 _postStateRoot,\n        bytes32 _withdrawRoot,\n        bytes calldata _aggrProof\n    ) external override OnlyProver {\n        require(_prevStateRoot != bytes32(0), \"previous state root is zero\");\n        require(_postStateRoot != bytes32(0), \"new state root is zero\");\n\n        // compute batch hash and verify\n        (uint256 memPtr, bytes32 _batchHash) = _loadBatchHeader(_batchHeader);\n\n        bytes32 _dataHash = BatchHeaderV0Codec.dataHash(memPtr);\n        uint256 _batchIndex = BatchHeaderV0Codec.batchIndex(memPtr);\n        require(committedBatches[_batchIndex] == _batchHash, \"incorrect batch hash\");\n\n        // verify previous state root.\n        require(finalizedStateRoots[_batchIndex - 1] == _prevStateRoot, \"incorrect previous state root\");\n\n        // avoid duplicated verification\n        require(finalizedStateRoots[_batchIndex] == bytes32(0), \"batch already verified\");\n\n        // compute public input hash\n        bytes32 _publicInputHash = keccak256(\n            abi.encodePacked(layer2ChainId, _prevStateRoot, _postStateRoot, _withdrawRoot, _dataHash)\n        );\n\n        // verify batch\n        IRollupVerifier(verifier).verifyAggregateProof(_batchIndex, _aggrProof, _publicInputHash);\n\n        // check and update lastFinalizedBatchIndex\n        unchecked {\n            require(lastFinalizedBatchIndex + 1 == _batchIndex, \"incorrect batch index\");\n            lastFinalizedBatchIndex = _batchIndex;\n        }\n\n        // record state root and withdraw root\n        finalizedStateRoots[_batchIndex] = _postStateRoot;\n        withdrawRoots[_batchIndex] = _withdrawRoot;\n\n        // Pop finalized and non-skipped message from L1MessageQueue.\n        uint256 _l1MessagePopped = BatchHeaderV0Codec.l1MessagePopped(memPtr);\n        if (_l1MessagePopped > 0) {\n            IL1MessageQueue _queue = IL1MessageQueue(messageQueue);\n\n            unchecked {\n                uint256 _startIndex = BatchHeaderV0Codec.totalL1MessagePopped(memPtr) - _l1MessagePopped;\n\n                for (uint256 i = 0; i < _l1MessagePopped; i += 256) {\n                    uint256 _count = 256;\n                    if (_l1MessagePopped - i < _count) {\n                        _count = _l1MessagePopped - i;\n                    }\n                    uint256 _skippedBitmap = BatchHeaderV0Codec.skippedBitmap(memPtr, i / 256);\n\n                    _queue.popCrossDomainMessage(_startIndex, _count, _skippedBitmap);\n\n                    _startIndex += 256;\n                }\n            }\n        }\n\n        emit FinalizeBatch(_batchIndex, _batchHash, _postStateRoot, _withdrawRoot);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update the status of sequencer.\n    /// @dev This function can only called by contract owner.\n    /// @param _account The address of account to update.\n    /// @param _status The status of the account to update.\n    function updateSequencer(address _account, bool _status) external onlyOwner {\n        isSequencer[_account] = _status;\n\n        emit UpdateSequencer(_account, _status);\n    }\n\n    /// @notice Update the status of prover.\n    /// @dev This function can only called by contract owner.\n    /// @param _account The address of account to update.\n    /// @param _status The status of the account to update.\n    function updateProver(address _account, bool _status) external onlyOwner {\n        isProver[_account] = _status;\n\n        emit UpdateProver(_account, _status);\n    }\n\n    /// @notice Update the address verifier contract.\n    /// @param _newVerifier The address of new verifier contract.\n    function updateVerifier(address _newVerifier) external onlyOwner {\n        address _oldVerifier = verifier;\n        verifier = _newVerifier;\n\n        emit UpdateVerifier(_oldVerifier, _newVerifier);\n    }\n\n    /// @notice Update the value of `maxNumL2TxInChunk`.\n    /// @param _maxNumL2TxInChunk The new value of `maxNumL2TxInChunk`.\n    function updateMaxNumL2TxInChunk(uint256 _maxNumL2TxInChunk) external onlyOwner {\n        uint256 _oldMaxNumL2TxInChunk = maxNumL2TxInChunk;\n        maxNumL2TxInChunk = _maxNumL2TxInChunk;\n\n        emit UpdateMaxNumL2TxInChunk(_oldMaxNumL2TxInChunk, _maxNumL2TxInChunk);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to load batch header from calldata to memory.\n    /// @param _batchHeader The batch header in calldata.\n    /// @return memPtr The start memory offset of loaded batch header.\n    /// @return _batchHash The hash of the loaded batch header.\n    function _loadBatchHeader(bytes calldata _batchHeader) internal pure returns (uint256 memPtr, bytes32 _batchHash) {\n        // load to memory\n        uint256 _length;\n        (memPtr, _length) = BatchHeaderV0Codec.loadAndValidate(_batchHeader);\n\n        // compute batch hash\n        _batchHash = BatchHeaderV0Codec.computeBatchHash(memPtr, _length);\n    }\n\n    /// @dev Internal function to commit a chunk.\n    /// @param memPtr The start memory offset to store list of `dataHash`.\n    /// @param _chunk The encoded chunk to commit.\n    /// @param _totalL1MessagesPoppedInBatch The total number of L1 messages popped in current batch.\n    /// @param _totalL1MessagesPoppedOverall The total number of L1 messages popped in all batches including current batch.\n    /// @param _skippedL1MessageBitmap The bitmap indicates whether each L1 message is skipped or not.\n    /// @return _totalNumL1MessagesInChunk The total number of L1 message popped in current chunk\n    function _commitChunk(\n        uint256 memPtr,\n        bytes memory _chunk,\n        uint256 _totalL1MessagesPoppedInBatch,\n        uint256 _totalL1MessagesPoppedOverall,\n        bytes calldata _skippedL1MessageBitmap\n    ) internal view returns (uint256 _totalNumL1MessagesInChunk) {\n        uint256 chunkPtr;\n        uint256 startDataPtr;\n        uint256 dataPtr;\n        uint256 blockPtr;\n\n        assembly {\n            dataPtr := mload(0x40)\n            startDataPtr := dataPtr\n            chunkPtr := add(_chunk, 0x20) // skip chunkLength\n            blockPtr := add(chunkPtr, 1) // skip numBlocks\n        }\n\n        uint256 _numBlocks = ChunkCodec.validateChunkLength(chunkPtr, _chunk.length);\n\n        // concatenate block contexts\n        uint256 _totalTransactionsInChunk;\n        for (uint256 i = 0; i < _numBlocks; i++) {\n            dataPtr = ChunkCodec.copyBlockContext(chunkPtr, dataPtr, i);\n            uint256 _numTransactionsInBlock = ChunkCodec.numTransactions(blockPtr);\n            unchecked {\n                _totalTransactionsInChunk += _numTransactionsInBlock;\n                blockPtr += ChunkCodec.BLOCK_CONTEXT_LENGTH;\n            }\n        }\n\n        assembly {\n            mstore(0x40, add(dataPtr, mul(_totalTransactionsInChunk, 0x20))) // reserve memory for tx hashes\n            blockPtr := add(chunkPtr, 1) // reset block ptr\n        }\n\n        // concatenate tx hashes\n        uint256 l2TxPtr = ChunkCodec.l2TxPtr(chunkPtr, _numBlocks);\n        while (_numBlocks > 0) {\n            // concatenate l1 message hashes\n            uint256 _numL1MessagesInBlock = ChunkCodec.numL1Messages(blockPtr);\n            dataPtr = _loadL1MessageHashes(\n                dataPtr,\n                _numL1MessagesInBlock,\n                _totalL1MessagesPoppedInBatch,\n                _totalL1MessagesPoppedOverall,\n                _skippedL1MessageBitmap\n            );\n\n            // concatenate l2 transaction hashes\n            uint256 _numTransactionsInBlock = ChunkCodec.numTransactions(blockPtr);\n            for (uint256 j = _numL1MessagesInBlock; j < _numTransactionsInBlock; j++) {\n                bytes32 txHash;\n                (txHash, l2TxPtr) = ChunkCodec.loadL2TxHash(l2TxPtr);\n                assembly {\n                    mstore(dataPtr, txHash)\n                    dataPtr := add(dataPtr, 0x20)\n                }\n            }\n\n            unchecked {\n                _totalNumL1MessagesInChunk += _numL1MessagesInBlock;\n                _totalL1MessagesPoppedInBatch += _numL1MessagesInBlock;\n                _totalL1MessagesPoppedOverall += _numL1MessagesInBlock;\n\n                _numBlocks -= 1;\n                blockPtr += ChunkCodec.BLOCK_CONTEXT_LENGTH;\n            }\n        }\n\n        // check the number of L2 transactions in the chunk\n        require(\n            _totalTransactionsInChunk - _totalNumL1MessagesInChunk <= maxNumL2TxInChunk,\n            \"too many L2 txs in one chunk\"\n        );\n\n        // check chunk has correct length\n        require(l2TxPtr - chunkPtr == _chunk.length, \"incomplete l2 transaction data\");\n\n        // compute data hash and store to memory\n        assembly {\n            let dataHash := keccak256(startDataPtr, sub(dataPtr, startDataPtr))\n            mstore(memPtr, dataHash)\n        }\n\n        return _totalNumL1MessagesInChunk;\n    }\n\n    /// @dev Internal function to load L1 message hashes from the message queue.\n    /// @param _ptr The memory offset to store the transaction hash.\n    /// @param _numL1Messages The number of L1 messages to load.\n    /// @param _totalL1MessagesPoppedInBatch The total number of L1 messages popped in current batch.\n    /// @param _totalL1MessagesPoppedOverall The total number of L1 messages popped in all batches including current batch.\n    /// @param _skippedL1MessageBitmap The bitmap indicates whether each L1 message is skipped or not.\n    /// @return uint256 The new memory offset after loading.\n    function _loadL1MessageHashes(\n        uint256 _ptr,\n        uint256 _numL1Messages,\n        uint256 _totalL1MessagesPoppedInBatch,\n        uint256 _totalL1MessagesPoppedOverall,\n        bytes calldata _skippedL1MessageBitmap\n    ) internal view returns (uint256) {\n        if (_numL1Messages == 0) return _ptr;\n        IL1MessageQueue _messageQueue = IL1MessageQueue(messageQueue);\n\n        unchecked {\n            uint256 _bitmap;\n            for (uint256 i = 0; i < _numL1Messages; i++) {\n                uint256 quo = _totalL1MessagesPoppedInBatch >> 8;\n                uint256 rem = _totalL1MessagesPoppedInBatch & 0xff;\n\n                // load bitmap every 256 bits\n                if (i == 0 || rem == 0) {\n                    assembly {\n                        _bitmap := calldataload(add(_skippedL1MessageBitmap.offset, mul(0x20, quo)))\n                    }\n                }\n                if (((_bitmap >> rem) & 1) == 0) {\n                    // message not skipped\n                    bytes32 _hash = _messageQueue.getCrossDomainMessage(_totalL1MessagesPoppedOverall);\n                    assembly {\n                        mstore(_ptr, _hash)\n                        _ptr := add(_ptr, 0x20)\n                    }\n                }\n\n                _totalL1MessagesPoppedInBatch += 1;\n                _totalL1MessagesPoppedOverall += 1;\n            }\n        }\n\n        return _ptr;\n    }\n}"
    }
  ]
}