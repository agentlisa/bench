{
  "Title": "[G-03] Avoid unnecessary storage updates",
  "Content": "- Severity: Gas Optimization\n- Confidence: High\n- Total Gas Saved: 16800\n\n### Description\nAvoid updating storage when the value hasn't changed. If the old value is equal to the new value, not re-storing the value will avoid a `SSTORE` operation (costing 2900 gas), potentially at the expense of a `SLOAD` operation (2100 gas) or a `WARMACCESS` operation (100 gas).\n\n<details>\n\n<summary>\nThere are 21 instances of this issue:\n\n</summary>\n\n###\n- The function `setCurve()` changes the state variable without first verifying if the values are different.\n\nFile: solidity/contracts/periphery/CurveMaster.sol\n```\n \nLine: 44          curves[_tokenAddress] = _curveAddress\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/periphery/CurveMaster.sol#L44](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/periphery/CurveMaster.sol#L44)\n\n- The function `setDelay()` changes the state variable without first verifying if the values are different.\n\nFile: solidity/contracts/governance/GovernorCharlie.sol\n```\n \nLine: 585          proposalTimelockDelay = _proposalTimelockDelay\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L585](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L585)\n\n- The function `setEmergencyDelay()` changes the state variable without first verifying if the values are different.\n\nFile: solidity/contracts/governance/GovernorCharlie.sol\n```\n \nLine: 596          emergencyTimelockDelay = _emergencyTimelockDelay\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L596](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L596)\n\n- The function `setEmergencyQuorumVotes()` changes the state variable without first verifying if the values are different.\n\nFile: solidity/contracts/governance/GovernorCharlie.sol\n```\n \nLine: 662          emergencyQuorumVotes = _newEmergencyQuorumVotes\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L662](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L662)\n\n- The function `setEmergencyVotingPeriod()` changes the state variable without first verifying if the values are different.\n\nFile: solidity/contracts/governance/GovernorCharlie.sol\n```\n \nLine: 629          emergencyVotingPeriod = _newEmergencyVotingPeriod\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L629](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L629)\n\n- The function `setMaxWhitelistPeriod()` changes the state variable without first verifying if the values are different.\n\nFile: solidity/contracts/governance/GovernorCharlie.sol\n```\n \nLine: 576          maxWhitelistPeriod = _second\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L576](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L576)\n\n- The function `setMonetaryPolicy()` changes the state variable without first verifying if the values are different.\n\nFile: solidity/contracts/utils/UFragments.sol\n```\n \nLine: 112          monetaryPolicy = _monetaryPolicy\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/utils/UFragments.sol#L112](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/utils/UFragments.sol#L112)\n\n- The function `setNewToken()` changes the state variable without first verifying if the values are different.\n\nFile: solidity/contracts/governance/GovernorCharlie.sol\n```\n \nLine: 568          amph = IAMPH(_token)\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L568](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L568)\n\n- The function `setOptimisticDelay()` changes the state variable without first verifying if the values are different.\n\nFile: solidity/contracts/governance/GovernorCharlie.sol\n```\n \nLine: 697          optimisticVotingDelay = _newOptimisticVotingDelay\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L697](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L697)\n\n- The function `setOptimisticQuorumVotes()` changes the state variable without first verifying if the values are different.\n\nFile: solidity/contracts/governance/GovernorCharlie.sol\n```\n \nLine: 708          optimisticQuorumVotes = _newOptimisticQuorumVotes\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L708](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L708)\n\n- The function `setPauser()` changes the state variable without first verifying if the values are different.\n\nFile: solidity/contracts/core/USDA.sol\n```\n \nLine: 64          pauser = _pauser\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/USDA.sol#L64](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/USDA.sol#L64)\n\n- The function `setProposalThreshold()` changes the state variable without first verifying if the values are different.\n\nFile: solidity/contracts/governance/GovernorCharlie.sol\n```\n \nLine: 640          proposalThreshold = _newProposalThreshold\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L640](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L640)\n\n- The function `setQuorumVotes()` changes the state variable without first verifying if the values are different.\n\nFile: solidity/contracts/governance/GovernorCharlie.sol\n```\n \nLine: 651          quorumVotes = _newQuorumVotes\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L651](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L651)\n\n- The function `setVaultController()` changes the state variable without first verifying if the values are different.\n\nFile: solidity/contracts/periphery/CurveMaster.sol\n```\n \nLine: 33          vaultControllerAddress = _vaultMasterAddress\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/periphery/CurveMaster.sol#L33](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/periphery/CurveMaster.sol#L33)\n\n- The function `setVotingDelay()` changes the state variable without first verifying if the values are different.\n\nFile: solidity/contracts/governance/GovernorCharlie.sol\n```\n \nLine: 607          votingDelay = _newVotingDelay\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L607](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L607)\n\n- The function `setVotingPeriod()` changes the state variable without first verifying if the values are different.\n\nFile: solidity/contracts/governance/GovernorCharlie.sol\n```\n \nLine: 618          votingPeriod = _newVotingPeriod\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L618](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L618)\n\n- The function `setWhitelistAccountExpiration()` changes the state variable without first verifying if the values are different.\n\nFile: solidity/contracts/governance/GovernorCharlie.sol\n```\n \nLine: 675          whitelistAccountExpirations[_account] = _expiration\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L675](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L675)\n\n- The function `setWhitelistGuardian()` changes the state variable without first verifying if the values are different.\n\nFile: solidity/contracts/governance/GovernorCharlie.sol\n```\n \nLine: 686          whitelistGuardian = _account\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L686](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L686)\n\n- The function `updateRegisteredErc20()` changes the state variable without first verifying if the values are different.\n\nFile: solidity/contracts/core/VaultController.sol\n```\n \nLine: 399          _collateral.crvRewardsContract = IBaseRewardPool(_crvRewards)\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/VaultController.sol#L399](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/VaultController.sol#L399)\n\n- The function `updateRegisteredErc20()` changes the state variable without first verifying if the values are different.\n\nFile: solidity/contracts/core/VaultController.sol\n```\n \nLine: 409          _collateral.cap = _cap\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/VaultController.sol#L409](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/VaultController.sol#L409)\n\n- The function `updateRegisteredErc20()` changes the state variable without first verifying if the values are different.\n\nFile: solidity/contracts/core/VaultController.sol\n```\n \nLine: 403          _collateral.oracle = IOracleRelay(_oracleAddress)\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/VaultController.sol#L403](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/VaultController.sol#L403)\n\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-07-amphora",
  "Code": [
    {
      "filename": "core/solidity/contracts/periphery/CurveMaster.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {ICurveMaster} from '@interfaces/periphery/ICurveMaster.sol';\nimport {ICurveSlave} from '@interfaces/utils/ICurveSlave.sol';\nimport {IVaultController} from '@interfaces/core/IVaultController.sol';\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\n\n/// @notice Curve master keeps a record of CurveSlave contracts and links it with an address\n/// @dev All numbers should be scaled to 1e18. for instance, number 5e17 represents 50%\ncontract CurveMaster is ICurveMaster, Ownable {\n  /// @dev Mapping of token to address\n  mapping(address => address) public curves;\n\n  /// @dev The vault controller address\n  address public vaultControllerAddress;\n\n  /// @notice Returns the value of curve labled _tokenAddress at _xValue\n  /// @param _tokenAddress The key to lookup the curve with in the mapping\n  /// @param _xValue The x value to pass to the slave\n  /// @return _value The y value of the curve\n  function getValueAt(address _tokenAddress, int256 _xValue) external view override returns (int256 _value) {\n    if (curves[_tokenAddress] == address(0)) revert CurveMaster_TokenNotEnabled();\n    ICurveSlave _curve = ICurveSlave(curves[_tokenAddress]);\n    _value = _curve.valueAt(_xValue);\n    if (_value == 0) revert CurveMaster_ZeroResult();\n  }\n\n  /// @notice Set the VaultController addr in order to pay interest on curve setting\n  /// @param _vaultMasterAddress The address of vault master\n  function setVaultController(address _vaultMasterAddress) external override onlyOwner {\n    address _oldCurveAddress = vaultControllerAddress;\n    vaultControllerAddress = _vaultMasterAddress;\n\n    emit VaultControllerSet(_oldCurveAddress, _vaultMasterAddress);\n  }\n\n  /// @notice Setting a new curve should pay interest\n  /// @param _tokenAddress The address of the token\n  /// @param _curveAddress The address of the curve for the contract\n  function setCurve(address _tokenAddress, address _curveAddress) external override onlyOwner {\n    if (vaultControllerAddress != address(0)) IVaultController(vaultControllerAddress).calculateInterest();\n    address _oldCurve = curves[_tokenAddress];\n    curves[_tokenAddress] = _curveAddress;\n\n    emit CurveSet(_oldCurve, _tokenAddress, _curveAddress);\n  }\n\n  /// @notice Special function that does not calculate interest, used for deployment\n  /// @param _tokenAddress The address of the token\n  /// @param _curveAddress The address of the curve for the contract\n  function forceSetCurve(address _tokenAddress, address _curveAddress) external override onlyOwner {\n    address _oldCurve = curves[_tokenAddress];\n    curves[_tokenAddress] = _curveAddress;\n\n    emit CurveForceSet(_oldCurve, _tokenAddress, _curveAddress);\n  }\n}"
    },
    {
      "filename": "core/solidity/contracts/governance/GovernorCharlie.sol",
      "content": "// solhint-disable max-states-count\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\npragma experimental ABIEncoderV2;\n\nimport {IAMPH} from '@interfaces/governance/IAMPH.sol';\nimport {IGovernorCharlie} from '@interfaces/governance/IGovernorCharlie.sol';\n\nimport {Receipt, ProposalState, Proposal} from '@contracts/utils/GovernanceStructs.sol';\n\ncontract GovernorCharlie is IGovernorCharlie {\n  /// @notice The name of this contract\n  string public constant NAME = 'Amphora Protocol Governor';\n\n  /// @notice The maximum number of actions that can be included in a proposal\n  uint256 public constant PROPOSAL_MAX_OPERATIONS = 10;\n\n  /// @notice The EIP-712 typehash for the contract's domain\n  bytes32 public constant DOMAIN_TYPEHASH =\n    keccak256('EIP712Domain(string name,uint256 chainId,address verifyingContract)');\n\n  /// @notice The EIP-712 typehash for the ballot struct used by the contract\n  bytes32 public constant BALLOT_TYPEHASH = keccak256('Ballot(uint256 proposalId,uint8 support)');\n\n  /// @notice The time for a proposal to be executed after passing\n  uint256 public constant GRACE_PERIOD = 14 days;\n\n  /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n  uint256 public quorumVotes;\n\n  /// @notice The number of votes in support of a proposal required in order for an emergency quorum to be reached and for a vote to succeed\n  uint256 public emergencyQuorumVotes;\n\n  /// @notice The delay before voting on a proposal may take place, once proposed, in blocks\n  uint256 public votingDelay;\n\n  /// @notice The duration of voting on a proposal, in blocks\n  uint256 public votingPeriod;\n\n  /// @notice The number of votes required in order for a voter to become a proposer\n  uint256 public proposalThreshold;\n\n  /// @notice Initial proposal id set at become\n  uint256 public initialProposalId;\n\n  /// @notice The total number of proposals\n  uint256 public proposalCount;\n\n  /// @notice The address of the Amphora Protocol governance token\n  IAMPH public amph;\n\n  /// @notice The official record of all proposals ever proposed\n  mapping(uint256 => Proposal) public proposals;\n\n  /// @notice The latest proposal for each proposer\n  mapping(address => uint256) public latestProposalIds;\n\n  /// @notice The mapping that saves queued transactions\n  mapping(bytes32 => bool) public queuedTransactions;\n\n  /// @notice The proposal holding period\n  uint256 public proposalTimelockDelay;\n\n  /// @notice Stores the expiration of account whitelist status as a timestamp\n  mapping(address => uint256) public whitelistAccountExpirations;\n\n  /// @notice Address which manages whitelisted proposals and whitelist accounts\n  address public whitelistGuardian;\n\n  /// @notice The duration of the voting on a emergency proposal, in blocks\n  uint256 public emergencyVotingPeriod;\n\n  /// @notice The emergency proposal holding period\n  uint256 public emergencyTimelockDelay;\n\n  /// @notice all receipts for proposal\n  mapping(uint256 => mapping(address => Receipt)) public proposalReceipts;\n\n  /// @notice The number of votes to reject an optimistic proposal\n  uint256 public optimisticQuorumVotes;\n\n  /// @notice The delay period before voting begins\n  uint256 public optimisticVotingDelay;\n\n  /// @notice The maximum number of seconds an address can be whitelisted for\n  uint256 public maxWhitelistPeriod;\n\n  constructor(address _amph) {\n    amph = IAMPH(_amph);\n    votingPeriod = 40_320;\n    votingDelay = 13_140;\n    proposalThreshold = 1_000_000_000_000_000_000_000_000;\n    proposalTimelockDelay = 172_800;\n    proposalCount = 0;\n    quorumVotes = 10_000_000_000_000_000_000_000_000;\n    emergencyQuorumVotes = 40_000_000_000_000_000_000_000_000;\n    emergencyVotingPeriod = 6570;\n    emergencyTimelockDelay = 43_200;\n\n    optimisticQuorumVotes = 2_000_000_000_000_000_000_000_000;\n    optimisticVotingDelay = 25_600;\n    maxWhitelistPeriod = 31_536_000;\n  }\n\n  /// @notice any function with this modifier can only be called by governance\n  modifier onlyGov() {\n    if (msg.sender != address(this)) revert GovernorCharlie_NotGovernorCharlie();\n    _;\n  }\n\n  /**\n   * @notice Function used to propose a new proposal. Sender must have delegates above the proposal threshold\n   * @param _targets Target addresses for proposal calls\n   * @param _values Eth values for proposal calls\n   * @param _signatures Function signatures for proposal calls\n   * @param _calldatas Calldatas for proposal calls\n   * @param _description String description of the proposal\n   * @return _proposalId Proposal id of new proposal\n   */\n  function propose(\n    address[] memory _targets,\n    uint256[] memory _values,\n    string[] memory _signatures,\n    bytes[] memory _calldatas,\n    string memory _description\n  ) public override returns (uint256 _proposalId) {\n    _proposalId = _propose(_targets, _values, _signatures, _calldatas, _description, false);\n  }\n\n  /**\n   * @notice Function used to propose a new emergency proposal. Sender must have delegates above the proposal threshold\n   * @param _targets Target addresses for proposal calls\n   * @param _values Eth values for proposal calls\n   * @param _signatures Function signatures for proposal calls\n   * @param _calldatas Calldatas for proposal calls\n   * @param _description String description of the proposal\n   * @return _proposalId Proposal id of new proposal\n   */\n  function proposeEmergency(\n    address[] memory _targets,\n    uint256[] memory _values,\n    string[] memory _signatures,\n    bytes[] memory _calldatas,\n    string memory _description\n  ) public override returns (uint256 _proposalId) {\n    _proposalId = _propose(_targets, _values, _signatures, _calldatas, _description, true);\n  }\n\n  /**\n   * @notice Function used to propose a new proposal. Sender must have delegates above the proposal threshold\n   * @param _targets Target addresses for proposal calls\n   * @param _values Eth values for proposal calls\n   * @param _signatures Function signatures for proposal calls\n   * @param _calldatas Calldatas for proposal calls\n   * @param _description String description of the proposal\n   * @param _emergency Bool to determine if proposal an emergency proposal\n   * @return _proposalId Proposal id of new proposal\n   */\n  function _propose(\n    address[] memory _targets,\n    uint256[] memory _values,\n    string[] memory _signatures,\n    bytes[] memory _calldatas,\n    string memory _description,\n    bool _emergency\n  ) internal returns (uint256 _proposalId) {\n    // Reject proposals before initiating as Governor\n    if (quorumVotes == 0) revert GovernorCharlie_NotActive();\n    // Allow addresses above proposal threshold and whitelisted addresses to propose\n    if (amph.getPriorVotes(msg.sender, (block.number - 1)) < proposalThreshold && !isWhitelisted(msg.sender)) {\n      revert GovernorCharlie_VotesBelowThreshold();\n    }\n    if (\n      _targets.length != _values.length || _targets.length != _signatures.length || _targets.length != _calldatas.length\n    ) revert GovernorCharlie_ArityMismatch();\n    if (_targets.length == 0) revert GovernorCharlie_NoActions();\n    if (_targets.length > PROPOSAL_MAX_OPERATIONS) revert GovernorCharlie_TooManyActions();\n\n    uint256 _latestProposalId = latestProposalIds[msg.sender];\n    if (_latestProposalId != 0) {\n      ProposalState _proposersLatestProposalState = state(_latestProposalId);\n      if (_proposersLatestProposalState == ProposalState.Active) revert GovernorCharlie_MultipleActiveProposals();\n      if (_proposersLatestProposalState == ProposalState.Pending) revert GovernorCharlie_MultiplePendingProposals();\n    }\n\n    proposalCount++;\n    Proposal memory _newProposal = Proposal({\n      id: proposalCount,\n      proposer: msg.sender,\n      eta: 0,\n      targets: _targets,\n      values: _values,\n      signatures: _signatures,\n      calldatas: _calldatas,\n      startBlock: block.number + votingDelay,\n      endBlock: block.number + votingDelay + votingPeriod,\n      forVotes: 0,\n      againstVotes: 0,\n      abstainVotes: 0,\n      canceled: false,\n      executed: false,\n      emergency: _emergency,\n      quorumVotes: quorumVotes,\n      delay: proposalTimelockDelay\n    });\n\n    //whitelist can't make emergency\n    if (_emergency && !isWhitelisted(msg.sender)) {\n      _newProposal.startBlock = block.number;\n      _newProposal.endBlock = block.number + emergencyVotingPeriod;\n      _newProposal.quorumVotes = emergencyQuorumVotes;\n      _newProposal.delay = emergencyTimelockDelay;\n    }\n\n    //whitelist can only make optimistic proposals\n    if (isWhitelisted(msg.sender)) {\n      _newProposal.quorumVotes = optimisticQuorumVotes;\n      _newProposal.startBlock = block.number + optimisticVotingDelay;\n      _newProposal.endBlock = block.number + optimisticVotingDelay + votingPeriod;\n    }\n\n    proposals[_newProposal.id] = _newProposal;\n    latestProposalIds[_newProposal.proposer] = _newProposal.id;\n\n    emit ProposalCreatedIndexed(\n      _newProposal.id,\n      msg.sender,\n      _targets,\n      _values,\n      _signatures,\n      _calldatas,\n      _newProposal.startBlock,\n      _newProposal.endBlock,\n      _description\n    );\n\n    emit ProposalCreated(\n      _newProposal.id,\n      msg.sender,\n      _targets,\n      _values,\n      _signatures,\n      _calldatas,\n      _newProposal.startBlock,\n      _newProposal.endBlock,\n      _description\n    );\n    _proposalId = _newProposal.id;\n  }\n\n  /**\n   * @notice Queues a proposal of state succeeded\n   * @param _proposalId The id of the proposal to queue\n   */\n  function queue(uint256 _proposalId) external override {\n    if (state(_proposalId) != ProposalState.Succeeded) revert GovernorCharlie_ProposalNotSucceeded();\n    Proposal storage _proposal = proposals[_proposalId];\n    uint256 _eta = block.timestamp + _proposal.delay;\n    for (uint256 _i = 0; _i < _proposal.targets.length; _i++) {\n      if (\n        queuedTransactions[keccak256(\n          abi.encode(\n            _proposal.targets[_i], _proposal.values[_i], _proposal.signatures[_i], _proposal.calldatas[_i], _eta\n          )\n        )]\n      ) revert GovernorCharlie_ProposalAlreadyQueued();\n      _queueTransaction(\n        _proposal.targets[_i],\n        _proposal.values[_i],\n        _proposal.signatures[_i],\n        _proposal.calldatas[_i],\n        _eta,\n        _proposal.delay\n      );\n    }\n    _proposal.eta = _eta;\n    emit ProposalQueuedIndexed(_proposalId, _eta);\n    emit ProposalQueued(_proposalId, _eta);\n  }\n\n  /// @notice Queues a transaction\n  /// @param _target Target address for transaction\n  /// @param _value Eth value for transaction\n  /// @param _signature Function signature for transaction\n  /// @param _data Calldata for transaction\n  /// @param _eta Timestamp for transaction\n  /// @param _delay Delay for transaction\n  /// @return _txHash Transaction hash\n  function _queueTransaction(\n    address _target,\n    uint256 _value,\n    string memory _signature,\n    bytes memory _data,\n    uint256 _eta,\n    uint256 _delay\n  ) internal returns (bytes32 _txHash) {\n    if (_eta < (_getBlockTimestamp() + _delay)) revert GovernorCharlie_DelayNotReached();\n\n    _txHash = keccak256(abi.encode(_target, _value, _signature, _data, _eta));\n    queuedTransactions[_txHash] = true;\n\n    emit QueueTransaction(_txHash, _target, _value, _signature, _data, _eta);\n  }\n\n  /**\n   * @notice Executes a queued proposal if eta has passed\n   * @param _proposalId The id of the proposal to execute\n   */\n  function execute(uint256 _proposalId) external payable override {\n    if (state(_proposalId) != ProposalState.Queued) revert GovernorCharlie_ProposalNotQueued();\n    Proposal storage _proposal = proposals[_proposalId];\n    _proposal.executed = true;\n    for (uint256 _i = 0; _i < _proposal.targets.length; _i++) {\n      this.executeTransaction{value: _proposal.values[_i]}(\n        _proposal.targets[_i], _proposal.values[_i], _proposal.signatures[_i], _proposal.calldatas[_i], _proposal.eta\n      );\n    }\n    emit ProposalExecutedIndexed(_proposalId);\n    emit ProposalExecuted(_proposalId);\n  }\n\n  /// @notice Executes a transaction\n  /// @param _target Target address for transaction\n  /// @param _value Eth value for transaction\n  /// @param _signature Function signature for transaction\n  /// @param _data Calldata for transaction\n  /// @param _eta Timestamp for transaction\n  function executeTransaction(\n    address _target,\n    uint256 _value,\n    string memory _signature,\n    bytes memory _data,\n    uint256 _eta\n  ) external payable override {\n    if (msg.sender != address(this)) revert GovernorCharlie_NotGovernorCharlie();\n\n    bytes32 _txHash = keccak256(abi.encode(_target, _value, _signature, _data, _eta));\n    if (!queuedTransactions[_txHash]) revert GovernorCharlie_ProposalNotQueued();\n    if (_getBlockTimestamp() < _eta) revert GovernorCharlie_TimelockNotReached();\n    if (_getBlockTimestamp() > _eta + GRACE_PERIOD) revert GovernorCharlie_TransactionStale();\n\n    queuedTransactions[_txHash] = false;\n\n    bytes memory _callData;\n\n    if (bytes(_signature).length == 0) _callData = _data;\n    else _callData = abi.encodePacked(bytes4(keccak256(bytes(_signature))), _data);\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool _success, /*bytes memory returnData*/ ) = _target.call{value: _value}(_callData);\n    if (!_success) revert GovernorCharlie_TransactionReverted();\n\n    emit ExecuteTransaction(_txHash, _target, _value, _signature, _data, _eta);\n  }\n\n  /**\n   * @notice Cancels a proposal only if sender is the proposer, or proposer delegates dropped below proposal threshold\n   * @notice whitelistGuardian can cancel proposals from whitelisted addresses\n   * @param _proposalId The id of the proposal to cancel\n   */\n  function cancel(uint256 _proposalId) external override {\n    if (state(_proposalId) == ProposalState.Executed) revert GovernorCharlie_ProposalAlreadyExecuted();\n\n    Proposal storage _proposal = proposals[_proposalId];\n\n    // Proposer can cancel\n    if (msg.sender != _proposal.proposer) {\n      // Whitelisted proposers can't be canceled for falling below proposal threshold\n      if (isWhitelisted(_proposal.proposer)) {\n        if (\n          (amph.getPriorVotes(_proposal.proposer, (block.number - 1)) >= proposalThreshold)\n            || msg.sender != whitelistGuardian\n        ) revert GovernorCharlie_WhitelistedProposer();\n      } else {\n        if ((amph.getPriorVotes(_proposal.proposer, (block.number - 1)) >= proposalThreshold)) {\n          revert GovernorCharlie_ProposalAboveThreshold();\n        }\n      }\n    }\n\n    _proposal.canceled = true;\n    for (uint256 _i = 0; _i < _proposal.targets.length; _i++) {\n      _cancelTransaction(\n        _proposal.targets[_i], _proposal.values[_i], _proposal.signatures[_i], _proposal.calldatas[_i], _proposal.eta\n      );\n    }\n\n    emit ProposalCanceledIndexed(_proposalId);\n    emit ProposalCanceled(_proposalId);\n  }\n\n  /// @notice Cancels a transaction\n  /// @param _target Target address for transaction\n  /// @param _value Eth value for transaction\n  /// @param _signature Function signature for transaction\n  /// @param _data Calldata for transaction\n  /// @param _eta Timestamp for transaction\n  function _cancelTransaction(\n    address _target,\n    uint256 _value,\n    string memory _signature,\n    bytes memory _data,\n    uint256 _eta\n  ) internal {\n    bytes32 _txHash = keccak256(abi.encode(_target, _value, _signature, _data, _eta));\n    queuedTransactions[_txHash] = false;\n\n    emit CancelTransaction(_txHash, _target, _value, _signature, _data, _eta);\n  }\n\n  /**\n   * @notice Gets actions of a proposal\n   * @param _proposalId The id of the proposal\n   * @return _targets The proposal targets\n   * @return _values The proposal values\n   * @return _signatures The proposal signatures\n   * @return _calldatas The proposal calldata\n   */\n  function getActions(uint256 _proposalId)\n    external\n    view\n    override\n    returns (\n      address[] memory _targets,\n      uint256[] memory _values,\n      string[] memory _signatures,\n      bytes[] memory _calldatas\n    )\n  {\n    Proposal storage _proposal = proposals[_proposalId];\n    return (_proposal.targets, _proposal.values, _proposal.signatures, _proposal.calldatas);\n  }\n\n  /**\n   * @notice Returns the proposal\n   * @param _proposalId The id of proposal\n   * @return _proposal The proposal\n   */\n  function getProposal(uint256 _proposalId) external view returns (Proposal memory _proposal) {\n    _proposal = proposals[_proposalId];\n  }\n\n  /**\n   * @notice Gets the receipt for a voter on a given proposal\n   * @param _proposalId The id of proposal\n   * @param _voter The address of the voter\n   * @return _votingReceipt The voting receipt\n   */\n  function getReceipt(\n    uint256 _proposalId,\n    address _voter\n  ) external view override returns (Receipt memory _votingReceipt) {\n    _votingReceipt = proposalReceipts[_proposalId][_voter];\n  }\n\n  /**\n   * @notice Gets the state of a proposal\n   * @param _proposalId The id of the proposal\n   * @return _state Proposal state\n   */\n  // solhint-disable-next-line code-complexity\n  function state(uint256 _proposalId) public view override returns (ProposalState _state) {\n    if (proposalCount < _proposalId || _proposalId <= initialProposalId) revert GovernorCharlie_InvalidProposalId();\n    Proposal storage _proposal = proposals[_proposalId];\n    bool _whitelisted = isWhitelisted(_proposal.proposer);\n    if (_proposal.canceled) return ProposalState.Canceled;\n    else if (block.number <= _proposal.startBlock) return ProposalState.Pending;\n    else if (block.number <= _proposal.endBlock) return ProposalState.Active;\n    else if (\n      (_whitelisted && _proposal.againstVotes > _proposal.quorumVotes)\n        || (!_whitelisted && _proposal.forVotes <= _proposal.againstVotes)\n        || (!_whitelisted && _proposal.forVotes < _proposal.quorumVotes)\n    ) return ProposalState.Defeated;\n    else if (_proposal.eta == 0) return ProposalState.Succeeded;\n    else if (_proposal.executed) return ProposalState.Executed;\n    else if (block.timestamp >= (_proposal.eta + GRACE_PERIOD)) return ProposalState.Expired;\n    _state = ProposalState.Queued;\n  }\n\n  /**\n   * @notice Cast a vote for a proposal\n   * @param _proposalId The id of the proposal to vote on\n   * @param _support The support value for the vote. 0=against, 1=for, 2=abstain\n   */\n  function castVote(uint256 _proposalId, uint8 _support) external override {\n    uint96 _numberOfVotes = _castVoteInternal(msg.sender, _proposalId, _support);\n    emit VoteCastIndexed(msg.sender, _proposalId, _support, _numberOfVotes, '');\n    emit VoteCast(msg.sender, _proposalId, _support, _numberOfVotes, '');\n  }\n\n  /**\n   * @notice Cast a vote for a proposal with a reason\n   * @param _proposalId The id of the proposal to vote on\n   * @param _support The support value for the vote. 0=against, 1=for, 2=abstain\n   * @param _reason The reason given for the vote by the voter\n   */\n  function castVoteWithReason(uint256 _proposalId, uint8 _support, string calldata _reason) external override {\n    uint96 _numberOfVotes = _castVoteInternal(msg.sender, _proposalId, _support);\n    emit VoteCastIndexed(msg.sender, _proposalId, _support, _numberOfVotes, _reason);\n    emit VoteCast(msg.sender, _proposalId, _support, _numberOfVotes, _reason);\n  }\n\n  /**\n   * @notice Cast a vote for a proposal by signature\n   * @dev External override function that accepts EIP-712 signatures for voting on proposals.\n   */\n  function castVoteBySig(uint256 _proposalId, uint8 _support, uint8 _v, bytes32 _r, bytes32 _s) external override {\n    bytes32 _domainSeparator =\n      keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(NAME)), _getChainIdInternal(), address(this)));\n    bytes32 _structHash = keccak256(abi.encode(BALLOT_TYPEHASH, _proposalId, _support));\n\n    bytes32 _digest = keccak256(abi.encodePacked('\\x19\\x01', _domainSeparator, _structHash));\n\n    if (uint256(_s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n      revert GovernorCharlie_InvalidSignature();\n    }\n    address _signatory = ecrecover(_digest, _v, _r, _s);\n    if (_signatory == address(0)) revert GovernorCharlie_InvalidSignature();\n    uint96 _numberOfVotes = _castVoteInternal(_signatory, _proposalId, _support);\n    emit VoteCastIndexed(_signatory, _proposalId, _support, _numberOfVotes, '');\n    emit VoteCast(_signatory, _proposalId, _support, _numberOfVotes, '');\n  }\n\n  /**\n   * @notice Internal function that caries out voting logic\n   * @param _voter The voter that is casting their vote\n   * @param _proposalId The id of the proposal to vote on\n   * @param _support The support value for the vote. 0=against, 1=for, 2=abstain\n   * @return _numberOfVotes The number of votes cast\n   */\n  function _castVoteInternal(\n    address _voter,\n    uint256 _proposalId,\n    uint8 _support\n  ) internal returns (uint96 _numberOfVotes) {\n    if (state(_proposalId) != ProposalState.Active) revert GovernorCharlie_VotingClosed();\n    if (_support > 2) revert GovernorCharlie_InvalidVoteType();\n    Proposal storage _proposal = proposals[_proposalId];\n    Receipt storage _receipt = proposalReceipts[_proposalId][_voter];\n    if (_receipt.hasVoted) revert GovernorCharlie_AlreadyVoted();\n    uint96 _votes = amph.getPriorVotes(_voter, _proposal.startBlock);\n\n    if (_support == 0) _proposal.againstVotes = _proposal.againstVotes + _votes;\n    else if (_support == 1) _proposal.forVotes = _proposal.forVotes + _votes;\n    else if (_support == 2) _proposal.abstainVotes = _proposal.abstainVotes + _votes;\n\n    _receipt.hasVoted = true;\n    _receipt.support = _support;\n    _receipt.votes = _votes;\n\n    _numberOfVotes = _votes;\n  }\n\n  /**\n   * @notice View function which returns if an account is whitelisted\n   * @param _account Account to check white list status of\n   * @return _isWhitelisted If the account is whitelisted\n   */\n  function isWhitelisted(address _account) public view override returns (bool _isWhitelisted) {\n    return (whitelistAccountExpirations[_account] > block.timestamp);\n  }\n\n  /**\n   * @notice Governance function for setting the governance token\n   * @param  _token The new token address\n   */\n  function setNewToken(address _token) external onlyGov {\n    amph = IAMPH(_token);\n  }\n\n  /**\n   * @notice Governance function for setting the max whitelist period\n   * @param  _second How many seconds to whitelist for\n   */\n  function setMaxWhitelistPeriod(uint256 _second) external onlyGov {\n    maxWhitelistPeriod = _second;\n  }\n\n  /**\n   * @notice Used to update the timelock period\n   * @param _proposalTimelockDelay The proposal holding period\n   */\n  function setDelay(uint256 _proposalTimelockDelay) public override onlyGov {\n    uint256 _oldTimelockDelay = proposalTimelockDelay;\n    proposalTimelockDelay = _proposalTimelockDelay;\n\n    emit NewDelay(_oldTimelockDelay, proposalTimelockDelay);\n  }\n\n  /**\n   * @notice Used to update the emergency timelock period\n   * @param _emergencyTimelockDelay The proposal holding period\n   */\n  function setEmergencyDelay(uint256 _emergencyTimelockDelay) public override onlyGov {\n    uint256 _oldEmergencyTimelockDelay = emergencyTimelockDelay;\n    emergencyTimelockDelay = _emergencyTimelockDelay;\n\n    emit NewEmergencyDelay(_oldEmergencyTimelockDelay, emergencyTimelockDelay);\n  }\n\n  /**\n   * @notice Governance function for setting the voting delay\n   * @param _newVotingDelay The new voting delay, in blocks\n   */\n  function setVotingDelay(uint256 _newVotingDelay) external override onlyGov {\n    uint256 _oldVotingDelay = votingDelay;\n    votingDelay = _newVotingDelay;\n\n    emit VotingDelaySet(_oldVotingDelay, votingDelay);\n  }\n\n  /**\n   * @notice Governance function for setting the voting period\n   * @param _newVotingPeriod The new voting period, in blocks\n   */\n  function setVotingPeriod(uint256 _newVotingPeriod) external override onlyGov {\n    uint256 _oldVotingPeriod = votingPeriod;\n    votingPeriod = _newVotingPeriod;\n\n    emit VotingPeriodSet(_oldVotingPeriod, votingPeriod);\n  }\n\n  /**\n   * @notice Governance function for setting the emergency voting period\n   * @param _newEmergencyVotingPeriod The new voting period, in blocks\n   */\n  function setEmergencyVotingPeriod(uint256 _newEmergencyVotingPeriod) external override onlyGov {\n    uint256 _oldEmergencyVotingPeriod = emergencyVotingPeriod;\n    emergencyVotingPeriod = _newEmergencyVotingPeriod;\n\n    emit EmergencyVotingPeriodSet(_oldEmergencyVotingPeriod, emergencyVotingPeriod);\n  }\n\n  /**\n   * @notice Governance function for setting the proposal threshold\n   * @param _newProposalThreshold The new proposal threshold\n   */\n  function setProposalThreshold(uint256 _newProposalThreshold) external override onlyGov {\n    uint256 _oldProposalThreshold = proposalThreshold;\n    proposalThreshold = _newProposalThreshold;\n\n    emit ProposalThresholdSet(_oldProposalThreshold, proposalThreshold);\n  }\n\n  /**\n   * @notice Governance function for setting the quorum\n   * @param _newQuorumVotes The new proposal quorum\n   */\n  function setQuorumVotes(uint256 _newQuorumVotes) external override onlyGov {\n    uint256 _oldQuorumVotes = quorumVotes;\n    quorumVotes = _newQuorumVotes;\n\n    emit NewQuorum(_oldQuorumVotes, quorumVotes);\n  }\n\n  /**\n   * @notice Governance function for setting the emergency quorum\n   * @param _newEmergencyQuorumVotes The new proposal quorum\n   */\n  function setEmergencyQuorumVotes(uint256 _newEmergencyQuorumVotes) external override onlyGov {\n    uint256 _oldEmergencyQuorumVotes = emergencyQuorumVotes;\n    emergencyQuorumVotes = _newEmergencyQuorumVotes;\n\n    emit NewEmergencyQuorum(_oldEmergencyQuorumVotes, emergencyQuorumVotes);\n  }\n\n  /**\n   * @notice Governance function for setting the whitelist expiration as a timestamp\n   * for an account. Whitelist status allows accounts to propose without meeting threshold\n   * @param _account Account address to set whitelist expiration for\n   * @param _expiration Expiration for account whitelist status as timestamp (if now < expiration, whitelisted)\n   */\n  function setWhitelistAccountExpiration(address _account, uint256 _expiration) external override onlyGov {\n    if (_expiration >= (maxWhitelistPeriod + block.timestamp)) revert GovernorCharlie_ExpirationExceedsMax();\n    whitelistAccountExpirations[_account] = _expiration;\n\n    emit WhitelistAccountExpirationSet(_account, _expiration);\n  }\n\n  /**\n   * @notice Governance function for setting the whitelistGuardian. WhitelistGuardian can cancel proposals from whitelisted addresses\n   * @param _account Account to set whitelistGuardian to (0x0 to remove whitelistGuardian)\n   */\n  function setWhitelistGuardian(address _account) external override onlyGov {\n    address _oldGuardian = whitelistGuardian;\n    whitelistGuardian = _account;\n\n    emit WhitelistGuardianSet(_oldGuardian, whitelistGuardian);\n  }\n\n  /**\n   * @notice Governance function for setting the optimistic voting delay\n   * @param _newOptimisticVotingDelay The new optimistic voting delay, in blocks\n   */\n  function setOptimisticDelay(uint256 _newOptimisticVotingDelay) external override onlyGov {\n    uint256 _oldOptimisticVotingDelay = optimisticVotingDelay;\n    optimisticVotingDelay = _newOptimisticVotingDelay;\n\n    emit OptimisticVotingDelaySet(_oldOptimisticVotingDelay, optimisticVotingDelay);\n  }\n\n  /**\n   * @notice Governance function for setting the optimistic quorum\n   * @param _newOptimisticQuorumVotes The new optimistic quorum votes, in blocks\n   */\n  function setOptimisticQuorumVotes(uint256 _newOptimisticQuorumVotes) external override onlyGov {\n    uint256 _oldOptimisticQuorumVotes = optimisticQuorumVotes;\n    optimisticQuorumVotes = _newOptimisticQuorumVotes;\n\n    emit OptimisticQuorumVotesSet(_oldOptimisticQuorumVotes, optimisticQuorumVotes);\n  }\n\n  /// @notice Returns the timelock address\n  /// @param _timelock The timelock address\n  function timelock() external view override returns (address _timelock) {\n    _timelock = address(this);\n  }\n\n  /// @notice Returns the proposal time lock delay\n  /// @return _delay The proposal time lock delay\n  function delay() external view override returns (uint256 _delay) {\n    _delay = proposalTimelockDelay;\n  }\n\n  /// @notice Returns the chaid id of the blockchain\n  /// @return _chainId The chain id\n  function _getChainIdInternal() internal view returns (uint256 _chainId) {\n    _chainId = block.chainid;\n  }\n\n  /// @notice Returns the block timestamp\n  /// @return _timestamp The block timestamp\n  function _getBlockTimestamp() internal view returns (uint256 _timestamp) {\n    // solium-disable-next-line security/no-block-members\n    _timestamp = block.timestamp;\n  }\n}"
    },
    {
      "filename": "core/solidity/contracts/governance/GovernorCharlie.sol",
      "content": "// solhint-disable max-states-count\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\npragma experimental ABIEncoderV2;\n\nimport {IAMPH} from '@interfaces/governance/IAMPH.sol';\nimport {IGovernorCharlie} from '@interfaces/governance/IGovernorCharlie.sol';\n\nimport {Receipt, ProposalState, Proposal} from '@contracts/utils/GovernanceStructs.sol';\n\ncontract GovernorCharlie is IGovernorCharlie {\n  /// @notice The name of this contract\n  string public constant NAME = 'Amphora Protocol Governor';\n\n  /// @notice The maximum number of actions that can be included in a proposal\n  uint256 public constant PROPOSAL_MAX_OPERATIONS = 10;\n\n  /// @notice The EIP-712 typehash for the contract's domain\n  bytes32 public constant DOMAIN_TYPEHASH =\n    keccak256('EIP712Domain(string name,uint256 chainId,address verifyingContract)');\n\n  /// @notice The EIP-712 typehash for the ballot struct used by the contract\n  bytes32 public constant BALLOT_TYPEHASH = keccak256('Ballot(uint256 proposalId,uint8 support)');\n\n  /// @notice The time for a proposal to be executed after passing\n  uint256 public constant GRACE_PERIOD = 14 days;\n\n  /// @notice The number of votes in support of a proposal required in order for a quorum to"
    }
  ]
}