{
  "Title": "[M-03] No check for existing extraRewards during push",
  "Content": "_Submitted by cryptphi, also found by csanuragjain_\n\n<https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/VE3DRewardPool.sol#L138>\n\n<https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/VE3DLocker.sol#L156>\n\n### Impact\n\nSimilar to a report I submitted for BaseRewardPool.sol (<https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/BaseRewardPool.sol#L126>)\n\nWhen adding `extraRewards` to the extra reward pool in <https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/VE3DRewardPool.sol#L138> , there's no check for already existing address.\n\nAssume a particular address takes up 2 slots out of 3, and a user withdraws staked extra rewards, the user will receive double the amount requested in <https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/VE3DRewardPool.sol#L257-L258>\n\n### Proof of Concept\n\n1.  Assume `rewardManager` had mistakenly added the same address twice in `addExtraReward()`\n2.  A user calls `stake()` , linked rewards is staked twice to the same address (unexpected behaviour I guess but not severe issue)\n3.  Now, user calls `withdraw()` to withdraw linked rewards (this is already 2x in step 2)\n4.  User will receive double the linked rewards due to the iteration in `https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/VE3DRewardPool.sol#L257-L258`\n\n### Recommended Mitigation Steps\n\nGuess a check for an already existing extraRewards can be added before Line 138\n\n#### Similar issue\n<https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/VE3DLocker.sol#L156> - not so sure of the severity for this.\n\n<https://github.com/code-423n4/2022-05-vetoken/blob/main/contracts/BaseRewardPool.sol#L126>  - reported in a seperate report\n\n**[jetbrain10 (veToken Finannce) confirmed](https://github.com/code-423n4/2022-05-vetoken-findings/issues/89)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-05-vetoken-findings/issues/89#issuecomment-1189682693):**\n > The warden has shown how, due to a misconfiguration error, a leak of value can happen, and other depositors (late withdrawers) would lose the rewards that they are entitled to.\n> \n> Mitigation seems to be straightforward (add a duplicate check, or use a enumerableMap), that said, because of the risk of loss contingent on configuration, I agree with Medium Severity.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-vetoken-finance-contest",
  "Code": [
    {
      "filename": "contracts/VE3DRewardPool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n/**\n *Submitted for verification at Etherscan.io on 2020-07-17\n */\n\n/*\n   ____            __   __        __   _\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\n     /___/\n\n* Synthetix: vetokenRewardPool.sol\n*\n* Docs: https://docs.synthetix.io/\n*\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./Interfaces/IVeAssetDeposit.sol\";\nimport \"./Interfaces/IRewards.sol\";\n\ncontract VE3DRewardPool is Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    IERC20 public immutable stakingToken;\n    uint256 public constant duration = 7 days;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n\n    address public immutable rewardManager;\n\n    uint256 public constant newRewardRatio = 830;\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    // reward token => reward token info\n    mapping(address => RewardTokenInfo) public rewardTokenInfo;\n    // list of reward tokens\n    EnumerableSet.AddressSet internal rewardTokens;\n    EnumerableSet.AddressSet internal operators;\n\n    address[] public extraRewards;\n\n    struct RewardTokenInfo {\n        address veAssetDeposits;\n        address ve3TokenRewards;\n        address ve3Token;\n        uint256 queuedRewards;\n        uint256 rewardRate;\n        uint256 historicalRewards;\n        uint256 rewardPerTokenStored;\n        uint256 currentRewards;\n        uint256 periodFinish;\n        uint256 lastUpdateTime;\n        mapping(address => uint256) userRewardPerTokenPaid;\n        mapping(address => uint256) rewards;\n    }\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n\n    constructor(address stakingToken_, address rewardManager_) {\n        stakingToken = IERC20(stakingToken_);\n\n        rewardManager = rewardManager_;\n    }\n\n    function addReward(\n        address _rewardToken,\n        address _veAssetDeposits,\n        address _ve3TokenRewards,\n        address _ve3Token\n    ) external onlyOwner {\n        rewardTokenInfo[_rewardToken].veAssetDeposits = _veAssetDeposits;\n        rewardTokenInfo[_rewardToken].ve3TokenRewards = _ve3TokenRewards;\n        rewardTokenInfo[_rewardToken].ve3Token = _ve3Token;\n        rewardTokens.add(_rewardToken);\n    }\n\n    function addOperator(address _newOperator) public onlyOwner {\n        operators.add(_newOperator);\n    }\n\n    function removeOperator(address _operator) public onlyOwner {\n        operators.remove(_operator);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function extraRewardsLength() external view returns (uint256) {\n        return extraRewards.length;\n    }\n\n    function addExtraReward(address _reward) external {\n        require(msg.sender == rewardManager, \"!authorized\");\n        require(_reward != address(0), \"!reward setting\");\n\n        extraRewards.push(_reward);\n    }\n\n    function clearExtraRewards() external {\n        require(msg.sender == rewardManager, \"!authorized\");\n        delete extraRewards;\n    }\n\n    modifier updateReward(address account) {\n        address _rewardToken;\n        for (uint256 i = 0; i < rewardTokens.length(); i++) {\n            _rewardToken = rewardTokens.at(i);\n            rewardTokenInfo[_rewardToken].rewardPerTokenStored = rewardPerToken(_rewardToken);\n            rewardTokenInfo[_rewardToken].lastUpdateTime = lastTimeRewardApplicable(_rewardToken);\n            if (account != address(0)) {\n                rewardTokenInfo[_rewardToken].rewards[account] = earnedReward(\n                    _rewardToken,\n                    account\n                );\n                rewardTokenInfo[_rewardToken].userRewardPerTokenPaid[account] = rewardTokenInfo[\n                    _rewardToken\n                ].rewardPerTokenStored;\n            }\n        }\n\n        _;\n    }\n\n    function lastTimeRewardApplicable(address _rewardToken) public view returns (uint256) {\n        return Math.min(block.timestamp, rewardTokenInfo[_rewardToken].periodFinish);\n    }\n\n    function rewardPerToken(address _rewardToken) public view returns (uint256) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            return rewardTokenInfo[_rewardToken].rewardPerTokenStored;\n        }\n        return\n            rewardTokenInfo[_rewardToken].rewardPerTokenStored.add(\n                lastTimeRewardApplicable(_rewardToken)\n                    .sub(rewardTokenInfo[_rewardToken].lastUpdateTime)\n                    .mul(rewardTokenInfo[_rewardToken].rewardRate)\n                    .mul(1e18)\n                    .div(supply)\n            );\n    }\n\n    function earnedReward(address _rewardToken, address account) internal view returns (uint256) {\n        return\n            balanceOf(account)\n                .mul(\n                    rewardPerToken(_rewardToken).sub(\n                        rewardTokenInfo[_rewardToken].userRewardPerTokenPaid[account]\n                    )\n                )\n                .div(1e18)\n                .add(rewardTokenInfo[_rewardToken].rewards[account]);\n    }\n\n    function earned(address _rewardToken, address account) external view returns (uint256) {\n        uint256 depositFeeRate = IVeAssetDeposit(rewardTokenInfo[_rewardToken].veAssetDeposits)\n            .lockIncentive();\n\n        uint256 r = earnedReward(_rewardToken, account);\n        uint256 fees = r.mul(depositFeeRate).div(FEE_DENOMINATOR);\n\n        //fees dont apply until whitelist+veVeAsset lock begins so will report\n        //slightly less value than what is actually received.\n        return r.sub(fees);\n    }\n\n    function stake(uint256 _amount) public updateReward(msg.sender) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        //also stake to linked rewards\n        uint256 length = extraRewards.length;\n        for (uint256 i = 0; i < length; i++) {\n            IRewards(extraRewards[i]).stake(msg.sender, _amount);\n        }\n\n        //add supply\n        _totalSupply = _totalSupply.add(_amount);\n        //add to sender balance sheet\n        _balances[msg.sender] = _balances[msg.sender].add(_amount);\n        //take tokens from sender\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        emit Staked(msg.sender, _amount);\n    }\n\n    function stakeAll() external {\n        uint256 balance = stakingToken.balanceOf(msg.sender);\n        stake(balance);\n    }\n\n    function stakeFor(address _for, uint256 _amount) public updateReward(_for) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        //also stake to linked rewards\n        uint256 length = extraRewards.length;\n        for (uint256 i = 0; i < length; i++) {\n            IRewards(extraRewards[i]).stake(_for, _amount);\n        }\n\n        //add supply\n        _totalSupply = _totalSupply.add(_amount);\n        //add to _for's balance sheet\n        _balances[_for] = _balances[_for].add(_amount);\n        //take tokens from sender\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        emit Staked(msg.sender, _amount);\n    }\n\n    function withdraw(uint256 _amount, bool claim) public updateReward(msg.sender) {\n        require(_amount > 0, \"RewardPool : Cannot withdraw 0\");\n\n        //also withdraw from linked rewards\n        uint256 length = extraRewards.length;\n        for (uint256 i = 0; i < length; i++) {\n            IRewards(extraRewards[i]).withdraw(msg.sender, _amount);\n        }\n\n        _totalSupply = _totalSupply.sub(_amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(_amount);\n        stakingToken.safeTransfer(msg.sender, _amount);\n        emit Withdrawn(msg.sender, _amount);\n\n        if (claim) {\n            getReward(msg.sender, true, false);\n        }\n    }\n\n    function withdrawAll(bool claim) external {\n        withdraw(_balances[msg.sender], claim);\n    }\n\n    function getReward(\n        address _account,\n        bool _claimExtras,\n        bool _stake\n    ) public updateReward(_account) {\n        address _rewardToken;\n        for (uint256 i = 0; i < rewardTokens.length(); i++) {\n            _rewardToken = rewardTokens.at(i);\n\n            uint256 reward = earnedReward(_rewardToken, _account);\n            if (reward > 0) {\n                rewardTokenInfo[_rewardToken].rewards[_account] = 0;\n                IERC20(_rewardToken).safeApprove(rewardTokenInfo[_rewardToken].veAssetDeposits, 0);\n                IERC20(_rewardToken).safeApprove(\n                    rewardTokenInfo[_rewardToken].veAssetDeposits,\n                    reward\n                );\n                IVeAssetDeposit(rewardTokenInfo[_rewardToken].veAssetDeposits).deposit(\n                    reward,\n                    false\n                );\n\n                uint256 ve3TokenBalance = IERC20(rewardTokenInfo[_rewardToken].ve3Token).balanceOf(\n                    address(this)\n                );\n                if (_stake) {\n                    IERC20(rewardTokenInfo[_rewardToken].ve3Token).safeApprove(\n                        rewardTokenInfo[_rewardToken].ve3TokenRewards,\n                        0\n                    );\n                    IERC20(rewardTokenInfo[_rewardToken].ve3Token).safeApprove(\n                        rewardTokenInfo[_rewardToken].ve3TokenRewards,\n                        ve3TokenBalance\n                    );\n                    IRewards(rewardTokenInfo[_rewardToken].ve3TokenRewards).stakeFor(\n                        _account,\n                        ve3TokenBalance\n                    );\n                } else {\n                    IERC20(rewardTokenInfo[_rewardToken].ve3Token).safeTransfer(\n                        _account,\n                        ve3TokenBalance\n                    );\n                }\n                emit RewardPaid(_account, ve3TokenBalance);\n            }\n        }\n\n        //also get rewards from linked rewards\n        if (_claimExtras) {\n            uint256 length = extraRewards.length;\n            for (uint256 i = 0; i < length; i++) {\n                IRewards(extraRewards[i]).getReward(_account);\n            }\n        }\n    }\n\n    function getReward(bool _stake) external {\n        getReward(msg.sender, true, _stake);\n    }\n\n    function donate(address _rewardToken, uint256 _amount) external {\n        IERC20(_rewardToken).safeTransferFrom(msg.sender, address(this), _amount);\n        rewardTokenInfo[_rewardToken].queuedRewards += _amount;\n    }\n\n    function queueNewRewards(address _rewardToken, uint256 _rewards) external {\n        require(operators.contains(_msgSender()), \"!authorized\");\n\n        _rewards = _rewards.add(rewardTokenInfo[_rewardToken].queuedRewards);\n\n        if (block.timestamp >= rewardTokenInfo[_rewardToken].periodFinish) {\n            notifyRewardAmount(_rewardToken, _rewards);\n            rewardTokenInfo[_rewardToken].queuedRewards = 0;\n            return;\n        }\n\n        //et = now - (finish-duration)\n        uint256 elapsedTime = block.timestamp.sub(\n            rewardTokenInfo[_rewardToken].periodFinish.sub(duration)\n        );\n        //current at now: rewardRate * elapsedTime\n        uint256 currentAtNow = rewardTokenInfo[_rewardToken].rewardRate * elapsedTime;\n        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);\n        if (queuedRatio < newRewardRatio) {\n            notifyRewardAmount(_rewardToken, _rewards);\n            rewardTokenInfo[_rewardToken].queuedRewards = 0;\n        } else {\n            rewardTokenInfo[_rewardToken].queuedRewards = _rewards;\n        }\n    }\n\n    function notifyRewardAmount(address _rewardToken, uint256 reward)\n        internal\n        updateReward(address(0))\n    {\n        rewardTokenInfo[_rewardToken].historicalRewards += reward;\n        if (block.timestamp >= rewardTokenInfo[_rewardToken].periodFinish) {\n            rewardTokenInfo[_rewardToken].rewardRate = reward.div(duration);\n        } else {\n            uint256 remaining = rewardTokenInfo[_rewardToken].periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardTokenInfo[_rewardToken].rewardRate);\n            reward = reward.add(leftover);\n            rewardTokenInfo[_rewardToken].rewardRate = reward.div(duration);\n        }\n        rewardTokenInfo[_rewardToken].currentRewards = reward;\n        rewardTokenInfo[_rewardToken].lastUpdateTime = block.timestamp;\n        rewardTokenInfo[_rewardToken].periodFinish = block.timestamp.add(duration);\n        emit RewardAdded(reward);\n    }\n}"
    },
    {
      "filename": "contracts/VE3DLocker.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport \"./helper/MathUtil.sol\";\nimport \"./helper/BoringMath.sol\";\n\nimport \"./Interfaces/IVeAssetDeposit.sol\";\nimport \"./Interfaces/IRewards.sol\";\n\n/*\nVE3D Locking contract for https://www.convexfinance.com/\nVE3D locked in this contract will be entitled to voting rights for the Vetoken Finance platform\nBased on EPS Staking contract for http://ellipsis.finance/\nBased on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards\n\nV2:\n- change locking mechanism to lock to a future epoch instead of current\n- pending lock getter\n- relocking allocates weight to the current epoch instead of future,\n    thus allows keeping voting weight in the same epoch a lock expires by relocking before a vote begins\n- balanceAtEpoch and supplyAtEpoch return proper values for future epochs\n- do not allow relocking directly to a new address\n*/\ncontract VE3DLocker is ReentrancyGuard, Ownable {\n    using BoringMath for uint256;\n    using BoringMath224 for uint224;\n    using BoringMath112 for uint112;\n    using BoringMath32 for uint32;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /* ========== STATE VARIABLES ========== */\n\n    struct Reward {\n        bool isVeAsset;\n        uint40 periodFinish;\n        uint208 rewardRate;\n        uint40 lastUpdateTime;\n        uint208 rewardPerTokenStored;\n        address ve3Token;\n        address ve3TokenStaking;\n        address veAssetDeposits;\n    }\n    struct Balances {\n        uint112 locked;\n        uint32 nextUnlockIndex;\n    }\n    struct LockedBalance {\n        uint112 amount;\n        uint32 unlockTime;\n    }\n    struct EarnedData {\n        address token;\n        uint256 amount;\n    }\n    struct Epoch {\n        uint224 supply;\n        uint32 date; //epoch start date\n    }\n\n    //token\n    IERC20 public stakingToken; //VE3D\n\n    //rewards\n    address[] public rewardTokens;\n    mapping(address => Reward) public rewardData;\n\n    EnumerableSet.AddressSet internal operators;\n\n    // Duration that rewards are streamed over\n    uint256 public constant rewardsDuration = 86400 * 7;\n\n    // Duration of lock/earned penalty period\n    uint256 public constant lockDuration = rewardsDuration * 16;\n\n    // reward token -> distributor -> is approved to add rewards\n    mapping(address => mapping(address => bool)) public rewardDistributors;\n\n    // user -> reward token -> amount\n    mapping(address => mapping(address => uint256)) public userRewardPerTokenPaid;\n    mapping(address => mapping(address => uint256)) public rewards;\n\n    //supplies and epochs\n    uint256 public lockedSupply;\n    Epoch[] public epochs;\n\n    //mappings for balance data\n    mapping(address => Balances) public balances;\n    mapping(address => LockedBalance[]) public userLocks;\n\n    uint256 public constant denominator = 10000;\n\n    //management\n    uint256 public kickRewardPerEpoch = 100;\n    uint256 public kickRewardEpochDelay = 4;\n\n    //shutdown\n    bool public isShutdown = false;\n\n    //erc20-like interface\n    string private _name;\n    string private _symbol;\n    uint8 private immutable _decimals;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(address _stakingToken) Ownable() {\n        _name = \"Vote Locked Vetoken Token\";\n        _symbol = \"xVE3D\";\n        _decimals = 18;\n\n        stakingToken = IERC20(_stakingToken);\n\n        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function version() public pure returns (uint256) {\n        return 2;\n    }\n\n    /* ========== ADMIN CONFIGURATION ========== */\n\n    // Add a new reward token to be distributed to stakers\n    function addReward(\n        address _rewardsToken,\n        address _veAssetDeposits,\n        address _ve3Token,\n        address _ve3TokenStaking,\n        address _distributor,\n        bool _isVeAsset\n    ) external {\n        require(_msgSender() == owner() || operators.contains(_msgSender()), \"!Auth\");\n        require(rewardData[_rewardsToken].lastUpdateTime == 0);\n        require(_rewardsToken != address(stakingToken));\n        rewardTokens.push(_rewardsToken);\n\n        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);\n        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);\n        rewardDistributors[_rewardsToken][_distributor] = true;\n\n        rewardData[_rewardsToken].isVeAsset = _isVeAsset;\n        // if reward is veAsset\n        if (_isVeAsset) {\n            require(_ve3Token != address(0));\n            require(_ve3TokenStaking != address(0));\n            require(_veAssetDeposits != address(0));\n            rewardData[_rewardsToken].ve3Token = _ve3Token;\n            rewardData[_rewardsToken].ve3TokenStaking = _ve3TokenStaking;\n            rewardData[_rewardsToken].veAssetDeposits = _veAssetDeposits;\n        }\n    }\n\n    // Modify approval for an address to call notifyRewardAmount\n    function approveRewardDistributor(\n        address _rewardsToken,\n        address _distributor,\n        bool _approved\n    ) external onlyOwner {\n        require(rewardData[_rewardsToken].lastUpdateTime > 0);\n        rewardDistributors[_rewardsToken][_distributor] = _approved;\n    }\n\n    //set kick incentive\n    function setKickIncentive(uint256 _rate, uint256 _delay) external onlyOwner {\n        require(_rate <= 500, \"over max rate\"); //max 5% per epoch\n        require(_delay >= 2, \"min delay\"); //minimum 2 epochs of grace\n        kickRewardPerEpoch = _rate;\n        kickRewardEpochDelay = _delay;\n    }\n\n    //shutdown the contract. unstake all tokens. release all locks\n    function shutdown() external onlyOwner {\n        isShutdown = true;\n    }\n\n    function addOperator(address _newOperator) public onlyOwner {\n        operators.add(_newOperator);\n    }\n\n    function removeOperator(address _operator) public onlyOwner {\n        operators.remove(_operator);\n    }\n\n    //set approvals for locking veAsset and staking VE3Token\n    function setApprovals() external {\n        for (uint256 i; i < rewardTokens.length; i++) {\n            address _rewardsToken = rewardTokens[i];\n            if (rewardData[_rewardsToken].isVeAsset) {\n                // set approve for staking VE3Token\n                IERC20(rewardData[_rewardsToken].ve3Token).safeApprove(\n                    rewardData[_rewardsToken].ve3TokenStaking,\n                    0\n                );\n                IERC20(rewardData[_rewardsToken].ve3Token).safeApprove(\n                    rewardData[_rewardsToken].ve3TokenStaking,\n                    type(uint256).max\n                );\n\n                // set approve for locking veAsset\n                IERC20(_rewardsToken).safeApprove(rewardData[_rewardsToken].veAssetDeposits, 0);\n                IERC20(_rewardsToken).safeApprove(\n                    rewardData[_rewardsToken].veAssetDeposits,\n                    type(uint256).max\n                );\n            }\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function _rewardPerToken(address _rewardsToken) internal view returns (uint256) {\n        if (lockedSupply == 0) {\n            return rewardData[_rewardsToken].rewardPerTokenStored;\n        }\n        return\n            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(\n                _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish)\n                    .sub(rewardData[_rewardsToken].lastUpdateTime)\n                    .mul(rewardData[_rewardsToken].rewardRate)\n                    .mul(1e18)\n                    .div(lockedSupply)\n            );\n    }\n\n    function _earned(\n        address _user,\n        address _rewardsToken,\n        uint256 _balance\n    ) internal view returns (uint256) {\n        return\n            _balance\n                .mul(\n                    _rewardPerToken(_rewardsToken).sub(\n                        userRewardPerTokenPaid[_user][_rewardsToken]\n                    )\n                )\n                .div(1e18)\n                .add(rewards[_user][_rewardsToken]);\n    }\n\n    function _lastTimeRewardApplicable(uint256 _finishTime) internal view returns (uint256) {\n        return Math.min(block.timestamp, _finishTime);\n    }\n\n    function lastTimeRewardApplicable(address _rewardsToken) public view returns (uint256) {\n        return _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);\n    }\n\n    function rewardPerToken(address _rewardsToken) external view returns (uint256) {\n        return _rewardPerToken(_rewardsToken);\n    }\n\n    function getRewardForDuration(address _rewardsToken) external view returns (uint256) {\n        return uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);\n    }\n\n    // Address and claimable amount of all reward tokens for the given account\n    function claimableRewards(address _account)\n        external\n        view\n        returns (EarnedData[] memory userRewards)\n    {\n        userRewards = new EarnedData[](rewardTokens.length);\n        Balances storage userBalance = balances[_account];\n        for (uint256 i = 0; i < userRewards.length; i++) {\n            address token = rewardTokens[i];\n            userRewards[i].token = token;\n            userRewards[i].amount = _earned(_account, token, userBalance.locked);\n        }\n        return userRewards;\n    }\n\n    // total token balance of an account, including unlocked but not withdrawn tokens\n    function lockedBalanceOf(address _user) external view returns (uint256 amount) {\n        return balances[_user].locked;\n    }\n\n    //balance of an account which only includes properly locked tokens as of the most recent eligible epoch\n    function balanceOf(address _user) external view returns (uint256 amount) {\n        return balanceAtEpochOf(findEpochId(block.timestamp), _user);\n    }\n\n    //balance of an account which only includes properly locked tokens at the given epoch\n    function balanceAtEpochOf(uint256 _epoch, address _user) public view returns (uint256 amount) {\n        LockedBalance[] storage locks = userLocks[_user];\n\n        //get timestamp of given epoch index\n        uint256 epochTime = epochs[_epoch].date;\n        //get timestamp of first non-inclusive epoch\n        uint256 cutoffEpoch = epochTime.sub(lockDuration);\n\n        //need to add up since the range could be in the middle somewhere\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {\n            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);\n            //lock epoch must be less or equal to the epoch we're basing from.\n            if (lockEpoch <= epochTime) {\n                if (lockEpoch > cutoffEpoch) {\n                    amount = amount.add(locks[i].amount);\n                } else {\n                    //stop now as no futher checks matter\n                    break;\n                }\n            }\n        }\n\n        return amount;\n    }\n\n    //return currently locked but not active balance\n    function pendingLockOf(address _user) external view returns (uint256 amount) {\n        LockedBalance[] storage locks = userLocks[_user];\n\n        uint256 locksLength = locks.length;\n\n        //return amount if latest lock is in the future\n        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        if (\n            locksLength > 0 &&\n            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) > currentEpoch\n        ) {\n            return locks[locksLength - 1].amount;\n        }\n\n        return 0;\n    }\n\n    function pendingLockAtEpochOf(uint256 _epoch, address _user)\n        external\n        view\n        returns (uint256 amount)\n    {\n        LockedBalance[] storage locks = userLocks[_user];\n\n        //get next epoch from the given epoch index\n        uint256 nextEpoch = uint256(epochs[_epoch].date).add(rewardsDuration);\n\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {\n            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);\n\n            //return the next epoch balance\n            if (lockEpoch == nextEpoch) {\n                return locks[i].amount;\n            } else if (lockEpoch < nextEpoch) {\n                //no need to check anymore\n                break;\n            }\n        }\n\n        return 0;\n    }\n\n    //supply of all properly locked balances at most recent eligible epoch\n    function totalSupply() external view returns (uint256 supply) {\n        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);\n        uint256 epochindex = epochs.length;\n\n        //do not include next epoch's supply\n        if (uint256(epochs[epochindex - 1].date) > currentEpoch) {\n            epochindex--;\n        }\n\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {\n            Epoch storage e = epochs[i];\n            if (uint256(e.date) <= cutoffEpoch) {\n                break;\n            }\n            supply = supply.add(e.supply);\n        }\n\n        return supply;\n    }\n\n    //supply of all properly locked balances at the given epoch\n    function totalSupplyAtEpoch(uint256 _epoch) external view returns (uint256 supply) {\n        uint256 epochStart = uint256(epochs[_epoch].date).div(rewardsDuration).mul(\n            rewardsDuration\n        );\n        uint256 cutoffEpoch = epochStart.sub(lockDuration);\n\n        //traverse inversely to make more current queries more gas efficient\n        for (uint256 i = _epoch; i + 1 != 0; i--) {\n            Epoch storage e = epochs[i];\n            if (uint256(e.date) <= cutoffEpoch) {\n                break;\n            }\n            supply = supply.add(epochs[i].supply);\n        }\n\n        return supply;\n    }\n\n    //find an epoch index based on timestamp\n    function findEpochId(uint256 _time) public view returns (uint256 epoch) {\n        uint256 max = epochs.length - 1;\n        uint256 min = 0;\n\n        //convert to start point\n        _time = _time.div(rewardsDuration).mul(rewardsDuration);\n\n        for (uint256 i = 0; i < 128; i++) {\n            if (min >= max) break;\n\n            uint256 mid = (min + max + 1) / 2;\n            uint256 midEpochBlock = epochs[mid].date;\n            if (midEpochBlock == _time) {\n                //found\n                return mid;\n            } else if (midEpochBlock < _time) {\n                min = mid;\n            } else {\n                max = mid - 1;\n            }\n        }\n        return min;\n    }\n\n    // Information on a user's locked balances\n    function lockedBalances(address _user)\n        external\n        view\n        returns (\n            uint256 total,\n            uint256 unlockable,\n            uint256 locked,\n            LockedBalance[] memory lockData\n        )\n    {\n        LockedBalance[] storage locks = userLocks[_user];\n        Balances storage userBalance = balances[_user];\n        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;\n        uint256 idx;\n        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {\n            if (locks[i].unlockTime > block.timestamp) {\n                if (idx == 0) {\n                    lockData = new LockedBalance[](locks.length - i);\n                }\n                lockData[idx] = locks[i];\n                idx++;\n                locked = locked.add(locks[i].amount);\n            } else {\n                unlockable = unlockable.add(locks[i].amount);\n            }\n        }\n        return (userBalance.locked, unlockable, locked, lockData);\n    }\n\n    //number of epochs\n    function epochCount() external view returns (uint256) {\n        return epochs.length;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function checkpointEpoch() external {\n        _checkpointEpoch();\n    }\n\n    //insert a new epoch if needed. fill in any gaps\n    function _checkpointEpoch() internal {\n        //create new epoch in the future where new non-active locks will lock to\n        uint256 nextEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration).add(\n            rewardsDuration\n        );\n        uint256 epochindex = epochs.length;\n\n        //first epoch add in constructor, no need to check 0 length\n\n        //check to add\n        if (epochs[epochindex - 1].date < nextEpoch) {\n            //fill any epoch gaps\n            while (epochs[epochs.length - 1].date != nextEpoch) {\n                uint256 nextEpochDate = uint256(epochs[epochs.length - 1].date).add(\n                    rewardsDuration\n                );\n                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));\n            }\n        }\n    }\n\n    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards\n    function lock(address _account, uint256 _amount) external nonReentrant updateReward(_account) {\n        //pull tokens\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        //lock\n        _lock(_account, _amount, false);\n    }\n\n    //lock tokens\n    function _lock(\n        address _account,\n        uint256 _amount,\n        bool _isRelock\n    ) internal {\n        require(_amount > 0, \"Cannot stake 0\");\n        require(!isShutdown, \"shutdown\");\n\n        Balances storage bal = balances[_account];\n\n        //must try check pointing epoch first\n        _checkpointEpoch();\n\n        //add user balances\n        uint112 lockAmount = _amount.to112();\n        bal.locked = bal.locked.add(lockAmount);\n\n        //add to total supplies\n        lockedSupply = lockedSupply.add(lock"
    }
  ]
}