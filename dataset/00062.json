{
  "Title": "Lack of Input Parameter Validation",
  "Content": "The [`resolverPercentageThreshold` variable](https://github.com/1inch/limit-order-settlement/blob/ff7909c4f32bee8879211607275dc30d788afee8/contracts/WhitelistRegistry.sol#L40) stores the percentage of the total supply that an address has to stake in order to become a resolver. This percentage should never be higher than 100% but [this is not enforced by the protocol](https://github.com/1inch/limit-order-settlement/blob/ff7909c4f32bee8879211607275dc30d788afee8/contracts/WhitelistRegistry.sol#L125-L128). In extreme cases, this might prevent the whitelist from functioning. For example, if `resolverPercentageThreshold` is set to `type(uint256).max`, it is not possible to [clean](https://github.com/1inch/limit-order-settlement/blob/ff7909c4f32bee8879211607275dc30d788afee8/contracts/WhitelistRegistry.sol#L142C14-L142C20) the whitelist anymore as the check overflows.\n\n\nConsider adding a check that the percentage is less than 100% when setting it.\n\n\n***Update:** Resolved in [pull request #138](https://github.com/1inch/limit-order-settlement/pull/138) at commits [3196ff8](https://github.com/1inch/limit-order-settlement/commit/3196ff8c1ebbfbc140840c20a992aa1fdf9dd735) and [921a6b3](https://github.com/1inch/limit-order-settlement/commit/921a6b3ad2e21fbb8279234facbaf78b9803fa77). The `resolverPercentageThreshold` variable can no longer be set to a value larger than 100%.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/WhitelistRegistry.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"@1inch/solidity-utils/contracts/libraries/UniERC20.sol\";\nimport \"@1inch/solidity-utils/contracts/libraries/AddressSet.sol\";\nimport \"@1inch/st1inch/contracts/interfaces/IVotable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title WhitelistRegistry\n * @notice The contract manages a whitelist for trading resolvers, providing functions to register,\n * promote and remove addresses, as well as setting various thresholds and limits. It also includes an\n * emergency rescue function for tokens sent to the contract accidentally.\n */\ncontract WhitelistRegistry is Ownable {\n    using UniERC20 for IERC20;\n    using AddressSet for AddressSet.Data;\n    using AddressArray for AddressArray.Data;\n\n    error BalanceLessThanThreshold();\n    error AlreadyRegistered();\n    error NotWhitelisted();\n    error SamePromotee();\n\n    /// @notice Emitted after a new resolver is registered.\n    event Registered(address addr);\n    /// @notice Emitted when a resolver is pushed out of whitelist.\n    event Unregistered(address addr);\n    /// @notice Emitted when the new minimum total supply percentage to get into the whitelist is set.\n    event ResolverPercentageThresholdSet(uint256 resolverPercentageThreshold);\n    /// @notice Emitted when a new worker for a resolver is set.\n    event Promotion(address promoter, uint256 chainId, address promotee);\n\n    uint256 public constant BASIS_POINTS = 10000;\n    IVotable public immutable token;\n\n    mapping(address => mapping(uint256 => address)) public promotions;\n    // 100% = 10000, 10% = 1000, 1% = 100\n    uint256 public resolverPercentageThreshold;\n\n    AddressSet.Data private _whitelist;\n\n    constructor(\n        IVotable token_,\n        uint256 resolverPercentageThreshold_\n    ) {\n        token = token_;\n        _setResolverPercentageThreshold(resolverPercentageThreshold_);\n    }\n\n    /**\n     * @notice Allows the contract owner to recover any tokens accidentally sent to the contract.\n     * @param token_ The token to recover.\n     * @param amount The amount of tokens to recover.\n     */\n    function rescueFunds(IERC20 token_, uint256 amount) external onlyOwner {\n        token_.uniTransfer(payable(msg.sender), amount);\n    }\n\n    /**\n     * @notice Allows the contract owner to set a new resolver threshold.\n     * The resolver threshold is the minimum total supply percentage required to get into the whitelist.\n     * @param resolverPercentageThreshold_ The new resolver threshold.\n     */\n    function setResolverPercentageThreshold(uint256 resolverPercentageThreshold_) external onlyOwner {\n        _setResolverPercentageThreshold(resolverPercentageThreshold_);\n    }\n\n\n    /**\n     * @notice Attempts to register the caller in the whitelist.\n     * @dev Reverts if the caller's total supply percentage is below the resolver threshold.\n     */\n    function register() external {\n        uint256 percentageThreshold = resolverPercentageThreshold;\n        uint256 totalSupply = token.totalSupply();\n        if (!_isValidBalance(percentageThreshold, token.balanceOf(msg.sender), totalSupply)) revert BalanceLessThanThreshold();\n        if (!_whitelist.add(msg.sender)) revert AlreadyRegistered();\n        emit Registered(msg.sender);\n        _clean(percentageThreshold, totalSupply);\n    }\n\n    /**\n     * @notice Registers a worker for the resolver to settle orders.\n     * @param chainId The chain ID where the worker will assigned.\n     * @param promotee The worker's address.\n     */\n    function promote(uint256 chainId, address promotee) external {\n        if (promotions[msg.sender][chainId] == promotee) revert SamePromotee();\n        promotions[msg.sender][chainId] = promotee;\n        emit Promotion(msg.sender, chainId, promotee);\n    }\n\n    /**\n     * @notice Cleans the whitelist by removing addresses that fall below the resolver threshold.\n     */\n    function clean() external {\n        _clean(resolverPercentageThreshold, token.totalSupply());\n    }\n\n    /**\n     * @notice Returns the addresses in the whitelist.\n     * @return whitelist A list of whitelisted addresses.\n     */\n    function getWhitelist() external view returns (address[] memory /* whitelist */) {\n        return _whitelist.items.get();\n    }\n\n    /**\n     * @notice Returns the worker list for a particular chain ID.\n     * @param chainId The chain ID to get the promoted addresses for.\n     * @return promotees A list of worker addresses.\n     */\n    function getPromotees(uint256 chainId) external view returns (address[] memory promotees) {\n        promotees = _whitelist.items.get();\n        unchecked {\n            uint256 len = promotees.length;\n            for (uint256 i = 0; i < len; ++i) {\n                promotees[i] = promotions[promotees[i]][chainId];\n            }\n        }\n    }\n\n    function _setResolverPercentageThreshold(uint256 resolverPercentageThreshold_) private {\n        resolverPercentageThreshold = resolverPercentageThreshold_;\n        emit ResolverPercentageThresholdSet(resolverPercentageThreshold_);\n    }\n\n    function _removeFromWhitelist(address account) private {\n        _whitelist.remove(account);\n        emit Unregistered(account);\n    }\n\n    function _isValidBalance(uint256 percentageThreshold, uint256 balance, uint256 totalSupply) private pure returns (bool) {\n        return (\n            balance > 0 &&\n            balance * BASIS_POINTS >= totalSupply * percentageThreshold)\n        ;\n    }\n\n    function _clean(uint256 percentageThreshold, uint256 totalSupply) private {\n        uint256 whitelistLength = _whitelist.length();\n        unchecked {\n            for (uint256 i = 0; i < whitelistLength; ) {\n                address curWhitelisted = _whitelist.at(i);\n                uint256 balance = token.balanceOf(curWhitelisted);\n                if (!_isValidBalance(percentageThreshold, balance, totalSupply)) {\n                    _removeFromWhitelist(curWhitelisted);\n                    whitelistLength--;\n                } else {\n                    i++;\n                }\n            }\n        }\n    }\n}"
    }
  ]
}