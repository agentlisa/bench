{
  "Title": "[C04] Users can claim unreleased rewards or have their funds locked",
  "Content": "The [`FeiPool` contract](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pool/FeiPool.sol) allows users to [deposit](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pool/Pool.sol#L46) `FEI/TRIBE` liquidity pool (LP) tokens into the Fei Pool to accrue `TRIBE` tokens as a reward. After some time, users may want to [withdraw](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pool/Pool.sol#L52) their LP tokens and get the accrued rewards. To track users’ staked amounts and the total staked amount in the pool, the contract defines the `stakedBalance` and `totalStaked` variables, respectively. These are [incremented](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pool/Pool.sol#L122-L123) each time a user deposits liquidity pool tokens into the pool.\n\n\nWhen a user withdraws their staked tokens and accrued rewards, [only the user’s `stakedBalance` is updated](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pool/Pool.sol#L133), while the `totalStaked` variable remains the same. Since the [`redeemableRewards` function](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pool/Pool.sol#L66) depends on the `totalStaked` variable to compute the amount of redeemable rewards in the [`_totalRedeemablePoolTokens` function](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pool/Pool.sol#L102), the total amount of redeemable tokens for the user is miscalculated, resulting in more tokens being released than what was intended.\n\n\nAdditionally, since the Fei Pool’s total supply of tokens decreases during [claims](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pool/Pool.sol#L147) and [withdrawals](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pool/Pool.sol#L138), while the `totalStaked` variable is unchanged, the [`balance` variable](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pool/Pool.sol#L102) from the `_totalRedeemablePoolTokens` function could become greater than the [`total` variable](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pool/Pool.sol#L108). This would prevent users from claiming rewards and withdrawing their stake due to [a “Redeemable underflow” require statement](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pool/Pool.sol#L110).\n\n\nConsider decrementing the `totalStaked` variable in the [`_withdraw`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pool/Pool.sol#L131) function to accurately track the total stake in the pool and avoid these scenarios.\n\n\n**Update:** *Fixed in [PR#19](https://github.com/fei-protocol/fei-protocol-core/pull/19). The `totalStaked` amount is now being decremented in the `_withdraw` function.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/pool/Pool.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./IPool.sol\";\nimport \"../utils/Timed.sol\";\nimport \"../utils/SafeMath128.sol\";\nimport \"../external/SafeMathCopy.sol\";\nimport \"../external/Decimal.sol\";\n\n/// @title abstract implementation of IPool interface\n/// @author Fei Protocol\nabstract contract Pool is IPool, ERC20, ERC20Burnable, Timed {\n\tusing Decimal for Decimal.D256;\n\tusing SafeMath128 for uint128;\n\tusing SafeCast for uint;\n\n\tbool internal initialized;\n\n\tIERC20 public override rewardToken;\n\tIERC20 public override stakedToken;\n\n\tuint128 public override claimedRewards;\n\tuint128 public override totalStaked;\n\n    mapping (address => uint) public override stakedBalance;\n\n\t/// @notice Pool constructor\n\t/// @param _duration duration of the pool reward distribution\n\t/// @param _name the name of the pool token\n\t/// @param _ticker the token ticker for the pool token\n\tconstructor(\n\t\tuint32 _duration,\n\t\tstring memory _name,\n\t\tstring memory _ticker\n\t) public ERC20(_name, _ticker) Timed(_duration) {}\n\n\tfunction claim(address from, address to) external override returns(uint amountReward) {\n\t\tamountReward = _claim(from, to);\n\t\temit Claim(from, to, amountReward);\n\t\treturn amountReward;\n\t}\n\n\tfunction deposit(address to, uint amount) external override {\n\t\taddress from = msg.sender;\n\t\t_deposit(from, to, amount);\n\t\temit Deposit(from, to, amount);\n\t}\n\n\tfunction withdraw(address to) external override returns(uint amountStaked, uint amountReward) {\n\t\taddress from = msg.sender;\n\t\tamountReward = _claim(from, to);\n\t\tamountStaked = _withdraw(from, to);\n\t\temit Withdraw(from, to, amountStaked, amountReward);\n\t\treturn (amountStaked, amountReward);\n\t}\n\n\tfunction init() public override virtual {\n\t\trequire(!initialized, \"Pool: Already initialized\");\n\t\t_initTimed();\n\t\tinitialized = true;\n\t}\n\n    function redeemableReward(address account) public view override returns(uint amountReward, uint amountPool) {\n\t\tamountPool = _redeemablePoolTokens(account);\n\t\treturn (releasedReward() * amountPool / _totalRedeemablePoolTokens(), amountPool);\n    }\n\n\tfunction releasedReward() public view override returns (uint) {\n\t\tuint total = rewardBalance();\n\t\tuint unreleased = unreleasedReward();\n\t\trequire(total >= unreleased, \"Pool: Released Reward underflow\");\n\t\treturn total - unreleased;\n\t}\n\n\tfunction unreleasedReward() public view override returns (uint) {\n\t\tif (isTimeEnded()) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn _unreleasedReward(totalReward(), uint(duration), uint(timestamp()));\n\t}\n\n\tfunction totalReward() public view override returns (uint) {\n\t\treturn rewardBalance() + uint(claimedRewards);\n\t}\n\n\tfunction rewardBalance() public view override returns (uint) {\n\t\treturn rewardToken.balanceOf(address(this));\n\t}\n\n\tfunction burnFrom(address account, uint amount) public override {\n\t\tif (msg.sender == account) {\n\t\t\tincreaseAllowance(account, amount);\n\t\t}\n\t\tsuper.burnFrom(account, amount);\n\t}\n\n\tfunction _totalRedeemablePoolTokens() internal view returns(uint) {\n\t\tuint total = totalSupply();\n\t\tuint balance = _twfb(uint(totalStaked));\n\t\trequire(total >= balance, \"Pool: Total redeemable underflow\");\n\t\treturn total - balance;\n\t}\n\n\tfunction _redeemablePoolTokens(address account) internal view returns(uint) {\n\t\tuint total = balanceOf(account);\n\t\tuint balance = _twfb(stakedBalance[account]);\n\t\trequire(total >= balance, \"Pool: Redeemable underflow\");\n\t\treturn total - balance;\n\t}\n\n\tfunction _unreleasedReward(uint _totalReward, uint _duration, uint _time) internal view virtual returns (uint);\n\n\tfunction _deposit(address from, address to, uint amount) internal {\n\t\trequire(initialized, \"Pool: Uninitialized\");\n\t\trequire(amount <= stakedToken.balanceOf(from), \"Pool: Balance too low to stake\");\n\n\t\tstakedToken.transferFrom(from, address(this), amount);\n\n\t\tstakedBalance[to] += amount;\n\t\t_incrementStaked(amount);\n\t\t\n\t\tuint poolTokens = _twfb(amount);\n\t\trequire(poolTokens != 0, \"Pool: Window has ended\");\n\n\t\t_mint(to, poolTokens);\n\t}\n\n\tfunction _withdraw(address from, address to) internal returns(uint amountStaked) {\n\t\tamountStaked = stakedBalance[from];\n\t\tstakedBalance[from] = 0;\n\t\tstakedToken.transfer(to, amountStaked);\n\n\t\tuint amountPool = balanceOf(from);\n\t\tif (amountPool != 0) {\n\t\t\t_burn(from, amountPool);\n\t\t}\n\t\treturn amountStaked;\t\n\t}\n\n\tfunction _claim(address from, address to) internal returns(uint) {\n\t\t(uint amountReward, uint amountPool) = redeemableReward(from);\n\t\trequire(amountPool != 0, \"Pool: User has no redeemable pool tokens\");\n\n\t\tburnFrom(from, amountPool);\n\t\t_incrementClaimed(amountReward);\n\n\t\trewardToken.transfer(to, amountReward);\n\t\treturn amountReward;\n\t}\n\n\tfunction _incrementClaimed(uint amount) internal {\n\t\tclaimedRewards = claimedRewards.add(amount.toUint128());\n\t}\n\n\tfunction _incrementStaked(uint amount) internal {\n\t\ttotalStaked = totalStaked.add(amount.toUint128());\n\t}\n\n\tfunction _twfb(uint amount) internal view returns(uint) {\n\t\treturn amount * uint(remainingTime());\n\t}\n\n\t// Updates stored staked balance pro-rata for transfer and transferFrom\n\tfunction _beforeTokenTransfer(address from, address to, uint amount) internal override {\n        if (from != address(0) && to != address(0)) {\n \t\t\tDecimal.D256 memory ratio = Decimal.ratio(amount, balanceOf(from));\n \t\t\tuint amountStaked = ratio.mul(stakedBalance[from]).asUint256();\n\t\t\t\n \t\t\tstakedBalance[from] -= amountStaked;\n \t\t\tstakedBalance[to] += amountStaked;\n        }\n    }\n\n\tfunction _setTokens(address _rewardToken, address _stakedToken) internal {\n\t\trewardToken = IERC20(_rewardToken);\n\t\tstakedToken = IERC20(_stakedToken);\t\n\t}\n}"
    },
    {
      "filename": "contracts/pool/Pool.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./IPool.sol\";\nimport \"../utils/Timed.sol\";\nimport \"../utils/SafeMath128.sol\";\nimport \"../external/SafeMathCopy.sol\";\nimport \"../external/Decimal.sol\";\n\n/// @title abstract implementation of IPool interface\n/// @author Fei Protocol\nabstract contract Pool is IPool, ERC20, ERC20Burnable, Timed {\n\tusing Decimal for Decimal.D256;\n\tusing SafeMath128 for uint128;\n\tusing SafeCast for uint;\n\n\tbool internal initialized;\n\n\tIERC20 public override rewardToken;\n\tIERC20 public override stakedToken;\n\n\tuint128 public override claimedRewards;\n\tuint128 public override totalStaked;\n\n    mapping (address => uint) public override stakedBalance;\n\n\t/// @notice Pool constructor\n\t/// @param _duration duration of the pool reward distribution\n\t/// @param _name the name of the pool token\n\t/// @param _ticker the token ticker for the pool token\n\tconstructor(\n\t\tuint32 _duration,\n\t\tstring memory _name,\n\t\tstring memory _ticker\n\t) public ERC20(_name, _ticker) Timed(_duration) {}\n\n\tfunction claim(address from, address to) external override returns(uint amountReward) {\n\t\tamountReward = _claim(from, to);\n\t\temit Claim(from, to, amountReward);\n\t\treturn amountReward;\n\t}\n\n\tfunction deposit(address to, uint amount) external override {\n\t\taddress from = msg.sender;\n\t\t_deposit(from, to, amount);\n\t\temit Deposit(from, to, amount);\n\t}\n\n\tfunction withdraw(address to) external override returns(uint amountStaked, uint amountReward) {\n\t\taddress from = msg.sender;\n\t\tamountReward = _claim(from, to);\n\t\tamountStaked = _withdraw(from, to);\n\t\temit Withdraw(from, to, amountStaked, amountReward);\n\t\treturn (amountStaked, amountReward);\n\t}\n\n\tfunction init() public override virtual {\n\t\trequire(!initialized, \"Pool: Already initialized\");\n\t\t_initTimed();\n\t\tinitialized = true;\n\t}\n\n    function redeemableReward(address account) public view override returns(uint amountReward, uint amountPool) {\n\t\tamountPool = _redeemablePoolTokens(account);\n\t\treturn (releasedReward() * amountPool / _totalRedeemablePoolTokens(), amountPool);\n    }\n\n\tfunction releasedReward() public view override returns (uint) {\n\t\tuint total = rewardBalance();\n\t\tuint unreleased = unreleasedReward();\n\t\trequire(total >= unreleased, \"Pool: Released Reward underflow\");\n\t\treturn total - unreleased;\n\t}\n\n\tfunction unreleasedReward() public view override returns (uint) {\n\t\tif (isTimeEnded()) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn _unreleasedReward(totalReward(), uint(duration), uint(timestamp()));\n\t}\n\n\tfunction totalReward() public view override returns (uint) {\n\t\treturn rewardBalance() + uint(claimedRewards);\n\t}\n\n\tfunction rewardBalance() public view override returns (uint) {\n\t\treturn rewardToken.balanceOf(address(this));\n\t}\n\n\tfunction burnFrom(address account, uint amount) public override {\n\t\tif (msg.sender == account) {\n\t\t\tincreaseAllowance(account, amount);\n\t\t}\n\t\tsuper.burnFrom(account, amount);\n\t}\n\n\tfunction _totalRedeemablePoolTokens() internal view returns(uint) {\n\t\tuint total = totalSupply();\n\t\tuint balance = _twfb(uint(totalStaked));\n\t\trequire(total >= balance, \"Pool: Total redeemable underflow\");\n\t\treturn total - balance;\n\t}\n\n\tfunction _redeemablePoolTokens(address account) internal view returns(uint) {\n\t\tuint total = balanceOf(account);\n\t\tuint balance = _twfb(stakedBalance[account]);\n\t\trequire(total >= balance, \"Pool: Redeemable underflow\");\n\t\treturn total - balance;\n\t}\n\n\tfunction _unreleasedReward(uint _totalReward, uint _duration, uint _time) internal view virtual returns (uint);\n\n\tfunction _deposit(address from, address to, uint amount) internal {\n\t\trequire(initialized, \"Pool: Uninitialized\");\n\t\trequire(amount <= stakedToken.balanceOf(from), \"Pool: Balance too low to stake\");\n\n\t\tstakedToken.transferFrom(from, address(this), amount);\n\n\t\tstakedBalance[to] += amount;\n\t\t_incrementStaked(amount);\n\t\t\n\t\tuint poolTokens = _twfb(amount);\n\t\trequire(poolTokens != 0, \"Pool: Window has ended\");\n\n\t\t_mint(to, poolTokens);\n\t}\n\n\tfunction _withdraw(address from, address to) internal returns(uint amountStaked) {\n\t\tamountStaked = stakedBalance[from];\n\t\tstakedBalance[from] = 0;\n\t\tstakedToken.transfer(to, amountStaked);\n\n\t\tuint amountPool = balanceOf(from);\n\t\tif (amountPool != 0) {\n\t\t\t_burn(from, amountPool);\n\t\t}\n\t\treturn amountStaked;\t\n\t}\n\n\tfunction _claim(address from, address to) internal returns(uint) {\n\t\t(uint amountReward, uint amountPool) = redeemableReward(from);\n\t\trequire(amountPool != 0, \"Pool: User has no redeemable pool tokens\");\n\n\t\tburnFrom(from, amountPool);\n\t\t_incrementClaimed(amountReward);\n\n\t\trewardToken.transfer(to, amountReward);\n\t\treturn amountReward;\n\t}\n\n\tfunction _incrementClaimed(uint amount) internal {\n\t\tclaimedRewards = claimedRewards.add(amount.toUint128());\n\t}\n\n\tfunction _incrementStaked(uint amount) internal {\n\t\ttotalStaked = totalStaked.add(amount.toUint128());\n\t}\n\n\tfunction _twfb(uint amount) internal view returns(uint) {\n\t\treturn amount * uint(remainingTime());\n\t}\n\n\t// Updates stored staked balance pro-rata for transfer and transferFrom\n\tfunction _beforeTokenTransfer(address from, address to, uint amount) internal override {\n        if (from != address(0) && to != address(0)) {\n \t\t\tDecimal.D256 memory ratio = Decimal.ratio(amount, balanceOf(from));\n \t\t\tuint amountStaked = ratio.mul(stakedBalance[from]).asUint256();\n\t\t\t\n \t\t\tstakedBalance[from] -= amountStaked;\n \t\t\tstakedBalance[to] += amountStaked;\n        }\n    }\n\n\tfunction _setTokens(address _rewardToken, address _stakedToken) internal {\n\t\trewardToken = IERC20(_rewardToken);\n\t\tstakedToken = IERC20(_stakedToken);\t\n\t}\n}"
    },
    {
      "filename": "contracts/pool/Pool.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./IPool.sol\";\nimport \"../utils/Timed.sol\";\nimport \"../utils/SafeMath128.sol\";\nimport \"../external/SafeMathCopy.sol\";\nimport \"../external/Decimal.sol\";\n\n/// @title abstract implementation of IPool interface\n/// @author Fei Protocol\nabstract contract Pool is IPool, ERC20, ERC20Burnable, Timed {\n\tusing Decimal for Decimal.D256;\n\tusing SafeMath128 for uint128;\n\tusing SafeCast for uint;\n\n\tbool internal initialized;\n\n\tIERC20 public override rewardToken;\n\tIERC20 public override stakedToken;\n\n\tuint128 public override claimedRewards;\n\tuint128 public override totalStaked;\n\n    mapping (address => uint) public override stakedBalance;\n\n\t/// @notice Pool constructor\n\t/// @param _duration duration of the pool reward distribution\n\t/// @param _name the name of the pool token\n\t/// @param _ticker the token ticker for the pool token\n\tconstructor(\n\t\tuint32 _duration,\n\t\tstring memory _name,\n\t\tstring memory _ticker\n\t) public ERC20(_name, _ticker) Timed(_duration) {}\n\n\tfunction claim(address from, address to) external override returns(uint amountReward) {\n\t\tamountReward = _claim(from, to);\n\t\temit Claim(from, to, amountReward);\n\t\treturn amountReward;\n\t}\n\n\tfunction deposit(address to, uint amount) external override {\n\t\taddress from = msg.sender;\n\t\t_deposit(from, to, amount);\n\t\temit Deposit(from, to, amount);\n\t}\n\n\tfunction withdraw(address to) external override returns(uint amountStaked, uint amountReward) {\n\t\taddress from = msg.sender;\n\t\tamountReward = _claim(from, to);\n\t\tamountStaked = _withdraw(from, to);\n\t\temit Withdraw(from, to, amountStaked, amountReward);\n\t\treturn (amountStaked, amountReward);\n\t}\n\n\tfunction init() public override virtual {\n\t\trequire(!initialized, \"Pool: Already initialized\");\n\t\t_initTimed();\n\t\tinitialized = true;\n\t}\n\n    function redeemableReward(address account) public view override returns(uint amountReward, uint amountPool) {\n\t\tamountPool = _redeemablePoolTokens(account);\n\t\treturn (releasedReward() * amountPool / _totalRedeemablePoolTokens(), amountPool);\n    }\n\n\tfunction releasedReward() public view override returns (uint) {\n\t\tuint total = rewardBalance();\n\t\tuint unreleased = unreleasedReward();\n\t\trequire(total >= unreleased, \"Pool: Released Reward underflow\");\n\t\treturn total - unreleased;\n\t}\n\n\tfunction unreleasedReward() public view override returns (uint) {\n\t\tif (isTimeEnded()) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn _unreleasedReward(totalReward(), uint(duration), uint(timestamp()));\n\t}\n\n\tfunction totalReward() public view override returns (uint) {\n\t\treturn rewardBalance() + uint(claimedRewards);\n\t}\n\n\tfunction rewardBalance() public view override returns (uint) {\n\t\treturn rewardToken.balanceOf(address(this));\n\t}\n\n\tfunction burnFrom(address account, uint amount) public override {\n\t\tif (msg.sender == account) {\n\t\t\tincreaseAllowance(account, amount);\n\t\t}\n\t\tsuper.burnFrom(account, amount);\n\t}\n\n\tfunction _totalRedeemablePoolTokens() internal view returns(uint) {\n\t\tuint total = totalSupply();\n\t\tuint balance = _twfb(uint(totalStaked));\n\t\trequire(total >= balance, \"Pool: Total redeemable underflow\");\n\t\treturn total - balance;\n\t}\n\n\tfunction _redeemablePoolTokens(address account) internal view returns(uint) {\n\t\tuint total = balanceOf(account);\n\t\tuint balance = _twfb(stakedBalance[account]);\n\t\trequire(total >= balance, \"Pool: Redeemable underflow\");\n\t\treturn total - balance;\n\t}\n\n\tfunction _unreleasedReward(uint _totalReward, uint _duration, uint _time) internal view virtual returns (uint);\n\n\tfunction _deposit(address from, address to, uint amount) internal {\n\t\trequire(initialized, \"Pool: Uninitialized\");\n\t\trequire(amount <= stakedToken.balanceOf(from), \"Pool: Balance too low to stake\");\n\n\t\tstakedToken.transferFrom(from, address(this), amount);\n\n\t\tstakedBalance[to] += amount;\n\t\t_incrementStaked(amount);\n\t\t\n\t\tuint poolTokens = _twfb(amount);\n\t\trequire(poolTokens != 0, \"Pool: Window has ended\");\n\n\t\t_mint(to, poolTokens);\n\t}\n\n\tfunction _withdraw(address from, address to) internal returns(uint amountStaked) {\n\t\tamountStaked = stakedBalance[from];\n\t\tstakedBalance[from] = 0;\n\t\tstakedToken.transfer(to, amountStaked);\n\n\t\tuint amountPool = balanceOf(from);\n\t\tif (amountPool != 0) {\n\t\t\t_burn(from, amountPool);\n\t\t}\n\t\treturn amountStaked;\t\n\t}\n\n\tfunction _claim(address from, address to) internal returns(uint) {\n\t\t(uint amountReward, uint amountPool) = redeemableReward(from);\n\t\trequire(amountPool != 0, \"Pool: User has no redeemable pool tokens\");\n\n\t\tburnFrom(from, amountPool);\n\t\t_incrementClaimed(amountReward);\n\n\t\trewardToken.transfer(to, amountReward);\n\t\treturn amountReward;\n\t}\n\n\tfunction _incrementClaimed(uint amount) internal {\n\t\tclaimedRewards = claimedRewards.add(amount.toUint128());\n\t}\n\n\tfunction _incrementStaked(uint amount) internal {\n\t\ttotalStaked = totalStaked.add(amount.toUint128());\n\t}\n\n\tfunction _twfb(uint amount) internal view returns(uint) {\n\t\treturn amount * uint(remainingTime());\n\t}\n\n\t// Updates stored staked balance pro-rata for transfer and transferFrom\n\tfunction _beforeTokenTransfer(address from, address to, uint amount) internal override {\n        if (from != address(0) && to != address(0)) {\n \t\t\tDecimal.D256 memory ratio = Decimal.ratio(amount, balanceOf(from));\n \t\t\tuint amountStaked = ratio.mul(stakedBalance[from]).asUint256();\n\t\t\t\n \t\t\tstakedBalance[from] -= amountStaked;\n \t\t\tstakedBalance[to] += amountStaked;\n        }\n    }\n\n\tfunction _setTokens(address _rewardToken, address _stakedToken) internal {\n\t\trewardToken = IERC20(_rewardToken);\n\t\tstakedToken = IERC20(_stakedToken);\t\n\t}\n}"
    }
  ]
}