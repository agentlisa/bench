{
  "Title": "[N-07] Incorrect comment in `_depositBorrowWithdraw()`",
  "Content": "\n[BaseMarketTest Line 71](https://github.com/code-423n4/2023-10-wildcat/blob/main/test/BaseMarketTest.sol#L71)\n\n### Issue Description\n\nInside the function, the comments state that 80% of the market assets get borrowed and 100% of withdrawal get withdrawn. This is not the case, as instead, the provided parameters `depositAmount`, `borrowAmount` and `withdrawalAmount` are used. There are no `require`` statements in the function that check for these requirements; 80%/100% being fulfilled by the parameters.\n\n### Recommended Mitigation Steps\n\nTo address this issue, consider either adding `require` statements to verify that the parameters adhere to the stated percentages, or remove the comments if they no longer apply to the functionality.\n\n**[laurenceday (Wildcat) confirmed](https://github.com/code-423n4/2023-10-wildcat-findings/issues/581#issuecomment-1794449659)**\n\n**[0xTheC0der (judge) commented](https://github.com/code-423n4/2023-10-wildcat-findings/issues/581#issuecomment-1804138282):**\n > L-03 seems intended; therefore, considered Non-Critical.\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-10-wildcat",
  "Code": [
    {
      "filename": "test/BaseMarketTest.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport { MockERC20 } from 'solmate/test/utils/mocks/MockERC20.sol';\n\nimport './shared/Test.sol';\nimport './helpers/VmUtils.sol';\nimport './helpers/MockController.sol';\nimport './helpers/ExpectedStateTracker.sol';\n\ncontract BaseMarketTest is Test, ExpectedStateTracker {\n  using stdStorage for StdStorage;\n  using FeeMath for MarketState;\n  using SafeCastLib for uint256;\n\n  MockERC20 internal asset;\n\n  address internal wildcatController = address(0x69);\n  address internal wintermuteController = address(0x70);\n  address internal wlUser = address(0x42);\n  address internal nonwlUser = address(0x43);\n\n  function setUp() public {\n    setUpContracts(false);\n  }\n\n  function setUpContracts(bool disableControllerChecks) internal {\n    if (address(controller) == address(0)) {\n      deployController(parameters.borrower, false, disableControllerChecks);\n    }\n    parameters.controller = address(controller);\n    parameters.asset = address(asset = new MockERC20('Token', 'TKN', 18));\n    deployMarket(parameters);\n    _authorizeLender(alice);\n    previousState = MarketState({\n      isClosed: false,\n      maxTotalSupply: parameters.maxTotalSupply,\n      scaledTotalSupply: 0,\n      isDelinquent: false,\n      timeDelinquent: 0,\n      reserveRatioBips: parameters.reserveRatioBips,\n      annualInterestBips: parameters.annualInterestBips,\n      scaleFactor: uint112(RAY),\n      lastInterestAccruedTimestamp: uint32(block.timestamp),\n      scaledPendingWithdrawals: 0,\n      pendingWithdrawalExpiry: 0,\n      normalizedUnclaimedWithdrawals: 0,\n      accruedProtocolFees: 0\n    });\n    lastTotalAssets = 0;\n\n    asset.mint(alice, type(uint128).max);\n    asset.mint(bob, type(uint128).max);\n\n    _approve(alice, address(market), type(uint256).max);\n    _approve(bob, address(market), type(uint256).max);\n  }\n\n  function _authorizeLender(address account) internal asAccount(parameters.borrower) {\n    address[] memory lenders = new address[](1);\n    lenders[0] = account;\n    controller.authorizeLenders(lenders);\n  }\n\n  function _deauthorizeLender(address account) internal asAccount(parameters.borrower) {\n    address[] memory lenders = new address[](1);\n    lenders[0] = account;\n    controller.deauthorizeLenders(lenders);\n  }\n\n  function _depositBorrowWithdraw(\n    address from,\n    uint256 depositAmount,\n    uint256 borrowAmount,\n    uint256 withdrawalAmount\n  ) internal asAccount(from) {\n    _deposit(from, depositAmount);\n    // Borrow 80% of market assets\n    _borrow(borrowAmount);\n    // Withdraw 100% of deposits\n    _requestWithdrawal(from, withdrawalAmount);\n  }\n\n  function _deposit(address from, uint256 amount) internal asAccount(from) returns (uint256) {\n    _authorizeLender(from);\n    uint256 currentBalance = market.balanceOf(from);\n    uint256 currentScaledBalance = market.scaledBalanceOf(from);\n    asset.mint(from, amount);\n    asset.approve(address(market), amount);\n    MarketState memory state = pendingState();\n    uint256 expectedNormalizedAmount = MathUtils.min(amount, state.maximumDeposit());\n    uint256 scaledAmount = state.scaleAmount(expectedNormalizedAmount);\n    state.scaledTotalSupply += scaledAmount.toUint104();\n    uint256 actualNormalizedAmount = market.depositUpTo(amount);\n    assertEq(actualNormalizedAmount, expectedNormalizedAmount, 'Actual amount deposited');\n    lastTotalAssets += actualNormalizedAmount;\n    updateState(state);\n    _checkState();\n    assertApproxEqAbs(market.balanceOf(from), currentBalance + amount, 1);\n    assertEq(market.scaledBalanceOf(from), currentScaledBalance + scaledAmount);\n    return actualNormalizedAmount;\n  }\n\n  function _requestWithdrawal(address from, uint256 amount) internal asAccount(from) {\n    MarketState memory state = pendingState();\n    uint256 currentBalance = market.balanceOf(from);\n    uint256 currentScaledBalance = market.scaledBalanceOf(from);\n    uint104 scaledAmount = state.scaleAmount(amount).toUint104();\n\n    if (state.pendingWithdrawalExpiry == 0) {\n      // vm.expectEmit(address(market));\n      state.pendingWithdrawalExpiry = uint32(block.timestamp + parameters.withdrawalBatchDuration);\n      emit WithdrawalBatchCreated(state.pendingWithdrawalExpiry);\n    }\n    WithdrawalBatch storage batch = _withdrawalData.batches[state.pendingWithdrawalExpiry];\n    batch.scaledTotalAmount += scaledAmount;\n    state.scaledPendingWithdrawals += scaledAmount;\n    _withdrawalData\n    .accountStatuses[state.pendingWithdrawalExpiry][from].scaledAmount += scaledAmount;\n\n    // vm.expectEmit(address(market));\n    emit WithdrawalQueued(state.pendingWithdrawalExpiry, from, scaledAmount);\n\n    uint256 availableLiquidity = _availableLiquidityForPendingBatch(batch, state);\n    if (availableLiquidity > 0) {\n      _applyWithdrawalBatchPayment(batch, state, state.pendingWithdrawalExpiry, availableLiquidity);\n    }\n    market.queueWithdrawal(amount);\n    updateState(state);\n    _checkState();\n    assertApproxEqAbs(market.balanceOf(from), currentBalance - amount, 1, 'balance');\n    assertEq(market.scaledBalanceOf(from), currentScaledBalance - scaledAmount, 'scaledBalance');\n  }\n\n  function _withdraw(address from, uint256 amount) internal asAccount(from) {\n    // MarketState memory state = pendingState();\n    // uint256 scaledAmount = state.scaleAmount(amount);\n    // @todo fix\n    /* \t\tMarketState memory state = pendingState();\n    uint256 scaledAmount = state.scaleAmount(amount);\n    state.decreaseScaledTotalSupply(scaledAmount);\n    market.withdraw(amount);\n    updateState(state);\n    lastTotalAssets -= amount;\n    _checkState(); */\n  }\n\n  event DebtRepaid(uint256 assetAmount);\n\n  function _borrow(uint256 amount) internal asAccount(borrower) {\n    MarketState memory state = pendingState();\n\n    // vm.expectEmit(address(market));\n    emit Borrow(amount);\n    // _expectTransfer(address(asset), borrower, address(market), amount);\n    market.borrow(amount);\n\n    lastTotalAssets -= amount;\n    updateState(state);\n    _checkState();\n  }\n\n  function _approve(address from, address to, uint256 amount) internal asAccount(from) {\n    asset.approve(to, amount);\n  }\n}"
    }
  ]
}