{
  "Title": "Lack of Validation",
  "Content": "Throughout the codebase, the following instances were identified where stronger validation can be applied:\n\n\n* In the `Admin` facet, the [`setTokenMultiplier` function](https://github.com/matter-labs/era-contracts/blob/d5c5d7a7c3a458f131e5de72c6c134a172e6763d/l1-contracts/contracts/state-transition/chain-deps/facets/Admin.sol#L79) allows the admin or `StateTransitionManager` to set the nominator and denominator which is [used by the `Mailbox`](https://github.com/matter-labs/era-contracts/blob/d5c5d7a7c3a458f131e5de72c6c134a172e6763d/l1-contracts/contracts/state-transition/chain-deps/facets/Mailbox.sol#L159-L160) to scale the L1 gas price. While the denominator can be freely set, the value 0 would [lead to a revert](https://github.com/matter-labs/era-contracts/blob/d5c5d7a7c3a458f131e5de72c6c134a172e6763d/l1-contracts/contracts/state-transition/chain-deps/facets/Mailbox.sol#L158) in the `Mailbox` for any requested L2 transaction. Consider applying the same check when setting the value.\n* In the `StateTransitionManager`, the [`setNewVersionUpgrade` function](https://github.com/matter-labs/era-contracts/blob/d5c5d7a7c3a458f131e5de72c6c134a172e6763d/l1-contracts/contracts/state-transition/StateTransitionManager.sol#L142) allows the owner to set a diamond cut for an old protocol version. Simultaneously, the new protocol version argument overwrites the `protocolVersion` of the `StateTransitionManager` and thereby determines which version the diamond cut upgrades to. The problem is that the diamond cut also contains a `protocolVersion` in the encoded [`ProposedUpgrade` struct](https://github.com/matter-labs/era-contracts/blob/d5c5d7a7c3a458f131e5de72c6c134a172e6763d/l1-contracts/contracts/upgrades/BaseZkSyncUpgrade.sol#L38) as the [`initCalldata`](https://github.com/matter-labs/era-contracts/blob/d5c5d7a7c3a458f131e5de72c6c134a172e6763d/l1-contracts/contracts/state-transition/libraries/Diamond.sol#L76) that then sets the ZK Chain's [`s.protocolVersion`](https://github.com/matter-labs/era-contracts/blob/d5c5d7a7c3a458f131e5de72c6c134a172e6763d/l1-contracts/contracts/upgrades/BaseZkSyncUpgrade.sol#L255). It is possible that the encoded `protocolVersion` is not consistent with the new protocol version from the function argument. This mismatch would lead to all ZK Chains of the `StateTransitionManager` not being able to commit more batches to their `Executor` facet due to a [version check](https://github.com/matter-labs/era-contracts/blob/d5c5d7a7c3a458f131e5de72c6c134a172e6763d/l1-contracts/contracts/state-transition/chain-deps/facets/Executor.sol#L227). Consider decoding the diamond cut argument to validate that the protocol versions of the upgrade align.\n* The [`DiamondInit` contract initializes](https://github.com/matter-labs/era-contracts/blob/d5c5d7a7c3a458f131e5de72c6c134a172e6763d/l1-contracts/contracts/state-transition/chain-deps/DiamondInit.sol#L24) the storage of a ZK Chain. This includes the addresses of the `verifier`, `admin`, and `validatorTimelock` that are checked to not be zero. However, with the recent upgrade, more addresses were introduced: `bridgehub`, `stateTransitionManager`, `baseToken`, `baseTokenBridge`, and `blobVersionedHashRetriever`. These addresses are not checked to not be zero. While some of these addresses originate from trusted sources like the `BridgeHub` or the `StateTransitionManager`, consider double checking them for consistency with the existing addresses and guaranteeing the functional correctness of the chain.\n* The `StateTransitionManager` can [set arbitrary addresses](https://github.com/matter-labs/era-contracts/blob/d5c5d7a7c3a458f131e5de72c6c134a172e6763d/l1-contracts/contracts/state-transition/StateTransitionManager.sol#L230) as registered ZK Chain contracts per chain ID. This may include overwriting a chain ID with the zero address. By the logic of this contract, this could allow creating a new chain for this ID by passing the [zero address check](https://github.com/matter-labs/era-contracts/blob/d5c5d7a7c3a458f131e5de72c6c134a172e6763d/l1-contracts/contracts/state-transition/StateTransitionManager.sol#L246-L249). Although, this it not allowed by the `BridgeHub` in charge, consider checking that upon registration of already deployed ZK Chains, the address cannot be set to zero.\n\n\n***Update:** Partially resolved in [pull request #297](https://github.com/matter-labs/era-contracts/pull/297). The Matter Labs team stated:*\n\n\n\n> *Partially fixed. We decided not to apply the suggestion for `setNewVersionUpgrade` to avoid additional complexity.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "l1-contracts/contracts/state-transition/chain-deps/facets/Admin.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {IAdmin} from \"../../chain-interfaces/IAdmin.sol\";\nimport {Diamond} from \"../../libraries/Diamond.sol\";\nimport {MAX_GAS_PER_TRANSACTION} from \"../../../common/Config.sol\";\nimport {FeeParams, PubdataPricingMode} from \"../ZkSyncStateTransitionStorage.sol\";\nimport {ZkSyncStateTransitionBase} from \"./ZkSyncStateTransitionBase.sol\";\nimport {IStateTransitionManager} from \"../../IStateTransitionManager.sol\";\n\n// While formally the following import is not used, it is needed to inherit documentation from it\nimport {IZkSyncStateTransitionBase} from \"../../chain-interfaces/IZkSyncStateTransitionBase.sol\";\n\n/// @title Admin Contract controls access rights for contract management.\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ncontract AdminFacet is ZkSyncStateTransitionBase, IAdmin {\n    /// @inheritdoc IZkSyncStateTransitionBase\n    string public constant override getName = \"AdminFacet\";\n\n    /// @inheritdoc IAdmin\n    function setPendingAdmin(address _newPendingAdmin) external onlyAdmin {\n        // Save previous value into the stack to put it into the event later\n        address oldPendingAdmin = s.pendingAdmin;\n        // Change pending admin\n        s.pendingAdmin = _newPendingAdmin;\n        emit NewPendingAdmin(oldPendingAdmin, _newPendingAdmin);\n    }\n\n    /// @inheritdoc IAdmin\n    function acceptAdmin() external {\n        address pendingAdmin = s.pendingAdmin;\n        require(msg.sender == pendingAdmin, \"n4\"); // Only proposed by current admin address can claim the admin rights\n\n        address previousAdmin = s.admin;\n        s.admin = pendingAdmin;\n        delete s.pendingAdmin;\n\n        emit NewPendingAdmin(pendingAdmin, address(0));\n        emit NewAdmin(previousAdmin, pendingAdmin);\n    }\n\n    /// @inheritdoc IAdmin\n    function setValidator(address _validator, bool _active) external onlyStateTransitionManager {\n        s.validators[_validator] = _active;\n        emit ValidatorStatusUpdate(_validator, _active);\n    }\n\n    /// @inheritdoc IAdmin\n    function setPorterAvailability(bool _zkPorterIsAvailable) external onlyStateTransitionManager {\n        // Change the porter availability\n        s.zkPorterIsAvailable = _zkPorterIsAvailable;\n        emit IsPorterAvailableStatusUpdate(_zkPorterIsAvailable);\n    }\n\n    /// @inheritdoc IAdmin\n    function setPriorityTxMaxGasLimit(uint256 _newPriorityTxMaxGasLimit) external onlyStateTransitionManager {\n        require(_newPriorityTxMaxGasLimit <= MAX_GAS_PER_TRANSACTION, \"n5\");\n\n        uint256 oldPriorityTxMaxGasLimit = s.priorityTxMaxGasLimit;\n        s.priorityTxMaxGasLimit = _newPriorityTxMaxGasLimit;\n        emit NewPriorityTxMaxGasLimit(oldPriorityTxMaxGasLimit, _newPriorityTxMaxGasLimit);\n    }\n\n    /// @inheritdoc IAdmin\n    function changeFeeParams(FeeParams calldata _newFeeParams) external onlyAdminOrStateTransitionManager {\n        // Double checking that the new fee params are valid, i.e.\n        // the maximal pubdata per batch is not less than the maximal pubdata per priority transaction.\n        require(_newFeeParams.maxPubdataPerBatch >= _newFeeParams.priorityTxMaxPubdata, \"n6\");\n\n        FeeParams memory oldFeeParams = s.feeParams;\n        s.feeParams = _newFeeParams;\n\n        emit NewFeeParams(oldFeeParams, _newFeeParams);\n    }\n\n    /// @inheritdoc IAdmin\n    function setTokenMultiplier(uint128 _nominator, uint128 _denominator) external onlyAdminOrStateTransitionManager {\n        uint128 oldNominator = s.baseTokenGasPriceMultiplierNominator;\n        uint128 oldDenominator = s.baseTokenGasPriceMultiplierDenominator;\n\n        s.baseTokenGasPriceMultiplierNominator = _nominator;\n        s.baseTokenGasPriceMultiplierDenominator = _denominator;\n\n        emit NewBaseTokenMultiplier(oldNominator, oldDenominator, _nominator, _denominator);\n    }\n\n    function setValidiumMode(PubdataPricingMode _validiumMode) external onlyAdmin {\n        require(s.totalBatchesCommitted == 0, \"AdminFacet: set validium only after genesis\"); // Validium mode can be set only before the first batch is committed\n        s.feeParams.pubdataPricingMode = _validiumMode;\n        emit ValidiumModeStatusUpdate(_validiumMode);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            UPGRADE EXECUTION\n    //////////////////////////////////////////////////////////////*/\n\n    /// upgrade a specific chain\n    function upgradeChainFromVersion(\n        uint256 _oldProtocolVersion,\n        Diamond.DiamondCutData calldata _diamondCut\n    ) external onlyAdminOrStateTransitionManager {\n        bytes32 cutHashInput = keccak256(abi.encode(_diamondCut));\n        require(\n            cutHashInput == IStateTransitionManager(s.stateTransitionManager).upgradeCutHash(_oldProtocolVersion),\n            \"StateTransition: cutHash mismatch\"\n        );\n\n        require(\n            s.protocolVersion == _oldProtocolVersion,\n            \"StateTransition: protocolVersion mismatch in STC when upgrading\"\n        );\n        Diamond.diamondCut(_diamondCut);\n        emit ExecuteUpgrade(_diamondCut);\n        require(\n            s.protocolVersion > _oldProtocolVersion,\n            \"StateTransition: protocolVersion mismatch in STC after upgrading\"\n        );\n    }\n\n    /// @inheritdoc IAdmin\n    function executeUpgrade(Diamond.DiamondCutData calldata _diamondCut) external onlyStateTransitionManager {\n        Diamond.diamondCut(_diamondCut);\n        emit ExecuteUpgrade(_diamondCut);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            CONTRACT FREEZING\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IAdmin\n    function freezeDiamond() external onlyAdminOrStateTransitionManager {\n        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();\n\n        require(!diamondStorage.isFrozen, \"a9\"); // diamond proxy is frozen already\n        diamondStorage.isFrozen = true;\n\n        emit Freeze();\n    }\n\n    /// @inheritdoc IAdmin\n    function unfreezeDiamond() external onlyAdminOrStateTransitionManager {\n        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();\n\n        require(diamondStorage.isFrozen, \"a7\"); // diamond proxy is not frozen\n        diamondStorage.isFrozen = false;\n\n        emit Unfreeze();\n    }\n}"
    },
    {
      "filename": "l1-contracts/contracts/state-transition/StateTransitionManager.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {Diamond} from \"./libraries/Diamond.sol\";\nimport {DiamondProxy} from \"./chain-deps/DiamondProxy.sol\";\nimport {IAdmin} from \"./chain-interfaces/IAdmin.sol\";\nimport {IDefaultUpgrade} from \"../upgrades/IDefaultUpgrade.sol\";\nimport {IDiamondInit} from \"./chain-interfaces/IDiamondInit.sol\";\nimport {IExecutor} from \"./chain-interfaces/IExecutor.sol\";\nimport {IStateTransitionManager, StateTransitionManagerInitializeData} from \"./IStateTransitionManager.sol\";\nimport {ISystemContext} from \"./l2-deps/ISystemContext.sol\";\nimport {IZkSyncStateTransition} from \"./chain-interfaces/IZkSyncStateTransition.sol\";\nimport {L2_SYSTEM_CONTEXT_SYSTEM_CONTRACT_ADDR, L2_FORCE_DEPLOYER_ADDR} from \"../common/L2ContractAddresses.sol\";\nimport {L2CanonicalTransaction} from \"../common/Messaging.sol\";\nimport {Ownable2Step} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport {ProposedUpgrade} from \"../upgrades/BaseZkSyncUpgrade.sol\";\nimport {ReentrancyGuard} from \"../common/ReentrancyGuard.sol\";\nimport {REQUIRED_L2_GAS_PRICE_PER_PUBDATA, L2_TO_L1_LOG_SERIALIZE_SIZE, DEFAULT_L2_LOGS_TREE_ROOT_HASH, EMPTY_STRING_KECCAK, SYSTEM_UPGRADE_L2_TX_TYPE, ERA_DIAMOND_PROXY, ERA_CHAIN_ID} from \"../common/Config.sol\";\nimport {VerifierParams} from \"./chain-interfaces/IVerifier.sol\";\n\n/// @title StateTransition contract\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ncontract StateTransitionManager is IStateTransitionManager, ReentrancyGuard, Ownable2Step {\n    /// @notice Address of the bridgehub\n    address public immutable bridgehub;\n\n    /// @notice chainId => chainContract\n    mapping(uint256 => address) public stateTransition;\n\n    /// @dev Batch hash zero, calculated at initialization\n    bytes32 public storedBatchZero;\n\n    /// @dev Stored cutData for diamond cut\n    bytes32 public initialCutHash;\n\n    /// @dev genesisUpgrade contract address, used to setChainId\n    address public genesisUpgrade;\n\n    /// @dev current protocolVersion\n    uint256 public protocolVersion;\n\n    /// @dev validatorTimelock contract address, used to setChainId\n    address public validatorTimelock;\n\n    /// @dev Stored cutData for upgrade diamond cut. protocolVersion => cutHash\n    mapping(uint256 => bytes32) public upgradeCutHash;\n\n    /// @dev used to manage non critical updates\n    address public admin;\n\n    /// @dev used to accept the admin role\n    address private pendingAdmin;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(address _bridgehub) reentrancyGuardInitializer {\n        bridgehub = _bridgehub;\n    }\n\n    /// @notice only the bridgehub can call\n    modifier onlyBridgehub() {\n        require(msg.sender == bridgehub, \"StateTransition: only bridgehub\");\n        _;\n    }\n\n    /// @notice the admin can call, for non-critical updates\n    modifier onlyOwnerOrAdmin() {\n        require(msg.sender == admin || msg.sender == owner(), \"Bridgehub: not owner or admin\");\n        _;\n    }\n\n    function getChainAdmin(uint256 _chainId) external view override returns (address) {\n        return IZkSyncStateTransition(stateTransition[_chainId]).getAdmin();\n    }\n\n    /// @dev initialize\n    function initialize(\n        StateTransitionManagerInitializeData calldata _initializeData\n    ) external reentrancyGuardInitializer {\n        require(_initializeData.governor != address(0), \"StateTransition: governor zero\");\n        _transferOwnership(_initializeData.governor);\n\n        genesisUpgrade = _initializeData.genesisUpgrade;\n        protocolVersion = _initializeData.protocolVersion;\n        validatorTimelock = _initializeData.validatorTimelock;\n\n        // We need to initialize the state hash because it is used in the commitment of the next batch\n        IExecutor.StoredBatchInfo memory batchZero = IExecutor.StoredBatchInfo(\n            0,\n            _initializeData.genesisBatchHash,\n            _initializeData.genesisIndexRepeatedStorageChanges,\n            0,\n            EMPTY_STRING_KECCAK,\n            DEFAULT_L2_LOGS_TREE_ROOT_HASH,\n            0,\n            _initializeData.genesisBatchCommitment\n        );\n        storedBatchZero = keccak256(abi.encode(batchZero));\n\n        initialCutHash = keccak256(abi.encode(_initializeData.diamondCut));\n\n        // While this does not provide a protection in the production, it is needed for local testing\n        // Length of the L2Log encoding should not be equal to the length of other L2Logs' tree nodes preimages\n        assert(L2_TO_L1_LOG_SERIALIZE_SIZE != 2 * 32);\n    }\n\n    /// @inheritdoc IStateTransitionManager\n    function setPendingAdmin(address _newPendingAdmin) external onlyOwnerOrAdmin {\n        // Save previous value into the stack to put it into the event later\n        address oldPendingAdmin = pendingAdmin;\n        // Change pending admin\n        pendingAdmin = _newPendingAdmin;\n        emit NewPendingAdmin(oldPendingAdmin, _newPendingAdmin);\n    }\n\n    /// @inheritdoc IStateTransitionManager\n    function acceptAdmin() external {\n        address currentPendingAdmin = pendingAdmin;\n        require(msg.sender == currentPendingAdmin, \"n42\"); // Only proposed by current admin address can claim the admin rights\n\n        address previousAdmin = admin;\n        admin = currentPendingAdmin;\n        delete pendingAdmin;\n\n        emit NewPendingAdmin(currentPendingAdmin, address(0));\n        emit NewAdmin(previousAdmin, pendingAdmin);\n    }\n\n    /// @dev set validatorTimelock. Cannot do it an initialization, as validatorTimelock is deployed after STM\n    function setValidatorTimelock(address _validatorTimelock) external onlyOwnerOrAdmin {\n        validatorTimelock = _validatorTimelock;\n    }\n\n    /// @dev set initial cutHash\n    function setInitialCutHash(Diamond.DiamondCutData calldata _diamondCut) external onlyOwner {\n        initialCutHash = keccak256(abi.encode(_diamondCut));\n    }\n\n    /// @dev set New Version with upgrade from old version\n    function setNewVersionUpgrade(\n        Diamond.DiamondCutData calldata _cutData,\n        uint256 _oldProtocolVersion,\n        uint256 _newProtocolVersion\n    ) external onlyOwner {\n        upgradeCutHash[_oldProtocolVersion] = keccak256(abi.encode(_cutData));\n        protocolVersion = _newProtocolVersion;\n    }\n\n    /// @dev set upgrade for some protocolVersion\n    function setUpgradeDiamondCut(\n        Diamond.DiamondCutData calldata _cutData,\n        uint256 _oldProtocolVersion\n    ) external onlyOwner {\n        upgradeCutHash[_oldProtocolVersion] = keccak256(abi.encode(_cutData));\n    }\n\n    /// @dev freezes the specified chain\n    function freezeChain(uint256 _chainId) external onlyOwner {\n        IZkSyncStateTransition(stateTransition[_chainId]).freezeDiamond();\n    }\n\n    /// @dev freezes the specified chain\n    function unfreezeChain(uint256 _chainId) external onlyOwner {\n        IZkSyncStateTransition(stateTransition[_chainId]).freezeDiamond();\n    }\n\n    /// @dev reverts batches on the specified chain\n    function revertBatches(uint256 _chainId, uint256 _newLastBatch) external onlyOwnerOrAdmin {\n        IZkSyncStateTransition(stateTransition[_chainId]).revertBatches(_newLastBatch);\n    }\n\n    /// registration\n\n    /// @dev we have to set the chainId at genesis, as blockhashzero is the same for all chains with the same chainId\n    function _setChainIdUpgrade(uint256 _chainId, address _chainContract) internal {\n        bytes memory systemContextCalldata = abi.encodeCall(ISystemContext.setChainId, (_chainId));\n        uint256[] memory uintEmptyArray;\n        bytes[] memory bytesEmptyArray;\n\n        L2CanonicalTransaction memory l2ProtocolUpgradeTx = L2CanonicalTransaction({\n            txType: SYSTEM_UPGRADE_L2_TX_TYPE,\n            from: uint256(uint160(L2_FORCE_DEPLOYER_ADDR)),\n            to: uint256(uint160(L2_SYSTEM_CONTEXT_SYSTEM_CONTRACT_ADDR)),\n            gasLimit: $(PRIORITY_TX_MAX_GAS_LIMIT),\n            gasPerPubdataByteLimit: REQUIRED_L2_GAS_PRICE_PER_PUBDATA,\n            maxFeePerGas: uint256(0),\n            maxPriorityFeePerGas: uint256(0),\n            paymaster: uint256(0),\n            // Note, that the priority operation id is used as \"nonce\" for L1->L2 transactions\n            nonce: protocolVersion,\n            value: 0,\n            reserved: [uint256(0), 0, 0, 0],\n            data: systemContextCalldata,\n            signature: new bytes(0),\n            factoryDeps: uintEmptyArray,\n            paymasterInput: new bytes(0),\n            reservedDynamic: new bytes(0)\n        });\n\n        ProposedUpgrade memory proposedUpgrade = ProposedUpgrade({\n            l2ProtocolUpgradeTx: l2ProtocolUpgradeTx,\n            factoryDeps: bytesEmptyArray,\n            bootloaderHash: bytes32(0),\n            defaultAccountHash: bytes32(0),\n            verifier: address(0),\n            verifierParams: VerifierParams({\n                recursionNodeLevelVkHash: bytes32(0),\n                recursionLeafLevelVkHash: bytes32(0),\n                recursionCircuitsSetVksHash: bytes32(0)\n            }),\n            l1ContractsUpgradeCalldata: new bytes(0),\n            postUpgradeCalldata: new bytes(0),\n            upgradeTimestamp: 0,\n            newProtocolVersion: protocolVersion\n        });\n\n        Diamond.FacetCut[] memory emptyArray;\n        Diamond.DiamondCutData memory cutData = Diamond.DiamondCutData({\n            facetCuts: emptyArray,\n            initAddress: genesisUpgrade,\n            initCalldata: abi.encodeCall(IDefaultUpgrade.upgrade, (proposedUpgrade))\n        });\n\n        IAdmin(_chainContract).executeUpgrade(cutData);\n        emit SetChainIdUpgrade(_chainContract, l2ProtocolUpgradeTx, protocolVersion);\n    }\n\n    function registerAlreadyDeployedStateTransition(\n        uint256 _chainId,\n        address _stateTransitionContract\n    ) external onlyOwner {\n        stateTransition[_chainId] = _stateTransitionContract;\n        emit StateTransitionNewChain(_chainId, _stateTransitionContract);\n    }\n\n    /// @notice called by Bridgehub when a chain registers\n    function createNewChain(\n        uint256 _chainId,\n        address _baseToken,\n        address _sharedBridge,\n        address _admin,\n        bytes calldata _diamondCut\n    ) external onlyBridgehub {\n        if (stateTransition[_chainId] != address(0)) {\n            // StateTransition chain already registered\n            return;\n        }\n\n        // check not registered\n        Diamond.DiamondCutData memory diamondCut = abi.decode(_diamondCut, (Diamond.DiamondCutData));\n\n        // check input\n        bytes32 cutHashInput = keccak256(_diamondCut);\n        require(cutHashInput == initialCutHash, \"StateTransition: initial cutHash mismatch\");\n\n        // construct init data\n        bytes memory initData;\n        /// all together 4+9*32=292 bytes\n        initData = bytes.concat(\n            IDiamondInit.initialize.selector,\n            bytes32(_chainId),\n            bytes32(uint256(uint160(bridgehub))),\n            bytes32(uint256(uint160(address(this)))),\n            bytes32(uint256(protocolVersion)),\n            bytes32(uint256(uint160(_admin))),\n            bytes32(uint256(uint160(validatorTimelock))),\n            bytes32(uint256(uint160(_baseToken))),\n            bytes32(uint256(uint160(_sharedBridge))),\n            bytes32(storedBatchZero),\n            diamondCut.initCalldata\n        );\n\n        diamondCut.initCalldata = initData;\n        // deploy stateTransitionContract\n        DiamondProxy stateTransitionContract = new DiamondProxy{salt: bytes32(0)}(block.chainid, diamondCut);\n\n        // save data\n        address stateTransitionAddress = address(stateTransitionContract);\n\n        stateTransition[_chainId] = stateTransitionAddress;\n\n        // set chainId in VM\n        _setChainIdUpgrade(_chainId, stateTransitionAddress);\n\n        emit StateTransitionNewChain(_chainId, stateTransitionAddress);\n    }\n}"
    },
    {
      "filename": "l1-contracts/contracts/state-transition/chain-deps/DiamondInit.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {Diamond} from \"../libraries/Diamond.sol\";\nimport {ZkSyncStateTransitionBase} from \"./facets/ZkSyncStateTransitionBase.sol\";\nimport {FeeParams} from \"./ZkSyncStateTransitionStorage.sol\";\nimport {L2_TO_L1_LOG_SERIALIZE_SIZE, MAX_GAS_PER_TRANSACTION} from \"../../common/Config.sol\";\nimport {InitializeData, IDiamondInit} from \"../chain-interfaces/IDiamondInit.sol\";\nimport {VerifierParams} from \"../chain-interfaces/IVerifier.sol\";\n\nimport \"../l2-deps/ISystemContext.sol\";\n\n/// @author Matter Labs\n/// @dev The contract is used only once to initialize the diamond proxy.\n/// @dev The deployment process takes care of this contract's initialization.\ncontract DiamondInit is ZkSyncStateTransitionBase, IDiamondInit {\n    /// @dev Initialize the implementation to prevent any possibility of a Parity hack.\n    constructor() reentrancyGuardInitializer {}\n\n    /// @notice hyperchain diamond contract initialization\n    /// @return Magic 32 bytes, which indicates that the contract logic is expected to be used as a diamond proxy\n    /// initializer\n    function initialize(InitializeData calldata _initializeData) external reentrancyGuardInitializer returns (bytes32) {\n        require(address(_initializeData.verifier) != address(0), \"vt\");\n        require(_initializeData.admin != address(0), \"vy\");\n        require(_initializeData.validatorTimelock != address(0), \"hc\");\n        require(_initializeData.priorityTxMaxGasLimit <= MAX_GAS_PER_TRANSACTION, \"vu\");\n\n        s.chainId = _initializeData.chainId;\n        s.bridgehub = _initializeData.bridgehub;\n        s.stateTransitionManager = _initializeData.stateTransitionManager;\n        s.baseToken = _initializeData.baseToken;\n        s.baseTokenBridge = _initializeData.baseTokenBridge;\n        s.protocolVersion = _initializeData.protocolVersion;\n\n        s.verifier = _initializeData.verifier;\n        s.admin = _initializeData.admin;\n        s.validators[_initializeData.validatorTimelock] = true;\n\n        s.storedBatchHashes[0] = _initializeData.storedBatchZero;\n        s.verifierParams = _initializeData.verifierParams;\n        s.l2BootloaderBytecodeHash = _initializeData.l2BootloaderBytecodeHash;\n        s.l2DefaultAccountBytecodeHash = _initializeData.l2DefaultAccountBytecodeHash;\n        s.priorityTxMaxGasLimit = _initializeData.priorityTxMaxGasLimit;\n        s.feeParams = _initializeData.feeParams;\n        s.blobVersionedHashRetriever = _initializeData.blobVersionedHashRetriever;\n\n        // While this does not provide a protection in the production, it is needed for local testing\n        // Length of the L2Log encoding should not be equal to the length of other L2Logs' tree nodes preimages\n        assert(L2_TO_L1_LOG_SERIALIZE_SIZE != 2 * 32);\n\n        return Diamond.DIAMOND_INIT_SUCCESS_RETURN_VALUE;\n    }\n}"
    },
    {
      "filename": "l1-contracts/contracts/state-transition/StateTransitionManager.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {Diamond} from \"./libraries/Diamond.sol\";\nimport {DiamondProxy} from \"./chain-deps/DiamondProxy.sol\";\nimport {IAdmin} from \"./chain-interfaces/IAdmin.sol\";\nimport {IDefaultUpgrade} from \"../upgrades/IDefaultUpgrade.sol\";\nimport {IDiamondInit} from \"./chain-interfaces/IDiamondInit.sol\";\nimport {IExecutor} from \"./chain-interfaces/IExecutor.sol\";\nimport {IStateTransitionManager, StateTransitionManagerInitializeData} from \"./IStateTransitionManager.sol\";\nimport {ISystemContext} from \"./l2-deps/ISystemContext.sol\";\nimport {IZkSyncStateTransition} from \"./chain-interfaces/IZkSyncStateTransition.sol\";\nimport {L2_SYSTEM_CONTEXT_SYSTEM_CONTRACT_ADDR, L2_FORCE_DEPLOYER_ADDR} from \"../common/L2ContractAddresses.sol\";\nimport {L2CanonicalTransaction} from \"../common/Messaging.sol\";\nimport {Ownable2Step} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport {ProposedUpgrade} from \"../upgrades/BaseZkSyncUpgrade.sol\";\nimport {ReentrancyGuard} from \"../common/ReentrancyGuard.sol\";\nimport {REQUIRED_L2_GAS_PRICE_PER_PUBDATA, L2_TO_L1_LOG_SERIALIZE_SIZE, DEFAULT_L2_LOGS_TREE_ROOT_HASH, EMPTY_STRING_KECCAK, SYSTEM_UPGRADE_L2_TX_TYPE, ERA_DIAMOND_PROXY, ERA_CHAIN_ID} from \"../common/Config.sol\";\nimport {VerifierParams} from \"./chain-interfaces/IVerifier.sol\";\n\n/// @title StateTransition contract\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ncontract StateTransitionManager is IStateTransitionManager, ReentrancyGuard, Ownable2Step {\n    /// @notice Address of the bridgehub\n    address public immutable bridgehub;\n\n    /// @notice chainId => chainContract\n    mapping(uint256 => address) public stateTransition;\n\n    /// @dev Batch hash zero, calculated at initialization\n    bytes32 public storedBatchZero;\n\n    /// @dev Stored cutData for diamond cut\n    bytes32 public initialCutHash;\n\n    /// @dev genesisUpgrade contract address, used to setChainId\n    address public genesisUpgrade;\n\n    /// @dev current protocolVersion\n    uint256 public protocolVersion;\n\n    /// @dev validatorTimelock contract address, used to setChainId\n    address public validatorTimelock;\n\n    /// @dev Stored cutData for upgrade diamond cut. protocolVersion => cutHash\n    mapping(uint256 => bytes32) public upgradeCutHash;\n\n    /// @dev used to manage non critical updates\n    address public admin;\n\n    /// @dev used to accept the admin role\n    address private pendingAdmin;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(address _bridgehub) reentrancyGuardInitializer {\n        bridgehub = _bridgehub;\n    }\n\n    /// @notice only the bridgehub can call\n    modifier onlyBridgehub() {\n        require(msg.sender == bridgehub, \"StateTransition: only bridgehub\");\n        _;\n    }\n\n    /// @notice the admin can call, for non-critical updates\n    modifier onlyOwnerOrAdmin() {\n        require(msg.sender == admin || msg.sender == owner(), \"Bridgehub: not owner or admin\");\n        _;\n    }\n\n    function getChainAdmin(uint256 _chainId) external view override returns (address) {\n        return IZkSyncStateTransition(stateTransition[_chainId]).getAdmin();\n    }\n\n    /// @dev initialize\n    function initialize(\n        StateTransitionManagerInitializeData calldata _initializeData\n    ) external reentrancyGuardInitializer {\n        require(_initializeData.governor != address(0), \"StateTransition: governor zero\");\n        _transferOwnership(_initializeData.governor);\n\n        genesisUpgrade = _initializeData.genesisUpgrade;\n        protocolVersion = _initializeData.protocolVersion;\n        validatorTimelock = _initializeData.validatorTimelock;\n\n        // We need to initialize the state hash because it is used in the commitment of the next batch\n        IExecutor.StoredBatchInfo memory batchZero = IExecutor.StoredBatchInfo(\n            0,\n            _initializeData.genesisBatchHash,\n            _initializeData.genesisIndexRepeatedStorageChanges,\n            0,\n            EMPTY_STRING_KECCAK,\n            DEFAULT_L2_LOGS_TREE_ROOT_HASH,\n            0,\n            _initializeData.genesisBatchCommitment\n        );\n        storedBatchZero = keccak256(abi.encode(batchZero));\n\n        initialCutHash = keccak256(abi.encode(_initializeData.diamondCut));\n\n        // While this does not provide a protection in the production, it is needed for local testing\n        // Length of the L2Log encoding should not be equal to the length of other L2Logs' tree nodes preimages\n        assert(L2_TO_L1_LOG_SERIALIZE_SIZE != 2 * 32);\n    }\n\n    /// @inheritdoc IStateTransitionManager\n    function setPendingAdmin(address _newPendingAdmin) external onlyOwnerOrAdmin {\n        // Save previous value into the stack to put it into the event later\n        address oldPendingAdmin = pendingAdmin;\n        // Change pending admin\n        pendingAdmin = _newPendingAdmin;\n        emit NewPendingAdmin(oldPendingAdmin, _newPendingAdmin);\n    }\n\n    /// @inheritdoc IStateTransitionManager\n    function acceptAdmin() external {\n        address currentPendingAdmin = pendingAdmin;\n        require(msg.sender == currentPendingAdmin, \"n42\"); // Only proposed by current admin address can claim the admin rights\n\n        address previousAdmin = admin;\n        admin = currentPendingAdmin;\n        delete pendingAdmin;\n\n        emit NewPendingAdmin(currentPendingAdmin, address(0));\n        emit NewAdmin(previousAdmin, pendingAdmin);\n    }\n\n    /// @dev set validatorTimelock. Cannot do it an initialization, as validatorTimelock is deployed after STM\n    function setValidatorTimelock(address _validatorTimelock) external onlyOwnerOrAdmin {\n        validatorTimelock = _validatorTimelock;\n    }\n\n    /// @dev set initial cutHash\n    function setInitialCutHash(Diamond.DiamondCutData calldata _diamondCut) external onlyOwner {\n        initialCutHash = keccak256(abi.encode(_diamondCut));\n    }\n\n    /// @dev set New Version with upgrade from old version\n    function setNewVersionUpgrade(\n        Diamond.DiamondCutData calldata _cutData,\n        uint256 _oldProtocolVersion,\n        uint256 _newProtocolVersion\n    ) external onlyOwner {\n        upgradeCutHash[_oldProtocolVersion] = keccak256(abi.encode(_cutData));\n        protocolVersion = _newProtocolVersion;\n    }\n\n    /// @dev set upgrade for some protocolVersion\n    function setUpgradeDiamondCut(\n        Diamond.DiamondCutData calldata _cutData,\n        uint256 _oldProtocolVersion\n    ) external onlyOwner {\n        upgradeCutHash[_oldProtocolVersion] = keccak256(abi.encode(_cutData));\n    }\n\n    /// @dev freezes the specified chain\n    function freezeChain(uint256 _chainId) external onlyOwner {\n        IZkSyncStateTransition(stateTransition[_chainId]).freezeDiamond();\n    }\n\n    /// @dev freezes the specified chain\n    function unfreezeChain(uint256 _chainId) external onlyOwner {\n        IZkSyncStateTransition(stateTransition[_chainId]).freezeDiamond();\n    }\n\n    /// @dev reverts batches on the specified chain\n    function revertBatches(uint256 _chainId, uint256 _newLastBatch) external onlyOwnerOrAdmin {\n        IZkSyncStateTransition(stateTransition[_chainId]).revertBatches(_newLastBatch);\n    }\n\n    /// registration\n\n    /// @dev we have to set the chainId at genesis, as blockhashzero is the same for all chains with the same chainId\n    function _setChainIdUpgrade(uint256 _chainId, address _chainContract) internal {\n        bytes memory systemContextCalldata = abi.encodeCall(ISystemContext.setChainId, (_chainId));\n        uint256[] memory uintEmptyArray;\n        bytes[] memory bytesEmptyArray;\n\n        L2CanonicalTransaction memory l2ProtocolUpgradeTx = L2CanonicalTransaction({\n            txType: SYSTEM_UPGRADE_L2_TX_TYPE,\n            from: uint256(uint160(L2_FORCE_DEPLOYER_ADDR)),\n            to: uint256(uint160(L2_SYSTEM_CONTEXT_SYSTEM_CONTRACT_ADDR)),\n            gasLimit: $(PRIORITY_TX_MAX_GAS_LIMIT),\n            gasPerPubdataByteLimit: REQUIRED_L2_GAS_PRICE_PER_PUBDATA,\n            maxFeePerGas: uint256(0),\n            maxPriorityFeePerGas: uint256(0),\n            paymaster: uint256(0),\n            // Note, that the priority operation id is used as \"nonce\" for L1->L2 transactions\n            nonce: protocolVersion,\n            value: 0,\n            reserved: [uint256(0), 0, 0, 0],\n            data: systemContextCalldata,\n            signature: new bytes(0),\n            factoryDeps: uintEmptyArray,\n            paymasterInput: new bytes(0),\n            reservedDynamic: new bytes(0)\n        });\n\n        ProposedUpgrade memory proposedUpgrade = ProposedUpgrade({\n            l2ProtocolUpgradeTx: l2ProtocolUpgradeTx,\n            factoryDeps: bytesEmptyArray,\n            bootloaderHash: bytes32(0),\n            defaultAccountHash: bytes32(0),\n            verifier: address(0),\n            verifierParams: VerifierParams({\n                recursionNodeLevelVkHash: bytes32(0),\n                recursionLeafLevelVkHash: bytes32(0),\n                recursionCircuitsSetVksHash: bytes32(0)\n            }),\n            l1ContractsUpgradeCalldata: new bytes(0),\n            postUpgradeCalldata: new bytes(0),\n            upgradeTimestamp: 0,\n            newProtocolVersion: protocolVersion\n        });\n\n        Diamond.FacetCut[] memory emptyArray;\n        Diamond.DiamondCutData memory cutData = Diamond.DiamondCutData({\n            facetCuts: emptyArray,\n            initAddress: genesisUpgrade,\n            initCalldata: abi.encodeCall(IDefaultUpgrade.upgrade, (proposedUpgrade))\n        });\n\n        IAdmin(_chainContract).executeUpgrade(cutData);\n        emit SetChainIdUpgrade(_chainContract, l2ProtocolUpgradeTx, protocolVersion);\n    }\n\n    function registerAlreadyDeployedStateTransition(\n        uint256 _chainId,\n        address _stateTransitionContract\n    ) external onlyOwner {\n        stateTransition[_chainId] = _stateTransitionContract;\n        emit StateTransitionNewChain(_chainId, _stateTransitionContract);\n    }\n\n    /// @notice called by Bridgehub when a chain registers\n    function createNewChain(\n        uint256 _chainId,\n        address _baseToken,\n        address _sharedBridge,\n        address _admin,\n        bytes calldata _diamondCut\n    ) external onlyBridgehub {\n        if (stateTransition[_chainId] != address(0)) {\n            // StateTransition chain already registered\n            return;\n        }\n\n        // check not registered\n        Diamond.DiamondCutData memory diamondCut = abi.decode(_diamondCut, (Diamond.DiamondCutData));\n\n        // check input\n        bytes32 cutHashInput = keccak256(_diamondCut);\n        require(cutHashInput == initialCutHash, \"StateTransition: initial cutHash mismatch\");\n\n        // construct init data\n        bytes memory initData;\n        /// all together 4+9*32=292 bytes\n        initData = bytes.concat(\n            IDiamondInit.initialize.selector,\n            bytes32(_chainId),\n            bytes32(uint256(uint160(bridgehub))),\n            bytes32(uint256(uint160(address(this)))),\n            bytes32(uint256(protocolVersion)),\n            bytes32(uint256(uint160(_admin))),\n            bytes32(uint256(uint160(validatorTimelock))),\n            bytes32(uint256(uint160(_baseToken))),\n            bytes32(uint256(uint160(_shar"
    }
  ]
}