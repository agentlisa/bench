{
  "Title": "[G-06] Arithmatic operations can be unchecked, since there is no underflow or overflow",
  "Content": "\nIn the `DistributionCreator.toggleTokenWhitelist` function implementation can be `unchecked` to save gas.\n\nThis function is used to toggle the value of `isWhitelistedToken[token]` between `0` adn `1`. Hence the arithematic operation can never underflow or overflow. Hence the `DistributionCreator.toggleTokenWhitelist` function can be updated as follows with the `unchecked` keyword.\n\n    function toggleTokenWhitelist(address token) external onlyGovernorOrGuardian {\n        unchecked{\n            uint256 toggleStatus = 1 - isWhitelistedToken[token];\n            isWhitelistedToken[token] = toggleStatus;\n        }\n        emit TokenWhitelistToggled(token, toggleStatus);\n    } \n\nhttps://github.com/AngleProtocol/merkl-contracts/blob/1825925daef8b22d9d6c0a2bc7aab3309342e786/contracts/DistributionCreator.sol#L398-L402<br>\nhttps://github.com/AngleProtocol/merkl-contracts/blob/1825925daef8b22d9d6c0a2bc7aab3309342e786/contracts/Distributor.sol#L266-L267<br>\nhttps://github.com/AngleProtocol/merkl-contracts/blob/1825925daef8b22d9d6c0a2bc7aab3309342e786/contracts/Distributor.sol#L273-L274<br>\nhttps://github.com/AngleProtocol/merkl-contracts/blob/1825925daef8b22d9d6c0a2bc7aab3309342e786/contracts/Distributor.sol#L208-L209<br>\nhttps://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/savings/Savings.sol#L221-L223\n\nIn the `SavingsVest.accrue()` function, when the protocol is under-collateralized and the `missing <= currentLockedProfit` the vesting profit updated as follows:\n\n            } else {\n                vestingProfit = currentLockedProfit - missing;\n                lastUpdate = uint64(block.timestamp);\n            }\n\nThis arithmetic operation can be unchecked due to previous check of `if (missing > currentLockedProfit)`.\n\nHence the above code snippet can be modified as follows:\n\n            } else {\n                unchecked{\n                    vestingProfit = currentLockedProfit - missing;\n                    lastUpdate = uint64(block.timestamp);\n                }\n            }\n\nhttps://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/savings/SavingsVest.sol#L134-L137\n\n**Status:** See [Mitigation Review](#mitigation-review) section below for details regarding mitigations related to gas optimizations.\n\n\n\n***\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-01-dev-test-repo",
  "Code": [
    {
      "filename": "contracts/DistributionCreator.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/*\n                  *                                                  █                              \n                *****                                               ▓▓▓                             \n                  *                                               ▓▓▓▓▓▓▓                         \n                                   *            ///.           ▓▓▓▓▓▓▓▓▓▓▓▓▓                       \n                                 *****        ////////            ▓▓▓▓▓▓▓                          \n                                   *       /////////////            ▓▓▓                             \n                     ▓▓                  //////////////////          █         ▓▓                   \n                   ▓▓  ▓▓             ///////////////////////                ▓▓   ▓▓                \n                ▓▓       ▓▓        ////////////////////////////           ▓▓        ▓▓              \n              ▓▓            ▓▓    /////////▓▓▓///////▓▓▓/////////       ▓▓             ▓▓            \n           ▓▓                 ,////////////////////////////////////// ▓▓                 ▓▓         \n        ▓▓                  //////////////////////////////////////////                     ▓▓      \n      ▓▓                  //////////////////////▓▓▓▓/////////////////////                          \n                       ,////////////////////////////////////////////////////                        \n                    .//////////////////////////////////////////////////////////                     \n                     .//////////////////////////██.,//////////////////////////█                     \n                       .//////////////////////████..,./////////////////////██                       \n                        ...////////////////███████.....,.////////////////███                        \n                          ,.,////////////████████ ........,///////////████                          \n                            .,.,//////█████████      ,.......///////████                            \n                               ,..//████████           ........./████                               \n                                 ..,██████                .....,███                                 \n                                    .██                     ,.,█                                    \n                                                                                                    \n                                                                                                    \n                                                                                                    \n               ▓▓            ▓▓▓▓▓▓▓▓▓▓       ▓▓▓▓▓▓▓▓▓▓        ▓▓               ▓▓▓▓▓▓▓▓▓▓          \n             ▓▓▓▓▓▓          ▓▓▓    ▓▓▓       ▓▓▓               ▓▓               ▓▓   ▓▓▓▓         \n           ▓▓▓    ▓▓▓        ▓▓▓    ▓▓▓       ▓▓▓    ▓▓▓        ▓▓               ▓▓▓▓▓             \n          ▓▓▓        ▓▓      ▓▓▓    ▓▓▓       ▓▓▓▓▓▓▓▓▓▓        ▓▓▓▓▓▓▓▓▓▓       ▓▓▓▓▓▓▓▓▓▓          \n*/\n\npragma solidity ^0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\nimport \"./interfaces/external/uniswap/IUniswapV3Pool.sol\";\nimport \"./interfaces/external/algebra/IAlgebraPool.sol\";\n\nimport \"./utils/UUPSHelper.sol\";\nimport \"./struct/DistributionParameters.sol\";\nimport \"./struct/ExtensiveDistributionParameters.sol\";\nimport \"./struct/RewardTokenAmounts.sol\";\n\n/// @title DistributionCreator\n/// @author Angle Labs, Inc.\n/// @notice Manages the distribution of rewards across different pools with concentrated liquidity (like on Uniswap V3)\n/// @dev This contract is mostly a helper for APIs built on top of Merkl\n/// @dev People depositing rewards must have signed a `message` with the conditions for using the\n/// product\n//solhint-disable\ncontract DistributionCreator is UUPSHelper, ReentrancyGuardUpgradeable {\n    using SafeERC20 for IERC20;\n\n    // =========================== CONSTANTS / VARIABLES ===========================\n\n    /// @notice Epoch duration\n    uint32 public constant EPOCH_DURATION = 3600;\n\n    /// @notice Base for fee computation\n    uint256 public constant BASE_9 = 1e9;\n\n    /// @notice `Core` contract handling access control\n    ICore public core;\n\n    /// @notice User contract for distributing rewards\n    address public distributor;\n\n    /// @notice Address to which fees are forwarded\n    address public feeRecipient;\n\n    /// @notice Value (in base 10**9) of the fees taken when creating a distribution for a pool which do not\n    /// have a whitelisted token in it\n    uint256 public fees;\n\n    /// @notice Message that needs to be acknowledged by users creating a distribution\n    string public message;\n\n    /// @notice Hash of the message that needs to be signed\n    bytes32 public messageHash;\n\n    /// @notice List of all rewards ever distributed or to be distributed in the contract\n    /// @dev An attacker could try to populate this list. It shouldn't be an issue as only view functions\n    /// iterate on it\n    DistributionParameters[] public distributionList;\n\n    /// @notice Maps an address to its fee rebate\n    mapping(address => uint256) public feeRebate;\n\n    /// @notice Maps a token to whether it is whitelisted or not. No fees are to be paid for incentives given\n    /// on pools with whitelisted tokens\n    mapping(address => uint256) public isWhitelistedToken;\n\n    /// @notice Maps an address to its nonce for creating a distribution\n    mapping(address => uint256) public nonces;\n\n    /// @notice Maps an address to the last valid hash signed\n    mapping(address => bytes32) public userSignatures;\n\n    /// @notice Maps a user to whether it is whitelisted for not signing\n    mapping(address => uint256) public userSignatureWhitelist;\n\n    /// @notice Maps a token to the minimum amount that must be sent per epoch for a distribution to be valid\n    /// @dev If `rewardTokenMinAmounts[token] == 0`, then `token` cannot be used as a reward\n    mapping(address => uint256) public rewardTokenMinAmounts;\n\n    /// @notice List of all reward tokens that have at some point been accepted\n    address[] public rewardTokens;\n\n    uint256[36] private __gap;\n\n    // =================================== EVENTS ==================================\n\n    event DistributorUpdated(address indexed _distributor);\n    event FeeRebateUpdated(address indexed user, uint256 userFeeRebate);\n    event FeeRecipientUpdated(address indexed _feeRecipient);\n    event FeesSet(uint256 _fees);\n    event MessageUpdated(bytes32 _messageHash);\n    event NewDistribution(DistributionParameters distribution, address indexed sender);\n    event RewardTokenMinimumAmountUpdated(address indexed token, uint256 amount);\n    event TokenWhitelistToggled(address indexed token, uint256 toggleStatus);\n    event UserSigned(bytes32 messageHash, address indexed user);\n    event UserSigningWhitelistToggled(address indexed user, uint256 toggleStatus);\n\n    // ================================= MODIFIERS =================================\n\n    /// @notice Checks whether the `msg.sender` has the governor role or the guardian role\n    modifier onlyGovernorOrGuardian() {\n        if (!core.isGovernorOrGuardian(msg.sender)) revert NotGovernorOrGuardian();\n        _;\n    }\n\n    /// @notice Checks whether an address has signed the message or not\n    modifier hasSigned() {\n        if (userSignatureWhitelist[msg.sender] == 0 && userSignatures[msg.sender] != messageHash) revert NotSigned();\n        _;\n    }\n\n    // ================================ CONSTRUCTOR ================================\n\n    function initialize(ICore _core, address _distributor, uint256 _fees) external initializer {\n        if (address(_core) == address(0) || _distributor == address(0)) revert ZeroAddress();\n        if (_fees > BASE_9) revert InvalidParam();\n        distributor = _distributor;\n        core = _core;\n        fees = _fees;\n    }\n\n    constructor() initializer {}\n\n    /// @inheritdoc UUPSUpgradeable\n    function _authorizeUpgrade(address) internal view override onlyGuardianUpgrader(core) {}\n\n    // ============================== DEPOSIT FUNCTION =============================\n\n    /// @notice Creates a `distribution` to incentivize a given pool for a specific period of time\n    /// @return distributionAmount How many reward tokens are actually taken into consideration in the contract\n    /// @dev If the address specified as a UniV3 pool is not effectively a pool, it will not be handled by the\n    /// distribution script and rewards may be lost\n    /// @dev Reward tokens sent as part of distributions must have been whitelisted before and amounts\n    /// sent should be bigger than a minimum amount specific to each token\n    /// @dev The `positionWrappers` specified in the `distribution` struct need to be supported by the script\n    /// List of supported `positionWrappers` can be found in the docs.\n    /// @dev If the pool incentivized contains one whitelisted token, then no fees are taken on the rewards\n    /// @dev This function reverts if the sender has not signed the message `messageHash` once through one of\n    /// the functions enabling to sign\n    function createDistribution(\n        DistributionParameters memory distribution\n    ) external hasSigned returns (uint256 distributionAmount) {\n        return _createDistribution(distribution);\n    }\n\n    /// @notice Same as the function above but for multiple distributions at once\n    /// @return List of all the distribution amounts actually deposited for each `distribution` in the `distributions` list\n    function createDistributions(\n        DistributionParameters[] memory distributions\n    ) external hasSigned returns (uint256[] memory) {\n        uint256 distributionsLength = distributions.length;\n        uint256[] memory distributionAmounts = new uint256[](distributionsLength);\n        for (uint256 i; i < distributionsLength; ) {\n            distributionAmounts[i] = _createDistribution(distributions[i]);\n            unchecked {\n                ++i;\n            }\n        }\n        return distributionAmounts;\n    }\n\n    /// @notice Checks whether the `msg.sender`'s `signature` is compatible with the message\n    /// to sign and stores the signature\n    /// @dev If you signed the message once, and the message has not been modified, then you do not\n    /// need to sign again\n    function sign(bytes calldata signature) external {\n        _sign(signature);\n    }\n\n    /// @notice Combines signing the message and creating a distribution\n    function signAndCreateDistribution(\n        DistributionParameters memory distribution,\n        bytes calldata signature\n    ) external returns (uint256 distributionAmount) {\n        _sign(signature);\n        return _createDistribution(distribution);\n    }\n\n    /// @notice Internal version of `createDistribution`\n    function _createDistribution(\n        DistributionParameters memory distribution\n    ) internal nonReentrant returns (uint256 distributionAmount) {\n        uint32 epochStart = _getRoundedEpoch(distribution.epochStart);\n        uint256 minDistributionAmount = rewardTokenMinAmounts[distribution.rewardToken];\n        distribution.epochStart = epochStart;\n        // Reward are not accepted in the following conditions:\n        if (\n            // if epoch parameters lead to a past distribution\n            epochStart + EPOCH_DURATION < block.timestamp ||\n            // if the amount of epochs for which this distribution should last is zero\n            distribution.numEpoch == 0 ||\n            // if the distribution parameters are not correctly specified\n            distribution.propFees + distribution.propToken0 + distribution.propToken1 != 1e4 ||\n            // if boosted addresses get less than non-boosted addresses in case of\n            (distribution.boostingAddress != address(0) && distribution.boostedReward < 1e4) ||\n            // if the type of the position wrappers is not well specified\n            distribution.positionWrappers.length != distribution.wrapperTypes.length ||\n            // if the reward token is not whitelisted as an incentive token\n            minDistributionAmount == 0 ||\n            // if the amount distributed is too small with respect to what is allowed\n            distribution.amount / distribution.numEpoch < minDistributionAmount\n        ) revert InvalidReward();\n        distributionAmount = distribution.amount;\n        // Computing fees: these are waived for whitelisted addresses and if there is a whitelisted token in a pool\n        uint256 userFeeRebate = feeRebate[msg.sender];\n        if (\n            userFeeRebate < BASE_9 &&\n            // Algebra pools also have these `token0` and `token1` parameters\n            isWhitelistedToken[IUniswapV3Pool(distribution.uniV3Pool).token0()] == 0 &&\n            isWhitelistedToken[IUniswapV3Pool(distribution.uniV3Pool).token1()] == 0\n        ) {\n            uint256 _fees = (fees * (BASE_9 - userFeeRebate)) / BASE_9;\n            uint256 distributionAmountMinusFees = (distributionAmount * (BASE_9 - _fees)) / BASE_9;\n            address _feeRecipient = feeRecipient;\n            _feeRecipient = _feeRecipient == address(0) ? address(this) : _feeRecipient;\n            IERC20(distribution.rewardToken).safeTransferFrom(\n                msg.sender,\n                _feeRecipient,\n                distributionAmount - distributionAmountMinusFees\n            );\n            distributionAmount = distributionAmountMinusFees;\n            distribution.amount = distributionAmount;\n        }\n\n        IERC20(distribution.rewardToken).safeTransferFrom(msg.sender, distributor, distributionAmount);\n        uint256 senderNonce = nonces[msg.sender];\n        nonces[msg.sender] = senderNonce + 1;\n        distribution.rewardId = bytes32(keccak256(abi.encodePacked(msg.sender, senderNonce)));\n        distributionList.push(distribution);\n        emit NewDistribution(distribution, msg.sender);\n    }\n\n    /// @notice Internal version of the `sign` function\n    function _sign(bytes calldata signature) internal {\n        bytes32 _messageHash = messageHash;\n        if (ECDSA.recover(_messageHash, signature) != msg.sender) revert InvalidSignature();\n        userSignatures[msg.sender] = _messageHash;\n        emit UserSigned(_messageHash, msg.sender);\n    }\n\n    // ================================= UI HELPERS ================================\n    // These functions are not to be queried on-chain and hence are not optimized for gas consumption\n\n    /// @notice Returns the list of all distributions ever made or to be done in the future\n    function getAllDistributions() external view returns (DistributionParameters[] memory) {\n        return distributionList;\n    }\n\n    /// @notice Returns the list of all currently active distributions on pools of supported AMMs (like Uniswap V3)\n    function getActiveDistributions() external view returns (ExtensiveDistributionParameters[] memory) {\n        uint32 roundedEpoch = _getRoundedEpoch(uint32(block.timestamp));\n        return _getPoolDistributionsBetweenEpochs(address(0), roundedEpoch, roundedEpoch + EPOCH_DURATION);\n    }\n\n    /// @notice Returns the list of all the reward tokens supported as well as their minimum amounts\n    function getValidRewardTokens() external view returns (RewardTokenAmounts[] memory) {\n        uint256 length;\n        uint256 rewardTokenListLength = rewardTokens.length;\n        RewardTokenAmounts[] memory validRewardTokens = new RewardTokenAmounts[](rewardTokenListLength);\n        for (uint32 i; i < rewardTokenListLength; ) {\n            address token = rewardTokens[i];\n            uint256 minAmount = rewardTokenMinAmounts[token];\n            if (minAmount > 0) {\n                validRewardTokens[length] = RewardTokenAmounts(token, minAmount);\n                length += 1;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        RewardTokenAmounts[] memory validRewardTokensShort = new RewardTokenAmounts[](length);\n        for (uint32 i; i < length; ) {\n            validRewardTokensShort[i] = validRewardTokens[i];\n            unchecked {\n                ++i;\n            }\n        }\n        return validRewardTokensShort;\n    }\n\n    /// @notice Returns the list of all the distributions that were or that are going to be live at\n    /// a specific epoch\n    function getDistributionsForEpoch(uint32 epoch) external view returns (ExtensiveDistributionParameters[] memory) {\n        uint32 roundedEpoch = _getRoundedEpoch(epoch);\n        return _getPoolDistributionsBetweenEpochs(address(0), roundedEpoch, roundedEpoch + EPOCH_DURATION);\n    }\n\n    /// @notice Gets the distributions that were or will be live at some point between `epochStart` (included) and `epochEnd` (excluded)\n    /// @dev If a distribution starts during `epochEnd`, it is not be returned by this function\n    /// @dev Conversely, if a distribution starts after `epochStart` and ends before `epochEnd`, it is returned by this function\n    function getDistributionsBetweenEpochs(\n        uint32 epochStart,\n        uint32 epochEnd\n    ) external view returns (ExtensiveDistributionParameters[] memory) {\n        return _getPoolDistributionsBetweenEpochs(address(0), _getRoundedEpoch(epochStart), _getRoundedEpoch(epochEnd));\n    }\n\n    /// @notice Returns the list of all distributions that were or will be live after `epochStart` (included)\n    function getDistributionsAfterEpoch(\n        uint32 epochStart\n    ) external view returns (ExtensiveDistributionParameters[] memory) {\n        return _getPoolDistributionsBetweenEpochs(address(0), _getRoundedEpoch(epochStart), type(uint32).max);\n    }\n\n    /// @notice Returns the list of all currently active distributions for a specific UniswapV3 pool\n    function getActivePoolDistributions(\n        address uniV3Pool\n    ) external view returns (ExtensiveDistributionParameters[] memory) {\n        uint32 roundedEpoch = _getRoundedEpoch(uint32(block.timestamp));\n        return _getPoolDistributionsBetweenEpochs(uniV3Pool, roundedEpoch, roundedEpoch + EPOCH_DURATION);\n    }\n\n    /// @notice Returns the list of all the distributions that were or that are going to be live at a\n    /// specific epoch and for a specific pool\n    function getPoolDistributionsForEpoch(\n        address uniV3Pool,\n        uint32 epoch\n    ) external view returns (ExtensiveDistributionParameters[] memory) {\n        uint32 roundedEpoch = _getRoundedEpoch(epoch);\n        return _getPoolDistributionsBetweenEpochs(uniV3Pool, roundedEpoch, roundedEpoch + EPOCH_DURATION);\n    }\n\n    /// @notice Returns the list of all distributions that were or will be live between `epochStart` (included) and `epochEnd` (excluded)\n    /// for a specific pool\n    function getPoolDistributionsBetweenEpochs(\n        address uniV3Pool,\n        uint32 epochStart,\n        uint32 epochEnd\n    ) external view returns (ExtensiveDistributionParameters[] memory) {\n        return _getPoolDistributionsBetweenEpochs(uniV3Pool, _getRoundedEpoch(epochStart), _getRoundedEpoch(epochEnd));\n    }\n\n    /// @notice Returns the list of all distributions that were or will be live after `epochStart` (included)\n    /// for a specific pool\n    function getPoolDistributionsAfterEpoch(\n        address uniV3Pool,\n        uint32 epochStart\n    ) external view returns (ExtensiveDistributionParameters[] memory) {\n        return _getPoolDistributionsBetweenEpochs(uniV3Pool, _getRoundedEpoch(epochStart), type(uint32).max);\n    }\n\n    // ============================ GOVERNANCE FUNCTIONS ===========================\n\n    /// @notice Sets a new `distributor` to which rewards should be distributed\n    function setNewDistributor(address _distributor) external onlyGovernorOrGuardian {\n        if (_distributor == address(0)) revert InvalidParam();\n        distributor = _distributor;\n        emit DistributorUpdated(_distributor);\n    }\n\n    /// @notice Sets the fees on deposit\n    function setFees(uint256 _fees) external onlyGovernorOrGuardian {\n        if (_fees >= BASE_9) revert InvalidParam();\n        fees = _fees;\n        emit FeesSet(_fees);\n    }\n\n    /// @notice Sets fee rebates for a given user\n    function setUserFeeRebate(address user, uint256 userFeeRebate) external onlyGovernorOrGuardian {\n        feeRebate[user] = userFeeRebate;\n        emit FeeRebateUpdated(user, userFeeRebate);\n    }\n\n    /// @notice Toggles the fee whitelist for `token`\n    function toggleTokenWhitelist(address token) external onlyGovernorOrGuardian {\n        uint256 toggleStatus = 1 - isWhitelistedToken[token];\n        isWhitelistedToken[token] = toggleStatus;\n        emit TokenWhitelistToggled(token, toggleStatus);\n    }\n\n    /// @notice Recovers fees accrued on the contract for a list of `tokens`\n    function recoverFees(IERC20[] calldata tokens, address to) external onlyGovernorOrGuardian {\n        uint256 tokensLength = tokens.length;\n        for (uint256 i; i < tokensLength; ) {\n            tokens[i].safeTransfer(to, tokens[i].balanceOf(address(this)));\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Sets the minimum amounts per distribution epoch for different reward tokens\n    function setRewardTokenMinAmounts(\n        address[] calldata tokens,\n        uint256[] calldata amounts\n    ) external onlyGovernorOrGuardian {\n        uint256 tokensLength = tokens.length;\n        for (uint256 i; i < tokensLength; ++i) {\n            uint256 amount = amounts[i];\n            // Basic logic check to make sure there are no duplicates in the `rewardTokens` table. If a token is\n            // removed then re-added, it will appear as a duplicate in the list\n            if (amount > 0 && rewardTokenMinAmounts[tokens[i]] == 0) rewardTokens.push(tokens[i]);\n            rewardTokenMinAmounts[tokens[i]] = amount;\n            emit RewardTokenMinimumAmountUpdated(tokens[i], amount);\n        }\n    }\n\n    /// @notice Sets a new address to receive fees\n    function setFeeRecipient(address _feeRecipient) external onlyGovernorOrGuardian {\n        feeRecipient = _feeRecipient;\n        emit FeeRecipientUpdated(_feeRecipient);\n    }\n\n    /// @notice Sets the message that needs to be signed by users before posting rewards\n    function setMessage(string memory _message) external onlyGovernorOrGuardian {\n        message = _message;\n        bytes32 _messageHash = ECDSA.toEthSignedMessageHash(bytes(_message));\n        messageHash = _messageHash;\n        emit MessageUpdated(_messageHash);\n    }\n\n    /// @notice Toggles the whitelist status for `user` when it comes to signing messages before depositing rewards.\n    function toggleSigningWhitelist(address user) external onlyGovernorOrGuardian {\n        uint256 whitelistStatus = 1 - userSignatureWhitelist[user];\n        userSignatureWhitelist[user] = whitelistStatus;\n        emit UserSigningWhitelistToggled(user, whitelistStatus);\n    }\n\n    // ============================== INTERNAL HELPERS =============================\n\n    /// @notice Rounds an `epoch` timestamp to the start of the corresponding period\n    function _getRoundedEpoch(uint32 epoch) internal pure returns (uint32) {\n        return (epoch / EPOCH_DURATION) * EPOCH_DURATION;\n    }\n\n    /// @notice Checks whether `distribution` was live between `roundedEpochStart` and `roundedEpochEnd`\n    function _isDistributionLiveBetweenEpochs(\n        DistributionParameters storage distribution,\n        uint32 roundedEpochStart,\n        uint32 roundedEpochEnd\n    ) internal view returns (bool) {\n        uint256 distributionEpochStart = distribution.epochStart;\n        return (distributionEpochStart + distribution.numEpoch * EPOCH_DURATION > roundedEpochStart &&\n            distributionEpochStart < roundedEpochEnd);\n    }\n\n    /// @notice Fetches data for `token` on the Uniswap `pool`\n    function _getUniswapTokenData(\n        IERC20Metadata token,\n        address pool\n    ) internal view returns (UniswapTokenData memory data) {\n        data.add = address(token);\n        data.decimals = token.decimals();\n        data.symbol = token.symbol();\n        data.poolBalance = token.balanceOf(pool);\n    }\n\n    /// @notice Fetches extra data about the parameters in a distribution\n    function _getExtensiveDistributionParameters(\n        DistributionParameters memory distribution\n    ) internal view returns (ExtensiveDistributionParameters memory extensiveParams) {\n        extensiveParams.base = distribution;\n        try IUniswapV3Pool(distribution.uniV3Pool).fee() returns (uint24 fee) {\n            extensiveParams.poolFee = fee;\n        } catch {\n            try IAlgebraPool(distribution.uniV3Pool).globalState() returns (\n                uint160,\n                int24,\n                uint16 fee,\n                uint16,\n                uint8,\n                uint8,\n                bool\n            ) {\n                extensiveParams.poolFee = uint24(fee);\n            } catch {\n                extensiveParams.poolFee = 0;\n            }\n        }\n        extensiveParams.token0 = _getUniswapTokenData(\n            IERC20Metadata(IUniswapV3Pool(distribution.uniV3Pool).token0()),\n            distribution.uniV3Pool\n        );\n        extensiveParams.token1 = _getUniswapTokenData(\n            IERC20Metadata(IUniswapV3Pool(distribution.uniV3Pool).token1()),\n            distribution.uniV3Pool\n        );\n        extensiveParams.rewardTokenSymbol = IERC20Metadata(distribution.rewardToken).symbol();\n        extensiveParams.rewardTokenDecimals = IERC20Metadata(distribution.rewardToken).decimals();\n    }\n\n    /// @notice Gets the list of all the distributions for `uniV3Pool` that have been active between `epochStart` and `epochEnd` (excluded)\n    /// @dev If the `uniV3Pool` parameter is equal to 0, then this function will return the distributions for all pools\n    function _getPoolDistributionsBetweenEpochs(\n        address uniV3Pool,\n        uint32 epochStart,\n        uint32 epochEnd\n    ) internal view returns (ExtensiveDistributionParameters[] memory) {\n        uint256 length;\n        uint256 distributionListLength = distributionList.length;\n        DistributionParameters[] memory longActiveRewards = new DistributionParameters[](distributionListLength);\n        for (uint32 i; i < distributionListLength; ) {\n            DistributionParameters storage distribution = distributionList[i];\n            if (\n                _isDistributionLiveBetweenEpochs(distribution, epochStart, epochEnd) &&\n                (uniV3Pool == address(0) || distribution.uniV3Pool == uniV3Pool)\n            ) {\n                longActiveRewards[length] = distribution;\n                length += 1;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        ExtensiveDistributionParameters[] memory activeRewards = new ExtensiveDistributionParameters[](length);\n        for (uint32 i; i < length; ) {\n            activeRewards[i] = _getExtensiveDistributionParameters(longActiveRewards[i]);\n            unchecked {\n                ++i;\n            }\n        }\n        return activeRewards;\n    }\n}"
    },
    {
      "filename": "contracts/Distributor.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/*\n                  *                                                  █                              \n                *****                                               ▓▓▓                             \n                  *                                               ▓▓▓▓▓▓▓                         \n                                   *            ///.           ▓▓▓▓▓▓▓▓▓▓▓▓▓                       \n                                 *****        ////////            ▓▓▓▓▓▓▓                          \n                                   *       /////////////            ▓▓▓                             \n                     ▓▓                  //////////////////          █         ▓▓                   \n                   ▓▓  ▓▓             ///////////////////////                ▓▓   ▓▓                \n                ▓▓       ▓▓        ////////////////////////////           ▓▓        ▓▓              \n              ▓▓            ▓▓    /////////▓▓▓///////▓▓▓/////////       ▓▓             ▓▓            \n           ▓▓                 ,////////////////////////////////////// ▓▓                 ▓▓         \n        ▓▓                  //////////////////////////////////////////                     ▓▓      \n      ▓▓                  //////////////////////▓▓▓▓/////////////////////                          \n                       ,////////////////////////////////////////////////////                        \n                    .//////////////////////////////////////////////////////////                     \n                     .//////////////////////////██.,//////////////////////////█                     \n                       .//////////////////////████..,./////////////////////██                       \n                        ...////////////////███████.....,.////////////////███                        \n                          ,.,////////////████████ ........,///////////████                          \n                            .,.,//////█████████      ,.......///////████                            \n                               ,..//████████           ........./████                               \n                                 ..,██████                .....,███                                 \n                                    .██                     ,.,█                                    \n                                                                                                    \n                                                                                                    \n                                                                                                    \n               ▓▓            ▓▓▓▓▓▓▓▓▓▓       ▓▓▓▓▓▓▓▓▓▓        ▓▓               ▓▓▓▓▓▓▓▓▓▓          \n             ▓▓▓▓▓▓          ▓▓▓    ▓▓▓       ▓▓▓               ▓▓               ▓▓   ▓▓▓▓         \n           ▓▓▓    ▓▓▓        ▓▓▓    ▓▓▓       ▓▓▓    ▓▓▓        ▓▓               ▓▓▓▓▓             \n          ▓▓▓        ▓▓      ▓▓▓    ▓▓▓       ▓▓▓▓▓▓▓▓▓▓        ▓▓▓▓▓▓▓▓▓▓       ▓▓▓▓▓▓▓▓▓▓          \n*/\n\npragma solidity ^0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"./utils/UUPSHelper.sol\";\n\nstruct MerkleTree {\n    // Root of a Merkle tree which leaves are `(address user, address token, uint amount)`\n    // representing an amount of tokens accumulated by `user`.\n    // The Merkle tree is assumed to have only increasing amounts: that is to say if a user can claim 1,\n    // then after the amount associated in the Merkle tree for this token should be x > 1\n    bytes32 merkleRoot;\n    // Ipfs hash of the tree data\n    bytes32 ipfsHash;\n}\n\nstruct Claim {\n    uint208 amount;\n    uint48 timestamp;\n}\n\n/// @title Distributor\n/// @notice Allows LPs on AMMs with concentrated liquidity to claim the rewards that were distributed to them\n/// @author Angle Labs. Inc\ncontract Distributor is UUPSHelper {\n    using SafeERC20 for IERC20;\n\n    /// @notice Epoch duration\n    uint32 internal constant _EPOCH_DURATION = 3600;\n\n    // ================================= VARIABLES =================================\n\n    /// @notice Tree of claimable tokens through this contract\n    MerkleTree public tree;\n\n    /// @notice Tree that was in place in the contract before the last `tree` update\n    MerkleTree public lastTree;\n\n    /// @notice Token to deposit to freeze the roots update\n    IERC20 public disputeToken;\n\n    /// @notice `Core` contract handling access control\n    ICore public core;\n\n    /// @notice Address which created the dispute\n    /// @dev Used to store if there is an ongoing dispute\n    address public disputer;\n\n    /// @notice When the current tree will become valid\n    uint48 public endOfDisputePeriod;\n\n    /// @notice Time before which a change in a tree becomes effective, in EPOCH_DURATION\n    uint48 public disputePeriod;\n\n    /// @notice Amount to deposit to freeze the roots update\n    uint256 public disputeAmount;\n\n    /// @notice Mapping user -> token -> amount to track claimed amounts\n    mapping(address => mapping(address => Claim)) public claimed;\n\n    /// @notice Trusted EOAs to update the Merkle root\n    mapping(address => uint256) public canUpdateMerkleRoot;\n\n    /// @notice Whether or not to disable permissionless claiming\n    mapping(address => uint256)"
    }
  ]
}