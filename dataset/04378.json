{
  "Title": "[L11] Unnecessary code repetition in Auction contract",
  "Content": "The `Auction` contract implements the functions [`getAuctionStartTime`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Auction.sol#L231) and [`getAuctionEndTime`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Auction.sol#L239), which implement the exact same logic except for [line 244](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Auction.sol#L244). Therefore, to favor simplicity and modularization, consider factoring out the repeated logic into a private function.\n\n\n***Update****: this issue is no longer valid as the* *`Auction`* *contract has been removed in* [*`f641c42`*](https://github.com/AugurProject/augur/commit/f641c42c47ca22d73e1e4184f6a5bb6e387e0630)*.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/augur-core/source/contracts/reporting/Auction.sol",
      "content": "pragma solidity 0.5.4;\n\nimport 'ROOT/reporting/IAuction.sol';\nimport 'ROOT/reporting/IUniverse.sol';\nimport 'ROOT/libraries/Initializable.sol';\nimport 'ROOT/reporting/IV2ReputationToken.sol';\nimport 'ROOT/reporting/IReputationToken.sol';\nimport 'ROOT/libraries/math/SafeMathUint256.sol';\nimport 'ROOT/reporting/Reporting.sol';\nimport 'ROOT/trading/ICash.sol';\nimport 'ROOT/reporting/IAuctionToken.sol';\nimport 'ROOT/factories/AuctionTokenFactory.sol';\n\n\ncontract Auction is Initializable, IAuction {\n    using SafeMathUint256 for uint256;\n\n    enum RoundType {\n        DORMANT_1,\n        DORMANT_2,\n        UNRECORDED,\n        DORMANT_3,\n        DORMANT_4,\n        DORMANT_5,\n        RECORDED\n    }\n\n    IAugur public augur;\n    IUniverse private universe;\n    IV2ReputationToken private reputationToken;\n    ICash public cash;\n    AuctionTokenFactory public auctionTokenFactory;\n    uint256 public initialRepPriceInAttoCash;\n\n    bool public bootstrapMode; // Indicates the auction is currently bootstrapping by selling off minted REP to get CASH for the CASH auction\n    bool public bootstrapped; // Records that a bootstrap initialization occurred. We can turn bootstrapping off if this has happened before.\n    uint256 public initializationTime; // The time this contract was uploaded and initialized. The auction cadence is relative to this time\n\n    uint256 public feeBalance; // The CASH this contract has received in fees.\n    uint256 public currentAuctionIndex; // The current auction index. Indicies starts at 0 relative to epoch where each week has 2\n    RoundType public currentRoundType; // The current auction type.\n    uint256 public initialAttoRepBalance; // The initial REP balance in attoREP considered for the current auction\n    uint256 public initialAttoCashBalance; // The initial CASH balance in attoCASH considered for the current auction\n    uint256 public initialRepSalePrice; // The initial price of REP in attoCASH for the current auction\n    uint256 public initialCashSalePrice; // The initial price of CASH in attoREP for the current auction\n    uint256 public lastRepPrice; // The last auction's Rep price in attoCASH, regardless of whether the result is used in determining reporting fees\n    uint256 public repPrice; // The Rep price in attoCASH that should be used to determine reporting fees during and immediately after an ignored auction.\n\n    function initialize(IAugur _augur, IUniverse _universe, IV2ReputationToken _reputationToken) public beforeInitialized returns (bool) {\n        endInitialization();\n        augur = _augur;\n        universe = _universe;\n        reputationToken = IV2ReputationToken(_reputationToken);\n        cash = ICash(augur.lookup(\"Cash\"));\n        auctionTokenFactory = AuctionTokenFactory(augur.lookup(\"AuctionTokenFactory\"));\n        initializationTime = augur.getTimestamp();\n        initialRepPriceInAttoCash = Reporting.getAuctionInitialRepPrice();\n        lastRepPrice = initialRepPriceInAttoCash;\n        repPrice = initialRepPriceInAttoCash;\n        bootstrapMode = true;\n        return true;\n    }\n\n    function initializeNewAuction() public returns (bool) {\n        uint256 _derivedRepPrice = getDerivedRepPriceInAttoCash();\n        if (currentRoundType == RoundType.RECORDED) {\n            repPrice = _derivedRepPrice;\n        }\n        lastRepPrice = _derivedRepPrice;\n        currentRoundType = getRoundType();\n        uint256 _currentAuctionIndex = getAuctionIndexForCurrentTime();\n        require(currentRoundType == RoundType.UNRECORDED || currentRoundType == RoundType.RECORDED);\n        require(currentAuctionIndex != _currentAuctionIndex);\n        if (bootstrapped) {\n            bootstrapMode = false;\n        }\n        require(!bootstrapMode || currentRoundType == RoundType.UNRECORDED);\n        bootstrapped = true;\n\n        // Get any funds from the previously participated in auction that are set to be distributed\n        if (repAuctionToken != IAuctionToken(0)) {\n            repAuctionToken.retrieveFunds();\n        }\n        if (cashAuctionToken != IAuctionToken(0)) {\n            cashAuctionToken.retrieveFunds();\n        }\n\n        uint256 _auctionRepBalanceTarget = reputationToken.totalSupply() / Reporting.getAuctionTargetSupplyDivisor();\n        uint256 _repBalance = reputationToken.balanceOf(address(this));\n\n        if (_repBalance < _auctionRepBalanceTarget) {\n            reputationToken.mintForAuction(_auctionRepBalanceTarget.sub(_repBalance));\n        }\n\n        initialAttoRepBalance = reputationToken.balanceOf(address(this));\n        initialAttoCashBalance = cash.balanceOf(address(this));\n\n        currentAuctionIndex = _currentAuctionIndex;\n\n        initialRepSalePrice = lastRepPrice.mul(Reporting.getAuctionInitialPriceMultiplier());\n        initialCashSalePrice = Reporting.getAuctionInitialPriceMultiplier().mul(10**36).div(lastRepPrice);\n\n        // Create and fund Tokens\n        repAuctionToken = auctionTokenFactory.createAuctionToken(augur, this, reputationToken, currentAuctionIndex);\n        if (!bootstrapMode) {\n            cashAuctionToken = auctionTokenFactory.createAuctionToken(augur, this, cash, currentAuctionIndex);\n            cash.transfer(address(cashAuctionToken), initialAttoCashBalance);\n        }\n        augur.recordAuctionTokens(universe);\n\n        reputationToken.transfer(address(repAuctionToken), initialAttoRepBalance);\n        return true;\n    }\n\n    function initializeNewAuctionIfNeeded() private returns (bool) {\n        if (currentAuctionIndex != getAuctionIndexForCurrentTime()) {\n            initializeNewAuction();\n        }\n        return true;\n    }\n\n    function tradeRepForCash(uint256 _attoCashAmount) public returns (bool) {\n        initializeNewAuctionIfNeeded();\n        require(!bootstrapMode);\n        uint256 _currentAttoCashBalance = getCurrentAttoCashBalance();\n        require(_currentAttoCashBalance > 0);\n        require(_attoCashAmount > 0);\n        _attoCashAmount = _attoCashAmount.min(_currentAttoCashBalance);\n        uint256 _cashPriceInAttoRep = getCashSalePriceInAttoRep();\n        uint256 _attoRepCost = _attoCashAmount.mul(_cashPriceInAttoRep) / 10**18;\n        reputationToken.trustedAuctionTransfer(msg.sender, address(this), _attoRepCost);\n        cashAuctionToken.mintForPurchaser(msg.sender, _attoRepCost);\n        return true;\n    }\n\n    function tradeCashForRep(uint256 _attoRepAmount) public payable returns (bool) {\n        initializeNewAuctionIfNeeded();\n        uint256 _currentAttoRepBalance = getCurrentAttoRepBalance();\n        require(_currentAttoRepBalance > 0);\n        require(_attoRepAmount > 0);\n        _attoRepAmount = _attoRepAmount.min(_currentAttoRepBalance);\n        uint256 _repPriceInAttoCash = getRepSalePriceInAttoCash();\n        uint256 _attoCashCost = _attoRepAmount.mul(_repPriceInAttoCash) / 10**18;\n        // This will raise an exception if insufficient CASH was sent\n        augur.trustedTransfer(cash, msg.sender, address(this), _attoCashCost);\n        repAuctionToken.mintForPurchaser(msg.sender, _attoCashCost);\n        return true;\n    }\n\n    function getRepSalePriceInAttoCash() public returns (uint256) {\n        initializeNewAuctionIfNeeded();\n        uint256 _timePassed = augur.getTimestamp().sub(initializationTime).sub(currentAuctionIndex * 1 days);\n        uint256 _priceDecrease = initialRepSalePrice.mul(_timePassed) / Reporting.getAuctionDuration();\n        return initialRepSalePrice.sub(_priceDecrease);\n    }\n\n    function getCashSalePriceInAttoRep() public returns (uint256) {\n        initializeNewAuctionIfNeeded();\n        require(!bootstrapMode);\n        uint256 _timePassed = augur.getTimestamp().sub(initializationTime).sub(currentAuctionIndex * 1 days);\n        uint256 _priceDecrease = initialCashSalePrice.mul(_timePassed) / Reporting.getAuctionDuration();\n        return initialCashSalePrice.sub(_priceDecrease);\n    }\n\n    function getCurrentAttoRepBalance() public returns (uint256) {\n        uint256 _repSalePriceInAttoCash = getRepSalePriceInAttoCash();\n        uint256 _cashSupply = repAuctionToken.maxSupply();\n        uint256 _attoRepSold = _cashSupply.mul(10**18).div(_repSalePriceInAttoCash);\n        if (_attoRepSold >= initialAttoRepBalance) {\n            return 0;\n        }\n        return initialAttoRepBalance.sub(_attoRepSold);\n    }\n\n    function getCurrentAttoCashBalance() public returns (uint256) {\n        uint256 _cashSalePriceInAttoRep = getCashSalePriceInAttoRep();\n        uint256 _repSupply = cashAuctionToken.maxSupply();\n        uint256 _attoCashSold = _repSupply.mul(10**18).div(_cashSalePriceInAttoRep);\n        if (_attoCashSold >= initialAttoCashBalance) {\n            return 0;\n        }\n        return initialAttoCashBalance.sub(_attoCashSold);\n    }\n\n    function auctionOver(IAuctionToken _auctionToken) public returns (bool) {\n        if (_auctionToken == repAuctionToken) {\n            return getCurrentAttoRepBalance() == 0;\n        } else if (_auctionToken == cashAuctionToken) {\n            return getCurrentAttoCashBalance() == 0;\n        }\n        return true;\n    }\n\n    function getDerivedRepPriceInAttoCash() public view returns (uint256) {\n        if (repAuctionToken == IAuctionToken(0) || cashAuctionToken == IAuctionToken(0)) {\n            return repPrice;\n        }\n        uint256 _repAuctionTokenMaxSupply = repAuctionToken.maxSupply();\n        uint256 _cashAuctionTokenMaxSupply = cashAuctionToken.maxSupply();\n        if (_repAuctionTokenMaxSupply == 0 || _cashAuctionTokenMaxSupply == 0) {\n            return repPrice;\n        }\n        uint256 _upperBoundRepPrice = repAuctionToken.maxSupply().mul(10**18).div(initialAttoRepBalance);\n        uint256 _lowerBoundRepPrice = initialAttoCashBalance.mul(10**18).div(_cashAuctionTokenMaxSupply);\n        return _upperBoundRepPrice.add(_lowerBoundRepPrice) / 2;\n    }\n\n    function getRepPriceInAttoCash() public view returns (uint256) {\n        // If this auction is over and it is a recorded auction use the price it found\n        if (getAuctionIndexForCurrentTime() != currentAuctionIndex && currentRoundType == RoundType.RECORDED) {\n            return getDerivedRepPriceInAttoCash();\n        }\n\n        return repPrice;\n    }\n\n    function getAuctionIndexForCurrentTime() public view returns (uint256) {\n        return augur.getTimestamp().sub(initializationTime) / Reporting.getAuctionDuration();\n    }\n\n    function isActive() public view returns (bool) {\n        RoundType _roundType = getRoundType();\n        return _roundType == RoundType.UNRECORDED || _roundType == RoundType.RECORDED;\n    }\n\n    function getRoundType() public view returns (RoundType) {\n        uint256 _auctionDay = getAuctionIndexForCurrentTime() % 7;\n        return RoundType(_auctionDay);\n    }\n\n    function getAuctionStartTime() public view returns (uint256) {\n        uint256 _auctionIndex = getAuctionIndexForCurrentTime();\n        uint256 _auctionDay = _auctionIndex % 7;\n        uint256 _weekStart = initializationTime.add(_auctionIndex).sub(_auctionDay);\n        uint256 _addedTime = _auctionDay > uint256(RoundType.UNRECORDED) ? uint256(RoundType.RECORDED) : uint256(RoundType.UNRECORDED);\n        return _weekStart.add(_addedTime.mul(Reporting.getAuctionDuration()));\n    }\n\n    function getAuctionEndTime() public view returns (uint256) {\n        uint256 _auctionIndex = getAuctionIndexForCurrentTime();\n        uint256 _auctionDay = _auctionIndex % 7;\n        uint256 _weekStart = initializationTime.add(_auctionIndex).sub(_auctionDay);\n        uint256 _addedTime = _auctionDay > uint256(RoundType.UNRECORDED) ? uint256(RoundType.RECORDED) : uint256(RoundType.UNRECORDED);\n        _addedTime += 1;\n        return _weekStart.add(_addedTime.mul(Reporting.getAuctionDuration()));\n    }\n\n    function getUniverse() public view returns (IUniverse) {\n        return universe;\n    }\n\n    function getReputationToken() public view returns (IReputationToken) {\n        return IReputationToken(reputationToken);\n    }\n}"
    }
  ]
}