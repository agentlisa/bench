{
  "Title": "[G-04] Using bools for storage incurs overhead (3 instances)",
  "Content": "\n*   Deployment. Gas Saved: **20 221**\n\n*   Minumal Method Call. Gas Saved: **266**\n\n*   Average Method Call. Gas Saved: **-990**\n\n*   Maximum Method Call. Gas Saved: **-5 979**\n\n<!---->\n\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\nUse uint256(1) and uint256(2) for true/false to avoid a Gwarmaccess (100 gas) for the extra SLOAD, and to avoid Gsset (20000 gas) when changing from 'false' to 'true', after having been 'true' in the past\n\n### src/ERC20/ERC20PermitPermissionedMint.sol:[20](https://github.com/code-423n4/2022-09-frax/blob/55ea6b1ef3857a277e2f47d42029bc0f3d6f9173/src/ERC20/ERC20PermitPermissionedMint.sol#L20)\n\n```diff\ndiff --git a/src/ERC20/ERC20PermitPermissionedMint.sol b/src/ERC20/ERC20PermitPermissionedMint.sol\nindex 3bed26d..a5d0aab 100644\n--- a/src/ERC20/ERC20PermitPermissionedMint.sol\n+++ b/src/ERC20/ERC20PermitPermissionedMint.sol\n@@ -17,7 +17,7 @@ contract ERC20PermitPermissionedMint is ERC20Permit, ERC20Burnable, Owned {\n   17,  17:\n   18,  18:     // Minters\n   19,  19:     address[] public minters_array; // Allowed to mint\n-  20     :-    mapping(address => bool) public minters; // Mapping is also used for faster verification\n+       20:+    mapping(address => uint256) public minters; // Mapping is also used for faster verification\n   21,  21:\n   22,  22:     /* ========== CONSTRUCTOR ========== */\n   23,  23:\n@@ -43,7 +43,7 @@ contract ERC20PermitPermissionedMint is ERC20Permit, ERC20Burnable, Owned {\n   43,  43:     }\n   44,  44:\n   45,  45:     modifier onlyMinters() {\n-  46     :-       require(minters[msg.sender] == true, \"Only minters\");\n+       46:+       require(minters[msg.sender] == 1, \"Only minters\");\n   47,  47:         _;\n   48,  48:     }\n   49,  49:\n@@ -65,8 +65,8 @@ contract ERC20PermitPermissionedMint is ERC20Permit, ERC20Burnable, Owned {\n   65,  65:     function addMinter(address minter_address) public onlyByOwnGov {\n   66,  66:         require(minter_address != address(0), \"Zero address detected\");\n   67,  67:\n-  68     :-        require(minters[minter_address] == false, \"Address already exists\");\n-  69     :-        minters[minter_address] = true;\n+       68:+        require(minters[minter_address] == 0, \"Address already exists\");\n+       69:+        minters[minter_address] = 1;\n   70,  70:         minters_array.push(minter_address);\n   71,  71:\n   72,  72:         emit MinterAdded(minter_address);\n@@ -75,7 +75,7 @@ contract ERC20PermitPermissionedMint is ERC20Permit, ERC20Burnable, Owned {\n   75,  75:     // Remove a minter\n   76,  76:     function removeMinter(address minter_address) public onlyByOwnGov {\n   77,  77:         require(minter_address != address(0), \"Zero address detected\");\n-  78     :-        require(minters[minter_address] == true, \"Address nonexistant\");\n+       78:+        require(minters[minter_address] == 1, \"Address nonexistant\");\n   79,  79:\n   80,  80:         // Delete from the mapping\n   81,  81:         delete minters[minter_address];\n```\n\n### src/frxETHMinter.sol:[43](https://github.com/code-423n4/2022-09-frax/blob/55ea6b1ef3857a277e2f47d42029bc0f3d6f9173/src/frxETHMinter.sol#L43), [49-50](https://github.com/code-423n4/2022-09-frax/blob/55ea6b1ef3857a277e2f47d42029bc0f3d6f9173/src/frxETHMinter.sol#L49-L50)\n\n```diff\ndiff --git a/src/frxETHMinter.sol b/src/frxETHMinter.sol\nindex 4565883..3036cea 100644\n--- a/src/frxETHMinter.sol\n+++ b/src/frxETHMinter.sol\n@@ -40,14 +40,14 @@ contract frxETHMinter is OperatorRegistry, ReentrancyGuard {\n   40,  40:\n   41,  41:     uint256 public withholdRatio; // What we keep and don't deposit whenever someone submit()'s ETH\n   42,  42:     uint256 public currentWithheldETH; // Needed for internal tracking\n-  43     :-    mapping(bytes => bool) public activeValidators; // Tracks validators (via their pubkeys) that already have 32 ETH in them\n+       43:+    mapping(bytes => uint256) public activeValidators; // Tracks validators (via their pubkeys) that already have 32 ETH in them\n   44,  44:\n   45,  45:     IDepositContract public immutable depositContract; // ETH 2.0 deposit contract\n   46,  46:     frxETH public immutable frxETHToken;\n   47,  47:     IsfrxETH public immutable sfrxETHToken;\n   48,  48:\n-  49     :-    bool public submitPaused;\n-  50     :-    bool public depositEtherPaused;\n+       49:+    uint256 public submitPaused;\n+       50:+    uint256 public depositEtherPaused;\n   51,  51:\n   52,  52:     constructor(\n   53,  53:         address depositContractAddress,\n@@ -84,7 +84,7 @@ contract frxETHMinter is OperatorRegistry, ReentrancyGuard {\n   84,  84:     /// @notice Mint frxETH to the recipient using sender's funds. Internal portion\n   85,  85:     function _submit(address recipient) internal nonReentrant {\n   86,  86:         // Initial pause and value checks\n-  87     :-        require(!submitPaused, \"Submit is paused\");\n+       87:+        require(0==submitPaused, \"Submit is paused\");\n   88,  88:         require(msg.value != 0, \"Cannot submit 0\");\n   89,  89:\n   90,  90:         // Give the sender frxETH\n@@ -119,7 +119,7 @@ contract frxETHMinter is OperatorRegistry, ReentrancyGuard {\n  119, 119:     /// @dev Usually a bot will call this periodically\n  120, 120:     function depositEther() external nonReentrant {\n  121, 121:         // Initial pause check\n- 122     :-        require(!depositEtherPaused, \"Depositing ETH is paused\");\n+      122:+        require(0==depositEtherPaused, \"Depositing ETH is paused\");\n  123, 123:\n  124, 124:         // See how many deposits can be made. Truncation desired.\n  125, 125:         uint256 numDeposits = (address(this).balance - currentWithheldETH) / DEPOSIT_SIZE;\n@@ -137,7 +137,7 @@ contract frxETHMinter is OperatorRegistry, ReentrancyGuard {\n  137, 137:\n  138, 138:             // Make sure the validator hasn't been deposited into already, to prevent stranding an extra 32 eth\n  139, 139:             // until withdrawals are allowed\n- 140     :-            require(!activeValidators[pubKey], \"Validator already has 32 ETH\");\n+      140:+            require(0==activeValidators[pubKey], \"Validator already has 32 ETH\");\n  141, 141:\n  142, 142:             // Deposit the ether in the ETH 2.0 deposit contract\n  143, 143:             depositContract.deposit{value: DEPOSIT_SIZE}(\n@@ -148,7 +148,7 @@ contract frxETHMinter is OperatorRegistry, ReentrancyGuard {\n  148, 148:             );\n  149, 149:\n  150, 150:             // Set the validator as used so it won't get an extra 32 ETH\n- 151     :-            activeValidators[pubKey] = true;\n+      151:+            activeValidators[pubKey] = 1;\n  152, 152:\n  153, 153:             emit DepositSent(pubKey, withdrawalCredential);\n  154, 154:         }\n@@ -175,14 +175,14 @@ contract frxETHMinter is OperatorRegistry, ReentrancyGuard {\n  175, 175:\n  176, 176:     /// @notice Toggle allowing submites\n  177, 177:     function togglePauseSubmits() external onlyByOwnGov {\n- 178     :-        submitPaused = !submitPaused;\n+      178:+        submitPaused = submitPaused==1?0:1;\n  179, 179:\n  180, 180:         emit SubmitPaused(submitPaused);\n  181, 181:     }\n  182, 182:\n  183, 183:     /// @notice Toggle allowing depositing ETH to validators\n  184, 184:     function togglePauseDepositEther() external onlyByOwnGov {\n- 185     :-        depositEtherPaused = !depositEtherPaused;\n+      185:+        depositEtherPaused = depositEtherPaused==1?0:1;\n  186, 186:\n  187, 187:         emit DepositEtherPaused(depositEtherPaused);\n  188, 188:     }\n@@ -205,9 +205,9 @@ contract frxETHMinter is OperatorRegistry, ReentrancyGuard {\n  205, 205:     event EmergencyEtherRecovered(uint256 amount);\n  206, 206:     event EmergencyERC20Recovered(address tokenAddress, uint256 tokenAmount);\n  207, 207:     event ETHSubmitted(address indexed sender, address indexed recipient, uint256 sent_amount, uint256 withheld_amt);\n- 208     :-    event DepositEtherPaused(bool new_status);\n+      208:+    event DepositEtherPaused(uint256 new_status);\n  209, 209:     event DepositSent(bytes indexed pubKey, bytes withdrawalCredential);\n- 210     :-    event SubmitPaused(bool new_status);\n+      210:+    event SubmitPaused(uint256 new_status);\n  211, 211:     event WithheldETHMoved(address indexed to, uint256 amount);\n  212, 212:     event WithholdRatioSet(uint256 newRatio);\n  213, 213: }\n```\n\n***\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-09-frax",
  "Code": [
    {
      "filename": "src/ERC20/ERC20PermitPermissionedMint.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"../Utils/Owned.sol\";\n\n/// @title Parent contract for frxETH.sol\n/** @notice Combines Openzeppelin's ERC20Permit and ERC20Burnable with Synthetix's Owned. \n    Also includes a list of authorized minters */\n/// @dev frxETH adheres to EIP-712/EIP-2612 and can use permits\ncontract ERC20PermitPermissionedMint is ERC20Permit, ERC20Burnable, Owned {\n    // Core\n    address public timelock_address;\n\n    // Minters\n    address[] public minters_array; // Allowed to mint\n    mapping(address => bool) public minters; // Mapping is also used for faster verification\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _creator_address,\n        address _timelock_address,\n        string memory _name,\n        string memory _symbol\n    ) \n    ERC20(_name, _symbol)\n    ERC20Permit(_name) \n    Owned(_creator_address)\n    {\n      timelock_address = _timelock_address;\n    }\n\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyByOwnGov() {\n        require(msg.sender == timelock_address || msg.sender == owner, \"Not owner or timelock\");\n        _;\n    }\n\n    modifier onlyMinters() {\n       require(minters[msg.sender] == true, \"Only minters\");\n        _;\n    } \n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    // Used by minters when user redeems\n    function minter_burn_from(address b_address, uint256 b_amount) public onlyMinters {\n        super.burnFrom(b_address, b_amount);\n        emit TokenMinterBurned(b_address, msg.sender, b_amount);\n    }\n\n    // This function is what other minters will call to mint new tokens \n    function minter_mint(address m_address, uint256 m_amount) public onlyMinters {\n        super._mint(m_address, m_amount);\n        emit TokenMinterMinted(msg.sender, m_address, m_amount);\n    }\n\n    // Adds whitelisted minters \n    function addMinter(address minter_address) public onlyByOwnGov {\n        require(minter_address != address(0), \"Zero address detected\");\n\n        require(minters[minter_address] == false, \"Address already exists\");\n        minters[minter_address] = true; \n        minters_array.push(minter_address);\n\n        emit MinterAdded(minter_address);\n    }\n\n    // Remove a minter \n    function removeMinter(address minter_address) public onlyByOwnGov {\n        require(minter_address != address(0), \"Zero address detected\");\n        require(minters[minter_address] == true, \"Address nonexistant\");\n        \n        // Delete from the mapping\n        delete minters[minter_address];\n\n        // 'Delete' from the array by setting the address to 0x0\n        for (uint i = 0; i < minters_array.length; i++){ \n            if (minters_array[i] == minter_address) {\n                minters_array[i] = address(0); // This will leave a null in the array and keep the indices the same\n                break;\n            }\n        }\n\n        emit MinterRemoved(minter_address);\n    }\n\n    function setTimelock(address _timelock_address) public onlyByOwnGov {\n        require(_timelock_address != address(0), \"Zero address detected\"); \n        timelock_address = _timelock_address;\n        emit TimelockChanged(_timelock_address);\n    }\n\n    /* ========== EVENTS ========== */\n    \n    event TokenMinterBurned(address indexed from, address indexed to, uint256 amount);\n    event TokenMinterMinted(address indexed from, address indexed to, uint256 amount);\n    event MinterAdded(address minter_address);\n    event MinterRemoved(address minter_address);\n    event TimelockChanged(address timelock_address);\n}"
    },
    {
      "filename": "src/frxETHMinter.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n// ====================================================================\n// |     ______                   _______                             |\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\n// |                                                                  |\n// ====================================================================\n// ============================ frxETHMinter ==========================\n// ====================================================================\n// Frax Finance: https://github.com/FraxFinance\n\n// Primary Author(s)\n// Jack Corddry: https://github.com/corddry\n// Justin Moore: https://github.com/0xJM\n\n// Reviewer(s) / Contributor(s)\n// Travis Moore: https://github.com/FortisFortuna\n// Dennis: https://github.com/denett\n// Jamie Turley: https://github.com/jyturley\n\nimport { frxETH } from \"./frxETH.sol\";\nimport { IsfrxETH } from \"./IsfrxETH.sol\";\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport { IDepositContract } from \"./DepositContract.sol\";\nimport \"./OperatorRegistry.sol\";\n\n/// @title Authorized minter contract for frxETH\n/// @notice Accepts user-supplied ETH and converts it to frxETH (submit()), and also optionally inline stakes it for sfrxETH (submitAndDeposit())\n/** @dev Has permission to mint frxETH. \n    Once +32 ETH has accumulated, adds it to a validator, which then deposits it for ETH 2.0 staking (depositEther())\n    Withhold ratio refers to what percentage of ETH this contract keeps whenever a user makes a deposit. 0% is kept initially */\ncontract frxETHMinter is OperatorRegistry, ReentrancyGuard {    \n    uint256 public constant DEPOSIT_SIZE = 32 ether; // ETH 2.0 minimum deposit size\n    uint256 public constant RATIO_PRECISION = 1e6; // 1,000,000 \n\n    uint256 public withholdRatio; // What we keep and don't deposit whenever someone submit()'s ETH\n    uint256 public currentWithheldETH; // Needed for internal tracking\n    mapping(bytes => bool) public activeValidators; // Tracks validators (via their pubkeys) that already have 32 ETH in them\n\n    IDepositContract public immutable depositContract; // ETH 2.0 deposit contract\n    frxETH public immutable frxETHToken;\n    IsfrxETH public immutable sfrxETHToken;\n\n    bool public submitPaused;\n    bool public depositEtherPaused;\n\n    constructor(\n        address depositContractAddress, \n        address frxETHAddress, \n        address sfrxETHAddress, \n        address _owner, \n        address _timelock_address,\n        bytes memory _withdrawalCredential\n    ) OperatorRegistry(_owner, _timelock_address, _withdrawalCredential) {\n        depositContract = IDepositContract(depositContractAddress);\n        frxETHToken = frxETH(frxETHAddress);\n        sfrxETHToken = IsfrxETH(sfrxETHAddress);\n        withholdRatio = 0; // No ETH is withheld initially\n        currentWithheldETH = 0;\n    }\n\n    /// @notice Mint frxETH and deposit it to receive sfrxETH in one transaction\n    /** @dev Could try using EIP-712 / EIP-2612 here in the future if you replace this contract,\n        but you might run into msg.sender vs tx.origin issues with the ERC4626 */\n    function submitAndDeposit(address recipient) external payable returns (uint256 shares) {\n        // Give the frxETH to this contract after it is generated\n        _submit(address(this));\n\n        // Approve frxETH to sfrxETH for staking\n        frxETHToken.approve(address(sfrxETHToken), msg.value);\n\n        // Deposit the frxETH and give the generated sfrxETH to the final recipient\n        uint256 sfrxeth_recieved = sfrxETHToken.deposit(msg.value, recipient);\n        require(sfrxeth_recieved > 0, 'No sfrxETH was returned');\n\n        return sfrxeth_recieved;\n    }\n\n    /// @notice Mint frxETH to the recipient using sender's funds. Internal portion\n    function _submit(address recipient) internal nonReentrant {\n        // Initial pause and value checks\n        require(!submitPaused, \"Submit is paused\");\n        require(msg.value != 0, \"Cannot submit 0\");\n\n        // Give the sender frxETH\n        frxETHToken.minter_mint(recipient, msg.value);\n\n        // Track the amount of ETH that we are keeping\n        uint256 withheld_amt = 0;\n        if (withholdRatio != 0) {\n            withheld_amt = (msg.value * withholdRatio) / RATIO_PRECISION;\n            currentWithheldETH += withheld_amt;\n        }\n\n        emit ETHSubmitted(msg.sender, recipient, msg.value, withheld_amt);\n    }\n\n    /// @notice Mint frxETH to the sender depending on the ETH value sent\n    function submit() external payable {\n        _submit(msg.sender);\n    }\n\n    /// @notice Mint frxETH to the recipient using sender's funds\n    function submitAndGive(address recipient) external payable {\n        _submit(recipient);\n    }\n\n    /// @notice Fallback to minting frxETH to the sender\n    receive() external payable {\n        _submit(msg.sender);\n    }\n\n    /// @notice Deposit batches of ETH to the ETH 2.0 deposit contract\n    /// @dev Usually a bot will call this periodically\n    function depositEther() external nonReentrant {\n        // Initial pause check\n        require(!depositEtherPaused, \"Depositing ETH is paused\");\n\n        // See how many deposits can be made. Truncation desired.\n        uint256 numDeposits = (address(this).balance - currentWithheldETH) / DEPOSIT_SIZE;\n        require(numDeposits > 0, \"Not enough ETH in contract\");\n\n        // Give each deposit chunk to an empty validator\n        for (uint256 i = 0; i < numDeposits; ++i) {\n            // Get validator information\n            (\n                bytes memory pubKey,\n                bytes memory withdrawalCredential,\n                bytes memory signature,\n                bytes32 depositDataRoot\n            ) = getNextValidator(); // Will revert if there are not enough free validators\n\n            // Make sure the validator hasn't been deposited into already, to prevent stranding an extra 32 eth\n            // until withdrawals are allowed\n            require(!activeValidators[pubKey], \"Validator already has 32 ETH\");\n\n            // Deposit the ether in the ETH 2.0 deposit contract\n            depositContract.deposit{value: DEPOSIT_SIZE}(\n                pubKey,\n                withdrawalCredential,\n                signature,\n                depositDataRoot\n            );\n\n            // Set the validator as used so it won't get an extra 32 ETH\n            activeValidators[pubKey] = true;\n\n            emit DepositSent(pubKey, withdrawalCredential);\n        }\n    }\n\n    /// @param newRatio of ETH that is sent to deposit contract vs withheld, 1e6 precision\n    /// @notice An input of 1e6 results in 100% of Eth deposited, 0% withheld\n    function setWithholdRatio(uint256 newRatio) external onlyByOwnGov {\n        require (newRatio <= RATIO_PRECISION, \"Ratio cannot surpass 100%\");\n        withholdRatio = newRatio;\n        emit WithholdRatioSet(newRatio);\n    }\n\n    /// @notice Give the withheld ETH to the \"to\" address\n    function moveWithheldETH(address payable to, uint256 amount) external onlyByOwnGov {\n        require(amount <= currentWithheldETH, \"Not enough withheld ETH in contract\");\n        currentWithheldETH -= amount;\n\n        (bool success,) = payable(to).call{ value: amount }(\"\");\n        require(success, \"Invalid transfer\");\n\n        emit WithheldETHMoved(to, amount);\n    }\n\n    /// @notice Toggle allowing submites\n    function togglePauseSubmits() external onlyByOwnGov {\n        submitPaused = !submitPaused;\n\n        emit SubmitPaused(submitPaused);\n    }\n\n    /// @notice Toggle allowing depositing ETH to validators\n    function togglePauseDepositEther() external onlyByOwnGov {\n        depositEtherPaused = !depositEtherPaused;\n\n        emit DepositEtherPaused(depositEtherPaused);\n    }\n\n    /// @notice For emergencies if something gets stuck\n    function recoverEther(uint256 amount) external onlyByOwnGov {\n        (bool success,) = address(owner).call{ value: amount }(\"\");\n        require(success, \"Invalid transfer\");\n\n        emit EmergencyEtherRecovered(amount);\n    }\n\n    /// @notice For emergencies if someone accidentally sent some ERC20 tokens here\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyByOwnGov {\n        require(IERC20(tokenAddress).transfer(owner, tokenAmount), \"recoverERC20: Transfer failed\");\n\n        emit EmergencyERC20Recovered(tokenAddress, tokenAmount);\n    }\n\n    event EmergencyEtherRecovered(uint256 amount);\n    event EmergencyERC20Recovered(address tokenAddress, uint256 tokenAmount);\n    event ETHSubmitted(address indexed sender, address indexed recipient, uint256 sent_amount, uint256 withheld_amt);\n    event DepositEtherPaused(bool new_status);\n    event DepositSent(bytes indexed pubKey, bytes withdrawalCredential);\n    event SubmitPaused(bool new_status);\n    event WithheldETHMoved(address indexed to, uint256 amount);\n    event WithholdRatioSet(uint256 newRatio);\n}"
    }
  ]
}