{
  "Title": "H-1: Oracle request timestamp and pending position timestamp mismatch can make most position updates invalid",
  "Content": "# Issue H-1: Oracle request timestamp and pending position timestamp mismatch can make most position updates invalid \n\nSource: https://github.com/sherlock-audit/2023-07-perennial-judging/issues/42 \n\n## Found by \nKingNFT, WATCHPUG, minhtrng, panprog\n\nWhen a new pending position is added, its timestamp is set to `currentTimestamp` returned by oracle's `status` function, which is a timestamp at certain granularities rounding up into the future, which means that most of the time it's greater than `block.timestamp`. However, when `request` is called for the oracle, the request timestamp is set to `block.timestamp`. Due to this mismatch, when the oracle price is commited, it is commited with request's timestamp, but when the position is settled, it tries to read the price at position's timestamp, which is a different time. As such, if the oracle price is commited for each request, it's still easily possible that all pending positions will have invalid oracle versions, completely breaking the protocol's functionality.\n\n## Vulnerability Detail\n\nAn example of what happens exactly:\n\n1. PythOracle granularity is set to 100.\n2. User opens position at timestamp = 101. Pending position is stored with timestamp = 200 (because PythOracle returns currentTimestamp = 200)\n3. At the same time `oracle.request()` is called, which stores 101 (current timestamp) into `versionList`\n4. User calls `oracle.commitRequested()`, which stores current price into `_prices[101]`\n5. Later when that pending position is settled, it requests `oracle.at(200)` which doesn't have a price set (is invalid).\n\nThe same will happen to all pending positions - so most of them will easily be invalid, which will completely break the protocol and cause all kinds of problems due to pending positions being invalid and not updating profit and loss properly.\n\n## Impact\n\nThe most straightforward impact is unexpectedly long position commit times and possible funds loss due to this, if the oracle commit flow is the normal expected flow (only commit requested versions). For example:\nT=1:   User A requests to open position long = 1. Position timestamp = 100. Oracle request timestamp = 1\nT=15:  Oracle commits requested version at timestamp = 1, price = $100.\nT=10010: User B requests to open position. Position timestamp = 10100. Oracle request timestamp = 10010\nT=10025: Oracle commits requested version at timestamp = 10010, price = $110.\n\nUser A expects to be filled at price close to $100. However, he's only filled when the next user trades after him, which happens much later than expected with a very different price ($110), so User A has lost $10 unexpectedly. Basically, each user will only be settled when the next user trades. In quiet markets this can lead to very long settlement times and very bad prices for users.\n\nUser A, however, can notice these long waiting times and can fix it by voluntary commiting non-requested versions. For example, he can commit at T=120 and be filled with the correct price. However, this will mean that all commits must be made non-requested, thus they will not be rewarded with the keeper fees. So the user will pay keeper fees when trading, but will also be forced to lose gas fees for oracle commits, so either broken and long waiting times, or broken oracle non-rewarded updates: both are high impacts.\n\nAnother impact is completely broken internal accounting due to a lot of invalid oracle versions. There is a different bug reported by me about desync of global and local positions during invalid oracles. This bug, when coupled with the desync of global and local positions, will lead to catastrophic consequences and complete breakage of accounting of collateral, bank run and loss of funds for users. Scenario of what can (and will) happen:\nUser B has active open position maker=2 with collateral = 100\nT=99: User A opens long=1 with collateral=100: update(0,1,0,100) (pending position timestamp = 100)\nT=101: User A decides to close: update(0,0,0,0) (pending position timestamp = 200)\nT=130: Oracle commited for timestamp=110, price = $100 (user A position at timestamp = 100 is invalid)\nT=150: User B settles: update(2,0,0,0)\nT=220: Oracle commited for timestamp=205, price = $90\nafter settlement of user A and user B:\nuser A will have collateral = $100 (local pending position long = 1 at timestamp = 100 will be invalidated and ignored)\nuser B will have collateral = $110 (global pending position long = 1 will be current at timestamp 110 and accumulate pnl from timestamp 110 to timestamp=205)\n\nSo total deposit of both users is $100 + $100 = $200\nTotal collateral in the end: $100 + $110 = $210\nBut protocol only has $200 in funds, so users will be unable to withdraw everything, which can cause bank run and loss of funds for the last user.\n\nSuch situations will happen all the time by themselves due to lots of invalid oracle versions, so this will mess up accounting completely.\n\nFor the details of this bug, you can refer to my other report.\n\n## Code Snippet\n\n1. Oracle `status()` returns timestamp which is in the future.\n\nOracle `status()` returns timestamp directly from current provider's `status()`:\nhttps://github.com/sherlock-audit/2023-07-perennial/blob/main/perennial-v2/packages/perennial-oracle/contracts/Oracle.sol#L47\n\nPythOracle `status()` timestamp is taken from `current()`, which in turn returns `current()` from PythFactory:\nhttps://github.com/sherlock-audit/2023-07-perennial/blob/main/perennial-v2/packages/perennial-oracle/contracts/pyth/PythOracle.sol#L101\n\nPythFactory `current()` returns timestamp which is granulated into the future using ceilDiv, which rounds up:\nhttps://github.com/sherlock-audit/2023-07-perennial/blob/main/perennial-v2/packages/perennial-oracle/contracts/pyth/PythFactory.sol#L76\n\n2. Pending position's timestamp is taken from oracle `status()`.\n\n`context.currentTimestamp` is set to timestamp from `oracle.status()`:\nhttps://github.com/sherlock-audit/2023-07-perennial/blob/main/perennial-v2/packages/perennial/contracts/Market.sol#L312\nhttps://github.com/sherlock-audit/2023-07-perennial/blob/main/perennial-v2/packages/perennial/contracts/Market.sol#L575\n\nNew pending positions (global and local) timestamp is set to `context.currentTimestamp`:\nhttps://github.com/sherlock-audit/2023-07-perennial/blob/main/perennial-v2/packages/perennial/contracts/Market.sol#L267-L269\n\nAnd `request()` from oracle is done at the same time:\nhttps://github.com/sherlock-audit/2023-07-perennial/blob/main/perennial-v2/packages/perennial/contracts/Market.sol#L284\n\n3. PythOracle `request()` stores `block.timestamp` in the request list (called `versionList`) (**not** `current()` timestamp):\nhttps://github.com/sherlock-audit/2023-07-perennial/blob/main/perennial-v2/packages/perennial-oracle/contracts/pyth/PythOracle.sol#L77-L81\n\n4. PythOracle `commitRequested()` sets price at `versionList` timestamp (i.e. `block.timestamp` at the time `request()` was made)\n\n`versionToCommit` is stored request's timestamp:\nhttps://github.com/sherlock-audit/2023-07-perennial/blob/main/perennial-v2/packages/perennial-oracle/contracts/pyth/PythOracle.sol#L135\n\nThe commit price is stored at the `versionToCommit` timestamp:\nhttps://github.com/sherlock-audit/2023-07-perennial/blob/main/perennial-v2/packages/perennial-oracle/contracts/pyth/PythOracle.sol#L154\nhttps://github.com/sherlock-audit/2023-07-perennial/blob/main/perennial-v2/packages/perennial-oracle/contracts/pyth/PythOracle.sol#L202-L203\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nMake timestamp of pending positions and timestamp of oracle request match. Record `current()` as a timestamp for the `request()`:\n```solidity\n function request(address) external onlyAuthorized { \n     uint nextTimestamp = current();\n     if (versionList.length == 0 || versionList[versionList.length - 1] < nextTimestamp) { \n         versionList.push(nextTimestamp);\n     } \n } \n```\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**__141345__** commented:\n> h\n\n\n\n**arjun-io**\n\nFixed via: https://github.com/equilibria-xyz/perennial-v2/pull/57\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/106",
  "Code": [
    {
      "filename": "perennial-v2/packages/perennial-oracle/contracts/Oracle.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport \"@equilibria/root/attribute/Instance.sol\";\nimport \"@equilibria/perennial-v2/contracts/interfaces/IOracleProviderFactory.sol\";\nimport \"./interfaces/IOracle.sol\";\n\n/// @title Oracle\n/// @notice The top-level oracle contract that implements an oracle provider interface.\n/// @dev Manages swapping between different underlying oracle provider interfaces over time.\ncontract Oracle is IOracle, Instance {\n    /// @notice A historical mapping of underlying oracle providers\n    mapping(uint256 => Epoch) public oracles;\n\n    /// @notice The global state of the oracle\n    Global public global;\n\n    /// @notice Initializes the contract state\n    /// @param initialProvider The initial oracle provider\n    function initialize(IOracleProvider initialProvider) external initializer(1) {\n        __Instance__initialize();\n        _updateCurrent(initialProvider);\n        _updateLatest(initialProvider.latest());\n    }\n\n    /// @notice Updates the current oracle provider\n    /// @param newProvider The new oracle provider\n    function update(IOracleProvider newProvider) external onlyOwner {\n        _updateCurrent(newProvider);\n        _updateLatest(newProvider.latest());\n    }\n\n    /// @notice Requests a new version at the current timestamp\n    /// @param account Original sender to optionally use for callbacks\n    function request(address account) external onlyAuthorized {\n        (OracleVersion memory latestVersion, uint256 currentTimestamp) = oracles[global.current].provider.status();\n\n        oracles[global.current].provider.request(account);\n        oracles[global.current].timestamp = uint96(currentTimestamp);\n        _updateLatest(latestVersion);\n    }\n\n    /// @notice Returns the latest committed version as well as the current timestamp\n    /// @return latestVersion The latest committed version\n    /// @return currentTimestamp The current timestamp\n    function status() external view returns (OracleVersion memory latestVersion, uint256 currentTimestamp) {\n        (latestVersion, currentTimestamp) = oracles[global.current].provider.status();\n        latestVersion = _handleLatest(latestVersion);\n    }\n\n    /// @notice Returns the latest committed version\n    function latest() public view returns (OracleVersion memory) {\n        return _handleLatest(oracles[global.current].provider.latest());\n    }\n\n    /// @notice Returns the current value\n    function current() public view returns (uint256) {\n        return oracles[global.current].provider.current();\n    }\n\n    /// @notice Returns the oracle version at a given timestamp\n    /// @param timestamp The timestamp to query\n    /// @return atVersion The oracle version at the given timestamp\n    function at(uint256 timestamp) public view returns (OracleVersion memory atVersion) {\n        if (timestamp == 0) return atVersion;\n        IOracleProvider provider = oracles[global.current].provider;\n        for (uint256 i = global.current - 1; i > 0; i--) {\n            if (timestamp > uint256(oracles[i].timestamp)) break;\n            provider = oracles[i].provider;\n        }\n        return provider.at(timestamp);\n    }\n\n    /// @notice Handles update the oracle to the new provider\n    /// @param newProvider The new oracle provider\n    function _updateCurrent(IOracleProvider newProvider) private {\n        if (global.current != global.latest) revert OracleOutOfSyncError();\n        oracles[uint256(++global.current)] = Epoch(newProvider, uint96(newProvider.current()));\n        emit OracleUpdated(newProvider);\n    }\n\n    /// @notice Handles updating the latest oracle to the current if it is ready\n    /// @param currentOracleLatestVersion The latest version from the current oracle\n    function _updateLatest(OracleVersion memory currentOracleLatestVersion) private {\n        if (_latestStale(currentOracleLatestVersion)) global.latest = global.current;\n    }\n\n    /// @notice Handles overriding the latest version\n    /// @dev Applicable if we haven't yet switched over to the current oracle from the latest oracle\n    /// @param currentOracleLatestVersion The latest version from the current oracle\n    /// @return latestVersion The latest version\n    function _handleLatest(\n        OracleVersion memory currentOracleLatestVersion\n    ) private view returns (OracleVersion memory latestVersion) {\n        if (global.current == global.latest) return currentOracleLatestVersion;\n\n        bool isLatestStale = _latestStale(currentOracleLatestVersion);\n        latestVersion = isLatestStale ? currentOracleLatestVersion : oracles[global.latest].provider.latest();\n\n        uint256 latestOracleTimestamp =\n            uint256(isLatestStale ? oracles[global.current].timestamp : oracles[global.latest].timestamp);\n        if (!isLatestStale && latestVersion.timestamp > latestOracleTimestamp)\n            return at(latestOracleTimestamp);\n    }\n\n    /// @notice Returns whether the latest oracle is ready to be updated\n    /// @param currentOracleLatestVersion The latest version from the current oracle\n    /// @return Whether the latest oracle is ready to be updated\n    function _latestStale(OracleVersion memory currentOracleLatestVersion) private view returns (bool) {\n        if (global.current == global.latest) return false;\n\n        uint256 latestTimestamp = global.latest == 0 ? 0 : oracles[global.latest].provider.latest().timestamp;\n        if (uint256(oracles[global.latest].timestamp) > latestTimestamp) return false;\n        if (uint256(oracles[global.latest].timestamp) >= currentOracleLatestVersion.timestamp) return false;\n\n        return true;\n    }\n\n    /// @dev Only if the caller is authorized by the factory\n    modifier onlyAuthorized {\n        if (!IOracleProviderFactory(address(factory())).authorized(msg.sender))\n            revert OracleProviderUnauthorizedError();\n        _;\n    }\n}"
    },
    {
      "filename": "perennial-v2/packages/perennial-oracle/contracts/pyth/PythOracle.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@pythnetwork/pyth-sdk-solidity/AbstractPyth.sol\";\nimport \"@equilibria/root/attribute/Instance.sol\";\nimport \"@equilibria/root/attribute/Kept.sol\";\nimport \"../interfaces/IPythFactory.sol\";\n\n/// @title PythOracle\n/// @notice Pyth implementation of the IOracle interface.\n/// @dev One instance per Pyth price feed should be deployed. Multiple products may use the same\n///      PythOracle instance if their payoff functions are based on the same underlying oracle.\n///      This implementation only supports non-negative prices.\ncontract PythOracle is IPythOracle, Instance, Kept {\n    /// @dev A Pyth update must come at least this long after a version to be valid\n    uint256 constant private MIN_VALID_TIME_AFTER_VERSION = 12 seconds;\n\n    /// @dev A Pyth update must come at most this long after a version to be valid\n    uint256 constant private MAX_VALID_TIME_AFTER_VERSION = 15 seconds;\n\n    /// @dev After this amount of time has passed for a version without being committed, the version can be invalidated.\n    uint256 constant private GRACE_PERIOD = 1 minutes;\n\n    /// @dev The multiplier for the keeper reward on top of cost\n    UFixed18 constant private KEEPER_REWARD_PREMIUM = UFixed18.wrap(1.5e18);\n\n    /// @dev The fixed gas buffer that is added to the keeper reward\n    uint256 constant private KEEPER_BUFFER = 80_000;\n\n    /// @dev Pyth contract\n    AbstractPyth public immutable pyth;\n\n    /// @dev Pyth price feed id\n    bytes32 public id;\n\n    /// @dev List of all requested oracle versions\n    uint256[] public versionList;\n\n    /// @dev Index in `versionList` of the next version a keeper should commit\n    uint256 public nextVersionIndexToCommit;\n\n    /// @dev Mapping from oracle version to oracle version data\n    mapping(uint256 => Fixed6) private _prices;\n\n    /// @dev Mapping from oracle version to when its VAA was published to Pyth\n    mapping(uint256 => uint256) private _publishTimes;\n\n    /// @dev The time when the last committed update was published to Pyth\n    uint256 private _lastCommittedPublishTime;\n\n    /// @dev The oracle version that was most recently committed\n    /// @dev We assume that we cannot commit an oracle version of 0, so `_latestVersion` being 0 means that no version has been committed yet\n    uint256 private _latestVersion;\n\n     /// @notice Initializes the immutable contract state\n     /// @param pyth_ Pyth contract\n    constructor(AbstractPyth pyth_) {\n        pyth = pyth_;\n    }\n\n    /// @notice Initializes the contract state\n    /// @param id_ price ID for Pyth price feed\n    /// @param chainlinkFeed_ Chainlink price feed for rewarding keeper in DSU\n    /// @param dsu_ Token to pay the keeper reward in\n    function initialize(bytes32 id_, AggregatorV3Interface chainlinkFeed_, Token18 dsu_) external initializer(1) {\n        __Instance__initialize();\n        __UKept__initialize(chainlinkFeed_, dsu_);\n\n        if (!pyth.priceFeedExists(id_)) revert PythOracleInvalidPriceIdError(id_);\n\n        id = id_;\n    }\n\n    /// @notice Records a request for a new oracle version\n    /// @dev Original sender to optionally use for callbacks\n    function request(address) external onlyAuthorized {\n        if (versionList.length == 0 || versionList[versionList.length - 1] != block.timestamp) {\n            versionList.push(block.timestamp);\n        }\n    }\n\n    /// @notice Returns the latest synced oracle version and the current oracle version\n    /// @return The latest synced oracle version\n    /// @return The current oracle version collecting new orders\n    function status() external view returns (OracleVersion memory, uint256) {\n        return (latest(), current());\n    }\n\n    /// @notice Returns the latest synced oracle version\n    /// @return latestVersion Latest oracle version\n    function latest() public view returns (OracleVersion memory latestVersion) {\n        if (_latestVersion == 0) return latestVersion;\n\n        return latestVersion = OracleVersion(_latestVersion, _prices[_latestVersion], true);\n    }\n\n    /// @notice Returns the current oracle version accepting new orders\n    /// @return Current oracle version\n    function current() public view returns (uint256) {\n        return IPythFactory(address(factory())).current();\n    }\n\n\n    /// @notice Returns the oracle version at version `version`\n    /// @param timestamp The timestamp of which to lookup\n    /// @return oracleVersion Oracle version at version `version`\n    function at(uint256 timestamp) public view returns (OracleVersion memory oracleVersion) {\n        Fixed6 price = _prices[timestamp];\n        return OracleVersion(timestamp, price, !price.isZero());\n    }\n\n    /// @notice Returns the next oracle version to commit\n    /// @return version The next oracle version to commit\n    function nextVersionToCommit() external view returns (uint256 version) {\n        if (versionList.length == 0 || nextVersionIndexToCommit >= versionList.length) return 0;\n        return versionList[nextVersionIndexToCommit];\n    }\n\n    /// @notice Commits the price represented by `updateData` to the next version that needs to be committed\n    /// @dev Will revert if there is an earlier versionIndex that could be committed with `updateData`\n    /// @param versionIndex The index of the version to commit\n    /// @param updateData The update data to commit\n    function commitRequested(uint256 versionIndex, bytes calldata updateData)\n        public\n        payable\n        keep(KEEPER_REWARD_PREMIUM, KEEPER_BUFFER, \"\")\n    {\n        // This check isn't necessary since the caller would not be able to produce a valid updateData\n        // with an update time corresponding to a null version, but reverting with a specific error is\n        // clearer.\n        if (nextVersionIndexToCommit >= versionList.length) revert PythOracleNoNewVersionToCommitError();\n        if (versionIndex < nextVersionIndexToCommit) revert PythOracleVersionIndexTooLowError();\n\n        uint256 versionToCommit = versionList[versionIndex];\n        PythStructs.Price memory pythPrice = _validateAndGetPrice(versionToCommit, updateData);\n\n        if (pythPrice.publishTime <= _lastCommittedPublishTime) revert PythOracleNonIncreasingPublishTimes();\n        _lastCommittedPublishTime = pythPrice.publishTime;\n\n        // Ensure that the keeper is committing the earliest possible version\n        if (versionIndex > nextVersionIndexToCommit) {\n            uint256 previousVersion = versionList[versionIndex - 1];\n            // We can only skip the previous version if the grace period has expired\n            if (block.timestamp <= previousVersion + GRACE_PERIOD) revert PythOracleGracePeriodHasNotExpiredError();\n\n            // If the update is valid for the previous version, we can't skip the previous version\n            if (\n                pythPrice.publishTime >= previousVersion + MIN_VALID_TIME_AFTER_VERSION &&\n                pythPrice.publishTime <= previousVersion + MAX_VALID_TIME_AFTER_VERSION\n            ) revert PythOracleUpdateValidForPreviousVersionError();\n        }\n\n        _recordPrice(versionToCommit, pythPrice);\n        nextVersionIndexToCommit = versionIndex + 1;\n        _latestVersion = versionToCommit;\n    }\n\n    /// @notice Commits the price to a non-requested version\n    /// @dev This commit function may pay out a keeper reward if the commited version is valid\n    ///      for the next requested version to commit.\n    /// @param oracleVersion The oracle version to commit\n    /// @param updateData The update data to commit\n    function commit(uint256 oracleVersion, bytes calldata updateData) external payable {\n        // Must be before the next requested version to commit, if it exists\n        // Otherwise, try to commit it as the next request version to commit\n        if (versionList.length > nextVersionIndexToCommit && oracleVersion >= versionList[nextVersionIndexToCommit]) {\n            commitRequested(nextVersionIndexToCommit, updateData);\n            return;\n        }\n\n        PythStructs.Price memory pythPrice = _validateAndGetPrice(oracleVersion, updateData);\n\n        // Oracle version must be more recent than those of the most recently committed version\n        if (oracleVersion <= _latestVersion) revert PythOracleVersionTooOldError();\n\n        _recordPrice(oracleVersion, pythPrice);\n        _latestVersion = oracleVersion;\n    }\n\n    /// @notice Validates that update fees have been paid, and that the VAA represented by `updateData` is within `oracleVersion + MIN_VALID_TIME_AFTER_VERSION` and `oracleVersion + MAX_VALID_TIME_AFTER_VERSION`\n    /// @param oracleVersion The oracle version to validate against\n    /// @param updateData The update data to validate\n    function _validateAndGetPrice(uint256 oracleVersion, bytes calldata updateData) private returns (PythStructs.Price memory price) {\n        bytes[] memory updateDataList = new bytes[](1);\n        updateDataList[0] = updateData;\n        bytes32[] memory idList = new bytes32[](1);\n        idList[0] = id;\n\n        return pyth.parsePriceFeedUpdates{value: pyth.getUpdateFee(updateDataList)}(\n            updateDataList,\n            idList,\n            SafeCast.toUint64(oracleVersion + MIN_VALID_TIME_AFTER_VERSION),\n            SafeCast.toUint64(oracleVersion + MAX_VALID_TIME_AFTER_VERSION)\n        )[0].price;\n    }\n\n    /// @notice Records `price` as a Fixed6 at version `oracleVersion`\n    /// @param oracleVersion The oracle version to record the price at\n    /// @param price The price to record\n    function _recordPrice(uint256 oracleVersion, PythStructs.Price memory price) private {\n        _prices[oracleVersion] = Fixed6Lib.from(price.price)\n            .mul(Fixed6Lib.from(SafeCast.toInt256(10 ** SafeCast.toUint256(price.expo > 0 ? price.expo : -price.expo))));\n        _publishTimes[oracleVersion] = price.publishTime;\n    }\n\n    /// @notice Pulls funds from the factory to reward the keeper\n    /// @param keeperFee The keeper fee to pull\n    function _raiseKeeperFee(UFixed18 keeperFee, bytes memory) internal override {\n        IPythFactory(address(factory())).claim(UFixed6Lib.from(keeperFee, true));\n    }\n\n    /// @dev Only allow authorized callers\n    modifier onlyAuthorized {\n        if (!IOracleProviderFactory(address(factory())).authorized(msg.sender)) revert OracleProviderUnauthorizedError();\n        _;\n    }\n}"
    },
    {
      "filename": "perennial-v2/packages/perennial-oracle/contracts/pyth/PythFactory.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport \"@equilibria/root/attribute/Factory.sol\";\nimport \"@pythnetwork/pyth-sdk-solidity/AbstractPyth.sol\";\nimport \"../interfaces/IPythFactory.sol\";\nimport \"../interfaces/IOracleFactory.sol\";\n\n/// @title PythFactory\n/// @notice Factory contract for creating and managing Pyth oracles\ncontract PythFactory is IPythFactory, Factory {\n    /// @notice The maximum value for granularity\n    uint256 public constant MAX_GRANULARITY = 1 hours;\n\n    /// @notice The legacy Chainlink price feed for ETH/USD used to calculate the keeper reward\n    AggregatorV3Interface public immutable ethTokenChainlinkFeed;\n\n    /// @notice The token that is paid out as a reward to oracle keepers\n    Token18 public immutable keeperToken;\n\n    /// @notice The root oracle factory\n    IOracleFactory public oracleFactory;\n\n    /// @notice Mapping of which factory's instances are authorized to request from this factory's instances\n    mapping(IFactory => bool) public callers;\n\n    /// @notice Mapping of oracle id to oracle instance\n    mapping(bytes32 => IOracleProvider) public oracles;\n\n    /// @notice The granularity of the oracle\n    Granularity private _granularity;\n\n    /// @notice Initializes the immutable contract state\n    /// @param implementation_ IPythOracle implementation contract\n    /// @param chainlinkFeed_ Chainlink price feed for rewarding keeper in DSU\n    /// @param dsu_ Token to pay the keeper reward in\n    constructor(address implementation_, AggregatorV3Interface chainlinkFeed_, Token18 dsu_) Factory(implementation_) {\n        ethTokenChainlinkFeed = chainlinkFeed_;\n        keeperToken = dsu_;\n    }\n\n    /// @notice Initializes the contract state\n    /// @param oracleFactory_ The root oracle factory\n    function initialize(IOracleFactory oracleFactory_) external initializer(1) {\n        __UOwnable__initialize();\n\n        oracleFactory = oracleFactory_;\n        _granularity = Granularity(0, 1, 0);\n    }\n\n    /// @notice Authorizes a factory's instances to request from this factory's instances\n    /// @param factory The factory to authorize\n    function authorize(IFactory factory) external onlyOwner {\n        callers[factory] = true;\n    }\n\n    /// @notice Creates a new oracle instance\n    /// @param id The id of the oracle to create\n    /// @return newOracle The newly created oracle instance\n    function create(bytes32 id) external onlyOwner returns (IPythOracle newOracle) {\n        newOracle = IPythOracle(address(\n            _create(abi.encodeCall(IPythOracle.initialize, (id, ethTokenChainlinkFeed, keeperToken)))));\n        oracles[id] = newOracle;\n\n        emit OracleCreated(newOracle, id);\n    }\n\n    /// @notice Returns the current timestamp\n    /// @dev Rounded up to the nearest granularity\n    /// @return The current timestamp\n    function current() public view returns (uint256) {\n        uint256 effectiveGranularity = block.timestamp <= uint256(_granularity.effectiveAfter) ?\n            uint256(_granularity.latestGranularity) :\n            uint256(_granularity.currentGranularity);\n\n        return Math.ceilDiv(block.timestamp, effectiveGranularity) * effectiveGranularity;\n    }\n\n    /// @notice Returns the granularity\n    /// @return The granularity\n    function granularity() external view returns (Granularity memory) {\n        return _granularity;\n    }\n\n    /// @notice Updates the granularity\n    /// @param newGranularity The new granularity\n    function updateGranularity(uint256 newGranularity) external onlyOwner {\n        uint256 _current = current();\n        if (newGranularity == 0) revert PythFactoryInvalidGranularityError();\n        if (_current <= uint256(_granularity.effectiveAfter)) revert PythFactoryInvalidGranularityError();\n        if (newGranularity > MAX_GRANULARITY) revert PythFactoryInvalidGranularityError();\n\n        _granularity = Granularity(\n            _granularity.currentGranularity,\n            uint64(newGranularity),\n            uint128(_current)\n        );\n        emit GranularityUpdated(newGranularity, _current);\n    }\n\n    /// @notice Claims an amount of incentive tokens, to be paid out as a reward to the keeper\n    /// @dev Can only be called by an instance of the factory\n    /// @param amount The amount of tokens to claim\n    function claim(UFixed6 amount) external onlyInstance {\n        oracleFactory.claim(amount);\n        keeperToken.push(msg.sender, UFixed18Lib.from(amount));\n    }\n\n    /// @notice Returns whether a caller is authorized to request from this factory's instances\n    /// @param caller The caller to check\n    /// @return Whether the caller is authorized\n    function authorized(address caller) external view returns (bool) {\n        IInstance callerInstance = IInstance(caller);\n        IFactory callerFactory = callerInstance.factory();\n        if (!callerFactory.instances(callerInstance)) return false;\n        return callers[callerFactory];\n    }\n}"
    },
    {
      "filename": "perennial-v2/packages/perennial/contracts/Market.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport \"@equilibria/root/attribute/Instance.sol\";\nimport \"@equilibria/root/attribute/ReentrancyGuard.sol\";\nimport \"./interfaces/IMarket.sol\";\nimport \"./interfaces/IMarketFactory.sol\";\n\n/// @title Market\n/// @notice Manages logic and state for a single market.\n/// @dev Cloned by the Factory contract to launch new markets.\ncontract Market is IMarket, Instance, ReentrancyGuard {\n    /// @dev The underlying token that the market settles in\n    Token18 public token;\n\n    /// @dev The token that incentive rewards are paid in\n    Token18 public reward;\n\n    /// @dev The oracle that provides the market price\n    IOracleProvider public oracle;\n\n    /// @dev The payoff function over the underlying oracle\n    IPayoffProvider public payoff;\n\n    /// @dev Beneficiary of the market, receives donations\n    address public beneficiary;\n\n    /// @dev Risk coordinator of the market\n    address public coordinator;\n\n    /// @dev Risk parameters of the market\n    RiskParameterStorage private _riskParameter;\n\n    /// @dev Parameters of the market\n    MarketParameterStorage private _parameter;\n\n    /// @dev Current global state of the market\n    GlobalStorage private _global;\n\n    /// @dev Current global position of the market\n    PositionStorageGlobal private _position;\n\n    /// @dev The global pending versions for each id\n    mapping(uint256 => PositionStorageGlobal) private _pendingPosition;\n\n    /// @dev Current local state of each account\n    mapping(address => LocalStorage) private _locals;\n\n    /// @dev Current local position of each account\n    mapping(address => PositionStorageLocal) private _positions;\n\n    /// @dev The local pending versions for each id for each account\n    mapping(address => mapping(uint256 => PositionStorageLocal)) private _pendingPositions;\n\n    /// @dev The historical version accumulator data for each accessed version\n    mapping(uint256 => VersionStorage) private _versions;\n\n    /// @notice Initializes the contract state\n    /// @param definition_ The market definition\n    function initialize(IMarket.MarketDefinition calldata definition_) external initializer(1) {\n        __Instance__initialize();\n        __UReentrancyGuard__initialize();\n\n        token = definition_.token;\n        oracle = definition_.oracle;\n        payoff = definition_.payoff;\n    }\n\n    /// @notice Updates the account's position and collateral\n    /// @param account The account to operate on\n    /// @param newMaker The new maker position for the account\n    /// @param newMaker The new long position for the account\n    /// @param newMaker The new short position for the account\n    /// @param collateral The collateral amount to add or remove from the account\n    /// @param protect Whether to put the account into a protected status for liquidations\n    function update(\n        address account,\n        UFixed6 newMaker,\n        UFixed6 newLong,\n        UFixed6 newShort,\n        Fixed6 collateral,\n        bool protect\n    ) external nonReentrant whenNotPaused {\n        Context memory context = _loadContext(account);\n        _settle(context, account);\n        _update(context, account, newMaker, newLong, newShort, collateral, protect);\n        _saveContext(context, account);\n    }\n\n    /// @notice Updates the beneficiary of the market\n    /// @param newBeneficiary The new beneficiary address\n    function updateBeneficiary(address newBeneficiary) external onlyOwner {\n        beneficiary = newBeneficiary;\n        emit BeneficiaryUpdated(newBeneficiary);\n    }\n\n    /// @notice Updates the coordinator of the market\n    /// @param newCoordinator The new coordinator address\n    function updateCoordinator(address newCoordinator) external onlyOwner {\n        coordinator = newCoordinator;\n        emit CoordinatorUpdated(newCoordinator);\n    }\n\n    /// @notice Updates the parameter set of the market\n    /// @param newParameter The new parameter set\n    function updateParameter(MarketParameter memory newParameter) external onlyOwner {\n        _parameter.validateAndStore(newParameter, IMarketFactory(address(factory())).parameter(), reward);\n        emit ParameterUpdated(newParameter);\n    }\n\n    /// @notice Updates the risk parameter set of the market\n    /// @param newRiskParameter The new risk parameter set\n    function updateRiskParameter(RiskParameter memory newRiskParameter) external onlyCoordinator {\n        _riskParameter.validateAndStore(newRiskParameter, IMarketFactory(address(factory())).parameter());\n        emit RiskParameterUpdated(newRiskParameter);\n    }\n\n    /// @notice Updates the reward token of the market\n    /// @param newReward The new reward token\n    function updateReward(Token18 newReward) public onlyOwner {\n        if (!reward.eq(Token18Lib.ZERO)) revert MarketRewardAlreadySetError();\n        if (newReward.eq(token)) revert MarketInvalidRewardError();\n\n        reward = newReward;\n        emit RewardUpdated(newReward);\n    }\n\n    /// @notice Claims any available fee that the sender has accrued\n    /// @dev Applicable fees include: protocol, oracle, risk, and donation\n    function claimFee() external {\n        Global memory newGlobal = _global.read();\n\n        if (_claimFee(address(factory()), newGlobal.protocolFee)) newGlobal.protocolFee = UFixed6Lib.ZERO;\n        if (_claimFee(address(IMarketFactory(address(factory())).oracleFactory()), newGlobal.oracleFee))\n            newGlobal.oracleFee = UFixed6Lib.ZERO;\n        if (_claimFee(coordinator, newGlobal.riskFee)) newGlobal.riskFee = UFixed6Lib.ZERO;\n        if (_claimFee(beneficiary, newGlobal.donation)) newGlobal.donation = UFixed6Lib.ZERO;\n\n        _global.store(newGlobal);\n    }\n\n    /// @notice Helper function to handle a singular fee claim\n    /// @param receiver The address to receive the fee\n    /// @param fee The amount of the fee to claim\n    function _claimFee(address receiver, UFixed6 fee) private returns (bool) {\n        if (msg.sender != receiver) return false;\n\n        token.push(receiver, UFixed18Lib.from(fee));\n        emit FeeClaimed(receiver, fee);\n        return true;\n    }\n\n    /// @notice Claims any available reward that the sender has accrued\n    function claimReward() external {\n        Local memory newLocal = _locals[msg.sender].read();\n\n        reward.push(msg.sender, UFixed18Lib.from(newLocal.reward));\n        emit RewardClaimed(msg.sender, newLocal.reward);\n\n        newLocal.reward = UFixed6Lib.ZERO;\n        _locals[msg.sender].store(newLocal);\n    }\n\n    /// @notice Returns the current parameter set\n    function parameter() external view returns (MarketParameter memory) {\n        return _parameter.read();\n    }\n\n    /// @notice Returns the current risk parameter set\n    function riskParameter() external view returns (RiskParameter memory) {\n        return _riskParameter.read();\n    }\n\n    /// @notice Returns the current global position\n    function position() external view returns (Position memory) {\n        return _position.read();\n    }\n\n    /// @notice Returns the current local position for the account\n    /// @param account The account to query\n    function positions(address account) external view returns (Position memory) {\n        return _positions[account].read();\n    }\n\n    /// @notice Returns the current global state\n    function global() external view returns (Global memory) {\n        return _global.read();\n    }\n\n    /// @notice Returns the historical version snapshot at the given timestamp\n    /// @param timestamp The timestamp to query\n    function versions(uint256 timestamp) external view returns (Version memory) {\n        return _versions[timestamp].read();\n    }\n\n    /// @notice Returns the local state for the given account\n    /// @param account The account to query\n    function locals(address account) external view returns (Local memory) {\n        return _locals[account].read();\n    }\n\n    /// @notice Returns the global pending position for the given id\n    /// @param id The id to query\n    function pendingPosition(uint256 id) external view returns (Position memory) {\n        return _pendingPosition[id].read();\n    }\n\n    /// @notice Returns the local pending position for the given account and id\n    /// @param account The account to query\n    /// @param id The id to query\n    function pendingPositions(address account, uint256 id) external view returns (Position memory) {\n        return _pendingPositions[account][id].read();\n    }\n\n    /// @notice Loads the current position context for the given account\n    /// @param context The context to load to\n    /// @param account The account to query\n    function _loadCurrentPositionContext(\n        Context memory context,\n        address account\n    ) private view returns (PositionContext memory positionContext) {\n        positionContext.global = _pendingPosition[context.global.currentId].read();\n        positionContext.local = _pendingPositions[account][context.local.currentId].read();\n        if (context.global.currentId == context.global.latestId)\n            positionContext.global.invalidate(context.latestPosition.global);\n        if (context.local.currentId == context.local.latestId)\n            positionContext.local.invalidate(context.latestPosition.local);\n    }\n\n    /// @notice Updates the current position\n    /// @param context The context to use\n    /// @param account The account to update\n    /// @param newMaker The new maker position size\n    /// @param newLong The new long position size\n    /// @param newShort The new short position size\n    /// @param collateral The change in collateral\n    /// @param protect Whether to protect the position for liquidation\n    function _update(\n        Context memory context,\n        address account,\n        UFixed6 newMaker,\n        UFixed6 newLong,\n        UFixed6 newShort,\n        Fixed6 collateral,\n        bool protect\n    ) private {\n        // read\n        context.currentPosition = _loadCurrentPositionContext(context, account);\n\n        // magic values\n        if (collateral.eq(Fixed6Lib.MIN)) collateral = context.local.collateral.mul(Fixed6Lib.NEG_ONE);\n        if (newMaker.eq(UFixed6Lib.MAX)) newMaker = context.currentPosition.local.maker;\n        if (newLong.eq(UFixed6Lib.MAX)) newLong = context.currentPosition.local.long;\n        if (newShort.eq(UFixed6Lib.MAX)) newShort = context.currentPosition.local.short;\n\n        // advance to next id if applicable\n        if (context.currentTimestamp > context.currentPosition.local.timestamp) {\n            context.local.currentId++;\n            context.currentPosition.local.prepare();\n        }\n        if (context.currentTimestamp > context.currentPosition.global.timestamp) {\n            context.global.currentId++;\n            context.currentPosition.global.prepare();\n        }\n\n        // update position\n        Order memory newOrder =\n            context.currentPosition.local.update(context.currentTimestamp, newMaker, newLong, newShort);\n        context.currentPosition.global.update(context.currentTimestamp, newOrder, context.riskParameter);\n\n        // update fee\n        newOrder.registerFee(context.latestVersion, context.marketParameter, context.riskParameter);\n        context.currentPosition.local.registerFee(newOrder);\n        context.currentPosition.global.registerFe"
    }
  ]
}