{
  "Title": "Price manipulation by calling `updatePhase` with different symbols",
  "Content": "##### Description\nIn the audited commit `29a0ccb5fc7ac838bd44c75c0afc398b84be267a`, the `endRoundId` value is not dependent on the asset symbol. By calling the `updatePhase` function with a different `symbol` argument, an attacker may manipulate the `endRoundId` values. This could violate the correctness of the price calculation algorithm, leading to incorrect battle income.\n\nAlthough this is a critical flaw, it is only exploitable during a 1-hour period after a Chainlink phase has been changed. Given its critical impact but low likelihood, this issue is assigned a HIGH severity rating.\n\nRelated code - the declaration of the `endRoundId`: https://github.com/DivergenceProtocol/diver-contracts/blob/29a0ccb5fc7ac838bd44c75c0afc398b84be267a/src/core/Oracle.sol#L17\n\n##### Recommendation\nWe recommend reworking the entire algorithm of interaction with Chainlink to render it more tolerant to manipulations.\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "src/core/Oracle.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { Ownable } from \"@oz/access/Ownable.sol\";\nimport { SafeCast } from \"@oz/utils/math/SafeCast.sol\";\nimport { AggregatorV3Interface } from \"chainlink/interfaces/AggregatorV3Interface.sol\";\nimport { getAdjustPrice } from \"./utils.sol\";\n\n/// @title Oracle\n/// @notice Get external price by Oracle\ncontract Oracle is Ownable {\n    using SafeCast for int256;\n\n    mapping(string => address) private externalOracleOf;\n    mapping(uint80 => uint80) public startRoundId;\n    mapping(uint80 => uint80) public endRoundId;\n    mapping(address => mapping(uint256 => uint256)) public fixPrices;\n    uint80 public latestPhase;\n\n    /// @notice Defines the underlying asset symbol and oracle address for a\n    /// pool.  Only called by the owner.\n    /// @param symbols The asset symbol for which to retrieve price feed\n    /// @param _oracles The external oracle address\n    function setExternalOracle(string[] calldata symbols, address[] calldata _oracles) external onlyOwner {\n        require(symbols.length == _oracles.length, \"symbols not match oracles\");\n        for (uint256 i = 0; i < symbols.length; i++) {\n            require(_oracles[i] != address(0), \"Zero Address\");\n            externalOracleOf[symbols[i]] = _oracles[i];\n        }\n    }\n\n    /// @notice Gets and computes price from external oracles\n    /// @param cOracleAddr chainlink price contract\n    /// @param ts Timestamp for the asset price\n    /// @return price_ The retrieved price\n    function getPriceByExternal(address cOracleAddr, uint256 ts) public view returns (uint256 price_, uint256 actualTs) {\n        require(block.timestamp >= ts, \"price not exist\");\n        if (block.timestamp - ts > 1 hours) {\n            // get price from setting\n            require(fixPrices[cOracleAddr][ts] != 0, \"setting price\");\n            price_ = fixPrices[cOracleAddr][ts];\n            actualTs = ts;\n        } else {\n            AggregatorV3Interface cOracle = AggregatorV3Interface(cOracleAddr);\n            require(cOracleAddr != address(0), \"external oracle not exist\");\n\n            (uint80 roundID,,,,) = cOracle.latestRoundData();\n\n            uint256 decimalDiff = 10 ** (18 - cOracle.decimals());\n            (price_, actualTs) = _getPrice(cOracle, roundID, ts, decimalDiff);\n        }\n    }\n\n    function setFixPrice(string memory symbol, uint256 ts, uint256 price) external onlyOwner {\n        require(externalOracleOf[symbol] != address(0), \"not support symbol\");\n        fixPrices[externalOracleOf[symbol]][ts] = price;\n    }\n\n    /// @notice Helper for retrieving prices from an external oracle.\n    /// @param cOracle Oracle interface for retrieving price feed\n    /// @param id The roundId using which price is retrieved\n    /// @param ts Timestamp for the asset price\n    /// @param decimalDiff Precision differences for the number of decimal\n    /// places of retrieved data\n    function _getPrice(\n        AggregatorV3Interface cOracle,\n        uint80 id,\n        uint256 ts,\n        uint256 decimalDiff\n    )\n        private\n        view\n        returns (uint256 finalPrice, uint256 finalTs)\n    {\n        // get next price after 8am utc\n        uint80 phaseId = getPhaseIdFromRoundId(id);\n        uint256 price;\n        uint256 actualTs;\n        // get price in two phase and select price that closer to 08 utc\n        for (uint80 i = phaseId; i >= 1; i--) {\n            (uint256 p, uint256 aTs) = getPriceInPhase(cOracle, getStartRoundId(i), i == phaseId ? id : getEndRoundId(i), ts);\n            if (price == 0) {\n                // first phase\n                price = p;\n                actualTs = aTs;\n                if (i == 1) {\n                    price *= decimalDiff;\n                    finalPrice = price;\n                    finalTs = actualTs;\n                }\n            } else {\n                if (p != 0) {\n                    // it is not first phase and closer than pre phase\n                    price = p;\n                    actualTs = aTs;\n                } else {\n                    // now, price is the closest to 08 utc\n                    price *= decimalDiff;\n                    finalPrice = price;\n                    finalTs = actualTs;\n                }\n            }\n        }\n    }\n\n    function getCOracle(string memory symbol) public view returns (address) {\n        address cOracle = externalOracleOf[symbol];\n        require(cOracle != address(0), \"not exist\");\n        return cOracle;\n    }\n\n    function updatePhase(uint80 roundId, string memory symbol) public {\n        try AggregatorV3Interface(getCOracle(symbol)).getRoundData(roundId) returns (uint80, int256 answerF, uint256 startedAtF, uint256, uint80) {\n            if (answerF == 0 && startedAtF == 0) {\n                revert(\"invalid roundId\");\n            }\n            uint80 phaseId = getPhaseIdFromRoundId(roundId);\n            if (startRoundId[phaseId] == 0) {\n                startRoundId[phaseId] = getStartRoundId(phaseId);\n            }\n            roundId++;\n            while (true) {\n                try AggregatorV3Interface(getCOracle(symbol)).getRoundData(roundId) returns (\n                    uint80, int256 answer, uint256, uint256 updatedAt, uint80\n                ) {\n                    if (answer == 0 && updatedAt == 0) {\n                        endRoundId[phaseId] = (roundId - 1);\n                        if (phaseId > latestPhase) {\n                            latestPhase = phaseId;\n                        }\n                        break;\n                    }\n                    roundId++;\n                } catch {\n                    endRoundId[phaseId] = (roundId - 1);\n                    if (phaseId > latestPhase) {\n                        latestPhase = phaseId;\n                    }\n                    break;\n                }\n            }\n        } catch {\n            revert(\"invalid roundId\");\n        }\n    }\n\n    function getPhaseIdFromRoundId(uint80 roundId) internal pure returns (uint80) {\n        return roundId >> 64;\n    }\n\n    function getStartRoundId(uint80 phaseId) internal pure returns (uint80) {\n        return (phaseId << 64) | 1;\n    }\n\n    function getEndRoundId(uint80 phaseId) internal view returns (uint80) {\n        require(endRoundId[phaseId] != 0, \"round error\");\n        return endRoundId[phaseId];\n    }\n\n    function getPriceInPhase(\n        AggregatorV3Interface cOracle,\n        uint80 start,\n        uint80 end,\n        uint256 ts\n    )\n        internal\n        view\n        returns (uint256 p, uint256 actualTs)\n    {\n        for (uint80 i = end; i >= start; i--) {\n            try cOracle.getRoundData(i) returns (uint80, int256 answer, uint256 startedAt, uint256, uint80) {\n                if (startedAt > 0 && startedAt < ts) {\n                    break;\n                }\n                if (startedAt >= ts && startedAt - ts <= 1 hours) {\n                    p = answer.toUint256();\n                    actualTs = startedAt;\n                }\n            } catch {\n                // just go to next round\n            }\n        }\n    }\n}"
    }
  ]
}