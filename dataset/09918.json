{
  "Title": "[M-18] Rewards can be lost",
  "Content": "_Submitted by csanuragjain_\n\nReward can be lost if bribeVault calls the updateRewardsMetadata on same rewardIdentifier again before user can claim his reward (since merkleRoot and proof will get updated).\n\n### Proof of Concept\n\n1.  bribeVault calls the updateRewardsMetadata at [RewardDistributor.sol#L97](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L97) using rewardIdentifier X\n2.  Assume  \\_distributions\\[i].proof contains merkle proof for User A\n3.  User A fails to call claim function\n4.  bribeVault again calls the updateRewardsMetadata at RewardDistributor.sol#L97 using rewardIdentifier X updating  \\_distributions\\[i].proof  which might not contain merkle proof of User A now. So User A loses his rewards\n\n### Recommended Mitigation Steps\n\nbribeVault should only make second call to updateRewardsMetadata on same rewardIdentifier when all claimers have made their claims.\n\n**[kphed (Redacted Cartel) disputed and commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/13#issuecomment-1040595384):**\n > We would only call `updateRewardsMetadata` again if there was an issue with the originally-set merkle root(s). The recommended mitigation steps above would block us from setting the correct merkle roots until after claimers claimed the wrong amounts.\n> \n> Thanks again for participating in our contest csanuragjain, looking forward to more feedback/suggestions/comments.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/13#issuecomment-1060063884):**\n > The finding highlights the consequences of admin privilege, in that the admin can use `updateRewardsMetadata` to deny claims.\n> \n> While I believe the warden could have done a better job at expressing the risks involved for users, I believe the finding to be valid. \n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-redacted-cartel-contest",
  "Code": [
    {
      "filename": "contracts/RewardDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {MerkleProof} from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport {Common} from \"./libraries/Common.sol\";\n\ncontract RewardDistributor is AccessControl, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    struct Reward {\n        address token;\n        bytes32 merkleRoot;\n        bytes32 proof;\n        uint256 updateCount;\n    }\n\n    struct Claim {\n        bytes32 identifier;\n        address account;\n        uint256 index;\n        uint256 amount;\n        bytes32[] merkleProof;\n    }\n\n    address public bribeVault;\n    mapping(bytes32 => Reward) public rewards; // Maps each of the reward identifier to its metadata\n    mapping(bytes32 => mapping(uint256 => mapping(uint256 => uint256)))\n        private claimed; // Tracks whether a specific reward claim has been done\n\n    event SetBribeVault(address _bribeVault);\n    event RewardClaimed(\n        bytes32 indexed identifier,\n        address indexed tokenAddress,\n        address indexed account,\n        uint256 updateCount,\n        uint256 index,\n        uint256 amount\n    );\n    event RewardMetadataUpdated(\n        bytes32 indexed identifier,\n        address indexed token,\n        bytes32 merkleRoot,\n        bytes32 proof,\n        uint256 indexed updateCount\n    );\n\n    constructor(address _bribeVault) {\n        require(_bribeVault != address(0), \"Invalid bribeVault\");\n        bribeVault = _bribeVault;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    // Enables BribeVault to transfer native tokens\n    receive() external payable {}\n\n    /**\n        @notice Set bribe vault\n        @param  _bribeVault address New address of the bribe vault\n     */\n    function setBribeVault(address _bribeVault)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_bribeVault != address(0), \"Invalid bribeVault\");\n        bribeVault = _bribeVault;\n\n        emit SetBribeVault(bribeVault);\n    }\n\n    /**\n        @notice Claim rewards based on the specified metadata\n        @param  _claims   Claim[] List of claim metadata\n     */\n    function claim(Claim[] calldata _claims) external nonReentrant {\n        require(_claims.length > 0, \"Invalid _claims\");\n\n        for (uint256 i = 0; i < _claims.length; i++) {\n            _claim(\n                _claims[i].identifier,\n                _claims[i].index,\n                _claims[i].account,\n                _claims[i].amount,\n                _claims[i].merkleProof\n            );\n        }\n    }\n\n    /**\n        @notice Update the overall metadata of the specified reward identifiers\n        @param  _distributions    Distribution[] List of reward distribution details\n     */\n    function updateRewardsMetadata(\n        Common.Distribution[] calldata _distributions\n    ) external {\n        require(msg.sender == bribeVault, \"Invalid access\");\n        require(_distributions.length > 0, \"Invalid _distributions\");\n\n        for (uint256 i = 0; i < _distributions.length; i++) {\n            // Update the metadata and also increment the update to reset the claimed tracker\n            Reward storage reward = rewards[_distributions[i].rewardIdentifier];\n            reward.token = _distributions[i].token;\n            reward.merkleRoot = _distributions[i].merkleRoot;\n            reward.proof = _distributions[i].proof;\n            reward.updateCount += 1;\n\n            emit RewardMetadataUpdated(\n                _distributions[i].rewardIdentifier,\n                _distributions[i].token,\n                _distributions[i].merkleRoot,\n                _distributions[i].proof,\n                reward.updateCount\n            );\n        }\n    }\n\n    /**\n        @notice Check if the reward on the specified identifier and index has been claimed\n        @param  _identifier    bytes32 The specified identifier\n        @param  _index         bytes32 The specified index\n        @return  claimed       bool    Whether reward has been claimed\n     */\n    function isRewardClaimed(bytes32 _identifier, uint256 _index)\n        public\n        view\n        returns (bool)\n    {\n        // Get the group index for the specified index along with the bit index\n        // and check if the corresponding bit index is flipped\n        Reward memory reward = rewards[_identifier];\n        uint256 claimedGroup = _index / 256;\n        uint256 claimedIndex = _index % 256;\n        uint256 claimedGroupState = claimed[_identifier][reward.updateCount][\n            claimedGroup\n        ];\n        uint256 mask = (1 << claimedIndex);\n        return claimedGroupState & mask == mask;\n    }\n\n    /**\n        @notice Claim a reward\n        @param  _rewardIdentifier  bytes32    Reward identifier\n        @param  _index             uint256    Node index\n        @param  _account           address    Eligible user account\n        @param  _amount            bytes32    Reward amount\n        @param  _merkleProof       bytes32[]  Merkle proof\n     */\n    function _claim(\n        bytes32 _rewardIdentifier,\n        uint256 _index,\n        address _account,\n        uint256 _amount,\n        bytes32[] calldata _merkleProof\n    ) internal {\n        Reward memory reward = rewards[_rewardIdentifier];\n        require(reward.merkleRoot != 0, \"Distribution not enabled\");\n        require(\n            !isRewardClaimed(_rewardIdentifier, _index),\n            \"Reward already claimed\"\n        );\n\n        // Verify the merkle proof\n        bytes32 node = keccak256(abi.encodePacked(_index, _account, _amount));\n        require(\n            MerkleProof.verify(_merkleProof, reward.merkleRoot, node),\n            \"Invalid proof\"\n        );\n\n        _setClaimed(_rewardIdentifier, _index);\n\n        // Check whether the reward is in the form of native tokens or ERC20\n        // by checking if the token address is set to the bribe vault or not\n        address token = reward.token;\n        if (token != bribeVault) {\n            IERC20(token).safeTransfer(_account, _amount);\n        } else {\n            payable(_account).transfer(_amount);\n        }\n\n        emit RewardClaimed(\n            _rewardIdentifier,\n            token,\n            _account,\n            reward.updateCount,\n            _index,\n            _amount\n        );\n    }\n\n    /**\n        @notice Set a reward as claimed\n        @param  _identifier  bytes32    Reward identifier\n        @param  _index       uint256    Node index\n     */\n    function _setClaimed(bytes32 _identifier, uint256 _index) internal {\n        Reward memory reward = rewards[_identifier];\n        uint256 claimedGroup = _index / 256;\n        uint256 claimedIndex = _index % 256;\n\n        // Flip the bit state to mark the corresponding index as claimed\n        claimed[_identifier][reward.updateCount][claimedGroup] =\n            claimed[_identifier][reward.updateCount][claimedGroup] |\n            (1 << claimedIndex);\n    }\n}"
    }
  ]
}