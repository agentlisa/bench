{
  "Title": "[G-27] Use `Short-Circuiting` rules to your advantage",
  "Content": "\nWhen using logical disjunction (`||`) or logical conjunction (`&&`), make sure to order your functions correctly for optimal gas usage. In logical disjunction (`OR`), if the first function resolves to true, the second one won’t be executed and hence, save you gas. In logical disjunction (`AND`), if the first function evaluates to false, the next function won’t be evaluated. Therefore, you should order your functions accordingly in your solidity code to reduce the probability of needing to evaluate the second function.\n\n```solidity\nFile: src/erc-20/ERC20Boost.sol\n117   if (!_gauges.contains(msg.sender) || _deprecatedGauges.contains(msg.sender)) {\n\n212   if (_deprecatedGauges.contains(gauge) || boost >= gaugeState.userGaugeBoost) {\n\n267   if (gauge == address(0) || !(newAdd || previouslyDeprecated)) revert InvalidGauge();\n\nand so .....\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/erc-20/ERC20Boost.sol#L117\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/erc-20/ERC20Boost.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {EnumerableSet} from \"@lib/EnumerableSet.sol\";\n\nimport {IBaseV2Gauge} from \"@gauges/interfaces/IBaseV2Gauge.sol\";\n\nimport {Errors} from \"./interfaces/Errors.sol\";\nimport {IERC20Boost} from \"./interfaces/IERC20Boost.sol\";\n\n/// @title An ERC20 with an embedded attachment mechanism to keep track of boost\n///        allocations to gauges.\nabstract contract ERC20Boost is ERC20, Ownable, IERC20Boost {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using SafeCastLib for *;\n\n    /*///////////////////////////////////////////////////////////////\n                            GAUGE STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    mapping(address => mapping(address => GaugeState)) public override getUserGaugeBoost;\n\n    /// @inheritdoc IERC20Boost\n    mapping(address => uint256) public override getUserBoost;\n\n    mapping(address => EnumerableSet.AddressSet) internal _userGauges;\n\n    EnumerableSet.AddressSet internal _gauges;\n\n    // Store deprecated gauges in case a user needs to free dead boost\n    EnumerableSet.AddressSet internal _deprecatedGauges;\n\n    /*///////////////////////////////////////////////////////////////\n                            VIEW HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    function gauges() external view returns (address[] memory) {\n        return _gauges.values();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function gauges(uint256 offset, uint256 num) external view returns (address[] memory values) {\n        values = new address[](num);\n        for (uint256 i = 0; i < num;) {\n            unchecked {\n                values[i] = _gauges.at(offset + i); // will revert if out of bounds\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC20Boost\n    function isGauge(address gauge) external view returns (bool) {\n        return _gauges.contains(gauge) && !_deprecatedGauges.contains(gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function numGauges() external view returns (uint256) {\n        return _gauges.length();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function deprecatedGauges() external view returns (address[] memory) {\n        return _deprecatedGauges.values();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function numDeprecatedGauges() external view returns (uint256) {\n        return _deprecatedGauges.length();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function freeGaugeBoost(address user) public view returns (uint256) {\n        return balanceOf[user] - getUserBoost[user];\n    }\n\n    /// @inheritdoc IERC20Boost\n    function userGauges(address user) external view returns (address[] memory) {\n        return _userGauges[user].values();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function isUserGauge(address user, address gauge) external view returns (bool) {\n        return _userGauges[user].contains(gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function userGauges(address user, uint256 offset, uint256 num) external view returns (address[] memory values) {\n        values = new address[](num);\n        for (uint256 i = 0; i < num;) {\n            unchecked {\n                values[i] = _userGauges[user].at(offset + i); // will revert if out of bounds\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC20Boost\n    function numUserGauges(address user) external view returns (uint256) {\n        return _userGauges[user].length();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    function attach(address user) external {\n        if (!_gauges.contains(msg.sender) || _deprecatedGauges.contains(msg.sender)) {\n            revert InvalidGauge();\n        }\n\n        // idempotent add\n        if (!_userGauges[user].add(msg.sender)) revert GaugeAlreadyAttached();\n\n        uint128 userGaugeBoost = balanceOf[user].toUint128();\n\n        if (getUserBoost[user] < userGaugeBoost) {\n            getUserBoost[user] = userGaugeBoost;\n            emit UpdateUserBoost(user, userGaugeBoost);\n        }\n\n        getUserGaugeBoost[user][msg.sender] =\n            GaugeState({userGaugeBoost: userGaugeBoost, totalGaugeBoost: totalSupply.toUint128()});\n\n        emit Attach(user, msg.sender, userGaugeBoost);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function detach(address user) external {\n        require(_userGauges[user].remove(msg.sender));\n        delete getUserGaugeBoost[user][msg.sender];\n\n        emit Detach(user, msg.sender);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        USER GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    function updateUserBoost(address user) external {\n        uint256 userBoost = 0;\n\n        address[] memory gaugeList = _userGauges[user].values();\n\n        uint256 length = gaugeList.length;\n        for (uint256 i = 0; i < length;) {\n            address gauge = gaugeList[i];\n\n            if (!_deprecatedGauges.contains(gauge)) {\n                uint256 gaugeBoost = getUserGaugeBoost[user][gauge].userGaugeBoost;\n\n                if (userBoost < gaugeBoost) userBoost = gaugeBoost;\n            }\n\n            unchecked {\n                i++;\n            }\n        }\n        getUserBoost[user] = userBoost;\n\n        emit UpdateUserBoost(user, userBoost);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementGaugeBoost(address gauge, uint256 boost) public {\n        GaugeState storage gaugeState = getUserGaugeBoost[msg.sender][gauge];\n        if (boost >= gaugeState.userGaugeBoost) {\n            _userGauges[msg.sender].remove(gauge);\n            delete getUserGaugeBoost[msg.sender][gauge];\n\n            emit Detach(msg.sender, gauge);\n        } else {\n            gaugeState.userGaugeBoost -= boost.toUint128();\n\n            emit DecrementUserGaugeBoost(msg.sender, gauge, gaugeState.userGaugeBoost);\n        }\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementGaugeAllBoost(address gauge) external {\n        require(_userGauges[msg.sender].remove(gauge));\n        delete getUserGaugeBoost[msg.sender][gauge];\n\n        emit Detach(msg.sender, gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementAllGaugesBoost(uint256 boost) external {\n        decrementGaugesBoostIndexed(boost, 0, _userGauges[msg.sender].length());\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementGaugesBoostIndexed(uint256 boost, uint256 offset, uint256 num) public {\n        address[] memory gaugeList = _userGauges[msg.sender].values();\n\n        uint256 length = gaugeList.length;\n        for (uint256 i = 0; i < num && i < length;) {\n            address gauge = gaugeList[offset + i];\n\n            GaugeState storage gaugeState = getUserGaugeBoost[msg.sender][gauge];\n\n            if (_deprecatedGauges.contains(gauge) || boost >= gaugeState.userGaugeBoost) {\n                require(_userGauges[msg.sender].remove(gauge)); // Remove from set. Should never fail.\n                delete getUserGaugeBoost[msg.sender][gauge];\n\n                emit Detach(msg.sender, gauge);\n            } else {\n                gaugeState.userGaugeBoost -= boost.toUint128();\n\n                emit DecrementUserGaugeBoost(msg.sender, gauge, gaugeState.userGaugeBoost);\n            }\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementAllGaugesAllBoost() external {\n        // Loop through all user gauges, live and deprecated\n        address[] memory gaugeList = _userGauges[msg.sender].values();\n\n        // Free gauges until through the entire list\n        uint256 size = gaugeList.length;\n        for (uint256 i = 0; i < size;) {\n            address gauge = gaugeList[i];\n\n            require(_userGauges[msg.sender].remove(gauge)); // Remove from set. Should never fail.\n            delete getUserGaugeBoost[msg.sender][gauge];\n\n            emit Detach(msg.sender, gauge);\n\n            unchecked {\n                i++;\n            }\n        }\n\n        getUserBoost[msg.sender] = 0;\n\n        emit UpdateUserBoost(msg.sender, 0);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ADMIN GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    function addGauge(address gauge) external onlyOwner {\n        _addGauge(gauge);\n    }\n\n    function _addGauge(address gauge) internal {\n        bool newAdd = _gauges.add(gauge);\n        bool previouslyDeprecated = _deprecatedGauges.remove(gauge);\n        // add and fail loud if zero address or already present and not deprecated\n        if (gauge == address(0) || !(newAdd || previouslyDeprecated)) revert InvalidGauge();\n\n        emit AddGauge(gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function removeGauge(address gauge) external onlyOwner {\n        _removeGauge(gauge);\n    }\n\n    function _removeGauge(address gauge) internal {\n        // add to deprecated and fail loud if not present\n        if (!_deprecatedGauges.add(gauge)) revert InvalidGauge();\n\n        emit RemoveGauge(gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function replaceGauge(address oldGauge, address newGauge) external onlyOwner {\n        _removeGauge(oldGauge);\n        _addGauge(newGauge);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// NOTE: any \"removal\" of tokens from a user requires notAttached < amount.\n\n    /**\n     * @notice Burns `amount` of tokens from `from` address.\n     * @dev User must have enough free boost.\n     * @param from The address to burn tokens from.\n     * @param amount The amount of tokens to burn.\n     */\n    function _burn(address from, uint256 amount) internal override notAttached(from, amount) {\n        super._burn(from, amount);\n    }\n\n    /**\n     * @notice Transfers `amount` of tokens from `msg.sender` to `to` address.\n     * @dev User must have enough free boost.\n     * @param to the address to transfer to.\n     * @param amount the amount to transfer.\n     */\n    function transfer(address to, uint256 amount) public override notAttached(msg.sender, amount) returns (bool) {\n        return super.transfer(to, amount);\n    }\n\n    /**\n     * @notice Transfers `amount` of tokens from `from` address to `to` address.\n     * @dev User must have enough free boost.\n     * @param from the address to transfer from.\n     * @param to the address to transfer to.\n     * @param amount the amount to transfer.\n     */\n    function transferFrom(address from, address to, uint256 amount)\n        public\n        override\n        notAttached(from, amount)\n        returns (bool)\n    {\n        return super.transferFrom(from, to, amount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Reverts if the user does not have enough free boost.\n     * @param user The user address.\n     * @param amount The amount of boost.\n     */\n    modifier notAttached(address user, uint256 amount) {\n        if (freeGaugeBoost(user) < amount) revert AttachedBoost();\n        _;\n    }\n}"
    }
  ]
}