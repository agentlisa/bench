{
  "Title": "[M-10] Add a timelock to `setPlatformFee()`",
  "Content": "_Submitted by Dravee_\n\n<https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/SplitFactory.sol#L120>\n\n<https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L67>\n\n### Impact\n\nIt is a good practice to give time for users to react and adjust to critical changes. A timelock provides more guarantees and reduces the level of trust required, thus decreasing risk for users. It also indicates that the project is legitimate.\n\nHere, no timelock capabilities seem to be used\n\nI believe this impacts multiple users enough to make them want to react / be notified ahead of time.\n\n### Recommended Mitigation Steps\n\nConsider adding a timelock to `setPlatformFee()`\n\n**[sofianeOuafir (Joyn) acknowledged and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/112#issuecomment-1099708757):**\n > This is a good idea. We will consider mitigating this but at the same time it might not be something we will solve \n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-03-joyn-contest",
  "Code": [
    {
      "filename": "splits/contracts/SplitFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {ProxyVault} from '@chestrnft/royalty-vault/contracts/ProxyVault.sol';\nimport {SplitProxy} from './SplitProxy.sol';\nimport {IRoyaltyVault} from '@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol';\nimport {ICoreCollection} from '../interfaces/ICoreCollection.sol';\n\ncontract SplitFactory is Ownable {\n  /**** Immutable storage ****/\n\n  address public immutable splitter;\n  address public immutable royaltyVault;\n\n  /**** Mmutable storage ****/\n  // Gets set within the block, and then deleted.\n\n  bytes32 public merkleRoot;\n  address public splitAsset;\n  address public royaltyAsset;\n  address public splitterProxy;\n  uint256 public platformFee;\n  address public platformFeeRecipient;\n\n  mapping(string => address) public splits;\n\n  /**** Events ****/\n\n  event SplitCreated(address indexed splitter, string splitId);\n\n  event VaultCreated(\n    address indexed vault,\n    address indexed splitter,\n    uint256 platformFee,\n    address platformFeeRecipient\n  );\n\n  event VaultAssignedToCollection(\n    address indexed vault,\n    address indexed splitter,\n    address indexed collectionContract\n  );\n\n  // ---------------- MODIFIER ----------------\n\n  modifier onlyAvailableSplit(string memory _splitId) {\n    require(\n      splits[_splitId] == address(0),\n      'SplitFactory : Split ID already in use'\n    );\n    _;\n  }\n\n  /**\n   * @dev Constructor\n   * @param _splitter The address of the Splitter contract.\n   */\n  constructor(address _splitter, address _royaltyVault) {\n    splitter = _splitter;\n    royaltyVault = _royaltyVault;\n    platformFee = 500; // 5%\n    platformFeeRecipient = 0x70388C130222eae55a0527a2367486bF5D12d6e7;\n  }\n\n  // ---------------- EXTERNAL ----------------\n\n  /**\n   * @dev Deploys a new SplitProxy and initializes collection's royalty vault.\n   * @param _merkleRoot The merkle root of the asset.\n   * @param _splitAsset The address of the asset to split.\n   * @param _collectionContract The address of the collection contract.\n   * @param _splitId The split identifier.\n   */\n  function createSplit(\n    bytes32 _merkleRoot,\n    address _splitAsset,\n    address _collectionContract,\n    string memory _splitId\n  ) external onlyAvailableSplit(_splitId) returns (address splitProxy) {\n    require(\n      ICoreCollection(_collectionContract).owner() == msg.sender,\n      'Transaction sender is not collection owner'\n    );\n    merkleRoot = _merkleRoot;\n    splitAsset = _splitAsset;\n    royaltyAsset = _splitAsset;\n\n    splitProxy = createSplitProxy(_splitId);\n    address vault = createVaultProxy(splitProxy);\n\n    ICoreCollection(_collectionContract).setRoyaltyVault(vault);\n    emit VaultAssignedToCollection(vault, splitter, _collectionContract);\n  }\n\n  /**\n   * @dev Deploys a new SplitProxy.\n   * @param _merkleRoot The merkle root of the asset.\n   * @param _splitAsset The address of the asset to split.\n   * @param _splitId The split identifier.\n   */\n  function createSplit(\n    bytes32 _merkleRoot,\n    address _splitAsset,\n    string memory _splitId\n  ) external onlyAvailableSplit(_splitId) returns (address splitProxy) {\n    merkleRoot = _merkleRoot;\n    splitAsset = _splitAsset;\n    royaltyAsset = _splitAsset;\n\n    splitProxy = createSplitProxy(_splitId);\n    createVaultProxy(splitProxy);\n  }\n\n  /**\n   * @dev Set Platform fee for collection contract.\n   * @param _platformFee Platform fee in scaled percentage. (5% = 200)\n   * @param _vault vault address.\n   */\n  function setPlatformFee(address _vault, uint256 _platformFee)\n    external\n    onlyOwner\n  {\n    IRoyaltyVault(_vault).setPlatformFee(_platformFee);\n  }\n\n  /**\n   * @dev Set Platform fee recipient for collection contract.\n   * @param _vault vault address.\n   * @param _platformFeeRecipient Platform fee recipient.\n   */\n  function setPlatformFeeRecipient(\n    address _vault,\n    address _platformFeeRecipient\n  ) external onlyOwner {\n    require(_vault != address(0), 'Invalid vault');\n    require(\n      _platformFeeRecipient != address(0),\n      'Invalid platform fee recipient'\n    );\n    IRoyaltyVault(_vault).setPlatformFeeRecipient(_platformFeeRecipient);\n  }\n\n  // ---------------- PRIVATE ----------------\n\n  /**\n   * @dev Creates a new SplitProxy.\n   */\n  function createSplitProxy(string memory _splitId)\n    private\n    returns (address splitProxy)\n  {\n    splitProxy = address(\n      new SplitProxy{salt: keccak256(abi.encode(merkleRoot))}()\n    );\n\n    splits[_splitId] = splitProxy;\n\n    emit SplitCreated(splitProxy, _splitId);\n\n    delete merkleRoot;\n    delete splitAsset;\n  }\n\n  function createVaultProxy(address splitProxy)\n    private\n    returns (address vault)\n  {\n    splitterProxy = splitProxy;\n    vault = address(new ProxyVault{salt: keccak256(abi.encode(splitProxy))}());\n    delete splitterProxy;\n    delete royaltyAsset;\n    emit VaultCreated(vault, splitProxy, platformFee, platformFeeRecipient);\n  }\n}"
    },
    {
      "filename": "royalty-vault/contracts/RoyaltyVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {IRoyaltyVault} from \"../interfaces/IRoyaltyVault.sol\";\nimport {VaultStorage} from \"./VaultStorage.sol\";\nimport {ISplitter} from \"../interfaces/ISplitter.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract RoyaltyVault is VaultStorage, IRoyaltyVault, ERC165, Ownable {\n    /**** Events ****/\n    event RoyaltySentToSplitter(address indexed splitter, uint256 amount);\n    event FeeSentToPlatform(\n        address indexed platformFeeRecipient,\n        uint256 amount\n    );\n    event NewRoyaltyVaultPlatformFee(uint256 platformFee);\n    event NewRoyaltyVaultPlatformFeeRecipient(address recipient);\n\n    /**\n     * @dev Getting royaltyAsset balance of Vault.\n     */\n    function getVaultBalance() public view override returns (uint256) {\n        return IERC20(royaltyAsset).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Send accumulated royalty to splitter.\n     */\n    function sendToSplitter() external override {\n        uint256 balanceOfVault = getVaultBalance();\n\n        require(\n            balanceOfVault > 0,\n            \"Vault does not have enough royalty Asset to send\"\n        );\n        require(splitterProxy != address(0), \"Splitter is not set\");\n\n        uint256 platformShare = (balanceOfVault * platformFee) / 10000;\n        uint256 splitterShare = balanceOfVault - platformShare;\n\n        require(\n            IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,\n            \"Failed to transfer royalty Asset to splitter\"\n        );\n        require(\n            ISplitter(splitterProxy).incrementWindow(splitterShare) == true,\n            \"Failed to increment splitter window\"\n        );\n        require(\n            IERC20(royaltyAsset).transfer(\n                platformFeeRecipient,\n                platformShare\n            ) == true,\n            \"Failed to transfer royalty Asset to platform fee recipient\"\n        );\n\n        emit RoyaltySentToSplitter(splitterProxy, splitterShare);\n        emit FeeSentToPlatform(platformFeeRecipient, platformShare);\n    }\n\n    /**\n     * @dev Set Platform fee for collection contract.\n     * @param _platformFee Platform fee in scaled percentage.\n     */\n    function setPlatformFee(uint256 _platformFee) external override onlyOwner {\n        platformFee = _platformFee;\n        emit NewRoyaltyVaultPlatformFee(_platformFee);\n    }\n\n    /**\n     * @dev Set Platform fee recipient for collection.\n     * @param _platformFeeRecipient Platform fee recipient address\n     */\n    function setPlatformFeeRecipient(address _platformFeeRecipient)\n        external\n        override\n        onlyOwner\n    {\n        platformFeeRecipient = _platformFeeRecipient;\n        emit NewRoyaltyVaultPlatformFeeRecipient(_platformFeeRecipient);\n    }\n\n    /**\n     * @dev Get Splitter address of proxyVault.\n     */\n    function getSplitter() public view override returns (address) {\n        return splitterProxy;\n    }\n\n    /**\n     * @dev Checks for support of IRoyaltyVault.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(IRoyaltyVault, ERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IRoyaltyVault).interfaceId;\n    }\n}"
    }
  ]
}