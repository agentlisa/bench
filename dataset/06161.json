{
  "Title": "[L-03] No event emitted when a vote is cast in `MultisigBase`",
  "Content": "\nTo vote in `MultisigBase` a signer submits the same data as the proposal. Then, this data is hashed into a [proposal id (`topic`)](https://github.com/code-423n4/2023-07-axelar/blob/main/contracts/cgp/auth/MultisigBase.sol#L47-L48) which has its votes tracked. When enough votes are cast the proposal passes:\n\nhttps://github.com/code-423n4/2023-07-axelar/blob/main/contracts/cgp/auth/MultisigBase.sol#L51-L63\n\n```solidity\nFile: cgp/auth/MultisigBase.sol\n\n51:        if (voting.hasVoted[msg.sender]) revert AlreadyVoted();\n52:\n53:        voting.hasVoted[msg.sender] = true;\n54:\n55:        // Determine the new vote count.\n56:        uint256 voteCount = voting.voteCount + 1;\n57:\n\n           // @audit no event emitted to track votes\n\n58:        // Do not proceed with operation execution if insufficient votes.\n59:        if (voteCount < signers.threshold) {\n60:            // Save updated vote count.\n61:            voting.voteCount = voteCount;\n62:            return;\n63:        }\n```\n\nHowever, there is no event emitted for when a vote is cast. This makes it difficult to track voting off-chain, which is important for transparency and for users and signers to know what `topics` are going on. `topics` can also only be tracked by their hashed value, hence, emitting this will help users to query on-chain for specific votes.\n\n### Recommendation\n\nAdd an event for when a vote is cast, containing `signer`, `topic` and `voteCount`.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-07-axelar",
  "Code": [
    {
      "filename": "contracts/cgp/auth/MultisigBase.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IMultisigBase } from '../interfaces/IMultisigBase.sol';\n\n/**\n * @title MultisigBase Contract\n * @notice This contract implements a custom multisignature wallet where transactions must be confirmed by a\n * threshold of signers. The signers and threshold may be updated every `epoch`.\n */\ncontract MultisigBase is IMultisigBase {\n    struct Voting {\n        uint256 voteCount;\n        mapping(address => bool) hasVoted;\n    }\n\n    struct Signers {\n        address[] accounts;\n        uint256 threshold;\n        mapping(address => bool) isSigner;\n    }\n\n    Signers public signers;\n    uint256 public signerEpoch;\n    // uint256 is for epoch, bytes32 for vote topic hash\n    mapping(uint256 => mapping(bytes32 => Voting)) public votingPerTopic;\n\n    /**\n     * @notice Contract constructor\n     * @dev Sets the initial list of signers and corresponding threshold.\n     * @param accounts Address array of the signers\n     * @param threshold Signature threshold required to validate a transaction\n     */\n    constructor(address[] memory accounts, uint256 threshold) {\n        _rotateSigners(accounts, threshold);\n    }\n\n    /**\n     * @notice Modifier to ensure the caller is a signer\n     * @dev Keeps track of votes for each operation and resets the vote count if the operation is executed.\n     * @dev Given the early void return, this modifier should be used with care on functions that return data.\n     */\n    modifier onlySigners() {\n        if (!signers.isSigner[msg.sender]) revert NotSigner();\n\n        bytes32 topic = keccak256(msg.data);\n        Voting storage voting = votingPerTopic[signerEpoch][topic];\n\n        // Check that signer has not voted, then record that they have voted.\n        if (voting.hasVoted[msg.sender]) revert AlreadyVoted();\n\n        voting.hasVoted[msg.sender] = true;\n\n        // Determine the new vote count.\n        uint256 voteCount = voting.voteCount + 1;\n\n        // Do not proceed with operation execution if insufficient votes.\n        if (voteCount < signers.threshold) {\n            // Save updated vote count.\n            voting.voteCount = voteCount;\n            return;\n        }\n\n        // Clear vote count and voted booleans.\n        voting.voteCount = 0;\n\n        uint256 count = signers.accounts.length;\n\n        for (uint256 i; i < count; ++i) {\n            voting.hasVoted[signers.accounts[i]] = false;\n        }\n\n        emit MultisigOperationExecuted(topic);\n\n        _;\n    }\n\n    /******************\\\n    |* Public Getters *|\n    \\******************/\n\n    /**\n     * @notice Returns the current signer threshold\n     * @return uint The signer threshold\n     */\n    function signerThreshold() external view override returns (uint256) {\n        return signers.threshold;\n    }\n\n    /**\n     * @notice Returns an array of current signers\n     * @return array of signer addresses\n     */\n    function signerAccounts() external view override returns (address[] memory) {\n        return signers.accounts;\n    }\n\n    /**\n     * @notice Getter to determine if an account is a signer\n     * @return boolean indicating if the account is a signer\n     */\n    function isSigner(address account) external view override returns (bool) {\n        return signers.isSigner[account];\n    }\n\n    /**\n     * @notice Getter to determine if an account has voted on a topic\n     * @return boolean indicating if the account has voted\n     */\n    function hasSignerVoted(address account, bytes32 topic) external view override returns (bool) {\n        return votingPerTopic[signerEpoch][topic].hasVoted[account];\n    }\n\n    /**\n     * @notice Get the number of votes for a topic\n     * @return uint256 indicating the number of votes for a topic\n     */\n    function getSignerVotesCount(bytes32 topic) external view override returns (uint256) {\n        uint256 length = signers.accounts.length;\n        uint256 voteCount;\n        for (uint256 i; i < length; ++i) {\n            if (votingPerTopic[signerEpoch][topic].hasVoted[signers.accounts[i]]) {\n                voteCount++;\n            }\n        }\n\n        return voteCount;\n    }\n\n    /***********\\\n    |* Setters *|\n    \\***********/\n\n    /**\n     * @notice Rotate the signers for the multisig\n     * @dev Updates the current set of signers and threshold and increments the `epoch`\n     * @dev This function is protected by the onlySigners modifier\n     * @param newAccounts Address array of the new signers\n     * @param newThreshold The new signature threshold for executing operations\n     */\n    function rotateSigners(address[] memory newAccounts, uint256 newThreshold) external virtual onlySigners {\n        _rotateSigners(newAccounts, newThreshold);\n    }\n\n    /**\n     * @dev Internal function that implements signer rotation logic\n     */\n    function _rotateSigners(address[] memory newAccounts, uint256 newThreshold) internal {\n        uint256 length = signers.accounts.length;\n\n        // Clean up old signers.\n        for (uint256 i; i < length; ++i) {\n            signers.isSigner[signers.accounts[i]] = false;\n        }\n\n        length = newAccounts.length;\n\n        if (newThreshold > length) revert InvalidSigners();\n\n        if (newThreshold == 0) revert InvalidSignerThreshold();\n\n        ++signerEpoch;\n\n        signers.accounts = newAccounts;\n        signers.threshold = newThreshold;\n\n        for (uint256 i; i < length; ++i) {\n            address account = newAccounts[i];\n\n            // Check that the account wasn't already set as a signer for this epoch.\n            if (signers.isSigner[account]) revert DuplicateSigner(account);\n            if (account == address(0)) revert InvalidSigners();\n\n            signers.isSigner[account] = true;\n        }\n\n        emit SignersRotated(newAccounts, newThreshold);\n    }\n}"
    },
    {
      "filename": "contracts/cgp/auth/MultisigBase.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IMultisigBase } from '../interfaces/IMultisigBase.sol';\n\n/**\n * @title MultisigBase Contract\n * @notice This contract implements a custom multisignature wallet where transactions must be confirmed by a\n * threshold of signers. The signers and threshold may be updated every `epoch`.\n */\ncontract MultisigBase is IMultisigBase {\n    struct Voting {\n        uint256 voteCount;\n        mapping(address => bool) hasVoted;\n    }\n\n    struct Signers {\n        address[] accounts;\n        uint256 threshold;\n        mapping(address => bool) isSigner;\n    }\n\n    Signers public signers;\n    uint256 public signerEpoch;\n    // uint256 is for epoch, bytes32 for vote topic hash\n    mapping(uint256 => mapping(bytes32 => Voting)) public votingPerTopic;\n\n    /**\n     * @notice Contract constructor\n     * @dev Sets the initial list of signers and corresponding threshold.\n     * @param accounts Address array of the signers\n     * @param threshold Signature threshold required to validate a transaction\n     */\n    constructor(address[] memory accounts, uint256 threshold) {\n        _rotateSigners(accounts, threshold);\n    }\n\n    /**\n     * @notice Modifier to ensure the caller is a signer\n     * @dev Keeps track of votes for each operation and resets the vote count if the operation is executed.\n     * @dev Given the early void return, this modifier should be used with care on functions that return data.\n     */\n    modifier onlySigners() {\n        if (!signers.isSigner[msg.sender]) revert NotSigner();\n\n        bytes32 topic = keccak256(msg.data);\n        Voting storage voting = votingPerTopic[signerEpoch][topic];\n\n        // Check that signer has not voted, then record that they have voted.\n        if (voting.hasVoted[msg.sender]) revert AlreadyVoted();\n\n        voting.hasVoted[msg.sender] = true;\n\n        // Determine the new vote count.\n        uint256 voteCount = voting.voteCount + 1;\n\n        // Do not proceed with operation execution if insufficient votes.\n        if (voteCount < signers.threshold) {\n            // Save updated vote count.\n            voting.voteCount = voteCount;\n            return;\n        }\n\n        // Clear vote count and voted booleans.\n        voting.voteCount = 0;\n\n        uint256 count = signers.accounts.length;\n\n        for (uint256 i; i < count; ++i) {\n            voting.hasVoted[signers.accounts[i]] = false;\n        }\n\n        emit MultisigOperationExecuted(topic);\n\n        _;\n    }\n\n    /******************\\\n    |* Public Getters *|\n    \\******************/\n\n    /**\n     * @notice Returns the current signer threshold\n     * @return uint The signer threshold\n     */\n    function signerThreshold() external view override returns (uint256) {\n        return signers.threshold;\n    }\n\n    /**\n     * @notice Returns an array of current signers\n     * @return array of signer addresses\n     */\n    function signerAccounts() external view override returns (address[] memory) {\n        return signers.accounts;\n    }\n\n    /**\n     * @notice Getter to determine if an account is a signer\n     * @return boolean indicating if the account is a signer\n     */\n    function isSigner(address account) external view override returns (bool) {\n        return signers.isSigner[account];\n    }\n\n    /**\n     * @notice Getter to determine if an account has voted on a topic\n     * @return boolean indicating if the account has voted\n     */\n    function hasSignerVoted(address account, bytes32 topic) external view override returns (bool) {\n        return votingPerTopic[signerEpoch][topic].hasVoted[account];\n    }\n\n    /**\n     * @notice Get the number of votes for a topic\n     * @return uint256 indicating the number of votes for a topic\n     */\n    function getSignerVotesCount(bytes32 topic) external view override returns (uint256) {\n        uint256 length = signers.accounts.length;\n        uint256 voteCount;\n        for (uint256 i; i < length; ++i) {\n            if (votingPerTopic[signerEpoch][topic].hasVoted[signers.accounts[i]]) {\n                voteCount++;\n            }\n        }\n\n        return voteCount;\n    }\n\n    /***********\\\n    |* Setters *|\n    \\***********/\n\n    /**\n     * @notice Rotate the signers for the multisig\n     * @dev Updates the current set of signers and threshold and increments the `epoch`\n     * @dev This function is protected by the onlySigners modifier\n     * @param newAccounts Address array of the new signers\n     * @param newThreshold The new signature threshold for executing operations\n     */\n    function rotateSigners(address[] memory newAccounts, uint256 newThreshold) external virtual onlySigners {\n        _rotateSigners(newAccounts, newThreshold);\n    }\n\n    /**\n     * @dev Internal function that implements signer rotation logic\n     */\n    function _rotateSigners(address[] memory newAccounts, uint256 newThreshold) internal {\n        uint256 length = signers.accounts.length;\n\n        // Clean up old signers.\n        for (uint256 i; i < length; ++i) {\n            signers.isSigner[signers.accounts[i]] = false;\n        }\n\n        length = newAccounts.length;\n\n        if (newThreshold > length) revert InvalidSigners();\n\n        if (newThreshold == 0) revert InvalidSignerThreshold();\n\n        ++signerEpoch;\n\n        signers.accounts = newAccounts;\n        signers.threshold = newThreshold;\n\n        for (uint256 i; i < length; ++i) {\n            address account = newAccounts[i];\n\n            // Check that the account wasn't already set as a signer for this epoch.\n            if (signers.isSigner[account]) revert DuplicateSigner(account);\n            if (account == address(0)) revert InvalidSigners();\n\n            signers.isSigner[account] = true;\n        }\n\n        emit SignersRotated(newAccounts, newThreshold);\n    }\n}"
    }
  ]
}