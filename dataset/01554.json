{
  "Title": "M-1: Funds can be stolen from the `FixedStrikeOptionTeller` contract by creating put option tokens without providing collateral",
  "Content": "# Issue M-1: Funds can be stolen from the `FixedStrikeOptionTeller` contract by creating put option tokens without providing collateral \n\nSource: https://github.com/sherlock-audit/2023-06-bond-judging/issues/61 \n\n## Found by \nberndartmueller, pks\\_, techOptimizor\n## Summary\n\nDue to a rounding error when calculating the `quoteAmount` in the `create` function of the `FixedStrikeOptionTeller` contract, it is possible to create (issue) option tokens without providing the necessary collateral. A malicious receiver can exploit this to steal funds from the `FixedStrikeOptionTeller` contract.\n\n## Vulnerability Detail\n\nAnyone can create (issue) put option tokens with the `create` function in the `FixedStrikeOptionTeller` contract. However, by specifying a very small `amount_`, the `quoteAmount` calculation in line 283 can potentially round down to zero. This is the case if the result of the multiplication in line 283, $amount * strikePrice$ is smaller than $10^{decimals}$, where `decimals` is the number of decimals of the payout token.\n\nFor example, assume the following scenario:\n\n| Parameter                | Description                                                                                      |\n| ------------------------ | ------------------------------------------------------------------------------------------------ |\n| Quote token              | $USDC. 6 decimals                                                                                |\n| Payout token             | $GMX. 18 decimals                                                                                |\n| $payoutToken_{decimals}$ | 18 decimals                                                                                      |\n| $amount$                 | `1e10`. Amount (`amount_`) supplied to the `create` function, in payout token decimal precision. |\n| $strikePrice$            | `50e6` ~ 50 USD. The strike price of the option token, in quote tokens.                              |\n\n_[Please note that the option token has the same amount of decimals as the payout token.](https://github.com/sherlock-audit/2023-06-bond/blob/main/options/src/fixed-strike/FixedStrikeOptionTeller.sol#L221)_\n\nCalculating `quoteAmount` leads to the following result:\n\n$$\n\\begin{align}\nquoteAmount &= \\dfrac{amount * strikePrice}{10^{payoutToken_{decimals}}} \\\\\n&= \\dfrac{1e10 * 50e6}{10^{18}} \\\\\n&= \\dfrac{5e17}{10^{18}} \\\\\n&= \\dfrac{5 * 10^{17}}{10^{18}} \\\\\n&= 0\n\\end{align}\n$$\n\nAs observed, the result is rounded down to zero due to the numerator being smaller than the denominator.\n\nThis results in **0** quote tokens to be transferred from the caller to the contract, and in return, the caller receives `1e10` ($amount$) option tokens. This process can be repeated to mint an arbitrary amount of option tokens for free.\n\n## Impact\n\nPut options can be minted for free without providing the required `quoteToken` collateral.\n\nThis is intensified by the fact that a malicious receiver, which anyone can be, can exploit this issue by deploying a new option token (optionally with a very short expiry), repeatedly minting free put options to accumulate option tokens, and then, once the option expires, call `reclaim` to receive quote token collateral.\n\nThis collateral, however, was supplied by other users who issued (created) option tokens with the same quote token. Thus, the malicious receiver can drain funds from other users and cause undercollateralization of those affected option tokens.\n\n## Code Snippet\n\n[src/fixed-strike/FixedStrikeOptionTeller.sol#L283](https://github.com/sherlock-audit/2023-06-bond/blob/main/options/src/fixed-strike/FixedStrikeOptionTeller.sol#L283)\n\n```solidity\n236: function create(\n237:     FixedStrikeOptionToken optionToken_,\n238:     uint256 amount_\n239: ) external override nonReentrant {\n...      // [...]\n268:\n269:     // Transfer in collateral\n270:     // If call option, transfer in payout tokens equivalent to the amount of option tokens being issued\n271:     // If put option, transfer in quote tokens equivalent to the amount of option tokens being issued * strike price\n272:     if (call) {\n...          // [...]\n281:     } else {\n282:         // Calculate amount of quote tokens required to mint\n283: @>      uint256 quoteAmount = amount_.mulDiv(strikePrice, 10 ** payoutToken.decimals()); // @audit-issue Rounds down\n284:\n285:         // Transfer quote tokens from user\n286:         // Check that amount received is not less than amount expected\n287:         // Handles edge cases like fee-on-transfer tokens (which are not supported)\n288:         uint256 startBalance = quoteToken.balanceOf(address(this));\n289:         quoteToken.safeTransferFrom(msg.sender, address(this), quoteAmount);\n290:         uint256 endBalance = quoteToken.balanceOf(address(this));\n291:         if (endBalance < startBalance + quoteAmount)\n292:             revert Teller_UnsupportedToken(address(quoteToken));\n293:     }\n294:\n295:     // Mint new option tokens to sender\n296:     optionToken.mint(msg.sender, amount_);\n297: }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adding a check after line 283 to ensure `quoteAmount` is not zero.\n\n\n\n\n## Discussion\n\n**Oighty**\n\nAgree with this issue. Checking for a zero quote amount is a potential solution, but it would be better to fix the precision issue. I'm going to explore other ways to do this (including something like the price scale system used in the other bond protocol contracts).\n\n**ctf-sec**\n\nI agree, if only checking the amount > 0, the precision loss can still be large and round down to 1 wei\n\nscaling amount with decimals seems the way to go!\n\n**ctf-sec**\n\nIn report #62 \n\nthe auditor is correct the user can game the code to not pay the quote amount and receive the payout token just like the receiver\n\nbut there is no loss of fund, because when minting option, the payout token collateral has to be supplied.\n\nIn this report\n\nit is true the user can game the code to not supply the collateral and get the option token and then call reclaim the drain the fund.\n\nthe impact is clearly more severe\n\nbut the reclaim issue has been extensively covered in report:\n\nhttps://github.com/sherlock-audit/2023-06-bond-judging/issues/79\n\nthe report takes the advantage of the rounding\n\nin fact in my report:\n\nhttps://github.com/sherlock-audit/2023-06-bond-judging/issues/90\n\nI highlight the decimals is large and collateral is round down to 0 then call reclaim to drain the fund as well\n\nAfter internal discussion, Agree with the de-duplication and leave as a separate medium\n\n**0x3b33**\n\nI mean the issue is valid in a way that there needs to be a check for quote of 0, but how is anyone gonna profit from it? The attacker's profit is only 1e10, compared to GMX's decimals 18, he is making nothing! If my calculations are not wrong, the attacker will make 0.00000055$ per call...\nWhen I press the button to turn my PC on I spend more money, let alone to run a TX on any network. \n\n**ctf-sec**\n\n> I mean the issue is valid in a way that there needs to be a check for quote of 0, but how is anyone gonna profit from it? The attacker's profit is only 1e10, compared to GMX's decimals 18, he is making nothing! If my calculations are not wrong, the attacker will make 0.00000055$ per call... When I press the button to turn my PC on I spend more money, let alone to run a TX on any network.\n\nTo profits, the attacker would need to repeated call reclaim (which is another issue)\n\nThe decimal rounding plays a role as well (which is another issue)\n\nEven the fact that can mint token without providing collateral make it a valid issue.\n\n**Oighty**\n\nFix implemented at https://github.com/Bond-Protocol/options/pull/11\n\n**ctf-sec**\n\nFix looks good\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/99",
  "Code": [
    {
      "filename": "options/src/fixed-strike/FixedStrikeOptionTeller.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {ClonesWithImmutableArgs} from \"src/lib/clones/ClonesWithImmutableArgs.sol\";\n\nimport {IFixedStrikeOptionTeller, IOptionTeller} from \"src/interfaces/IFixedStrikeOptionTeller.sol\";\nimport {FixedStrikeOptionToken} from \"src/fixed-strike/FixedStrikeOptionToken.sol\";\n\nimport {TransferHelper} from \"src/lib/TransferHelper.sol\";\nimport {FullMath} from \"src/lib/FullMath.sol\";\n\n/// @title Fixed Strike Option Teller\n/// @notice Fixed Strike Option Teller Contract\n/// @dev Option Teller contracts handle the deployment, creation, and exercise of option tokens.\n///      Option Tokens are ERC20 tokens that represent the right to buy (call) or sell (put) a fixed\n///      amount of an asset (payout token) for an amount of another asset (quote token) between two\n///      timestamps (eligible and expiry). Option Tokens are denominated in units of the payout token\n///      and are created at a 1:1 ratio for the amount of payout tokens to buy or sell.\n///      The amount of quote tokens required to exercise (call) or collateralize (put) an option token\n///      is called the strike price. Strike prices are denominated in units of the quote token.\n///      The Fixed Strike Option Teller implementation creates option tokens that have a fixed strike\n///      price that is set at the time of creation.\n///\n///      In order to create option tokens, an issuer must deploy the specific token configuration on\n///      the teller, and then provide collateral to the teller to mint option tokens. The collateral is\n///      required to guarantee that the option tokens can be exercised. The collateral required depends on\n///      the option type. For call options, the collateral required is an amount of payout tokens equivalent\n///      to the amount of option tokens being minted. For put options, the collateral required is an amount\n///      of quote tokens equivalent to the amount of option tokens being minted multipled by the strike price.\n///      As the name \"option\" suggests, the holder of an option token has the right, but not the obligation,\n///      to exercise the option token within the eligible time window. If the option token is not exercised,\n///      the designated \"receiver\" of the option token exercise proceeds can reclaim the collateral after\n///      the expiry timestamp. If an option token is exercised, the holder receives the collateral and the\n///      receiver receives the exercise proceeds.\n///\n/// @author Bond Protocol\ncontract FixedStrikeOptionTeller is IFixedStrikeOptionTeller, Auth, ReentrancyGuard {\n    using TransferHelper for ERC20;\n    using FullMath for uint256;\n    using ClonesWithImmutableArgs for address;\n\n    /* ========== ERRORS ========== */\n\n    error Teller_NotAuthorized();\n    error Teller_TokenDoesNotExist(bytes32 optionHash);\n    error Teller_UnsupportedToken(address token);\n    error Teller_InvalidParams(uint256 index, bytes value);\n    error Teller_OptionExpired(uint48 expiry);\n    error Teller_NotEligible(uint48 eligible);\n    error Teller_NotExpired(uint48 expiry);\n    error Teller_PriceOutOfBounds();\n\n    /* ========== EVENTS ========== */\n    event WroteOption(uint256 indexed id, address indexed referrer, uint256 amount, uint256 payout);\n    event OptionTokenCreated(\n        FixedStrikeOptionToken optionToken,\n        ERC20 indexed payoutToken,\n        ERC20 quoteToken,\n        uint48 eligible,\n        uint48 indexed expiry,\n        address indexed receiver,\n        bool call,\n        uint256 strikePrice\n    );\n\n    /* ========== STATE VARIABLES ========== */\n\n    /// @notice Fee paid to protocol when options are exercised in basis points (3 decimal places).\n    uint48 public protocolFee;\n\n    /// @notice Base value used to scale fees. 1e5 = 100%\n    uint48 public constant FEE_DECIMALS = 1e5; // one percent equals 1000.\n\n    /// @notice FixedStrikeOptionToken reference implementation (deployed on creation to clone from)\n    FixedStrikeOptionToken public immutable optionTokenImplementation;\n\n    /// @notice Minimum duration an option must be eligible to exercise (in seconds)\n    uint48 public minOptionDuration;\n\n    /// @notice Fees earned by protocol, by token\n    mapping(ERC20 => uint256) public fees;\n\n    /// @notice Fixed strike option tokens (hash of parameters to address)\n    mapping(bytes32 => FixedStrikeOptionToken) public optionTokens;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /// @param guardian_    Address of the guardian for Auth\n    /// @param authority_   Address of the authority for Auth\n    constructor(address guardian_, Authority authority_) Auth(guardian_, authority_) {\n        // Explicitly setting protocol fee to zero initially\n        protocolFee = 0;\n\n        // Set minimum option duration initially to 1 day (the absolute minimum given timestamp rounding)\n        minOptionDuration = uint48(1 days);\n\n        // Deploy option token implementation that clones proxy to\n        optionTokenImplementation = new FixedStrikeOptionToken();\n    }\n\n    /* ========== CREATE OPTION TOKENS ========== */\n\n    /// @inheritdoc IFixedStrikeOptionTeller\n    function deploy(\n        ERC20 payoutToken_,\n        ERC20 quoteToken_,\n        uint48 eligible_,\n        uint48 expiry_,\n        address receiver_,\n        bool call_,\n        uint256 strikePrice_\n    ) external override nonReentrant returns (FixedStrikeOptionToken) {\n        // If eligible is zero, use current timestamp\n        if (eligible_ == 0) eligible_ = uint48(block.timestamp);\n\n        // Eligible and Expiry are rounded to the nearest day at 0000 UTC (in seconds) since\n        // option tokens are only unique to a day, not a specific timestamp.\n        eligible_ = uint48(eligible_ / 1 days) * 1 days;\n        expiry_ = uint48(expiry_ / 1 days) * 1 days;\n\n        // Revert if eligible is in the past, we do this to avoid duplicates tokens with the same parameters otherwise\n        // Truncate block.timestamp to the nearest day for comparison\n        if (eligible_ < uint48(block.timestamp / 1 days) * 1 days)\n            revert Teller_InvalidParams(2, abi.encodePacked(eligible_));\n\n        // Revert if the difference between eligible and expiry is less than min duration or eligible is after expiry\n        // Don't need to check expiry against current timestamp since eligible is already checked\n        if (eligible_ > expiry_ || expiry_ - eligible_ < minOptionDuration)\n            revert Teller_InvalidParams(3, abi.encodePacked(expiry_));\n\n        // Revert if any addresses are zero or the tokens are not contracts\n        if (address(payoutToken_) == address(0) || address(payoutToken_).code.length == 0)\n            revert Teller_InvalidParams(0, abi.encodePacked(payoutToken_));\n        if (address(quoteToken_) == address(0) || address(quoteToken_).code.length == 0)\n            revert Teller_InvalidParams(1, abi.encodePacked(quoteToken_));\n        if (receiver_ == address(0)) revert Teller_InvalidParams(4, abi.encodePacked(receiver_));\n\n        // Revert if strike price is zero or out of bounds\n        int8 priceDecimals = _getPriceDecimals(strikePrice_, quoteToken_.decimals()); // @audit determine if this external call to provided quote token is an issue\n        if (strikePrice_ == 0 || priceDecimals > int8(9) || priceDecimals < int8(-9))\n            revert Teller_InvalidParams(6, abi.encodePacked(strikePrice_));\n\n        // Create option token if one doesn't already exist\n        // Timestamps are truncated above to give canonical version of hash\n        bytes32 optionHash = _getOptionTokenHash(\n            payoutToken_,\n            quoteToken_,\n            eligible_,\n            expiry_,\n            receiver_,\n            call_,\n            strikePrice_\n        );\n\n        FixedStrikeOptionToken optionToken = optionTokens[optionHash];\n\n        // If option token doesn't exist, deploy it\n        if (address(optionToken) == address(0)) {\n            optionToken = _deploy(\n                payoutToken_,\n                quoteToken_,\n                eligible_,\n                expiry_,\n                receiver_,\n                call_,\n                strikePrice_\n            );\n\n            // Set the domain separator for the option token on creation to save gas on permit approvals\n            optionToken.updateDomainSeparator();\n\n            // Store option token against computed hash\n            optionTokens[optionHash] = optionToken;\n\n            // Emit event\n            emit OptionTokenCreated(\n                optionToken,\n                payoutToken_,\n                quoteToken_,\n                eligible_,\n                expiry_,\n                receiver_,\n                call_,\n                strikePrice_\n            );\n        }\n        return optionToken;\n    }\n\n    function _deploy(\n        ERC20 payoutToken_,\n        ERC20 quoteToken_,\n        uint48 eligible_,\n        uint48 expiry_,\n        address receiver_,\n        bool call_,\n        uint256 strikePrice_\n    ) internal returns (FixedStrikeOptionToken) {\n        // All data has been validated prior to entering this function\n        // Option token does not exist yet\n\n        // Get name and symbol for option token\n        (bytes32 name, bytes32 symbol) = _getNameAndSymbol(\n            payoutToken_,\n            quoteToken_,\n            expiry_,\n            call_,\n            strikePrice_\n        );\n\n        // Deploy option token\n        return\n            FixedStrikeOptionToken(\n                address(optionTokenImplementation).clone(\n                    abi.encodePacked(\n                        name,\n                        symbol,\n                        uint8(payoutToken_.decimals()),\n                        payoutToken_,\n                        quoteToken_,\n                        eligible_,\n                        expiry_,\n                        receiver_,\n                        call_,\n                        address(this),\n                        strikePrice_\n                    )\n                )\n            );\n    }\n\n    /// @inheritdoc IFixedStrikeOptionTeller\n    function create(\n        FixedStrikeOptionToken optionToken_,\n        uint256 amount_\n    ) external override nonReentrant {\n        // Load option parameters\n        (\n            ERC20 payoutToken,\n            ERC20 quoteToken,\n            uint48 eligible,\n            uint48 expiry,\n            address receiver,\n            bool call,\n            uint256 strikePrice\n        ) = optionToken_.getOptionParameters();\n\n        // Retrieve the internally stored option token with this configuration\n        // Reverts internally if token doesn't exist\n        FixedStrikeOptionToken optionToken = getOptionToken(\n            payoutToken,\n            quoteToken,\n            eligible,\n            expiry,\n            receiver,\n            call,\n            strikePrice\n        );\n\n        // Revert if provided token address does not match stored token address\n        if (optionToken_ != optionToken) revert Teller_UnsupportedToken(address(optionToken_));\n\n        // Revert if expiry is in the past\n        if (uint256(expiry) < block.timestamp) revert Teller_OptionExpired(expiry);\n\n        // Transfer in collateral\n        // If call option, transfer in payout tokens equivalent to the amount of option tokens being issued\n        // If put option, transfer in quote tokens equivalent to the amount of option tokens being issued * strike price\n        if (call) {\n            // Transfer payout tokens from user\n            // Check that amount received is not less than amount expected\n            // Handles edge cases like fee-on-transfer tokens (which are not supported)\n            uint256 startBalance = payoutToken.balanceOf(address(this));\n            payoutToken.safeTransferFrom(msg.sender, address(this), amount_);\n            uint256 endBalance = payoutToken.balanceOf(address(this));\n            if (endBalance < startBalance + amount_)\n                revert Teller_UnsupportedToken(address(payoutToken));\n        } else {\n            // Calculate amount of quote tokens required to mint\n            uint256 quoteAmount = amount_.mulDiv(strikePrice, 10 ** payoutToken.decimals());\n\n            // Transfer quote tokens from user\n            // Check that amount received is not less than amount expected\n            // Handles edge cases like fee-on-transfer tokens (which are not supported)\n            uint256 startBalance = quoteToken.balanceOf(address(this));\n            quoteToken.safeTransferFrom(msg.sender, address(this), quoteAmount);\n            uint256 endBalance = quoteToken.balanceOf(address(this));\n            if (endBalance < startBalance + quoteAmount)\n                revert Teller_UnsupportedToken(address(quoteToken));\n        }\n\n        // Mint new option tokens to sender\n        optionToken.mint(msg.sender, amount_);\n    }\n\n    /* ========== EXERCISE OPTION TOKENS ========== */\n\n    /// @inheritdoc IFixedStrikeOptionTeller\n    function exercise(\n        FixedStrikeOptionToken optionToken_,\n        uint256 amount_\n    ) external override nonReentrant {\n        // Load option parameters\n        (\n            ERC20 payoutToken,\n            ERC20 quoteToken,\n            uint48 eligible,\n            uint48 expiry,\n            address receiver,\n            bool call,\n            uint256 strikePrice\n        ) = optionToken_.getOptionParameters();\n\n        // Retrieve the internally stored option token with this configuration\n        // Reverts internally if token doesn't exist\n        FixedStrikeOptionToken optionToken = getOptionToken(\n            payoutToken,\n            quoteToken,\n            eligible,\n            expiry,\n            receiver,\n            call,\n            strikePrice\n        );\n\n        // Revert if token does not match stored token\n        if (optionToken_ != optionToken) revert Teller_UnsupportedToken(address(optionToken_));\n\n        // Validate that option token is eligible to be exercised\n        if (uint48(block.timestamp) < eligible) revert Teller_NotEligible(eligible);\n\n        // Validate that option token is not expired\n        if (uint48(block.timestamp) >= expiry) revert Teller_OptionExpired(expiry);\n\n        // Calculate amount of quote tokens equivalent to amount at strike price\n        uint256 quoteAmount = amount_.mulDiv(strikePrice, 10 ** payoutToken.decimals());\n\n        // If not receiver, require payment\n        if (msg.sender != receiver) {\n            // If call, transfer in quote tokens equivalent to the amount of option tokens being exercised * strike price\n            // If put, transfer in payout tokens equivalent to the amount of option tokens being exercised\n            if (call) {\n                // Calculate protocol fee\n                uint256 fee = (quoteAmount * protocolFee) / FEE_DECIMALS;\n                fees[quoteToken] += fee;\n\n                // Transfer proceeds from user\n                // Check balances before and after transfer to ensure that the correct amount was transferred\n                // @audit this does enable potential malicious option tokens that can't be exercised\n                // However, we view it as a \"buyer beware\" situation that can handled on the front-end\n                uint256 startBalance = quoteToken.balanceOf(address(this));\n                quoteToken.safeTransferFrom(msg.sender, address(this), quoteAmount);\n                uint256 endBalance = quoteToken.balanceOf(address(this));\n                if (endBalance < startBalance + quoteAmount)\n                    revert Teller_UnsupportedToken(address(quoteToken));\n\n                // Transfer proceeds minus fee to receiver\n                quoteToken.safeTransfer(receiver, quoteAmount - fee);\n            } else {\n                // Calculate protocol fee (in payout tokens)\n                uint256 fee = (amount_ * protocolFee) / FEE_DECIMALS;\n                fees[payoutToken] += fee;\n\n                // Transfer proceeds from user\n                // Check balances before and after transfer to ensure that the correct amount was transferred\n                // @audit this does enable potential malicious option tokens that can't be exercised\n                // However, we view it as a \"buyer beware\" situation that can handled on the front-end\n                uint256 startBalance = payoutToken.balanceOf(address(this));\n                payoutToken.safeTransferFrom(msg.sender, address(this), amount_);\n                uint256 endBalance = payoutToken.balanceOf(address(this));\n                if (endBalance < startBalance + amount_)\n                    revert Teller_UnsupportedToken(address(payoutToken));\n\n                // Transfer proceeds minus fee to receiver\n                payoutToken.safeTransfer(receiver, amount_ - fee);\n            }\n        }\n\n        // Burn option tokens\n        optionToken.burn(msg.sender, amount_);\n\n        if (call) {\n            // Transfer payout tokens to user\n            payoutToken.safeTransfer(msg.sender, amount_);\n        } else {\n            // Transfer quote tokens to user\n            quoteToken.safeTransfer(msg.sender, quoteAmount);\n        }\n    }\n\n    /// @inheritdoc IFixedStrikeOptionTeller\n    function reclaim(FixedStrikeOptionToken optionToken_) external override nonReentrant {\n        // Load option parameters\n        (\n            ERC20 payoutToken,\n            ERC20 quoteToken,\n            uint48 eligible,\n            uint48 expiry,\n            address receiver,\n            bool call,\n            uint256 strikePrice\n        ) = optionToken_.getOptionParameters();\n\n        // Retrieve the internally stored option token with this configuration\n        // Reverts internally if token doesn't exist\n        FixedStrikeOptionToken optionToken = getOptionToken(\n            payoutToken,\n            quoteToken,\n            eligible,\n            expiry,\n            receiver,\n            call,\n            strikePrice\n        );\n\n        // Revert if token does not match stored token\n        if (optionToken_ != optionToken) revert Teller_UnsupportedToken(address(optionToken_));\n\n        // Revert if not expired\n        if (uint48(block.timestamp) < expiry) revert Teller_NotExpired(expiry);\n\n        // Revert if caller is not receiver\n        if (msg.sender != receiver) revert Teller_NotAuthorized();\n\n        // Transfer remaining collateral to receiver\n        uint256 amount = optionToken.totalSupply();\n        if (call) {\n            payoutToken.safeTransfer(receiver, amount);\n        } else {\n            // Calculate amount of quote tokens equivalent to amount at strike price\n            uint256 quoteAmount = amount.mulDiv(strikePrice, 10 ** payoutToken.decimals());\n            quoteToken.safeTransfer(receiver, quoteAmount);\n        }\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /// @inheritdoc IFixedStrikeOptionTeller\n    function exerciseCost(\n        FixedStrikeOptionToken optionToken_,\n        uint256 amount_\n    ) external view returns (ERC20, uint256) {\n        // Load option parameters\n        (\n            ERC20 payoutToken,\n            ERC20 quoteToken,\n            uint48 eligible,\n            uint48 expiry,\n            address receiver,\n            bool call,\n            uint256 strikePrice\n        ) = optionToken_.getOptionParameters();\n\n        // Retrieve the internally stored option token with this configuration\n        // Reverts internally if token doesn't exist\n        FixedStrikeOptionToken optionToken = getOptionToken(\n            payoutToken,\n            quoteToken,\n            eligible,\n            expiry,\n            receiver,\n            call,\n            strikePrice\n        );\n\n        // Revert if token does not match stored token\n        if (optionToken_ != optionToken) revert Teller_UnsupportedToken(address(optionToken_));\n\n        // If option is a call, calculate quote tokens required to exercise\n        // If option is a put, exercise cost is the same as the option token amount in payout tokens\n        if (call) {\n            return (quoteToken, amount_.mulDiv(strikePrice, 10 ** payoutToken.decimals()));\n        } else {\n            return (payoutToken, amount_);\n        }\n    }\n\n    /// @inheritdoc IFixedStrikeOptionTeller\n    function getOptionToken(\n        ERC20 payoutToken_,\n        ERC20 quoteToken_,\n        uint48 eligible_,\n        uint48 expiry_,\n        address receiver_,\n        bool call_,\n        uint256 strikePrice_\n    ) public view returns (FixedStrikeOptionToken) {\n        // Eligible and Expiry are rounded to the nearest day at 0000 UTC (in seconds) since\n        // option tokens are only unique to a day, not a specific timestamp.\n        uint48 eligible = uint48(eligible_ / 1 days) * 1 days;\n        uint48 expiry = uint48(expiry_ / 1 days) * 1 days;\n\n        // Calculate a hash from the normalized inputs\n        bytes32 optionHash = _getOptionTokenHash(\n            payoutToken_,\n            quoteToken_,\n            eligible,\n            expiry,\n            receiver_,\n            call_,\n            strikePrice_\n        );\n\n        FixedStrikeOptionToken optionToken = optionTokens[optionHash];\n\n        // Revert if token does not exist\n        if (address(optionToken) == address(0)) revert Teller_TokenDoesNotExist(optionHash);\n\n        return optionToken;\n    }\n\n    /// @inheritdoc IFixedStrikeOptionTeller\n    function getOptionTokenHash(\n        ERC20 payoutToken_,\n        ERC20 quoteToken_,\n        uint48 eligible_,\n        uint48 expiry_,\n        address receiver_,\n        bool call_,\n        uint256 strikePrice_\n    ) external pure returns (bytes32) {\n        // Eligible and Expiry are rounded to the nearest day at 0000 UTC (in seconds) since\n        // option tokens are only unique to a day, not a specific timestamp.\n        uint48 eligible = uint48(eligible_ / 1 days) * 1 days;\n        uint48 expiry = uint48(expiry_ / 1 days) * 1 days;\n\n        return\n            _getOptionTokenHash(\n                payoutToken_,\n                quoteToken_,\n                eligible,\n                expiry,\n                receiver_,\n                call_,\n                strikePrice_\n            );\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function _getOptionTokenHash(\n        ERC20 payoutToken_,\n        ERC20 quoteToken_,\n        uint48 eligible_,\n        uint48 expiry_,\n        address receiver_,\n        bool call_,\n        uint256 strikePrice_\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    payoutToken_,\n                    quoteToken_,\n                    eligible_,\n                    expiry_,\n                    receiver_,\n                    call_,\n                    strikePrice_\n                )\n            );\n    }\n\n    /// @notice Derive name and symbol of option token\n    function _getNameAndSymbol(\n        ERC20 payoutToken_,\n        ERC20 quoteToken_,\n        uint256 expiry_,\n        bool call_,\n        uint256 strikePrice_\n    ) internal view returns (bytes32, bytes32) {\n        // Examples\n        // WETH call option expiring on 2100-01-01 with strike price of 10_010.50 DAI would be formatted as:\n        // Name: \"WETH/DAI C 1.001e4 2100-01-01\"\n        // Symbol: \"WETH/DAI-C-21000101\"\n        //\n        // WETH put option expiring on 2100-01-01 with strike price of 10.546 DAI would be formatted as:\n        // Name: \"WETH/DAI P 1.054e1 2100-01-01\"\n        // Symbol: \"WETH/DAI-P-21000101\"\n\n        // Get the date format from the expiry timestamp.\n        // Convert a number of days into a human-readable date, courtesy of BokkyPooBah.\n        // Source: https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary/blob/master/contracts/BokkyPooBahsDateTimeLibrary.sol\n        string memory yearStr;\n        string memory monthStr;\n        string memory dayStr;\n        {\n            int256 __days = int256(expiry_ / 1 days);\n\n            int256 num1 = __days + 68569 + 2440588; // 2440588 = OFFSET19700101\n            int256 num2 = (4 * num1) / 146097;\n            num1 = num1 - (146097 * num2 + 3) / 4;\n            int256 _year = (4000 * (num1 + 1)) / 1461001;\n            num1 = num1 - (1461 * _year) / 4 + 31;\n            int256 _month = (80 * num1) / 2447;\n            int256 _day = num1 - (2447 * _month) / 80;\n            num1 = _month / 11;\n            _month = _month + 2 - 12 * num1;\n            _year = 100 * (num2 - 49) + _year + num1;\n\n            yearStr = _uint2str(uint256(_year) % 10000);\n            monthStr = uint256(_month) < 10\n                ? string(abi.encodePacked(\"0\", _uint2str(uint256(_month))))\n                : _uint2str(uint256(_month));\n            dayStr = uint256(_day) < 10\n                ? string(abi.encodePacked(\"0\", _uint2str(uint256(_day))))\n                : _uint2str(uint256(_day));\n        }\n\n        // Format token symbols\n        // Symbols longer than 5 characters are truncated, min length would be 1 if tokens have no symbols, max length is 11\n        bytes memory tokenSymbols;\n        {\n            bytes memory payoutSymbol = bytes(payoutToken_.symbol());\n            if (payoutSymbol.length > 5) payoutSymbol = abi.encodePacked(bytes5(payoutSymbol));\n            bytes memory quoteSymbol = bytes(quoteToken_.symbol());\n            if (quoteSymbol.length > 5) quoteSymbol = abi.encodePacked(bytes5(quoteSymbol));\n\n            tokenSymbols = abi.encodePacked(payoutSymbol, \"/\", quoteSymbol);\n        }\n\n        // Format option type\n        bytes1 callPut = call_ ? bytes1(\"C\") : bytes1(\"P\");\n\n        // Format strike price\n        // Strike price is formatted as scientific notation to 3 significant figures\n        // Will either be 7 or 8 bytes, e.g. 1.056e1 (7) or 9.745e-2 (8)\n        bytes memory strike = _getScientificNotation(strikePrice_, quoteToken_.decimals());\n\n        // Construct name/symbol strings.\n\n        // Name is formatted as \"payoutSymbol/quoteSymbol callPut strikePrice expiry\" with the following constraints: // Name and symbol can each be at most 32 bytes since it is stored as a bytes32\n        // quoteSymbol - 5 bytes\n        // \" \" - 1 byte\n        // callPut - 1 byte\n        // \" \" - 1 byte\n        // strikePrice - 7 or 8 bytes, scientific notation to 3 significant figures, e.g. 1.056e1 (7) or 9.745e-2 (8)\n        // \" \" - 1 byte\n        // expiry - 8 bytes, YYYYMMDD\n        // Total is 30 or 31 bytes\n\n        // Symbol is formatted as \"payoutSymbol/quoteSymbol-callPut-expiry\" with the following constraints:\n        // payoutSymbol - 5 bytes\n        // \"/\" - 1 byte\n        // quoteSymbol - 5 bytes\n        // \"-\" - 1 byte\n        // callPut - 1 byte\n        // \"-\" - 1 byte\n        // expiry - 8 bytes, YYYYMMDD\n        // Total is 22 bytes\n\n        bytes32 name = bytes32(\n            abi.encodePacked(\n                tokenSymbols,\n                \" \",\n                callPut,\n                \" \",\n                strike,\n                \" \",\n                yearStr,\n                monthStr,\n                dayStr\n            )\n        );\n        bytes32 symbol = bytes32(\n            abi.encodePacked(tokenSymbols, \"-\", callPut, \"-\", yearStr, monthStr, dayStr)\n        );\n\n        return (name, symbol);\n    }\n\n    /// @notice Helper function to calculate number of price decimals in the provided price\n    /// @param price_   The price to calculate the number of decimals for\n    /// @return         The number of decimals\n    function _getPriceDecimals(uint256 price_, uint8 tokenDecimals_) internal pure returns (int8) {\n        int8 decimals;\n        while (price_ >= 10) {\n            price_ = price_ / 10;\n            decimals++;\n        }\n\n        // Subtract the stated decimals from the calculated decimals to get the relative price decimals.\n        // Required to do it this way vs. normalizing at the beginning since price decimals can be negative.\n        return decimals - int8(tokenDecimals_);\n    }\n\n    /// @notice Helper function to format a uint256 into scientific notation to 3 significant figures\n    /// @param price_           The price to format\n    /// @param tokenDecimals_   The number of decimals in the token\n    function _getScientificNotation(\n        uint256 price_,\n        uint8 tokenDecimals_\n    ) internal pure returns (bytes memory) {\n        // Get a bytes representation of the price in scientific notation to 3 significant figures.\n        // 1. Get the number of price decimals\n        int8 priceDecimals = _getPriceDecimals(price_, tokenDecimals_);\n\n        // If priceDecimals are >= 10 or <= -10, then it will be too large to fit in the byte limit\n        // However, this is already checked when an option token is deployed\n\n        // 2. Get a string of the price decimals and exponent figure\n        uint256 decimals = priceDecimals < 0\n            ? uint256(uint8(-priceDecimals))\n            : uint256(uint8(priceDecimals));\n        bytes memory decStr = bytes.concat(\"e\", bytes(_uint2str(decimals)));\n\n        // 3. Get a string of the leading digits with decimal point\n        uint8 priceMagnitude = uint8(int8(tokenDecimals_) + priceDecimals);\n        uint256 digits = price_ / (10 ** (priceMagnitude < 3 ? 0 : priceMagnitude - 3));\n        bytes memory digitStr = bytes(_uint2str(digits));\n        uint256 len = bytes(digitStr).length;\n        bytes memory leadingStr = bytes.concat(digitStr[0], \".\");\n        for (uint256 i = 1; i < len; ++i) {\n            leadingStr = bytes.concat(leadingStr, digitStr[i]);\n        }\n\n        // 4. Combine and return\n        // The bytes string should be at most 8 bytes (e.g. 1.056e-1)\n        return bytes.concat(leadingStr, decStr);\n    }\n\n    // Some fancy math to convert a uint into a string, courtesy of Provable Things.\n    // Updated to work with solc 0.8.0.\n    // https://github.com/provable-things/ethereum-api/blob/master/provableAPI_0.6.sol\n    function _uint2str(uint256 _i) internal pure returns (string memory) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint256 j = _i;\n        uint256 len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint256 k = len;\n        while (_i != 0) {\n            k = k - 1;\n            uint8 temp = (48 + uint8(_i - (_i / 10) * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n\n    /* ========== ADMIN & FEES ========== */\n\n    /// @inheritdoc IOptionTeller\n    function setMinOptionDuration(uint48 duration_) external override requiresAuth {\n        // Must be a minimum of 1 day due to timestamp rounding\n        if (duration_ < uint48(1 days)) revert Teller_InvalidParams(0, abi.encodePacked(duration_));\n        minOptionDuration = duration_;\n    }\n\n    /// @inheritdoc IOptionTeller\n    function setProtocolFee(uint48 fee_) external override requiresAuth {\n        if (fee_ > 5e3) revert Teller_InvalidParams(0, abi.encodePacked(fee_)); // 5% max\n        protocolFee = fee_;\n    }\n\n    /// @inheritdoc IOptionTeller\n    function claimFees(\n        ERC20[] memory tokens_,\n        address to_\n    ) external override nonReentrant requiresAuth {\n        uint256 len = tokens_.length;\n        for (uint256 i; i < len; ++i) {\n            ERC20 token = tokens_[i];\n            uint256 send = fees[token];\n\n            if (send != 0) {\n                fees[token] = 0;\n                token.safeTransfer(to_, send);\n            }\n        }\n    }\n}"
    },
    {
      "filename": "options/src/fixed-strike/FixedStrikeOptionTeller.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {ClonesWithImmutableArgs} from \"src/lib/clones/ClonesWithImmutableArgs.sol\";\n\nimport {IFixedStrikeOptionTeller, IOptionTeller} from \"src/interfaces/IFixedStrikeOptionTeller.sol\";\nimport {FixedStrikeOptionToken} from \"src/fixed-strike/FixedStrikeOptionToken.sol\";\n\nimport {TransferHelper} from \"src/lib/TransferHelper.sol\";\nimport {FullMath} from \"src/lib/FullMath.sol\";\n\n/// @title Fixed Strike Option Teller\n/// @notice Fixed Strike Option Teller Contract\n/// @dev Option Teller contracts handle the deployment, creation, and exercise of option tokens.\n///      Option Tokens are ERC20 tokens that represent the right to buy (call) or sell (put) a fixed\n///      amount of an asset (payout token) for an amount of another asset (quote token) between two\n///      timestamps (eli"
    }
  ]
}