{
  "Title": "[G-12]   String literals passed to abi.encode()/abi.encodePacked() should not be split by commas",
  "Content": "String literals can be split into multiple parts and still be considered as a single string literal. Adding commas between each chunk makes it no longer a single string, and instead multiple strings. EACH new comma costs 21 gas due to stack operations and separate MSTOREs.\n\n\n```solidity\nfile:   src/libraries/LibWellConstructor.sol\n\n81      initFunctionCall = abi.encodeWithSignature(\"init(string,string)\", name, symbol);\n\n```\nhttps://github.com/code-423n4/2023-07-basin/blob/main/src/libraries/LibWellConstructor.sol#L81\n\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-07-basin",
  "Code": [
    {
      "filename": "src/libraries/LibWellConstructor.sol",
      "content": "// SPDX-License-Identifier: MIT\n// forgefmt: disable-start\n\npragma solidity ^0.8.17;\n\nimport {LibContractInfo} from \"src/libraries/LibContractInfo.sol\";\nimport {Call, IERC20} from \"src/Well.sol\";\n\nlibrary LibWellConstructor {\n    /**\n     * @notice Encode the Well's immutable data and init data.\n     */\n    function encodeWellDeploymentData(\n        address _aquifer,\n        IERC20[] memory _tokens,\n        Call memory _wellFunction,\n        Call[] memory _pumps\n    ) internal view returns (bytes memory immutableData, bytes memory initData) {\n        immutableData = encodeWellImmutableData(_aquifer, _tokens, _wellFunction, _pumps);\n        initData = encodeWellInitFunctionCall(_tokens, _wellFunction);\n    }\n\n    /**\n     * @notice Encode the Well's immutable data.\n     * @param _aquifer The address of the Aquifer which will deploy this Well.\n     * @param _tokens A list of ERC20 tokens supported by the Well.\n     * @param _wellFunction A single Call struct representing a call to the Well Function.\n     * @param _pumps An array of Call structs representings calls to Pumps.\n     * @dev `immutableData` is tightly packed, however since `_tokens` itself is\n     * an array, each address in the array will be padded up to 32 bytes.\n     *\n     * Arbitrary-length bytes are applied to the end of the encoded bytes array\n     * for easy reading of statically-sized data.\n     * \n     */\n    function encodeWellImmutableData(\n        address _aquifer,\n        IERC20[] memory _tokens,\n        Call memory _wellFunction,\n        Call[] memory _pumps\n    ) internal pure returns (bytes memory immutableData) {\n        bytes memory packedPumps;\n        for (uint256 i; i < _pumps.length; ++i) {\n            packedPumps = abi.encodePacked(\n                packedPumps,            // previously packed pumps\n                _pumps[i].target,       // pump address\n                _pumps[i].data.length,  // pump data length\n                _pumps[i].data          // pump data (bytes)\n            );\n        }\n        \n        immutableData = abi.encodePacked(\n            _aquifer,                   // aquifer address\n            _tokens.length,             // number of tokens\n            _wellFunction.target,       // well function address\n            _wellFunction.data.length,  // well function data length\n            _pumps.length,              // number of pumps\n            _tokens,                    // tokens array\n            _wellFunction.data,         // well function data (bytes)\n            packedPumps                 // packed pumps (bytes)\n        );\n    }\n\n    /**\n     * @notice Encode a call to the {Well.init} function to set a standardized ERC20 name and symbol.\n     */\n    function encodeWellInitFunctionCall(\n        IERC20[] memory _tokens,\n        Call memory _wellFunction\n    ) public view returns (bytes memory initFunctionCall) {\n        string memory name = LibContractInfo.getSymbol(address(_tokens[0]));\n        string memory symbol = name;\n        for (uint256 i = 1; i < _tokens.length; ++i) {\n            name = string.concat(name, \":\", LibContractInfo.getSymbol(address(_tokens[i])));\n            symbol = string.concat(symbol, LibContractInfo.getSymbol(address(_tokens[i])));\n        }\n        name = string.concat(name, \" \", LibContractInfo.getName(_wellFunction.target), \" Well\");\n        symbol = string.concat(symbol, LibContractInfo.getSymbol(_wellFunction.target), \"w\");\n\n        // See {Well.init}.\n        initFunctionCall = abi.encodeWithSignature(\"init(string,string)\", name, symbol);\n    }\n\n    /**\n     * @notice Encode a Call struct representing an arbitrary call to `target` with additional data `data`.\n     */\n    function encodeCall(address target, bytes memory data) public pure returns (Call memory) {\n        return Call(target, data);\n    }\n}"
    }
  ]
}