{
  "Title": "[L15] Unused code",
  "Content": "Throughout the codebase, there are cases of unused code. For example:\n\n\n* None of the inlined `DSMath` functions in [VaultLifecycle](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/VaultLifecycle.sol#L521-L538) are used.\n* The [`InitiateGnosisAuction`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/RibbonThetaVault.sol#L62) event is not used in `RibbonThetaVault`.\n* The [`PlaceAuctionBid`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/RibbonDeltaVault.sol#L52) event is not used in `RibbonDeltaVault`.\n\n\nTo improve the readability of the codebase and limit the potential attack surface, consider always removing unnecessary lines of code.\n\n\n**Update**: *Fixed in [commit `e1ec5868835ee2ed718668695157bea11f209553` of PR#90](https://github.com/ribbon-finance/ribbon-v2/pull/90/commits/e1ec5868835ee2ed718668695157bea11f209553). The Ribbon team explained that, as the `InitiateGnosisAuction` and `PlaceAuctionBid` events are emitted from libraries, they would not be part of the vaultsâ€™ ABIs, so they included these events in the vault contracts in order to facilitate their detection and decoding.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/libraries/VaultLifecycle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.3;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {Vault} from \"./Vault.sol\";\nimport {\n    IStrikeSelection,\n    IOptionsPremiumPricer\n} from \"../interfaces/IRibbon.sol\";\nimport {GnosisAuction} from \"./GnosisAuction.sol\";\nimport {\n    IOtokenFactory,\n    IOtoken,\n    IController,\n    GammaTypes\n} from \"../interfaces/GammaInterface.sol\";\nimport {IERC20Detailed} from \"../interfaces/IERC20Detailed.sol\";\nimport {\n    SupportsNonCompliantERC20\n} from \"../libraries/SupportsNonCompliantERC20.sol\";\n\nlibrary VaultLifecycle {\n    using SafeMath for uint256;\n    using SupportsNonCompliantERC20 for IERC20;\n\n    struct CloseParams {\n        address OTOKEN_FACTORY;\n        address USDC;\n        address currentOption;\n        uint256 delay;\n        uint16 lastStrikeOverride;\n        uint256 overriddenStrikePrice;\n    }\n\n    function commitAndClose(\n        address strikeSelection,\n        address optionsPremiumPricer,\n        uint256 premiumDiscount,\n        CloseParams calldata closeParams,\n        Vault.VaultParams storage vaultParams,\n        Vault.VaultState storage vaultState\n    )\n        external\n        returns (\n            address otokenAddress,\n            uint256 premium,\n            uint256 strikePrice,\n            uint256 delta\n        )\n    {\n        uint256 expiry;\n\n        // uninitialized state\n        if (closeParams.currentOption == address(0)) {\n            expiry = getNextFriday(block.timestamp);\n        } else {\n            expiry = getNextFriday(\n                IOtoken(closeParams.currentOption).expiryTimestamp()\n            );\n        }\n\n        IStrikeSelection selection = IStrikeSelection(strikeSelection);\n\n        bool isPut = vaultParams.isPut;\n        address underlying = vaultParams.underlying;\n        address asset = vaultParams.asset;\n\n        (strikePrice, delta) = closeParams.lastStrikeOverride ==\n            vaultState.round\n            ? (closeParams.overriddenStrikePrice, selection.delta())\n            : selection.getStrikePrice(expiry, isPut);\n\n        require(strikePrice != 0, \"!strikePrice\");\n\n        otokenAddress = getOrDeployOtoken(\n            closeParams,\n            underlying,\n            asset,\n            strikePrice,\n            expiry,\n            isPut\n        );\n\n        premium = GnosisAuction.getOTokenPremium(\n            otokenAddress,\n            optionsPremiumPricer,\n            premiumDiscount\n        );\n\n        require(premium > 0, \"!premium\");\n    }\n\n    function verifyOtoken(address otokenAddress, uint256 delay) private view {\n        require(otokenAddress != address(0), \"!otokenAddress\");\n\n        IOtoken otoken = IOtoken(otokenAddress);\n        uint256 readyAt = block.timestamp.add(delay);\n        require(otoken.expiryTimestamp() >= readyAt, \"Expiry before delay\");\n    }\n\n    function rollover(\n        uint256 currentSupply,\n        address asset,\n        uint8 decimals,\n        uint256 initialSharePrice,\n        uint256 pendingAmount,\n        uint128 queuedWithdrawShares\n    )\n        external\n        view\n        returns (\n            uint256 newLockedAmount,\n            uint256 newPricePerShare,\n            uint256 mintShares\n        )\n    {\n        uint256 currentBalance = IERC20(asset).balanceOf(address(this));\n        uint256 roundStartBalance = currentBalance.sub(pendingAmount);\n\n        uint256 singleShare = 10**uint256(decimals);\n\n        newPricePerShare = getPPS(\n            currentSupply,\n            roundStartBalance,\n            singleShare,\n            initialSharePrice\n        );\n\n        // After closing the short, if the options expire in-the-money\n        // vault pricePerShare would go down because vault's asset balance decreased.\n        // This ensures that the newly-minted shares do not take on the loss.\n        uint256 _mintShares =\n            pendingAmount.mul(singleShare).div(newPricePerShare);\n\n        uint256 newSupply = currentSupply.add(_mintShares);\n\n        uint256 queuedWithdrawAmount =\n            newSupply > 0\n                ? uint256(queuedWithdrawShares).mul(currentBalance).div(\n                    newSupply\n                )\n                : 0;\n\n        return (\n            currentBalance.sub(queuedWithdrawAmount),\n            newPricePerShare,\n            _mintShares\n        );\n    }\n\n    // https://github.com/opynfinance/GammaProtocol/blob/master/contracts/Otoken.sol#L70\n    uint256 private constant OTOKEN_DECIMALS = 10**8;\n\n    function createShort(\n        address gammaController,\n        address marginPool,\n        address oTokenAddress,\n        uint256 depositAmount\n    ) external returns (uint256) {\n        IController controller = IController(gammaController);\n        uint256 newVaultID =\n            (controller.getAccountVaultCounter(address(this))).add(1);\n\n        IOtoken oToken = IOtoken(oTokenAddress);\n        address collateralAsset = oToken.collateralAsset();\n\n        uint256 collateralDecimals =\n            uint256(IERC20Detailed(collateralAsset).decimals());\n        uint256 mintAmount;\n\n        if (oToken.isPut()) {\n            // For minting puts, there will be instances where the full depositAmount will not be used for minting.\n            // This is because of an issue with precision.\n            //\n            // For ETH put options, we are calculating the mintAmount (10**8 decimals) using\n            // the depositAmount (10**18 decimals), which will result in truncation of decimals when scaling down.\n            // As a result, there will be tiny amounts of dust left behind in the Opyn vault when minting put otokens.\n            //\n            // For simplicity's sake, we do not refund the dust back to the address(this) on minting otokens.\n            // We retain the dust in the vault so the calling contract can withdraw the\n            // actual locked amount + dust at settlement.\n            //\n            // To test this behavior, we can console.log\n            // MarginCalculatorInterface(0x7A48d10f372b3D7c60f6c9770B91398e4ccfd3C7).getExcessCollateral(vault)\n            // to see how much dust (or excess collateral) is left behind.\n            mintAmount = depositAmount\n                .mul(OTOKEN_DECIMALS)\n                .mul(DSWAD) // we use 10**18 to give extra precision\n                .div(\n                oToken.strikePrice().mul(10**(18 - (8 - collateralDecimals)))\n            );\n        } else {\n            mintAmount = depositAmount;\n            uint256 scaleBy = 10**(collateralDecimals.sub(8)); // oTokens have 8 decimals\n\n            if (mintAmount > scaleBy && collateralDecimals > 8) {\n                mintAmount = depositAmount.div(scaleBy); // scale down from 10**18 to 10**8\n            }\n        }\n\n        // double approve to fix non-compliant ERC20s\n        IERC20 collateralToken = IERC20(collateralAsset);\n        collateralToken.safeApprove(marginPool, depositAmount);\n\n        IController.ActionArgs[] memory actions =\n            new IController.ActionArgs[](3);\n\n        actions[0] = IController.ActionArgs(\n            IController.ActionType.OpenVault,\n            address(this), // owner\n            address(this), // receiver -  we need this contract to receive so we can swap at the end\n            address(0), // asset, otoken\n            newVaultID, // vaultId\n            0, // amount\n            0, //index\n            \"\" //data\n        );\n\n        actions[1] = IController.ActionArgs(\n            IController.ActionType.DepositCollateral,\n            address(this), // owner\n            address(this), // address to transfer from\n            collateralAsset, // deposited asset\n            newVaultID, // vaultId\n            depositAmount, // amount\n            0, //index\n            \"\" //data\n        );\n\n        actions[2] = IController.ActionArgs(\n            IController.ActionType.MintShortOption,\n            address(this), // owner\n            address(this), // address to transfer to\n            oTokenAddress, // deposited asset\n            newVaultID, // vaultId\n            mintAmount, // amount\n            0, //index\n            \"\" //data\n        );\n\n        controller.operate(actions);\n\n        return mintAmount;\n    }\n\n    /**\n     * @notice Close the existing short otoken position. Currently this implementation is simple.\n     * It closes the most recent vault opened by the contract. This assumes that the contract will\n     * only have a single vault open at any given time. Since calling `closeShort` deletes vaults,\n     * this assumption should hold.\n     */\n    function settleShort(address gammaController) external returns (uint256) {\n        IController controller = IController(gammaController);\n\n        // gets the currently active vault ID\n        uint256 vaultID = controller.getAccountVaultCounter(address(this));\n\n        GammaTypes.Vault memory vault =\n            controller.getVault(address(this), vaultID);\n\n        require(vault.shortOtokens.length > 0, \"No short\");\n\n        IERC20 collateralToken = IERC20(vault.collateralAssets[0]);\n\n        uint256 startCollateralBalance =\n            collateralToken.balanceOf(address(this));\n\n        // If it is after expiry, we need to settle the short position using the normal way\n        // Delete the vault and withdraw all remaining collateral from the vault\n        IController.ActionArgs[] memory actions =\n            new IController.ActionArgs[](1);\n\n        actions[0] = IController.ActionArgs(\n            IController.ActionType.SettleVault,\n            address(this), // owner\n            address(this), // address to transfer to\n            address(0), // not used\n            vaultID, // vaultId\n            0, // not used\n            0, // not used\n            \"\" // not used\n        );\n\n        controller.operate(actions);\n\n        uint256 endCollateralBalance = collateralToken.balanceOf(address(this));\n\n        return endCollateralBalance.sub(startCollateralBalance);\n    }\n\n    /**\n     * @notice Exercises the ITM option using existing long otoken position. Currently this implementation is simple.\n     * It calls the `Redeem` action to claim the payout.\n     */\n    function settleLong(\n        address gammaController,\n        address oldOption,\n        address asset\n    ) external returns (uint256) {\n        IController controller = IController(gammaController);\n\n        uint256 oldOptionBalance = IERC20(oldOption).balanceOf(address(this));\n\n        if (controller.getPayout(oldOption, oldOptionBalance) == 0) {\n            return 0;\n        }\n\n        uint256 startAssetBalance = IERC20(asset).balanceOf(address(this));\n\n        // If it is after expiry, we need to redeem the profits\n        IController.ActionArgs[] memory actions =\n            new IController.ActionArgs[](1);\n\n        actions[0] = IController.ActionArgs(\n            IController.ActionType.Redeem,\n            address(0), // not used\n            address(this), // address to send profits to\n            oldOption, // address of otoken\n            0, // not used\n            oldOptionBalance, // otoken balance\n            0, // not used\n            \"\" // not used\n        );\n\n        controller.operate(actions);\n\n        uint256 endAssetBalance = IERC20(asset).balanceOf(address(this));\n\n        return endAssetBalance.sub(startAssetBalance);\n    }\n\n    /**\n     * @notice Burn the remaining oTokens left over from auction. Currently this implementation is simple.\n     * It burns oTokens from the most recent vault opened by the contract. This assumes that the contract will\n     * only have a single vault open at any given time.\n     */\n    function burnOtokens(address gammaController, uint256 amount)\n        external\n        returns (uint256)\n    {\n        IController controller = IController(gammaController);\n\n        // gets the currently active vault ID\n        uint256 vaultID = controller.getAccountVaultCounter(address(this));\n\n        GammaTypes.Vault memory vault =\n            controller.getVault(address(this), vaultID);\n\n        require(vault.shortOtokens.length > 0, \"No short\");\n\n        IERC20 collateralToken = IERC20(vault.collateralAssets[0]);\n\n        uint256 startCollateralBalance =\n            collateralToken.balanceOf(address(this));\n\n        // Burning all otokens that are left from the gnosis auction,\n        // then withdrawing the corresponding collateral amount from the vault\n        IController.ActionArgs[] memory actions =\n            new IController.ActionArgs[](2);\n\n        actions[0] = IController.ActionArgs(\n            IController.ActionType.BurnShortOption,\n            address(this), // owner\n            address(this), // address to transfer to\n            address(vault.shortOtokens[0]), // otoken address\n            vaultID, // vaultId\n            amount, // amount\n            0, //index\n            \"\" //data\n        );\n\n        actions[1] = IController.ActionArgs(\n            IController.ActionType.WithdrawCollateral,\n            address(this), // owner\n            address(this), // address to transfer to\n            address(collateralToken), // withdrawn asset\n            vaultID, // vaultId\n            vault.collateralAmounts[0].mul(amount).div(vault.shortAmounts[0]), // amount\n            0, //index\n            \"\" //data\n        );\n\n        controller.operate(actions);\n\n        uint256 endCollateralBalance = collateralToken.balanceOf(address(this));\n\n        return endCollateralBalance.sub(startCollateralBalance);\n    }\n\n    function getOrDeployOtoken(\n        CloseParams calldata closeParams,\n        address underlying,\n        address collateralAsset,\n        uint256 strikePrice,\n        uint256 expiry,\n        bool isPut\n    ) internal returns (address) {\n        IOtokenFactory factory = IOtokenFactory(closeParams.OTOKEN_FACTORY);\n\n        address otokenFromFactory =\n            factory.getOtoken(\n                underlying,\n                closeParams.USDC,\n                collateralAsset,\n                strikePrice,\n                expiry,\n                isPut\n            );\n\n        if (otokenFromFactory != address(0)) {\n            return otokenFromFactory;\n        }\n\n        address otoken =\n            factory.createOtoken(\n                underlying,\n                closeParams.USDC,\n                collateralAsset,\n                strikePrice,\n                expiry,\n                isPut\n            );\n\n        verifyOtoken(otoken, closeParams.delay);\n\n        return otoken;\n    }\n\n    function startAuction(GnosisAuction.AuctionDetails calldata auctionDetails)\n        external\n        returns (uint256)\n    {\n        return GnosisAuction.startAuction(auctionDetails);\n    }\n\n    function placeBid(GnosisAuction.BidDetails calldata bidDetails)\n        external\n        returns (\n            uint256,\n            uint256,\n            uint64\n        )\n    {\n        return GnosisAuction.placeBid(bidDetails);\n    }\n\n    function claimAuctionOtokens(\n        Vault.AuctionSellOrder calldata auctionSellOrder,\n        address gnosisEasyAuction,\n        address counterpartyThetaVault\n    ) external {\n        GnosisAuction.claimAuctionOtokens(\n            auctionSellOrder,\n            gnosisEasyAuction,\n            counterpartyThetaVault\n        );\n    }\n\n    function verifyConstructorParams(\n        address owner,\n        address feeRecipient,\n        uint256 performanceFee,\n        string calldata tokenName,\n        string calldata tokenSymbol,\n        Vault.VaultParams calldata _vaultParams\n    ) external pure {\n        require(owner != address(0), \"!owner\");\n        require(feeRecipient != address(0), \"!feeRecipient\");\n        require(performanceFee > 0, \"!performanceFee\");\n        require(performanceFee < 10**8, \"performanceFee >= 100%\");\n        require(bytes(tokenName).length > 0, \"!tokenName\");\n        require(bytes(tokenSymbol).length > 0, \"!tokenSymbol\");\n\n        require(_vaultParams.asset != address(0), \"!asset\");\n        require(_vaultParams.underlying != address(0), \"!underlying\");\n        require(_vaultParams.minimumSupply > 0, \"!minimumSupply\");\n        require(_vaultParams.cap > 0, \"!cap\");\n        require(_vaultParams.initialSharePrice > 0, \"!initialSharePrice\");\n    }\n\n    /**\n     * @notice Gets the next options expiry timestamp\n     * @param currentExpiry is the expiry timestamp of the current option\n     * Reference: https://codereview.stackexchange.com/a/33532\n     * Examples:\n     * getNextFriday(week 1 thursday) -> week 1 friday\n     * getNextFriday(week 1 friday) -> week 2 friday\n     * getNextFriday(week 1 saturday) -> week 2 friday\n     */\n    function getNextFriday(uint256 currentExpiry)\n        internal\n        pure\n        returns (uint256)\n    {\n        // dayOfWeek = 0 (sunday) - 6 (saturday)\n        uint256 dayOfWeek = ((currentExpiry / 1 days) + 4) % 7;\n        uint256 nextFriday = currentExpiry + ((7 + 5 - dayOfWeek) % 7) * 1 days;\n        uint256 friday8am = nextFriday - (nextFriday % (24 hours)) + (8 hours);\n\n        // If the passed currentExpiry is day=Friday hour>8am, we simply increment it by a week to next Friday\n        if (currentExpiry >= friday8am) {\n            friday8am += 7 days;\n        }\n        return friday8am;\n    }\n\n    function getPPS(\n        uint256 currentSupply,\n        uint256 roundStartBalance,\n        uint256 singleShare,\n        uint256 initialSharePrice\n    ) internal pure returns (uint256 newPricePerShare) {\n        newPricePerShare = currentSupply > 0\n            ? singleShare.mul(roundStartBalance).div(currentSupply)\n            : initialSharePrice;\n    }\n\n    /***\n     * DSMath Copy paste\n     */\n\n    uint256 constant DSWAD = 10**18;\n\n    function dsadd(uint256 x, uint256 y) private pure returns (uint256 z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n\n    function dsmul(uint256 x, uint256 y) private pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n\n    //rounds to zero if x*y < WAD / 2\n    function dswdiv(uint256 x, uint256 y) private pure returns (uint256 z) {\n        z = dsadd(dsmul(x, DSWAD), y / 2) / y;\n    }\n}"
    },
    {
      "filename": "contracts/vaults/RibbonThetaVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.3;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport {GnosisAuction} from \"../libraries/GnosisAuction.sol\";\nimport {OptionsThetaVaultStorage} from \"../storage/OptionsVaultStorage.sol\";\nimport {Vault} from \"../libraries/Vault.sol\";\nimport {VaultLifecycle} from \"../libraries/VaultLifecycle.sol\";\nimport {ShareMath} from \"../libraries/ShareMath.sol\";\nimport {RibbonVault} from \"./base/RibbonVault.sol\";\n\ncontract RibbonThetaVault is RibbonVault, OptionsThetaVaultStorage {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using ShareMath for Vault.DepositReceipt;\n\n    /************************************************\n     *  IMMUTABLES & CONSTANTS\n     ***********************************************/\n\n    // oTokenFactory is the factory contract used to spawn otokens. Used to lookup otokens.\n    address public immutable OTOKEN_FACTORY;\n\n    /************************************************\n     *  EVENTS\n     ***********************************************/\n\n    event OpenShort(\n        address indexed options,\n        uint256 depositAmount,\n        address manager\n    );\n\n    event CloseShort(\n        address indexed options,\n        uint256 withdrawAmount,\n        address manager\n    );\n\n    event NewOptionStrikeSelected(uint256 strikePrice, uint256 delta);\n\n    event PremiumDiscountSet(\n        uint256 premiumDiscount,\n        uint256 newPremiumDiscount\n    );\n\n    event AuctionDurationSet(\n        uint256 auctionDuration,\n        uint256 newAuctionDuration\n    );\n\n    event InstantWithdraw(\n        address indexed account,\n        uint256 amount,\n        uint16 round\n    );\n\n    event InitiateGnosisAuction(\n        address auctioningToken,\n        address biddingToken,\n        uint256 auctionCounter,\n        address manager\n    );\n\n    /************************************************\n     *  CONSTRUCTOR & INITIALIZATION\n     ***********************************************/\n\n    /**\n     * @notice Initializes the contract with immutable variables\n     * @param _weth is the Wrapped Ether contract\n     * @param _usdc is the USDC contract\n     * @param _oTokenFactory is the contract address for minting new opyn option types (strikes, asset, expiry)\n     * @param _gammaController is the contract address for opyn actions\n     * @param _marginPool is the contract address for providing collateral to opyn\n     * @param _gnosisEasyAuction is the contract address that facilitates gnosis auctions\n     */\n    constructor(\n        address _weth,\n        address _usdc,\n        address _oTokenFactory,\n        address _gammaController,\n        address _marginPool,\n        address _gnosisEasyAuction\n    )\n        RibbonVault(\n            _weth,\n            _usdc,\n            _gammaController,\n            _marginPool,\n            _gnosisEasyAuction\n        )\n    {\n        require(_oTokenFactory != address(0), \"!_oTokenFactory\");\n        OTOKEN_FACTORY = _oTokenFactory;\n    }\n\n    /**\n     * @notice Initializes the OptionVault contract with storage variables.\n     */\n    function initialize(\n        address _owner,\n        address _feeRecipient,\n        uint256 _managementFee,\n        uint256 _performanceFee,\n        string memory tokenName,\n        string memory tokenSymbol,\n        address _optionsPremiumPricer,\n        address _strikeSelection,\n        uint32 _premiumDiscount,\n        uint256 _auctionDuration,\n        Vault.VaultParams calldata _vaultParams\n    ) external initializer {\n        baseInitialize(\n            _owner,\n            _feeRecipient,\n            _managementFee,\n            _performanceFee,\n            tokenName,\n            tokenSymbol,\n            _vaultParams\n        );\n        require(_optionsPremiumPricer != address(0), \"!_optionsPremiumPricer\");\n        require(_strikeSelection != address(0), \"!_strikeSelection\");\n        require(\n            _premiumDiscount > 0 && _premiumDiscount < 1000,\n            \"!_premiumDiscount\"\n        );\n        require(_auctionDuration >= 1 hours, \"!_auctionDuration\");\n        optionsPremiumPricer = _optionsPremiumPricer;\n        strikeSelection = _strikeSelection;\n        premiumDiscount = _premiumDiscount;\n        auctionDuration = _auctionDuration;\n    }\n\n    /************************************************\n     *  SETTERS\n     ***********************************************/\n\n    /**\n     * @notice Sets the new discount on premiums for options we are selling\n     * @param newPremiumDiscount is the premium discount\n     */\n    function setPremiumDiscount(uint16 newPremiumDiscount) external onlyOwner {\n        require(\n            newPremiumDiscount > 0 && newPremiumDiscount < 1000,\n            \"Invalid discount\"\n        );\n\n        emit PremiumDiscountSet(premiumDiscount, newPremiumDiscount);\n\n        premiumDiscount = newPremiumDiscount;\n    }\n\n    /**\n     * @notice Sets the new auction duration\n     * @param newAuctionDuration is the auction duration\n     */\n    function setAuctionDuration(uint256 newAuctionDuration) external onlyOwner {\n        require(newAuctionDuration >= 1 hours, \"Invalid auction duration\");\n\n        emit AuctionDurationSet(auctionDuration, newAuctionDuration);\n\n        auctionDuration = newAuctionDuration;\n    }\n\n    /**\n     * @notice Withdraws the assets on the vault using the outstanding `DepositReceipt.amount`\n     * @param amount is the amount to withdraw\n     */\n    function withdrawInstantly(uint256 amount) external nonReentrant {\n        Vault.DepositReceipt storage depositReceipt =\n            depositReceipts[msg.sender];\n\n        uint16 currentRound = vaultState.round;\n        require(amount > 0, \"!amount\");\n        require(depositReceipt.round == currentRound, \"Invalid round\");\n\n        uint104 receiptAmount = depositReceipt.amount;\n        require(receiptAmount >= amount, \"Exceed amount\");\n\n        // Subtraction underflow checks already ensure it is smaller than uint104\n        depositReceipt.amount = uint104(uint256(receiptAmount).sub(amount));\n        vaultState.totalPending = uint128(\n            uint256(vaultState.totalPending).sub(amount)\n        );\n\n        emit InstantWithdraw(msg.sender, amount, currentRound);\n\n        transferAsset(msg.sender, amount);\n    }\n\n    /************************************************\n     *  VAULT OPERATIONS\n     ***********************************************/\n\n    /**\n     * @notice Sets the next option the vault will be shorting, and closes the existing short.\n     *         This allows all the users to withdraw if the next option is malicious.\n     */\n    function commitAndClose() external onlyOwner nonReentrant {\n        address oldOption = optionState.currentOption;\n\n        VaultLifecycle.CloseParams memory closeParams =\n            VaultLifecycle.CloseParams({\n                OTOKEN_FACTORY: OTOKEN_FACTORY,\n                USDC: USDC,\n                currentOption: oldOption,\n                delay: delay,\n                lastStrikeOverride: lastStrikeOverride,\n                overriddenStrikePrice: overriddenStrikePrice\n            });\n\n        (\n            address otokenAddress,\n            uint256 premium,\n            uint256 strikePrice,\n            uint256 delta\n        ) =\n            VaultLifecycle.commitAndClose(\n                strikeSelection,\n                optionsPremiumPricer,\n                premiumDiscount,\n                closeParams,\n                vaultParams,\n                vaultState\n            );\n\n        emit NewOptionStrikeSelected(strikePrice, delta);\n\n        ShareMath.assertUint104(premium);\n        currentOtokenPremium = uint104(premium);\n        optionState.nextOption = otokenAddress;\n        optionState.nextOptionReadyAt = uint32(block.timestamp.add(delay));\n\n        _closeShort(oldOption);\n    }\n\n    /**\n     * @notice Closes the existing short position for the vault.\n     */\n    function _closeShort(address oldOption) private {\n        optionState.currentOption = address(0);\n\n        uint104 lockedAmount = vaultState.lockedAmount;\n        vaultState.lastLockedAmount = lockedAmount > 0\n            ? lockedAmount\n            : vaultState.lastLockedAmount;\n\n        vaultState.lockedAmount = 0;\n\n        if (oldOption != address(0)) {\n            uint256 withdrawAmount =\n                VaultLifecycle.settleShort(GAMMA_CONTROLLER);\n            emit CloseShort(oldOption, withdrawAmount, msg.sender);\n        }\n    }\n\n    /**\n     * @notice Rolls the vault's funds into a new short position.\n     */\n    function rollToNextOption() external nonReentrant {\n        (address newOption, uint256 lockedBalance) = _rollToNextOption();\n\n        vaultState.lockedAmount = uint104(lockedBalance);\n\n        emit OpenShort(newOption, lockedBalance, msg.sender);\n\n        VaultLifecycle.createShort(\n            GAMMA_CONTROLLER,\n            MARGIN_POOL,\n            newOption,\n            lockedBalance\n        );\n\n        startAuction();\n    }\n\n    /**\n     * @notice Initiate the gnosis auction.\n     */\n    function startAuction() public onlyOwner {\n        GnosisAuction.AuctionDetails memory auctionDetails;\n\n        uint256 currOtokenPremium = currentOtokenPremium;\n\n        require(currOtokenPremium > 0, \"!currentOtokenPremium\");\n\n        auctionDetails.oTokenAddress = optionState.currentOption;\n        auctionDetails.gnosisEasyAuction = GNOSIS_EASY_AUCTION;\n        auctionDetails.asset = vaultParams.asset;\n        auctionDetails.assetDecimals = vaultParams.decimals;\n        auctionDetails.oTokenPremium = currOtokenPremium;\n        auctionDetails.duration = auctionDuration;\n\n        optionAuctionID = VaultLifecycle.startAuction(auctionDetails);\n    }\n\n    /**\n     * @notice Burn the remaining oTokens left over from gnosis auction.\n     */\n    function burnRemainingOTokens() external onlyOwner nonReentrant {\n        uint256 numOTokensToBurn =\n            IERC20(optionState.currentOption).balanceOf(address(this));\n        require(numOTokensToBurn > 0, \"!otokens\");\n        uint256 unlockedAssedAmount =\n            VaultLifecycle.burnOtokens(GAMMA_CONTROLLER, numOTokensToBurn);\n        vaultState.lockedAmount = uint104(\n            uint256(vaultState.lockedAmount).sub(unlockedAssedAmount)\n        );\n    }\n\n    /**\n     * @notice Optionality to set strike price manually\n     * @param strikePrice is the strike price of the new oTokens (decimals = 8)\n     */\n    function setStrikePrice(uint128 strikePrice)\n        external\n        onlyOwner\n        nonReentrant\n    {\n        require(strikePrice > 0, \"!strikePrice\");\n        overriddenStrikePrice = strikePrice;\n        lastStrikeOverride = vaultState.round;\n    }\n}"
    },
    {
      "filename": "contracts/vaults/RibbonDeltaVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.3;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport {DSMath} from \"../vendor/DSMath.sol\";\nimport {GnosisAuction} from \"../libraries/GnosisAuction.sol\";\nimport {OptionsDeltaVaultStorage} from \"../storage/OptionsVaultStorage.sol\";\nimport {Vault} from \"../libraries/Vault.sol\";\nimport {VaultLifecycle} from \"../libraries/VaultLifecycle.sol\";\nimport {ShareMath} from \"../libraries/ShareMath.sol\";\nimport {RibbonVault} from \"./base/RibbonVault.sol\";\nimport {IRibbonThetaVault} from \"../interfaces/IRibbonThetaVault.sol\";\nimport {IGnosisAuction} from \"../interfaces/IGnosisAuction.sol\";\n\ncontract RibbonDeltaVault is RibbonVault, DSMath, OptionsDeltaVaultStorage {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using ShareMath for Vault.DepositReceipt;\n\n    /************************************************\n     *  IMMUTABLES & CONSTANTS\n     ***********************************************/\n\n    /************************************************\n     *  EVENTS\n     ***********************************************/\n\n    event OpenLong(\n        address indexed options,\n        uint256 purchaseAmount,\n        uint256 premium,\n        address manager\n    );\n\n    event CloseLong(\n        address indexed options,\n        uint256 profitAmount,\n        address manager\n    );\n\n    event NewOptionAllocationSet(\n        uint256 optionAllocationPct,\n        uint256 newOptionAllocationPct\n    );\n\n    event InstantWithdraw(address indexed account, uint256 share, uint16 round);\n\n    event PlaceAuctionBid(\n        uint256 auctionId,\n        address auctioningToken,\n        uint256 sellAmount,\n        uint256 buyAmount,\n        address bidder\n    );\n\n    /************************************************\n     *  CONSTRUCTOR & INITIALIZATION\n     ***********************************************/\n\n    /**\n     * @notice Initializes the contract with immutable variables\n     * @param _weth is the Wrapped Ether contract\n     * @param _usdc is the USDC contract\n     * @param _gammaController is the contract address for opyn actions\n     * @param _marginPool is the contract address for providing collateral to opyn\n     * @param _gnosisEasyAuction is the contract address that facilitates gnosis auctions\n     */\n    constructor(\n        address _weth,\n        address _usdc,\n        address _gammaController,\n        address _marginPool,\n        address _gnosisEasyAuction\n    )\n        RibbonVault(\n            _weth,\n            _usdc,\n            _gammaController,\n            _marginPool,\n            _gnosisEasyAuction\n        )\n    {}\n\n    /**\n     * @notice Initializes the OptionVault contract with storage variables.\n     */\n    function initialize(\n        address _owner,\n        address _feeRecipient,\n        uint256 _managementFee,\n        uint256 _performanceFee,\n        string memory tokenName,\n        string memory tokenSymbol,\n        address _counterpartyThetaVault,\n        uint256 _optionAllocationPct,\n        Vault.VaultParams calldata _vaultParams\n    ) external initializer {\n        baseInitialize(\n            _owner,\n            _feeRecipient,\n            _managementFee,\n            _performanceFee,\n            tokenName,\n            tokenSymbol,\n            _vaultParams\n        );\n        require(\n            _counterpartyThetaVault != addr"
    }
  ]
}