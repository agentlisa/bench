{
  "Title": "Fragilely Shared Pointer",
  "Content": "In the `buyGas` function of the `state_transition.go` file, the value of `mgval` is intended to be copied into `balanceCheck`. However, instead of the value, a pointer to the value is copied. Hence, [with this assignment](https://github.com/mantlenetworkio/op-geth/blob/4d05b2cd9a2b8096680eb9b2e87e473a44a43922/core/state_transition.go#L304), the variables share the same memory. Luckily, the `balanceCheck` variable then gets another pointer assigned due to `new(big.Int).SetUint64()`.\n\n\nHowever, if in future revisions this code were to be changed to `balanceCheck.SetUint64()`, no new memory would be allocated for this value, implying an overwrite of `mgval` with it. In this code context, this means that the transaction [value is additionally considered](https://github.com/mantlenetworkio/op-geth/blob/4d05b2cd9a2b8096680eb9b2e87e473a44a43922/core/state_transition.go#L308) as gas cost, leading to a [double spending of the value](https://github.com/mantlenetworkio/op-geth/blob/4d05b2cd9a2b8096680eb9b2e87e473a44a43922/core/state_transition.go#L346) or additional spending [for the transaction sponsor](https://github.com/mantlenetworkio/op-geth/blob/4d05b2cd9a2b8096680eb9b2e87e473a44a43922/core/state_transition.go#L340).\n\n\nConsider avoiding a shared pointer altogether by always allocating a new value through `new(big.Int).SetUint64()`. While this is not an issue in the given function, it is better to minimize the risk before it escalates in the future if not treated carefully.\n\n\n***Update:** Resolved in [pull request #52](https://github.com/mantlenetworkio/op-geth/pull/52) at commit [75b60cb](https://github.com/mantlenetworkio/op-geth/pull/52/commits/75b60cb8f353730f5d68390618cde0ceafcce24d).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "core/state_transition.go",
      "content": "// Copyright 2014 The go-ethereum Authors\n// This file is part of the go-ethereum library.\n//\n// The go-ethereum library is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// The go-ethereum library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.\n\npackage core\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"math/big\"\n\n\t\"github.com/ethereum/go-ethereum/common\"\n\tcmath \"github.com/ethereum/go-ethereum/common/math\"\n\t\"github.com/ethereum/go-ethereum/core/types\"\n\t\"github.com/ethereum/go-ethereum/core/vm\"\n\t\"github.com/ethereum/go-ethereum/crypto\"\n\t\"github.com/ethereum/go-ethereum/log\"\n\t\"github.com/ethereum/go-ethereum/params\"\n\t\"golang.org/x/crypto/sha3\"\n)\n\nvar (\n\tBVM_ETH_ADDR = common.HexToAddress(\"0xdEAddEaDdeadDEadDEADDEAddEADDEAddead1111\")\n)\n\n// ExecutionResult includes all output after executing given evm\n// message no matter the execution itself is successful or not.\ntype ExecutionResult struct {\n\tUsedGas    uint64 // Total used gas but include the refunded gas\n\tErr        error  // Any error encountered during the execution(listed in core/vm/errors.go)\n\tReturnData []byte // Returned data from evm(function result or data supplied with revert opcode)\n}\n\n// Unwrap returns the internal evm error which allows us for further\n// analysis outside.\nfunc (result *ExecutionResult) Unwrap() error {\n\treturn result.Err\n}\n\n// Failed returns the indicator whether the execution is successful or not\nfunc (result *ExecutionResult) Failed() bool { return result.Err != nil }\n\n// Return is a helper function to help caller distinguish between revert reason\n// and function return. Return returns the data after execution if no error occurs.\nfunc (result *ExecutionResult) Return() []byte {\n\tif result.Err != nil {\n\t\treturn nil\n\t}\n\treturn common.CopyBytes(result.ReturnData)\n}\n\n// Revert returns the concrete revert reason if the execution is aborted by `REVERT`\n// opcode. Note the reason can be nil if no data supplied with revert opcode.\nfunc (result *ExecutionResult) Revert() []byte {\n\tif result.Err != vm.ErrExecutionReverted {\n\t\treturn nil\n\t}\n\treturn common.CopyBytes(result.ReturnData)\n}\n\n// IntrinsicGas computes the 'intrinsic gas' for a message with the given data.\nfunc IntrinsicGas(data []byte, accessList types.AccessList, isContractCreation bool, isHomestead, isEIP2028 bool, isEIP3860 bool) (uint64, error) {\n\t// Set the starting gas for the raw transaction\n\tvar gas uint64\n\tif isContractCreation && isHomestead {\n\t\tgas = params.TxGasContractCreation\n\t} else {\n\t\tgas = params.TxGas\n\t}\n\tdataLen := uint64(len(data))\n\t// Bump the required gas by the amount of transactional data\n\tif dataLen > 0 {\n\t\t// Zero and non-zero bytes are priced differently\n\t\tvar nz uint64\n\t\tfor _, byt := range data {\n\t\t\tif byt != 0 {\n\t\t\t\tnz++\n\t\t\t}\n\t\t}\n\t\t// Make sure we don't exceed uint64 for all data combinations\n\t\tnonZeroGas := params.TxDataNonZeroGasFrontier\n\t\tif isEIP2028 {\n\t\t\tnonZeroGas = params.TxDataNonZeroGasEIP2028\n\t\t}\n\t\tif (math.MaxUint64-gas)/nonZeroGas < nz {\n\t\t\treturn 0, ErrGasUintOverflow\n\t\t}\n\t\tgas += nz * nonZeroGas\n\n\t\tz := dataLen - nz\n\t\tif (math.MaxUint64-gas)/params.TxDataZeroGas < z {\n\t\t\treturn 0, ErrGasUintOverflow\n\t\t}\n\t\tgas += z * params.TxDataZeroGas\n\n\t\tif isContractCreation && isEIP3860 {\n\t\t\tlenWords := toWordSize(dataLen)\n\t\t\tif (math.MaxUint64-gas)/params.InitCodeWordGas < lenWords {\n\t\t\t\treturn 0, ErrGasUintOverflow\n\t\t\t}\n\t\t\tgas += lenWords * params.InitCodeWordGas\n\t\t}\n\t}\n\tif accessList != nil {\n\t\tgas += uint64(len(accessList)) * params.TxAccessListAddressGas\n\t\tgas += uint64(accessList.StorageKeys()) * params.TxAccessListStorageKeyGas\n\t}\n\treturn gas, nil\n}\n\n// toWordSize returns the ceiled word size required for init code payment calculation.\nfunc toWordSize(size uint64) uint64 {\n\tif size > math.MaxUint64-31 {\n\t\treturn math.MaxUint64/32 + 1\n\t}\n\n\treturn (size + 31) / 32\n}\n\ntype RunMode uint8\n\nconst (\n\tCommitMode RunMode = iota\n\tGasEstimationMode\n\tGasEstimationWithSkipCheckBalanceMode\n\tEthcallMode\n)\n\n// A Message contains the data derived from a single transaction that is relevant to state\n// processing.\ntype Message struct {\n\tTo         *common.Address\n\tFrom       common.Address\n\tNonce      uint64\n\tValue      *big.Int\n\tGasLimit   uint64\n\tGasPrice   *big.Int\n\tGasFeeCap  *big.Int\n\tGasTipCap  *big.Int\n\tData       []byte\n\tAccessList types.AccessList\n\n\t// When SkipAccountCheckss is true, the message nonce is not checked against the\n\t// account nonce in state. It also disables checking that the sender is an EOA.\n\t// This field will be set to true for operations like RPC eth_call.\n\tSkipAccountChecks bool\n\n\tIsSystemTx    bool                // IsSystemTx indicates the message, if also a deposit, does not emit gas usage.\n\tIsDepositTx   bool                // IsDepositTx indicates the message is force-included and can persist a mint.\n\tMint          *big.Int            // Mint is the amount to mint before EVM processing, or nil if there is no minting.\n\tETHValue      *big.Int            // ETHValue is the amount to mint BVM_ETH before EVM processing, or nil if there is no minting.\n\tETHTxValue    *big.Int            // ETHTxValue is the amount to be transferred to msg.To before EVM processing, and the transfer will be reverted if EVM failed\n\tMetaTxParams  *types.MetaTxParams // MetaTxParams contains necessary parameter to sponsor gas fee for msg.From.\n\tRollupDataGas types.RollupGasData // RollupDataGas indicates the rollup cost of the message, 0 if not a rollup or no cost.\n\n\t// runMode\n\tRunMode RunMode\n}\n\n// TransactionToMessage converts a transaction into a Message.\nfunc TransactionToMessage(tx *types.Transaction, s types.Signer, baseFee *big.Int, rules *params.Rules) (*Message, error) {\n\tif rules == nil {\n\t\treturn nil, errors.New(\"param rules is nil pointer\")\n\t}\n\tmetaTxParams, err := types.DecodeAndVerifyMetaTxParams(tx, rules.IsMetaTxV2)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tmsg := &Message{\n\t\tNonce:             tx.Nonce(),\n\t\tGasLimit:          tx.Gas(),\n\t\tGasPrice:          new(big.Int).Set(tx.GasPrice()),\n\t\tGasFeeCap:         new(big.Int).Set(tx.GasFeeCap()),\n\t\tGasTipCap:         new(big.Int).Set(tx.GasTipCap()),\n\t\tTo:                tx.To(),\n\t\tValue:             tx.Value(),\n\t\tData:              tx.Data(),\n\t\tAccessList:        tx.AccessList(),\n\t\tIsSystemTx:        tx.IsSystemTx(),\n\t\tIsDepositTx:       tx.IsDepositTx(),\n\t\tMint:              tx.Mint(),\n\t\tRollupDataGas:     tx.RollupDataGas(),\n\t\tETHValue:          tx.ETHValue(),\n\t\tETHTxValue:        tx.ETHTxValue(),\n\t\tMetaTxParams:      metaTxParams,\n\t\tSkipAccountChecks: false,\n\t\tRunMode:           CommitMode,\n\t}\n\t// If baseFee provided, set gasPrice to effectiveGasPrice.\n\tif baseFee != nil {\n\t\tmsg.GasPrice = cmath.BigMin(msg.GasPrice.Add(msg.GasTipCap, baseFee), msg.GasFeeCap)\n\t}\n\tmsg.From, err = types.Sender(s, tx)\n\treturn msg, err\n}\n\n// CalculateRollupGasDataFromMessage calculate RollupGasData from message.\nfunc (st *StateTransition) CalculateRollupGasDataFromMessage() {\n\ttx := types.NewTx(&types.DynamicFeeTx{\n\t\tNonce:     st.msg.Nonce,\n\t\tValue:     st.msg.Value,\n\t\tGas:       st.msg.GasLimit,\n\t\tGasTipCap: st.msg.GasTipCap,\n\t\tGasFeeCap: st.msg.GasFeeCap,\n\t\tData:      st.msg.Data,\n\t})\n\n\tst.msg.RollupDataGas = tx.RollupDataGas()\n\n\t// add a constant to cover sigs(V,R,S) and other data to make sure that the gasLimit from eth_estimateGas can cover L1 cost\n\t// just used for estimateGas and the actual L1 cost depends on users' tx when executing\n\tst.msg.RollupDataGas.Ones += 80\n}\n\n// ApplyMessage computes the new state by applying the given message\n// against the old state within the environment.\n//\n// ApplyMessage returns the bytes returned by any EVM execution (if it took place),\n// the gas used (which includes gas refunds) and an error if it failed. An error always\n// indicates a core error meaning that the message would always fail for that particular\n// state and would never be accepted within a block.\nfunc ApplyMessage(evm *vm.EVM, msg *Message, gp *GasPool) (*ExecutionResult, error) {\n\treturn NewStateTransition(evm, msg, gp).TransitionDb()\n}\n\n// StateTransition represents a state transition.\n//\n// == The State Transitioning Model\n//\n// A state transition is a change made when a transaction is applied to the current world\n// state. The state transitioning model does all the necessary work to work out a valid new\n// state root.\n//\n//  1. Nonce handling\n//  2. Pre pay gas\n//  3. Create a new state object if the recipient is nil\n//  4. Value transfer\n//\n// == If contract creation ==\n//\n//\t4a. Attempt to run transaction data\n//\t4b. If valid, use result as code for the new state object\n//\n// == end ==\n//\n//  5. Run Script section\n//  6. Derive new state root\ntype StateTransition struct {\n\tgp           *GasPool\n\tmsg          *Message\n\tgasRemaining uint64\n\tinitialGas   uint64\n\tstate        vm.StateDB\n\tevm          *vm.EVM\n}\n\n// NewStateTransition initialises and returns a new state transition object.\nfunc NewStateTransition(evm *vm.EVM, msg *Message, gp *GasPool) *StateTransition {\n\treturn &StateTransition{\n\t\tgp:    gp,\n\t\tevm:   evm,\n\t\tmsg:   msg,\n\t\tstate: evm.StateDB,\n\t}\n}\n\n// to returns the recipient of the message.\nfunc (st *StateTransition) to() common.Address {\n\tif st.msg == nil || st.msg.To == nil /* contract creation */ {\n\t\treturn common.Address{}\n\t}\n\treturn *st.msg.To\n}\n\nfunc (st *StateTransition) buyGas() (*big.Int, error) {\n\tif err := st.applyMetaTransaction(); err != nil {\n\t\treturn nil, err\n\t}\n\tmgval := new(big.Int).SetUint64(st.msg.GasLimit)\n\tmgval = mgval.Mul(mgval, st.msg.GasPrice)\n\tvar l1Cost *big.Int\n\tif st.msg.RunMode == GasEstimationMode || st.msg.RunMode == GasEstimationWithSkipCheckBalanceMode {\n\t\tst.CalculateRollupGasDataFromMessage()\n\t}\n\tif st.evm.Context.L1CostFunc != nil && st.msg.RunMode != EthcallMode {\n\t\tl1Cost = st.evm.Context.L1CostFunc(st.evm.Context.BlockNumber.Uint64(), st.evm.Context.Time, st.msg.RollupDataGas, st.msg.IsDepositTx, st.msg.To)\n\t}\n\tif l1Cost != nil && (st.msg.RunMode == GasEstimationMode || st.msg.RunMode == GasEstimationWithSkipCheckBalanceMode) {\n\t\tmgval = mgval.Add(mgval, l1Cost)\n\t}\n\tbalanceCheck := mgval\n\tif st.msg.GasFeeCap != nil {\n\t\tbalanceCheck = new(big.Int).SetUint64(st.msg.GasLimit)\n\t\tbalanceCheck = balanceCheck.Mul(balanceCheck, st.msg.GasFeeCap)\n\t\tbalanceCheck.Add(balanceCheck, st.msg.Value)\n\t\tif l1Cost != nil && st.msg.RunMode == GasEstimationMode {\n\t\t\tbalanceCheck.Add(balanceCheck, l1Cost)\n\t\t}\n\t}\n\tif st.msg.RunMode != GasEstimationWithSkipCheckBalanceMode && st.msg.RunMode != EthcallMode {\n\t\tif st.msg.MetaTxParams != nil {\n\t\t\tpureGasFeeValue := new(big.Int).Sub(balanceCheck, st.msg.Value)\n\t\t\tsponsorAmount, selfPayAmount := types.CalculateSponsorPercentAmount(st.msg.MetaTxParams, pureGasFeeValue)\n\t\t\tif have, want := st.state.GetBalance(st.msg.MetaTxParams.GasFeeSponsor), sponsorAmount; have.Cmp(want) < 0 {\n\t\t\t\treturn nil, fmt.Errorf(\"%w: gas fee sponsor %v have %v want %v\", ErrInsufficientFunds, st.msg.MetaTxParams.GasFeeSponsor.Hex(), have, want)\n\t\t\t}\n\t\t\tselfPayAmount = new(big.Int).Add(selfPayAmount, st.msg.Value)\n\t\t\tif have, want := st.state.GetBalance(st.msg.From), selfPayAmount; have.Cmp(want) < 0 {\n\t\t\t\treturn nil, fmt.Errorf(\"%w: address %v have %v want %v\", ErrInsufficientFunds, st.msg.From.Hex(), have, want)\n\t\t\t}\n\t\t} else {\n\t\t\tif have, want := st.state.GetBalance(st.msg.From), balanceCheck; have.Cmp(want) < 0 {\n\t\t\t\treturn nil, fmt.Errorf(\"%w: address %v have %v want %v\", ErrInsufficientFunds, st.msg.From.Hex(), have, want)\n\t\t\t}\n\t\t}\n\t}\n\n\tif err := st.gp.SubGas(st.msg.GasLimit); err != nil {\n\t\treturn nil, err\n\t}\n\tst.gasRemaining += st.msg.GasLimit\n\n\tst.initialGas = st.msg.GasLimit\n\tif st.msg.RunMode != GasEstimationWithSkipCheckBalanceMode && st.msg.RunMode != EthcallMode {\n\t\tif st.msg.MetaTxParams != nil {\n\t\t\tsponsorAmount, selfPayAmount := types.CalculateSponsorPercentAmount(st.msg.MetaTxParams, mgval)\n\t\t\tst.state.SubBalance(st.msg.MetaTxParams.GasFeeSponsor, sponsorAmount)\n\t\t\tst.state.SubBalance(st.msg.From, selfPayAmount)\n\t\t\tlog.Debug(\"BuyGas for metaTx\",\n\t\t\t\t\"sponsor\", st.msg.MetaTxParams.GasFeeSponsor.String(), \"amount\", sponsorAmount.String(),\n\t\t\t\t\"user\", st.msg.From.String(), \"amount\", selfPayAmount.String())\n\t\t} else {\n\t\t\tst.state.SubBalance(st.msg.From, mgval)\n\t\t}\n\t}\n\treturn l1Cost, nil\n}\n\nfunc (st *StateTransition) applyMetaTransaction() error {\n\tif st.msg.MetaTxParams == nil {\n\t\treturn nil\n\t}\n\tif st.msg.MetaTxParams.ExpireHeight < st.evm.Context.BlockNumber.Uint64() {\n\t\treturn types.ErrExpiredMetaTx\n\t}\n\n\tst.msg.Data = st.msg.MetaTxParams.Payload\n\treturn nil\n}\n\nfunc (st *StateTransition) preCheck() (*big.Int, error) {\n\tif st.msg.IsDepositTx {\n\t\t// No fee fields to check, no nonce to check, and no need to check if EOA (L1 already verified it for us)\n\t\t// Gas is free, but no refunds!\n\t\tst.initialGas = st.msg.GasLimit\n\t\tst.gasRemaining += st.msg.GasLimit // Add gas here in order to be able to execute calls.\n\t\t// Don't touch the gas pool for system transactions\n\t\tif st.msg.IsSystemTx {\n\t\t\tif st.evm.ChainConfig().IsOptimismRegolith(st.evm.Context.Time) {\n\t\t\t\treturn nil, fmt.Errorf(\"%w: address %v\", ErrSystemTxNotSupported,\n\t\t\t\t\tst.msg.From.Hex())\n\t\t\t}\n\t\t\treturn common.Big0, nil\n\t\t}\n\t\tif err := st.gp.SubGas(st.msg.GasLimit); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn common.Big0, nil // gas used by deposits may not be used by other txs\n\t}\n\t// Only check transactions that are not fake\n\tmsg := st.msg\n\tif !msg.SkipAccountChecks {\n\t\t// Make sure this transaction's nonce is correct.\n\t\tstNonce := st.state.GetNonce(msg.From)\n\t\tif msgNonce := msg.Nonce; stNonce < msgNonce {\n\t\t\treturn nil, fmt.Errorf(\"%w: address %v, tx: %d state: %d\", ErrNonceTooHigh,\n\t\t\t\tmsg.From.Hex(), msgNonce, stNonce)\n\t\t} else if stNonce > msgNonce {\n\t\t\treturn nil, fmt.Errorf(\"%w: address %v, tx: %d state: %d\", ErrNonceTooLow,\n\t\t\t\tmsg.From.Hex(), msgNonce, stNonce)\n\t\t} else if stNonce+1 < stNonce {\n\t\t\treturn nil, fmt.Errorf(\"%w: address %v, nonce: %d\", ErrNonceMax,\n\t\t\t\tmsg.From.Hex(), stNonce)\n\t\t}\n\t\t// Make sure the sender is an EOA\n\t\tcodeHash := st.state.GetCodeHash(msg.From)\n\t\tif codeHash != (common.Hash{}) && codeHash != types.EmptyCodeHash {\n\t\t\treturn nil, fmt.Errorf(\"%w: address %v, codehash: %s\", ErrSenderNoEOA,\n\t\t\t\tmsg.From.Hex(), codeHash)\n\t\t}\n\t}\n\n\t// Make sure that transaction gasFeeCap is greater than the baseFee (post london)\n\tif st.evm.ChainConfig().IsLondon(st.evm.Context.BlockNumber) {\n\t\t// Skip the checks if gas fields are zero and baseFee was explicitly disabled (eth_call)\n\t\tif !st.evm.Config.NoBaseFee || msg.GasFeeCap.BitLen() > 0 || msg.GasTipCap.BitLen() > 0 {\n\t\t\tif l := msg.GasFeeCap.BitLen(); l > 256 {\n\t\t\t\treturn nil, fmt.Errorf(\"%w: address %v, maxFeePerGas bit length: %d\", ErrFeeCapVeryHigh,\n\t\t\t\t\tmsg.From.Hex(), l)\n\t\t\t}\n\t\t\tif l := msg.GasTipCap.BitLen(); l > 256 {\n\t\t\t\treturn nil, fmt.Errorf(\"%w: address %v, maxPriorityFeePerGas bit length: %d\", ErrTipVeryHigh,\n\t\t\t\t\tmsg.From.Hex(), l)\n\t\t\t}\n\t\t\tif msg.GasFeeCap.Cmp(msg.GasTipCap) < 0 {\n\t\t\t\treturn nil, fmt.Errorf(\"%w: address %v, maxPriorityFeePerGas: %s, maxFeePerGas: %s\", ErrTipAboveFeeCap,\n\t\t\t\t\tmsg.From.Hex(), msg.GasTipCap, msg.GasFeeCap)\n\t\t\t}\n\t\t\t// This will panic if baseFee is nil, but basefee presence is verified\n\t\t\t// as part of header validation.\n\t\t\tif msg.GasFeeCap.Cmp(st.evm.Context.BaseFee) < 0 {\n\t\t\t\treturn nil, fmt.Errorf(\"%w: address %v, maxFeePerGas: %s baseFee: %s\", ErrFeeCapTooLow,\n\t\t\t\t\tmsg.From.Hex(), msg.GasFeeCap, st.evm.Context.BaseFee)\n\t\t\t}\n\t\t}\n\t}\n\treturn st.buyGas()\n}\n\n// TransitionDb will transition the state by applying the current message and\n// returning the evm execution result with following fields.\n//\n//   - used gas: total gas used (including gas being refunded)\n//   - returndata: the returned data from evm\n//   - concrete execution error: various EVM errors which abort the execution, e.g.\n//     ErrOutOfGas, ErrExecutionReverted\n//\n// However if any consensus issue encountered, return the error directly with\n// nil evm execution result.\nfunc (st *StateTransition) TransitionDb() (*ExecutionResult, error) {\n\tif mint := st.msg.Mint; mint != nil {\n\t\tst.state.AddBalance(st.msg.From, mint)\n\t}\n\n\t//Mint BVM_ETH\n\trules := st.evm.ChainConfig().Rules(st.evm.Context.BlockNumber, st.evm.Context.Random != nil, st.evm.Context.Time)\n\t//add eth value\n\tif ethValue := st.msg.ETHValue; ethValue != nil && ethValue.Cmp(big.NewInt(0)) != 0 {\n\t\tst.mintBVMETH(ethValue, rules)\n\t}\n\tsnap := st.state.Snapshot()\n\t// Will be reverted if failed\n\tif ethTxValue := st.msg.ETHTxValue; ethTxValue != nil && ethTxValue.Cmp(big.NewInt(0)) != 0 {\n\t\tst.transferBVMETH(ethTxValue, rules)\n\t}\n\n\tresult, err := st.innerTransitionDb()\n\t// Failed deposits must still be included. Unless we cannot produce the block at all due to the gas limit.\n\t// On deposit failure, we rewind any state changes from after the minting, and increment the nonce.\n\tif err != nil && err != ErrGasLimitReached && st.msg.IsDepositTx {\n\t\tst.state.RevertToSnapshot(snap)\n\t\t// Even though we revert the state changes, always increment the nonce for the next deposit transaction\n\t\tst.state.SetNonce(st.msg.From, st.state.GetNonce(st.msg.From)+1)\n\t\t// Record deposits as using all their gas (matches the gas pool)\n\t\t// System Transactions are special & are not recorded as using any gas (anywhere)\n\t\t// Regolith changes this behaviour so the actual gas used is reported.\n\t\t// In this case the tx is invalid so is recorded as using all gas.\n\t\tgasUsed := st.msg.GasLimit\n\t\tif st.msg.IsSystemTx && !st.evm.ChainConfig().IsRegolith(st.evm.Context.Time) {\n\t\t\tgasUsed = 0\n\t\t}\n\t\tresult = &ExecutionResult{\n\t\t\tUsedGas:    gasUsed,\n\t\t\tErr:        fmt.Errorf(\"failed deposit: %w\", err),\n\t\t\tReturnData: nil,\n\t\t}\n\t\terr = nil\n\t}\n\treturn result, err\n}\n\nfunc (st *StateTransition) innerTransitionDb() (*ExecutionResult, error) {\n\t// First check this message satisfies all consensus rules before\n\t// applying the message. The rules include these clauses\n\t//\n\t// 1. the nonce of the message caller is correct\n\t// 2. caller has enough balance to cover transaction fee(gaslimit * gasprice)\n\t// 3. the amount of gas required is available in the block\n\t// 4. the purchased gas is enough to cover intrinsic usage\n\t// 5. there is no overflow when calculating intrinsic gas\n\t// 6. caller has enough balance to cover asset transfer for **topmost** call\n\n\t// Check clauses 1-3, buy gas if everything is correct\n\ttokenRatio := st.state.GetState(types.GasOracleAddr, types.TokenRatioSlot).Big().Uint64()\n\tl1Cost, err := st.preCheck()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif st.evm.Config.Debug {\n\t\tst.evm.Config.Tracer.CaptureTxStart(st.initialGas)\n\t\tdefer func() {\n\t\t\tst.evm.Config.Tracer.CaptureTxEnd(st.gasRemaining)\n\t\t}()\n\t}\n\n\tvar (\n\t\tmsg              = st.msg\n\t\tsender           = vm.AccountRef(msg.From)\n\t\trules            = st.evm.ChainConfig().Rules(st.evm.Context.BlockNumber, st.evm.Context.Random != nil, st.evm.Context.Time)\n\t\tcontractCreation = msg.To == nil\n\t)\n\n\t// Check clauses 4-5, subtract intrinsic gas if everything is correct\n\tgas, err := IntrinsicGas(msg.Data, msg.AccessList, contractCreation, rules.IsHomestead, rules.IsIstanbul, rules.IsShanghai)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !st.msg.IsDepositTx && !st.msg.IsSystemTx {\n\t\tgas = gas * tokenRatio\n\t}\n\tif st.gasRemaining < gas {\n\t\treturn nil, fmt.Errorf(\"%w: have %d, want %d\", ErrIntrinsicGas, st.gasRemaining, gas)\n\t}\n\tst.gasRemaining -= gas\n\n\tvar l1Gas uint64\n\tif !st.msg.IsDepositTx && !st.msg.IsSystemTx {\n\t\tif st.msg.GasPrice.Cmp(common.Big0) > 0 && l1Cost != nil {\n\t\t\tl1Gas = new(big.Int).Div(l1Cost, st.msg.GasPrice).Uint64()\n\t\t\tif st.msg.GasLimit < l1Gas {\n\t\t\t\treturn nil, fmt.Errorf(\"%w: have %d, want %d\", ErrIntrinsicGas, st.gasRemaining, l1Gas)\n\t\t\t}\n\t\t}\n\t\tif st.gasRemaining < l1Gas {\n\t\t\treturn nil, fmt.Errorf(\"%w: have %d, want %d\", ErrIntrinsicGas, st.gasRemaining, l1Gas)\n\t\t}\n\t\tst.gasRemaining -= l1Gas\n\t\tif tokenRatio > 0 {\n\t\t\tst.gasRemaining = st.gasRemaining / tokenRatio\n\t\t}\n\t}\n\n\t// Check clause 6\n\tif msg.Value.Sign() > 0 && !st.evm.Context.CanTransfer(st.state, msg.From, msg.Value) {\n\t\treturn nil, fmt.Errorf(\"%w: address %v\", ErrInsufficientFundsForTransfer, msg.From.Hex())\n\t}\n\n\t// Check whether the init code size has been exceeded.\n\tif rules.IsShanghai && contractCreation && len(msg.Data) > params.MaxInitCodeSize {\n\t\treturn nil, fmt.Errorf(\"%w: code size %v limit %v\", ErrMaxInitCodeSizeExceeded, len(msg.Data), params.MaxInitCodeSize)\n\t}\n\n\t// Execute the preparatory steps for state transition which includes:\n\t// - prepare accessList(post-berlin)\n\t// - reset transient storage(eip 1153)\n\tst.state.Prepare(rules, msg.From, st.evm.Context.Coinbase, msg.To, vm.ActivePrecompiles(rules), msg.AccessList)\n\n\tvar (\n\t\tret   []byte\n\t\tvmerr error // vm errors do not effect consensus and are therefore not assigned to err\n\t)\n\tif contractCreation {\n\t\tret, _, st.gasRemaining, vmerr = st.evm.Create(sender, msg.Data, st.gasRemaining, msg.Value)\n\t} else {\n\t\t// Increment the nonce for the next transaction\n\t\tst.state.SetNonce(msg.From, st.state.GetNonce(sender.Address())+1)\n\t\tret, st.gasRemaining, vmerr = st.evm.Call(sender, st.to(), msg.Data, st.gasRemaining, msg.Value)\n\t}\n\n\t// if deposit: skip refunds, skip tipping coinbase\n\t// Regolith changes this behaviour to report the actual gasUsed instead of always reporting all gas used.\n\tif st.msg.IsDepositTx && !rules.IsOptimismRegolith {\n\t\t// Record deposits as using all their gas (matches the gas pool)\n\t\t// System Transactions are special & are not recorded as using any gas (anywhere)\n\t\tgasUsed := st.msg.GasLimit\n\t\tif st.msg.IsSystemTx {\n\t\t\tgasUsed = 0\n\t\t}\n\t\treturn &ExecutionResult{\n\t\t\tUsedGas:    gasUsed,\n\t\t\tErr:        vmerr,\n\t\t\tReturnData: ret,\n\t\t}, nil\n\t}\n\t// Note for deposit tx there is no ETH refunded for unused gas, but that's taken care of by the fact that gasPrice\n\t// is always 0 for deposit tx. So calling refundGas will ensure the gasUsed accounting is correct without actually\n\t// changing the sender's balance\n\tif !st.msg.IsDepositTx && !st.msg.IsSystemTx {\n\t\tif !rules.IsLondon {\n\t\t\t// Before EIP-3529: refunds were capped to gasUsed / 2\n\t\t\tst.refundGas(params.RefundQuotient, tokenRatio)\n\t\t} else {\n\t\t\t// After EIP-3529: refunds are capped to gasUsed / 5\n\t\t\tst.refundGas(params.RefundQuotientEIP3529, tokenRatio)\n\t\t}\n\t}\n\n\tif st.msg.IsDepositTx && rules.IsOptimismRegolith {\n\t\t// Skip coinbase payments for deposit tx in Regolith\n\t\treturn &ExecutionResult{\n\t\t\tUsedGas:    st.gasUsed(),\n\t\t\tErr:        vmerr,\n\t\t\tReturnData: ret,\n\t\t}, nil\n\t}\n\teffectiveTip := msg.GasPrice\n\tif rules.IsLondon {\n\t\teffectiveTip = cmath.BigMin(msg.GasTipCap, new(big.Int).Sub(msg.GasFeeCap, st.evm.Context.BaseFee))\n\t}\n\n\tif st.evm.Config.NoBaseFee && msg.GasFeeCap.Sign() == 0 && msg.GasTipCap.Sign() == 0 {\n\t\t// Skip fee payment when NoBaseFee is set and the fee fields\n\t\t// are 0. This avoids a negative effectiveTip being applied to\n\t\t// the coinbase when simulating calls.\n\t} else {\n\t\tfee := new(big.Int).SetUint64(st.gasUsed())\n\t\tfee.Mul(fee, effectiveTip)\n\t\tst.state.AddBalance(st.evm.Context.Coinbase, fee)\n\t}\n\n\t// Check that we are post bedrock to enable op-geth to be able to create pseudo pre-bedrock blocks (these are pre-bedrock, but don't follow l2 geth rules)\n\t// Note optimismConfig will not be nil if rules.IsOptimismBedrock is true\n\tif optimismConfig := st.evm.ChainConfig().Optimism; optimismConfig != nil && rules.IsOptimismBedrock {\n\t\tst.state.AddBalance(params.OptimismBaseFeeRecipient, new(big.Int).Mul(new(big.Int).SetUint64(st.gasUsed()), st.evm.Context.BaseFee))\n\t\t// Can not collect l1 fee here again, all l1 fee has been collected by CoinBase & OptimismBaseFeeRecipient\n\t\t//if cost := st.evm.Context.L1CostFunc(st.evm.Context.BlockNumber.Uint64(), st.evm.Context.Time, st.msg.RollupDataGas, st.msg.IsDepositTx); cost != nil {\n\t\t//\tst.state.AddBalance(params.OptimismL1FeeRecipient, cost)\n\t\t//}\n\t}\n\n\treturn &ExecutionResult{\n\t\tUsedGas:    st.gasUsed(),\n\t\tErr:        vmerr,\n\t\tReturnData: ret,\n\t}, nil\n}\n\nfunc (st *StateTransition) refundGas(refundQuotient, tokenRatio uint64) {\n\tif st.msg.RunMode == GasEstimationWithSkipCheckBalanceMode || st.msg.RunMode == EthcallMode {\n\t\tst.gasRemaining = st.gasRemaining * tokenRatio\n\t\tst.gp.AddGas(st.gasRemaining)\n\t\treturn\n\t}\n\t// Apply refund counter, capped to a refund quotient\n\trefund := st.gasUsed() / refundQuotient\n\tif refund > st.state.GetRefund() {\n\t\trefund = st.state.GetRefund()\n\t}\n\tst.gasRemaining += refund\n\n\t// Return ETH for remaining gas, exchanged at the original rate.\n\tst.gasRemaining = st.gasRemaining * tokenRatio\n\tremaining := new(big.Int).Mul(new(big.Int).SetUint64(st.gasRemaining), st.msg.GasPrice)\n\tif st.msg.MetaTxParams != nil {\n\t\tsponsorRefundAmount, selfRefundAmount := types.CalculateSponsorPercentAmount(st.msg.MetaTxParams, remaining)\n\t\tst.state.AddBalance(st.msg.MetaTxParams.GasFeeSponsor, sponsorRefundAmount)\n\t\tst.state.AddBalance(st.msg.From, selfRefundAmount)\n\t\tlog.Debug(\"RefundGas for metaTx\",\n\t\t\t\"sponsor\", st.msg.MetaTxParams.GasFeeSponsor.String(), \"refundAmount\", sponsorRefundAmount.String(),\n\t\t\t\"user\", st.msg.From.String(), \"refundAmount\", selfRefundAmount.String())\n\t} else {\n\t\tst.state.AddBalance(st.msg.From, remaining)\n\t}\n\n\t// Also return remaining gas to the block gas counter so it is\n\t// available for the next transaction.\n\tst.gp.AddGas(st.gasRemaining)\n}\n\n// gasUsed returns the amount of gas used up by the state transition.\nfunc (st *StateTransition) gasUsed() uint64 {\n\treturn st.initialGas - st.gasRemaining\n}\n\nfunc (st *StateTransition) mintBVMETH(ethValue *big.Int, rules params.Rules) {\n\tif !rules.IsMantleBVMETHMintUpgrade {\n\t\tvar key common.Hash\n\t\tvar ethRecipient common.Address\n\t\tif st.msg.To != nil {\n\t\t\tethRecipient = *st.msg.To\n\t\t} else {\n\t\t\tethRecipient = crypto.CreateAddress(st.msg.From, st.evm.StateDB.GetNonce(st.msg.From))\n\t\t}\n\t\tkey = getBVMETHBalanceKey(ethRecipient)\n\t\tvalue := st.state.GetState(BVM_ETH_ADDR, key)\n\t\tbal := value.Big()\n\t\tbal = bal.Add(bal, ethValue)\n\t\tst.state.SetState(BVM_ETH_ADDR, key, common.BigToHash(bal))\n\n\t\tst.addBVMETHTotalSupply(ethValue)\n\t\tst.generateBVMETHMintEvent(ethRecipient, ethValue)\n\t\treturn\n\t}\n\tkey := getBVMETHBalanceKey(st.msg.From)\n\tvalue := st.state.GetState(BVM_ETH_ADDR, key)\n\tbal := value.Big()\n\tbal = bal.Add(bal, ethValue)\n\tst.state.SetState(BVM_ETH_ADDR, key, common.BigToHash(bal))\n\n\tst.addBVMETHTotalSupply(ethValue)\n\tst.generateBVMETHMintEvent(st.msg.From, ethValue)\n}\n\nfunc (st *StateTransition) addBVMETHTotalSupply(ethValue *big.Int) {\n\tkey := getBVMETHTotalSupplyKey()\n\tvalue := st.state.GetState(BVM_ETH_ADDR, key)\n\tbal := value.Big()\n\tbal = bal.Add(bal, ethValue)\n\tst.state.SetState(BVM_ETH_ADDR, key, common.BigToHash(bal))\n}\n\nfunc (st *StateTransition) transferBVMETH(ethValue *big.Int, rules params.Rules) {\n\tif !rules.IsMantleBVMETHMintUpgrade {\n\t\treturn\n\t}\n\tvar ethRecipient common.Address\n\tif st.msg.To != nil {\n\t\tethRecipient = *st.msg.To\n\t} else {\n\t\tethRecipient = crypto.CreateAddress(st.msg.From, st.evm.StateDB.GetNonce(st.msg.From))\n\t}\n\tif ethRecipient == st.msg.From {\n\t\treturn\n\t}\n\n\tfromKey := getBVMETHBalanceKey(st.msg.From)\n\ttoKey := getBVMETHBalanceKey(ethRecipient)\n\n\tfromBalanceValue := st.state.GetState(BVM_ETH_ADDR, fromKey)\n\ttoBalanceValue := st.state.GetState(BVM_ETH_ADDR, toKey)\n\n\tfromBalance := fromBalanceValue.Big()\n\ttoBalance := toBalanceValue.Big()\n\n\tfromBalance = new(big.Int).Sub(fromBalance, ethValue)\n\ttoBalance = new(big.Int).Add(toBalance, ethValue)\n\n\tst.state.SetState(BVM_ETH_ADDR, fromKey, common.BigToHash(fromBalance))\n\tst.state.SetState(BVM_ETH_ADDR, toKey, common.BigToHash(toBalance))\n\n\tst.generateBVMETHTransferEvent(st.msg.From, ethRecipient, ethValue)\n}\n\nfunc getBVMETHBalanceKey(addr common.Address) common.Hash {\n\tposition := common.Big0\n\thasher := sha3.NewLegacyKeccak256()\n\thasher.Write(common.LeftPadBytes(addr.Bytes(), 32))\n\thasher.Write(common.LeftPadBytes(position.Bytes(), 32))\n\tdigest := hasher.Sum(nil)\n\treturn common.BytesToHash(digest)\n}\n\nfunc getBVMETHTotalSupplyKey() common.Hash {\n\treturn common.BytesToHash(common.Big2.Bytes())\n}\n\nfunc (st *StateTransition) generateBVMETHMintEvent(mintAddress common.Address, mintValue *big.Int) {\n\t// keccak(\"Mint(address,uint256)\") = \"0x0f6798a560793a54c3bcfe86a93cde1e73087d944c0ea20544137d4121396885\"\n\tmethodHash := common.HexToHash(\"0x0f6798a560793a54c3bcfe86a93cde1e73087d944c0ea20544137d4121396885\")\n\ttopics := make([]common.Hash, 2)\n\ttopics[0] = methodHash\n\ttopics[1] = mintAddress.Hash()\n\t//data means the mint amount in MINT EVENT.\n\td := common.HexToHash(common.Bytes2Hex(mintValue.Bytes())).Bytes()\n\tst.evm.StateDB.AddLog(&types.Log{\n\t\tAddress: BVM_ETH_ADDR,\n\t\tTopics:  topics,\n\t\tData:    d,\n\t\t// This is a non-consensus field, but assigned here because\n\t\t// core/state doesn't know the current block number.\n\t\tBlockNumber: st.evm.Context.BlockNumber.Uint64(),\n\t})\n}\n\nfunc (st *StateTransition) generateBVMETHTransferEvent(from, to common.Address, amount *big.Int) {\n\t// keccak(\"Transfer(address,address,uint256)\") = \"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\"\n\tmethodHash := common.HexToHash(\"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\")\n\ttopics := make([]common.Hash, 3)\n\ttopics[0] = methodHash\n\ttopics[1] = from.Hash()\n\ttopics[2] = to.Hash()\n\t//data means the transfer amount in Transfer EVENT.\n\tdata := common.HexToHash(common.Bytes2Hex(amount.Bytes())).Bytes()\n\tst.evm.StateDB.AddLog(&types.Log{\n\t\tAddress: BVM_ETH_ADDR,\n\t\tTopics:  topics,\n\t\tData:    data,\n\t\t// This is a non-consensus field, but assigned here because\n\t\t// core/state doesn't know the current block number.\n\t\tBlockNumber: st.evm.Context.BlockNumber.Uint64(),\n\t})\n}"
    },
    {
      "filename": "core/state_transition.go",
      "content": "// Copyright 2014 The go-ethereum Authors\n// This file is part of the go-ethereum library.\n//\n// The go-ethereum library is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// The go-ethereum library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.\n\npackage core\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"math/big\"\n\n\t\"github.com/ethereum/go-ethereum/common\"\n\tcmath \"github.com/ethereum/go-ethereum/common/math\"\n\t\"github.com/ethereum/go-ethereum/core/types\"\n\t\"github.com/ethereum/go-ethereum/core/vm\"\n\t\"github.com/ethereum/go-ethereum/crypto\"\n\t\"github.com/ethereum/go-ethereum/log\"\n\t\"github.com/ethereum/go-ethereum/params\"\n\t\"golang.org/x/crypto/sha3\"\n)\n\nvar (\n\tBVM_ETH_ADDR = common.HexToAddress(\"0xdEAddEaDdeadDEadDEADDEAddEADDEAddead1111\")\n)\n\n// ExecutionResult includes all output after executing given evm\n// message no matter the execution itself is successful or not.\ntype ExecutionResult struct {\n\tUsedGas    uint64 // Total used gas but include the refunded gas\n\tErr        error  // Any error encountered during the execution(listed in core/vm/errors.go)\n\tReturnData []byte // Returned data from evm(function result or data supplied with revert opcode)\n}\n\n// Unwrap returns the internal evm error which allows us for further\n// analysis outside.\nfunc (result *ExecutionResult) Unwrap() error {\n\treturn result.Err\n}\n\n// Failed returns the indicator whether the execution is successful or not\nfunc (result *ExecutionResult) Failed() bool { return result.Err != nil }\n\n// Return is a helper function to help caller distinguish between revert reason\n// and function return. Return returns the data after execution if no error occurs.\nfunc (result *ExecutionResult) Return() []byte {\n\tif result.Err != nil {\n\t\treturn nil\n\t}\n\treturn common.CopyBytes(result.ReturnData)\n}\n\n// Revert returns the concrete revert reason if the execution is aborted by `REVERT`\n// opcode. Note the reason can be nil if no data supplied with revert opcode.\nfunc (result *ExecutionResult) Revert() []byte {\n\tif result.Err != vm.ErrExecutionReverted {\n\t\treturn nil\n\t}\n\treturn common.CopyBytes(result.ReturnData)\n}\n\n// IntrinsicGas computes the"
    }
  ]
}