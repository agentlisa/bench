{
  "Title": "M-5: Extraordinary proposals can receive more tokens than eligible",
  "Content": "# Issue M-5: Extraordinary proposals can receive more tokens than eligible \n\nSource: https://github.com/sherlock-audit/2023-01-ajna-judging/issues/124 \n\n## Found by \nberndartmueller\n\n## Summary\n\nTwo extraordinary proposals proposed at similar times (while no other extraordinary proposals are executed) can request the same amount of tokens (`proposal.tokensRequested`). But if the second proposal is proposed **after** the first proposal is successfully funded and executed, the second proposal could not request the same amount of tokens. It would have to be lower due to `ExtraordinaryFunding.sol#L86`.\n\n## Vulnerability Detail\n\nProposing an extraordinary funding proposal with the `ExtraordinaryFunding.proposeExtraordinary` function verifies that the requested token amount is within (less than) a certain limit in `ExtraordinaryFunding.sol#L86`. The limit is based on the treasury Ajna token balance and decreases with an increasing number of funded extraordinary proposals. A maximum number of **10** extraordinary proposals can be funded.\n\nIf multiple extraordinary proposals are proposed while the number of funded proposals is unchanged, the limit for the tokens requested is the same for those proposals. At a later time, if those proposals pass voting, the proposals are executed and receive the requested (stale) token amount.\n\n## Impact\n\nThe requested token amount of an extraordinary proposal is not checked when executing if it's within the same limits imposed by L86.\n\nIf another extraordinary proposal was successfully funded and executed in the meantime of the 1 month voting period for the proposal, the limit for the requested token amount is already lower than the `proposal.tokensRequested` amount.\n\nThis means that if multiple extraordinary proposals are proposed at a similar time and pass voting, the `tokensRequested` amount is stale and potentially too much.\n\n## Code Snippet\n\n[ecosystem-coordination/src/grants/base/ExtraordinaryFunding.sol#L86](https://github.com/sherlock-audit/2023-01-ajna/blob/main/ecosystem-coordination/src/grants/base/ExtraordinaryFunding.sol#L86)\n\n```solidity\n067: function proposeExtraordinary(\n068:     uint256 endBlock_,\n069:     address[] memory targets_,\n070:     uint256[] memory values_,\n071:     bytes[] memory calldatas_,\n072:     string memory description_) external returns (uint256 proposalId_) {\n073:\n074:     proposalId_ = hashProposal(targets_, values_, calldatas_, keccak256(bytes(description_)));\n075:\n076:     if (extraordinaryFundingProposals[proposalId_].proposalId != 0) revert ProposalAlreadyExists();\n077:\n078:     // check proposal length is within limits of 1 month maximum and it hasn't already been submitted\n079:     if (block.number + MAX_EFM_PROPOSAL_LENGTH < endBlock_ || extraordinaryFundingProposals[proposalId_].proposalId != 0) {\n080:         revert ExtraordinaryFundingProposalInvalid();\n081:     }\n082:\n083:     uint256 totalTokensRequested = _validateCallDatas(targets_, values_, calldatas_);\n084:\n085:     // check tokens requested is within limits\n086:     if (totalTokensRequested > getSliceOfTreasury(Maths.WAD - _getMinimumThresholdPercentage())) revert ExtraordinaryFundingProposalInvalid();\n087:\n088:     // store newly created proposal\n089:     ExtraordinaryFundingProposal storage newProposal = extraordinaryFundingProposals[proposalId_];\n090:     newProposal.proposalId      = proposalId_;\n091:     newProposal.startBlock      = block.number;\n092:     newProposal.endBlock        = endBlock_;\n093:     newProposal.tokensRequested = totalTokensRequested;\n094:\n095:     emit ProposalCreated(\n096:         proposalId_,\n097:         msg.sender,\n098:         targets_,\n099:         values_,\n100:         new string[](targets_.length),\n101:         calldatas_,\n102:         block.number,\n103:         endBlock_,\n104:         description_);\n105: }\n106:\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider re-checking the `tokensRequested` amount when executing an extraordinary proposal and make sure it's within the same or similar limits as when proposing.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/32",
  "Code": [
    {
      "filename": "ecosystem-coordination/src/grants/base/ExtraordinaryFunding.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport { IERC20 } from \"@oz/token/ERC20/IERC20.sol\";\n\nimport { Funding } from \"./Funding.sol\";\n\nimport { IExtraordinaryFunding } from \"../interfaces/IExtraordinaryFunding.sol\";\n\nimport { Maths } from \"../libraries/Maths.sol\";\n\nabstract contract ExtraordinaryFunding is Funding, IExtraordinaryFunding {\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    /**\n     * @notice Mapping of extant extraordinary funding proposals.\n     * @dev proposalId => ExtraordinaryFundingProposal.\n     */\n    mapping (uint256 => ExtraordinaryFundingProposal) internal extraordinaryFundingProposals;\n\n    /**\n     * @notice The list of extraordinary funding proposalIds that have been executed.\n     */\n    uint256[] internal fundedExtraordinaryProposals;\n\n    /**\n     * @notice The maximum length of a proposal's voting period, in blocks.\n     */\n    uint256 internal constant MAX_EFM_PROPOSAL_LENGTH = 216_000; // number of blocks in one month\n\n    /**************************/\n    /*** Proposal Functions ***/\n    /**************************/\n\n    /// @inheritdoc IExtraordinaryFunding\n    function executeExtraordinary(address[] memory targets_, uint256[] memory values_, bytes[] memory calldatas_, bytes32 descriptionHash_) external nonReentrant returns (uint256 proposalId_) {\n        proposalId_ = hashProposal(targets_, values_, calldatas_, descriptionHash_);\n\n        ExtraordinaryFundingProposal storage proposal = extraordinaryFundingProposals[proposalId_];\n\n        if (proposal.executed) {\n            revert ExecuteExtraordinaryProposalInvalid();\n        }\n\n        // check if the proposal has received more votes than minimumThreshold and tokensRequestedPercentage of all tokens\n        if (proposal.votesReceived >= proposal.tokensRequested + getSliceOfNonTreasury(_getMinimumThresholdPercentage())) {\n            proposal.succeeded = true;\n        } else {\n            proposal.succeeded = false;\n            revert ExecuteExtraordinaryProposalInvalid();\n        }\n\n        fundedExtraordinaryProposals.push(proposal.proposalId);\n\n        super.execute(targets_, values_, calldatas_, descriptionHash_);\n        proposal.executed = true;\n\n        // update treasury\n        treasury -= proposal.tokensRequested;\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function proposeExtraordinary(\n        uint256 endBlock_,\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        string memory description_) external returns (uint256 proposalId_) {\n\n        proposalId_ = hashProposal(targets_, values_, calldatas_, keccak256(bytes(description_)));\n\n        if (extraordinaryFundingProposals[proposalId_].proposalId != 0) revert ProposalAlreadyExists();\n\n        // check proposal length is within limits of 1 month maximum and it hasn't already been submitted\n        if (block.number + MAX_EFM_PROPOSAL_LENGTH < endBlock_ || extraordinaryFundingProposals[proposalId_].proposalId != 0) {\n            revert ExtraordinaryFundingProposalInvalid();\n        }\n\n        uint256 totalTokensRequested = _validateCallDatas(targets_, values_, calldatas_);\n\n        // check tokens requested is within limits\n        if (totalTokensRequested > getSliceOfTreasury(Maths.WAD - _getMinimumThresholdPercentage())) revert ExtraordinaryFundingProposalInvalid();\n\n        // store newly created proposal\n        ExtraordinaryFundingProposal storage newProposal = extraordinaryFundingProposals[proposalId_];\n        newProposal.proposalId      = proposalId_;\n        newProposal.startBlock      = block.number;\n        newProposal.endBlock        = endBlock_;\n        newProposal.tokensRequested = totalTokensRequested;\n\n        emit ProposalCreated(\n            proposalId_,\n            msg.sender,\n            targets_,\n            values_,\n            new string[](targets_.length),\n            calldatas_,\n            block.number,\n            endBlock_,\n            description_);\n    }\n\n    /************************/\n    /*** Voting Functions ***/\n    /************************/\n\n    /**\n     * @notice Vote on a proposal for extraordinary funding.\n     * @dev    Votes can only be cast affirmatively, or not cast at all.\n     * @param  proposalId_ The ID of the current proposal being voted upon.\n     * @param  account_    The voting account.\n     * @return votes_      The amount of votes cast.\n     */\n    function _extraordinaryFundingVote(uint256 proposalId_, address account_) internal returns (uint256 votes_) {\n        if (hasVotedExtraordinary[proposalId_][account_]) revert AlreadyVoted();\n\n        ExtraordinaryFundingProposal storage proposal = extraordinaryFundingProposals[proposalId_];\n\n        if (proposal.startBlock > block.number || proposal.endBlock < block.number || proposal.executed) {\n            revert ExtraordinaryFundingProposalInactive();\n        }\n\n        // check voting power at snapshot block\n        votes_ = _getVotes(account_, block.number, abi.encode(proposalId_));\n        proposal.votesReceived += votes_;\n\n        // record that voter has voted on this extraorindary funding proposal\n        hasVotedExtraordinary[proposalId_][account_] = true;\n\n        emit VoteCast(account_, proposalId_, 1, votes_, \"\");\n    }\n\n    /**\n     * @notice Check if a proposal for extraordinary funding has succeeded.\n     * @param  proposalId_ The ID of the proposal being checked.\n     * @return             Boolean indicating whether the proposal has succeeded.\n     */\n    function _extraordinaryFundingVoteSucceeded(uint256 proposalId_) internal view returns (bool) {\n        return extraordinaryFundingProposals[proposalId_].succeeded;\n    }\n\n    /***********************/\n    /*** View Functions ****/\n    /***********************/\n\n    function _getMinimumThresholdPercentage() internal view returns (uint256) {\n        // default minimum threshold is 50\n        if (fundedExtraordinaryProposals.length == 0) {\n            return 0.5 * 1e18;\n        }\n        // minimum threshold increases according to the number of funded EFM proposals\n        else {\n            return 0.5 * 1e18 + (fundedExtraordinaryProposals.length * (0.05 * 1e18));\n        }\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function getMinimumThresholdPercentage() external view returns (uint256) {\n        return _getMinimumThresholdPercentage();\n    }\n\n    /**\n     * @notice Get the number of ajna tokens equivalent to a given percentage.\n     * @param percentage_ The percentage of the Non treasury to retrieve, in WAD.\n     * @return The number of tokens, in WAD.\n     */\n    function getSliceOfNonTreasury(uint256 percentage_) public view returns (uint256) {\n        uint256 totalAjnaSupply = IERC20(ajnaTokenAddress).totalSupply();\n        return Maths.wmul(totalAjnaSupply - treasury, percentage_);\n    }\n\n    /**\n     * @notice Get the number of ajna tokens equivalent to a given percentage.\n     * @param percentage_ The percentage of the treasury to retrieve, in WAD.\n     * @return The number of tokens, in WAD.\n     */\n    function getSliceOfTreasury(uint256 percentage_) public view returns (uint256) {\n        return Maths.wmul(treasury, percentage_);\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function getExtraordinaryProposalInfo(uint256 proposalId_) external view returns (uint256, uint256, uint256, uint256, uint256, bool, bool) {\n        ExtraordinaryFundingProposal memory proposal = extraordinaryFundingProposals[proposalId_];\n        return (\n            proposal.proposalId,\n            proposal.tokensRequested,\n            proposal.startBlock,\n            proposal.endBlock,\n            proposal.votesReceived,\n            proposal.succeeded,\n            proposal.executed\n        );\n    }\n\n}"
    }
  ]
}