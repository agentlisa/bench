{
  "Title": "[H-04] Incorrect solvency check because it multiplies collateralizationRate by share not amount when calculating liquidation threshold",
  "Content": "\nWhen a Collateralized Debt Position (CDP) reaches that liquidation threshold, it becomes eligible for liquidation and anyone can repay a position in exchange for a portion of the collateral.\n`Market._isSolvent` is used to check if the user is solvent. if not, then it can be liquidated. Here is the method body:\n\n    function _isSolvent(\n    \taddress user,\n    \tuint256 _exchangeRate\n    ) internal view returns (bool) {\n    \t// accrue must have already been called!\n    \tuint256 borrowPart = userBorrowPart[user];\n    \tif (borrowPart == 0) return true;\n    \tuint256 collateralShare = userCollateralShare[user];\n    \tif (collateralShare == 0) return false;\n\n    \tRebase memory _totalBorrow = totalBorrow;\n\n    \treturn\n    \t\tyieldBox.toAmount(\n    \t\t\tcollateralId,\n    \t\t\tcollateralShare *\n    \t\t\t\t(EXCHANGE_RATE_PRECISION / FEE_PRECISION) *\n    \t\t\t\tcollateralizationRate,\n    \t\t\tfalse\n    \t\t) >=\n    \t\t// Moved exchangeRate here instead of dividing the other side to preserve more precision\n    \t\t(borrowPart * _totalBorrow.elastic * _exchangeRate) /\n    \t\t\t_totalBorrow.base;\n    }\n\n[Code link](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/Market.sol#L402C1-L425C6)\n\nThe issue is that the collateralizationRate is multiplied by collateralShare (with precision constants) then converted to amount. This is incorrect, **the collateralizationRate sholud be used with amounts and not shares. Otherwise, we get wrong results**.\n\n```solidity\nyieldBox.toAmount(\n\t\t\tcollateralId,\n\t\t\tcollateralShare *\n\t\t\t\t(EXCHANGE_RATE_PRECISION / FEE_PRECISION) *\n\t\t\t\tcollateralizationRate,\n\t\t\tfalse\n\t\t)\n```\n\nPlease note that when using shares **it is not in favour of the protocol**, so amounts should be used instead. The only case where this is ok, is when the share/amount ratio is 1:1 which can not be, because totalAmount always get +1 and totalShares +1e8 to prevent 1:1 ratio type of attack.\n\n```solidity\n    function _toAmount(\n        uint256 share,\n        uint256 totalShares_,\n        uint256 totalAmount,\n        bool roundUp\n    ) internal pure returns (uint256 amount) {\n        // To prevent reseting the ratio due to withdrawal of all shares, we start with\n        // 1 amount/1e8 shares already burned. This also starts with a 1 : 1e8 ratio which\n        // functions like 8 decimal fixed point math. This prevents ratio attacks or inaccuracy\n        // due to 'gifting' or rebasing tokens. (Up to a certain degree)\n        totalAmount++;\n        totalShares_ += 1e8;\n\n```\n\n[Code link](https://github.com/Tapioca-DAO/YieldBox/blob/f5ad271b2dcab8b643b7cf622c2d6a128e109999/contracts/YieldBoxRebase.sol#L47-L52)\n\nMoreover, in the method `_computeMaxAndMinLTVInAsset` which is supposed to returns the min and max LTV for user in asset price. Amount is used and not share. Here is the code:\n\n    \tfunction _computeMaxAndMinLTVInAsset(\n    \t\tuint256 collateralShare,\n    \t\tuint256 _exchangeRate\n    \t) internal view returns (uint256 min, uint256 max) {\n    \t\tuint256 collateralAmount = yieldBox.toAmount(\n    \t\t\tcollateralId,\n    \t\t\tcollateralShare,\n    \t\t\tfalse\n    \t\t);\n\n    \t\tmax = (collateralAmount * EXCHANGE_RATE_PRECISION) / _exchangeRate;\n    \t\tmin = (max * collateralizationRate) / FEE_PRECISION;\n    \t}\n\n[Code Link](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/Market.sol#L428-L440)\n\nI've set this to high severity because solvency check is a crucial part of the protocol. In short, we have :\n\n1.  Inconsistency across the protocol\n2.  Inaccuracy of calculating the liquidation threshold\n3.  Not in favour of the protocol\n\nNote: this is also applicable for ohter methods. For example, `Market._computeMaxBorrowableAmount`.\n\n### Proof of Concept\n\n*   When you run the PoC below, you will get the following results:\n\n```sh\n[PASS] test_borrow_repay() (gas: 118001)\nLogs:\n  ===BORROW===\n  UserBorrowPart: 745372500000000000000\n  Total Borrow Base: 745372500000000000000\n  Total Borrow Elastic: 745372500000000000000\n  ===356 days passed===\n  Total Borrow Elastic: 749089151896269477984\n  ===Solvency#1 => multiply by share===\n  A: 749999999999925000000750007499999924999\n  B: 749089151896269477984000000000000000000\n  ===Solvency#2 => multiply by amount===\n  A: 749999999999925000000750000000000000000\n  B: 749089151896269477984000000000000000000\n  ===Result===\n  Solvency#1.A != Solvency#2.A\n\nTest result: ok. 1 passed; 0 failed; finished in 16.69ms\n```\n\nAs you can see, numbers are not equal, and when using shares it is not in favour of the protocol, so amount should be used instead.\n\n*   Code: Please note some lines in borrow method were commented out for simplicity. It is irrelevant anyway.\n*   `_toAmount` copied from YieldBoxRebase\n\n<details>\n\n```solidity\n// PoC => BIGBANG - Solvency Check Inaccuracy\n// Command => forge test -vv\npragma solidity >=0.8.4 <0.9.0;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport \"forge-std/console.sol\";\n\nimport {DSTest} from \"ds-test/test.sol\";\nstruct AccrueInfo {\n    uint64 debtRate;\n    uint64 lastAccrued;\n}\n\nstruct Rebase {\n    uint128 elastic;\n    uint128 base;\n}\n\n/// @notice A rebasing library using overflow-/underflow-safe math.\nlibrary RebaseLibrary {\n    /// @notice Calculates the base value in relationship to `elastic` and `total`.\n    function toBase(\n        Rebase memory total,\n        uint256 elastic,\n        bool roundUp\n    ) internal pure returns (uint256 base) {\n        if (total.elastic == 0) {\n            base = elastic;\n        } else {\n            base = (elastic * total.base) / total.elastic;\n            if (roundUp && (base * total.elastic) / total.base < elastic) {\n                base++;\n            }\n        }\n    }\n\n    /// @notice Calculates the elastic value in relationship to `base` and `total`.\n    function toElastic(\n        Rebase memory total,\n        uint256 base,\n        bool roundUp\n    ) internal pure returns (uint256 elastic) {\n        if (total.base == 0) {\n            elastic = base;\n        } else {\n            elastic = (base * total.elastic) / total.base;\n            if (roundUp && (elastic * total.base) / total.elastic < base) {\n                elastic++;\n            }\n        }\n    }\n\n    /// @notice Add `elastic` to `total` and doubles `total.base`.\n    /// @return (Rebase) The new total.\n    /// @return base in relationship to `elastic`.\n    function add(\n        Rebase memory total,\n        uint256 elastic,\n        bool roundUp\n    ) internal pure returns (Rebase memory, uint256 base) {\n        base = toBase(total, elastic, roundUp);\n        total.elastic += uint128(elastic);\n        total.base += uint128(base);\n        return (total, base);\n    }\n\n    /// @notice Sub `base` from `total` and update `total.elastic`.\n    /// @return (Rebase) The new total.\n    /// @return elastic in relationship to `base`.\n    function sub(\n        Rebase memory total,\n        uint256 base,\n        bool roundUp\n    ) internal pure returns (Rebase memory, uint256 elastic) {\n        elastic = toElastic(total, base, roundUp);\n        total.elastic -= uint128(elastic);\n        total.base -= uint128(base);\n        return (total, elastic);\n    }\n\n    /// @notice Add `elastic` and `base` to `total`.\n    function add(\n        Rebase memory total,\n        uint256 elastic,\n        uint256 base\n    ) internal pure returns (Rebase memory) {\n        total.elastic += uint128(elastic);\n        total.base += uint128(base);\n        return total;\n    }\n\n    /// @notice Subtract `elastic` and `base` to `total`.\n    function sub(\n        Rebase memory total,\n        uint256 elastic,\n        uint256 base\n    ) internal pure returns (Rebase memory) {\n        total.elastic -= uint128(elastic);\n        total.base -= uint128(base);\n        return total;\n    }\n\n    /// @notice Add `elastic` to `total` and update storage.\n    /// @return newElastic Returns updated `elastic`.\n    function addElastic(\n        Rebase storage total,\n        uint256 elastic\n    ) internal returns (uint256 newElastic) {\n        newElastic = total.elastic += uint128(elastic);\n    }\n\n    /// @notice Subtract `elastic` from `total` and update storage.\n    /// @return newElastic Returns updated `elastic`.\n    function subElastic(\n        Rebase storage total,\n        uint256 elastic\n    ) internal returns (uint256 newElastic) {\n        newElastic = total.elastic -= uint128(elastic);\n    }\n}\n\ncontract BIGBANG_MOCK {\n    using RebaseLibrary for Rebase;\n    uint256 public collateralizationRate = 75000; // 75% // made public to access it from test contract\n    uint256 public liquidationMultiplier = 12000; //12%\n    uint256 public constant FEE_PRECISION = 1e5; // made public to access it from test contract\n    uint256 public EXCHANGE_RATE_PRECISION = 1e18; //made public to access it from test contract\n\n    uint256 public borrowOpeningFee = 50; //0.05%\n    Rebase public totalBorrow;\n    uint256 public totalBorrowCap;\n    AccrueInfo public accrueInfo;\n\n    /// @notice borrow amount per user\n    mapping(address => uint256) public userBorrowPart;\n\n    uint256 public USDO_balance; // just to track USDO balance of BigBang\n\n    function _accrue() public {\n        // made public so we can call it from the test contract\n        AccrueInfo memory _accrueInfo = accrueInfo;\n        // Number of seconds since accrue was called\n        uint256 elapsedTime = block.timestamp - _accrueInfo.lastAccrued;\n        if (elapsedTime == 0) {\n            return;\n        }\n        //update debt rate // for simplicity we return bigBangEthDebtRate which is 5e15\n        uint256 annumDebtRate = 5e15; // getDebtRate(); // 5e15 for eth. Check Penrose.sol Line:131\n        _accrueInfo.debtRate = uint64(annumDebtRate / 31536000); //per second\n\n        _accrueInfo.lastAccrued = uint64(block.timestamp);\n\n        Rebase memory _totalBorrow = totalBorrow;\n\n        uint256 extraAmount = 0;\n\n        // Calculate fees\n        extraAmount =\n            (uint256(_totalBorrow.elastic) *\n                _accrueInfo.debtRate *\n                elapsedTime) /\n            1e18;\n        _totalBorrow.elastic += uint128(extraAmount);\n\n        totalBorrow = _totalBorrow;\n        accrueInfo = _accrueInfo;\n\n        // emit LogAccrue(extraAmount, _accrueInfo.debtRate); // commented out since it irrelevant\n    }\n\n    function totalBorrowElastic() public view returns (uint128) {\n        return totalBorrow.elastic;\n    }\n\n    function totalBorrowBase() public view returns (uint128) {\n        return totalBorrow.base;\n    }\n\n    function _borrow(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (uint256 part, uint256 share) {\n        uint256 feeAmount = (amount * borrowOpeningFee) / FEE_PRECISION; // A flat % fee is charged for any borrow\n\n        (totalBorrow, part) = totalBorrow.add(amount + feeAmount, true);\n        require(\n            totalBorrowCap == 0 || totalBorrow.elastic <= totalBorrowCap,\n            \"BigBang: borrow cap reached\"\n        );\n\n        userBorrowPart[from] += part; // toBase from RebaseLibrary. userBorrowPart stores the sharee\n\n        //mint USDO\n        // IUSDOBase(address(asset)).mint(address(this), amount); // not needed\n        USDO_balance += amount;\n\n        //deposit borrowed amount to user\n        // asset.approve(address(yieldBox), amount);  // not needed\n        // yieldBox.depositAsset(assetId, address(this), to, amount, 0); // not needed\n        USDO_balance -= amount;\n\n        // share = yieldBox.toShare(assetId, amount, false); // not needed\n\n        // emit LogBorrow(from, to, amount, feeAmount, part); // not needed\n    }\n\n    // copied from YieldBoxRebase\n    function _toAmount(\n        uint256 share,\n        uint256 totalShares_,\n        uint256 totalAmount,\n        bool roundUp\n    ) external pure returns (uint256 amount) {\n        // To prevent reseting the ratio due to withdrawal of all shares, we start with\n        // 1 amount/1e8 shares already burned. This also starts with a 1 : 1e8 ratio which\n        // functions like 8 decimal fixed point math. This prevents ratio attacks or inaccuracy\n        // due to 'gifting' or rebasing tokens. (Up to a certain degree)\n        totalAmount++;\n        totalShares_ += 1e8;\n\n        // Calculte the amount using te current amount to share ratio\n        amount = (share * totalAmount) / totalShares_;\n\n        // Default is to round down (Solidity), round up if required\n        if (roundUp && (amount * totalShares_) / totalAmount < share) {\n            amount++;\n        }\n    }\n}\n\ncontract BIGBANG_ISSUES is DSTest, Test {\n    BIGBANG_MOCK bigbangMock;\n    address bob;\n\n    function setUp() public {\n        bigbangMock = new BIGBANG_MOCK();\n        bob = vm.addr(1);\n    }\n\n    function test_borrow_repay() public {\n        // borrow\n        uint256 amount = 745e18;\n\n        vm.warp(1 days);\n        bigbangMock._accrue(); // acrrue before borrow (this is done on borrow)\n\n        bigbangMock._borrow(bob, address(0), amount);\n        console.log(\"===BORROW===\");\n        // console.log(\"Amount: %d\", amount);\n        console.log(\"UserBorrowPart: %d\", bigbangMock.userBorrowPart(bob));\n        console.log(\"Total Borrow Base: %d\", bigbangMock.totalBorrowBase());\n        console.log(\n            \"Total Borrow Elastic: %d\",\n            bigbangMock.totalBorrowElastic()\n        );\n\n        // time elapsed\n        vm.warp(365 days);\n        console.log(\"===356 days passed===\");\n        bigbangMock._accrue();\n        console.log(\n            \"Total Borrow Elastic: %d\",\n            bigbangMock.totalBorrowElastic()\n        ); \n\n        // Check Insolvency\n\n        uint256 _exchangeRate = 1e18;\n        uint256 collateralShare = 1000e18;\n        uint256 totalShares = 1000e18;\n        uint256 totalAmount = 1000e18;\n        uint256 EXCHANGE_RATE_PRECISION = bigbangMock.EXCHANGE_RATE_PRECISION();\n        uint256 FEE_PRECISION = bigbangMock.FEE_PRECISION();\n        uint256 collateralizationRate = bigbangMock.collateralizationRate();\n\n        uint256 borrowPart = bigbangMock.userBorrowPart(bob);\n        uint256 _totalBorrowElastic = bigbangMock.totalBorrowElastic();\n        uint256 _totalBorrowBase = bigbangMock.totalBorrowBase();\n\n\n\n        console.log(\"===Solvency#1 => multiply by share===\");\n        // we pass totalShares and totalAmount\n        uint256 A = bigbangMock._toAmount(\n            collateralShare *\n                (EXCHANGE_RATE_PRECISION / FEE_PRECISION) *\n                collateralizationRate,\n            totalShares,\n            totalAmount,\n            false\n        );\n\n        // Moved exchangeRate here instead of dividing the other side to preserve more precision\n        uint256 B = (borrowPart * _totalBorrowElastic * _exchangeRate) /\n            _totalBorrowBase;\n\n        // bool isSolvent = A >= B;\n\n        console.log(\"A: %d\", A);\n        console.log(\"B: %d\", B);\n\n\n        console.log(\"===Solvency#2 => multiply by amount===\");\n\n        A =\n            bigbangMock._toAmount(\n                collateralShare,\n                totalShares,\n                totalAmount,\n                false\n            ) *\n            (EXCHANGE_RATE_PRECISION / FEE_PRECISION) *\n            collateralizationRate;\n\n        // Moved exchangeRate here instead of dividing the other side to preserve more precision\n        B =\n            (borrowPart * _totalBorrowElastic * _exchangeRate) /\n            _totalBorrowBase;\n\n        // isSolvent = A >= B;\n\n        console.log(\"A: %d\", A);\n        console.log(\"B: %d\", B);\n\n\n        console.log(\"===Result===\");\n        console.log(\"Solvency#1.A != Solvency#2.A\");\n\n    }\n}\n```\n\n</details>\n\n### Recommended Mitigation Steps\n\nUse amount for calculation instead of shares. Check the PoC as it demonstrates such an example.\n\n**[0xRektora (sponsor) confirmed](https://github.com/code-423n4/2023-07-tapioca-findings/issues/1582#issuecomment-1703067281)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-07-tapioca",
  "Code": [
    {
      "filename": "contracts/markets/Market.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\n\nimport \"tapioca-sdk/dist/contracts/YieldBox/contracts/YieldBox.sol\";\nimport \"tapioca-periph/contracts/interfaces/IOracle.sol\";\nimport \"tapioca-periph/contracts/interfaces/IPenrose.sol\";\nimport \"./MarketERC20.sol\";\n\n/// @title Market contract\n/// @notice Market contract implemented by Singularity & BigBang\nabstract contract Market is MarketERC20, BoringOwnable {\n    using RebaseLibrary for Rebase;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    /// @notice returns YieldBox address\n    YieldBox public yieldBox;\n    /// @notice returns Penrose address\n    IPenrose public penrose;\n\n    /// @notice collateral token address\n    IERC20 public collateral;\n    /// @notice collateral token YieldBox id\n    uint256 public collateralId;\n    /// @notice asset token address\n    IERC20 public asset;\n    /// @notice asset token YieldBox id\n    uint256 public assetId;\n\n    /// @notice contract's pause state\n    bool public paused;\n    /// @notice conservator's addresss\n    /// @dev conservator can pause/unpause the contract\n    address public conservator;\n\n    /// @notice oracle address\n    IOracle public oracle;\n    /// @notice oracleData\n    bytes public oracleData;\n    /// @notice Exchange and interest rate tracking.\n    /// This is 'cached' here because calls to Oracles can be very expensive.\n    /// Asset -> collateral = assetAmount * exchangeRate.\n    uint256 public exchangeRate;\n\n    /// @notice total amount borrowed\n    /// @dev elastic = Total token amount to be repayed by borrowers, base = Total parts of the debt held by borrowers\n    Rebase public totalBorrow;\n    /// @notice total collateral supplied\n    uint256 public totalCollateralShare;\n    /// @notice max borrow cap\n    uint256 public totalBorrowCap;\n    /// @notice borrow amount per user\n    mapping(address => uint256) public userBorrowPart;\n    /// @notice collateral share per user\n    mapping(address => uint256) public userCollateralShare;\n\n    /// @notice liquidation caller rewards\n    uint256 public callerFee; // 90%\n    /// @notice liquidation protocol rewards\n    uint256 public protocolFee; // 10%\n    /// @notice min % a liquidator can receive in rewards\n    uint256 public minLiquidatorReward = 1e3; //1%\n    /// @notice max % a liquidator can receive in rewards\n    uint256 public maxLiquidatorReward = 1e4; //10%\n    /// @notice max liquidatable bonus amount\n    /// @dev max % added to the amount that can be liquidated\n    uint256 public liquidationBonusAmount = 1e4; //10%\n    /// @notice collateralization rate\n    uint256 public collateralizationRate; // 75%\n    /// @notice borrowing opening fee\n    uint256 public borrowOpeningFee = 50; //0.05%\n    /// @notice liquidation multiplier used to compute liquidator rewards\n    uint256 public liquidationMultiplier = 12000; //12%\n\n    // ***************** //\n    // *** CONSTANTS *** //\n    // ***************** //\n    uint256 internal EXCHANGE_RATE_PRECISION; //not costant, but can only be set in the 'init' method\n    uint256 internal constant FEE_PRECISION = 1e5;\n    uint256 internal constant FEE_PRECISION_DECIMALS = 5;\n\n    // ************** //\n    // *** EVENTS *** //\n    // ************** //\n    /// @notice event emitted when conservator is updated\n    event ConservatorUpdated(address indexed old, address indexed _new);\n    /// @notice event emitted when pause state is changed\n    event PausedUpdated(bool oldState, bool newState);\n    /// @notice event emitted when cached exchange rate is updated\n    event LogExchangeRate(uint256 rate);\n    /// @notice event emitted when borrow cap is updated\n    event LogBorrowCapUpdated(uint256 _oldVal, uint256 _newVal);\n    /// @notice event emitted when oracle data is updated\n    event OracleDataUpdated();\n    /// @notice event emitted when oracle is updated\n    event OracleUpdated();\n    /// @notice event emitted when a position is liquidated\n    event Liquidated(\n        address liquidator,\n        address[] users,\n        uint256 liquidatorReward,\n        uint256 protocolReward,\n        uint256 repayedAmount,\n        uint256 collateralShareRemoved\n    );\n    /// @notice event emitted when borrow opening fee is updated\n    event LogBorrowingFee(uint256 _oldVal, uint256 _newVal);\n    /// @notice event emitted when the liquidation multiplier rate is updated\n    event LiquidationMultiplierUpdated(uint256 oldVal, uint256 newVal);\n\n    modifier notPaused() {\n        require(!paused, \"Market: paused\");\n        _;\n    }\n    /// @dev Checks if the user is solvent in the closed liquidation case at the end of the function body.\n    modifier solvent(address from) {\n        updateExchangeRate();\n        _accrue();\n\n        _;\n\n        require(_isSolvent(from, exchangeRate), \"Market: insolvent\");\n    }\n\n    bool internal initialized;\n    modifier onlyOnce() {\n        require(!initialized, \"Market: initialized\");\n        _;\n        initialized = true;\n    }\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n    /// @notice sets the borrowing opening fee\n    /// @dev can only be called by the owner\n    /// @param _val the new value\n    function setBorrowOpeningFee(uint256 _val) external onlyOwner {\n        require(_val <= FEE_PRECISION, \"Market: not valid\");\n        emit LogBorrowingFee(borrowOpeningFee, _val);\n        borrowOpeningFee = _val;\n    }\n\n    /// @notice sets max borrowable amount\n    /// @dev can only be called by the owner\n    /// @param _cap the new value\n    function setBorrowCap(uint256 _cap) external notPaused onlyOwner {\n        emit LogBorrowCapUpdated(totalBorrowCap, _cap);\n        totalBorrowCap = _cap;\n    }\n\n    /// @notice sets common market configuration\n    /// @dev values are updated only if > 0 or not address(0)\n    function setMarketConfig(\n        uint256 _borrowOpeningFee,\n        IOracle _oracle,\n        bytes calldata _oracleData,\n        address _conservator,\n        uint256 _callerFee,\n        uint256 _protocolFee,\n        uint256 _liquidationBonusAmount,\n        uint256 _minLiquidatorReward,\n        uint256 _maxLiquidatorReward,\n        uint256 _totalBorrowCap,\n        uint256 _collateralizationRate\n    ) external onlyOwner {\n        if (_borrowOpeningFee > 0) {\n            require(_borrowOpeningFee <= FEE_PRECISION, \"Market: not valid\");\n            emit LogBorrowingFee(borrowOpeningFee, _borrowOpeningFee);\n            borrowOpeningFee = _borrowOpeningFee;\n        }\n\n        if (address(_oracle) != address(0)) {\n            oracle = _oracle;\n            emit OracleUpdated();\n        }\n\n        if (_oracleData.length > 0) {\n            oracleData = _oracleData;\n            emit OracleDataUpdated();\n        }\n\n        if (_conservator != address(0)) {\n            emit ConservatorUpdated(conservator, _conservator);\n            conservator = _conservator;\n        }\n\n        if (_callerFee > 0) {\n            require(_callerFee <= FEE_PRECISION, \"Market: not valid\");\n            callerFee = _callerFee;\n        }\n\n        if (_protocolFee > 0) {\n            require(_protocolFee <= FEE_PRECISION, \"Market: not valid\");\n            protocolFee = _protocolFee;\n        }\n\n        if (_liquidationBonusAmount > 0) {\n            require(\n                _liquidationBonusAmount < FEE_PRECISION,\n                \"Market: not valid\"\n            );\n            liquidationBonusAmount = _liquidationBonusAmount;\n        }\n\n        if (_minLiquidatorReward > 0) {\n            require(_minLiquidatorReward < FEE_PRECISION, \"Market: not valid\");\n            require(\n                _minLiquidatorReward < maxLiquidatorReward,\n                \"Market: not valid\"\n            );\n            minLiquidatorReward = _minLiquidatorReward;\n        }\n\n        if (_maxLiquidatorReward > 0) {\n            require(_maxLiquidatorReward < FEE_PRECISION, \"Market: not valid\");\n            require(\n                _maxLiquidatorReward > minLiquidatorReward,\n                \"Market: not valid\"\n            );\n            maxLiquidatorReward = _maxLiquidatorReward;\n        }\n\n        if (_totalBorrowCap > 0) {\n            emit LogBorrowCapUpdated(totalBorrowCap, _totalBorrowCap);\n            totalBorrowCap = _totalBorrowCap;\n        }\n\n        if (_collateralizationRate > 0) {\n            require(\n                _collateralizationRate <= FEE_PRECISION,\n                \"Market: not valid\"\n            );\n            collateralizationRate = _collateralizationRate;\n        }\n    }\n\n    /// @notice updates the pause state of the contract\n    /// @dev can only be called by the conservator\n    /// @param val the new value\n    function updatePause(bool val) external {\n        require(msg.sender == conservator, \"Market: unauthorized\");\n        require(val != paused, \"Market: same state\");\n        emit PausedUpdated(paused, val);\n        paused = val;\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice returns the maximum liquidatable amount for user\n    function computeClosingFactor(\n        uint256 borrowPart,\n        uint256 collateralPartInAsset,\n        uint256 borrowPartDecimals,\n        uint256 collateralPartDecimals,\n        uint256 ratesPrecision\n    ) public view returns (uint256) {\n        uint256 borrowPartScaled = borrowPart;\n        if (borrowPartDecimals > 18) {\n            borrowPartScaled = borrowPart / (10 ** (borrowPartDecimals - 18));\n        }\n        if (borrowPartDecimals < 18) {\n            borrowPartScaled = borrowPart * (10 ** (18 - borrowPartDecimals));\n        }\n\n        uint256 collateralPartInAssetScaled = collateralPartInAsset;\n        if (collateralPartDecimals > 18) {\n            collateralPartInAssetScaled =\n                collateralPartInAsset /\n                (10 ** (collateralPartDecimals - 18));\n        }\n        if (collateralPartDecimals < 18) {\n            collateralPartInAssetScaled =\n                collateralPartInAsset *\n                (10 ** (18 - collateralPartDecimals));\n        }\n\n        uint256 liquidationStartsAt = (collateralPartInAssetScaled *\n            collateralizationRate) / (10 ** ratesPrecision);\n        if (borrowPartScaled < liquidationStartsAt) return 0;\n\n        uint256 numerator = borrowPartScaled -\n            ((collateralizationRate * collateralPartInAssetScaled) /\n                (10 ** ratesPrecision));\n        uint256 denominator = ((10 ** ratesPrecision) -\n            (collateralizationRate *\n                ((10 ** ratesPrecision) + liquidationMultiplier)) /\n            (10 ** ratesPrecision)) * (10 ** (18 - ratesPrecision));\n\n        uint256 x = (numerator * 1e18) / denominator;\n        return x;\n    }\n\n    /// @notice return the amount of collateral for a `user` to be solvent, min TVL and max TVL. Returns 0 if user already solvent.\n    /// @dev we use a `CLOSED_COLLATERIZATION_RATE` that is a safety buffer when making the user solvent again,\n    ///      to prevent from being liquidated. This function is valid only if user is not solvent by `_isSolvent()`.\n    /// @param user The user to check solvency.\n    /// @param _exchangeRate the exchange rate asset/collateral.\n    /// @return amountToSolvency the amount of collateral to be solvent.\n    function computeTVLInfo(\n        address user,\n        uint256 _exchangeRate\n    )\n        public\n        view\n        returns (uint256 amountToSolvency, uint256 minTVL, uint256 maxTVL)\n    {\n        uint256 borrowPart = userBorrowPart[user];\n        if (borrowPart == 0) return (0, 0, 0);\n\n        Rebase memory _totalBorrow = totalBorrow;\n\n        uint256 collateralAmountInAsset = _computeMaxBorrowableAmount(\n            user,\n            _exchangeRate\n        );\n\n        borrowPart = (borrowPart * _totalBorrow.elastic) / _totalBorrow.base;\n\n        amountToSolvency = borrowPart >= collateralAmountInAsset\n            ? borrowPart - collateralAmountInAsset\n            : 0;\n\n        (minTVL, maxTVL) = _computeMaxAndMinLTVInAsset(\n            userCollateralShare[user],\n            _exchangeRate\n        );\n    }\n\n    /// @notice Gets the exchange rate. I.e how much collateral to buy 1e18 asset.\n    /// @dev This function is supposed to be invoked if needed because Oracle queries can be expensive.\n    ///      Oracle should consider USDO at 1$\n    /// @return updated True if `exchangeRate` was updated.\n    /// @return rate The new exchange rate.\n    function updateExchangeRate() public returns (bool updated, uint256 rate) {\n        (updated, rate) = oracle.get(\"\");\n\n        if (updated) {\n            require(rate > 0, \"Market: invalid rate\");\n            exchangeRate = rate;\n            emit LogExchangeRate(rate);\n        } else {\n            // Return the old rate if fetching wasn't successful\n            rate = exchangeRate;\n        }\n    }\n\n    /// @notice computes the possible liquidator reward\n    /// @notice user the user for which a liquidation operation should be performed\n    /// @param _exchangeRate the exchange rate asset/collateral to use for internal computations\n    function computeLiquidatorReward(\n        address user,\n        uint256 _exchangeRate\n    ) public view returns (uint256) {\n        (uint256 minTVL, uint256 maxTVL) = _computeMaxAndMinLTVInAsset(\n            userCollateralShare[user],\n            _exchangeRate\n        );\n        return _getCallerReward(userBorrowPart[user], minTVL, maxTVL);\n    }\n\n    // ************************** //\n    // *** INTERNAL FUNCTIONS *** //\n    // ************************** //\n    function _accrue() internal virtual;\n\n    function _getRevertMsg(\n        bytes memory _returnData\n    ) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return \"Market: no return data\";\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n\n    function _computeMaxBorrowableAmount(\n        address user,\n        uint256 _exchangeRate\n    ) internal view returns (uint256 collateralAmountInAsset) {\n        collateralAmountInAsset =\n            yieldBox.toAmount(\n                collateralId,\n                (userCollateralShare[user] *\n                    (EXCHANGE_RATE_PRECISION / FEE_PRECISION) *\n                    collateralizationRate),\n                false\n            ) /\n            _exchangeRate;\n    }\n\n    /// @notice Concrete implementation of `isSolvent`. Includes a parameter to allow caching `exchangeRate`.\n    /// @param _exchangeRate The exchange rate. Used to cache the `exchangeRate` between calls.\n    function _isSolvent(\n        address user,\n        uint256 _exchangeRate\n    ) internal view returns (bool) {\n        // accrue must have already been called!\n        uint256 borrowPart = userBorrowPart[user];\n        if (borrowPart == 0) return true;\n        uint256 collateralShare = userCollateralShare[user];\n        if (collateralShare == 0) return false;\n\n        Rebase memory _totalBorrow = totalBorrow;\n\n        return\n            yieldBox.toAmount(\n                collateralId,\n                collateralShare *\n                    (EXCHANGE_RATE_PRECISION / FEE_PRECISION) *\n                    collateralizationRate,\n                false\n            ) >=\n            // Moved exchangeRate here instead of dividing the other side to preserve more precision\n            (borrowPart * _totalBorrow.elastic * _exchangeRate) /\n                _totalBorrow.base;\n    }\n\n    /// @notice Returns the min and max LTV for user in asset price\n    function _computeMaxAndMinLTVInAsset(\n        uint256 collateralShare,\n        uint256 _exchangeRate\n    ) internal view returns (uint256 min, uint256 max) {\n        uint256 collateralAmount = yieldBox.toAmount(\n            collateralId,\n            collateralShare,\n            false\n        );\n\n        max = (collateralAmount * EXCHANGE_RATE_PRECISION) / _exchangeRate;\n        min = (max * collateralizationRate) / FEE_PRECISION;\n    }\n\n    function _getCallerReward(\n        uint256 borrowed,\n        uint256 startTVLInAsset,\n        uint256 maxTVLInAsset\n    ) internal view returns (uint256) {\n        if (borrowed == 0) return 0;\n        if (startTVLInAsset == 0) return 0;\n\n        if (borrowed < startTVLInAsset) return 0;\n        if (borrowed >= maxTVLInAsset) return minLiquidatorReward;\n\n        uint256 rewardPercentage = ((borrowed - startTVLInAsset) *\n            FEE_PRECISION) / (maxTVLInAsset - startTVLInAsset);\n\n        int256 diff = int256(minLiquidatorReward) - int256(maxLiquidatorReward);\n        int256 reward = (diff * int256(rewardPercentage)) /\n            int256(FEE_PRECISION) +\n            int256(maxLiquidatorReward);\n\n        return uint256(reward);\n    }\n\n    function _computeAllowanceAmountInAsset(\n        address user,\n        uint256 _exchangeRate,\n        uint256 borrowAmount,\n        uint256 assetDecimals\n    ) internal view returns (uint256) {\n        uint256 maxBorrowabe = _computeMaxBorrowableAmount(user, _exchangeRate);\n\n        uint256 shareRatio = _getRatio(\n            borrowAmount,\n            maxBorrowabe,\n            assetDecimals\n        );\n        return (shareRatio * userCollateralShare[user]) / (10 ** assetDecimals);\n    }\n\n    function _getRatio(\n        uint256 numerator,\n        uint256 denominator,\n        uint256 precision\n    ) private pure returns (uint256) {\n        if (numerator == 0 || denominator == 0) {\n            return 0;\n        }\n        uint256 _numerator = numerator * 10 ** (precision + 1);\n        uint256 _quotient = ((_numerator / denominator) + 5) / 10;\n        return (_quotient);\n    }\n}"
    },
    {
      "filename": "contracts/YieldBoxRebase.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\npragma experimental ABIEncoderV2;\nimport \"./interfaces/IStrategy.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IERC1155.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/Base64.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringAddress.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/Domain.sol\";\nimport \"./ERC1155TokenReceiver.sol\";\nimport \"./ERC1155.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/BoringBatchable.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/BoringFactory.sol\";\n\nlibrary YieldBoxRebase {\n    /// @notice Calculates the base value in relationship to `elastic` and `total`.\n    function _toShares(\n        uint256 amount,\n        uint256 totalShares_,\n        uint256 totalAmount,\n        bool roundUp\n    ) internal pure returns (uint256 share) {\n        // To prevent reseting the ratio due to withdrawal of all shares, we start with\n        // 1 amount/1e8 shares already burned. This also starts with a 1 : 1e8 ratio which\n        // functions like 8 decimal fixed point math. This prevents ratio attacks or inaccuracy\n        // due to 'gifting' or rebasing tokens. (Up to a certain degree)\n        totalAmount++;\n        totalShares_ += 1e8;\n\n        // Calculte the shares using te current amount to share ratio\n        share = (amount * totalShares_) / totalAmount;\n\n        // Default is to round down (Solidity), round up if required\n        if (roundUp && (share * totalAmount) / totalShares_ < amount) {\n            share++;\n        }\n    }\n\n    /// @notice Calculates the elastic value in relationship to `base` and `total`.\n    function _toAmount(\n        uint256 share,\n        uint256 totalShares_,\n        uint256 totalAmount,\n        bool roundUp\n    ) internal pure returns (uint256 amount) {\n        // To prevent reseting the ratio due to withdrawal of all shares, we start with\n        // 1 amount/1e8 shares already burned. This also starts with a 1 : 1e8 ratio which\n        // functions like 8 decimal fixed point math. This prevents ratio attacks or inaccuracy\n        // due to 'gifting' or rebasing tokens. (Up to a certain degree)\n        totalAmount++;\n        totalShares_ += 1e8;\n\n        // Calculte the amount using te current amount to share ratio\n        amount = (share * totalAmount) / totalShares_;\n\n        // Default is to round down (Solidity), round up if required\n        if (roundUp && (amount * totalShares_) / totalAmount < share) {\n            amount++;\n        }\n    }\n}"
    },
    {
      "filename": "contracts/markets/Market.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\n\nimport \"tapioca-sdk/dist/contracts/YieldBox/contracts/YieldBox.sol\";\nimport \"tapioca-periph/contracts/interfaces/IOracle.sol\";\nimport \"tapioca-periph/contracts/interfaces/IPenrose.sol\";\nimport \"./MarketERC20.sol\";\n\n/// @title Market contract\n/// @notice Market contract implemented by Singularity & BigBang\nabstract contract Market is MarketERC20, BoringOwnable {\n    using RebaseLibrary for Rebase;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    /// @notice returns YieldBox address\n    YieldBox public yieldBox;\n    /// @notice returns Penrose address\n    IPenrose public penrose;\n\n    /// @notice collateral token address\n    IERC20 public collateral;\n    /// @notice collateral token YieldBox id\n    uint256 public collateralId;\n    /// @notice asset token address\n    IERC20 public asset;\n    /// @notice asset token YieldBox id\n    uint256 public assetId;\n\n    /// @notice contract's pause state\n    bool public paused;\n    /// @notice conservator's addresss\n    /// @dev conservator can pause/unpause the contract\n    address public conservator;\n\n    /// @notice oracle address\n    IOracle public oracle;\n    /// @notice oracleData\n    bytes public oracleData;\n    /// @notice Exchange and interest rate tracking.\n    /// This is 'cached' here because calls to Oracles can be very expensive.\n    /// Asset -> collateral = assetAmount * exchangeRate.\n    uint256 public exchangeRate;\n\n    /// @notice total amount borrowed\n    /// @dev elastic = Total token amount to be repayed by borrowers, base = Total parts of the debt held by borrowers\n    Rebase public totalBorrow;\n    /// @notice total collateral supplied\n    uint256 public totalCollateralShare;\n    /// @notice max borrow cap\n    uint256 public totalBorrowCap;\n    /// @notice borrow amount per user\n    mapping(address => uint256) public userBorrowPart;\n    /// @notice collateral share per user\n    mapping(address => uint256) public userCollateralShare;\n\n    /// @notice liquidation caller rewards\n    uint256 public callerFee; // 90%\n    /// @notice liquidation protocol rewards\n    uint256 public protocolFee; // 10%\n    /// @notice min % a liquidator can receive in rewards\n    uint256 public minLiquidatorReward = 1e3; //1%\n    /// @notice max % a liquidator can receive in rewards\n    uint256 public maxLiquidatorReward = 1e4; //10%\n    /// @notice max liquidatable bonus amount\n    /// @dev max % added to the amount that can be liquidated\n    uint256 public liquidationBonusAmount = 1e4; //10%\n    /// @notice collateralization rate\n    uint256 public collateralizationRate; // 75%\n    /// @notice borrowing opening fee\n    uint256 public borrowOpeningFee = 50; //0.05%\n    /// @notice liquidation multiplier used to compute liquidator rewards\n    uint256 public liquidationMultiplier = 12000; //12%\n\n    // ***************** //\n    // *** CONSTANTS *** //\n    // ***************** //\n    uint256 internal EXCHANGE_RATE_PRECISION; //not costant, but can only be set in the 'init' method\n    uint256 internal constant FEE_PRECISION = 1e5;\n    uint256 internal constant FEE_PRECISION_DECIMALS = 5;\n\n    // ************** //\n    // *** EVENTS *** //\n    // ************** //\n    /// @notice event emitted when conservator is updated\n    event ConservatorUpdated(address indexed old, address indexed _new);\n    /// @notice event emitted when pause state is changed\n    event PausedUpdated(bool oldState, bool newState);\n    /// @notice event emitted when cached exchange rate is updated\n    event LogExchangeRate(uint256 rate);\n    /// @notice event emitted when borrow cap is updated\n    event LogBorrowCapUpdated(uint256 _oldVal, uint256 _newVal);\n    /// @notice event emitted when oracle data is updated\n    event OracleDataUpdated();\n    /// @notice event emitted when oracle is updated\n    event OracleUpdated();\n    /// @notice event emitted when a position is liquidated\n    event Liquidated(\n        address liquidator,\n        address[] users,\n        uint256 liquidatorReward,\n        uint256 protocolReward,\n        uint256 repayedAmount,\n        uint256 collateralShareRemoved\n    );\n    /// @notice event emitted when borrow opening fee is updated\n    event LogBorrowingFee(uint256 _oldVal, uint256 _newVal);\n    /// @notice event emitted when the liquidation multiplier rate is updated\n    event LiquidationMultiplierUpdated(uint256 oldVal, uint256 newVal);\n\n    modifier notPaused() {\n        require(!paused, \"Market: paused\");\n        _;\n    }\n    /// @dev Checks if the user is solvent in the closed liquidation case at the end of the function body.\n    modifier solvent(address from) {\n        updateExchangeRate();\n        _accrue();\n\n        _;\n\n        require(_isSolvent(from, exchangeRate), \"Market: insolvent\");\n    }\n\n    bool internal initialized;\n    modifier onlyOnce() {\n        require(!initialized, \"Market: initialized\");\n        _;\n        initialized = true;\n    }\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n    /// @notice sets the borrowing opening fee\n    /// @dev can only be called by the owner\n    /// @param _val the new value\n    function setBorrowOpeningFee(uint256 _val) external onlyOwner {\n        require(_val <= FEE_PRECISION, \"Market: not valid\");\n        emit LogBorrowingFee(borrowOpeningFee, _val);\n        borrowOpeningFee = _val;\n    }\n\n    /// @notice sets max borrowable amount\n    /// @dev can only be called by the owner\n    /// @param _cap the new value\n    function setBorrowCap(uint256 _cap) external notPaused onlyOwner {\n        emit LogBorrowCapUpdated(totalBorrowCap, _cap);\n        totalBorrowCap = _cap;\n    }\n\n    /// @notice sets common market configuration\n    /// @dev values are updated only if > 0 or not address(0)\n    function setMarketConfig(\n        uint256 _borrowOpeningFee,\n        IOracle _oracle,\n        bytes calldata _oracleData,\n        address _conservator,\n        uint256 _callerFee,\n        uint256 _protocolFee,\n        uint256 _liquidationBonusAmount,\n        uint256 _minLiquidatorReward,\n        uint256 _maxLiquidatorReward,\n        uint256 _totalBorrowCap,\n        uint256 _collateralizationRate\n    ) external onlyOwner {\n        if (_borrowOpeningFee > 0) {\n            require(_borrowOpeningFee <= FEE_PRECISION, \"Market: not valid\");\n            emit LogBorrowingFee(borrowOpeningFee, _borrowOpeningFee);\n            borrowOpeningFee = _borrowOpeningFee;\n        }\n\n        if (address(_oracle) != address(0)) {\n            oracle = _oracle;\n            emit OracleUpdated();\n        }\n\n        if (_oracleData.length > 0) {\n            oracleData = _oracleData;\n            emit OracleDataUpdated();\n        }\n\n        if (_conservator != address(0)) {\n            emit ConservatorUpdated(conservator, _conservator);\n            conservator = _conservator;\n        }\n\n        if (_callerFee > 0) {\n            require(_callerFee <= FEE_PRECISION, \"Market: not valid\");\n            callerFee = _callerFee;\n        }\n\n        if (_protocolFee > 0) {\n            require(_protocolFee <= FEE_PRECISION, \"Market: not valid\");\n            protocolFee = _protocolFee;\n        }\n\n        if (_liquidationBonusAmount > 0) {\n            require(\n                _liquidationBonusAmount < FEE_PRECISION,\n                \"Market: not valid\"\n            );\n            liquidationBonusAmount = _liquidationBonusAmount;\n        }\n\n        if (_minLiquidatorReward > 0) {\n            require(_minLiquidatorReward < FEE_PRECISION, \"Market: not valid\");\n            require(\n                _minLiquidatorReward < maxLiquidatorReward,\n                \"Market: not valid\"\n            );\n            minLiquidatorReward = _minLiquidatorReward;\n        }\n\n        if (_maxLiquidatorReward > 0) {\n            require(_maxLiquidatorReward < FEE_PRECISION, \"Market: not valid\");\n            require(\n                _maxLiquidatorReward > minLiquidatorReward,\n                \"Market: not valid\"\n            );\n            maxLiquidatorReward = _maxLiquidatorReward;\n        }\n\n        if (_totalBorrowCap > 0) {\n            emit LogBorrowCapUpdated(totalBorrowCap, _totalBorrowCap);\n            totalBorrowCap = _totalBorrowCap;\n        }\n\n        if (_collateralizationRate > 0) {\n            require(\n                _collateralizationRate <= FEE_PRECISION,\n                \"Market: not valid\"\n            );\n            collateralizationRate = _collateralizationRate;\n        }\n    }\n\n    /// @notice updates the pause state of the contract\n    /// @dev can only be called by the conservator\n    /// @param val the new value\n    function updatePause(bool val) external {\n        require(msg.sender == conservator, \"Market: unauthorized\");\n        require(val != paused, \"Market: same state\");\n        emit PausedUpdated(paused, val);\n        paused = val;\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice returns the maximum liquidatable amount for user\n    function computeClosingFactor(\n        uint256 borrowPart,\n        uint256 collateralPartInAsset,\n        uint256 borrowPartDecimals,\n        uint256 collateralPartDecimals,\n        uint256 ratesPrecision\n    ) public view returns (uint256) {\n        uint256 borrowPartScaled = borrowPart;\n        if (borrowPartDecimals > 18) {\n            borrowPartScaled = borrowPart / (10 ** (borrowPartDecimals - 18));\n        }\n        if (borrowPartDecimals < 18) {\n            borrowPartScaled = borrowPart * (10 ** (18 - borrowPartDecimals));\n        }\n\n        uint256 collateralPartInAssetScaled = collateralPartInAsset;\n        if (collateralPartDecimals > 18) {\n            collateralPartInAssetScaled =\n                collateralPartInAsset /\n                (10 ** (collateralPartDecimals - 18));\n        }\n        if (collateralPartDecimals < 18) {\n            collateralPartInAssetScaled =\n                collateralPartInAsset *\n                (10 ** (18 - collateralPartDecimals));\n        }\n\n        uint256 liquidationStartsAt = (collateralPartInAssetScaled *\n            collateralizationRate) / (10 ** ratesPrecision);\n        if (borrowPartScaled < liquidationStartsAt) return 0;\n\n        uint256 numerator = borrowPartScaled -\n            ((collateralizationRate * collateralPartInAssetScaled) /\n                (10 ** ratesPrecision));\n        uint256 denominator = ((10 ** ratesPrecision) -\n            (collateralizationRate *\n                ((10 ** ratesPrecision) + liquidationMultiplier)) /\n            (10 ** ratesPrecision)) * (10 ** (18 - ratesPrecision));\n\n        uint256 x = (numerator * 1e18) / denominator;\n        return x;\n    }\n\n    /// @notice return the amount of collateral for a `user` to be solvent, min TVL and max TVL. Returns 0 if user already solvent.\n    /// @dev we use a `CLOSED_COLLATERIZATION_RATE` that is a safety buffer when making the user solvent again,\n    ///      to prevent from being liquidated. This function is valid only if user is not solvent by `_isSolvent()`.\n    /// @param user The user to check solvency.\n    /// @param _exchangeRate the exchange rate asset/collateral.\n    /// @return amountToSolvency the amount of collateral to be solvent.\n    function computeTVLInfo(\n        address user,\n        uint256 _exchangeRate\n    )\n        public\n        view\n        returns (uint256 amountToSolvency, uint256 minTVL, uint256 maxTVL)\n    {\n        uint256 borrowPart = userBorrowPart[user];\n        if (borrowPart == 0) return (0, 0, 0);\n\n        Rebase memory _totalBorrow = totalBorrow;\n\n        uint256 collateralAmountInAsset = _computeMaxBorrowableAmount(\n            user,\n            _exchangeRate\n        );\n\n        borrowPart = (borrowPart * _totalBorrow.elastic) / _totalBorrow.base;\n\n        amountToSolvency = borrowPart >= collateralAmountInAsset\n            ? borrowPart -"
    }
  ]
}