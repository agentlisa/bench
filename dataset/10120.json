{
  "Title": "[H-07] `ConcentratedLiquidityPosition.sol#burn()` Wrong implementation allows attackers to steal yield",
  "Content": "_Submitted by WatchPug_\n\nWhen a user calls `ConcentratedLiquidityPosition.sol#burn()` to burn their liquidity, it calls `ConcentratedLiquidityPool.sol#burn()` -> `_updatePosition()`:\n\n[`ConcentratedLiquidityPool.sol#L525` L553](https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPool.sol#L525-L553)\n\nThe `_updatePosition()` function will return `amount0fees` and `amount1fees` of the whole position with the `lower` and `upper` tick and send them to the `recipient` alongside the burned liquidity amounts.\n\n#### Proof of Concept\n1.  Alice minted \\$10000 worth of liquidity with `lower` and `upper` tick set to 99 and 199;\n2.  Alice accumulated \\$1000 worth of fee in token0 and token1;\n3.  The attacker can mint a small amount (\\$1 worth) of liquidity using the same `lower` and `upper` tick;\n4.  The attacker calls `ConcentratedLiquidityPosition.sol#burn()` to steal all the unclaimed yield with the ticks of (99, 199) include the \\$1000 worth of yield from Alice.\n\n#### Recommended Mitigation Steps\nConsider making `ConcentratedLiquidityPosition.sol#burn()` always use `address(this)` as `recipient` in:\n\n```solidity\nposition.pool.burn(abi.encode(position.lower, position.upper, amount, recipient, unwrapBento));\n```\n\nand transfer proper amounts to the user.\n\n**[sarangparikh22 (Sushi) confirmed](https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/52)**\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2021-09-sushitrident-2",
  "Code": [
    {
      "filename": "contracts/pool/concentrated/ConcentratedLiquidityPool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"../../interfaces/IBentoBoxMinimal.sol\";\nimport \"../../interfaces/IMasterDeployer.sol\";\nimport \"../../interfaces/IPool.sol\";\nimport \"../../interfaces/IPositionManager.sol\";\nimport \"../../interfaces/ITridentCallee.sol\";\nimport \"../../interfaces/ITridentRouter.sol\";\nimport \"../../libraries/concentratedPool/FullMath.sol\";\nimport \"../../libraries/concentratedPool/TickMath.sol\";\nimport \"../../libraries/concentratedPool/UnsafeMath.sol\";\nimport \"../../libraries/concentratedPool/DyDxMath.sol\";\nimport \"../../libraries/concentratedPool/SwapLib.sol\";\nimport \"../../libraries/concentratedPool/Ticks.sol\";\nimport \"hardhat/console.sol\";\n\n/// @notice Trident exchange pool template with concentrated liquidity and constant product formula for swapping between an ERC-20 token pair.\n/// @dev The reserves are stored as bento shares.\n//      The curve is applied to shares as well. This pool does not care about the underlying amounts.\ncontract ConcentratedLiquidityPool is IPool {\n    using Ticks for mapping(int24 => Ticks.Tick);\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);\n    event Collect(address indexed sender, uint256 amount0, uint256 amount1);\n    event Sync(uint256 reserveShares0, uint256 reserveShares1);\n\n    /// @dev References for tickSpacing:\n    // 100 tickSpacing -> 2% between ticks.\n    bytes32 public constant override poolIdentifier = \"Trident:ConcentratedLiquidity\";\n\n    uint24 internal constant MAX_FEE = 100000; /// @dev Maximum `swapFee` is 10%.\n\n    uint128 internal immutable MAX_TICK_LIQUIDITY;\n    uint24 internal immutable tickSpacing;\n    uint24 internal immutable swapFee; /// @dev 1000 corresponds to 0.1% fee. Fee is measured in pips.\n\n    address internal immutable barFeeTo;\n    IBentoBoxMinimal internal immutable bento;\n    IMasterDeployer internal immutable masterDeployer;\n\n    address internal immutable token0;\n    address internal immutable token1;\n\n    uint128 public liquidity;\n\n    uint160 internal secondsPerLiquidity; /// @dev Multiplied by 2^128.\n    uint32 internal lastObservation;\n\n    uint256 public feeGrowthGlobal0; /// @dev All fee growth counters are multiplied by 2^128.\n    uint256 public feeGrowthGlobal1;\n\n    uint256 public barFee;\n\n    uint128 internal token0ProtocolFee;\n    uint128 internal token1ProtocolFee;\n\n    uint128 internal reserve0; /// @dev `bento` share balance tracker.\n    uint128 internal reserve1;\n\n    uint160 internal price; /// @dev Sqrt of price aka. âˆš(y/x), multiplied by 2^96.\n    int24 internal nearestTick; /// @dev Tick that is just below the current price.\n\n    uint256 internal unlocked;\n    modifier lock() {\n        require(unlocked == 1, \"LOCKED\");\n        unlocked = 2;\n        _;\n        unlocked = 1;\n    }\n\n    mapping(int24 => Ticks.Tick) public ticks;\n    mapping(address => mapping(int24 => mapping(int24 => Position))) public positions;\n\n    struct Position {\n        uint128 liquidity;\n        uint256 feeGrowthInside0Last;\n        uint256 feeGrowthInside1Last;\n    }\n\n    struct SwapCache {\n        uint256 feeAmount;\n        uint256 totalFeeAmount;\n        uint256 protocolFee;\n        uint256 feeGrowthGlobal;\n        uint256 currentPrice;\n        uint256 currentLiquidity;\n        uint256 input;\n        int24 nextTickToCross;\n    }\n\n    struct MintParams {\n        int24 lowerOld;\n        int24 lower;\n        int24 upperOld;\n        int24 upper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        bool token0native;\n        bool token1native;\n        /// @dev To mint an NFT the positionOwner should be set to the positionManager contract.\n        address positionOwner;\n        /// @dev When minting through the positionManager contract positionRecipient should be the NFT recipient.\n        //    It can be set to address(0) if we are not minting through the positionManager contract.\n        address positionRecipient;\n    }\n\n    /// @dev Only set immutable variables here - state changes made here will not be used.\n    constructor(bytes memory _deployData, IMasterDeployer _masterDeployer) {\n        (address _token0, address _token1, uint24 _swapFee, uint160 _price, uint24 _tickSpacing) = abi.decode(\n            _deployData,\n            (address, address, uint24, uint160, uint24)\n        );\n\n        require(_token0 != address(0), \"ZERO_ADDRESS\");\n        require(_token0 != address(this), \"INVALID_TOKEN0\");\n        require(_token1 != address(this), \"INVALID_TOKEN1\");\n        require(_swapFee <= MAX_FEE, \"INVALID_SWAP_FEE\");\n        \n        token0 = _token0;\n        token1 = _token1;\n        swapFee = _swapFee;\n        price = _price;\n        tickSpacing = _tickSpacing;\n        /// @dev Prevents global liquidity overflow in the case all ticks are initialised.\n        MAX_TICK_LIQUIDITY = Ticks.getMaxLiquidity(_tickSpacing);\n        ticks[TickMath.MIN_TICK] = Ticks.Tick(TickMath.MIN_TICK, TickMath.MAX_TICK, uint128(0), 0, 0, 0);\n        ticks[TickMath.MAX_TICK] = Ticks.Tick(TickMath.MIN_TICK, TickMath.MAX_TICK, uint128(0), 0, 0, 0);\n        nearestTick = TickMath.MIN_TICK;\n        bento = IBentoBoxMinimal(_masterDeployer.bento());\n        barFeeTo = _masterDeployer.barFeeTo();\n        barFee = _masterDeployer.barFee();\n        masterDeployer = _masterDeployer;\n        unlocked = 1;\n    }\n\n    /// @dev Mints LP tokens - should be called via the router after transferring `bento` tokens.\n    // The router must ensure that sufficient LP tokens are minted by using the return value.\n    function mint(bytes calldata data) public override lock returns (uint256 _liquidity) {\n        MintParams memory mintParams = abi.decode(data, (MintParams));\n\n        uint256 priceLower = uint256(TickMath.getSqrtRatioAtTick(mintParams.lower));\n        uint256 priceUpper = uint256(TickMath.getSqrtRatioAtTick(mintParams.upper));\n        uint256 currentPrice = uint256(price);\n\n        _liquidity = DyDxMath.getLiquidityForAmounts(\n            priceLower,\n            priceUpper,\n            currentPrice,\n            mintParams.amount1Desired,\n            mintParams.amount0Desired\n        );\n\n        {\n            require(_liquidity <= MAX_TICK_LIQUIDITY, \"LIQUIDITY_OVERFLOW\");\n\n            (uint256 amount0fees, uint256 amount1fees) = _updatePosition(\n                mintParams.positionOwner,\n                mintParams.lower,\n                mintParams.upper,\n                int128(uint128(_liquidity))\n            );\n            if (amount0fees > 0) {\n                _transfer(token0, amount0fees, mintParams.positionOwner, false);\n                reserve0 -= uint128(amount0fees);\n            }\n            if (amount1fees > 0) {\n                _transfer(token1, amount1fees, mintParams.positionOwner, false);\n                reserve1 -= uint128(amount1fees);\n            }\n        }\n\n        unchecked {\n            if (priceLower < currentPrice && currentPrice < priceUpper) liquidity += uint128(_liquidity);\n        }\n\n        _ensureTickSpacing(mintParams.lower, mintParams.upper);\n        nearestTick = Ticks.insert(\n            ticks,\n            feeGrowthGlobal0,\n            feeGrowthGlobal1,\n            secondsPerLiquidity,\n            mintParams.lowerOld,\n            mintParams.lower,\n            mintParams.upperOld,\n            mintParams.upper,\n            uint128(_liquidity),\n            nearestTick,\n            uint160(currentPrice)\n        );\n\n        (uint128 amount0Actual, uint128 amount1Actual) = _getAmountsForLiquidity(priceLower, priceUpper, currentPrice, _liquidity);\n\n        ITridentRouter.TokenInput[] memory callbackData = new ITridentRouter.TokenInput[](2);\n        callbackData[0] = ITridentRouter.TokenInput(token0, mintParams.token0native, amount0Actual);\n        callbackData[1] = ITridentRouter.TokenInput(token1, mintParams.token1native, amount1Actual);\n\n        ITridentCallee(msg.sender).tridentMintCallback(abi.encode(callbackData));\n\n        unchecked {\n            if (amount0Actual != 0) {\n                require(amount0Actual + reserve0 <= _balance(token0), \"TOKEN0_MISSING\");\n                reserve0 += amount0Actual;\n            }\n\n            if (amount1Actual != 0) {\n                require(amount1Actual + reserve1 <= _balance(token1), \"TOKEN1_MISSING\");\n                reserve1 += amount1Actual;\n            }\n        }\n\n        (uint256 feeGrowth0, uint256 feeGrowth1) = rangeFeeGrowth(mintParams.lower, mintParams.upper);\n\n        if (mintParams.positionRecipient != address(0)) {\n            IPositionManager(mintParams.positionOwner).positionMintCallback(\n                mintParams.positionRecipient,\n                mintParams.lower,\n                mintParams.upper,\n                uint128(_liquidity),\n                feeGrowth0,\n                feeGrowth1\n            );\n        }\n\n        emit Mint(mintParams.positionOwner, amount0Actual, amount1Actual, mintParams.positionRecipient);\n    }\n\n    /// @dev Burns LP tokens sent to this contract. The router must ensure that the user gets sufficient output tokens.\n    function burn(bytes calldata data) public override lock returns (IPool.TokenAmount[] memory withdrawnAmounts) {\n        (int24 lower, int24 upper, uint128 amount, address recipient, bool unwrapBento) = abi.decode(\n            data,\n            (int24, int24, uint128, address, bool)\n        );\n\n        uint160 priceLower = TickMath.getSqrtRatioAtTick(lower);\n        uint160 priceUpper = TickMath.getSqrtRatioAtTick(upper);\n        uint160 currentPrice = price;\n\n        unchecked {\n            if (priceLower < currentPrice && currentPrice < priceUpper) liquidity -= amount;\n        }\n\n        (uint256 amount0, uint256 amount1) = _getAmountsForLiquidity(\n            uint256(priceLower),\n            uint256(priceUpper),\n            uint256(currentPrice),\n            uint256(amount)\n        );\n\n        (uint256 amount0fees, uint256 amount1fees) = _updatePosition(msg.sender, lower, upper, -int128(amount));\n\n        unchecked {\n            amount0 += amount0fees;\n            amount1 += amount1fees;\n        }\n\n        withdrawnAmounts = new TokenAmount[](2);\n        withdrawnAmounts[0] = TokenAmount({token: token0, amount: amount0});\n        withdrawnAmounts[1] = TokenAmount({token: token1, amount: amount1});\n\n        unchecked {\n            reserve0 -= uint128(amount0fees);\n            reserve1 -= uint128(amount1fees);\n        }\n\n        _transferBothTokens(recipient, amount0, amount1, unwrapBento);\n\n        nearestTick = Ticks.remove(ticks, lower, upper, amount, nearestTick);\n        emit Burn(msg.sender, amount0, amount1, recipient);\n    }\n\n    function burnSingle(bytes calldata) public override returns (uint256) {\n        revert();\n    }\n\n    function collect(\n        int24 lower,\n        int24 upper,\n        address recipient,\n        bool unwrapBento\n    ) public lock returns (uint256 amount0fees, uint256 amount1fees) {\n        (amount0fees, amount1fees) = _updatePosition(msg.sender, lower, upper, 0);\n\n        _transferBothTokens(recipient, amount0fees, amount1fees, unwrapBento);\n\n        reserve0 -= uint128(amount0fees);\n        reserve1 -= uint128(amount1fees);\n\n        emit Collect(msg.sender, amount0fees, amount1fees);\n    }\n\n    /// @dev Swaps one token for another. The router must prefund this contract and ensure there isn't too much slippage\n    // - price is âˆš(y/x)\n    // - x is token0\n    // - zero for one -> price will move down.\n    function swap(bytes memory data) public override lock returns (uint256 amountOut) {\n        (bool zeroForOne, uint256 inAmount, address recipient, bool unwrapBento) = abi.decode(data, (bool, uint256, address, bool));\n\n        SwapCache memory cache = SwapCache({\n            feeAmount: 0,\n            totalFeeAmount: 0,\n            protocolFee: 0,\n            feeGrowthGlobal: zeroForOne ? feeGrowthGlobal1 : feeGrowthGlobal0,\n            currentPrice: uint256(price),\n            currentLiquidity: uint256(liquidity),\n            input: inAmount,\n            nextTickToCross: zeroForOne ? nearestTick : ticks[nearestTick].nextTick\n        });\n\n        {\n            uint256 timestamp = block.timestamp;\n            uint256 diff = timestamp - uint256(lastObservation); /// @dev Underflow in 2106.\n            if (diff > 0 && liquidity > 0) {\n                lastObservation = uint32(timestamp);\n                secondsPerLiquidity += uint160((diff << 128) / liquidity);\n            }\n        }\n\n        while (cache.input != 0) {\n            uint256 nextTickPrice = uint256(TickMath.getSqrtRatioAtTick(cache.nextTickToCross));\n            uint256 output = 0;\n            bool cross = false;\n\n            if (zeroForOne) {\n                // Trading token 0 (x) for token 1 (y).\n                // Price is decreasing.\n                // Maximum input amount within current tick range: Î”x = Î”(1/âˆšð‘ƒ) Â· L.\n                uint256 maxDx = DyDxMath.getDx(cache.currentLiquidity, nextTickPrice, cache.currentPrice, false);\n\n                if (cache.input <= maxDx) {\n                    // We can swap within the current range.\n                    uint256 liquidityPadded = cache.currentLiquidity << 96;\n                    // Calculate new price after swap: âˆšð‘ƒ[new] =  L Â· âˆšð‘ƒ / (L + Î”x Â· âˆšð‘ƒ)\n                    // This is derrived from Î”(1/âˆšð‘ƒ) = Î”x/L\n                    // where Î”(1/âˆšð‘ƒ) is 1/âˆšð‘ƒ[old] - 1/âˆšð‘ƒ[new] and we solve for âˆšð‘ƒ[new].\n                    // In case of an owerflow we can use: âˆšð‘ƒ[new] = L / (L / âˆšð‘ƒ + Î”x).\n                    // This is derrived by dividing the original fraction by âˆšð‘ƒ on both sides.\n                    uint256 newPrice = uint256(\n                        FullMath.mulDivRoundingUp(liquidityPadded, cache.currentPrice, liquidityPadded + cache.currentPrice * cache.input)\n                    );\n\n                    if (!(nextTickPrice <= newPrice && newPrice < cache.currentPrice)) {\n                        // Overflow. We use a modified version of the formula.\n                        newPrice = uint160(UnsafeMath.divRoundingUp(liquidityPadded, liquidityPadded / cache.currentPrice + cache.input));\n                    }\n                    // Based on the price difference calculate the output of th swap: Î”y = Î”âˆšP Â· L.\n                    output = DyDxMath.getDy(cache.currentLiquidity, newPrice, cache.currentPrice, false);\n                    cache.currentPrice = newPrice;\n                    cache.input = 0;\n                } else {\n                    // Execute swap step and cross the tick.\n                    output = DyDxMath.getDy(cache.currentLiquidity, nextTickPrice, cache.currentPrice, false);\n                    cache.currentPrice = nextTickPrice;\n                    cross = true;\n                    cache.input -= maxDx;\n                }\n            } else {\n                // Price is increasing.\n                // Maximum swap amount within the current tick range: Î”y = Î”âˆšP Â· L.\n                uint256 maxDy = DyDxMath.getDy(cache.currentLiquidity, cache.currentPrice, nextTickPrice, false);\n\n                if (cache.input <= maxDy) {\n                    // We can swap within the current range.\n                    // Calculate new price after swap: Î”P = Î”y/L.\n                    uint256 newPrice = cache.currentPrice +\n                        FullMath.mulDiv(cache.input, 0x1000000000000000000000000, cache.currentLiquidity);\n                    /// @dev Calculate output of swap\n                    // - Î”x = Î”(1/âˆšP) Â· L.\n                    output = DyDxMath.getDx(cache.currentLiquidity, cache.currentPrice, newPrice, false);\n                    cache.currentPrice = newPrice;\n                    cache.input = 0;\n                } else {\n                    /// @dev Swap & cross the tick.\n                    output = DyDxMath.getDx(cache.currentLiquidity, cache.currentPrice, nextTickPrice, false);\n                    cache.currentPrice = nextTickPrice;\n                    cross = true;\n                    cache.input -= maxDy;\n                }\n            }\n            (cache.totalFeeAmount, amountOut, cache.protocolFee, cache.feeGrowthGlobal) = SwapLib.handleFees(\n                output,\n                swapFee,\n                barFee,\n                cache.currentLiquidity,\n                cache.totalFeeAmount,\n                amountOut,\n                cache.protocolFee,\n                cache.feeGrowthGlobal\n            );\n            if (cross) {\n                (cache.currentLiquidity, cache.nextTickToCross) = Ticks.cross(\n                    ticks,\n                    cache.nextTickToCross,\n                    secondsPerLiquidity,\n                    cache.currentLiquidity,\n                    cache.feeGrowthGlobal,\n                    zeroForOne\n                );\n                if (cache.currentLiquidity == 0) {\n                    // We step into a zone that has liquidity - or we reach the end of the linked list.\n                    cache.currentPrice = uint256(TickMath.getSqrtRatioAtTick(cache.nextTickToCross));\n                    (cache.currentLiquidity, cache.nextTickToCross) = Ticks.cross(\n                        ticks,\n                        cache.nextTickToCross,\n                        secondsPerLiquidity,\n                        cache.currentLiquidity,\n                        cache.feeGrowthGlobal,\n                        zeroForOne\n                    );\n                }\n            }\n        }\n\n        price = uint160(cache.currentPrice);\n\n        int24 newNearestTick = zeroForOne ? cache.nextTickToCross : ticks[cache.nextTickToCross].previousTick;\n\n        if (nearestTick != newNearestTick) {\n            nearestTick = newNearestTick;\n            liquidity = uint128(cache.currentLiquidity);\n        }\n\n        _updateReserves(zeroForOne, uint128(inAmount), amountOut);\n\n        _updateFees(zeroForOne, cache.feeGrowthGlobal, uint128(cache.protocolFee));\n\n        if (zeroForOne) {\n            _transfer(token1, amountOut, recipient, unwrapBento);\n            emit Swap(recipient, token0, token1, inAmount, amountOut);\n        } else {\n            _transfer(token0, amountOut, recipient, unwrapBento);\n            emit Swap(recipient, token1, token0, inAmount, amountOut);\n        }\n    }\n\n    /// @dev Reserved for IPool.\n    function flashSwap(bytes calldata) public override returns (uint256) {\n        revert();\n    }\n\n    /// @dev Updates `barFee` for Trident protocol.\n    function updateBarFee() public {\n        barFee = IMasterDeployer(masterDeployer).barFee();\n    }\n\n    /// @dev Collects fees for Trident protocol.\n    function collectProtocolFee() public lock returns (uint128 amount0, uint128 amount1) {\n        if (token0ProtocolFee > 1) {\n            amount0 = token0ProtocolFee - 1;\n            token0ProtocolFee = 1;\n            reserve0 -= amount0;\n            _transfer(token0, amount0, barFeeTo, false);\n        }\n        if (token1ProtocolFee > 1) {\n            amount1 = token1ProtocolFee - 1;\n            token1ProtocolFee = 1;\n            reserve1 -= amount1;\n            _transfer(token1, amount1, barFeeTo, false);\n        }\n    }\n\n    function _ensureTickSpacing(int24 lower, int24 upper) internal view {\n        require(lower % int24(tickSpacing) == 0, \"INVALID_TICK\");\n        require((lower / int24(tickSpacing)) % 2 == 0, \"LOWER_EVEN\");\n\n        require(upper % int24(tickSpacing) == 0, \"INVALID_TICK\");\n        require((upper / int24(tickSpacing)) % 2 != 0, \"UPPER_ODD\"); /// @dev Can be either -1 or 1.\n    }\n\n    function _getAmountsForLiquidity(\n        uint256 priceLower,\n        uint256 priceUpper,\n        uint256 currentPrice,\n        uint256 liquidityAmount\n    ) internal pure returns (uint128 token0amount, uint128 token1amount) {\n        if (priceUpper <= currentPrice) {\n            /// @dev Only supply `token1` (`token1` is Y).\n            token1amount = uint128(DyDxMath.getDy(liquidityAmount, priceLower, priceUpper, true));\n        } else if (currentPrice <= priceLower) {\n            /// @dev Only supply `token0` (`token0` is X).\n            token0amount = uint128(DyDxMath.getDx(liquidityAmount, priceLower, priceUpper, true));\n        } else {\n            /// @dev Supply both tokens.\n            token0amount = uint128(DyDxMath.getDx(liquidityAmount, currentPrice, priceUpper, true));\n            token1amount = uint128(DyDxMath.getDy(liquidityAmount, priceLower, currentPrice, true));\n        }\n    }\n\n    function _updateReserves(\n        bool zeroForOne,\n        uint128 inAmount,\n        uint256 amountOut\n    ) internal {\n        if (zeroForOne) {\n            uint256 balance0 = _balance(token0);\n            uint128 newBalance = reserve0 + inAmount;\n            require(uint256(newBalance) <= balance0, \"TOKEN0_MISSING\");\n            reserve0 = newBalance;\n            reserve1 -= uint128(amountOut);\n        } else {\n            uint256 balance1 = _balance(token1);\n            uint128 newBalance = reserve1 + inAmount;\n            require(uint256(newBalance) <= balance1, \"TOKEN1_MISSING\");\n            reserve1 = newBalance;\n            reserve0 -= uint128(amountOut);\n        }\n    }\n\n    function _updateFees(\n        bool zeroForOne,\n        uint256 feeGrowthGlobal,\n        uint128 protocolFee\n    ) internal {\n        if (zeroForOne) {\n            feeGrowthGlobal1 = feeGrowthGlobal;\n            token1ProtocolFee += protocolFee;\n        } else {\n            feeGrowthGlobal0 = feeGrowthGlobal;\n            token0ProtocolFee += protocolFee;\n        }\n    }\n\n    function _updatePosition(\n        address owner,\n        int24 lower,\n        int24 upper,\n        int128 amount\n    ) internal returns (uint256 amount0fees, uint256 amount1fees) {\n        Position storage position = positions[owner][lower][upper];\n\n        (uint256 growth0current, uint256 growth1current) = rangeFeeGrowth(lower, upper);\n        amount0fees = FullMath.mulDiv(\n            growth0current - position.feeGrowthInside0Last,\n            position.liquidity,\n            0x100000000000000000000000000000000\n        );\n\n        amount1fees = FullMath.mulDiv(\n            growth1current - position.feeGrowthInside1Last,\n            position.liquidity,\n            0x100000000000000000000000000000000\n        );\n\n        if (amount < 0) position.liquidity -= uint128(-amount);\n        if (amount > 0) position.liquidity += uint128(amount);\n\n        require(position.liquidity < MAX_TICK_LIQUIDITY, \"MAX_TICK_LIQUIDITY\");\n\n        position.feeGrowthInside0Last = growth0current;\n        position.feeGrowthInside1Last = growth1current;\n    }\n\n    function _balance(address token) internal view returns (uint256 balance) {\n        balance = bento.balanceOf(token, address(this));\n    }\n\n    function _transfer(\n        address token,\n        uint256 shares,\n        address to,\n        bool unwrapBento\n    ) internal {\n        if (unwrapBento) {\n            bento.withdraw(token, address(this), to, 0, shares);\n        } else {\n            bento.transfer(token, address(this), to, shares);\n        }\n    }\n\n    function _transferBothTokens(\n        address to,\n        uint256 shares0,\n        uint256 shares1,\n        bool unwrapBento\n    ) internal {\n        if (unwrapBento) {\n            bento.withdraw(token0, address(this), to, 0, shares0);\n            bento.withdraw(token1, address(this), to, 0, shares1);\n        } else {\n            bento.transfer(token0, address(this), to, shares0);\n            bento.transfer(token1, address(this), to, shares1);\n        }\n    }\n\n    /// @dev Generic formula for fee growth inside a range: (globalGrowth - growthBelow - growthAbove)\n    // - available counters: global, outside u, outside v.\n\n    //                  u         â–¼         v\n    // ----|----|-------|xxxxxxxxxxxxxxxxxxx|--------|--------- (global - feeGrowthOutside(u) - feeGrowthOutside(v))\n\n    //             â–¼    u                   v\n    // ----|----|-------|xxxxxxxxxxxxxxxxxxx|--------|--------- (global - (global - feeGrowthOutside(u)) - feeGrowthOutside(v))\n\n    //                  u                   v    â–¼\n    // ----|----|-------|xxxxxxxxxxxxxxxxxxx|--------|--------- (global - feeGrowthOutside(u) - (global - feeGrowthOutside(v)))\n\n    /// @notice Calculates the fee growth inside a range (per unit of liquidity).\n    /// @dev Multiply `rangeFeeGrowth` delta by the provided liquidity to get accrued fees for some period.\n    function rangeFeeGrowth(int24 lowerTick, int24 upperTick) public view returns (uint256 feeGrowthInside0, uint256 feeGrowthInside1) {\n        int24 currentTick = nearestTick;\n\n        Ticks.Tick storage lower = ticks[lowerTick];\n        Ticks.Tick storage upper = ticks[upperTick];\n\n        /// @dev Calculate fee growth below & above.\n        uint256 _feeGrowthGlobal0 = feeGrowthGlobal0;\n        uint256 _feeGrowthGlobal1 = feeGrowthGlobal1;\n        uint256 feeGrowthBelow0;\n        uint256 feeGrowthBelow1;\n        uint256 feeGrowthAbove0;\n        uint256 feeGrowthAbove1;\n\n        if (lowerTick <= currentTick) {\n            feeGrowthBelow0 = lower.feeGrowthOutside0;\n            feeGrowthBelow1 = lower.feeGrowthOutside1;\n        } else {\n            feeGrowthBelow0 = _feeGrowthGlobal0 - lower.feeGrowthOutside0;\n            feeGrowthBelow1 = _feeGrowthGlobal1 - lower.feeGrowthOutside1;\n        }\n\n        if (currentTick < upperTick) {\n            feeGrowthAbove0 = upper.feeGrowthOutside0;\n            feeGrowthAbove1 = upper.feeGrowthOutside1;\n        } else {\n            feeGrowthAbove0 = _feeGrowthGlobal0 - upper.feeGrowthOutside0;\n            feeGrowthAbove1 = _feeGrowthGlobal1 - upper.feeGrowthOutside1;\n        }\n\n        feeGrowthInside0 = _feeGrowthGlobal0 - feeGrowthBelow0 - feeGrowthAbove0;\n        feeGrowthInside1 = _feeGrowthGlobal1 - feeGrowthBelow1 - feeGrowthAbove1;\n    }\n\n    function rangeSecondsInside(int24 lowerTick, int24 upperTick) public view returns (uint256 secondsInside) {\n        int24 currentTick = nearestTick;\n\n        Ticks.Tick storage lower = ticks[lowerTick];\n        Ticks.Tick storage upper = ticks[upperTick];\n\n        uint256 secondsGlobal = secondsPerLiquidity;\n        uint256 secondsBelow;\n        uint256 secondsAbove;\n\n        if (lowerTick <= currentTick) {\n            secondsBelow = lower.secondsPerLiquidityOutside;\n        } else {\n            secondsBelow = secondsGlobal - lower.secondsPerLiquidityOutside;\n        }\n\n        if (currentTick < upperTick) {\n            secondsAbove = upper.secondsPerLiquidityOutside;\n        } else {\n            secondsAbove = secondsGlobal - upper.secondsPerLiquidityOutside;\n        }\n\n        secondsInside = secondsGlobal - secondsBelow - secondsAbove;\n    }\n\n    function getAssets() public view override returns (address[] memory assets) {\n        assets = new address[](2);\n        assets[0] = token0;\n        assets[1] = token1;\n    }\n\n    /// @dev Reserved for IPool.\n    function getAmountOut(bytes calldata) public pure override returns (uint256) {\n        revert();\n    }\n\n    function getImmutables()\n        public\n        view\n        returns (\n            uint128 _MAX_TICK_LIQUIDITY,\n            uint24 _tickSpacing,\n            uint24 _swapFee,\n            address _barFeeTo,\n            IBentoBoxMinimal _bento,\n            IMasterDeployer _masterDeployer,\n            address _token0,\n            address _token1\n        )\n    {\n        _MAX_TICK_LIQUIDITY = MAX_TICK_LIQUIDITY;\n        _tickSpacing = tickSpacing;\n        _swapFee = swapFee; /// @dev 1000 corresponds to 0.1% fee.\n        _barFeeTo = barFeeTo;\n        _bento = bento;\n        _masterDeployer = masterDeployer;\n        _token0 = token0;\n        _token1 = token1;\n    }\n\n    function getPriceAndNearestTicks() public view returns (uint160 _price, int24 _nearestTick) {\n        _price = price;\n        _nearestTick = nearestTick;\n    }\n\n    function getTokenProtocolFees() public view returns (uint128 _token0ProtocolFee, uint128 _token1ProtocolFee) {\n        _token0ProtocolFee = token0ProtocolFee;\n        _token1ProtocolFee = token1ProtocolFee;\n    }\n\n    function getReserves() public view returns (uint128 _reserve0, uint128 _reserve1) {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n    }\n\n    function getLiquidityAndLastObservation() public view returns (uint160 _secondsPerLiquidity, uint32 _lastObservation) {\n        _secondsPerLiquidity = secondsPerLiquidity;\n        _lastObservation = lastObservation;\n    }\n}"
    }
  ]
}