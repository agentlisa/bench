{
  "Title": "[M-01] Transactions can be replayed when a connectedChain is removed and then reconnected",
  "Content": "_Submitted by WatchPug, also found by cmichel_\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/11d6a6ae5bf16af552edd75183791375e501915f/contracts/MessageProxy.sol#L313-L317>\n\n```solidity\nfunction removeConnectedChain(string memory schainName) public virtual override onlyChainConnector {\n    bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n    require(connectedChains[schainHash].inited, \"Chain is not initialized\");\n    delete connectedChains[schainHash];\n}\n```\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/11d6a6ae5bf16af552edd75183791375e501915f/contracts/MessageProxy.sol#L402-L409>\n\n```solidity\nfunction _addConnectedChain(bytes32 schainHash) internal onlyChainConnector {\n    require(!connectedChains[schainHash].inited,\"Chain is already connected\");\n    connectedChains[schainHash] = ConnectedChainInfo({\n        incomingMessageCounter: 0,\n        outgoingMessageCounter: 0,\n        inited: true\n    });\n}\n```\n\nIn the current implementation, when a connected chain is removed, the `incomingMessageCounter` and `outgoingMessageCounter` will be deleted.\n\nAnd if it's reconnected again, the `incomingMessageCounter` and `outgoingMessageCounter` will be reset to `0`.\n\nHowever, since the contract is using `connectedChains[fromChainHash].incomingMessageCounter` and `signature` to ensure that the message can only be processed once.\n\n### Impact\n\n1.  Once the `incomingMessageCounter` resets to `0`, all the past messages (transactions) can be replayed with the old signatures.\n\n2.  Another impact is that, for the particular reconnected schain, both inbound and outbound messages may not be able to be processed properly, as the counter is now out of sync with the remote schain.\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/11d6a6ae5bf16af552edd75183791375e501915f/contracts/schain/MessageProxyForSchain.sol#L212-L221>\n\n```solidity\nrequire(\n    _verifyMessages(\n        _hashedArray(messages, startingCounter, fromChainName),\n        signature\n    ),\n    \"Signature is not verified\"\n);\nrequire(\n    startingCounter == connectedChains[fromChainHash].incomingMessageCounter,\n    \"Starting counter is not qual to incoming message counter\");\n```\n\n### Recommendation\n\nWhen removing and connecting a schain, instead of delete/reset the couter, consider leaving the counter as it is when `removeConnectedChain`, `_addConnectedChain` also should not reset the counter:\n\n```solidity\nfunction removeConnectedChain(string memory schainName) public virtual override onlyChainConnector {\n    bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n    require(connectedChains[schainHash].inited, \"Chain is not initialized\");\n    connectedChains[targetChainHash].inited = false;\n}\n```\n\n```solidity\nfunction _addConnectedChain(bytes32 schainHash) internal onlyChainConnector {\n    require(!connectedChains[schainHash].inited,\"Chain is already connected\");\n    connectedChains[schainHash].inited = true;\n}\n```\n**[DimaStebaev (SKALE) disagreed with severity and commented](https://github.com/code-423n4/2022-02-skale-findings/issues/57#issuecomment-1064177348):**\n> Acknowledged, and work is on the roadmap.\n\n**[GalloDaSballo (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-02-skale-findings/issues/57#issuecomment-1143788390):**\n > I believe the finding to have validity, in that, a set of signed messages can be replayed if the chain is disconnected and then re-connected while maintaining the same validators.\n> \n> At this time I think Medium Severity (External Conditions Reliance) to be more appropriate and that the issue can be fully sidestepped by changing validators on a chain reconnect\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-skale-contest",
  "Code": [
    {
      "filename": "contracts/MessageProxy.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   MessageProxy.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/IGasReimbursable.sol\";\nimport \"@skalenetwork/ima-interfaces/IMessageProxy.sol\";\nimport \"@skalenetwork/ima-interfaces/IMessageReceiver.sol\";\n\n\n/**\n * @title MessageProxy\n * @dev Abstract contract for MessageProxyForMainnet and MessageProxyForSchain.\n */\nabstract contract MessageProxy is AccessControlEnumerableUpgradeable, IMessageProxy {\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    /**\n     * @dev Structure that stores counters for outgoing and incoming messages.\n     */\n    struct ConnectedChainInfo {\n        // message counters start with 0\n        uint256 incomingMessageCounter;\n        uint256 outgoingMessageCounter;\n        bool inited;\n    }\n\n    bytes32 public constant MAINNET_HASH = keccak256(abi.encodePacked(\"Mainnet\"));\n    bytes32 public constant CHAIN_CONNECTOR_ROLE = keccak256(\"CHAIN_CONNECTOR_ROLE\");\n    bytes32 public constant EXTRA_CONTRACT_REGISTRAR_ROLE = keccak256(\"EXTRA_CONTRACT_REGISTRAR_ROLE\");\n    bytes32 public constant CONSTANT_SETTER_ROLE = keccak256(\"CONSTANT_SETTER_ROLE\");\n    uint256 public constant MESSAGES_LENGTH = 10;\n\n    //   schainHash => ConnectedChainInfo\n    mapping(bytes32 => ConnectedChainInfo) public connectedChains;\n    //   schainHash => contract address => allowed\n    // solhint-disable-next-line private-vars-leading-underscore\n    mapping(bytes32 => mapping(address => bool)) internal deprecatedRegistryContracts;\n\n    uint256 public gasLimit;\n\n    /**\n     * @dev Emitted for every outgoing message to schain.\n     */\n    event OutgoingMessage(\n        bytes32 indexed dstChainHash,\n        uint256 indexed msgCounter,\n        address indexed srcContract,\n        address dstContract,\n        bytes data\n    );\n\n    /**\n     * @dev Emitted when function `postMessage` returns revert.\n     *  Used to prevent stuck loop inside function `postIncomingMessages`.\n     */\n    event PostMessageError(\n        uint256 indexed msgCounter,\n        bytes message\n    );\n\n    /**\n     * @dev Emitted when gas limit per one call of `postMessage` was changed.\n     */\n    event GasLimitWasChanged(\n        uint256 oldValue,\n        uint256 newValue\n    );\n\n    /**\n     * @dev Emitted when the version was updated\n     */\n    event VersionUpdated(string oldVersion, string newVersion);\n\n    /**\n     * @dev Emitted when extra contract was added.\n     */\n    event ExtraContractRegistered(\n        bytes32 indexed chainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Emitted when extra contract was removed.\n     */\n    event ExtraContractRemoved(\n        bytes32 indexed chainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {CHAIN_CONNECTOR_ROLE}.\n     */\n    modifier onlyChainConnector() {\n        require(hasRole(CHAIN_CONNECTOR_ROLE, msg.sender), \"CHAIN_CONNECTOR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {EXTRA_CONTRACT_REGISTRAR_ROLE}.\n     */\n    modifier onlyExtraContractRegistrar() {\n        require(hasRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender), \"EXTRA_CONTRACT_REGISTRAR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {CONSTANT_SETTER_ROLE}.\n     */\n    modifier onlyConstantSetter() {\n        require(hasRole(CONSTANT_SETTER_ROLE, msg.sender), \"Not enough permissions to set constant\");\n        _;\n    }    \n\n    /**\n     * @dev Sets gasLimit to a new value.\n     * \n     * Requirements:\n     * \n     * - `msg.sender` must be granted CONSTANT_SETTER_ROLE.\n     */\n    function setNewGasLimit(uint256 newGasLimit) external override onlyConstantSetter {\n        emit GasLimitWasChanged(gasLimit, newGasLimit);\n        gasLimit = newGasLimit;\n    }\n\n    /**\n     * @dev Virtual function for `postIncomingMessages`.\n     */\n    function postIncomingMessages(\n        string calldata fromSchainName,\n        uint256 startingCounter,\n        Message[] calldata messages,\n        Signature calldata sign\n    )\n        external\n        virtual\n        override;\n\n    /**\n     * @dev Allows `msg.sender` to register extra contract for all schains\n     * for being able to transfer messages from custom contracts.\n     * \n     * Requirements:\n     * \n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     * - Passed address should be contract.\n     * - Extra contract must not be registered.\n     */\n    function registerExtraContractForAll(address extraContract) external override onlyExtraContractRegistrar {\n        require(extraContract.isContract(), \"Given address is not a contract\");\n        require(!_getRegistryContracts()[bytes32(0)].contains(extraContract), \"Extra contract is already registered\");\n        _getRegistryContracts()[bytes32(0)].add(extraContract);\n        emit ExtraContractRegistered(bytes32(0), extraContract);\n    }\n\n    /**\n     * @dev Allows `msg.sender` to remove extra contract for all schains.\n     * Extra contract will no longer be able to send messages through MessageProxy.\n     * \n     * Requirements:\n     * \n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     */\n    function removeExtraContractForAll(address extraContract) external override onlyExtraContractRegistrar {\n        require(_getRegistryContracts()[bytes32(0)].contains(extraContract), \"Extra contract is not registered\");\n        _getRegistryContracts()[bytes32(0)].remove(extraContract);\n        emit ExtraContractRemoved(bytes32(0), extraContract);\n    }\n\n    /**\n     * @dev Should return length of contract registered by schainHash.\n     */\n    function getContractRegisteredLength(bytes32 schainHash) external view override returns (uint256) {\n        return _getRegistryContracts()[schainHash].length();\n    }\n\n    /**\n     * @dev Should return a range of contracts registered by schainHash.\n     * \n     * Requirements:\n     * range should be less or equal 10 contracts\n     */\n    function getContractRegisteredRange(\n        bytes32 schainHash,\n        uint256 from,\n        uint256 to\n    )\n        external\n        view\n        override\n        returns (address[] memory contractsInRange)\n    {\n        require(\n            from < to && to - from <= 10 && to <= _getRegistryContracts()[schainHash].length(),\n            \"Range is incorrect\"\n        );\n        contractsInRange = new address[](to - from);\n        for (uint256 i = from; i < to; i++) {\n            contractsInRange[i - from] = _getRegistryContracts()[schainHash].at(i);\n        }\n    }\n\n    /**\n     * @dev Returns number of outgoing messages.\n     * \n     * Requirements:\n     * \n     * - Target schain  must be initialized.\n     */\n    function getOutgoingMessagesCounter(string calldata targetSchainName)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        bytes32 dstChainHash = keccak256(abi.encodePacked(targetSchainName));\n        require(connectedChains[dstChainHash].inited, \"Destination chain is not initialized\");\n        return connectedChains[dstChainHash].outgoingMessageCounter;\n    }\n\n    /**\n     * @dev Returns number of incoming messages.\n     * \n     * Requirements:\n     * \n     * - Source schain must be initialized.\n     */\n    function getIncomingMessagesCounter(string calldata fromSchainName)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        bytes32 srcChainHash = keccak256(abi.encodePacked(fromSchainName));\n        require(connectedChains[srcChainHash].inited, \"Source chain is not initialized\");\n        return connectedChains[srcChainHash].incomingMessageCounter;\n    }\n\n    function initializeMessageProxy(uint newGasLimit) public initializer {\n        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(CHAIN_CONNECTOR_ROLE, msg.sender);\n        _setupRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender);\n        _setupRole(CONSTANT_SETTER_ROLE, msg.sender);\n        gasLimit = newGasLimit;\n    }\n\n    /**\n     * @dev Posts message from this contract to `targetChainHash` MessageProxy contract.\n     * This is called by a smart contract to make a cross-chain call.\n     * \n     * Emits an {OutgoingMessage} event.\n     *\n     * Requirements:\n     * \n     * - Target chain must be initialized.\n     * - Target chain must be registered as external contract.\n     */\n    function postOutgoingMessage(\n        bytes32 targetChainHash,\n        address targetContract,\n        bytes memory data\n    )\n        public\n        override\n        virtual\n    {\n        require(connectedChains[targetChainHash].inited, \"Destination chain is not initialized\");\n        _authorizeOutgoingMessageSender(targetChainHash);\n        \n        emit OutgoingMessage(\n            targetChainHash,\n            connectedChains[targetChainHash].outgoingMessageCounter,\n            msg.sender,\n            targetContract,\n            data\n        );\n\n        connectedChains[targetChainHash].outgoingMessageCounter += 1;\n    }\n\n    /**\n     * @dev Allows `CHAIN_CONNECTOR_ROLE` to remove connected chain from this contract.\n     * \n     * Requirements:\n     * \n     * - `msg.sender` must be granted `CHAIN_CONNECTOR_ROLE`.\n     * - `schainName` must be initialized.\n     */\n    function removeConnectedChain(string memory schainName) public virtual override onlyChainConnector {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(connectedChains[schainHash].inited, \"Chain is not initialized\");\n        delete connectedChains[schainHash];\n    }    \n\n    /**\n     * @dev Checks whether chain is currently connected.\n     */\n    function isConnectedChain(\n        string memory schainName\n    )\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return connectedChains[keccak256(abi.encodePacked(schainName))].inited;\n    }\n\n    /**\n     * @dev Checks whether contract is currently registered as extra contract.\n     */\n    function isContractRegistered(\n        bytes32 schainHash,\n        address contractAddress\n    )\n        public\n        view\n        override\n        returns (bool)\n    {\n        return _getRegistryContracts()[schainHash].contains(contractAddress);\n    }\n\n    /**\n     * @dev Allows MessageProxy to register extra contract for being able to transfer messages from custom contracts.\n     * \n     * Requirements:\n     * \n     * - Extra contract address must be contract.\n     * - Extra contract must not be registered.\n     * - Extra contract must not be registered for all chains.\n     */\n    function _registerExtraContract(\n        bytes32 chainHash,\n        address extraContract\n    )\n        internal\n    {      \n        require(extraContract.isContract(), \"Given address is not a contract\");\n        require(!_getRegistryContracts()[chainHash].contains(extraContract), \"Extra contract is already registered\");\n        require(\n            !_getRegistryContracts()[bytes32(0)].contains(extraContract),\n            \"Extra contract is already registered for all chains\"\n        );\n        \n        _getRegistryContracts()[chainHash].add(extraContract);\n        emit ExtraContractRegistered(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to remove extra contract,\n     * thus `extraContract` will no longer be available to transfer messages from mainnet to schain.\n     * \n     * Requirements:\n     * \n     * - Extra contract must be registered.\n     */\n    function _removeExtraContract(\n        bytes32 chainHash,\n        address extraContract\n    )\n        internal\n    {\n        require(_getRegistryContracts()[chainHash].contains(extraContract), \"Extra contract is not registered\");\n        _getRegistryContracts()[chainHash].remove(extraContract);\n        emit ExtraContractRemoved(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to connect schain with MessageProxyOnMainnet for transferring messages.\n     * \n     * Requirements:\n     * \n     * - `msg.sender` must be granted CHAIN_CONNECTOR_ROLE.\n     * - SKALE chain must not be connected.\n     */\n    function _addConnectedChain(bytes32 schainHash) internal onlyChainConnector {\n        require(!connectedChains[schainHash].inited,\"Chain is already connected\");\n        connectedChains[schainHash] = ConnectedChainInfo({\n            incomingMessageCounter: 0,\n            outgoingMessageCounter: 0,\n            inited: true\n        });\n    }\n\n    /**\n     * @dev Allows MessageProxy to send messages from schain to mainnet.\n     * Destination contract must implement `postMessage` method.\n     */\n    function _callReceiverContract(\n        bytes32 schainHash,\n        Message calldata message,\n        uint counter\n    )\n        internal\n        returns (address)\n    {\n        if (!message.destinationContract.isContract()) {\n            emit PostMessageError(\n                counter,\n                \"Destination contract is not a contract\"\n            );\n            return address(0);\n        }\n        try IMessageReceiver(message.destinationContract).postMessage{gas: gasLimit}(\n            schainHash,\n            message.sender,\n            message.data\n        ) returns (address receiver) {\n            return receiver;\n        } catch Error(string memory reason) {\n            emit PostMessageError(\n                counter,\n                bytes(reason)\n            );\n            return address(0);\n        } catch (bytes memory revertData) {\n            emit PostMessageError(\n                counter,\n                revertData\n            );\n            return address(0);\n        }\n    }\n\n    /**\n     * @dev Returns receiver of message.\n     */\n    function _getGasPayer(\n        bytes32 schainHash,\n        Message calldata message,\n        uint counter\n    )\n        internal\n        returns (address)\n    {\n        try IGasReimbursable(message.destinationContract).gasPayer{gas: gasLimit}(\n            schainHash,\n            message.sender,\n            message.data\n        ) returns (address receiver) {\n            return receiver;\n        } catch Error(string memory reason) {\n            emit PostMessageError(\n                counter,\n                bytes(reason)\n            );\n            return address(0);\n        } catch (bytes memory revertData) {\n            emit PostMessageError(\n                counter,\n                revertData\n            );\n            return address(0);\n        }\n    }\n\n    /**\n     * @dev Checks whether `msg.sender` is registered as custom extra contract.\n     */\n    function _authorizeOutgoingMessageSender(bytes32 targetChainHash) internal view virtual {\n        require(\n            isContractRegistered(bytes32(0), msg.sender) || isContractRegistered(targetChainHash, msg.sender),\n            \"Sender contract is not registered\"\n        );        \n    }\n\n    /**\n     * @dev Returns list of registered custom extra contracts.\n     */\n    function _getRegistryContracts()\n        internal\n        view\n        virtual\n        returns (mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) storage);\n\n    /**\n     * @dev Returns hash of message array.\n     */\n    function _hashedArray(\n        Message[] calldata messages,\n        uint256 startingCounter,\n        string calldata fromChainName\n    )\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes memory data;\n        for (uint256 i = 0; i < messages.length; i++) {\n            data = abi.encodePacked(\n                data,\n                bytes32(bytes20(messages[i].sender)),\n                bytes32(bytes20(messages[i].destinationContract)),\n                messages[i].data\n            );\n        }\n        data = abi.encodePacked(\n            data,\n            bytes32(startingCounter),\n            bytes32(keccak256(abi.encodePacked(fromChainName)))\n        );\n        return keccak256(data);\n    }\n}"
    },
    {
      "filename": "contracts/MessageProxy.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   MessageProxy.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/IGasReimbursable.sol\";\nimport \"@skalenetwork/ima-interfaces/IMessageProxy.sol\";\nimport \"@skalenetwork/ima-interfaces/IMessageReceiver.sol\";\n\n\n/**\n * @title MessageProxy\n * @dev Abstract contract for MessageProxyForMainnet and MessageProxyForSchain.\n */\nabstract contract MessageProxy is AccessControlEnumerableUpgradeable, IMessageProxy {\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    /**\n     * @dev Structure that stores counters for outgoing and incoming messages.\n     */\n    struct ConnectedChainInfo {\n        // message counters start with 0\n        uint256 incomingMessageCounter;\n        uint256 outgoingMessageCounter;\n        bool inited;\n    }\n\n    bytes32 public constant MAINNET_HASH = keccak256(abi.encodePacked(\"Mainnet\"));\n    bytes32 public constant CHAIN_CONNECTOR_ROLE = keccak256(\"CHAIN_CONNECTOR_ROLE\");\n    bytes32 public constant EXTRA_CONTRACT_REGISTRAR_ROLE = keccak256(\"EXTRA_CONTRACT_REGISTRAR_ROLE\");\n    bytes32 public constant CONSTANT_SETTER_ROLE = keccak256(\"CONSTANT_SETTER_ROLE\");\n    uint256 public constant MESSAGES_LENGTH = 10;\n\n    //   schainHash => ConnectedChainInfo\n    mapping(bytes32 => ConnectedChainInfo) public connectedChains;\n    //   schainHash => contract address => allowed\n    // solhint-disable-next-line private-vars-leading-underscore\n    mapping(bytes32 => mapping(address => bool)) internal deprecatedRegistryContracts;\n\n    uint256 public gasLimit;\n\n    /**\n     * @dev Emitted for every outgoing message to schain.\n     */\n    event OutgoingMessage(\n        bytes32 indexed dstChainHash,\n        uint256 indexed msgCounter,\n        address indexed srcContract,\n        address dstContract,\n        bytes data\n    );\n\n    /**\n     * @dev Emitted when function `postMessage` returns revert.\n     *  Used to prevent stuck loop inside function `postIncomingMessages`.\n     */\n    event PostMessageError(\n        uint256 indexed msgCounter,\n        bytes message\n    );\n\n    /**\n     * @dev Emitted when gas limit per one call of `postMessage` was changed.\n     */\n    event GasLimitWasChanged(\n        uint256 oldValue,\n        uint256 newValue\n    );\n\n    /**\n     * @dev Emitted when the version was updated\n     */\n    event VersionUpdated(string oldVersion, string newVersion);\n\n    /**\n     * @dev Emitted when extra contract was added.\n     */\n    event ExtraContractRegistered(\n        bytes32 indexed chainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Emitted when extra contract was removed.\n     */\n    event ExtraContractRemoved(\n        bytes32 indexed chainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {CHAIN_CONNECTOR_ROLE}.\n     */\n    modifier onlyChainConnector() {\n        require(hasRole(CHAIN_CONNECTOR_ROLE, msg.sender), \"CHAIN_CONNECTOR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {EXTRA_CONTRACT_REGISTRAR_ROLE}.\n     */\n    modifier onlyExtraContractRegistrar() {\n        require(hasRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender), \"EXTRA_CONTRACT_REGISTRAR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {CONSTANT_SETTER_ROLE}.\n     */\n    modifier onlyConstantSetter() {\n        require(hasRole(CONSTANT_SETTER_ROLE, msg.sender), \"Not enough permissions to set constant\");\n        _;\n    }    \n\n    /**\n     * @dev Sets gasLimit to a new value.\n     * \n     * Requirements:\n     * \n     * - `msg.sender` must be granted CONSTANT_SETTER_ROLE.\n     */\n    function setNewGasLimit(uint256 newGasLimit) external override onlyConstantSetter {\n        emit GasLimitWasChanged(gasLimit, newGasLimit);\n        gasLimit = newGasLimit;\n    }\n\n    /**\n     * @dev Virtual function for `postIncomingMessages`.\n     */\n    function postIncomingMessages(\n        string calldata fromSchainName,\n        uint256 startingCounter,\n        Message[] calldata messages,\n        Signature calldata sign\n    )\n        external\n        virtual\n        override;\n\n    /**\n     * @dev Allows `msg.sender` to register extra contract for all schains\n     * for being able to transfer messages from custom contracts.\n     * \n     * Requirements:\n     * \n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     * - Passed address should be contract.\n     * - Extra contract must not be registered.\n     */\n    function registerExtraContractForAll(address extraContract) external override onlyExtraContractRegistrar {\n        require(extraContract.isContract(), \"Given address is not a contract\");\n        require(!_getRegistryContracts()[bytes32(0)].contains(extraContract), \"Extra contract is already registered\");\n        _getRegistryContracts()[bytes32(0)].add(extraContract);\n        emit ExtraContractRegistered(bytes32(0), extraContract);\n    }\n\n    /**\n     * @dev Allows `msg.sender` to remove extra contract for all schains.\n     * Extra contract will no longer be able to send messages through MessageProxy.\n     * \n     * Requirements:\n     * \n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     */\n    function removeExtraContractForAll(address extraContract) external override onlyExtraContractRegistrar {\n        require(_getRegistryContracts()[bytes32(0)].contains(extraContract), \"Extra contract is not registered\");\n        _getRegistryContracts()[bytes32(0)].remove(extraContract);\n        emit ExtraContractRemoved(bytes32(0), extraContract);\n    }\n\n    /**\n     * @dev Should return length of contract registered by schainHash.\n     */\n    function getContractRegisteredLength(bytes32 schainHash) external view override returns (uint256) {\n        return _getRegistryContracts()[schainHash].length();\n    }\n\n    /**\n     * @dev Should return a range of contracts registered by schainHash.\n     * \n     * Requirements:\n     * range should be less or equal 10 contracts\n     */\n    function getContractRegisteredRange(\n        bytes32 schainHash,\n        uint256 from,\n        uint256 to\n    )\n        external\n        view\n        override\n        returns (address[] memory contractsInRange)\n    {\n        require(\n            from < to && to - from <= 10 && to <= _getRegistryContracts()[schainHash].length(),\n            \"Range is incorrect\"\n        );\n        contractsInRange = new address[](to - from);\n        for (uint256 i = from; i < to; i++) {\n            contractsInRange[i - from] = _getRegistryContracts()[schainHash].at(i);\n        }\n    }\n\n    /**\n     * @dev Returns number of outgoing messages.\n     * \n     * Requirements:\n     * \n     * - Target schain  must be initialized.\n     */\n    function getOutgoingMessagesCounter(string calldata targetSchainName)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        bytes32 dstChainHash = keccak256(abi.encodePacked(targetSchainName));\n        require(connectedChains[dstChainHash].inited, \"Destination chain is not initialized\");\n        return connectedChains[dstChainHash].outgoingMessageCounter;\n    }\n\n    /**\n     * @dev Returns number of incoming messages.\n     * \n     * Requirements:\n     * \n     * - Source schain must be initialized.\n     */\n    function getIncomingMessagesCounter(string calldata fromSchainName)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        bytes32 srcChainHash = keccak256(abi.encodePacked(fromSchainName));\n        require(connectedChains[srcChainHash].inited, \"Source chain is not initialized\");\n        return connectedChains[srcChainHash].incomingMessageCounter;\n    }\n\n    function initializeMessageProxy(uint newGasLimit) public initializer {\n        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(CHAIN_CONNECTOR_ROLE, msg.sender);\n        _setupRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender);\n        _setupRole(CONSTANT_SETTER_ROLE, msg.sender);\n        gasLimit = newGasLimit;\n    }\n\n    /**\n     * @dev Posts message from this contract to `targetChainHash` MessageProxy contract.\n     * This is called by a smart contract to make a cross-chain call.\n     * \n     * Emits an {OutgoingMessage} event.\n     *\n     * Requirements:\n     * \n     * - Target chain must be initialized.\n     * - Target chain must be registered as external contract.\n     */\n    function postOutgoingMessage(\n        bytes32 targetChainHash,\n        address targetContract,\n        bytes memory data\n    )\n        public\n        override\n        virtual\n    {\n        require(connectedChains[targetChainHash].inited, \"Destination chain is not initialized\");\n        _authorizeOutgoingMessageSender(targetChainHash);\n        \n        emit OutgoingMessage(\n            targetChainHash,\n            connectedChains[targetChainHash].outgoingMessageCounter,\n            msg.sender,\n            targetContract,\n            data\n        );\n\n        connectedChains[targetChainHash].outgoingMessageCounter += 1;\n    }\n\n    /**\n     * @dev Allows `CHAIN_CONNECTOR_ROLE` to remove connected chain from this contract.\n     * \n     * Requirements:\n     * \n     * - `msg.sender` must be granted `CHAIN_CONNECTOR_ROLE`.\n     * - `schainName` must be initialized.\n     */\n    function removeConnectedChain(string memory schainName) public virtual override onlyChainConnector {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(connectedChains[schainHash].inited, \"Chain is not initialized\");\n        delete connectedChains[schainHash];\n    }    \n\n    /**\n     * @dev Checks whether chain is currently connected.\n     */\n    function isConnectedChain(\n        string memory schainName\n    )\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return connectedChains[keccak256(abi.encodePacked(schainName))].inited;\n    }\n\n    /**\n     * @dev Checks whether contract is currently registered as extra contract.\n     */\n    function isContractRegistered(\n        bytes32 schainHash,\n        address contractAddress\n    )\n        public\n        view\n        override\n        returns (bool)\n    {\n        return _getRegistryContracts()[schainHash].contains(contractAddress);\n    }\n\n    /**\n     * @dev Allows MessageProxy to register extra contract for being able to transfer messages from custom contracts.\n     * \n     * Requirements:\n     * \n     * - Extra contract address must be contract.\n     * - Extra contract must not be registered.\n     * - Extra contract must not be registered for all chains.\n     */\n    function _registerExtraContract(\n        bytes32 chainHash,\n        address extraContract\n    )\n        internal\n    {      \n        require(extraContract.isContract(), \"Given address is not a contract\");\n        require(!_getRegistryContracts()[chainHash].contains(extraContract), \"Extra contract is already registered\");\n        require(\n            !_getRegistryContracts()[bytes32(0)].contains(extraContract),\n            \"Extra contract is already registered for all chains\"\n        );\n        \n        _getRegistryContracts()[chainHash].add(extraContract);\n        emit ExtraContractRegistered(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to remove extra contract,\n     * thus `extraContract` will no longer be available to transfer messages from mainnet to schain.\n     * \n     * Requirements:\n     * \n     * - Extra contract must be registered.\n     */\n    function _removeExtraContract(\n        bytes32 chainHash,\n        address extraContract\n    )\n        internal\n    {\n        require(_getRegistryContracts()[chainHash].contains(extraContract), \"Extra contract is not registered\");\n        _getRegistryContracts()[chainHash].remove(extraContract);\n        emit ExtraContractRemoved(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to connect schain with MessageProxyOnMainnet for transferring messages.\n     * \n     * Requirements:\n     * \n     * - `msg.sender` must be granted CHAIN_CONNECTOR_ROLE.\n     * - SKALE chain must not be connected.\n     */\n    function _addConnectedChain(bytes32 schainHash) internal onlyChainConnector {\n        require(!connectedChains[schainHash].inited,\"Chain is already connected\");\n        connectedChains[schainHash] = ConnectedChainInfo({\n            incomingMessageCounter: 0,\n            outgoingMessageCounter: 0,\n            inited: true\n        });\n    }\n\n    /**\n     * @dev Allows MessageProxy to send messages from schain to mainnet.\n     * Destination contract must implement `postMessage` method.\n     */\n    function _callReceiverContract(\n        bytes32 schainHash,\n        Message calldata message,\n        uint counter\n    )\n        internal\n        returns (address)\n    {\n        if (!message.destinationContract.isContract()) {\n            emit PostMessageError(\n                counter,\n                \"Destination contract is not a contract\"\n            );\n            return address(0);\n        }\n        try IMessageReceiver(message.destinationContract).postMessage{gas: gasLimit}(\n            schainHash,\n            message.sender,\n            message.data\n        ) returns (address receiver) {\n            return receiver;\n        } catch Error(string memory reason) {\n            emit PostMessageError(\n                counter,\n                bytes(reason)\n            );\n            return address(0);\n        } catch (bytes memory revertData) {\n            emit PostMessageError(\n                counter,\n                revertData\n            );\n            return address(0);\n        }\n    }\n\n    /**\n     * @dev Returns receiver of message.\n     */\n    function _getGasPayer(\n        bytes32 schainHash,\n        Message calldata message,\n        uint counter\n    )\n        internal\n        returns (address)\n    {\n        try IGasReimbursable(message.destinationContract).gasPayer{gas: gasLimit}(\n            schainHash,\n            message.sender,\n            message.data\n        ) returns (address receiver) {\n            return receiver;\n        } catch Error(string memory reason) {\n            emit PostMessageError(\n                counter,\n                bytes(reason)\n            );\n            return address(0);"
    }
  ]
}