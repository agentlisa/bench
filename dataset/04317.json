{
  "Title": "[L13] Nonexistent role can be set in Withdrawable contract",
  "Content": "The internal [`setWithdrawRole` function](https://github.com/UMAprotocol/protocol/blob/9d403ddb5f2f07194daefe7da51e0e0a6306f2c4/core/contracts/common/implementation/Withdrawable.sol#L47) of the `Withdrawable` contract can be used by derived contracts to set the role identifier allowed to withdraw Ether or tokens. However, the function does not validate whether the passed `roleId` argument is already registered. While [the functionâ€™s docstrings](https://github.com/UMAprotocol/protocol/blob/9d403ddb5f2f07194daefe7da51e0e0a6306f2c4/core/contracts/common/implementation/Withdrawable.sol#L44) explicitly state that the role must exist, this should be checked programmatically to avoid errors.\n\n\nConsider using the available [`onlyValidRole` modifier](https://github.com/UMAprotocol/protocol/blob/9d403ddb5f2f07194daefe7da51e0e0a6306f2c4/core/contracts/common/implementation/MultiRole.sol#L155) to effectively validate that the `roleId` argument exists.\n\n\n**Update:** *Fixed in [PR#1226](https://github.com/UMAprotocol/protocol/pull/1226).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "core/contracts/common/implementation/Withdrawable.sol",
      "content": "/**\n * Withdrawable contract.\n */\n\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./MultiRole.sol\";\n\n\n/**\n * @title Base contract that allows a specific role to withdraw any ETH and/or ERC20 tokens that the contract holds.\n */\ncontract Withdrawable is MultiRole {\n    uint private _roleId;\n\n    /**\n     * @notice Withdraws ETH from the contract.\n     */\n    function withdraw(uint amount) external onlyRoleHolder(_roleId) {\n        msg.sender.transfer(amount);\n    }\n\n    /**\n     * @notice Withdraws ERC20 tokens from the contract.\n     */\n    function withdrawErc20(address erc20Address, uint amount) external onlyRoleHolder(_roleId) {\n        IERC20 erc20 = IERC20(erc20Address);\n        require(erc20.transfer(msg.sender, amount));\n    }\n\n    /**\n     * @notice Internal method that allows derived contracts to create a role for withdrawal.\n     * @dev Either this method or `setWithdrawRole` must be called by the derived class for this contract to function\n     * properly.\n     */\n    function createWithdrawRole(uint roleId, uint managingRoleId, address owner) internal {\n        _roleId = roleId;\n        _createExclusiveRole(roleId, managingRoleId, owner);\n    }\n\n    /**\n     * @notice Internal method that allows derived contracts to choose the role for withdrawal.\n     * @dev The role `roleId` must exist. Either this method or `createWithdrawRole` must be called by the derived class\n     * for this contract to function properly.\n     */\n    function setWithdrawRole(uint roleId) internal {\n        _roleId = roleId;\n    }\n}"
    },
    {
      "filename": "core/contracts/common/implementation/MultiRole.sol",
      "content": "pragma solidity ^0.6.0;\n\n\nlibrary Exclusive {\n    struct RoleMembership {\n        address member;\n    }\n\n    function isMember(RoleMembership storage roleMembership, address memberToCheck) internal view returns (bool) {\n        return roleMembership.member == memberToCheck;\n    }\n\n    function resetMember(RoleMembership storage roleMembership, address newMember) internal {\n        require(newMember != address(0x0), \"Cannot set an exclusive role to 0x0\");\n        roleMembership.member = newMember;\n    }\n\n    function getMember(RoleMembership storage roleMembership) internal view returns (address) {\n        return roleMembership.member;\n    }\n\n    function init(RoleMembership storage roleMembership, address initialMember) internal {\n        resetMember(roleMembership, initialMember);\n    }\n}\n\n\nlibrary Shared {\n    struct RoleMembership {\n        mapping(address => bool) members;\n    }\n\n    function isMember(RoleMembership storage roleMembership, address memberToCheck) internal view returns (bool) {\n        return roleMembership.members[memberToCheck];\n    }\n\n    function addMember(RoleMembership storage roleMembership, address memberToAdd) internal {\n        roleMembership.members[memberToAdd] = true;\n    }\n\n    function removeMember(RoleMembership storage roleMembership, address memberToRemove) internal {\n        roleMembership.members[memberToRemove] = false;\n    }\n\n    function init(RoleMembership storage roleMembership, address[] memory initialMembers) internal {\n        for (uint i = 0; i < initialMembers.length; i++) {\n            addMember(roleMembership, initialMembers[i]);\n        }\n    }\n}\n\n\n/**\n * @title Base class to manage permissions for the derived class.\n */\ncontract MultiRole {\n    using Exclusive for Exclusive.RoleMembership;\n    using Shared for Shared.RoleMembership;\n\n    enum RoleType { Invalid, Exclusive, Shared }\n\n    struct Role {\n        uint managingRole;\n        RoleType roleType;\n        Exclusive.RoleMembership exclusiveRoleMembership;\n        Shared.RoleMembership sharedRoleMembership;\n    }\n\n    mapping(uint => Role) private roles;\n\n    /**\n     * @notice Reverts unless the caller is a member of the specified roleId.\n     */\n    modifier onlyRoleHolder(uint roleId) {\n        require(holdsRole(roleId, msg.sender), \"Sender does not hold required role\");\n        _;\n    }\n\n    /**\n     * @notice Reverts unless the caller is a member of the manager role for the specified roleId.\n     */\n    modifier onlyRoleManager(uint roleId) {\n        require(holdsRole(roles[roleId].managingRole, msg.sender), \"Can only be called by a role manager\");\n        _;\n    }\n\n    /**\n     * @notice Reverts unless the roleId represents an initialized, exclusive roleId.\n     */\n    modifier onlyExclusive(uint roleId) {\n        require(roles[roleId].roleType == RoleType.Exclusive, \"Must be called on an initialized Exclusive role\");\n        _;\n    }\n\n    /**\n     * @notice Reverts unless the roleId represents an initialized, shared roleId.\n     */\n    modifier onlyShared(uint roleId) {\n        require(roles[roleId].roleType == RoleType.Shared, \"Must be called on an initialized Shared role\");\n        _;\n    }\n\n    /**\n     * @notice Whether `memberToCheck` is a member of roleId.\n     * @dev Reverts if roleId does not correspond to an initialized role.\n     */\n    function holdsRole(uint roleId, address memberToCheck) public view returns (bool) {\n        Role storage role = roles[roleId];\n        if (role.roleType == RoleType.Exclusive) {\n            return role.exclusiveRoleMembership.isMember(memberToCheck);\n        } else if (role.roleType == RoleType.Shared) {\n            return role.sharedRoleMembership.isMember(memberToCheck);\n        }\n        require(false, \"Invalid roleId\");\n    }\n\n    /**\n     * @notice Changes the exclusive role holder of `roleId` to `newMember`.\n     * @dev Reverts if the caller is not a member of the managing role for `roleId` or if `roleId` is not an\n     * initialized, exclusive role.\n     */\n    function resetMember(uint roleId, address newMember) public onlyExclusive(roleId) onlyRoleManager(roleId) {\n        roles[roleId].exclusiveRoleMembership.resetMember(newMember);\n    }\n\n    /**\n     * @notice Gets the current holder of the exclusive role, `roleId`.\n     * @dev Reverts if `roleId` does not represent an initialized, exclusive role.\n     */\n    function getMember(uint roleId) public view onlyExclusive(roleId) returns (address) {\n        return roles[roleId].exclusiveRoleMembership.getMember();\n    }\n\n    /**\n     * @notice Adds `newMember` to the shared role, `roleId`.\n     * @dev Reverts if `roleId` does not represent an initialized, shared role or if the caller is not a member of the\n     * managing role for `roleId`.\n     */\n    function addMember(uint roleId, address newMember) public onlyShared(roleId) onlyRoleManager(roleId) {\n        roles[roleId].sharedRoleMembership.addMember(newMember);\n    }\n\n    /**\n     * @notice Removes `memberToRemove` from the shared role, `roleId`.\n     * @dev Reverts if `roleId` does not represent an initialized, shared role or if the caller is not a member of the\n     * managing role for `roleId`.\n     */\n    function removeMember(uint roleId, address memberToRemove) public onlyShared(roleId) onlyRoleManager(roleId) {\n        roles[roleId].sharedRoleMembership.removeMember(memberToRemove);\n    }\n\n    /**\n     * @notice Reverts if `roleId` is not initialized.\n     */\n    modifier onlyValidRole(uint roleId) {\n        require(roles[roleId].roleType != RoleType.Invalid, \"Attempted to use an invalid roleId\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if `roleId` is initialized.\n     */\n    modifier onlyInvalidRole(uint roleId) {\n        require(roles[roleId].roleType == RoleType.Invalid, \"Cannot use a pre-existing role\");\n        _;\n    }\n\n    /**\n     * @notice Internal method to initialize a shared role, `roleId`, which will be managed by `managingRoleId`.\n     * `initialMembers` will be immediately added to the role.\n     * @dev Should be called by derived contracts, usually at construction time. Will revert if the role is already\n     * initialized.\n     */\n    function _createSharedRole(uint roleId, uint managingRoleId, address[] memory initialMembers)\n        internal\n        onlyInvalidRole(roleId)\n    {\n        Role storage role = roles[roleId];\n        role.roleType = RoleType.Shared;\n        role.managingRole = managingRoleId;\n        role.sharedRoleMembership.init(initialMembers);\n        require(\n            roles[managingRoleId].roleType != RoleType.Invalid,\n            \"Attempted to use an invalid role to manage a shared role\"\n        );\n    }\n\n    /**\n     * @notice Internal method to initialize a exclusive role, `roleId`, which will be managed by `managingRoleId`.\n     * `initialMembers` will be immediately added to the role.\n     * @dev Should be called by derived contracts, usually at construction time. Will revert if the role is already\n     * initialized.\n     */\n    function _createExclusiveRole(uint roleId, uint managingRoleId, address initialMember)\n        internal\n        onlyInvalidRole(roleId)\n    {\n        Role storage role = roles[roleId];\n        role.roleType = RoleType.Exclusive;\n        role.managingRole = managingRoleId;\n        role.exclusiveRoleMembership.init(initialMember);\n        require(\n            roles[managingRoleId].roleType != RoleType.Invalid,\n            \"Attempted to use an invalid role to manage an exclusive role\"\n        );\n    }\n}"
    }
  ]
}