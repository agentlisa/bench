{
  "Title": "M-3: Oracle will not failover as expected during liquidation",
  "Content": "# Issue M-3: Oracle will not failover as expected during liquidation \n\nSource: https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/177 \n\n## Found by \n0xLogos, Stryder, alexzoid, evmboi32, ge6a, gqrp, jennifer37, nobody2018, trauki, xiaoming90\n## Summary\n\nOracle will not failover as expected during liquidation. If the liquidation cannot be executed due to the revert described in the following scenario, underwater positions and bad debt accumulate in the protocol, threatening the solvency of the protocol.\n\n## Vulnerability Detail\n\nThe liquidators have the option to update the Pyth price during liquidation. If the liquidators do not intend to update the Pyth price during liquidation, they have to call the second `liquidate(uint256 tokenId)` function at Line 85 below directly, which does not have the `updatePythPrice` modifier.\n\nhttps://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/LiquidationModule.sol#L75\n\n```solidity\nFile: LiquidationModule.sol\n75:     function liquidate(\n76:         uint256 tokenID,\n77:         bytes[] calldata priceUpdateData\n78:     ) external payable whenNotPaused updatePythPrice(vault, msg.sender, priceUpdateData) {\n79:         liquidate(tokenID);\n80:     }\n81: \n82:     /// @notice Function to liquidate a position.\n83:     /// @dev One could directly call this method instead of `liquidate(uint256, bytes[])` if they don't want to update the Pyth price.\n84:     /// @param tokenId The token ID of the leverage position.\n85:     function liquidate(uint256 tokenId) public nonReentrant whenNotPaused liquidationInvariantChecks(vault, tokenId) {\n86:         FlatcoinStructs.Position memory position = vault.getPosition(tokenId);\n```\n\nIt was understood from the protocol team that the rationale for allowing the liquidators to execute a liquidation without updating the Pyth price is to ensure that the liquidations will work regardless of Pyth's working status, in which case Chainlink is the fallback, and the last oracle price will be used for the liquidation.\n\nHowever, upon further review, it was found that the fallback mechanism within the FlatCoin protocol does not work as expected by the protocol team.\n\nAssume that Pyth is down. In this case, no one would be able to fetch the latest off-chain price from Pyth network and update Pyth on-chain contract. As a result, the prices stored in the Pyth on-chain contract will become outdated and stale. \n\nWhen liquidation is executed in FlatCoin protocol, the following `_getPrice` function will be executed to fetch the price. Line 107 below will fetch the latest price from Chainlink, while Line 108 below will fetch the last available price on the Pyth on-chain contract. When the Pyth on-chain prices have not been updated for a period of time, the deviation between `onchainPrice` and `offchainPrice` will widen till a point where `diffPercent > maxDiffPercent` and a revert will occur at Line 113 below, thus blocking the liquidation from being carried out. As a result, the liquidation mechanism within the FlatCoin protocol will stop working.\n\nAlso, the protocol team's goal of allowing the liquidators to execute a liquidation without updating the Pyth price to ensure that the liquidations will work regardless of Pyth's working status will not be achieved.\n\nhttps://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/OracleModule.sol#L113\n\n```solidity\nFile: OracleModule.sol\n102:     /// @notice Returns the latest 18 decimal price of asset from either Pyth.network or Chainlink.\n103:     /// @dev It verifies the Pyth network price against Chainlink price (ensure that it is within a threshold).\n104:     /// @return price The latest 18 decimal price of asset.\n105:     /// @return timestamp The timestamp of the latest price.\n106:     function _getPrice(uint32 maxAge) internal view returns (uint256 price, uint256 timestamp) {\n107:         (uint256 onchainPrice, uint256 onchainTime) = _getOnchainPrice(); // will revert if invalid\n108:         (uint256 offchainPrice, uint256 offchainTime, bool offchainInvalid) = _getOffchainPrice();\n109:         bool offchain;\n110: \n111:         uint256 priceDiff = (int256(onchainPrice) - int256(offchainPrice)).abs();\n112:         uint256 diffPercent = (priceDiff * 1e18) / onchainPrice;\n113:         if (diffPercent > maxDiffPercent) revert FlatcoinErrors.PriceMismatch(diffPercent);\n114: \n115:         if (offchainInvalid == false) {\n116:             // return the freshest price\n117:             if (offchainTime >= onchainTime) {\n118:                 price = offchainPrice;\n119:                 timestamp = offchainTime;\n120:                 offchain = true;\n121:             } else {\n122:                 price = onchainPrice;\n123:                 timestamp = onchainTime;\n124:             }\n125:         } else {\n126:             price = onchainPrice;\n127:             timestamp = onchainTime;\n128:         }\n129: \n130:         // Check that the timestamp is within the required age\n131:         if (maxAge < type(uint32).max && timestamp + maxAge < block.timestamp) {\n132:             revert FlatcoinErrors.PriceStale(\n133:                 offchain ? FlatcoinErrors.PriceSource.OffChain : FlatcoinErrors.PriceSource.OnChain\n134:             );\n135:         }\n136:     }\n```\n\n## Impact\n\nThe liquidation mechanism is the core component of the protocol and is important to the solvency of the protocol. If the liquidation cannot be executed due to the revert described in the above scenario, underwater positions and bad debt accumulate in the protocol threaten the solvency of the protocol.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/LiquidationModule.sol#L75\n\nhttps://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/OracleModule.sol#L113C10-L113C92\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider implementing a feature to allow the protocol team to disable the price deviation check so that the protocol team can disable it in the event that Pyth network is down for an extended period of time.\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid: high(4)\n\n\n\n**sherlock-admin**\n\nThe protocol team fixed this issue in PR/commit https://github.com/dhedge/flatcoin-v1/pull/270.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/132",
  "Code": [
    {
      "filename": "flatcoin-v1/src/LiquidationModule.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\n\nimport {Initializable} from \"openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\n\nimport {ModuleUpgradeable} from \"./abstracts/ModuleUpgradeable.sol\";\nimport {OracleModifiers} from \"./abstracts/OracleModifiers.sol\";\nimport {FlatcoinErrors} from \"./libraries/FlatcoinErrors.sol\";\nimport {FlatcoinStructs} from \"./libraries/FlatcoinStructs.sol\";\nimport {FlatcoinModuleKeys} from \"./libraries/FlatcoinModuleKeys.sol\";\nimport {FlatcoinEvents} from \"./libraries/FlatcoinEvents.sol\";\nimport {PerpMath} from \"./libraries/PerpMath.sol\";\nimport {InvariantChecks} from \"./misc/InvariantChecks.sol\";\n\nimport {IFlatcoinVault} from \"./interfaces/IFlatcoinVault.sol\";\nimport {ILeverageModule} from \"./interfaces/ILeverageModule.sol\";\nimport {IOracleModule} from \"./interfaces/IOracleModule.sol\";\nimport {ILiquidationModule} from \"./interfaces/ILiquidationModule.sol\";\nimport {ILimitOrder} from \"./interfaces/ILimitOrder.sol\";\n\n/// @title LiquidationModule\n/// @author dHEDGE\n/// @notice Module for liquidating leveraged positions.\ncontract LiquidationModule is\n    ILiquidationModule,\n    Initializable,\n    ModuleUpgradeable,\n    OracleModifiers,\n    ReentrancyGuardUpgradeable,\n    InvariantChecks\n{\n    /// @notice Liquidation fee basis points paid to liquidator.\n    /// @dev Note that this needs to be used together with keeper fee bounds.\n    /// @dev Should include 18 decimals i.e, 0.2% => 0.002e18 => 2e15\n    uint128 public liquidationFeeRatio;\n\n    /// @notice Liquidation price buffer in basis points to prevent negative margin on liquidation.\n    /// @dev Should include 18 decimals i.e, 0.75% => 0.0075e18 => 75e14\n    uint128 public liquidationBufferRatio;\n\n    /// @notice Upper bound for the liquidation fee.\n    /// @dev Denominated in USD.\n    uint256 public liquidationFeeUpperBound;\n\n    /// @notice Lower bound for the liquidation fee.\n    /// @dev Denominated in USD.\n    uint256 public liquidationFeeLowerBound;\n\n    /// @dev To prevent the implementation contract from being used, we invoke the _disableInitializers\n    /// function in the constructor to automatically lock it when it is deployed.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        IFlatcoinVault _vault,\n        uint128 _liquidationFeeRatio,\n        uint128 _liquidationBufferRatio,\n        uint256 _liquidationFeeLowerBound,\n        uint256 _liquidationFeeUpperBound\n    ) external initializer {\n        __Module_init(FlatcoinModuleKeys._LIQUIDATION_MODULE_KEY, _vault);\n\n        setLiquidationFeeRatio(_liquidationFeeRatio);\n        setLiquidationBufferRatio(_liquidationBufferRatio);\n        setLiquidationFeeBounds(_liquidationFeeLowerBound, _liquidationFeeUpperBound);\n    }\n\n    /////////////////////////////////////////////\n    //         Public Write Functions          //\n    /////////////////////////////////////////////\n\n    function liquidate(\n        uint256 tokenID,\n        bytes[] calldata priceUpdateData\n    ) external payable whenNotPaused updatePythPrice(vault, msg.sender, priceUpdateData) {\n        liquidate(tokenID);\n    }\n\n    /// @notice Function to liquidate a position.\n    /// @dev One could directly call this method instead of `liquidate(uint256, bytes[])` if they don't want to update the Pyth price.\n    /// @param tokenId The token ID of the leverage position.\n    function liquidate(uint256 tokenId) public nonReentrant whenNotPaused liquidationInvariantChecks(vault, tokenId) {\n        FlatcoinStructs.Position memory position = vault.getPosition(tokenId);\n\n        (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice();\n\n        // Settle funding fees accrued till now.\n        vault.settleFundingFees();\n\n        // Check if the position can indeed be liquidated.\n        if (!canLiquidate(tokenId)) revert FlatcoinErrors.CannotLiquidate(tokenId);\n\n        FlatcoinStructs.PositionSummary memory positionSummary = PerpMath._getPositionSummary(\n            position,\n            vault.cumulativeFundingRate(),\n            currentPrice\n        );\n\n        // Check that the total margin deposited by the long traders is not -ve.\n        // To get this amount, we will have to account for the PnL and funding fees accrued.\n        int256 settledMargin = positionSummary.marginAfterSettlement;\n\n        uint256 liquidatorFee;\n\n        // If the settled margin is greater than 0, send a portion (or all) of the margin to the liquidator and LPs.\n        if (settledMargin > 0) {\n            // Calculate the liquidation fees to be sent to the caller.\n            uint256 expectedLiquidationFee = PerpMath._liquidationFee(\n                position.additionalSize,\n                liquidationFeeRatio,\n                liquidationFeeLowerBound,\n                liquidationFeeUpperBound,\n                currentPrice\n            );\n\n            uint256 remainingMargin;\n\n            // Calculate the remaining margin after accounting for liquidation fees.\n            // If the settled margin is less than the liquidation fee, then the liquidator fee is the settled margin.\n            if (uint256(settledMargin) > expectedLiquidationFee) {\n                liquidatorFee = expectedLiquidationFee;\n                remainingMargin = uint256(settledMargin) - expectedLiquidationFee;\n            } else {\n                liquidatorFee = uint256(settledMargin);\n            }\n\n            // Adjust the stable collateral total to account for user's remaining margin.\n            // If the remaining margin is greater than 0, this goes to the LPs.\n            // Note that {`remainingMargin` - `profitLoss`} is the same as {`marginDeposited` + `accruedFunding`}.\n            vault.updateStableCollateralTotal(int256(remainingMargin) - positionSummary.profitLoss);\n\n            // Send the liquidator fee to the caller of the function.\n            // If the liquidation fee is greater than the remaining margin, then send the remaining margin.\n            vault.sendCollateral(msg.sender, liquidatorFee);\n        } else {\n            // If the settled margin is -ve then the LPs have to bear the cost.\n            // Adjust the stable collateral total to account for user's profit/loss and the negative margin.\n            // Note: We are adding `settledMargin` and `profitLoss` instead of subtracting because of their sign (which will be -ve).\n            vault.updateStableCollateralTotal(settledMargin - positionSummary.profitLoss);\n        }\n\n        // Update the global position data.\n        // Note that we are only accounting for `globalMarginDelta`, `marginDeposited` and `userAccruedFunding`.\n        // and not the PnL of the user when altering `marginDepositedTotal`.\n        // This is because the PnL is already accounted for in the `stableCollateralTotal`.\n        // So when the PnL is +ve (the trader made profits), the trader takes the profit along with the margin deposited.\n        // When the PnL is -ve, the trader loses a portion of the margin deposited to the LPs and the rest is again taken along.\n        // In neither case, the PnL is added/subtracted to/from the `marginDepositedTotal`.\n        // Now we are subtracting `userAccruedFunding` in the below function call because:\n        //      `globalMarginDelta` = `userAccruedFunding` + Funding accrued by the rest of the long traders.\n        // And this accrued funding is being taken away from the system (if +ve) or given to LPs (if -ve).\n        // When the `userAccruedFunding` is +ve, the user takes away the funding fees earned.\n        // When it's negative, the user pays the funding fees to the LPs and their margin is reduced.\n        // So the `marginDepositedTotal` is added with `userAccruedFunding` in the below function call as the user has paid for their share\n        // of funding fees.\n        vault.updateGlobalPositionData({\n            price: position.lastPrice,\n            marginDelta: -(int256(position.marginDeposited) + positionSummary.accruedFunding),\n            additionalSizeDelta: -int256(position.additionalSize) // Since position is being closed, additionalSizeDelta should be negative.\n        });\n\n        // Delete position storage\n        vault.deletePosition(tokenId);\n\n        // Cancel any limit orders associated with the position\n        ILimitOrder(vault.moduleAddress(FlatcoinModuleKeys._LIMIT_ORDER_KEY)).cancelExistingLimitOrder(tokenId);\n\n        // If the position token is locked because of an announced order, it should still be liquidatable\n        ILeverageModule leverageModule = ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY));\n        leverageModule.unlock(tokenId);\n        leverageModule.burn(tokenId);\n\n        emit FlatcoinEvents.PositionLiquidated(tokenId, msg.sender, liquidatorFee);\n    }\n\n    /////////////////////////////////////////////\n    //             View Functions              //\n    /////////////////////////////////////////////\n\n    /// @notice Function to calculate liquidation price for a given position.\n    /// @dev Note that liquidation price is influenced by the funding rates and also the current price.\n    /// @param tokenId The token ID of the leverage position.\n    /// @return liqPrice The liquidation price in $ terms.\n    function liquidationPrice(uint256 tokenId) public view returns (uint256 liqPrice) {\n        (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice();\n\n        return liquidationPrice(tokenId, currentPrice);\n    }\n\n    /// @notice Function to calculate liquidation price for a given position at a given price.\n    /// @dev Note that liquidation price is influenced by the funding rates and also the current price.\n    /// @param tokenId The token ID of the leverage position.\n    /// @param price The price at which the liquidation price is to be calculated.\n    /// @return liqPrice The liquidation price in $ terms.\n    function liquidationPrice(uint256 tokenId, uint256 price) public view returns (uint256 liqPrice) {\n        FlatcoinStructs.Position memory position = vault.getPosition(tokenId);\n\n        int256 nextFundingEntry = _accountFundingFees();\n\n        return\n            PerpMath._approxLiquidationPrice({\n                position: position,\n                nextFundingEntry: nextFundingEntry,\n                liquidationFeeRatio: liquidationFeeRatio,\n                liquidationBufferRatio: liquidationBufferRatio,\n                liquidationFeeLowerBound: liquidationFeeLowerBound,\n                liquidationFeeUpperBound: liquidationFeeUpperBound,\n                currentPrice: price\n            });\n    }\n\n    /// @notice Function which determines if a leverage position can be liquidated or not.\n    /// @param tokenId The token ID of the leverage position.\n    /// @return liquidatable True if the position can be liquidated, false otherwise.\n    function canLiquidate(uint256 tokenId) public view returns (bool liquidatable) {\n        // Get the current price from the oracle module.\n        (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice();\n\n        return canLiquidate(tokenId, currentPrice);\n    }\n\n    function canLiquidate(uint256 tokenId, uint256 price) public view returns (bool liquidatable) {\n        FlatcoinStructs.Position memory position = vault.getPosition(tokenId);\n\n        int256 nextFundingEntry = _accountFundingFees();\n\n        return\n            PerpMath._canLiquidate({\n                position: position,\n                liquidationFeeRatio: liquidationFeeRatio,\n                liquidationBufferRatio: liquidationBufferRatio,\n                liquidationFeeLowerBound: liquidationFeeLowerBound,\n                liquidationFeeUpperBound: liquidationFeeUpperBound,\n                nextFundingEntry: nextFundingEntry,\n                currentPrice: price\n            });\n    }\n\n    /// @notice Function to calculate the liquidation fee awarded for a liquidating a given position.\n    /// @param tokenId The token ID of the leverage position.\n    /// @return liquidationFee The liquidation fee in collateral units.\n    function getLiquidationFee(uint256 tokenId) public view returns (uint256 liquidationFee) {\n        // Get the latest price from the oracle module.\n        (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice();\n\n        return\n            PerpMath._liquidationFee(\n                vault.getPosition(tokenId).additionalSize,\n                liquidationFeeRatio,\n                liquidationFeeLowerBound,\n                liquidationFeeUpperBound,\n                currentPrice\n            );\n    }\n\n    /// @notice Function to calculate the liquidation margin for a given additional size amount.\n    /// @param additionalSize The additional size amount for which the liquidation margin is to be calculated.\n    /// @return liquidationMargin The liquidation margin in collateral units.\n    function getLiquidationMargin(uint256 additionalSize) public view returns (uint256 liquidationMargin) {\n        // Get the latest price from the oracle module.\n        (uint256 currentPrice, ) = IOracleModule(vault.moduleAddress(FlatcoinModuleKeys._ORACLE_MODULE_KEY)).getPrice();\n\n        return getLiquidationMargin(additionalSize, currentPrice);\n    }\n\n    /// @notice Function to calculate the liquidation margin for a given additional size amount and price.\n    /// @param additionalSize The additional size amount for which the liquidation margin is to be calculated.\n    /// @param price The price at which the liquidation margin is to be calculated.\n    /// @return liquidationMargin The liquidation margin in collateral units.\n    function getLiquidationMargin(\n        uint256 additionalSize,\n        uint256 price\n    ) public view returns (uint256 liquidationMargin) {\n        return\n            PerpMath._liquidationMargin(\n                additionalSize,\n                liquidationFeeRatio,\n                liquidationBufferRatio,\n                liquidationFeeLowerBound,\n                liquidationFeeUpperBound,\n                price\n            );\n    }\n\n    /////////////////////////////////////////////\n    //            Owner Functions              //\n    /////////////////////////////////////////////\n\n    function setLiquidationFeeRatio(uint128 _newLiquidationFeeRatio) public onlyOwner {\n        if (_newLiquidationFeeRatio == 0) revert FlatcoinErrors.ZeroValue(\"newLiquidationFeeRatio\");\n\n        emit FlatcoinEvents.LiquidationFeeRatioModified(liquidationFeeRatio, _newLiquidationFeeRatio);\n\n        liquidationFeeRatio = _newLiquidationFeeRatio;\n    }\n\n    function setLiquidationBufferRatio(uint128 _newLiquidationBufferRatio) public onlyOwner {\n        if (_newLiquidationBufferRatio == 0) revert FlatcoinErrors.ZeroValue(\"newLiquidationBufferRatio\");\n\n        emit FlatcoinEvents.LiquidationBufferRatioModified(liquidationBufferRatio, _newLiquidationBufferRatio);\n\n        liquidationBufferRatio = _newLiquidationBufferRatio;\n    }\n\n    function setLiquidationFeeBounds(\n        uint256 _newLiquidationFeeLowerBound,\n        uint256 _newLiquidationFeeUpperBound\n    ) public onlyOwner {\n        if (_newLiquidationFeeUpperBound == 0 || _newLiquidationFeeLowerBound == 0)\n            revert FlatcoinErrors.ZeroValue(\"newLiquidationFee\");\n        if (_newLiquidationFeeUpperBound < _newLiquidationFeeLowerBound)\n            revert FlatcoinErrors.InvalidBounds(_newLiquidationFeeLowerBound, _newLiquidationFeeUpperBound);\n\n        emit FlatcoinEvents.LiquidationFeeBoundsModified(\n            liquidationFeeLowerBound,\n            liquidationFeeUpperBound,\n            _newLiquidationFeeLowerBound,\n            _newLiquidationFeeUpperBound\n        );\n\n        liquidationFeeLowerBound = _newLiquidationFeeLowerBound;\n        liquidationFeeUpperBound = _newLiquidationFeeUpperBound;\n    }\n\n    /////////////////////////////////////////////\n    //           Internal Functions            //\n    /////////////////////////////////////////////\n\n    /// @dev Accounts for the funding fees based on the market state.\n    /// @return nextFundingEntry The cumulative funding rate based on the latest market state.\n    function _accountFundingFees() internal view returns (int256 nextFundingEntry) {\n        uint256 stableCollateralTotal = vault.stableCollateralTotal();\n        int256 currMarketSkew = int256(vault.getGlobalPositions().sizeOpenedTotal) - int256(stableCollateralTotal);\n\n        int256 currentFundingRate = PerpMath._currentFundingRate({\n            proportionalSkew: PerpMath._proportionalSkew({\n                skew: currMarketSkew,\n                stableCollateralTotal: stableCollateralTotal\n            }),\n            lastRecomputedFundingRate: vault.lastRecomputedFundingRate(),\n            lastRecomputedFundingTimestamp: vault.lastRecomputedFundingTimestamp(),\n            maxFundingVelocity: vault.maxFundingVelocity(),\n            maxVelocitySkew: vault.maxVelocitySkew()\n        });\n\n        int256 unrecordedFunding = PerpMath._unrecordedFunding(\n            currentFundingRate,\n            vault.lastRecomputedFundingRate(),\n            vault.lastRecomputedFundingTimestamp()\n        );\n\n        return PerpMath._nextFundingEntry(unrecordedFunding, vault.cumulativeFundingRate());\n    }\n}"
    },
    {
      "filename": "flatcoin-v1/src/OracleModule.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\n\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SafeCastUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/utils/math/SafeCastUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/contracts/interfaces/IERC20Upgradeable.sol\";\nimport {SignedMath} from \"openzeppelin-contracts/contracts/utils/math/SignedMath.sol\";\nimport {IPyth} from \"pyth-sdk-solidity/IPyth.sol\";\nimport {PythStructs} from \"pyth-sdk-solidity/PythStructs.sol\";\n\nimport {FlatcoinErrors} from \"./libraries/FlatcoinErrors.sol\";\nimport {FlatcoinStructs} from \"./libraries/FlatcoinStructs.sol\";\nimport {FlatcoinModuleKeys} from \"./libraries/FlatcoinModuleKeys.sol\";\nimport {FlatcoinEvents} from \"./libraries/FlatcoinEvents.sol\";\nimport {ModuleUpgradeable} from \"./abstracts/ModuleUpgradeable.sol\";\n\nimport {IFlatcoinVault} from \"./interfaces/IFlatcoinVault.sol\";\nimport {IOracleModule} from \"./interfaces/IOracleModule.sol\";\nimport {IChainlinkAggregatorV3} from \"./interfaces/IChainlinkAggregatorV3.sol\";\n\n/// @title OracleModule\n/// @author dHEDGE\n/// @notice Can query collateral oracle price.\n/// @dev Interfaces with onchain and offchain oracles (eg. Chainlink and Pyth network).\ncontract OracleModule is IOracleModule, ModuleUpgradeable, ReentrancyGuardUpgradeable {\n    using SafeCastUpgradeable for *;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SignedMath for int256;\n\n    address public asset; // Asset to price\n\n    FlatcoinStructs.OnchainOracle public onchainOracle; // Onchain Chainlink oracle\n\n    FlatcoinStructs.OffchainOracle public offchainOracle; // Offchain Pyth network oracle\n\n    // Max difference between onchain and offchain oracle. 1e18 = 100%\n    uint256 public maxDiffPercent;\n\n    /// @dev To prevent the implementation contract from being used, we invoke the _disableInitializers\n    /// function in the constructor to automatically lock it when it is deployed.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Function to initialize this contract.\n    function initialize(\n        IFlatcoinVault _vault,\n        address _asset,\n        FlatcoinStructs.OnchainOracle calldata _onchainOracle,\n        FlatcoinStructs.OffchainOracle calldata _offchainOracle,\n        uint256 _maxDiffPercent\n    ) external initializer {\n        __Module_init(FlatcoinModuleKeys._ORACLE_MODULE_KEY, _vault);\n        __ReentrancyGuard_init();\n\n        _setAsset(_asset);\n        _setOnchainOracle(_onchainOracle);\n        _setOffchainOracle(_offchainOracle);\n        _setMaxDiffPercent(_maxDiffPercent);\n    }\n\n    function updatePythPrice(address sender, bytes[] calldata priceUpdateData) external payable nonReentrant {\n        // Get fee amount to pay to Pyth\n        uint256 fee = offchainOracle.oracleContract.getUpdateFee(priceUpdateData);\n\n        // Update the price data (and pay the fee)\n        offchainOracle.oracleContract.updatePriceFeeds{value: fee}(priceUpdateData);\n\n        if (msg.value - fee > 0) {\n            // Need to refund caller. Try to return unused value, or revert if failed\n            (bool success, ) = sender.call{value: msg.value - fee}(\"\");\n            if (success == false) revert FlatcoinErrors.RefundFailed();\n        }\n    }\n\n    /////////////////////////////////////////////\n    //             View Functions              //\n    /////////////////////////////////////////////\n\n    /// @notice Returns the latest 18 decimal price of asset from either Pyth.network or Chainlink.\n    /// @dev The oldest pricestamp will be the Chainlink oracle `maxAge` setting. Otherwise the call will revert.\n    /// @return price The latest 18 decimal price of asset.\n    /// @return timestamp The timestamp of the latest price.\n    function getPrice() public view returns (uint256 price, uint256 timestamp) {\n        (price, timestamp) = _getPrice(type(uint32).max);\n    }\n\n    /// @notice The same as getPrice() but it includes maximum acceptable oracle timestamp input parameter.\n    /// @param maxAge Oldest acceptable oracle price.\n    /// @return price The latest 18 decimal price of asset.\n    /// @return timestamp The timestamp of the latest price.\n    function getPrice(uint32 maxAge) public view returns (uint256 price, uint256 timestamp) {\n        (price, timestamp) = _getPrice(maxAge);\n    }\n\n    /////////////////////////////////////////////\n    //            Internal Functions           //\n    /////////////////////////////////////////////\n\n    /// @notice Returns the latest 18 decimal price of asset from either Pyth.network or Chainlink.\n    /// @dev It verifies the Pyth network price against Chainlink price (ensure that it is within a threshold).\n    /// @return price The latest 18 decimal price of asset.\n    /// @return timestamp The timestamp of the latest price.\n    function _getPrice(uint32 maxAge) internal view returns (uint256 price, uint256 timestamp) {\n        (uint256 onchainPrice, uint256 onchainTime) = _getOnchainPrice(); // will revert if invalid\n        (uint256 offchainPrice, uint256 offchainTime, bool offchainInvalid) = _getOffchainPrice();\n        bool offchain;\n\n        uint256 priceDiff = (int256(onchainPrice) - int256(offchainPrice)).abs();\n        uint256 diffPercent = (priceDiff * 1e18) / onchainPrice;\n        if (diffPercent > maxDiffPercent) revert FlatcoinErrors.PriceMismatch(diffPercent);\n\n        if (offchainInvalid == false) {\n            // return the freshest price\n            if (offchainTime >= onchainTime) {\n                price = offchainPrice;\n                timestamp = offchainTime;\n                offchain = true;\n            } else {\n                price = onchainPrice;\n                timestamp = onchainTime;\n            }\n        } else {\n            price = onchainPrice;\n            timestamp = onchainTime;\n        }\n\n        // Check that the timestamp is within the required age\n        if (maxAge < type(uint32).max && timestamp + maxAge < block.timestamp) {\n            revert FlatcoinErrors.PriceStale(\n                offchain ? FlatcoinErrors.PriceSource.OffChain : FlatcoinErrors.PriceSource.OnChain\n            );\n        }\n    }\n\n    /// @dev Will revert on any issue. This is because the Onchain price is critical\n    /// @return price The latest 18 decimal price of asset.\n    /// @return timestamp The timestamp of the latest price.\n    function _getOnchainPrice() internal view returns (uint256 price, uint256 timestamp) {\n        IChainlinkAggregatorV3 oracle = onchainOracle.oracleContract;\n        if (address(oracle) == address(0)) revert FlatcoinErrors.ZeroAddress(\"oracle\");\n\n        (, int256 _price, , uint256 updatedAt, ) = oracle.latestRoundData();\n        timestamp = updatedAt;\n        // check Chainlink oracle price updated within `maxAge` time.\n        if (block.timestamp > timestamp + onchainOracle.maxAge)\n            revert FlatcoinErrors.PriceStale(FlatcoinErrors.PriceSource.OnChain);\n\n        if (_price > 0) {\n            price = uint256(_price) * (10 ** 10); // convert Chainlink oracle decimals 8 -> 18\n        } else {\n            // Issue with onchain oracle indicates a serious problem\n            revert FlatcoinErrors.PriceInvalid(FlatcoinErrors.PriceSource.OnChain);\n        }\n    }\n\n    /// @dev `_getPrice` can fall back to the Onchain oracle.\n    /// @return price The latest 18 decimal price of asset.\n    /// @return timestamp The timestamp of the latest price.\n    /// @return invalid True if the price is invalid.\n    function _getOffchainPrice() internal view returns (uint256 price, uint256 timestamp, bool invalid) {\n        IPyth oracle = offchainOracle.oracleContract;\n        if (address(oracle) == address(0)) revert FlatcoinErrors.ZeroAddress(\"oracle\");\n\n        try oracle.getPriceNoOlderThan(offchainOracle.priceId, offchainOracle.maxAge) returns (\n            PythStructs.Price memory priceData\n        ) {\n            timestamp = priceData.publishTime;\n\n            // Check that Pyth price and confidence is a positive value\n            // Check that the exponential param is negative (eg -8 for 8 decimals)\n            if (priceData.price > 0 && priceData.conf > 0 && priceData.expo < 0) {\n                price = ((priceData.price).toUint256()) * (10 ** (18 + priceData.expo).toUint256()); // convert oracle expo/decimals eg 8 -> 18\n\n                // Check that Pyth price confidence meets minimum\n                if (priceData.price / int64(priceData.conf) < int32(offchainOracle.minConfidenceRatio)) {\n                    invalid = true; // price confidence is too low\n                }\n            } else {\n                invalid = true;\n            }\n        } catch {\n            invalid = true; // couldn't fetch the price with the asked input param\n        }\n    }\n\n    /// @dev Sets the asset to price.\n    /// @param _asset The asset to price.\n    function _setAsset(address _asset) internal {\n        if (_asset == address(0)) revert FlatcoinErrors.ZeroAddress(\"asset\");\n\n        asset = _asset;\n        emit FlatcoinEvents.SetAsset(_asset);\n    }\n\n    /// @notice Setting a Chainlink price feed push oracle.\n    /// @param newOracle The Chainlink aggregator oracle address.\n    function _setOnchainOracle(FlatcoinStructs.OnchainOracle calldata newOracle) internal {\n        if (address(newOracle.oracleContract) == address(0) || newOracle.maxAge <= 0)\n            revert FlatcoinErrors.OracleConfigInvalid();\n\n        onchainOracle = newOracle;\n        emit FlatcoinEvents.SetOnChainOracle(newOracle);\n    }\n\n    /// @notice Setting a Pyth Network price feed pull oracle.\n    /// @param newOracle The new onchain oracle configuration.\n    function _setOffchainOracle(FlatcoinStructs.OffchainOracle calldata newOracle) internal {\n        if (\n            address(newOracle.oracleContract) == address(0) ||\n            newOracle.priceId == bytes32(0) ||\n            newOracle.maxAge <= 0 ||\n            newOracle.minConfidenceRatio <= 0\n        ) revert FlatcoinErrors.OracleConfigInvalid();\n\n        offchainOracle = FlatcoinStructs.OffchainOracle(\n            newOracle.oracleContract,\n            newOracle.priceId,\n            newOracle.maxAge,\n            newOracle.minConfidenceRatio\n        );\n        emit FlatcoinEvents.SetOffChainOracle(newOracle);\n    }\n\n    /// @notice Setting the maximum percentage between onchain and offchain oracle.\n    /// @param _maxDiffPercent The maximum percentage between onchain and offchain oracle.\n    function _setMaxDiffPercent(uint256 _maxDiffPercent) internal {\n        // Max diff percent must be between 0 and (or equal to) 100%.\n        // 0 means that we don't ever expect the oracle prices to differ.\n        // 1e18 means that we don't care if the oracle prices differ.\n        if (_maxDiffPercent == 0 || _maxDiffPercent > 1e18) revert FlatcoinErrors.OracleConfigInvalid();\n\n        maxDiffPercent = _maxDiffPercent;\n\n        emit FlatcoinEvents.SetMaxDiffPercent(_maxDiffPercent);\n    }\n\n    /////////////////////////////////////////////\n    //             Owner Functions             //\n    /////////////////////////////////////////////\n\n    /// @notice Sets the asset and oracles (onchain and offchain).\n    /// @dev Changes should be handled with care as it's possible to misconfigure.\n    /// @param _asset The asset to price.\n    /// @param _onchainOracle The onchain oracle configuration.\n    /// @param _offchainOracle The offchain oracle configuration.\n    function setOracle(\n        address _asset,\n        FlatcoinStructs.OnchainOracle calldata _onchainOracle,\n        FlatcoinStructs.OffchainOracle calldata _offchainOracle\n    ) external onlyOwner {\n        // Note: It's not possible to check that the oracles match the configured asset\n        // and any configuration changes should be handled with care.\n        _setAsset(_asset);\n        _setOnchainOracle(_onchainOracle);\n        _setOffchainOracle(_offchainOracle);\n    }\n\n    /// @notice Sets the maximum percentage between onchain and offchain oracle\n    /// @param _maxDiffPercent The maximum percentage between onchain and offchain oracle\n    function setMaxDiffPercent(uint256 _maxDiffPercent) external onlyOwner {\n        _setMaxDiffPercent(_maxDiffPercent);\n    }\n}"
    },
    {
      "filename": "flatcoin-v1/src/LiquidationModule.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\n\nimport {Initializable} from \"openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\n\nimport {ModuleUpgradeable} from \"./abstracts/ModuleUpgradeable.sol\";\nimport {OracleModifiers} from \"./abstracts/OracleModifiers.sol\";\nimport {FlatcoinErrors} from \"./libraries/FlatcoinErrors.sol\";\nimport {FlatcoinStructs} from \"./libraries/FlatcoinStructs.sol\";\nimport {FlatcoinModuleKeys} from \"./libraries/FlatcoinModuleKeys.sol\";\nimport {FlatcoinEvents} from \"./libraries/FlatcoinEvents.sol\";\nimport {PerpMath} from \"./libraries/PerpMath.sol\";\nimport {InvariantChecks} from \"./misc/InvariantChecks.sol\";\n\nimport {IFlatcoinVault} from \"./interfaces/IFlatcoinVault.sol\";\nimport {ILeverageModule} from \"./interfaces/ILeverageModule.sol\";\nimport {IOracleModule} from \"./interfaces/IOracleModule.sol\";\nimport {ILiquidationModule} from \"./interfaces/ILiquidationModule.sol\";\nimport {ILimitOrder} from \"./interfaces/ILimitOrder.sol\";\n\n/// @title LiquidationModule\n/// @author dHEDGE\n/// @notice Module for liquidating leveraged positions.\ncontract LiquidationModule is\n    ILiquidationModule,\n    Initializable,\n    ModuleUpgradeable,\n    OracleModifiers,\n    ReentrancyGuardUpgradeable,\n    InvariantChecks\n{\n    /// @notice Liquidation fee basis points paid to liquidator.\n    /// @dev Note that this needs to be used together with keeper fee bounds.\n    /// @dev Should include 18 decimals i.e, 0.2% => 0.002e18 => 2e15\n    uint128 public liquidationFeeRatio;\n\n    /// @notice Liquidation price buffer in basis points to prevent negative margin on liquidation.\n    /// @dev Should include 18 decimals i.e, 0.75% => 0.0075e18 => 75e14\n    uint128 public liquidationBufferRatio;\n\n    /// @notice Upper bound for the liquidation fee.\n    /// @dev Denominated in USD.\n    uint256 public liquidationFeeUpperBound;\n\n    /// @notice Lower bound for the liquidation fee.\n    /// @dev Denominated in USD.\n    uint256 public liquidationFeeLowerBound;\n\n    /// @dev To prevent the implementation contract from being used, we invoke the _disableInitializers\n    /// function in the constructor to automatically lock it when it is deployed.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        IFlatcoinVault _vault,\n        uint128 _liquidationFeeRatio,\n        uint128 _liquidationBuffe"
    }
  ]
}