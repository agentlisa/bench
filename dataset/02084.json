{
  "Title": "H-19: No slippage for withdrawal without swapping path",
  "Content": "# Issue H-19: No slippage for withdrawal without swapping path \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/70 \n\n## Found by \nbin2chen, rvierdiiev\n\n## Summary\nNo slippage for withdrawal without swapping path\n## Vulnerability Detail\nWhen user withdraws, he should provide amount of LP tokens, that he wants to burn. According to that amount, output amount of long and short tokens of the market [will be calculated](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/withdrawal/WithdrawalUtils.sol#L274) for him.\n\nIn case if user wants to swap this short/long tokens to another tokens, then he can provide longTokenSwapPath/shortTokenSwapPath array. If he doesn't want to swap them, but just receive without swapping, he doesn't provide that array.\n\nNo matter if he provided swap path or no, swapping [will be called](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/withdrawal/WithdrawalUtils.sol#L354-L374).\n\nThen inside `SwapUtils.swap` in case if no swap path is provided, then function will just [send tokens to receiver](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/swap/SwapUtils.sol#L99-L109).\nOne of parameters of `SwapUtils.swap` function is [`minOutputAmount`](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/withdrawal/WithdrawalUtils.sol#L414). This parameter is important as it stands as slippage protection. In case if swap path is not provided, then amount will not be checked for that slippage. If swap path present, then slippage check [will be done](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/swap/SwapUtils.sol#L144-L146). \nSo in case if no swap path is provided, then slippage provided by user will not be checked, as inside `WithdrawalUtils._executeWithdrawal` there is no any check that user received [`minShortTokenAmount`](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/withdrawal/WithdrawalUtils.sol#L371) and [`minLongTokenAmount`](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/withdrawal/WithdrawalUtils.sol#L360).\nBecause of that user can be frontrunned and lose some funds.\n## Impact\nThere is no slippage check in case if user doesn't provide swap path.\n## Code Snippet\nProvided above\n## Tool used\n\nManual Review\n\n## Recommendation\nYou need to check that `minLongTokenAmount`, `minShortTokenAmount` is satisfied after the swap.\n\n\n\n## Discussion\n\n**xvi10**\n\nFix in https://github.com/gmx-io/gmx-synthetics/commit/7ca5adaacbeb717ae91badc250c56441fd86a417\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/withdrawal/WithdrawalUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../adl/AdlUtils.sol\";\n\nimport \"../data/DataStore.sol\";\n\nimport \"./WithdrawalVault.sol\";\nimport \"./WithdrawalStoreUtils.sol\";\nimport \"./WithdrawalEventUtils.sol\";\n\nimport \"../nonce/NonceUtils.sol\";\nimport \"../pricing/SwapPricingUtils.sol\";\nimport \"../oracle/Oracle.sol\";\nimport \"../oracle/OracleUtils.sol\";\n\nimport \"../gas/GasUtils.sol\";\nimport \"../callback/CallbackUtils.sol\";\n\nimport \"../utils/Array.sol\";\nimport \"../utils/ReceiverUtils.sol\";\n\n/**\n * @title WithdrawalUtils\n * @dev Library for withdrawal functions\n */\nlibrary WithdrawalUtils {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using Array for uint256[];\n    using Price for Price.Props;\n    using Withdrawal for Withdrawal.Props;\n\n    /**\n     * @param receiver The address that will receive the withdrawal tokens.\n     * @param callbackContract The contract that will be called back.\n     * @param market The market on which the withdrawal will be executed.\n     * @param marketTokenAmount The amount of market tokens that will be withdrawn.\n     * @param minLongTokenAmount The minimum amount of long tokens that must be withdrawn.\n     * @param minShortTokenAmount The minimum amount of short tokens that must be withdrawn.\n     * @param shouldUnwrapNativeToken Whether the native token should be unwrapped when executing the withdrawal.\n     * @param executionFee The execution fee for the withdrawal.\n     * @param callbackGasLimit The gas limit for calling the callback contract.\n     */\n    struct CreateWithdrawalParams {\n        address receiver;\n        address callbackContract;\n        address market;\n        address[] longTokenSwapPath;\n        address[] shortTokenSwapPath;\n        uint256 marketTokenAmount;\n        uint256 minLongTokenAmount;\n        uint256 minShortTokenAmount;\n        bool shouldUnwrapNativeToken;\n        uint256 executionFee;\n        uint256 callbackGasLimit;\n    }\n\n    /**\n     * @param dataStore The data store where withdrawal data is stored.\n     * @param eventEmitter The event emitter that is used to emit events.\n     * @param withdrawalVault WithdrawalVault.\n     * @param oracle The oracle that provides market prices.\n     * @param key The unique identifier of the withdrawal to execute.\n     * @param minOracleBlockNumbers The min block numbers for the oracle prices.\n     * @param maxOracleBlockNumbers The max block numbers for the oracle prices.\n     * @param keeper The keeper that is executing the withdrawal.\n     * @param startingGas The starting gas limit for the withdrawal execution.\n     */\n    struct ExecuteWithdrawalParams {\n        DataStore dataStore;\n        EventEmitter eventEmitter;\n        WithdrawalVault withdrawalVault;\n        Oracle oracle;\n        bytes32 key;\n        uint256[] minOracleBlockNumbers;\n        uint256[] maxOracleBlockNumbers;\n        address keeper;\n        uint256 startingGas;\n    }\n\n    struct ExecuteWithdrawalCache {\n        uint256 longTokenOutputAmount;\n        uint256 shortTokenOutputAmount;\n        SwapPricingUtils.SwapFees longTokenFees;\n        SwapPricingUtils.SwapFees shortTokenFees;\n        uint256 longTokenPoolAmountDelta;\n        uint256 shortTokenPoolAmountDelta;\n    }\n\n    error MinLongTokens(uint256 received, uint256 expected);\n    error MinShortTokens(uint256 received, uint256 expected);\n    error InsufficientMarketTokens(uint256 balance, uint256 expected);\n    error InsufficientWntAmount(uint256 wntAmount, uint256 executionFee);\n    error EmptyWithdrawal();\n    error EmptyMarketTokenAmount();\n    error InvalidPoolValueForWithdrawal(int256 poolValue);\n\n    /**\n     * @dev Creates a withdrawal in the withdrawal store.\n     *\n     * @param dataStore The data store where withdrawal data is stored.\n     * @param eventEmitter The event emitter that is used to emit events.\n     * @param withdrawalVault WithdrawalVault.\n     * @param account The account that initiated the withdrawal.\n     * @param params The parameters for creating the withdrawal.\n     * @return The unique identifier of the created withdrawal.\n     */\n    function createWithdrawal(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        WithdrawalVault withdrawalVault,\n        address account,\n        CreateWithdrawalParams memory params\n    ) external returns (bytes32) {\n        address wnt = TokenUtils.wnt(dataStore);\n        uint256 wntAmount = withdrawalVault.recordTransferIn(wnt);\n\n        if (wntAmount < params.executionFee) {\n            revert InsufficientWntAmount(wntAmount, params.executionFee);\n        }\n\n        ReceiverUtils.validateReceiver(params.receiver);\n\n        if (params.marketTokenAmount == 0) {\n            revert EmptyMarketTokenAmount();\n        }\n\n        GasUtils.handleExcessExecutionFee(\n            dataStore,\n            withdrawalVault,\n            wntAmount,\n            params.executionFee\n        );\n\n        MarketUtils.validateEnabledMarket(dataStore, params.market);\n\n        Withdrawal.Props memory withdrawal = Withdrawal.Props(\n            Withdrawal.Addresses(\n                account,\n                params.receiver,\n                params.callbackContract,\n                params.market,\n                params.longTokenSwapPath,\n                params.shortTokenSwapPath\n            ),\n            Withdrawal.Numbers(\n                params.marketTokenAmount,\n                params.minLongTokenAmount,\n                params.minShortTokenAmount,\n                Chain.currentBlockNumber(),\n                params.executionFee,\n                params.callbackGasLimit\n            ),\n            Withdrawal.Flags(\n                params.shouldUnwrapNativeToken\n            )\n        );\n\n        CallbackUtils.validateCallbackGasLimit(dataStore, withdrawal.callbackGasLimit());\n\n        uint256 estimatedGasLimit = GasUtils.estimateExecuteWithdrawalGasLimit(dataStore, withdrawal);\n        GasUtils.validateExecutionFee(dataStore, estimatedGasLimit, params.executionFee);\n\n        bytes32 key = NonceUtils.getNextKey(dataStore);\n\n        WithdrawalStoreUtils.set(dataStore, key, withdrawal);\n\n        WithdrawalEventUtils.emitWithdrawalCreated(eventEmitter, key, withdrawal);\n\n        return key;\n    }\n\n    /**\n     * Executes a withdrawal on the market.\n     *\n     * @param params The parameters for executing the withdrawal.\n     */\n    function executeWithdrawal(ExecuteWithdrawalParams memory params) external {\n        Withdrawal.Props memory withdrawal = WithdrawalStoreUtils.get(params.dataStore, params.key);\n        if (withdrawal.account() == address(0)) {\n            revert EmptyWithdrawal();\n        }\n        if (withdrawal.marketTokenAmount() == 0) {\n            revert EmptyMarketTokenAmount();\n        }\n\n        OracleUtils.validateBlockNumberWithinRange(\n            params.minOracleBlockNumbers,\n            params.maxOracleBlockNumbers,\n            withdrawal.updatedAtBlock()\n        );\n\n        uint256 marketTokensBalance = MarketToken(payable(withdrawal.market())).balanceOf(withdrawal.account());\n        if (marketTokensBalance < withdrawal.marketTokenAmount()) {\n            revert InsufficientMarketTokens(marketTokensBalance, withdrawal.marketTokenAmount());\n        }\n\n        _executeWithdrawal(params, withdrawal);\n\n        WithdrawalEventUtils.emitWithdrawalExecuted(params.eventEmitter, params.key);\n\n        CallbackUtils.afterWithdrawalExecution(params.key, withdrawal);\n\n        GasUtils.payExecutionFee(\n            params.dataStore,\n            params.withdrawalVault,\n            withdrawal.executionFee(),\n            params.startingGas,\n            params.keeper,\n            withdrawal.account()\n        );\n    }\n\n    /**\n     * @dev Cancels a withdrawal.\n     * @param dataStore The data store.\n     * @param eventEmitter The event emitter.\n     * @param withdrawalVault The withdrawal vault.\n     * @param key The withdrawal key.\n     * @param keeper The keeper sending the transaction.\n     * @param startingGas The starting gas for the transaction.\n     */\n    function cancelWithdrawal(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        WithdrawalVault withdrawalVault,\n        bytes32 key,\n        address keeper,\n        uint256 startingGas,\n        string memory reason,\n        bytes memory reasonBytes\n    ) external {\n        Withdrawal.Props memory withdrawal = WithdrawalStoreUtils.get(dataStore, key);\n        if (withdrawal.account() == address(0)) {\n            revert EmptyWithdrawal();\n        }\n\n        WithdrawalStoreUtils.remove(dataStore, key, withdrawal.account());\n\n        WithdrawalEventUtils.emitWithdrawalCancelled(eventEmitter, key, reason, reasonBytes);\n\n        CallbackUtils.afterWithdrawalCancellation(key, withdrawal);\n\n        GasUtils.payExecutionFee(\n            dataStore,\n            withdrawalVault,\n            withdrawal.executionFee(),\n            startingGas,\n            keeper,\n            withdrawal.account()\n        );\n    }\n\n    /**\n     * @dev executes a withdrawal.\n     * @param params ExecuteWithdrawalParams.\n     * @param withdrawal The withdrawal to execute.\n     */\n    function _executeWithdrawal(\n        ExecuteWithdrawalParams memory params,\n        Withdrawal.Props memory withdrawal\n    ) internal {\n        Market.Props memory market = MarketUtils.getEnabledMarket(params.dataStore, withdrawal.market());\n\n        MarketUtils.MarketPrices memory prices = MarketUtils.getMarketPrices(\n            params.oracle,\n            market\n        );\n\n        ExecuteWithdrawalCache memory cache;\n\n        (cache.longTokenOutputAmount, cache.shortTokenOutputAmount) = _getOutputAmounts(params, market, prices, withdrawal.marketTokenAmount());\n\n        cache.longTokenFees = SwapPricingUtils.getSwapFees(\n            params.dataStore,\n            market.marketToken,\n            cache.longTokenOutputAmount\n        );\n\n        FeeUtils.incrementClaimableFeeAmount(\n            params.dataStore,\n            params.eventEmitter,\n            market.marketToken,\n            market.longToken,\n            cache.longTokenFees.feeReceiverAmount,\n            Keys.WITHDRAWAL_FEE\n        );\n\n        cache.shortTokenFees = SwapPricingUtils.getSwapFees(\n            params.dataStore,\n            market.marketToken,\n            cache.shortTokenOutputAmount\n        );\n\n        FeeUtils.incrementClaimableFeeAmount(\n            params.dataStore,\n            params.eventEmitter,\n            market.marketToken,\n            market.shortToken,\n            cache.shortTokenFees.feeReceiverAmount,\n            Keys.WITHDRAWAL_FEE\n        );\n\n        // the pool will be reduced by the outputAmount minus the fees for the pool\n        cache.longTokenPoolAmountDelta = cache.longTokenOutputAmount - cache.longTokenFees.feeAmountForPool;\n        cache.longTokenOutputAmount = cache.longTokenFees.amountAfterFees;\n\n        cache.shortTokenPoolAmountDelta = cache.shortTokenOutputAmount - cache.shortTokenFees.feeAmountForPool;\n        cache.shortTokenOutputAmount = cache.shortTokenFees.amountAfterFees;\n\n        MarketUtils.applyDeltaToPoolAmount(\n            params.dataStore,\n            params.eventEmitter,\n            market.marketToken,\n            market.longToken,\n            -cache.longTokenPoolAmountDelta.toInt256()\n        );\n\n        MarketUtils.applyDeltaToPoolAmount(\n            params.dataStore,\n            params.eventEmitter,\n            market.marketToken,\n            market.shortToken,\n            -cache.shortTokenPoolAmountDelta.toInt256()\n        );\n\n        MarketUtils.validateReserve(\n            params.dataStore,\n            market,\n            prices,\n            true\n        );\n\n        MarketUtils.validateReserve(\n            params.dataStore,\n            market,\n            prices,\n            false\n        );\n\n        MarketUtils.validateMaxPnl(\n            params.dataStore,\n            market,\n            prices,\n            Keys.MAX_PNL_FACTOR_FOR_WITHDRAWALS\n        );\n\n        WithdrawalStoreUtils.remove(params.dataStore, params.key, withdrawal.account());\n\n        MarketToken(payable(market.marketToken)).burn(withdrawal.account(), withdrawal.marketTokenAmount());\n\n        swap(\n            params,\n            market,\n            market.longToken,\n            cache.longTokenOutputAmount,\n            withdrawal.longTokenSwapPath(),\n            withdrawal.minLongTokenAmount(),\n            withdrawal.receiver(),\n            withdrawal.shouldUnwrapNativeToken()\n        );\n\n        swap(\n            params,\n            market,\n            market.shortToken,\n            cache.shortTokenOutputAmount,\n            withdrawal.shortTokenSwapPath(),\n            withdrawal.minShortTokenAmount(),\n            withdrawal.receiver(),\n            withdrawal.shouldUnwrapNativeToken()\n        );\n\n        SwapPricingUtils.emitSwapFeesCollected(\n            params.eventEmitter,\n            market.marketToken,\n            market.longToken,\n            \"withdrawal\",\n            cache.longTokenFees\n        );\n\n        SwapPricingUtils.emitSwapFeesCollected(\n            params.eventEmitter,\n            market.marketToken,\n            market.shortToken,\n            \"withdrawal\",\n            cache.shortTokenFees\n        );\n    }\n\n    function swap(\n        ExecuteWithdrawalParams memory params,\n        Market.Props memory market,\n        address tokenIn,\n        uint256 amountIn,\n        address[] memory swapPath,\n        uint256 minOutputAmount,\n        address receiver,\n        bool shouldUnwrapNativeToken\n    ) internal {\n        Market.Props[] memory swapPathMarkets = MarketUtils.getEnabledMarkets(params.dataStore, swapPath);\n\n        SwapUtils.swap(\n            SwapUtils.SwapParams(\n                params.dataStore, // dataStore\n                params.eventEmitter, // eventEmitter\n                params.oracle, // oracle\n                Bank(payable(market.marketToken)), // bank\n                tokenIn, // tokenIn\n                amountIn, // amountIn\n                swapPathMarkets, // swapPathMarkets\n                minOutputAmount, // minOutputAmount\n                receiver, // receiver\n                shouldUnwrapNativeToken // shouldUnwrapNativeToken\n            )\n        );\n    }\n\n    function _getOutputAmounts(\n        ExecuteWithdrawalParams memory params,\n        Market.Props memory market,\n        MarketUtils.MarketPrices memory prices,\n        uint256 marketTokenAmount\n    ) internal view returns (uint256, uint256) {\n        // the max pnl factor for withdrawals should be the lower of the max pnl factor values\n        // which means that pnl would be capped to a smaller amount and the pool\n        // value would be higher even if there is a large pnl\n        // this should be okay since MarketUtils.validateMaxPnl is called after the withdrawal\n        // which ensures that the max pnl factor for withdrawals was not exceeded\n        int256 _poolValue = MarketUtils.getPoolValue(\n            params.dataStore,\n            market,\n            prices.longTokenPrice,\n            prices.shortTokenPrice,\n            params.oracle.getPrimaryPrice(market.indexToken),\n            Keys.MAX_PNL_FACTOR_FOR_WITHDRAWALS,\n            false\n        );\n\n        if (_poolValue <= 0) {\n            revert InvalidPoolValueForWithdrawal(_poolValue);\n        }\n\n        uint256 poolValue = _poolValue.toUint256();\n        uint256 marketTokensSupply = MarketUtils.getMarketTokenSupply(MarketToken(payable(market.marketToken)));\n        uint256 marketTokensUsd = MarketUtils.marketTokenAmountToUsd(marketTokenAmount, poolValue, marketTokensSupply);\n\n        uint256 longTokenPoolAmount = MarketUtils.getPoolAmount(params.dataStore, market.marketToken, market.longToken);\n        uint256 shortTokenPoolAmount = MarketUtils.getPoolAmount(params.dataStore, market.marketToken, market.shortToken);\n\n        uint256 longTokenPoolUsd = longTokenPoolAmount * prices.longTokenPrice.max;\n        uint256 shortTokenPoolUsd = shortTokenPoolAmount * prices.shortTokenPrice.max;\n\n        uint256 longTokenOutputUsd = marketTokensUsd * longTokenPoolUsd / (longTokenPoolUsd + shortTokenPoolUsd);\n        uint256 shortTokenOutputUsd = marketTokensUsd * shortTokenPoolUsd / (longTokenPoolUsd + shortTokenPoolUsd);\n\n        return (\n            longTokenOutputUsd / prices.longTokenPrice.max,\n            shortTokenOutputUsd / prices.shortTokenPrice.max\n        );\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/withdrawal/WithdrawalUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../adl/AdlUtils.sol\";\n\nimport \"../data/DataStore.sol\";\n\nimport \"./WithdrawalVault.sol\";\nimport \"./WithdrawalStoreUtils.sol\";\nimport \"./WithdrawalEventUtils.sol\";\n\nimport \"../nonce/NonceUtils.sol\";\nimport \"../pricing/SwapPricingUtils.sol\";\nimport \"../oracle/Oracle.sol\";\nimport \"../oracle/OracleUtils.sol\";\n\nimport \"../gas/GasUtils.sol\";\nimport \"../callback/CallbackUtils.sol\";\n\nimport \"../utils/Array.sol\";\nimport \"../utils/ReceiverUtils.sol\";\n\n/**\n * @title WithdrawalUtils\n * @dev Library for withdrawal functions\n */\nlibrary WithdrawalUtils {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using Array for uint256[];\n    using Price for Price.Props;\n    using Withdrawal for Withdrawal.Props;\n\n    /**\n     * @param receiver The address that will receive the withdrawal tokens.\n     * @param callbackContract The contract that will be called back.\n     * @param market The market on which the withdrawal will be executed.\n     * @param marketTokenAmount The amount of market tokens that will be withdrawn.\n     * @param minLongTokenAmount The minimum amount of long tokens that must be withdrawn.\n     * @param minShortTokenAmount The minimum amount of short tokens that must be withdrawn.\n     * @param shouldUnwrapNativeToken Whether the native token should be unwrapped when executing the withdrawal.\n     * @param executionFee The execution fee for the withdrawal.\n     * @param callbackGasLimit The gas limit for calling the callback contract.\n     */\n    struct CreateWithdrawalParams {\n        address receiver;\n        address callbackContract;\n        address market;\n        address[] longTokenSwapPath;\n        address[] shortTokenSwapPath;\n        uint256 marketTokenAmount;\n        uint256 minLongTokenAmount;\n        uint256 minShortTokenAmount;\n        bool shouldUnwrapNativeToken;\n        uint256 executionFee;\n        uint256 callbackGasLimit;\n    }\n\n    /**\n     * @param dataStore The data store where withdrawal data is stored.\n     * @param eventEmitter The event emitter that is used to emit events.\n     * @param withdrawalVault WithdrawalVault.\n     * @param oracle The oracle that provides market prices.\n     * @param key The unique identifier of the withdrawal to execute.\n     * @param minOracleBlockNumbers The min block numbers for the oracle prices.\n     * @param maxOracleBlockNumbers The max block numbers for the oracle prices.\n     * @param keeper The keeper that is executing the withdrawal.\n     * @param startingGas The starting gas limit for the withdrawal execution.\n     */\n    struct ExecuteWithdrawalParams {\n        DataStore dataStore;\n        EventEmitter eventEmitter;\n        WithdrawalVault withdrawalVault;\n        Oracle oracle;\n        bytes32 key;\n        uint256[] minOracleBlockNumbers;\n        uint256[] maxOracleBlockNumbers;\n        address keeper;\n        uint256 startingGas;\n    }\n\n    struct ExecuteWithdrawalCache {\n        uint256 longTokenOutputAmount;\n        uint256 shortTokenOutputAmount;\n        SwapPricingUtils.SwapFees longTokenFees;\n        SwapPricingUtils.SwapFees shortTokenFees;\n        uint256 longTokenPoolAmountDelta;\n        uint256 shortTokenPoolAmountDelta;\n    }\n\n    error MinLongTokens(uint256 received, uint256 expected);\n    error MinShortTokens(uint256 received, uint256 expected);\n    error InsufficientMarketTokens(uint256 balance, uint256 expected);\n    error InsufficientWntAmount(uint256 wntAmount, uint256 executionFee);\n    error EmptyWithdrawal();\n    error EmptyMarketTokenAmount();\n    error InvalidPoolValueForWithdrawal(int256 poolValue);\n\n    /**\n     * @dev Creates a withdrawal in the withdrawal store.\n     *\n     * @param dataStore The data store where withdrawal data is stored.\n     * @param eventEmitter The event emitter that is used to emit events.\n     * @param withdrawalVault WithdrawalVault.\n     * @param account The account that initiated the withdrawal.\n     * @param params The parameters for creating the withdrawal.\n     * @return The unique identifier of the created withdrawal.\n     */\n    function createWithdrawal(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        WithdrawalVault withdrawalVault,\n        address account,\n        CreateWithdrawalParams memory params\n    ) external returns (bytes32) {\n        address wnt = TokenUtils.wnt(dataStore);\n        uint256 wntAmount = withdrawalVault.recordTransferIn(wnt);\n\n        if (wntAmount < params.executionFee) {\n            revert InsufficientWntAmount(wntAmount, params.executionFee);\n        }\n\n        ReceiverUtils.validateReceiver(params.receiver);\n\n        if (params.marketTokenAmount == 0) {\n            revert EmptyMarketTokenAmount();\n        }\n\n        GasUtils.handleExcessExecutionFee(\n            dataStore,\n            withdrawalVault,\n            wntAmount,\n            params.executionFee\n        );\n\n        MarketUtils.validateEnabledMarket(dataStore, params.market);\n\n        Withdrawal.Props memory withdrawal = Withdrawal.Props(\n            Withdrawal.Addresses(\n                account,\n                params.receiver,\n                params.callbackContract,\n                params.market,\n                params.longTokenSwapPath,\n                params.shortTokenSwapPath\n            ),\n            Withdrawal.Numbers(\n                params.marketTokenAmount,\n                params.minLongTokenAmount,\n                params.minShortTokenAmount,\n                Chain.currentBlockNumber(),\n                params.executionFee,\n                params.callbackGasLimit\n            ),\n            Withdrawal.Flags(\n                params.shouldUnwrapNativeToken\n            )\n        );\n\n        CallbackUtils.validateCallbackGasLimit(dataStore, withdrawal.callbackGasLimit());\n\n        uint256 estimatedGasLimit = GasUtils.estimateExecuteWithdrawalGasLimit(dataStore, withdrawal);\n        GasUtils.validateExecutionFee(dataStore, estimatedGasLimit, params.executionFee);\n\n        bytes32 key = NonceUtils.getNextKey(dataStore);\n\n        WithdrawalStoreUtils.set(dataStore, key, withdrawal);\n\n        WithdrawalEventUtils.emitWithdrawalCreated(eventEmitter, key, withdrawal);\n\n        return key;\n    }\n\n    /**\n     * Executes a withdrawal on the market.\n     *\n     * @param params The parameters for executing the withdrawal.\n     */\n    function executeWithdrawal(ExecuteWithdrawalParams memory params) external {\n        Withdrawal.Props memory withdrawal = WithdrawalStoreUtils.get(params.dataStore, params.key);\n        if (withdrawal.account() == address(0)) {\n            revert EmptyWithdrawal();\n        }\n        if (withdrawal.marketTokenAmount() == 0) {\n            revert EmptyMarketTokenAmount();\n        }\n\n        OracleUtils.validateBlockNumberWithinRange(\n            params.minOracleBlockNumbers,\n            params.maxOracleBlockNumbers,\n            withdrawal.updatedAtBlock()\n        );\n\n        uint256 marketTokensBalance = MarketToken(payable(withdrawal.market())).balanceOf(withdrawal.account());\n        if (marketTokensBalance < withdrawal.marketTokenAmount()) {\n            revert InsufficientMarketTokens(marketTokensBalance, withdrawal.marketTokenAmount());\n        }\n\n        _executeWithdrawal(params, withdrawal);\n\n        WithdrawalEventUtils.emitWithdrawalExecuted(params.eventEmitter, params.key);\n\n        CallbackUtils.afterWithdrawalExecution(params.key, withdrawal);\n\n        GasUtils.payExecutionFee(\n            params.dataStore,\n            params.withdrawalVault,\n            withdrawal.executionFee(),\n            params.startingGas,\n            params.keeper,\n            withdrawal.account()\n        );\n    }\n\n    /**\n     * @dev Cancels a withdrawal.\n     * @param dataStore The data store.\n     * @param eventEmitter The event emitter.\n     * @param withdrawalVault The withdrawal vault.\n     * @param key The withdrawal key.\n     * @param keeper The keeper sending the transaction.\n     * @param startingGas The starting gas for the transaction.\n     */\n    function cancelWithdrawal(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        WithdrawalVault withdrawalVault,\n        bytes32 key,\n        address keeper,\n        uint256 startingGas,\n        string memory reason,\n        bytes memory reasonBytes\n    ) external {\n        Withdrawal.Props memory withdrawal = WithdrawalStoreUtils.get(dataStore, key);\n        if (withdrawal.account() == address(0)) {\n            revert EmptyWithdrawal();\n        }\n\n        WithdrawalStoreUtils.remove(dataStore, key, withdrawal.account());\n\n        WithdrawalEventUtils.emitWithdrawalCancelled(eventEmitter, key, reason, reasonBytes);\n\n        CallbackUtils.afterWithdrawalCancellation(key, withdrawal);\n\n        GasUtils.payExecutionFee(\n            dataStore,\n            withdrawalVault,\n            withdrawal.executionFee(),\n            startingGas,\n            keeper,\n            withdrawal.account()\n        );\n    }\n\n    /**\n     * @dev executes a withdrawal.\n     * @param params ExecuteWithdrawalParams.\n     * @param withdrawal The withdrawal to execute.\n     */\n    function _executeWithdrawal(\n        ExecuteWithdrawalParams memory params,\n        Withdrawal.Props memory withdrawal\n    ) internal {\n        Market.Props memory market = MarketUtils.getEnabledMarket(params.dataStore, withdrawal.market());\n\n        MarketUtils.MarketPrices memory prices = MarketUtils.getMarketPrices(\n            params.oracle,\n            market\n        );\n\n        ExecuteWithdrawalCache memory cache;\n\n        (cache.longTokenOutputAmount, cache.shortTokenOutputAmount) = _getOutputAmounts(params, market, prices, withdrawal.marketTokenAmount());\n\n        cache.longTokenFees = SwapPricingUtils.getSwapFees(\n            params.dataStore,\n            market.marketToken,\n            cache.longTokenOutputAmount\n        );\n\n        FeeUtils.incrementClaimableFeeAmount(\n            params.dataStore,\n            params.eventEmitter,\n            market.marketToken,\n            market.longToken,\n            cache.longTokenFees.feeReceiverAmount,\n            Keys.WITHDRAWAL_FEE\n        );\n\n        cache.shortTokenFees = SwapPricingUtils.getSwapFees(\n            params.dataStore,\n            market.marketToken,\n            cache.shortTokenOutputAmount\n        );\n\n        FeeUtils.incrementClaimableFeeAmount(\n            params.dataStore,\n            params.eventEmitter,\n            market.marketToken,\n            market.shortToken,\n            cache.shortTokenFees.feeReceiverAmount,\n            Keys.WITHDRAWAL_FEE\n        );\n\n        // the pool will be reduced by the outputAmount minus the fees for the pool\n        cache.longTokenPoolAmountDelta = cache.longTokenOutputAmount - cache.longTokenFees.feeAmountForPool;\n        cache.longTokenOutputAmount = cache.longTokenFees.amountAfterFees;\n\n        cache.shortTokenPoolAmountDelta = cache.shortTokenOutputAmount - cache.shortTokenFees.feeAmountForPool;\n        cache.shortTokenOutputAmount = cache.shortTokenFees.amountAfterFees;\n\n        MarketUtils.applyDeltaToPoolAmount(\n            params.dataStore,\n            params.eventEmitter,\n            market.marketToken,\n            market.longToken,\n            -cache.longTokenPoolAmountDelta.toInt256()\n        );\n\n        MarketUtils.applyDeltaToPoolAmount(\n            params.dataStore,\n            params.eventEmitter,\n            market.marketToken,\n            market.shortToken,\n            -cache.shortTokenPoolAmountDelta.toInt256()\n        );\n\n        MarketUtils.validateReserve(\n            params.dataStore,\n            market,\n            prices,\n            true\n        );\n\n        MarketUtils.validateReserve(\n            params.dataStore,\n            market,\n            prices,\n            false\n        );\n\n        MarketUtils.validateMaxPnl(\n            params.dataStore,\n            market,\n            prices,\n            Keys.MAX_PNL_FACTOR_FOR_WITHDRAWALS\n        );\n\n        WithdrawalStoreUtils.remove(params.dataStore, params.key, withdrawal.account());\n\n        MarketToken(payable(market.marketToken)).burn(withdrawal.account(), withdrawal.marketTokenAmount());\n\n        swap(\n            params,\n            market,\n            market.longToken,\n            cache.longTokenOutputAmount,\n            withdrawal.longTokenSwapPath(),\n            withdrawal.minLongTokenAmount(),\n            withdrawal.receiver(),\n            withdrawal.shouldUnwrapNativeToken()\n        );\n\n        swap(\n            params,\n            market,\n            market.shortToken,\n            cache.shortTokenOutputAmount,\n            withdrawal.shortTokenSwapPath(),\n            withdrawal.minShortTokenAmount(),\n            withdrawal.receiver(),\n            withdrawal.shouldUnwrapNativeToken()\n        );\n\n        SwapPricingUtils.emitSwapFeesCollected(\n            params.eventEmitter,\n            market.marketToken,\n            market.longToken,\n            \"withdrawal\",\n            cache.longTokenFees\n        );\n\n        SwapPricingUtils.emitSwapFeesCollected(\n            params.eventEmitter,\n            market.marketToken,\n            market.shortToken,\n            \"withdrawal\",\n            cache.shortTokenFees\n        );\n    }\n\n    function swap(\n        ExecuteWithdrawalParams memory params,\n        Market.Props memory market,\n        address tokenIn,\n        uint256 amountIn,\n        address[] memory swapPath,\n        uint256 minOutputAmount,\n        address receiver,\n        bool shouldUnwrapNativeToken\n    ) internal {\n        Market.Props[] memory swapPathMarkets = MarketUtils.getEnabledMarkets(params.dataStore, swapPath);\n\n        SwapUtils.swap(\n            SwapUtils.SwapParams(\n                params.dataStore, // dataStore\n                params.eventEmitter, // eventEmitter\n                params.oracle, // oracle\n                Bank(payable(market.marketToken)), // bank\n                tokenIn, // tokenIn\n                amountIn, // amountIn\n                swapPathMarkets, // swapPathMarkets\n                minOutputAmount, // minOutputAmount\n                receiver, // receiver\n                shouldUnwrapNativeToken // shouldUnwrapNativeToken\n            )\n        );\n    }\n\n    function _getOutputAmounts(\n        ExecuteWithdrawalParams memory params,\n        Market.Props memory market,\n        MarketUtils.MarketPrices memory prices,\n        uint256 marketTokenAmount\n    ) internal view returns (uint256, uint256) {\n        // the max pnl factor for withdrawals should be the lower of the max pnl factor values\n        // which means that pnl would be capped to a smaller amount and the pool\n        // value would be higher even if there is a large pnl\n        // this should be okay since MarketUtils.validateMaxPnl is called after the withdrawal\n        // which ensures that the max pnl factor for withdrawals was not exceeded\n        int256 _poolValue = MarketUtils.getPoolValue(\n            params.dataStore,\n            market,\n            prices.longTokenPrice,\n            prices.shortTokenPrice,\n            params.oracle.getPrimaryPrice(market.indexToken),\n            Keys.MAX_PNL_FACTOR_FOR_WITHDRAWALS,\n            false\n        );\n\n        if (_poolValue <= 0) {\n            revert InvalidPoolValueForWithdrawal(_poolValue);\n        }\n\n        uint256 poolValue = _poolValue.toUint256();\n        uint256 marketTokensSupply = MarketUtils.getMarketTokenSupply(MarketToken(payable(market.marketToken)));\n        uint256 marketTokensUsd = MarketUtils.marketTokenAmountToUsd(marketTokenAmount, poolValue, marketTokensSupply);\n\n        uint256 longTokenPoolAmount = MarketUtils.getPoolAmount(params.dataStore, market.marketToken, market.longToken);\n        uint256 shortTokenPoolAmount = MarketUtils.getPoolAmount(params.dataStore, market.marketToken, market.shortToken);\n\n        uint256 longTokenPoolUsd = longTokenPoolAmount * prices.longTokenPrice.max;\n        uint256 shortTokenPoolUsd = shortTokenPoolAmount * prices.shortTokenPrice.max;\n\n        uint256 longTokenOutputUsd = marketTokensUsd * longTokenPoolUsd / (longTokenPoolUsd + shortTokenPoolUsd);\n        uint256 shortTokenOutputUsd = marketTokensUsd * shortTokenPoolUsd / (longTokenPoolUsd + shortTokenPoolUsd);\n\n        return (\n            longTokenOutputUsd / prices.longTokenPrice.max,"
    }
  ]
}