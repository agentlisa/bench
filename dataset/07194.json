{
  "Title": "[N-08] Duplicated constants",
  "Content": "\n[`TypeHashDirectory`](https://github.com/horsefacts/seaport/blob/5de7302bc773d9821ba4759e47fc981680911ea0/contracts/lib/TypehashDirectory.sol#L20-L24) defines several constants, like `OneWord`, `OneWordShift`, `AlmostOneWord`, and `FreeMemoryPointerSlot` that are defined elsewhere in the codebase. Consider extracting these to a shared constants file:\n\n```solidity\n    uint256 internal constant OneWord = 0x20;\n    uint256 internal constant OneWordShift = 5;\n    uint256 internal constant AlmostOneWord = 0x1f;\n    uint256 internal constant FreeMemoryPointerSlot = 0x40;\n```\n\n**[0age (OpenSea) commented](https://github.com/code-423n4/2023-01-opensea-findings/issues/78#issuecomment-1401115226):**\n > This is a high-quality QA report ðŸ‘ \n\n**[hickuphh3 (judge) commented](https://github.com/code-423n4/2023-01-opensea-findings/issues/78#issuecomment-1403815190):**\n > 8 non-criticals, but I think they provide more value than the other QA reports I've come across thus far. Hence, it's worthy of an A grade (+bonus from sponsor for flagging it as high-quality).\n\n**[0age (OpenSea) resolved](https://github.com/code-423n4/2023-01-opensea-findings/issues/78#issuecomment-1446881163):**\n > **[N-01] Replace \"ETH\" with \"Native token\":** https://github.com/ProjectOpenSea/seaport/pull/921\n>\n > **[N-02] Extract or use named constants:** https://github.com/ProjectOpenSea/seaport/pull/922\n>\n > **[N-03] Fragile check for contract order type:** https://github.com/ProjectOpenSea/seaport/pull/922\n>\n > **[N-04] Inconsistent use of hex vs. decimal values:** https://github.com/ProjectOpenSea/seaport/pull/922\n>\n > **[N-05] Custom comment typos:** https://github.com/ProjectOpenSea/seaport/pull/924\n>\n > **[N-06] AlmostOneWord is confusing:** https://github.com/ProjectOpenSea/seaport/pull/923\n>\n > **[N-07] Typos in comments:** https://github.com/ProjectOpenSea/seaport/pull/924\n>\n > **[N-08] Duplicated constants:** https://github.com/ProjectOpenSea/seaport/pull/922\n\n\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-01-opensea",
  "Code": [
    {
      "filename": "contracts/lib/TypehashDirectory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n/**\n * @title TypehashDirectory\n * @notice The typehash directory contains 24 bulk order EIP-712 typehashes,\n *         depending on the height of the tree in each bulk order payload, as\n *         its runtime code (with an invalid opcode prefix so that the contract\n *         cannot be called normally). This runtime code is designed to be read\n *         from by Seaport using `extcodecopy` while verifying bulk signatures.\n */\ncontract TypehashDirectory {\n    // Encodes \"[2]\" for use in deriving typehashes.\n    bytes3 internal constant twoSubstring = 0x5B325D;\n    uint256 internal constant twoSubstringLength = 3;\n\n    // Dictates maximum bulk order group size; 24 => 2^24 => 16,777,216 orders.\n    uint256 internal constant MaxTreeHeight = 24;\n\n    uint256 internal constant InvalidOpcode = 0xfe;\n    uint256 internal constant OneWord = 0x20;\n    uint256 internal constant OneWordShift = 5;\n    uint256 internal constant AlmostOneWord = 0x1f;\n    uint256 internal constant FreeMemoryPointerSlot = 0x40;\n\n    /**\n     * @dev Derive 24 bulk order EIP-712 typehashes, one for each supported\n     *      tree height from 1 to 24, and write them to runtime code.\n     */\n    constructor() {\n        // Declare an array where each type hash will be writter.\n        bytes32[] memory typeHashes = new bytes32[](MaxTreeHeight);\n\n        // Derive a string of 24 \"[2]\" substrings.\n        bytes memory brackets = getMaxTreeBrackets(MaxTreeHeight);\n\n        // Derive a string of subtypes for the order parameters.\n        bytes memory subTypes = getTreeSubTypes();\n\n        // Cache memory pointer before each loop so memory doesn't expand by the\n        // full string size on each loop.\n        uint256 freeMemoryPointer;\n        assembly {\n            freeMemoryPointer := mload(FreeMemoryPointerSlot)\n        }\n\n        // Iterate over each tree height.\n        for (uint256 i = 0; i < MaxTreeHeight; ) {\n            // The actual height is one greater than its respective index.\n            uint256 height = i + 1;\n\n            // Slice brackets length to size needed for `height`.\n            assembly {\n                mstore(brackets, mul(twoSubstringLength, height))\n            }\n\n            // Encode the type string for the BulkOrder struct.\n            bytes memory bulkOrderTypeString = bytes.concat(\n                \"BulkOrder(OrderComponents\",\n                brackets,\n                \" tree)\",\n                subTypes\n            );\n\n            // Derive EIP712 type hash.\n            bytes32 typeHash = keccak256(bulkOrderTypeString);\n            typeHashes[i] = typeHash;\n\n            // Reset the free memory pointer.\n            assembly {\n                mstore(FreeMemoryPointerSlot, freeMemoryPointer)\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        assembly {\n            // Overwrite length with zero to give the contract an INVALID prefix\n            // and deploy the type hashes array as a contract.\n            mstore(typeHashes, InvalidOpcode)\n\n            return(\n                add(typeHashes, AlmostOneWord),\n                add(shl(OneWordShift, MaxTreeHeight), 1)\n            )\n        }\n    }\n\n    /**\n     * @dev Internal pure function that returns a string of \"[2]\" substrings,\n     *      with a number of substrings equal to the provided height.\n     *\n     * @param maxHeight The number of \"[2]\" substrings to include.\n     *\n     * @return A bytes array representing the string.\n     */\n    function getMaxTreeBrackets(\n        uint256 maxHeight\n    ) internal pure returns (bytes memory) {\n        bytes memory suffixes = new bytes(twoSubstringLength * maxHeight);\n        assembly {\n            // Retrieve the pointer to the array head.\n            let ptr := add(suffixes, OneWord)\n\n            // Derive the terminal pointer.\n            let endPtr := add(ptr, mul(maxHeight, twoSubstringLength))\n\n            // Iterate over each pointer until terminal pointer is reached.\n            for {\n\n            } lt(ptr, endPtr) {\n                ptr := add(ptr, twoSubstringLength)\n            } {\n                // Insert \"[2]\" substring directly at current pointer location.\n                mstore(ptr, twoSubstring)\n            }\n        }\n\n        // Return the fully populated array of substrings.\n        return suffixes;\n    }\n\n    /**\n     * @dev Internal pure function that returns a string of subtypes used in\n     *      generating bulk order EIP-712 typehashes.\n     *\n     * @return A bytes array representing the string.\n     */\n    function getTreeSubTypes() internal pure returns (bytes memory) {\n        // Construct the OfferItem type string.\n        // prettier-ignore\n        bytes memory offerItemTypeString = bytes(\n                \"OfferItem(\"\n                    \"uint8 itemType,\"\n                    \"address token,\"\n                    \"uint256 identifierOrCriteria,\"\n                    \"uint256 startAmount,\"\n                    \"uint256 endAmount\"\n                \")\"\n            );\n\n        // Construct the ConsiderationItem type string.\n        // prettier-ignore\n        bytes memory considerationItemTypeString = bytes(\n                \"ConsiderationItem(\"\n                    \"uint8 itemType,\"\n                    \"address token,\"\n                    \"uint256 identifierOrCriteria,\"\n                    \"uint256 startAmount,\"\n                    \"uint256 endAmount,\"\n                    \"address recipient\"\n                \")\"\n            );\n\n        // Construct the OrderComponents type string, not including the above.\n        // prettier-ignore\n        bytes memory orderComponentsPartialTypeString = bytes(\n                \"OrderComponents(\"\n                    \"address offerer,\"\n                    \"address zone,\"\n                    \"OfferItem[] offer,\"\n                    \"ConsiderationItem[] consideration,\"\n                    \"uint8 orderType,\"\n                    \"uint256 startTime,\"\n                    \"uint256 endTime,\"\n                    \"bytes32 zoneHash,\"\n                    \"uint256 salt,\"\n                    \"bytes32 conduitKey,\"\n                    \"uint256 counter\"\n                \")\"\n            );\n\n        // Return the combined string.\n        return\n            abi.encodePacked(\n                considerationItemTypeString,\n                offerItemTypeString,\n                orderComponentsPartialTypeString\n            );\n    }\n}"
    }
  ]
}