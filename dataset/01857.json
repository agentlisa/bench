{
  "Title": "Virtual pools detached from the corresponding `AlgebraPool` result in an inconsistent state",
  "Content": "##### Description\nIn cases where `AlgebraPool` connected to `VirtualAlgebraPool` catches a revert during a call to the `crossTo` function, the pool will reset its `activeIncentive` parameter to the 0 address here: https://github.com/cryptoalgebra/Algebra/blob/7290fad656bfa89db3743c52af631154f6a8a2d5/src/core/contracts/base/SwapCalculation.sol#L210.\nSubsequently, the virtual pool enters a state where it is not `deactivated`, its `rewardRates` remain non-zero, and the detached pool no longer updates subsequent price changes. As a result, current liquidity providers continue to collect rewards based on the \"frozen\" price present in the pool at the moment of detachment.\n\n##### Recommendation\nWe recommend updating `rewardRates` for the pool to 0 and setting the `deactivated` state to `true` during the detachment process to prevent the accumulation of rewards based on outdated prices.\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "src/core/contracts/base/SwapCalculation.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.17;\n\nimport '../interfaces/IAlgebraVirtualPool.sol';\nimport '../libraries/PriceMovementMath.sol';\nimport '../libraries/LimitOrderManagement.sol';\nimport '../libraries/LowGasSafeMath.sol';\nimport '../libraries/SafeCast.sol';\nimport './AlgebraPoolBase.sol';\n\n/// @title Algebra swap calculation abstract contract\n/// @notice Contains _calculateSwap encapsulating internal logic of swaps\nabstract contract SwapCalculation is AlgebraPoolBase {\n  using TickManagement for mapping(int24 => TickManagement.Tick);\n  using LimitOrderManagement for mapping(int24 => LimitOrderManagement.LimitOrder);\n  using SafeCast for uint256;\n  using LowGasSafeMath for uint256;\n  using LowGasSafeMath for int256;\n\n  struct SwapCalculationCache {\n    uint256 communityFee; // The community fee of the selling token, uint256 to minimize casts\n    uint160 secondsPerLiquidityCumulative; // The global secondPerLiquidity at the moment\n    bool crossedAnyTick; //  If we have already crossed at least one active tick\n    int256 amountRequiredInitial; // The initial value of the exact input\\output amount\n    int256 amountCalculated; // The additive amount of total output\\input calculated through the swap\n    uint256 totalFeeGrowth; // The initial totalFeeGrowth + the fee growth during a swap\n    uint256 totalFeeGrowthB;\n    bool exactInput; // Whether the exact input or output is specified\n    uint16 fee; // The current dynamic fee\n    uint16 timepointIndex; // The index of last written timepoint\n    int24 prevInitializedTick; // The previous initialized tick in linked list\n    uint32 blockTimestamp; // The timestamp of current block\n  }\n\n  struct PriceMovementCache {\n    uint160 stepSqrtPrice; // The Q64.96 sqrt of the price at the start of the step\n    int24 nextTick; // The tick till the current step goes\n    bool initialized; // True if the _nextTick_ is initialized\n    uint160 nextTickPrice; // The Q64.96 sqrt of the price calculated from the _nextTick_\n    uint256 input; // The additive amount of tokens that have been provided\n    uint256 output; // The additive amount of token that have been withdrawn\n    uint256 feeAmount; // The total amount of fee earned within a current step\n    bool inLimitOrder; // If a limit order is currently being executed\n  }\n\n  function _calculateSwap(\n    bool zeroToOne,\n    int256 amountRequired,\n    uint160 limitSqrtPrice\n  ) internal returns (int256 amount0, int256 amount1, uint160 currentPrice, int24 currentTick, uint128 currentLiquidity, uint256 communityFeeAmount) {\n    if (amountRequired == 0) revert zeroAmountRequired();\n    if (amountRequired == type(int256).min) revert invalidAmountRequired(); // to avoid problems when changing sign\n    SwapCalculationCache memory cache;\n    {\n      // load from one storage slot\n      currentPrice = globalState.price;\n      currentTick = globalState.tick;\n      cache.fee = globalState.fee;\n      cache.timepointIndex = globalState.timepointIndex;\n      cache.communityFee = globalState.communityFee;\n      cache.prevInitializedTick = globalState.prevInitializedTick;\n\n      (cache.amountRequiredInitial, cache.exactInput) = (amountRequired, amountRequired > 0);\n\n      currentLiquidity = liquidity;\n\n      if (zeroToOne) {\n        if (limitSqrtPrice >= currentPrice || limitSqrtPrice <= TickMath.MIN_SQRT_RATIO) revert invalidLimitSqrtPrice();\n        cache.totalFeeGrowth = totalFeeGrowth0Token;\n      } else {\n        if (limitSqrtPrice <= currentPrice || limitSqrtPrice >= TickMath.MAX_SQRT_RATIO) revert invalidLimitSqrtPrice();\n        cache.totalFeeGrowth = totalFeeGrowth1Token;\n      }\n\n      cache.blockTimestamp = _blockTimestamp();\n\n      (uint16 newTimepointIndex, uint16 newFee) = _writeTimepoint(cache.timepointIndex, cache.blockTimestamp, currentTick, currentLiquidity);\n\n      // new timepoint appears only for first swap/mint/burn in block\n      if (newTimepointIndex != cache.timepointIndex) {\n        cache.timepointIndex = newTimepointIndex;\n        if (cache.fee != newFee) {\n          cache.fee = newFee;\n          emit Fee(newFee);\n        }\n      }\n    }\n\n    PriceMovementCache memory step;\n    step.nextTick = zeroToOne ? cache.prevInitializedTick : ticks[cache.prevInitializedTick].nextTick;\n    unchecked {\n      // swap until there is remaining input or output tokens or we reach the price limit\n      while (true) {\n        step.stepSqrtPrice = currentPrice;\n        step.initialized = true;\n        step.nextTickPrice = TickMath.getSqrtRatioAtTick(step.nextTick);\n\n        if (step.stepSqrtPrice == step.nextTickPrice && ticks[step.nextTick].hasLimitOrders) {\n          step.inLimitOrder = true;\n          bool isLimitOrderExecuted = false;\n          // calculate the amounts from LO\n          (isLimitOrderExecuted, step.output, step.input, step.feeAmount) = limitOrders.executeLimitOrders(\n            step.nextTick,\n            currentPrice,\n            zeroToOne,\n            amountRequired,\n            cache.fee / 2\n          );\n          if (isLimitOrderExecuted) {\n            if (ticks[step.nextTick].liquidityTotal == 0) {\n              cache.prevInitializedTick = _insertOrRemoveTick(step.nextTick, currentTick, cache.prevInitializedTick, true);\n              step.initialized = false;\n            } else {\n              ticks[step.nextTick].hasLimitOrders = false;\n            }\n            step.inLimitOrder = false;\n          }\n        } else {\n          (currentPrice, step.input, step.output, step.feeAmount) = PriceMovementMath.movePriceTowardsTarget(\n            zeroToOne,\n            currentPrice,\n            (zeroToOne == (step.nextTickPrice < limitSqrtPrice)) // move the price to the target or to the limit\n              ? limitSqrtPrice\n              : step.nextTickPrice,\n            currentLiquidity,\n            amountRequired,\n            cache.fee\n          );\n        }\n\n        if (cache.exactInput) {\n          amountRequired -= (step.input + step.feeAmount).toInt256(); // decrease remaining input amount\n          cache.amountCalculated = cache.amountCalculated.sub(step.output.toInt256()); // decrease calculated output amount\n        } else {\n          amountRequired += step.output.toInt256(); // increase remaining output amount (since its negative)\n          cache.amountCalculated = cache.amountCalculated.add((step.input + step.feeAmount).toInt256()); // increase calculated input amount\n        }\n\n        if (cache.communityFee > 0) {\n          uint256 delta = (step.feeAmount.mul(cache.communityFee)) / Constants.COMMUNITY_FEE_DENOMINATOR;\n          step.feeAmount -= delta;\n          communityFeeAmount += delta;\n        }\n\n        if (currentLiquidity > 0) cache.totalFeeGrowth += FullMath.mulDiv(step.feeAmount, Constants.Q128, currentLiquidity);\n\n        if (currentPrice == step.nextTickPrice && !step.inLimitOrder) {\n          // if the reached tick is initialized then we need to cross it\n          if (step.initialized) {\n            // we have opened LOs\n            if (ticks[step.nextTick].hasLimitOrders) {\n              currentTick = zeroToOne ? step.nextTick : step.nextTick - 1;\n              continue;\n            }\n\n            if (!cache.crossedAnyTick) {\n              cache.crossedAnyTick = true;\n              cache.secondsPerLiquidityCumulative = secondsPerLiquidityCumulative;\n              cache.totalFeeGrowthB = zeroToOne ? totalFeeGrowth1Token : totalFeeGrowth0Token;\n            }\n\n            int128 liquidityDelta;\n            if (zeroToOne) {\n              liquidityDelta = -ticks.cross(\n                step.nextTick,\n                cache.totalFeeGrowth, // A == 0\n                cache.totalFeeGrowthB, // B == 1\n                cache.secondsPerLiquidityCumulative,\n                cache.blockTimestamp\n              );\n              cache.prevInitializedTick = ticks[cache.prevInitializedTick].prevTick;\n            } else {\n              liquidityDelta = ticks.cross(\n                step.nextTick,\n                cache.totalFeeGrowthB, // B == 0\n                cache.totalFeeGrowth, // A == 1\n                cache.secondsPerLiquidityCumulative,\n                cache.blockTimestamp\n              );\n              cache.prevInitializedTick = step.nextTick;\n            }\n            currentLiquidity = LiquidityMath.addDelta(currentLiquidity, liquidityDelta);\n          }\n\n          (currentTick, step.nextTick) = zeroToOne\n            ? (step.nextTick - 1, cache.prevInitializedTick)\n            : (step.nextTick, ticks[cache.prevInitializedTick].nextTick);\n        } else if (currentPrice != step.stepSqrtPrice) {\n          // if the price has changed but hasn't reached the target\n          currentTick = TickMath.getTickAtSqrtRatio(currentPrice);\n          break; // since the price hasn't reached the target, amountRequired should be 0\n        }\n        // check stop condition\n        if (amountRequired == 0 || currentPrice == limitSqrtPrice) {\n          break;\n        }\n      }\n\n      if (cache.crossedAnyTick) {\n        // ticks cross data is needed to be duplicated in a virtual pool\n        address _activeIncentive = activeIncentive;\n        if (_activeIncentive != address(0)) {\n          bool isIncentiveActive; // if the incentive is stopped or faulty, the active incentive will be reset to 0\n          try IAlgebraVirtualPool(_activeIncentive).crossTo(currentTick, zeroToOne) returns (bool success) {\n            isIncentiveActive = success;\n          } catch {\n            // pool will reset activeIncentive in this case\n          }\n          if (!isIncentiveActive) {\n            activeIncentive = address(0);\n            emit Incentive(address(0));\n          }\n        }\n      }\n\n      (amount0, amount1) = zeroToOne == cache.exactInput // the amount to provide could be less than initially specified (e.g. reached limit)\n        ? (cache.amountRequiredInitial - amountRequired, cache.amountCalculated) // the amount to get could be less than initially specified (e.g. reached limit)\n        : (cache.amountCalculated, cache.amountRequiredInitial - amountRequired);\n    }\n\n    (globalState.price, globalState.tick, globalState.fee, globalState.timepointIndex, globalState.prevInitializedTick) = (\n      currentPrice,\n      currentTick,\n      cache.fee,\n      cache.timepointIndex,\n      cache.prevInitializedTick\n    );\n\n    liquidity = currentLiquidity;\n    if (zeroToOne) {\n      totalFeeGrowth0Token = cache.totalFeeGrowth;\n    } else {\n      totalFeeGrowth1Token = cache.totalFeeGrowth;\n    }\n  }\n}"
    }
  ]
}