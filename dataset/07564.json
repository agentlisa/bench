{
  "Title": "[L-06]  `abi.encodePacked()` should not be used with dynamic types when passing the result to a hash function such as `keccak256()`",
  "Content": "Use `abi.encode()` instead which will pad items to 32 bytes, which will [prevent hash collisions](https://docs.soliditylang.org/en/v0.8.13/abi-spec.html#non-standard-packed-mode) (e.g. `abi.encodePacked(0x123,0x456)` => `0x123456` => `abi.encodePacked(0x1,0x23456)`, but `abi.encode(0x123,0x456)` => `0x0...1230...456`). \"Unless there is a compelling reason, `abi.encode` should be preferred\". If there is only one argument to `abi.encodePacked()` it can often be cast to `bytes()` or `bytes32()` [instead](https://ethereum.stackexchange.com/questions/30912/how-to-compare-strings-in-solidity#answer-82739).\n\nIf all arguments are strings and or bytes, `bytes.concat()` should be used instead.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: paraspace-core/contracts/protocol/libraries/logic/ValidationLogic.sol\n\n1115          bytes32 typeHash = keccak256(\n1116              abi.encodePacked(\n1117                  \"Credit(address token,uint256 amount,bytes orderId)\"\n1118              )\n1119:         );\n\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/logic/ValidationLogic.sol#L1115-L1119\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-11-paraspace",
  "Code": [
    {
      "filename": "paraspace-core/contracts/protocol/libraries/logic/ValidationLogic.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {IERC20} from \"../../../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport {IERC721} from \"../../../dependencies/openzeppelin/contracts/IERC721.sol\";\nimport {Address} from \"../../../dependencies/openzeppelin/contracts/Address.sol\";\nimport {GPv2SafeERC20} from \"../../../dependencies/gnosis/contracts/GPv2SafeERC20.sol\";\nimport {IReserveInterestRateStrategy} from \"../../../interfaces/IReserveInterestRateStrategy.sol\";\nimport {IScaledBalanceToken} from \"../../../interfaces/IScaledBalanceToken.sol\";\nimport {IPriceOracleGetter} from \"../../../interfaces/IPriceOracleGetter.sol\";\nimport {IPToken} from \"../../../interfaces/IPToken.sol\";\nimport {ICollateralizableERC721} from \"../../../interfaces/ICollateralizableERC721.sol\";\nimport {IAuctionableERC721} from \"../../../interfaces/IAuctionableERC721.sol\";\nimport {INToken} from \"../../../interfaces/INToken.sol\";\nimport {SignatureChecker} from \"../../../dependencies/looksrare/contracts/libraries/SignatureChecker.sol\";\nimport {IPriceOracleSentinel} from \"../../../interfaces/IPriceOracleSentinel.sol\";\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {UserConfiguration} from \"../configuration/UserConfiguration.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {WadRayMath} from \"../math/WadRayMath.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {GenericLogic} from \"./GenericLogic.sol\";\nimport {SafeCast} from \"../../../dependencies/openzeppelin/contracts/SafeCast.sol\";\nimport {IToken} from \"../../../interfaces/IToken.sol\";\nimport {XTokenType, IXTokenType} from \"../../../interfaces/IXTokenType.sol\";\nimport {Helpers} from \"../helpers/Helpers.sol\";\nimport {INonfungiblePositionManager} from \"../../../dependencies/uniswap/INonfungiblePositionManager.sol\";\nimport \"../../../interfaces/INTokenApeStaking.sol\";\n\n/**\n * @title ReserveLogic library\n *\n * @notice Implements functions to validate the different actions of the protocol\n */\nlibrary ValidationLogic {\n    using WadRayMath for uint256;\n    using PercentageMath for uint256;\n    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n    using UserConfiguration for DataTypes.UserConfigurationMap;\n\n    // Factor to apply to \"only-variable-debt\" liquidity rate to get threshold for rebalancing, expressed in bps\n    // A value of 0.9e4 results in 90%\n    uint256 public constant REBALANCE_UP_LIQUIDITY_RATE_THRESHOLD = 0.9e4;\n\n    // Minimum health factor allowed under any circumstance\n    // A value of 0.95e18 results in 0.95\n    uint256 public constant MINIMUM_HEALTH_FACTOR_LIQUIDATION_THRESHOLD =\n        0.95e18;\n\n    /**\n     * @dev Minimum health factor to consider a user position healthy\n     * A value of 1e18 results in 1\n     */\n    uint256 public constant HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 1e18;\n\n    /**\n     * @notice Validates a supply action.\n     * @param reserveCache The cached data of the reserve\n     * @param amount The amount to be supplied\n     */\n    function validateSupply(\n        DataTypes.ReserveCache memory reserveCache,\n        uint256 amount,\n        DataTypes.AssetType assetType\n    ) internal view {\n        require(amount != 0, Errors.INVALID_AMOUNT);\n\n        IXTokenType xToken = IXTokenType(reserveCache.xTokenAddress);\n        require(\n            xToken.getXTokenType() != XTokenType.PTokenSApe,\n            Errors.SAPE_NOT_ALLOWED\n        );\n\n        (\n            bool isActive,\n            bool isFrozen,\n            ,\n            bool isPaused,\n            DataTypes.AssetType reserveAssetType\n        ) = reserveCache.reserveConfiguration.getFlags();\n\n        require(reserveAssetType == assetType, Errors.INVALID_ASSET_TYPE);\n        require(isActive, Errors.RESERVE_INACTIVE);\n        require(!isPaused, Errors.RESERVE_PAUSED);\n        require(!isFrozen, Errors.RESERVE_FROZEN);\n\n        uint256 supplyCap = reserveCache.reserveConfiguration.getSupplyCap();\n\n        if (assetType == DataTypes.AssetType.ERC20) {\n            require(\n                supplyCap == 0 ||\n                    (IPToken(reserveCache.xTokenAddress)\n                        .scaledTotalSupply()\n                        .rayMul(reserveCache.nextLiquidityIndex) + amount) <=\n                    supplyCap *\n                        (10**reserveCache.reserveConfiguration.getDecimals()),\n                Errors.SUPPLY_CAP_EXCEEDED\n            );\n        } else if (assetType == DataTypes.AssetType.ERC721) {\n            require(\n                supplyCap == 0 ||\n                    (INToken(reserveCache.xTokenAddress).totalSupply() +\n                        amount <=\n                        supplyCap),\n                Errors.SUPPLY_CAP_EXCEEDED\n            );\n        }\n    }\n\n    /**\n     * @notice Validates a supply action from NToken contract\n     * @param reserveCache The cached data of the reserve\n     * @param params The params of the supply\n     * @param assetType the type of the asset supplied\n     */\n    function validateSupplyFromNToken(\n        DataTypes.ReserveCache memory reserveCache,\n        DataTypes.ExecuteSupplyERC721Params memory params,\n        DataTypes.AssetType assetType\n    ) internal view {\n        require(\n            msg.sender == reserveCache.xTokenAddress,\n            Errors.CALLER_NOT_XTOKEN\n        );\n\n        uint256 amount = params.tokenData.length;\n        validateSupply(reserveCache, amount, assetType);\n\n        for (uint256 index = 0; index < amount; index++) {\n            // validate that the owner of the underlying asset is the NToken  contract\n            require(\n                IERC721(params.asset).ownerOf(\n                    params.tokenData[index].tokenId\n                ) == reserveCache.xTokenAddress,\n                Errors.NOT_THE_OWNER\n            );\n            // validate that the owner of the ntoken that has the same tokenId is the zero address\n            require(\n                IERC721(reserveCache.xTokenAddress).ownerOf(\n                    params.tokenData[index].tokenId\n                ) == address(0x0),\n                Errors.NOT_THE_OWNER\n            );\n        }\n    }\n\n    /**\n     * @notice Validates a withdraw action.\n     * @param reserveCache The cached data of the reserve\n     * @param amount The amount to be withdrawn\n     * @param userBalance The balance of the user\n     */\n    function validateWithdraw(\n        DataTypes.ReserveCache memory reserveCache,\n        uint256 amount,\n        uint256 userBalance\n    ) internal pure {\n        require(amount != 0, Errors.INVALID_AMOUNT);\n\n        require(\n            amount <= userBalance,\n            Errors.NOT_ENOUGH_AVAILABLE_USER_BALANCE\n        );\n\n        IXTokenType xToken = IXTokenType(reserveCache.xTokenAddress);\n        require(\n            xToken.getXTokenType() != XTokenType.PTokenSApe,\n            Errors.SAPE_NOT_ALLOWED\n        );\n\n        (\n            bool isActive,\n            ,\n            ,\n            bool isPaused,\n            DataTypes.AssetType reserveAssetType\n        ) = reserveCache.reserveConfiguration.getFlags();\n\n        require(\n            reserveAssetType == DataTypes.AssetType.ERC20,\n            Errors.INVALID_ASSET_TYPE\n        );\n        require(isActive, Errors.RESERVE_INACTIVE);\n        require(!isPaused, Errors.RESERVE_PAUSED);\n    }\n\n    function validateWithdrawERC721(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        DataTypes.ReserveCache memory reserveCache,\n        address asset,\n        uint256[] memory tokenIds\n    ) internal view {\n        (\n            bool isActive,\n            ,\n            ,\n            bool isPaused,\n            DataTypes.AssetType reserveAssetType\n        ) = reserveCache.reserveConfiguration.getFlags();\n\n        require(\n            reserveAssetType == DataTypes.AssetType.ERC721,\n            Errors.INVALID_ASSET_TYPE\n        );\n        require(isActive, Errors.RESERVE_INACTIVE);\n        require(!isPaused, Errors.RESERVE_PAUSED);\n\n        INToken nToken = INToken(reserveCache.xTokenAddress);\n        if (nToken.getXTokenType() == XTokenType.NTokenUniswapV3) {\n            for (uint256 index = 0; index < tokenIds.length; index++) {\n                ValidationLogic.validateForUniswapV3(\n                    reservesData,\n                    asset,\n                    tokenIds[index],\n                    true,\n                    true,\n                    false\n                );\n            }\n        }\n    }\n\n    struct ValidateBorrowLocalVars {\n        uint256 currentLtv;\n        uint256 collateralNeededInBaseCurrency;\n        uint256 userCollateralInBaseCurrency;\n        uint256 userDebtInBaseCurrency;\n        uint256 availableLiquidity;\n        uint256 healthFactor;\n        uint256 totalDebt;\n        uint256 totalSupplyVariableDebt;\n        uint256 reserveDecimals;\n        uint256 borrowCap;\n        uint256 amountInBaseCurrency;\n        uint256 assetUnit;\n        address siloedBorrowingAddress;\n        bool isActive;\n        bool isFrozen;\n        bool isPaused;\n        bool borrowingEnabled;\n        bool siloedBorrowingEnabled;\n        DataTypes.AssetType assetType;\n    }\n\n    /**\n     * @notice Validates a borrow action.\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param params Additional params needed for the validation\n     */\n    function validateBorrow(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        DataTypes.ValidateBorrowParams memory params\n    ) internal view {\n        require(params.amount != 0, Errors.INVALID_AMOUNT);\n        ValidateBorrowLocalVars memory vars;\n\n        (\n            vars.isActive,\n            vars.isFrozen,\n            vars.borrowingEnabled,\n            vars.isPaused,\n            vars.assetType\n        ) = params.reserveCache.reserveConfiguration.getFlags();\n\n        require(\n            vars.assetType == DataTypes.AssetType.ERC20,\n            Errors.INVALID_ASSET_TYPE\n        );\n        require(vars.isActive, Errors.RESERVE_INACTIVE);\n        require(!vars.isPaused, Errors.RESERVE_PAUSED);\n        require(!vars.isFrozen, Errors.RESERVE_FROZEN);\n        require(vars.borrowingEnabled, Errors.BORROWING_NOT_ENABLED);\n\n        require(\n            params.priceOracleSentinel == address(0) ||\n                IPriceOracleSentinel(params.priceOracleSentinel)\n                    .isBorrowAllowed(),\n            Errors.PRICE_ORACLE_SENTINEL_CHECK_FAILED\n        );\n\n        vars.reserveDecimals = params\n            .reserveCache\n            .reserveConfiguration\n            .getDecimals();\n        vars.borrowCap = params\n            .reserveCache\n            .reserveConfiguration\n            .getBorrowCap();\n        unchecked {\n            vars.assetUnit = 10**vars.reserveDecimals;\n        }\n\n        if (vars.borrowCap != 0) {\n            vars.totalSupplyVariableDebt = params\n                .reserveCache\n                .currScaledVariableDebt\n                .rayMul(params.reserveCache.nextVariableBorrowIndex);\n\n            vars.totalDebt = vars.totalSupplyVariableDebt + params.amount;\n\n            unchecked {\n                require(\n                    vars.totalDebt <= vars.borrowCap * vars.assetUnit,\n                    Errors.BORROW_CAP_EXCEEDED\n                );\n            }\n        }\n\n        (\n            vars.userCollateralInBaseCurrency,\n            ,\n            vars.userDebtInBaseCurrency,\n            vars.currentLtv,\n            ,\n            ,\n            ,\n            vars.healthFactor,\n            ,\n\n        ) = GenericLogic.calculateUserAccountData(\n            reservesData,\n            reservesList,\n            DataTypes.CalculateUserAccountDataParams({\n                userConfig: params.userConfig,\n                reservesCount: params.reservesCount,\n                user: params.userAddress,\n                oracle: params.oracle\n            })\n        );\n\n        require(\n            vars.userCollateralInBaseCurrency != 0,\n            Errors.COLLATERAL_BALANCE_IS_ZERO\n        );\n        require(vars.currentLtv != 0, Errors.LTV_VALIDATION_FAILED);\n\n        require(\n            vars.healthFactor > HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\n            Errors.HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD\n        );\n\n        vars.amountInBaseCurrency =\n            IPriceOracleGetter(params.oracle).getAssetPrice(params.asset) *\n            params.amount;\n        unchecked {\n            vars.amountInBaseCurrency /= vars.assetUnit;\n        }\n\n        //add the current already borrowed amount to the amount requested to calculate the total collateral needed.\n        vars.collateralNeededInBaseCurrency = (vars.userDebtInBaseCurrency +\n            vars.amountInBaseCurrency).percentDiv(vars.currentLtv); //LTV is calculated in percentage\n\n        require(\n            vars.collateralNeededInBaseCurrency <=\n                vars.userCollateralInBaseCurrency,\n            Errors.COLLATERAL_CANNOT_COVER_NEW_BORROW\n        );\n    }\n\n    /**\n     * @notice Validates a repay action.\n     * @param reserveCache The cached data of the reserve\n     * @param amountSent The amount sent for the repayment. Can be an actual value or uint(-1)\n     * @param onBehalfOf The address of the user msg.sender is repaying for\n     * @param variableDebt The borrow balance of the user\n     */\n    function validateRepay(\n        DataTypes.ReserveCache memory reserveCache,\n        uint256 amountSent,\n        address onBehalfOf,\n        uint256 variableDebt\n    ) internal view {\n        require(amountSent != 0, Errors.INVALID_AMOUNT);\n        require(\n            amountSent != type(uint256).max || msg.sender == onBehalfOf,\n            Errors.NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF\n        );\n\n        (\n            bool isActive,\n            ,\n            ,\n            bool isPaused,\n            DataTypes.AssetType assetType\n        ) = reserveCache.reserveConfiguration.getFlags();\n        require(isActive, Errors.RESERVE_INACTIVE);\n        require(!isPaused, Errors.RESERVE_PAUSED);\n        require(\n            assetType == DataTypes.AssetType.ERC20,\n            Errors.INVALID_ASSET_TYPE\n        );\n\n        uint256 variableDebtPreviousIndex = IScaledBalanceToken(\n            reserveCache.variableDebtTokenAddress\n        ).getPreviousIndex(onBehalfOf);\n\n        require(\n            (variableDebtPreviousIndex < reserveCache.nextVariableBorrowIndex),\n            Errors.SAME_BLOCK_BORROW_REPAY\n        );\n\n        require((variableDebt != 0), Errors.NO_DEBT_OF_SELECTED_TYPE);\n    }\n\n    /**\n     * @notice Validates the action of setting an asset as collateral.\n     * @param reserveCache The cached data of the reserve\n     * @param userBalance The balance of the user\n     */\n    function validateSetUseERC20AsCollateral(\n        DataTypes.ReserveCache memory reserveCache,\n        uint256 userBalance\n    ) internal pure {\n        require(userBalance != 0, Errors.UNDERLYING_BALANCE_ZERO);\n\n        IXTokenType xToken = IXTokenType(reserveCache.xTokenAddress);\n        require(\n            xToken.getXTokenType() != XTokenType.PTokenSApe,\n            Errors.SAPE_NOT_ALLOWED\n        );\n\n        (\n            bool isActive,\n            ,\n            ,\n            bool isPaused,\n            DataTypes.AssetType reserveAssetType\n        ) = reserveCache.reserveConfiguration.getFlags();\n\n        require(\n            reserveAssetType == DataTypes.AssetType.ERC20,\n            Errors.INVALID_ASSET_TYPE\n        );\n        require(isActive, Errors.RESERVE_INACTIVE);\n        require(!isPaused, Errors.RESERVE_PAUSED);\n    }\n\n    function validateSetUseERC721AsCollateral(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        DataTypes.ReserveCache memory reserveCache,\n        address asset,\n        uint256[] calldata tokenIds\n    ) internal view {\n        (\n            bool isActive,\n            ,\n            ,\n            bool isPaused,\n            DataTypes.AssetType reserveAssetType\n        ) = reserveCache.reserveConfiguration.getFlags();\n\n        require(\n            reserveAssetType == DataTypes.AssetType.ERC721,\n            Errors.INVALID_ASSET_TYPE\n        );\n        require(isActive, Errors.RESERVE_INACTIVE);\n        require(!isPaused, Errors.RESERVE_PAUSED);\n\n        INToken nToken = INToken(reserveCache.xTokenAddress);\n        if (nToken.getXTokenType() == XTokenType.NTokenUniswapV3) {\n            for (uint256 index = 0; index < tokenIds.length; index++) {\n                ValidationLogic.validateForUniswapV3(\n                    reservesData,\n                    asset,\n                    tokenIds[index],\n                    true,\n                    true,\n                    false\n                );\n            }\n        }\n    }\n\n    struct ValidateLiquidateLocalVars {\n        bool collateralReserveActive;\n        bool collateralReservePaused;\n        bool principalReserveActive;\n        bool principalReservePaused;\n        bool isCollateralEnabled;\n        DataTypes.AssetType collateralReserveAssetType;\n    }\n\n    struct ValidateAuctionLocalVars {\n        bool collateralReserveActive;\n        bool collateralReservePaused;\n        bool isCollateralEnabled;\n        DataTypes.AssetType collateralReserveAssetType;\n    }\n\n    /**\n     * @notice Validates the liquidation action.\n     * @param userConfig The user configuration mapping\n     * @param collateralReserve The reserve data of the collateral\n     * @param params Additional parameters needed for the validation\n     */\n    function validateLiquidateERC20(\n        DataTypes.UserConfigurationMap storage userConfig,\n        DataTypes.ReserveData storage collateralReserve,\n        DataTypes.ValidateLiquidateERC20Params memory params\n    ) internal view {\n        ValidateLiquidateLocalVars memory vars;\n\n        (\n            vars.collateralReserveActive,\n            ,\n            ,\n            vars.collateralReservePaused,\n            vars.collateralReserveAssetType\n        ) = collateralReserve.configuration.getFlags();\n\n        require(\n            vars.collateralReserveAssetType == DataTypes.AssetType.ERC20,\n            Errors.INVALID_ASSET_TYPE\n        );\n\n        require(\n            msg.value == 0 || params.liquidationAsset == params.weth,\n            Errors.INVALID_LIQUIDATION_ASSET\n        );\n\n        require(\n            msg.value == 0 || msg.value >= params.actualLiquidationAmount,\n            Errors.LIQUIDATION_AMOUNT_NOT_ENOUGH\n        );\n\n        IXTokenType xToken = IXTokenType(\n            params.liquidationAssetReserveCache.xTokenAddress\n        );\n        require(\n            xToken.getXTokenType() != XTokenType.PTokenSApe,\n            Errors.SAPE_NOT_ALLOWED\n        );\n\n        (\n            vars.principalReserveActive,\n            ,\n            ,\n            vars.principalReservePaused,\n\n        ) = params.liquidationAssetReserveCache.reserveConfiguration.getFlags();\n\n        require(\n            vars.collateralReserveActive && vars.principalReserveActive,\n            Errors.RESERVE_INACTIVE\n        );\n        require(\n            !vars.collateralReservePaused && !vars.principalReservePaused,\n            Errors.RESERVE_PAUSED\n        );\n\n        require(\n            params.priceOracleSentinel == address(0) ||\n                params.healthFactor <\n                MINIMUM_HEALTH_FACTOR_LIQUIDATION_THRESHOLD ||\n                IPriceOracleSentinel(params.priceOracleSentinel)\n                    .isLiquidationAllowed(),\n            Errors.PRICE_ORACLE_SENTINEL_CHECK_FAILED\n        );\n\n        require(\n            params.healthFactor < HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\n            Errors.HEALTH_FACTOR_NOT_BELOW_THRESHOLD\n        );\n\n        vars.isCollateralEnabled =\n            collateralReserve.configuration.getLiquidationThreshold() != 0 &&\n            userConfig.isUsingAsCollateral(collateralReserve.id);\n\n        //if collateral isn't enabled as collateral by user, it cannot be liquidated\n        require(\n            vars.isCollateralEnabled,\n            Errors.COLLATERAL_CANNOT_BE_AUCTIONED_OR_LIQUIDATED\n        );\n        require(\n            params.totalDebt != 0,\n            Errors.SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER\n        );\n    }\n\n    /**\n     * @notice Validates the liquidation action.\n     * @param userConfig The user configuration mapping\n     * @param collateralReserve The reserve data of the collateral\n     * @param params Additional parameters needed for the validation\n     */\n    function validateLiquidateERC721(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        DataTypes.UserConfigurationMap storage userConfig,\n        DataTypes.ReserveData storage collateralReserve,\n        DataTypes.ValidateLiquidateERC721Params memory params\n    ) internal view {\n        require(\n            params.liquidator != params.borrower,\n            Errors.LIQUIDATOR_CAN_NOT_BE_SELF\n        );\n\n        ValidateLiquidateLocalVars memory vars;\n\n        (\n            vars.collateralReserveActive,\n            ,\n            ,\n            vars.collateralReservePaused,\n            vars.collateralReserveAssetType\n        ) = collateralReserve.configuration.getFlags();\n\n        require(\n            vars.collateralReserveAssetType == DataTypes.AssetType.ERC721,\n            Errors.INVALID_ASSET_TYPE\n        );\n\n        INToken nToken = INToken(collateralReserve.xTokenAddress);\n        if (nToken.getXTokenType() == XTokenType.NTokenUniswapV3) {\n            ValidationLogic.validateForUniswapV3(\n                reservesData,\n                params.collateralAsset,\n                params.tokenId,\n                true,\n                true,\n                false\n            );\n        }\n\n        (\n            vars.principalReserveActive,\n            ,\n            ,\n            vars.principalReservePaused,\n\n        ) = params.liquidationAssetReserveCache.reserveConfiguration.getFlags();\n\n        require(\n            vars.collateralReserveActive && vars.principalReserveActive,\n            Errors.RESERVE_INACTIVE\n        );\n        require(\n            !vars.collateralReservePaused && !vars.principalReservePaused,\n            Errors.RESERVE_PAUSED\n        );\n\n        require(\n            params.priceOracleSentinel == address(0) ||\n                params.healthFactor <\n                MINIMUM_HEALTH_FACTOR_LIQUIDATION_THRESHOLD ||\n                IPriceOracleSentinel(params.priceOracleSentinel)\n                    .isLiquidationAllowed(),\n            Errors.PRICE_ORACLE_SENTINEL_CHECK_FAILED\n        );\n\n        if (params.auctionEnabled) {\n            require(\n                params.healthFactor < params.auctionRecoveryHealthFactor,\n                Errors.ERC721_HEALTH_FACTOR_NOT_BELOW_THRESHOLD\n            );\n            require(\n                IAuctionableERC721(params.xTokenAddress).isAuctioned(\n                    params.tokenId\n                ),\n                Errors.AUCTION_NOT_STARTED\n            );\n        } else {\n            require(\n                params.healthFactor < HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\n                Errors.ERC721_HEALTH_FACTOR_NOT_BELOW_THRESHOLD\n            );\n        }\n\n        require(\n            params.maxLiquidationAmount >= params.actualLiquidationAmount &&\n                (msg.value == 0 || msg.value >= params.maxLiquidationAmount),\n            Errors.LIQUIDATION_AMOUNT_NOT_ENOUGH\n        );\n\n        vars.isCollateralEnabled =\n            collateralReserve.configuration.getLiquidationThreshold() != 0 &&\n            userConfig.isUsingAsCollateral(collateralReserve.id) &&\n            ICollateralizableERC721(params.xTokenAddress).isUsedAsCollateral(\n                params.tokenId\n            );\n\n        //if collateral isn't enabled as collateral by user, it cannot be liquidated\n        require(\n            vars.isCollateralEnabled,\n            Errors.COLLATERAL_CANNOT_BE_AUCTIONED_OR_LIQUIDATED\n        );\n        require(params.globalDebt != 0, Errors.GLOBAL_DEBT_IS_ZERO);\n    }\n\n    /**\n     * @notice Validates the health factor of a user.\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param userConfig The state of the user for the specific reserve\n     * @param user The user to validate health factor of\n     * @param reservesCount The number of available reserves\n     * @param oracle The price oracle\n     */\n    function validateHealthFactor(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        DataTypes.UserConfigurationMap memory userConfig,\n        address user,\n        uint256 reservesCount,\n        address oracle\n    ) internal view returns (uint256, bool) {\n        (\n            ,\n            ,\n            ,\n            ,\n            ,\n            ,\n            ,\n            uint256 healthFactor,\n            ,\n            bool hasZeroLtvCollateral\n        ) = GenericLogic.calculateUserAccountData(\n                reservesData,\n                reservesList,\n                DataTypes.CalculateUserAccountDataParams({\n                    userConfig: userConfig,\n                    reservesCount: reservesCount,\n                    user: user,\n                    oracle: oracle\n                })\n            );\n\n        require(\n            healthFactor >= HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\n            Errors.HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD\n        );\n\n        return (healthFactor, hasZeroLtvCollateral);\n    }\n\n    function validateStartAuction(\n        DataTypes.UserConfigurationMap storage userConfig,\n        DataTypes.ReserveData storage collateralReserve,\n        DataTypes.ValidateAuctionParams memory params\n    ) internal view {\n        ValidateAuctionLocalVars memory vars;\n\n        DataTypes.ReserveConfigurationMap\n            memory collateralConfiguration = collateralReserve.configuration;\n        (\n            vars.collateralReserveActive,\n            ,\n            ,\n            vars.collateralReservePaused,\n            vars.collateralReserveAssetType\n        ) = collateralConfiguration.getFlags();\n\n        require(\n            vars.collateralReserveAssetType == DataTypes.AssetType.ERC721,\n            Errors.INVALID_ASSET_TYPE\n        );\n\n        require(\n            IERC721(params.xTokenAddress).ownerOf(params.tokenId) ==\n                params.user,\n            Errors.NOT_THE_OWNER\n        );\n\n        require(vars.collateralReserveActive, Errors.RESERVE_INACTIVE);\n        require(!vars.collateralReservePaused, Errors.RESERVE_PAUSED);\n\n        require(\n            collateralReserve.auctionStrategyAddress != address(0),\n            Errors.AUCTION_NOT_ENABLED\n        );\n        require(\n            !IAuctionableERC721(params.xTokenAddress).isAuctioned(\n                params.tokenId\n            ),\n            Errors.AUCTION_ALREADY_STARTED\n        );\n\n        require(\n            params.erc721HealthFactor < HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\n            Errors.ERC721_HEALTH_FACTOR_NOT_BELOW_THRESHOLD\n        );\n\n        vars.isCollateralEnabled =\n            collateralConfiguration.getLiquidationThreshold() != 0 &&\n            userConfig.isUsingAsCollateral(collateralReserve.id) &&\n            ICollateralizableERC721(params.xTokenAddress).isUsedAsCollateral(\n                params.tokenId\n            );\n\n        //if collateral isn't enabled as collateral by user, it cannot be auctioned\n        require(\n            vars.isCollateralEnabled,\n            Errors.COLLATERAL_CANNOT_BE_AUCTIONED_OR_LIQUIDATED\n        );\n    }\n\n    function validateEndAuction(\n        DataTypes.ReserveData storage collateralReserve,\n        DataTypes.ValidateAuctionParams memory params\n    ) internal view {\n        ValidateAuctionLocalVars memory vars;\n\n        (\n            vars.collateralReserveActive,\n            ,\n            ,\n            vars.collateralReservePaused,\n            vars.collateralReserveAssetType\n        ) = collateralReserve.configuration.getFlags();\n\n        require(\n            vars.collateralReserveAssetType == DataTypes.AssetType.ERC721,\n            Errors.INVALID_ASSET_TYPE\n        );\n        require(\n            IERC721(params.xTokenAddress).ownerOf(params.tokenId) ==\n                params.user,\n            Errors.NOT_THE_OWNER\n        );\n        require(vars.collateralReserveActive, Errors.RESERVE_INACTIVE);\n        require(!vars.collateralReservePaused, Errors.RESERVE_PAUSED);\n        require(\n            IAuctionableERC721(params.xTokenAddress).isAuctioned(\n                params.tokenId\n            ),\n            Errors.AUCTION_NOT_STARTED\n        );\n\n        require(\n            params.erc721HealthFactor > params.auctionRecoveryHealthFactor,\n            Errors.ERC721_HEALTH_FACTOR_NOT_ABOVE_THRESHOLD\n        );\n    }\n\n    /**\n     * @notice Validates the health factor of a user and the ltv of the asset being withdrawn.\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param userConfig The state of the user for the specific reserve\n     * @param asset The asset for which the ltv will be validated\n     * @param from The user from which the xTokens are being transferred\n     * @param reservesCount The number of available reserves\n     * @param oracle The price oracle\n     */\n    function validateHFAndLtvERC20(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        DataTypes.UserConfigurationMap memory userConfig,\n        address asset,\n        address from,\n        uint256 reservesCount,\n        address oracle\n    ) internal view {\n        DataTypes.ReserveData storage reserve = reservesData[asset];\n\n        (, bool hasZeroLtvCollateral) = validateHealthFactor(\n            reservesData,\n            reservesList,\n            userConfig,\n            from,\n            reservesCount,\n            oracle\n        );\n\n        require(\n            !hasZeroLtvCollateral || reserve.configuration.getLtv() == 0,\n            Errors.LTV_VALIDATION_FAILED\n        );\n    }\n\n    /**\n     * @notice Validates the health factor of a user and the ltv of the erc721 asset being withdrawn.\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param userConfig The state of the user for the specific reserve\n     * @param asset The asset for which the ltv will be validated\n     * @param tokenIds The asset tokenIds for which the ltv will be validated\n     * @param from The user from which the xTokens are being transferred\n     * @param reservesCount The number of available reserves\n     * @param oracle The price oracle\n     */\n    function validateHFAndLtvERC721(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        DataTypes.UserConfigurationMap memory userConfig,\n        address asset,\n        uint256[] memory tokenIds,\n        address from,\n        uint256 reservesCount,\n        address oracle\n    ) internal view {\n        DataTypes.ReserveData storage reserve = reservesData[asset];\n\n        (, bool hasZeroLtvCollateral) = validateHealthFactor(\n            reservesData,\n            reservesList,\n            userConfig,\n            from,\n            reservesCount,\n            oracle\n        );\n\n        if (hasZeroLtvCollateral) {\n            INToken nToken = INToken(reserve.xTokenAddress);\n            if (nToken.getXTokenType() == XTokenType.NTokenUniswapV3) {\n                for (uint256 index = 0; index < tokenIds.length; index++) {\n                    (uint256 assetLTV, ) = GenericLogic.getLtvAndLTForUniswapV3(\n                        reservesData,\n                        asset,\n                        tokenIds[index],\n                        reserve.configuration.getLtv(),\n                        0\n                    );\n                    require(assetLTV == 0, Errors.LTV_VALIDATION_FAILED);\n                }\n            } else {\n                require(\n                    reserve.configuration.getLtv() == 0,\n                    Errors.LTV_VALIDATION_FAILED\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Validates a transfer action.\n     * @param reserve The reserve object\n     */\n    function validateTransferERC20(DataTypes.ReserveData storage reserve)\n        internal\n        view\n    {\n        require(!reserve.configurati"
    }
  ]
}