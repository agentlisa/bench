{
  "Title": "M-8: Oracle.sol: observe function has overflow risk and should cast to uint256 like Uniswap V3 does",
  "Content": "# Issue M-8: Oracle.sol: observe function has overflow risk and should cast to uint256 like Uniswap V3 does \n\nSource: https://github.com/sherlock-audit/2023-10-aloe-judging/issues/85 \n\n## Found by \nroguereddwarf\nThe `Oracle.observe` function basically uses the same math from the Uniswap V3 code to search for observations.  \n\nIn comparison to Uniswap V3, the `Oracle.observe` function takes a `seed` such that the runtime of the function can be decreased by calculating the `seed` off-chain to act as a hint for finding the observation.  \n\nIn the process of copying the Uniswap V3 code, a `uint256` cast has been forgotten which introduces a risk of intermediate overflow in the `Oracle.observe` function.  \n\nThereby the `secondsPerLiquidityCumulativeX128` return value can be wrong which can corrupt the implied volatility (ÌV) calculation.  \n\n## Vulnerability Detail\nLooking at the `Oracle.observe` function, the `secondsPerLiquidityCumulativeX128` return value is calculated as follows:\n\nhttps://github.com/aloelabs/aloe-ii/blob/c71e7b0cfdec830b1f054486dfe9d58ce407c7a4/core/src/libraries/Oracle.sol#L196\n```solidity\nliqCumL + uint160(((liqCumR - liqCumL) * delta) / denom)\n```\n\nThe calculation is done in an `unchecked` block. `liqCumR` and `liqCumL` have type `uint160`.  \n`delta` and `denom` have type `uint56`.  \n\nLet's compare this to the Uniswap V3 code.\n\nhttps://github.com/Uniswap/v3-core/blob/d8b1c635c275d2a9450bd6a78f3fa2484fef73eb/contracts/libraries/Oracle.sol#L279-L284\n```solidity\nbeforeOrAt.secondsPerLiquidityCumulativeX128 +\n    uint160(\n        (uint256(\n            atOrAfter.secondsPerLiquidityCumulativeX128 - beforeOrAt.secondsPerLiquidityCumulativeX128\n        ) * targetDelta) / observationTimeDelta\n    )\n```\n\nThe result of `atOrAfter.secondsPerLiquidityCumulativeX128 - beforeOrAt.secondsPerLiquidityCumulativeX128` is cast to `uint256`.  \n\nThat's because multiplying the result by `targetDelta` can overflow the `uint160` type.  \n\nThe maximum value of `uint160` is roughly `1.5e48`.  \n\n`delta` is simply the time difference between `timeL` and `target` in seconds.  \n\nThe `secondsPerLiquidityCumulative` values are accumulators that are calculated as follows:\nhttps://github.com/Uniswap/v3-core/blob/d8b1c635c275d2a9450bd6a78f3fa2484fef73eb/contracts/libraries/Oracle.sol#L41-L42\n```solidity\nsecondsPerLiquidityCumulativeX128: last.secondsPerLiquidityCumulativeX128 +\n    ((uint160(delta) << 128) / (liquidity > 0 ? liquidity : 1)),\n```\n\nIf `liquidity` is very low and the time difference between observations is very big (hours to days), this can lead to the intermediate overflow in the `Oracle` library, such that the `secondsPerLiquidityCumulative` is much smaller than it should be.  \n\nThe lowest value for the above division is `1`. In that case the accumulator grows by `2^128` (`~3.4e38`) every second.\n\nIf observations are apart 24 hours (`86400 seconds`), this can lead to an overflow:\nAssume for simplicity `target - timeL = timeR - timeL`\n```text\n(liqCumR - liqCumL) * delta = 3.4e38 * 86400 * 86400 > 1.5e48`\n```\n\n## Impact\nThe corrupted return value affects the [`Volatility` library](https://github.com/aloelabs/aloe-ii/blob/c71e7b0cfdec830b1f054486dfe9d58ce407c7a4/core/src/libraries/Volatility.sol#L121). Specifically, the IV calculation.    \n\nThis can lead to wrong IV updates and LTV ratios that do not reflect the true IV, making the application more prone to bad debt or reducing capital efficiency.  \n\n## Code Snippet\nhttps://github.com/aloelabs/aloe-ii/blob/c71e7b0cfdec830b1f054486dfe9d58ce407c7a4/core/src/libraries/Oracle.sol#L196\n\nhttps://github.com/Uniswap/v3-core/blob/d8b1c635c275d2a9450bd6a78f3fa2484fef73eb/contracts/libraries/Oracle.sol#L279-L284\n\n## Tool used\nManual Review\n\n## Recommendation\nPerform the same cast to `uint256` that Uniswap V3 performs:  \n```solidity\nliqCumL + uint160((uint256(liqCumR - liqCumL) * delta) / denom)\n```\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**tsvetanovv** commented:\n> I don't think this is problem because liqCumR and liqCumL are uint160 \n\n**MohammedRizwan** commented:\n>  valid\n\n\n\n**haydenshively**\n\nValid high, will fix\n\n**panprog**\n\nEscalate\n\nThis should be a valid medium, not high, because while the situation is possible, it can only happen when liquidity is extremely low (basically no liquidity). The example calculation assumes minimum liquidity value (0 or 1):\n```solidity\nsecondsPerLiquidityCumulativeX128: last.secondsPerLiquidityCumulativeX128 +\n    ((uint160(delta) << 128) / (liquidity > 0 ? liquidity : 1)),\n...\n(liqCumR - liqCumL) * delta = 3.4e38 * 86400 * 86400 ~= 2.5e48 > 1.5e48`\n```\n\nEven with such a low liquidity value the overflow happens just barely. Even a value of 2 for liquidity already won't overflow. If the pool has 0 liquidity (or 1, 2 or even 100 - even for token with 6 decimals that's basically empty pool) for over a day - nobody should/will really use it. Any semi-active pool which will actually be used will have much higher liquidity at all times.\n\nSo the issue describes a very edge case which most probably won't ever happen in real life.\n\nThe reporter probably also understands it and set his reported issue severity to medium, not high.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This should be a valid medium, not high, because while the situation is possible, it can only happen when liquidity is extremely low (basically no liquidity). The example calculation assumes minimum liquidity value (0 or 1):\n> ```solidity\n> secondsPerLiquidityCumulativeX128: last.secondsPerLiquidityCumulativeX128 +\n>     ((uint160(delta) << 128) / (liquidity > 0 ? liquidity : 1)),\n> ...\n> (liqCumR - liqCumL) * delta = 3.4e38 * 86400 * 86400 ~= 2.5e48 > 1.5e48`\n> ```\n> \n> Even with such a low liquidity value the overflow happens just barely. Even a value of 2 for liquidity already won't overflow. If the pool has 0 liquidity (or 1, 2 or even 100 - even for token with 6 decimals that's basically empty pool) for over a day - nobody should/will really use it. Any semi-active pool which will actually be used will have much higher liquidity at all times.\n> \n> So the issue describes a very edge case which most probably won't ever happen in real life.\n> \n> The reporter probably also understands it and set his reported issue severity to medium, not high.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**roguereddwarf**\n\n@panprog \n\nI agree with the escalation. I intentionally reported this as Medium due to the Low likelihood.\n\n**Trumpero**\n\nPlanning to accept escalation and downgrade this issue to medium because of the low likelihood.\n\n**Czar102**\n\nResult:\nMedium\nUnique\n\nAll parties agree on the above result.\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [panprog](https://github.com/sherlock-audit/2023-10-aloe-judging/issues/85/#issuecomment-1801857655): accepted\n\n**haydenshively**\n\nFixed in https://github.com/aloelabs/aloe-ii/pull/208\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/120",
  "Code": [
    {
      "filename": "core/src/libraries/Oracle.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\nimport {FixedPointMathLib as SoladyMath} from \"solady/utils/FixedPointMathLib.sol\";\nimport {IUniswapV3Pool} from \"v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\n\nimport {UNISWAP_AVG_WINDOW} from \"./constants/Constants.sol\";\nimport {Q16} from \"./constants/Q.sol\";\nimport {TickMath} from \"./TickMath.sol\";\n\n/// @title Oracle\n/// @notice Provides functions to integrate with V3 pool oracle\n/// @author Aloe Labs, Inc.\n/// @author Modified from [Uniswap](https://github.com/Uniswap/v3-periphery/blob/main/contracts/libraries/OracleLibrary.sol)\nlibrary Oracle {\n    struct PoolData {\n        // the current price (from pool.slot0())\n        uint160 sqrtPriceX96;\n        // the current tick (from pool.slot0())\n        int24 currentTick;\n        // the mean sqrt(price) over some period (OracleLibrary.consult() to get arithmeticMeanTick, then use TickMath)\n        uint160 sqrtMeanPriceX96;\n        // the mean liquidity over some period (OracleLibrary.consult())\n        uint160 secondsPerLiquidityX128;\n        // the number of seconds to look back when getting mean tick & mean liquidity\n        uint32 oracleLookback;\n        // the liquidity depth at currentTick (from pool.liquidity())\n        uint128 tickLiquidity;\n    }\n\n    /**\n     * @notice Calculates time-weighted means of tick and liquidity for a given Uniswap V3 pool\n     * @param pool Address of the pool that we want to observe\n     * @param seed The indices of `pool.observations` where we start our search for the 30-minute-old (lowest 16 bits)\n     * and 60-minute-old (next 16 bits) observations. Determine these off-chain to make this method more efficient\n     * than Uniswap's binary search. If any of the highest 8 bits are set, we fallback to onchain binary search.\n     * @return data An up-to-date `PoolData` struct containing all fields except `oracleLookback` and `tickLiquidity`\n     * @return metric If the price was manipulated at any point in the past `UNISWAP_AVG_WINDOW` seconds, then at\n     * some point in that period, this value will spike. It may still be high now, or (if the attacker is smart and\n     * well-financed) it may have returned to nominal.\n     */\n    function consult(IUniswapV3Pool pool, uint40 seed) internal view returns (PoolData memory data, uint56 metric) {\n        uint16 observationIndex;\n        uint16 observationCardinality;\n        (data.sqrtPriceX96, data.currentTick, observationIndex, observationCardinality, , , ) = pool.slot0();\n\n        unchecked {\n            int56[] memory tickCumulatives = new int56[](3);\n            uint160[] memory secondsPerLiquidityCumulativeX128s = new uint160[](3);\n\n            if ((seed >> 32) > 0) {\n                uint32[] memory secondsAgos = new uint32[](3);\n                secondsAgos[0] = UNISWAP_AVG_WINDOW * 2;\n                secondsAgos[1] = UNISWAP_AVG_WINDOW;\n                secondsAgos[2] = 0;\n                (tickCumulatives, secondsPerLiquidityCumulativeX128s) = pool.observe(secondsAgos);\n            } else {\n                (tickCumulatives[0], ) = observe(\n                    pool,\n                    uint32(block.timestamp - UNISWAP_AVG_WINDOW * 2),\n                    seed >> 16,\n                    data.currentTick,\n                    observationIndex,\n                    observationCardinality\n                );\n                (tickCumulatives[1], secondsPerLiquidityCumulativeX128s[1]) = observe(\n                    pool,\n                    uint32(block.timestamp - UNISWAP_AVG_WINDOW),\n                    seed % Q16,\n                    data.currentTick,\n                    observationIndex,\n                    observationCardinality\n                );\n                (tickCumulatives[2], secondsPerLiquidityCumulativeX128s[2]) = observe(\n                    pool,\n                    uint32(block.timestamp),\n                    observationIndex,\n                    data.currentTick,\n                    observationIndex,\n                    observationCardinality\n                );\n            }\n\n            data.secondsPerLiquidityX128 =\n                secondsPerLiquidityCumulativeX128s[2] -\n                secondsPerLiquidityCumulativeX128s[1];\n\n            // Compute arithmetic mean tick over `UNISWAP_AVG_WINDOW`, always rounding down to -inf\n            int256 delta = tickCumulatives[2] - tickCumulatives[1];\n            int256 meanTick0ToW = delta / int32(UNISWAP_AVG_WINDOW);\n            assembly (\"memory-safe\") {\n                // Equivalent: if (delta < 0 && (delta % UNISWAP_AVG_WINDOW != 0)) meanTick0ToW--;\n                meanTick0ToW := sub(meanTick0ToW, and(slt(delta, 0), iszero(iszero(smod(delta, UNISWAP_AVG_WINDOW)))))\n            }\n            data.sqrtMeanPriceX96 = TickMath.getSqrtRatioAtTick(int24(meanTick0ToW));\n\n            // Compute arithmetic mean tick over the interval [-2w, 0)\n            int256 meanTick0To2W = (tickCumulatives[2] - tickCumulatives[0]) / int32(UNISWAP_AVG_WINDOW * 2);\n            // Compute arithmetic mean tick over the interval [-2w, -w]\n            int256 meanTickWTo2W = (tickCumulatives[1] - tickCumulatives[0]) / int32(UNISWAP_AVG_WINDOW);\n            //                                         i                 i-2w                       i-w               i-2w\n            //        meanTick0To2W - meanTickWTo2W = (∑ tick_n * dt_n - ∑ tick_n * dt_n) / (2T) - (∑ tick_n * dt_n - ∑ tick_n * dt_n) / T\n            //                                         n=0               n=0                        n=0               n=0\n            //\n            //                                        i                   i-w\n            // 2T * (meanTick0To2W - meanTickWTo2W) = ∑ tick_n * dt_n  - 2∑ tick_n * dt_n\n            //                                        n=i-2w              n=i-2w\n            //\n            //                                        i                   i-w\n            //                                      = ∑ tick_n * dt_n  -  ∑ tick_n * dt_n\n            //                                        n=i-w               n=i-2w\n            //\n            // Thus far all values have been \"true\". We now assume that some manipulated value `manip_n` is added to each `tick_n`\n            //\n            //                                        i                               i-w\n            //                                      = ∑ (tick_n + manip_n) * dt_n  -  ∑ (tick_n + manip_n) * dt_n\n            //                                        n=i-w                           n=i-2w\n            //\n            //                                        i                   i-w                 i                    i-w\n            //                                      = ∑ tick_n * dt_n  -  ∑ tick_n * dt_n  +  ∑ manip_n * dt_n  -  ∑ manip_n * dt_n\n            //                                        n=i-w               n=i-2w              n=i-w                n=i-2w\n            //\n            //        meanTick0To2W - meanTickWTo2W = (meanTick0ToW_true - meanTickWTo2W_true) / 2  +  (sumManip0ToW - sumManipWTo2W) / (2T)\n            //\n            // For short time periods and reasonable market conditions, (meanTick0ToW_true - meanTickWTo2W_true) ≈ 0\n            //\n            //                                      ≈ (sumManip0ToW - sumManipWTo2W) / (2T)\n            //\n            // The TWAP we care about (see a few lines down) is measured over the interval [-w, 0). The result we've\n            // just derived contains `sumManip0ToW`, which is the sum of all manipulation in that same interval. As\n            // such, we use it as a metric for detecting manipulation. NOTE: If an attacker manipulates things to\n            // the same extent in the prior interval [-2w, -w), the metric will be 0. To guard against this, we must\n            // to watch the metric over the entire window. Even though it may be 0 *now*, it will have risen past a\n            // threshold at *some point* in the past `UNISWAP_AVG_WINDOW` seconds.\n            metric = uint56(SoladyMath.dist(meanTick0To2W, meanTickWTo2W));\n        }\n    }\n\n    /**\n     * @notice Searches for oracle observations nearest to the `target` time. If `target` lies between two existing\n     * observations, linearly interpolate between them. If `target` is newer than the most recent observation,\n     * we interpolate between the most recent one and a hypothetical one taken at the current block.\n     * @dev As long as `target <= block.timestamp`, return values should match what you'd get from Uniswap.\n     * @custom:example ```solidity\n     *   uint32[] memory secondsAgos = new uint32[](1);\n     *   secondsAgos[0] = block.timestamp - target;\n     *   (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) = pool.observe(\n     *     secondsAgos\n     *   );\n     * ```\n     * @param pool The Uniswap pool to examine\n     * @param target The timestamp of the desired observation\n     * @param seed The index of `pool.observations` where we start our search. Can be determined off-chain to make\n     * this method more efficient than Uniswap's binary search.\n     * @param tick The current tick (from `pool.slot0()`)\n     * @param observationIndex The current observation index (from `pool.slot0()`)\n     * @param observationCardinality The current observation cardinality (from `pool.slot0()`)\n     * @return The tick * time elapsed since `pool` was first initialized\n     * @return The time elapsed / max(1, liquidity) since `pool` was first initialized\n     */\n    function observe(\n        IUniswapV3Pool pool,\n        uint32 target,\n        uint256 seed,\n        int24 tick,\n        uint16 observationIndex,\n        uint16 observationCardinality\n    ) internal view returns (int56, uint160) {\n        unchecked {\n            seed %= observationCardinality;\n            (uint32 timeL, int56 tickCumL, uint160 liqCumL, ) = pool.observations(seed);\n\n            for (uint256 i = 0; i < observationCardinality; i++) {\n                if (timeL == target) {\n                    return (tickCumL, liqCumL);\n                }\n\n                if (timeL < target && seed == observationIndex) {\n                    uint56 delta = uint56(target - timeL);\n                    uint128 liquidity = pool.liquidity();\n                    return (\n                        tickCumL + tick * int56(delta),\n                        liqCumL + (uint160(delta) << 128) / (liquidity > 0 ? liquidity : 1)\n                    );\n                }\n\n                seed = (seed + 1) % observationCardinality;\n                (uint32 timeR, int56 tickCumR, uint160 liqCumR, ) = pool.observations(seed);\n\n                if (timeL < target && target < timeR) {\n                    uint56 delta = uint56(target - timeL);\n                    uint56 denom = uint56(timeR - timeL);\n                    // Uniswap divides before multiplying, so we do too\n                    return (\n                        tickCumL + ((tickCumR - tickCumL) / int56(denom)) * int56(delta),\n                        liqCumL + uint160(((liqCumR - liqCumL) * delta) / denom)\n                    );\n                }\n\n                (timeL, tickCumL, liqCumL) = (timeR, tickCumR, liqCumR);\n            }\n\n            revert(\"OLD\");\n        }\n    }\n\n    /**\n     * @notice Given a pool, returns the number of seconds ago of the oldest stored observation\n     * @param pool Address of Uniswap V3 pool that we want to observe\n     * @param observationIndex The observation index from pool.slot0()\n     * @param observationCardinality The observationCardinality from pool.slot0()\n     * @dev `(, , uint16 observationIndex, uint16 observationCardinality, , , ) = pool.slot0();`\n     * @return secondsAgo The number of seconds ago that the oldest observation was stored\n     */\n    function getMaxSecondsAgo(\n        IUniswapV3Pool pool,\n        uint16 observationIndex,\n        uint16 observationCardinality\n    ) internal view returns (uint32 secondsAgo) {\n        require(observationCardinality != 0, \"NI\");\n\n        unchecked {\n            (uint32 observationTimestamp, , , bool initialized) = pool.observations(\n                (observationIndex + 1) % observationCardinality\n            );\n\n            // The next index might not be initialized if the cardinality is in the process of increasing\n            // In this case the oldest observation is always in index 0\n            if (!initialized) {\n                (observationTimestamp, , , ) = pool.observations(0);\n            }\n\n            secondsAgo = uint32(block.timestamp) - observationTimestamp;\n        }\n    }\n}"
    },
    {
      "filename": "contracts/libraries/Oracle.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0 <0.8.0;\n\n/// @title Oracle\n/// @notice Provides price and liquidity data useful for a wide variety of system designs\n/// @dev Instances of stored oracle data, \"observations\", are collected in the oracle array\n/// Every pool is initialized with an oracle array length of 1. Anyone can pay the SSTOREs to increase the\n/// maximum length of the oracle array. New slots will be added when the array is fully populated.\n/// Observations are overwritten when the full length of the oracle array is populated.\n/// The most recent observation is available, independent of the length of the oracle array, by passing 0 to observe()\nlibrary Oracle {\n    struct Observation {\n        // the block timestamp of the observation\n        uint32 blockTimestamp;\n        // the tick accumulator, i.e. tick * time elapsed since the pool was first initialized\n        int56 tickCumulative;\n        // the seconds per liquidity, i.e. seconds elapsed / max(1, liquidity) since the pool was first initialized\n        uint160 secondsPerLiquidityCumulativeX128;\n        // whether or not the observation is initialized\n        bool initialized;\n    }\n\n    /// @notice Transforms a previous observation into a new observation, given the passage of time and the current tick and liquidity values\n    /// @dev blockTimestamp _must_ be chronologically equal to or greater than last.blockTimestamp, safe for 0 or 1 overflows\n    /// @param last The specified observation to be transformed\n    /// @param blockTimestamp The timestamp of the new observation\n    /// @param tick The active tick at the time of the new observation\n    /// @param liquidity The total in-range liquidity at the time of the new observation\n    /// @return Observation The newly populated observation\n    function transform(\n        Observation memory last,\n        uint32 blockTimestamp,\n        int24 tick,\n        uint128 liquidity\n    ) private pure returns (Observation memory) {\n        uint32 delta = blockTimestamp - last.blockTimestamp;\n        return\n            Observation({\n                blockTimestamp: blockTimestamp,\n                tickCumulative: last.tickCumulative + int56(tick) * delta,\n                secondsPerLiquidityCumulativeX128: last.secondsPerLiquidityCumulativeX128 +\n                    ((uint160(delta) << 128) / (liquidity > 0 ? liquidity : 1)),\n                initialized: true\n            });\n    }\n\n    /// @notice Initialize the oracle array by writing the first slot. Called once for the lifecycle of the observations array\n    /// @param self The stored oracle array\n    /// @param time The time of the oracle initialization, via block.timestamp truncated to uint32\n    /// @return cardinality The number of populated elements in the oracle array\n    /// @return cardinalityNext The new length of the oracle array, independent of population\n    function initialize(Observation[65535] storage self, uint32 time)\n        internal\n        returns (uint16 cardinality, uint16 cardinalityNext)\n    {\n        self[0] = Observation({\n            blockTimestamp: time,\n            tickCumulative: 0,\n            secondsPerLiquidityCumulativeX128: 0,\n            initialized: true\n        });\n        return (1, 1);\n    }\n\n    /// @notice Writes an oracle observation to the array\n    /// @dev Writable at most once per block. Index represents the most recently written element. cardinality and index must be tracked externally.\n    /// If the index is at the end of the allowable array length (according to cardinality), and the next cardinality\n    /// is greater than the current one, cardinality may be increased. This restriction is created to preserve ordering.\n    /// @param self The stored oracle array\n    /// @param index The index of the observation that was most recently written to the observations array\n    /// @param blockTimestamp The timestamp of the new observation\n    /// @param tick The active tick at the time of the new observation\n    /// @param liquidity The total in-range liquidity at the time of the new observation\n    /// @param cardinality The number of populated elements in the oracle array\n    /// @param cardinalityNext The new length of the oracle array, independent of population\n    /// @return indexUpdated The new index of the most recently written element in the oracle array\n    /// @return cardinalityUpdated The new cardinality of the oracle array\n    function write(\n        Observation[65535] storage self,\n        uint16 index,\n        uint32 blockTimestamp,\n        int24 tick,\n        uint128 liquidity,\n        uint16 cardinality,\n        uint16 cardinalityNext\n    ) internal returns (uint16 indexUpdated, uint16 cardinalityUpdated) {\n        Observation memory last = self[index];\n\n        // early return if we've already written an observation this block\n        if (last.blockTimestamp == blockTimestamp) return (index, cardinality);\n\n        // if the conditions are right, we can bump the cardinality\n        if (cardinalityNext > cardinality && index == (cardinality - 1)) {\n            cardinalityUpdated = cardinalityNext;\n        } else {\n            cardinalityUpdated = cardinality;\n        }\n\n        indexUpdated = (index + 1) % cardinalityUpdated;\n        self[indexUpdated] = transform(last, blockTimestamp, tick, liquidity);\n    }\n\n    /// @notice Prepares the oracle array to store up to `next` observations\n    /// @param self The stored oracle array\n    /// @param current The current next cardinality of the oracle array\n    /// @param next The proposed next cardinality which will be populated in the oracle array\n    /// @return next The next cardinality which will be populated in the oracle array\n    function grow(\n        Observation[65535] storage self,\n        uint16 current,\n        uint16 next\n    ) internal returns (uint16) {\n        require(current > 0, 'I');\n        // no-op if the passed next value isn't greater than the current next value\n        if (next <= current) return current;\n        // store in each slot to prevent fresh SSTOREs in swaps\n        // this data will not be used because the initialized boolean is still false\n        for (uint16 i = current; i < next; i++) self[i].blockTimestamp = 1;\n        return next;\n    }\n\n    /// @notice comparator for 32-bit timestamps\n    /// @dev safe for 0 or 1 overflows, a and b _must_ be chronologically before or equal to time\n    /// @param time A timestamp truncated to 32 bits\n    /// @param a A comparison timestamp from which to determine the relative position of `time`\n    /// @param b From which to determine the relative position of `time`\n    /// @return bool Whether `a` is chronologically <= `b`\n    function lte(\n        uint32 time,\n        uint32 a,\n        uint32 b\n    ) private pure returns (bool) {\n        // if there hasn't been overflow, no need to adjust\n        if (a <= time && b <= time) return a <= b;\n\n        uint256 aAdjusted = a > time ? a : a + 2**32;\n        uint256 bAdjusted = b > time ? b : b + 2**32;\n\n        return aAdjusted <= bAdjusted;\n    }\n\n    /// @notice Fetches the observations beforeOrAt and atOrAfter a target, i.e. where [beforeOrAt, atOrAfter] is satisfied.\n    /// The result may be the same observation, or adjacent observations.\n    /// @dev The answer must be contained in the array, used when the target is located within the stored observation\n    /// boundaries: older than the most recent observation and younger, or the same age as, the oldest observation\n    /// @param self The stored oracle array\n    /// @param time The current block.timestamp\n    /// @param target The timestamp at which the reserved observation should be for\n    /// @param index The index of the observation that was most recently written to the observations array\n    /// @param cardinality The number of populated elements in the oracle array\n    /// @return beforeOrAt The observation recorded before, or at, the target\n    /// @return atOrAfter The observation recorded at, or after, the target\n    function binarySearch(\n        Observation[65535] storage self,\n        uint32 time,\n        uint32 target,\n        uint16 index,\n        uint16 cardinality\n    ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {\n        uint256 l = (index + 1) % cardinality; // oldest observation\n        uint256 r = l + cardinality - 1; // newest observation\n        uint256 i;\n        while (true) {\n            i = (l + r) / 2;\n\n            beforeOrAt = self[i % cardinality];\n\n            // we've landed on an uninitialized tick, keep searching higher (more recently)\n            if (!beforeOrAt.initialized) {\n                l = i + 1;\n                continue;\n            }\n\n            atOrAfter = self[(i + 1) % cardinality];\n\n            bool targetAtOrAfter = lte(time, beforeOrAt.blockTimestamp, target);\n\n            // check if we've found the answer!\n            if (targetAtOrAfter && lte(time, target, atOrAfter.blockTimestamp)) break;\n\n            if (!targetAtOrAfter) r = i - 1;\n            else l = i + 1;\n        }\n    }\n\n    /// @notice Fetches the observations beforeOrAt and atOrAfter a given target, i.e. where [beforeOrAt, atOrAfter] is satisfied\n    /// @dev Assumes there is at least 1 initialized observation.\n    /// Used by observeSingle() to compute the counterfactual accumulator values as of a given block timestamp.\n    /// @param self The stored oracle array\n    /// @param time The current block.timestamp\n    /// @param target The timestamp at which the reserved observation should be for\n    /// @param tick The active tick at the time of the returned or simulated observation\n    /// @param index The index of the observation that was most recently written to the observations array\n    /// @param liquidity The total pool liquidity at the time of the call\n    /// @param cardinality The number of populated elements in the oracle array\n    /// @return beforeOrAt The observation which occurred at, or before, the given timestamp\n    /// @return atOrAfter The observation which occurred at, or after, the given timestamp\n    function getSurroundingObservations(\n        Observation[65535] storage self,\n        uint32 time,\n        uint32 target,\n        int24 tick,\n        uint16 index,\n        uint128 liquidity,\n        uint16 cardinality\n    ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {\n        // optimistically set before to the newest observation\n        beforeOrAt = self[index];\n\n        // if the target is chronologically at or after the newest observation, we can early return\n        if (lte(time, beforeOrAt.blockTimestamp, target)) {\n            if (beforeOrAt.blockTimestamp == target) {\n                // if newest observation equals target, we're in the same block, so we can ignore atOrAfter\n                return (beforeOrAt, atOrAfter);\n            } else {\n                // otherwise, we need to transform\n                return (beforeOrAt, transform(beforeOrAt, target, tick, liquidity));\n            }\n        }\n\n        // now, set before to the oldest observation\n        beforeOrAt = self[(index + 1) % cardinality];\n        if (!beforeOrAt.initialized) beforeOrAt = self[0];\n\n        // ensure that the target is chronologically at or after the oldest observation\n        require(lte(time, beforeOrAt.blockTimestamp, target), 'OLD');\n\n        // if we've reached this point, we have to binary search\n        return binarySearch(self, time, target, index, cardinality);\n    }\n\n    /// @dev Reverts if an observation at or before the desired observation timestamp does not exist.\n    /// 0 may be passed as `secondsAgo' to return the current cumulative values.\n    /// If called with a timestamp falling between two observations, returns the counterfactual accumulator values\n    /// at exactly the timestamp between the two observations.\n    /// @param self The stored oracle array\n    /// @param time The current block timestamp\n    /// @param secondsAgo The amount of time to look back, in seconds, at which point to return an observation\n    /// @param tick The current tick\n    /// @param index The index of the observation that was most recently written to the observations array\n    /// @param liquidity The current in-range pool liquidity\n    /// @param cardinality The number of populated elements in the oracle array\n    /// @return tickCumulative The tick * time elapsed since the pool was first initialized, as of `secondsAgo`\n    /// @return secondsPerLiquidityCumulativeX128 The time elapsed / max(1, liquidity) since the pool was first initialized, as of `secondsAgo`\n    function observeSingle(\n        Observation[65535] storage self,\n        uint32 time,\n        uint32 secondsAgo,\n        int24 tick,\n        uint16 index,\n        uint128 liquidity,\n        uint16 cardinality\n    ) internal view returns (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) {\n        if (secondsAgo == 0) {\n            Observation memory last = self[index];\n            if (last.blockTimestamp != time) last = transform(last, time, tick, liquidity);\n            return (last.tickCumulative, last.secondsPerLiquidityCumulativeX128);\n        }\n\n        uint32 target = time - secondsAgo;\n\n        (Observation memory beforeOrAt, Observation memory atOrAfter) =\n            getSurroundingObservations(self, time, target, tick, index, liquidity, cardinality);\n\n        if (target == beforeOrAt.blockTimestamp) {\n            // we're at the left boundary\n            return (beforeOrAt.tickCumulative, beforeOrAt.secondsPerLiquidityCumulativeX128);\n        } else if (target == atOrAfter.blockTimestamp) {\n            // we're at the right boundary\n            return (atOrAfter.tickCumulative, atOrAfter.secondsPerLiquidityCumulativeX128);\n        } else {\n            // we're in the middle\n            uint32 observationTimeDelta = atOrAfter.blockTimestamp - beforeOrAt.blockTimestamp;\n            uint32 targetDelta = target - beforeOrAt.blockTimestamp;\n            return (\n                beforeOrAt.tickCumulative +\n                    ((atOrAfter.tickCumulative - beforeOrAt.tickCumulative) / observationTimeDelta) *\n                    targetDelta,\n                beforeOrAt.secondsPerLiquidityCumulativeX128 +\n                    uint160(\n                        (uint256(\n                            atOrAfter.secondsPerLiquidityCumulativeX128 - beforeOrAt.secondsPerLiquidityCumulativeX128\n                        ) * targetDelta) / observationTimeDelta\n                    )\n            );\n        }\n    }\n\n    /// @notice Returns the accumulator values as of each time seconds ago from the given time in the array of `secondsAgos`\n    /// @dev Reverts if `secondsAgos` > oldest observation\n    /// @param self The stored oracle array\n    /// @param time The current block.timestamp\n    /// @param secondsAgos Each amount of time to look back, in seconds, at which point to return an observation\n    /// @param tick The current tick\n    /// @param index The index of the observation that was most recently written to the observations array\n    /// @param liquidity The current in-range pool liquidity\n    /// @param cardinality The number of populated elements in the oracle array\n    /// @return tickCumulatives The tick * time elapsed since the pool was first initialized, as of each `secondsAgo`\n    /// @return secondsPerLiquidityCumulativeX128s The cumulative seconds / max(1, liquidity) since the pool was first initialized, as of each `secondsAgo`\n    function observe(\n        Observation[65535] storage self,\n        uint32 time,\n        uint32[] memory secondsAgos,\n        int24 tick,\n        uint16 index,\n        uint128 liquidity,\n        uint16 cardinality\n    ) internal view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) {\n        require(cardinality > 0, 'I');\n\n        tickCumulatives = new int56[](secondsAgos.length);\n        secondsPerLiquidityCumulativeX128s = new uint160[](secondsAgos.length);\n        for (uint256 i = 0; i < secondsAgos.length; i++) {\n            (tickCumulatives[i], secondsPerLiquidityCumulativeX128s[i]) = observeSingle(\n                self,\n                time,\n                secondsAgos[i],\n                tick,\n                index,\n                liquidity,\n                cardinality\n            );\n        }\n    }\n}"
    },
    {
      "filename": "contracts/libraries/Oracle.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0 <0.8.0;\n\n/// @title Oracle\n/// @notice Provides price and liquidity data useful for a wide variety of system designs\n/// @dev Instances of stored oracle data, \"observations\", are collected in the oracle array\n/// Every pool is initialized with an oracle array length of 1. Anyone can pay the SSTOREs to increase the\n/// maximum length of the oracle array. New slots will be added when the array is fully populated.\n/// Observations are overwritten when the full length of the oracle array is populated.\n/// The most recent observation is available, independent of the length of the oracle array, by passing 0 to observe()\nlibrary Oracle {\n    struct Observation {\n        // the block timestamp of the observation\n        uint32 blockTimestamp;\n        // the tick accumulator, i.e. tick * time elapsed since the pool was first initialized\n        int56 tickCumulative;\n        // the seconds per liquidity, i.e. seconds elapsed / max(1, liquidity) since the pool was first initialized\n        uint160 secondsPerLiquidityCumulativeX128;\n        // whether or not the observation is initialized\n        bool initialized;\n    }\n\n    /// @notice Transforms a previous observation into a new observation, given the passage of time and the current tick and liquidity values\n    /// @dev blockTimestamp _must_ be chronologically equal to or greater than last.blockTimestamp, safe for 0 or 1 overflows\n    /// @param last The specified observation to be transformed\n    /// @param blockTimestamp The timestamp of the new observation\n    /// @param tick The active tick at the time of the new observation\n    /// @param liquidity The total in-range liquidity at the time of the new observation\n    /// @return Observation The newly populated observation\n    function transform(\n        Observation memory last,\n        uint32 blockTimestamp,\n        int24 tick,\n        uint128 liquidity\n    ) private pure returns (Observation memory) {\n        uint32 delta = blockTimestamp - last.blockTimestamp;\n        return\n            Observation({\n                blockTimestamp: blockTimestamp,\n                tickCumulative: last.tickCumulative + int56(tick) * delta,\n                secondsPerLiquidityCumulativeX128: last.secondsPerLiquidityCumulativeX128 +\n                    ((uint160(delta) << 128) / (liquidity > 0 ? liquidity : 1)),\n                initialized: true\n            });\n    }\n\n    /// @notice Initialize the oracle array by writing the first slot. Called once for the lifecycle of the observations array\n    /// @param self The stored oracle array\n    /// @param time The time of the oracle initialization, via block.timestamp truncated to uint32\n    /// @return cardinality The number of populated elements in the oracle array\n    /// @return cardinalityNext The new length of the oracle array, independent of population\n    function initialize(Observation[65535] storage self, uint32 time)\n        internal\n        returns (uint16 cardinality, uint16 cardinalityNext)\n    {\n        self[0] = Observation({\n            blockTimestamp: time,\n            tickCumulative: 0,\n            secondsPerLiquidityCumulativeX128: 0,\n            initialized: true\n        });\n        return (1, 1);\n    }\n\n    /// @notice Writes an oracle observation to the array\n    /// @dev Writable at most once per block. Index represents the most recently written element. cardinality and index must be tracked externally.\n    /// If the index is at the end of the allowable array length (according to cardinality), and the next cardinality\n    /// is greater than the current one, card"
    }
  ]
}