{
  "Title": "Incorrect Depth Calculation for Extension Nodes Allows Denial-of-Service",
  "Content": "The [`PatriciaMerkleTrieVerifier` library](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/libraries/verifier/PatriciaMerkleTrieVerifier.sol) is used by the `L2ScrollMessenger` contract to prove that the `L1ScrollMessenger` has [sent an L1 message](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/L2ScrollMessenger.sol#L120) or [executed an L2 message](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/L2ScrollMessenger.sol#L155). Further, this functionality enables the user to [retry an L1 sent message on L2](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/L2ScrollMessenger.sol#L228) in case of insufficient gas. Therefore, users can call the [RPC method `eth_getProof`](https://eips.ethereum.org/EIPS/eip-1186) on an Ethereum node and submit the obtained proof to the `L2ScrollMessenger` contract to replay their message if there was [at least one failed attempt to relay the message](https://github.com/scroll-tech/scroll/blob/2a745ad7a9a2d8570432003ed570eaed1544394a/contracts/src/L2/L2ScrollMessenger.sol#L242). Since the proof verification is based on the world state and account storage trie, the proof consists of an account and storage proof.\n\n\nDuring verification, the `PatriciaMerkleTrieVerifier` library walks down the inclusion proof to verify that [hashes match as expected](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/libraries/verifier/PatriciaMerkleTrieVerifier.sol#L378). However, when encountering an extension node in the account or storage proof, the library [incorrectly computes the depth](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/libraries/verifier/PatriciaMerkleTrieVerifier.sol#L394) by adding the length in bytes to the depth, instead of the number of nibbles (half-bytes), as well as not accounting for the [path length parity](https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/#specification).\n\n\nFor example, if the extension node `['13 f4 a7', next_hash]` was encountered, the 1 would indicate that it is an extension node with an odd path length. The correct path length to be added to the depth would be 5, but the library incorrectly adds 3 to the depth by getting the [length in bytes](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/libraries/verifier/PatriciaMerkleTrieVerifier.sol#L393). More concretely, due to an extension node in the account proof, it is impossible to prove that the storage slot `0` of address `0x0068cf6ef4fdf5a95d0e2546dab76f679969f3f5` contains the value 2 on the Ethereum mainnet.\n\n\nThis error leads to valid proofs not being accepted by the `PatriciaMerkleTrieVerifier` library. Since only the storage for the `L1ScrollMessenger` contract address [is checked](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/L2ScrollMessenger.sol#L141), a present extension node in the proof for this account would fail all verifications. An attacker can take advantage of this by brute-forcing an address on L1 via `CREATE2` that has a hash collision in the first nibbles with the [hash of the `L1ScrollMessenger` address](https://github.com/scroll-tech/scroll/blob/fb443822978768f7df278d9ee5fdf8a82c6c6707/contracts/src/libraries/verifier/PatriciaMerkleTrieVerifier.sol#L432). Hence, an extension node is forced to appear in the state trie, thereby preventing any message to be replayed on L2 - a denial-of-service attack - potentially locking users' funds until the contract is upgraded.\n\n\nConsider fixing the length calculation for extension nodes to accept valid proofs. It is advised to test the library and integration more thoroughly, for instance with a differential fuzzing approach and integration tests.\n\n\n***Update:** Resolved in [pull request #617](https://github.com/scroll-tech/scroll/pull/617) at commit [a8832bf](https://github.com/scroll-tech/scroll/pull/617/commits/a8832bfb68a1e2c4a6b1b5d881cac34cb398830d).*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/libraries/verifier/PatriciaMerkleTrieVerifier.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary PatriciaMerkleTrieVerifier {\n    /// @notice Internal function to validates a proof from eth_getProof.\n    /// @param account The address of the contract.\n    /// @param storageKey The storage slot to verify.\n    /// @param proof The rlp encoding result of eth_getProof.\n    /// @return stateRoot The computed state root. Must be checked by the caller.\n    /// @return storageValue The value of `storageKey`.\n    ///\n    /// @dev The code is based on\n    /// 1. https://eips.ethereum.org/EIPS/eip-1186\n    /// 2. https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/\n    /// 3. https://github.com/ethereum/go-ethereum/blob/master/trie/proof.go#L114\n    /// 4. https://github.com/privacy-scaling-explorations/zkevm-chain/blob/master/contracts/templates/PatriciaValidator.sol\n    ///\n    /// The encoding order of `proof` is\n    /// ```text\n    /// |        1 byte        |      ...      |        1 byte        |      ...      |\n    /// | account proof length | account proof | storage proof length | storage proof |\n    /// ```\n    function verifyPatriciaProof(\n        address account,\n        bytes32 storageKey,\n        bytes calldata proof\n    ) internal pure returns (bytes32 stateRoot, bytes32 storageValue) {\n        assembly {\n            // hashes 32 bytes of `v`\n            function keccak_32(v) -> r {\n                mstore(0x00, v)\n                r := keccak256(0x00, 0x20)\n            }\n            // hashes the last 20 bytes of `v`\n            function keccak_20(v) -> r {\n                mstore(0x00, v)\n                r := keccak256(0x0c, 0x14)\n            }\n            // reverts with error `msg`.\n            // make sure the length of error string <= 32\n            function revertWith(msg) {\n                // keccak(\"Error(string)\")\n                mstore(0x00, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n                mstore(0x04, 0x20) // str.offset\n                mstore(0x44, msg)\n                let msgLen\n                for {\n\n                } msg {\n\n                } {\n                    msg := shl(8, msg)\n                    msgLen := add(msgLen, 1)\n                }\n                mstore(0x24, msgLen) // str.length\n                revert(0x00, 0x64)\n            }\n            // reverts with `msg` when condition is not matched.\n            // make sure the length of error string <= 32\n            function require(cond, msg) {\n                if iszero(cond) {\n                    revertWith(msg)\n                }\n            }\n\n            // special function for decoding the storage value\n            // because of the prefix truncation if value > 31 bytes\n            // see `loadValue`\n            function decodeItem(word, len) -> ret {\n                // default\n                ret := word\n\n                // RLP single byte\n                if lt(word, 0x80) {\n                    leave\n                }\n\n                // truncated\n                if gt(len, 32) {\n                    leave\n                }\n\n                // value is >= 0x80 and <= 32 bytes.\n                // `len` should be at least 2 (prefix byte + value)\n                // otherwise the RLP is malformed.\n                let bits := mul(len, 8)\n                // sub 8 bits - the prefix\n                bits := sub(bits, 8)\n                let mask := shl(bits, 0xff)\n                // invert the mask\n                mask := not(mask)\n                // should hold the value - prefix byte\n                ret := and(ret, mask)\n            }\n\n            // returns the `len` of the whole RLP list at `ptr`\n            // and the offset for the first value inside the list.\n            function decodeListLength(ptr) -> len, startOffset {\n                let b0 := byte(0, calldataload(ptr))\n                // In most cases, it is a long list. So we reorder the branch to reduce branch prediction miss.\n\n                // 0xf8 - 0xff, long list, length > 55\n                if gt(b0, 0xf7) {\n                    // the RLP encoding consists of a single byte with value 0xf7\n                    // plus the length in bytes of the length of the payload in binary form,\n                    // followed by the length of the payload, followed by the concatenation\n                    // of the RLP encodings of the items.\n                    // the extended length is ignored\n                    let lengthBytes := sub(b0, 0xf7)\n                    if gt(lengthBytes, 32) {\n                        invalid()\n                    }\n\n                    // load the extended length\n                    startOffset := add(ptr, 1)\n                    let extendedLen := calldataload(startOffset)\n                    let bits := sub(256, mul(lengthBytes, 8))\n                    extendedLen := shr(bits, extendedLen)\n\n                    len := add(extendedLen, lengthBytes)\n                    len := add(len, 1)\n                    startOffset := add(startOffset, lengthBytes)\n                    leave\n                }\n                // 0xc0 - 0xf7, short list, length <= 55\n                if gt(b0, 0xbf) {\n                    // the RLP encoding consists of a single byte with value 0xc0\n                    // plus the length of the list followed by the concatenation of\n                    // the RLP encodings of the items.\n                    len := sub(b0, 0xbf)\n                    startOffset := add(ptr, 1)\n                    leave\n                }\n                revertWith(\"Not list\")\n            }\n\n            // returns the kind, calldata offset of the value and the length in bytes\n            // for the RLP encoded data item at `ptr`. used in `decodeFlat`\n            // kind = 0 means string/bytes, kind = 1 means list.\n            function decodeValue(ptr) -> kind, dataLen, valueOffset {\n                let b0 := byte(0, calldataload(ptr))\n\n                // 0x00 - 0x7f, single byte\n                if lt(b0, 0x80) {\n                    // for a single byte whose value is in the [0x00, 0x7f] range,\n                    // that byte is its own RLP encoding.\n                    dataLen := 1\n                    valueOffset := ptr\n                    leave\n                }\n\n                // 0x80 - 0xb7, short string/bytes, length <= 55\n                if lt(b0, 0xb8) {\n                    // the RLP encoding consists of a single byte with value 0x80\n                    // plus the length of the string followed by the string.\n                    dataLen := sub(b0, 0x80)\n                    valueOffset := add(ptr, 1)\n                    leave\n                }\n\n                // 0xb8 - 0xbf, long string/bytes, length > 55\n                if lt(b0, 0xc0) {\n                    // the RLP encoding consists of a single byte with value 0xb7\n                    // plus the length in bytes of the length of the string in binary form,\n                    // followed by the length of the string, followed by the string.\n                    let lengthBytes := sub(b0, 0xb7)\n                    if gt(lengthBytes, 4) {\n                        invalid()\n                    }\n\n                    // load the extended length\n                    valueOffset := add(ptr, 1)\n                    let extendedLen := calldataload(valueOffset)\n                    let bits := sub(256, mul(lengthBytes, 8))\n                    extendedLen := shr(bits, extendedLen)\n\n                    dataLen := extendedLen\n                    valueOffset := add(valueOffset, lengthBytes)\n                    leave\n                }\n\n                kind := 1\n                // 0xc0 - 0xf7, short list, length <= 55\n                if lt(b0, 0xf8) {\n                    // intentionally ignored\n                    // dataLen := sub(firstByte, 0xc0)\n                    valueOffset := add(ptr, 1)\n                    leave\n                }\n\n                // 0xf8 - 0xff, long list, length > 55\n                {\n                    // the extended length is ignored\n                    dataLen := sub(b0, 0xf7)\n                    valueOffset := add(ptr, 1)\n                    leave\n                }\n            }\n\n            // decodes all RLP encoded data and stores their DATA items\n            // [length - 128 bits | calldata offset - 128 bits] in a continous memory region.\n            // Expects that the RLP starts with a list that defines the length\n            // of the whole RLP region.\n            function decodeFlat(_ptr) -> ptr, memStart, nItems, hash {\n                ptr := _ptr\n\n                // load free memory ptr\n                // doesn't update the ptr and leaves the memory region dirty\n                memStart := mload(0x40)\n\n                let payloadLen, startOffset := decodeListLength(ptr)\n                // reuse memStart region and hash\n                calldatacopy(memStart, ptr, payloadLen)\n                hash := keccak256(memStart, payloadLen)\n\n                let memPtr := memStart\n                let ptrStop := add(ptr, payloadLen)\n                ptr := startOffset\n\n                // decode until the end of the list\n                for {\n\n                } lt(ptr, ptrStop) {\n\n                } {\n                    let kind, len, valuePtr := decodeValue(ptr)\n                    ptr := add(len, valuePtr)\n\n                    if iszero(kind) {\n                        // store the length of the data and the calldata offset\n                        // low -------> high\n                        // |     128 bits    |   128 bits   |\n                        // | calldata offset | value length |\n                        mstore(memPtr, or(shl(128, len), valuePtr))\n                        memPtr := add(memPtr, 0x20)\n                    }\n                }\n\n                if iszero(eq(ptr, ptrStop)) {\n                    invalid()\n                }\n\n                nItems := div(sub(memPtr, memStart), 32)\n            }\n\n            // prefix gets truncated to 256 bits\n            // `depth` is untrusted and can lead to bogus\n            // shifts/masks. In that case, the remaining verification\n            // steps must fail or lead to an invalid stateRoot hash\n            // if the proof data is 'spoofed but valid'\n            function derivePath(key, depth) -> path {\n                path := key\n\n                let bits := mul(depth, 4)\n                {\n                    let mask := not(0)\n                    mask := shr(bits, mask)\n                    path := and(path, mask)\n                }\n\n                // even prefix\n                let prefix := 0x20\n                if mod(depth, 2) {\n                    // odd\n                    prefix := 0x3\n                }\n\n                // the prefix may be shifted outside bounds\n                // this is intended, see `loadValue`\n                bits := sub(256, bits)\n                prefix := shl(bits, prefix)\n                path := or(prefix, path)\n            }\n\n            // loads and aligns a value from calldata\n            // given the `len|offset` stored at `memPtr`\n            function loadValue(memPtr, idx) -> value {\n                let tmp := mload(add(memPtr, mul(32, idx)))\n                // assuming 0xffffff is sufficient for storing calldata offset\n                let offset := and(tmp, 0xffffff)\n                let len := shr(128, tmp)\n\n                if gt(len, 31) {\n                    // special case - truncating the value is intended.\n                    // this matches the behavior in `derivePath` that truncates to 256 bits.\n                    offset := add(offset, sub(len, 32))\n                    value := calldataload(offset)\n                    leave\n                }\n\n                // everything else is\n                // < 32 bytes - align the value\n                let bits := mul(sub(32, len), 8)\n                value := calldataload(offset)\n                value := shr(bits, value)\n            }\n\n            // loads and aligns a value from calldata\n            // given the `len|offset` stored at `memPtr`\n            // Same as `loadValue` except it returns also the size\n            // of the value.\n            function loadValueLen(memPtr, idx) -> value, len {\n                let tmp := mload(add(memPtr, mul(32, idx)))\n                // assuming 0xffffff is sufficient for storing calldata offset\n                let offset := and(tmp, 0xffffff)\n                len := shr(128, tmp)\n\n                if gt(len, 31) {\n                    // special case - truncating the value is intended.\n                    // this matches the behavior in `derivePath` that truncates to 256 bits.\n                    offset := add(offset, sub(len, 32))\n                    value := calldataload(offset)\n                    leave\n                }\n\n                // everything else is\n                // < 32 bytes - align the value\n                let bits := mul(sub(32, len), 8)\n                value := calldataload(offset)\n                value := shr(bits, value)\n            }\n\n            function loadPair(memPtr, idx) -> offset, len {\n                let tmp := mload(add(memPtr, mul(32, idx)))\n                // assuming 0xffffff is sufficient for storing calldata offset\n                offset := and(tmp, 0xffffff)\n                len := shr(128, tmp)\n            }\n\n            // decodes RLP at `_ptr`.\n            // reverts if the number of DATA items doesn't match `nValues`.\n            // returns the RLP data items at pos `v0`, `v1`\n            // and the size of `v1out`\n            function hashCompareSelect(_ptr, nValues, v0, v1) -> ptr, hash, v0out, v1out, v1outlen {\n                ptr := _ptr\n\n                let memStart, nItems\n                ptr, memStart, nItems, hash := decodeFlat(ptr)\n\n                if iszero(eq(nItems, nValues)) {\n                    revertWith(\"Node items mismatch\")\n                }\n\n                v0out, v1outlen := loadValueLen(memStart, v0)\n                v1out, v1outlen := loadValueLen(memStart, v1)\n            }\n\n            // traverses the tree from the root to the node before the leaf.\n            // based on https://github.com/ethereum/go-ethereum/blob/master/trie/proof.go#L114\n            function walkTree(key, _ptr) -> ptr, rootHash, expectedHash, path {\n                ptr := _ptr\n\n                // the first byte is the number of nodes\n                let nodes := byte(0, calldataload(ptr))\n                ptr := add(ptr, 1)\n\n                // keeps track of ascend/descend - however you may look at a tree\n                let depth\n\n                // treat the leaf node with different logic\n                for {\n                    let i := 1\n                } lt(i, nodes) {\n                    i := add(i, 1)\n                } {\n                    let memStart, nItems, hash\n                    ptr, memStart, nItems, hash := decodeFlat(ptr)\n\n                    // first item is considered the root node.\n                    // Otherwise verifies that the hash of the current node\n                    // is the same as the previous choosen one.\n                    switch i\n                    case 1 {\n                        rootHash := hash\n                    }\n                    default {\n                        require(eq(hash, expectedHash), \"Hash mismatch\")\n                    }\n\n                    switch nItems\n                    case 2 {\n                        // extension node\n                        // load the second item.\n                        // this is the hash of the next node.\n                        let value, len := loadValueLen(memStart, 1)\n                        expectedHash := value\n\n                        // get the byte length of the first item\n                        // Note: the value itself is not validated\n                        // and it is instead assumed that any invalid\n                        // value is invalidated by comparing the root hash.\n                        let prefixLen := shr(128, mload(memStart))\n                        depth := add(depth, prefixLen)\n                    }\n                    case 17 {\n                        let bits := sub(252, mul(depth, 4))\n                        let nibble := and(shr(bits, key), 0xf)\n\n                        // load the value at pos `nibble`\n                        let value, len := loadValueLen(memStart, nibble)\n\n                        expectedHash := value\n                        depth := add(depth, 1)\n                    }\n                    default {\n                        // everything else is unexpected\n                        revertWith(\"Invalid node\")\n                    }\n                }\n\n                // lastly, derive the path of the choosen one (TM)\n                path := derivePath(key, depth)\n            }\n\n            // shared variable names\n            let storageHash\n            let encodedPath\n            let path\n            let hash\n            let vlen\n            // starting point\n            let ptr := proof.offset\n\n            {\n                // account proof\n                // Note: this doesn't work if there are no intermediate nodes before the leaf.\n                // This is not possible in practice because of the fact that there must be at least\n                // 2 accounts in the tree to make a transaction to a existing contract possible.\n                // Thus, 2 leaves.\n                let prevHash\n                let key := keccak_20(account)\n                // `stateRoot` is a return value and must be checked by the caller\n                ptr, stateRoot, prevHash, path := walkTree(key, ptr)\n\n                let memStart, nItems\n                ptr, memStart, nItems, hash := decodeFlat(ptr)\n\n                // the hash of the leaf must match the previous hash from the node\n                require(eq(hash, prevHash), \"Account leaf hash mismatch\")\n\n                // 2 items\n                // - encoded path\n                // - account leaf RLP (4 items)\n                require(eq(nItems, 2), \"Account leaf node mismatch\")\n\n                encodedPath := loadValue(memStart, 0)\n                // the calculated path must match the encoded path in the leaf\n                require(eq(path, encodedPath), \"Account encoded path mismatch\")\n\n                // Load the position, length of the second element (RLP encoded)\n                let leafPtr, leafLen := loadPair(memStart, 1)\n                leafPtr, memStart, nItems, hash := decodeFlat(leafPtr)\n\n                // the account leaf should contain 4 values,\n                // we want:\n                // - storageHash @ 2\n                require(eq(nItems, 4), \"Account leaf items mismatch\")\n                storageHash := loadValue(memStart, 2)\n            }\n\n            {\n                // storage proof\n                let rootHash\n                let key := keccak_32(storageKey)\n                ptr, rootHash, hash, path := walkTree(key, ptr)\n\n                // leaf should contain 2 values\n                // - encoded path @ 0\n                // - storageValue @ 1\n                ptr, hash, encodedPath, storageValue, vlen := hashCompareSelect(ptr, 2, 0, 1)\n                // the calculated path must match the encoded path in the leaf\n                require(eq(path, encodedPath), \"Storage encoded path mismatch\")\n\n                switch rootHash\n                case 0 {\n                    // in the case that the leaf is the only element, then\n                    // the hash of the leaf must match the value from the account leaf\n                    require(eq(hash, storageHash), \"Storage root mismatch\")\n                }\n                default {\n                    // otherwise the root hash of the storage tree\n                    // must match the value from the account leaf\n                    require(eq(rootHash, storageHash), \"Storage root mismatch\")\n                }\n\n                // storageValue is a return value\n                storageValue := decodeItem(storageValue, vlen)\n            }\n\n            // the one and only boundary check\n            // in case an attacker crafted a malicous payload\n            // and succeeds in the prior verification steps\n            // then this should catch any bogus accesses\n            if iszero(eq(ptr, add(proof.offset, proof.length))) {\n                revertWith(\"Proof length mismatch\")\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/src/libraries/verifier/PatriciaMerkleTrieVerifier.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary PatriciaMerkleTrieVerifier {\n    /// @notice Internal function to validates a proof from eth_getProof.\n    /// @param account The address of the contract.\n    /// @param storageKey The storage slot to verify.\n    /// @param proof The rlp encoding result of eth_getProof.\n    /// @return stateRoot The computed state root. Must be checked by the caller.\n    /// @return storageValue The value of `storageKey`.\n    ///\n    /// @dev The code is based on\n    /// 1. https://eips.ethereum.org/EIPS/eip-1186\n    /// 2. https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/\n    /// 3. https://github.com/ethereum/go-ethereum/blob/master/trie/proof.go#L114\n    /// 4. https://github.com/privacy-scaling-explorations/zkevm-chain/blob/master/contracts/templates/PatriciaValidator.sol\n    ///\n    /// The encoding order of `proof` is\n    /// ```text\n    /// |        1 byte        |      ...      |        1 byte        |      ...      |\n    /// | account proof length | account proof | storage proof length | storage proof |\n    /// ```\n    function verifyPatriciaProof(\n        address account,\n        bytes32 storageKey,\n        bytes calldata proof\n    ) internal pure returns (bytes32 stateRoot, bytes32 storageValue) {\n        assembly {\n            // hashes 32 bytes of `v`\n            function keccak_32(v) -> r {\n                mstore(0x00, v)\n                r := keccak256(0x00, 0x20)\n            }\n            // hashes the last 20 bytes of `v`\n            function keccak_20(v) -> r {\n                mstore(0x00, v)\n                r := keccak256(0x0c, 0x14)\n            }\n            // reverts with error `msg`.\n            // make sure the length of error string <= 32\n            function revertWith(msg) {\n                // keccak(\"Error(string)\")\n                mstore(0x00, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n                mstore(0x04, 0x20) // str.offset\n                mstore(0x44, msg)\n                let msgLen\n                for {\n\n                } msg {\n\n                } {\n                    msg := shl(8, msg)\n                    msgLen := add(msgLen, 1)\n                }\n                mstore(0x24, msgLen) // str.length\n                revert(0x00, 0x64)\n            }\n            // reverts with `msg` when condition is not matched.\n            // make sure the length of error string <= 32\n            function require(cond, msg) {\n                if iszero(cond) {\n                    revertWith(msg)\n                }\n            }\n\n            // special function for decoding the storage value\n            // because of the prefix truncation if value > 31 bytes\n            // see `loadValue`\n            function decodeItem(word, len) -> ret {\n                // default\n                ret := word\n\n                // RLP single byte\n                if lt(word, 0x80) {\n                    leave\n                }\n\n                // truncated\n                if gt(len, 32) {\n                    leave\n                }\n\n                // value is >= 0x80 and <= 32 bytes.\n                // `len` should be at least 2 (prefix byte + value)\n                // otherwise the RLP is malformed.\n                let bits := mul(len, 8)\n                // sub 8 bits - the prefix\n                bits := sub(bits, 8)\n                let mask := shl(bits, 0xff)\n                // invert the mask\n                mask := not(mask)\n                // should hold the value - prefix byte\n                ret := and(ret, mask)\n            }\n\n            // returns the `len` of the whole RLP list at `ptr`\n            // and the offset for the first value inside the list.\n            function decodeListLength(ptr) -> len, startOffset {\n                let b0 := byte(0, calldataload(ptr))\n                // In most cases, it is a long list. So we reorder the branch to reduce branch prediction miss.\n\n                // 0xf8 - 0xff, long list, length > 55\n                if gt(b0, 0xf7) {\n                    // the RLP encoding consists of a single byte with value 0xf7\n                    // plus the length in bytes of the length of the payload in binary form,\n                    // followed by the length of the payload, followed by the concatenation\n                    // of the RLP encodings of the items.\n                    // the extended length is ignored\n                    let lengthBytes := sub(b0, 0xf7)\n                    if gt(lengthBytes, 32) {\n                        invalid()\n                    }\n\n                    // load the extended length\n                    startOffset := add(ptr, 1)\n                    let extendedLen := calldataload(startOffset)\n                    let bits := sub(256, mul(lengthBytes, 8))\n                    extendedLen := shr(bits, extendedLen)\n\n                    len := add(extendedLen, lengthBytes)\n                    len := add(len, 1)\n                    startOffset := add(startOffset, lengthBytes)\n                    leave\n                }\n                // 0xc0 - 0xf7, short list, length <= 55\n                if gt(b0, 0xbf) {\n                    // the RLP encoding consists of a single byte with value 0xc0\n                    // plus the length of the list followed by the concatenation of\n                    // the RLP encodings of the items.\n                    len := sub(b0, 0xbf)\n                    startOffset := add(ptr, 1)\n                    leave\n                }\n                revertWith(\"Not list\")\n            }\n\n            // returns the kind, calldata offset of the value and the length in bytes\n            // for the RLP encoded data item at `ptr`. used in `decodeFlat`\n            // kind = 0 means string/bytes, kind = 1 means list.\n            function decodeValue(ptr) -> kind, dataLen, valueOffset {\n                let b0 := byte(0, calldataload(ptr))\n\n                // 0x00 - 0x7f, single byte\n                if lt(b0, 0x80) {\n                    // for a single byte whose value is in the [0x00, 0x7f] range,\n                    // that byte is its own RLP encoding.\n                    dataLen := 1\n                    valueOffset := ptr\n                    leave\n                }\n\n                // 0x80 - 0xb7, short string/bytes, length <= 55\n                if lt(b0, 0xb8) {\n                    // the RLP encoding consists of a single byte with value 0x80\n                    // plus the length of the string followed by the string.\n                    dataLen := sub(b0, 0x80)\n                    valueOffset := add(ptr, 1)\n                    leave\n                }\n\n                // 0xb8 - 0xbf, long string/bytes, length > 55\n                if lt(b0, 0xc0) {\n                    // the RLP encoding consists of a single byte with value 0xb7\n                    // plus the length in bytes of the length of the string in binary form,\n                    // followed by the length of the string, followed by the string.\n                    let lengthBytes := sub(b0, 0xb7)\n                    if gt(lengthBytes, 4) {\n                        invalid()\n                    }\n\n                    // load the extended length\n                    valueOffset := add(ptr, 1)\n                    let extendedLen := calldataload(valueOffset)\n                    let bits := sub(256, mul(lengthBytes, 8))\n                    extendedLen := shr(bits, extendedLen)\n\n                    dataLen := extendedLen\n                    valueOffset := add(valueOffset, lengthBytes)\n                    leave\n                }\n\n                kind := 1\n                // 0xc0 - 0xf7, short list, length <= 55\n                if lt(b0, 0xf8) {\n                    // intentionally ignored\n                    // dataLen := sub(firstByte, 0xc0)\n                    valueOffset := add(ptr, 1)\n                    leave\n                }\n\n                // 0xf8 - 0xff, long list, length > 55\n                {\n                    // the extended length is ignored\n                    dataLen := sub(b0, 0xf7)\n                    valueOffset := add(ptr, 1)\n                    leave\n                }\n            }\n\n            // decodes all RLP encoded data and stores their DATA items\n            // [length - 128 bits | calldata offset - 128 bits] in a continous memory region.\n            // Expects that the RLP starts with a list that defines the length\n            // of the whole RLP region.\n            function decodeFlat(_ptr) -> ptr, memStart, nItems, hash {\n                ptr := _ptr\n\n                // load free memory ptr\n                // doesn't update the ptr and leaves the memory region dirty\n                memStart := mload(0x40)\n\n                let payloadLen, startOffset := decodeListLength(ptr)\n                // reuse memStart region and hash\n                calldatacopy(memStart, ptr, payloadLen)\n                hash := keccak256(memStart, payloadLen)\n\n                let memPtr := memStart\n                let ptrStop := add(ptr, payloadLen)\n                ptr := startOffset\n\n                // decode until the end of the list\n                for {\n\n                } lt(ptr, ptrStop) {\n\n                } {\n                    let kind, len, valuePtr := decodeValue(ptr)\n                    ptr := add(len, valuePtr)\n\n                    if iszero(kind) {\n                        // store the length of the data and the calldata offset\n                        // low -------> high\n                        // |     128 bits    |   128 bits   |\n                        // | calldata offset | value length |\n                        mstore(memPtr, or(shl(128, len), valuePtr))\n                        memPtr := add(memPtr, 0x20)\n                    }\n                }\n\n                if iszero(eq(ptr, ptrStop)) {\n                    invalid()\n                }\n\n                nItems := div(sub(memPtr, memStart), 32)\n            }\n\n            // prefix gets truncated to 256 bits\n            // `depth` is untrusted and can lead to bogus\n            // shifts/masks. In that case, the remaining verification\n            // steps must fail or lead to an invalid stateRoot hash\n            // if the proof data is 'spoofed but valid'\n            function derivePath(key, depth) -> path {\n                path := key\n\n                let bits := mul(depth, 4)\n                {\n                    let mask := not(0)\n                    mask := shr(bits, mask)\n                    path := and(path, mask)\n                }\n\n                // even prefix\n                let prefix := 0x20\n                if mod(depth, 2) {\n                    // odd\n                    prefix := 0x3\n                }\n\n                // the prefix may be shifted outside bounds\n                // this is intended, see `loadValue`\n                bits := sub(256, bits)\n                prefix := shl(bits, prefix)\n                path := or(prefix, path)\n            }\n\n            // loads and aligns a value from calldata\n            // given the `len|offset` stored at `memPtr`\n            function loadValue(memPtr, idx) -> value {\n                let tmp := mload(add(memPtr, mul(32, idx)))\n                // assuming 0xffffff is sufficient for storing calldata offset\n                let offset := and(tmp, 0xffffff)\n                let len := shr(128, tmp)\n\n                if gt(len, 31) {\n                    // special case - truncating the value is intended.\n                    // this matches the behavior in `derivePath` that truncates to 256 bits.\n                    offset := add(offset, sub(len, 32))\n                    value := calldataload(offset)\n                    leave\n                }\n\n                // everything else is\n                // < 32 bytes - align the value\n                let bits := mul(sub(32, len), 8)\n                value := calldataload(offset)\n                value := shr(bits, value)\n            }\n\n            // loads and aligns a value from calldata\n            // given the `len|offset` stored at `memPtr`\n            // Same as `loadValue` except it returns also the size\n            // of the value.\n            function loadValueLen(memPtr, idx) -> value, len {"
    }
  ]
}