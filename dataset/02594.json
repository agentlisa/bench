{
  "Title": "Incorrect recalculation of shares during deposit",
  "Content": "When a user deposits to the `STETHVault`, the amount of shares they are expected to receive is recalculated [after stETH is transferred](https://github.com/pods-finance/yield-contracts/blob/c4b401ce674c24798de5f9d02c82e466ee0a2600/contracts/vaults/STETHVault.sol#L130-L131) from the depositor to the vault. Since the vault’s idle assets have not yet been updated, the transferred stETH is incorrectly included in the conversion [calculation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.7.3/contracts/token/ERC20/extensions/ERC4626.sol#L152). This may cause the `spentCap` to be incorrectly updated and the `Deposit` event to emit a smaller value of shares than what will actually be issued when the deposit is processed.\n\n\nConsider performing the `previewDeposit` and `_spendCap` calls after the `totalIdleAssets` have already been updated. This ensures any stETH that is transferred during the deposit will be correctly accounted for. Additionally, consider swapping the order of the [`totalIdleAssets` decrement and `_restoreCap` logic](https://github.com/pods-finance/yield-contracts/blob/c4b401ce674c24798de5f9d02c82e466ee0a2600/contracts/vaults/BaseVault.sol#L331-L332) in the [`refund`](https://github.com/pods-finance/yield-contracts/blob/c4b401ce674c24798de5f9d02c82e466ee0a2600/contracts/vaults/BaseVault.sol#L326) function in `BaseVault` to accommodate for the changes in `_deposit`.\n\n\n**Update:** *Resolved in [PR#118](https://github.com/pods-finance/yield-contracts/pull/118), with commit `db0c86daa2d52d1f92e59ae852cade40be351b82` being the last one added.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/vaults/STETHVault.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport { IERC4626 } from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport { ERC4626 } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { BaseVault } from \"./BaseVault.sol\";\nimport { IConfigurationManager } from \"../interfaces/IConfigurationManager.sol\";\n\n/**\n * @title STETHVault\n * @notice A Vault that use variable weekly yields to buy strangles\n * @author Pods Finance\n */\ncontract STETHVault is BaseVault {\n    using SafeERC20 for IERC20Metadata;\n    using Math for uint256;\n\n    /**\n     * @dev INVESTOR_RATIO is the proportion that the weekly yield will be split\n     * The precision of this number is set by the variable DENOMINATOR. 5000 is equivalent to 50%\n     */\n    uint256 public constant INVESTOR_RATIO = 5000;\n    address public immutable investor;\n    uint8 public immutable sharePriceDecimals;\n    uint256 public lastRoundAssets;\n    Fractional public lastSharePrice;\n\n    event StartRoundData(uint256 indexed roundId, uint256 lastRoundAssets, uint256 sharePrice);\n    event EndRoundData(\n        uint256 indexed roundId,\n        uint256 roundAccruedInterest,\n        uint256 investmentYield,\n        uint256 idleAssets\n    );\n    event SharePrice(uint256 indexed roundId, uint256 startSharePrice, uint256 endSharePrice);\n\n    constructor(\n        IConfigurationManager _configuration,\n        IERC20Metadata _asset,\n        address _investor\n    )\n        BaseVault(\n            _configuration,\n            _asset,\n            string(abi.encodePacked(_asset.symbol(), \" Volatility Vault\")),\n            string(abi.encodePacked(_asset.symbol(), \"vv\"))\n        )\n    {\n        investor = _investor;\n        sharePriceDecimals = _asset.decimals();\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function totalAssets() public view override(ERC4626, IERC4626) returns (uint256) {\n        return IERC20Metadata(asset()).balanceOf(address(this)) - totalIdleAssets();\n    }\n\n    /**\n     * @notice Return the stETH price per share\n     * @dev Each share is considered to be 10^(assets.decimals())\n     */\n    function sharePrice() external view returns (uint256) {\n        return totalAssets().mulDiv(10**sharePriceDecimals, totalSupply(), Math.Rounding.Down);\n    }\n\n    /**\n     * @inheritdoc BaseVault\n     */\n    function _afterRoundStart() internal override {\n        uint256 supply = totalSupply();\n\n        lastRoundAssets = totalAssets();\n        lastSharePrice = Fractional({ numerator: supply == 0 ? 0 : lastRoundAssets, denominator: supply });\n\n        uint256 currentSharePrice = lastSharePrice.denominator == 0\n            ? 0\n            : lastSharePrice.numerator.mulDiv(10**sharePriceDecimals, lastSharePrice.denominator, Math.Rounding.Down);\n        emit StartRoundData(vaultState.currentRoundId, lastRoundAssets, currentSharePrice);\n    }\n\n    /**\n     * @inheritdoc BaseVault\n     */\n    function _afterRoundEnd() internal override {\n        uint256 roundAccruedInterest = 0;\n        uint256 endSharePrice = 0;\n        uint256 investmentYield = IERC20Metadata(asset()).balanceOf(investor);\n        uint256 supply = totalSupply();\n\n        if (supply != 0) {\n            roundAccruedInterest = totalAssets() - lastRoundAssets;\n            uint256 investmentAmount = (roundAccruedInterest * INVESTOR_RATIO) / DENOMINATOR;\n\n            // Pulls the yields from investor\n            if (investmentYield > 0) {\n                IERC20Metadata(asset()).safeTransferFrom(investor, address(this), investmentYield);\n            }\n\n            if (investmentAmount > 0) {\n                IERC20Metadata(asset()).safeTransfer(investor, investmentAmount);\n            }\n\n            // End Share price needs to be calculated after the transfers between investor and vault\n            endSharePrice = (totalAssets()).mulDiv(10**sharePriceDecimals, supply, Math.Rounding.Down);\n        }\n\n        uint256 startSharePrice = lastSharePrice.denominator == 0\n            ? 0\n            : lastSharePrice.numerator.mulDiv(10**sharePriceDecimals, lastSharePrice.denominator, Math.Rounding.Down);\n\n        emit EndRoundData(vaultState.currentRoundId, roundAccruedInterest, investmentYield, totalIdleAssets());\n        emit SharePrice(vaultState.currentRoundId, startSharePrice, endSharePrice);\n    }\n\n    /**\n     * @inheritdoc BaseVault\n     */\n    function _deposit(\n        address caller,\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual override {\n        assets = _stETHTransferFrom(caller, address(this), assets);\n        shares = previewDeposit(assets);\n\n        _spendCap(shares);\n        _addToDepositQueue(receiver, assets);\n        emit Deposit(caller, receiver, assets, shares);\n    }\n\n    /**\n     * @inheritdoc BaseVault\n     */\n    function _withdrawWithFees(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual override returns (uint256 receiverAssets, uint256 receiverShares) {\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        _burn(owner, shares);\n        _restoreCap(shares);\n\n        lastRoundAssets -= shares.mulDiv(lastSharePrice.numerator, lastSharePrice.denominator, Math.Rounding.Down);\n\n        uint256 fee = _getFee(assets);\n        receiverAssets = assets - fee;\n        receiverShares = shares;\n\n        emit Withdraw(caller, receiver, owner, receiverAssets, shares);\n        receiverAssets = _stETHTransferFrom(address(this), receiver, receiverAssets);\n\n        if (fee > 0) {\n            emit FeeCollected(fee);\n            _stETHTransferFrom(address(this), controller(), fee);\n        }\n    }\n\n    /**\n     * @dev Moves `amount` of stETH from `from` to `to` using the\n     * allowance mechanism.\n     *\n     * Note that due to division rounding, not always is not possible to move\n     * the entire amount, hence transfer is attempted, returning the\n     * `effectiveAmount` transferred.\n     *\n     * For more information refer to: https://docs.lido.fi/guides/steth-integration-guide#1-wei-corner-case\n     */\n    function _stETHTransferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) internal returns (uint256) {\n        uint256 balanceBefore = IERC20Metadata(asset()).balanceOf(to);\n        if (from == address(this)) {\n            IERC20Metadata(asset()).safeTransfer(to, amount);\n        } else {\n            IERC20Metadata(asset()).safeTransferFrom(from, to, amount);\n        }\n        return IERC20Metadata(asset()).balanceOf(to) - balanceBefore;\n    }\n}"
    },
    {
      "filename": "contracts/vaults/BaseVault.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport { IERC4626 } from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { ERC20Permit } from \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport { IERC20Permit } from \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\nimport { ERC4626 } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { EnumerableMap } from \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\nimport { IConfigurationManager } from \"../interfaces/IConfigurationManager.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { CastUint } from \"../libs/CastUint.sol\";\nimport { Capped } from \"../mixins/Capped.sol\";\n\n/**\n * @title BaseVault\n * @notice A Vault that tokenize shares of strategy\n * @author Pods Finance\n */\nabstract contract BaseVault is IVault, ERC20Permit, ERC4626, Capped {\n    using SafeERC20 for IERC20Metadata;\n    using Math for uint256;\n    using CastUint for uint256;\n    using EnumerableMap for EnumerableMap.AddressToUintMap;\n\n    /**\n     * @dev DENOMINATOR represents the precision for the following system variables:\n     * - MAX_WITHDRAW_FEE\n     * - INVESTOR_RATIO\n     */\n    uint256 public constant DENOMINATOR = 10000;\n    /**\n     * @dev MAX_WITHDRAW_FEE is a safe check in case the ConfigurationManager sets\n     * a fee high enough that can be used as a way to drain funds.\n     * The precision of this number is set by constant DENOMINATOR.\n     */\n    uint256 public constant MAX_WITHDRAW_FEE = 1000;\n    /**\n     * @notice Minimum asset amount for the first deposit\n     * @dev This amount that prevents the first depositor to steal funds from subsequent depositors.\n     * See https://code4rena.com/reports/2022-01-sherlock/#h-01-first-user-can-steal-everyone-elses-tokens\n     */\n    uint256 public immutable MIN_INITIAL_ASSETS;\n\n    IConfigurationManager public immutable configuration;\n    VaultState internal vaultState;\n    EnumerableMap.AddressToUintMap internal depositQueue;\n\n    constructor(\n        IConfigurationManager configuration_,\n        IERC20Metadata asset_,\n        string memory name_,\n        string memory symbol_\n    ) ERC20(name_, symbol_) ERC20Permit(name_) ERC4626(asset_) Capped(configuration_) {\n        configuration = configuration_;\n\n        // Vault starts in `start` state\n        emit RoundStarted(vaultState.currentRoundId, 0);\n        vaultState.lastEndRoundTimestamp = uint32(block.timestamp);\n\n        MIN_INITIAL_ASSETS = 10**uint256(asset_.decimals());\n    }\n\n    modifier onlyController() {\n        if (msg.sender != controller()) revert IVault__CallerIsNotTheController();\n        _;\n    }\n\n    modifier onlyRoundStarter() {\n        bool lastRoundEndedAWeekAgo = block.timestamp >= vaultState.lastEndRoundTimestamp + 1 weeks;\n\n        if (!lastRoundEndedAWeekAgo && msg.sender != controller()) {\n            revert IVault__CallerIsNotTheController();\n        }\n        _;\n    }\n\n    modifier whenNotProcessingDeposits() {\n        if (vaultState.isProcessingDeposits) revert IVault__ForbiddenWhileProcessingDeposits();\n        _;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function currentRoundId() external view returns (uint32) {\n        return vaultState.currentRoundId;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function isProcessingDeposits() external view returns (bool) {\n        return vaultState.isProcessingDeposits;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function processedDeposits() external view returns (uint256) {\n        return vaultState.processedDeposits;\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function deposit(uint256 assets, address receiver)\n        public\n        virtual\n        override(ERC4626, IERC4626)\n        whenNotProcessingDeposits\n        returns (uint256)\n    {\n        return super.deposit(assets, receiver);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function depositWithPermit(\n        uint256 assets,\n        address receiver,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override whenNotProcessingDeposits returns (uint256) {\n        IERC20Permit(asset()).permit(msg.sender, address(this), assets, deadline, v, r, s);\n        return super.deposit(assets, receiver);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function mint(uint256 shares, address receiver)\n        public\n        virtual\n        override(ERC4626, IERC4626)\n        whenNotProcessingDeposits\n        returns (uint256)\n    {\n        return super.mint(shares, receiver);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function mintWithPermit(\n        uint256 shares,\n        address receiver,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override whenNotProcessingDeposits returns (uint256) {\n        uint256 assets = previewMint(shares);\n        IERC20Permit(asset()).permit(msg.sender, address(this), assets, deadline, v, r, s);\n        return super.mint(shares, receiver);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual override(ERC4626, IERC4626) whenNotProcessingDeposits returns (uint256 assets) {\n        assets = convertToAssets(shares);\n\n        if (assets == 0) revert IVault__ZeroAssets();\n        (assets, ) = _withdrawWithFees(msg.sender, receiver, owner, assets, shares);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual override(ERC4626, IERC4626) whenNotProcessingDeposits returns (uint256 shares) {\n        shares = _convertToShares(assets, Math.Rounding.Up);\n        (, shares) = _withdrawWithFees(msg.sender, receiver, owner, assets, shares);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function previewWithdraw(uint256 assets) public view override(ERC4626, IERC4626) returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Up);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function previewRedeem(uint256 shares) public view override(ERC4626, IERC4626) returns (uint256) {\n        uint256 assets = _convertToAssets(shares, Math.Rounding.Down);\n        return assets - _getFee(assets);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function maxDeposit(address) public view override(ERC4626, IERC4626) returns (uint256) {\n        uint256 _availableCap = availableCap();\n        if (_availableCap != type(uint256).max) {\n            return previewMint(_availableCap);\n        }\n        return _availableCap;\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function maxMint(address) public view override(ERC4626, IERC4626) returns (uint256) {\n        return availableCap();\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function maxWithdraw(address owner) public view override(ERC4626, IERC4626) returns (uint256) {\n        return previewRedeem(balanceOf(owner));\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function getWithdrawFeeRatio() public view override returns (uint256) {\n        uint256 _withdrawFeeRatio = configuration.getParameter(address(this), \"WITHDRAW_FEE_RATIO\");\n        // Fee is limited to MAX_WITHDRAW_FEE\n        return Math.min(_withdrawFeeRatio, MAX_WITHDRAW_FEE);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function idleAssetsOf(address owner) public view virtual returns (uint256) {\n        (, uint256 assets) = depositQueue.tryGet(owner);\n        return assets;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function assetsOf(address owner) external view virtual returns (uint256) {\n        uint256 supply = totalSupply();\n        uint256 shares = balanceOf(owner);\n        uint256 committedAssets = supply == 0\n            ? 0\n            : shares.mulDiv(IERC20Metadata(asset()).balanceOf(address(this)), supply, Math.Rounding.Down);\n        return convertToAssets(shares) + idleAssetsOf(owner) + committedAssets;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function totalIdleAssets() public view virtual returns (uint256) {\n        return vaultState.totalIdleAssets;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function depositQueueSize() public view returns (uint256) {\n        return depositQueue.length();\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function queuedDeposits() public view returns (address[] memory) {\n        address[] memory addresses = new address[](depositQueue.length());\n        for (uint256 i = 0; i < addresses.length; i++) {\n            (address owner, ) = depositQueue.at(i);\n            addresses[i] = owner;\n        }\n        return addresses;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function controller() public view returns (address) {\n        return configuration.getParameter(address(this), \"VAULT_CONTROLLER\").toAddress();\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function startRound() external virtual onlyRoundStarter returns (uint32) {\n        if (!vaultState.isProcessingDeposits) revert IVault__NotProcessingDeposits();\n\n        vaultState.isProcessingDeposits = false;\n\n        _afterRoundStart();\n        emit RoundStarted(vaultState.currentRoundId, vaultState.processedDeposits);\n        vaultState.processedDeposits = 0;\n\n        return vaultState.currentRoundId;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function endRound() external virtual onlyController {\n        if (vaultState.isProcessingDeposits) revert IVault__AlreadyProcessingDeposits();\n\n        vaultState.isProcessingDeposits = true;\n        _afterRoundEnd();\n        vaultState.lastEndRoundTimestamp = uint32(block.timestamp);\n\n        emit RoundEnded(vaultState.currentRoundId);\n\n        vaultState.currentRoundId += 1;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function refund() external returns (uint256 assets) {\n        (, assets) = depositQueue.tryGet(msg.sender);\n        if (assets == 0) revert IVault__ZeroAssets();\n\n        if (depositQueue.remove(msg.sender)) {\n            vaultState.totalIdleAssets -= assets;\n            _restoreCap(convertToShares(assets));\n        }\n\n        emit DepositRefunded(msg.sender, vaultState.currentRoundId, assets);\n        IERC20Metadata(asset()).safeTransfer(msg.sender, assets);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function migrate(IVault newVault) external override {\n        if (!configuration.isVaultMigrationAllowed(address(this), address(newVault))) {\n            revert IVault__MigrationNotAllowed();\n        }\n\n        // Redeem owner assets from this Vault\n        uint256 shares = balanceOf(msg.sender);\n        uint256 assets = redeem(shares, address(this), msg.sender);\n\n        // Deposit assets to `newVault`\n        IERC20Metadata(asset()).safeApprove(address(newVault), assets);\n        newVault.handleMigration(assets, msg.sender);\n\n        emit Migrated(msg.sender, address(this), address(newVault), assets, shares);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function handleMigration(uint256 assets, address receiver) external override returns (uint256) {\n        if (!configuration.isVaultMigrationAllowed(msg.sender, address(this))) {\n            revert IVault__MigrationNotAllowed();\n        }\n\n        return deposit(assets, receiver);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function processQueuedDeposits(address[] calldata depositors) external {\n        if (!vaultState.isProcessingDeposits) revert IVault__NotProcessingDeposits();\n\n        for (uint256 i = 0; i < depositors.length; i++) {\n            if (depositQueue.contains(depositors[i])) {\n                vaultState.processedDeposits += _processDeposit(depositors[i]);\n            }\n        }\n    }\n\n    /** Internals **/\n\n    /**\n     * @notice Mint new shares, effectively representing user participation in the Vault.\n     */\n    function _processDeposit(address depositor) internal virtual returns (uint256) {\n        uint256 currentAssets = totalAssets();\n        uint256 supply = totalSupply();\n        uint256 assets = depositQueue.get(depositor);\n        uint256 shares = currentAssets == 0 || supply == 0\n            ? assets\n            : assets.mulDiv(supply, currentAssets, Math.Rounding.Down);\n\n        if (supply == 0 && assets < MIN_INITIAL_ASSETS) {\n            revert IVault__AssetsUnderMinimumAmount(assets);\n        }\n\n        depositQueue.remove(depositor);\n        vaultState.totalIdleAssets -= assets;\n        _mint(depositor, shares);\n        emit DepositProcessed(depositor, vaultState.currentRoundId, assets, shares);\n\n        return assets;\n    }\n\n    /**\n     * @notice Add a new entry to the deposit to queue\n     */\n    function _addToDepositQueue(address receiver, uint256 assets) internal {\n        (, uint256 previous) = depositQueue.tryGet(receiver);\n        vaultState.totalIdleAssets += assets;\n        depositQueue.set(receiver, previous + assets);\n    }\n\n    /**\n     * @notice Calculate the fee amount on withdraw.\n     */\n    function _getFee(uint256 assets) internal view returns (uint256) {\n        return assets.mulDiv(getWithdrawFeeRatio(), DENOMINATOR, Math.Rounding.Down);\n    }\n\n    /**\n     * @dev Pull assets from the caller and add it to the deposit queue\n     */\n    function _deposit(\n        address caller,\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual override {\n        IERC20Metadata(asset()).safeTransferFrom(caller, address(this), assets);\n\n        _spendCap(shares);\n        _addToDepositQueue(receiver, assets);\n        emit Deposit(caller, receiver, assets, shares);\n    }\n\n    /**\n     * @dev Burn shares from the caller and release assets to the receiver\n     */\n    function _withdrawWithFees(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual returns (uint256 receiverAssets, uint256 receiverShares) {\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        _burn(owner, shares);\n        _restoreCap(shares);\n\n        // Apply custom withdraw logic\n        _beforeWithdraw(shares, assets);\n\n        uint256 fee = _getFee(assets);\n        receiverAssets = assets - fee;\n        receiverShares = shares;\n\n        emit Withdraw(caller, receiver, owner, receiverAssets, shares);\n        IERC20Metadata(asset()).safeTransfer(receiver, receiverAssets);\n\n        if (fee > 0) {\n            emit FeeCollected(fee);\n            IERC20Metadata(asset()).safeTransfer(controller(), fee);\n        }\n    }\n\n    /** Hooks **/\n\n    /* solhint-disable no-empty-blocks */\n\n    /**\n     * @dev This hook should be implemented in the contract implementation.\n     * It will trigger after the shares were burned\n     */\n    function _beforeWithdraw(uint256 shares, uint256 assets) internal virtual {}\n\n    /**\n     * @dev This hook should be implemented in the contract implementation.\n     * It will trigger after setting isProcessingDeposits to false\n     */\n    function _afterRoundStart() internal virtual {}\n\n    /**\n     * @dev This hook should be implemented in the contract implementation.\n     * It will trigger after setting isProcessingDeposits to true\n     */\n    function _afterRoundEnd() internal virtual {}\n\n    /* solhint-enable no-empty-blocks */\n}"
    }
  ]
}