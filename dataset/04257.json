{
  "Title": "[H01] Users can exercise small amounts without sending collateral",
  "Content": "When exercising option tokens, the [`_exercise` function](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L638) calls `_validateAndBurn` to validate that the exercising account is able to transfer in the required amount of the `exerciseAsset`. This is calculated by [`getExerciseData(tokenAmount)`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L744), which uses the amount of option token units transferred in as `tokenAmount`. In the case of a `CALL` option, [`getExerciseData` will call `_getTokenStrikePriceRelation`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L343-344). If `tokenAmount` is small enough, and `strikePrice` is smaller than `underlyingPrecision`, it is possible for `_getTokenStrikePriceRelation` to [return `0`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L760). This results in the `expectedAmount` (which the exerciser is [required to transfer in](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L746-750)) being `0` as well. So, the user can choose a `tokenAmount` which is nonzero, that allows them to transfer in no tokens to conduct an exercise.\n\n\nAfter `_validateAndBurn`, the [`_exerciseOwners` function](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L640) is called. Within this function, the [`_exerciseAccount`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L697) function calls [`getExerciseData`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L711) to determine the amount to be [transferred](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L717-21) to the accounts being exercised. In the case of a `CALL` option, it will again utilize [`_getTokenStrikePriceRelation(tokenAmount)`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L344), where `tokenAmount` is the amount of collateral tokens being exercised. This results in `_exerciseAccount` also [transferring](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L717-721) `0` units of the asset to the account being exercised. This should be the option minter’s reward for selling their collateral, but we see that the minter receives nothing and thus is effectively robbed.\n\n\nFinally, the `_exercise` function calls [`getCollateralOnExercise`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L654), which will simply return `tokenAmount` with a fee taken out for the `CALL` case. The following call to [`_transferCollateral`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L655) will then [transfer this amount back to `msg.sender`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L618-628).\n\n\nAs can be seen from the above situation, it is possible for a user to exercise another “for free”. In the case of a `CALL` option for `ETH/USDC`, with the strike price being `200 USDC`, any amount under `5e9` option token units will result in the exerciser having to pay nothing. This, notably, can be extended to users receiving more collateral than deserved by always exercising an amount of token units that is one less than a number evenly divisible by `5e9`. Thus, although redeeming `4.99...e9` tokens is disinentivized by gas costs, there is little disincentive to modify a larger token amount when exercising if the exercise was already planned anyway.\n\n\nHere we present two potential solutions. First, consider modifiying the `_getTokenStrikePriceRelation` function such that instead of rounding down by default, it rounds up upon any division which results in a fraction. However, this  \n\nmay cause problems when exercising multiple accounts, as each account’s received amount within `_exerciseAccount` is determined via a call to [`getExerciseData`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L711), which may also round. So, the amount transferred in by the user to exercise may be calculated as `x+1` units due to rounding, but when exercising `n` accounts, the total amount transferred to the accounts may be as high as `x+n` due to rounding on *each separate account’s transfer*. This means that the [transfers within `_exerciseAccount`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L717-721) may attempt to transfer more than the exercising account [originally paid within `_validateAndBurn`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L746-750). To solve this, the user could be required to transfer in the required amount of units plus `n_max`, where `n_max` is the highest possible number of accounts that could be exercised. Any extra funds can be returned to the user at the end of the [`_exercise` function](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L642). Alternatively, it can be left in the contract if it is deemed to not be worth as much as the potential gas savings from avoiding the transfer.\n\n\nThe second potential solution is to refactor all calculation functions to take the less precise asset of any asset pair, and determine option token amounts based on this. Then, the corresponding amount of the higher precision asset can be derived via multiplication. This way, fractional units will never occur, as all mathematical operations will be based on multiplication. However it may require more complex logic to handle different combinations of `CALL` vs. `PUT` and underlying assets having more decimals vs. less decimals than the stike assets.\n\n\nConsider implementing one of the described solutions. In general, any rounding errors should favor protocol solvency, followed by the users minting tokens, since they are taking a risk. If there is any loss of units of assets, it should be done in such a way that the protocol never has, and option minters never receive, less assets than expected. As always, when making large changes to the codebase, thorough passing test coverage should be achieved before moving to deployment.\n\n\n**Update:** *Fixed in [pull request #12](https://github.com/AuctusProject/aco/pull/12). They are implementing the first solution presented. We want to highlight the fact that the exercising account doesn’t receive back the amount of extra tokens left after the exercise. While this can be acceptable if the gas cost to send them back is higher than the value they represent, it can start to be a problem if a single token unit is highly valuable.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "smart-contracts/contracts/core/ACOToken.sol",
      "content": "pragma solidity ^0.6.6;\n\nimport \"./ERC20.sol\";\nimport \"../libs/Address.sol\";\nimport \"../libs/BokkyPooBahsDateTimeLibrary.sol\";\nimport \"../libs/Strings.sol\";\n\n/**\n * @title ACOToken\n * @dev The implementation of the ACO token.\n * The token is ERC20 compliance.\n */\ncontract ACOToken is ERC20 {\n    using Address for address;\n    \n    /**\n     * @dev Struct to store the accounts that generated tokens with a collateral deposit.\n     */\n    struct TokenCollateralized {\n        /**\n         * @dev Current amount of tokens.\n         */\n        uint256 amount;\n        \n        /**\n         * @dev Index on the collateral owners array.\n         */\n        uint256 index;\n    }\n    \n    /**\n     * @dev Emitted when collateral is deposited on the contract.\n     * @param account Address of the collateral owner.\n     * @param amount Amount of collateral deposited.\n     */\n    event CollateralDeposit(address indexed account, uint256 amount);\n    \n    /**\n     * @dev Emitted when collateral is withdrawn from the contract.\n     * @param account Address of the account.\n     * @param recipient Address of the collateral destination.\n     * @param amount Amount of collateral withdrawn.\n     * @param fee The fee amount charged on the withdrawal.\n     */\n    event CollateralWithdraw(address indexed account, address indexed recipient, uint256 amount, uint256 fee);\n    \n    /**\n     * @dev Emitted when the collateral is used on an assignment.\n     * @param from Address of the account of the collateral owner.\n     * @param to Address of the account that exercises tokens to get the collateral.\n     * @param paidAmount Amount paid to the collateral owner.\n     * @param tokenAmount Amount of tokens used to exercise.\n     */\n    event Assigned(address indexed from, address indexed to, uint256 paidAmount, uint256 tokenAmount);\n\n    /**\n     * @dev The ERC20 token address for the underlying asset (0x0 for Ethereum). \n     */\n    address public underlying;\n    \n    /**\n     * @dev The ERC20 token address for the strike asset (0x0 for Ethereum). \n     */\n    address public strikeAsset;\n    \n    /**\n     * @dev Address of the fee destination charged on the exercise.\n     */\n    address payable public feeDestination;\n    \n    /**\n     * @dev True if the type is CALL, false for PUT.\n     */\n    bool public isCall;\n    \n    /**\n     * @dev The strike price for the token with the strike asset precision.\n     */\n    uint256 public strikePrice;\n    \n    /**\n     * @dev The UNIX time for the token expiration.\n     */\n    uint256 public expiryTime;\n    \n    /**\n     * @dev The total amount of collateral on the contract.\n     */\n    uint256 public totalCollateral;\n    \n    /**\n     * @dev The fee value. It is a percentage value (100000 is 100%).\n     */\n    uint256 public acoFee;\n    \n    /**\n     * @dev Symbol of the underlying asset.\n     */\n    string public underlyingSymbol;\n    \n    /**\n     * @dev Symbol of the strike asset.\n     */\n    string public strikeAssetSymbol;\n    \n    /**\n     * @dev Decimals for the underlying asset.\n     */\n    uint8 public underlyingDecimals;\n    \n    /**\n     * @dev Decimals for the strike asset.\n     */\n    uint8 public strikeAssetDecimals;\n    \n    /**\n     * @dev Underlying precision. (10 ^ underlyingDecimals)\n     */\n    uint256 internal underlyingPrecision;\n    \n    /**\n     * @dev Accounts that generated tokens with a collateral deposit.\n     */\n    mapping(address => TokenCollateralized) internal tokenData;\n    \n    /**\n     * @dev Array with all accounts with collateral deposited.\n     */\n    address[] internal _collateralOwners;\n    \n    /**\n     * @dev Internal data to control the reentrancy.\n     */\n    bool internal _notEntered;\n    \n    /**\n     * @dev Selector for ERC20 transfer function.\n     */\n    bytes4 internal _transferSelector;\n    \n    /**\n     * @dev Selector for ERC20 transfer from function.\n     */\n    bytes4 internal _transferFromSelector;\n    \n    /**\n     * @dev Modifier to check if the token is not expired.\n     * It is executed only while the token is not expired.\n     */\n    modifier notExpired() {\n        require(_notExpired(), \"ACOToken::Expired\");\n        _;\n    }\n    \n    /**\n     * @dev Modifier to prevents a contract from calling itself during the function execution.\n     */\n    modifier nonReentrant() {\n        require(_notEntered, \"ACOToken::Reentry\");\n        _notEntered = false;\n        _;\n        _notEntered = true;\n    }\n    \n    /**\n     * @dev Function to initialize the contract.\n     * It should be called when creating the token.\n     * It must be called only once. The `assert` is to guarantee that behavior.\n     * @param _underlying Address of the underlying asset (0x0 for Ethereum).\n     * @param _strikeAsset Address of the strike asset (0x0 for Ethereum).\n     * @param _isCall True if the type is CALL, false for PUT.\n     * @param _strikePrice The strike price with the strike asset precision.\n     * @param _expiryTime The UNIX time for the token expiration.\n     * @param _acoFee Value of the ACO fee. It is a percentage value (100000 is 100%).\n     * @param _feeDestination Address of the fee destination charged on the exercise.\n     */\n    function init(\n        address _underlying,\n        address _strikeAsset,\n        bool _isCall,\n        uint256 _strikePrice,\n        uint256 _expiryTime,\n        uint256 _acoFee,\n        address payable _feeDestination\n    ) public {\n        require(underlying == address(0) && strikeAsset == address(0) && strikePrice == 0, \"ACOToken::init: Already initialized\");\n        \n        require(_expiryTime > now, \"ACOToken::init: Invalid expiry\");\n        require(_strikePrice > 0, \"ACOToken::init: Invalid strike price\");\n        require(_underlying != _strikeAsset, \"ACOToken::init: Same assets\");\n        require(_acoFee <= 500, \"ACOToken::init: Invalid ACO fee\"); // Maximum is 0.5%\n        require(_isEther(_underlying) || _underlying.isContract(), \"ACOToken::init: Invalid underlying\");\n        require(_isEther(_strikeAsset) || _strikeAsset.isContract(), \"ACOToken::init: Invalid strike asset\");\n        \n        underlying = _underlying;\n        strikeAsset = _strikeAsset;\n        isCall = _isCall;\n        strikePrice = _strikePrice;\n        expiryTime = _expiryTime;\n        acoFee = _acoFee;\n        feeDestination = _feeDestination;\n        underlyingDecimals = _getAssetDecimals(_underlying);\n        strikeAssetDecimals = _getAssetDecimals(_strikeAsset);\n        underlyingSymbol = _getAssetSymbol(_underlying);\n        strikeAssetSymbol = _getAssetSymbol(_strikeAsset);\n        underlyingPrecision = 10 ** uint256(underlyingDecimals);\n\n        _transferSelector = bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n        _transferFromSelector = bytes4(keccak256(bytes(\"transferFrom(address,address,uint256)\")));\n        _notEntered = true;\n    }\n    \n    /**\n     * @dev Function to guarantee that the contract will not receive ether directly.\n     */\n    receive() external payable {\n        revert();\n    }\n    \n    /**\n     * @dev Function to get the token name.\n     */\n    function name() public view override returns(string memory) {\n        return _name();\n    }\n    \n    /**\n     * @dev Function to get the token symbol, that it is equal to the name.\n     */\n    function symbol() public view override returns(string memory) {\n        return _name();\n    }\n    \n    /**\n     * @dev Function to get the token decimals, that it is equal to the underlying asset decimals.\n     */\n    function decimals() public view override returns(uint8) {\n        return underlyingDecimals;\n    }\n    \n    /**\n     * @dev Function to get the current amount of collateral for an account.\n     * @param account Address of the account.\n     * @return The current amount of collateral.\n     */\n    function currentCollateral(address account) public view returns(uint256) {\n        return getCollateralAmount(currentCollateralizedTokens(account));\n    }\n    \n    /**\n     * @dev Function to get the current amount of unassignable collateral for an account.\n     * NOTE: The function is valid when the token is NOT expired yet. \n     * After expiration, the unassignable collateral is equal to the account's collateral balance.\n     * @param account Address of the account.\n     * @return The respective amount of unassignable collateral.\n     */\n    function unassignableCollateral(address account) public view returns(uint256) {\n        return getCollateralAmount(unassignableTokens(account));\n    }\n    \n    /**\n     * @dev Function to get  the current amount of assignable collateral for an account.\n     * NOTE: The function is valid when the token is NOT expired yet. \n     * After expiration, the assignable collateral is zero.\n     * @param account Address of the account.\n     * @return The respective amount of assignable collateral.\n     */\n    function assignableCollateral(address account) public view returns(uint256) {\n        return getCollateralAmount(assignableTokens(account));\n    }\n    \n    /**\n     * @dev Function to get the current amount of collateralized tokens for an account.\n     * @param account Address of the account.\n     * @return The current amount of collateralized tokens.\n     */\n    function currentCollateralizedTokens(address account) public view returns(uint256) {\n        return tokenData[account].amount;\n    }\n    \n    /**\n     * @dev Function to get the current amount of unassignable tokens for an account.\n     * NOTE: The function is valid when the token is NOT expired yet. \n     * After expiration, the unassignable tokens is equal to the account's collateralized tokens.\n     * @param account Address of the account.\n     * @return The respective amount of unassignable tokens.\n     */\n    function unassignableTokens(address account) public view returns(uint256) {\n        if (balanceOf(account) > tokenData[account].amount) {\n            return tokenData[account].amount;\n        } else {\n            return balanceOf(account);\n        }\n    }\n    \n    /**\n     * @dev Function to get  the current amount of assignable tokens for an account.\n     * NOTE: The function is valid when the token is NOT expired yet. \n     * After expiration, the assignable tokens is zero.\n     * @param account Address of the account.\n     * @return The respective amount of assignable tokens.\n     */\n    function assignableTokens(address account) public view returns(uint256) {\n        return _getAssignableAmount(account);\n    }\n    \n    /**\n     * @dev Function to get the equivalent collateral amount for a token amount.\n     * @param tokenAmount Amount of tokens.\n     * @return The respective amount of collateral.\n     */\n    function getCollateralAmount(uint256 tokenAmount) public view returns(uint256) {\n        if (isCall) {\n            return tokenAmount;\n        } else if (tokenAmount > 0) {\n            return _getTokenStrikePriceRelation(tokenAmount);\n        } else {\n            return 0;\n        }\n    }\n    \n    /**\n     * @dev Function to get the equivalent token amount for a collateral amount.\n     * @param collateralAmount Amount of collateral.\n     * @return The respective amount of tokens.\n     */\n    function getTokenAmount(uint256 collateralAmount) public view returns(uint256) {\n        if (isCall) {\n            return collateralAmount;\n        } else if (collateralAmount > 0) {\n            return collateralAmount.mul(underlyingPrecision).div(strikePrice);\n        } else {\n            return 0;\n        }\n    }\n    \n    /**\n     * @dev Function to get the data for exercise of an amount of token.\n     * @param tokenAmount Amount of tokens.\n     * @return The asset and the respective amount that should be sent to get the collateral.\n     */\n    function getExerciseData(uint256 tokenAmount) public view returns(address, uint256) {\n        if (isCall) {\n            return (strikeAsset, _getTokenStrikePriceRelation(tokenAmount)); \n        } else {\n            return (underlying, tokenAmount);\n        }\n    }\n    \n    /**\n     * @dev Function to get the collateral to be received on an exercise and the respective fee.\n     * @param tokenAmount Amount of tokens.\n     * @return The collateral to be received and the respective fee.\n     */\n    function getCollateralOnExercise(uint256 tokenAmount) public view returns(uint256, uint256) {\n        uint256 collateralAmount = getCollateralAmount(tokenAmount);\n        uint256 fee = collateralAmount.mul(acoFee).div(100000);\n        collateralAmount = collateralAmount.sub(fee);\n        return (collateralAmount, fee);\n    }\n    \n    /**\n     * @dev Function to get the collateral asset.\n     * @return The address of the collateral asset.\n     */\n    function collateral() public view returns(address) {\n        if (isCall) {\n            return underlying;\n        } else {\n            return strikeAsset;\n        }\n    }\n    \n    /**\n     * @dev Function to mint tokens with Ether deposited as collateral.\n     * NOTE: The function only works when the token is NOT expired yet. \n     */\n    function mintPayable() external payable {\n        require(_isEther(collateral()), \"ACOToken::mintPayable: Invalid call\");\n       _mintToken(msg.sender, msg.value);\n    }\n    \n    /**\n     * @dev Function to mint tokens with Ether deposited as collateral to an informed account.\n     * However, the minted tokens are assigned to the transaction sender.\n     * NOTE: The function only works when the token is NOT expired yet. \n     * @param account Address of the account that will be the collateral owner.\n     */\n    function mintToPayable(address account) external payable {\n        require(_isEther(collateral()), \"ACOToken::mintToPayable: Invalid call\");\n       _mintToken(account, msg.value);\n    }\n    \n    /**\n     * @dev Function to mint tokens with ERC20 deposited as collateral.\n     * NOTE: The function only works when the token is NOT expired yet. \n     * @param collateralAmount Amount of collateral deposited.\n     */\n    function mint(uint256 collateralAmount) external {\n        address _collateral = collateral();\n        require(!_isEther(_collateral), \"ACOToken::mint: Invalid call\");\n        \n        _transferFromERC20(_collateral, msg.sender, address(this), collateralAmount);\n        _mintToken(msg.sender, collateralAmount);\n    }\n    \n    /**\n     * @dev Function to mint tokens with ERC20 deposited as collateral to an informed account.\n     * However, the minted tokens are assigned to the transaction sender.\n     * NOTE: The function only works when the token is NOT expired yet. \n     * @param account Address of the account that will be the collateral owner.\n     * @param collateralAmount Amount of collateral deposited.\n     */\n    function mintTo(address account, uint256 collateralAmount) external {\n        address _collateral = collateral();\n        require(!_isEther(_collateral), \"ACOToken::mintTo: Invalid call\");\n        \n        _transferFromERC20(_collateral, msg.sender, address(this), collateralAmount);\n        _mintToken(account, collateralAmount);\n    }\n    \n    /**\n     * @dev Function to burn tokens and get the collateral, not assigned, back.\n     * NOTE: The function only works when the token is NOT expired yet. \n     * @param tokenAmount Amount of tokens to be burned.\n     */\n    function burn(uint256 tokenAmount) external {\n        _burn(msg.sender, tokenAmount);\n    }\n    \n    /**\n     * @dev Function to burn tokens from a specific account and send the collateral to its address.\n     * The token allowance must be respected.\n     * The collateral is sent to the transaction sender.\n     * NOTE: The function only works when the token is NOT expired yet. \n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens to be burned.\n     */\n    function burnFrom(address account, uint256 tokenAmount) external {\n        _burn(account, tokenAmount);\n    }\n    \n    /**\n     * @dev Function to get the collateral, not assigned, back.\n     * NOTE: The function only works when the token IS expired. \n     */\n    function redeem() external {\n        _redeem(msg.sender);\n    }\n    \n    /**\n     * @dev Function to get the collateral from a specific account sent back to its address .\n     * The token allowance must be respected.\n     * The collateral is sent to the transaction sender.\n     * NOTE: The function only works when the token IS expired. \n     * @param account Address of the account.\n     */\n    function redeemFrom(address account) external {\n        require(tokenData[account].amount <= allowance(account, msg.sender), \"ACOToken::redeemFrom: No allowance\");\n        _redeem(account);\n    }\n    \n    /**\n     * @dev Function to exercise the tokens, paying to get the equivalent collateral.\n     * The paid amount is sent to the collateral owners that were assigned.\n     * NOTE: The function only works when the token is NOT expired. \n     * @param tokenAmount Amount of tokens.\n     */\n    function exercise(uint256 tokenAmount) external payable {\n        _exercise(msg.sender, tokenAmount);\n    }\n    \n    /**\n     * @dev Function to exercise the tokens from an account, paying to get the equivalent collateral.\n     * The token allowance must be respected.\n     * The paid amount is sent to the collateral owners that were assigned.\n     * The collateral is transferred to the transaction sender.\n     * NOTE: The function only works when the token is NOT expired. \n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens.\n     */\n    function exerciseFrom(address account, uint256 tokenAmount) external payable {\n        _exercise(account, tokenAmount);\n    }\n    \n    /**\n     * @dev Function to exercise the tokens, paying to get the equivalent collateral.\n     * The paid amount is sent to the collateral owners (on accounts list) that were assigned.\n     * NOTE: The function only works when the token is NOT expired. \n     * @param tokenAmount Amount of tokens.\n     * @param accounts The array of addresses to get collateral from.\n     */\n    function exerciseAccounts(uint256 tokenAmount, address[] calldata accounts) external payable {\n        _exerciseFromAccounts(msg.sender, tokenAmount, accounts);\n    }\n    \n    /**\n     * @dev Function to exercise the tokens from a specific account, paying to get the equivalent collateral sent to its address.\n     * The token allowance must be respected.\n     * The paid amount is sent to the collateral owners (on accounts list) that were assigned.\n     * The collateral is transferred to the transaction sender.\n     * NOTE: The function only works when the token is NOT expired. \n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens.\n     * @param accounts The array of addresses to get the deposited collateral.\n     */\n    function exerciseAccountsFrom(address account, uint256 tokenAmount, address[] calldata accounts) external payable {\n        _exerciseFromAccounts(account, tokenAmount, accounts);\n    }\n    \n    /**\n     * @dev Function to burn the tokens after expiration.\n     * It is an optional function to `clear` the account wallet from an expired and not functional token.\n     * NOTE: The function only works when the token IS expired. \n     */\n    function clear() external {\n        _clear(msg.sender);\n    }\n    \n    /**\n     * @dev Function to burn the tokens from an account after expiration.\n     * It is an optional function to `clear` the account wallet from an expired and not functional token.\n     * The token allowance must be respected.\n     * NOTE: The function only works when the token IS expired. \n     * @param account Address of the account.\n     */\n    function clearFrom(address account) external {\n        _clear(account);\n    }\n    \n    /**\n     * @dev Internal function to burn the tokens from an account after expiration.\n     * @param account Address of the account.\n     */\n    function _clear(address account) internal {\n        require(!_notExpired(), \"ACOToken::_clear: Token not expired yet\");\n        require(!_accountHasCollateral(account), \"ACOToken::_clear: Must call the redeem method\");\n        \n        _callBurn(account, balanceOf(account));\n    }\n    \n    /**\n     * @dev Internal function to redeem respective collateral from an account.\n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens.\n     */\n    function _redeemCollateral(address account, uint256 tokenAmount) internal {\n        require(_accountHasCollateral(account), \"ACOToken::_redeemCollateral: No collateral available\");\n        require(tokenAmount > 0, \"ACOToken::_redeemCollateral: Invalid token amount\");\n        \n        TokenCollateralized storage data = tokenData[account];\n        data.amount = data.amount.sub(tokenAmount);\n        \n        _removeCollateralDataIfNecessary(account);\n        \n        _transferCollateral(account, getCollateralAmount(tokenAmount), 0);\n    }\n    \n    /**\n     * @dev Internal function to mint tokens.\n     * The tokens are minted for the transaction sender.\n     * @param account Address of the account.\n     * @param collateralAmount Amount of collateral deposited.\n     */\n    function _mintToken(address account, uint256 collateralAmount) nonReentrant notExpired internal {\n        require(collateralAmount > 0, \"ACOToken::_mintToken: Invalid collateral amount\");\n        \n        if (!_accountHasCollateral(account)) {\n            tokenData[account].index = _collateralOwners.length;\n            _collateralOwners.push(account);\n        }\n        \n        uint256 tokenAmount = getTokenAmount(collateralAmount);\n        tokenData[account].amount = tokenData[account].amount.add(tokenAmount);\n        \n        totalCollateral = totalCollateral.add(collateralAmount);\n        \n        emit CollateralDeposit(account, collateralAmount);\n        \n        super._mintAction(msg.sender, tokenAmount);\n    }\n    \n    /**\n     * @dev Internal function to transfer tokens. \n     * The token transfer only works when the token is NOT expired. \n     * @param sender Source of the tokens.\n     * @param recipient Destination address for the tokens.\n     * @param amount Amount of tokens.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) notExpired internal override {\n        super._transferAction(sender, recipient, amount);\n    }\n    \n    /**\n     * @dev Internal function to set the token permission from an account to another address. \n     * The token approval only works when the token is NOT expired. \n     * @param owner Address of the token owner.\n     * @param spender Address of the spender authorized.\n     * @param amount Amount of tokens authorized.\n     */\n    function _approve(address owner, address spender, uint256 amount) notExpired internal override {\n        super._approveAction(owner, spender, amount);\n    }\n    \n    /**\n     * @dev Internal function to transfer collateral. \n     * When there is a fee, the calculated fee is also transferred to the destination fee address.\n     * The collateral destination is always the transaction sender address.\n     * @param account Address of the account.\n     * @param collateralAmount Amount of collateral to be redeemed.\n     * @param fee Amount of fee charged.\n     */\n    function _transferCollateral(address account, uint256 collateralAmount, uint256 fee) internal {\n        \n        totalCollateral = totalCollateral.sub(collateralAmount.add(fee));\n        \n        address _collateral = collateral();\n        if (_isEther(_collateral)) {\n            payable(msg.sender).transfer(collateralAmount);\n            if (fee > 0) {\n                feeDestination.transfer(fee);   \n            }\n        } else {\n            _transferERC20(_collateral, msg.sender, collateralAmount);\n            if (fee > 0) {\n                _transferERC20(_collateral, feeDestination, fee);\n            }\n        }\n        \n        emit CollateralWithdraw(account, msg.sender, collateralAmount, fee);\n    }\n    \n    /**\n     * @dev Internal function to exercise the tokens from an account. \n     * @param account Address of the account that is exercising.\n     * @param tokenAmount Amount of tokens.\n     */\n    function _exercise(address account, uint256 tokenAmount) nonReentrant internal {\n        _validateAndBurn(account, tokenAmount);\n        _exerciseOwners(account, tokenAmount);\n        (uint256 collateralAmount, uint256 fee) = getCollateralOnExercise(tokenAmount);\n        _transferCollateral(account, collateralAmount, fee);\n    }\n    \n    /**\n     * @dev Internal function to exercise the tokens from an account. \n     * @param account Address of the account that is exercising.\n     * @param tokenAmount Amount of tokens.\n     * @param accounts The array of addresses to get the collateral from.\n     */\n    function _exerciseFromAccounts(address account, uint256 tokenAmount, address[] memory accounts) nonReentrant internal {\n        _validateAndBurn(account, tokenAmount);\n        _exerciseAccounts(account, tokenAmount, accounts);\n        (uint256 collateralAmount, uint256 fee) = getCollateralOnExercise(tokenAmount);\n        _transferCollateral(account, collateralAmount, fee);\n    }\n    \n    /**\n     * @dev Internal function to exercise the assignable tokens from the stored list of collateral owners. \n     * @param exerciseAccount Address of the account that is exercising.\n     * @param tokenAmount Amount of tokens.\n     */\n    function _exerciseOwners(address exerciseAccount, uint256 tokenAmount) internal {\n        uint256 start = _collateralOwners.length - 1;\n        for (uint256 i = start; i >= 0; --i) {\n            if (tokenAmount == 0) {\n                break;\n            }\n            tokenAmount = _exerciseAccount(_collateralOwners[i], tokenAmount, exerciseAccount);\n        }\n        require(tokenAmount == 0, \"ACOToken::_exerciseOwners: Invalid remaining amount\");\n    }\n    \n    /**\n     * @dev Internal function to exercise the assignable tokens from an accounts list. \n     * @param exerciseAccount Address of the account that is exercising.\n     * @param tokenAmount Amount of tokens.\n     * @param accounts The array of addresses to get the collateral from.\n     */\n    function _exerciseAccounts(address exerciseAccount, uint256 tokenAmount, address[] memory accounts) internal {\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            if (tokenAmount == 0) {\n                break;\n            }\n            tokenAmount = _exerciseAccount(accounts[i], tokenAmount, exerciseAccount);\n        }\n        require(tokenAmount == 0, \"ACOToken::_exerciseAccounts: Invalid remaining amount\");\n    }\n    \n    /**\n     * @dev Internal function to exercise the assignable tokens from an account and transfer to its address the respective payment. \n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens.\n     * @param exerciseAccount Address of the account that is exercising.\n     * @return Remaining amount of tokens.\n     */\n    function _exerciseAccount(address account, uint256 tokenAmount, address exerciseAccount) internal returns(uint256) {\n        uint256 available = _getAssignableAmount(account);\n        if (available > 0) {\n            \n            TokenCollateralized storage data = tokenData[account];\n            uint256 valueToTransfer;\n            if (available < tokenAmount) {\n                valueToTransfer = available;\n                tokenAmount = tokenAmount.sub(available);\n            } else {\n                valueToTransfer = tokenAmount;\n                tokenAmount = 0;\n            }\n            \n            (address exerciseAsset, uint256 amount) = getExerciseData(valueToTransfer);\n\n            data.amount = data.amount.sub(valueToTransfer); \n            \n            _removeCollateralDataIfNecessary(account);\n            \n            if (_isEther(exerciseAsset)) {\n                payable(account).transfer(amount);\n            } else {\n                _transferERC20(exerciseAsset, account, amount);\n            }\n            emit Assigned(account, exerciseAccount, amount, valueToTransfer);\n        }\n        \n        return tokenAmount;\n    }\n    \n    /**\n     * @dev Internal function to validate the exercise operation and burn the respective tokens.\n     * @param account Address of the account that is exercising.\n     * @param tokenAmount Amount of tokens.\n     */\n    function _validateAndBurn(address account, uint256 tokenAmount) notExpired internal {\n        require(tokenAmount > 0, \"ACOToken::_validateAndBurn: Invalid token amount\");\n        \n        // Whether an account has deposited collateral it only can exercise the extra amount of unassignable tokens.\n        if (_accountHasCollateral(account)) {\n            require(balanceOf(account) > tokenData[account].amount, \"ACOToken::_validateAndBurn: Tokens compromised\");\n            require(tokenAmount <= balanceOf(account).sub(tokenData[account].amount), \"ACOToken::_validateAndBurn: Token amount not available\"); \n        }\n        \n        _callBurn(account, tokenAmount);\n        \n        (address exerciseAsset, uint256 expectedAmount) = getExerciseData(tokenAmount);\n\n        if (_isEther(exerciseAsset)) {\n            require(msg.value == expectedAmount, \"ACOToken::_validateAndBurn: Invalid ether amount\");\n        } else {\n            require(msg.value == 0, \"ACOToken::_validateAndBurn: No ether expected\");\n            _transferFromERC20(exerciseAsset, msg.sender, address(this), expectedAmount);\n        }\n    }\n    \n    /**\n     * @dev Internal function to calculate the token strike price relation.\n     * @param tokenAmount Amount of tokens.\n     * @return Calculated value with strike asset precision.\n     */\n    function _getTokenStrikePriceRelation(uint256 tokenAmount) internal view returns(uint256) {\n        return tokenAmount.mul(strikePrice).div(underlyingPrecision);\n    }\n    \n    /**\n     * @dev Internal function to get the collateral sent back from an account.\n     * Function to be called when the token IS expired.\n     * @param account Address of the account.\n     */\n    function _redeem(address account) nonReentrant internal {\n        require(!_notExpired(), \"ACOToken::_redeem: Token not expired yet\");\n        \n        _redeemCollateral(account, tokenData[account].amount);\n        super._burnAction(account, balanceOf(account));\n    }\n    \n    /**\n     * @dev Internal function to burn tokens from an account and get the collateral, not assigned, back.\n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens to be burned.\n     */\n    function _burn(address account, uint256 tokenAmount) nonReentrant notExpired internal {\n        _redeemCollateral(account, tokenAmount);\n        _callBurn(account, tokenAmount);\n    }\n    \n    /**\n     * @dev Internal function to burn tokens.\n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens to be burned.\n     */\n    function _callBurn(address account, uint256 tokenAmount) internal {\n        if (account == msg.sender) {\n            super._burnAction(account, tokenAmount);\n        } else {\n            super._burnFrom(account, tokenAmount);\n        }\n    }\n    \n    /**\n     * @dev Internal function to get the amount of assignable token from an account.\n     * @param account Address of the account.\n     * @return The assignable amount of tokens.\n     */\n    function _getAssignableAmount(address account) internal view returns(uint256) {\n        if (tokenData[account].amount > balanceOf(account)) {\n            return tokenData[account].amount.sub(balanceOf(account));\n        } else {\n            return 0;\n        }\n    }\n    \n    /**\n     * @dev Internal function to remove the token data with collateral if its total amount was assigned.\n     * @param account Address of account.\n     */\n    function _removeCollateralDataIfNecessary(address account) internal {\n        TokenCollateralized storage data = tokenData[account];\n        if (!_hasCollateral(data)) {\n            uint256 lastIndex = _collateralOwners.length - 1;\n            if (lastIndex != data.index) {\n                address last = _collateralOwners[lastIndex];\n                tokenData[last].index = data.index;\n                _collateralOwners[data.index] = last;\n            }\n            _collateralOwners.pop();\n            delete tokenData[account];\n        }\n    }\n    \n    /**\n     * @dev Internal function to get if the token is not expired.\n     * @return Whether the token is NOT expired.\n     */\n    function _notExpired() internal view returns(bool) {\n        return now <= expiryTime;\n    }\n    \n    /**\n     * @dev Internal function to get if an account has collateral deposited.\n     * @param account Address of the account.\n     * @return Whether the account has collateral deposited.\n     */"
    }
  ]
}