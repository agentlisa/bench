{
  "Title": "[L07] Not using SafeMath functions",
  "Content": "Although most of the codebase employs SafeMath methods where appropriate, there are still a few instances of regular Solidity arithmetic operators being used. *Some* examples are:\n\n\n* On [line 81 of `RiskFramework.sol`](https://github.com/notional-finance/contracts/blob/b6fc6be4622422d0e34c90e77f2ec9da18596b8c/contracts/utils/RiskFramework.sol#L81) `*` is used.\n* On [line 207 of `Escrow.sol`](https://github.com/notional-finance/contracts/blob/b6fc6be4622422d0e34c90e77f2ec9da18596b8c/contracts/Escrow.sol#L207) `++` is used.\n\n\nThese instances are not protected from potential overflows and may return unexpected values that could lead to data in `storage` being unintentionally overwritten. Consider always performing arithmetic operations with methods that protect the system from such possibilities, like the [math libraries of OpenZeppelin contracts](https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/math).\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/utils/RiskFramework.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../lib/SafeInt256.sol\";\nimport \"../lib/SafeMath.sol\";\n\nimport \"../utils/Governed.sol\";\nimport \"../utils/Common.sol\";\nimport \"../interface/IPortfoliosCallable.sol\";\nimport \"../storage/PortfoliosStorage.sol\";\n\nimport \"../CashMarket.sol\";\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\n\n/**\n * @title Risk Framework\n * @notice Calculates the currency requirements for a portfolio.\n */\nlibrary RiskFramework {\n    using SafeMath for uint256;\n    using SafeInt256 for int256;\n\n    /** The cash ladder for a single instrument or cash group */\n    struct CashLadder {\n        // The cash group id for this cash ladder\n        uint16 id;\n        // The currency group id for this cash ladder\n        uint16 currency;\n        // The cash ladder for the maturities of this cash group\n        int256[] cashLadder;\n    }\n\n    /**\n     * @notice Given a portfolio of assets, returns a set of requirements in every currency represented.\n     * @param portfolio a portfolio of assets\n     * @return a set of requirements in every cash group represented by the portfolio\n     */\n    function getRequirement(\n        Common.Asset[] memory portfolio,\n        address Portfolios\n    ) public view returns (Common.Requirement[] memory) {\n        Common._sortPortfolio(portfolio);\n\n        // Each position in this array will hold the value of the portfolio in each maturity.\n        (Common.CashGroup[] memory cashGroups, CashLadder[] memory ladders) = _fetchCashGroups(\n            portfolio,\n            IPortfoliosCallable(Portfolios)\n        );\n\n        uint128 fCashHaircut = PortfoliosStorageSlot._fCashHaircut();\n        uint128 fCashMaxHaircut = PortfoliosStorageSlot._fCashMaxHaircut();\n        uint32 blockTime = uint32(block.timestamp);\n\n        int256[] memory cashClaims = _getCashLadders(\n            portfolio,\n            cashGroups,\n            ladders,\n            PortfoliosStorageSlot._liquidityHaircut(),\n            blockTime\n        );\n\n        // We now take the per cash group cash ladder and summarize it into a single requirement. The future\n        // cash group requirements will be aggregated into a single currency requirement in the free collateral function\n        Common.Requirement[] memory requirements = new Common.Requirement[](ladders.length);\n\n        for (uint256 i; i < ladders.length; i++) {\n            requirements[i].currency = ladders[i].currency;\n            requirements[i].cashClaim = cashClaims[i];\n            uint32 initialMaturity;\n            if (blockTime % cashGroups[i].maturityLength == 0) {\n                // If this is true then blockTime = maturity at index 0 and we do not add an offset.\n                initialMaturity = blockTime;\n            } else {\n                initialMaturity = blockTime - (blockTime % cashGroups[i].maturityLength) + cashGroups[i].maturityLength;\n            }\n\n            for (uint256 j; j < ladders[i].cashLadder.length; j++) {\n                int256 netfCash = ladders[i].cashLadder[j];\n                if (netfCash > 0) {\n                    uint32 maturity = initialMaturity + cashGroups[i].maturityLength * uint32(j);\n                    // If netfCash value is positive here then we have to haircut it.\n                    netfCash = _calculateReceiverValue(netfCash, maturity, blockTime, fCashHaircut, fCashMaxHaircut);\n                }\n\n                requirements[i].netfCashValue = requirements[i].netfCashValue.add(netfCash);\n            }\n        }\n\n        return requirements;\n    }\n\n    /**\n     * @notice Calculates the cash ladders for every cash group in a portfolio.\n     *\n     * @param portfolio a portfolio of assets\n     * @return an array of cash ladders and an npv figure for every cash group\n     */\n    function _getCashLadders(\n        Common.Asset[] memory portfolio,\n        Common.CashGroup[] memory cashGroups,\n        CashLadder[] memory ladders,\n        uint128 liquidityHaircut,\n        uint32 blockTime\n    ) internal view returns (int256[] memory) {\n\n        // This will hold the current cash claims balance\n        int256[] memory cashClaims = new int256[](ladders.length);\n\n        // Set up the first group's cash ladder before we iterate\n        uint256 groupIndex;\n        // In this loop we know that the assets are sorted and none of them have matured. We always call\n        // settleMaturedAssets before we enter the risk framework.\n        for (uint256 i; i < portfolio.length; i++) {\n            if (portfolio[i].cashGroupId != ladders[groupIndex].id) {\n                // This is the start of a new group\n                groupIndex++;\n            }\n\n            (int256 fCashAmount, int256 cashClaimAmount) = _calculateAssetValue(\n                portfolio[i],\n                cashGroups[groupIndex],\n                blockTime,\n                liquidityHaircut\n            );\n\n            cashClaims[groupIndex] = cashClaims[groupIndex].add(cashClaimAmount);\n            if (portfolio[i].maturity <= blockTime) {\n                // If asset has matured then all the fCash is considered a current cash claim. This branch will only be\n                // reached when calling this function as a view. During liquidation and settlement calls we ensure that\n                // all matured assets have been settled to cash first.\n                cashClaims[groupIndex] = cashClaims[groupIndex].add(fCashAmount);\n            } else {\n                uint256 offset = (portfolio[i].maturity - blockTime) / cashGroups[groupIndex].maturityLength;\n\n                if (cashGroups[groupIndex].cashMarket == address(0)) {\n                    // We do not allow positive fCash to net out negative fCash for idiosyncratic trades\n                    // so we zero out positive cash at this point.\n                    fCashAmount = fCashAmount > 0 ? 0 : fCashAmount;\n                }\n\n                ladders[groupIndex].cashLadder[offset] = ladders[groupIndex].cashLadder[offset].add(fCashAmount);\n            }\n        }\n\n        return cashClaims;\n    }\n\n    function _calculateAssetValue(\n        Common.Asset memory asset,\n        Common.CashGroup memory cg,\n        uint32 blockTime,\n        uint128 liquidityHaircut\n    ) internal view returns (int256, int256) {\n        int256 cashClaim;\n        int256 fCash;\n\n        if (Common.isLiquidityToken(asset.assetType)) {\n            (cashClaim, fCash) = _calculateLiquidityTokenClaims(asset, cg.cashMarket, blockTime, liquidityHaircut);\n        } else if (Common.isCashPayer(asset.assetType)) {\n            fCash = int256(asset.notional).neg();\n        } else if (Common.isCashReceiver(asset.assetType)) {\n            fCash = int256(asset.notional);\n        }\n\n        return (fCash, cashClaim);\n    }\n\n    function _calculateReceiverValue(\n        int256 fCash,\n        uint32 maturity,\n        uint32 blockTime,\n        uint128 fCashHaircut,\n        uint128 fCashMaxHaircut\n    ) internal pure returns (int256) {\n        require(maturity > blockTime);\n\n        // As we roll down to maturity the haircut value will decrease until\n        // we hit the maxPostHaircutValue where we cap this.\n        // fCash - fCash * haircut * timeToMaturity / secondsInYear\n        int256 postHaircutValue = fCash.sub(\n            fCash\n                .mul(fCashHaircut)\n                .mul(maturity - blockTime)\n                .div(Common.SECONDS_IN_YEAR)\n                // fCashHaircut is in 1e18\n                .div(Common.DECIMALS)\n        );\n\n        int256 maxPostHaircutValue = fCash\n            // This will be set to something like 0.95e18\n            .mul(fCashMaxHaircut)\n            .div(Common.DECIMALS);\n\n        if (postHaircutValue < maxPostHaircutValue) {\n            return postHaircutValue;\n        } else {\n            return maxPostHaircutValue;\n        }\n    }\n\n    function _calculateLiquidityTokenClaims(\n        Common.Asset memory asset,\n        address cashMarket,\n        uint32 blockTime,\n        uint128 liquidityHaircut\n    ) internal view returns (uint128, uint128) {\n        CashMarket.Market memory market = CashMarket(cashMarket).getMarket(asset.maturity);\n\n        uint256 cashClaim;\n        uint256 fCashClaim;\n\n        if (blockTime < asset.maturity) {\n            // We haircut these amounts because it is uncertain how much claim either of these will actually have\n            // when it comes to reclaim the liquidity token. For example, there may be less collateral in the pool\n            // relative to fCash due to trades that have happened between the initial free collateral check\n            // and the liquidation.\n            cashClaim = uint256(market.totalCurrentCash)\n                .mul(asset.notional)\n                .mul(liquidityHaircut)\n                .div(Common.DECIMALS)\n                .div(market.totalLiquidity);\n\n            fCashClaim = uint256(market.totalfCash)\n                .mul(asset.notional)\n                .mul(liquidityHaircut)\n                .div(Common.DECIMALS)\n                .div(market.totalLiquidity);\n        } else {\n            cashClaim = uint256(market.totalCurrentCash)\n                .mul(asset.notional)\n                .div(market.totalLiquidity);\n\n            fCashClaim = uint256(market.totalfCash)\n                .mul(asset.notional)\n                .div(market.totalLiquidity);\n        }\n\n        return (SafeCast.toUint128(cashClaim), SafeCast.toUint128(fCashClaim));\n    }\n\n    function _fetchCashGroups(\n        Common.Asset[] memory portfolio,\n        IPortfoliosCallable Portfolios\n    ) internal view returns (Common.CashGroup[] memory, CashLadder[] memory) {\n        uint8[] memory groupIds = new uint8[](portfolio.length);\n        uint256 numGroups;\n\n        groupIds[numGroups] = portfolio[0].cashGroupId;\n        // Count the number of cash groups in the portfolio, we will return a cash ladder for each.\n        for (uint256 i = 1; i < portfolio.length; i++) {\n            if (portfolio[i].cashGroupId != groupIds[numGroups]) {\n                numGroups++;\n                groupIds[numGroups] = portfolio[i].cashGroupId;\n            }\n        }\n\n        uint8[] memory requestGroups = new uint8[](numGroups + 1);\n        for (uint256 i; i < requestGroups.length; i++) {\n            requestGroups[i] = groupIds[i];\n        }\n\n        Common.CashGroup[] memory cgs = Portfolios.getCashGroups(requestGroups);\n\n        CashLadder[] memory ladders = new CashLadder[](cgs.length);\n        for (uint256 i; i < ladders.length; i++) {\n            ladders[i].id = requestGroups[i];\n            ladders[i].currency = cgs[i].currency;\n            ladders[i].cashLadder = new int256[](cgs[i].numMaturities);\n        }\n\n        return (cgs, ladders);\n    }\n}"
    },
    {
      "filename": "contracts/Escrow.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./utils/Governed.sol\";\nimport \"./utils/Liquidation.sol\";\n\nimport \"./lib/SafeInt256.sol\";\nimport \"./lib/SafeMath.sol\";\nimport \"./lib/SafeUInt128.sol\";\nimport \"./lib/SafeERC20.sol\";\n\nimport \"./interface/IERC20.sol\";\nimport \"./interface/IERC777.sol\";\nimport \"./interface/IERC777Recipient.sol\";\nimport \"./interface/IERC1820Registry.sol\";\nimport \"./interface/IAggregator.sol\";\nimport \"./interface/IEscrowCallable.sol\";\nimport \"./interface/IWETH.sol\";\n\nimport \"./storage/EscrowStorage.sol\";\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\n\n/**\n * @title Escrow\n * @notice Manages a account balances for the entire system including deposits, withdraws,\n * cash balances, collateral lockup for trading, cash transfers (settlement), and liquidation.\n */\ncontract Escrow is EscrowStorage, Governed, IERC777Recipient, IEscrowCallable {\n    using SafeUInt128 for uint128;\n    using SafeMath for uint256;\n    using SafeInt256 for int256;\n\n    uint256 private constant UINT256_MAX = 2**256 - 1;\n\n    /**\n     * @dev skip\n     * @param directory reference to other contracts\n     * @param registry ERC1820 registry for ERC777 token standard\n     */\n    function initialize(\n        address directory,\n        address owner,\n        address registry,\n        address weth\n    ) external initializer {\n        Governed.initialize(directory, owner);\n\n        // This registry call is used for the ERC777 token standard.\n        IERC1820Registry(registry).setInterfaceImplementer(address(0), TOKENS_RECIPIENT_INTERFACE_HASH, address(this));\n\n        // List ETH as the zero currency\n        WETH = weth;\n        currencyIdToAddress[0] = WETH;\n        addressToCurrencyId[WETH] = 0;\n        currencyIdToDecimals[0] = Common.DECIMALS;\n        emit NewCurrency(WETH);\n    }\n\n    /********** Events *******************************/\n\n    /**\n     * @notice A new currency\n     * @param token address of the tradable token\n     */\n    event NewCurrency(address indexed token);\n\n    /**\n     * @notice A new exchange rate between two currencies\n     * @param base id of the base currency\n     * @param quote id of the quote currency\n     */\n    event UpdateExchangeRate(uint16 indexed base, uint16 indexed quote);\n\n    /**\n     * @notice Notice of a deposit made to an account\n     * @param currency currency id of the deposit\n     * @param account address of the account where the deposit was made\n     * @param value amount of tokens deposited\n     */\n    event Deposit(uint16 indexed currency, address account, uint256 value);\n\n    /**\n     * @notice Notice of a withdraw from an account\n     * @param currency currency id of the withdraw\n     * @param account address of the account where the withdraw was made\n     * @param value amount of tokens withdrawn\n     */\n    event Withdraw(uint16 indexed currency, address account, uint256 value);\n\n    /**\n     * @notice Notice of a successful liquidation. `msg.sender` will be the liquidator.\n     * @param localCurrency currency that was liquidated\n     * @param collateralCurrency currency that was exchanged for the local currency\n     * @param account the account that was liquidated\n     * @param amountRecollateralized the amount of local currency that recollateralized\n     */\n    event Liquidate(uint16 indexed localCurrency, uint16 collateralCurrency, address account, uint128 amountRecollateralized);\n\n    /**\n     * @notice Notice of a successful batch liquidation. `msg.sender` will be the liquidator.\n     * @param localCurrency currency that was liquidated\n     * @param collateralCurrency currency that was exchanged for the local currency\n     * @param accounts the accounts that were liquidated\n     * @param amountRecollateralized the amount of local currency that recollateralized\n     */\n    event LiquidateBatch(\n        uint16 indexed localCurrency,\n        uint16 collateralCurrency,\n        address[] accounts,\n        uint128[] amountRecollateralized\n    );\n\n    /**\n     * @notice Notice of a successful cash settlement. `msg.sender` will be the settler.\n     * @param localCurrency currency that was settled\n     * @param collateralCurrency currency that was exchanged for the local currency\n     * @param payer the account that paid in the settlement\n     * @param settledAmount the amount settled between the parties\n     */\n    event SettleCash(\n        uint16 localCurrency,\n        uint16 collateralCurrency,\n        address indexed payer,\n        uint128 settledAmount\n    );\n\n    /**\n     * @notice Notice of a successful batch cash settlement. `msg.sender` will be the settler.\n     * @param localCurrency currency that was settled\n     * @param collateralCurrency currency that was exchanged for the local currency\n     * @param payers the accounts that paid in the settlement\n     * @param settledAmounts the amounts settled between the parties\n     */\n    event SettleCashBatch(\n        uint16 localCurrency,\n        uint16 collateralCurrency,\n        address[] payers,\n        uint128[] settledAmounts\n    );\n\n    /**\n     * @notice Emitted when liquidation and settlement discounts are set\n     * @param liquidationDiscount discount given to liquidators when purchasing collateral\n     * @param settlementDiscount discount given to settlers when purchasing collateral\n     * @param repoIncentive incentive given to liquidators for pulling liquidity tokens to recollateralize an account\n     */\n    event SetDiscounts(uint128 liquidationDiscount, uint128 settlementDiscount, uint128 repoIncentive);\n\n    /**\n     * @notice Emitted when reserve account is set\n     * @param reserveAccount account that holds balances in reserve\n     */\n    event SetReserve(address reserveAccount);\n\n    /********** Events *******************************/\n\n    /********** Governance Settings ******************/\n\n    /**\n     * @notice Sets a local cached version of the G_LIQUIDITY_HAIRCUT on the RiskFramework contract. This will be\n     * used locally in the settlement and liquidation calculations when we pull local currency liquidity tokens.\n     * @dev skip\n     */\n    function setLiquidityHaircut(uint128 haircut) external override {\n        require(calledByPortfolios(), $$(ErrorCode(UNAUTHORIZED_CALLER)));\n        EscrowStorageSlot._setLiquidityHaircut(haircut);\n    }\n\n    /**\n     * @notice Sets discounts applied when purchasing collateral during liquidation or settlement. Discounts are\n     * represented as percentages multiplied by 1e18. For example, a 5% discount for liquidators will be set as\n     * 1.05e18\n     * @dev governance\n     * @param liquidation discount applied to liquidation\n     * @param settlement discount applied to settlement\n     * @param repoIncentive incentive to repo liquidity tokens\n     */\n    function setDiscounts(uint128 liquidation, uint128 settlement, uint128 repoIncentive) external onlyOwner {\n        EscrowStorageSlot._setLiquidationDiscount(liquidation);\n        EscrowStorageSlot._setSettlementDiscount(settlement);\n        EscrowStorageSlot._setLiquidityTokenRepoIncentive(repoIncentive);\n\n        emit SetDiscounts(liquidation, settlement, repoIncentive);\n    }\n\n    /**\n     * @notice Sets the reserve account used to settle against for insolvent accounts\n     * @dev governance\n     * @param account address of reserve account\n     */\n    function setReserveAccount(address account) external onlyOwner {\n        G_RESERVE_ACCOUNT = account;\n\n        emit SetReserve(account);\n    }\n\n    /**\n     * @notice Lists a new currency for deposits\n     * @dev governance\n     * @param token address of ERC20 or ERC777 token to list\n     * @param options a set of booleans that describe the token\n     */\n    function listCurrency(address token, TokenOptions memory options) public onlyOwner {\n        require(addressToCurrencyId[token] == 0 && token != WETH, $$(ErrorCode(INVALID_CURRENCY)));\n\n        maxCurrencyId++;\n        // We don't do a lot of checking here but since this is purely an administrative\n        // activity we just rely on governance not to set this improperly.\n        currencyIdToAddress[maxCurrencyId] = token;\n        addressToCurrencyId[token] = maxCurrencyId;\n        tokenOptions[token] = options;\n        uint256 decimals = IERC20(token).decimals();\n        currencyIdToDecimals[maxCurrencyId] = 10**(decimals);\n        // We need to set this number so that the free collateral check can provision\n        // the right number of currencies.\n        Portfolios().setNumCurrencies(maxCurrencyId);\n\n        emit NewCurrency(token);\n    }\n\n    /**\n     * @notice Creates an exchange rate between two currencies.\n     * @dev governance\n     * @param base the base currency\n     * @param quote the quote currency\n     * @param rateOracle the oracle that will give the exchange rate between the two\n     * @param buffer multiple to apply to the exchange rate that sets the collateralization ratio\n     * @param rateDecimals decimals of precision that the rate oracle uses\n     * @param mustInvert true if the chainlink oracle must be inverted\n     */\n    function addExchangeRate(\n        uint16 base,\n        uint16 quote,\n        address rateOracle,\n        uint128 buffer,\n        uint128 rateDecimals,\n        bool mustInvert\n    ) external onlyOwner {\n        // We require that exchange rate buffers are always greater than the settlement discount. The reason is\n        // that if this is not the case, it opens up the possibility that free collateral actually ends up in a worse\n        // position in the event of a third party settlement.\n        require(buffer > G_SETTLEMENT_DISCOUNT(), $$(ErrorCode(INVALID_HAIRCUT_SIZE)));\n        exchangeRateOracles[base][quote] = ExchangeRate.Rate(\n            rateOracle,\n            rateDecimals,\n            mustInvert,\n            buffer\n        );\n\n        emit UpdateExchangeRate(base, quote);\n    }\n\n    /********** Governance Settings ******************/\n\n    /********** Getter Methods ***********************/\n\n    /**\n     * @notice Evaluates whether or not a currency id is valid\n     * @param currency currency id\n     * @return true if the currency is valid\n     */\n    function isValidCurrency(uint16 currency) public override view returns (bool) {\n        return currency <= maxCurrencyId;\n    }\n\n    /**\n     * @notice Getter method for exchange rates\n     * @param base token address for the base currency\n     * @param quote token address for the quote currency\n     * @return ExchangeRate struct\n     */\n    function getExchangeRate(uint16 base, uint16 quote) external view returns (ExchangeRate.Rate memory) {\n        return exchangeRateOracles[base][quote];\n    }\n\n    /**\n     * @notice Returns the net balances of all the currencies owned by an account as\n     * an array. Each index of the array refers to the currency id.\n     * @param account the account to query\n     * @return the balance of each currency net of the account's cash position\n     */\n    function getBalances(address account) external override view returns (int256[] memory) {\n        // We add one here because the zero currency index is unused\n        int256[] memory balances = new int256[](maxCurrencyId + 1);\n\n        for (uint256 i; i < balances.length; i++) {\n            balances[i] = cashBalances[uint16(i)][account];\n        }\n\n        return balances;\n    }\n\n    /**\n     * @notice Converts the balances given to ETH for the purposes of determining whether an account has\n     * sufficient free collateral.\n     * @dev - INVALID_CURRENCY: length of the amounts array must match the total number of currencies\n     *  - INVALID_EXCHANGE_RATE: exchange rate returned by the oracle is less than 0\n     * @param amounts the balance in each currency group as an array, each index refers to the currency group id.\n     * @return an array the same length as amounts with each balance denominated in ETH\n     */\n    function convertBalancesToETH(int256[] memory amounts) public override view returns (int256[] memory) {\n        // We expect values for all currencies to be supplied here, we will not do any work on 0 balances.\n        require(amounts.length == maxCurrencyId + 1, $$(ErrorCode(INVALID_CURRENCY)));\n        int256[] memory results = new int256[](amounts.length);\n\n        // Currency ID = 0 is already ETH so we don't need to convert it, unless it is negative. Then we will\n        // haircut it.\n        if (amounts[0] < 0) {\n            // We store the ETH buffer on the exchange rate back to itself.\n            uint128 buffer = exchangeRateOracles[0][0].buffer;\n            results[0] = amounts[0].mul(buffer).div(Common.DECIMALS);\n        } else {\n            results[0] = amounts[0];\n        }\n\n        for (uint256 i = 1; i < amounts.length; i++) {\n            if (amounts[i] == 0) continue;\n\n            ExchangeRate.Rate memory er = exchangeRateOracles[uint16(i)][0];\n            uint256 baseDecimals = currencyIdToDecimals[uint16(i)];\n\n            if (amounts[i] < 0) {\n                // We buffer negative amounts to enforce collateralization ratios\n                results[i] = ExchangeRate._convertToETH(er, baseDecimals, amounts[i], true);\n            } else {\n                // We do not buffer positive amounts so that they can be used to collateralize\n                // other debts.\n                results[i] = ExchangeRate._convertToETH(er, baseDecimals, amounts[i], false);\n            }\n        }\n\n        return results;\n    }\n\n    /********** Getter Methods ***********************/\n\n    /********** Withdraw / Deposit Methods ***********/\n\n    /**\n     * @notice receive fallback for WETH transfers\n     * @dev skip\n     */\n    receive() external payable {\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\n    }\n\n    /**\n     * @notice This is a special function to handle ETH deposits. Value of ETH to be deposited must be specified in `msg.value`\n     * @dev - OVER_MAX_ETH_BALANCE: balance of deposit cannot overflow uint128\n     */\n    function depositEth() external payable {\n        _depositEth(msg.sender);\n    }\n\n    function _depositEth(address to) internal {\n        require(msg.value <= Common.MAX_UINT_128, $$(ErrorCode(OVER_MAX_ETH_BALANCE)));\n        IWETH(WETH).deposit{value: msg.value}();\n\n        cashBalances[0][to] = cashBalances[0][to].add(\n            uint128(msg.value)\n        );\n        emit Deposit(0, to, msg.value);\n    }\n\n    /**\n     * @notice Withdraw ETH from the contract.\n     * @dev - INSUFFICIENT_BALANCE: not enough balance in account\n     * - INSUFFICIENT_FREE_COLLATERAL: not enough free collateral to withdraw\n     * - TRANSFER_FAILED: eth transfer did not return success\n     * @param amount the amount of eth to withdraw from the contract\n     */\n    function withdrawEth(uint128 amount) external {\n        _withdrawEth(msg.sender, amount);\n    }\n\n    function _withdrawEth(address to, uint128 amount) internal {\n        int256 balance = cashBalances[0][to];\n        cashBalances[0][to] = balance.subNoNeg(amount);\n        require(_freeCollateral(to) >= 0, $$(ErrorCode(INSUFFICIENT_FREE_COLLATERAL)));\n\n        IWETH(WETH).withdraw(uint256(amount));\n        // solium-disable-next-line security/no-call-value\n        (bool success, ) = to.call{value: amount}(\"\");\n        require(success, $$(ErrorCode(TRANSFER_FAILED)));\n        emit Withdraw(0, to, amount);\n    }\n\n    /**\n     * @notice Transfers a balance from an ERC20 token contract into the Escrow. Do not call this for ERC777 transfers, use\n     * the `send` method instead.\n     * @dev - INVALID_CURRENCY: token address supplied is not a valid currency\n     * @param token token contract to send from\n     * @param amount tokens to transfer\n     */\n    function deposit(address token, uint128 amount) external {\n        _deposit(msg.sender, token, amount);\n    }\n\n    function _deposit(address from, address token, uint128 amount) internal {\n        uint16 currencyId = addressToCurrencyId[token];\n        if ((currencyId == 0 && token != WETH)) {\n            revert($$(ErrorCode(INVALID_CURRENCY)));\n        }\n\n        TokenOptions memory options = tokenOptions[token];\n        amount = _tokenDeposit(token, from, amount, options);\n        if (!options.isERC777) cashBalances[currencyId][from] = cashBalances[currencyId][from].add(amount);\n\n        emit Deposit(currencyId, from, amount);\n    }\n\n    function _tokenDeposit(\n        address token,\n        address from,\n        uint128 amount,\n        TokenOptions memory options\n    ) internal returns (uint128) {\n        if (options.hasTransferFee) {\n            // If there is a transfer fee we check the pre and post transfer balance to ensure that we increment\n            // the balance by the correct amount after transfer.\n            uint256 preTransferBalance = IERC20(token).balanceOf(address(this));\n            SafeERC20.safeTransferFrom(IERC20(token), from, address(this), amount);\n            uint256 postTransferBalance = IERC20(token).balanceOf(address(this));\n\n            amount = SafeCast.toUint128(postTransferBalance.sub(preTransferBalance));\n        } else if (options.isERC777) {\n            IERC777(token).operatorSend(from, address(this), amount, \"0x\", \"0x\");\n        }else {\n            SafeERC20.safeTransferFrom(IERC20(token), from, address(this), amount);\n        }\n        \n        return amount;\n    }\n\n    /**\n     * @notice Withdraws from an account's collateral holdings back to their account. Checks if the\n     * account has sufficient free collateral after the withdraw or else it fails.\n     * @dev - INSUFFICIENT_BALANCE: not enough balance in account\n     * - INVALID_CURRENCY: token address supplied is not a valid currency\n     * - INSUFFICIENT_FREE_COLLATERAL: not enough free collateral to withdraw\n     * @param token collateral type to withdraw\n     * @param amount total value to withdraw\n     */\n    function withdraw(address token, uint128 amount) external {\n       _withdraw(msg.sender, msg.sender, token, amount, true);\n    }\n\n    function _withdraw(\n        address from,\n        address to,\n        address token,\n        uint128 amount,\n        bool checkFC\n    ) internal {\n        uint16 currencyId = addressToCurrencyId[token];\n        require(token != address(0), $$(ErrorCode(INVALID_CURRENCY)));\n\n        // We settle matured assets before withdraw in case there are matured cash receiver or liquidity\n        // token assets\n        if (checkFC) Portfolios().settleMaturedAssets(from);\n\n        int256 balance = cashBalances[currencyId][from];\n        cashBalances[currencyId][from] = balance.subNoNeg(amount);\n\n        // We're checking this after the withdraw has been done on currency balances. We skip this check\n        // for batch withdraws when we check once after everything is completed.\n        if (checkFC) {\n            (int256 fc, /* int256[] memory */, /* int256[] memory */) = Portfolios().freeCollateralView(from);\n            require(fc >= 0, $$(ErrorCode(INSUFFICIENT_FREE_COLLATERAL)));\n        }\n\n        _tokenWithdraw(token, to, amount);\n\n        emit Withdraw(currencyId, to, amount);\n    }\n\n    function _tokenWithdraw(\n        address token,\n        address to,\n        uint128 amount\n    ) internal {\n        if (tokenOptions[token].isERC777) {\n            IERC777(token).send(to, amount, \"0x\");\n        } else {\n            SafeERC20.safeTransfer(IERC20(token), to, amount);\n        }\n    }\n\n    /**\n     * @notice Deposits on behalf of an account, called via the ERC1155 batchOperation and bridgeTransferFrom.\n     * @dev skip\n     */\n    function depositsOnBehalf(address account, Common.Deposit[] memory deposits) public payable override {\n        require(calledByERC1155Trade(), $$(ErrorCode(UNAUTHORIZED_CALLER)));\n\n        if (msg.value != 0) {\n            _depositEth(account);\n        }\n\n        for (uint256 i; i < deposits.length; i++) {\n            address tokenAddress = currencyIdToAddress[deposits[i].currencyId];\n            _deposit(account, tokenAddress, deposits[i].amount);\n        }\n    }\n\n    /**\n     * @notice Withdraws on behalf of an account, called via the ERC1155 batchOperation and bridgeTransferFrom. Note that\n     * this does not handle non-WETH withdraws.\n     * @dev skip\n     */\n    function withdrawsOnBehalf(address account, Common.Withdraw[] memory withdraws) public override {\n        require(calledByERC1155Trade(), $$(ErrorCode(UNAUTHORIZED_CALLER)));\n\n        for (uint256 i; i < withdraws.length; i++) {\n            address tokenAddress = currencyIdToAddress[withdraws[i].currencyId];\n            uint128 amount;\n\n            if (withdraws[i].amount == 0) {\n                // If the amount is zero then we skip.\n                continue;\n            } else {\n                amount = withdraws[i].amount;\n            }\n\n            // We skip the free collateral check here because ERC1155.batchOperation will do the check\n            // before it exits.\n            _withdraw(account, withdraws[i].to, tokenAddress, amount, false);\n        }\n    }\n\n    /**\n     * @notice Receives tokens from an ERC777 send message.\n     * @dev skip\n     * @param from address the tokens are being sent from (!= msg.sender)\n     * @param amount amount\n     */\n    function tokensReceived(\n        address, /*operator*/\n        address from,\n        address, /*to*/\n        uint256 amount,\n        bytes calldata, /*userData*/\n        bytes calldata /*operatorData*/\n    ) external override {\n        uint16 currencyId = addressToCurrencyId[msg.sender];\n        require(currencyId != 0, $$(ErrorCode(INVALID_CURRENCY)));\n        cashBalances[currencyId][from] = cashBalances[currencyId][from].add(SafeCast.toUint128(amount));\n\n        emit Deposit(currencyId, from, amount);\n    }\n\n    /********** Withdraw / Deposit Methods ***********/\n\n    /********** Cash Management *********/\n\n    /**\n     * @notice Transfers the cash required between the Market and the specified account. Cash\n     * held by the Market is available to p"
    }
  ]
}