{
  "Title": "[G-15] Remove unused local variable",
  "Content": "\n```solidity\nFile: contracts-full/TransmuterBuffer.sol   #1\n\n515           (uint256 availableShares, uint256 lastAccruedWeight) = IAlchemistV2(alchemist).positions(address(this), token);\n```\n\n<https://github.com/code-423n4/2022-05-alchemix/blob/71abbe683dfd5c0686b7e594fb4f78a14b668d8b/contracts-full/TransmuterBuffer.sol#L515>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-05-alchemix-contest",
  "Code": [
    {
      "filename": "contracts-full/TransmuterBuffer.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"./base/Errors.sol\";\n\nimport \"./interfaces/IAlchemistV2.sol\";\nimport \"./interfaces/ITokenAdapter.sol\";\nimport \"./interfaces/transmuter/ITransmuterBuffer.sol\";\nimport \"./interfaces/transmuter/ITransmuterV2.sol\";\n\nimport \"./libraries/FixedPointMath.sol\";\nimport \"./libraries/LiquidityMath.sol\";\nimport \"./libraries/SafeCast.sol\";\nimport \"./libraries/TokenUtils.sol\";\nimport \"./interfaces/IERC20TokenReceiver.sol\";\n\n/// @title  ITransmuterBuffer\n/// @author Alchemix Finance\n///\n/// @notice An interface contract to buffer funds between the Alchemist and the Transmuter\ncontract TransmuterBuffer is ITransmuterBuffer, AccessControl, Initializable {\n    using SafeMath for uint256;\n    using FixedPointMath for FixedPointMath.Number;\n\n    /// @notice The identifier of the role which maintains other roles.\n    bytes32 public constant ADMIN = keccak256(\"ADMIN\");\n\n    /// @notice The identifier of the keeper role.\n    bytes32 public constant KEEPER = keccak256(\"KEEPER\");\n\n    /// @inheritdoc ITransmuterBuffer\n    string public constant override version = \"2.2.0\";\n\n    /// @notice The alchemist address.\n    address public alchemist;\n\n    /// @notice The public transmuter address for each address.\n    mapping(address => address) public transmuter;\n\n    /// @notice The flowRate for each address.\n    mapping(address => uint256) public flowRate;\n\n    /// @notice The last update timestamp gor the flowRate for each address.\n    mapping(address => uint256) public lastFlowrateUpdate;\n\n    /// @notice The amount of flow available per ERC20.\n    mapping(address => uint256) public flowAvailable;\n\n    /// @notice The yieldTokens of each underlying supported by the Alchemist.\n    mapping(address => address[]) public _yieldTokens;\n\n    /// @notice The total amount of an underlying token that has been exchanged into the transmuter, and has not been claimed.\n    mapping(address => uint256) public currentExchanged;\n\n    /// @notice The underlying-tokens registered in the TransmuterBuffer.\n    address[] public registeredUnderlyings;\n\n    /// @notice The debt-token used by the TransmuterBuffer.\n    address public debtToken;\n\n    /// @notice A mapping of weighting schemas to be used in actions taken on the Alchemist (burn, deposit).\n    mapping(address => Weighting) public weightings;\n\n    /// @dev A mapping of addresses to denote permissioned sources of funds\n    mapping(address => bool) public sources;\n\n    /// @dev A mapping of addresses to their respective AMOs.\n    mapping(address => address) public amos;\n\n    /// @dev A mapping of underlying tokens to divert to the AMO.\n    mapping(address => bool) public divertToAmo;\n\n    constructor() initializer {}\n\n    /// @dev Initialize the contract\n    ///\n    /// @param _admin     The governing address of the buffer.\n    /// @param _debtToken The debt token minted by the Alchemist and accepted by the Transmuter.\n    function initialize(address _admin, address _debtToken) external initializer {\n        _setupRole(ADMIN, _admin);\n        _setRoleAdmin(ADMIN, ADMIN);\n        _setRoleAdmin(KEEPER, ADMIN);\n        debtToken = _debtToken;\n    }\n\n    /// @dev Only allows the transmuter to call the modified function\n    ///\n    /// Reverts if the caller is not a correct transmuter.\n    ///\n    /// @param underlyingToken the underlying token associated with the transmuter.\n    modifier onlyTransmuter(address underlyingToken) {\n        if (msg.sender != transmuter[underlyingToken]) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    /// @dev Only allows a governance-permissioned source to call the modified function\n    ///\n    /// Reverts if the caller is not a permissioned source.\n    modifier onlySource() {\n        if (!sources[msg.sender]) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    /// @dev Only calls from the admin address are authorized to pass.\n    modifier onlyAdmin() {\n        if (!hasRole(ADMIN, msg.sender)) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    /// @dev Only calls from a keeper address are authorized to pass.\n    modifier onlyKeeper() {\n        if (!hasRole(KEEPER, msg.sender)) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function getWeight(address weightToken, address token)\n        external\n        view\n        override\n        returns (uint256 weight)\n    {\n        return weightings[weightToken].weights[token];\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function getAvailableFlow(address underlyingToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // total amount of collateral that the buffer controls in the alchemist\n        uint256 totalUnderlyingBuffered = getTotalUnderlyingBuffered(\n            underlyingToken\n        );\n\n        if (totalUnderlyingBuffered < flowAvailable[underlyingToken]) {\n            return totalUnderlyingBuffered;\n        } else {\n            return flowAvailable[underlyingToken];\n        }\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function getTotalCredit() public view override returns (uint256 credit) {\n        (int256 debt, ) = IAlchemistV2(alchemist).accounts(address(this));\n        credit = debt >= 0 ? 0 : SafeCast.toUint256(-debt);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function getTotalUnderlyingBuffered(address underlyingToken)\n        public\n        view\n        override\n        returns (uint256 totalBuffered)\n    {\n        totalBuffered = TokenUtils.safeBalanceOf(underlyingToken, address(this));\n        for (uint256 i = 0; i < _yieldTokens[underlyingToken].length; i++) {\n            totalBuffered += _getTotalBuffered(_yieldTokens[underlyingToken][i]);\n        }\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function setWeights(\n        address weightToken,\n        address[] memory tokens,\n        uint256[] memory weights\n    ) external override onlyAdmin {\n        Weighting storage weighting = weightings[weightToken];\n        delete weighting.tokens;\n        weighting.totalWeight = 0;\n        for (uint256 i = 0; i < tokens.length; i++) {\n            address yieldToken = tokens[i];\n\n            // For any weightToken that is not the debtToken, we want to verify that the yield-tokens being\n            // set for the weight schema accept said weightToken as collateral.\n            //\n            // We don't want to do this check on the debtToken because it is only used in the burnCredit() function\n            // and we want to be able to burn credit to any yield-token in the Alchemist.\n            if (weightToken != debtToken) {\n                IAlchemistV2.YieldTokenParams memory params = IAlchemistV2(alchemist)\n                    .getYieldTokenParameters(yieldToken);\n                address underlyingToken = ITokenAdapter(params.adapter)\n                    .underlyingToken();\n\n                if (weightToken != underlyingToken) {\n                    revert IllegalState();\n                }\n            }\n\n            weighting.tokens.push(yieldToken);\n            weighting.weights[yieldToken] = weights[i];\n            weighting.totalWeight += weights[i];\n        }\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function setSource(address source, bool flag) external override onlyAdmin {\n        if (sources[source] == flag) {\n            revert IllegalArgument();\n        }\n        sources[source] = flag;\n        emit SetSource(source, flag);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function setTransmuter(address underlyingToken, address newTransmuter) external override onlyAdmin {\n        if (ITransmuterV2(newTransmuter).underlyingToken() != underlyingToken) {\n            revert IllegalArgument();\n        }\n        transmuter[underlyingToken] = newTransmuter;\n        emit SetTransmuter(underlyingToken, newTransmuter);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function setAlchemist(address _alchemist) external override onlyAdmin {\n        sources[alchemist] = false;\n        sources[_alchemist] = true;\n\n        if (alchemist != address(0)) {\n            for (uint256 i = 0; i < registeredUnderlyings.length; i++) {\n                TokenUtils.safeApprove(registeredUnderlyings[i], alchemist, 0);\n            }\n            TokenUtils.safeApprove(debtToken, alchemist, 0);\n        }\n\n        alchemist = _alchemist;\n        for (uint256 i = 0; i < registeredUnderlyings.length; i++) {\n            TokenUtils.safeApprove(registeredUnderlyings[i], alchemist, type(uint256).max);\n        }\n        TokenUtils.safeApprove(debtToken, alchemist, type(uint256).max);\n\n        emit SetAlchemist(alchemist);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function setAmo(address underlyingToken, address amo) external override onlyAdmin {\n        amos[underlyingToken] = amo;\n        emit SetAmo(underlyingToken, amo);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function setDivertToAmo(address underlyingToken, bool divert) external override onlyAdmin {\n        divertToAmo[underlyingToken] = divert;\n        emit SetDivertToAmo(underlyingToken, divert);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function registerAsset(\n        address underlyingToken,\n        address _transmuter\n    ) external override onlyAdmin {\n        if (!IAlchemistV2(alchemist).isSupportedUnderlyingToken(underlyingToken)) {\n            revert IllegalState();\n        }\n\n        // only add to the array if not already contained in it\n        for (uint256 i = 0; i < registeredUnderlyings.length; i++) {\n            if (registeredUnderlyings[i] == underlyingToken) {\n                revert IllegalState();\n            }\n        }\n\n        if (ITransmuterV2(_transmuter).underlyingToken() != underlyingToken) {\n            revert IllegalArgument();\n        }\n\n        transmuter[underlyingToken] = _transmuter;\n        registeredUnderlyings.push(underlyingToken);\n        TokenUtils.safeApprove(underlyingToken, alchemist, type(uint256).max);\n        emit RegisterAsset(underlyingToken, _transmuter);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function setFlowRate(address underlyingToken, uint256 _flowRate)\n        external\n        override\n        onlyAdmin\n    {\n        _exchange(underlyingToken);\n\n        flowRate[underlyingToken] = _flowRate;\n        emit SetFlowRate(underlyingToken, _flowRate);\n    }\n\n    /// @inheritdoc IERC20TokenReceiver\n    function onERC20Received(address underlyingToken, uint256 amount)\n        external\n        override\n        onlySource\n    {\n        if (divertToAmo[underlyingToken]) {\n            _flushToAmo(underlyingToken, amount);\n        } else {\n            _updateFlow(underlyingToken);\n\n            // total amount of collateral that the buffer controls in the alchemist\n            uint256 localBalance = TokenUtils.safeBalanceOf(underlyingToken, address(this));\n\n            // if there is not enough locally buffered collateral to meet the flow rate, exchange only the exchanged amount\n            if (localBalance < flowAvailable[underlyingToken]) {\n                currentExchanged[underlyingToken] += amount;\n                ITransmuterV2(transmuter[underlyingToken]).exchange(amount);\n            } else {\n                uint256 exchangeable = flowAvailable[underlyingToken] - currentExchanged[underlyingToken];\n                currentExchanged[underlyingToken] += exchangeable;\n                ITransmuterV2(transmuter[underlyingToken]).exchange(exchangeable);\n            }\n        }\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function exchange(address underlyingToken) external override onlyKeeper {\n        _exchange(underlyingToken);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function flushToAmo(address underlyingToken, uint256 amount) external override onlyKeeper {\n        if (divertToAmo[underlyingToken]) {\n            _flushToAmo(underlyingToken, amount);\n        } else {\n            revert IllegalState();\n        }\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function withdraw(\n        address underlyingToken,\n        uint256 amount,\n        address recipient\n    ) external override onlyTransmuter(underlyingToken) {\n        if (amount > flowAvailable[underlyingToken]) {\n            revert IllegalArgument();\n        }\n\n        uint256 localBalance = TokenUtils.safeBalanceOf(underlyingToken, address(this));\n        if (amount > localBalance) {\n            revert IllegalArgument();\n        }\n\n        flowAvailable[underlyingToken] -= amount;\n        currentExchanged[underlyingToken] -= amount;\n\n        TokenUtils.safeTransfer(underlyingToken, recipient, amount);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function withdrawFromAlchemist(\n        address yieldToken,\n        uint256 shares,\n        uint256 minimumAmountOut\n    ) external override onlyKeeper {\n        IAlchemistV2(alchemist).withdrawUnderlying(yieldToken, shares, address(this), minimumAmountOut);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function refreshStrategies() public override {\n        address[] memory supportedYieldTokens = IAlchemistV2(alchemist)\n            .getSupportedYieldTokens();\n        address[] memory supportedUnderlyingTokens = IAlchemistV2(alchemist)\n            .getSupportedUnderlyingTokens();\n\n        if (registeredUnderlyings.length != supportedUnderlyingTokens.length) {\n            revert IllegalState();\n        }\n\n        // clear current strats\n        for (uint256 j = 0; j < registeredUnderlyings.length; j++) {\n            delete _yieldTokens[registeredUnderlyings[j]];\n        }\n\n        uint256 numYTokens = supportedYieldTokens.length;\n        for (uint256 i = 0; i < numYTokens; i++) {\n            address yieldToken = supportedYieldTokens[i];\n\n            IAlchemistV2.YieldTokenParams memory params = IAlchemistV2(alchemist)\n                .getYieldTokenParameters(yieldToken);\n            if (params.enabled) {\n                _yieldTokens[params.underlyingToken].push(yieldToken);\n            }\n        }\n        emit RefreshStrategies();\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function burnCredit() external override onlyKeeper {\n        IAlchemistV2(alchemist).poke(address(this));\n        uint256 credit = getTotalCredit();\n        if (credit == 0) {\n            revert IllegalState();\n        }\n        IAlchemistV2(alchemist).mint(credit, address(this));\n\n        _alchemistAction(credit, debtToken, _alchemistDonate);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function depositFunds(address underlyingToken, uint256 amount)\n        external\n        override\n        onlyKeeper\n    {\n        if (amount == 0) {\n            revert IllegalArgument();\n        }\n        uint256 localBalance = TokenUtils.safeBalanceOf(underlyingToken, address(this));\n        if (localBalance < amount) {\n            revert IllegalArgument();\n        }\n        _updateFlow(underlyingToken);\n        \n        // Don't deposit exchanged funds into the Alchemist.\n        // Doing so puts those funds at risk, and could lead to users being unable to claim\n        // their transmuted funds in the event of a vault loss.\n        if (localBalance - amount < currentExchanged[underlyingToken]) {\n            revert IllegalState();\n        }\n        _alchemistAction(amount, underlyingToken, _alchemistDeposit);\n    }\n\n    /// @dev Gets the total value of the yield tokens in units of underlying tokens that this contract holds.\n    ///\n    /// @param yieldToken The address of the target yield token.\n    function _getTotalBuffered(address yieldToken)\n        internal\n        view\n        returns (uint256)\n    {\n        (uint256 balance, ) = IAlchemistV2(alchemist).positions(address(this), yieldToken);\n        IAlchemistV2.YieldTokenParams memory params = IAlchemistV2(alchemist)\n            .getYieldTokenParameters(yieldToken);\n        uint256 tokensPerShare = IAlchemistV2(alchemist)\n            .getUnderlyingTokensPerShare(yieldToken);\n        return (balance * tokensPerShare) / 10**params.decimals;\n    }\n\n    /// @dev Updates the available flow for a give underlying token\n    ///\n    /// @param underlyingToken the underlying token whos flow is being updated\n    function _updateFlow(address underlyingToken) internal returns (uint256) {\n        // additional flow to be allocated based on flow rate\n        uint256 marginalFlow = (block.timestamp -\n            lastFlowrateUpdate[underlyingToken]) * flowRate[underlyingToken];\n        flowAvailable[underlyingToken] += marginalFlow;\n        lastFlowrateUpdate[underlyingToken] = block.timestamp;\n        return marginalFlow;\n    }\n\n    /// @notice Runs an action on the Alchemist according to a given weighting schema.\n    ///\n    /// This function gets a weighting schema defined under the `weightToken` key, and calls the target action\n    /// with a weighted value of `amount` and the associated token.\n    ///\n    /// @param amount       The amount of funds to use in the action.\n    /// @param weightToken  The key of the weighting schema to be used for the action.\n    /// @param action       The action to be taken.\n    function _alchemistAction(\n        uint256 amount,\n        address weightToken,\n        function(address, uint256) action\n    ) internal {\n        IAlchemistV2(alchemist).poke(address(this));\n\n        Weighting storage weighting = weightings[weightToken];\n        for (uint256 j = 0; j < weighting.tokens.length; j++) {\n            address token = weighting.tokens[j];\n            uint256 actionAmt = (amount * weighting.weights[token]) / weighting.totalWeight;\n            action(token, actionAmt);\n        }\n    }\n\n    /// @notice Donate credit weight to a target yield-token by burning debt-tokens.\n    ///\n    /// @param token    The target yield-token.\n    /// @param amount      The amount of debt-tokens to burn.\n    function _alchemistDonate(address token, uint256 amount) internal {\n        IAlchemistV2(alchemist).donate(token, amount);\n    }\n\n    /// @notice Deposits funds into the Alchemist.\n    ///\n    /// @param token  The yield-token to deposit.\n    /// @param amount The amount to deposit.\n    function _alchemistDeposit(address token, uint256 amount) internal {\n        IAlchemistV2(alchemist).depositUnderlying(\n            token,\n            amount,\n            address(this),\n            0\n        );\n    }\n\n    /// @notice Withdraws funds from the Alchemist.\n    ///\n    /// @param token            The yield-token to withdraw.\n    /// @param amountUnderlying The amount of underlying to withdraw.\n    function _alchemistWithdraw(address token, uint256 amountUnderlying) internal {\n        uint8 decimals = TokenUtils.expectDecimals(token);\n        uint256 pricePerShare = IAlchemistV2(alchemist).getUnderlyingTokensPerShare(token);\n        uint256 wantShares = amountUnderlying * 10**decimals / pricePerShare;\n        (uint256 availableShares, uint256 lastAccruedWeight) = IAlchemistV2(alchemist).positions(address(this), token);\n        if (wantShares > availableShares) {\n            wantShares = availableShares;\n        }\n        // Allow 1% slippage\n        uint256 minimumAmountOut = amountUnderlying - amountUnderlying * 100 / 10000;\n        if (wantShares > 0) {\n            IAlchemistV2(alchemist).withdrawUnderlying(token, wantShares, address(this), minimumAmountOut);\n        }\n    }\n\n    /// @notice Pull necessary funds from the Alchemist and exchange them.\n    ///\n    /// @param underlyingToken The underlying-token to exchange.\n    function _exchange(address underlyingToken) internal {\n        _updateFlow(underlyingToken);\n\n        uint256 totalUnderlyingBuffered = getTotalUnderlyingBuffered(underlyingToken);\n        uint256 initialLocalBalance = TokenUtils.safeBalanceOf(underlyingToken, address(this));\n        uint256 want = 0;\n        // Here we assume the invariant underlyingToken.balanceOf(address(this)) >= currentExchanged[underlyingToken].\n        if (totalUnderlyingBuffered < flowAvailable[underlyingToken]) {\n            // Pull the rest of the funds from the Alchemist.\n            want = totalUnderlyingBuffered - initialLocalBalance;\n        } else if (initialLocalBalance < flowAvailable[underlyingToken]) {\n            // totalUnderlyingBuffered > flowAvailable so we have funds available to pull.\n            want = flowAvailable[underlyingToken] - initialLocalBalance;\n        }\n\n        if (want > 0) {\n            _alchemistAction(want, underlyingToken, _alchemistWithdraw);\n        }\n\n        uint256 localBalance = TokenUtils.safeBalanceOf(underlyingToken, address(this));\n        uint256 exchangeDelta = 0;\n        if (localBalance > flowAvailable[underlyingToken]) {\n            exchangeDelta = flowAvailable[underlyingToken] - currentExchanged[underlyingToken];\n        } else {\n            exchangeDelta = localBalance - currentExchanged[underlyingToken];\n        }\n\n        if (exchangeDelta > 0) {\n            currentExchanged[underlyingToken] += exchangeDelta;\n            ITransmuterV2(transmuter[underlyingToken]).exchange(exchangeDelta);\n        }\n    }\n\n    /// @notice Flush funds to the amo.\n    ///\n    /// @param underlyingToken The underlyingToken to flush.\n    /// @param amount          The amount to flush.\n    function _flushToAmo(address underlyingToken, uint256 amount) internal {\n        TokenUtils.safeTransfer(underlyingToken, amos[underlyingToken], amount);\n        IERC20TokenReceiver(amos[underlyingToken]).onERC20Received(underlyingToken, amount);\n    }\n}"
    }
  ]
}