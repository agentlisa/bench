{
  "Title": "Cross Domain Messengers Can Fail in Relaying a Message",
  "Content": "The [`L1CrossDomainMessenger` contract](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/packages/contracts-bedrock/contracts/L1/L1CrossDomainMessenger.sol) extends [`CrossDomainMessenger`](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/packages/contracts-bedrock/contracts/universal/CrossDomainMessenger.sol) and overrides the [`relayMessage` function](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/packages/contracts-bedrock/contracts/L1/L1CrossDomainMessenger.sol#L166). One of the characteristics of the original `relayMessage` function is that the estimation of whether there is enough gas or not to proceed with the external call [has](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/packages/contracts-bedrock/contracts/universal/CrossDomainMessenger.sol#L435-L455) a few operations performed in between. The `hasMinGas` function, responsible for the proper gas check, has clear [docstrings](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/packages/contracts-bedrock/contracts/libraries/SafeCall.sol#L67) that warn against the overhead gas provided. It [states](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/packages/contracts-bedrock/contracts/libraries/SafeCall.sol#L77) that 40000 units of gas are added as extra gas cost to account for a worst-case scenario of the `CALL` opcode called in the subsequent external call. The worst-case scenario includes:\n\n\n* Access to cold storage that accounts for [2600](https://github.com/ethereum/execution-specs/blob/cd9b7d6a9af2f5e07cad02a4971744dd6a553b10/src/ethereum/shanghai/vm/gas.py#L62) units of gas.\n* Call to a non-existent target that accounts for [25000](https://github.com/ethereum/execution-specs/blob/cd9b7d6a9af2f5e07cad02a4971744dd6a553b10/src/ethereum/shanghai/vm/gas.py#L46) units of gas.\n* A positive `msg.value` in the call that will increase the cost by [9000](https://github.com/ethereum/execution-specs/blob/cd9b7d6a9af2f5e07cad02a4971744dd6a553b10/src/ethereum/shanghai/vm/gas.py#L47) units of gas.\n\n\nAlso, note that the [second](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/packages/contracts-bedrock/contracts/universal/CrossDomainMessenger.sol#L436) argument of the `hasMinGas` function is the sum of the following two variables:\n\n\n* [`RELAY_RESERVED_GAS`](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/packages/contracts-bedrock/contracts/universal/CrossDomainMessenger.sol#L157) which is set to 40000 units of gas. This is an estimation of how much gas is needed to continue with the `relayMessage` execution after the external call. This is unchanged from Optimism code.\n* [`RELAY_GAS_CHECK_BUFFER`](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/packages/contracts-bedrock/contracts/universal/CrossDomainMessenger.sol#L163) which is set to 5000 units of gas and represents an amount that should be used in between the `hasMinGas` function and the external call. This is also unchanged from Optimism code.\n\n\nThe `hasMinGas` function contains the following formula:\n\n\n\n\n```\nÂ [ gasLeft - (40000 + _reservedGas) ] * 63/64 >= _minGas\n\n```\n\n\nHere, `_reservedGas` is 45000 units of gas of which only 5000 are estimated to be a buffer before the external call. Taking into account all of this, between the gas estimation and the external call, there is a total buffer of 5000 plus the remainder of the 40000, removing the worst case scenario of 36600 units of gas, for a total of 8400 units of gas (and [not](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/packages/contracts-bedrock/contracts/libraries/SafeCall.sol#L85) 5700 as mentioned in the docs). After the external call, another 40000 units of gas are reserve to finish with the normal execution.\n\n\nThe `L1CrossDomainMessenger` override adds some extra instructions in the code: [an](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/packages/contracts-bedrock/contracts/L1/L1CrossDomainMessenger.sol#L250) `approve` call to the MNT token contract in case the message being relayed contains a movement of MNT tokens, and a [second](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/packages/contracts-bedrock/contracts/L1/L1CrossDomainMessenger.sol#L256) `approve` to set the allowance back to 0 which is repeated after the external call. Whether the second approval is needed or not depends on whether there might be circumstances in which given approvals are not consumed by the target of the external call.\n\n\nAn approval of an ERC-20 token can span from a few thousand up to 30000 or 40000 units of gas, exceeding the buffer of few thousands units provided by far. [Some](https://optimistic.etherscan.io/tx/0xebc91e5f1d421eb2165a8d58a5275dd0eebee7008dbf8c2f19d7078b70e7f078) instances of an `OptmismMintableERC20` token might consume even more than 40000 units of gas for every `approve` call. `approve` call gas consumption definitely depends on whether values are being set from zero to positive values or the other way around, or from non-zero to non-zero values. Notice that a similar argument can be made for the `relayMessage` [function](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/packages/contracts-bedrock/contracts/L2/L2CrossDomainMessenger.sol#L161) of the `L2CrossDomainMessenger`.\n\n\nIn light of the above, consider revisiting the values for `RELAY_GAS_CHECK_BUFFER` and `RELAY_RESERVED_GAS`, and deciding whether the second approval is needed to avoid having unexpected gas failures due to extra instructions included from the original Optimism code that came with no changes to those default estimation values. Moreover, given the added logic from Optimism code, gas buffers should be adapted to ensure that enough overhead is added so that the transactions do not fail. It is worth noting that calls to `relayMessage` that can be engineered to fail can prevent the finalization of deposits and withdrawals, opening the doors for DoS attacks.\n\n\n***Update:** Resolved in [pull request #114](https://github.com/mantlenetworkio/mantle-v2/pull/114/files) at commit [67f0904](https://github.com/mantlenetworkio/mantle-v2/tree/67f0904af76580e05b630714411b0e6dadfd5e83) and at commit [92ebaf9](https://github.com/mantlenetworkio/mantle-v2/commit/92ebaf96622e8126ce5322bdf3ea730640c7a548).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/ethereum/shanghai/vm/gas.py",
      "content": "\"\"\"\nEthereum Virtual Machine (EVM) Gas\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n.. contents:: Table of Contents\n    :backlinks: none\n    :local:\n\nIntroduction\n------------\n\nEVM gas constants and calculators.\n\"\"\"\nfrom dataclasses import dataclass\nfrom typing import List, Tuple\n\nfrom ethereum.base_types import U256, Uint\nfrom ethereum.trace import GasAndRefund, evm_trace\nfrom ethereum.utils.numeric import ceil32\n\nfrom . import Evm\nfrom .exceptions import OutOfGasError\n\nGAS_JUMPDEST = Uint(1)\nGAS_BASE = Uint(2)\nGAS_VERY_LOW = Uint(3)\nGAS_STORAGE_SET = Uint(20000)\nGAS_STORAGE_UPDATE = Uint(5000)\nGAS_STORAGE_CLEAR_REFUND = Uint(4800)\nGAS_LOW = Uint(5)\nGAS_MID = Uint(8)\nGAS_HIGH = Uint(10)\nGAS_EXPONENTIATION = Uint(10)\nGAS_EXPONENTIATION_PER_BYTE = Uint(50)\nGAS_MEMORY = Uint(3)\nGAS_KECCAK256 = Uint(30)\nGAS_KECCAK256_WORD = Uint(6)\nGAS_COPY = Uint(3)\nGAS_BLOCK_HASH = Uint(20)\nGAS_LOG = Uint(375)\nGAS_LOG_DATA = Uint(8)\nGAS_LOG_TOPIC = Uint(375)\nGAS_CREATE = Uint(32000)\nGAS_CODE_DEPOSIT = Uint(200)\nGAS_ZERO = Uint(0)\nGAS_NEW_ACCOUNT = Uint(25000)\nGAS_CALL_VALUE = Uint(9000)\nGAS_CALL_STIPEND = Uint(2300)\nGAS_SELF_DESTRUCT = Uint(5000)\nGAS_SELF_DESTRUCT_NEW_ACCOUNT = Uint(25000)\nGAS_ECRECOVER = Uint(3000)\nGAS_SHA256 = Uint(60)\nGAS_SHA256_WORD = Uint(12)\nGAS_RIPEMD160 = Uint(600)\nGAS_RIPEMD160_WORD = Uint(120)\nGAS_IDENTITY = Uint(15)\nGAS_IDENTITY_WORD = Uint(3)\nGAS_RETURN_DATA_COPY = Uint(3)\nGAS_FAST_STEP = Uint(5)\nGAS_BLAKE2_PER_ROUND = Uint(1)\nGAS_COLD_SLOAD = Uint(2100)\nGAS_COLD_ACCOUNT_ACCESS = Uint(2600)\nGAS_WARM_ACCESS = Uint(100)\nGAS_INIT_CODE_WORD_COST = 2\n\n\n@dataclass\nclass ExtendMemory:\n    \"\"\"\n    Define the parameters for memory extension in opcodes\n\n    `cost`: `ethereum.base_types.Uint`\n        The gas required to perform the extension\n    `expand_by`: `ethereum.base_types.Uint`\n        The size by which the memory will be extended\n    \"\"\"\n\n    cost: Uint\n    expand_by: Uint\n\n\n@dataclass\nclass MessageCallGas:\n    \"\"\"\n    Define the gas cost and stipend for executing the call opcodes.\n\n    `cost`: `ethereum.base_types.Uint`\n        The non-refundable portion of gas reserved for executing the\n        call opcode.\n    `stipend`: `ethereum.base_types.Uint`\n        The portion of gas available to sub-calls that is refundable\n        if not consumed\n    \"\"\"\n\n    cost: Uint\n    stipend: Uint\n\n\ndef charge_gas(evm: Evm, amount: Uint) -> None:\n    \"\"\"\n    Subtracts `amount` from `evm.gas_left`.\n\n    Parameters\n    ----------\n    evm :\n        The current EVM.\n    amount :\n        The amount of gas the current operation requires.\n\n    \"\"\"\n    evm_trace(evm, GasAndRefund(amount))\n\n    if evm.gas_left < amount:\n        raise OutOfGasError\n    else:\n        evm.gas_left -= U256(amount)\n\n\ndef calculate_memory_gas_cost(size_in_bytes: Uint) -> Uint:\n    \"\"\"\n    Calculates the gas cost for allocating memory\n    to the smallest multiple of 32 bytes,\n    such that the allocated size is at least as big as the given size.\n\n    Parameters\n    ----------\n    size_in_bytes :\n        The size of the data in bytes.\n\n    Returns\n    -------\n    total_gas_cost : `ethereum.base_types.Uint`\n        The gas cost for storing data in memory.\n    \"\"\"\n    size_in_words = ceil32(size_in_bytes) // 32\n    linear_cost = size_in_words * GAS_MEMORY\n    quadratic_cost = size_in_words**2 // 512\n    total_gas_cost = linear_cost + quadratic_cost\n    try:\n        return total_gas_cost\n    except ValueError:\n        raise OutOfGasError\n\n\ndef calculate_gas_extend_memory(\n    memory: bytearray, extensions: List[Tuple[U256, U256]]\n) -> ExtendMemory:\n    \"\"\"\n    Calculates the gas amount to extend memory\n\n    Parameters\n    ----------\n    memory :\n        Memory contents of the EVM.\n    extensions:\n        List of extensions to be made to the memory.\n        Consists of a tuple of start position and size.\n\n    Returns\n    -------\n    extend_memory: `ExtendMemory`\n    \"\"\"\n    size_to_extend = Uint(0)\n    to_be_paid = Uint(0)\n    current_size = Uint(len(memory))\n    for start_position, size in extensions:\n        if size == 0:\n            continue\n        before_size = ceil32(current_size)\n        after_size = ceil32(Uint(start_position) + Uint(size))\n        if after_size <= before_size:\n            continue\n\n        size_to_extend += after_size - before_size\n        already_paid = calculate_memory_gas_cost(before_size)\n        total_cost = calculate_memory_gas_cost(after_size)\n        to_be_paid += total_cost - already_paid\n\n        current_size = after_size\n\n    return ExtendMemory(to_be_paid, size_to_extend)\n\n\ndef calculate_message_call_gas(\n    value: U256,\n    gas: Uint,\n    gas_left: Uint,\n    memory_cost: Uint,\n    extra_gas: Uint,\n    call_stipend: Uint = GAS_CALL_STIPEND,\n) -> MessageCallGas:\n    \"\"\"\n    Calculates the MessageCallGas (cost and stipend) for\n    executing call Opcodes.\n\n    Parameters\n    ----------\n    value:\n        The amount of `ETH` that needs to be transferred.\n    gas :\n        The amount of gas provided to the message-call.\n    gas_left :\n        The amount of gas left in the current frame.\n    memory_cost :\n        The amount needed to extend the memory in the current frame.\n    extra_gas :\n        The amount of gas needed for transferring value + creating a new\n        account inside a message call.\n    call_stipend :\n        The amount of stipend provided to a message call to execute code while\n        transferring value(ETH).\n\n    Returns\n    -------\n    message_call_gas: `MessageCallGas`\n    \"\"\"\n    call_stipend = Uint(0) if value == 0 else call_stipend\n    if gas_left < extra_gas + memory_cost:\n        return MessageCallGas(gas + extra_gas, gas + call_stipend)\n\n    gas = min(gas, max_message_call_gas(gas_left - memory_cost - extra_gas))\n\n    return MessageCallGas(gas + extra_gas, gas + call_stipend)\n\n\ndef max_message_call_gas(gas: Uint) -> Uint:\n    \"\"\"\n    Calculates the maximum gas that is allowed for making a message call\n\n    Parameters\n    ----------\n    gas :\n        The amount of gas provided to the message-call.\n\n    Returns\n    -------\n    max_allowed_message_call_gas: `ethereum.base_types.Uint`\n        The maximum gas allowed for making the message-call.\n    \"\"\"\n    return gas - (gas // 64)\n\n\ndef init_code_cost(init_code_length: Uint) -> Uint:\n    \"\"\"\n    Calculates the gas to be charged for the init code in CREAT*\n    opcodes as well as create transactions.\n\n    Parameters\n    ----------\n    init_code_length :\n        The length of the init code provided to the opcode\n        or a create transaction\n\n    Returns\n    -------\n    init_code_gas: `ethereum.base_types.Uint`\n        The gas to be charged for the init code.\n    \"\"\"\n    return GAS_INIT_CODE_WORD_COST * ceil32(init_code_length) // 32"
    },
    {
      "filename": "src/ethereum/shanghai/vm/gas.py",
      "content": "\"\"\"\nEthereum Virtual Machine (EVM) Gas\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n.. contents:: Table of Contents\n    :backlinks: none\n    :local:\n\nIntroduction\n------------\n\nEVM gas constants and calculators.\n\"\"\"\nfrom dataclasses import dataclass\nfrom typing import List, Tuple\n\nfrom ethereum.base_types import U256, Uint\nfrom ethereum.trace import GasAndRefund, evm_trace\nfrom ethereum.utils.numeric import ceil32\n\nfrom . import Evm\nfrom .exceptions import OutOfGasError\n\nGAS_JUMPDEST = Uint(1)\nGAS_BASE = Uint(2)\nGAS_VERY_LOW = Uint(3)\nGAS_STORAGE_SET = Uint(20000)\nGAS_STORAGE_UPDATE = Uint(5000)\nGAS_STORAGE_CLEAR_REFUND = Uint(4800)\nGAS_LOW = Uint(5)\nGAS_MID = Uint(8)\nGAS_HIGH = Uint(10)\nGAS_EXPONENTIATION = Uint(10)\nGAS_EXPONENTIATION_PER_BYTE = Uint(50)\nGAS_MEMORY = Uint(3)\nGAS_KECCAK256 = Uint(30)\nGAS_KECCAK256_WORD = Uint(6)\nGAS_COPY = Uint(3)\nGAS_BLOCK_HASH = Uint(20)\nGAS_LOG = Uint(375)\nGAS_LOG_DATA = Uint(8)\nGAS_LOG_TOPIC = Uint(375)\nGAS_CREATE = Uint(32000)\nGAS_CODE_DEPOSIT = Uint(200)\nGAS_ZERO = Uint(0)\nGAS_NEW_ACCOUNT = Uint(25000)\nGAS_CALL_VALUE = Uint(9000)\nGAS_CALL_STIPEND = Uint(2300)\nGAS_SELF_DESTRUCT = Uint(5000)\nGAS_SELF_DESTRUCT_NEW_ACCOUNT = Uint(25000)\nGAS_ECRECOVER = Uint(3000)\nGAS_SHA256 = Uint(60)\nGAS_SHA256_WORD = Uint(12)\nGAS_RIPEMD160 = Uint(600)\nGAS_RIPEMD160_WORD = Uint(120)\nGAS_IDENTITY = Uint(15)\nGAS_IDENTITY_WORD = Uint(3)\nGAS_RETURN_DATA_COPY = Uint(3)\nGAS_FAST_STEP = Uint(5)\nGAS_BLAKE2_PER_ROUND = Uint(1)\nGAS_COLD_SLOAD = Uint(2100)\nGAS_COLD_ACCOUNT_ACCESS = Uint(2600)\nGAS_WARM_ACCESS = Uint(100)\nGAS_INIT_CODE_WORD_COST = 2\n\n\n@dataclass\nclass ExtendMemory:\n    \"\"\"\n    Define the parameters for memory extension in opcodes\n\n    `cost`: `ethereum.base_types.Uint`\n        The gas required to perform the extension\n    `expand_by`: `ethereum.base_types.Uint`\n        The size by which the memory will be extended\n    \"\"\"\n\n    cost: Uint\n    expand_by: Uint\n\n\n@dataclass\nclass MessageCallGas:\n    \"\"\"\n    Define the gas cost and stipend for executing the call opcodes.\n\n    `cost`: `ethereum.base_types.Uint`\n        The non-refundable portion of gas reserved for executing the\n        call opcode.\n    `stipend`: `ethereum.base_types.Uint`\n        The portion of gas available to sub-calls that is refundable\n        if not consumed\n    \"\"\"\n\n    cost: Uint\n    stipend: Uint\n\n\ndef charge_gas(evm: Evm, amount: Uint) -> None:\n    \"\"\"\n    Subtracts `amount` from `evm.gas_left`.\n\n    Parameters\n    ----------\n    evm :\n        The current EVM.\n    amount :\n        The amount of gas the current operation requires.\n\n    \"\"\"\n    evm_trace(evm, GasAndRefund(amount))\n\n    if evm.gas_left < amount:\n        raise OutOfGasError\n    else:\n        evm.gas_left -= U256(amount)\n\n\ndef calculate_memory_gas_cost(size_in_bytes: Uint) -> Uint:\n    \"\"\"\n    Calculates the gas cost for allocating memory\n    to the smallest multiple of 32 bytes,\n    such that the allocated size is at least as big as the given size.\n\n    Parameters\n    ----------\n    size_in_bytes :\n        The size of the data in bytes.\n\n    Returns\n    -------\n    total_gas_cost : `ethereum.base_types.Uint`\n        The gas cost for storing data in memory.\n    \"\"\"\n    size_in_words = ceil32(size_in_bytes) // 32\n    linear_cost = size_in_words * GAS_MEMORY\n    quadratic_cost = size_in_words**2 // 512\n    total_gas_cost = linear_cost + quadratic_cost\n    try:\n        return total_gas_cost\n    except ValueError:\n        raise OutOfGasError\n\n\ndef calculate_gas_extend_memory(\n    memory: bytearray, extensions: List[Tuple[U256, U256]]\n) -> ExtendMemory:\n    \"\"\"\n    Calculates the gas amount to extend memory\n\n    Parameters\n    ----------\n    memory :\n        Memory contents of the EVM.\n    extensions:\n        List of extensions to be made to the memory.\n        Consists of a tuple of start position and size.\n\n    Returns\n    -------\n    extend_memory: `ExtendMemory`\n    \"\"\"\n    size_to_extend = Uint(0)\n    to_be_paid = Uint(0)\n    current_size = Uint(len(memory))\n    for start_position, size in extensions:\n        if size == 0:\n            continue\n        before_size = ceil32(current_size)\n        after_size = ceil32(Uint(start_position) + Uint(size))\n        if after_size <= before_size:\n            continue\n\n        size_to_extend += after_size - before_size\n        already_paid = calculate_memory_gas_cost(before_size)\n        total_cost = calculate_memory_gas_cost(after_size)\n        to_be_paid += total_cost - already_paid\n\n        current_size = after_size\n\n    return ExtendMemory(to_be_paid, size_to_extend)\n\n\ndef calculate_message_call_gas(\n    value: U256,\n    gas: Uint,\n    gas_left: Uint,\n    memory_cost: Uint,\n    extra_gas: Uint,\n    call_stipend: Uint = GAS_CALL_STIPEND,\n) -> MessageCallGas:\n    \"\"\"\n    Calculates the MessageCallGas (cost and stipend) for\n    executing call Opcodes.\n\n    Parameters\n    ----------\n    value:\n        The amount of `ETH` that needs to be transferred.\n    gas :\n        The amount of gas provided to the message-call.\n    gas_left :\n        The amount of gas left in the current frame.\n    memory_cost :\n        The amount needed to extend the memory in the current frame.\n    extra_gas :\n        The amount of gas needed for transferring value + creating a new\n        account inside a message call.\n    call_stipend :\n        The amount of stipend provided to a message call to execute code while\n        transferring value(ETH).\n\n    Returns\n    -------\n    message_call_gas: `MessageCallGas`\n    \"\"\"\n    call_stipend = Uint(0) if value == 0 else call_stipend\n    if gas_left < extra_gas + memory_cost:\n        return MessageCallGas(gas + extra_gas, gas + call_stipend)\n\n    gas = min(gas, max_message_call_gas(gas_left - memory_cost - extra_gas))\n\n    return MessageCallGas(gas + extra_gas, gas + call_stipend)\n\n\ndef max_message_call_gas(gas: Uint) -> Uint:\n    \"\"\"\n    Calculates the maximum gas that is allowed for making a message call\n\n    Parameters\n    ----------\n    gas :\n        The amount of gas provided to the message-call.\n\n    Returns\n    -------\n    max_allowed_message_call_gas: `ethereum.base_types.Uint`\n        The maximum gas allowed for making the message-call.\n    \"\"\"\n    return gas - (gas // 64)\n\n\ndef init_code_cost(init_code_length: Uint) -> Uint:\n    \"\"\"\n    Calculates the gas to be charged for the init code in CREAT*\n    opcodes as well as create transactions.\n\n    Parameters\n    ----------\n    init_code_length :\n        The length of the init code provided to the opcode\n        or a create transaction\n\n    Returns\n    -------\n    init_code_gas: `ethereum.base_types.Uint`\n        The gas to be charged for the init code.\n    \"\"\"\n    return GAS_INIT_CODE_WORD_COST * ceil32(init_code_length) // 32"
    },
    {
      "filename": "src/ethereum/shanghai/vm/gas.py",
      "content": "\"\"\"\nEthereum Virtual Machine (EVM) Gas\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n.. contents:: Table of Contents\n    :backlinks: none\n    :local:\n\nIntroduction\n------------\n\nEVM gas constants and calculators.\n\"\"\"\nfrom dataclasses import dataclass\nfrom typing import List, Tuple\n\nfrom ethereum.base_types import U256, Uint\nfrom ethereum.trace import GasAndRefund, evm_trace\nfrom ethereum.utils.numeric import ceil32\n\nfrom . import Evm\nfrom .exceptions import OutOfGasError\n\nGAS_JUMPDEST = Uint(1)\nGAS_BASE = Uint(2)\nGAS_VERY_LOW = Uint(3)\nGAS_STORAGE_SET = Uint(20000)\nGAS_STORAGE_UPDATE = Uint(5000)\nGAS_STORAGE_CLEAR_REFUND = Uint(4800)\nGAS_LOW = Uint(5)\nGAS_MID = Uint(8)\nGAS_HIGH = Uint(10)\nGAS_EXPONENTIATION = Uint(10)\nGAS_EXPONENTIATION_PER_BYTE = Uint(50)\nGAS_MEMORY = Uint(3)\nGAS_KECCAK256 = Uint(30)\nGAS_KECCAK256_WORD = Uint(6)\nGAS_COPY = Uint(3)\nGAS_BLOCK_HASH = Uint(20)\nGAS_LOG = Uint(375)\nGAS_LOG_DATA = Uint(8)\nGAS_LOG_TOPIC = Uint(375)\nGAS_CREATE = Uint(32000)\nGAS_CODE_DEPOSIT = Uint(200)\nGAS_ZERO = Uint(0)\nGAS_NEW_ACCOUNT = Uint(25000)\nGAS_CALL_VALUE = Uint(9000)\nGAS_CALL_STIPEND = Uint(2300)\nGAS_SELF_DESTRUCT = Uint(5000)\nGAS_SELF_DESTRUCT_NEW_ACCOUNT = Uint(25000)\nGAS_ECRECOVER = Uint(3000)\nGAS_SHA256 = Uint(60)\nGAS_SHA256_WORD = Uint(12)\nGAS_RIPEMD160 = Uint(600)\nGAS_RIPEMD160_WORD = Uint(120)\nGAS_IDENTITY = Uint(15)\nGAS_IDENTITY_WORD = Uint(3)\nGAS_RETURN_DATA_COPY = Uint(3)\nGAS_FAST_STEP = Uint(5)\nGAS_BLAKE2_PER_ROUND = Uint(1)\nGAS_COLD_SLOAD = Uint(2100)\nGAS_COLD_ACCOUNT_ACCESS = Uint(2600)\nGAS_WARM_ACCESS = Uint(100)\nGAS_INIT_CODE_WORD_COST = 2\n\n\n@dataclass\nclass ExtendMemory:\n    \"\"\"\n    Define the parameters for memory extension in opcodes\n\n    `cost`: `ethereum.base_types.Uint`\n        The gas required to perform the extension\n    `expand_by`: `ethereum.base_types.Uint`\n        The size by which the memory will be extended\n    \"\"\"\n\n    cost: Uint\n    expand_by: Uint\n\n\n@dataclass\nclass MessageCallGas:\n    \"\"\"\n    Define the gas cost and stipend for executing the call opcodes.\n\n    `cost`: `ethereum.base_types.Uint`\n        The non-refundable portion of gas reserved for executing the\n        call opcode.\n    `stipend`: `ethereum.base_types.Uint`\n        The portion of gas available to sub-calls that is refundable\n        if not consumed\n    \"\"\"\n\n    cost: Uint\n    stipend: Uint\n\n\ndef charge_gas(evm: Evm, amount: Uint) -> None:\n    \"\"\"\n    Subtracts `amount` from `evm.gas_left`.\n\n    Parameters\n    ----------\n    evm :\n        The current EVM.\n    amount :\n        The amount of gas the current operation requires.\n\n    \"\"\"\n    evm_trace(evm, GasAndRefund(amount))\n\n    if evm.gas_left < amount:\n        raise OutOfGasError\n    else:\n        evm.gas_left -= U256(amount)\n\n\ndef calculate_memory_gas_cost(size_in_bytes: Uint) -> Uint:\n    \"\"\"\n    Calculates the gas cost for allocating memory\n    to the smallest multiple of 32 bytes,\n    such that the allocated size is at least as big as the given size.\n\n    Parameters\n    ----------\n    size_in_bytes :\n        The size of the data in bytes.\n\n    Returns\n    -------\n    total_gas_cost : `ethereum.base_types.Uint`\n        The gas cost for storing data in memory.\n    \"\"\"\n    size_in_words = ceil32(size_in_bytes) // 32\n    linear_cost = size_in_words * GAS_MEMORY\n    quadratic_cost = size_in_words**2 // 512\n    total_gas_cost = linear_cost + quadratic_cost\n    try:\n        return total_gas_cost\n    except ValueError:\n        raise OutOfGasError\n\n\ndef calculate_gas_extend_memory(\n    memory: bytearray, extensions: List[Tuple[U256, U256]]\n) -> ExtendMemory:\n    \"\"\"\n    Calculates the gas amount to extend memory\n\n    Parameters\n    ----------\n    memory :\n        Memory contents of the EVM.\n    extensions:\n        List of extensions to be made to the memory.\n        Consists of a tuple of start position and size.\n\n    Returns\n    -------\n    extend_memory: `ExtendMemory`\n    \"\"\"\n    size_to_extend = Uint(0)\n    to_be_paid = Uint(0)\n    current_size = Uint(len(memory))\n    for start_position, size in extensions:\n        if size == 0:\n            continue\n        before_size = ceil32(current_size)\n        after_size = ceil32(Uint(start_position) + Uint(size))\n        if after_size <= before_size:\n            continue\n\n        size_to_extend += after_size - before_size\n        already_paid = calculate_memory_gas_cost(before_size)\n        total_cost = calculate_memory_gas_cost(after_size)\n        to_be_paid += total_cost - already_paid\n\n        current_size = after_size\n\n    return ExtendMemory(to_be_paid, size_to_extend)\n\n\ndef calculate_message_call_gas(\n    value: U256,\n    gas: Uint,\n    gas_left: Uint,\n    memory_cost: Uint,\n    extra_gas: Uint,\n    call_stipend: Uint = GAS_CALL_STIPEND,\n) -> MessageCallGas:\n    \"\"\"\n    Calculates the MessageCallGas (cost and stipend) for\n    executing call Opcodes.\n\n    Parameters\n    ----------\n    value:\n        The amount of `ETH` that needs to be transferred.\n    gas :\n        The amount of gas provided to the message-call.\n    gas_left :\n        The amount of gas left in the current frame.\n    memory_cost :\n        The amount needed to extend the memory in the current frame.\n    extra_gas :\n        The amount of gas needed for transferring value + creating a new\n        account inside a message call.\n    call_stipend :\n        The amount of stipend provided to a message call to execute code while\n        transferring value(ETH).\n\n    Returns\n    -------\n    message_call_gas: `MessageCallGas`\n    \"\"\"\n    call_stipend = Uint(0) if value == 0 else call_stipend\n    if gas_left < extra_gas + memory_cost:\n        return MessageCallGas(gas + extra_gas, gas + call_stipend)\n\n    gas = min(gas, max_message_call_gas(gas_left - memory_cost - extra_gas))\n\n    return MessageCallGas(gas + extra_gas, gas + call_stipend)\n\n\ndef max_message_call_gas(gas: Uint) -> Uint:\n    \"\"\"\n    Calculates the maximum gas that is allowed for making a message call\n\n    Parameters\n    ----------\n    gas :\n        The amount of gas provided to the message-call.\n\n    Returns\n    -------\n    max_allowed_message_call_gas: `ethereum.base_types.Uint`\n        The maximum gas allowed for making the message-call.\n    \"\"\"\n    return gas - (gas // 64)\n\n\ndef init_code_cost(init_code_length: Uint) -> Uint:\n    \"\"\"\n    Calculates the gas to be charged for the init code in CREAT*\n    opcodes as well as create transactions.\n\n    Parameters\n    ----------\n    init_code_length :\n        The length of the init code provided to the opcode\n        or a create transaction\n\n    Returns\n    -------\n    init_code_gas: `ethereum.base_types.Uint`\n        The gas to be charged for the init code.\n    \"\"\"\n    return GAS_INIT_CODE_WORD_COST * ceil32(init_code_length) // 32"
    },
    {
      "filename": "packages/contracts-bedrock/contracts/universal/CrossDomainMessenger.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { SafeCall } from \"../libraries/SafeCall.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { Constants } from \"../libraries/Constants.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n\n/**\n * @custom:legacy\n * @title CrossDomainMessengerLegacySpacer0\n * @notice Contract only exists to add a spacer to the CrossDomainMessenger where the\n *         libAddressManager variable used to exist. Must be the first contract in the inheritance\n *         tree of the CrossDomainMessenger.\n */\ncontract CrossDomainMessengerLegacySpacer0 {\n    /**\n     * @custom:legacy\n     * @custom:spacer libAddressManager\n     * @notice Spacer for backwards compatibility.\n     */\n    address private spacer_0_0_20;\n}\n\n/**\n * @custom:legacy\n * @title CrossDomainMessengerLegacySpacer1\n * @notice Contract only exists to add a spacer to the CrossDomainMessenger where the\n *         PausableUpgradable and OwnableUpgradeable variables used to exist. Must be\n *         the third contract in the inheritance tree of the CrossDomainMessenger.\n */\ncontract CrossDomainMessengerLegacySpacer1 {\n    /**\n     * @custom:legacy\n     * @custom:spacer ContextUpgradable's __gap\n     * @notice Spacer for backwards compatibility. Comes from OpenZeppelin\n     *         ContextUpgradable.\n     *\n     */\n    uint256[50] private spacer_1_0_1600;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer OwnableUpgradeable's _owner\n     * @notice Spacer for backwards compatibility.\n     *         Come from OpenZeppelin OwnableUpgradeable.\n     */\n    address private spacer_51_0_20;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer OwnableUpgradeable's __gap\n     * @notice Spacer for backwards compatibility. Comes from OpenZeppelin\n     *         OwnableUpgradeable.\n     */\n    uint256[49] private spacer_52_0_1568;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer PausableUpgradable's _paused\n     * @notice Spacer for backwards compatibility. Comes from OpenZeppelin\n     *         PausableUpgradable.\n     */\n    bool private spacer_101_0_1;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer PausableUpgradable's __gap\n     * @notice Spacer for backwards compatibility. Comes from OpenZeppelin\n     *         PausableUpgradable.\n     */\n    uint256[49] private spacer_102_0_1568;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer ReentrancyGuardUpgradeable's `_status` field.\n     * @notice Spacer for backwards compatibility.\n     */\n    uint256 private spacer_151_0_32;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer ReentrancyGuardUpgradeable's __gap\n     * @notice Spacer for backwards compatibility.\n     */\n    uint256[49] private spacer_152_0_1568;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer blockedMessages\n     * @notice Spacer for backwards compatibility.\n     */\n    mapping(bytes32 => bool) private spacer_201_0_32;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer relayedMessages\n     * @notice Spacer for backwards compatibility.\n     */\n    mapping(bytes32 => bool) private spacer_202_0_32;\n}\n\n/**\n * @custom:upgradeable\n * @title CrossDomainMessenger\n * @notice CrossDomainMessenger is a base contract that provides the core logic for the L1 and L2\n *         cross-chain messenger contracts. It's designed to be a universal interface that only\n *         needs to be extended slightly to provide low-level message passing functionality on each\n *         chain it's deployed on. Currently only designed for message passing between two paired\n *         chains and does not support one-to-many interactions.\n *\n *         Any changes to this contract MUST result in a semver bump for contracts that inherit it.\n */\nabstract contract CrossDomainMessenger is\n    CrossDomainMessengerLegacySpacer0,\n    Initializable,\n    CrossDomainMessengerLegacySpacer1\n{\n    using SafeERC20 for IERC20;\n    /**\n     * @notice Current message version identifier.\n     */\n    uint16 public constant MESSAGE_VERSION = 1;\n\n    /**\n     * @notice Constant overhead added to the base gas for a message.\n     */\n    uint64 public constant RELAY_CONSTANT_OVERHEAD = 200_000;\n\n    /**\n     * @notice Numerator for dynamic overhead added to the base gas for a message.\n     */\n    uint64 public constant MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR = 64;\n\n    /**\n     * @notice Denominator for dynamic overhead added to the base gas for a message.\n     */\n    uint64 public constant MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR = 63;\n\n    /**\n     * @notice Extra gas added to base gas for each byte of calldata in a message.\n     */\n    uint64 public constant MIN_GAS_CALLDATA_OVERHEAD = 16;\n\n    /**\n     * @notice Gas reserved for performing the external call in `relayMessage`.\n     */\n    uint64 public constant RELAY_CALL_OVERHEAD = 40_000;\n\n    /**\n     * @notice Gas reserved for finalizing the execution of `relayMessage` after the safe call.\n     */\n    uint64 public constant RELAY_RESERVED_GAS = 40_000;\n\n    /**\n     * @notice Gas reserved for the execution between the `hasMinGas` check and the external\n     *         call in `relayMessage`.\n     */\n    uint64 public constant RELAY_GAS_CHECK_BUFFER = 5_000;\n\n    /**\n     * @notice Address of the paired CrossDomainMessenger contract on the other chain.\n     */\n    address public immutable OTHER_MESSENGER;\n\n    /**\n     * @notice Mapping of message hashes to boolean receipt values. Note that a message will only\n     *         be present in this mapping if it has successfully been relayed on this chain, and\n     *         can therefore not be relayed again.\n     */\n    mapping(bytes32 => bool) public successfulMessages;\n\n    /**\n     * @notice Address of the sender of the currently executing message on the other chain. If the\n     *         value of this variable is the default value (0x00000000...dead) then no message is\n     *         currently being executed. Use the xDomainMessageSender getter which will throw an\n     *         error if this is the case.\n     */\n    address internal xDomainMsgSender;\n\n\n    /**\n     * @custom:legacy\n     * @custom:spacer pauseOwner\n     * @notice Spacer for backwards compatibility.\n     */\n    address internal pauseOwner_spacer;\n\n    /**\n     * @notice Nonce for the next message to be sent, without the message version applied. Use the\n     *         messageNonce getter which will insert the message version into the nonce to give you\n     *         the actual nonce to be used for the message.\n     */\n    uint240 internal msgNonce;\n\n    /**\n     * @notice Mapping of message hashes to a boolean if and only if the message has failed to be\n     *         executed at least once. A message will not be present in this mapping if it\n     *         successfully executed on the first attempt.\n     */\n    mapping(bytes32 => bool) public failedMessages;\n\n    /**\n     * @notice Reserve extra slots in the storage layout for future upgrades.\n     *         A gap size of 41 was chosen here, so that the first slot used in a child contract\n     *         would be a multiple of 50.\n     */\n    uint256[41] private __gap;\n\n    /**\n     * @notice Emitted whenever a message is sent to the other chain.\n     *\n     * @param target       Address of the recipient of the message.\n     * @param sender       Address of the sender of the message.\n     * @param message      Message to trigger the recipient address with.\n     * @param messageNonce Unique nonce attached to the message.\n     * @param gasLimit     Minimum gas limit that the message can be executed with.\n     */\n    event SentMessage(\n        address indexed target,\n        address sender,\n        bytes message,\n        uint256 messageNonce,\n        uint256 gasLimit\n    );\n\n    /**\n     * @notice Additional event data to emit, required as of Bedrock. Cannot be merged with the\n     *         SentMessage event without breaking the ABI of this contract, this is good enough.\n     *\n     * @param sender    Address of the sender of the message.\n     * @param mntValue  MNT value sent along with the message to the recipient.\n     * @param ethValue  ETH value sent along with the message to the recipient.\n     */\n    event SentMessageExtension1(address indexed sender, uint256 mntValue,uint256 ethValue);\n\n    /**\n     * @notice Emitted whenever a message is successfully relayed on this chain.\n     *\n     * @param msgHash Hash of the message that was relayed.\n     */\n    event RelayedMessage(bytes32 indexed msgHash);\n\n    /**\n     * @notice Emitted whenever a message fails to be relayed on this chain.\n     *\n     * @param msgHash Hash of the message that failed to be relayed.\n     */\n    event FailedRelayedMessage(bytes32 indexed msgHash);\n\n    /**\n     * @param _otherMessenger Address of the messenger on the paired chain.\n     */\n    constructor(address _otherMessenger) {\n        OTHER_MESSENGER = _otherMessenger;\n    }\n\n    /**\n     * @notice Sends a message to some target address on the other chain. Note that if the call\n     *         always reverts, then the message will be unrelayable, and any ETH sent will be\n     *         permanently locked. The same will occur if the target on the other chain is\n     *         considered unsafe (see the _isUnsafeTarget() function).\n     *\n     * @param _otherSideNativeTokenAmount   Bridge the other side native token amount.\n     * @param _target                       Target contract or wallet address.\n     * @param _message                      Message to trigger the target address with.\n     * @param _minGasLimit                  Minimum gas limit that the message can be executed with.\n     */\n    function sendMessage(\n        uint256 _otherSideNativeTokenAmount,\n        address _target,\n        bytes calldata _message,\n        uint32 _minGasLimit\n    ) external payable virtual {\n        // Triggers a message to the other messenger. Note that the amount of gas provided to the\n        // message is the amount of gas requested by the user PLUS the base gas value. We want to\n        // guarantee the property that the call to the target contract will always have at least\n        // the minimum gas limit specified by the user.\n        _sendMessage(\n            _otherSideNativeTokenAmount,\n            OTHER_MESSENGER,\n            baseGas(_message, _minGasLimit),\n            abi.encodeWithSelector(\n                this.relayMessage.selector,\n                messageNonce(),\n                msg.sender,\n                _target,\n                0,\n                msg.value,\n                _minGasLimit,\n                _message\n            )\n        );\n\n        emit SentMessage(_target, msg.sender, _message, messageNonce(), _minGasLimit);\n        emit SentMessageExtension1(msg.sender, _otherSideNativeTokenAmount, msg.value);\n\n        unchecked {\n            ++msgNonce;\n        }\n    }\n\n    /**\n* @notice Sends a message to some target address on the other chain. Note that if the call\n     *         always reverts, then the message will be unrelayable, and any ETH sent will be\n     *         permanently locked. The same will occur if the target on the other chain is\n     *         considered unsafe (see the _isUnsafeTarget() function).\n     *\n     * @param _target                       Target contract or wallet address.\n     * @param _message                      Message to trigger the target address with.\n     * @param _minGasLimit                  Minimum gas limit that the message can be executed with.\n     */\n    function sendMessage(\n        address _target,\n        bytes calldata _message,\n        uint32 _minGasLimit\n    ) external payable virtual {\n        // Triggers a message to the other messenger. Note that the amount of gas provided to the\n        // message is the amount of gas requested by the user PLUS the base gas value. We want to\n        // guarantee the property that the call to the target contract will always have at least\n        // the minimum gas limit specified by the user.\n        _sendMessage(\n            0,\n            OTHER_MESSENGER,\n            baseGas(_message, _minGasLimit),\n            abi.encodeWithSelector(\n                this.relayMessage.selector,\n                messageNonce(),"
    }
  ]
}