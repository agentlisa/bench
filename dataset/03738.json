{
  "Title": "Deposit will be unavailable if lending pool address will be updated by AAVE",
  "Content": "##### Description\nAt line https://github.com/Grandthrax/yearnV2-generic-lender-strat/blob/55b4d3b03845b7b71b24b50baa30823b3e42ebcf/contracts/GenericLender/GenericAave.sol#L132 the `deposit` function assumes recent approval of token transfer. However, the  `safeApprove()` is called once during contract initialization(https://github.com/Grandthrax/yearnV2-generic-lender-strat/blob/55b4d3b03845b7b71b24b50baa30823b3e42ebcf/contracts/GenericLender/GenericAave.sol#L49) and possible changes of lending pool address is not tracked properly. If lending pool address is updated by AAVE, the `deposit()` will be unavailable/reverted until contract replacement.\n\n##### Recommendation\nCall `safeApprove()` on demand before calling `deposit()` on lending pool.\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/GenericLender/GenericAave.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./GenericLenderBase.sol\";\nimport \"../Interfaces/Aave/IAToken.sol\";\nimport \"../Interfaces/Aave/ILendingPool.sol\";\nimport \"../Interfaces/Aave/IProtocolDataProvider.sol\";\nimport \"../Interfaces/Aave/IReserveInterestRateStrategy.sol\";\nimport \"../Libraries/Aave/DataTypes.sol\";\n\n/********************\n *   A lender plugin for LenderYieldOptimiser for any erc20 asset on Aave (not eth)\n *   Made by SamPriestley.com\n *   https://github.com/Grandthrax/yearnv2/blob/master/contracts/GenericLender/GenericCream.sol\n *\n ********************* */\n\ncontract GenericAave is GenericLenderBase {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    IProtocolDataProvider public constant protocolDataProvider = IProtocolDataProvider(address(0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d));\n    IAToken public aToken;\n\n    constructor(\n        address _strategy,\n        string memory name,\n        IAToken _aToken\n    ) public GenericLenderBase(_strategy, name) {\n        _initialize(_aToken);\n    }\n\n    function initialize(IAToken _aToken) external {\n        _initialize(_aToken);\n    }\n\n    function _initialize(IAToken _aToken) internal {\n        require(address(aToken) == address(0), \"GenericAave already initialized\");\n\n        aToken = _aToken;\n        require(_lendingPool().getReserveData(address(want)).aTokenAddress == address(_aToken), \"WRONG ATOKEN\");\n        IERC20(address(want)).safeApprove(address(_lendingPool()), type(uint256).max);\n    }\n\n    function cloneAaveLender(\n        address _strategy,\n        string memory _name,\n        IAToken _aToken\n    ) external returns (address newLender) {\n        newLender = _clone(_strategy, _name);\n        GenericAave(newLender).initialize(_aToken);\n    }\n\n    function nav() external view override returns (uint256) {\n        return _nav();\n    }\n\n    function _nav() internal view returns (uint256) {\n        return want.balanceOf(address(this)).add(underlyingBalanceStored());\n    }\n\n    function underlyingBalanceStored() public view returns (uint256 balance) {\n        balance = aToken.balanceOf(address(this));\n    }\n\n    function apr() external view override returns (uint256) {\n        return _apr();\n    }\n\n    function _apr() internal view returns (uint256) {\n        return uint256(_lendingPool().getReserveData(address(want)).currentLiquidityRate).div(1e9); // dividing by 1e9 to pass from ray to wad\n    }\n\n    function weightedApr() external view override returns (uint256) {\n        uint256 a = _apr();\n        return a.mul(_nav());\n    }\n\n    function withdraw(uint256 amount) external override management returns (uint256) {\n        return _withdraw(amount);\n    }\n\n    //emergency withdraw. sends balance plus amount to governance\n    function emergencyWithdraw(uint256 amount) external override management {\n        _lendingPool().withdraw(address(want), amount, address(this));\n\n        want.safeTransfer(vault.governance(), want.balanceOf(address(this)));\n    }\n\n    //withdraw an amount including any want balance\n    function _withdraw(uint256 amount) internal returns (uint256) {\n        uint256 balanceUnderlying = aToken.balanceOf(address(this));\n        uint256 looseBalance = want.balanceOf(address(this));\n        uint256 total = balanceUnderlying.add(looseBalance);\n\n        if (amount > total) {\n            //cant withdraw more than we own\n            amount = total;\n        }\n\n        if (looseBalance >= amount) {\n            want.safeTransfer(address(strategy), amount);\n            return amount;\n        }\n\n        //not state changing but OK because of previous call\n        uint256 liquidity = want.balanceOf(address(aToken));\n\n        if (liquidity > 1) {\n            uint256 toWithdraw = amount.sub(looseBalance);\n\n            if (toWithdraw <= liquidity) {\n                //we can take all\n                _lendingPool().withdraw(address(want), toWithdraw, address(this));\n            } else {\n                //take all we can\n                _lendingPool().withdraw(address(want), liquidity, address(this));\n            }\n        }\n        looseBalance = want.balanceOf(address(this));\n        want.safeTransfer(address(strategy), looseBalance);\n        return looseBalance;\n    }\n\n    function deposit() external override management {\n        uint256 balance = want.balanceOf(address(this));\n        _lendingPool().deposit(address(want), balance, address(this), 7);\n    }\n\n    function withdrawAll() external override management returns (bool) {\n        uint256 invested = _nav();\n        uint256 returned = _withdraw(invested);\n        return returned >= invested;\n    }\n\n    function hasAssets() external view override returns (bool) {\n        return aToken.balanceOf(address(this)) > 0;\n    }\n\n    function _lendingPool() internal view returns (ILendingPool lendingPool) {\n        lendingPool = ILendingPool(protocolDataProvider.ADDRESSES_PROVIDER().getLendingPool());\n    }\n\n    function aprAfterDeposit(uint256 extraAmount) external view override returns (uint256) {\n        // i need to calculate new supplyRate after Deposit (when deposit has not been done yet)\n        DataTypes.ReserveData memory reserveData = _lendingPool().getReserveData(address(want));\n\n        (uint256 availableLiquidity, uint256 totalStableDebt, uint256 totalVariableDebt, , , , uint256 averageStableBorrowRate, , , ) =\n            protocolDataProvider.getReserveData(address(want));\n\n        uint256 newLiquidity = availableLiquidity.add(extraAmount);\n\n        (, , , , uint256 reserveFactor, , , , , ) = protocolDataProvider.getReserveConfigurationData(address(want));\n\n        (uint256 newLiquidityRate, , ) =\n            IReserveInterestRateStrategy(reserveData.interestRateStrategyAddress).calculateInterestRates(\n                address(want),\n                newLiquidity,\n                totalStableDebt,\n                totalVariableDebt,\n                averageStableBorrowRate,\n                reserveFactor\n            );\n\n        return newLiquidityRate.div(1e9); // divided by 1e9 to go from Ray to Wad\n    }\n\n    function protectedTokens() internal view override returns (address[] memory) {\n        address[] memory protected = new address[](2);\n        protected[0] = address(want);\n        protected[1] = address(aToken);\n        return protected;\n    }\n}"
    }
  ]
}