{
  "Title": "[G-07]  Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` or `if`-statement",
  "Content": "`require(a <= b); x = b - a` => `require(a <= b); unchecked { x = b - a }`\n\n*There is 1 instance of this issue:*\n```solidity\nFile: paraspace-core/contracts/protocol/libraries/logic/LiquidationLogic.sol\n\n/// @audit if-condition on line 874\n877:                      msg.value - vars.actualLiquidationAmount\n\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/logic/LiquidationLogic.sol#L877\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-11-paraspace",
  "Code": [
    {
      "filename": "paraspace-core/contracts/protocol/libraries/logic/LiquidationLogic.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {IERC20} from \"../../../dependencies/openzeppelin/contracts//IERC20.sol\";\nimport {GPv2SafeERC20} from \"../../../dependencies/gnosis/contracts/GPv2SafeERC20.sol\";\nimport {PercentageMath} from \"../../libraries/math/PercentageMath.sol\";\nimport {WadRayMath} from \"../../libraries/math/WadRayMath.sol\";\nimport {Math} from \"../../../dependencies/openzeppelin/contracts/Math.sol\";\nimport {Helpers} from \"../../libraries/helpers/Helpers.sol\";\nimport {DataTypes} from \"../../libraries/types/DataTypes.sol\";\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {SupplyLogic} from \"./SupplyLogic.sol\";\nimport {ValidationLogic} from \"./ValidationLogic.sol\";\nimport {GenericLogic} from \"./GenericLogic.sol\";\nimport {UserConfiguration} from \"../../libraries/configuration/UserConfiguration.sol\";\nimport {ReserveConfiguration} from \"../../libraries/configuration/ReserveConfiguration.sol\";\nimport {Address} from \"../../../dependencies/openzeppelin/contracts/Address.sol\";\nimport {IPToken} from \"../../../interfaces/IPToken.sol\";\nimport {IWETH} from \"../../../misc/interfaces/IWETH.sol\";\nimport {ICollateralizableERC721} from \"../../../interfaces/ICollateralizableERC721.sol\";\nimport {IAuctionableERC721} from \"../../../interfaces/IAuctionableERC721.sol\";\nimport {INToken} from \"../../../interfaces/INToken.sol\";\nimport {PRBMath} from \"../../../dependencies/math/PRBMath.sol\";\nimport {PRBMathUD60x18} from \"../../../dependencies/math/PRBMathUD60x18.sol\";\nimport {IReserveAuctionStrategy} from \"../../../interfaces/IReserveAuctionStrategy.sol\";\nimport {IVariableDebtToken} from \"../../../interfaces/IVariableDebtToken.sol\";\nimport {IPriceOracleGetter} from \"../../../interfaces/IPriceOracleGetter.sol\";\nimport {IPoolAddressesProvider} from \"../../../interfaces/IPoolAddressesProvider.sol\";\nimport {Errors} from \"../../libraries/helpers/Errors.sol\";\n\n/**\n * @title LiquidationLogic library\n *\n * @notice Implements actions involving management of collateral in the protocol, the main one being the liquidations\n **/\nlibrary LiquidationLogic {\n    using PercentageMath for uint256;\n    using ReserveLogic for DataTypes.ReserveCache;\n    using ReserveLogic for DataTypes.ReserveData;\n    using UserConfiguration for DataTypes.UserConfigurationMap;\n    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n    using PRBMathUD60x18 for uint256;\n    using GPv2SafeERC20 for IERC20;\n\n    /**\n     * @dev Default percentage of borrower's debt to be repaid in a liquidation.\n     * @dev Percentage applied when the users health factor is above `CLOSE_FACTOR_HF_THRESHOLD`\n     * Expressed in bps, a value of 0.5e4 results in 50.00%\n     */\n    uint256 internal constant DEFAULT_LIQUIDATION_CLOSE_FACTOR = 0.5e4;\n\n    /**\n     * @dev Maximum percentage of borrower's debt to be repaid in a liquidation\n     * @dev Percentage applied when the users health factor is below `CLOSE_FACTOR_HF_THRESHOLD`\n     * Expressed in bps, a value of 1e4 results in 100.00%\n     */\n    uint256 public constant MAX_LIQUIDATION_CLOSE_FACTOR = 1e4;\n\n    /**\n     * @dev This constant represents below which health factor value it is possible to liquidate\n     * an amount of debt corresponding to `MAX_LIQUIDATION_CLOSE_FACTOR`.\n     * A value of 0.95e18 results in 95%\n     */\n    uint256 public constant CLOSE_FACTOR_HF_THRESHOLD = 0.95e18;\n\n    // See `IPool` for descriptions\n    event ReserveUsedAsCollateralEnabled(\n        address indexed reserve,\n        address indexed user\n    );\n    event ReserveUsedAsCollateralDisabled(\n        address indexed reserve,\n        address indexed user\n    );\n    event LiquidateERC20(\n        address indexed collateralAsset,\n        address indexed liquidationAsset,\n        address indexed borrower,\n        uint256 liquidationAmount,\n        uint256 liquidatedCollateralAmount,\n        address liquidator,\n        bool receivePToken\n    );\n    event LiquidateERC721(\n        address indexed collateralAsset,\n        address indexed liquidationAsset,\n        address indexed borrower,\n        uint256 liquidationAmount,\n        uint256 liquidatedCollateralTokenId,\n        address liquidator,\n        bool receiveNToken\n    );\n    event AuctionEnded(\n        address indexed user,\n        address indexed collateralAsset,\n        uint256 indexed collateralTokenId\n    );\n\n    struct ExecuteLiquidateLocalVars {\n        //userCollateral from collateralReserve\n        uint256 userCollateral;\n        //userGlobalCollateral from all reserves\n        uint256 userGlobalCollateral;\n        //userDebt from liquadationReserve\n        uint256 userDebt;\n        //userGlobalDebt from all reserves\n        uint256 userGlobalDebt;\n        //actualLiquidationAmount to repay based on collateral\n        uint256 actualLiquidationAmount;\n        //actualCollateral allowed to liquidate\n        uint256 actualCollateralToLiquidate;\n        //liquidationBonusRate from reserve config\n        uint256 liquidationBonus;\n        //user health factor\n        uint256 healthFactor;\n        //liquidation protocol fee to be sent to treasury\n        uint256 liquidationProtocolFee;\n        //liquidation funds payer\n        address payer;\n        //collateral P|N Token\n        address collateralXToken;\n        //auction strategy\n        address auctionStrategyAddress;\n        //liquidation asset reserve id\n        uint16 liquidationAssetReserveId;\n        //whether auction is enabled\n        bool auctionEnabled;\n        //liquidation reserve cache\n        DataTypes.ReserveCache liquidationAssetReserveCache;\n    }\n\n    struct LiquidateParametersLocalVars {\n        uint256 userCollateral;\n        uint256 collateralPrice;\n        uint256 liquidationAssetPrice;\n        uint256 liquidationAssetDecimals;\n        uint256 collateralDecimals;\n        uint256 collateralAssetUnit;\n        uint256 liquidationAssetUnit;\n        uint256 actualCollateralToLiquidate;\n        uint256 actualLiquidationAmount;\n        uint256 actualLiquidationBonus;\n        uint256 liquidationProtocolFeePercentage;\n        uint256 liquidationProtocolFee;\n        // Auction related\n        uint256 auctionMultiplier;\n        uint256 auctionStartTime;\n    }\n\n    /**\n     * @notice Function to liquidate a position if its Health Factor drops below 1. The caller (liquidator)\n     * covers `liquidationAmount` amount of debt of the user getting liquidated, and receives\n     * a proportional amount of the `collateralAsset` plus a bonus to cover market risk\n     * @dev Emits the `LiquidateERC20()` event\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param usersConfig The users configuration mapping that track the supplied/borrowed assets\n     * @param params The additional parameters needed to execute the liquidation function\n     * @return actualLiquidationAmount The actual debt that is getting liquidated.\n     **/\n    function executeLiquidateERC20(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        mapping(address => DataTypes.UserConfigurationMap) storage usersConfig,\n        DataTypes.ExecuteLiquidateParams memory params\n    ) external returns (uint256) {\n        ExecuteLiquidateLocalVars memory vars;\n\n        DataTypes.ReserveData storage collateralReserve = reservesData[\n            params.collateralAsset\n        ];\n        DataTypes.ReserveData storage liquidationAssetReserve = reservesData[\n            params.liquidationAsset\n        ];\n        DataTypes.UserConfigurationMap storage userConfig = usersConfig[\n            params.borrower\n        ];\n        vars.liquidationAssetReserveCache = liquidationAssetReserve.cache();\n        liquidationAssetReserve.updateState(vars.liquidationAssetReserveCache);\n\n        (, , , , , , , vars.healthFactor, , ) = GenericLogic\n            .calculateUserAccountData(\n                reservesData,\n                reservesList,\n                DataTypes.CalculateUserAccountDataParams({\n                    userConfig: userConfig,\n                    reservesCount: params.reservesCount,\n                    user: params.borrower,\n                    oracle: params.priceOracle\n                })\n            );\n\n        (vars.userDebt, vars.actualLiquidationAmount) = _calculateDebt(\n            params,\n            vars\n        );\n\n        (vars.collateralXToken, vars.liquidationBonus) = _getConfigurationData(\n            collateralReserve\n        );\n\n        (\n            vars.userCollateral,\n            vars.actualCollateralToLiquidate,\n            vars.actualLiquidationAmount,\n            vars.liquidationProtocolFee\n        ) = _calculateERC20LiquidationParameters(\n            collateralReserve,\n            params,\n            vars\n        );\n\n        ValidationLogic.validateLiquidateERC20(\n            userConfig,\n            collateralReserve,\n            DataTypes.ValidateLiquidateERC20Params({\n                liquidationAssetReserveCache: vars.liquidationAssetReserveCache,\n                weth: params.weth,\n                liquidationAmount: params.liquidationAmount,\n                actualLiquidationAmount: vars.actualLiquidationAmount,\n                liquidationAsset: params.liquidationAsset,\n                totalDebt: vars.userDebt,\n                healthFactor: vars.healthFactor,\n                priceOracleSentinel: params.priceOracleSentinel\n            })\n        );\n\n        if (vars.userDebt == vars.actualLiquidationAmount) {\n            userConfig.setBorrowing(liquidationAssetReserve.id, false);\n        }\n\n        // If the collateral being liquidated is equal to the user balance,\n        // we set the currency as not being used as collateral anymore\n        if (\n            vars.actualCollateralToLiquidate + vars.liquidationProtocolFee ==\n            vars.userCollateral\n        ) {\n            userConfig.setUsingAsCollateral(collateralReserve.id, false);\n            emit ReserveUsedAsCollateralDisabled(\n                params.collateralAsset,\n                params.borrower\n            );\n        }\n\n        // Transfer fee to treasury if it is non-zero\n        if (vars.liquidationProtocolFee != 0) {\n            IPToken(vars.collateralXToken).transferOnLiquidation(\n                params.borrower,\n                IPToken(vars.collateralXToken).RESERVE_TREASURY_ADDRESS(),\n                vars.liquidationProtocolFee\n            );\n        }\n\n        _burnDebtTokens(liquidationAssetReserve, params, vars);\n\n        if (params.receiveXToken) {\n            _liquidatePTokens(usersConfig, collateralReserve, params, vars);\n        } else {\n            _burnCollateralPTokens(collateralReserve, params, vars);\n        }\n\n        emit LiquidateERC20(\n            params.collateralAsset,\n            params.liquidationAsset,\n            params.borrower,\n            vars.actualLiquidationAmount,\n            vars.actualCollateralToLiquidate,\n            params.liquidator,\n            params.receiveXToken\n        );\n\n        return vars.actualLiquidationAmount;\n    }\n\n    /**\n     * @notice Function to liquidate an ERC721 of a position if its Health Factor drops below 1. The caller (liquidator)\n     * covers `liquidationAmount` amount of debt of the user getting liquidated, and receives\n     * a proportional tokenId of the `collateralAsset` minus a bonus to cover market risk\n     * @dev Emits the `LiquidateERC721()` event\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param usersConfig The users configuration mapping that track the supplied/borrowed assets\n     * @param params The additional parameters needed to execute the liquidation function\n     * @return actualLiquidationAmount The actual liquidation amount.\n     **/\n    function executeLiquidateERC721(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        mapping(address => DataTypes.UserConfigurationMap) storage usersConfig,\n        DataTypes.ExecuteLiquidateParams memory params\n    ) external returns (uint256) {\n        ExecuteLiquidateLocalVars memory vars;\n\n        DataTypes.ReserveData storage collateralReserve = reservesData[\n            params.collateralAsset\n        ];\n        DataTypes.ReserveData storage liquidationAssetReserve = reservesData[\n            params.liquidationAsset\n        ];\n        DataTypes.UserConfigurationMap storage userConfig = usersConfig[\n            params.borrower\n        ];\n\n        vars.liquidationAssetReserveId = liquidationAssetReserve.id;\n        vars.liquidationAssetReserveCache = liquidationAssetReserve.cache();\n        // liquidationAssetReserve.updateState(vars.liquidationAssetReserveCache);\n\n        vars.auctionStrategyAddress = collateralReserve.auctionStrategyAddress;\n        vars.auctionEnabled = vars.auctionStrategyAddress != address(0);\n\n        (\n            vars.userGlobalCollateral,\n            ,\n            vars.userGlobalDebt, //in base currency\n            ,\n            ,\n            ,\n            ,\n            ,\n            vars.healthFactor,\n\n        ) = GenericLogic.calculateUserAccountData(\n            reservesData,\n            reservesList,\n            DataTypes.CalculateUserAccountDataParams({\n                userConfig: userConfig,\n                reservesCount: params.reservesCount,\n                user: params.borrower,\n                oracle: params.priceOracle\n            })\n        );\n\n        (vars.collateralXToken, vars.liquidationBonus) = _getConfigurationData(\n            collateralReserve\n        );\n        if (vars.auctionEnabled) {\n            vars.liquidationBonus = PercentageMath.PERCENTAGE_FACTOR;\n        }\n\n        (\n            vars.userCollateral,\n            vars.actualLiquidationAmount,\n            vars.liquidationProtocolFee,\n            vars.userGlobalDebt\n        ) = _calculateERC721LiquidationParameters(\n            collateralReserve,\n            params,\n            vars\n        );\n\n        ValidationLogic.validateLiquidateERC721(\n            reservesData,\n            userConfig,\n            collateralReserve,\n            DataTypes.ValidateLiquidateERC721Params({\n                liquidationAssetReserveCache: vars.liquidationAssetReserveCache,\n                liquidator: params.liquidator,\n                borrower: params.borrower,\n                globalDebt: vars.userGlobalDebt,\n                actualLiquidationAmount: vars.actualLiquidationAmount,\n                maxLiquidationAmount: params.liquidationAmount,\n                healthFactor: vars.healthFactor,\n                priceOracleSentinel: params.priceOracleSentinel,\n                collateralAsset: params.collateralAsset,\n                tokenId: params.collateralTokenId,\n                xTokenAddress: vars.collateralXToken,\n                auctionEnabled: vars.auctionEnabled,\n                auctionRecoveryHealthFactor: params.auctionRecoveryHealthFactor\n            })\n        );\n\n        if (vars.auctionEnabled) {\n            IAuctionableERC721(vars.collateralXToken).endAuction(\n                params.collateralTokenId\n            );\n            emit AuctionEnded(\n                params.borrower,\n                params.collateralAsset,\n                params.collateralTokenId\n            );\n        }\n\n        _supplyNewCollateral(reservesData, userConfig, params, vars);\n\n        // If the collateral being liquidated is equal to the user balance,\n        // we set the currency as not being used as collateral anymore\n        if (vars.userCollateral == 1) {\n            userConfig.setUsingAsCollateral(collateralReserve.id, false);\n            emit ReserveUsedAsCollateralDisabled(\n                params.collateralAsset,\n                params.borrower\n            );\n        }\n\n        // Transfer fee to treasury if it is non-zero\n        if (vars.liquidationProtocolFee != 0) {\n            IERC20(params.liquidationAsset).safeTransferFrom(\n                vars.payer,\n                IPToken(vars.liquidationAssetReserveCache.xTokenAddress)\n                    .RESERVE_TREASURY_ADDRESS(),\n                vars.liquidationProtocolFee\n            );\n        }\n\n        if (params.receiveXToken) {\n            INToken(vars.collateralXToken).transferOnLiquidation(\n                params.borrower,\n                params.liquidator,\n                params.collateralTokenId\n            );\n        } else {\n            _burnCollateralNTokens(params, vars);\n        }\n\n        emit LiquidateERC721(\n            params.collateralAsset,\n            params.liquidationAsset,\n            params.borrower,\n            vars.actualLiquidationAmount,\n            params.collateralTokenId,\n            params.liquidator,\n            params.receiveXToken\n        );\n\n        return vars.actualLiquidationAmount;\n    }\n\n    /**\n     * @notice Burns the collateral xTokens and transfers the underlying to the liquidator.\n     * @dev   The function also updates the state and the interest rate of the collateral reserve.\n     * @param collateralReserve The data of the collateral reserve\n     * @param params The additional parameters needed to execute the liquidation function\n     * @param vars The executeLiquidateERC20() function local vars\n     */\n    function _burnCollateralPTokens(\n        DataTypes.ReserveData storage collateralReserve,\n        DataTypes.ExecuteLiquidateParams memory params,\n        ExecuteLiquidateLocalVars memory vars\n    ) internal {\n        DataTypes.ReserveCache memory collateralReserveCache = collateralReserve\n            .cache();\n        collateralReserve.updateState(collateralReserveCache);\n        collateralReserve.updateInterestRates(\n            collateralReserveCache,\n            params.collateralAsset,\n            0,\n            vars.actualCollateralToLiquidate\n        );\n\n        // Burn the equivalent amount of xToken, sending the underlying to the liquidator\n        IPToken(vars.collateralXToken).burn(\n            params.borrower,\n            params.liquidator,\n            vars.actualCollateralToLiquidate,\n            collateralReserveCache.nextLiquidityIndex\n        );\n    }\n\n    /**\n     * @notice Burns the collateral xTokens and transfers the underlying to the liquidator.\n     * @dev   The function also updates the state and the interest rate of the collateral reserve.\n     * @param params The additional parameters needed to execute the liquidation function\n     * @param vars The executeLiquidateERC20() function local vars\n     */\n    function _burnCollateralNTokens(\n        DataTypes.ExecuteLiquidateParams memory params,\n        ExecuteLiquidateLocalVars memory vars\n    ) internal {\n        // Burn the equivalent amount of xToken, sending the underlying to the liquidator\n        uint256[] memory tokenIds = new uint256[](1);\n        tokenIds[0] = params.collateralTokenId;\n        INToken(vars.collateralXToken).burn(\n            params.borrower,\n            params.liquidator,\n            tokenIds\n        );\n    }\n\n    /**\n     * @notice Liquidates the user xTokens by transferring them to the liquidator.\n     * @dev   The function also checks the state of the liquidator and activates the xToken as collateral\n     *        as in standard transfers if the isolation mode constraints are respected.\n     * @param usersConfig The users configuration mapping that track the supplied/borrowed assets\n     * @param collateralReserve The data of the collateral reserve\n     * @param params The additional parameters needed to execute the liquidation function\n     * @param vars The executeLiquidateERC20() function local vars\n     */\n    function _liquidatePTokens(\n        mapping(address => DataTypes.UserConfigurationMap) storage usersConfig,\n        DataTypes.ReserveData storage collateralReserve,\n        DataTypes.ExecuteLiquidateParams memory params,\n        ExecuteLiquidateLocalVars memory vars\n    ) internal {\n        IPToken pToken = IPToken(vars.collateralXToken);\n        uint256 liquidatorPreviousPTokenBalance = pToken.balanceOf(\n            params.liquidator\n        );\n        pToken.transferOnLiquidation(\n            params.borrower,\n            params.liquidator,\n            vars.actualCollateralToLiquidate\n        );\n\n        if (liquidatorPreviousPTokenBalance == 0) {\n            DataTypes.UserConfigurationMap\n                storage liquidatorConfig = usersConfig[params.liquidator];\n\n            liquidatorConfig.setUsingAsCollateral(collateralReserve.id, true);\n            emit ReserveUsedAsCollateralEnabled(\n                params.collateralAsset,\n                params.liquidator\n            );\n        }\n    }\n\n    /**\n     * @notice Burns the debt tokens of the user up to the amount being repaid by the liquidator.\n     * @dev The function alters the `liquidationAssetReserveCache` state in `vars` to update the debt related data.\n     * @param liquidationAssetReserve The data of the liquidation reserve\n     * @param params The additional parameters needed to execute the liquidation function\n     * @param vars the executeLiquidateERC20() function local vars\n     */\n    function _burnDebtTokens(\n        DataTypes.ReserveData storage liquidationAssetReserve,\n        DataTypes.ExecuteLiquidateParams memory params,\n        ExecuteLiquidateLocalVars memory vars\n    ) internal {\n        _depositETH(params, vars);\n\n        // Transfers the debt asset being repaid to the xToken, where the liquidity is kept\n        IERC20(params.liquidationAsset).safeTransferFrom(\n            vars.payer,\n            vars.liquidationAssetReserveCache.xTokenAddress,\n            vars.actualLiquidationAmount\n        );\n        // Handle payment\n        IPToken(vars.liquidationAssetReserveCache.xTokenAddress)\n            .handleRepayment(params.liquidator, vars.actualLiquidationAmount);\n        // Burn borrower's debt token\n        vars\n            .liquidationAssetReserveCache\n            .nextScaledVariableDebt = IVariableDebtToken(\n            vars.liquidationAssetReserveCache.variableDebtTokenAddress\n        ).burn(\n                params.borrower,\n                vars.actualLiquidationAmount,\n                vars.liquidationAssetReserveCache.nextVariableBorrowIndex\n            );\n        // Update borrow & supply rate\n        liquidationAssetReserve.updateInterestRates(\n            vars.liquidationAssetReserveCache,\n            params.liquidationAsset,\n            vars.actualLiquidationAmount,\n            0\n        );\n    }\n\n    /**\n     * @notice Supply new collateral for taking out of borrower's another collateral\n     * @param userConfig The user configuration that track the supplied/borrowed assets\n     * @param params The additional parameters needed to execute the liquidation function\n     * @param vars the executeLiquidateERC20() function local vars\n     */\n    function _supplyNewCollateral(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        DataTypes.UserConfigurationMap storage userConfig,\n        DataTypes.ExecuteLiquidateParams memory params,\n        ExecuteLiquidateLocalVars memory vars\n    ) internal {\n        _depositETH(params, vars);\n\n        SupplyLogic.executeSupply(\n            reservesData,\n            userConfig,\n            DataTypes.ExecuteSupplyParams({\n                asset: params.liquidationAsset,\n                amount: vars.actualLiquidationAmount -\n                    vars.liquidationProtocolFee,\n                onBehalfOf: params.borrower,\n                payer: vars.payer,\n                referralCode: 0\n            })\n        );\n\n        if (!userConfig.isUsingAsCollateral(vars.liquidationAssetReserveId)) {\n            userConfig.setUsingAsCollateral(\n                vars.liquidationAssetReserveId,\n                true\n            );\n            emit ReserveUsedAsCollateralEnabled(\n                params.liquidationAsset,\n                params.borrower\n            );\n        }\n    }\n\n    /**\n     * @notice Calculates the total debt of the user and the actual amount to liquidate depending on the health factor\n     * and corresponding close factor. we are always using max closing factor in this version\n     * @param params The additional parameters needed to execute the liquidation function\n     * @param vars the executeLiquidateERC20() function local vars\n     * @return The total debt of the user\n     * @return The actual debt that is getting liquidated. If liquidation amount passed in by the liquidator is greater then the total user debt, then use the user total debt as the actual debt getting liquidated. If the user total debt is greater than the liquidation amount getting passed in by the liquidator, then use the liquidation amount the user is passing in.\n     */\n    function _calculateDebt(\n        DataTypes.ExecuteLiquidateParams memory params,\n        ExecuteLiquidateLocalVars memory vars\n    ) internal view returns (uint256, uint256) {\n        // userDebt = debt of the borrowed position needed for liquidation\n        uint256 userDebt = Helpers.getUserCurrentDebt(\n            params.borrower,\n            vars.liquidationAssetReserveCache.variableDebtTokenAddress\n        );\n\n        uint256 closeFactor = vars.healthFactor > CLOSE_FACTOR_HF_THRESHOLD\n            ? DEFAULT_LIQUIDATION_CLOSE_FACTOR\n            : MAX_LIQUIDATION_CLOSE_FACTOR;\n\n        uint256 maxLiquidatableDebt = userDebt.percentMul(closeFactor);\n\n        uint256 actualLiquidationAmount = Math.min(\n            params.liquidationAmount,\n            maxLiquidatableDebt\n        );\n\n        return (userDebt, actualLiquidationAmount);\n    }\n\n    /**\n     * @notice Returns the configuration data for the debt and the collateral reserves.\n     * @param collateralReserve The data of the collateral reserve\n     * @return The collateral xToken\n     * @return The liquidation bonus to apply to the collateral\n     */\n    function _getConfigurationData(\n        DataTypes.ReserveData storage collateralReserve\n    ) internal view returns (address, uint256) {\n        address collateralXToken = collateralReserve.xTokenAddress;\n        uint256 liquidationBonus = collateralReserve\n            .configuration\n            .getLiquidationBonus();\n\n        return (collateralXToken, liquidationBonus);\n    }\n\n    /**\n     * @notice Calculates how much of a specific collateral can be liquidated, given\n     * a certain amount of debt asset.\n     * @dev This function needs to be called after all the checks to validate the liquidation have been performed,\n     *   otherwise it might fail.\n     * @param collateralReserve The data of the collateral reserve\n     * @param params The additional parameters needed to execute the liquidation function\n     * @param superVars the executeLiquidateERC20() function local vars\n     * @return The user collateral balance\n     * @return The maximum amount that is possible to liquidate given all the liquidation constraints (user balance, close factor)\n     * @return The amount to repay with the liquidation\n     * @return The fee taken from the liquidation bonus amount to be paid to the protocol\n     **/\n    function _calculateERC20LiquidationParameters(\n        DataTypes.ReserveData storage collateralReserve,\n        DataTypes.ExecuteLiquidateParams memory params,\n        ExecuteLiquidateLocalVars memory superVars\n    )\n        internal\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        LiquidateParametersLocalVars memory vars;\n\n        vars.userCollateral = IPToken(superVars.collateralXToken).balanceOf(\n            params.borrower\n        );\n        vars.collateralPrice = IPriceOracleGetter(params.priceOracle)\n            .getAssetPrice(params.collateralAsset);\n        vars.liquidationAssetPrice = IPriceOracleGetter(params.priceOracle)\n            .getAssetPrice(params.liquidationAsset);\n\n        vars.collateralDecimals = collateralReserve.configuration.getDecimals();\n        vars.liquidationAssetDecimals = superVars\n            .liquidationAssetReserveCache\n            .reserveConfiguration\n            .getDecimals();\n\n        unchecked {\n            vars.collateralAssetUnit = 10**vars.collateralDecimals;\n            vars.liquidationAssetUnit = 10**vars.liquidationAssetDecimals;\n        }\n\n        vars.liquidationProtocolFeePercentage = collateralReserve\n            .configuration\n            .getLiquidationProtocolFee();\n\n        uint256 maxCollateralToLiquidate = ((vars.liquidationAssetPrice *\n            superVars.actualLiquidationAmount *\n            vars.collateralAssetUnit) /\n            (vars.collateralPrice * vars.liquidationAssetUnit)).percentMul(\n                superVars.liquidationBonus\n            );\n\n        if (maxCollateralToLiquidate > vars.userCollateral) {\n            vars.actualCollateralToLiquidate = vars.userCollateral;\n            vars.actualLiquidationAmount = (\n                ((vars.collateralPrice *\n                    vars.actualCollateralToLiquidate *\n                    vars.liquidationAssetUnit) /\n                    (vars.liquidationAssetPrice * vars.collateralAssetUnit))\n            ).percentDiv(superVars.liquidationBonus);\n        } else {\n            vars.actualCollateralToLiquidate = maxCollateralToLiquidate;\n            vars.actualLiquidationAmount = superVars.actualLiquidationAmount;\n        }\n\n        if (vars.liquidationProtocolFeePercentage != 0) {\n            uint256 bonusCollateral = vars.actualCollateralToLiquidate -\n                vars.actualCollateralToLiquidate.percentDiv(\n                    superVars.liquidationBonus\n                );\n\n            vars.liquidationProtocolFee = bonusCollateral.percentMul(\n                vars.liquidationProtocolFeePercentage\n            );\n\n            return (\n                vars.userCollateral,\n                vars.actualCollateralToLiquidate - vars.liquidationProtocolFee,\n                vars.actualLiquidationAmount,\n                vars.liquidationProtocolFee\n            );\n        } else {\n            return (\n                vars.userCollateral,\n                vars.actualCollateralToLiquidate,\n                vars.actualLiquidationAmount,\n                0\n            );\n        }\n    }\n\n    /**\n     * @notice Calculates how much of a specific collateral can be liquidated, given\n     * a certain amount of debt asset.\n     * @dev This function needs to be called after all the checks to validate the liquidation have been performed,\n     *   otherwise it might fail.\n     * @param collateralReserve The data of the collateral reserve\n     * @param params The additional parameters needed to execute the liquidation function\n     * @param superVars the executeLiquidateERC20() function local vars\n     * @return The user collateral balance\n     * @return The discounted nft price + the liquidationProtocolFee\n     * @return The liquidationProtocolFee\n     * @return The debt price you are paying in (for example, USD or ETH)\n     **/\n    function _calculateERC721LiquidationParameters(\n        DataTypes.ReserveData storage collateralReserve,\n        DataTypes.ExecuteLiquidateParams memory params,\n        ExecuteLiquidateLocalVars memory superVars\n    )\n        internal\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        LiquidateParametersLocalVars memory vars;\n\n        vars.userCollateral = ICollateralizableERC721(\n            superVars.collateralXToken\n        ).collateralizedBalanceOf(params.borrower);\n\n        // price of the asset that is used as collateral\n        if (INToken(superVars.collateralXToken).getAtomicPricingConfig()) {\n            vars.collateralPrice = IPriceOracleGetter(params.priceOracle)\n                .getTokenPrice(\n                    params.collateralAsset,\n                    params.collateralTokenId\n                );\n        } else {\n            vars.collateralPrice = IPriceOracleGetter(params.priceOracle)\n                .getAssetPrice(params.collateralAsset);\n        }\n\n        if (\n            superVars.auctionEnabled &&\n            IAuctionableERC721(superVars.collateralXToken).isAuctioned(\n                params.collateralTokenId\n            )\n        ) {\n            vars.auctionStartTime = IAuctionableERC721(\n                superVars.collateralXToken\n            ).getAuctionData(params.collateralTokenId).startTime;\n            vars.auctionMultiplier = IReserveAuctionStrategy(\n                superVars.auctionStrategyAddress\n            ).calculateAuctionPriceMultiplier(\n                    vars.auctionStartTime,\n                    block.timestamp\n                );\n            vars.coll"
    }
  ]
}