{
  "Title": "[M-04] NFT Owner can stuck Crowdfund user funds",
  "Content": "# Lines of code\n\nhttps://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/crowdfund/AuctionCrowdfund.sol#L236\n\n\n# Vulnerability details\n\n## Impact\nConsider a scenario where few users contributed in auction but noone has placed any bid due to reason like NFT price crash etc. So there was 0 bid, nft owner could seize the crowdfund users fund until they pay a ransom amount as shown below.\n\n## Proof of Concept\n1. NFT N auction is going on\n2. CrowdFund users have contributed 100 amount for this auction\n3. Bidding has not been done yet\n4. A news came for this NFT owner which leads to crashing of this NFT price\n5. CrowdFund users are happy that they have not bided and are just waiting for auction to complete so that they can get there refund\n6. NFT owner realizing this blackmails the CrowdFund users to send him amount 50 or else he would send this worthless NFT to the Crowdfund Auction contract basically stucking all crowdfund users fund. CrowdFund users ignore this and simply wait for auction to end\n7. Once auction completes [finalize function](https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/crowdfund/AuctionCrowdfund.sol#L196) is called\n\n```\nfunction finalize(FixedGovernanceOpts memory governanceOpts)\n        external\n        onlyDelegateCall\n        returns (Party party_)\n    {\n...\n if (nftContract.safeOwnerOf(nftTokenId) == address(this)) {\n            if (lastBid_ == 0) {\n                // The NFT was gifted to us. Everyone who contributed wins.\n                lastBid_ = totalContributions;\n                if (lastBid_ == 0) {\n                    // Nobody ever contributed. The NFT is effectively burned.\n                    revert NoContributionsError();\n                }\n                lastBid = lastBid_;\n            }\n            // Create a governance party around the NFT.\n            party_ = _createParty(\n                _getPartyFactory(),\n                governanceOpts,\n                nftContract,\n                nftTokenId\n            );\n            emit Won(lastBid_, party_);\n        } \n...\n}\n```\n\n8. Before calling finalize the lastBid was 0 since no one has bid on this auction but lets see what happens on calling finalize\n\n9. Since NFT owner has transferred NFT to this contract so below statement holds true and lastBid_ is also 0 since no one has bided\n\n```\nif (lastBid_ == 0) {\n                lastBid_ = totalContributions;\n```\n\n10. This means now lastBid_ is changed to totalContributions which is 100 so crowdfund users funds will not be refunded and they will end up with non needed NFT. \n\n## Recommended Mitigation Steps\nRemove the line lastBid_ = totalContributions; and let it be the last bid amount which crowdfund users actually bided with.",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-09-partydao-contest",
  "Code": [
    {
      "filename": "contracts/crowdfund/AuctionCrowdfund.sol",
      "content": "// SPDX-License-Identifier: Beta Software\npragma solidity ^0.8;\n\nimport \"../tokens/IERC721.sol\";\nimport \"../party/Party.sol\";\nimport \"../utils/Implementation.sol\";\nimport \"../utils/LibSafeERC721.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../gatekeepers/IGateKeeper.sol\";\n\nimport \"../market-wrapper/IMarketWrapper.sol\";\nimport \"./Crowdfund.sol\";\n\n/// @notice A crowdfund that can repeatedly bid on an auction for a specific NFT\n///         (i.e. with a known token ID) until it wins.\ncontract AuctionCrowdfund is Implementation, Crowdfund {\n    using LibSafeERC721 for IERC721;\n    using LibSafeCast for uint256;\n    using LibRawResult for bytes;\n\n    enum AuctionCrowdfundStatus {\n        // The crowdfund has been created and contributions can be made and\n        // acquisition functions may be called.\n        Active,\n        // An temporary state set by the contract during complex operations to\n        // act as a reentrancy guard.\n        Busy,\n        // The crowdfund is over and has either won or lost.\n        Finalized\n    }\n\n    struct AuctionCrowdfundOptions {\n        // The name of the crowdfund.\n        // This will also carry over to the governance party.\n        string name;\n        // The token symbol for both the crowdfund and the governance NFTs.\n        string symbol;\n        // The auction ID (specific to the IMarketWrapper).\n        uint256 auctionId;\n        // IMarketWrapper contract that handles interactions with auction markets.\n        IMarketWrapper market;\n        // The ERC721 contract of the NFT being bought.\n        IERC721 nftContract;\n        // ID of the NFT being bought.\n        uint256 nftTokenId;\n        // How long this crowdfund has to bid on the NFT, in seconds.\n        uint40 duration;\n        // Maximum bid allowed.\n        uint96 maximumBid;\n        // An address that receives a portion of the final voting power\n        // when the party transitions into governance.\n        address payable splitRecipient;\n        // What percentage (in bps) of the final total voting power `splitRecipient`\n        // receives.\n        uint16 splitBps;\n        // If ETH is attached during deployment, it will be interpreted\n        // as a contribution. This is who gets credit for that contribution.\n        address initialContributor;\n        // If there is an initial contribution, this is who they will delegate their\n        // voting power to when the crowdfund transitions to governance.\n        address initialDelegate;\n        // The gatekeeper contract to use (if non-null) to restrict who can\n        // contribute to this crowdfund.\n        IGateKeeper gateKeeper;\n        // The gate ID within the gateKeeper contract to use.\n        bytes12 gateKeeperId;\n        // Fixed governance options (i.e. cannot be changed) that the governance\n        // `Party` will be created with if the crowdfund succeeds.\n        FixedGovernanceOpts governanceOpts;\n    }\n\n    event Bid(uint256 bidAmount);\n    event Won(uint256 bid, Party party);\n    event Lost();\n\n    error InvalidAuctionIdError();\n    error AuctionFinalizedError(uint256 auctionId);\n    error AlreadyHighestBidderError();\n    error ExceedsMaximumBidError(uint256 bidAmount, uint256 maximumBid);\n    error NoContributionsError();\n    error AuctionNotExpiredError();\n\n    /// @notice The NFT contract to buy.\n    IERC721 public nftContract;\n    /// @notice The NFT token ID to buy.\n    uint256 public nftTokenId;\n    /// @notice An adapter for the auction market (Zora, OpenSea, etc).\n    /// @dev This will be delegatecalled into to execute bids.\n    IMarketWrapper public market;\n    /// @notice The auction ID to identify the auction on the `market`.\n    uint256 public auctionId;\n    /// @notice The maximum possible bid this crowdfund can make.\n    uint96 public maximumBid;\n    /// @notice The last successful bid() amount.\n    uint96 public lastBid;\n    /// @notice When this crowdfund expires. If the NFT has not been bought\n    ///         by this time, participants can withdraw their contributions.\n    uint40 public expiry;\n    // Track extra status of the crowdfund specific to bids.\n    AuctionCrowdfundStatus private _bidStatus;\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) Crowdfund(globals) {}\n\n    /// @notice Initializer to be delegatecalled by `Proxy` constructor. Will\n    ///         revert if called outside the constructor.\n    /// @param opts Options used to initialize the crowdfund. These are fixed\n    ///             and cannot be changed later.\n    function initialize(AuctionCrowdfundOptions memory opts)\n        external\n        payable\n        onlyConstructor\n    {\n        nftContract = opts.nftContract;\n        nftTokenId = opts.nftTokenId;\n        market = opts.market;\n        expiry = uint40(opts.duration + block.timestamp);\n        auctionId = opts.auctionId;\n        maximumBid = opts.maximumBid;\n        Crowdfund._initialize(CrowdfundOptions({\n            name: opts.name,\n            symbol: opts.symbol,\n            splitRecipient: opts.splitRecipient,\n            splitBps: opts.splitBps,\n            initialContributor: opts.initialContributor,\n            initialDelegate: opts.initialDelegate,\n            gateKeeper: opts.gateKeeper,\n            gateKeeperId: opts.gateKeeperId,\n            governanceOpts: opts.governanceOpts\n        }));\n\n        // Check that the auction can be bid on and is valid.\n        if (!market.auctionIdMatchesToken(\n            opts.auctionId,\n            address(opts.nftContract),\n            opts.nftTokenId))\n        {\n            revert InvalidAuctionIdError();\n        }\n    }\n\n    /// @notice Accept naked ETH, e.g., if an auction needs to return ETH to us.\n    receive() external payable {}\n\n    /// @notice Place a bid on the NFT using the funds in this crowdfund,\n    ///         placing the minimum possible bid to be the highest bidder, up to\n    ///         `maximumBid`.\n    function bid() external onlyDelegateCall {\n        // Check that the auction is still active.\n        {\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\n            if (lc != CrowdfundLifecycle.Active) {\n                revert WrongLifecycleError(lc);\n            }\n        }\n        // Mark as busy to prevent `burn()`, `bid()`, and `contribute()`\n        // getting called because this will result in a `CrowdfundLifecycle.Busy`.\n        _bidStatus = AuctionCrowdfundStatus.Busy;\n        // Make sure the auction is not finalized.\n        uint256 auctionId_ = auctionId;\n        if (market.isFinalized(auctionId_)) {\n            revert AuctionFinalizedError(auctionId_);\n        }\n        // Only bid if we are not already the highest bidder.\n        if (market.getCurrentHighestBidder(auctionId_) == address(this)) {\n            revert AlreadyHighestBidderError();\n        }\n        // Get the minimum necessary bid to be the highest bidder.\n        uint96 bidAmount = market.getMinimumBid(auctionId_).safeCastUint256ToUint96();\n        // Make sure the bid is less than the maximum bid.\n        if (bidAmount > maximumBid) {\n            revert ExceedsMaximumBidError(bidAmount, maximumBid);\n        }\n        lastBid = bidAmount;\n        // No need to check that we have `bidAmount` since this will attempt to\n        // transfer `bidAmount` ETH to the auction platform.\n        (bool s, bytes memory r) = address(market).delegatecall(abi.encodeCall(\n            IMarketWrapper.bid,\n            (auctionId_, bidAmount)\n        ));\n        if (!s) {\n            r.rawRevert();\n        }\n        emit Bid(bidAmount);\n\n        _bidStatus = AuctionCrowdfundStatus.Active;\n    }\n\n    /// @notice Calls finalize() on the market adapter, which will claim the NFT\n    ///         (if necessary) if we won, or recover our bid (if necessary)\n    ///         if we lost. If we won, a governance party will also be created.\n    /// @param governanceOpts The options used to initialize governance in the\n    ///                       `Party` instance created if the crowdfund wins.\n    /// @return party_ Address of the `Party` instance created if successful.\n    function finalize(FixedGovernanceOpts memory governanceOpts)\n        external\n        onlyDelegateCall\n        returns (Party party_)\n    {\n        // Check that the auction is still active and has not passed the `expiry` time.\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\n        if (lc != CrowdfundLifecycle.Active && lc != CrowdfundLifecycle.Expired) {\n            revert WrongLifecycleError(lc);\n        }\n        // Mark as busy to prevent burn(), bid(), and contribute()\n        // getting called because this will result in a `CrowdfundLifecycle.Busy`.\n        _bidStatus = AuctionCrowdfundStatus.Busy;\n\n        uint96 lastBid_ = lastBid;\n        // Only finalize on the market if we placed a bid.\n        if (lastBid_ != 0) {\n            uint256 auctionId_ = auctionId;\n            // Finalize the auction if it isn't finalized.\n            if (!market.isFinalized(auctionId_)) {\n                // Note that even if this crowdfund has expired but the auction is still\n                // ongoing, this call can fail and block finalization until the auction ends.\n                (bool s, bytes memory r) = address(market).call(abi.encodeCall(\n                    IMarketWrapper.finalize,\n                    auctionId_\n                ));\n                if (!s) {\n                    r.rawRevert();\n                }\n            }\n        } else {\n            // If we never placed a bid, the auction must have expired.\n            if (lc != CrowdfundLifecycle.Expired) {\n                revert AuctionNotExpiredError();\n            }\n        }\n        // Are we now in possession of the NFT?\n        if (nftContract.safeOwnerOf(nftTokenId) == address(this)) {\n            if (lastBid_ == 0) {\n                // The NFT was gifted to us. Everyone who contributed wins.\n                lastBid_ = totalContributions;\n                if (lastBid_ == 0) {\n                    // Nobody ever contributed. The NFT is effectively burned.\n                    revert NoContributionsError();\n                }\n                lastBid = lastBid_;\n            }\n            // Create a governance party around the NFT.\n            party_ = _createParty(\n                _getPartyFactory(),\n                governanceOpts,\n                nftContract,\n                nftTokenId\n            );\n            emit Won(lastBid_, party_);\n        } else {\n            // Clear `lastBid` so `_getFinalPrice()` is 0 and people can redeem their\n            // full contributions when they burn their participation NFTs.\n            lastBid = 0;\n            emit Lost();\n        }\n\n        _bidStatus = AuctionCrowdfundStatus.Finalized;\n    }\n\n    /// @inheritdoc Crowdfund\n    function getCrowdfundLifecycle() public override view returns (CrowdfundLifecycle) {\n        // Do not rely on `market.isFinalized()` in case `auctionId` gets reused.\n        AuctionCrowdfundStatus status = _bidStatus;\n        if (status == AuctionCrowdfundStatus.Busy) {\n            // In the midst of finalizing/bidding (trying to reenter).\n            return CrowdfundLifecycle.Busy;\n        }\n        if (status == AuctionCrowdfundStatus.Finalized) {\n            return address(party) != address(0)\n                // If we're fully finalized and we have a party instance then we won.\n                ? CrowdfundLifecycle.Won\n                // Otherwise we lost.\n                : CrowdfundLifecycle.Lost;\n        }\n        if (block.timestamp >= expiry) {\n            // Expired. `finalize()` needs to be called.\n            return CrowdfundLifecycle.Expired;\n        }\n        return CrowdfundLifecycle.Active;\n    }\n\n    function _getFinalPrice()\n        internal\n        override\n        view\n        returns (uint256 price)\n    {\n        return lastBid;\n    }\n}"
    }
  ]
}