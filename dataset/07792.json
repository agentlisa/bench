{
  "Title": "[06]",
  "Content": "\nFor each deposit of an ERC20 token, the information of the token is read and packed and sent to L2. Even if this token is used before for deposit, again this information is sent to L2, which is waste of gas.<br>\n[L1ERC20Bridge.sol#L164-L169](https://github.com/code-423n4/2022-10-zksync/blob/456078b53a6d09636b84522ac8f3e8049e4e3af5/ethereum/contracts/bridge/L1ERC20Bridge.sol#L164-L169)<br>\n[L1ERC20Bridge.sol#L155](https://github.com/code-423n4/2022-10-zksync/blob/456078b53a6d09636b84522ac8f3e8049e4e3af5/ethereum/contracts/bridge/L1ERC20Bridge.sol#L155)<br>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-10-zksync",
  "Code": [
    {
      "filename": "ethereum/contracts/bridge/L1ERC20Bridge.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/IL1Bridge.sol\";\nimport \"./interfaces/IL2Bridge.sol\";\n\nimport \"../common/interfaces/IAllowList.sol\";\nimport \"../common/AllowListed.sol\";\nimport \"../common/libraries/UnsafeBytes.sol\";\nimport \"../common/ReentrancyGuard.sol\";\nimport \"../common/L2ContractHelper.sol\";\n\n/// @author Matter Labs\n/// @notice Smart contract that allows depositing ERC20 tokens from Ethereum to zkSync v2.0\n/// @dev It is standard implementation of ERC20 Bridge that can be used as a refference\n/// for any other custom token bridges.\ncontract L1ERC20Bridge is IL1Bridge, AllowListed, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    /// @dev The smart contract that manages the list with permission to call contract functions\n    IAllowList immutable allowList;\n\n    /// @dev zkSync smart contract that used to operate with L2 via asynchronous L2 <-> L1 communication\n    IMailbox immutable zkSyncMailbox;\n\n    /// @dev Ergs limit for requesting L2 deposit finalization transaction\n    /// NOTE: constant is not calculated accurately, because ergs count in L2 is not stable yet\n    uint256 constant DEPOSIT_ERGS_LIMIT = 2097152;\n\n    /// @dev Ergs limit for requesting L1 -> L2 transaction of deploying L2 bridge instance\n    /// NOTE: constant is not calculated accurately, because ergs count in L2 is not stable yet\n    uint256 constant DEPLOY_L2_BRIDGE_COUNTERPART_ERGS_LIMIT = 2097152;\n\n    /// @dev A mapping L2 block number => message number => flag\n    /// @dev Used to indicate that zkSync L2 -> L1 message was already processed\n    mapping(uint256 => mapping(uint256 => bool)) public isWithdrawalFinalized;\n\n    /// @dev A mapping account => L1 token address => L2 deposit transaction hash => amount\n    /// @dev Used for saving the number of deposited funds, to claim them in case the deposit transaction will fail\n    mapping(address => mapping(address => mapping(bytes32 => uint256))) depositAmount;\n\n    /// @dev The address of deployed L2 bridge counterpart\n    address public l2Bridge;\n\n    /// @dev The address of the factory that deploys proxy for L2 tokens\n    address public l2TokenFactory;\n\n    /// @dev The bytecode hash of the L2 token contract\n    bytes32 public l2ProxyTokenBytecodeHash;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(IMailbox _mailbox, IAllowList _allowList) reentrancyGuardInitializer {\n        zkSyncMailbox = _mailbox;\n        allowList = _allowList;\n    }\n\n    /// @dev Initializes a contract bridge for later use. Expected to be used in the proxy\n    /// @dev During initialization deploys L2 bridge counterpart as well as provides some factory deps for it\n    /// @param _factoryDeps A list of raw bytecodes that are needed for deployment of the L2 bridge\n    /// @notice _factoryDeps[0] == a raw bytecode of L2 bridge\n    /// @notice _factoryDeps[1] == a raw bytecode of token proxy\n    /// @param _l2TokenFactory Pre-calculated address of L2 token beacon proxy\n    /// @notice At the time of the function call, it is not yet deployed in L2, but knowledge of its address\n    /// @notice is necessary for determining L2 token address by L1 address, see `l2TokenAddress(address)` function\n    /// @param _governor Address which can change L2 token implementation\n    function initialize(\n        bytes[] calldata _factoryDeps,\n        address _l2TokenFactory,\n        address _governor\n    ) external reentrancyGuardInitializer {\n        // We are expecting to see the exect two bytecodes that are needed to initiailize the bridge\n        require(_factoryDeps.length == 2, \"mk\");\n        l2ProxyTokenBytecodeHash = L2ContractHelper.hashL2Bytecode(_factoryDeps[1]);\n        l2TokenFactory = _l2TokenFactory;\n\n        bytes32 create2Salt = bytes32(0);\n        bytes memory create2Input = abi.encode(address(this), l2ProxyTokenBytecodeHash, _governor);\n        bytes32 l2BridgeBytecodeHash = L2ContractHelper.hashL2Bytecode(_factoryDeps[0]);\n        bytes memory deployL2BridgeCalldata = abi.encodeCall(\n            IContractDeployer.create2,\n            (create2Salt, l2BridgeBytecodeHash, create2Input)\n        );\n\n        l2Bridge = L2ContractHelper.computeCreate2Address(\n            address(this),\n            create2Salt,\n            l2BridgeBytecodeHash,\n            keccak256(create2Input)\n        );\n\n        zkSyncMailbox.requestL2Transaction(\n            DEPLOYER_SYSTEM_CONTRACT_ADDRESS,\n            0,\n            deployL2BridgeCalldata,\n            DEPLOY_L2_BRIDGE_COUNTERPART_ERGS_LIMIT,\n            _factoryDeps\n        );\n    }\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @return txHash The L2 transaction hash of deposit finalization\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount\n    ) external payable nonReentrant senderCanCallFunction(allowList) returns (bytes32 txHash) {\n        uint256 amount = _depositFunds(msg.sender, IERC20(_l1Token), _amount);\n        require(amount > 0, \"1T\"); // empty deposit amount\n\n        bytes memory l2TxCalldata = _getDepositL2Calldata(msg.sender, _l2Receiver, _l1Token, amount);\n        txHash = zkSyncMailbox.requestL2Transaction{value: msg.value}(\n            l2Bridge,\n            0, // L2 msg.value\n            l2TxCalldata,\n            DEPOSIT_ERGS_LIMIT,\n            new bytes[](0)\n        );\n\n        // Save the deposited amount to claim funds on L1 if the deposit failed on L2\n        depositAmount[msg.sender][_l1Token][txHash] = amount;\n\n        emit DepositInitiated(msg.sender, _l2Receiver, _l1Token, amount);\n    }\n\n    /// @dev Transfers tokens from the depositor address to the smart contract address\n    /// @return The difference between the contract balance before and after the transferring funds\n    function _depositFunds(\n        address _from,\n        IERC20 _token,\n        uint256 _amount\n    ) internal returns (uint256) {\n        uint256 balanceBefore = _token.balanceOf(address(this));\n        _token.safeTransferFrom(_from, address(this), _amount);\n        uint256 balanceAfter = _token.balanceOf(address(this));\n\n        return balanceAfter - balanceBefore;\n    }\n\n    /// @dev Generate a calldata for calling the deposit finalization on the L2 bridge contract\n    function _getDepositL2Calldata(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount\n    ) internal view returns (bytes memory txCalldata) {\n        bytes memory gettersData = _getERC20Getters(_l1Token);\n\n        txCalldata = abi.encodeCall(\n            IL2Bridge.finalizeDeposit,\n            (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData)\n        );\n    }\n\n    /// @dev Receives and parses (name, symbol, decimals) from the token contract\n    function _getERC20Getters(address _token) internal view returns (bytes memory data) {\n        (, bytes memory data1) = _token.staticcall(abi.encodeCall(IERC20Metadata.name, ()));\n        (, bytes memory data2) = _token.staticcall(abi.encodeCall(IERC20Metadata.symbol, ()));\n        (, bytes memory data3) = _token.staticcall(abi.encodeCall(IERC20Metadata.decimals, ()));\n        data = abi.encode(data1, data2, data3);\n    }\n\n    /// @dev Withdraw funds from the initiated deposit, that failed when finalizing on L2\n    /// @param _depositSender The address of the deposit initiator\n    /// @param _l1Token The address of the deposited L1 ERC20 token\n    /// @param _l2TxHash The L2 transaction hash of the failed deposit finalization\n    /// @param _l2BlockNumber The L2 block number where the deposit finalization was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBlock The L2 transaction number in a block, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction with deposit finalization\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BlockNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBlock,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant senderCanCallFunction(allowList) {\n        // Bootloader sends an L2 -> L1 log only after processing the L1 -> L2 transaction.\n        // Thus, we can verify that the deposit (L1 -> L2 transaction) was included in the L2 block with failed status.\n        //\n        // The semantics of such L2 -> L1 log is always:\n        // - sender = BOOTLOADER_ADDRESS\n        // - key = hash(L1ToL2Transaction)\n        // - value = status of the processing transaction (1 - success & 0 for fail)\n        // - isService = true (just a conventional value)\n        // - l2ShardId = 0 (means that L1 -> L2 transaction was processed in a rollup shard, other shards are not available yet anyway)\n        // - txNumberInBlock = number of transaction in the block\n        L2Log memory l2Log = L2Log({\n            l2ShardId: 0,\n            isService: true,\n            txNumberInBlock: _l2TxNumberInBlock,\n            sender: BOOTLOADER_ADDRESS,\n            key: _l2TxHash,\n            value: bytes32(0)\n        });\n        bool success = zkSyncMailbox.proveL2LogInclusion(_l2BlockNumber, _l2MessageIndex, l2Log, _merkleProof);\n        require(success, \"yn\");\n\n        uint256 amount = depositAmount[_depositSender][_l1Token][_l2TxHash];\n        require(amount > 0, \"y1\");\n\n        delete depositAmount[_depositSender][_l1Token][_l2TxHash];\n        // Withdraw funds\n        IERC20(_l1Token).safeTransfer(_depositSender, amount);\n\n        emit ClaimedFailedDeposit(_depositSender, _l1Token, amount);\n    }\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BlockNumber The L2 block number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBlock The L2 transaction number in a block, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeWithdrawal(\n        uint256 _l2BlockNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBlock,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant senderCanCallFunction(allowList) {\n        require(!isWithdrawalFinalized[_l2BlockNumber][_l2MessageIndex], \"pw\");\n\n        L2Message memory l2ToL1Message = L2Message({\n            txNumberInBlock: _l2TxNumberInBlock,\n            sender: l2Bridge,\n            data: _message\n        });\n\n        (address l1Receiver, address l1Token, uint256 amount) = _parseL2WithdrawalMessage(l2ToL1Message.data);\n        // Preventing the stack too deep error\n        {\n            bool success = zkSyncMailbox.proveL2MessageInclusion(\n                _l2BlockNumber,\n                _l2MessageIndex,\n                l2ToL1Message,\n                _merkleProof\n            );\n            require(success, \"nq\");\n        }\n\n        isWithdrawalFinalized[_l2BlockNumber][_l2MessageIndex] = true;\n        // Withdraw funds\n        IERC20(l1Token).safeTransfer(l1Receiver, amount);\n\n        emit WithdrawalFinalized(l1Receiver, l1Token, amount);\n    }\n\n    /// @dev Decode the withdraw message that came from L2\n    function _parseL2WithdrawalMessage(bytes memory _l2ToL1message)\n        internal\n        pure\n        returns (\n            address l1Receiver,\n            address l1Token,\n            uint256 amount\n        )\n    {\n        // Check that the message length is correct.\n        // It should be equal to the length of the function signature + address + address + uint256 = 4 + 20 + 20 + 32 = 76 (bytes).\n        require(_l2ToL1message.length == 76, \"kk\");\n\n        (uint32 functionSignature, uint256 offset) = UnsafeBytes.readUint32(_l2ToL1message, 0);\n        require(bytes4(functionSignature) == this.finalizeWithdrawal.selector, \"nt\");\n\n        (l1Receiver, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (l1Token, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (amount, offset) = UnsafeBytes.readUint256(_l2ToL1message, offset);\n    }\n\n    /// @return The L2 token address that would be minted for deposit of the given L1 token\n    function l2TokenAddress(address _l1Token) public view returns (address) {\n        bytes32 constructorInputHash = keccak256(abi.encode(address(l2TokenFactory), \"\"));\n        bytes32 salt = bytes32(uint256(uint160(_l1Token)));\n\n        return L2ContractHelper.computeCreate2Address(l2Bridge, salt, l2ProxyTokenBytecodeHash, constructorInputHash);\n    }\n}"
    },
    {
      "filename": "ethereum/contracts/bridge/L1ERC20Bridge.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/IL1Bridge.sol\";\nimport \"./interfaces/IL2Bridge.sol\";\n\nimport \"../common/interfaces/IAllowList.sol\";\nimport \"../common/AllowListed.sol\";\nimport \"../common/libraries/UnsafeBytes.sol\";\nimport \"../common/ReentrancyGuard.sol\";\nimport \"../common/L2ContractHelper.sol\";\n\n/// @author Matter Labs\n/// @notice Smart contract that allows depositing ERC20 tokens from Ethereum to zkSync v2.0\n/// @dev It is standard implementation of ERC20 Bridge that can be used as a refference\n/// for any other custom token bridges.\ncontract L1ERC20Bridge is IL1Bridge, AllowListed, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    /// @dev The smart contract that manages the list with permission to call contract functions\n    IAllowList immutable allowList;\n\n    /// @dev zkSync smart contract that used to operate with L2 via asynchronous L2 <-> L1 communication\n    IMailbox immutable zkSyncMailbox;\n\n    /// @dev Ergs limit for requesting L2 deposit finalization transaction\n    /// NOTE: constant is not calculated accurately, because ergs count in L2 is not stable yet\n    uint256 constant DEPOSIT_ERGS_LIMIT = 2097152;\n\n    /// @dev Ergs limit for requesting L1 -> L2 transaction of deploying L2 bridge instance\n    /// NOTE: constant is not calculated accurately, because ergs count in L2 is not stable yet\n    uint256 constant DEPLOY_L2_BRIDGE_COUNTERPART_ERGS_LIMIT = 2097152;\n\n    /// @dev A mapping L2 block number => message number => flag\n    /// @dev Used to indicate that zkSync L2 -> L1 message was already processed\n    mapping(uint256 => mapping(uint256 => bool)) public isWithdrawalFinalized;\n\n    /// @dev A mapping account => L1 token address => L2 deposit transaction hash => amount\n    /// @dev Used for saving the number of deposited funds, to claim them in case the deposit transaction will fail\n    mapping(address => mapping(address => mapping(bytes32 => uint256))) depositAmount;\n\n    /// @dev The address of deployed L2 bridge counterpart\n    address public l2Bridge;\n\n    /// @dev The address of the factory that deploys proxy for L2 tokens\n    address public l2TokenFactory;\n\n    /// @dev The bytecode hash of the L2 token contract\n    bytes32 public l2ProxyTokenBytecodeHash;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(IMailbox _mailbox, IAllowList _allowList) reentrancyGuardInitializer {\n        zkSyncMailbox = _mailbox;\n        allowList = _allowList;\n    }\n\n    /// @dev Initializes a contract bridge for later use. Expected to be used in the proxy\n    /// @dev During initialization deploys L2 bridge counterpart as well as provides some factory deps for it\n    /// @param _factoryDeps A list of raw bytecodes that are needed for deployment of the L2 bridge\n    /// @notice _factoryDeps[0] == a raw bytecode of L2 bridge\n    /// @notice _factoryDeps[1] == a raw bytecode of token proxy\n    /// @param _l2TokenFactory Pre-calculated address of L2 token beacon proxy\n    /// @notice At the time of the function call, it is not yet deployed in L2, but knowledge of its address\n    /// @notice is necessary for determining L2 token address by L1 address, see `l2TokenAddress(address)` function\n    /// @param _governor Address which can change L2 token implementation\n    function initialize(\n        bytes[] calldata _factoryDeps,\n        address _l2TokenFactory,\n        address _governor\n    ) external reentrancyGuardInitializer {\n        // We are expecting to see the exect two bytecodes that are needed to initiailize the bridge\n        require(_factoryDeps.length == 2, \"mk\");\n        l2ProxyTokenBytecodeHash = L2ContractHelper.hashL2Bytecode(_factoryDeps[1]);\n        l2TokenFactory = _l2TokenFactory;\n\n        bytes32 create2Salt = bytes32(0);\n        bytes memory create2Input = abi.encode(address(this), l2ProxyTokenBytecodeHash, _governor);\n        bytes32 l2BridgeBytecodeHash = L2ContractHelper.hashL2Bytecode(_factoryDeps[0]);\n        bytes memory deployL2BridgeCalldata = abi.encodeCall(\n            IContractDeployer.create2,\n            (create2Salt, l2BridgeBytecodeHash, create2Input)\n        );\n\n        l2Bridge = L2ContractHelper.computeCreate2Address(\n            address(this),\n            create2Salt,\n            l2BridgeBytecodeHash,\n            keccak256(create2Input)\n        );\n\n        zkSyncMailbox.requestL2Transaction(\n            DEPLOYER_SYSTEM_CONTRACT_ADDRESS,\n            0,\n            deployL2BridgeCalldata,\n            DEPLOY_L2_BRIDGE_COUNTERPART_ERGS_LIMIT,\n            _factoryDeps\n        );\n    }\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @return txHash The L2 transaction hash of deposit finalization\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount\n    ) external payable nonReentrant senderCanCallFunction(allowList) returns (bytes32 txHash) {\n        uint256 amount = _depositFunds(msg.sender, IERC20(_l1Token), _amount);\n        require(amount > 0, \"1T\"); // empty deposit amount\n\n        bytes memory l2TxCalldata = _getDepositL2Calldata(msg.sender, _l2Receiver, _l1Token, amount);\n        txHash = zkSyncMailbox.requestL2Transaction{value: msg.value}(\n            l2Bridge,\n            0, // L2 msg.value\n            l2TxCalldata,\n            DEPOSIT_ERGS_LIMIT,\n            new bytes[](0)\n        );\n\n        // Save the deposited amount to claim funds on L1 if the deposit failed on L2\n        depositAmount[msg.sender][_l1Token][txHash] = amount;\n\n        emit DepositInitiated(msg.sender, _l2Receiver, _l1Token, amount);\n    }\n\n    /// @dev Transfers tokens from the depositor address to the smart contract address\n    /// @return The difference between the contract balance before and after the transferring funds\n    function _depositFunds(\n        address _from,\n        IERC20 _token,\n        uint256 _amount\n    ) internal returns (uint256) {\n        uint256 balanceBefore = _token.balanceOf(address(this));\n        _token.safeTransferFrom(_from, address(this), _amount);\n        uint256 balanceAfter = _token.balanceOf(address(this));\n\n        return balanceAfter - balanceBefore;\n    }\n\n    /// @dev Generate a calldata for calling the deposit finalization on the L2 bridge contract\n    function _getDepositL2Calldata(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount\n    ) internal view returns (bytes memory txCalldata) {\n        bytes memory gettersData = _getERC20Getters(_l1Token);\n\n        txCalldata = abi.encodeCall(\n            IL2Bridge.finalizeDeposit,\n            (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData)\n        );\n    }\n\n    /// @dev Receives and parses (name, symbol, decimals) from the token contract\n    function _getERC20Getters(address _token) internal view returns (bytes memory data) {\n        (, bytes memory data1) = _token.staticcall(abi.encodeCall(IERC20Metadata.name, ()));\n        (, bytes memory data2) = _token.staticcall(abi.encodeCall(IERC20Metadata.symbol, ()));\n        (, bytes memory data3) = _token.staticcall(abi.encodeCall(IERC20Metadata.decimals, ()));\n        data = abi.encode(data1, data2, data3);\n    }\n\n    /// @dev Withdraw funds from the initiated deposit, that failed when finalizing on L2\n    /// @param _depositSender The address of the deposit initiator\n    /// @param _l1Token The address of the deposited L1 ERC20 token\n    /// @param _l2TxHash The L2 transaction hash of the failed deposit finalization\n    /// @param _l2BlockNumber The L2 block number where the deposit finalization was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBlock The L2 transaction number in a block, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction with deposit finalization\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BlockNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBlock,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant senderCanCallFunction(allowList) {\n        // Bootloader sends an L2 -> L1 log only after processing the L1 -> L2 transaction.\n        // Thus, we can verify that the deposit (L1 -> L2 transaction) was included in the L2 block with failed status.\n        //\n        // The semantics of such L2 -> L1 log is always:\n        // - sender = BOOTLOADER_ADDRESS\n        // - key = hash(L1ToL2Transaction)\n        // - value = status of the processing transaction (1 - success & 0 for fail)\n        // - isService = true (just a conventional value)\n        // - l2ShardId = 0 (means that L1 -> L2 transaction was processed in a rollup shard, other shards are not available yet anyway)\n        // - txNumberInBlock = number of transaction in the block\n        L2Log memory l2Log = L2Log({\n            l2ShardId: 0,\n            isService: true,\n            txNumberInBlock: _l2TxNumberInBlock,\n            sender: BOOTLOADER_ADDRESS,\n            key: _l2TxHash,\n            value: bytes32(0)\n        });\n        bool success = zkSyncMailbox.proveL2LogInclusion(_l2BlockNumber, _l2MessageIndex, l2Log, _merkleProof);\n        require(success, \"yn\");\n\n        uint256 amount = depositAmount[_depositSender][_l1Token][_l2TxHash];\n        require(amount > 0, \"y1\");\n\n        delete depositAmount[_depositSender][_l1Token][_l2TxHash];\n        // Withdraw funds\n        IERC20(_l1Token).safeTransfer(_depositSender, amount);\n\n        emit ClaimedFailedDeposit(_depositSender, _l1Token, amount);\n    }\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BlockNumber The L2 block number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBlock The L2 transaction number in a block, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeWithdrawal(\n        uint256 _l2BlockNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBlock,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant senderCanCallFunction(allowList) {\n        require(!isWithdrawalFinalized[_l2BlockNumber][_l2MessageIndex], \"pw\");\n\n        L2Message memory l2ToL1Message = L2Message({\n            txNumberInBlock: _l2TxNumberInBlock,\n            sender: l2Bridge,\n            data: _message\n        });\n\n        (address l1Receiver, address l1Token, uint256 amount) = _parseL2WithdrawalMessage(l2ToL1Message.data);\n        // Preventing the stack too deep error\n        {\n            bool success = zkSyncMailbox.proveL2MessageInclusion(\n                _l2BlockNumber,\n                _l2MessageIndex,\n                l2ToL1Message,\n                _merkleProof\n            );\n            require(success, \"nq\");\n        }\n\n        isWithdrawalFinalized[_l2BlockNumber][_l2MessageIndex] = true;\n        // Withdraw funds\n        IERC20(l1Token).safeTransfer(l1Receiver, amount);\n\n        emit WithdrawalFinalized(l1Receiver, l1Token, amount);\n    }\n\n    /// @dev Decode the withdraw message that came from L2\n    function _parseL2WithdrawalMessage(bytes memory _l2ToL1message)\n        internal\n        pure\n        returns (\n            address l1Receiver,\n            address l1Token,\n            uint256 amount\n        )\n    {\n        // Check that the message length is correct.\n        // It should be equal to the length of the function signature + address + address + uint256 = 4 + 20 + 20 + 32 = 76 (bytes).\n        require(_l2ToL1message.length == 76, \"kk\");\n\n        (uint32 functionSignature, uint256 offset) = UnsafeBytes.readUint32(_l2ToL1message, 0);\n        require(bytes4(functionSignature) == this.finalizeWithdrawal.selector, \"nt\");\n\n        (l1Receiver, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (l1Token, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (amount, offset) = UnsafeBytes.readUint256(_l2ToL1message, offset);\n    }\n\n    /// @return The L2 token address that would be minted for deposit of the given L1 token\n    function l2TokenAddress(address _l1Token) public view returns (address) {\n        bytes32 constructorInputHash = keccak256(abi.encode(address(l2TokenFactory), \"\"));\n        bytes32 salt = bytes32(uint256(uint160(_l1Token)));\n\n        return L2ContractHelper.computeCreate2Address(l2Bridge, salt, l2ProxyTokenBytecodeHash, constructorInputHash);\n    }\n}"
    }
  ]
}