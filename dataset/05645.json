{
  "Title": "[G-08]  Use named returns for local variables of pure functions where it is possible",
  "Content": "\n### Proof of Concept\n\n```solidity\nlibrary NoNamedReturnArithmetic {\n    \n    function sum(uint256 num1, uint256 num2) internal pure returns(uint256){\n        return num1 + num2;\n    }\n}\n\ncontract NoNamedReturn {\n    using NoNamedReturnArithmetic for uint256;\n\n    uint256 public stateVar;\n\n    function add2State(uint256 num) public {\n        stateVar = stateVar.sum(num);\n    }\n}\n```\n\n```solidity\ntest for test/NoNamedReturn.t.sol:NamedReturnTest\n[PASS] test_Increment() (gas: 27639)\n```\n\n```solidity\nlibrary NamedReturnArithmetic {\n    \n    function sum(uint256 num1, uint256 num2) internal pure returns(uint256 theSum){\n        theSum = num1 + num2;\n    }\n}\n\ncontract NamedReturn {\n    using NamedReturnArithmetic for uint256;\n\n    uint256 public stateVar;\n\n    function add2State(uint256 num) public {\n        stateVar = stateVar.sum(num);\n    }\n}\n```\n\n```solidity\ntest for test/NamedReturn.t.sol:NamedReturnTest\n[PASS] test_Increment() (gas: 27613)\n```\n\n*There are 3 instances of this issue.*\n\n1. Use named returns in the `__buildTransactionStructHash()` function.\n\n    https://github.com/code-423n4/2023-10-brahma/blob/main/contracts/src/libraries/TypeHashHelper.sol#L64\n\n```solidity\nfile: contracts/src/libraries/TypeHashHelper.sol\n\n64:    function _buildTransactionStructHash(Transaction memory txn) internal pure returns (bytes32) {\n65:        return keccak256(\n66:            abi.encode(\n67:                TRANSACTION_PARAMS_TYPEHASH,\n68:                txn.to,\n69:                txn.value,\n70:                keccak256(txn.data),\n71:                txn.operation,\n72:                txn.account,\n73:                txn.executor,\n74:                txn.nonce\n75:            )\n76:        );\n77:    }\n```\n\nThe code could be refactored as shown in the diff below:\n\n```diff\ndiff --git a/contracts/src/libraries/TypeHashHelper.sol b/contracts/src/libraries/TypeHashHelper.sol\nindex df1a5aa..64e0ed0 100644\n--- a/contracts/src/libraries/TypeHashHelper.sol\n+++ b/contracts/src/libraries/TypeHashHelper.sol\n@@ -61,8 +61,8 @@ library TypeHashHelper {\n      * @param txn transaction params struct\n      * @return transactionStructHash\n      */\n-    function _buildTransactionStructHash(Transaction memory txn) internal pure returns (bytes32) {\n-        return keccak256(\n+    function _buildTransactionStructHash(Transaction memory txn) internal pure returns (bytes32 trxHash) {\n+        trxHash = keccak256(\n             abi.encode(\n                 TRANSACTION_PARAMS_TYPEHASH,\n                 txn.to,\n```\n\n2. Use named returns in the `_buildValidationStructHash()` function.\n\n    https://github.com/code-423n4/2023-10-brahma/blob/main/contracts/src/libraries/TypeHashHelper.sol#L84\n\n```solidity\nfile: contracts/src/libraries/TypeHashHelper.sol\n\n84:    function _buildValidationStructHash(Validation memory validation) internal pure returns (bytes32) {\n85:        return keccak256(\n86:            abi.encode(\n87:                VALIDATION_PARAMS_TYPEHASH,\n88:                validation.transactionStructHash,\n89:                validation.policyHash,\n90:                validation.expiryEpoch\n91:            )\n92:        );\n93:    }\n```\n\n```diff\ndiff --git a/contracts/src/libraries/TypeHashHelper.sol b/contracts/src/libraries/TypeHashHelper.sol\nindex df1a5aa..6df88fc 100644\n--- a/contracts/src/libraries/TypeHashHelper.sol\n+++ b/contracts/src/libraries/TypeHashHelper.sol\n@@ -81,8 +81,8 @@ library TypeHashHelper {\n      * @param validation validation params struct\n      * @return validationStructHash\n      */\n-    function _buildValidationStructHash(Validation memory validation) internal pure returns (bytes32) {\n-        return keccak256(\n+    function _buildValidationStructHash(Validation memory validation) internal pure returns (bytes32 validationHash) {\n+        validationHash = keccak256(\n             abi.encode(\n                 VALIDATION_PARAMS_TYPEHASH,\n                 validation.transactionStructHash,\n```\n\n3. Use named returns in the `_generateSingleThresholdSignature()` function.\n\n    https://github.com/code-423n4/2023-10-brahma/blob/main/contracts/src/libraries/SafeHelper.sol#L84\n\n```solidity\nfile: contracts/src/libraries/SafeHelper.sol\n\n87:    function _generateSingleThresholdSignature(address owner) internal pure returns (bytes memory) {\n88:        bytes memory signatures = abi.encodePacked(\n89:            bytes12(0), // Padding for signature verifier address\n90:            bytes20(owner), // Signature Verifier\n91:            bytes32(0), // Position of extra data bytes (last set of data)\n92:            bytes1(hex\"01\") // Signature Type - 1 (presigned transaction)\n93:        );\n94:        return signatures;\n95:    }\n```\n\nThe code could be refactored as shown in the diff below:\n\n```diff\ndiff --git a/contracts/src/libraries/SafeHelper.sol b/contracts/src/libraries/SafeHelper.sol                        \nindex 7830a80..4497e00 100644                                                                                       \n--- a/contracts/src/libraries/SafeHelper.sol                                                                        \n+++ b/contracts/src/libraries/SafeHelper.sol                                                                        \n@@ -84,14 +84,13 @@ library SafeHelper {                                                                            \n      * @param owner Owner of the safe                                                                              \n      * @return signatures bytes array containing single pre validated owner signature                              \n      */                                                                                                            \n-    function _generateSingleThresholdSignature(address owner) internal pure returns (bytes memory) {               \n-        bytes memory signatures = abi.encodePacked(                                                                \n+    function _generateSingleThresholdSignature(address owner) internal pure returns (bytes memory signatures) {    \n+        signatures = abi.encodePacked(                                                                             \n             bytes12(0), // Padding for signature verifier address                                                  \n             bytes20(owner), // Signature Verifier                                                                  \n             bytes32(0), // Position of extra data bytes (last set of data)                                         \n             bytes1(hex\"01\") // Signature Type - 1 (presigned transaction)                                          \n         );                                                                                                         \n-        return signatures;                                                                                         \n     }                                                                                                              \n                                                                                                                    \n     /**                                                                                                            \n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-10-brahma",
  "Code": [
    {
      "filename": "contracts/src/libraries/TypeHashHelper.sol",
      "content": "/// SPDX-License-Identifier: BUSL-1.1\n\n/// Copyright (C) 2023 Brahma.fi\n\npragma solidity 0.8.19;\n\n/**\n * @title TypeHashHelper\n * @author Brahma.fi\n * @notice Helper library containing functions to build EIP712 struct and type hashes\n */\nlibrary TypeHashHelper {\n    /**\n     * @notice Structural representation of transaction details\n     * @param operation type of operation\n     * @param to address to send tx to\n     * @param account address of safe\n     * @param executor address of executor if executed via executor plugin, address(0) if executed via execTransaction\n     * @param value txn value\n     * @param nonce txn nonce\n     * @param data txn callData\n     */\n    struct Transaction {\n        uint8 operation;\n        address to;\n        address account;\n        address executor;\n        uint256 value;\n        uint256 nonce;\n        bytes data;\n    }\n\n    /**\n     * @notice Type of validation struct to hash\n     * @param expiryEpoch max time till validity of the signature\n     * @param transactionStructHash txn digest generated using TypeHashHelper._buildTransactionStructHash()\n     * @param policyHash policy commit hash of the safe account\n     */\n    struct Validation {\n        uint32 expiryEpoch;\n        bytes32 transactionStructHash;\n        bytes32 policyHash;\n    }\n\n    /**\n     * @notice EIP712 typehash for transaction data\n     * @dev keccak256(\"ExecutionParams(address to,uint256 value,bytes data,uint8 operation,address account,address executor,uint256 nonce)\");\n     */\n    bytes32 public constant TRANSACTION_PARAMS_TYPEHASH =\n        0xfd4628b53a91b366f1977138e2eda53b93c8f5cc74bda8440f108d7da1e99290;\n\n    /**\n     * @notice EIP712 typehash for validation data\n     * @dev keccak256(\"ValidationParams(ExecutionParams executionParams,bytes32 policyHash,uint32 expiryEpoch)ExecutionParams(address to,uint256 value,bytes data,uint8 operation,address account,address executor,uint256 nonce)\")\n     */\n    bytes32 public constant VALIDATION_PARAMS_TYPEHASH =\n        0x0c7f653e0f641e41fbb4ed1440c7d0b08b8d2a19e1c35cfc98de2d47519e15b1;\n\n    /**\n     * @notice Builds EIP712 transaction struct hash\n     * @param txn transaction params struct\n     * @return transactionStructHash\n     */\n    function _buildTransactionStructHash(Transaction memory txn) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                TRANSACTION_PARAMS_TYPEHASH,\n                txn.to,\n                txn.value,\n                keccak256(txn.data),\n                txn.operation,\n                txn.account,\n                txn.executor,\n                txn.nonce\n            )\n        );\n    }\n\n    /**\n     * @notice Builds EIP712 validation struct hash\n     * @param validation validation params struct\n     * @return validationStructHash\n     */\n    function _buildValidationStructHash(Validation memory validation) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                VALIDATION_PARAMS_TYPEHASH,\n                validation.transactionStructHash,\n                validation.policyHash,\n                validation.expiryEpoch\n            )\n        );\n    }\n}"
    },
    {
      "filename": "contracts/src/libraries/TypeHashHelper.sol",
      "content": "/// SPDX-License-Identifier: BUSL-1.1\n\n/// Copyright (C) 2023 Brahma.fi\n\npragma solidity 0.8.19;\n\n/**\n * @title TypeHashHelper\n * @author Brahma.fi\n * @notice Helper library containing functions to build EIP712 struct and type hashes\n */\nlibrary TypeHashHelper {\n    /**\n     * @notice Structural representation of transaction details\n     * @param operation type of operation\n     * @param to address to send tx to\n     * @param account address of safe\n     * @param executor address of executor if executed via executor plugin, address(0) if executed via execTransaction\n     * @param value txn value\n     * @param nonce txn nonce\n     * @param data txn callData\n     */\n    struct Transaction {\n        uint8 operation;\n        address to;\n        address account;\n        address executor;\n        uint256 value;\n        uint256 nonce;\n        bytes data;\n    }\n\n    /**\n     * @notice Type of validation struct to hash\n     * @param expiryEpoch max time till validity of the signature\n     * @param transactionStructHash txn digest generated using TypeHashHelper._buildTransactionStructHash()\n     * @param policyHash policy commit hash of the safe account\n     */\n    struct Validation {\n        uint32 expiryEpoch;\n        bytes32 transactionStructHash;\n        bytes32 policyHash;\n    }\n\n    /**\n     * @notice EIP712 typehash for transaction data\n     * @dev keccak256(\"ExecutionParams(address to,uint256 value,bytes data,uint8 operation,address account,address executor,uint256 nonce)\");\n     */\n    bytes32 public constant TRANSACTION_PARAMS_TYPEHASH =\n        0xfd4628b53a91b366f1977138e2eda53b93c8f5cc74bda8440f108d7da1e99290;\n\n    /**\n     * @notice EIP712 typehash for validation data\n     * @dev keccak256(\"ValidationParams(ExecutionParams executionParams,bytes32 policyHash,uint32 expiryEpoch)ExecutionParams(address to,uint256 value,bytes data,uint8 operation,address account,address executor,uint256 nonce)\")\n     */\n    bytes32 public constant VALIDATION_PARAMS_TYPEHASH =\n        0x0c7f653e0f641e41fbb4ed1440c7d0b08b8d2a19e1c35cfc98de2d47519e15b1;\n\n    /**\n     * @notice Builds EIP712 transaction struct hash\n     * @param txn transaction params struct\n     * @return transactionStructHash\n     */\n    function _buildTransactionStructHash(Transaction memory txn) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                TRANSACTION_PARAMS_TYPEHASH,\n                txn.to,\n                txn.value,\n                keccak256(txn.data),\n                txn.operation,\n                txn.account,\n                txn.executor,\n                txn.nonce\n            )\n        );\n    }\n\n    /**\n     * @notice Builds EIP712 validation struct hash\n     * @param validation validation params struct\n     * @return validationStructHash\n     */\n    function _buildValidationStructHash(Validation memory validation) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                VALIDATION_PARAMS_TYPEHASH,\n                validation.transactionStructHash,\n                validation.policyHash,\n                validation.expiryEpoch\n            )\n        );\n    }\n}"
    },
    {
      "filename": "contracts/src/libraries/SafeHelper.sol",
      "content": "/// SPDX-License-Identifier: BUSL-1.1\n\n/// Copyright (C) 2023 Brahma.fi\n\npragma solidity 0.8.19;\n\nimport {Enum, IGnosisSafe} from \"interfaces/external/IGnosisSafe.sol\";\nimport {Types} from \"interfaces/Types.sol\";\n\n/**\n * @title SafeHelper\n * @author Brahma.fi\n * @notice Helper library containing functions to interact with gnosis safe\n */\nlibrary SafeHelper {\n    error InvalidMultiSendCall(uint256);\n    error InvalidMultiSendInput();\n    error SafeExecTransactionFailed();\n    error UnableToParseOperation();\n\n    /// @notice uint256(keccak256(\"guard_manager.guard.address\"))\n    /// @dev This refers to the storage slot where guard is stored in Safe's layout: https://github.com/safe-global/safe-contracts/blob/ff4c6761fbfae8ab8a94f36fd26bcfb2b5414eb1/contracts/base/GuardManager.sol#L77\n    uint256 internal constant _GUARD_STORAGE_SLOT =\n        33528237782592280163068556224972516439282563014722366175641814928123294921928;\n    /// @notice uint256(keccak256(\"fallback_manager.handler.address\"))\n    /// @dev This refers to the storage slot where fallback handler is stored in Safe's layout: https://github.com/safe-global/safe-contracts/blob/ff4c6761fbfae8ab8a94f36fd26bcfb2b5414eb1/contracts/base/FallbackManager.sol#L14\n    uint256 internal constant _FALLBACK_HANDLER_STORAGE_SLOT =\n        49122629484629529244014240937346711770925847994644146912111677022347558721749;\n\n    /**\n     * @notice Contains hash for expected overridable guard removal calldata\n     * @dev This is the hash of the calldata for the following function call\n     *\n     * abi.encodeCall(IGnosisSafe.setGuard, (address(0))) = 0xe19a9dd90000000000000000000000000000000000000000000000000000000000000000\n     * keccak256(abi.encodeCall(IGnosisSafe.setGuard, (address(0)))) = 0xc0e2c16ecb99419a40dd8b9c0b339b27acebd27c481a28cd606927aeb86f5079\n     */\n    bytes32 internal constant _GUARD_REMOVAL_CALLDATA_HASH =\n        0xc0e2c16ecb99419a40dd8b9c0b339b27acebd27c481a28cd606927aeb86f5079;\n\n    /**\n     * @notice Contains hash for expected overridable fallback handler removal calldata\n     * @dev This is the hash of the calldata for the following function call\n     *\n     * abi.encodeCall(IGnosisSafe.setFallbackHandler, (address(0))) = 0xf08a0323000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n     * keccak256(abi.encodeCall(IGnosisSafe.setFallbackHandler, (address(0)))) = 0x5bdf8c44c012c1347b2b15694dc5cc39b899eb99e32614676b7661001be925b7\n     */\n    bytes32 internal constant _FALLBACK_REMOVAL_CALLDATA_HASH =\n        0x5bdf8c44c012c1347b2b15694dc5cc39b899eb99e32614676b7661001be925b7;\n\n    /**\n     * @notice Executes a transaction on a safe\n     *\n     * @dev Allows any contract using this library to execute a transaction on a safe\n     *  Assumes the contract using this method is the owner of the safe\n     *  Also assumes the safe is a single threshold safe\n     *  This uses pre-validated signature scheme used by gnosis\n     *\n     * @param safe Safe address\n     * @param target Target contract address\n     * @param op Safe Operation type\n     * @param data Transaction data\n     */\n    function _executeOnSafe(address safe, address target, Enum.Operation op, bytes memory data) internal {\n        bool success = IGnosisSafe(safe).execTransaction(\n            address(target), // to\n            0, // value\n            data, // data\n            op, // operation\n            0, // safeTxGas\n            0, // baseGas\n            0, // gasPrice\n            address(0), // gasToken\n            payable(address(0)), // refundReceiver\n            _generateSingleThresholdSignature(address(this)) // signatures\n        );\n\n        if (!success) revert SafeExecTransactionFailed();\n    }\n\n    /**\n     * @notice Generates a pre-validated signature for a safe transaction\n     * @dev Refer to https://docs.safe.global/learn/safe-core/safe-core-protocol/signatures#pre-validated-signatures\n     * This calldata assumes that owner is the actual address that will be sending the execTransaction call to safe\n     * @param owner Owner of the safe\n     * @return signatures bytes array containing single pre validated owner signature\n     */\n    function _generateSingleThresholdSignature(address owner) internal pure returns (bytes memory) {\n        bytes memory signatures = abi.encodePacked(\n            bytes12(0), // Padding for signature verifier address\n            bytes20(owner), // Signature Verifier\n            bytes32(0), // Position of extra data bytes (last set of data)\n            bytes1(hex\"01\") // Signature Type - 1 (presigned transaction)\n        );\n        return signatures;\n    }\n\n    /**\n     * @notice Packs multiple executables into a single bytes array compatible with Safe's MultiSend contract which can be used as argument for multicall method\n     * @dev Reference contract at https://github.com/safe-global/safe-contracts/blob/main/contracts/libraries/MultiSend.sol\n     * @param _txns Array of executables to pack\n     * @return packedTxns bytes array containing packed transactions\n     */\n    function _packMultisendTxns(Types.Executable[] memory _txns) internal pure returns (bytes memory packedTxns) {\n        uint256 len = _txns.length;\n        if (len == 0) revert InvalidMultiSendInput();\n\n        uint256 i = 0;\n        do {\n            // Enum.Operation.Call is 0\n            uint8 call = uint8(Enum.Operation.Call);\n            if (_txns[i].callType == Types.CallType.DELEGATECALL) {\n                call = uint8(Enum.Operation.DelegateCall);\n            } else if (_txns[i].callType == Types.CallType.STATICCALL) {\n                revert InvalidMultiSendCall(i);\n            }\n\n            uint256 calldataLength = _txns[i].data.length;\n\n            bytes memory encodedTxn = abi.encodePacked(\n                bytes1(call), bytes20(_txns[i].target), bytes32(_txns[i].value), bytes32(calldataLength), _txns[i].data\n            );\n\n            if (i != 0) {\n                // If not first transaction, append to packedTxns\n                packedTxns = abi.encodePacked(packedTxns, encodedTxn);\n            } else {\n                // If first transaction, set packedTxns to encodedTxn\n                packedTxns = encodedTxn;\n            }\n\n            unchecked {\n                ++i;\n            }\n        } while (i < len);\n    }\n\n    /**\n     * @notice Gets the guard for a safe\n     * @param safe address of safe\n     * @return address of guard, address(0) if no guard exists\n     */\n    function _getGuard(address safe) internal view returns (address) {\n        bytes memory guardAddress = IGnosisSafe(safe).getStorageAt(_GUARD_STORAGE_SLOT, 1);\n        return address(uint160(uint256(bytes32(guardAddress))));\n    }\n\n    /**\n     * @notice Gets the fallback handler for a safe\n     * @param safe address of safe\n     * @return address of fallback handler, address(0) if no fallback handler exists\n     */\n    function _getFallbackHandler(address safe) internal view returns (address) {\n        bytes memory fallbackHandlerAddress = IGnosisSafe(safe).getStorageAt(_FALLBACK_HANDLER_STORAGE_SLOT, 1);\n        return address(uint160(uint256(bytes32(fallbackHandlerAddress))));\n    }\n\n    /**\n     * @notice Converts a CallType enum to an Operation enum.\n     * @dev Reverts with UnableToParseOperation error if the CallType is not supported.\n     * @param callType The CallType enum to be converted.\n     * @return operation The converted Operation enum.\n     */\n    function _parseOperationEnum(Types.CallType callType) internal pure returns (Enum.Operation operation) {\n        if (callType == Types.CallType.DELEGATECALL) {\n            operation = Enum.Operation.DelegateCall;\n        } else if (callType == Types.CallType.CALL) {\n            operation = Enum.Operation.Call;\n        } else {\n            revert UnableToParseOperation();\n        }\n    }\n}"
    }
  ]
}