{
  "Title": "[M-05] Cashback on referral",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-02-aave-lens/blob/aaf6c116345f3647e11a35010f28e3b90e7b4862/contracts/core/modules/collect/FeeCollectModule.sol#L99\n\n\n# Vulnerability details\n\n## Impact\nIn the fee collect modules like `FeeCollectModule` there is no prevention of someone submitting a second profile they own as the `referrerProfileId` in `processCollect` to receive back part of the fees paid.\n\nThe referral system is essentially broken as all rational agents will submit a second profile they control to get back part of the fees.\nOne could even create a referrer smart contract profile that anyone can submit which automatically refunds the fee received.\nA [similar royalties/referral fees issue](https://github.com/code-423n4/2021-11-nested-findings/issues/30) was judged high-severity recently.\n\n## Recommended Mitigation Steps\nThere's no way to avoid this except by not allowing any profile as a referrer.\nWhitelist certain important infrastructure providers, like different frontends, as referrers and only allow these to be used instead of users submitting their alt profiles.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-aave-lens-contest",
  "Code": [
    {
      "filename": "contracts/core/modules/collect/FeeCollectModule.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {ICollectModule} from '../../../interfaces/ICollectModule.sol';\nimport {Errors} from '../../../libraries/Errors.sol';\nimport {FeeModuleBase} from '../FeeModuleBase.sol';\nimport {ModuleBase} from '../ModuleBase.sol';\nimport {FollowValidationModuleBase} from '../FollowValidationModuleBase.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * @notice A struct containing the necessary data to execute collect actions on a publication.\n *\n * @param amount The collecting cost associated with this publication.\n * @param recipient The recipient address associated with this publication.\n * @param currency The currency associated with this publication.\n * @param referralFee The referral fee associated with this publication.\n */\nstruct ProfilePublicationData {\n    uint256 amount;\n    address recipient;\n    address currency;\n    uint16 referralFee;\n}\n\n/**\n * @title FeeCollectModule\n * @author Lens Protocol\n *\n * @notice This is a simple Lens CollectModule implementation, inheriting from the ICollectModule interface and\n * the FeeCollectModuleBase abstract contract.\n *\n * This module works by allowing unlimited collects for a publication at a given price.\n */\ncontract FeeCollectModule is ICollectModule, FeeModuleBase, FollowValidationModuleBase {\n    using SafeERC20 for IERC20;\n\n    mapping(uint256 => mapping(uint256 => ProfilePublicationData))\n        internal _dataByPublicationByProfile;\n\n    constructor(address hub, address moduleGlobals) FeeModuleBase(moduleGlobals) ModuleBase(hub) {}\n\n    /**\n     * @notice This collect module levies a fee on collects and supports referrals. Thus, we need to decode data.\n     *\n     * @param profileId The token ID of the profile of the publisher, passed by the hub.\n     * @param pubId The publication ID of the newly created publication, passed by the hub.\n     * @param data The arbitrary data parameter, decoded into:\n     *      uint256 amount: The currency total amount to levy.\n     *      address currency: The currency address, must be internally whitelisted.\n     *      address recipient: The custom recipient address to direct earnings to.\n     *      uint16 referralFee: The referral fee to set.\n     *\n     * @return An abi encoded bytes parameter, which is the same as the passed data parameter.\n     */\n    function initializePublicationCollectModule(\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external override onlyHub returns (bytes memory) {\n        (uint256 amount, address currency, address recipient, uint16 referralFee) = abi.decode(\n            data,\n            (uint256, address, address, uint16)\n        );\n        if (\n            !_currencyWhitelisted(currency) ||\n            recipient == address(0) ||\n            referralFee > BPS_MAX ||\n            amount < BPS_MAX\n        ) revert Errors.InitParamsInvalid();\n\n        _dataByPublicationByProfile[profileId][pubId].referralFee = referralFee;\n        _dataByPublicationByProfile[profileId][pubId].recipient = recipient;\n        _dataByPublicationByProfile[profileId][pubId].currency = currency;\n        _dataByPublicationByProfile[profileId][pubId].amount = amount;\n\n        return data;\n    }\n\n    /**\n     * @dev Processes a collect by:\n     *  1. Ensuring the collector is a follower\n     *  2. Charging a fee\n     */\n    function processCollect(\n        uint256 referrerProfileId,\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external virtual override onlyHub {\n        _checkFollowValidity(profileId, collector);\n        if (referrerProfileId == profileId) {\n            _processCollect(collector, profileId, pubId, data);\n        } else {\n            _processCollectWithReferral(referrerProfileId, collector, profileId, pubId, data);\n        }\n    }\n\n    /**\n     * @notice Returns the publication data for a given publication, or an empty struct if that publication was not\n     * initialized with this module.\n     *\n     * @param profileId The token ID of the profile mapped to the publication to query.\n     * @param pubId The publication ID of the publication to query.\n     *\n     * @return The ProfilePublicationData struct mapped to that publication.\n     */\n    function getPublicationData(uint256 profileId, uint256 pubId)\n        external\n        view\n        returns (ProfilePublicationData memory)\n    {\n        return _dataByPublicationByProfile[profileId][pubId];\n    }\n\n    function _processCollect(\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) internal {\n        uint256 amount = _dataByPublicationByProfile[profileId][pubId].amount;\n        address currency = _dataByPublicationByProfile[profileId][pubId].currency;\n        _validateDataIsExpected(data, currency, amount);\n\n        (address treasury, uint16 treasuryFee) = _treasuryData();\n        address recipient = _dataByPublicationByProfile[profileId][pubId].recipient;\n        uint256 treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n        uint256 adjustedAmount = amount - treasuryAmount;\n\n        IERC20(currency).safeTransferFrom(collector, recipient, adjustedAmount);\n        IERC20(currency).safeTransferFrom(collector, treasury, treasuryAmount);\n    }\n\n    function _processCollectWithReferral(\n        uint256 referrerProfileId,\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) internal {\n        uint256 amount = _dataByPublicationByProfile[profileId][pubId].amount;\n        address currency = _dataByPublicationByProfile[profileId][pubId].currency;\n        _validateDataIsExpected(data, currency, amount);\n\n        uint256 referralFee = _dataByPublicationByProfile[profileId][pubId].referralFee;\n        address treasury;\n        uint256 treasuryAmount;\n\n        // Avoids stack too deep\n        {\n            uint16 treasuryFee;\n            (treasury, treasuryFee) = _treasuryData();\n            treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n        }\n\n        uint256 adjustedAmount = amount - treasuryAmount;\n\n        if (referralFee != 0) {\n            // The reason we levy the referral fee on the adjusted amount is so that referral fees\n            // don't bypass the treasury fee, in essence referrals pay their fair share to the treasury.\n            uint256 referralAmount = (adjustedAmount * referralFee) / BPS_MAX;\n            adjustedAmount = adjustedAmount - referralAmount;\n\n            address referralRecipient = IERC721(HUB).ownerOf(referrerProfileId);\n\n            IERC20(currency).safeTransferFrom(collector, referralRecipient, referralAmount);\n        }\n        address recipient = _dataByPublicationByProfile[profileId][pubId].recipient;\n\n        IERC20(currency).safeTransferFrom(collector, recipient, adjustedAmount);\n        IERC20(currency).safeTransferFrom(collector, treasury, treasuryAmount);\n    }\n}"
    }
  ]
}