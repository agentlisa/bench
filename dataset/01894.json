{
  "Title": "M-6: Inconsistency handling of DAI as collateral in the BuyUSSDSellCollateral function",
  "Content": "# Issue M-6: Inconsistency handling of DAI as collateral in the BuyUSSDSellCollateral function \n\nSource: https://github.com/sherlock-audit/2023-05-USSD-judging/issues/515 \n\n## Found by \n0xRobocop, GimelSec, J4de, WATCHPUG, saidam017\n## Summary\n\nDAI is the base asset of the `USSD.sol` contract, when a rebalacing needs to occur during a peg-down recovery, collateral is sold for DAI, which then is used to buy USSD in the DAI / USSD uniswap pool. Hence, when DAI is the collateral, this is not sold because there no existe a path to sell DAI for DAI.\n\n## Vulnerability Detail\n\nThe above behavior is handled when collateral is about to be sold for DAI, see the comment `no need to swap DAI` ([link to the code](https://github.com/sherlock-audit/2023-05-USSD/blob/6d7a9fdfb1f1ed838632c25b6e1b01748d0bafda/ussd-contracts/contracts/USSDRebalancer.sol#L117-L139)):\n\n```solidity\nif (collateralval > amountToBuyLeftUSD) {\n   // sell a portion of collateral and exit\n   if (collateral[i].pathsell.length > 0) {\n       uint256 amountBefore = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n       uint256 amountToSellUnits = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * ((amountToBuyLeftUSD * 1e18 / collateralval) / 1e18) / 1e18;\n       IUSSD(USSD).UniV3SwapInput(collateral[i].pathsell, amountToSellUnits);\n       amountToBuyLeftUSD -= (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n       DAItosell += (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n   } \n   else {\n       // no need to swap DAI\n       DAItosell = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * amountToBuyLeftUSD / collateralval;\n   }\n}\n\nelse {\n   // @audit-issue Not handling the case where this is DAI as is done above.\n   // sell all or skip (if collateral is too little, 5% treshold)\n   if (collateralval >= amountToBuyLeftUSD / 20) {\n      uint256 amountBefore = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n      // sell all collateral and move to next one\n      IUSSD(USSD).UniV3SwapInput(collateral[i].pathsell, IERC20Upgradeable(collateral[i].token).balanceOf(USSD));\n      amountToBuyLeftUSD -= (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n      DAItosell += (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n   }\n}\n```\nThe problem is in the `else branch` of the first if statement `collateralval > amountToBuyLeftUSD`, which lacks the check `if (collateral[i].pathsell.length > 0)`\n\n## Impact\n\nA re-balancing on a peg-down recovery will fail if the `collateralval` of DAI is less than `amountToBuyLeftUSD` but greater than `amountToBuyLeftUSD / 20` since the DAI collateral does not have a sell path.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/6d7a9fdfb1f1ed838632c25b6e1b01748d0bafda/ussd-contracts/contracts/USSDRebalancer.sol#L130-L139\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nHandle the case as is the done on the if branch of `collateralval > amountToBuyLeftUSD`:\n\n```solidity\nif (collateral[i].pathsell.length > 0) {\n  // Sell collateral for DAI\n}\nelse {\n // No need to swap DAI\n}\n```\n\n\n\n\n## Discussion\n\n**0xRobocop**\n\nEscalate for 10 USDC\n\nThis is not a duplicate of #111 \n\nThis issue points to an inconsistency in handling DAI as a collateral during peg-down recovery scenarios. The contract will try to sell DAI, but DAI does not have a sell path, so the transaction will revert.\n\n```solidity\nif (collateralval > amountToBuyLeftUSD) {\n   // sell a portion of collateral and exit\n   if (collateral[i].pathsell.length > 0) {\n       uint256 amountBefore = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n       uint256 amountToSellUnits = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * ((amountToBuyLeftUSD * 1e18 / collateralval) / 1e18) / 1e18;\n       IUSSD(USSD).UniV3SwapInput(collateral[i].pathsell, amountToSellUnits);\n       amountToBuyLeftUSD -= (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n       DAItosell += (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n   } \n   else {\n       // no need to swap DAI\n       DAItosell = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * amountToBuyLeftUSD / collateralval;\n   }\n}\n\nelse {\n   // @audit-issue Not handling the case where this is DAI as is done above.\n   // sell all or skip (if collateral is too little, 5% treshold)\n   if (collateralval >= amountToBuyLeftUSD / 20) {\n      uint256 amountBefore = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n      // sell all collateral and move to next one\n      IUSSD(USSD).UniV3SwapInput(collateral[i].pathsell, IERC20Upgradeable(collateral[i].token).balanceOf(USSD));\n      amountToBuyLeftUSD -= (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n      DAItosell += (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n   }\n}\n```\n\nSee the inconsistency on the upper `if` and `else` branches. The `else` branch may try to sell DAI, but DAI does not have a sell path.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> This is not a duplicate of #111 \n> \n> This issue points to an inconsistency in handling DAI as a collateral during peg-down recovery scenarios. The contract will try to sell DAI, but DAI does not have a sell path, so the transaction will revert.\n> \n> ```solidity\n> if (collateralval > amountToBuyLeftUSD) {\n>    // sell a portion of collateral and exit\n>    if (collateral[i].pathsell.length > 0) {\n>        uint256 amountBefore = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n>        uint256 amountToSellUnits = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * ((amountToBuyLeftUSD * 1e18 / collateralval) / 1e18) / 1e18;\n>        IUSSD(USSD).UniV3SwapInput(collateral[i].pathsell, amountToSellUnits);\n>        amountToBuyLeftUSD -= (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n>        DAItosell += (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n>    } \n>    else {\n>        // no need to swap DAI\n>        DAItosell = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * amountToBuyLeftUSD / collateralval;\n>    }\n> }\n> \n> else {\n>    // @audit-issue Not handling the case where this is DAI as is done above.\n>    // sell all or skip (if collateral is too little, 5% treshold)\n>    if (collateralval >= amountToBuyLeftUSD / 20) {\n>       uint256 amountBefore = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n>       // sell all collateral and move to next one\n>       IUSSD(USSD).UniV3SwapInput(collateral[i].pathsell, IERC20Upgradeable(collateral[i].token).balanceOf(USSD));\n>       amountToBuyLeftUSD -= (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n>       DAItosell += (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n>    }\n> }\n> ```\n> \n> See the inconsistency on the upper `if` and `else` branches. The `else` branch may try to sell DAI, but DAI does not have a sell path.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\n@ctf-sec \n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\n\n**sherlock-admin**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0xRobocop](https://github.com/sherlock-audit/2023-05-USSD-judging/issues/515/#issuecomment-1605656433): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/82",
  "Code": [
    {
      "filename": "ussd-contracts/contracts/USSDRebalancer.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"./interfaces/IUSSDRebalancer.sol\";\n\nimport \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n\n/**\n    @dev rebalancer module for USSD ERC20 token. Performs swaps to return USSD/DAI pool balance 1-to-1\n         selling USSD for buying collateral or buying and burning USSD for selling collateral\n */\ncontract USSDRebalancer is AccessControlUpgradeable, IUSSDRebalancer {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // main USSD/DAI pool\n    IUniswapV3Pool public uniPool;\n\n    // USSD token\n    address public USSD;\n\n    // boundary to make rebalancing\n    uint256 private threshold;\n\n    // ratios of collateralization for different collateral accumulating\n    uint256[] public flutterRatios;\n    \n    // base asset for other pool leg (DAI)\n    address private baseAsset;\n\n    // role to perform rebalancer management functions\n    bytes32 public constant STABLE_CONTROL_ROLE = keccak256(\"STABLECONTROL\");\n\n    function initialize(address _ussd) public initializer {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        threshold = 1e4;\n        USSD = _ussd;\n    }\n\n    modifier onlyControl() {\n        require(hasRole(STABLE_CONTROL_ROLE, msg.sender), \"control only\");\n        _;\n    }\n\n    function setPoolAddress(address _pool) public onlyControl {\n      uniPool = IUniswapV3Pool(_pool);\n    }\n\n    function getPool() public view override returns (address) {\n        return address(uniPool);\n    }\n\n    function setTreshold(uint256 _threshold) public onlyControl {\n      threshold = _threshold;\n    }\n\n    function setFlutterRatios(uint256[] calldata _flutterRatios) public onlyControl {\n      flutterRatios = _flutterRatios;\n    }\n\n    function setBaseAsset(address _baseAsset) public onlyControl {\n      baseAsset = _baseAsset;\n    }\n\n    /// @dev get price estimation to DAI using pool address and uniswap price\n    function getOwnValuation() public view returns (uint256 price) {\n      (uint160 sqrtPriceX96,,,,,,) =  uniPool.slot0();\n      if(uniPool.token0() == USSD) {\n        price = uint(sqrtPriceX96)*(uint(sqrtPriceX96))/(1e6) >> (96 * 2);\n      } else {\n        price = uint(sqrtPriceX96)*(uint(sqrtPriceX96))*(1e18 /* 1e12 + 1e6 decimal representation */) >> (96 * 2);\n        // flip the fraction\n        price = (1e24 / price) / 1e12;\n      }\n    }\n\n    /// @dev return pool balances with USSD first\n    function getSupplyProportion() public view returns (uint256, uint256) {\n      uint256 vol1 = IERC20Upgradeable(uniPool.token0()).balanceOf(address(uniPool));\n      uint256 vol2 = IERC20Upgradeable(uniPool.token1()).balanceOf(address(uniPool));\n      if (uniPool.token0() == USSD) {\n        return (vol1, vol2);\n      }\n      return (vol2, vol1);\n    }\n\n    function rebalance() override public {\n      uint256 ownval = getOwnValuation();\n      (uint256 USSDamount, uint256 DAIamount) = getSupplyProportion();\n      if (ownval < 1e6 - threshold) {\n        // peg-down recovery\n        BuyUSSDSellCollateral((USSDamount - DAIamount / 1e12)/2);\n      } else if (ownval > 1e6 + threshold) {\n        // mint and buy collateral\n        // never sell too much USSD for DAI so it 'overshoots' (becomes more in quantity than DAI on the pool)\n        // otherwise could be arbitraged through mint/redeem\n        // the execution difference due to fee should be taken into accounting too\n        // take 1% safety margin (estimated as 2 x 0.5% fee)\n        IUSSD(USSD).mintRebalancer(((DAIamount / 1e12 - USSDamount)/2) * 99 / 100); // mint ourselves amount till balance recover\n        SellUSSDBuyCollateral();\n      }\n    }\n\n    function BuyUSSDSellCollateral(uint256 amountToBuy) internal {\n      CollateralInfo[] memory collateral = IUSSD(USSD).collateralList();\n      //uint amountToBuyLeftUSD = amountToBuy * 1e12 * 1e6 / getOwnValuation();\n      uint amountToBuyLeftUSD = amountToBuy * 1e12;\n      uint DAItosell = 0;\n      // Sell collateral in order of collateral array\n      for (uint256 i = 0; i < collateral.length; i++) {\n        uint256 collateralval = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * 1e18 / (10**IERC20MetadataUpgradeable(collateral[i].token).decimals()) * collateral[i].oracle.getPriceUSD() / 1e18;\n        if (collateralval > amountToBuyLeftUSD) {\n          // sell a portion of collateral and exit\n          if (collateral[i].pathsell.length > 0) {\n            uint256 amountBefore = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n            uint256 amountToSellUnits = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * ((amountToBuyLeftUSD * 1e18 / collateralval) / 1e18) / 1e18;\n            IUSSD(USSD).UniV3SwapInput(collateral[i].pathsell, amountToSellUnits);\n            amountToBuyLeftUSD -= (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n            DAItosell += (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n          } else {\n            // no need to swap DAI\n            DAItosell = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * amountToBuyLeftUSD / collateralval;\n          }\n          break;\n        } else {\n          // sell all or skip (if collateral is too little, 5% treshold)\n          if (collateralval >= amountToBuyLeftUSD / 20) {\n            uint256 amountBefore = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n            // sell all collateral and move to next one\n            IUSSD(USSD).UniV3SwapInput(collateral[i].pathsell, IERC20Upgradeable(collateral[i].token).balanceOf(USSD));\n            amountToBuyLeftUSD -= (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n            DAItosell += (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n          }\n        }\n      }\n\n      // buy USSD (sell DAI) to burn\n      // never sell too much DAI so USSD 'overshoots' (becomes less in quantity than DAI on the pool)\n      // otherwise could be arbitraged through mint/redeem\n      // the remainder (should be small, due to oracle twap lag) to be left as DAI collateral\n      // the execution difference due to fee should be taken into accounting too\n      // take 1% safety margin (estimated as 2 x 0.5% fee)\n      if (DAItosell > amountToBuy * 1e12 * 99 / 100) {\n        DAItosell = amountToBuy * 1e12 * 99 / 100;\n      }\n\n      if (DAItosell > 0) {\n        if (uniPool.token0() == USSD) {\n            IUSSD(USSD).UniV3SwapInput(bytes.concat(abi.encodePacked(uniPool.token1(), hex\"0001f4\", uniPool.token0())), DAItosell);\n        } else {\n            IUSSD(USSD).UniV3SwapInput(bytes.concat(abi.encodePacked(uniPool.token0(), hex\"0001f4\", uniPool.token1())), DAItosell);\n        }\n      }\n\n      IUSSD(USSD).burnRebalancer(IUSSD(USSD).balanceOf(USSD));\n    }\n\n    function SellUSSDBuyCollateral() internal {\n      uint256 amount = IUSSD(USSD).balanceOf(USSD);\n      // sell for DAI then swap by DAI routes\n      uint256 daibought = 0;\n      if (uniPool.token0() == USSD) {\n        daibought = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n        IUSSD(USSD).UniV3SwapInput(bytes.concat(abi.encodePacked(uniPool.token0(), hex\"0001f4\", uniPool.token1())), amount);\n        daibought = IERC20Upgradeable(baseAsset).balanceOf(USSD) - daibought; // would revert if not bought\n      } else {\n        daibought = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n        IUSSD(USSD).UniV3SwapInput(bytes.concat(abi.encodePacked(uniPool.token1(), hex\"0001f4\", uniPool.token0())), amount);\n        daibought = IERC20Upgradeable(baseAsset).balanceOf(USSD) - daibought; // would revert if not bought\n      }\n\n      // total collateral portions\n      uint256 cf = IUSSD(USSD).collateralFactor();\n      uint256 flutter = 0;\n      for (flutter = 0; flutter < flutterRatios.length; flutter++) {\n        if (cf < flutterRatios[flutter]) {\n          break;\n        }\n      }\n\n      CollateralInfo[] memory collateral = IUSSD(USSD).collateralList();\n      uint portions = 0;\n      uint ownval = (getOwnValuation() * 1e18 / 1e6) * IUSSD(USSD).totalSupply() / 1e6; // 1e18 total USSD value\n      for (uint256 i = 0; i < collateral.length; i++) {\n        uint256 collateralval = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * 1e18 / (10**IERC20MetadataUpgradeable(collateral[i].token).decimals()) * collateral[i].oracle.getPriceUSD() / 1e18;\n        if (collateralval * 1e18 / ownval < collateral[i].ratios[flutter]) {\n          portions++;\n        }\n      }\n\n      for (uint256 i = 0; i < collateral.length; i++) {\n        uint256 collateralval = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * 1e18 / (10**IERC20MetadataUpgradeable(collateral[i].token).decimals()) * collateral[i].oracle.getPriceUSD() / 1e18;\n        if (collateralval * 1e18 / ownval < collateral[i].ratios[flutter]) {\n          if (collateral[i].token != uniPool.token0() || collateral[i].token != uniPool.token1()) {\n            // don't touch DAI if it's needed to be bought (it's already bought)\n            IUSSD(USSD).UniV3SwapInput(collateral[i].pathbuy, daibought/portions);\n          }\n        }\n      }\n    }\n}"
    },
    {
      "filename": "ussd-contracts/contracts/USSDRebalancer.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"./interfaces/IUSSDRebalancer.sol\";\n\nimport \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n\n/**\n    @dev rebalancer module for USSD ERC20 token. Performs swaps to return USSD/DAI pool balance 1-to-1\n         selling USSD for buying collateral or buying and burning USSD for selling collateral\n */\ncontract USSDRebalancer is AccessControlUpgradeable, IUSSDRebalancer {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // main USSD/DAI pool\n    IUniswapV3Pool public uniPool;\n\n    // USSD token\n    address public USSD;\n\n    // boundary to make rebalancing\n    uint256 private threshold;\n\n    // ratios of collateralization for different collateral accumulating\n    uint256[] public flutterRatios;\n    \n    // base asset for other pool leg (DAI)\n    address private baseAsset;\n\n    // role to perform rebalancer management functions\n    bytes32 public constant STABLE_CONTROL_ROLE = keccak256(\"STABLECONTROL\");\n\n    function initialize(address _ussd) public initializer {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        threshold = 1e4;\n        USSD = _ussd;\n    }\n\n    modifier onlyControl() {\n        require(hasRole(STABLE_CONTROL_ROLE, msg.sender), \"control only\");\n        _;\n    }\n\n    function setPoolAddress(address _pool) public onlyControl {\n      uniPool = IUniswapV3Pool(_pool);\n    }\n\n    function getPool() public view override returns (address) {\n        return address(uniPool);\n    }\n\n    function setTreshold(uint256 _threshold) public onlyControl {\n      threshold = _threshold;\n    }\n\n    function setFlutterRatios(uint256[] calldata _flutterRatios) public onlyControl {\n      flutterRatios = _flutterRatios;\n    }\n\n    function setBaseAsset(address _baseAsset) public onlyControl {\n      baseAsset = _baseAsset;\n    }\n\n    /// @dev get price estimation to DAI using pool address and uniswap price\n    function getOwnValuation() public view returns (uint256 price) {\n      (uint160 sqrtPriceX96,,,,,,) =  uniPool.slot0();\n      if(uniPool.token0() == USSD) {\n        price = uint(sqrtPriceX96)*(uint(sqrtPriceX96))/(1e6) >> (96 * 2);\n      } else {\n        price = uint(sqrtPriceX96)*(uint(sqrtPriceX96))*(1e18 /* 1e12 + 1e6 decimal representation */) >> (96 * 2);\n        // flip the fraction\n        price = (1e24 / price) / 1e12;\n      }\n    }\n\n    /// @dev return pool balances with USSD first\n    function getSupplyProportion() public view returns (uint256, uint256) {\n      uint256 vol1 = IERC20Upgradeable(uniPool.token0()).balanceOf(address(uniPool));\n      uint256 vol2 = IERC20Upgradeable(uniPool.token1()).balanceOf(address(uniPool));\n      if (uniPool.token0() == USSD) {\n        return (vol1, vol2);\n      }\n      return (vol2, vol1);\n    }\n\n    function rebalance() override public {\n      uint256 ownval = getOwnValuation();\n      (uint256 USSDamount, uint256 DAIamount) = getSupplyProportion();\n      if (ownval < 1e6 - threshold) {\n        // peg-down recovery\n        BuyUSSDSellCollateral((USSDamount - DAIamount / 1e12)/2);\n      } else if (ownval > 1e6 + threshold) {\n        // mint and buy collateral\n        // never sell too much USSD for DAI so it 'overshoots' (becomes more in quantity than DAI on the pool)\n        // otherwise could be arbitraged through mint/redeem\n        // the execution difference due to fee should be taken into accounting too\n        // take 1% safety margin (estimated as 2 x 0.5% fee)\n        IUSSD(USSD).mintRebalancer(((DAIamount / 1e12 - USSDamount)/2) * 99 / 100); // mint ourselves amount till balance recover\n        SellUSSDBuyCollateral();\n      }\n    }\n\n    function BuyUSSDSellCollateral(uint256 amountToBuy) internal {\n      CollateralInfo[] memory collateral = IUSSD(USSD).collateralList();\n      //uint amountToBuyLeftUSD = amountToBuy * 1e12 * 1e6 / getOwnValuation();\n      uint amountToBuyLeftUSD = amountToBuy * 1e12;\n      uint DAItosell = 0;\n      // Sell collateral in order of collateral array\n      for (uint256 i = 0; i < collateral.length; i++) {\n        uint256 collateralval = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * 1e18 / (10**IERC20MetadataUpgradeable(collateral[i].token).decimals()) * collateral[i].oracle.getPriceUSD() / 1e18;\n        if (collateralval > amountToBuyLeftUSD) {\n          // sell a portion of collateral and exit\n          if (collateral[i].pathsell.length > 0) {\n            uint256 amountBefore = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n            uint256 amountToSellUnits = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * ((amountToBuyLeftUSD * 1e18 / collateralval) / 1e18) / 1e18;\n            IUSSD(USSD).UniV3SwapInput(collateral[i].pathsell, amountToSellUnits);\n            amountToBuyLeftUSD -= (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n            DAItosell += (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n          } else {\n            // no need to swap DAI\n            DAItosell = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * amountToBuyLeftUSD / collateralval;\n          }\n          break;\n        } else {\n          // sell all or skip (if collateral is too little, 5% treshold)\n          if (collateralval >= amountToBuyLeftUSD / 20) {\n            uint256 amountBefore = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n            // sell all collateral and move to next one\n            IUSSD(USSD).UniV3SwapInput(collateral[i].pathsell, IERC20Upgradeable(collateral[i].token).balanceOf(USSD));\n            amountToBuyLeftUSD -= (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n            DAItosell += (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n          }\n        }\n      }\n\n      // buy USSD (sell DAI) to burn\n      // never sell too much DAI so USSD 'overshoots' (becomes less in quantity than DAI on the pool)\n      // otherwise could be arbitraged through mint/redeem\n      // the remainder (should be small, due to oracle twap lag) to be left as DAI collateral\n      // the execution difference due to fee should be taken into accounting too\n      // take 1% safety margin (estimated as 2 x 0.5% fee)\n      if (DAItosell > amountToBuy * 1e12 * 99 / 100) {\n        DAItosell = amountToBuy * 1e12 * 99 / 100;\n      }\n\n      if (DAItosell > 0) {\n        if (uniPool.token0() == USSD) {\n            IUSSD(USSD).UniV3SwapInput(bytes.concat(abi.encodePacked(uniPool.token1(), hex\"0001f4\", uniPool.token0())), DAItosell);\n        } else {\n            IUSSD(USSD).UniV3SwapInput(bytes.concat(abi.encodePacked(uniPool.token0(), hex\"0001f4\", uniPool.token1())), DAItosell);\n        }\n      }\n\n      IUSSD(USSD).burnRebalancer(IUSSD(USSD).balanceOf(USSD));\n    }\n\n    function SellUSSDBuyCollateral() internal {\n      uint256 amount = IUSSD(USSD).balanceOf(USSD);\n      // sell for DAI then swap by DAI routes\n      uint256 daibought = 0;\n      if (uniPool.token0() == USSD) {\n        daibought = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n        IUSSD(USSD).UniV3SwapInput(bytes.concat(abi.encodePacked(uniPool.token0(), hex\"0001f4\", uniPool.token1())), amount);\n        daibought = IERC20Upgradeable(baseAsset).balanceOf(USSD) - daibought; // would revert if not bought\n      } else {\n        daibought = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n        IUSSD(USSD).UniV3SwapInput(bytes.concat(abi.encodePacked(uniPool.token1(), hex\"0001f4\", uniPool.token0())), amount);\n        daibought = IERC20Upgradeable(baseAsset).balanceOf(USSD) - daibought; // would revert if not bought\n      }\n\n      // total collateral portions\n      uint256 cf = IUSSD(USSD).collateralFactor();\n      uint256 flutter = 0;\n      for (flutter = 0; flutter < flutterRatios.length; flutter++) {\n        if (cf < flutterRatios[flutter]) {\n          break;\n        }\n      }\n\n      CollateralInfo[] memory collateral = IUSSD(USSD).collateralList();\n      uint portions = 0;\n      uint ownval = (getOwnValuation() * 1e18 / 1e6) * IUSSD(USSD).totalSupply() / 1e6; // 1e18 total USSD value\n      for (uint256 i = 0; i < collateral.length; i++) {\n        uint256 collateralval = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * 1e18 / (10**IERC20MetadataUpgradeable(collateral[i].token).decimals()) * collateral[i].oracle.getPriceUSD() / 1e18;\n        if (collateralval * 1e18 / ownval < collateral[i].ratios[flutter]) {\n          portions++;\n        }\n      }\n\n      for (uint256 i = 0; i < collateral.length; i++) {\n        uint256 collateralval = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * 1e18 / (10**IERC20MetadataUpgradeable(collateral[i].token).decimals()) * collateral[i].oracle.getPriceUSD() / 1e18;\n        if (collateralval * 1e18 / ownval < collateral[i].ratios[flutter]) {\n          if (collateral[i].token != uniPool.token0() || collateral[i].token != uniPool.token1()) {\n            // don't touch DAI if it's needed to be bought (it's already bought)\n            IUSSD(USSD).UniV3SwapInput(collateral[i].pathbuy, daibought/portions);\n          }\n        }\n      }\n    }\n}"
    }
  ]
}