{
  "Title": "[09] Unneeded function still not removed",
  "Content": "Per Pashov's audit report, L-04 mentioned that the unused `EthenaMinting::encodeRoute` has been removed by Ethena. However, this erroneous function still exists in EthenaMinting.sol. \n\nhttps://github.com/code-423n4/2023-10-ethena/blob/main/contracts/EthenaMinting.sol#L334-L336\n\n```diff\n-  function encodeRoute(Route calldata route) public pure returns (bytes memory) {\n-    return abi.encode(ROUTE_TYPE, route.addresses, route.ratios);\n-  }\n```\nConsider removing this controversial function where possible. \n\n**[FJ-Riveros (Ethena) acknowledged](https://github.com/code-423n4/2023-10-ethena-findings/issues/602#issuecomment-1804182947)**\n\n***Note: the following submissions from the same warden were downgraded from Medium to Low/Non-critical and were also considered by the judge in scoring:***\n- [[10] Inconsistent Role-Based Checks in `redistributeLockedAmount` and `_beforeTokenTransfer functions`](https://github.com/code-423n4/2023-10-ethena-findings/issues/367)\n- [[11] Denial-of-Service Vulnerability via Minimum Shares Restriction](https://github.com/code-423n4/2023-10-ethena-findings/issues/371)\n- [[12] Inflexible Withdrawal Management in StakedUSDeV2 Contract](https://github.com/code-423n4/2023-10-ethena-findings/issues/389)\n\n\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-10-ethena",
  "Code": [
    {
      "filename": "contracts/EthenaMinting.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\n/**\n * solhint-disable private-vars-leading-underscore\n */\n\nimport \"./SingleAdminAccessControl.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport \"./interfaces/IUSDe.sol\";\nimport \"./interfaces/IEthenaMinting.sol\";\n\n/**\n * @title Ethena Minting\n * @notice This contract mints and redeems USDe in a single, atomic, trustless transaction\n */\ncontract EthenaMinting is IEthenaMinting, SingleAdminAccessControl, ReentrancyGuard {\n  using SafeERC20 for IERC20;\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  /* --------------- CONSTANTS --------------- */\n\n  /// @notice EIP712 domain\n  bytes32 private constant EIP712_DOMAIN =\n    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n  /// @notice route type\n  bytes32 private constant ROUTE_TYPE = keccak256(\"Route(address[] addresses,uint256[] ratios)\");\n\n  /// @notice order type\n  bytes32 private constant ORDER_TYPE = keccak256(\n    \"Order(uint8 order_type,uint256 expiry,uint256 nonce,address benefactor,address beneficiary,address collateral_asset,uint256 collateral_amount,uint256 usde_amount)\"\n  );\n\n  /// @notice role enabling to invoke mint\n  bytes32 private constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n  /// @notice role enabling to invoke redeem\n  bytes32 private constant REDEEMER_ROLE = keccak256(\"REDEEMER_ROLE\");\n\n  /// @notice role enabling to disable mint and redeem and remove minters and redeemers in an emergency\n  bytes32 private constant GATEKEEPER_ROLE = keccak256(\"GATEKEEPER_ROLE\");\n\n  /// @notice EIP712 domain hash\n  bytes32 private constant EIP712_DOMAIN_TYPEHASH = keccak256(abi.encodePacked(EIP712_DOMAIN));\n\n  /// @notice address denoting native ether\n  address private constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n  /// @notice EIP712 name\n  bytes32 private constant EIP_712_NAME = keccak256(\"EthenaMinting\");\n\n  /// @notice holds EIP712 revision\n  bytes32 private constant EIP712_REVISION = keccak256(\"1\");\n\n  /* --------------- STATE VARIABLES --------------- */\n\n  /// @notice usde stablecoin\n  IUSDe public usde;\n\n  /// @notice Supported assets\n  EnumerableSet.AddressSet internal _supportedAssets;\n\n  // @notice custodian addresses\n  EnumerableSet.AddressSet internal _custodianAddresses;\n\n  /// @notice holds computable chain id\n  uint256 private immutable _chainId;\n\n  /// @notice holds computable domain separator\n  bytes32 private immutable _domainSeparator;\n\n  /// @notice user deduplication\n  mapping(address => mapping(uint256 => uint256)) private _orderBitmaps;\n\n  /// @notice USDe minted per block\n  mapping(uint256 => uint256) public mintedPerBlock;\n  /// @notice USDe redeemed per block\n  mapping(uint256 => uint256) public redeemedPerBlock;\n\n  /// @notice For smart contracts to delegate signing to EOA address\n  mapping(address => mapping(address => bool)) public delegatedSigner;\n\n  /// @notice max minted USDe allowed per block\n  uint256 public maxMintPerBlock;\n  ///Â @notice max redeemed USDe allowed per block\n  uint256 public maxRedeemPerBlock;\n\n  /* --------------- MODIFIERS --------------- */\n\n  /// @notice ensure that the already minted USDe in the actual block plus the amount to be minted is below the maxMintPerBlock var\n  /// @param mintAmount The USDe amount to be minted\n  modifier belowMaxMintPerBlock(uint256 mintAmount) {\n    if (mintedPerBlock[block.number] + mintAmount > maxMintPerBlock) revert MaxMintPerBlockExceeded();\n    _;\n  }\n\n  /// @notice ensure that the already redeemed USDe in the actual block plus the amount to be redeemed is below the maxRedeemPerBlock var\n  /// @param redeemAmount The USDe amount to be redeemed\n  modifier belowMaxRedeemPerBlock(uint256 redeemAmount) {\n    if (redeemedPerBlock[block.number] + redeemAmount > maxRedeemPerBlock) revert MaxRedeemPerBlockExceeded();\n    _;\n  }\n\n  /* --------------- CONSTRUCTOR --------------- */\n\n  constructor(\n    IUSDe _usde,\n    address[] memory _assets,\n    address[] memory _custodians,\n    address _admin,\n    uint256 _maxMintPerBlock,\n    uint256 _maxRedeemPerBlock\n  ) {\n    if (address(_usde) == address(0)) revert InvalidUSDeAddress();\n    if (_assets.length == 0) revert NoAssetsProvided();\n    if (_admin == address(0)) revert InvalidZeroAddress();\n    usde = _usde;\n\n    _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n\n    for (uint256 i = 0; i < _assets.length; i++) {\n      addSupportedAsset(_assets[i]);\n    }\n\n    for (uint256 j = 0; j < _custodians.length; j++) {\n      addCustodianAddress(_custodians[j]);\n    }\n\n    // Set the max mint/redeem limits per block\n    _setMaxMintPerBlock(_maxMintPerBlock);\n    _setMaxRedeemPerBlock(_maxRedeemPerBlock);\n\n    if (msg.sender != _admin) {\n      _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n\n    _chainId = block.chainid;\n    _domainSeparator = _computeDomainSeparator();\n\n    emit USDeSet(address(_usde));\n  }\n\n  /* --------------- EXTERNAL --------------- */\n\n  /**\n   * @notice Fallback function to receive ether\n   */\n  receive() external payable {\n    emit Received(msg.sender, msg.value);\n  }\n\n  /**\n   * @notice Mint stablecoins from assets\n   * @param order struct containing order details and confirmation from server\n   * @param signature signature of the taker\n   */\n  function mint(Order calldata order, Route calldata route, Signature calldata signature)\n    external\n    override\n    nonReentrant\n    onlyRole(MINTER_ROLE)\n    belowMaxMintPerBlock(order.usde_amount)\n  {\n    if (order.order_type != OrderType.MINT) revert InvalidOrder();\n    verifyOrder(order, signature);\n    if (!verifyRoute(route, order.order_type)) revert InvalidRoute();\n    if (!_deduplicateOrder(order.benefactor, order.nonce)) revert Duplicate();\n    // Add to the minted amount in this block\n    mintedPerBlock[block.number] += order.usde_amount;\n    _transferCollateral(\n      order.collateral_amount, order.collateral_asset, order.benefactor, route.addresses, route.ratios\n    );\n    usde.mint(order.beneficiary, order.usde_amount);\n    emit Mint(\n      msg.sender,\n      order.benefactor,\n      order.beneficiary,\n      order.collateral_asset,\n      order.collateral_amount,\n      order.usde_amount\n    );\n  }\n\n  /**\n   * @notice Redeem stablecoins for assets\n   * @param order struct containing order details and confirmation from server\n   * @param signature signature of the taker\n   */\n  function redeem(Order calldata order, Signature calldata signature)\n    external\n    override\n    nonReentrant\n    onlyRole(REDEEMER_ROLE)\n    belowMaxRedeemPerBlock(order.usde_amount)\n  {\n    if (order.order_type != OrderType.REDEEM) revert InvalidOrder();\n    verifyOrder(order, signature);\n    if (!_deduplicateOrder(order.benefactor, order.nonce)) revert Duplicate();\n    // Add to the redeemed amount in this block\n    redeemedPerBlock[block.number] += order.usde_amount;\n    usde.burnFrom(order.benefactor, order.usde_amount);\n    _transferToBeneficiary(order.beneficiary, order.collateral_asset, order.collateral_amount);\n    emit Redeem(\n      msg.sender,\n      order.benefactor,\n      order.beneficiary,\n      order.collateral_asset,\n      order.collateral_amount,\n      order.usde_amount\n    );\n  }\n\n  /// @notice Sets the max mintPerBlock limit\n  function setMaxMintPerBlock(uint256 _maxMintPerBlock) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setMaxMintPerBlock(_maxMintPerBlock);\n  }\n\n  /// @notice Sets the max redeemPerBlock limit\n  function setMaxRedeemPerBlock(uint256 _maxRedeemPerBlock) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setMaxRedeemPerBlock(_maxRedeemPerBlock);\n  }\n\n  /// @notice Disables the mint and redeem\n  function disableMintRedeem() external onlyRole(GATEKEEPER_ROLE) {\n    _setMaxMintPerBlock(0);\n    _setMaxRedeemPerBlock(0);\n  }\n\n  /// @notice Enables smart contracts to delegate an address for signing\n  function setDelegatedSigner(address _delegateTo) external {\n    delegatedSigner[_delegateTo][msg.sender] = true;\n    emit DelegatedSignerAdded(_delegateTo, msg.sender);\n  }\n\n  /// @notice Enables smart contracts to undelegate an address for signing\n  function removeDelegatedSigner(address _removedSigner) external {\n    delegatedSigner[_removedSigner][msg.sender] = false;\n    emit DelegatedSignerRemoved(_removedSigner, msg.sender);\n  }\n\n  /// @notice transfers an asset to a custody wallet\n  function transferToCustody(address wallet, address asset, uint256 amount) external nonReentrant onlyRole(MINTER_ROLE) {\n    if (wallet == address(0) || !_custodianAddresses.contains(wallet)) revert InvalidAddress();\n    if (asset == NATIVE_TOKEN) {\n      (bool success,) = wallet.call{value: amount}(\"\");\n      if (!success) revert TransferFailed();\n    } else {\n      IERC20(asset).safeTransfer(wallet, amount);\n    }\n    emit CustodyTransfer(wallet, asset, amount);\n  }\n\n  /// @notice Removes an asset from the supported assets list\n  function removeSupportedAsset(address asset) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (!_supportedAssets.remove(asset)) revert InvalidAssetAddress();\n    emit AssetRemoved(asset);\n  }\n\n  /// @notice Checks if an asset is supported.\n  function isSupportedAsset(address asset) external view returns (bool) {\n    return _supportedAssets.contains(asset);\n  }\n\n  /// @notice Removes an custodian from the custodian address list\n  function removeCustodianAddress(address custodian) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (!_custodianAddresses.remove(custodian)) revert InvalidCustodianAddress();\n    emit CustodianAddressRemoved(custodian);\n  }\n\n  /// @notice Removes the minter role from an account, this can ONLY be executed by the gatekeeper role\n  /// @param minter The address to remove the minter role from\n  function removeMinterRole(address minter) external onlyRole(GATEKEEPER_ROLE) {\n    _revokeRole(MINTER_ROLE, minter);\n  }\n\n  /// @notice Removes the redeemer role from an account, this can ONLY be executed by the gatekeeper role\n  /// @param redeemer The address to remove the redeemer role from\n  function removeRedeemerRole(address redeemer) external onlyRole(GATEKEEPER_ROLE) {\n    _revokeRole(REDEEMER_ROLE, redeemer);\n  }\n\n  /* --------------- PUBLIC --------------- */\n\n  /// @notice Adds an asset to the supported assets list.\n  function addSupportedAsset(address asset) public onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (asset == address(0) || asset == address(usde) || !_supportedAssets.add(asset)) {\n      revert InvalidAssetAddress();\n    }\n    emit AssetAdded(asset);\n  }\n\n  /// @notice Adds an custodian to the supported custodians list.\n  function addCustodianAddress(address custodian) public onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (custodian == address(0) || custodian == address(usde) || !_custodianAddresses.add(custodian)) {\n      revert InvalidCustodianAddress();\n    }\n    emit CustodianAddressAdded(custodian);\n  }\n\n  /// @notice Get the domain separator for the token\n  /// @dev Return cached value if chainId matches cache, otherwise recomputes separator, to prevent replay attack across forks\n  /// @return The domain separator of the token at current chain\n  function getDomainSeparator() public view returns (bytes32) {\n    if (block.chainid == _chainId) {\n      return _domainSeparator;\n    }\n    return _computeDomainSeparator();\n  }\n\n  /// @notice hash an Order struct\n  function hashOrder(Order calldata order) public view override returns (bytes32) {\n    return ECDSA.toTypedDataHash(getDomainSeparator(), keccak256(encodeOrder(order)));\n  }\n\n  function encodeOrder(Order calldata order) public pure returns (bytes memory) {\n    return abi.encode(\n      ORDER_TYPE,\n      order.order_type,\n      order.expiry,\n      order.nonce,\n      order.benefactor,\n      order.beneficiary,\n      order.collateral_asset,\n      order.collateral_amount,\n      order.usde_amount\n    );\n  }\n\n  function encodeRoute(Route calldata route) public pure returns (bytes memory) {\n    return abi.encode(ROUTE_TYPE, route.addresses, route.ratios);\n  }\n\n  /// @notice assert validity of signed order\n  function verifyOrder(Order calldata order, Signature calldata signature) public view override returns (bool, bytes32) {\n    bytes32 taker_order_hash = hashOrder(order);\n    address signer = ECDSA.recover(taker_order_hash, signature.signature_bytes);\n    if (!(signer == order.benefactor || delegatedSigner[signer][order.benefactor])) revert InvalidSignature();\n    if (order.beneficiary == address(0)) revert InvalidAmount();\n    if (order.collateral_amount == 0) revert InvalidAmount();\n    if (order.usde_amount == 0) revert InvalidAmount();\n    if (block.timestamp > order.expiry) revert SignatureExpired();\n    return (true, taker_order_hash);\n  }\n\n  /// @notice assert validity of route object per type\n  function verifyRoute(Route calldata route, OrderType orderType) public view override returns (bool) {\n    // routes only used to mint\n    if (orderType == OrderType.REDEEM) {\n      return true;\n    }\n    uint256 totalRatio = 0;\n    if (route.addresses.length != route.ratios.length) {\n      return false;\n    }\n    if (route.addresses.length == 0) {\n      return false;\n    }\n    for (uint256 i = 0; i < route.addresses.length; ++i) {\n      if (!_custodianAddresses.contains(route.addresses[i]) || route.addresses[i] == address(0) || route.ratios[i] == 0)\n      {\n        return false;\n      }\n      totalRatio += route.ratios[i];\n    }\n    if (totalRatio != 10_000) {\n      return false;\n    }\n    return true;\n  }\n\n  /// @notice verify validity of nonce by checking its presence\n  function verifyNonce(address sender, uint256 nonce) public view override returns (bool, uint256, uint256, uint256) {\n    if (nonce == 0) revert InvalidNonce();\n    uint256 invalidatorSlot = uint64(nonce) >> 8;\n    uint256 invalidatorBit = 1 << uint8(nonce);\n    mapping(uint256 => uint256) storage invalidatorStorage = _orderBitmaps[sender];\n    uint256 invalidator = invalidatorStorage[invalidatorSlot];\n    if (invalidator & invalidatorBit != 0) revert InvalidNonce();\n\n    return (true, invalidatorSlot, invalidator, invalidatorBit);\n  }\n\n  /* --------------- PRIVATE --------------- */\n\n  /// @notice deduplication of taker order\n  function _deduplicateOrder(address sender, uint256 nonce) private returns (bool) {\n    (bool valid, uint256 invalidatorSlot, uint256 invalidator, uint256 invalidatorBit) = verifyNonce(sender, nonce);\n    mapping(uint256 => uint256) storage invalidatorStorage = _orderBitmaps[sender];\n    invalidatorStorage[invalidatorSlot] = invalidator | invalidatorBit;\n    return valid;\n  }\n\n  /* --------------- INTERNAL --------------- */\n\n  /// @notice transfer supported asset to beneficiary address\n  function _transferToBeneficiary(address beneficiary, address asset, uint256 amount) internal {\n    if (asset == NATIVE_TOKEN) {\n      if (address(this).balance < amount) revert InvalidAmount();\n      (bool success,) = (beneficiary).call{value: amount}(\"\");\n      if (!success) revert TransferFailed();\n    } else {\n      if (!_supportedAssets.contains(asset)) revert UnsupportedAsset();\n      IERC20(asset).safeTransfer(beneficiary, amount);\n    }\n  }\n\n  /// @notice transfer supported asset to array of custody addresses per defined ratio\n  function _transferCollateral(\n    uint256 amount,\n    address asset,\n    address benefactor,\n    address[] calldata addresses,\n    uint256[] calldata ratios\n  ) internal {\n    // cannot mint using unsupported asset or native ETH even if it is supported for redemptions\n    if (!_supportedAssets.contains(asset) || asset == NATIVE_TOKEN) revert UnsupportedAsset();\n    IERC20 token = IERC20(asset);\n    uint256 totalTransferred = 0;\n    for (uint256 i = 0; i < addresses.length; ++i) {\n      uint256 amountToTransfer = (amount * ratios[i]) / 10_000;\n      token.safeTransferFrom(benefactor, addresses[i], amountToTransfer);\n      totalTransferred += amountToTransfer;\n    }\n    uint256 remainingBalance = amount - totalTransferred;\n    if (remainingBalance > 0) {\n      token.safeTransferFrom(benefactor, addresses[addresses.length - 1], remainingBalance);\n    }\n  }\n\n  /// @notice Sets the max mintPerBlock limit\n  function _setMaxMintPerBlock(uint256 _maxMintPerBlock) internal {\n    uint256 oldMaxMintPerBlock = maxMintPerBlock;\n    maxMintPerBlock = _maxMintPerBlock;\n    emit MaxMintPerBlockChanged(oldMaxMintPerBlock, maxMintPerBlock);\n  }\n\n  /// @notice Sets the max redeemPerBlock limit\n  function _setMaxRedeemPerBlock(uint256 _maxRedeemPerBlock) internal {\n    uint256 oldMaxRedeemPerBlock = maxRedeemPerBlock;\n    maxRedeemPerBlock = _maxRedeemPerBlock;\n    emit MaxRedeemPerBlockChanged(oldMaxRedeemPerBlock, maxRedeemPerBlock);\n  }\n\n  /// @notice Compute the current domain separator\n  /// @return The domain separator for the token\n  function _computeDomainSeparator() internal view returns (bytes32) {\n    return keccak256(abi.encode(EIP712_DOMAIN, EIP_712_NAME, EIP712_REVISION, block.chainid, address(this)));\n  }\n}"
    }
  ]
}