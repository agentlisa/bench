{
  "Title": "Tokens Can Get Stuck While Finalizing Deposit",
  "Content": "In the `L1BatchBridgeGateway` contract, [`IL1ERC20Gateway.getL2ERC20Address`](https://github.com/scroll-tech/scroll/blob/84f73c76d2cfd0b07640315fc85e7e43eef98498/contracts/src/batch-bridge/L1BatchBridgeGateway.sol#L297) retrieves the corresponding `l2Token` address of the `l1Token`. In the `L2BatchBridgeGateway` contract, a [`tokenMapping`](https://github.com/scroll-tech/scroll/blob/84f73c76d2cfd0b07640315fc85e7e43eef98498/contracts/src/batch-bridge/L2BatchBridgeGateway.sol#L85) is used to set and get the corresponding `l1Token`Â in order to minimize gas cost, as opposed to using the [`IL2ERC20Gateway.getL1ERC20Address`](https://github.com/scroll-tech/scroll/blob/84f73c76d2cfd0b07640315fc85e7e43eef98498/contracts/src/L2/gateways/IL2ERC20Gateway.sol#L48) function. The token mapping is used by the `distribute` function, which needs to know the corresponding L1 address of the token to distribute.\n\n\nIn the `L2BatchBridgeGateway` contract, the [`finalizeBatchDeposit` function](https://github.com/scroll-tech/scroll/blob/84f73c76d2cfd0b07640315fc85e7e43eef98498/contracts/src/batch-bridge/L2BatchBridgeGateway.sol#L144-L167) relies on the messenger to accurately [map the `l2Token` address to the associated `l1Token`](https://github.com/scroll-tech/scroll/blob/84f73c76d2cfd0b07640315fc85e7e43eef98498/contracts/src/batch-bridge/L2BatchBridgeGateway.sol#L154-L158) when a batch deposit of a token is executed and finalized for the first time. The function will revert in a subsequent call if the `l1Token` differs from the `storedL1Token`.\n\n\nIn the `L2CustomERC20Gateway` contract, the token mapping from L2 to L1 is [updatable](https://github.com/scroll-tech/scroll/blob/84f73c76d2cfd0b07640315fc85e7e43eef98498/contracts/src/L2/gateways/L2CustomERC20Gateway.sol#L114-L121). In a scenario where the tokens being bridged are handled by the `L2CustomERC20Gateway`, a change of address of the token on L1 cannot be replicated in the `L2BatchBridgeGateway`. When batch bridging the new `l1Token` with the changed address to L2, the `finalizeBatchDeposit` function will retrieve the old `l1Token` address from its mapping. Ultimately, the function will revert since the updated address of the `l1Token` will not match the address that is recorded in the mapping.\n\n\nConsider removing the duplicated token mapping and supplying the `l1Token` as a parameter to the `distribute` function. Alternatively, consider either leveraging the `IL2ERC20Gateway.getL1ERC20Address` function or providing a function that enables the `L2BatchBridgeGateway` contract's token mapping to be updated.\n\n\n***Update:** Acknowledged, not resolved. The Scroll team stated:*\n\n\n\n> *Acknowledged. Not a priority at the moment.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/batch-bridge/L1BatchBridgeGateway.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.24;\n\nimport {AccessControlEnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport {IL1ERC20Gateway} from \"../L1/gateways/IL1ERC20Gateway.sol\";\nimport {IL1GatewayRouter} from \"../L1/gateways/IL1GatewayRouter.sol\";\nimport {IL1MessageQueue} from \"../L1/rollup/IL1MessageQueue.sol\";\nimport {IL1ScrollMessenger} from \"../L1/IL1ScrollMessenger.sol\";\n\nimport {BatchBridgeCodec} from \"./BatchBridgeCodec.sol\";\nimport {L2BatchBridgeGateway} from \"./L2BatchBridgeGateway.sol\";\n\n/// @title L1BatchBridgeGateway\ncontract L1BatchBridgeGateway is AccessControlEnumerableUpgradeable, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when some user deposited token to this contract.\n    /// @param sender The address of token sender.\n    /// @param token The address of deposited token.\n    /// @param batchIndex The batch index of current deposit.\n    /// @param amount The amount of token deposited (including fee).\n    /// @param fee The amount of fee charged.\n    event Deposit(\n        address indexed sender,\n        address indexed token,\n        uint256 indexed batchIndex,\n        uint256 amount,\n        uint256 fee\n    );\n\n    /// @notice Emitted when a batch deposit is initiated.\n    /// @param caller The address of caller who initiate the deposit.\n    /// @param l1Token The address of the token in L1 to deposit.\n    /// @param batchIndex The index of current batch deposit.\n    /// @param l2Token The address of the corresponding token in L2.\n    event BatchDeposit(address indexed caller, address indexed l1Token, uint256 indexed batchIndex, address l2Token);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when caller is not `messenger`.\n    error ErrorCallerNotMessenger();\n\n    /// @dev Thrown when the deposited amount is smaller than `minAmountPerTx`.\n    error ErrorDepositAmountTooSmall();\n\n    /// @dev Thrown when users try to deposit ETH with `depositERC20` method.\n    error ErrorIncorrectMethodForETHDeposit();\n\n    /// @dev Thrown when the `msg.value` is not enough for batch deposit fee.\n    error ErrorInsufficientMsgValueForBatchDepositFee();\n\n    /// @dev Thrown when the given new batch config is invalid.\n    error ErrorInvalidBatchConfig();\n\n    /// @dev Thrown when no pending batch exists.\n    error ErrorNoPendingBatch();\n\n    /// @dev Thrown when user deposits unsupported tokens.\n    error ErrorTokenNotSupported();\n\n    /// @dev Thrown when ETH transfer failed.\n    error ErrorTransferETHFailed();\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The role for batch deposit keeper.\n    bytes32 public constant KEEPER_ROLE = keccak256(\"KEEPER_ROLE\");\n\n    /// @notice The safe gas limit for batch bridge.\n    uint256 private constant SAFE_BATCH_BRIDGE_GAS_LIMIT = 200000;\n\n    /// @notice The address of corresponding `L2BatchDepositGateway` contract.\n    address public immutable counterpart;\n\n    /// @notice The address of `L1GatewayRouter` contract.\n    address public immutable router;\n\n    /// @notice The address of `L1ScrollMessenger` contract.\n    address public immutable messenger;\n\n    /// @notice The address of `L1MessageQueue` contract.\n    address public immutable queue;\n\n    /***********\n     * Structs *\n     ***********/\n\n    /// @notice The config for batch token bridge.\n    /// @dev Compiler will pack this into a single `bytes32`.\n    /// @param feeAmountPerTx The amount of fee charged for each deposit.\n    /// @param minAmountPerTx The minimum amount of token for each deposit.\n    /// @param maxTxsPerBatch The maximum number of deposit in each batch.\n    /// @param maxDelayPerBatch The maximum number of seconds to wait in each batch.\n    /// @param safeBridgeGasLimit The safe bridge gas limit for bridging token from L1 to L2.\n    struct BatchConfig {\n        uint96 feeAmountPerTx;\n        uint96 minAmountPerTx;\n        uint16 maxTxsPerBatch;\n        uint24 maxDelayPerBatch;\n        uint24 safeBridgeGasLimit;\n    }\n\n    /// @dev Compiler will pack this into two `bytes32`.\n    /// @param amount The total amount of token to deposit in current batch.\n    /// @param startTime The timestamp of the first deposit.\n    /// @param numDeposits The total number of deposits in current batch.\n    /// @param hash The hash of current batch.\n    ///   Suppose there are `n` deposits in current batch with `senders` and `amounts`. The hash is computed as\n    ///   ```text\n    ///   hash[0] = concat(token, batch_index)\n    ///   hash[i] = keccak(hash[i-1], concat(senders[i], amounts[i]))\n    ///   ```\n    ///   The type of `token` and `senders` is `address`, while The type of `batch_index` and `amounts[i]` is `uint96`.\n    ///   In current way, the hash of each batch among all tokens should be different.\n    struct BatchState {\n        uint128 amount;\n        uint64 startTime;\n        uint64 numDeposits;\n        bytes32 hash;\n    }\n\n    /// @dev Compiler will pack this into a single `bytes32`.\n    /// @param pending The total amount of token pending to bridge.\n    /// @param currentBatchIndex The index of current batch.\n    /// @param pendingBatchIndex The index of pending batch (next batch to bridge).\n    struct TokenState {\n        uint128 pending;\n        uint64 currentBatchIndex;\n        uint64 pendingBatchIndex;\n    }\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from token address to batch bridge config.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => BatchConfig) public configs;\n\n    /// @notice Mapping from token address to batch index to batch state.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => mapping(uint256 => BatchState)) public batches;\n\n    /// @notice Mapping from token address to token state.\n    /// @dev The `address(0)` is used for ETH.\n    mapping(address => TokenState) public tokens;\n\n    /// @notice The address of fee vault.\n    address public feeVault;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @param _counterpart The address of `L2BatchDepositGateway` contract in L2.\n    /// @param _router The address of `L1GatewayRouter` contract in L1.\n    /// @param _messenger The address of `L1ScrollMessenger` contract in L1.\n    /// @param _queue The address of `L1MessageQueue` contract in L1.\n    constructor(\n        address _counterpart,\n        address _router,\n        address _messenger,\n        address _queue\n    ) {\n        _disableInitializers();\n\n        counterpart = _counterpart;\n        router = _router;\n        messenger = _messenger;\n        queue = _queue;\n    }\n\n    /// @notice Initialize the storage of `L1BatchDepositGateway`.\n    /// @param _feeVault The address of fee vault contract.\n    function initialize(address _feeVault) external initializer {\n        __Context_init(); // from ContextUpgradeable\n        __ERC165_init(); // from ERC165Upgradeable\n        __AccessControl_init(); // from AccessControlUpgradeable\n        __AccessControlEnumerable_init(); // from AccessControlEnumerableUpgradeable\n        __ReentrancyGuard_init(); // from ReentrancyGuardUpgradeable\n\n        feeVault = _feeVault;\n        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Receive refunded ETH from `L1ScrollMessenger`.\n    receive() external payable {\n        if (_msgSender() != messenger) {\n            revert ErrorCallerNotMessenger();\n        }\n    }\n\n    /// @notice Deposit ETH.\n    function depositETH() external payable {\n        // no safe cast check here, since no one has so much ETH yet.\n        _deposit(address(0), _msgSender(), uint96(msg.value));\n    }\n\n    /// @notice Deposit ERC20 token.\n    ///\n    /// @param token The address of token.\n    /// @param amount The amount of token to deposit. We use type `uint96`, since it is enough for most of the major tokens.\n    function depositERC20(address token, uint96 amount) external {\n        if (token == address(0)) revert ErrorIncorrectMethodForETHDeposit();\n\n        // common practice to handle fee on transfer token.\n        uint256 beforeBalance = IERC20Upgradeable(token).balanceOf(address(this));\n        IERC20Upgradeable(token).safeTransferFrom(_msgSender(), address(this), amount);\n        amount = uint96(IERC20Upgradeable(token).balanceOf(address(this)) - beforeBalance);\n\n        _deposit(token, _msgSender(), amount);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Add or update the batch bridge config for the given token.\n    ///\n    /// @dev The caller should make sure `safeBridgeGasLimit` is enough for batch bridging.\n    ///\n    /// @param token The address of token to update.\n    /// @param newConfig The new config.\n    function setBatchConfig(address token, BatchConfig memory newConfig) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (\n            newConfig.maxTxsPerBatch == 0 ||\n            newConfig.maxDelayPerBatch == 0 ||\n            newConfig.feeAmountPerTx > newConfig.minAmountPerTx\n        ) {\n            revert ErrorInvalidBatchConfig();\n        }\n        configs[token] = newConfig;\n    }\n\n    /// @notice Initiate the batch bridge of current pending batch.\n    /// @param token The address of the token.\n    function executeBatchDeposit(address token) external payable onlyRole(KEEPER_ROLE) {\n        BatchConfig memory cachedBatchConfig = configs[token];\n        TokenState memory cachedTokenState = tokens[token];\n        _tryFinalizeCurrentBatch(token, cachedBatchConfig, cachedTokenState);\n\n        // no batch to bridge\n        if (cachedTokenState.currentBatchIndex == cachedTokenState.pendingBatchIndex) {\n            revert ErrorNoPendingBatch();\n        }\n\n        // check bridge fee\n        uint256 depositFee = IL1MessageQueue(queue).estimateCrossDomainMessageFee(cachedBatchConfig.safeBridgeGasLimit);\n        uint256 batchBridgeFee = IL1MessageQueue(queue).estimateCrossDomainMessageFee(SAFE_BATCH_BRIDGE_GAS_LIMIT);\n        if (msg.value < depositFee + batchBridgeFee) {\n            revert ErrorInsufficientMsgValueForBatchDepositFee();\n        }\n\n        // take accumulated fee to fee vault\n        uint256 accumulatedFee;\n        if (token == address(0)) {\n            // no uncheck here just in case\n            accumulatedFee = address(this).balance - msg.value - cachedTokenState.pending;\n        } else {\n            // no uncheck here just in case\n            accumulatedFee = IERC20Upgradeable(token).balanceOf(address(this)) - cachedTokenState.pending;\n        }\n        if (accumulatedFee > 0) {\n            _transferToken(token, feeVault, accumulatedFee);\n        }\n\n        // deposit token to L2\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.pendingBatchIndex];\n        address l2Token;\n        if (token == address(0)) {\n            IL1ScrollMessenger(messenger).sendMessage{value: cachedBatchState.amount + depositFee}(\n                counterpart,\n                cachedBatchState.amount,\n                new bytes(0),\n                cachedBatchConfig.safeBridgeGasLimit\n            );\n        } else {\n            address gateway = IL1GatewayRouter(router).getERC20Gateway(token);\n            l2Token = IL1ERC20Gateway(gateway).getL2ERC20Address(token);\n            IERC20Upgradeable(token).safeApprove(gateway, 0);\n            IERC20Upgradeable(token).safeApprove(gateway, cachedBatchState.amount);\n            IL1ERC20Gateway(gateway).depositERC20{value: depositFee}(\n                token,\n                counterpart,\n                cachedBatchState.amount,\n                cachedBatchConfig.safeBridgeGasLimit\n            );\n        }\n\n        // notify `L2BatchBridgeGateway`\n        IL1ScrollMessenger(messenger).sendMessage{value: batchBridgeFee}(\n            counterpart,\n            0,\n            abi.encodeCall(\n                L2BatchBridgeGateway.finalizeBatchDeposit,\n                (token, l2Token, cachedTokenState.pendingBatchIndex, cachedBatchState.hash)\n            ),\n            SAFE_BATCH_BRIDGE_GAS_LIMIT\n        );\n\n        emit BatchDeposit(_msgSender(), token, cachedTokenState.pendingBatchIndex, l2Token);\n\n        // update token state\n        unchecked {\n            cachedTokenState.pending -= uint128(cachedBatchState.amount);\n            cachedTokenState.pendingBatchIndex += 1;\n        }\n        tokens[token] = cachedTokenState;\n\n        // refund keeper fee\n        unchecked {\n            if (msg.value > depositFee + batchBridgeFee) {\n                _transferToken(address(0), _msgSender(), msg.value - depositFee - batchBridgeFee);\n            }\n        }\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to deposit token.\n    /// @param token The address of token to deposit.\n    /// @param sender The address of token sender.\n    /// @param amount The amount of token to deposit.\n    function _deposit(\n        address token,\n        address sender,\n        uint96 amount\n    ) internal nonReentrant {\n        BatchConfig memory cachedBatchConfig = configs[token];\n        TokenState memory cachedTokenState = tokens[token];\n        _tryFinalizeCurrentBatch(token, cachedBatchConfig, cachedTokenState);\n\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.currentBatchIndex];\n        if (amount < cachedBatchConfig.minAmountPerTx) {\n            revert ErrorDepositAmountTooSmall();\n        }\n\n        emit Deposit(sender, token, cachedTokenState.currentBatchIndex, amount, cachedBatchConfig.feeAmountPerTx);\n\n        // deduct fee and update cached state\n        unchecked {\n            amount -= cachedBatchConfig.feeAmountPerTx;\n            cachedTokenState.pending += amount;\n            cachedBatchState.amount += amount;\n            cachedBatchState.numDeposits += 1;\n        }\n\n        // compute the hash chain\n        bytes32 node = BatchBridgeCodec.encodeNode(sender, amount);\n        if (cachedBatchState.hash == bytes32(0)) {\n            bytes32 initialNode = BatchBridgeCodec.encodeInitialNode(token, cachedTokenState.currentBatchIndex);\n            // this is first tx in this batch\n            cachedBatchState.hash = BatchBridgeCodec.hash(initialNode, node);\n            cachedBatchState.startTime = uint64(block.timestamp);\n        } else {\n            cachedBatchState.hash = BatchBridgeCodec.hash(cachedBatchState.hash, node);\n        }\n\n        batches[token][cachedTokenState.currentBatchIndex] = cachedBatchState;\n        tokens[token] = cachedTokenState;\n    }\n\n    /// @dev Internal function to finalize current batch.\n    ///      This function may change the value of `cachedTokenState`, which can be used in later operation.\n    /// @param token The address of token to finalize.\n    /// @param cachedBatchConfig The cached batch config in memory.\n    /// @param cachedTokenState The cached token state in memory.\n    function _tryFinalizeCurrentBatch(\n        address token,\n        BatchConfig memory cachedBatchConfig,\n        TokenState memory cachedTokenState\n    ) internal view {\n        if (cachedBatchConfig.maxTxsPerBatch == 0) {\n            revert ErrorTokenNotSupported();\n        }\n        BatchState memory cachedBatchState = batches[token][cachedTokenState.currentBatchIndex];\n        // return if it is the very first deposit in the current batch\n        if (cachedBatchState.numDeposits == 0) return;\n\n        // finalize current batchIndex when `maxTxsPerBatch` or `maxDelayPerBatch` reached.\n        if (\n            cachedBatchState.numDeposits == cachedBatchConfig.maxTxsPerBatch ||\n            block.timestamp - cachedBatchState.startTime > cachedBatchConfig.maxDelayPerBatch\n        ) {\n            cachedTokenState.currentBatchIndex += 1;\n        }\n    }\n\n    /// @dev Internal function to transfer token, including ETH.\n    /// @param token The address of token.\n    /// @param receiver The address of token receiver.\n    /// @param amount The amount of token to transfer.\n    function _transferToken(\n        address token,\n        address receiver,\n        uint256 amount\n    ) private {\n        if (token == address(0)) {\n            (bool success, ) = receiver.call{value: amount}(\"\");\n            if (!success) revert ErrorTransferETHFailed();\n        } else {\n            IERC20Upgradeable(token).safeTransfer(receiver, amount);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/src/batch-bridge/L2BatchBridgeGateway.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.24;\n\nimport {AccessControlEnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport {IL2ScrollMessenger} from \"../L2/IL2ScrollMessenger.sol\";\nimport {BatchBridgeCodec} from \"./BatchBridgeCodec.sol\";\n\n/// @title L2BatchBridgeGateway\ncontract L2BatchBridgeGateway is AccessControlEnumerableUpgradeable {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when token mapping for ERC20 token is updated.\n    /// @param l2Token The address of corresponding ERC20 token in layer 2.\n    /// @param oldL1Token The address of the old corresponding ERC20 token in layer 1.\n    /// @param newL1Token The address of the new corresponding ERC20 token in layer 1.\n    event UpdateTokenMapping(address indexed l2Token, address indexed oldL1Token, address indexed newL1Token);\n\n    /// @notice Emitted when batch bridge is finalized.\n    /// @param l1Token The address of token in L1.\n    /// @param l2Token The address of token in L2.\n    /// @param batchIndex The index of batch finalized.\n    event FinalizeBatchDeposit(address indexed l1Token, address indexed l2Token, uint256 indexed batchIndex);\n\n    /// @notice Emitted when batch distribution finished.\n    /// @param l1Token The address of token in L1.\n    /// @param l2Token The address of token in L2.\n    /// @param batchIndex The index of batch distributed.\n    event BatchDistribute(address indexed l1Token, address indexed l2Token, uint256 indexed batchIndex);\n\n    /// @notice Emitted when token distribute failed.\n    /// @param l2Token The address of token in L2.\n    /// @param batchIndex The index of the batch.\n    /// @param receiver The address of token receiver.\n    /// @param amount The amount of token to distribute.\n    event DistributeFailed(address indexed l2Token, uint256 indexed batchIndex, address receiver, uint256 amount);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when caller is not `messenger`.\n    error ErrorCallerNotMessenger();\n\n    /// @dev Thrown when the L1 token mapping mismatch with `finalizeBatchBridge`.\n    error ErrorL1TokenMismatched();\n\n    /// @dev Thrown when message sender is not `counterpart`.\n    error ErrorMessageSenderNotCounterpart();\n\n    /// @dev Thrown no failed distribution exists.\n    error ErrorNoFailedDistribution();\n\n    /// @dev Thrown when the batch hash mismatch.\n    error ErrorBatchHashMismatch();\n\n    /// @dev Thrown when distributing the same batch.\n    error ErrorBatchDistributed();\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The role for batch deposit keeper.\n    bytes32 public constant KEEPER_ROLE = keccak256(\"KEEPER_ROLE\");\n\n    /// @notice The safe gas limit for ETH transfer\n    uint256 private constant SAFE_ETH_TRANSFER_GAS_LIMIT = 50000;\n\n    /// @notice The address of corresponding `L1BatchBridgeGateway` contract.\n    address public immutable counterpart;\n\n    /// @notice The address of corresponding `L2ScrollMessenger` contract.\n    address public immutable messenger;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from l2 token address to l1 token address.\n    mapping(address => address) public tokenMapping;\n\n    /// @notice Mapping from L2 token address to batch index to batch hash.\n    mapping(address => mapping(uint256 => bytes32)) public batchHashes;\n\n    /// @notice Mapping from token address to the amount of failed distribution.\n    mapping(address => uint256) public failedAmount;\n\n    /// @notice Mapping from batch hash to the distribute status.\n    mapping(bytes32 => bool) public isDistributed;\n\n    /*************\n     * Modifiers *\n     *************/\n\n    modifier onlyMessenger() {\n        if (_msgSender() != messenger) {\n            revert ErrorCallerNotMessenger();\n        }\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @param _counterpart The address of `L1BatchBridgeGateway` contract in L1.\n    /// @param _messenger The address of `L2ScrollMessenger` contract in L2.\n    constructor(address _counterpart, address _messenger) {\n        _disableInitializers();\n\n        counterpart = _counterpart;\n        messenger = _messenger;\n    }\n\n    /// @notice Initialize the storage of `L2BatchBridgeGateway`.\n    function initialize() external initializer {\n        __Context_init(); // from ContextUpgradeable\n        __ERC165_init(); // from ERC165Upgradeable\n        __AccessControl_init(); // from AccessControlUpgradeable\n        __AccessControlEnumerable_init(); // from AccessControlEnumerableUpgradeable\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Receive batch bridged ETH from `L2ScrollMessenger`.\n    receive() external payable onlyMessenger {\n        // empty\n    }\n\n    /// @notice Finalize L1 initiated batch token deposit.\n    /// @param l1Token The address of the token in L1.\n    /// @param l2Token The address of the token in L2.\n    /// @param batchIndex The index of this batch bridge.\n    /// @param hash The hash of this batch.\n    function finalizeBatchDeposit(\n        address l1Token,\n        address l2Token,\n        uint256 batchIndex,\n        bytes32 hash\n    ) external onlyMessenger {\n        if (counterpart != IL2ScrollMessenger(messenger).xDomainMessageSender()) {\n            revert ErrorMessageSenderNotCounterpart();\n        }\n\n        // trust the messenger and update `tokenMapping` in first call\n        // another assumption is this function should never fail due to out of gas\n        address storedL1Token = tokenMapping[l2Token];\n        if (storedL1Token == address(0) && l1Token != address(0)) {\n            tokenMapping[l2Token] = l1Token;\n        } else if (storedL1Token != l1Token) {\n            // this usually won't happen, check just in case.\n            revert ErrorL1TokenMismatched();\n        }\n\n        batchHashes[l2Token][batchIndex] = hash;\n\n        emit FinalizeBatchDeposit(l1Token, l2Token, batchIndex);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Withdraw distribution failed tokens.\n    /// @param token The address of token to withdraw.\n    /// @param receiver The address of token receiver.\n    function withdrawFailedAmount(address token, address receiver) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        uint256 amount = failedAmount[token];\n        if (amount == 0) revert ErrorNoFailedDistribution();\n        failedAmount[token] = 0;\n\n        _transferToken(token, receiver, amount);\n    }\n\n    /// @notice Distribute deposited token to corresponding receivers.\n    /// @param l2Token The address of L2 token.\n    /// @param batchIndex The index of batch to distribute.\n    /// @param nodes The list of encoded L1 deposits.\n    function distribute(\n        address l2Token,\n        uint64 batchIndex,\n        bytes32[] memory nodes\n    ) external onlyRole(KEEPER_ROLE) {\n        address l1Token = tokenMapping[l2Token];\n        bytes32 hash = BatchBridgeCodec.encodeInitialNode(l1Token, batchIndex);\n        for (uint256 i = 0; i < nodes.length; i++) {\n            hash = BatchBridgeCodec.hash(hash, nodes[i]);\n        }\n        if (batchHashes[l2Token][batchIndex] != hash) {\n            revert ErrorBatchHashMismatch();\n        }\n        if (isDistributed[hash]) {\n            revert ErrorBatchDistributed();\n        }\n        isDistributed[hash] = true;\n\n        // do transfer and allow failure to avoid DDOS attack\n        for (uint256 i = 0; i < nodes.length; i++) {\n            (address receiver, uint256 amount) = BatchBridgeCodec.decodeNode(nodes[i]);\n            if (!_transferToken(l2Token, receiver, amount)) {\n                failedAmount[l2Token] += amount;\n\n                emit DistributeFailed(l2Token, batchIndex, receiver, amount);\n            }\n        }\n\n        emit BatchDistribute(l1Token, l2Token, batchIndex);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to transfer token, including ETH.\n    /// @param token The address of token.\n    /// @param receiver The address of token receiver.\n    /// @param amount The amount of token to transfer.\n    /// @return success Whether the transfer is successful.\n    function _transferToken(\n        address token,\n        address receiver,\n        uint256 amount\n    ) private returns (bool success) {\n        if (token == address(0)) {\n            // We add gas limit here to avoid DDOS from malicious receiver.\n            (success, ) = receiver.call{value: amount, gas: SAFE_ETH_TRANSFER_GAS_LIMIT}(\"\");\n        } else {\n            // We perform a low level call here, to bypass Solidity's return data size checking mechanism.\n            // Normally, the token is selected that the call would not revert unless out of gas.\n            bytes memory returnData;\n            (success, returnData) = token.call(abi.encodeCall(IERC20Upgradeable.transfer, (receiver, amount)));\n            if (success && returnData.length > 0) {\n                success = abi.decode(returnData, (bool));\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/src/L2/gateways/L2CustomERC20Gateway.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.24;\n\nimport {IL2ERC20Gateway, L2ERC20Gateway} from \"./L2ERC20Gateway.sol\";\nimport {IL2ScrollMessenger} from \"../IL2ScrollMessenger.sol\";\nimport {IL1ERC20Gateway} from \"../../L1/gateways/IL1ERC20Gateway.sol\";\nimport {ScrollGatewayBase} from \"../../libraries/gateway/ScrollGatewayBase.sol\";\nimport {IScrollERC20Upgradeable} from \"../../libraries/token/IScrollERC20Upgradeable.sol\";\n\n/// @title L2ERC20Gateway\n/// @notice The `L2ERC20Gateway` is used to withdraw custom ERC20 compatible tokens on layer 2 and\n/// finalize deposit the tokens from layer 1.\n/// @dev The withdrawn tokens tokens will be burned directly. On finalizing deposit, the corresponding\n/// tokens will be minted and transferred to the recipient.\ncontract L2CustomERC20Gateway is L2ERC20Gateway {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when token mapping for ERC20 token is updated.\n    /// @param l2Token The address of corresponding ERC20 token in layer 2.\n    /// @param oldL1Token The address of the old corresponding ERC20 token in layer 1.\n    /// @param newL1Token The address of the new corresponding ERC20 token in layer 1.\n    event UpdateTokenMapping(address indexed l2Token, address indexed oldL1Token, address indexed newL1Token);\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from layer 2 token address to layer 1 token address for ERC20 token.\n    // solhint-disable-next-line var-name-mixedcase\n    mapping(address => address) public tokenMapping;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @notice Constructor for `L2CustomERC20Gateway` implementation contract.\n    ///\n    /// @param _counterpart The address of `L1CustomERC20Gateway` contract in L1.\n    /// @param _router The address of `L2GatewayRouter` contract in L2.\n    /// @param _messenger The address of `L2ScrollMessenger` contract in L2.\n    constructor(\n        address _counterpart,\n        address _router,\n        address _messenger\n    ) ScrollGatewayBase(_counterpart, _router, _messenger) {\n        if (_router == address(0)) revert ErrorZeroAddress();\n\n        _disableInitializers();\n    }\n\n    /// @notice Initialize the storage of `L2CustomERC20Gateway`.\n    ///\n    /// @dev The parameters `_counterpart`, `_router` and `_messenger` are no longer used.\n    ///\n    /// @param _counterpart The address of `L1CustomERC20Gateway` contract in L1.\n    /// @param _router The address of `L2GatewayRouter` contract in L2.\n    /// @param _messenger The address of `L2ScrollMessenger` contract in L2.\n    function initialize(\n        address _counterpart,\n        address _router,\n        address _messenger\n    ) external initializer {\n        ScrollGatewayBase._initialize(_counterpart, _router, _messenger);\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IL2ERC20Gateway\n    function getL1ERC20Address(address _l2Token) external view override returns (address) {\n        return tokenMapping[_l2Token];\n    }\n\n    /// @inheritdoc IL2ERC20Gateway\n    function getL2ERC20Address(address) public pure override returns (address) {\n        revert(\"unimplemented\");\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL2ERC20Gateway\n    function finalizeDepositERC20(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable override onlyCallByCounterpart nonReentrant {\n        require(msg.value == 0, \"nonzero msg.value\");\n        require(_l1Token != address(0), \"token address cannot be 0\");\n        require(_l1Token == tokenMapping[_l2Token], \"l1 token mismatch\");\n\n        IScrollERC20Upgradeable(_l2Token).mint(_to, _amount);\n\n        _doCallback(_to, _data);\n\n        emit FinalizeDepositERC20(_l1Token, _l2Token, _from, _to, _amount, _data);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update layer 2 to layer 1 token mapping.\n    /// @param _l2Token The address of corresponding ERC20 token on layer 2.\n    /// @param _l1Token The address of ERC20 token on layer 1.\n    function updateTokenMapping(address _l2Token, address _l1Token) external onlyOwner {\n        require(_l1Token != address(0), \"token address cannot be 0\");\n\n        address _oldL1Token = tokenMapping[_l2Token];\n        tokenMapping[_l2Token] = _l1Token;\n\n        emit UpdateTokenMapping(_l2Token, _oldL1Token, _l1Token);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @inheritdoc L2ERC20Gateway\n    function _withdraw(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) internal virtual override nonReentrant {\n        address _l1Token = tokenMapping[_token];\n        require(_l1Token != address(0), \"no corresponding l1 token\");\n\n        require(_amount > 0, \"withdraw zero amount\");\n\n        // 1. Extract real sender if this call is from L2GatewayRouter.\n        address _from = _msgSender();\n        if (router == _from) {\n            (_from, _data) = abi.decode(_data, (address, bytes));\n        }\n\n        // 2. Burn token.\n        IScrollERC20Upgradeable(_token).burn(_from, _amount);\n\n        // 3. Generate message passed to L1StandardERC20Gateway.\n        bytes memory _message = abi.encodeCall(\n            IL1ERC20Gateway.finalizeWithdrawERC20,\n            (_l1Token, _token, _from, _to, _amount, _data)\n        );\n\n        // 4. send message to L2ScrollMessenger\n        IL2ScrollMessenger(messenger).sendMessage{value: msg.value}(counterpart, 0, _message, _gasLimit);\n\n        emit WithdrawERC20(_l1Token, _token, _from, _to, _amount, _data);\n    }\n}"
    }
  ]
}