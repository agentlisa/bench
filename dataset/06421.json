{
  "Title": "[M-05] `StaderOracle` - Strict equal can cause no consensus if trusted nodes are removed before consensus",
  "Content": "\n<https://github.com/code-423n4/2023-06-stader/blob/main/contracts/StaderOracle.sol#L148> <br><https://github.com/code-423n4/2023-06-stader/blob/main/contracts/StaderOracle.sol#L290>\n\n\n            if (\n                submissionCount == trustedNodesCount / 2 + 1 &&\n                _exchangeRate.reportingBlockNumber > exchangeRate.reportingBlockNumber\n            ) {\n                updateWithInLimitER(\n                    _exchangeRate.totalETHBalance,\n                    _exchangeRate.totalETHXSupply,\n                    _exchangeRate.reportingBlockNumber\n                );\n            }\n\nIn `submitExchangeRateData`, consensus is reached if `submissionCount` is strictly equal to desired number. However, `trustNodesCount` can be decreased and this condition can be never met.\n\n```\n        if ((submissionCount == (2 * trustedNodesCount) / 3 + 1)) {\n            lastReportedSDPriceData = _sdPriceData;\n            lastReportedSDPriceData.sdPriceInETH = getMedianValue(sdPrices);\n            delete sdPrices;\n\n```\n\nIn `submitSDPrice`, if this case happens, `sdPrices` doesn't get deleted and it will affect the next submission batch's price.\n\n### Proof of Concept\n\nIn the above snippet, let's assume `trustedNodesCount` = 10, `submissionCount` = 5.<br>\nThe condition doesn't meet for now (5 != 10/2+1). Then `trustedNodesCount` decreases to 9.<br>\nNext time when a node submits, `trustedNodesCount` = 9, `submissionCount` = 6.<br>\nThen the condition cannot be met since (6 != 9/2+1).\n\n### Recommended Mitigation Steps\n\nReplace strict equal with equal or greater than. Or replace it with greater than and decrease the right side.\n\nNot sure about adding cooldown for add/remove trusted nodes.\n\n**[manoj9april (Stader) confirmed and commented:](https://github.com/code-423n4/2022-06-stader-findings/issues/321#issuecomment-1598308197)**\n > Thanks, we will fix this.\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2022-06-stader-findings/issues/321#issuecomment-1616579131):**\n > Keeping medium severity because of the sponsor's label, but the justification of why it qualifies for Med and what the impacts of the bug are is insufficient.\n> \n> For most functions, it seems the `submissionCount` depends on the `reportingBlockNumber` so the impact would only be one period where the oracle couldn't be updated, which doesn't qualify without additional justification. For example, for `submitSocializingRewardsMerkleRoot` and `submitMissedAttestationPenalties`, the impact may be more important.\n\n**[sanjay-staderlabs (Stader) commented](https://github.com/code-423n4/2023-06-stader-findings/issues/321#issuecomment-1633521001):**\n>This is fixed.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-06-stader",
  "Code": [
    {
      "filename": "contracts/StaderOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport './library/UtilLib.sol';\n\nimport './interfaces/IPoolUtils.sol';\nimport './interfaces/IStaderOracle.sol';\nimport './interfaces/ISocializingPool.sol';\nimport './interfaces/INodeRegistry.sol';\nimport './interfaces/IStaderStakePoolManager.sol';\n\nimport '@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol';\nimport '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol';\n\ncontract StaderOracle is IStaderOracle, AccessControlUpgradeable, PausableUpgradeable, ReentrancyGuardUpgradeable {\n    bool public override erInspectionMode;\n    bool public override isPORFeedBasedERData;\n    SDPriceData public lastReportedSDPriceData;\n    IStaderConfig public override staderConfig;\n    ExchangeRate public inspectionModeExchangeRate;\n    ExchangeRate public exchangeRate;\n    ValidatorStats public validatorStats;\n\n    uint256 public constant MAX_ER_UPDATE_FREQUENCY = 7200 * 7; // 7 days\n    uint256 public constant ER_CHANGE_MAX_BPS = 10000;\n    uint256 public override erChangeLimit;\n    uint256 public constant MIN_TRUSTED_NODES = 5;\n\n    /// @inheritdoc IStaderOracle\n    uint256 public override reportingBlockNumberForWithdrawnValidators;\n    /// @inheritdoc IStaderOracle\n    uint256 public override trustedNodesCount;\n    /// @inheritdoc IStaderOracle\n    uint256 public override lastReportedMAPDIndex;\n    uint256 public override erInspectionModeStartBlock;\n\n    // indicate the health of protocol on beacon chain\n    // enabled by `MANAGER` if heavy slashing on protocol on beacon chain\n    bool public override safeMode;\n\n    /// @inheritdoc IStaderOracle\n    mapping(address => bool) public override isTrustedNode;\n    mapping(bytes32 => bool) private nodeSubmissionKeys;\n    mapping(bytes32 => uint8) private submissionCountKeys;\n    mapping(bytes32 => uint16) public override missedAttestationPenalty;\n    uint256[] private sdPrices;\n\n    bytes32 public constant ETHX_ER_UF = keccak256('ETHX_ER_UF'); // ETHx Exchange Rate, Balances Update Frequency\n    bytes32 public constant SD_PRICE_UF = keccak256('SD_PRICE_UF'); // SD Price Update Frequency Key\n    bytes32 public constant VALIDATOR_STATS_UF = keccak256('VALIDATOR_STATS_UF'); // Validator Status Update Frequency Key\n    bytes32 public constant WITHDRAWN_VALIDATORS_UF = keccak256('WITHDRAWN_VALIDATORS_UF'); // Withdrawn Validator Update Frequency Key\n    bytes32 public constant MISSED_ATTESTATION_PENALTY_UF = keccak256('MISSED_ATTESTATION_PENALTY_UF'); // Missed Attestation Penalty Update Frequency Key\n    mapping(bytes32 => uint256) public updateFrequencyMap;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address _admin, address _staderConfig) public initializer {\n        UtilLib.checkNonZeroAddress(_admin);\n        UtilLib.checkNonZeroAddress(_staderConfig);\n\n        __AccessControl_init();\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        erChangeLimit = 500; //5% deviation threshold\n        setUpdateFrequency(ETHX_ER_UF, 7200);\n        setUpdateFrequency(SD_PRICE_UF, 7200);\n        setUpdateFrequency(VALIDATOR_STATS_UF, 7200);\n        setUpdateFrequency(WITHDRAWN_VALIDATORS_UF, 14400);\n        setUpdateFrequency(MISSED_ATTESTATION_PENALTY_UF, 50400);\n        staderConfig = IStaderConfig(_staderConfig);\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n        emit UpdatedStaderConfig(_staderConfig);\n    }\n\n    /// @inheritdoc IStaderOracle\n    function addTrustedNode(address _nodeAddress) external override {\n        UtilLib.onlyManagerRole(msg.sender, staderConfig);\n        UtilLib.checkNonZeroAddress(_nodeAddress);\n        if (isTrustedNode[_nodeAddress]) {\n            revert NodeAlreadyTrusted();\n        }\n        isTrustedNode[_nodeAddress] = true;\n        trustedNodesCount++;\n\n        emit TrustedNodeAdded(_nodeAddress);\n    }\n\n    /// @inheritdoc IStaderOracle\n    function removeTrustedNode(address _nodeAddress) external override {\n        UtilLib.onlyManagerRole(msg.sender, staderConfig);\n        UtilLib.checkNonZeroAddress(_nodeAddress);\n        if (!isTrustedNode[_nodeAddress]) {\n            revert NodeNotTrusted();\n        }\n        isTrustedNode[_nodeAddress] = false;\n        trustedNodesCount--;\n\n        emit TrustedNodeRemoved(_nodeAddress);\n    }\n\n    /// @inheritdoc IStaderOracle\n    function submitExchangeRateData(ExchangeRate calldata _exchangeRate)\n        external\n        override\n        trustedNodeOnly\n        checkMinTrustedNodes\n        checkERInspectionMode\n        whenNotPaused\n    {\n        if (isPORFeedBasedERData) {\n            revert InvalidERDataSource();\n        }\n        if (_exchangeRate.reportingBlockNumber >= block.number) {\n            revert ReportingFutureBlockData();\n        }\n        if (_exchangeRate.reportingBlockNumber % updateFrequencyMap[ETHX_ER_UF] > 0) {\n            revert InvalidReportingBlock();\n        }\n\n        // Get submission keys\n        bytes32 nodeSubmissionKey = keccak256(\n            abi.encode(\n                msg.sender,\n                _exchangeRate.reportingBlockNumber,\n                _exchangeRate.totalETHBalance,\n                _exchangeRate.totalETHXSupply\n            )\n        );\n        bytes32 submissionCountKey = keccak256(\n            abi.encode(_exchangeRate.reportingBlockNumber, _exchangeRate.totalETHBalance, _exchangeRate.totalETHXSupply)\n        );\n        uint8 submissionCount = attestSubmission(nodeSubmissionKey, submissionCountKey);\n        // Emit balances submitted event\n        emit ExchangeRateSubmitted(\n            msg.sender,\n            _exchangeRate.reportingBlockNumber,\n            _exchangeRate.totalETHBalance,\n            _exchangeRate.totalETHXSupply,\n            block.timestamp\n        );\n\n        if (\n            submissionCount == trustedNodesCount / 2 + 1 &&\n            _exchangeRate.reportingBlockNumber > exchangeRate.reportingBlockNumber\n        ) {\n            updateWithInLimitER(\n                _exchangeRate.totalETHBalance,\n                _exchangeRate.totalETHXSupply,\n                _exchangeRate.reportingBlockNumber\n            );\n        }\n    }\n\n    /// @inheritdoc IStaderOracle\n    function updateERFromPORFeed() external override checkERInspectionMode whenNotPaused {\n        if (!isPORFeedBasedERData) {\n            revert InvalidERDataSource();\n        }\n        (uint256 newTotalETHBalance, uint256 newTotalETHXSupply, uint256 reportingBlockNumber) = getPORFeedData();\n        updateWithInLimitER(newTotalETHBalance, newTotalETHXSupply, reportingBlockNumber);\n    }\n\n    /**\n     * @notice update the exchange rate when er change limit crossed, after verifying `inspectionModeExchangeRate` data\n     * @dev `erInspectionMode` must be true to call this function\n     */\n    function closeERInspectionMode() external override whenNotPaused {\n        if (!erInspectionMode) {\n            revert ERChangeLimitNotCrossed();\n        }\n        disableERInspectionMode();\n        _updateExchangeRate(\n            inspectionModeExchangeRate.totalETHBalance,\n            inspectionModeExchangeRate.totalETHXSupply,\n            inspectionModeExchangeRate.reportingBlockNumber\n        );\n    }\n\n    // turn off erInspectionMode if `inspectionModeExchangeRate` is incorrect so that oracle/POR can push new data\n    function disableERInspectionMode() public override whenNotPaused {\n        if (\n            !staderConfig.onlyManagerRole(msg.sender) &&\n            erInspectionModeStartBlock + MAX_ER_UPDATE_FREQUENCY > block.number\n        ) {\n            revert CooldownNotComplete();\n        }\n        erInspectionMode = false;\n    }\n\n    /// @notice submits merkle root and handles reward\n    /// sends user rewards to Stader Stake Pool Manager\n    /// sends protocol rewards to stader treasury\n    /// updates operator reward balances on socializing pool\n    /// @param _rewardsData contains rewards merkleRoot and rewards split info\n    /// @dev _rewardsData.index should not be zero\n    function submitSocializingRewardsMerkleRoot(RewardsData calldata _rewardsData)\n        external\n        override\n        trustedNodeOnly\n        checkMinTrustedNodes\n        whenNotPaused\n        nonReentrant\n    {\n        if (_rewardsData.reportingBlockNumber >= block.number) {\n            revert ReportingFutureBlockData();\n        }\n        if (_rewardsData.reportingBlockNumber != getMerkleRootReportableBlockByPoolId(_rewardsData.poolId)) {\n            revert InvalidReportingBlock();\n        }\n        if (_rewardsData.index != getCurrentRewardsIndexByPoolId(_rewardsData.poolId)) {\n            revert InvalidMerkleRootIndex();\n        }\n\n        // Get submission keys\n        bytes32 nodeSubmissionKey = keccak256(\n            abi.encode(\n                msg.sender,\n                _rewardsData.index,\n                _rewardsData.merkleRoot,\n                _rewardsData.poolId,\n                _rewardsData.operatorETHRewards,\n                _rewardsData.userETHRewards,\n                _rewardsData.protocolETHRewards,\n                _rewardsData.operatorSDRewards\n            )\n        );\n        bytes32 submissionCountKey = keccak256(\n            abi.encode(\n                _rewardsData.index,\n                _rewardsData.merkleRoot,\n                _rewardsData.poolId,\n                _rewardsData.operatorETHRewards,\n                _rewardsData.userETHRewards,\n                _rewardsData.protocolETHRewards,\n                _rewardsData.operatorSDRewards\n            )\n        );\n\n        // Emit merkle root submitted event\n        emit SocializingRewardsMerkleRootSubmitted(\n            msg.sender,\n            _rewardsData.index,\n            _rewardsData.merkleRoot,\n            _rewardsData.poolId,\n            block.number\n        );\n\n        uint8 submissionCount = attestSubmission(nodeSubmissionKey, submissionCountKey);\n\n        if ((submissionCount == trustedNodesCount / 2 + 1)) {\n            address socializingPool = IPoolUtils(staderConfig.getPoolUtils()).getSocializingPoolAddress(\n                _rewardsData.poolId\n            );\n            ISocializingPool(socializingPool).handleRewards(_rewardsData);\n\n            emit SocializingRewardsMerkleRootUpdated(\n                _rewardsData.index,\n                _rewardsData.merkleRoot,\n                _rewardsData.poolId,\n                block.number\n            );\n        }\n    }\n\n    function submitSDPrice(SDPriceData calldata _sdPriceData) external override trustedNodeOnly checkMinTrustedNodes {\n        if (_sdPriceData.reportingBlockNumber >= block.number) {\n            revert ReportingFutureBlockData();\n        }\n        if (_sdPriceData.reportingBlockNumber % updateFrequencyMap[SD_PRICE_UF] > 0) {\n            revert InvalidReportingBlock();\n        }\n        if (_sdPriceData.reportingBlockNumber <= lastReportedSDPriceData.reportingBlockNumber) {\n            revert ReportingPreviousCycleData();\n        }\n\n        // Get submission keys\n        bytes32 nodeSubmissionKey = keccak256(abi.encode(msg.sender, _sdPriceData.reportingBlockNumber));\n        bytes32 submissionCountKey = keccak256(abi.encode(_sdPriceData.reportingBlockNumber));\n        uint8 submissionCount = attestSubmission(nodeSubmissionKey, submissionCountKey);\n        insertSDPrice(_sdPriceData.sdPriceInETH);\n        // Emit SD Price submitted event\n        emit SDPriceSubmitted(msg.sender, _sdPriceData.sdPriceInETH, _sdPriceData.reportingBlockNumber, block.number);\n\n        // price can be derived once more than 66% percent oracles have submitted price\n        if ((submissionCount == (2 * trustedNodesCount) / 3 + 1)) {\n            lastReportedSDPriceData = _sdPriceData;\n            lastReportedSDPriceData.sdPriceInETH = getMedianValue(sdPrices);\n            delete sdPrices;\n\n            // Emit SD Price updated event\n            emit SDPriceUpdated(_sdPriceData.sdPriceInETH, _sdPriceData.reportingBlockNumber, block.number);\n        }\n    }\n\n    function insertSDPrice(uint256 _sdPrice) internal {\n        sdPrices.push(_sdPrice);\n        if (sdPrices.length == 1) return;\n\n        uint256 j = sdPrices.length - 1;\n        while ((j >= 1) && (_sdPrice < sdPrices[j - 1])) {\n            sdPrices[j] = sdPrices[j - 1];\n            j--;\n        }\n        sdPrices[j] = _sdPrice;\n    }\n\n    function getMedianValue(uint256[] storage dataArray) internal view returns (uint256 _medianValue) {\n        uint256 len = dataArray.length;\n        return (dataArray[(len - 1) / 2] + dataArray[len / 2]) / 2;\n    }\n\n    /// @inheritdoc IStaderOracle\n    function submitValidatorStats(ValidatorStats calldata _validatorStats)\n        external\n        override\n        trustedNodeOnly\n        checkMinTrustedNodes\n        whenNotPaused\n    {\n        if (_validatorStats.reportingBlockNumber >= block.number) {\n            revert ReportingFutureBlockData();\n        }\n        if (_validatorStats.reportingBlockNumber % updateFrequencyMap[VALIDATOR_STATS_UF] > 0) {\n            revert InvalidReportingBlock();\n        }\n\n        // Get submission keys\n        bytes32 nodeSubmissionKey = keccak256(\n            abi.encode(\n                msg.sender,\n                _validatorStats.reportingBlockNumber,\n                _validatorStats.exitingValidatorsBalance,\n                _validatorStats.exitedValidatorsBalance,\n                _validatorStats.slashedValidatorsBalance,\n                _validatorStats.exitingValidatorsCount,\n                _validatorStats.exitedValidatorsCount,\n                _validatorStats.slashedValidatorsCount\n            )\n        );\n        bytes32 submissionCountKey = keccak256(\n            abi.encode(\n                _validatorStats.reportingBlockNumber,\n                _validatorStats.exitingValidatorsBalance,\n                _validatorStats.exitedValidatorsBalance,\n                _validatorStats.slashedValidatorsBalance,\n                _validatorStats.exitingValidatorsCount,\n                _validatorStats.exitedValidatorsCount,\n                _validatorStats.slashedValidatorsCount\n            )\n        );\n\n        uint8 submissionCount = attestSubmission(nodeSubmissionKey, submissionCountKey);\n        // Emit validator stats submitted event\n        emit ValidatorStatsSubmitted(\n            msg.sender,\n            _validatorStats.reportingBlockNumber,\n            _validatorStats.exitingValidatorsBalance,\n            _validatorStats.exitedValidatorsBalance,\n            _validatorStats.slashedValidatorsBalance,\n            _validatorStats.exitingValidatorsCount,\n            _validatorStats.exitedValidatorsCount,\n            _validatorStats.slashedValidatorsCount,\n            block.timestamp\n        );\n\n        if (\n            submissionCount == trustedNodesCount / 2 + 1 &&\n            _validatorStats.reportingBlockNumber > validatorStats.reportingBlockNumber\n        ) {\n            validatorStats = _validatorStats;\n\n            // Emit stats updated event\n            emit ValidatorStatsUpdated(\n                _validatorStats.reportingBlockNumber,\n                _validatorStats.exitingValidatorsBalance,\n                _validatorStats.exitedValidatorsBalance,\n                _validatorStats.slashedValidatorsBalance,\n                _validatorStats.exitingValidatorsCount,\n                _validatorStats.exitedValidatorsCount,\n                _validatorStats.slashedValidatorsCount,\n                block.timestamp\n            );\n        }\n    }\n\n    /// @inheritdoc IStaderOracle\n    function submitWithdrawnValidators(WithdrawnValidators calldata _withdrawnValidators)\n        external\n        override\n        trustedNodeOnly\n        checkMinTrustedNodes\n        whenNotPaused\n        nonReentrant\n    {\n        if (_withdrawnValidators.reportingBlockNumber >= block.number) {\n            revert ReportingFutureBlockData();\n        }\n        if (_withdrawnValidators.reportingBlockNumber % updateFrequencyMap[WITHDRAWN_VALIDATORS_UF] > 0) {\n            revert InvalidReportingBlock();\n        }\n\n        bytes memory encodedPubkeys = abi.encode(_withdrawnValidators.sortedPubkeys);\n        // Get submission keys\n        bytes32 nodeSubmissionKey = keccak256(\n            abi.encode(\n                msg.sender,\n                _withdrawnValidators.reportingBlockNumber,\n                _withdrawnValidators.nodeRegistry,\n                encodedPubkeys\n            )\n        );\n        bytes32 submissionCountKey = keccak256(\n            abi.encode(_withdrawnValidators.reportingBlockNumber, _withdrawnValidators.nodeRegistry, encodedPubkeys)\n        );\n\n        uint8 submissionCount = attestSubmission(nodeSubmissionKey, submissionCountKey);\n        // Emit withdrawn validators submitted event\n        emit WithdrawnValidatorsSubmitted(\n            msg.sender,\n            _withdrawnValidators.reportingBlockNumber,\n            _withdrawnValidators.nodeRegistry,\n            _withdrawnValidators.sortedPubkeys,\n            block.timestamp\n        );\n\n        if (\n            submissionCount == trustedNodesCount / 2 + 1 &&\n            _withdrawnValidators.reportingBlockNumber > reportingBlockNumberForWithdrawnValidators\n        ) {\n            reportingBlockNumberForWithdrawnValidators = _withdrawnValidators.reportingBlockNumber;\n            INodeRegistry(_withdrawnValidators.nodeRegistry).withdrawnValidators(_withdrawnValidators.sortedPubkeys);\n\n            // Emit withdrawn validators updated event\n            emit WithdrawnValidatorsUpdated(\n                _withdrawnValidators.reportingBlockNumber,\n                _withdrawnValidators.nodeRegistry,\n                _withdrawnValidators.sortedPubkeys,\n                block.timestamp\n            );\n        }\n    }\n\n    /// @inheritdoc IStaderOracle\n    function submitMissedAttestationPenalties(MissedAttestationPenaltyData calldata _mapd)\n        external\n        override\n        trustedNodeOnly\n        checkMinTrustedNodes\n        whenNotPaused\n    {\n        if (_mapd.reportingBlockNumber >= block.number) {\n            revert ReportingFutureBlockData();\n        }\n        if (_mapd.reportingBlockNumber != getMissedAttestationPenaltyReportableBlock()) {\n            revert InvalidReportingBlock();\n        }\n        if (_mapd.index != lastReportedMAPDIndex + 1) {\n            revert InvalidMAPDIndex();\n        }\n\n        bytes memory encodedPubkeys = abi.encode(_mapd.sortedPubkeys);\n\n        // Get submission keys\n        bytes32 nodeSubmissionKey = keccak256(abi.encode(msg.sender, _mapd.index, encodedPubkeys));\n        bytes32 submissionCountKey = keccak256(abi.encode(_mapd.index, encodedPubkeys));\n        uint8 submissionCount = attestSubmission(nodeSubmissionKey, submissionCountKey);\n\n        // Emit missed attestation penalty submitted event\n        emit MissedAttestationPenaltySubmitted(\n            msg.sender,\n            _mapd.index,\n            block.number,\n            _mapd.reportingBlockNumber,\n            _mapd.sortedPubkeys\n        );\n\n        if ((submissionCount == trustedNodesCount / 2 + 1)) {\n            lastReportedMAPDIndex = _mapd.index;\n            uint256 keyCount = _mapd.sortedPubkeys.length;\n            for (uint256 i; i < keyCount; ) {\n                bytes32 pubkeyRoot = UtilLib.getPubkeyRoot(_mapd.sortedPubkeys[i]);\n                missedAttestationPenalty[pubkeyRoot]++;\n                unchecked {\n                    ++i;\n                }\n            }\n            emit MissedAttestationPenaltyUpdated(_mapd.index, block.number, _mapd.sortedPubkeys);\n        }\n    }\n\n    /// @inheritdoc IStaderOracle\n    function enableSafeMode() external override {\n        UtilLib.onlyManagerRole(msg.sender, staderConfig);\n        safeMode = true;\n        emit SafeModeEnabled();\n    }\n\n    function disableSafeMode() external override onlyRole(DEFAULT_ADMIN_ROLE) {\n        safeMode = false;\n        emit SafeModeDisabled();\n    }\n\n    //update the address of staderConfig\n    function updateStaderConfig(address _staderConfig) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        UtilLib.checkNonZeroAddress(_staderConfig);\n        staderConfig = IStaderConfig(_staderConfig);\n        emit UpdatedStaderConfig(_staderConfig);\n    }\n\n    function setERUpdateFrequency(uint256 _updateFrequency) external override {\n        UtilLib.onlyManagerRole(msg.sender, staderConfig);\n        if (_updateFrequency > MAX_ER_UPDATE_FREQUENCY) {\n            revert InvalidUpdate();\n        }\n        setUpdateFrequency(ETHX_ER_UF, _updateFrequency);\n    }\n\n    function togglePORFeedBasedERData() external override checkERInspectionMode {\n        UtilLib.onlyManagerRole(msg.sender, staderConfig);\n        isPORFeedBasedERData = !isPORFeedBasedERData;\n        emit ERDataSourceToggled(isPORFeedBasedERData);\n    }\n\n    //update the deviation threshold value, 0 deviationThreshold not allowed\n    function updateERChangeLimit(uint256 _erChangeLimit) external override {\n        UtilLib.onlyManagerRole(msg.sender, staderConfig);\n        if (_erChangeLimit == 0 || _erChangeLimit > ER_CHANGE_MAX_BPS) {\n            revert ERPermissibleChangeOutofBounds();\n        }\n        erChangeLimit = _erChangeLimit;\n        emit UpdatedERChangeLimit(erChangeLimit);\n    }\n\n    function setSDPriceUpdateFrequency(uint256 _updateFrequency) external override {\n        UtilLib.onlyManagerRole(msg.sender, staderConfig);\n        setUpdateFrequency(SD_PRICE_UF, _updateFrequency);\n    }\n\n    function setValidatorStatsUpdateFrequency(uint256 _updateFrequency) external override {\n        UtilLib.onlyManagerRole(msg.sender, staderConfig);\n        setUpdateFrequency(VALIDATOR_STATS_UF, _updateFrequency);\n    }\n\n    function setWithdrawnValidatorsUpdateFrequency(uint256 _updateFrequency) external override {\n        UtilLib.onlyManagerRole(msg.sender, staderConfig);\n        setUpdateFrequency(WITHDRAWN_VALIDATORS_UF, _updateFrequency);\n    }\n\n    function setMissedAttestationPenaltyUpdateFrequency(uint256 _updateFrequency) external override {\n        UtilLib.onlyManagerRole(msg.sender, staderConfig);\n        setUpdateFrequency(MISSED_ATTESTATION_PENALTY_UF, _updateFrequency);\n    }\n\n    function setUpdateFrequency(bytes32 _key, uint256 _updateFrequency) internal {\n        if (_updateFrequency == 0) {\n            revert ZeroFrequency();\n        }\n        if (_updateFrequency == updateFrequencyMap[_key]) {\n            revert FrequencyUnchanged();\n        }\n        updateFrequencyMap[_key] = _updateFrequency;\n\n        emit UpdateFrequencyUpdated(_updateFrequency);\n    }\n\n    function getERReportableBlock() public view override returns (uint256) {\n        return getReportableBlockFor(ETHX_ER_UF);\n    }\n\n    function getMerkleRootReportableBlockByPoolId(uint8 _poolId) public view override returns (uint256) {\n        (, , uint256 currentEndBlock) = ISocializingPool(\n            IPoolUtils(staderConfig.getPoolUtils()).getSocializingPoolAddress(_poolId)\n        ).getRewardDetails();\n        return currentEndBlock;\n    }\n\n    function getSDPriceReportableBlock() public view override returns (uint256) {\n        return getReportableBlockFor(SD_PRICE_UF);\n    }\n\n    function getValidatorStatsReportableBlock() public view override returns (uint256) {\n        return getReportableBlockFor(VALIDATOR_STATS_UF);\n    }\n\n    function getWithdrawnValidatorReportableBlock() public view override returns (uint256) {\n        return getReportableBlockFor(WITHDRAWN_VALIDATORS_UF);\n    }\n\n    function getMissedAttestationPenaltyReportableBlock() public view override returns (uint256) {\n        return getReportableBlockFor(MISSED_ATTESTATION_PENALTY_UF);\n    }\n\n    function getReportableBlockFor(bytes32 _key) internal view returns (uint256) {\n        uint256 updateFrequency = updateFrequencyMap[_key];\n        if (updateFrequency == 0) {\n            revert UpdateFrequencyNotSet();\n        }\n        return (block.number / updateFrequency) * updateFrequency;\n    }\n\n    function getCurrentRewardsIndexByPoolId(uint8 _poolId) public view returns (uint256) {\n        return\n            ISocializingPool(IPoolUtils(staderConfig.getPoolUtils()).getSocializingPoolAddress(_poolId))\n                .getCurrentRewardsIndex();\n    }\n\n    function getValidatorStats() external view override returns (ValidatorStats memory) {\n        return (validatorStats);\n    }\n\n    function getExchangeRate() external view override returns (ExchangeRate memory) {\n        return (exchangeRate);\n    }\n\n    function attestSubmission(bytes32 _nodeSubmissionKey, bytes32 _submissionCountKey)\n        internal\n        returns (uint8 _submissionCount)\n    {\n        // Check & update node submission status\n        if (nodeSubmissionKeys[_nodeSubmissionKey]) {\n            revert DuplicateSubmissionFromNode();\n        }\n        nodeSubmissionKeys[_nodeSubmissionKey] = true;\n        submissionCountKeys[_submissionCountKey]++;\n        _submissionCount = submissionCountKeys[_submissionCountKey];\n    }\n\n    function getSDPriceInETH() external view override returns (uint256) {\n        return lastReportedSDPriceData.sdPriceInETH;\n    }\n\n    function getPORFeedData()\n        internal\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        (, int256 totalETHBalanceInInt, , , ) = AggregatorV3Interface(staderConfig.getETHBalancePORFeedProxy())\n            .latestRoundData();\n        (, int256 totalETHXSupplyInInt, , , ) = AggregatorV3Interface(staderConfig.getETHXSupplyPORFeedProxy())\n            .latestRoundData();\n        return (uint256(totalETHBalanceInInt), uint256(totalETHXSupplyInInt), block.number);\n    }\n\n    function updateWithInLimitER(\n        uint256 _newTotalETHBalance,\n        uint256 _newTotalETHXSupply,\n        uint256 _reportingBlockNumber\n    ) internal {\n        uint256 currentExchangeRate = UtilLib.computeExchangeRate(\n            exchangeRate.totalETHBalance,\n            exchangeRate.totalETHXSupply,\n            staderConfig\n        );\n        uint256 newExchangeRate = UtilLib.computeExchangeRate(_newTotalETHBalance, _newTotalETHXSupply, staderConfig);\n        if (\n            !(newExchangeRate >= (currentExchangeRate * (ER_CHANGE_MAX_BPS - erChangeLimit)) / ER_CHANGE_MAX_BPS &&\n                newExchangeRate <= ((currentExchangeRate * (ER_CHANGE_MAX_BPS + erChangeLimit)) / ER_CHANGE_MAX_BPS))\n        ) {\n            erInspectionMode = true;\n            erInspectionModeStartBlock = block.number;\n            inspectionModeExchangeRate.totalETHBalance = _newTotalETHBalance;\n            inspectionModeExchangeRate.totalETHXSupply = _newTotalETHXSupply;\n            inspectionModeExchangeRate.reportingBlockNumber = _reportingBlockNumber;\n            emit ERInspectionModeActivated(erInspectionMode, block.timestamp);\n            return;\n        }\n        _updateExchangeRate(_newTotalETHBalance, _newTotalETHXSupply, _reportingBlockNumber);\n    }\n\n    function _updateExchangeRate(\n        uint256 _totalETHBalance,\n        uint256 _totalETHXSupply,\n        uint256 _reportingBlockNumber\n    ) internal {\n        exchangeRate.totalETHBalance = _totalETHBalance;\n        exchangeRate.totalETHXSupply = _totalETHXSupply;\n        exchangeRate.reportingBlockNumber = _reportingBlockNumber;\n\n        // Emit balances updated event\n        emit ExchangeRateUpdated(\n            exchangeRate.reportingBlockNumber,\n            exchangeRate.totalETHBalance,\n            exchangeRate.totalETHXSupply,\n            block.timestamp\n        );\n    }\n\n    modifier checkERInspectionMode() {\n        if (erInspectionMode) {\n            revert InspectionModeActive();\n        }\n        _;\n    }\n\n    modifier trustedNodeOnly() {\n        if (!isTrustedNode[msg.sender]) {\n            revert NotATrustedNode();\n        }\n        _;\n    }\n\n    modifier checkMinTrustedNodes() {\n        if (trustedNodesCount < MIN_TRUSTED_NODES) {\n            revert InsufficientTrustedNodes();\n        }\n        _;\n    }\n}"
    }
  ]
}