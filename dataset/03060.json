{
  "Title": "Interest rate model update impacts the old time period",
  "Content": "##### Description\nAfter an admin changes the interest rate model parameters by using this function\nhttps://github.com/ibdotxyz/compound-protocol/blob/8cd45803b48552e344e22be280c9e1c03ec8644a/contracts/TripleSlopeRateModel.sol#L100\nindexes will be recalculated in the upcoming accrueInterest() function call. But this call applies new interest settings to the previous period of time which is not correct.\n##### Recommendation\nThe interest rate model parameters should be changed just after calling the accrueInterest() function for each asset. It can be done by creating a special service contract.\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/TripleSlopeRateModel.sol",
      "content": "pragma solidity ^0.5.16;\n\nimport \"./InterestRateModel.sol\";\nimport \"./SafeMath.sol\";\n\n/**\n * @title CREAM's TripleSlopeRateModel Contract\n * @author C.R.E.A.M. Finance\n */\ncontract TripleSlopeRateModel is InterestRateModel {\n    using SafeMath for uint256;\n\n    event NewInterestParams(\n        uint256 baseRatePerBlock,\n        uint256 multiplierPerBlock,\n        uint256 jumpMultiplierPerBlock,\n        uint256 kink1,\n        uint256 kink2,\n        uint256 roof\n    );\n\n    /**\n     * @notice The address of the owner, i.e. the Timelock contract, which can update parameters directly\n     */\n    address public owner;\n\n    /**\n     * @notice The approximate number of blocks per year that is assumed by the interest rate model\n     */\n    uint256 public constant blocksPerYear = 2102400;\n\n    /**\n     * @notice The minimum roof value used for calculating borrow rate.\n     */\n    uint256 internal constant minRoofValue = 1e18;\n\n    /**\n     * @notice The multiplier of utilization rate that gives the slope of the interest rate\n     */\n    uint256 public multiplierPerBlock;\n\n    /**\n     * @notice The base interest rate which is the y-intercept when utilization rate is 0\n     */\n    uint256 public baseRatePerBlock;\n\n    /**\n     * @notice The multiplierPerBlock after hitting a specified utilization point\n     */\n    uint256 public jumpMultiplierPerBlock;\n\n    /**\n     * @notice The utilization point at which the interest rate is fixed\n     */\n    uint256 public kink1;\n\n    /**\n     * @notice The utilization point at which the jump multiplier is applied\n     */\n    uint256 public kink2;\n\n    /**\n     * @notice The utilization point at which the rate is fixed\n     */\n    uint256 public roof;\n\n    /**\n     * @notice Construct an interest rate model\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n     * @param kink1_ The utilization point at which the interest rate is fixed\n     * @param kink2_ The utilization point at which the jump multiplier is applied\n     * @param roof_ The utilization point at which the borrow rate is fixed\n     * @param owner_ The address of the owner, i.e. the Timelock contract (which has the ability to update parameters directly)\n     */\n    constructor(\n        uint256 baseRatePerYear,\n        uint256 multiplierPerYear,\n        uint256 jumpMultiplierPerYear,\n        uint256 kink1_,\n        uint256 kink2_,\n        uint256 roof_,\n        address owner_\n    ) public {\n        owner = owner_;\n\n        updateTripleRateModelInternal(baseRatePerYear, multiplierPerYear, jumpMultiplierPerYear, kink1_, kink2_, roof_);\n    }\n\n    /**\n     * @notice Update the parameters of the interest rate model (only callable by owner, i.e. Timelock)\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n     * @param kink1_ The utilization point at which the interest rate is fixed\n     * @param kink2_ The utilization point at which the jump multiplier is applied\n     * @param roof_ The utilization point at which the borrow rate is fixed\n     */\n    function updateTripleRateModel(\n        uint256 baseRatePerYear,\n        uint256 multiplierPerYear,\n        uint256 jumpMultiplierPerYear,\n        uint256 kink1_,\n        uint256 kink2_,\n        uint256 roof_\n    ) external {\n        require(msg.sender == owner, \"only the owner may call this function.\");\n\n        updateTripleRateModelInternal(baseRatePerYear, multiplierPerYear, jumpMultiplierPerYear, kink1_, kink2_, roof_);\n    }\n\n    /**\n     * @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market (currently unused)\n     * @return The utilization rate as a mantissa between [0, 1e18]\n     */\n    function utilizationRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves\n    ) public view returns (uint256) {\n        // Utilization rate is 0 when there are no borrows\n        if (borrows == 0) {\n            return 0;\n        }\n\n        uint256 util = borrows.mul(1e18).div(cash.add(borrows).sub(reserves));\n        // If the utilization is above the roof, cap it.\n        if (util > roof) {\n            util = roof;\n        }\n        return util;\n    }\n\n    /**\n     * @notice Calculates the current borrow rate per block, with the error code expected by the market\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\n     */\n    function getBorrowRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves\n    ) public view returns (uint256) {\n        uint256 util = utilizationRate(cash, borrows, reserves);\n\n        if (util <= kink1) {\n            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n        } else if (util <= kink2) {\n            return kink1.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n        } else {\n            uint256 normalRate = kink1.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n            uint256 excessUtil = util.sub(kink2);\n            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);\n        }\n    }\n\n    /**\n     * @notice Calculates the current supply rate per block\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @param reserveFactorMantissa The current reserve factor for the market\n     * @return The supply rate percentage per block as a mantissa (scaled by 1e18)\n     */\n    function getSupplyRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves,\n        uint256 reserveFactorMantissa\n    ) public view returns (uint256) {\n        uint256 oneMinusReserveFactor = uint256(1e18).sub(reserveFactorMantissa);\n        uint256 borrowRate = getBorrowRate(cash, borrows, reserves);\n        uint256 rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\n        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\n    }\n\n    /**\n     * @notice Internal function to update the parameters of the interest rate model\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n     * @param kink1_ The utilization point at which the interest rate is fixed\n     * @param kink2_ The utilization point at which the jump multiplier is applied\n     * @param roof_ The utilization point at which the borrow rate is fixed\n     */\n    function updateTripleRateModelInternal(\n        uint256 baseRatePerYear,\n        uint256 multiplierPerYear,\n        uint256 jumpMultiplierPerYear,\n        uint256 kink1_,\n        uint256 kink2_,\n        uint256 roof_\n    ) internal {\n        require(kink1_ <= kink2_, \"kink1 must less than or equal to kink2\");\n        require(roof_ >= minRoofValue, \"invalid roof value\");\n\n        baseRatePerBlock = baseRatePerYear.div(blocksPerYear);\n        multiplierPerBlock = (multiplierPerYear.mul(1e18)).div(blocksPerYear.mul(kink1_));\n        jumpMultiplierPerBlock = jumpMultiplierPerYear.div(blocksPerYear);\n        kink1 = kink1_;\n        kink2 = kink2_;\n        roof = roof_;\n\n        emit NewInterestParams(baseRatePerBlock, multiplierPerBlock, jumpMultiplierPerBlock, kink1, kink2, roof);\n    }\n}"
    }
  ]
}