{
  "Title": "[G-28] Calculate simple operations at once",
  "Content": "\n**File:** `TransactionValidator.sol`\n\n[File: code/contracts/ethereum/contracts/state-transition/libraries/TransactionValidator.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/libraries/TransactionValidator.sol#L77)\n```solidity\n77:             costForComputation = L1_TX_INTRINSIC_L2_GAS;\n78: \n79:             // Taking into account the hashing costs that depend on the length of the transaction\n80:             // Note that L1_TX_DELTA_544_ENCODING_BYTES is the delta in the price for every 544 bytes of\n81:             // the transaction's encoding. It is taken as LCM between 136 and 32 (the length for each keccak256 round\n82:             // and the size of each new encoding word).\n83:             costForComputation += Math.ceilDiv(_encodingLength * L1_TX_DELTA_544_ENCODING_BYTES, 544);\n84: \n85:             // Taking into the account the additional costs of providing new factory dependencies\n86:             costForComputation += _numberOfFactoryDependencies * L1_TX_DELTA_FACTORY_DEPS_L2_GAS;\n87: \n88:             // There is a minimal amount of computational L2 gas that the transaction should cover\n89:             costForComputation = Math.max(costForComputation, L1_TX_MIN_L2_GAS_BASE);\n```\n\nAbove code performs redundant addition at lines 83, 86. Every time it adds the value to `costForComputation`, instead of doing it only once:\n\n```\n            costForComputation = Math.max(L1_TX_INTRINSIC_L2_GAS + Math.ceilDiv(_encodingLength * L1_TX_DELTA_544_ENCODING_BYTES, 544) + _numberOfFactoryDependencies * L1_TX_DELTA_FACTORY_DEPS_L2_GAS, L1_TX_MIN_L2_GAS_BASE);\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-03-zksync",
  "Code": [
    {
      "filename": "code/contracts/ethereum/contracts/state-transition/libraries/TransactionValidator.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport {L2CanonicalTransaction} from \"../../common/Messaging.sol\";\nimport {TX_SLOT_OVERHEAD_L2_GAS, MEMORY_OVERHEAD_GAS, L1_TX_INTRINSIC_L2_GAS, L1_TX_DELTA_544_ENCODING_BYTES, L1_TX_DELTA_FACTORY_DEPS_L2_GAS, L1_TX_MIN_L2_GAS_BASE, L1_TX_INTRINSIC_PUBDATA, L1_TX_DELTA_FACTORY_DEPS_PUBDATA} from \"../../common/Config.sol\";\n\n/// @title zkSync Library for validating L1 -> L2 transactions\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\nlibrary TransactionValidator {\n    /// @dev Used to validate key properties of an L1->L2 transaction\n    /// @param _transaction The transaction to validate\n    /// @param _encoded The abi encoded bytes of the transaction\n    /// @param _priorityTxMaxGasLimit The max gas limit, generally provided from Storage.sol\n    /// @param _priorityTxMaxPubdata The maximal amount of pubdata that a single L1->L2 transaction can emit\n    function validateL1ToL2Transaction(\n        L2CanonicalTransaction memory _transaction,\n        bytes memory _encoded,\n        uint256 _priorityTxMaxGasLimit,\n        uint256 _priorityTxMaxPubdata\n    ) internal pure {\n        uint256 l2GasForTxBody = getTransactionBodyGasLimit(_transaction.gasLimit, _encoded.length);\n\n        // Ensuring that the transaction is provable\n        require(l2GasForTxBody <= _priorityTxMaxGasLimit, \"ui\");\n        // Ensuring that the transaction cannot output more pubdata than is processable\n        require(l2GasForTxBody / _transaction.gasPerPubdataByteLimit <= _priorityTxMaxPubdata, \"uk\");\n\n        // Ensuring that the transaction covers the minimal costs for its processing:\n        // hashing its content, publishing the factory dependencies, etc.\n        require(\n            getMinimalPriorityTransactionGasLimit(\n                _encoded.length,\n                _transaction.factoryDeps.length,\n                _transaction.gasPerPubdataByteLimit\n            ) <= l2GasForTxBody,\n            \"up\"\n        );\n    }\n\n    /// @dev Used to validate upgrade transactions\n    /// @param _transaction The transaction to validate\n    function validateUpgradeTransaction(L2CanonicalTransaction memory _transaction) internal pure {\n        // Restrict from to be within system contract range (0...2^16 - 1)\n        require(_transaction.from <= type(uint16).max, \"ua\");\n        require(_transaction.to <= type(uint160).max, \"ub\");\n        require(_transaction.paymaster == 0, \"uc\");\n        require(_transaction.value == 0, \"ud\");\n        require(_transaction.maxFeePerGas == 0, \"uq\");\n        require(_transaction.maxPriorityFeePerGas == 0, \"ux\");\n        require(_transaction.reserved[0] == 0, \"ue\");\n        require(_transaction.reserved[1] <= type(uint160).max, \"uf\");\n        require(_transaction.reserved[2] == 0, \"ug\");\n        require(_transaction.reserved[3] == 0, \"uo\");\n        require(_transaction.signature.length == 0, \"uh\");\n        require(_transaction.paymasterInput.length == 0, \"ul1\");\n        require(_transaction.reservedDynamic.length == 0, \"um\");\n    }\n\n    /// @dev Calculates the approximate minimum gas limit required for executing a priority transaction.\n    /// @param _encodingLength The length of the priority transaction encoding in bytes.\n    /// @param _numberOfFactoryDependencies The number of new factory dependencies that will be added.\n    /// @param _l2GasPricePerPubdata The L2 gas price for publishing the priority transaction on L2.\n    /// @return The minimum gas limit required to execute the priority transaction.\n    /// Note: The calculation includes the main cost of the priority transaction, however, in reality, the operator can spend a little more gas on overheads.\n    function getMinimalPriorityTransactionGasLimit(\n        uint256 _encodingLength,\n        uint256 _numberOfFactoryDependencies,\n        uint256 _l2GasPricePerPubdata\n    ) internal pure returns (uint256) {\n        uint256 costForComputation;\n        {\n            // Adding the intrinsic cost for the transaction, i.e. auxiliary prices which cannot be easily accounted for\n            costForComputation = L1_TX_INTRINSIC_L2_GAS;\n\n            // Taking into account the hashing costs that depend on the length of the transaction\n            // Note that L1_TX_DELTA_544_ENCODING_BYTES is the delta in the price for every 544 bytes of\n            // the transaction's encoding. It is taken as LCM between 136 and 32 (the length for each keccak256 round\n            // and the size of each new encoding word).\n            costForComputation += Math.ceilDiv(_encodingLength * L1_TX_DELTA_544_ENCODING_BYTES, 544);\n\n            // Taking into the account the additional costs of providing new factory dependencies\n            costForComputation += _numberOfFactoryDependencies * L1_TX_DELTA_FACTORY_DEPS_L2_GAS;\n\n            // There is a minimal amount of computational L2 gas that the transaction should cover\n            costForComputation = Math.max(costForComputation, L1_TX_MIN_L2_GAS_BASE);\n        }\n\n        uint256 costForPubdata = 0;\n        {\n            // Adding the intrinsic cost for the transaction, i.e. auxiliary prices which cannot be easily accounted for\n            costForPubdata = L1_TX_INTRINSIC_PUBDATA * _l2GasPricePerPubdata;\n\n            // Taking into the account the additional costs of providing new factory dependencies\n            costForPubdata += _numberOfFactoryDependencies * L1_TX_DELTA_FACTORY_DEPS_PUBDATA * _l2GasPricePerPubdata;\n        }\n\n        return costForComputation + costForPubdata;\n    }\n\n    /// @notice Based on the full L2 gas limit (that includes the batch overhead) and other\n    /// properties of the transaction, returns the l2GasLimit for the body of the transaction (the actual execution).\n    /// @param _totalGasLimit The L2 gas limit that includes both the overhead for processing the batch\n    /// and the L2 gas needed to process the transaction itself (i.e. the actual l2GasLimit that will be used for the transaction).\n    /// @param _encodingLength The length of the ABI-encoding of the transaction.\n    function getTransactionBodyGasLimit(\n        uint256 _totalGasLimit,\n        uint256 _encodingLength\n    ) internal pure returns (uint256 txBodyGasLimit) {\n        uint256 overhead = getOverheadForTransaction(_encodingLength);\n\n        require(_totalGasLimit >= overhead, \"my\"); // provided gas limit doesn't cover transaction overhead\n        unchecked {\n            // We enforce the fact that `_totalGasLimit >= overhead` explicitly above.\n            txBodyGasLimit = _totalGasLimit - overhead;\n        }\n    }\n\n    /// @notice Based on the total L2 gas limit and several other parameters of the transaction\n    /// returns the part of the L2 gas that will be spent on the batch's overhead.\n    /// @dev The details of how this function works can be checked in the documentation\n    /// of the fee model of zkSync. The appropriate comments are also present\n    /// in the Rust implementation description of function `get_maximal_allowed_overhead`.\n    /// @param _encodingLength The length of the binary encoding of the transaction in bytes\n    function getOverheadForTransaction(\n        uint256 _encodingLength\n    ) internal pure returns (uint256 batchOverheadForTransaction) {\n        // The overhead from taking up the transaction's slot\n        batchOverheadForTransaction = TX_SLOT_OVERHEAD_L2_GAS;\n\n        // The overhead for occupying the bootloader memory can be derived from encoded_len\n        uint256 overheadForLength = MEMORY_OVERHEAD_GAS * _encodingLength;\n        batchOverheadForTransaction = Math.max(batchOverheadForTransaction, overheadForLength);\n    }\n}"
    }
  ]
}