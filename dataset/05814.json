{
  "Title": "[L-03] Missing name and symbol for AfEth token",
  "Content": "\nhttps://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L72\n\nThe AfEth contract inherits from ERC20Upgradeable but doesn't call its base initializer, which is in charge of setting the name and symbol for the ERC20 token.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-09-asymmetry",
  "Code": [
    {
      "filename": "contracts/AfEth.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"contracts/strategies/votium/VotiumStrategy.sol\";\nimport \"contracts/external_interfaces/IVotiumStrategy.sol\";\nimport \"contracts/strategies/AbstractStrategy.sol\";\n\n// AfEth is the strategy manager for safEth and votium strategies\ncontract AfEth is Initializable, OwnableUpgradeable, ERC20Upgradeable {\n    uint256 public ratio;\n    uint256 public protocolFee;\n    address public feeAddress;\n    address public constant SAF_ETH_ADDRESS =\n        0x6732Efaf6f39926346BeF8b821a04B6361C4F3e5;\n    address public vEthAddress; // Votium Strategy Address\n    uint256 public latestWithdrawId;\n\n    struct WithdrawInfo {\n        address owner;\n        uint256 amount;\n        uint256 safEthWithdrawAmount;\n        uint256 vEthWithdrawId;\n        uint256 withdrawTime;\n    }\n\n    mapping(uint256 => WithdrawInfo) public withdrawIdInfo;\n    bool public pauseDeposit;\n    bool public pauseWithdraw;\n\n    error StrategyAlreadyAdded();\n    error StrategyNotFound();\n    error InsufficientBalance();\n    error InvalidStrategy();\n    error InvalidFee();\n    error CanNotWithdraw();\n    error NotOwner();\n    error FailedToSend();\n    error FailedToDeposit();\n    error Paused();\n    error BelowMinOut();\n\n    event WithdrawRequest(\n        address indexed account,\n        uint256 amount,\n        uint256 withdrawId,\n        uint256 withdrawTime\n    );\n\n    address private constant CVX_ADDRESS =\n        0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B;\n    address private constant VLCVX_ADDRESS =\n        0x72a19342e8F1838460eBFCCEf09F6585e32db86E;\n\n    uint256 public pendingSafEthWithdraws;\n\n    modifier onlyWithdrawIdOwner(uint256 withdrawId) {\n        if (withdrawIdInfo[withdrawId].owner != msg.sender) revert NotOwner();\n        _;\n    }\n\n    // As recommended by https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n        @notice - Initialize values for the contracts\n        @dev - This replaces the constructor for upgradeable contracts\n    */\n    function initialize() external initializer {\n        _transferOwnership(msg.sender);\n        ratio = 5e17;\n    }\n\n    /**\n     * @notice - Sets the strategy addresses for safEth and votium\n     * @param _vEthAddress - vEth strategy address\n     */\n    function setStrategyAddress(address _vEthAddress) external onlyOwner {\n        vEthAddress = _vEthAddress;\n    }\n\n    /**\n        @notice - Sets the target ratio of safEth to votium. \n        @notice target ratio is maintained by directing rewards into either safEth or votium strategy\n        @param _newRatio - New ratio of safEth to votium\n    */\n    function setRatio(uint256 _newRatio) public onlyOwner {\n        ratio = _newRatio;\n    }\n\n    /**\n        @notice - Sets the protocol fee address which takes a percentage of the rewards.\n        @param _newFeeAddress - New protocol fee address to collect rewards\n    */\n    function setFeeAddress(address _newFeeAddress) public onlyOwner {\n        feeAddress = _newFeeAddress;\n    }\n\n    /**\n        @notice - Sets the protocol fee which takes a percentage of the rewards.\n        @param _newFee - New protocol fee\n    */\n    function setProtocolFee(uint256 _newFee) public onlyOwner {\n        if (_newFee > 1e18) revert InvalidFee();\n        protocolFee = _newFee;\n    }\n\n    /**\n        @notice - Enables/Disables depositing\n        @param _pauseDeposit - Bool to set pauseDeposit\n\n    */\n    function setPauseDeposit(bool _pauseDeposit) external onlyOwner {\n        pauseDeposit = _pauseDeposit;\n    }\n\n    /**\n        @notice - Enables/Disables withdrawing & requesting to withdraw\n        @param _pauseWithdraw - Bool to set pauseWithdraw\n    */\n    function setPauseWithdraw(bool _pauseWithdraw) external onlyOwner {\n        pauseWithdraw = _pauseWithdraw;\n    }\n\n    /**\n        @notice - Get's the price of afEth\n        @dev - Checks each strategy and calculates the total value in ETH divided by supply of afETH tokens\n        @return - Price of afEth\n    */\n    function price() public view returns (uint256) {\n        if (totalSupply() == 0) return 1e18;\n        AbstractStrategy vEthStrategy = AbstractStrategy(vEthAddress);\n        uint256 safEthValueInEth = (ISafEth(SAF_ETH_ADDRESS).approxPrice(true) *\n            safEthBalanceMinusPending()) / 1e18;\n        uint256 vEthValueInEth = (vEthStrategy.price() *\n            vEthStrategy.balanceOf(address(this))) / 1e18;\n        return ((vEthValueInEth + safEthValueInEth) * 1e18) / totalSupply();\n    }\n\n    /**\n        @notice - Deposits into each strategy\n        @dev - This is the entry into the protocol\n        @param _minout - Minimum amount of afEth to mint\n    */\n    function deposit(uint256 _minout) external payable virtual {\n        if (pauseDeposit) revert Paused();\n        uint256 amount = msg.value;\n        uint256 priceBeforeDeposit = price();\n        uint256 totalValue;\n\n        AbstractStrategy vStrategy = AbstractStrategy(vEthAddress);\n\n        uint256 sValue = (amount * ratio) / 1e18;\n        uint256 sMinted = sValue > 0\n            ? ISafEth(SAF_ETH_ADDRESS).stake{value: sValue}(0)\n            : 0;\n        uint256 vValue = (amount * (1e18 - ratio)) / 1e18;\n        uint256 vMinted = vValue > 0 ? vStrategy.deposit{value: vValue}() : 0;\n        totalValue +=\n            (sMinted * ISafEth(SAF_ETH_ADDRESS).approxPrice(true)) +\n            (vMinted * vStrategy.price());\n        if (totalValue == 0) revert FailedToDeposit();\n        uint256 amountToMint = totalValue / priceBeforeDeposit;\n        if (amountToMint < _minout) revert BelowMinOut();\n        _mint(msg.sender, amountToMint);\n    }\n\n    /**\n        @notice - Request to close position\n        @param _amount - Amount of afEth to withdraw\n    */\n    function requestWithdraw(uint256 _amount) external virtual {\n        uint256 withdrawTimeBefore = withdrawTime(_amount);\n        if (pauseWithdraw) revert Paused();\n        latestWithdrawId++;\n\n        // ratio of afEth being withdrawn to totalSupply\n        // we are transfering the afEth to the contract when we requestWithdraw\n        // we shouldn't include that in the withdrawRatio\n        uint256 afEthBalance = balanceOf(address(this));\n        uint256 withdrawRatio = (_amount * 1e18) /\n            (totalSupply() - afEthBalance);\n\n        _transfer(msg.sender, address(this), _amount);\n\n        uint256 votiumBalance = IERC20(vEthAddress).balanceOf(address(this));\n        uint256 votiumWithdrawAmount = (withdrawRatio * votiumBalance) / 1e18;\n        uint256 vEthWithdrawId = AbstractStrategy(vEthAddress).requestWithdraw(\n            votiumWithdrawAmount\n        );\n\n        uint256 safEthBalance = safEthBalanceMinusPending();\n\n        uint256 safEthWithdrawAmount = (withdrawRatio * safEthBalance) / 1e18;\n\n        pendingSafEthWithdraws += safEthWithdrawAmount;\n\n        withdrawIdInfo[latestWithdrawId]\n            .safEthWithdrawAmount = safEthWithdrawAmount;\n        withdrawIdInfo[latestWithdrawId].vEthWithdrawId = vEthWithdrawId;\n\n        withdrawIdInfo[latestWithdrawId].owner = msg.sender;\n        withdrawIdInfo[latestWithdrawId].amount = _amount;\n        withdrawIdInfo[latestWithdrawId].withdrawTime = withdrawTimeBefore;\n\n        emit WithdrawRequest(\n            msg.sender,\n            _amount,\n            latestWithdrawId,\n            withdrawTimeBefore\n        );\n    }\n\n    /**\n        @notice - Checks if withdraw can be executed from withdrawId\n        @param _withdrawId - Id of the withdraw request for SafEth\n        @return - Bool if withdraw can be executed\n    */\n    function canWithdraw(uint256 _withdrawId) public view returns (bool) {\n        return\n            AbstractStrategy(vEthAddress).canWithdraw(\n                withdrawIdInfo[_withdrawId].vEthWithdrawId\n            );\n    }\n\n    /**\n        @notice - Get's the withdraw time for an amount of AfEth\n        @param _amount - Amount of afETH to withdraw\n        @return - Highest withdraw time of the strategies\n    */\n    function withdrawTime(uint256 _amount) public view returns (uint256) {\n        return AbstractStrategy(vEthAddress).withdrawTime(_amount);\n    }\n\n    /**\n        @notice - Withdraw from each strategy\n        @param _withdrawId - Id of the withdraw request\n        @param _minout - Minimum amount of ETH to receive\n    */\n    function withdraw(\n        uint256 _withdrawId,\n        uint256 _minout\n    ) external virtual onlyWithdrawIdOwner(_withdrawId) {\n        if (pauseWithdraw) revert Paused();\n        uint256 ethBalanceBefore = address(this).balance;\n        WithdrawInfo memory withdrawInfo = withdrawIdInfo[_withdrawId];\n        if (!canWithdraw(_withdrawId)) revert CanNotWithdraw();\n\n        ISafEth(SAF_ETH_ADDRESS).unstake(withdrawInfo.safEthWithdrawAmount, 0);\n        AbstractStrategy(vEthAddress).withdraw(withdrawInfo.vEthWithdrawId);\n\n        _burn(address(this), withdrawIdInfo[_withdrawId].amount);\n        uint256 ethBalanceAfter = address(this).balance;\n        uint256 ethReceived = ethBalanceAfter - ethBalanceBefore;\n\n        pendingSafEthWithdraws -= withdrawInfo.safEthWithdrawAmount;\n\n        if (ethReceived < _minout) revert BelowMinOut();\n        // solhint-disable-next-line\n        (bool sent, ) = msg.sender.call{value: ethReceived}(\"\");\n        if (!sent) revert FailedToSend();\n    }\n\n    /**\n     * @notice - sells _amount of eth from votium contract\n     * @dev - puts it into safEthStrategy or votiumStrategy, whichever is underweight.\\\n     * @param _amount - amount of eth to sell\n     */\n    function depositRewards(uint256 _amount) public payable {\n        IVotiumStrategy votiumStrategy = IVotiumStrategy(vEthAddress);\n        uint256 feeAmount = (_amount * protocolFee) / 1e18;\n        if (feeAmount > 0) {\n            // solhint-disable-next-line\n            (bool sent, ) = feeAddress.call{value: feeAmount}(\"\");\n            if (!sent) revert FailedToSend();\n        }\n        uint256 amount = _amount - feeAmount;\n        uint256 safEthTvl = (ISafEth(SAF_ETH_ADDRESS).approxPrice(true) *\n            safEthBalanceMinusPending()) / 1e18;\n        uint256 votiumTvl = ((votiumStrategy.cvxPerVotium() *\n            votiumStrategy.ethPerCvx(true)) *\n            IERC20(vEthAddress).balanceOf(address(this))) / 1e36;\n        uint256 totalTvl = (safEthTvl + votiumTvl);\n        uint256 safEthRatio = (safEthTvl * 1e18) / totalTvl;\n        if (safEthRatio < ratio) {\n            ISafEth(SAF_ETH_ADDRESS).stake{value: amount}(0);\n        } else {\n            votiumStrategy.depositRewards{value: amount}(amount);\n        }\n    }\n\n    function safEthBalanceMinusPending() public view returns (uint256) {\n        return\n            IERC20(SAF_ETH_ADDRESS).balanceOf(address(this)) -\n            pendingSafEthWithdraws;\n    }\n\n    receive() external payable {}\n}"
    }
  ]
}