{
  "Title": "M-4: Adversary can break NFT distribution by depositing up to max then refunding all of them",
  "Content": "# Issue M-4: Adversary can break NFT distribution by depositing up to max then refunding all of them \n\nSource: https://github.com/sherlock-audit/2023-02-openq-judging/issues/262 \n\n## Found by \nHollaDieWaldfee, Jeiwan, 0x52, HonorLt, GimelSec, bin2chen, caventa, kiki\\_dev, clems4ever, unforgiven, Ruhum, 0xmuxyz, dipp, jkoppel, libratus\n\n## Summary\n\nBounties limit the number of NFT deposits to five. An adversary can block adding NFTs by repeatedly depositing and withdrawing an NFT.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-02-openq/blob/main/contracts/Bounty/Implementations/BountyCore.sol#L64-L93\n\nAll bounties use BountyCore#refundDeposit to process refunds to user. This simply transfers the NFT back to the funder but leaves the nftDeposit. This uses up the deposit limit which is current set to 5. Since the deposit cap is used up by deposits that have been refunded the slots can't be used to distribute legitimate NFTs to the bounty claimant. \n\n## Impact\n\nAdversary can block legitimate NFT distribution\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-openq/blob/main/contracts/Bounty/Implementations/BountyCore.sol#L64-L93\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWhen an NFT deposit is refunded it should remove the depositID from nftDeposits\n\n## Discussion\n\n**FlacoJones**\n\nValid. Will fix by removing nft funding and disbaling crowdfunding\n\n**FlacoJones**\n\nhttps://github.com/OpenQDev/OpenQ-Contracts/pull/113\n\nand \n\nhttps://github.com/OpenQDev/OpenQ-Contracts/pull/116\n\nand\n\nhttps://github.com/OpenQDev/OpenQ-Contracts/pull/114\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/39",
  "Code": [
    {
      "filename": "contracts/Bounty/Implementations/BountyCore.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport '../Storage/BountyStorageCore.sol';\n\n/// @title BountyCore\n/// @author FlacoJones\n/// @notice Shared methods common to all bounty types\n/// @dev BountyCore -> BountyStorageCore -> Core Dependencies (OZ + Custom)\nabstract contract BountyCore is BountyStorageCore {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address payable;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    /// @notice Creates a deposit and transfers tokens from msg.sender to this contract\n    /// @param _funder The funder's address\n    /// @param _tokenAddress The ERC20 token address (ZeroAddress if funding with protocol token)\n    /// @param _volume The volume of token to transfer\n    /// @param _expiration The duration until the deposit becomes refundable\n    /// @return (depositId, volumeReceived) Returns the deposit id and the amount transferred to bounty\n    function receiveFunds(\n        address _funder,\n        address _tokenAddress,\n        uint256 _volume,\n        uint256 _expiration\n    )\n        external\n        payable\n        virtual\n        onlyDepositManager\n        nonReentrant\n        returns (bytes32, uint256)\n    {\n        require(_volume != 0, Errors.ZERO_VOLUME_SENT);\n        require(_expiration > 0, Errors.EXPIRATION_NOT_GREATER_THAN_ZERO);\n        require(status == OpenQDefinitions.OPEN, Errors.CONTRACT_IS_CLOSED);\n\n        bytes32 depositId = _generateDepositId();\n\n        uint256 volumeReceived;\n        if (_tokenAddress == address(0)) {\n            volumeReceived = msg.value;\n        } else {\n            volumeReceived = _receiveERC20(_tokenAddress, _funder, _volume);\n        }\n\n        funder[depositId] = _funder;\n        tokenAddress[depositId] = _tokenAddress;\n        volume[depositId] = volumeReceived;\n        depositTime[depositId] = block.timestamp;\n        expiration[depositId] = _expiration;\n        isNFT[depositId] = false;\n\n        deposits.push(depositId);\n        tokenAddresses.add(_tokenAddress);\n\n        return (depositId, volumeReceived);\n    }\n\n    /// @notice Transfers volume of deposit or NFT of deposit from bounty to funder\n    /// @param _depositId The deposit to refund\n    /// @param _funder The initial funder of the deposit\n    /// @param _volume The volume to be refunded (only relevant if deposit is not an NFT, otherwise is zero)\n    function refundDeposit(\n        bytes32 _depositId,\n        address _funder,\n        uint256 _volume\n    ) external virtual onlyDepositManager nonReentrant {\n        require(!refunded[_depositId], Errors.DEPOSIT_ALREADY_REFUNDED);\n        require(funder[_depositId] == _funder, Errors.CALLER_NOT_FUNDER);\n        require(\n            block.timestamp >= depositTime[_depositId] + expiration[_depositId],\n            Errors.PREMATURE_REFUND_REQUEST\n        );\n\n        refunded[_depositId] = true;\n\n        if (tokenAddress[_depositId] == address(0)) {\n            _transferProtocolToken(funder[_depositId], _volume);\n        } else if (isNFT[_depositId]) {\n            _transferNft(\n                tokenAddress[_depositId],\n                funder[_depositId],\n                tokenId[_depositId]\n            );\n        } else {\n            _transferERC20(\n                tokenAddress[_depositId],\n                funder[_depositId],\n                _volume\n            );\n        }\n    }\n\n    /// @notice Extends deposit duration\n    /// @param _depositId The deposit to extend\n    /// @param _seconds Number of seconds to extend deposit\n    /// @param _funder The initial funder of the deposit\n    function extendDeposit(\n        bytes32 _depositId,\n        uint256 _seconds,\n        address _funder\n    ) external virtual onlyDepositManager nonReentrant returns (uint256) {\n        require(status == OpenQDefinitions.OPEN, Errors.CONTRACT_IS_CLOSED);\n        require(!refunded[_depositId], Errors.DEPOSIT_ALREADY_REFUNDED);\n        require(funder[_depositId] == _funder, Errors.CALLER_NOT_FUNDER);\n\n        if (\n            block.timestamp > depositTime[_depositId] + expiration[_depositId]\n        ) {\n            expiration[_depositId] =\n                block.timestamp -\n                depositTime[_depositId] +\n                _seconds;\n        } else {\n            expiration[_depositId] = expiration[_depositId] + _seconds;\n        }\n\n        return expiration[_depositId];\n    }\n\n    /// @notice Transfers NFT from bounty address to _payoutAddress\n    /// @param _payoutAddress The destination address for the NFT\n    /// @param _depositId The payout address of the bounty\n    function claimNft(address _payoutAddress, bytes32 _depositId)\n        external\n        virtual\n        onlyClaimManager\n        nonReentrant\n    {\n        _transferNft(\n            tokenAddress[_depositId],\n            _payoutAddress,\n            tokenId[_depositId]\n        );\n    }\n\n    /// @notice Sets the funding goal\n    /// @param _fundingToken Token address for funding goal\n    /// @param _fundingGoal Token volume for funding goal\n    function setFundingGoal(address _fundingToken, uint256 _fundingGoal)\n        external\n        virtual\n        onlyOpenQ\n    {\n        fundingGoal = _fundingGoal;\n        fundingToken = _fundingToken;\n        hasFundingGoal = true;\n    }\n\n    /// @notice Whether or not KYC is required to fund and claim the bounty\n    /// @param _kycRequired Whether or not KYC is required to fund and claim the bounty\n    function setKycRequired(bool _kycRequired) external virtual onlyOpenQ {\n        kycRequired = _kycRequired;\n    }\n\n    /// @notice Whether or not the Bounty is invoiceRequired\n    /// @param _invoiceRequired Whether or not the Bounty is invoiceRequired\n    function setInvoiceRequired(bool _invoiceRequired)\n        external\n        virtual\n        onlyOpenQ\n    {\n        invoiceRequired = _invoiceRequired;\n    }\n\n    /// @notice Whether or not KYC is required to fund and claim the bounty\n    /// @param _supportingDocumentsRequired Whether or not KYC is required to fund and claim the bounty\n    function setSupportingDocumentsRequired(bool _supportingDocumentsRequired)\n        external\n        virtual\n        onlyOpenQ\n    {\n        supportingDocumentsRequired = _supportingDocumentsRequired;\n    }\n\n    /// @notice Transfers _volume of both ERC20 or protocol token to _payoutAddress\n    /// @param _tokenAddress Address of an ERC20 or Zero Address for protocol token\n    /// @param _volume Volume to transfer\n    /// @param _payoutAddress Destination address\n    function _transferToken(\n        address _tokenAddress,\n        uint256 _volume,\n        address _payoutAddress\n    ) internal virtual {\n        if (_tokenAddress == address(0)) {\n            _transferProtocolToken(_payoutAddress, _volume);\n        } else {\n            _transferERC20(_tokenAddress, _payoutAddress, _volume);\n        }\n    }\n\n    /// @notice Receives _volume of ERC20 at _tokenAddress from _funder to bounty address\n    /// @param _tokenAddress The ERC20 token address\n    /// @param _funder The funder of the bounty\n    /// @param _volume The volume of token to transfer\n    function _receiveERC20(\n        address _tokenAddress,\n        address _funder,\n        uint256 _volume\n    ) internal virtual returns (uint256) {\n        uint256 balanceBefore = getERC20Balance(_tokenAddress);\n        IERC20Upgradeable token = IERC20Upgradeable(_tokenAddress);\n        token.safeTransferFrom(_funder, address(this), _volume);\n        uint256 balanceAfter = getERC20Balance(_tokenAddress);\n        require(\n            balanceAfter >= balanceBefore,\n            Errors.TOKEN_TRANSFER_IN_OVERFLOW\n        );\n\n        //// The reason we take the balanceBefore and balanceAfter rather than the raw volume\n        /// is because certain ERC20 contracts ( e.g. USDT) take fees on transfers.\n        /// Therefore the volume received after transferFrom can be lower than the raw volume sent by the sender\n        return balanceAfter - balanceBefore;\n    }\n\n    /// @notice Transfers _volume of ERC20 at _tokenAddress from bounty address to _funder\n    /// @param _tokenAddress The ERC20 token address\n    /// @param _payoutAddress The destination address of the funds\n    /// @param _volume The volume of token to transfer\n    function _transferERC20(\n        address _tokenAddress,\n        address _payoutAddress,\n        uint256 _volume\n    ) internal virtual {\n        IERC20Upgradeable token = IERC20Upgradeable(_tokenAddress);\n        token.safeTransfer(_payoutAddress, _volume);\n    }\n\n    /// @notice Transfers _volume of protocol token from bounty address to _payoutAddress\n    /// @param _payoutAddress The destination address of the funds\n    /// @param _volume The volume of token to transfer\n    function _transferProtocolToken(address _payoutAddress, uint256 _volume)\n        internal\n        virtual\n    {\n        payable(_payoutAddress).sendValue(_volume);\n    }\n\n    /// @notice Receives NFT of _tokenId on _tokenAddress from _funder to bounty address\n    /// @param _tokenAddress The ERC721 token address\n    /// @param _sender The sender of the NFT\n    /// @param _tokenId The tokenId\n    function _receiveNft(\n        address _tokenAddress,\n        address _sender,\n        uint256 _tokenId\n    ) internal virtual {\n        IERC721Upgradeable nft = IERC721Upgradeable(_tokenAddress);\n        nft.safeTransferFrom(_sender, address(this), _tokenId);\n    }\n\n    /// @notice Transfers NFT of _tokenId on _tokenAddress from bounty address to _payoutAddress\n    /// @param _tokenAddress The ERC721 token address\n    /// @param _payoutAddress The sender of the NFT\n    /// @param _tokenId The tokenId\n    function _transferNft(\n        address _tokenAddress,\n        address _payoutAddress,\n        uint256 _tokenId\n    ) internal virtual {\n        IERC721Upgradeable nft = IERC721Upgradeable(_tokenAddress);\n        nft.safeTransferFrom(address(this), _payoutAddress, _tokenId);\n    }\n\n    /// @notice Generates a unique deposit ID from bountyId and the current length of deposits\n    function _generateDepositId() internal view virtual returns (bytes32) {\n        return keccak256(abi.encode(bountyId, deposits.length));\n    }\n\n    /// TRANSFER HELPERS\n\n    /// @notice Returns token balance for both ERC20 or protocol token\n    /// @param _tokenAddress Address of an ERC20 or Zero Address for protocol token\n    function getTokenBalance(address _tokenAddress)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        if (_tokenAddress == address(0)) {\n            return address(this).balance;\n        } else {\n            return getERC20Balance(_tokenAddress);\n        }\n    }\n\n    /// @notice Returns the ERC20 balance for this bounty address\n    /// @param _tokenAddress The ERC20 token address\n    /// @return balance The ERC20 balance for this bounty address\n    function getERC20Balance(address _tokenAddress)\n        public\n        view\n        virtual\n        returns (uint256 balance)\n    {\n        IERC20Upgradeable token = IERC20Upgradeable(_tokenAddress);\n        return token.balanceOf(address(this));\n    }\n\n    /// @notice Returns an array of all deposits (ERC20, protocol token, and NFT) for this bounty\n    /// @return deposits The array of deposits including ERC20, protocol token, and NFT\n    function getDeposits() external view virtual returns (bytes32[] memory) {\n        return deposits;\n    }\n\n    /// @notice Returns an array of ONLY NFT deposits for this bounty\n    /// @return nftDeposits The array of NFT deposits\n    function getNftDeposits() external view virtual returns (bytes32[] memory) {\n        return nftDeposits;\n    }\n\n    /// @notice Returns an array of all ERC20 token addresses which have funded this bounty\n    /// @return tokenAddresses An array of all ERC20 token addresses which have funded this bounty\n    function getTokenAddresses()\n        public\n        view\n        virtual\n        returns (address[] memory)\n    {\n        return tokenAddresses.values();\n    }\n\n    /// @notice Returns the total number of unique tokens deposited on the bounty\n    /// @return tokenAddressesCount The length of the array of all ERC20 token addresses which have funded this bounty\n    function getTokenAddressesCount() external view virtual returns (uint256) {\n        return tokenAddresses.values().length;\n    }\n\n    /// @notice Returns the amount of locked tokens (of a specific token) on a bounty address, only available for claims but not for refunds\n    /// @param _depositId The depositId that determines which token is being looked at\n    /// @return uint256\n    function getLockedFunds(address _depositId)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        uint256 lockedFunds;\n        bytes32[] memory depList = this.getDeposits();\n        for (uint256 i = 0; i < depList.length; i++) {\n            if (\n                block.timestamp <\n                depositTime[depList[i]] + expiration[depList[i]] &&\n                tokenAddress[depList[i]] == _depositId\n            ) {\n                lockedFunds += volume[depList[i]];\n            }\n        }\n\n        return lockedFunds;\n    }\n}"
    },
    {
      "filename": "contracts/Bounty/Implementations/BountyCore.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport '../Storage/BountyStorageCore.sol';\n\n/// @title BountyCore\n/// @author FlacoJones\n/// @notice Shared methods common to all bounty types\n/// @dev BountyCore -> BountyStorageCore -> Core Dependencies (OZ + Custom)\nabstract contract BountyCore is BountyStorageCore {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address payable;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    /// @notice Creates a deposit and transfers tokens from msg.sender to this contract\n    /// @param _funder The funder's address\n    /// @param _tokenAddress The ERC20 token address (ZeroAddress if funding with protocol token)\n    /// @param _volume The volume of token to transfer\n    /// @param _expiration The duration until the deposit becomes refundable\n    /// @return (depositId, volumeReceived) Returns the deposit id and the amount transferred to bounty\n    function receiveFunds(\n        address _funder,\n        address _tokenAddress,\n        uint256 _volume,\n        uint256 _expiration\n    )\n        external\n        payable\n        virtual\n        onlyDepositManager\n        nonReentrant\n        returns (bytes32, uint256)\n    {\n        require(_volume != 0, Errors.ZERO_VOLUME_SENT);\n        require(_expiration > 0, Errors.EXPIRATION_NOT_GREATER_THAN_ZERO);\n        require(status == OpenQDefinitions.OPEN, Errors.CONTRACT_IS_CLOSED);\n\n        bytes32 depositId = _generateDepositId();\n\n        uint256 volumeReceived;\n        if (_tokenAddress == address(0)) {\n            volumeReceived = msg.value;\n        } else {\n            volumeReceived = _receiveERC20(_tokenAddress, _funder, _volume);\n        }\n\n        funder[depositId] = _funder;\n        tokenAddress[depositId] = _tokenAddress;\n        volume[depositId] = volumeReceived;\n        depositTime[depositId] = block.timestamp;\n        expiration[depositId] = _expiration;\n        isNFT[depositId] = false;\n\n        deposits.push(depositId);\n        tokenAddresses.add(_tokenAddress);\n\n        return (depositId, volumeReceived);\n    }\n\n    /// @notice Transfers volume of deposit or NFT of deposit from bounty to funder\n    /// @param _depositId The deposit to refund\n    /// @param _funder The initial funder of the deposit\n    /// @param _volume The volume to be refunded (only relevant if deposit is not an NFT, otherwise is zero)\n    function refundDeposit(\n        bytes32 _depositId,\n        address _funder,\n        uint256 _volume\n    ) external virtual onlyDepositManager nonReentrant {\n        require(!refunded[_depositId], Errors.DEPOSIT_ALREADY_REFUNDED);\n        require(funder[_depositId] == _funder, Errors.CALLER_NOT_FUNDER);\n        require(\n            block.timestamp >= depositTime[_depositId] + expiration[_depositId],\n            Errors.PREMATURE_REFUND_REQUEST\n        );\n\n        refunded[_depositId] = true;\n\n        if (tokenAddress[_depositId] == address(0)) {\n            _transferProtocolToken(funder[_depositId], _volume);\n        } else if (isNFT[_depositId]) {\n            _transferNft(\n                tokenAddress[_depositId],\n                funder[_depositId],\n                tokenId[_depositId]\n            );\n        } else {\n            _transferERC20(\n                tokenAddress[_depositId],\n                funder[_depositId],\n                _volume\n            );\n        }\n    }\n\n    /// @notice Extends deposit duration\n    /// @param _depositId The deposit to extend\n    /// @param _seconds Number of seconds to extend deposit\n    /// @param _funder The initial funder of the deposit\n    function extendDeposit(\n        bytes32 _depositId,\n        uint256 _seconds,\n        address _funder\n    ) external virtual onlyDepositManager nonReentrant returns (uint256) {\n        require(status == OpenQDefinitions.OPEN, Errors.CONTRACT_IS_CLOSED);\n        require(!refunded[_depositId], Errors.DEPOSIT_ALREADY_REFUNDED);\n        require(funder[_depositId] == _funder, Errors.CALLER_NOT_FUNDER);\n\n        if (\n            block.timestamp > depositTime[_depositId] + expiration[_depositId]\n        ) {\n            expiration[_depositId] =\n                block.timestamp -\n                depositTime[_depositId] +\n                _seconds;\n        } else {\n            expiration[_depositId] = expiration[_depositId] + _seconds;\n        }\n\n        return expiration[_depositId];\n    }\n\n    /// @notice Transfers NFT from bounty address to _payoutAddress\n    /// @param _payoutAddress The destination address for the NFT\n    /// @param _depositId The payout address of the bounty\n    function claimNft(address _payoutAddress, bytes32 _depositId)\n        external\n        virtual\n        onlyClaimManager\n        nonReentrant\n    {\n        _transferNft(\n            tokenAddress[_depositId],\n            _payoutAddress,\n            tokenId[_depositId]\n        );\n    }\n\n    /// @notice Sets the funding goal\n    /// @param _fundingToken Token address for funding goal\n    /// @param _fundingGoal Token volume for funding goal\n    function setFundingGoal(address _fundingToken, uint256 _fundingGoal)\n        external\n        virtual\n        onlyOpenQ\n    {\n        fundingGoal = _fundingGoal;\n        fundingToken = _fundingToken;\n        hasFundingGoal = true;\n    }\n\n    /// @notice Whether or not KYC is required to fund and claim the bounty\n    /// @param _kycRequired Whether or not KYC is required to fund and claim the bounty\n    function setKycRequired(bool _kycRequired) external virtual onlyOpenQ {\n        kycRequired = _kycRequired;\n    }\n\n    /// @notice Whether or not the Bounty is invoiceRequired\n    /// @param _invoiceRequired Whether or not the Bounty is invoiceRequired\n    function setInvoiceRequired(bool _invoiceRequired)\n        external\n        virtual\n        onlyOpenQ\n    {\n        invoiceRequired = _invoiceRequired;\n    }\n\n    /// @notice Whether or not KYC is required to fund and claim the bounty\n    /// @param _supportingDocumentsRequired Whether or not KYC is required to fund and claim the bounty\n    function setSupportingDocumentsRequired(bool _supportingDocumentsRequired)\n        external\n        virtual\n        onlyOpenQ\n    {\n        supportingDocumentsRequired = _supportingDocumentsRequired;\n    }\n\n    /// @notice Transfers _volume of both ERC20 or protocol token to _payoutAddress\n    /// @param _tokenAddress Address of an ERC20 or Zero Address for protocol token\n    /// @param _volume Volume to transfer\n    /// @param _payoutAddress Destination address\n    function _transferToken(\n        address _tokenAddress,\n        uint256 _volume,\n        address _payoutAddress\n    ) internal virtual {\n        if (_tokenAddress == address(0)) {\n            _transferProtocolToken(_payoutAddress, _volume);\n        } else {\n            _transferERC20(_tokenAddress, _payoutAddress, _volume);\n        }\n    }\n\n    /// @notice Receives _volume of ERC20 at _tokenAddress from _funder to bounty address\n    /// @param _tokenAddress The ERC20 token address\n    /// @param _funder The funder of the bounty\n    /// @param _volume The volume of token to transfer\n    function _receiveERC20(\n        address _tokenAddress,\n        address _funder,\n        uint256 _volume\n    ) internal virtual returns (uint256) {\n        uint256 balanceBefore = getERC20Balance(_tokenAddress);\n        IERC20Upgradeable token = IERC20Upgradeable(_tokenAddress);\n        token.safeTransferFrom(_funder, address(this), _volume);\n        uint256 balanceAfter = getERC20Balance(_tokenAddress);\n        require(\n            balanceAfter >= balanceBefore,\n            Errors.TOKEN_TRANSFER_IN_OVERFLOW\n        );\n\n        //// The reason we take the balanceBefore and balanceAfter rather than the raw volume\n        /// is because certain ERC20 contracts ( e.g. USDT) take fees on transfers.\n        /// Therefore the volume received after transferFrom can be lower than the raw volume sent by the sender\n        return balanceAfter - balanceBefore;\n    }\n\n    /// @notice Transfers _volume of ERC20 at _tokenAddress from bounty address to _funder\n    /// @param _tokenAddress The ERC20 token address\n    /// @param _payoutAddress The destination address of the funds\n    /// @param _volume The volume of token to transfer\n    function _transferERC20(\n        address _tokenAddress,\n        address _payoutAddress,\n        uint256 _volume\n    ) internal virtual {\n        IERC20Upgradeable token = IERC20Upgradeable(_tokenAddress);\n        token.safeTransfer(_payoutAddress, _volume);\n    }\n\n    /// @notice Transfers _volume of protocol token from bounty address to _payoutAddress\n    /// @param _payoutAddress The destination address of the funds\n    /// @param _volume The volume of token to transfer\n    function _transferProtocolToken(address _payoutAddress, uint256 _volume)\n        internal\n        virtual\n    {\n        payable(_payoutAddress).sendValue(_volume);\n    }\n\n    /// @notice Receives NFT of _tokenId on _tokenAddress from _funder to bounty address\n    /// @param _tokenAddress The ERC721 token address\n    /// @param _sender The sender of the NFT\n    /// @param _tokenId The tokenId\n    function _receiveNft(\n        address _tokenAddress,\n        address _sender,\n        uint256 _tokenId\n    ) internal virtual {\n        IERC721Upgradeable nft = IERC721Upgradeable(_tokenAddress);\n        nft.safeTransferFrom(_sender, address(this), _tokenId);\n    }\n\n    /// @notice Transfers NFT of _tokenId on _tokenAddress from bounty address to _payoutAddress\n    /// @param _tokenAddress The ERC721 token address\n    /// @param _payoutAddress The sender of the NFT\n    /// @param _tokenId The tokenId\n    function _transferNft(\n        address _tokenAddress,\n        address _payoutAddress,\n        uint256 _tokenId\n    ) internal virtual {\n        IERC721Upgradeable nft = IERC721Upgradeable(_tokenAddress);\n        nft.safeTransferFrom(address(this), _payoutAddress, _tokenId);\n    }\n\n    /// @notice Generates a unique deposit ID from bountyId and the current length of deposits\n    function _generateDepositId() internal view virtual returns (bytes32) {\n        return keccak256(abi.encode(bountyId, deposits.length));\n    }\n\n    /// TRANSFER HELPERS\n\n    /// @notice Returns token balance for both ERC20 or protocol token\n    /// @param _tokenAddress Address of an ERC20 or Zero Address for protocol token\n    function getTokenBalance(address _tokenAddress)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        if (_tokenAddress == address(0)) {\n            return address(this).balance;\n        } else {\n            return getERC20Balance(_tokenAddress);\n        }\n    }\n\n    /// @notice Returns the ERC20 balance for this bounty address\n    /// @param _tokenAddress The ERC20 token address\n    /// @return balance The ERC20 balance for this bounty address\n    function getERC20Balance(address _tokenAddress)\n        public\n        view\n        virtual\n        returns (uint256 balance)\n    {\n        IERC20Upgradeable token = IERC20Upgradeable(_tokenAddress);\n        return token.balanceOf(address(this));\n    }\n\n    /// @notice Returns an array of all deposits (ERC20, protocol token, and NFT) for this bounty\n    /// @return deposits The array of deposits including ERC20, protocol token, and NFT\n    function getDeposits() external view virtual returns (bytes32[] memory) {\n        return deposits;\n    }\n\n    /// @notice Returns an array of ONLY NFT deposits for this bounty\n    /// @return nftDeposits The array of NFT deposits\n    function getNftDeposits() external view virtual returns (bytes32[] memory) {\n        return nftDeposits;\n    }\n\n    /// @notice Returns an array of all ERC20 token addresses which have funded this bounty\n    /// @return tokenAddresses An array of all ERC20 token addresses which have funded this bounty\n    function getTokenAddresses()\n        public\n        view\n        virtual\n        returns (address[] memory)\n    {\n        return tokenAddresses.values();\n    }\n\n    /// @notice Returns the total number of unique tokens deposited on the bounty\n    /// @return tokenAddressesCount The length of the array of all ERC20 token addresses which have funded this bounty\n    function getTokenAddressesCount() external view virtual returns (uint256) {\n        return tokenAddresses.values().length;\n    }\n\n    /// @notice Returns the amount of locked tokens (of a specific token) on a bounty address, only available for claims but not for refunds\n    /// @param _depositId The depositId that determines which token is being looked at\n    /// @return uint256\n    function getLockedFunds(address _depositId)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        uint256 lockedFunds;\n        bytes32[] memory depList = this.getDeposits();\n        for (uint256 i = 0; i < depList.length; i++) {\n            if (\n                block.timestamp <\n                depositTime[depList[i]] + expiration[depList[i]] &&\n                tokenAddress[depList[i]] == _depositId\n            ) {\n                lockedFunds += volume[depList[i]];\n            }\n        }\n\n        return lockedFunds;\n    }\n}"
    }
  ]
}