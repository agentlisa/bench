{
  "Title": "User's can loose collateral when exiting a short",
  "Content": "# User's can loose collateral when exiting a short\n\n### Severity\nHigh Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/ExitShortFacet.sol#L145-L224\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/ExitShortFacet.sol#L145-L224</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/BidOrdersFacet.sol#L283-L294\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/BidOrdersFacet.sol#L283-L294</a>\n\n\n## Summary\nIn `exitShort`, the ShortRecord is exited by placing a bid on the orderbook. If a partially filled ShortRecord matches with its own associated short order and fully buys back the debt, the user will loose the collateral present in the short order.\n\n## Vulnerability Details\nIf the user's own short order is matched when calling `exitShort`, the debt and collateral of the short order is added to the same ShortRecord that is being exited. If the user wanted to buyBack the entire debt and is successful in doing so, the ShortRecord will be deleted. \n```solidity\n    function exitShort(\n        address asset,\n        uint8 id,\n        uint88 buyBackAmount,\n        uint80 price,\n        uint16[] memory shortHintArray\n    )\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, msg.sender, id)\n    {\n        \n       // more code\n\n        // Create bid with current msg.sender\n        (e.ethFilled, e.ercAmountLeft) = IDiamond(payable(address(this))).createForcedBid(\n            msg.sender, e.asset, price, buyBackAmount, shortHintArray\n        );\n\n        e.ercFilled = buyBackAmount - e.ercAmountLeft;\n        Asset.ercDebt -= e.ercFilled;\n        s.assetUser[e.asset][msg.sender].ercEscrowed -= e.ercFilled;\n\n\n        // @audit if the debt is fully filled, the short record is deleted\n        // Refund the rest of the collateral if ercDebt is fully paid back\n        if (e.ercDebt == e.ercFilled) {\n            // Full Exit\n            LibShortRecord.disburseCollateral(\n                e.asset, msg.sender, e.collateral, short.zethYieldRate, short.updatedAt\n            );\n            LibShortRecord.deleteShortRecord(e.asset, msg.sender, id); // prevent re-entrancy\n``` \nhttps://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/ExitShortFacet.sol#L145-L224\n\nSince the user's newly added collateral from the partially filled short order is accounted in this ShortRecord, it will lead to the user loosing the collateral.\n\n```solidity\n    function matchlowestSell(\n        address asset,\n        STypes.Order memory lowestSell,\n        STypes.Order memory incomingBid,\n        MTypes.Match memory matchTotal\n    ) private {\n\n            // more code\n\n            // @audit if the short order is already associated with a shortRecord, the collateral and debt is accounted there\n            if (lowestSell.shortRecordId > 0) {\n                // shortRecord has been partially filled before\n                LibShortRecord.fillShortRecord(\n                    asset,\n                    lowestSell.addr,\n                    lowestSell.shortRecordId,\n                    status,\n                    shortFillEth,\n                    fillErc,\n                    matchTotal.ercDebtRate,\n                    matchTotal.zethYieldRate\n                );\n```\nhttps://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/BidOrdersFacet.sol#L254-L294\n\n### Example scenario:\n1. User calls the `createLimitShort` function with `price = 2000` and `debt = 100`. Hence supplying `collateral = 5 * 2000 * 100`\n2. Based on the current bids present in the orderbook, `50 ercTokens` is sold. \n3. This will create a ShortRecord with `debt = 50` and ` collateral = 3 * 2000 * 100` and a short order will be placed on the orderbook with `ercTokens amount = 50` and `price = 2000`.\n4. After some time the user decides to completely exit the short. The user calls `exitShort()` with `buyBackAmount = 50` and `price = 2000`.\n5. The lowest priced short order happens to be that of the user itself. Hence these two are matched resulting in the short order accounting for the new `collateral` and `debt` in the same ShortRecord.\n`ShortRecord.debt += 50` and `ShortRecord.collateral += 3 * 2000 * 100`.\n6. Since the enitre bid order is filled, `e.ercDebt == e.ercFilled` will pass, executing `LibShortRecord.deleteShortRecord(e.asset, msg.sender, id)`. This will delete the ShortRecord leading to the user not being able to claim his newly added `debt and collateral`. \n\n### POC Test\nAdd the following changes to test/Shorts.t.sol and run.\n```diff\ndiff --git a/test/Shorts.t.sol b/test/Shorts.t.sol\nindex f1c3927..79c4d52 100644\n--- a/test/Shorts.t.sol\n+++ b/test/Shorts.t.sol\n@@ -72,6 +72,51 @@ contract ShortsTest is OBFixture {\n         );\n     }\n \n+    function test_userLoosesCollateralOnMatchingWithUsersOwnShort() public{\n+        uint88 DEFAULT_AMOUNT_HALF = DEFAULT_AMOUNT/2;\n+        \n+        //funded inside fundLimitShortOpt\n+        uint88 userVaultEthEscrowedInitial = SHORT1_PRICE.mulU80(DEFAULT_AMOUNT) * 5;\n+\n+        //bids fills half the short\n+        fundLimitBidOpt(SHORT1_PRICE, DEFAULT_AMOUNT_HALF, receiver);\n+        fundLimitShortOpt(SHORT1_PRICE, DEFAULT_AMOUNT, sender);\n+\n+        //after short creation funds are split for the short order and the collateral\n+        assertEq(diamond.getVaultUserStruct(vault,sender).ethEscrowed,userVaultEthEscrowedInitial - SHORT1_PRICE.mulU80(DEFAULT_AMOUNT) * 5);\n+        \n+        STypes.Order memory userShortOrder = diamond.getShorts(asset)[0];\n+\n+        assertEq(userShortOrder.addr,sender);\n+        assertEq(userShortOrder.ercAmount,DEFAULT_AMOUNT_HALF);\n+\n+        STypes.ShortRecord memory userShortRecord = diamond.getShortRecords(asset,sender)[0];\n+\n+        assertEq(\n+            userShortRecord.ercDebt, DEFAULT_AMOUNT_HALF\n+        );\n+\n+        assertEq(\n+            userShortRecord.collateral,\n+            SHORT1_PRICE.mulU80(DEFAULT_AMOUNT_HALF) * 6\n+        );\n+\n+        //exit matching with the same short. this is supposed to move the funds from the short order to the short record. it does but since the record gets cancelled the user can no longer access these funds\n+        vm.prank(sender);\n+        uint16[] memory shortHintArray = new uint16[](1);\n+        shortHintArray[0] = userShortOrder.id;\n+\n+        diamond.exitShort(asset,userShortRecord.id,userShortRecord.ercDebt,SHORT1_PRICE,shortHintArray);\n+\n+        //short order gets filled and short record gets cancelled\n+        assertEq(diamond.getShorts(asset).length,0);\n+        assertEq(diamond.getShortRecords(asset,sender).length,0);\n+ \n+        // user now only has half of initial\n+         assertEq(diamond.getVaultUserStruct(vault,sender).ethEscrowed,userVaultEthEscrowedInitial/2);\n+        \n+    }\n+\n     function prepareExitShort(uint8 exitType) public {\n         makeShorts();\n``` \n\n## Impact\nUsers will loose collateral\n\n## Recommendation\nCheck if the existing debt is equal to the previous debt\n```diff\ndiff --git a/contracts/facets/ExitShortFacet.sol b/contracts/facets/ExitShortFacet.sol\nindex 8c73c38..4dadd69 100644\n--- a/contracts/facets/ExitShortFacet.sol\n+++ b/contracts/facets/ExitShortFacet.sol\n@@ -216,7 +216,7 @@ contract ExitShortFacet is Modifiers {\n         s.assetUser[e.asset][msg.sender].ercEscrowed -= e.ercFilled;\n \n         // Refund the rest of the collateral if ercDebt is fully paid back\n-        if (e.ercDebt == e.ercFilled) {\n+        if (e.ercDebt == e.ercFilled && short.ercDebt == e.ercDebt) {\n             // Full Exit\n             LibShortRecord.disburseCollateral(\n                 e.asset, msg.sender, e.collateral, short.zethYieldRate, short.updatedAt\n\n```",
  "Impact": "HIGH",
  "Source": "https://www.codehawks.com/contests/clm871gl00001mp081mzjdlwc",
  "Code": [
    {
      "filename": "contracts/facets/ExitShortFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U80, U88} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {IDiamond} from \"interfaces/IDiamond.sol\";\n\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {STypes, MTypes, OF} from \"contracts/libraries/DataTypes.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract ExitShortFacet is Modifiers {\n    using U256 for uint256;\n    using U80 for uint80;\n    using U88 for uint88;\n    using LibShortRecord for STypes.ShortRecord;\n    using {LibAsset.burnMsgSenderDebt} for address;\n\n    address private immutable cusd;\n\n    constructor(address _cusd) {\n        cusd = _cusd;\n    }\n\n    /**\n     * @notice Exits a short using shorter's ERC in wallet (i.e.MetaMask)\n     * @dev allows for partial exit via buyBackAmount\n     *\n     * @param asset The market that will be impacted\n     * @param id Id of short\n     * @param buyBackAmount Erc amount to buy back\n     *\n     */\n\n    function exitShortWallet(address asset, uint8 id, uint88 buyBackAmount)\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, msg.sender, id)\n    {\n        STypes.ShortRecord storage short = s.shortRecords[asset][msg.sender][id];\n\n        short.updateErcDebt(asset);\n        uint256 ercDebt = short.ercDebt;\n        if (buyBackAmount > ercDebt || buyBackAmount == 0) revert Errors.InvalidBuyback();\n\n        if (ercDebt > buyBackAmount) {\n            uint256 leftoverAmt = (ercDebt - buyBackAmount).mul(LibOracle.getPrice(asset));\n            if (leftoverAmt < LibAsset.minBidEth(asset)) {\n                revert Errors.CannotLeaveDustAmount();\n            }\n        }\n\n        asset.burnMsgSenderDebt(buyBackAmount);\n        s.asset[asset].ercDebt -= buyBackAmount;\n        // refund the rest of the collateral if ercDebt is fully paid back\n        if (buyBackAmount == ercDebt) {\n            uint256 vault = s.asset[asset].vault;\n            uint88 collateral = short.collateral;\n            s.vaultUser[vault][msg.sender].ethEscrowed += collateral;\n            LibShortRecord.disburseCollateral(\n                asset, msg.sender, collateral, short.zethYieldRate, short.updatedAt\n            );\n            LibShortRecord.deleteShortRecord(asset, msg.sender, id);\n        } else {\n            short.ercDebt -= buyBackAmount;\n            short.maybeResetFlag(asset);\n        }\n        emit Events.ExitShortWallet(asset, msg.sender, id, buyBackAmount);\n    }\n\n    /**\n     * @notice Exits a short using shorter's ERC in balance (ErcEscrowed)\n     * @dev allows for partial exit via buyBackAmount\n     *\n     * @param asset The market that will be impacted\n     * @param id Id of short\n     * @param buyBackAmount Erc amount to buy back\n     *\n     */\n\n    function exitShortErcEscrowed(address asset, uint8 id, uint88 buyBackAmount)\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, msg.sender, id)\n    {\n        STypes.Asset storage Asset = s.asset[asset];\n\n        STypes.ShortRecord storage short = s.shortRecords[asset][msg.sender][id];\n\n        short.updateErcDebt(asset);\n        uint256 ercDebt = short.ercDebt;\n        if (buyBackAmount == 0 || buyBackAmount > ercDebt) revert Errors.InvalidBuyback();\n\n        STypes.AssetUser storage AssetUser = s.assetUser[asset][msg.sender];\n        if (AssetUser.ercEscrowed < buyBackAmount) {\n            revert Errors.InsufficientERCEscrowed();\n        }\n\n        if (ercDebt > buyBackAmount) {\n            uint256 leftoverAmt = (ercDebt - buyBackAmount).mul(LibOracle.getPrice(asset));\n            if (leftoverAmt < LibAsset.minBidEth(asset)) {\n                revert Errors.CannotLeaveDustAmount();\n            }\n        }\n\n        AssetUser.ercEscrowed -= buyBackAmount;\n        Asset.ercDebt -= buyBackAmount;\n        // refund the rest of the collateral if ercDebt is fully paid back\n        if (ercDebt == buyBackAmount) {\n            uint88 collateral = short.collateral;\n            s.vaultUser[Asset.vault][msg.sender].ethEscrowed += collateral;\n            LibShortRecord.disburseCollateral(\n                asset, msg.sender, collateral, short.zethYieldRate, short.updatedAt\n            );\n            LibShortRecord.deleteShortRecord(asset, msg.sender, id);\n        } else {\n            short.ercDebt -= buyBackAmount;\n            short.maybeResetFlag(asset);\n        }\n        emit Events.ExitShortErcEscrowed(asset, msg.sender, id, buyBackAmount);\n    }\n\n    /**\n     * @notice Exits a short by placing bid on market\n     * @dev allows for partial exit via buyBackAmount\n     *\n     * @param asset The market that will be impacted\n     * @param id Id of short\n     * @param buyBackAmount Erc amount to buy back\n     * @param price Price at which shorter wants to place bid\n     * @param shortHintArray Array of hintId for the id to start matching against shorts since you can't match a short < oracle price\n     *\n     */\n\n    function exitShort(\n        address asset,\n        uint8 id,\n        uint88 buyBackAmount,\n        uint80 price,\n        uint16[] memory shortHintArray\n    )\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, msg.sender, id)\n    {\n        MTypes.ExitShort memory e;\n        e.asset = asset;\n        LibOrders.updateOracleAndStartingShortViaTimeBidOnly(\n            e.asset, OF.FifteenMinutes, shortHintArray\n        );\n\n        STypes.Asset storage Asset = s.asset[e.asset];\n        STypes.ShortRecord storage short = s.shortRecords[e.asset][msg.sender][id];\n\n        short.updateErcDebt(e.asset);\n\n        e.beforeExitCR = short.getCollateralRatio(e.asset);\n        e.ercDebt = short.ercDebt;\n        e.collateral = short.collateral;\n\n        if (buyBackAmount == 0 || buyBackAmount > e.ercDebt) {\n            revert Errors.InvalidBuyback();\n        }\n        if (e.ercDebt > buyBackAmount) {\n            uint256 leftoverAmt = (e.ercDebt - buyBackAmount).mul(price);\n            if (leftoverAmt < LibAsset.minBidEth(e.asset)) {\n                revert Errors.CannotLeaveDustAmount();\n            }\n        }\n\n        {\n            uint256 ethAmount = price.mul(buyBackAmount);\n            if (ethAmount > e.collateral) revert Errors.InsufficientCollateral();\n        }\n\n        {\n            uint16 lowestAskKey = s.asks[e.asset][Constants.HEAD].nextId;\n            uint16 startingShortId = s.asset[e.asset].startingShortId;\n\n            if (\n                (\n                    lowestAskKey == Constants.TAIL\n                        || s.asks[e.asset][lowestAskKey].price > price\n                )\n                    && (\n                        startingShortId == Constants.HEAD\n                            || s.shorts[e.asset][startingShortId].price > price\n                    )\n            ) {\n                revert Errors.ExitShortPriceTooLow();\n            }\n        }\n\n        // Temporary accounting to enable bid\n        STypes.VaultUser storage VaultUser = s.vaultUser[Asset.vault][msg.sender];\n        VaultUser.ethEscrowed += e.collateral;\n\n        // Create bid with current msg.sender\n        (e.ethFilled, e.ercAmountLeft) = IDiamond(payable(address(this))).createForcedBid(\n            msg.sender, e.asset, price, buyBackAmount, shortHintArray\n        );\n\n        e.ercFilled = buyBackAmount - e.ercAmountLeft;\n        Asset.ercDebt -= e.ercFilled;\n        s.assetUser[e.asset][msg.sender].ercEscrowed -= e.ercFilled;\n\n        // Refund the rest of the collateral if ercDebt is fully paid back\n        if (e.ercDebt == e.ercFilled) {\n            // Full Exit\n            LibShortRecord.disburseCollateral(\n                e.asset, msg.sender, e.collateral, short.zethYieldRate, short.updatedAt\n            );\n            LibShortRecord.deleteShortRecord(e.asset, msg.sender, id); // prevent re-entrancy\n        } else {\n            short.collateral -= e.ethFilled;\n            short.ercDebt -= e.ercFilled;\n\n            //@dev Only allow partial exit if the CR is same or better than before\n            if (short.getCollateralRatio(e.asset) < e.beforeExitCR) {\n                revert Errors.PostExitCRLtPreExitCR();\n            }\n\n            //@dev collateral already subtracted in exitShort()\n            VaultUser.ethEscrowed -= e.collateral - e.ethFilled;\n            LibShortRecord.disburseCollateral(\n                e.asset, msg.sender, e.ethFilled, short.zethYieldRate, short.updatedAt\n            );\n            short.maybeResetFlag(e.asset);\n        }\n        emit Events.ExitShort(asset, msg.sender, id, e.ercFilled);\n    }\n}"
    },
    {
      "filename": "contracts/facets/BidOrdersFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U88, U80} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {STypes, MTypes, O, SR, OF} from \"contracts/libraries/DataTypes.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract BidOrdersFacet is Modifiers {\n    using U256 for uint256;\n    using U88 for uint88;\n    using U80 for uint80;\n    using {LibOrders.isShort} for STypes.Order;\n\n    /**\n     * @notice Creates bid order in market\n     * @dev IncomingBid created here instead of BidMatchAlgo to prevent stack too deep\n     *\n     * @param asset The market that will be impacted\n     * @param price Unit price in eth for erc\n     * @param ercAmount Amount of erc to buy\n     * @param isMarketOrder Boolean for whether the bid is limit or market\n     * @param orderHintArray Array of hint ID for gas-optimized sorted placement on market\n     * @param shortHintArray Array of hint ID for gas-optimized short matching above oracle price\n     *\n     * @return ethFilled Amount of eth filled\n     * @return ercAmountLeft Amount of erc not matched\n     */\n\n    function createBid(\n        address asset,\n        uint80 price,\n        uint88 ercAmount,\n        bool isMarketOrder,\n        MTypes.OrderHint[] calldata orderHintArray,\n        uint16[] calldata shortHintArray\n    )\n        external\n        isNotFrozen(asset)\n        onlyValidAsset(asset)\n        nonReentrant\n        returns (uint88 ethFilled, uint88 ercAmountLeft)\n    {\n        // Update oracle and starting short if last updated more than 1 hour ago\n        LibOrders.updateOracleAndStartingShortViaTimeBidOnly(\n            asset, OF.OneHour, shortHintArray\n        );\n\n        return _createBid(\n            msg.sender,\n            asset,\n            price,\n            ercAmount,\n            isMarketOrder,\n            orderHintArray,\n            shortHintArray\n        );\n    }\n\n    /**\n     * @notice create a bid order for exiting a short, only callable by specific contracts\n     *\n     * @param sender Address of caller (only for exiting a short)\n     * @param asset The market that will be impacted\n     * @param price Unit price in eth for erc\n     * @param ercAmount Amount of erc to buy\n     * @param shortHintArray Array of hint ID for gas-optimized short matching above oracle price\n     *\n     * @return ethFilled Amount of eth filled\n     * @return ercAmountLeft Amount of erc not matched\n     */\n    function createForcedBid(\n        address sender,\n        address asset,\n        uint80 price,\n        uint88 ercAmount,\n        uint16[] calldata shortHintArray\n    ) external onlyDiamond returns (uint88 ethFilled, uint88 ercAmountLeft) {\n        //@dev leave empty, don't need hint for market buys\n        MTypes.OrderHint[] memory orderHintArray;\n\n        // @dev update oracle in callers\n        return _createBid(\n            sender,\n            asset,\n            price,\n            ercAmount,\n            Constants.MARKET_ORDER,\n            orderHintArray,\n            shortHintArray\n        );\n    }\n\n    function _createBid(\n        address sender,\n        address asset,\n        uint80 price,\n        uint88 ercAmount,\n        bool isMarketOrder,\n        MTypes.OrderHint[] memory orderHintArray,\n        uint16[] memory shortHintArray\n    ) private returns (uint88 ethFilled, uint88 ercAmountLeft) {\n        uint256 eth = ercAmount.mul(price);\n        if (eth < LibAsset.minBidEth(asset)) revert Errors.OrderUnderMinimumSize();\n\n        STypes.Asset storage Asset = s.asset[asset];\n        if (s.vaultUser[Asset.vault][sender].ethEscrowed < eth) {\n            revert Errors.InsufficientETHEscrowed();\n        }\n\n        STypes.Order memory incomingBid;\n        incomingBid.addr = sender;\n        incomingBid.price = price;\n        incomingBid.ercAmount = ercAmount;\n        incomingBid.id = Asset.orderId;\n        incomingBid.orderType = isMarketOrder ? O.MarketBid : O.LimitBid;\n        incomingBid.creationTime = LibOrders.getOffsetTime();\n\n        MTypes.BidMatchAlgo memory b;\n        b.oraclePrice = LibOracle.getPrice(asset);\n        b.askId = s.asks[asset][Constants.HEAD].nextId;\n        //@dev setting initial shortId to match \"backwards\" (See _shortDirectionHandler() below)\n        b.shortHintId = b.shortId = Asset.startingShortId;\n\n        emit Events.CreateBid(asset, sender, incomingBid.id, incomingBid.creationTime);\n\n        STypes.Order memory lowestSell = _getLowestSell(asset, b);\n        if (\n            incomingBid.price >= lowestSell.price\n                && (\n                    lowestSell.orderType == O.LimitAsk || lowestSell.orderType == O.LimitShort\n                )\n        ) {\n            //@dev if match and match price is gt .5% to saved oracle in either direction, update startingShortId\n            LibOrders.updateOracleAndStartingShortViaThreshold(\n                asset, b.oraclePrice, incomingBid, shortHintArray\n            );\n            b.shortHintId = b.shortId = Asset.startingShortId;\n            return bidMatchAlgo(asset, incomingBid, orderHintArray, b);\n        } else {\n            //@dev no match, add to market if limit order\n            LibOrders.addBid(asset, incomingBid, orderHintArray);\n            return (0, ercAmount);\n        }\n    }\n\n    /**\n     * @notice The matching algorithm for bids\n     *\n     * @param asset The market that will be impacted\n     * @param incomingBid Active bid order\n     * @param orderHintArray Array of hint ID for gas-optimized sorted placement on market\n     * @param b Memory struct used throughout bidMatchAlgo\n     *\n     * @return ethFilled Amount of eth filled\n     * @return ercAmountLeft Amount of erc not matched\n     */\n    function bidMatchAlgo(\n        address asset,\n        STypes.Order memory incomingBid,\n        MTypes.OrderHint[] memory orderHintArray,\n        MTypes.BidMatchAlgo memory b\n    ) private returns (uint88 ethFilled, uint88 ercAmountLeft) {\n        uint256 minBidEth = LibAsset.minBidEth(asset);\n        MTypes.Match memory matchTotal;\n\n        while (true) {\n            //@dev Handles scenario when no sells left after partial fill\n            if (b.askId == Constants.TAIL && b.shortId == Constants.TAIL) {\n                if (incomingBid.ercAmount.mul(incomingBid.price) >= minBidEth) {\n                    LibOrders.addBid(asset, incomingBid, orderHintArray);\n                }\n                return matchIncomingBid(asset, incomingBid, matchTotal, b);\n            }\n\n            STypes.Order memory lowestSell = _getLowestSell(asset, b);\n\n            if (incomingBid.price >= lowestSell.price) {\n                // Consider bid filled if only dust amount left\n                if (incomingBid.ercAmount.mul(lowestSell.price) == 0) {\n                    return matchIncomingBid(asset, incomingBid, matchTotal, b);\n                }\n                matchlowestSell(asset, lowestSell, incomingBid, matchTotal);\n                if (incomingBid.ercAmount > lowestSell.ercAmount) {\n                    incomingBid.ercAmount -= lowestSell.ercAmount;\n                    lowestSell.ercAmount = 0;\n                    if (lowestSell.isShort()) {\n                        b.matchedShortId = lowestSell.id;\n                        b.prevShortId = lowestSell.prevId;\n                        LibOrders.matchOrder(s.shorts, asset, lowestSell.id);\n                        _shortDirectionHandler(asset, lowestSell, incomingBid, b);\n                    } else {\n                        b.matchedAskId = lowestSell.id;\n                        LibOrders.matchOrder(s.asks, asset, lowestSell.id);\n                        b.askId = lowestSell.nextId;\n                    }\n                } else {\n                    // If the product of remaining ercAmount and price rounds down to 0 just close the sell order\n                    bool dustErcAmount = (lowestSell.ercAmount - incomingBid.ercAmount)\n                        .mul(lowestSell.price) == 0;\n\n                    if (dustErcAmount || incomingBid.ercAmount == lowestSell.ercAmount) {\n                        if (lowestSell.isShort()) {\n                            b.matchedShortId = lowestSell.id;\n                            b.prevShortId = lowestSell.prevId;\n                            LibOrders.matchOrder(s.shorts, asset, lowestSell.id);\n                        } else {\n                            b.matchedAskId = lowestSell.id;\n                            LibOrders.matchOrder(s.asks, asset, lowestSell.id);\n                        }\n                    } else {\n                        if (lowestSell.isShort()) {\n                            STypes.Order storage lowestShort =\n                                s.shorts[asset][lowestSell.id];\n                            lowestShort.ercAmount =\n                                lowestSell.ercAmount - incomingBid.ercAmount;\n                            lowestShort.shortRecordId = lowestSell.shortRecordId;\n                        } else {\n                            s.asks[asset][lowestSell.id].ercAmount =\n                                lowestSell.ercAmount - incomingBid.ercAmount;\n                        }\n                    }\n                    lowestSell.ercAmount -= incomingBid.ercAmount;\n                    incomingBid.ercAmount = 0;\n                    return matchIncomingBid(asset, incomingBid, matchTotal, b);\n                }\n            } else {\n                if (incomingBid.ercAmount.mul(incomingBid.price) >= minBidEth) {\n                    LibOrders.addBid(asset, incomingBid, orderHintArray);\n                }\n                return matchIncomingBid(asset, incomingBid, matchTotal, b);\n            }\n        }\n    }\n    /**\n     * @notice Settles lowest ask and updates incoming bid\n     * @dev DittoMatchedShares only assigned for asks sitting > 2 weeks of seconds\n     *\n     * @param asset The market that will be impacted\n     * @param lowestSell Lowest sell order (ask or short) on market\n     * @param incomingBid Active bid order\n     * @param matchTotal Struct of the running matched totals\n     */\n\n    function matchlowestSell(\n        address asset,\n        STypes.Order memory lowestSell,\n        STypes.Order memory incomingBid,\n        MTypes.Match memory matchTotal\n    ) private {\n        uint88 fillErc = incomingBid.ercAmount > lowestSell.ercAmount\n            ? lowestSell.ercAmount\n            : incomingBid.ercAmount;\n        uint88 fillEth = lowestSell.price.mulU88(fillErc);\n\n        if (lowestSell.orderType == O.LimitShort) {\n            // Match short\n            uint88 colUsed = fillEth.mulU88(LibOrders.convertCR(lowestSell.initialMargin));\n            LibOrders.increaseSharesOnMatch(asset, lowestSell, matchTotal, colUsed);\n            uint88 shortFillEth = fillEth + colUsed;\n            matchTotal.shortFillEth += shortFillEth;\n            // Saves gas when multiple shorts are matched\n            if (!matchTotal.ratesQueried) {\n                STypes.Asset storage Asset = s.asset[asset];\n                matchTotal.ratesQueried = true;\n                matchTotal.ercDebtRate = Asset.ercDebtRate;\n                matchTotal.zethYieldRate = s.vault[Asset.vault].zethYieldRate;\n            }\n            // Default enum is PartialFill\n            SR status;\n            if (incomingBid.ercAmount >= lowestSell.ercAmount) {\n                status = SR.FullyFilled;\n            }\n            if (lowestSell.shortRecordId > 0) {\n                // shortRecord has been partially filled before\n                LibShortRecord.fillShortRecord(\n                    asset,\n                    lowestSell.addr,\n                    lowestSell.shortRecordId,\n                    status,\n                    shortFillEth,\n                    fillErc,\n                    matchTotal.ercDebtRate,\n                    matchTotal.zethYieldRate\n                );\n            } else {\n                // shortRecord newly created\n                lowestSell.shortRecordId = LibShortRecord.createShortRecord(\n                    asset,\n                    lowestSell.addr,\n                    status,\n                    shortFillEth,\n                    fillErc,\n                    matchTotal.ercDebtRate,\n                    matchTotal.zethYieldRate,\n                    0\n                );\n            }\n        } else {\n            // Match ask\n            s.vaultUser[s.asset[asset].vault][lowestSell.addr].ethEscrowed += fillEth;\n            matchTotal.askFillErc += fillErc;\n        }\n\n        matchTotal.fillErc += fillErc;\n        matchTotal.fillEth += fillEth;\n    }\n\n    /**\n     * @notice Final settlement of incoming bid\n     *\n     * @param asset The market that will be impacted\n     * @param incomingBid Active bid order\n     * @param matchTotal Struct of the running matched totals\n     * @param b Memory struct used throughout bidMatchAlgo\n     *\n     * @return ethFilled Amount of eth filled\n     * @return ercAmountLeft Amount of erc not matched\n     */\n\n    function matchIncomingBid(\n        address asset,\n        STypes.Order memory incomingBid,\n        MTypes.Match memory matchTotal,\n        MTypes.BidMatchAlgo memory b\n    ) private returns (uint88 ethFilled, uint88 ercAmountLeft) {\n        if (matchTotal.fillEth == 0) {\n            return (0, incomingBid.ercAmount);\n        }\n\n        STypes.Asset storage Asset = s.asset[asset];\n        uint256 vault = Asset.vault;\n\n        LibOrders.updateSellOrdersOnMatch(asset, b);\n\n        // If at least one short was matched\n        if (matchTotal.shortFillEth > 0) {\n            STypes.Vault storage Vault = s.vault[vault];\n\n            // Matched Shares\n            Vault.dittoMatchedShares += matchTotal.dittoMatchedShares;\n            // Yield Accounting\n            Vault.zethCollateral += matchTotal.shortFillEth;\n            Asset.zethCollateral += matchTotal.shortFillEth;\n            Asset.ercDebt += matchTotal.fillErc - matchTotal.askFillErc;\n\n            //@dev Approximates the startingShortId after bid is fully executed\n            O shortOrderType = s.shorts[asset][b.shortId].orderType;\n            O prevShortOrderType = s.shorts[asset][b.prevShortId].orderType;\n            uint80 prevShortPrice = s.shorts[asset][b.prevShortId].price;\n\n            if (shortOrderType != O.Cancelled && shortOrderType != O.Matched) {\n                Asset.startingShortId = b.shortId;\n            } else if (\n                prevShortOrderType != O.Cancelled && prevShortOrderType != O.Matched\n                    && prevShortPrice >= b.oraclePrice\n            ) {\n                Asset.startingShortId = b.prevShortId;\n            } else {\n                if (b.isMovingFwd) {\n                    Asset.startingShortId = s.shorts[asset][b.shortId].nextId;\n                } else {\n                    Asset.startingShortId = s.shorts[asset][b.shortHintId].nextId;\n                }\n            }\n        }\n\n        // Match bid\n        s.vaultUser[vault][incomingBid.addr].ethEscrowed -= matchTotal.fillEth;\n        s.assetUser[asset][incomingBid.addr].ercEscrowed += matchTotal.fillErc;\n        return (matchTotal.fillEth, incomingBid.ercAmount);\n    }\n\n    //@dev If neither conditions are true, it returns an empty Order struct\n    function _getLowestSell(address asset, MTypes.BidMatchAlgo memory b)\n        private\n        view\n        returns (STypes.Order memory lowestSell)\n    {\n        if (b.shortId != Constants.HEAD) {\n            //@dev Setting lowestSell after comparing short and ask prices\n            bool noAsks = b.askId == Constants.TAIL;\n            bool shortPriceLessThanAskPrice =\n                s.shorts[asset][b.shortId].price < s.asks[asset][b.askId].price;\n            if (noAsks || shortPriceLessThanAskPrice) {\n                lowestSell = s.shorts[asset][b.shortId];\n                return lowestSell;\n            } else {\n                return s.asks[asset][b.askId];\n            }\n        } else if (b.askId != Constants.TAIL) {\n            //@dev Handles scenario when there are no shorts\n            return s.asks[asset][b.askId];\n        }\n    }\n\n    function _shortDirectionHandler(\n        address asset,\n        STypes.Order memory lowestSell,\n        STypes.Order memory incomingBid,\n        MTypes.BidMatchAlgo memory b\n    ) private view {\n        /*\n        @dev: Table refers to how algo updates the shorts after execution. Refer to updateSellOrdersOnMatch()\n         +----------------+-------------------------+--------------------------+\n         |    Direction   |         First ID        |          Last ID         |\n         +----------------+-------------------------+--------------------------+\n         | Fwd only       | firstShortIdBelowOracle*| matchedShortId           |\n         | Back only      | prevShortId             |shortHintId**             |\n         | Back then fwd  | firstShortIdBelowOracle | shortId                  |\n         +----------------+-------------------------+--------------------------+\n        \n        * firstShortIdBelowOracle directly PRECEDES the first short Id that can be matched.\n        firstShortIdBelowOracle cannot itself be matched since it is below oracle price\n        \n        ** shortHintId will always be first Id matched if valid (within 1% of oracle)\n        As such, it will be used as the last Id matched (if moving backwards ONLY)\n\n        Example:\n        BEFORE: HEAD <-> (ID1)* <-> (ID2) <-> (ID3) <-> (ID4) <-> [ID5] <-> (ID6) <-> NEXT\n\n        Assume (ID1) is under the oracle price, therefore (ID2) is technically first eligible short that can be matched\n        Imagine the user passes in [ID5] as the hint, which corresponds to a price within 1% of the oracle, thus making it valid\n        If the bid matches BACKWARDS ONLY, lets say to (ID2), then the linked list will look like this after execution\n\n        AFTER: HEAD <-> (ID1)* <-> (ID6) <-> NEXT\n        \n        Here, (ID1) becomes the \"First ID\" and the shortHint ID [ID5] was the \"LastID\"\n        */\n\n        if (s.shorts[asset][b.prevShortId].price >= b.oraclePrice && !b.isMovingFwd) {\n            //@dev shortHintId should always be the first thing matched\n            b.isMovingBack = true;\n            b.shortId = b.prevShortId;\n        } else if (s.shorts[asset][b.prevShortId].price < b.oraclePrice && !b.isMovingFwd)\n        {\n            b.firstShortIdBelowOracle = b.prevShortId;\n            b.shortId = s.shorts[asset][b.shortHintId].nextId;\n\n            STypes.Order storage nextShort = s.shorts[asset][lowestSell.nextId];\n            //@dev Only set to true if actually moving forward\n            if (b.shortId != Constants.HEAD && nextShort.price <= incomingBid.price) {\n                b.isMovingFwd = true;\n            }\n        } else if (b.isMovingFwd) {\n            b.shortId = lowestSell.nextId;\n        }\n    }\n}"
    },
    {
      "filename": "contracts/facets/ExitShortFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U80, U88} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {IDiamond} from \"interfaces/IDiamond.sol\";\n\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {STypes, MTypes, OF} from \"contracts/libraries/DataTypes.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract ExitShortFacet is Modifiers {\n    using U256 for uint256;\n    using U80 for uint80;\n    using U88 for uint88;\n    using LibShortRecord for STypes.ShortRecord;\n    using {LibAsset.burnMsgSenderDebt} for address;\n\n    address private immutable cusd;\n\n    constructor(address _cusd) {\n        cusd = _cusd;\n    }\n\n    /**\n     * @notice Exits a short using shorter's ERC in wallet (i.e.MetaMask)\n     * @dev allows for partial exit via buyBackAmount\n     *\n     * @param asset The market that will be impacted\n     * @param id Id of short\n     * @param buyBackAmount Erc amount to buy back\n     *\n     */\n\n    function exitShortWallet(address asset, uint8 id, uint88 buyBackAmount)\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, msg.sender, id)\n    {\n        STypes.ShortRecord storage short = s.shortRecords[asset][msg.sender][id];\n\n        short.updateErcDebt(asset);\n        uint256 ercDebt = short.ercDebt;\n        if (buyBackAmount > ercDebt || buyBackAmount == 0) revert Errors.InvalidBuyback();\n\n        if (ercDebt > buyBackAmount) {\n            uint256 leftoverAmt = (ercDebt - buyBackAmount).mul(LibOracle.getPrice(asset));\n            if (leftoverAmt < LibAsset.minBidEth(asset)) {\n                revert Errors.CannotLeaveDustAmount();\n            }\n        }\n\n        asset.burnMsgSenderDebt(buyBackAmount);\n        s.asset[asset].ercDebt -= buyBackAmount;\n        // refund the rest of the collateral if ercDebt is fully paid back\n        if (buyBackAmount == ercDebt) {\n            uint256 vault = s.asset[asset].vault;\n            uint88 collateral = short.collateral;\n            s.vaultUser[vault][msg.sender].ethEscrowed += collateral;\n            LibShortRecord.disburseCollateral(\n                asset, msg.sender, collateral, short.zethYieldRate, short.updatedAt\n            );\n            LibShortRecord.deleteShortRecord(asset, msg.sender, id);\n        } else {\n            short.ercDebt -= buyBackAmount;\n            short.maybeResetFlag(asset);\n        }\n        emit Events.ExitShortWallet(asset, msg.sender, id, buyBackAmount);\n    }\n\n    /**\n     * @notice Exits a short using shorter's ERC in balance (ErcEscrowed)\n     * @dev allows for partial exit via buyBackAmount\n     *\n     * @param asset The market that will be impacted\n     * @param id Id of short\n     * @param buyBackAmount Erc amount to buy back\n     *\n     */\n\n    function exitShortErcEscrowed(address asset, uint8 id, uint88 buyBackAmount)\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, msg.sender, id)\n    {\n        STypes.Asset storage Asset = s.asset[asset];\n\n        STypes.ShortRecord storage short = s.shortRecords[asset][msg.sender][id];\n\n        short.updateErcDebt(asset);\n        uint256 ercDebt = short.ercDebt;\n        if (buyBackAmount == 0 || buyBackAmount > ercDebt) revert Errors.InvalidBuyback();\n\n        STypes.AssetUser storage AssetUser = s.assetUser[asset][msg.sender];\n        if (AssetUser.ercEscrowed < buyBackAmount) {\n            revert Errors.InsufficientERCEscrowed();\n        }\n\n        if (ercDebt > buyBackAmount) {\n            uint256 leftoverAmt = (ercDebt - buyBackAmount).mul(LibOracle.getPrice(asset));\n            if (leftoverAmt < LibAsset.minBidEth(asset)) {\n                revert Errors.CannotLeaveDustAmount();\n            }\n        }\n\n        AssetUser.ercEscrowed -= buyBackAmount;\n        Asset.ercDebt -= buyBackAmount;\n        // refund the rest of the collateral if ercDebt is fully paid back\n        if (ercDebt == buyBackAmount) {\n            uint88 collate"
    }
  ]
}