{
  "Title": "[L-08] No Storage Gap for ` BaseSmartAccount ` and `ModuleManager `",
  "Content": "\n[BaseSmartAccount.sol#L33](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol#L33)<br>\n[ModuleManager.sol#L9](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol#L9)\n\n### Impact\nFor upgradeable contracts, inheriting contracts may introduce new variables. In order to be able to add new variables to the upgradeable contract without causing storage collisions, a storage gap should be added to the upgradeable contract.\n\nIf no storage gap is added, when the upgradable contract introduces new variables, it may override the variables in the inheriting contract.\n\nStorage gaps are a convention for reserving storage slots in a base contract, allowing future versions of that contract to use up those slots without affecting the storage layout of child contracts.<br>\nTo create a storage gap, declare a fixed-size array in the base contract with an initial number of slots.<br>\nThis can be an array of uint256 so that each element reserves a 32 byte slot. Use the naming convention `__gap` so that OpenZeppelin Upgrades will recognize the gap:\n\nClassification for a similar problem:<br>\nhttps://code4rena.com/reports/2022-05-alchemix/#m-05-no-storage-gap-for-upgradeable-contract-might-lead-to-storage-slot-collision\n\n```js\ncontract Base {\n    uint256 base1;\n    uint256[49] __gap;\n}\n\ncontract Child is Base {\n    uint256 child;\n}\n```\n\nOpenzeppelin Storage Gaps notification:\n```js\nStorage Gaps\nThis makes the storage layouts incompatible, as explained in Writing Upgradeable Contracts. \nThe size of the __gap array is calculated so that the amount of storage used by a contract \nalways adds up to the same number (in this case 50 storage slots).\n```\n\n### Recommended Mitigation Steps\nConsider adding a storage gap at the end of the upgradeable abstract contract\n```js\nuint256[50] private __gap;\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2023-01-biconomy-smart-contract-wallet-contest",
  "Code": [
    {
      "filename": "scw-contracts/contracts/smart-contract-wallet/BaseSmartAccount.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.12;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable reason-string */\n\nimport \"@account-abstraction/contracts/interfaces/IAccount.sol\";\nimport \"@account-abstraction/contracts/interfaces/IEntryPoint.sol\";\nimport \"./common/Enum.sol\";\n\nstruct Transaction {\n        address to;\n        uint256 value;\n        bytes data;\n        Enum.Operation operation;\n        uint256 targetTxGas;\n    }\n\nstruct FeeRefund {\n        uint256 baseGas;\n        uint256 gasPrice; //gasPrice or tokenGasPrice\n        uint256 tokenGasPriceFactor;\n        address gasToken;\n        address payable refundReceiver;\n    }\n\n/**\n * Basic account implementation.\n * this contract provides the basic logic for implementing the IAccount interface  - validateUserOp\n * specific account implementation should inherit it and provide the account-specific logic\n */\nabstract contract BaseSmartAccount is IAccount {\n    using UserOperationLib for UserOperation;\n\n\n    /**\n     * return the account nonce.\n     * subclass should return a nonce value that is used both by _validateAndUpdateNonce, and by the external provider (to read the current nonce)\n     */\n    function nonce() public view virtual returns (uint256);\n\n     /**\n     * return the account nonce.\n     * subclass should return a nonce value that is used both by _validateAndUpdateNonce, and by the external provider (to read the current nonce)\n     */\n    function nonce(uint256 _batchId) public view virtual returns (uint256);\n\n    /**\n     * return the entryPoint used by this account.\n     * subclass should return the current entryPoint used by this account.\n     */\n    function entryPoint() public view virtual returns (IEntryPoint);\n\n    /**\n     * Validate user's signature and nonce.\n     * subclass doesn't need to override this method. Instead, it should override the specific internal validation methods.\n     */\n    // review virtual \n    function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash, address aggregator, uint256 missingAccountFunds)\n    external override virtual returns (uint256 deadline) {\n        _requireFromEntryPoint();\n        deadline = _validateSignature(userOp, userOpHash, aggregator);\n        if (userOp.initCode.length == 0) {\n            _validateAndUpdateNonce(userOp);\n        }\n        _payPrefund(missingAccountFunds);\n    }\n\n    /**\n     * ensure the request comes from the known entrypoint.\n     */\n    function _requireFromEntryPoint() internal virtual view {\n        require(msg.sender == address(entryPoint()), \"account: not from EntryPoint\");\n    }\n\n    /**\n     * validate the signature is valid for this message.\n     * @param userOp validate the userOp.signature field\n     * @param userOpHash convenient field: the hash of the request, to check the signature against\n     *          (also hashes the entrypoint and chain-id)\n     * @param aggregator the current aggregator. can be ignored by accounts that don't use aggregators\n     * @return deadline the last block timestamp this operation is valid, or zero if it is valid indefinitely.\n     *      Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    // Review if we need to make view function\n    function _validateSignature(UserOperation calldata userOp, bytes32 userOpHash, address aggregator)\n    internal virtual returns (uint256 deadline);\n\n    /**\n     * validate the current nonce matches the UserOperation nonce.\n     * then it should update the account's state to prevent replay of this UserOperation.\n     * called only if initCode is empty (since \"nonce\" field is used as \"salt\" on account creation)\n     * @param userOp the op to validate.\n     */\n    function _validateAndUpdateNonce(UserOperation calldata userOp) internal virtual;\n\n    /**\n     * sends to the entrypoint (msg.sender) the missing funds for this transaction.\n     * subclass MAY override this method for better funds management\n     * (e.g. send to the entryPoint more than the minimum required, so that in future transactions\n     * it will not be required to send again)\n     * @param missingAccountFunds the minimum value this method should send the entrypoint.\n     *  this value MAY be zero, in case there is enough deposit, or the userOp has a paymaster.\n     */\n    function _payPrefund(uint256 missingAccountFunds) internal virtual {\n        if (missingAccountFunds != 0) {\n            (bool success,) = payable(msg.sender).call{value : missingAccountFunds, gas : type(uint256).max}(\"\");\n            (success);\n            //ignore failure (its EntryPoint's job to verify, not account.)\n        }\n    }\n    \n    function init(address _owner, address _entryPointAddress, address _handler) external virtual;\n\n    function execTransaction(\n        Transaction memory _tx,\n        uint256 batchId,\n        FeeRefund memory refundInfo,\n        bytes memory signatures) public payable virtual returns (bool success);\n}"
    },
    {
      "filename": "scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol",
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.12;\n\nimport \"../common/Enum.sol\";\nimport \"../common/SelfAuthorized.sol\";\nimport \"./Executor.sol\";\n\n/// @title Module Manager - A contract that manages modules that can execute transactions via this contract\ncontract ModuleManager is SelfAuthorized, Executor {    \n    // Events\n    event EnabledModule(address module);\n    event DisabledModule(address module);\n    event ExecutionFromModuleSuccess(address indexed module);\n    event ExecutionFromModuleFailure(address indexed module);\n\n    address internal constant SENTINEL_MODULES = address(0x1);\n\n    mapping(address => address) internal modules;\n\n    function setupModules(address to, bytes memory data) internal {\n        require(modules[SENTINEL_MODULES] == address(0), \"BSA100\");\n        modules[SENTINEL_MODULES] = SENTINEL_MODULES;\n        if (to != address(0))\n            // Setup has to complete successfully or transaction fails.\n            require(execute(to, 0, data, Enum.Operation.DelegateCall, gasleft()), \"BSA000\");\n    }\n\n    /// @dev Allows to add a module to the whitelist.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Enables the module `module` for the Safe.\n    /// @param module Module to be whitelisted.\n    function enableModule(address module) public authorized {\n        // Module address cannot be null or sentinel.\n        require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\");\n        // Module cannot be added twice.\n        require(modules[module] == address(0), \"BSA102\");\n        modules[module] = modules[SENTINEL_MODULES];\n        modules[SENTINEL_MODULES] = module;\n        emit EnabledModule(module);\n    }\n\n    /// @dev Allows to remove a module from the whitelist.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Disables the module `module` for the Safe.\n    /// @param prevModule Module that pointed to the module to be removed in the linked list\n    /// @param module Module to be removed.\n    function disableModule(address prevModule, address module) public authorized {\n        // Validate module address and check that it corresponds to module index.\n        require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\");\n        require(modules[prevModule] == module, \"BSA103\");\n        modules[prevModule] = modules[module];\n        modules[module] = address(0);\n        emit DisabledModule(module);\n    }\n\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) public virtual returns (bool success) {\n        // Only whitelisted modules are allowed.\n        require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"BSA104\");\n        // Execute transaction without further confirmations.\n        success = execute(to, value, data, operation, gasleft());\n        if (success) emit ExecutionFromModuleSuccess(msg.sender);\n        else emit ExecutionFromModuleFailure(msg.sender);\n    }\n\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations and return data\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModuleReturnData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) public returns (bool success, bytes memory returnData) {\n        success = execTransactionFromModule(to, value, data, operation);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Load free memory location\n            let ptr := mload(0x40)\n            // We allocate memory for the return data by setting the free memory location to\n            // current free memory location + data size + 32 bytes for data size value\n            mstore(0x40, add(ptr, add(returndatasize(), 0x20)))\n            // Store the size\n            mstore(ptr, returndatasize())\n            // Store the data\n            returndatacopy(add(ptr, 0x20), 0, returndatasize())\n            // Point the return data to the correct memory location\n            returnData := ptr\n        }\n    }\n\n    /// @dev Returns if an module is enabled\n    /// @return True if the module is enabled\n    function isModuleEnabled(address module) public view returns (bool) {\n        return SENTINEL_MODULES != module && modules[module] != address(0);\n    }\n\n    /// @dev Returns array of modules. Useful for a widget\n    /// @param start Start of the page.\n    /// @param pageSize Maximum number of modules that should be returned.\n    /// @return array Array of modules.\n    /// @return next Start of the next page.\n    function getModulesPaginated(address start, uint256 pageSize) external view returns (address[] memory array, address next) {\n        // Init array with max page size\n        array = new address[](pageSize);\n\n        // Populate return array\n        uint256 moduleCount = 0;\n        address currentModule = modules[start];\n        while (currentModule != address(0x0) && currentModule != SENTINEL_MODULES && moduleCount < pageSize) {\n            array[moduleCount] = currentModule;\n            currentModule = modules[currentModule];\n            moduleCount++;\n        }\n        next = currentModule;\n        // Set correct size of returned array\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(array, moduleCount)\n        }\n    }\n}"
    }
  ]
}