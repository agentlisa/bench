{
  "Title": "[M-14] The royaltyRecipient could not be prepare to receive ether, making the sell to fail",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/EthRouter.sol#L188-L191\n\n\n# Vulnerability details\n\n## Impact\nThe `royaltyRecipient` is an arbitrary address setup by the collection if the collection `royaltyRecipient` is a contract and this contract its not prepared to receive ether the ether transfer will always fail paying the royalties.\n\n\n\n## Proof of Concept\nHere is a foundry POC, take note that i have to write a new Milady mock collection because in the original is hardcoded to `0xbeefbeef` so its impossible to change the `royaltyRecipient`;  [Milady.sol#L31](https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/test/shared/Milady.sol#L31)\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"test/Fixture.sol\";\n\ncontract POCRejectTest is Fixture {\n    PrivatePool public privatePool;\n    uint256 public totalTokens = 0;\n    uint256 public minOutputAmount = 0;\n\n    uint256 royaltyFeeRate = 0.1e18; // 10%\n    address royaltyRecipient = address(new EthRejecter());\n\n    Milady2 milady2 = new Milady2();\n\n    function setUp() public {\n        milady2.setApprovalForAll(address(ethRouter), true);\n\n        vm.mockCall(\n            address(milady2),\n            abi.encodeWithSelector(ERC721.ownerOf.selector, address(privatePool)),\n            abi.encode(address(this))\n        );\n\n        // lets setup a trap for the royalty        \n        milady2.setRoyaltyInfo(royaltyFeeRate, royaltyRecipient);\n\n    }\n\n    function _addSell() internal returns (EthRouter.Sell memory, uint256) {\n        uint256[] memory empty = new uint256[](0);\n        privatePool = factory.create{value: 100e18}(\n            address(0),\n            address(milady2),\n            100e18,\n            10e18,\n            200,\n            199,\n            bytes32(0),\n            true,\n            false,\n            bytes32(address(this).balance), // random between each call to _addBuy\n            empty,\n            100e18\n        );\n\n        uint256[] memory tokenIds = new uint256[](2);\n        for (uint256 i = 0; i < 2; i++) {\n            milady2.mint(address(this), i + totalTokens);\n            tokenIds[i] = i + totalTokens;\n        }\n\n        totalTokens += 2;\n\n        bytes32[][] memory publicPoolProofs = new bytes32[][](0);\n        EthRouter.Sell memory sell = EthRouter.Sell({\n            pool: payable(address(privatePool)),\n            nft: address(milady2),\n            tokenIds: tokenIds,\n            tokenWeights: new uint256[](0),\n            proof: PrivatePool.MerkleMultiProof(new bytes32[](0), new bool[](0)),\n            stolenNftProofs: new IStolenNftOracle.Message[](0),\n            isPublicPool: false,\n            publicPoolProofs: publicPoolProofs\n        });\n\n        (uint256 baseTokenAmount,,) = privatePool.sellQuote(tokenIds.length * 1e18);\n        return (sell, baseTokenAmount);\n    }\n\n    function test_PaysRoyalties() public {\n        // arrange\n        EthRouter.Sell[] memory sells = new EthRouter.Sell[](3);\n        (EthRouter.Sell memory sell1, uint256 outputAmount1) = _addSell();\n        (EthRouter.Sell memory sell2, uint256 outputAmount2) = _addSell();\n        minOutputAmount += outputAmount1 + outputAmount2;\n        sells[0] = sell1;\n        sells[1] = sell2;\n        Pair pair = caviar.create(address(milady2), address(0), bytes32(0));\n        deal(address(pair), 1.123e18);\n        deal(address(pair), address(pair), 10e18);\n\n        uint256[] memory tokenIds = new uint256[](2);\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            tokenIds[i] = i + totalTokens;\n            milady2.mint(address(this), i + totalTokens);\n        }\n        sells[2] = EthRouter.Sell({\n            pool: payable(address(pair)),\n            nft: address(milady2),\n            tokenIds: tokenIds,\n            tokenWeights: new uint256[](0),\n            proof: PrivatePool.MerkleMultiProof(new bytes32[](0), new bool[](0)),\n            stolenNftProofs: new IStolenNftOracle.Message[](0),\n            isPublicPool: true,\n            publicPoolProofs: new bytes32[][](0)\n        });\n\n        uint256 outputAmount = pair.sellQuote(tokenIds.length * 1e18);\n\n        uint256 royaltyFee = outputAmount / tokenIds.length * royaltyFeeRate / 1e18 * tokenIds.length;\n        outputAmount -= royaltyFee;\n        minOutputAmount += outputAmount;\n\n        // act\n        ethRouter.sell(sells, minOutputAmount, 0, true);\n\n        // assert\n        assertEq(address(royaltyRecipient).balance, royaltyFee, \"Should have paid royalties\");\n        assertGt(address(royaltyRecipient).balance, 0, \"Should have paid royalties\");\n    }\n}\n\ncontract EthRejecter {\n    // The contract could not have a method called \"receive\" or \"fallback\", i added here\n    // to show the concept of a contract that rejects ETH\n    receive() external payable {\n        revert(\"ETH REJECTED EXAMPLE\");\n    }\n}\n\ncontract Milady2 is ERC721, ERC2981 {\n    uint256 public royaltyFeeRate = 0; // to 18 decimals\n    address public royaltyRecipient = address(0);\n\n    constructor() ERC721(\"Milady Maker\", \"MIL\") {}\n\n    function tokenURI(uint256) public view virtual override returns (string memory) {\n        return \"https://milady.io\";\n    }\n\n    function mint(address to, uint256 id) public {\n        _mint(to, id);\n    }\n\n    function setRoyaltyInfo(uint256 _royaltyFeeRate, address _royaltyRecipient) public {\n        royaltyFeeRate = _royaltyFeeRate;\n        royaltyRecipient = _royaltyRecipient;\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC2981, ERC721) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function royaltyInfo(uint256, uint256 salePrice) public view override returns (address, uint256) {\n        return (royaltyRecipient, salePrice * royaltyFeeRate / 1e18);\n    }\n}\n\n```\n\n\n## Tools Used\nManual revision\n\n\n## Recommended Mitigation Steps\n\nThere are two simple ways from my point of view to force ether send and solve this issue;\n\nYou could use a simple contract that selfdestrcut an firce ether, but selfdestruct is deprecated so its not a good idea, please view [solady/SafeTransferLib.sol#L65](https://github.com/Vectorized/solady/blob/main/src/utils/SafeTransferLib.sol#L65)\n\nThe other think you could do is if a address is rejecting ether, send WETH instead, this pattern is common and well known.",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-04-caviar-private-pools",
  "Code": [
    {
      "filename": "src/EthRouter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/*\n *                                     _H_\n *                                    /___\\\n *                                    \\888/\n * ~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~U~^~^~^~^~^~^~^\n *                       ~              |\n *       ~                        o     |        ~\n *                 ___        o         |\n *        _,.--,.'`   `~'-.._    O      |\n *       /_  .-\"      _   /_\\'.         |   ~\n *      .-';'       (( `  \\0/  `\\       #\n *     /__;          ((_  ,_     |  ,   #\n *     .-;                  \\_   /  #  _#,\n *    /  ;    .-' /  _.--\"\"-.\\`~`   `#(('\\\\        ~\n *    ;-';   /   / .'                  )) \\\\\n *        ; /.--'.'                   ((   ))\n *         \\     |        ~            \\\\ ((\n *          \\    |                      )) `\n *    ~      \\   |                      `\n *            \\  |\n *            .` `\"\"-.\n *          .'        \\         ~               ~\n *          |    |\\    |\n *          \\   /  '-._|\n *           \\.'\n */\n\nimport {ERC721, ERC721TokenReceiver} from \"solmate/tokens/ERC721.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {IERC2981} from \"openzeppelin/interfaces/IERC2981.sol\";\nimport {Pair, ReservoirOracle} from \"caviar/Pair.sol\";\nimport {IRoyaltyRegistry} from \"royalty-registry-solidity/IRoyaltyRegistry.sol\";\n\nimport {PrivatePool} from \"./PrivatePool.sol\";\nimport {IStolenNftOracle} from \"./interfaces/IStolenNftOracle.sol\";\n\n/// @title Eth Router\n/// @author out.eth (@outdoteth)\n/// @notice This contract is used to route buy, sell, and change orders to multiple pools in one transaction. It\n/// will route the orders to either a private pool or a public pool. If the order goes to a public pool, then users\n/// can choose whether or not they would like to pay royalties. The only base token which is supported is native ETH.\ncontract EthRouter is ERC721TokenReceiver {\n    using SafeTransferLib for address;\n\n    struct Buy {\n        address payable pool;\n        address nft;\n        uint256[] tokenIds;\n        uint256[] tokenWeights;\n        PrivatePool.MerkleMultiProof proof;\n        uint256 baseTokenAmount;\n        bool isPublicPool;\n    }\n\n    struct Sell {\n        address payable pool;\n        address nft;\n        uint256[] tokenIds;\n        uint256[] tokenWeights;\n        PrivatePool.MerkleMultiProof proof;\n        IStolenNftOracle.Message[] stolenNftProofs;\n        bool isPublicPool;\n        bytes32[][] publicPoolProofs;\n    }\n\n    struct Change {\n        address payable pool;\n        address nft;\n        uint256[] inputTokenIds;\n        uint256[] inputTokenWeights;\n        PrivatePool.MerkleMultiProof inputProof;\n        IStolenNftOracle.Message[] stolenNftProofs;\n        uint256[] outputTokenIds;\n        uint256[] outputTokenWeights;\n        PrivatePool.MerkleMultiProof outputProof;\n    }\n\n    error DeadlinePassed();\n    error OutputAmountTooSmall();\n    error PriceOutOfRange();\n    error InvalidRoyaltyFee();\n\n    address public immutable royaltyRegistry;\n\n    receive() external payable {}\n\n    constructor(address _royaltyRegistry) {\n        royaltyRegistry = _royaltyRegistry;\n    }\n\n    /// @notice Executes a series of buy operations against public or private pools.\n    /// @param buys The buy operations to execute.\n    /// @param deadline The deadline for the transaction to be mined. Will revert if timestamp is greater than deadline.\n    /// If it's set to 0 then there is no deadline.\n    /// @param payRoyalties Whether to pay royalties or not.\n    function buy(Buy[] calldata buys, uint256 deadline, bool payRoyalties) public payable {\n        // check that the deadline has not passed (if any)\n        if (block.timestamp > deadline && deadline != 0) {\n            revert DeadlinePassed();\n        }\n\n        // loop through and execute the the buys\n        for (uint256 i = 0; i < buys.length; i++) {\n            if (buys[i].isPublicPool) {\n                // execute the buy against a public pool\n                uint256 inputAmount = Pair(buys[i].pool).nftBuy{value: buys[i].baseTokenAmount}(\n                    buys[i].tokenIds, buys[i].baseTokenAmount, 0\n                );\n\n                // pay the royalties if buyer has opted-in\n                if (payRoyalties) {\n                    uint256 salePrice = inputAmount / buys[i].tokenIds.length;\n                    for (uint256 j = 0; j < buys[i].tokenIds.length; j++) {\n                        // get the royalty fee and recipient\n                        (uint256 royaltyFee, address royaltyRecipient) =\n                            getRoyalty(buys[i].nft, buys[i].tokenIds[j], salePrice);\n\n                        if (royaltyFee > 0) {\n                            // transfer the royalty fee to the royalty recipient\n                            royaltyRecipient.safeTransferETH(royaltyFee);\n                        }\n                    }\n                }\n            } else {\n                // execute the buy against a private pool\n                PrivatePool(buys[i].pool).buy{value: buys[i].baseTokenAmount}(\n                    buys[i].tokenIds, buys[i].tokenWeights, buys[i].proof\n                );\n            }\n\n            for (uint256 j = 0; j < buys[i].tokenIds.length; j++) {\n                // transfer the NFT to the caller\n                ERC721(buys[i].nft).safeTransferFrom(address(this), msg.sender, buys[i].tokenIds[j]);\n            }\n        }\n\n        // refund any surplus ETH to the caller\n        if (address(this).balance > 0) {\n            msg.sender.safeTransferETH(address(this).balance);\n        }\n    }\n\n    /// @notice Executes a series of sell operations against public or private pools.\n    /// @param sells The sell operations to execute.\n    /// @param minOutputAmount The minimum amount of output tokens that must be received for the transaction to succeed.\n    /// @param deadline The deadline for the transaction to be mined. Will revert if timestamp is greater than deadline.\n    /// Set to 0 for there to be no deadline.\n    /// @param payRoyalties Whether to pay royalties or not.\n    function sell(Sell[] calldata sells, uint256 minOutputAmount, uint256 deadline, bool payRoyalties) public {\n        // check that the deadline has not passed (if any)\n        if (block.timestamp > deadline && deadline != 0) {\n            revert DeadlinePassed();\n        }\n\n        // loop through and execute the sells\n        for (uint256 i = 0; i < sells.length; i++) {\n            // transfer the NFTs into the router from the caller\n            for (uint256 j = 0; j < sells[i].tokenIds.length; j++) {\n                ERC721(sells[i].nft).safeTransferFrom(msg.sender, address(this), sells[i].tokenIds[j]);\n            }\n\n            // approve the pair to transfer NFTs from the router\n            ERC721(sells[i].nft).setApprovalForAll(sells[i].pool, true);\n\n            if (sells[i].isPublicPool) {\n                // exceute the sell against a public pool\n                uint256 outputAmount = Pair(sells[i].pool).nftSell(\n                    sells[i].tokenIds,\n                    0,\n                    0,\n                    sells[i].publicPoolProofs,\n                    // ReservoirOracle.Message[] is the exact same as IStolenNftOracle.Message[] and can be\n                    // decoded/encoded 1-to-1.\n                    abi.decode(abi.encode(sells[i].stolenNftProofs), (ReservoirOracle.Message[]))\n                );\n\n                // pay the royalties if seller has opted-in\n                if (payRoyalties) {\n                    uint256 salePrice = outputAmount / sells[i].tokenIds.length;\n                    for (uint256 j = 0; j < sells[i].tokenIds.length; j++) {\n                        // get the royalty fee and recipient\n                        (uint256 royaltyFee, address royaltyRecipient) =\n                            getRoyalty(sells[i].nft, sells[i].tokenIds[j], salePrice);\n\n                        if (royaltyFee > 0) {\n                            // transfer the royalty fee to the royalty recipient\n                            royaltyRecipient.safeTransferETH(royaltyFee);\n                        }\n                    }\n                }\n            } else {\n                // execute the sell against a private pool\n                PrivatePool(sells[i].pool).sell(\n                    sells[i].tokenIds, sells[i].tokenWeights, sells[i].proof, sells[i].stolenNftProofs\n                );\n            }\n        }\n\n        // check that the output amount is greater than the minimum\n        if (address(this).balance < minOutputAmount) {\n            revert OutputAmountTooSmall();\n        }\n\n        // transfer the output amount to the caller\n        msg.sender.safeTransferETH(address(this).balance);\n    }\n\n    /// @notice Executes a deposit to a private pool (transfers NFTs and ETH to the pool).\n    /// @param privatePool The private pool to deposit to.\n    /// @param nft The NFT contract address.\n    /// @param tokenIds The token IDs of the NFTs to deposit.\n    /// @param minPrice The minimum price of the pool. Will revert if price is smaller than this.\n    /// @param maxPrice The maximum price of the pool. Will revert if price is greater than this.\n    /// @param deadline The deadline for the transaction to be mined. Will revert if timestamp is greater than deadline.\n    /// Set to 0 for deadline to be ignored.\n    function deposit(\n        address payable privatePool,\n        address nft,\n        uint256[] calldata tokenIds,\n        uint256 minPrice,\n        uint256 maxPrice,\n        uint256 deadline\n    ) public payable {\n        // check deadline has not passed (if any)\n        if (block.timestamp > deadline && deadline != 0) {\n            revert DeadlinePassed();\n        }\n\n        // check pool price is in between min and max\n        uint256 price = PrivatePool(privatePool).price();\n        if (price > maxPrice || price < minPrice) {\n            revert PriceOutOfRange();\n        }\n\n        // transfer NFTs from caller\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n        }\n\n        // approve pair to transfer NFTs from router\n        ERC721(nft).setApprovalForAll(privatePool, true);\n\n        // execute deposit\n        PrivatePool(privatePool).deposit{value: msg.value}(tokenIds, msg.value);\n    }\n\n    /// @notice Executes a series of change operations against a private pool.\n    /// @param changes The change operations to execute.\n    /// @param deadline The deadline for the transaction to be mined. Will revert if timestamp is greater than deadline.\n    /// Set to 0 for deadline to be ignored.\n    function change(Change[] calldata changes, uint256 deadline) public payable {\n        // check deadline has not passed (if any)\n        if (block.timestamp > deadline && deadline != 0) {\n            revert DeadlinePassed();\n        }\n\n        // loop through and execute the changes\n        for (uint256 i = 0; i < changes.length; i++) {\n            Change memory _change = changes[i];\n\n            // transfer NFTs from caller\n            for (uint256 j = 0; j < changes[i].inputTokenIds.length; j++) {\n                ERC721(_change.nft).safeTransferFrom(msg.sender, address(this), _change.inputTokenIds[j]);\n            }\n\n            // approve pair to transfer NFTs from router\n            ERC721(_change.nft).setApprovalForAll(_change.pool, true);\n\n            // execute change\n            PrivatePool(_change.pool).change{value: msg.value}(\n                _change.inputTokenIds,\n                _change.inputTokenWeights,\n                _change.inputProof,\n                _change.stolenNftProofs,\n                _change.outputTokenIds,\n                _change.outputTokenWeights,\n                _change.outputProof\n            );\n\n            // transfer NFTs to caller\n            for (uint256 j = 0; j < changes[i].outputTokenIds.length; j++) {\n                ERC721(_change.nft).safeTransferFrom(address(this), msg.sender, _change.outputTokenIds[j]);\n            }\n        }\n\n        // refund any surplus ETH to the caller\n        if (address(this).balance > 0) {\n            msg.sender.safeTransferETH(address(this).balance);\n        }\n    }\n\n    /// @notice Gets the royalty and recipient for a given NFT and sale price. Looks up the royalty info from the\n    /// manifold registry.\n    /// @param tokenId The token ID of the NFT.\n    /// @param salePrice The sale price of the NFT.\n    /// @return royaltyFee The royalty fee to pay.\n    /// @return recipient The address to pay the royalty fee to.\n    function getRoyalty(address nft, uint256 tokenId, uint256 salePrice)\n        public\n        view\n        returns (uint256 royaltyFee, address recipient)\n    {\n        // get the royalty lookup address\n        address lookupAddress = IRoyaltyRegistry(royaltyRegistry).getRoyaltyLookupAddress(nft);\n\n        if (IERC2981(lookupAddress).supportsInterface(type(IERC2981).interfaceId)) {\n            // get the royalty fee from the registry\n            (recipient, royaltyFee) = IERC2981(lookupAddress).royaltyInfo(tokenId, salePrice);\n\n            // revert if the royalty fee is greater than the sale price\n            if (royaltyFee > salePrice) revert InvalidRoyaltyFee();\n        }\n    }\n}"
    }
  ]
}