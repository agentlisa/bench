{
  "Title": "Last Rewards Cannot Be Collected",
  "Content": "The [`collectRewards` function](https://github.com/OriginProtocol/ousd-governance/blob/3c3b7993b40b5c21525722fda459b983251b65bd/contracts/FixedRateRewardsSource.sol#L63-L86) of the `FixedRateRewardsSource` contract will attempt to release funds at a fixed rate per second regardless of how many tokens it owns. For the caller who attempts to collect the last remaining funds in the contract, the released amount may surpass the owned amount. Meaning, any call to collect rewards will revert and the owned tokens will never be released. It is possible to release owned tokens if the exact difference between released and owned tokens is transferred prior to collecting the rewards.\n\n\nConsider adding logic to calculate the released tokens as the minimum between the calculated amount and the owned amount.\n\n\n***Update:** Resolved in [pull request #413](https://github.com/OriginProtocol/ousd-governance/pull/413). The Origin Protocol team stated:*\n\n\n\n> *We also detected this, and have already done a PR with this change during the audit.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/FixedRateRewardsSource.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport {Governable} from \"./Governable.sol\";\nimport {Initializable} from \"./upgrades/Initializable.sol\";\nimport \"OpenZeppelin/openzeppelin-contracts@4.6.0/contracts/token/ERC20/IERC20.sol\";\n\ncontract FixedRateRewardsSource is Governable, Initializable {\n    error UnauthorizedCaller();\n    error InvalidRewardRate();\n\n    event StrategistUpdated(address _address);\n    event RewardsTargetChange(address target, address previousTarget);\n    event RewardsPerSecondChanged(uint256 newRPS, uint256 oldRPS);\n    event RewardCollected(uint256 amountCollected);\n\n    address public immutable rewardToken;\n\n    address public strategistAddr;\n\n    address public rewardsTarget;\n\n    struct RewardConfig {\n        // Inspired by (Copied from) `Dripper.Drip` struct.\n        uint64 lastCollect; // Overflows 262 billion years after the sun dies\n        uint192 rewardsPerSecond;\n    }\n\n    RewardConfig public rewardConfig;\n\n    /**\n     * @dev Verifies that the caller is either Governor or Strategist.\n     */\n    modifier onlyGovernorOrStrategist() {\n        if (msg.sender != strategistAddr && !isGovernor()) {\n            revert UnauthorizedCaller();\n        }\n\n        _;\n    }\n\n    constructor(address _rewardToken) {\n        rewardToken = _rewardToken;\n    }\n\n    /// @dev Initialize the proxy implementation\n    /// @param _strategistAddr Address of the Strategist\n    /// @param _rewardsTarget Address that receives rewards\n    /// @param _rewardsPerSecond Rate of reward emission\n    function initialize(address _strategistAddr, address _rewardsTarget, uint192 _rewardsPerSecond)\n        external\n        initializer\n    {\n        _setStrategistAddr(_strategistAddr);\n        _setRewardsTarget(_rewardsTarget);\n\n        // Rewards start from the moment the contract is initialized\n        rewardConfig.lastCollect = uint64(block.timestamp);\n\n        _setRewardsPerSecond(_rewardsPerSecond);\n    }\n\n    /// @dev Collect pending rewards\n    /// @return rewardAmount Amount of reward collected\n    function collectRewards() external returns (uint256 rewardAmount) {\n        address _target = rewardsTarget;\n        if (_target != msg.sender) {\n            revert UnauthorizedCaller();\n        }\n\n        // Compute pending rewards\n        rewardAmount = previewRewards();\n\n        // Update timestamp\n        rewardConfig.lastCollect = uint64(block.timestamp);\n\n        if (rewardAmount > 0) {\n            // Should not revert if there's no reward to transfer.\n\n            emit RewardCollected(rewardAmount);\n\n            // Intentionally skipping balance check to save some gas\n            // since `transfer` anyway would fail in case of low balance\n            IERC20(rewardToken).transfer(_target, rewardAmount);\n        }\n    }\n\n    /// @dev Compute pending rewards since last collect\n    /// @return rewardAmount Amount of reward that'll be distributed if collected now\n    function previewRewards() public view returns (uint256) {\n        RewardConfig memory _config = rewardConfig;\n        return (block.timestamp - _config.lastCollect) * _config.rewardsPerSecond;\n        // return _previewRewards(rewardConfig);\n    }\n\n    /// @dev Set address of the strategist\n    /// @param _address Address of the Strategist\n    function setStrategistAddr(address _address) external onlyGovernor {\n        _setStrategistAddr(_address);\n    }\n\n    function _setStrategistAddr(address _address) internal {\n        emit StrategistUpdated(_address);\n        // Can be set to zero to disable\n        strategistAddr = _address;\n    }\n\n    /// @dev Set the address of the contract than can collect rewards\n    /// @param _rewardsTarget contract address that can collect rewards\n    function setRewardsTarget(address _rewardsTarget) external onlyGovernor {\n        _setRewardsTarget(_rewardsTarget);\n    }\n\n    /// @dev Set the address of the contract than can collect rewards\n    /// @param _rewardsTarget contract address that can collect rewards\n    function _setRewardsTarget(address _rewardsTarget) internal {\n        emit RewardsTargetChange(_rewardsTarget, rewardsTarget);\n        // Can be set to zero to disable\n        rewardsTarget = _rewardsTarget;\n    }\n\n    /// @dev Set the rate of reward emission\n    /// @param _rewardsPerSecond Amount of rewardToken to distribute per second\n    function setRewardsPerSecond(uint192 _rewardsPerSecond) external onlyGovernorOrStrategist {\n        _setRewardsPerSecond(_rewardsPerSecond);\n    }\n\n    /// @dev Set the rate of reward emission\n    /// @param _rewardsPerSecond Amount of rewardToken to distribute per second\n    function _setRewardsPerSecond(uint192 _rewardsPerSecond) internal {\n        // Update storage\n        RewardConfig storage _config = rewardConfig;\n        emit RewardsPerSecondChanged(_rewardsPerSecond, _config.rewardsPerSecond);\n        _config.rewardsPerSecond = _rewardsPerSecond;\n    }\n}"
    }
  ]
}