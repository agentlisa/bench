{
  "Title": "[M-07] Trading will not work on Ethereum if USDT is used",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L652\n\n\n# Vulnerability details\n\n## Impact\n\nTraders will not be able to:\n1. Initiate a market order\n2. Add margin\n3. Add to position\n4. initiate limit order\n\nIf USDT is set as the margin asset and protocol is deployed on ethereum.\n\n(Note: this issue was submitted after consulting with the sponsor even though currently there are no plans to deploy the platform on ethereum)\n\n## Proof of Concept\n\n`USDT` has a race condition protection mechanism on ethereum chain:\nIt does not allow users to change the allowance without first changing the allowance to 0. \n\n`approve` function in `USDT` on ethereum:\nhttps://etherscan.io/token/0xdac17f958d2ee523a2206206994597c13d831ec7#code#L205\n```\n    function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {\n\n        // To change the approve amount you first have to reduce the addresses`\n        //  allowance to zero by calling `approve(_spender, 0)` if it is not\n        //  already 0 to mitigate the race condition described here:\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n        require(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\n\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n    }\n```\n\nin `Trading` if users use `USDT` as margin to:\n1. Initiate a market order\n2. Add margin\n3. Add to position\n4. initiate limit order\n\nThe transaction will revert. \n\nThis is due to the the `_handleDeposit` which is called in all of the above uses. \n`_handleDeposit` calls the `USDT` margin asset `approve` function with `type(uint).max`.\nFrom the second time `approve` will be called, the transaction will revert.\n\n`_handleDeposit` in `Trading`:\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L652\n```\n    function _handleDeposit(address _tigAsset, address _marginAsset, uint256 _margin, address _stableVault\n, ERC20PermitData calldata _permitData, address _trader) internal {\n------\n            IERC20(_marginAsset).transferFrom(_trader, address(this), _margin/_marginDecMultiplier);\n            IERC20(_marginAsset).approve(_stableVault, type(uint).max);\n            IStableVault(_stableVault).deposit(_marginAsset, _margin/_marginDecMultiplier);\n------\n    }\n```\n\n## Tools Used\n\nVS Code\n\n## Recommended Mitigation Steps\n\nNo need to to approve `USDT` every time. \nThe protocol could:\n1. Keep a record if allowance was already set on an address\n2. Create an external function that can be called by the owner to approve the a token address",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-12-tigris-trade-contest",
  "Code": [
    {
      "filename": "contracts/Trading.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"./utils/MetaContext.sol\";\nimport \"./interfaces/ITrading.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./interfaces/IPairsContract.sol\";\nimport \"./interfaces/IReferrals.sol\";\nimport \"./interfaces/IPosition.sol\";\nimport \"./interfaces/IGovNFT.sol\";\nimport \"./interfaces/IStableVault.sol\";\nimport \"./utils/TradingLibrary.sol\";\n\ninterface ITradingExtension {\n    function getVerifiedPrice(\n        uint _asset,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        uint _withSpreadIsLong\n    ) external returns(uint256 _price, uint256 _spread);\n    function getRef(\n        address _trader\n    ) external pure returns(address);\n    function _setReferral(\n        bytes32 _referral,\n        address _trader\n    ) external;\n    function validateTrade(uint _asset, address _tigAsset, uint _margin, uint _leverage) external view;\n    function isPaused() external view returns(bool);\n    function minPos(address) external view returns(uint);\n    function modifyLongOi(\n        uint _asset,\n        address _tigAsset,\n        bool _onOpen,\n        uint _size\n    ) external;\n    function modifyShortOi(\n        uint _asset,\n        address _tigAsset,\n        bool _onOpen,\n        uint _size\n    ) external;\n    function paused() external returns(bool);\n    function _limitClose(\n        uint _id,\n        bool _tp,\n        PriceData calldata _priceData,\n        bytes calldata _signature\n    ) external returns(uint _limitPrice, address _tigAsset);\n    function _checkGas() external view;\n    function _closePosition(\n        uint _id,\n        uint _price,\n        uint _percent\n    ) external returns (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout);\n}\n\ninterface IStable is IERC20 {\n    function burnFrom(address account, uint amount) external;\n    function mintFor(address account, uint amount) external;\n}\n\ninterface ExtendedIERC20 is IERC20 {\n    function decimals() external view returns (uint);\n}\n\ninterface ERC20Permit is IERC20 {\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\ncontract Trading is MetaContext, ITrading {\n\n    error LimitNotSet(); //7\n    error NotLiquidatable();\n    error TradingPaused();\n    error BadDeposit();\n    error BadWithdraw();\n    error ValueNotEqualToMargin();\n    error BadLeverage();\n    error NotMargin();\n    error NotAllowedPair();\n    error BelowMinPositionSize();\n    error BadClosePercent();\n    error NoPrice();\n    error LiqThreshold();\n\n    uint constant private DIVISION_CONSTANT = 1e10; // 100%\n    uint private constant liqPercent = 9e9; // 90%\n\n    struct Fees {\n        uint daoFees;\n        uint burnFees;\n        uint referralFees;\n        uint botFees;\n    }\n    Fees public openFees = Fees(\n        0,\n        0,\n        0,\n        0\n    );\n    Fees public closeFees = Fees(\n        0,\n        0,\n        0,\n        0\n    );\n    uint public limitOrderPriceRange = 1e8; // 1%\n\n    uint public maxWinPercent;\n    uint public vaultFundingPercent;\n\n    IPairsContract private pairsContract;\n    IPosition private position;\n    IGovNFT private gov;\n    ITradingExtension private tradingExtension;\n\n    struct Delay {\n        uint delay; // Block number where delay ends\n        bool actionType; // True for open, False for close\n    }\n    mapping(uint => Delay) public blockDelayPassed; // id => Delay\n    uint public blockDelay;\n    mapping(uint => uint) public limitDelay; // id => block.timestamp\n\n    mapping(address => bool) public allowedVault;\n\n    struct Proxy {\n        address proxy;\n        uint256 time;\n    }\n\n    mapping(address => Proxy) public proxyApprovals;\n\n    constructor(\n        address _position,\n        address _gov,\n        address _pairsContract\n    )\n    {\n        position = IPosition(_position);\n        gov = IGovNFT(_gov);\n        pairsContract = IPairsContract(_pairsContract);\n    }\n\n    // ===== END-USER FUNCTIONS =====\n\n    /**\n     * @param _tradeInfo Trade info\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _permitData data and signature needed for token approval\n     * @param _trader address the trade is initiated for\n     */\n    function initiateMarketOrder(\n        TradeInfo calldata _tradeInfo,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        ERC20PermitData calldata _permitData,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkDelay(position.getCount(), true);\n        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);\n        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();\n        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);\n        tradingExtension._setReferral(_tradeInfo.referral, _trader);\n        uint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false);\n        uint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;\n        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);\n        uint256 _isLong = _tradeInfo.direction ? 1 : 2;\n        (uint256 _price,) = tradingExtension.getVerifiedPrice(_tradeInfo.asset, _priceData, _signature, _isLong);\n        IPosition.MintTrade memory _mintTrade = IPosition.MintTrade(\n            _trader,\n            _marginAfterFees,\n            _tradeInfo.leverage,\n            _tradeInfo.asset,\n            _tradeInfo.direction,\n            _price,\n            _tradeInfo.tpPrice,\n            _tradeInfo.slPrice,\n            0,\n            _tigAsset\n        );\n        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);\n        unchecked {\n            if (_tradeInfo.direction) {\n                tradingExtension.modifyLongOi(_tradeInfo.asset, _tigAsset, true, _positionSize);\n            } else {\n                tradingExtension.modifyShortOi(_tradeInfo.asset, _tigAsset, true, _positionSize);\n            }\n        }\n        _updateFunding(_tradeInfo.asset, _tigAsset);\n        position.mint(\n            _mintTrade\n        );\n        unchecked {\n            emit PositionOpened(_tradeInfo, 0, _price, position.getCount()-1, _trader, _marginAfterFees);\n        }   \n    }\n\n    /**\n     * @dev initiate closing position\n     * @param _id id of the position NFT\n     * @param _percent percent of the position being closed in BP\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _stableVault StableVault address\n     * @param _outputToken Token received upon closing trade\n     * @param _trader address the trade is initiated for\n     */\n    function initiateCloseOrder(\n        uint _id,\n        uint _percent,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        address _stableVault,\n        address _outputToken,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkDelay(_id, false);\n        _checkOwner(_id, _trader);\n        _checkVault(_stableVault, _outputToken);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType != 0) revert(\"4\"); //IsLimit        \n        (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);\n\n        if (_percent > DIVISION_CONSTANT || _percent == 0) revert BadClosePercent();\n        _closePosition(_id, _percent, _price, _stableVault, _outputToken, false); \n    }\n\n    /**\n     * @param _id position id\n     * @param _addMargin margin amount used to add to the position\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _stableVault StableVault address\n     * @param _marginAsset Token being used to add to the position\n     * @param _permitData data and signature needed for token approval\n     * @param _trader address the trade is initiated for\n     */\n    function addToPosition(\n        uint _id,\n        uint _addMargin,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        address _stableVault,\n        address _marginAsset,\n        ERC20PermitData calldata _permitData,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        _checkDelay(_id, true);\n        IPosition.Trade memory _trade = position.trades(_id);\n        tradingExtension.validateTrade(_trade.asset, _trade.tigAsset, _trade.margin + _addMargin, _trade.leverage);\n        _checkVault(_stableVault, _marginAsset);\n        if (_trade.orderType != 0) revert(\"4\"); //IsLimit\n        uint _fee = _handleOpenFees(_trade.asset, _addMargin*_trade.leverage/1e18, _trader, _trade.tigAsset, false);\n        _handleDeposit(\n            _trade.tigAsset,\n            _marginAsset,\n            _addMargin - _fee,\n            _stableVault,\n            _permitData,\n            _trader\n        );\n        position.setAccInterest(_id);\n        unchecked {\n            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, _trade.direction ? 1 : 2);\n            uint _positionSize = (_addMargin - _fee) * _trade.leverage / 1e18;\n            if (_trade.direction) {\n                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, true, _positionSize);\n            } else {\n                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, true, _positionSize);     \n            }\n            _updateFunding(_trade.asset, _trade.tigAsset);\n            _addMargin -= _fee;\n            uint _newMargin = _trade.margin + _addMargin;\n            uint _newPrice = _trade.price*_trade.margin/_newMargin + _price*_addMargin/_newMargin;\n\n            position.addToPosition(\n                _trade.id,\n                _newMargin,\n                _newPrice\n            );\n            \n            emit AddToPosition(_trade.id, _newMargin, _newPrice, _trade.trader);\n        }\n    }\n\n    /**\n     * @param _tradeInfo Trade info\n     * @param _orderType type of limit order used to open the position\n     * @param _price limit price\n     * @param _permitData data and signature needed for token approval\n     * @param _trader address the trade is initiated for\n     */\n    function initiateLimitOrder(\n        TradeInfo calldata _tradeInfo,\n        uint256 _orderType, // 1 limit, 2 stop\n        uint256 _price,\n        ERC20PermitData calldata _permitData,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();\n        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);\n        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);\n        if (_orderType == 0) revert(\"5\");\n        if (_price == 0) revert NoPrice();\n        tradingExtension._setReferral(_tradeInfo.referral, _trader);\n        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);\n        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);\n        uint256 _id = position.getCount();\n        position.mint(\n            IPosition.MintTrade(\n                _trader,\n                _tradeInfo.margin,\n                _tradeInfo.leverage,\n                _tradeInfo.asset,\n                _tradeInfo.direction,\n                _price,\n                _tradeInfo.tpPrice,\n                _tradeInfo.slPrice,\n                _orderType,\n                _tigAsset\n            )\n        );\n        limitDelay[_id] = block.timestamp + 4;\n        emit PositionOpened(_tradeInfo, _orderType, _price, _id, _trader, _tradeInfo.margin);\n    }\n\n    /**\n     * @param _id position ID\n     * @param _trader address the trade is initiated for\n     */\n    function cancelLimitOrder(\n        uint256 _id,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType == 0) revert();\n        IStable(_trade.tigAsset).mintFor(_trader, _trade.margin);\n        position.burn(_id);\n        emit LimitCancelled(_id, _trader);\n    }\n\n    /**\n     * @param _id position id\n     * @param _marginAsset Token being used to add to the position\n     * @param _stableVault StableVault address\n     * @param _addMargin margin amount being added to the position\n     * @param _permitData data and signature needed for token approval\n     * @param _trader address the trade is initiated for\n     */\n    function addMargin(\n        uint256 _id,\n        address _marginAsset,\n        address _stableVault,\n        uint256 _addMargin,\n        ERC20PermitData calldata _permitData,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        _checkVault(_stableVault, _marginAsset);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType != 0) revert(); //IsLimit\n        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);\n        _handleDeposit(_trade.tigAsset, _marginAsset, _addMargin, _stableVault, _permitData, _trader);\n        unchecked {\n            uint256 _newMargin = _trade.margin + _addMargin;\n            uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;\n            if (_newLeverage < asset.minLeverage) revert(\"!lev\");\n            position.modifyMargin(_id, _newMargin, _newLeverage);\n            emit MarginModified(_id, _newMargin, _newLeverage, true, _trader);\n        }\n    }\n\n    /**\n     * @param _id position id\n     * @param _stableVault StableVault address\n     * @param _outputToken token the trader will receive\n     * @param _removeMargin margin amount being removed from the position\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _trader address the trade is initiated for\n     */\n    function removeMargin(\n        uint256 _id,\n        address _stableVault,\n        address _outputToken,\n        uint256 _removeMargin,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        _checkVault(_stableVault, _outputToken);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType != 0) revert(); //IsLimit\n        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);\n        uint256 _newMargin = _trade.margin - _removeMargin;\n        uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;\n        if (_newLeverage > asset.maxLeverage) revert(\"!lev\");\n        (uint _assetPrice,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);\n        (,int256 _payout) = TradingLibrary.pnl(_trade.direction, _assetPrice, _trade.price, _newMargin, _newLeverage, _trade.accInterest);\n        unchecked {\n            if (_payout <= int256(_newMargin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert LiqThreshold();\n        }\n        position.modifyMargin(_trade.id, _newMargin, _newLeverage);\n        _handleWithdraw(_trade, _stableVault, _outputToken, _removeMargin);\n        emit MarginModified(_trade.id, _newMargin, _newLeverage, false, _trader);\n    }\n\n    /**\n     * @param _type true for TP, false for SL\n     * @param _id position id\n     * @param _limitPrice TP/SL trigger price\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     * @param _trader address the trade is initiated for\n     */\n    function updateTpSl(\n        bool _type,\n        uint _id,\n        uint _limitPrice,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        IPosition.Trade memory _trade = position.trades(_id);\n        if (_trade.orderType != 0) revert(\"4\"); //IsLimit\n        if (_type) {\n            position.modifyTp(_id, _limitPrice);\n        } else {\n            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);\n            _checkSl(_limitPrice, _trade.direction, _price);\n            position.modifySl(_id, _limitPrice);\n        }\n        emit UpdateTPSL(_id, _type, _limitPrice, _trader);\n    }\n\n    /**\n     * @param _id position id\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     */\n    function executeLimitOrder(\n        uint _id, \n        PriceData calldata _priceData,\n        bytes calldata _signature\n    ) \n        external\n    {\n        unchecked {\n            _checkDelay(_id, true);\n            tradingExtension._checkGas();\n            if (tradingExtension.paused()) revert TradingPaused();\n            require(block.timestamp >= limitDelay[_id]);\n            IPosition.Trade memory trade = position.trades(_id);\n            uint _fee = _handleOpenFees(trade.asset, trade.margin*trade.leverage/1e18, trade.trader, trade.tigAsset, true);\n            (uint256 _price, uint256 _spread) = tradingExtension.getVerifiedPrice(trade.asset, _priceData, _signature, 0);\n            if (trade.orderType == 0) revert(\"5\");\n            if (_price > trade.price+trade.price*limitOrderPriceRange/DIVISION_CONSTANT || _price < trade.price-trade.price*limitOrderPriceRange/DIVISION_CONSTANT) revert(\"6\"); //LimitNotMet\n            if (trade.direction && trade.orderType == 1) {\n                if (trade.price < _price) revert(\"6\"); //LimitNotMet\n            } else if (!trade.direction && trade.orderType == 1) {\n                if (trade.price > _price) revert(\"6\"); //LimitNotMet\n            } else if (!trade.direction && trade.orderType == 2) {\n                if (trade.price < _price) revert(\"6\"); //LimitNotMet\n                trade.price = _price;\n            } else {\n                if (trade.price > _price) revert(\"6\"); //LimitNotMet\n                trade.price = _price;\n            } \n            if(trade.direction) {\n                trade.price += trade.price * _spread / DIVISION_CONSTANT;\n            } else {\n                trade.price -= trade.price * _spread / DIVISION_CONSTANT;\n            }\n            if (trade.direction) {\n                tradingExtension.modifyLongOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);\n            } else {\n                tradingExtension.modifyShortOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);\n            }\n            _updateFunding(trade.asset, trade.tigAsset);\n            position.executeLimitOrder(_id, trade.price, trade.margin - _fee);\n            emit LimitOrderExecuted(trade.asset, trade.direction, trade.price, trade.leverage, trade.margin - _fee, _id, trade.trader, _msgSender());\n        }\n    }\n\n    /**\n     * @notice liquidate position\n     * @param _id id of the position NFT\n     * @param _priceData verifiable off-chain data\n     * @param _signature node signature\n     */\n    function liquidatePosition(\n        uint _id,\n        PriceData calldata _priceData,\n        bytes calldata _signature\n    )\n        external\n    {\n        unchecked {\n            tradingExtension._checkGas();\n            IPosition.Trade memory _trade = position.trades(_id);\n            if (_trade.orderType != 0) revert(\"4\"); //IsLimit\n\n            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);\n            (uint256 _positionSizeAfterPrice, int256 _payout) = TradingLibrary.pnl(_trade.direction, _price, _trade.price, _trade.margin, _trade.leverage, _trade.accInterest);\n            uint256 _positionSize = _trade.margin*_trade.leverage/1e18;\n            if (_payout > int256(_trade.margin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert NotLiquidatable();\n            if (_trade.direction) {\n                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, false, _positionSize);\n            } else {\n                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, false, _positionSize);\n            }\n            _updateFunding(_trade.asset, _trade.tigAsset);\n            _handleCloseFees(_trade.asset, type(uint).max, _trade.tigAsset, _positionSizeAfterPrice, _trade.trader, true);\n            position.burn(_id);\n            emit PositionLiquidated(_id, _trade.trader, _msgSender());\n        }\n    }\n\n    /**\n     * @dev close position at a pre-set price\n     * @param _id id of the position NFT\n     * @param _tp true if take profit\n     * @param _priceData verifiable off-chain price data\n     * @param _signature node signature\n     */\n    function limitClose(\n        uint _id,\n        bool _tp,\n        PriceData calldata _priceData,\n        bytes calldata _signature\n    )\n        external\n    {\n        _checkDelay(_id, false);\n        (uint _limitPrice, address _tigAsset) = tradingExtension._limitClose(_id, _tp, _priceData, _signature);\n        _closePosition(_id, DIVISION_CONSTANT, _limitPrice, address(0), _tigAsset, true);\n    }\n\n    /**\n     * @notice Trader can approve a proxy wallet address for it to trade on its behalf. Can also provide proxy wallet with gas.\n     * @param _proxy proxy wallet address\n     * @param _timestamp end timestamp of approval period\n     */\n    function approveProxy(address _proxy, uint256 _timestamp) external payable {\n        proxyApprovals[_msgSender()] = Proxy(\n            _proxy,\n            _timestamp\n        );\n        payable(_proxy).transfer(msg.value);\n    }\n\n    // ===== INTERNAL FUNCTIONS =====\n\n    /**\n     * @dev close the initiated position.\n     * @param _id id of the position NFT\n     * @param _percent percent of the position being closed\n     * @param _price pair price\n     * @param _stableVault StableVault address\n     * @param _outputToken Token that trader will receive\n     * @param _isBot false if closed via market order\n     */\n    function _closePosition(\n        uint _id,\n        uint _percent,\n        uint _price,\n        address _stableVault,\n        address _outputToken,\n        bool _isBot\n    )\n        internal\n    {\n        (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout) = tradingExtension._closePosition(_id, _price, _percent);\n        position.setAccInterest(_id);\n        _updateFunding(_trade.asset, _trade.tigAsset);\n        if (_percent < DIVISION_CONSTANT) {\n            if ((_trade.margin*_trade.leverage*(DIVISION_CONSTANT-_percent)/DIVISION_CONSTANT)/1e18 < tradingExtension.minPos(_trade.tigAsset)) revert(\"!size\");\n            position.reducePosition(_id, _percent);\n        } else {\n            position.burn(_id);\n        }\n        uint256 _toMint;\n        if (_payout > 0) {\n            unchecked {\n                _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);\n                if (maxWinPercent > 0 && _toMint > _trade.margin*maxWinPercent/DIVISION_CONSTANT) {\n                    _toMint = _trade.margin*maxWinPercent/DIVISION_CONSTANT;\n                }\n            }\n            _handleWithdraw(_trade, _stableVault, _outputToken, _toMint);\n        }\n        emit PositionClosed(_id, _price, _percent, _toMint, _trade.trader, _isBot ? _msgSender() : _trade.trader);\n    }\n\n    /**\n     * @dev handle stablevault deposits for different trading functions\n     * @param _tigAsset tigAsset token address\n     * @param _marginAsset token being deposited into stablevault\n     * @param _margin amount being deposited\n     * @param _stableVault StableVault address\n     * @param _permitData Data for approval via permit\n     * @param _trader Trader address to take tokens from\n     */\n    function _handleDeposit(address _tigAsset, address _marginAsset, uint256 _margin, address _stableVault, ERC20PermitData calldata _permitData, address _trader) internal {\n        IStable tigAsset = IStable(_tigAsset);\n        if (_tigAsset != _marginAsset) {\n            if (_permitData.usePermit) {\n                ERC20Permit(_marginAsset).permit(_trader, address(this), _permitData.amount, _permitData.deadline, _permitData.v, _permitData.r, _permitData.s);\n            }\n            uint256 _balBefore = tigAsset.balanceOf(address(this));\n            uint _marginDecMultiplier = 10**(18-ExtendedIERC20(_marginAsset).decimals());\n            IERC20(_marginAsset).transferFrom(_trader, address(this), _margin/_marginDecMultiplier);\n            IERC20(_marginAsset).approve(_stableVault, type(uint).max);\n            IStableVault(_stableVault).deposit(_marginAsset, _margin/_marginDecMultiplier);\n            if (tigAsset.balanceOf(address(this)) != _balBefore + _margin) revert BadDeposit();\n            tigAsset.burnFrom(address(this), tigAsset.balanceOf(address(this)));\n        } else {\n            tigAsset.burnFrom(_trader, _margin);\n        }        \n    }\n\n    /**\n     * @dev handle stablevault withdrawals for different trading functions\n     * @param _trade Position info\n     * @param _stableVault StableVault address\n     * @param _outputToken Output token address\n     * @param _toMint Amount of tigAsset minted to be used for withdrawal\n     */\n    function _handleWithdraw(IPosition.Trade memory _trade, address _stableVault, address _outputToken, uint _toMint) internal {\n        IStable(_trade.tigAsset).mintFor(address(this), _toMint);\n        if (_outputToken == _trade.tigAsset) {\n            IERC20(_outputToken).transfer(_trade.trader, _toMint);\n        } else {\n            uint256 _balBefore = IERC20(_outputToken).balanceOf(address(this));\n            IStableVault(_stableVault).withdraw(_outputToken, _toMint);\n            if (IERC20(_outputToken).balanceOf(address(this)) != _balBefore + _toMint/(10**(18-ExtendedIERC20(_outputToken).decimals()))) revert BadWithdraw();\n            IERC20(_outputToken).transfer(_trade.trader, IERC20(_outputToken).balanceOf(address(this)) - _balBefore);\n        }        \n    }\n\n    /**\n     * @dev handle fees distribution for opening\n     * @param _asset asset id\n     * @param _positionSize position size\n     * @param _trader trader address\n     * @param _tigAsset tigAsset address\n     * @param _isBot false if opened via market order\n     * @return _feePaid total fees paid during opening\n     */\n    function _handleOpenFees(\n        uint _asset,\n        uint _positionSize,\n        address _trader,\n        address _tigAsset,\n        bool _isBot\n    )\n        internal\n        returns (uint _feePaid)\n    {\n        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);\n        Fees memory _fees = openFees;\n        unchecked {\n            _fees.daoFees = _fees.daoFees * asset.feeMultiplier / DIVISION_CONSTANT;\n            _fees.burnFees = _fees.burnFees * asset.feeMultiplier / DIVISION_CONSTANT;\n            _fees.referralFees = _fees.referralFees * asset.feeMultiplier / DIVISION_CONSTANT;\n            _fees.botFees = _fees.botFees * asset.feeMultiplier / DIVISION_CONSTANT;\n        }\n        address _referrer = tradingExtension.getRef(_trader); //referrals.getReferral(referrals.getReferred(_trader));\n        if (_referrer != address(0)) {\n            unchecked {\n                IStable(_tigAsset).mintFor(\n                    _referrer,\n                    _positionSize\n                    * _fees.referralFees // get referral fee%\n                    / DIVISION_CONSTANT // divide by 100%\n                );\n            }\n            _fees.daoFees = _fees.daoFees - _fees.referralFees*2;\n        }\n        if (_isBot) {\n            unchecked {\n                IStable(_tigAsset).mintFor(\n                    _msgSender(),\n                    _positionSize\n                    * _fees.botFees // get bot fee%\n                    / DIVISION_CONSTANT // divide by 100%\n                );\n            }\n            _fees.daoFees = _fees.daoFees - _fees.botFees;\n        } else {\n            _fees.botFees = 0;\n        }\n        unchecked {\n            uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT;\n            _feePaid =\n                _positionSize\n                * (_fees.burnFees + _fees.botFees) // get total fee%\n                / DIVISION_CONSTANT // divide by 100%\n                + _daoFeesPaid;\n            emit FeesDistributed(\n                _tigAsset,\n                _daoFeesPaid,\n                _positionSize * _fees.burnFees / DIVISION_CONSTANT,\n                _referrer != address(0) ? _positionSize * _fees.referralFees / DIVISION_CONSTANT : 0,\n                _positionSize * _fees.botFees / DIVISION_CONSTANT,\n                _referrer\n            );\n            IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);\n        }\n        gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));\n    }\n\n    /**\n     * @dev handle fees distribution for closing\n     * @param _asset asset id\n     * @param _payout payout to trader before fees\n     * @param _tigAsset margin asset\n     * @param _positionSize position size\n     * @param _trader trader address\n     * @param _isBot false if closed via market order\n     * @return payout_ payout to trader after fees\n     */\n    function _handleCloseFees(\n        uint _asset,\n        uint _payout,\n        address _tigAsset,\n        uint _positionSize,\n        address _trader,\n        bool _isBot\n    )\n        internal\n        returns (uint payout_)\n    {\n        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);\n        Fees memory _fees = closeFees;\n        uint _daoFeesPaid;\n        uint _burnFeesPaid;\n        uint _referralFeesPaid;\n        unchecked {\n            _daoFeesPaid = (_positionSize*_fees.daoFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;\n            _burnFeesPaid = (_positionSize*_fees.burnFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;\n        }\n        uint _botFeesPaid;\n        address _referrer = tradingExtension.getRef(_trader);//referrals.getReferral(referrals.getReferred(_trader));\n        if (_referrer != address(0)) {\n            unchecked {\n                _referralFeesPaid = (_positionSize*_fees.referralFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;\n            }\n            IStable(_tigAsset).mintFor(\n                _referrer,\n                _referralFeesPaid\n            );\n             _daoFeesPaid = _daoFeesPaid-_referralFeesPaid*2;\n        }\n        if (_isBot) {\n            unchecked {\n                _botFeesPaid = (_positionSize*_fees.botFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;\n                IStable(_tigAsset).mintFor(\n                    _msgSender(),\n                    _botFeesPaid\n                );\n            }\n            _daoFeesPaid = _daoFeesPaid - _botFeesPaid;\n        }\n        emit FeesDistributed(_tigAsset, _daoFeesPaid, _burnFeesPaid, _referralFeesPaid, _botFeesPaid, _referrer);\n        payout_ = _payout - _daoFeesPaid - _burnFeesPaid - _botFeesPaid;\n        IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);\n        IStable(_tigAsset).approve(address(gov), type(uint).max);\n        gov.distribute(_tigAsset, _daoFeesPaid);\n        return payout_;\n    }\n\n    /**\n     * @dev update funding rates after open interest changes\n     * @param _asset asset id\n     * @param _tigAsset tigAsset used for OI\n     */\n    function _updateFunding(uint256 _asset, address _tigAsset) internal {\n        position.updateFunding(\n            _asset,\n            _tigAsset,\n            pairsContract.idToOi(_asset, _tigAsset).longOi,\n            pairsContract.idToOi(_asset, _tigAsset).shortOi,\n            pairsContract.idToAsset(_asset).baseFundingRate,\n            vaultFundingPercent\n        );\n    }\n\n    /**\n     * @dev check that SL price is valid compared to market price\n     * @param _sl SL price\n     * @param _direction long/short\n     * @param _price market price\n     */\n    function _checkSl(uint _sl, bool _direction, uint _price) internal pure {\n        if (_direction) {\n            if (_sl > _price) revert(\"3\"); //BadStopLoss\n        } else {\n            if (_sl < _price && _sl != 0) revert(\"3\"); //BadStopLoss\n        }\n    }\n\n    /**\n     * @dev check that trader address owns the position\n     * @param _id position id\n     * @param _trader trader address\n     */\n    fun"
    }
  ]
}