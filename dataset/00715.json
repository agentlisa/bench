{
  "Title": "M-1: Nobody can cast for any proposal",
  "Content": "# Issue M-1: Nobody can cast for any proposal \n\nSource: https://github.com/sherlock-audit/2024-01-olympus-on-chain-governance-judging/issues/37 \n\n## Found by \nBauer, Breeje, alexzoid, blutorque, cawfree, cocacola, emrekocak, fibonacci, hals, nobody2018, pontifex, s1ce\n## Summary\n\n[[castVote](https://github.com/sherlock-audit/2024-01-olympus-on-chain-governance/blob/main/bophades/src/external/governance/GovernorBravoDelegate.sol#L369)](https://github.com/sherlock-audit/2024-01-olympus-on-chain-governance/blob/main/bophades/src/external/governance/GovernorBravoDelegate.sol#L369)/[[castVoteWithReason](https://github.com/sherlock-audit/2024-01-olympus-on-chain-governance/blob/main/bophades/src/external/governance/GovernorBravoDelegate.sol#L385)](https://github.com/sherlock-audit/2024-01-olympus-on-chain-governance/blob/main/bophades/src/external/governance/GovernorBravoDelegate.sol#L385)/[[castVoteBySig](https://github.com/sherlock-audit/2024-01-olympus-on-chain-governance/blob/main/bophades/src/external/governance/GovernorBravoDelegate.sol#L403)](https://github.com/sherlock-audit/2024-01-olympus-on-chain-governance/blob/main/bophades/src/external/governance/GovernorBravoDelegate.sol#L403) are used to vote for the specified proposal. These functions internally call [[castVoteInternal](https://github.com/sherlock-audit/2024-01-olympus-on-chain-governance/blob/main/bophades/src/external/governance/GovernorBravoDelegate.sol#L433-L437)](https://github.com/sherlock-audit/2024-01-olympus-on-chain-governance/blob/main/bophades/src/external/governance/GovernorBravoDelegate.sol#L433-L437) to perform voting logic. However, `castVoteInternal` can never be executed successfully.\n\n## Vulnerability Detail\n\n```solidity\nFile: bophades\\src\\external\\governance\\GovernorBravoDelegate.sol\n433:     function castVoteInternal(\n434:         address voter,\n435:         uint256 proposalId,\n436:         uint8 support\n437:     ) internal returns (uint256) {\n......\n444:         // Get the user's votes at the start of the proposal and at the time of voting. Take the minimum.\n445:         uint256 originalVotes = gohm.getPriorVotes(voter, proposal.startBlock);\n446:->       uint256 currentVotes = gohm.getPriorVotes(voter, block.number);\n447:         uint256 votes = currentVotes > originalVotes ? originalVotes : currentVotes;\n......\n462:     }\n```\n\nThe second parameter of `gohm.getPriorVotes(voter, block.number)` can only a number smaller than `block.number`. Please see the [[code](https://etherscan.io/token/0x0ab87046fBb341D058F17CBC4c1133F25a20a52f#code#L703)](https://etherscan.io/token/0x0ab87046fBb341D058F17CBC4c1133F25a20a52f#code#L703) deployed by gOHM on the mainnet:\n\n```solidity\nfunction getPriorVotes(address account, uint256 blockNumber) external view returns (uint256) {\n->      require(blockNumber < block.number, \"gOHM::getPriorVotes: not yet determined\");\n......\n    }\n```\n\nTherefore, L446 will always revert. Voting will not be possible.\n\nCopy the coded POC below to one project from Foundry and run `forge test -vvv` to prove this issue.\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport \"forge-std/Test.sol\";\n\ninterface CheatCodes {\n    function prank(address) external;\n    function createSelectFork(string calldata,uint256) external returns(uint256);\n}\n\ninterface IGOHM {\n    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint256);\n}\n\ncontract ContractTest is DSTest{\n    address gOHM = 0x0ab87046fBb341D058F17CBC4c1133F25a20a52f;\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"https://rpc.ankr.com/eth\", 19068280);\n    }\n\n    function testRevert() public {\n        address user = address(0x12399543949349);\n        cheats.prank(user);\n        IGOHM(gOHM).getPriorVotes(address(0x1111111111), block.number);\n    }\n\n    function testOk() public {\n        address user = address(0x12399543949349);\n        cheats.prank(user);\n        IGOHM(gOHM).getPriorVotes(address(0x1111111111), block.number - 1);\n    }\n}\n/**output\n[PASS] testOk() (gas: 13019)\n[FAIL. Reason: revert: gOHM::getPriorVotes: not yet determined] testRevert() (gas: 10536)\nTraces:\n  [10536] ContractTest::testRevert()\n    ├─ [0] VM::prank(0x0000000000000000000000000012399543949349)\n    │   └─ ← ()\n    ├─ [540] 0x0ab87046fBb341D058F17CBC4c1133F25a20a52f::getPriorVotes(0x0000000000000000000000000000001111111111, 19068280 [1.906e7]) [staticcall]  \n    │   └─ ← revert: gOHM::getPriorVotes: not yet determined\n    └─ ← revert: gOHM::getPriorVotes: not yet determined\n\nTest result: FAILED. 1 passed; 1 failed; 0 skipped; finished in 1.80s\n**/\n```\n\n## Impact\n\nNobody can cast for any proposal. Not being able to vote means the entire governance contract will be useless. Core functionality is broken.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-01-olympus-on-chain-governance/blob/main/bophades/src/external/governance/GovernorBravoDelegate.sol#L446\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n```fix\nFile: bophades\\src\\external\\governance\\GovernorBravoDelegate.sol\n445:         uint256 originalVotes = gohm.getPriorVotes(voter, proposal.startBlock);\n446:-        uint256 currentVotes = gohm.getPriorVotes(voter, block.number);\n446:+        uint256 currentVotes = gohm.getPriorVotes(voter, block.number - 1);\n447:         uint256 votes = currentVotes > originalVotes ? originalVotes : currentVotes;\n```\n\n&nbsp;\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**haxatron** commented:\n> Medium. It would be caught immediately on deployment and implementation is upgradeable. There can be no loss of funds which is requisite of a high.\n\n\n\n**IllIllI000**\n\nAgree with haxatron that this is Medium, not High, based on Sherlock's rules\n\n**nevillehuang**\n\nCan agree, since this is purely a DoS, no malicious actions can be performed since no voting can be done anyways. \n\n@Czar102 I am interested in hearing your opinion, but I will set medium for now, because governance protocols fund loss impact is not obvious but I initially rated it high because it quite literally breaks the whole protocol. I believe sherlock needs to cater to different types of protocols and not only associate rules to defi/financial losses (example protocols include: governance, on chain social media protocols etc..)\n\n**0xLienid**\n\nFix: https://github.com/OlympusDAO/bophades/pull/293\n\n**IllIllI000**\n\nThe [PR](https://github.com/OlympusDAO/bophades/pull/293) follows the suggested recommendation and correctly modifies the only place that solely `block.number` is used, changing it to `block.number - 1`. The only place not using this value is the [call](https://github.com/sherlock-audit/2024-01-olympus-on-chain-governance/blob/6171681cfeec8a24b0449f988b75908b5e640a35/bophades/src/external/governance/GovernorBravoDelegate.sol#L445C59-L445C78) above it which uses `proposal.startBlock`. The `state()` when `startBlock` is equal to `block.number` is `ProposalState.Pending`, so this case will never cause problems, since there are checks of the [state](https://github.com/sherlock-audit/2024-01-olympus-on-chain-governance/blob/6171681cfeec8a24b0449f988b75908b5e640a35/bophades/src/external/governance/GovernorBravoDelegate.sol#L438). The PR also modifies the mock gOHM contract to mirror the behavior that caused the bug.\n\n**s1ce**\n\nEscalate\n\nThis is a high. Voting is a core part of a governance protocol, and this bricks all voting functionality. \n\n**sherlock-admin2**\n\n> Escalate\n> \n> This is a high. Voting is a core part of a governance protocol, and this bricks all voting functionality. \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**0xf1b0**\n\nBesides the fact that this issue breaks the core logic of the contract, _it won't be immediately detected upon deployment_, as previously mentioned as the reason for downgrading the severity. The voting process only becomes possible after a proposal has been made and time has elapsed. At this point, the issue will be raised, necessitating the deployment of an update. While the new version is being prepared, the proposal may expire, and a new one will have to be created. If the proposal includes some critical changes, this time delay can pose a serious problem.\n\n**IllIllI000**\n\nIgnore this part since, while true, it appears to be confusing some:\n~~The sponsor [mentioned](https://discord.com/channels/812037309376495636/1199005597035663520/1199639446585364480) this test file as where to look for how things will be deployed. The first action is to propose and start a vote for assigning the [whitelist guardian](https://github.com/sherlock-audit/2024-01-olympus-on-chain-governance/blob/6171681cfeec8a24b0449f988b75908b5e640a35/bophades/src/test/external/GovernorBravoDelegate.t.sol#L96-L100), and that will flag the issue before anything else.~~\n\nFurthermore, the timelock needs to [pull](https://github.com/sherlock-audit/2024-01-olympus-on-chain-governance/blob/6171681cfeec8a24b0449f988b75908b5e640a35/bophades/src/policies/RolesAdmin.sol#L86) in order to become and admin with access to the treasury. Until that happens, the existing admin has the power to do anything, so there's no case where something critical can't be done. The 'pull' requirement for transferring the admin to the timelock is a requirement of the code, not of the test. The Sherlock rules also state that opportunity costs (e.g. delays in voting `for example, due to a loss of core functionality`) do not count as a loss of funds.\n\n**r0ck3tzx**\n\nThe test file within `setUp()` function configures the environment for testing, not for the actual deployment. The deployment process can and probably will look different, so no assumptions should be made based on the test file. The mention just shows how the `whitelistGuardian` will be configured, and not at what time/stage it will be done.\n\nThe LSW creates hypotheticals about how the deployment process might look, and because of that, the issue would be caught early. Anyone who has ever deployed a protocol knows that the process is complex and often involves use of private mempools. Making assumptions about the deployment without having actual deployment scripts is dangerous and might lead to serious issues. \n\n**0xf1b0**\n\nEven though some proposals may be initiated at the time of deployment, it will take between 3 to 7 days before the issue becomes apparent, as voting will not be available until then.\n\n**nevillehuang**\n\nI agree with watsons here, but would have to respect the decision of @Czar102 and his enforcement of sherlock rules. Governance protocols already have nuances of funds loss being not obvious, and the whole protocol revolves around voting as the core mechanism, if you cannot vote, you essentially lose the purpose of the whole governance.\n\n**0xf1b0**\n\nI've seen a lot of discussion regarding the rule of funds at risk. It seems that they never take into account the lost profits. A scenario where the core functionality of the system is broken could result in a loss of confidence in the protocol, causing users to be hesitant about investing their money due to the fear of such an issue recurring.\n\n**Czar102**\n\nFrom my understanding, due to the fact that the timelock needs to pull, the new governance contract needs to call it. And since it's completely broken, it will never pull the admin rights.\n\nHence, this is not a high severity impact of locking funds and rights in a governance, but a medium severity issue since the contract fails to work. Is it accurate? @IllIllI000 \n\n**IllIllI000**\n\nYes, that's correct\n\n**Czar102**\n\nPlanning to reject the escalation and leave the issue as is.\n\n**0xf1b0**\n\nBy the way, it will not be possible to update the contract, because a new implementation can only be set through the voting process, which does not work.\n\nThat's at least 2 out of 3:\n- it won't be immediately detected upon deployment\n- it's not upgradeable\n\n**IllIllI000**\n\nit's being deployed fresh for this project, so it'll just be redeployed. The 2/3 stuff I [think](https://github.com/sherlock-protocol/sherlock-v2-docs/pull/19/files#diff-2ca8cda6feebe0aa72fbd8892f0f1435d2f8443da97cf8f60737b37965dd53acL35) you're referring to is for new contests\n\n**Czar102**\n\nResult:\nMedium\nHas duplicates\n\n**sherlock-admin**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [s1ce](https://github.com/sherlock-audit/2024-01-olympus-on-chain-governance-judging/issues/37/#issuecomment-1917427085): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/155",
  "Code": [
    {
      "filename": "bophades/src/external/governance/GovernorBravoDelegate.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.15;\n\nimport {IgOHM} from \"src/interfaces/IgOHM.sol\";\nimport {ITimelock} from \"./interfaces/ITimelock.sol\";\nimport {IGovernorBravoEventsAndErrors} from \"./interfaces/IGovernorBravoEvents.sol\";\n\nimport {GovernorBravoDelegateStorageV2} from \"./abstracts/GovernorBravoStorage.sol\";\n\nimport \"src/Kernel.sol\";\n\ncontract GovernorBravoDelegate is GovernorBravoDelegateStorageV2, IGovernorBravoEventsAndErrors {\n    // --- CONSTANTS ---------------------------------------------------------------\n\n    /// @notice The name of this contract\n    string public constant name = \"Olympus Governor Bravo\";\n\n    /// @notice The minimum setable proposal threshold\n    uint256 public constant MIN_PROPOSAL_THRESHOLD_PCT = 1_000; // 1% (out of 100_000)\n\n    /// @notice The maximum setable proposal threshold\n    uint256 public constant MAX_PROPOSAL_THRESHOLD_PCT = 90_000; // 90% (out of 100_000)\n\n    /// @notice The minimum setable voting period\n    uint256 public constant MIN_VOTING_PERIOD = 21600; // About 3 days (12s block time)\n\n    /// @notice The max setable voting period\n    uint256 public constant MAX_VOTING_PERIOD = 100800; // About 2 weeks (12s block time)\n\n    /// @notice The min setable voting delay\n    uint256 public constant MIN_VOTING_DELAY = 21600; // About 3 days (12s block time)\n\n    /// @notice The max setable voting delay\n    uint256 public constant MAX_VOTING_DELAY = 50400; // About 1 week (12s block time)\n\n    /// @notice The percentage of total supply in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n    /// @dev    Olympus has a variable supply system, that actively fluctuates fairly significantly, so it is better to use\n    ///         a percentage of total supply, rather than a fixed number of tokens.\n    uint256 public constant quorumPct = 20_000; // 20% (out of 100_000)\n\n    /// @notice The percentage of total supply in support of a proposal related to a high risk module in the Default system required\n    ///         in order for a quorum to be reached and for a vote to succeed\n    /// @dev    Olympus has a variable supply system, that actively fluctuates fairly significantly, so it is better to use\n    ///         a percentage of total supply, rather than a fixed number of tokens.\n    uint256 public constant highRiskQuorum = 30_000; // 30% (out of 100_000)\n\n    /// @notice The percentage of votes that must be in favor of a proposal for it to succeed\n    uint256 public constant approvalThresholdPct = 55_000; // 55% (out of 100_000)\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    uint256 public constant proposalMaxOperations = 10; // 10 actions\n\n    /// @notice The central hub of the Default Framework system that manages modules and policies\n    /// @dev    Used in this adaptation of Governor Bravo to identify high risk proposals\n    address public kernel;\n\n    /// @notice Modules in the Default system that are considered high risk\n    /// @dev    In Default Framework, Keycodes are used to uniquely identify modules. They are a\n    ///         wrapper over the bytes5 data type, and allow us to easily check if a proposal is\n    ///         touching any specific modules\n    mapping(Keycode => bool) public isKeycodeHighRisk;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,uint8 support)\");\n\n    // --- INITIALIZE --------------------------------------------------------------\n\n    /**\n     * @notice Used to initialize the contract during delegator constructor\n     * @param timelock_ The address of the Timelock\n     * @param gohm_ The address of the gOHM token\n     * @param kernel_ The address of the kernel\n     * @param votingPeriod_ The initial voting period\n     * @param votingDelay_ The initial voting delay\n     * @param proposalThreshold_ The initial proposal threshold (percentage of total supply. out of 1000)\n     */\n    function initialize(\n        address timelock_,\n        address gohm_,\n        address kernel_,\n        uint256 votingPeriod_,\n        uint256 votingDelay_,\n        uint256 proposalThreshold_\n    ) public virtual {\n        if (msg.sender != admin) revert GovernorBravo_OnlyAdmin();\n        if (address(timelock) != address(0)) revert GovernorBravo_AlreadyInitialized();\n        if (timelock_ == address(0) || gohm_ == address(0) || kernel_ == address(0))\n            revert GovernorBravo_AddressZero();\n        if (votingPeriod_ < MIN_VOTING_PERIOD || votingPeriod_ > MAX_VOTING_PERIOD)\n            revert GovernorBravo_InvalidPeriod();\n        if (votingDelay_ < MIN_VOTING_DELAY || votingDelay_ > MAX_VOTING_DELAY)\n            revert GovernorBravo_InvalidDelay();\n        if (\n            proposalThreshold_ < MIN_PROPOSAL_THRESHOLD_PCT ||\n            proposalThreshold_ > MAX_PROPOSAL_THRESHOLD_PCT\n        ) revert GovernorBravo_InvalidThreshold();\n\n        // Set up contract dependencies\n        timelock = ITimelock(timelock_);\n        gohm = IgOHM(gohm_);\n        kernel = kernel_;\n\n        // Configure voting parameters\n        vetoGuardian = msg.sender;\n        votingDelay = votingDelay_;\n        votingPeriod = votingPeriod_;\n        proposalThreshold = proposalThreshold_;\n        isKeycodeHighRisk[toKeycode(bytes5(\"TRSRY\"))] = true;\n        isKeycodeHighRisk[toKeycode(bytes5(\"MINTR\"))] = true;\n    }\n\n    // --- GOVERNANCE LOGIC --------------------------------------------------------\n\n    /**\n     * @notice Function used to propose a new proposal. Sender must have delegates above the proposal threshold\n     * @param targets Target addresses for proposal calls\n     * @param values Eth values for proposal calls\n     * @param signatures Function signatures for proposal calls\n     * @param calldatas Calldatas for proposal calls\n     * @param description String description of the proposal\n     * @return Proposal id of new proposal\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) public returns (uint256) {\n        // Allow addresses above proposal threshold and whitelisted addresses to propose\n        if (\n            gohm.getPriorVotes(msg.sender, block.number - 1) <= getProposalThresholdVotes() &&\n            !isWhitelisted(msg.sender)\n        ) revert GovernorBravo_Proposal_ThresholdNotMet();\n        if (\n            targets.length != values.length ||\n            targets.length != signatures.length ||\n            targets.length != calldatas.length\n        ) revert GovernorBravo_Proposal_LengthMismatch();\n        if (targets.length == 0) revert GovernorBravo_Proposal_NoActions();\n        if (targets.length > proposalMaxOperations) revert GovernorBravo_Proposal_TooManyActions();\n\n        uint256 latestProposalId = latestProposalIds[msg.sender];\n        if (latestProposalId != 0) {\n            ProposalState proposersLatestProposalState = state(latestProposalId);\n            if (proposersLatestProposalState == ProposalState.Active)\n                revert GovernorBravo_Proposal_AlreadyActive();\n            if (proposersLatestProposalState == ProposalState.Pending)\n                revert GovernorBravo_Proposal_AlreadyPending();\n        }\n\n        uint256 startBlock = block.number + votingDelay;\n        uint256 endBlock = startBlock + votingPeriod;\n\n        proposalCount++;\n        uint256 newProposalID = proposalCount;\n\n        {\n            // Given Olympus's dynamic supply, we need to capture quorum and proposal thresholds in terms\n            // of the total supply at the time of proposal creation.\n            uint256 quorumVotes;\n            uint256 proposalThresholdVotes = getProposalThresholdVotes();\n\n            // Identify the quorum level to use\n            if (_isHighRiskProposal(targets, signatures, calldatas)) {\n                quorumVotes = getHighRiskQuorumVotes();\n            } else {\n                quorumVotes = getQuorumVotes();\n            }\n\n            Proposal storage newProposal = proposals[newProposalID];\n            // This should never happen but add a check in case.\n            if (newProposal.id != 0) revert GovernorBravo_Proposal_IdCollision();\n\n            newProposal.id = newProposalID;\n            newProposal.proposer = msg.sender;\n            newProposal.proposalThreshold = proposalThresholdVotes;\n            newProposal.quorumVotes = quorumVotes;\n            newProposal.targets = targets;\n            newProposal.values = values;\n            newProposal.signatures = signatures;\n            newProposal.calldatas = calldatas;\n            newProposal.startBlock = startBlock;\n            newProposal.endBlock = endBlock;\n\n            latestProposalIds[newProposal.proposer] = newProposal.id;\n        }\n\n        emit ProposalCreated(\n            newProposalID,\n            msg.sender,\n            targets,\n            values,\n            signatures,\n            calldatas,\n            startBlock,\n            endBlock,\n            description\n        );\n        return newProposalID;\n    }\n\n    /**\n     * @notice Queues a successful proposal\n     * @param proposalId The id of the proposal to queue\n     */\n    function queue(uint256 proposalId) external {\n        if (state(proposalId) != ProposalState.Succeeded)\n            revert GovernorBravo_Queue_FailedProposal();\n\n        Proposal storage proposal = proposals[proposalId];\n        uint256 eta = block.timestamp + timelock.delay();\n\n        // Check that proposer has not fallen below proposal threshold since proposal creation\n        // If proposer is whitelisted, they can queue regardless of threshold\n        if (\n            !isWhitelisted(proposal.proposer) &&\n            gohm.getPriorVotes(proposal.proposer, block.number - 1) < proposal.proposalThreshold\n        ) revert GovernorBravo_Queue_BelowThreshold();\n\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            _queueOrRevertInternal(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                eta\n            );\n        }\n        proposal.eta = eta;\n        emit ProposalQueued(proposalId, eta);\n    }\n\n    function _queueOrRevertInternal(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        if (timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))))\n            revert GovernorBravo_Queue_AlreadyQueued();\n\n        timelock.queueTransaction(target, value, signature, data, eta);\n    }\n\n    /**\n     * @notice Executes a queued proposal if eta has passed\n     * @param proposalId The id of the proposal to execute\n     */\n    function execute(uint256 proposalId) external payable {\n        if (state(proposalId) != ProposalState.Queued) revert GovernorBravo_Execute_NotQueued();\n\n        Proposal storage proposal = proposals[proposalId];\n\n        // Check that proposer has not fallen below proposal threshold since proposal creation\n        // If proposer is whitelisted, they can execute regardless of threshold\n        if (\n            !isWhitelisted(proposal.proposer) &&\n            gohm.getPriorVotes(proposal.proposer, block.number - 1) < proposal.proposalThreshold\n        ) revert GovernorBravo_Execute_BelowThreshold();\n\n        proposal.executed = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.executeTransaction{value: proposal.values[i]}(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n        emit ProposalExecuted(proposalId);\n    }\n\n    /**\n     * @notice Cancels a proposal only if sender is the proposer, or proposer delegates dropped below proposal threshold\n     * @param proposalId The id of the proposal to cancel\n     */\n    function cancel(uint256 proposalId) external {\n        if (state(proposalId) == ProposalState.Executed)\n            revert GovernorBravo_Cancel_AlreadyExecuted();\n\n        Proposal storage proposal = proposals[proposalId];\n\n        // Proposer can cancel\n        if (msg.sender != proposal.proposer) {\n            // Whitelisted proposers can't be canceled for falling below proposal threshold\n            if (isWhitelisted(proposal.proposer)) {\n                if (\n                    (gohm.getPriorVotes(proposal.proposer, block.number - 1) >=\n                        proposal.proposalThreshold) || msg.sender != whitelistGuardian\n                ) revert GovernorBravo_Cancel_WhitelistedProposer();\n            } else {\n                if (\n                    gohm.getPriorVotes(proposal.proposer, block.number - 1) >=\n                    proposal.proposalThreshold\n                ) revert GovernorBravo_Cancel_AboveThreshold();\n            }\n        }\n\n        proposal.canceled = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.cancelTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n\n        emit ProposalCanceled(proposalId);\n    }\n\n    /**\n     * @notice Vetoes a proposal only if sender is the veto guardian\n     * @param proposalId The id of the proposal to veto\n     */\n    function veto(uint256 proposalId) external {\n        if (msg.sender != vetoGuardian) revert GovernorBravo_OnlyVetoGuardian();\n        if (state(proposalId) == ProposalState.Executed)\n            revert GovernorBravo_Veto_AlreadyExecuted();\n\n        Proposal storage proposal = proposals[proposalId];\n\n        proposal.vetoed = true;\n        for (uint256 i; i < proposal.targets.length; ) {\n            // If the proposal has been queued, cancel on the timelock\n            if (\n                timelock.queuedTransactions(\n                    keccak256(\n                        abi.encode(\n                            proposal.targets[i],\n                            proposal.values[i],\n                            proposal.signatures[i],\n                            proposal.calldatas[i],\n                            proposal.eta\n                        )\n                    )\n                )\n            ) {\n                timelock.cancelTransaction(\n                    proposal.targets[i],\n                    proposal.values[i],\n                    proposal.signatures[i],\n                    proposal.calldatas[i],\n                    proposal.eta\n                );\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ProposalVetoed(proposalId);\n    }\n\n    /**\n     * @notice Cast a vote for a proposal\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     */\n    function castVote(uint256 proposalId, uint8 support) external {\n        emit VoteCast(\n            msg.sender,\n            proposalId,\n            support,\n            castVoteInternal(msg.sender, proposalId, support),\n            \"\"\n        );\n    }\n\n    /**\n     * @notice Cast a vote for a proposal with a reason\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @param reason The reason given for the vote by the voter\n     */\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) external {\n        emit VoteCast(\n            msg.sender,\n            proposalId,\n            support,\n            castVoteInternal(msg.sender, proposalId, support),\n            reason\n        );\n    }\n\n    /**\n     * @notice Cast a vote for a proposal by signature\n     * @dev External function that accepts EIP-712 signatures for voting on proposals.\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        uint8 support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainIdInternal(), address(this))\n        );\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        if (signatory == address(0)) revert GovernorBravo_InvalidSignature();\n        emit VoteCast(\n            signatory,\n            proposalId,\n            support,\n            castVoteInternal(signatory, proposalId, support),\n            \"\"\n        );\n    }\n\n    /**\n     * @notice Internal function that caries out voting logic\n     * @param voter The voter that is casting their vote\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @return The number of votes cast\n     */\n    function castVoteInternal(\n        address voter,\n        uint256 proposalId,\n        uint8 support\n    ) internal returns (uint256) {\n        if (state(proposalId) != ProposalState.Active) revert GovernorBravo_Vote_Closed();\n        if (support > 2) revert GovernorBravo_Vote_InvalidType();\n        Proposal storage proposal = proposals[proposalId];\n        Receipt storage receipt = proposal.receipts[voter];\n        if (receipt.hasVoted) revert GovernorBravo_Vote_AlreadyCast();\n\n        // Get the user's votes at the start of the proposal and at the time of voting. Take the minimum.\n        uint256 originalVotes = gohm.getPriorVotes(voter, proposal.startBlock);\n        uint256 currentVotes = gohm.getPriorVotes(voter, block.number);\n        uint256 votes = currentVotes > originalVotes ? originalVotes : currentVotes;\n\n        if (support == 0) {\n            proposal.againstVotes = proposal.againstVotes + votes;\n        } else if (support == 1) {\n            proposal.forVotes = proposal.forVotes + votes;\n        } else if (support == 2) {\n            proposal.abstainVotes = proposal.abstainVotes + votes;\n        }\n\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = votes;\n\n        return votes;\n    }\n\n    // --- ADMIN FUNCTIONS ---------------------------------------------------------\n\n    /**\n     * @notice Admin function for setting the voting delay\n     * @param newVotingDelay new voting delay, in blocks\n     */\n    function _setVotingDelay(uint256 newVotingDelay) external {\n        if (msg.sender != admin) revert GovernorBravo_OnlyAdmin();\n        if (newVotingDelay < MIN_VOTING_DELAY || newVotingDelay > MAX_VOTING_DELAY)\n            revert GovernorBravo_InvalidDelay();\n\n        uint256 oldVotingDelay = votingDelay;\n        votingDelay = newVotingDelay;\n\n        emit VotingDelaySet(oldVotingDelay, votingDelay);\n    }\n\n    /**\n     * @notice Admin function for setting the voting period\n     * @param newVotingPeriod new voting period, in blocks\n     */\n    function _setVotingPeriod(uint256 newVotingPeriod) external {\n        if (msg.sender != admin) revert GovernorBravo_OnlyAdmin();\n        if (newVotingPeriod < MIN_VOTING_PERIOD || newVotingPeriod > MAX_VOTING_PERIOD)\n            revert GovernorBravo_InvalidPeriod();\n\n        uint256 oldVotingPeriod = votingPeriod;\n        votingPeriod = newVotingPeriod;\n\n        emit VotingPeriodSet(oldVotingPeriod, votingPeriod);\n    }\n\n    /**\n     * @notice Admin function for setting the proposal threshold\n     * @dev newProposalThreshold must be greater than the hardcoded min\n     * @param newProposalThreshold new proposal threshold\n     */\n    function _setProposalThreshold(uint256 newProposalThreshold) external {\n        if (msg.sender != admin) revert GovernorBravo_OnlyAdmin();\n        if (\n            newProposalThreshold < MIN_PROPOSAL_THRESHOLD_PCT ||\n            newProposalThreshold > MAX_PROPOSAL_THRESHOLD_PCT\n        ) revert GovernorBravo_InvalidThreshold();\n\n        uint256 oldProposalThreshold = proposalThreshold;\n        proposalThreshold = newProposalThreshold;\n\n        emit ProposalThresholdSet(oldProposalThreshold, proposalThreshold);\n    }\n\n    /**\n     * @notice Admin function for setting the whitelist expiration as a timestamp for an account. Whitelist status allows accounts to propose without meeting threshold\n     * @param account Account address to set whitelist expiration for\n     * @param expiration Expiration for account whitelist status as timestamp (if now < expiration, whitelisted)\n     */\n    function _setWhitelistAccountExpiration(address account, uint256 expiration) external {\n        if (msg.sender != admin && msg.sender != whitelistGuardian)\n            revert GovernorBravo_OnlyAdmin();\n        whitelistAccountExpirations[account] = expiration;\n\n        emit WhitelistAccountExpirationSet(account, expiration);\n    }\n\n    /**\n     * @notice Admin function for setting the whitelistGuardian. WhitelistGuardian can cancel proposals from whitelisted addresses\n     * @param account Account to set whitelistGuardian to (0x0 to remove whitelistGuardian)\n     */\n    function _setWhitelistGuardian(address account) external {\n        if (msg.sender != admin) revert GovernorBravo_OnlyAdmin();\n        address oldGuardian = whitelistGuardian;\n        whitelistGuardian = account;\n\n        emit WhitelistGuardianSet(oldGuardian, whitelistGuardian);\n    }\n\n    /**\n     * @notice Admin function for setting the vetoGuardian. vetoGuardian can veto any proposal\n     * @param account Account to set vetoGuardian to (0x0 to remove vetoGuardian)\n     */\n    function _setVetoGuardian(address account) external {\n        if (msg.sender != admin) revert GovernorBravo_OnlyAdmin();\n        address oldGuardian = vetoGuardian;\n        vetoGuardian = account;\n\n        emit VetoGuardianSet(oldGuardian, vetoGuardian);\n    }\n\n    /**\n     * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @param newPendingAdmin New pending admin.\n     */\n    function _setPendingAdmin(address newPendingAdmin) external {\n        // Check caller = admin\n        if (msg.sender != admin) revert GovernorBravo_OnlyAdmin();\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n    }\n\n    /**\n     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n     * @dev Admin function for pending admin to accept role and update admin\n     */\n    function _acceptAdmin() external {\n        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\n        if (msg.sender != pendingAdmin || msg.sender == address(0))\n            revert GovernorBravo_OnlyPendingAdmin();\n\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n\n        // Clear the pending value\n        pendingAdmin = address(0);\n\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n    }\n\n    /**\n     * @notice Sets whether a module is considered high risk\n     * @dev Admin function to set whether a module in the Default Framework is considered high risk\n     * @param module_ The module to set the risk of\n     * @param isHighRisk_ If the module is high risk\n     */\n    function _setModuleRiskLevel(bytes5 module_, bool isHighRisk_) external {\n        if (msg.sender != admin) revert GovernorBravo_OnlyAdmin();\n        isKeycodeHighRisk[toKeycode(module_)] = isHighRisk_;\n    }\n\n    // --- HELPER FUNCTIONS: INTERNAL ----------------------------------------------\n\n    /**\n     * @dev Checks if a proposal is high risk by identifying actions where the Default Framework kernel\n     *      is the target, if so, checking if it's installing or deactivating a policy, and if so,\n     *      checking if the policy is touching a high risk module.\n     */\n    function _isHighRiskProposal(\n        address[] memory targets,\n        string[] memory signatures,\n        bytes[] memory calldatas\n    ) internal returns (bool) {\n        // If proposal interacts with the kernel, and is touching a policy that interacts with\n        // a flagged module, then it is high risk.\n        uint256 numActions = targets.length;\n\n        for (uint256 i = 0; i < numActions; i++) {\n            address target = targets[i];\n            string memory signature = signatures[i];\n            bytes memory data = calldatas[i];\n\n            if (target == kernel) {\n                // Get function selector\n                bytes4 selector = bytes(signature).length == 0\n                    ? bytes4(data)\n                    : bytes4(keccak256(bytes(signature)));\n\n                // Check if the action is making a core change to system via the kernel\n                if (selector == Kernel.executeAction.selector) {\n                    uint8 action;\n                    address actionTarget;\n\n                    if (bytes(signature).length == 0 && data.length == 0x44) {\n                        assembly {\n                            action := mload(add(data, 0x24)) // accounting for length and selector in first 4 bytes\n                            actionTarget := mload(add(data, 0x44))\n                        }\n                    } else if (data.length == 0x40) {\n                        (action, actionTarget) = abi.decode(data, (uint8, address));\n                    } else {\n                        continue;\n                    }\n\n                    // If the action is upgrading a module (1)\n                    if (action == 1) {\n                        // Check if the module has a high risk keycode\n                        if (isKeycodeHighRisk[Module(actionTarget).KEYCODE()]) return true;\n                    }\n                    // If the action is installing (2) or deactivating (3) a policy, pull the list of dependencies\n                    else if (action == 2 || action == 3) {\n                        // Call `configureDependencies` on the policy\n                        Keycode[] memory dependencies = Policy(actionTarget)\n                            .configureDependencies();\n\n                        // Iterate over dependencies and looks for high risk keycodes\n                        uint256 numDeps = dependencies.length;\n                        for (uint256 j; j < numDeps; j++) {\n                            Keycode dep = dependencies[j];\n                            if (isKeycodeHighRisk[dep]) return true;\n                        }\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    // --- GETTER FUNCTIONS: SYSTEM ------------------------------------------------\n\n    /**\n     * @notice View function that gets the chain ID of the current network\n     * @return The chain ID\n     */\n    function getChainIdInternal() internal view returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n\n    /**\n     * @notice View function that gets the proposal threshold in number of gOHM based on current supply\n     * @return The proposal threshold in number of gOHM\n     */\n    function getProposalThresholdVotes() public view returns (uint256) {\n        return (gohm.totalSupply() * proposalThreshold) / 100_000;\n    }\n\n    /**\n     * @notice View function that gets the quorum in number of gOHM based on current supply\n     * @return The quorum in number of gOHM\n     */\n    function getQuorumVotes() public view returns (uint256) {\n        return (gohm.totalSupply() * quorumPct) / 100_000;\n    }\n\n    /**\n     * @notice View function that gets the high risk quorum in number of gOHM based on current supply\n     * @return The high risk quorum in number of gOHM\n     */\n    function getHighRiskQuorumVotes() public view returns (uint256) {\n        return (gohm.totalSupply() * highRiskQuorum) / 100_000;\n    }\n\n    /**\n     * @notice View function which returns if an account is whitelisted\n     * @param account Account to check white list status of\n     * @return If the account is whitelisted\n     */\n    function isWhitelisted(address account) public view returns (bool) {\n        return (whitelistAccountExpirations[account] > block.timestamp);\n    }\n\n    // --- GETTER FUNCTIONS: PROPOSAL ----------------------------------------------\n\n    /**\n     * @notice Gets the quorum required for a given proposal\n     * @param proposalId the id of the proposal\n     * @return The quorum required for the given proposal\n     */\n    function getProposalQuorum(uint256 proposalId) external view returns (uint256) {\n        return proposals[proposalId].quorumVotes;\n    }\n\n    /**\n     * @notice Gets the proposer votes threshold required for a given proposal\n     * @param proposalId the id of the proposal\n     * @return The proposer votes threshold required for the given proposal\n     */\n    function getProposalThreshold(uint256 proposalId) external view returns (uint256) {\n        return proposals[proposalId].proposalThreshold;\n    }\n\n    /**\n     * @notice Gets the eta value for a given proposal\n     * @param proposalId the id of the proposal\n     * @return The eta value for the given proposal\n     */\n    function getProposalEta(uint256 proposalId) external view returns (uint256) {\n        return proposals[proposalId].eta;\n    }\n\n    /**\n     * @notice Gets the against, for, and abstain votes for a given proposal\n     * @param proposalId the id of the proposal\n     * @return The against, for, and abstain votes for the given proposal\n     */\n    function getProposalVotes(\n        uint256 proposalId\n    ) external view returns (uint256, uint256, uint256) {\n        Proposal storage p = proposals[proposalId];\n        return (p.againstVotes, p.forVotes, p.abstainVotes);\n    }\n\n    /**\n     * @notice Gets actions of a proposal\n     * @param proposalId the id of the proposal\n     * @return targets of the proposal actions\n     * @return values of the proposal actions\n     * @return signatures of the proposal actions\n     * @return calldatas of the proposal actions\n     */\n    function getActions(\n        uint256 proposalId\n    )\n        external\n        view\n        returns (\n            address[] memory targets,\n            uint256[] memory values,\n            string[] memory signatures,\n            bytes[] memory calldatas\n        )\n    {\n        Proposal storage p = proposals[proposalId];\n        return (p.targets, p.values, p.signatures, p.calldatas);\n    }\n\n    /**\n     * @notice Gets the receipt for a voter on a given proposal\n     * @param proposalId the id of proposal\n     * @param voter The address of the voter\n     * @return The voting receipt\n     */\n    function getReceipt(uint256 proposalId, address voter) external view returns (Receipt memory) {\n        return proposals[proposalId].receipts[voter];\n    }\n\n    /**\n     * @notice Gets the voting outcome of the proposal\n     * @param proposalId the id of proposal\n     * @return The voting outcome\n     */\n    function getVoteOutcome(uint256 proposalId) public view returns (bool) {\n        Proposal storage proposal = proposals[proposalId];\n\n        if (proposal.forVotes == 0 && proposal.againstVotes == 0) {\n            return false;\n        } else if (\n            (proposal.forVotes * 100_000) / (proposal.forVotes + proposal.againstVotes) <\n            approvalThresholdPct ||\n            proposal.forVotes < proposal.quorumVotes\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Gets the state of a proposal\n     * @param proposalId The id of the proposal\n     * @return Proposal state\n     */\n    function state(uint256 proposalId) public view returns (ProposalState) {\n        if (proposalCount"
    }
  ]
}