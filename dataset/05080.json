{
  "Title": "[G-08] Use unchecked{} whenever underflow not possible (Instances Missed by bot)(Gas Saved ~320 Gas)",
  "Content": "\n**Note: Analyzer only talks about overflow errors so these underflow related instances also not covered by that** \n\n### Total Gas Saved : ~320 GAS in 2 Instances.\n\nBecause of previous condition check before the operation(-), it can be decided that underflow not possible.\n\n### Saves ~160  GAS per instance\n\n```solidity\nFile : src/libraries/PrincipalTokenUtil.sol\n\n73:    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {\n\n75:     newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate); //@audit due it's if condition it's subtraction can be unchecked\n  \n80:       if (_ibtRate >= _oldIBTRate) {\n        ...\n95:         } else {\n\n\n104:    uint256 expectedNegativeYieldInAssetRay = Math.ceilDiv(\n105:                        ibtOfPTInRay * (_oldIBTRate - _ibtRate), //@audit since it is in else so subtraction can be unchecked\n\n              ...  \n              }\n\n```\n(https://github.com/code-423n4/2024-02-spectra/blob/main/src/libraries/PrincipalTokenUtil.sol#L75C12-L75C86), (https://github.com/code-423n4/2024-02-spectra/blob/main/src/libraries/PrincipalTokenUtil.sol#L104C21-L105C65)\n\n```diff\nFile : src/libraries/PrincipalTokenUtil.sol\n\n-75:     newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);\n+        unchecked {\n+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;\n+        }\n+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);\n\n-104:    uint256 expectedNegativeYieldInAssetRay = Math.ceilDiv(\n-105:                        ibtOfPTInRay * (_oldIBTRate - _ibtRate),\n+        unchecked {\n+                uint256 oldIBTRateMinusIbtRate = _oldIBTRate - _ibtRate;\n+       }\n+        uint256 expectedNegativeYieldInAssetRay = Math.ceilDiv(\n+                            ibtOfPTInRay * (oldIBTRateMinusIbtRate),\n\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-02-spectra",
  "Code": [
    {
      "filename": "src/libraries/PrincipalTokenUtil.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.20;\n\nimport \"../interfaces/IYieldToken.sol\";\nimport \"../interfaces/IPrincipalToken.sol\";\nimport \"../interfaces/IRegistry.sol\";\nimport \"openzeppelin-contracts/interfaces/IERC4626.sol\";\nimport \"openzeppelin-math/Math.sol\";\nimport \"../libraries/RayMath.sol\";\n\nlibrary PrincipalTokenUtil {\n    using Math for uint256;\n    using RayMath for uint256;\n\n    error AssetDoesNotImplementMetadata();\n\n    uint256 private constant SAFETY_BOUND = 100; // used to favour the protocol in case of approximations\n    uint256 private constant FEE_DIVISOR = 1e18; // equivalent to 100% fees\n\n    /** @dev See {IPrincipalToken-convertToSharesWithRate}. */\n    function _convertToSharesWithRate(\n        uint256 _assets,\n        uint256 _rate,\n        uint256 _ibtUnit,\n        Math.Rounding _rounding\n    ) internal pure returns (uint256 shares) {\n        if (_rate == 0) {\n            revert IPrincipalToken.RateError();\n        }\n        return _assets.mulDiv(_ibtUnit, _rate, _rounding);\n    }\n\n    /** @dev See {IPrincipalToken-convertToAssetsWithRate}. */\n    function _convertToAssetsWithRate(\n        uint256 _shares,\n        uint256 _rate,\n        uint256 _ibtUnit,\n        Math.Rounding _rounding\n    ) internal pure returns (uint256 assets) {\n        return _shares.mulDiv(_rate, _ibtUnit, _rounding);\n    }\n\n    /**\n     * @dev Computes the yield for a specified user since the last update.\n     * @param _user The address for which the yield is to be calculated.\n     * @param _userYieldIBT the current yield of user in IBT\n     * @param _oldIBTRate the previous deposit IBT rate of user (in Ray)\n     * @param _ibtRate the current IBT rate (in Ray)\n     * @param _oldPTRate the previous deposit pt rate of user (in Ray)\n     * @param _ptRate the current PT rate (in Ray)\n     * @param _yt the address of YT\n     * @return returns the calculated yield in IBT of user\n     */\n    function _computeYield(\n        address _user,\n        uint256 _userYieldIBT,\n        uint256 _oldIBTRate,\n        uint256 _ibtRate,\n        uint256 _oldPTRate,\n        uint256 _ptRate,\n        address _yt\n    ) external view returns (uint256) {\n        if (_oldPTRate == _ptRate && _ibtRate == _oldIBTRate) {\n            return _userYieldIBT;\n        }\n        uint256 newYieldInIBTRay;\n        uint256 userYTBalanceInRay = IYieldToken(_yt).actualBalanceOf(_user).toRay(\n            IYieldToken(_yt).decimals()\n        );\n        // ibtOfPT is the yield generated by each PT corresponding to the YTs that the user holds\n        uint256 ibtOfPTInRay = userYTBalanceInRay.mulDiv(_oldPTRate, _oldIBTRate);\n        if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {\n            // only positive yield happened\n            newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);\n        } else {\n            if (_oldPTRate > _ptRate) {\n                // PT depeg happened\n                uint256 yieldInAssetRay;\n                if (_ibtRate >= _oldIBTRate) {\n                    // both negative and positive yield happened, more positive\n                    yieldInAssetRay =\n                        _convertToAssetsWithRate(\n                            userYTBalanceInRay,\n                            _oldPTRate - _ptRate,\n                            RayMath.RAY_UNIT,\n                            Math.Rounding.Floor\n                        ) +\n                        _convertToAssetsWithRate(\n                            ibtOfPTInRay,\n                            _ibtRate - _oldIBTRate,\n                            RayMath.RAY_UNIT,\n                            Math.Rounding.Floor\n                        );\n                } else {\n                    // either both negative and positive yield happened, more negative\n                    // or only negative yield happened\n                    uint256 actualNegativeYieldInAssetRay = _convertToAssetsWithRate(\n                        userYTBalanceInRay,\n                        _oldPTRate - _ptRate,\n                        RayMath.RAY_UNIT,\n                        Math.Rounding.Floor\n                    );\n                    uint256 expectedNegativeYieldInAssetRay = Math.ceilDiv(\n                        ibtOfPTInRay * (_oldIBTRate - _ibtRate),\n                        RayMath.RAY_UNIT\n                    );\n                    yieldInAssetRay = expectedNegativeYieldInAssetRay >\n                        actualNegativeYieldInAssetRay\n                        ? 0\n                        : actualNegativeYieldInAssetRay - expectedNegativeYieldInAssetRay;\n                    yieldInAssetRay = yieldInAssetRay.fromRay(\n                        IERC4626(IPrincipalToken(IYieldToken(_yt).getPT()).underlying()).decimals()\n                    ) < SAFETY_BOUND\n                        ? 0\n                        : yieldInAssetRay;\n                }\n                newYieldInIBTRay = _convertToSharesWithRate(\n                    yieldInAssetRay,\n                    _ibtRate,\n                    RayMath.RAY_UNIT,\n                    Math.Rounding.Floor\n                );\n            } else {\n                // PT rate increased or did not depeg on IBT rate decrease\n                revert IPrincipalToken.RateError();\n            }\n        }\n        return _userYieldIBT + newYieldInIBTRay.fromRay(IERC20Metadata(_yt).decimals());\n    }\n\n    /**\n     * @dev Attempts to fetch the token decimals. Reverts if the attempt failed in some way.\n     * @param _token The token address\n     * @return The ERC20 token decimals\n     */\n    function _tryGetTokenDecimals(address _token) external view returns (uint8) {\n        (bool success, bytes memory encodedDecimals) = _token.staticcall(\n            abi.encodeCall(IERC20Metadata.decimals, ())\n        );\n        if (success && encodedDecimals.length >= 32) {\n            uint256 returnedDecimals = abi.decode(encodedDecimals, (uint256));\n            if (returnedDecimals <= type(uint8).max) {\n                return uint8(returnedDecimals);\n            }\n        }\n        revert AssetDoesNotImplementMetadata();\n    }\n\n    /**\n     * @dev Compute tokenization fee for a given amount\n     * @param _amount The amount to tokenize\n     * @param _pt The address of the pt on which the fee is being paid\n     * @param _registry The address of registry that stores fee rate\n     * @return returns The calculated tokenization fee\n     */\n    function _computeTokenizationFee(\n        uint256 _amount,\n        address _pt,\n        address _registry\n    ) internal view returns (uint256) {\n        return\n            _amount\n                .mulDiv(IRegistry(_registry).getTokenizationFee(), FEE_DIVISOR, Math.Rounding.Ceil)\n                .mulDiv(\n                    FEE_DIVISOR - IRegistry(_registry).getFeeReduction(_pt, msg.sender),\n                    FEE_DIVISOR,\n                    Math.Rounding.Ceil\n                );\n    }\n\n    /**\n     * @dev Compute yield fee for a given amount\n     * @param _amount the amount of yield\n     * @param _registry the address of registry that stores fee rate\n     * @return returns the calculated yield fee\n     */\n    function _computeYieldFee(uint256 _amount, address _registry) internal view returns (uint256) {\n        return _amount.mulDiv(IRegistry(_registry).getYieldFee(), FEE_DIVISOR, Math.Rounding.Ceil);\n    }\n\n    /**\n     * @dev Compute flashloan fee for a given amount\n     * @param _amount the amount to flashloan\n     * @param _registry the address of registry that stores fee rate\n     * @return returns the calculated flashloan fee\n     */\n    function _computeFlashloanFee(\n        uint256 _amount,\n        address _registry\n    ) internal view returns (uint256) {\n        return\n            _amount.mulDiv(\n                IRegistry(_registry).getPTFlashLoanFee(),\n                FEE_DIVISOR,\n                Math.Rounding.Ceil\n            );\n    }\n}"
    }
  ]
}