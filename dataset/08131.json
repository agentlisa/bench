{
  "Title": "[M-23] Treasury module is vulnerable to cross-contract reentrancy",
  "Content": "_Submitted by Czar102_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/TRSRY.sol#L108-L112><br>\n\nAn attacker can pay back their loan to the treasury module with protocol-owned tokens. This will cause their loan to decrease despite the protocol won't be given funds for it.\n\n### Proof of Concept\n\nThe code first measures the number of tokens in the treasury, then transfers an amount to the contract and checks the change it caused. This is put behind a nonReentrant modifier so that one can't use the same balance change to pay back multiple parts of (potentially) multiple loans.\n\nThe problem arises when the treasury doesn't only claim tokens from paying back loans, but also claims protocol revenue. Since, an attacker can gain execution in the moment the funds are pulled to the treasury to trigger any function that grants treasury this type of tokens (collects protocol revenue). The contract will count these tokens as paying back one's loan since this happened between balance measurements.\n\n### Recommended Mitigation Steps\n\nAdd a function used to pull a token to the contract and mark it nonReentrant. Any transfer of tokens to the treasury should be done through that function.\n\n**[ind-igo (Olympus) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/426#issuecomment-1240219578):**\n > I am confused by this submission. Need more information.\n\n**[ind-igo (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/426#issuecomment-1244569278):**\n > Spoke with Czar, solution for minimal change is adding `received = min(received, amount_); `. Confirming issue.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-08-olympus-dao-contest",
  "Code": [
    {
      "filename": "src/modules/TRSRY.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\n\nimport {TransferHelper} from \"libraries/TransferHelper.sol\";\n\nimport \"src/Kernel.sol\";\n\n// ERRORS\nerror TRSRY_NotApproved();\nerror TRSRY_NoDebtOutstanding();\n\n/// @notice Treasury holds reserves, LP tokens and all other assets under the control\n///         of the protocol.\ncontract OlympusTreasury is Module, ReentrancyGuard {\n    using TransferHelper for ERC20;\n\n    event ApprovedForWithdrawal(address indexed policy_, ERC20 indexed token_, uint256 amount_);\n    event Withdrawal(\n        address indexed policy_,\n        address indexed withdrawer_,\n        ERC20 indexed token_,\n        uint256 amount_\n    );\n    event DebtIncurred(ERC20 indexed token_, address indexed policy_, uint256 amount_);\n    event DebtRepaid(ERC20 indexed token_, address indexed policy_, uint256 amount_);\n    event DebtSet(ERC20 indexed token_, address indexed policy_, uint256 amount_);\n\n    /// @notice Mapping of who is approved for withdrawal.\n    /// @dev    withdrawer -> token -> amount. Infinite approval is max(uint256).\n    mapping(address => mapping(ERC20 => uint256)) public withdrawApproval;\n\n    /// @notice Total debt for token across all withdrawals.\n    mapping(ERC20 => uint256) public totalDebt;\n\n    /// @notice Debt for particular token and debtor address\n    mapping(ERC20 => mapping(address => uint256)) public reserveDebt;\n\n    /*//////////////////////////////////////////////////////////////\n                            MODULE INTERFACE\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(Kernel kernel_) Module(kernel_) {}\n\n    function KEYCODE() public pure override returns (Keycode) {\n        return toKeycode(\"TRSRY\");\n    }\n\n    function VERSION() external pure override returns (uint8 major, uint8 minor) {\n        return (1, 0);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CORE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function getReserveBalance(ERC20 token_) external view returns (uint256) {\n        return token_.balanceOf(address(this)) + totalDebt[token_];\n    }\n\n    /// @notice Sets approval for specific withdrawer addresses\n    function setApprovalFor(\n        address withdrawer_,\n        ERC20 token_,\n        uint256 amount_\n    ) external permissioned {\n        withdrawApproval[withdrawer_][token_] = amount_;\n\n        emit ApprovedForWithdrawal(withdrawer_, token_, amount_);\n    }\n\n    /// @notice Allow withdrawal of reserve funds from pre-approved addresses.\n    function withdrawReserves(\n        address to_,\n        ERC20 token_,\n        uint256 amount_\n    ) public {\n        _checkApproval(msg.sender, token_, amount_);\n\n        token_.safeTransfer(to_, amount_);\n\n        emit Withdrawal(msg.sender, to_, token_, amount_);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             DEBT FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Pre-approved policies can get a loan to perform operations on treasury assets.\n    function getLoan(ERC20 token_, uint256 amount_) external permissioned {\n        _checkApproval(msg.sender, token_, amount_);\n\n        // Add debt to caller\n        reserveDebt[token_][msg.sender] += amount_;\n        totalDebt[token_] += amount_;\n\n        token_.safeTransfer(msg.sender, amount_);\n\n        emit DebtIncurred(token_, msg.sender, amount_);\n    }\n\n    /// @notice Lets an address with debt repay their loan.\n    function repayLoan(ERC20 token_, uint256 amount_) external nonReentrant {\n        if (reserveDebt[token_][msg.sender] == 0) revert TRSRY_NoDebtOutstanding();\n\n        // Deposit from caller first (to handle nonstandard token transfers)\n        uint256 prevBalance = token_.balanceOf(address(this));\n        token_.safeTransferFrom(msg.sender, address(this), amount_);\n\n        uint256 received = token_.balanceOf(address(this)) - prevBalance;\n\n        // Subtract debt from caller\n        reserveDebt[token_][msg.sender] -= received;\n        totalDebt[token_] -= received;\n\n        emit DebtRepaid(token_, msg.sender, received);\n    }\n\n    /// @notice An escape hatch for setting debt in special cases, like swapping reserves to another token.\n    function setDebt(\n        ERC20 token_,\n        address debtor_,\n        uint256 amount_\n    ) external permissioned {\n        uint256 oldDebt = reserveDebt[token_][debtor_];\n\n        reserveDebt[token_][debtor_] = amount_;\n\n        if (oldDebt < amount_) totalDebt[token_] += amount_ - oldDebt;\n        else totalDebt[token_] -= oldDebt - amount_;\n\n        emit DebtSet(token_, debtor_, amount_);\n    }\n\n    function _checkApproval(\n        address withdrawer_,\n        ERC20 token_,\n        uint256 amount_\n    ) internal {\n        // Must be approved\n        uint256 approval = withdrawApproval[withdrawer_][token_];\n        if (approval < amount_) revert TRSRY_NotApproved();\n\n        // Check for infinite approval\n        if (approval != type(uint256).max) {\n            unchecked {\n                withdrawApproval[withdrawer_][token_] = approval - amount_;\n            }\n        }\n    }\n}"
    }
  ]
}