{
  "Title": "[05] Trust in Deployer - No guarantee that base will be `totalSupply`",
  "Content": "[TribeRedeemer.sol#L34-L35](https://github.com/code-423n4/2022-09-tribe/blob/769b0586b4975270b669d7d1581aa5672d6999d5/contracts/shutdown/redeem/TribeRedeemer.sol#L34-L35)\n\n```solidity\n        redeemBase = _redeemBase;\n\n```\n\nBecause `redeemedToken` is known, you could just retrieve the `totalSupply` from it to ensure the claims are for all tokens available.\n\nEnd users will have to verify that `redeemBase` is consistent with the Circulating Supply.\n\n### Mitigation Steps\n\nComment and let end users know of this, or use `totalSupply` from the token.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-09-tribe",
  "Code": [
    {
      "filename": "contracts/shutdown/redeem/TribeRedeemer.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport {IERC20, SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/// @title contract used to redeem a list of tokens, by permanently\n/// taking another token out of circulation.\n/// @author Fei Protocol\ncontract TribeRedeemer is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    /// @notice event to track redemptions\n    event Redeemed(address indexed owner, address indexed receiver, uint256 amount, uint256 base);\n\n    /// @notice token to redeem\n    address public immutable redeemedToken;\n\n    /// @notice tokens to receive when redeeming\n    address[] private tokensReceived;\n\n    /// @notice base used to compute the redemption amounts.\n    /// For instance, if the base is 100, and a user provides 100 `redeemedToken`,\n    /// they will receive all the balances of each `tokensReceived` held on this contract.\n    uint256 public redeemBase;\n\n    constructor(\n        address _redeemedToken,\n        address[] memory _tokensReceived,\n        uint256 _redeemBase\n    ) {\n        redeemedToken = _redeemedToken;\n        tokensReceived = _tokensReceived;\n        redeemBase = _redeemBase;\n    }\n\n    /// @notice Public function to get `tokensReceived`\n    function tokensReceivedOnRedeem() public view returns (address[] memory) {\n        return tokensReceived;\n    }\n\n    /// @notice Return the balances of `tokensReceived` that would be\n    /// transferred if redeeming `amountIn` of `redeemedToken`.\n    function previewRedeem(uint256 amountIn)\n        public\n        view\n        returns (address[] memory tokens, uint256[] memory amountsOut)\n    {\n        tokens = tokensReceivedOnRedeem();\n        amountsOut = new uint256[](tokens.length);\n\n        uint256 base = redeemBase;\n        for (uint256 i = 0; i < tokensReceived.length; i++) {\n            uint256 balance = IERC20(tokensReceived[i]).balanceOf(address(this));\n            require(balance != 0, \"ZERO_BALANCE\");\n            // @dev, this assumes all of `tokensReceived` and `redeemedToken`\n            // have the same number of decimals\n            uint256 redeemedAmount = (amountIn * balance) / base;\n            amountsOut[i] = redeemedAmount;\n        }\n    }\n\n    /// @notice Redeem `redeemedToken` for a pro-rata basket of `tokensReceived`\n    function redeem(address to, uint256 amountIn) external nonReentrant {\n        IERC20(redeemedToken).safeTransferFrom(msg.sender, address(this), amountIn);\n\n        (address[] memory tokens, uint256[] memory amountsOut) = previewRedeem(amountIn);\n\n        uint256 base = redeemBase;\n        redeemBase = base - amountIn; // decrement the base for future redemptions\n        for (uint256 i = 0; i < tokens.length; i++) {\n            IERC20(tokens[i]).safeTransfer(to, amountsOut[i]);\n        }\n\n        emit Redeemed(msg.sender, to, amountIn, base);\n    }\n}"
    }
  ]
}