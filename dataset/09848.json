{
  "Title": "[N-01] money-market-contracts: Market max\\_borrow\\_factor is not capped",
  "Content": "\n### Line References\n\n<https://github.com/code-423n4/2022-02-anchor/blob/main/contracts/money-market-contracts/contracts/market/src/contract.rs#L66>\n\n<https://github.com/code-423n4/2022-02-anchor/blob/main/contracts/money-market-contracts/contracts/market/src/contract.rs#L321-L323>\n\n### Description\n\nThere is no check to ensure that `max_borrow_factor` is less than 100% (`Decimal::One()`). It is therefore possible to set a borrow factor of > 1. However, the consequence of it is negligible because it would be the same as setting the value to 100% (can’t borrow if there is no liquidity left).\n\n### Proof of Concept\n\nChange the instantiation and update config test values to a value greater than 100%, such as `Decimal256::MAX`.\n\n<https://github.com/code-423n4/2022-02-anchor/blob/main/contracts/money-market-contracts/contracts/market/src/testing/tests.rs#L36>\n\n```rust\nlet msg = InstantiateMsg {\n  owner_addr: \"owner\".to_string(),\n  stable_denom: \"uusd\".to_string(),\n  aterra_code_id: 123u64,\n  anc_emission_rate: Decimal256::one(),\n  max_borrow_factor: Decimal256::MAX,\n};\n```\n\n<https://github.com/code-423n4/2022-02-anchor/blob/main/contracts/money-market-contracts/contracts/market/src/testing/tests.rs#L215>\n\n```rust\nlet msg = ExecuteMsg::UpdateConfig {\n  owner_addr: None,\n  interest_model: Some(\"interest2\".to_string()),\n  distribution_model: Some(\"distribution2\".to_string()),\n  max_borrow_factor: Some(Decimal256::percent(120)),\n};\n```\n\n### Recommended Mitigation Steps\n\nEnsure `max_borrow_factor` doesn’t exceed `Decimal256::one()`.\n\n```rust\n// add error in market/src/error.rs\npub enum ContractError {\n  #[error(\"Setting greater than theoretical borrow factor\")]\n  MaxTheoreticalBorrowFactorExceeded {},\n  ...\n}\n\n// in market/src/contract.rs\n// before store_config() in L54\nif msg.max_borrow_factor > Decimal256::one() {\n  return Err(ContractError::MaxTheoreticalBorrowFactorExceeded {});\n}\n\n// in update_config()\nif let Some(max_borrow_factor) = max_borrow_factor {\n  if max_borrow_factor > Decimal256::one() {\n    return Err(ContractError::MaxTheoreticalBorrowFactorExceeded {});\n  }\n  config.max_borrow_factor = max_borrow_factor;\n}\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-02-anchor",
  "Code": [
    {
      "filename": "contracts/money-market-contracts/contracts/market/src/contract.rs",
      "content": "#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\n\nuse crate::borrow::{\n    borrow_stable, claim_rewards, compute_interest, compute_interest_raw, compute_reward,\n    query_borrower_info, query_borrower_infos, repay_stable, repay_stable_from_liquidation,\n};\nuse crate::deposit::{compute_exchange_rate_raw, deposit_stable, redeem_stable};\nuse crate::error::ContractError;\nuse crate::querier::{query_anc_emission_rate, query_borrow_rate, query_target_deposit_rate};\nuse crate::response::MsgInstantiateContractResponse;\nuse crate::state::{read_config, read_state, store_config, store_state, Config, State};\n\nuse cosmwasm_bignumber::{Decimal256, Uint256};\nuse cosmwasm_std::{\n    attr, from_binary, to_binary, Addr, BankMsg, Binary, CanonicalAddr, Coin, CosmosMsg, Deps,\n    DepsMut, Env, MessageInfo, Reply, Response, StdError, StdResult, SubMsg, Uint128, WasmMsg,\n};\nuse cw20::{Cw20Coin, Cw20ReceiveMsg, MinterResponse};\n\nuse moneymarket::common::optional_addr_validate;\nuse moneymarket::interest_model::BorrowRateResponse;\nuse moneymarket::market::{\n    ConfigResponse, Cw20HookMsg, EpochStateResponse, ExecuteMsg, InstantiateMsg, QueryMsg,\n    StateResponse,\n};\nuse moneymarket::querier::{deduct_tax, query_balance, query_supply};\nuse protobuf::Message;\nuse terraswap::token::InstantiateMsg as TokenInstantiateMsg;\n\npub const INITIAL_DEPOSIT_AMOUNT: u128 = 1000000;\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: InstantiateMsg,\n) -> Result<Response, ContractError> {\n    let initial_deposit = info\n        .funds\n        .iter()\n        .find(|c| c.denom == msg.stable_denom)\n        .map(|c| c.amount)\n        .unwrap_or_else(Uint128::zero);\n\n    if initial_deposit != Uint128::from(INITIAL_DEPOSIT_AMOUNT) {\n        return Err(ContractError::InitialFundsNotDeposited(\n            INITIAL_DEPOSIT_AMOUNT,\n            msg.stable_denom,\n        ));\n    }\n\n    store_config(\n        deps.storage,\n        &Config {\n            contract_addr: deps.api.addr_canonicalize(env.contract.address.as_str())?,\n            owner_addr: deps.api.addr_canonicalize(&msg.owner_addr)?,\n            aterra_contract: CanonicalAddr::from(vec![]),\n            overseer_contract: CanonicalAddr::from(vec![]),\n            interest_model: CanonicalAddr::from(vec![]),\n            distribution_model: CanonicalAddr::from(vec![]),\n            collector_contract: CanonicalAddr::from(vec![]),\n            distributor_contract: CanonicalAddr::from(vec![]),\n            stable_denom: msg.stable_denom.clone(),\n            max_borrow_factor: msg.max_borrow_factor,\n        },\n    )?;\n\n    store_state(\n        deps.storage,\n        &State {\n            total_liabilities: Decimal256::zero(),\n            total_reserves: Decimal256::zero(),\n            last_interest_updated: env.block.height,\n            last_reward_updated: env.block.height,\n            global_interest_index: Decimal256::one(),\n            global_reward_index: Decimal256::zero(),\n            anc_emission_rate: msg.anc_emission_rate,\n            prev_aterra_supply: Uint256::zero(),\n            prev_exchange_rate: Decimal256::one(),\n        },\n    )?;\n\n    Ok(\n        Response::new().add_submessages(vec![SubMsg::reply_on_success(\n            CosmosMsg::Wasm(WasmMsg::Instantiate {\n                admin: None,\n                code_id: msg.aterra_code_id,\n                funds: vec![],\n                label: \"\".to_string(),\n                msg: to_binary(&TokenInstantiateMsg {\n                    name: format!(\"Anchor Terra {}\", msg.stable_denom[1..].to_uppercase()),\n                    symbol: format!(\n                        \"a{}T\",\n                        msg.stable_denom[1..(msg.stable_denom.len() - 1)].to_uppercase()\n                    ),\n                    decimals: 6u8,\n                    initial_balances: vec![Cw20Coin {\n                        address: env.contract.address.to_string(),\n                        amount: Uint128::from(INITIAL_DEPOSIT_AMOUNT),\n                    }],\n                    mint: Some(MinterResponse {\n                        minter: env.contract.address.to_string(),\n                        cap: None,\n                    }),\n                })?,\n            }),\n            1,\n        )]),\n    )\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -> Result<Response, ContractError> {\n    match msg {\n        ExecuteMsg::Receive(msg) => receive_cw20(deps, env, info, msg),\n        ExecuteMsg::RegisterContracts {\n            overseer_contract,\n            interest_model,\n            distribution_model,\n            collector_contract,\n            distributor_contract,\n        } => {\n            let api = deps.api;\n            register_contracts(\n                deps,\n                api.addr_validate(&overseer_contract)?,\n                api.addr_validate(&interest_model)?,\n                api.addr_validate(&distribution_model)?,\n                api.addr_validate(&collector_contract)?,\n                api.addr_validate(&distributor_contract)?,\n            )\n        }\n        ExecuteMsg::UpdateConfig {\n            owner_addr,\n            interest_model,\n            distribution_model,\n            max_borrow_factor,\n        } => {\n            let api = deps.api;\n            update_config(\n                deps,\n                env,\n                info,\n                optional_addr_validate(api, owner_addr)?,\n                optional_addr_validate(api, interest_model)?,\n                optional_addr_validate(api, distribution_model)?,\n                max_borrow_factor,\n            )\n        }\n        ExecuteMsg::ExecuteEpochOperations {\n            deposit_rate,\n            target_deposit_rate,\n            threshold_deposit_rate,\n            distributed_interest,\n        } => execute_epoch_operations(\n            deps,\n            env,\n            info,\n            deposit_rate,\n            target_deposit_rate,\n            threshold_deposit_rate,\n            distributed_interest,\n        ),\n        ExecuteMsg::DepositStable {} => deposit_stable(deps, env, info),\n        ExecuteMsg::BorrowStable { borrow_amount, to } => {\n            let api = deps.api;\n            borrow_stable(\n                deps,\n                env,\n                info,\n                borrow_amount,\n                optional_addr_validate(api, to)?,\n            )\n        }\n        ExecuteMsg::RepayStable {} => repay_stable(deps, env, info),\n        ExecuteMsg::RepayStableFromLiquidation {\n            borrower,\n            prev_balance,\n        } => {\n            let api = deps.api;\n            repay_stable_from_liquidation(\n                deps,\n                env,\n                info,\n                api.addr_validate(&borrower)?,\n                prev_balance,\n            )\n        }\n        ExecuteMsg::ClaimRewards { to } => {\n            let api = deps.api;\n            claim_rewards(deps, env, info, optional_addr_validate(api, to)?)\n        }\n    }\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn reply(deps: DepsMut, _env: Env, msg: Reply) -> Result<Response, ContractError> {\n    match msg.id {\n        1 => {\n            // get new token's contract address\n            let res: MsgInstantiateContractResponse = Message::parse_from_bytes(\n                msg.result.unwrap().data.unwrap().as_slice(),\n            )\n            .map_err(|_| {\n                ContractError::Std(StdError::parse_err(\n                    \"MsgInstantiateContractResponse\",\n                    \"failed to parse data\",\n                ))\n            })?;\n            let token_addr = Addr::unchecked(res.get_contract_address());\n\n            register_aterra(deps, token_addr)\n        }\n        _ => Err(ContractError::InvalidReplyId {}),\n    }\n}\n\npub fn receive_cw20(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    cw20_msg: Cw20ReceiveMsg,\n) -> Result<Response, ContractError> {\n    let contract_addr = info.sender;\n    match from_binary(&cw20_msg.msg) {\n        Ok(Cw20HookMsg::RedeemStable {}) => {\n            // only asset contract can execute this message\n            let config: Config = read_config(deps.storage)?;\n            if deps.api.addr_canonicalize(contract_addr.as_str())? != config.aterra_contract {\n                return Err(ContractError::Unauthorized {});\n            }\n\n            let cw20_sender_addr = deps.api.addr_validate(&cw20_msg.sender)?;\n            redeem_stable(deps, env, cw20_sender_addr, cw20_msg.amount)\n        }\n        _ => Err(ContractError::MissingRedeemStableHook {}),\n    }\n}\n\npub fn register_aterra(deps: DepsMut, token_addr: Addr) -> Result<Response, ContractError> {\n    let mut config: Config = read_config(deps.storage)?;\n    if config.aterra_contract != CanonicalAddr::from(vec![]) {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    config.aterra_contract = deps.api.addr_canonicalize(token_addr.as_str())?;\n    store_config(deps.storage, &config)?;\n\n    Ok(Response::new().add_attributes(vec![attr(\"aterra\", token_addr)]))\n}\n\npub fn register_contracts(\n    deps: DepsMut,\n    overseer_contract: Addr,\n    interest_model: Addr,\n    distribution_model: Addr,\n    collector_contract: Addr,\n    distributor_contract: Addr,\n) -> Result<Response, ContractError> {\n    let mut config: Config = read_config(deps.storage)?;\n    if config.overseer_contract != CanonicalAddr::from(vec![])\n        || config.interest_model != CanonicalAddr::from(vec![])\n        || config.distribution_model != CanonicalAddr::from(vec![])\n        || config.collector_contract != CanonicalAddr::from(vec![])\n        || config.distributor_contract != CanonicalAddr::from(vec![])\n    {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    config.overseer_contract = deps.api.addr_canonicalize(overseer_contract.as_str())?;\n    config.interest_model = deps.api.addr_canonicalize(interest_model.as_str())?;\n    config.distribution_model = deps.api.addr_canonicalize(distribution_model.as_str())?;\n    config.collector_contract = deps.api.addr_canonicalize(collector_contract.as_str())?;\n    config.distributor_contract = deps.api.addr_canonicalize(distributor_contract.as_str())?;\n    store_config(deps.storage, &config)?;\n\n    Ok(Response::default())\n}\n\npub fn update_config(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    owner_addr: Option<Addr>,\n    interest_model: Option<Addr>,\n    distribution_model: Option<Addr>,\n    max_borrow_factor: Option<Decimal256>,\n) -> Result<Response, ContractError> {\n    let mut config: Config = read_config(deps.storage)?;\n\n    // permission check\n    if deps.api.addr_canonicalize(info.sender.as_str())? != config.owner_addr {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    if let Some(owner_addr) = owner_addr {\n        config.owner_addr = deps.api.addr_canonicalize(owner_addr.as_str())?;\n    }\n\n    if interest_model.is_some() {\n        let mut state: State = read_state(deps.storage)?;\n        compute_interest(deps.as_ref(), &config, &mut state, env.block.height, None)?;\n        store_state(deps.storage, &state)?;\n\n        if let Some(interest_model) = interest_model {\n            config.interest_model = deps.api.addr_canonicalize(interest_model.as_str())?;\n        }\n    }\n\n    if let Some(distribution_model) = distribution_model {\n        config.distribution_model = deps.api.addr_canonicalize(distribution_model.as_str())?;\n    }\n\n    if let Some(max_borrow_factor) = max_borrow_factor {\n        config.max_borrow_factor = max_borrow_factor;\n    }\n\n    store_config(deps.storage, &config)?;\n    Ok(Response::new().add_attributes(vec![attr(\"action\", \"update_config\")]))\n}\n\npub fn execute_epoch_operations(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    deposit_rate: Decimal256,\n    target_deposit_rate: Decimal256,\n    threshold_deposit_rate: Decimal256,\n    distributed_interest: Uint256,\n) -> Result<Response, ContractError> {\n    let config: Config = read_config(deps.storage)?;\n    if config.overseer_contract != deps.api.addr_canonicalize(info.sender.as_str())? {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    let mut state: State = read_state(deps.storage)?;\n\n    // Compute interest and reward before updating anc_emission_rate\n    let aterra_supply = query_supply(\n        deps.as_ref(),\n        deps.api.addr_humanize(&config.aterra_contract)?,\n    )?;\n    let balance: Uint256 = query_balance(\n        deps.as_ref(),\n        deps.api.addr_humanize(&config.contract_addr)?,\n        config.stable_denom.to_string(),\n    )? - distributed_interest;\n\n    let borrow_rate_res: BorrowRateResponse = query_borrow_rate(\n        deps.as_ref(),\n        deps.api.addr_humanize(&config.interest_model)?,\n        balance,\n        state.total_liabilities,\n        state.total_reserves,\n    )?;\n\n    compute_interest_raw(\n        &mut state,\n        env.block.height,\n        balance,\n        aterra_supply,\n        borrow_rate_res.rate,\n        target_deposit_rate,\n    );\n\n    // recompute prev_exchange_rate with distributed_interest\n    state.prev_exchange_rate =\n        compute_exchange_rate_raw(&state, aterra_supply, balance + distributed_interest);\n\n    compute_reward(&mut state, env.block.height);\n\n    // Compute total_reserves to fund collector contract\n    // Update total_reserves and send it to collector contract\n    // only when there is enough balance\n    let total_reserves = state.total_reserves * Uint256::one();\n    let messages: Vec<CosmosMsg> = if !total_reserves.is_zero() && balance > total_reserves {\n        state.total_reserves = state.total_reserves - Decimal256::from_uint256(total_reserves);\n\n        vec![CosmosMsg::Bank(BankMsg::Send {\n            to_address: deps\n                .api\n                .addr_humanize(&config.collector_contract)?\n                .to_string(),\n            amount: vec![deduct_tax(\n                deps.as_ref(),\n                Coin {\n                    denom: config.stable_denom,\n                    amount: total_reserves.into(),\n                },\n            )?],\n        })]\n    } else {\n        vec![]\n    };\n\n    // Query updated anc_emission_rate\n    state.anc_emission_rate = query_anc_emission_rate(\n        deps.as_ref(),\n        deps.api.addr_humanize(&config.distribution_model)?,\n        deposit_rate,\n        target_deposit_rate,\n        threshold_deposit_rate,\n        state.anc_emission_rate,\n    )?\n    .emission_rate;\n\n    store_state(deps.storage, &state)?;\n\n    Ok(Response::new().add_messages(messages).add_attributes(vec![\n        attr(\"action\", \"execute_epoch_operations\"),\n        attr(\"total_reserves\", total_reserves),\n        attr(\"anc_emission_rate\", state.anc_emission_rate.to_string()),\n    ]))\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, env: Env, msg: QueryMsg) -> StdResult<Binary> {\n    match msg {\n        QueryMsg::Config {} => to_binary(&query_config(deps)?),\n        QueryMsg::State { block_height } => to_binary(&query_state(deps, env, block_height)?),\n        QueryMsg::EpochState {\n            block_height,\n            distributed_interest,\n        } => to_binary(&query_epoch_state(\n            deps,\n            block_height,\n            distributed_interest,\n        )?),\n        QueryMsg::BorrowerInfo {\n            borrower,\n            block_height,\n        } => to_binary(&query_borrower_info(\n            deps,\n            env,\n            deps.api.addr_validate(&borrower)?,\n            block_height,\n        )?),\n        QueryMsg::BorrowerInfos { start_after, limit } => to_binary(&query_borrower_infos(\n            deps,\n            optional_addr_validate(deps.api, start_after)?,\n            limit,\n        )?),\n    }\n}\n\npub fn query_config(deps: Deps) -> StdResult<ConfigResponse> {\n    let config: Config = read_config(deps.storage)?;\n    Ok(ConfigResponse {\n        owner_addr: deps.api.addr_humanize(&config.owner_addr)?.to_string(),\n        aterra_contract: deps.api.addr_humanize(&config.aterra_contract)?.to_string(),\n        interest_model: deps.api.addr_humanize(&config.interest_model)?.to_string(),\n        distribution_model: deps\n            .api\n            .addr_humanize(&config.distribution_model)?\n            .to_string(),\n        overseer_contract: deps\n            .api\n            .addr_humanize(&config.overseer_contract)?\n            .to_string(),\n        collector_contract: deps\n            .api\n            .addr_humanize(&config.collector_contract)?\n            .to_string(),\n        distributor_contract: deps\n            .api\n            .addr_humanize(&config.distributor_contract)?\n            .to_string(),\n        stable_denom: config.stable_denom,\n        max_borrow_factor: config.max_borrow_factor,\n    })\n}\n\npub fn query_state(deps: Deps, env: Env, block_height: Option<u64>) -> StdResult<StateResponse> {\n    let mut state: State = read_state(deps.storage)?;\n\n    let block_height = if let Some(block_height) = block_height {\n        block_height\n    } else {\n        env.block.height\n    };\n\n    if block_height < state.last_interest_updated {\n        return Err(StdError::generic_err(\n            \"block_height must bigger than last_interest_updated\",\n        ));\n    }\n\n    if block_height < state.last_reward_updated {\n        return Err(StdError::generic_err(\n            \"block_height must bigger than last_reward_updated\",\n        ));\n    }\n\n    let config: Config = read_config(deps.storage)?;\n\n    // Compute interest rate with given block height\n    compute_interest(deps, &config, &mut state, block_height, None)?;\n\n    // Compute reward rate with given block height\n    compute_reward(&mut state, block_height);\n\n    Ok(StateResponse {\n        total_liabilities: state.total_liabilities,\n        total_reserves: state.total_reserves,\n        last_interest_updated: state.last_interest_updated,\n        last_reward_updated: state.last_reward_updated,\n        global_interest_index: state.global_interest_index,\n        global_reward_index: state.global_reward_index,\n        anc_emission_rate: state.anc_emission_rate,\n        prev_aterra_supply: state.prev_aterra_supply,\n        prev_exchange_rate: state.prev_exchange_rate,\n    })\n}\n\npub fn query_epoch_state(\n    deps: Deps,\n    block_height: Option<u64>,\n    distributed_interest: Option<Uint256>,\n) -> StdResult<EpochStateResponse> {\n    let config: Config = read_config(deps.storage)?;\n    let mut state: State = read_state(deps.storage)?;\n\n    let distributed_interest = distributed_interest.unwrap_or_else(Uint256::zero);\n    let aterra_supply = query_supply(deps, deps.api.addr_humanize(&config.aterra_contract)?)?;\n    let balance = query_balance(\n        deps,\n        deps.api.addr_humanize(&config.contract_addr)?,\n        config.stable_denom.to_string(),\n    )? - distributed_interest;\n\n    if let Some(block_height) = block_height {\n        if block_height < state.last_interest_updated {\n            return Err(StdError::generic_err(\n                \"block_height must bigger than last_interest_updated\",\n            ));\n        }\n\n        let borrow_rate_res: BorrowRateResponse = query_borrow_rate(\n            deps,\n            deps.api.addr_humanize(&config.interest_model)?,\n            balance,\n            state.total_liabilities,\n            state.total_reserves,\n        )?;\n\n        let target_deposit_rate: Decimal256 =\n            query_target_deposit_rate(deps, deps.api.addr_humanize(&config.overseer_contract)?)?;\n\n        // Compute interest rate to return latest epoch state\n        compute_interest_raw(\n            &mut state,\n            block_height,\n            balance,\n            aterra_supply,\n            borrow_rate_res.rate,\n            target_deposit_rate,\n        );\n    }\n\n    // compute_interest_raw store current exchange rate\n    // as prev_exchange_rate, so just return prev_exchange_rate\n    let exchange_rate =\n        compute_exchange_rate_raw(&state, aterra_supply, balance + distributed_interest);\n\n    Ok(EpochStateResponse {\n        exchange_rate,\n        aterra_supply,\n    })\n}"
    },
    {
      "filename": "contracts/money-market-contracts/contracts/market/src/contract.rs",
      "content": "#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\n\nuse crate::borrow::{\n    borrow_stable, claim_rewards, compute_interest, compute_interest_raw, compute_reward,\n    query_borrower_info, query_borrower_infos, repay_stable, repay_stable_from_liquidation,\n};\nuse crate::deposit::{compute_exchange_rate_raw, deposit_stable, redeem_stable};\nuse crate::error::ContractError;\nuse crate::querier::{query_anc_emission_rate, query_borrow_rate, query_target_deposit_rate};\nuse crate::response::MsgInstantiateContractResponse;\nuse crate::state::{read_config, read_state, store_config, store_state, Config, State};\n\nuse cosmwasm_bignumber::{Decimal256, Uint256};\nuse cosmwasm_std::{\n    attr, from_binary, to_binary, Addr, BankMsg, Binary, CanonicalAddr, Coin, CosmosMsg, Deps,\n    DepsMut, Env, MessageInfo, Reply, Response, StdError, StdResult, SubMsg, Uint128, WasmMsg,\n};\nuse cw20::{Cw20Coin, Cw20ReceiveMsg, MinterResponse};\n\nuse moneymarket::common::optional_addr_validate;\nuse moneymarket::interest_model::BorrowRateResponse;\nuse moneymarket::market::{\n    ConfigResponse, Cw20HookMsg, EpochStateResponse, ExecuteMsg, InstantiateMsg, QueryMsg,\n    StateResponse,\n};\nuse moneymarket::querier::{deduct_tax, query_balance, query_supply};\nuse protobuf::Message;\nuse terraswap::token::InstantiateMsg as TokenInstantiateMsg;\n\npub const INITIAL_DEPOSIT_AMOUNT: u128 = 1000000;\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: InstantiateMsg,\n) -> Result<Response, ContractError> {\n    let initial_deposit = info\n        .funds\n        .iter()\n        .find(|c| c.denom == msg.stable_denom)\n        .map(|c| c.amount)\n        .unwrap_or_else(Uint128::zero);\n\n    if initial_deposit != Uint128::from(INITIAL_DEPOSIT_AMOUNT) {\n        return Err(ContractError::InitialFundsNotDeposited(\n            INITIAL_DEPOSIT_AMOUNT,\n            msg.stable_denom,\n        ));\n    }\n\n    store_config(\n        deps.storage,\n        &Config {\n            contract_addr: deps.api.addr_canonicalize(env.contract.address.as_str())?,\n            owner_addr: deps.api.addr_canonicalize(&msg.owner_addr)?,\n            aterra_contract: CanonicalAddr::from(vec![]),\n            overseer_contract: CanonicalAddr::from(vec![]),\n            interest_model: CanonicalAddr::from(vec![]),\n            distribution_model: CanonicalAddr::from(vec![]),\n            collector_contract: CanonicalAddr::from(vec![]),\n            distributor_contract: CanonicalAddr::from(vec![]),\n            stable_denom: msg.stable_denom.clone(),\n            max_borrow_factor: msg.max_borrow_factor,\n        },\n    )?;\n\n    store_state(\n        deps.storage,\n        &State {\n            total_liabilities: Decimal256::zero(),\n            total_reserves: Decimal256::zero(),\n            last_interest_updated: env.block.height,\n            last_reward_updated: env.block.height,\n            global_interest_index: Decimal256::one(),\n            global_reward_index: Decimal256::zero(),\n            anc_emission_rate: msg.anc_emission_rate,\n            prev_aterra_supply: Uint256::zero(),\n            prev_exchange_rate: Decimal256::one(),\n        },\n    )?;\n\n    Ok(\n        Response::new().add_submessages(vec![SubMsg::reply_on_success(\n            CosmosMsg::Wasm(WasmMsg::Instantiate {\n                admin: None,\n                code_id: msg.aterra_code_id,\n                funds: vec![],\n                label: \"\".to_string(),\n                msg: to_binary(&TokenInstantiateMsg {\n                    name: format!(\"Anchor Terra {}\", msg.stable_denom[1..].to_uppercase()),\n                    symbol: format!(\n                        \"a{}T\",\n                        msg.stable_denom[1..(msg.stable_denom.len() - 1)].to_uppercase()\n                    ),\n                    decimals: 6u8,\n                    initial_balances: vec![Cw20Coin {\n                        address: env.contract.address.to_string(),\n                        amount: Uint128::from(INITIAL_DEPOSIT_AMOUNT),\n                    }],\n                    mint: Some(MinterResponse {\n                        minter: env.contract.address.to_string(),\n                        cap: None,\n                    }),\n                })?,\n            }),\n            1,\n        )]),\n    )\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -> Result<Response, ContractError> {\n    match msg {\n        ExecuteMsg::Receive(msg) => receive_cw20(deps, env, info, msg),\n        ExecuteMsg::RegisterContracts {\n            overseer_contract,\n            interest_model,\n            distribution_model,\n            collector_contract,\n            distributor_contract,\n        } => {\n            let api = deps.api;\n            register_contracts(\n                deps,\n                api.addr_validate(&overseer_contract)?,\n                api.addr_validate(&interest_model)?,\n                api.addr_validate(&distribution_model)?,\n                api.addr_validate(&collector_contract)?,\n                api.addr_validate(&distributor_contract)?,\n            )\n        }\n        ExecuteMsg::UpdateConfig {\n            owner_addr,\n            interest_model,\n            distribution_model,\n            max_borrow_factor,\n        } => {\n            let api = deps.api;\n            update_config(\n                deps,\n                env,\n                info,\n                optional_addr_validate(api, owner_addr)?,\n                optional_addr_validate(api, interest_model)?,\n                optional_addr_validate(api, distribution_model)?,\n                max_borrow_factor,\n            )\n        }\n        ExecuteMsg::ExecuteEpochOperations {\n            deposit_rate,\n            target_deposit_rate,\n            threshold_deposit_rate,\n            distributed_interest,\n        } => execute_epoch_operations(\n            deps,\n            env,\n            info,\n            deposit_rate,\n            target_deposit_rate,\n            threshold_deposit_rate,\n            distributed_interest,\n        ),\n        ExecuteMsg::DepositStable {} => deposit_stable(deps, env, info),\n        ExecuteMsg::BorrowStable { borrow_amount, to } => {\n            let api = deps.api;\n            borrow_stable(\n                deps,\n                env,\n                info,\n                borrow_amount,\n                optional_addr_validate(api, to)?,\n            )\n        }\n        ExecuteMsg::RepayStable {} => repay_stable(deps, env, info),\n        ExecuteMsg::RepayStableFromLiquidation {\n            borrower,\n            prev_balance,\n        } => {\n            let api = deps.api;\n            repay_stable_from_liquidation(\n                deps,\n                env,\n                info,\n                api.addr_validate(&borrower)?,\n                prev_balance,\n            )\n        }\n        ExecuteMsg::ClaimRewards { to } => {\n            let api = deps.api;\n            claim_rewards(deps, env, info, optional_addr_validate(api, to)?)\n        }\n    }\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn reply(deps: DepsMut, _env: Env, msg: Reply) -> Result<Response, ContractError> {\n    match msg.id {\n        1 => {\n            // get new token's contract address\n            let res: MsgInstantiateContractResponse = Message::parse_from_bytes(\n                msg.result.unwrap().data.unwrap().as_slice(),\n            )\n            .map_err(|_| {\n                ContractError::Std(StdError::parse_err(\n                    \"MsgInstantiateContractResponse\",\n                    \"failed to parse data\",\n                ))\n            })?;\n            let token_addr = Addr::unchecked(res.get_contract_address());\n\n            register_aterra(deps, token_addr)\n        }\n        _ => Err(ContractError::InvalidReplyId {}),\n    }\n}\n\npub fn receive_cw20(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    cw20_msg: Cw20ReceiveMsg,\n) -> Result<Response, ContractError> {\n    let contract_addr = info.sender;\n    match from_binary(&cw20_msg.msg) {\n        Ok(Cw20HookMsg::RedeemStable {}) => {\n            // only asset contract can execute this message\n            let config: Config = read_config(deps.storage)?;\n            if deps.api.addr_canonicalize(contract_addr.as_str())? != config.aterra_contract {\n                return Err(ContractError::Unauthorized {});\n            }\n\n            let cw20_sender_addr = deps.api.addr_validate(&cw20_msg.sender)?;\n            redeem_stable(deps, env, cw20_sender_addr, cw20_msg.amount)\n        }\n        _ => Err(ContractError::MissingRedeemStableHook {}),\n    }\n}\n\npub fn register_aterra(deps: DepsMut, token_addr: Addr) -> Result<Response, ContractError> {\n    let mut config: Config = read_config(deps.storage)?;\n    if config.aterra_contract != CanonicalAddr::from(vec![]) {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    config.aterra_contract = deps.api.addr_canonicalize(token_addr.as_str())?;\n    store_config(deps.storage, &config)?;\n\n    Ok(Response::new().add_attributes(vec![attr(\"aterra\", token_addr)]))\n}\n\npub fn register_contracts(\n    deps: DepsMut,\n    overseer_contract: Addr,\n    interest_model: Addr,\n    distribution_model: Addr,\n    collector_contract: Addr,\n    distributor_contract: Addr,\n) -> Result<Response, ContractError> {\n    let mut config: Config = read_config(deps.storage)?;\n    if config.overseer_contract != CanonicalAddr::from(vec![])\n        || config.interest_model != CanonicalAddr::from(vec![])\n        || config.distribution_model != CanonicalAddr::from(vec![])\n        || config.collector_contract != CanonicalAddr::from(vec![])\n        || config.distributor_contract != CanonicalAddr::from(vec![])\n    {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    config.overseer_contract = deps.api.addr_canonicalize(overseer_contract.as_str())?;\n    config.interest_model = deps.api.addr_canonicalize(interest_model.as_str())?;\n    config.distribution_model = deps.api.addr_canonicalize(distribution_model.as_str())?;\n    config.collector_contract = deps.api.addr_canonicalize(collector_contract.as_str())?;\n    config.distributor_contract = deps.api.addr_canonicalize(distributor_contract.as_str())?;\n    store_config(deps.storage, &config)?;\n\n    Ok(Response::default())\n}\n\npub fn update_config(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    owner_addr: Option<Addr>,\n    interest_model: Option<Addr>,\n    distribution_model: Option<Addr>,\n    max_borrow_factor: Option<Decimal256>,\n) -> Result<Response, ContractError> {\n    let mut config: Config = read_config(deps.storage)?;\n\n    // permission check\n    if deps.api.addr_canonicalize(info.sender.as_str())? != config.owner_addr {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    if let Some(owner_addr) = owner_addr {\n        config.owner_addr = deps.api.addr_canonicalize(owner_addr.as_str())?;\n    }\n\n    if interest_model.is_some() {\n        let mut state: State = read_state(deps.storage)?;\n        compute_interest(deps.as_ref(), &config, &mut state, env.block.height, None)?;\n        store_state(deps.storage, &state)?;\n\n        if let Some(interest_model) = interest_model {\n            config.interest_model = deps.api.addr_canonicalize(interest_model.as_str())?;\n        }\n    }\n\n    if let Some(distribution_model) = distribution_model {\n        config.distribution_model = deps.api.addr_canonicalize(distribution_model.as_str())?;\n    }\n\n    if let Some(max_borrow_factor) = max_borrow_factor {\n        config.max_borrow_factor = max_borrow_factor;\n    }\n\n    store_config(deps.storage, &config)?;\n    Ok(Response::new().add_attributes(vec![attr(\"action\", \"update_config\")]))\n}\n\npub fn execute_epoch_operations(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    deposit_rate: Decimal256,\n    target_deposit_rate: Decimal256,\n    threshold_deposit_rate: Decimal256,\n    distributed_interest: Uint256,\n) -> Result<Response, ContractError> {\n    let config: Config = read_config(deps.storage)?;\n    if config.overseer_contract != deps.api.addr_canonicalize(info.sender.as_str())? {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    let mut state: State = read_state(deps.storage)?;\n\n    // Compute interest and reward before updating anc_emission_rate\n    let aterra_supply = query_supply(\n        deps.as_ref(),\n        deps.api.addr_humanize(&config.aterra_contract)?,\n    )?;\n    let balance: Uint256 = query_balance(\n        deps.as_ref(),\n        deps.api.addr_humanize(&config.cont"
    }
  ]
}