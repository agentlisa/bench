{
  "Title": "Owner can finalize crowdsale before it has ended",
  "Content": "`finalize` function from `FinalizableCrowdsale` is overriden by `MANACrowdsale` in [line 115](https://github.com/decentraland/mana/blob/a13905356378cc0153dd3c2153c8ceae6400970d/contracts/MANACrowdsale.sol#L115). The modified version removes the precondition requiring that the crowdsale `hasEnded`. This is not required by the smart contract specification, and makes the crowdsale vulnerable to premature closing by the owner.\n\n\nIt also introduces a race condition in which investors can still purchase tokens after the crowdsale is finalized but before the continuous sale is started, as the validation for processing a purchase in [line 33](https://github.com/decentraland/mana/blob/a13905356378cc0153dd3c2153c8ceae6400970d/contracts/ContinuousCrowdsale.sol#L33) of `ContinuousCrowdsale` does not check the `isFinalized` flag. This causes an imbalance in the ratio of the shares between the foundation and the investors, since the foundation’s shares are emitted on finalization.\n\n\nRemove the overriding of `finalize` in `MANACrowdsale`, and also the overriding of `hasEnded` in [line 111](https://github.com/decentraland/mana/blob/a13905356378cc0153dd3c2153c8ceae6400970d/contracts/MANACrowdsale.sol#L111).\n\n\n**EDIT**: fixed in commit [`9f07555e51df352aff7bc58b6830904215a7dd14`](https://github.com/decentraland/mana/commit/9f07555e51df352aff7bc58b6830904215a7dd14).\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/MANACrowdsale.sol",
      "content": "pragma solidity ^0.4.11;\n\nimport \"zeppelin-solidity/contracts/crowdsale/CappedCrowdsale.sol\";\nimport \"zeppelin-solidity/contracts/crowdsale/Crowdsale.sol\";\nimport \"zeppelin-solidity/contracts/crowdsale/FinalizableCrowdsale.sol\";\nimport \"./ContinuousCrowdsale.sol\";\nimport \"./WhitelistedCrowdsale.sol\";\nimport \"./MANAToken.sol\";\n\ncontract MANACrowdsale is ContinuousCrowdsale, CappedCrowdsale, WhitelistedCrowdsale, FinalizableCrowdsale {\n\n    uint256 public constant INFLATION = 8; // percent\n\n    uint256 public constant TOTAL_SHARE = 100;\n    uint256 public constant CROWDSALE_SHARE = 40;\n    uint256 public constant FOUNDATION_SHARE = 60;\n\n    // price at which whitelisted buyers will be able to buy tokens\n    uint256 public preferentialRate;\n\n    // customize the rate for each whitelisted buyer\n    mapping (address => uint256) public buyerRate;\n\n    // change of price in every block during the initial coin offering\n    uint256 public rateChange;\n\n    event RateChange(uint256 amount);\n\n    function MANACrowdsale(\n        uint256 _startBlock, uint256 _endBlock,\n        uint256 _rate, uint256 _rateChange,\n        uint256 _preferentialRate,\n        address _wallet\n    )\n        CappedCrowdsale(150000 ether)\n        WhitelistedCrowdsale()\n        FinalizableCrowdsale()\n        Crowdsale(_startBlock, _endBlock, _rate, _wallet)\n    {\n        rateChange = _rateChange;\n        preferentialRate = _preferentialRate;\n    }\n\n    function createTokenContract() internal returns (MintableToken) {\n        return new MANAToken();\n    }\n\n    function setBuyerRate(address buyer, uint256 rate) onlyOwner {\n        require(buyer != 0);\n        require(rate != 0);\n\n        buyerRate[buyer] = rate;\n    }\n\n    function getRate() internal returns(uint256) {\n        // return the current price if we are in continuous sale\n        if (continuousSale) {\n            return rate;\n        }\n\n        // some early buyers are offered a discount on the crowdsale price\n        if (buyerRate[msg.sender] != 0) {\n            return buyerRate[msg.sender];\n        }\n\n        // whitelisted buyers can purchase at preferential price before crowdsale ends\n        if (isWhitelisted(msg.sender) && !hasEnded()) {\n            return preferentialRate;\n        }\n\n        // otherwise compute the price for the auction\n        return rate.sub(rateChange.mul(block.number - startBlock));\n    }\n\n    // low level token purchase function\n    function processPurchase(address beneficiary) internal returns(uint256) {\n        uint256 weiAmount = msg.value;\n        uint256 updatedWeiRaised = weiRaised.add(weiAmount);\n\n        uint256 rate = getRate();\n        // calculate token amount to be created\n        uint256 tokens = weiAmount.mul(rate);\n\n        // update state\n        weiRaised = updatedWeiRaised;\n\n        token.mint(beneficiary, tokens);\n        TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n\n        forwardFunds();\n\n        return tokens;\n    }\n\n    function setWallet(address _wallet) onlyOwner {\n        require(_wallet != 0x0);\n        wallet = _wallet;\n    }\n\n    function setRate(uint256 _rate) onlyOwner {\n        require(isFinalized);\n        rate = _rate;\n        RateChange(_rate);\n    }\n\n    function startContinuousSale() onlyOwner {\n        require(isFinalized);\n        continuousSale = true;\n    }\n\n    function hasEnded() constant returns(bool) {\n        return isFinalized || super.hasEnded();\n    }\n\n    function finalize() onlyOwner {\n        require(!isFinalized);\n\n        finalization();\n        Finalized();\n\n        isFinalized = true;\n    }\n\n    function finalization() internal {\n        uint256 totalSupply = token.totalSupply();\n        uint256 finalSupply = TOTAL_SHARE.mul(totalSupply).div(CROWDSALE_SHARE);\n\n        // emit tokens for the foundation\n        token.mint(wallet, FOUNDATION_SHARE.mul(finalSupply).div(TOTAL_SHARE));\n\n        // initialize issuance \n        // TODO: possibility of overflow in these operations should be analized\n        uint256 annualIssuance = finalSupply.mul(INFLATION).div(100);\n        issuance = annualIssuance.mul(BUCKET_SIZE).div(1 years);\n\n        // NOTE: cannot call super here because it would finish minting and\n        // the continuous sale would not be able to proceed\n    }\n}"
    },
    {
      "filename": "contracts/ContinuousCrowdsale.sol",
      "content": "pragma solidity ^0.4.11;\n\nimport \"zeppelin-solidity/contracts/crowdsale/Crowdsale.sol\";\n\n/**\n * @title ContinuousCrowdsale\n * @dev ContinuousCrowdsale implements a contract for managing a continuous token sale\n */\ncontract ContinuousCrowdsale is Crowdsale {\n    // time bucket size\n    uint256 public constant BUCKET_SIZE = 12 hours;\n\n    // true if continous sale is enabled\n    bool public continuousSale = false;\n\n    // last time bucket from which tokens have been purchased\n    uint256 public lastBucket = 0;\n\n    // amount issued in the last bucket\n    uint256 public bucketAmount = 0;\n\n    // max amount of tokens to mint per time bucket\n    uint256 public issuance = 0;\n\n    function buyTokens(address beneficiary) payable {\n        require(beneficiary != 0x0);\n\n        if (continuousSale) {\n            prepareContinuousPurchase();\n            uint256 tokens = processPurchase(beneficiary);\n            checkContinuousPurchase(tokens);\n        } else {\n            require(validPurchase());\n            processPurchase(beneficiary);\n        }\n    }\n\n    function prepareContinuousPurchase() internal {\n        uint256 timestamp = block.timestamp;\n        uint256 bucket = timestamp - (timestamp % BUCKET_SIZE);\n\n        if (bucket > lastBucket) {\n            lastBucket = bucket;\n            bucketAmount = 0;\n        }\n    }\n\n    function checkContinuousPurchase(uint256 tokens) internal {\n        bucketAmount += tokens;\n        require(bucketAmount <= issuance);\n    }\n\n    function processPurchase(address beneficiary) internal returns(uint256) {\n        uint256 weiAmount = msg.value;\n        uint256 updatedWeiRaised = weiRaised.add(weiAmount);\n\n        // calculate token amount to be created\n        uint256 tokens = weiAmount.mul(rate);\n\n        // update state\n        weiRaised = updatedWeiRaised;\n\n        token.mint(beneficiary, tokens);\n        TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n\n        forwardFunds();\n\n        return tokens;\n    }\n}"
    },
    {
      "filename": "contracts/MANACrowdsale.sol",
      "content": "pragma solidity ^0.4.11;\n\nimport \"zeppelin-solidity/contracts/crowdsale/CappedCrowdsale.sol\";\nimport \"zeppelin-solidity/contracts/crowdsale/Crowdsale.sol\";\nimport \"zeppelin-solidity/contracts/crowdsale/FinalizableCrowdsale.sol\";\nimport \"./ContinuousCrowdsale.sol\";\nimport \"./WhitelistedCrowdsale.sol\";\nimport \"./MANAToken.sol\";\n\ncontract MANACrowdsale is ContinuousCrowdsale, CappedCrowdsale, WhitelistedCrowdsale, FinalizableCrowdsale {\n\n    uint256 public constant INFLATION = 8; // percent\n\n    uint256 public constant TOTAL_SHARE = 100;\n    uint256 public constant CROWDSALE_SHARE = 40;\n    uint256 public constant FOUNDATION_SHARE = 60;\n\n    // price at which whitelisted buyers will be able to buy tokens\n    uint256 public preferentialRate;\n\n    // customize the rate for each whitelisted buyer\n    mapping (address => uint256) public buyerRate;\n\n    // change of price in every block during the initial coin offering\n    uint256 public rateChange;\n\n    event RateChange(uint256 amount);\n\n    function MANACrowdsale(\n        uint256 _startBlock, uint256 _endBlock,\n        uint256 _rate, uint256 _rateChange,\n        uint256 _preferentialRate,\n        address _wallet\n    )\n        CappedCrowdsale(150000 ether)\n        WhitelistedCrowdsale()\n        FinalizableCrowdsale()\n        Crowdsale(_startBlock, _endBlock, _rate, _wallet)\n    {\n        rateChange = _rateChange;\n        preferentialRate = _preferentialRate;\n    }\n\n    function createTokenContract() internal returns (MintableToken) {\n        return new MANAToken();\n    }\n\n    function setBuyerRate(address buyer, uint256 rate) onlyOwner {\n        require(buyer != 0);\n        require(rate != 0);\n\n        buyerRate[buyer] = rate;\n    }\n\n    function getRate() internal returns(uint256) {\n        // return the current price if we are in continuous sale\n        if (continuousSale) {\n            return rate;\n        }\n\n        // some early buyers are offered a discount on the crowdsale price\n        if (buyerRate[msg.sender] != 0) {\n            return buyerRate[msg.sender];\n        }\n\n        // whitelisted buyers can purchase at preferential price before crowdsale ends\n        if (isWhitelisted(msg.sender) && !hasEnded()) {\n            return preferentialRate;\n        }\n\n        // otherwise compute the price for the auction\n        return rate.sub(rateChange.mul(block.number - startBlock));\n    }\n\n    // low level token purchase function\n    function processPurchase(address beneficiary) internal returns(uint256) {\n        uint256 weiAmount = msg.value;\n        uint256 updatedWeiRaised = weiRaised.add(weiAmount);\n\n        uint256 rate = getRate();\n        // calculate token amount to be created\n        uint256 tokens = weiAmount.mul(rate);\n\n        // update state\n        weiRaised = updatedWeiRaised;\n\n        token.mint(beneficiary, tokens);\n        TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n\n        forwardFunds();\n\n        return tokens;\n    }\n\n    function setWallet(address _wallet) onlyOwner {\n        require(_wallet != 0x0);\n        wallet = _wallet;\n    }\n\n    function setRate(uint256 _rate) onlyOwner {\n        require(isFinalized);\n        rate = _rate;\n        RateChange(_rate);\n    }\n\n    function startContinuousSale() onlyOwner {\n        require(isFinalized);\n        continuousSale = true;\n    }\n\n    function hasEnded() constant returns(bool) {\n        return isFinalized || super.hasEnded();\n    }\n\n    function finalize() onlyOwner {\n        require(!isFinalized);\n\n        finalization();\n        Finalized();\n\n        isFinalized = true;\n    }\n\n    function finalization() internal {\n        uint256 totalSupply = token.totalSupply();\n        uint256 finalSupply = TOTAL_SHARE.mul(totalSupply).div(CROWDSALE_SHARE);\n\n        // emit tokens for the foundation\n        token.mint(wallet, FOUNDATION_SHARE.mul(finalSupply).div(TOTAL_SHARE));\n\n        // initialize issuance \n        // TODO: possibility of overflow in these operations should be analized\n        uint256 annualIssuance = finalSupply.mul(INFLATION).div(100);\n        issuance = annualIssuance.mul(BUCKET_SIZE).div(1 years);\n\n        // NOTE: cannot call super here because it would finish minting and\n        // the continuous sale would not be able to proceed\n    }\n}"
    }
  ]
}