{
  "Title": "[M-02] An attacker can bloat the Pink runtime storage with zero costs",
  "Content": "\nAn attacker can perform a bloat attack by creating a very high amount of dust accounts. This can occur with a minimal cost for the attacker, and results in a very high and increased cost in terms of storage and fees.\n\n### Proof of Concept\n\nOn substrate-based runtimes, the [Existential Deposit](https://wiki.polkadot.network/docs/build-protocol-info#existential-deposit) (ED) is the minimum balance needed to have an active account, and it's useful to prevent dust accounts from bloating the storage state. In case the balance goes under the ED, the account will be reaped, (i.e. completely removed from storage) and the nonce reset.\n\nStorage usage has a cost in terms of fees which impacts all the users, as there is a bigger overhead. The issue is that on the Pink runtime, the ED is dangerously low, which enables bloating attacks.\n\nLet's see how feasible is to perform an attack from a price perspective. On Polkadot, the ED is `1 DOT`. At the moment of writing, `1 DOT` is worth about `$10 USD`, so if an attacker would want to split 10 million USD as dust between their own accounts, they would be able to create only 1 million accounts.\n\nOn the Pink runtime, this is not the case. At the moment of writing `1 PHA` is equal to `~$0.20 USD`; but here, the ED is only 1 unit:\n\n```rust\n     pub const ExistentialDeposit: Balance = 1;\n```\n\n<https://github.com/code-423n4/2024-03-phala-network/blob/a01ffbe992560d8d0f17deadfb9b9a2bed38377e/phala-blockchain/crates/pink/runtime/src/runtime.rs#L48>\n\nAs balance is simply a type alias of `u128`:\n\n```rust\n     pub type Balance = u128;\n```\n\n<https://github.com/code-423n4/2024-03-phala-network/blob/a01ffbe992560d8d0f17deadfb9b9a2bed38377e/phala-blockchain/crates/pink/runtime/src/types.rs#L11>\n\nAnd `1 PHA` is equal to [`1_000_000_000_000`](https://github.com/Phala-Network/phala-blockchain/blob/1dd8911a6c8f3fe628f8a27ef3e4848b8100faf4/standalone/runtime/src/constants.rs#L26-L29):\n\n```rust\n     pub const PHAS: Balance = 1_000_000_000_000;\n     pub const DOLLARS: Balance = PHAS;\n     pub const CENTS: Balance = DOLLARS / 100;\n     pub const MILLICENTS: Balance = CENTS / 1_000;\n```\n\nThis means that an account costs only `$0.20 / 1_000_000_000_000` for the attacker.\n\nFollowing the previous `DOT` example, this means that an attacker could create **1 TRILLION accounts** by simply paying just `$0.20`, but they could create even more accounts (several order of magnitudes bigger) with a small \"investment\" to fill all the storage.\n\n### Recommended Mitigation Steps\n\nConsider using a reasonable Existential Deposit. I recommend at least one `CENTS` (i.e. `1_000_000_000`):\n\n```diff\n-    pub const ExistentialDeposit: Balance = 1;\n+    pub const ExistentialDeposit: Balance = 1 * CENTS;\n```\n\n### Assessed type\n\nDecimal\n\n**[kvinwang (Phala) confirmed](https://github.com/code-423n4/2024-03-phala-network-findings/issues/49#issuecomment-2019466089)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-03-phala-network",
  "Code": [
    {
      "filename": "phala-blockchain/crates/pink/runtime/src/runtime.rs",
      "content": "mod extension;\nmod pallet_pink;\n\nuse crate::types::{AccountId, Balance, BlockNumber, Hash, Hashing, Nonce};\nuse frame_support::{\n    parameter_types,\n    traits::{ConstBool, ConstU32},\n    weights::{constants::WEIGHT_REF_TIME_PER_SECOND, Weight},\n};\nuse log::info;\nuse pallet_contracts::{\n    migration::{v11, v12, v13, v14, v15, NoopMigration},\n    weights::SubstrateWeight,\n    Frame, Migration, Schedule,\n};\nuse sp_runtime::{traits::IdentityLookup, Perbill};\n\npub use extension::get_side_effects;\npub use pink_capi::types::ExecSideEffects;\n\ntype Block = sp_runtime::generic::Block<\n    sp_runtime::generic::Header<BlockNumber, Hashing>,\n    frame_system::mocking::MockUncheckedExtrinsic<PinkRuntime>,\n>;\n\npub type SystemEvents = Vec<frame_system::EventRecord<RuntimeEvent, Hash>>;\n\nframe_support::construct_runtime! {\n    pub struct PinkRuntime {\n        System: frame_system,\n        Timestamp: pallet_timestamp,\n        Balances: pallet_balances,\n        Randomness: pallet_insecure_randomness_collective_flip,\n        Contracts: pallet_contracts,\n        Pink: pallet_pink,\n    }\n}\n\nconst NORMAL_DISPATCH_RATIO: Perbill = Perbill::from_percent(75);\n\nparameter_types! {\n    pub const BlockHashCount: u32 = 250;\n    pub RuntimeBlockWeights: frame_system::limits::BlockWeights =\n        frame_system::limits::BlockWeights::with_sensible_defaults(\n            Weight::from_parts(2u64 * WEIGHT_REF_TIME_PER_SECOND, u64::MAX),\n            NORMAL_DISPATCH_RATIO,\n        );\n    pub const ExistentialDeposit: Balance = 1;\n    pub const MaxLocks: u32 = 50;\n    pub const MaxReserves: u32 = 50;\n    pub const MaxHolds: u32 = 10;\n}\n\nimpl pallet_pink::Config for PinkRuntime {\n    type Currency = Balances;\n}\n\nimpl pallet_balances::Config for PinkRuntime {\n    type Balance = Balance;\n    type DustRemoval = ();\n    type RuntimeEvent = RuntimeEvent;\n    type ExistentialDeposit = ExistentialDeposit;\n    type AccountStore = frame_system::Pallet<PinkRuntime>;\n    type WeightInfo = pallet_balances::weights::SubstrateWeight<PinkRuntime>;\n    type MaxLocks = MaxLocks;\n    type MaxReserves = MaxReserves;\n    type ReserveIdentifier = [u8; 8];\n    type FreezeIdentifier = RuntimeFreezeReason;\n    type MaxHolds = MaxHolds;\n    type MaxFreezes = ();\n    type RuntimeHoldReason = RuntimeHoldReason;\n    type RuntimeFreezeReason = RuntimeFreezeReason;\n}\n\nimpl frame_system::Config for PinkRuntime {\n    type BaseCallFilter = frame_support::traits::Everything;\n    type BlockWeights = RuntimeBlockWeights;\n    type BlockLength = ();\n    type DbWeight = ();\n    type RuntimeOrigin = RuntimeOrigin;\n    type Nonce = Nonce;\n    type Hash = Hash;\n    type RuntimeCall = RuntimeCall;\n    type Hashing = Hashing;\n    type AccountId = AccountId;\n    type Lookup = IdentityLookup<Self::AccountId>;\n    type Block = Block;\n    type RuntimeEvent = RuntimeEvent;\n    type BlockHashCount = BlockHashCount;\n    type Version = ();\n    type PalletInfo = PalletInfo;\n    type AccountData = pallet_balances::AccountData<Balance>;\n    type OnNewAccount = ();\n    type OnKilledAccount = ();\n    type SystemWeightInfo = ();\n    type SS58Prefix = ();\n    type OnSetCode = ();\n    type MaxConsumers = frame_support::traits::ConstU32<16>;\n}\n\nimpl pallet_insecure_randomness_collective_flip::Config for PinkRuntime {}\n\nparameter_types! {\n    pub const MinimumPeriod: u64 = 1;\n}\n\nimpl pallet_timestamp::Config for PinkRuntime {\n    type Moment = u64;\n    type OnTimestampSet = ();\n    type MinimumPeriod = MinimumPeriod;\n    type WeightInfo = ();\n}\n\nconst MAX_CODE_LEN: u32 = 2 * 1024 * 1024;\n\nparameter_types! {\n    pub DepositPerStorageByte: Balance = Pink::deposit_per_byte();\n    pub DepositPerStorageItem: Balance = Pink::deposit_per_item();\n    pub const DefaultDepositLimit: Balance = Balance::max_value();\n    pub const MaxCodeLen: u32 = MAX_CODE_LEN;\n    pub const MaxStorageKeyLen: u32 = 128;\n    pub const MaxDebugBufferLen: u32 = 128 * 1024;\n    pub DefaultSchedule: Schedule<PinkRuntime> = {\n        let mut schedule = Schedule::<PinkRuntime>::default();\n        const MB: u32 = 16;  // 64KiB * 16\n        // Each concurrent query would create a VM instance to serve it. We couldn't\n        // allocate too much here.\n        schedule.limits.memory_pages = 4 * MB;\n        schedule.instruction_weights.base = 8000;\n        schedule.limits.runtime_memory = 2048 * 1024 * 1024; // For unittests\n        schedule.limits.payload_len = 1024 * 1024; // Max size for storage value\n        schedule\n    };\n    pub CodeHashLockupDepositPercent: Perbill = Perbill::from_percent(0);\n}\n\nimpl pallet_contracts::Config for PinkRuntime {\n    type Time = Timestamp;\n    type Randomness = Randomness;\n    type Currency = Balances;\n    type RuntimeEvent = RuntimeEvent;\n    type RuntimeCall = RuntimeCall;\n    type CallFilter = frame_support::traits::Nothing;\n    type CallStack = [Frame<Self>; 5];\n    type WeightPrice = Pink;\n    type WeightInfo = SubstrateWeight<Self>;\n    type ChainExtension = extension::PinkExtension;\n    type Schedule = DefaultSchedule;\n    type DepositPerByte = DepositPerStorageByte;\n    type DepositPerItem = DepositPerStorageItem;\n    type DefaultDepositLimit = DefaultDepositLimit;\n    type AddressGenerator = Pink;\n    type MaxCodeLen = MaxCodeLen;\n    type MaxStorageKeyLen = MaxStorageKeyLen;\n    type UnsafeUnstableInterface = ConstBool<false>;\n    type MaxDebugBufferLen = MaxDebugBufferLen;\n    type Migrations = (\n        // Our on-chain runtime was started from polkadot-v0.9.41 but it already contains\n        // the changes handled by the v10::Migration. So we just use a NoopMigration here.\n        NoopMigration<10>,\n        v11::Migration<Self>,\n        v12::Migration<Self, Balances>,\n        v13::Migration<Self>,\n        v14::Migration<Self, Balances>,\n        v15::Migration<Self>,\n    );\n    type CodeHashLockupDepositPercent = CodeHashLockupDepositPercent;\n    type MaxDelegateDependencies = ConstU32<32>;\n    type RuntimeHoldReason = RuntimeHoldReason;\n    type Debug = ();\n    type Environment = ();\n    type Xcm = ();\n}\n\n#[test]\nfn detect_parameter_changes() {\n    use pallet_contracts::Config;\n\n    insta::assert_debug_snapshot!((\n        <PinkRuntime as frame_system::Config>::BlockWeights::get(),\n        <PinkRuntime as Config>::Schedule::get(),\n        <PinkRuntime as Config>::DefaultDepositLimit::get(),\n        <PinkRuntime as Config>::MaxCodeLen::get(),\n        <PinkRuntime as Config>::MaxStorageKeyLen::get(),\n    ));\n}\n\n/// Call on_genesis for all pallets. This would put the each pallet's storage version into\n/// the frame_support::StorageVersion.\npub fn on_genesis() {\n    <AllPalletsWithSystem as frame_support::traits::OnGenesis>::on_genesis();\n}\n\n/// Call on_runtime_upgrade for all pallets\npub fn on_runtime_upgrade() {\n    use frame_support::traits::OnRuntimeUpgrade;\n    type Migrations = (Migration<PinkRuntime>, AllPalletsWithSystem);\n    Migrations::on_runtime_upgrade();\n    info!(\"Runtime database migration done\");\n}\n\n/// Call on_idle for each pallet.\npub fn on_idle(n: BlockNumber) {\n    <AllPalletsWithSystem as frame_support::traits::OnIdle<BlockNumber>>::on_idle(n, Weight::MAX);\n}\n\n#[test]\nfn check_metadata() {\n    let (major, minor, _) = this_crate::version_tuple!();\n    let filename = format!(\"assets/metadata-{major}.{minor}.bin\");\n    check_metadata_with_path(&filename).expect(\"metadata changed\");\n}\n\n#[cfg(coverage)]\n#[test]\nfn check_metadata_for_coverage() {\n    let filename = format!(\"/tmp/pink-runtime-metadata.bin.cov\");\n    assert!(check_metadata_with_path(&filename).is_err())\n}\n\n#[cfg(test)]\nfn check_metadata_with_path(path: &str) -> Result<(), String> {\n    let storage = crate::storage::in_memory_backend::InMemoryStorage::default();\n    let context = pink_capi::v1::ocall::ExecContext {\n        block_number: 1,\n        ..Default::default()\n    };\n    let metadata: Vec<u8> = storage\n        .execute_with(&context, || PinkRuntime::metadata().into())\n        .0;\n    let old_metadata = std::fs::read(path).unwrap_or_default();\n    if metadata != old_metadata {\n        let new_metadata_path = std::env::current_dir().unwrap().join(format!(\"{path}.new\"));\n        std::fs::write(&new_metadata_path, metadata).unwrap();\n        return Err(format!(\n            \"Pink runtime metadata changed. The new metadata is stored at \\n {:?}\",\n            new_metadata_path.display()\n        ));\n    }\n    Ok(())\n}"
    },
    {
      "filename": "phala-blockchain/crates/pink/runtime/src/types.rs",
      "content": "use scale::{Decode, Encode};\nuse sp_runtime::{traits::BlakeTwo256, AccountId32};\n\npub use frame_support::weights::Weight;\n\nuse crate::runtime::SystemEvents;\n\npub type Hash = sp_core::H256;\npub type Hashing = BlakeTwo256;\npub type AccountId = AccountId32;\npub type Balance = u128;\npub type BlockNumber = u32;\npub type Nonce = u64;\n\n#[derive(Encode, Decode, Clone, Debug)]\npub struct EventsBlockHeader {\n    pub number: u64,\n    pub runtime_version: (u32, u32),\n    pub parent_hash: Hash,\n    pub body_hash: Hash,\n}\n\n// The body layout may change in the future. They should be decoded as type determined by\n// header.runtime_version.\n#[derive(Encode, Decode, Clone, Debug)]\npub struct EventsBlockBody {\n    pub phala_block_number: BlockNumber,\n    pub contract_call_nonce: Option<Vec<u8>>,\n    pub entry_contract: Option<AccountId>,\n    pub events: SystemEvents,\n    pub origin: Option<AccountId>,\n}\n\n#[derive(Encode, Decode, Clone, Debug)]\npub struct EventsBlock {\n    pub header: EventsBlockHeader,\n    pub body: EventsBlockBody,\n}\n\n#[test]\nfn test_decode_and_verify_event_chain() {\n    // The log file is greped from the pruntime log in e2e with `grep 'event_chain' pruntime0.log > events.log`\n    // If this test fails, it means the event chain layout changed, consider to regenerate the log file if the\n    // change is expected.\n    let blocks_file = include_str!(\"../assets/events.log\");\n    let mut parent_hash = Hash::default();\n\n    fn extract_payload(log_line: &str) -> Option<&str> {\n        let payload_marker = \"payload=\";\n        log_line\n            .split_whitespace()\n            .find(|segment| segment.starts_with(payload_marker))\n            .and_then(|segment| segment.strip_prefix(payload_marker))\n    }\n\n    for line in blocks_file.lines() {\n        let line = line.trim();\n        if line.is_empty() {\n            continue;\n        }\n        let payload = extract_payload(line).expect(\"Invalid log line\");\n        let bytes = hex::decode(payload).unwrap();\n        let event: EventsBlock = Decode::decode(&mut &bytes[..]).unwrap();\n        let header_hash: Hash = sp_core::blake2_256(&event.header.encode()).into();\n        let body_hash: Hash = sp_core::blake2_256(&event.body.encode()).into();\n        assert!(event.header.parent_hash == parent_hash);\n        assert!(event.header.body_hash == body_hash);\n        parent_hash = header_hash;\n\n        // For cov\n        assert!(!format!(\"{:?}\", event.clone()).is_empty());\n    }\n}"
    },
    {
      "filename": "standalone/runtime/src/constants.rs",
      "content": "// This file is part of Substrate.\n\n// Copyright (C) 2019-2021 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// \thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! A set of constant values used in substrate runtime.\n\n#![allow(clippy::identity_op)]\n\n/// Money matters.\npub mod currency {\n    use node_primitives::Balance;\n\n    pub const PHAS: Balance = 1_000_000_000_000;\n    pub const DOLLARS: Balance = PHAS;\n    pub const CENTS: Balance = DOLLARS / 100;\n    pub const MILLICENTS: Balance = CENTS / 1_000;\n\n    pub const fn deposit(items: u32, bytes: u32) -> Balance {\n        items as Balance * 15 * CENTS + (bytes as Balance) * 6 * CENTS\n    }\n}\n\n/// Time.\npub mod time {\n    use node_primitives::{BlockNumber, Moment};\n\n    /// Since BABE is probabilistic this is the average expected block time that\n    /// we are targeting. Blocks will be produced at a minimum duration defined\n    /// by `SLOT_DURATION`, but some slots will not be allocated to any\n    /// authority and hence no block will be produced. We expect to have this\n    /// block time on average following the defined slot duration and the value\n    /// of `c` configured for BABE (where `1 - c` represents the probability of\n    /// a slot being empty).\n    /// This value is only used indirectly to define the unit constants below\n    /// that are expressed in blocks. The rest of the code should use\n    /// `SLOT_DURATION` instead (like the Timestamp pallet for calculating the\n    /// minimum period).\n    ///\n    /// If using BABE with secondary slots (default) then all of the slots will\n    /// always be assigned, in which case `MILLISECS_PER_BLOCK` and\n    /// `SLOT_DURATION` should have the same value.\n    ///\n    /// <https://research.web3.foundation/en/latest/polkadot/block-production/Babe.html#-6.-practical-results>\n    pub const MILLISECS_PER_BLOCK: Moment = 3000;\n    pub const SECS_PER_BLOCK: Moment = MILLISECS_PER_BLOCK / 1000;\n\n    // NOTE: Currently it is not possible to change the slot duration after the chain has started.\n    //       Attempting to do so will brick block production.\n    pub const SLOT_DURATION: Moment = MILLISECS_PER_BLOCK;\n\n    // 1 in 4 blocks (on average, not counting collisions) will be primary BABE blocks.\n    pub const PRIMARY_PROBABILITY: (u64, u64) = (1, 4);\n\n    // NOTE: Currently it is not possible to change the epoch duration after the chain has started.\n    //       Attempting to do so will brick block production.\n    pub const EPOCH_DURATION_IN_BLOCKS: BlockNumber = 10 * MINUTES;\n    pub const EPOCH_DURATION_IN_SLOTS: u64 = {\n        const SLOT_FILL_RATE: f64 = MILLISECS_PER_BLOCK as f64 / SLOT_DURATION as f64;\n\n        (EPOCH_DURATION_IN_BLOCKS as f64 * SLOT_FILL_RATE) as u64\n    };\n\n    // These time units are defined in number of blocks.\n    pub const MINUTES: BlockNumber = 60 / (SECS_PER_BLOCK as BlockNumber);\n    pub const HOURS: BlockNumber = MINUTES * 60;\n    pub const DAYS: BlockNumber = HOURS * 24;\n\n    // Storage\n    frame_support::parameter_types! {\n        pub storage MillisecsPerBlock: Moment = MILLISECS_PER_BLOCK;\n        pub storage SecsPerBlock: Moment = MILLISECS_PER_BLOCK / 1000;\n\n        pub storage SlotDuration: Moment = MILLISECS_PER_BLOCK;\n        pub storage EpochDurationInBlocks: BlockNumber = 1 * HOURS;\n        pub storage EpochDurationInSlots: u64 = {\n            const SLOT_FILL_RATE: f64 = MILLISECS_PER_BLOCK as f64 / SLOT_DURATION as f64;\n\n            (EPOCH_DURATION_IN_BLOCKS as f64 * SLOT_FILL_RATE) as u64\n        };\n\n        // These time units are defined in number of blocks.\n        pub storage Minutes: BlockNumber = 60 / (SECS_PER_BLOCK as BlockNumber);\n        pub storage Hours: BlockNumber = MINUTES * 60;\n        pub storage Days: BlockNumber = HOURS * 24;\n    }\n}"
    }
  ]
}