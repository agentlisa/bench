{
  "Title": "TODO comments should be resolved",
  "Content": "##### Description\nThere are multiple TODO comments - https://github.com/cryptoalgebra/Algebra/blob/6f57b3e218630106a4d41aedefd38f9e83b41e2b/src/farming/contracts/farmings/AlgebraEternalFarming.sol#L169, https://github.com/cryptoalgebra/Algebra/blob/6f57b3e218630106a4d41aedefd38f9e83b41e2b/src/farming/contracts/farmings/AlgebraEternalFarming.sol#L354, https://github.com/cryptoalgebra/Algebra/blob/6f57b3e218630106a4d41aedefd38f9e83b41e2b/src/farming/contracts/FarmingCenter.sol#L87 and https://github.com/cryptoalgebra/Algebra/blob/6f57b3e218630106a4d41aedefd38f9e83b41e2b/src/farming/contracts/FarmingCenter.sol#L115.\n\n##### Recommendation\nWe recommend removing the above-mentioned comments.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/farming/contracts/farmings/AlgebraEternalFarming.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.8.20;\n\nimport './EternalVirtualPool.sol';\nimport '../libraries/IncentiveId.sol';\nimport '../libraries/NFTPositionInfo.sol';\nimport '../interfaces/IAlgebraEternalFarming.sol';\nimport '../interfaces/IAlgebraEternalVirtualPool.sol';\nimport '../interfaces/IFarmingCenter.sol';\n\nimport '@cryptoalgebra/core/contracts/interfaces/IAlgebraPoolDeployer.sol';\nimport '@cryptoalgebra/core/contracts/interfaces/IAlgebraPool.sol';\nimport '@cryptoalgebra/core/contracts/interfaces/IAlgebraFactory.sol';\nimport '@cryptoalgebra/core/contracts/interfaces/IERC20Minimal.sol';\nimport '@cryptoalgebra/core/contracts/libraries/SafeCast.sol';\nimport '@cryptoalgebra/core/contracts/libraries/FullMath.sol';\nimport '@cryptoalgebra/core/contracts/libraries/Constants.sol';\nimport '@cryptoalgebra/core/contracts/libraries/TickMath.sol';\nimport '@cryptoalgebra/core/contracts/libraries/LowGasSafeMath.sol';\n\nimport '@cryptoalgebra/periphery/contracts/libraries/TransferHelper.sol';\n\nimport '@cryptoalgebra/plugins/contracts/interfaces/plugins/IFarmingPlugin.sol';\n\n/// @title Algebra eternal (v2-like) farming\ncontract AlgebraEternalFarming is IAlgebraEternalFarming {\n  using SafeCast for int256;\n  using LowGasSafeMath for uint256;\n  using LowGasSafeMath for uint128;\n\n  /// @notice Represents a farming incentive\n  struct Incentive {\n    uint128 totalReward;\n    uint128 bonusReward;\n    address virtualPoolAddress;\n    uint24 minimalPositionWidth;\n    bool deactivated;\n    address pluginAddress;\n  }\n\n  /// @notice Represents the farm for nft\n  struct Farm {\n    uint128 liquidity;\n    int24 tickLower;\n    int24 tickUpper;\n    uint256 innerRewardGrowth0;\n    uint256 innerRewardGrowth1;\n  }\n\n  /// @inheritdoc IAlgebraEternalFarming\n  INonfungiblePositionManager public immutable override nonfungiblePositionManager;\n\n  IAlgebraPoolDeployer private immutable deployer;\n  IAlgebraFactory private immutable factory;\n\n  IFarmingCenter public farmingCenter;\n  /// @inheritdoc IAlgebraEternalFarming\n  bool public override isEmergencyWithdrawActivated;\n  // reentrancy lock\n  bool private unlocked = true;\n\n  /// @dev bytes32 refers to the return value of IncentiveId.compute\n  /// @inheritdoc IAlgebraEternalFarming\n  mapping(bytes32 => Incentive) public override incentives;\n\n  /// @dev farms[tokenId][incentiveHash] => Farm\n  /// @inheritdoc IAlgebraEternalFarming\n  mapping(uint256 => mapping(bytes32 => Farm)) public override farms;\n\n  uint256 public numOfIncentives;\n\n  bytes32 public constant INCENTIVE_MAKER_ROLE = keccak256('INCENTIVE_MAKER_ROLE');\n  bytes32 public constant FARMINGS_ADMINISTRATOR_ROLE = keccak256('FARMINGS_ADMINISTRATOR_ROLE');\n\n  /// @dev rewards[owner][rewardToken] => uint256\n  /// @inheritdoc IAlgebraEternalFarming\n  mapping(address => mapping(IERC20Minimal => uint256)) public override rewards;\n\n  modifier onlyIncentiveMaker() {\n    _checkHasRole(INCENTIVE_MAKER_ROLE);\n    _;\n  }\n\n  modifier onlyAdministrator() {\n    _checkHasRole(FARMINGS_ADMINISTRATOR_ROLE);\n    _;\n  }\n\n  modifier onlyFarmingCenter() {\n    _checkIsFarmingCenter();\n    _;\n  }\n\n  /// @param _deployer pool deployer contract address\n  /// @param _nonfungiblePositionManager the NFT position manager contract address\n  constructor(IAlgebraPoolDeployer _deployer, INonfungiblePositionManager _nonfungiblePositionManager) {\n    (deployer, nonfungiblePositionManager) = (_deployer, _nonfungiblePositionManager);\n    factory = IAlgebraFactory(_nonfungiblePositionManager.factory());\n  }\n\n  /// @inheritdoc IAlgebraEternalFarming\n  function isIncentiveActive(bytes32 incentiveId) external view override returns (bool res) {\n    return _isIncentiveActive(incentives[incentiveId]);\n  }\n\n  function _checkIsFarmingCenter() internal view {\n    require(msg.sender == address(farmingCenter));\n  }\n\n  function _checkHasRole(bytes32 role) internal view {\n    require(factory.hasRoleOrOwner(role, msg.sender));\n  }\n\n  /// @inheritdoc IAlgebraEternalFarming\n  function createEternalFarming(\n    IncentiveKey memory key,\n    IncentiveParams memory params\n  ) external override onlyIncentiveMaker returns (address virtualPool) {\n    address connectedPlugin = key.pool.plugin();\n    if (connectedPlugin == address(0)) revert pluginNotConnected();\n    if (_getCurrentVirtualPoolInPlugin(IFarmingPlugin(connectedPlugin)) != address(0)) revert farmingAlreadyExists();\n\n    virtualPool = address(new EternalVirtualPool(address(this), connectedPlugin));\n    _connectVirtualPoolToPlugin(virtualPool, IFarmingPlugin(connectedPlugin));\n\n    key.nonce = numOfIncentives++;\n    bytes32 incentiveId = IncentiveId.compute(key);\n    Incentive storage newIncentive = incentives[incentiveId];\n\n    (params.reward, params.bonusReward) = _receiveRewards(key, params.reward, params.bonusReward, newIncentive);\n    if (params.reward == 0) revert zeroRewardAmount();\n\n    unchecked {\n      if (int256(uint256(params.minimalPositionWidth)) > (int256(TickMath.MAX_TICK) - int256(TickMath.MIN_TICK)))\n        revert minimalPositionWidthTooWide();\n    }\n    newIncentive.virtualPoolAddress = virtualPool;\n    newIncentive.minimalPositionWidth = params.minimalPositionWidth;\n    newIncentive.pluginAddress = connectedPlugin;\n\n    emit EternalFarmingCreated(\n      key.rewardToken,\n      key.bonusRewardToken,\n      key.pool,\n      virtualPool,\n      key.nonce,\n      params.reward,\n      params.bonusReward,\n      params.minimalPositionWidth\n    );\n\n    _addRewards(IAlgebraEternalVirtualPool(virtualPool), params.reward, params.bonusReward, incentiveId);\n    _setRewardRates(IAlgebraEternalVirtualPool(virtualPool), params.rewardRate, params.bonusRewardRate, incentiveId);\n  }\n\n  /// @inheritdoc IAlgebraEternalFarming\n  function deactivateIncentive(IncentiveKey memory key) external override onlyIncentiveMaker {\n    (bytes32 incentiveId, Incentive storage incentive) = _getIncentiveByKey(key);\n    if (incentive.deactivated) revert incentiveStopped();\n\n    IAlgebraEternalVirtualPool virtualPool = IAlgebraEternalVirtualPool(incentive.virtualPoolAddress);\n\n    incentive.deactivated = true;\n    virtualPool.deactivate();\n\n    (uint128 rewardRate0, uint128 rewardRate1) = virtualPool.rewardRates();\n    if (rewardRate0 | rewardRate1 != 0) _setRewardRates(virtualPool, 0, 0, incentiveId);\n\n    IFarmingPlugin plugin = IFarmingPlugin(incentive.pluginAddress); // TODO optimize\n    if (address(virtualPool) == _getCurrentVirtualPoolInPlugin(plugin)) {\n      _connectVirtualPoolToPlugin(address(0), IFarmingPlugin(plugin));\n    }\n    emit IncentiveDeactivated(incentiveId);\n  }\n\n  /// @inheritdoc IAlgebraEternalFarming\n  function decreaseRewardsAmount(IncentiveKey memory key, uint128 rewardAmount, uint128 bonusRewardAmount) external override onlyAdministrator {\n    (bytes32 incentiveId, Incentive storage incentive) = _getIncentiveByKey(key);\n    IAlgebraEternalVirtualPool virtualPool = IAlgebraEternalVirtualPool(incentive.virtualPoolAddress);\n\n    _distributeRewards(virtualPool);\n    (uint128 rewardReserve0, uint128 rewardReserve1) = virtualPool.rewardReserves();\n    if (rewardAmount > rewardReserve0) rewardAmount = rewardReserve0;\n    if (rewardAmount >= incentive.totalReward) rewardAmount = incentive.totalReward - 1; // to not trigger 'non-existent incentive'\n    incentive.totalReward = incentive.totalReward - rewardAmount;\n\n    if (bonusRewardAmount > rewardReserve1) bonusRewardAmount = rewardReserve1;\n    incentive.bonusReward = incentive.bonusReward - bonusRewardAmount;\n\n    virtualPool.decreaseRewards(rewardAmount, bonusRewardAmount);\n\n    if (rewardAmount > 0) TransferHelper.safeTransfer(address(key.rewardToken), msg.sender, rewardAmount);\n    if (bonusRewardAmount > 0) TransferHelper.safeTransfer(address(key.bonusRewardToken), msg.sender, bonusRewardAmount);\n\n    emit RewardAmountsDecreased(rewardAmount, bonusRewardAmount, incentiveId);\n  }\n\n  /// @inheritdoc IAlgebraEternalFarming\n  function setFarmingCenterAddress(address _farmingCenter) external override onlyAdministrator {\n    require(_farmingCenter != address(farmingCenter));\n    farmingCenter = IFarmingCenter(_farmingCenter);\n    emit FarmingCenter(_farmingCenter);\n  }\n\n  /// @inheritdoc IAlgebraEternalFarming\n  function setEmergencyWithdrawStatus(bool newStatus) external override onlyAdministrator {\n    require(isEmergencyWithdrawActivated != newStatus);\n    isEmergencyWithdrawActivated = newStatus;\n    emit EmergencyWithdraw(newStatus);\n  }\n\n  /// @inheritdoc IAlgebraEternalFarming\n  function addRewards(IncentiveKey memory key, uint128 rewardAmount, uint128 bonusRewardAmount) external override {\n    (bytes32 incentiveId, Incentive storage incentive) = _getIncentiveByKey(key);\n\n    if (!_isIncentiveActive(incentive)) revert incentiveStopped();\n\n    IAlgebraEternalVirtualPool virtualPool = IAlgebraEternalVirtualPool(incentive.virtualPoolAddress);\n\n    (rewardAmount, bonusRewardAmount) = _receiveRewards(key, rewardAmount, bonusRewardAmount, incentive);\n\n    if (rewardAmount | bonusRewardAmount > 0) {\n      _addRewards(virtualPool, rewardAmount, bonusRewardAmount, incentiveId);\n    }\n  }\n\n  /// @inheritdoc IAlgebraEternalFarming\n  function setRates(IncentiveKey memory key, uint128 rewardRate, uint128 bonusRewardRate) external override onlyIncentiveMaker {\n    bytes32 incentiveId = IncentiveId.compute(key);\n    IAlgebraEternalVirtualPool virtualPool = IAlgebraEternalVirtualPool(incentives[incentiveId].virtualPoolAddress);\n\n    if ((rewardRate | bonusRewardRate != 0) && (!_isIncentiveActive(incentives[incentiveId]))) revert incentiveStopped();\n\n    _setRewardRates(virtualPool, rewardRate, bonusRewardRate, incentiveId);\n  }\n\n  /// @inheritdoc IAlgebraEternalFarming\n  function enterFarming(IncentiveKey memory key, uint256 tokenId) external override onlyFarmingCenter {\n    if (isEmergencyWithdrawActivated) revert emergencyActivated();\n    (bytes32 incentiveId, int24 tickLower, int24 tickUpper, uint128 liquidity, address virtualPoolAddress) = _enterFarming(key, tokenId);\n\n    IAlgebraEternalVirtualPool virtualPool = IAlgebraEternalVirtualPool(virtualPoolAddress);\n    (uint256 innerRewardGrowth0, uint256 innerRewardGrowth1) = _getInnerRewardsGrowth(virtualPool, tickLower, tickUpper);\n\n    farms[tokenId][incentiveId] = Farm(liquidity, tickLower, tickUpper, innerRewardGrowth0, innerRewardGrowth1);\n\n    emit FarmEntered(tokenId, incentiveId, liquidity);\n  }\n\n  /// @inheritdoc IAlgebraEternalFarming\n  function exitFarming(IncentiveKey memory key, uint256 tokenId, address _owner) external override onlyFarmingCenter {\n    bytes32 incentiveId = IncentiveId.compute(key);\n    Farm memory farm = _getFarm(tokenId, incentiveId);\n\n    uint256 reward;\n    uint256 bonusReward;\n    if (!isEmergencyWithdrawActivated) {\n      (reward, bonusReward) = _updatePosition(farm, key, incentiveId, _owner, -int256(uint256(farm.liquidity)).toInt128());\n    }\n\n    delete farms[tokenId][incentiveId];\n\n    emit FarmEnded(tokenId, incentiveId, address(key.rewardToken), address(key.bonusRewardToken), _owner, reward, bonusReward);\n  }\n\n  /// @inheritdoc IAlgebraEternalFarming\n  function claimReward(IERC20Minimal rewardToken, address to, uint256 amountRequested) external override returns (uint256 reward) {\n    return _claimReward(rewardToken, msg.sender, to, amountRequested);\n  }\n\n  /// @inheritdoc IAlgebraEternalFarming\n  function claimRewardFrom(\n    IERC20Minimal rewardToken,\n    address from,\n    address to,\n    uint256 amountRequested\n  ) external override onlyFarmingCenter returns (uint256 reward) {\n    return _claimReward(rewardToken, from, to, amountRequested);\n  }\n\n  function _updatePosition(\n    Farm memory farm,\n    IncentiveKey memory key,\n    bytes32 incentiveId,\n    address _owner,\n    int128 liquidityDelta\n  ) internal returns (uint256 reward, uint256 bonusReward) {\n    Incentive storage incentive = incentives[incentiveId];\n    IAlgebraEternalVirtualPool virtualPool = IAlgebraEternalVirtualPool(incentive.virtualPoolAddress);\n\n    if (_getCurrentVirtualPoolInPlugin(IFarmingPlugin(incentive.pluginAddress)) != address(virtualPool)) incentive.deactivated = true; // pool can \"detach\" by itself\n    int24 tick = incentive.deactivated ? virtualPool.globalTick() : _getTickInPool(key.pool);\n\n    // update rewards, as ticks may be cleared when liquidity decreases\n    _distributeRewards(virtualPool);\n\n    (reward, bonusReward, , ) = _getNewRewardsForFarm(virtualPool, farm);\n\n    // liquidityDelta will be nonzero\n    _updatePositionInVirtualPool(address(virtualPool), farm.tickLower, farm.tickUpper, liquidityDelta, tick);\n\n    mapping(IERC20Minimal => uint256) storage rewardBalances = rewards[_owner];\n    unchecked {\n      if (reward != 0) rewardBalances[key.rewardToken] += reward; // user must claim before overflow\n      if (bonusReward != 0) rewardBalances[key.bonusRewardToken] += bonusReward; // user must claim before overflow\n    }\n  }\n\n  /// @notice reward amounts can be outdated, actual amounts could be obtained via static call of `collectRewards` in FarmingCenter\n  /// @inheritdoc IAlgebraEternalFarming\n  function getRewardInfo(IncentiveKey memory key, uint256 tokenId) external view override returns (uint256 reward, uint256 bonusReward) {\n    bytes32 incentiveId = IncentiveId.compute(key);\n    Farm memory farm = _getFarm(tokenId, incentiveId);\n\n    IAlgebraEternalVirtualPool virtualPool = IAlgebraEternalVirtualPool(incentives[incentiveId].virtualPoolAddress);\n    (reward, bonusReward, , ) = _getNewRewardsForFarm(virtualPool, farm);\n  }\n\n  /// @notice reward amounts should be updated before calling this method\n  /// @inheritdoc IAlgebraEternalFarming\n  function collectRewards(\n    IncentiveKey memory key,\n    uint256 tokenId,\n    address _owner\n  ) external override onlyFarmingCenter returns (uint256 reward, uint256 bonusReward) {\n    (bytes32 incentiveId, Incentive storage incentive) = _getIncentiveByKey(key);\n    Farm memory farm = _getFarm(tokenId, incentiveId);\n\n    IAlgebraEternalVirtualPool virtualPool = IAlgebraEternalVirtualPool(incentive.virtualPoolAddress);\n    _distributeRewards(virtualPool);\n\n    uint256 innerRewardGrowth0;\n    uint256 innerRewardGrowth1;\n    (reward, bonusReward, innerRewardGrowth0, innerRewardGrowth1) = _getNewRewardsForFarm(virtualPool, farm);\n\n    Farm storage _farm = farms[tokenId][incentiveId];\n    _farm.innerRewardGrowth0 = innerRewardGrowth0;\n    _farm.innerRewardGrowth1 = innerRewardGrowth1;\n\n    mapping(IERC20Minimal => uint256) storage rewardBalances = rewards[_owner];\n    unchecked {\n      if (reward != 0) rewardBalances[key.rewardToken] += reward; // user must claim before overflow\n      if (bonusReward != 0) rewardBalances[key.bonusRewardToken] += bonusReward; // user must claim before overflow\n    }\n\n    emit RewardsCollected(tokenId, incentiveId, reward, bonusReward);\n  }\n\n  function _isIncentiveActive(Incentive storage incentive) private view returns (bool) {\n    address virtualPoolAddress = incentive.virtualPoolAddress;\n    bool _deactivated = incentive.deactivated;\n    if (!_deactivated) {\n      IAlgebraEternalVirtualPool virtualPool = IAlgebraEternalVirtualPool(virtualPoolAddress);\n      // TODO\n      _deactivated = virtualPool.deactivated();\n    }\n    return !_deactivated;\n  }\n\n  function _getInnerRewardsGrowth(IAlgebraEternalVirtualPool virtualPool, int24 tickLower, int24 tickUpper) private view returns (uint256, uint256) {\n    return virtualPool.getInnerRewardsGrowth(tickLower, tickUpper);\n  }\n\n  function _getNewRewardsForFarm(\n    IAlgebraEternalVirtualPool virtualPool,\n    Farm memory farm\n  ) private view returns (uint256 reward, uint256 bonusReward, uint256 innerRewardGrowth0, uint256 innerRewardGrowth1) {\n    (innerRewardGrowth0, innerRewardGrowth1) = _getInnerRewardsGrowth(virtualPool, farm.tickLower, farm.tickUpper);\n\n    (reward, bonusReward) = (\n      FullMath.mulDiv(innerRewardGrowth0 - farm.innerRewardGrowth0, farm.liquidity, Constants.Q128),\n      FullMath.mulDiv(innerRewardGrowth1 - farm.innerRewardGrowth1, farm.liquidity, Constants.Q128)\n    );\n  }\n\n  function _distributeRewards(IAlgebraEternalVirtualPool virtualPool) private {\n    virtualPool.distributeRewards();\n  }\n\n  function _addRewards(IAlgebraEternalVirtualPool virtualPool, uint128 amount0, uint128 amount1, bytes32 incentiveId) private {\n    virtualPool.addRewards(amount0, amount1);\n    emit RewardsAdded(amount0, amount1, incentiveId);\n  }\n\n  function _setRewardRates(IAlgebraEternalVirtualPool virtualPool, uint128 rate0, uint128 rate1, bytes32 incentiveId) private {\n    virtualPool.setRates(rate0, rate1);\n    emit RewardsRatesChanged(rate0, rate1, incentiveId);\n  }\n\n  function _connectVirtualPoolToPlugin(address virtualPool, IFarmingPlugin plugin) private {\n    farmingCenter.connectVirtualPoolToPlugin(plugin, virtualPool);\n  }\n\n  function _getCurrentVirtualPoolInPlugin(IFarmingPlugin plugin) internal view returns (address virtualPool) {\n    return plugin.incentive();\n  }\n\n  function _getFarm(uint256 tokenId, bytes32 incentiveId) private view returns (Farm memory result) {\n    result = farms[tokenId][incentiveId];\n    if (result.liquidity == 0) revert farmDoesNotExist();\n  }\n\n  function _receiveRewards(\n    IncentiveKey memory key,\n    uint128 reward,\n    uint128 bonusReward,\n    Incentive storage incentive\n  ) internal returns (uint128 receivedReward, uint128 receivedBonusReward) {\n    if (!unlocked) revert reentrancyLock();\n    unlocked = false; // reentrancy lock\n    if (reward > 0) receivedReward = _receiveToken(key.rewardToken, reward);\n    if (bonusReward > 0) receivedBonusReward = _receiveToken(key.bonusRewardToken, bonusReward);\n    unlocked = true;\n\n    (uint128 _totalRewardBefore, uint128 _bonusRewardBefore) = (incentive.totalReward, incentive.bonusReward);\n    incentive.totalReward = _totalRewardBefore + receivedReward;\n    incentive.bonusReward = _bonusRewardBefore + receivedBonusReward;\n  }\n\n  function _receiveToken(IERC20Minimal token, uint128 amount) private returns (uint128) {\n    uint256 balanceBefore = _getBalanceOf(token);\n    TransferHelper.safeTransferFrom(address(token), msg.sender, address(this), amount);\n    uint256 balanceAfter = _getBalanceOf(token);\n    require(balanceAfter > balanceBefore);\n    unchecked {\n      uint256 received = balanceAfter - balanceBefore;\n      if (received > type(uint128).max) revert invalidTokenAmount();\n      return (uint128(received));\n    }\n  }\n\n  function _enterFarming(\n    IncentiveKey memory key,\n    uint256 tokenId\n  ) internal returns (bytes32 incentiveId, int24 tickLower, int24 tickUpper, uint128 liquidity, address virtualPool) {\n    Incentive storage incentive;\n    (incentiveId, incentive) = _getIncentiveByKey(key);\n\n    if (farms[tokenId][incentiveId].liquidity != 0) revert tokenAlreadyFarmed();\n\n    virtualPool = incentive.virtualPoolAddress;\n    uint24 minimalAllowedTickWidth = incentive.minimalPositionWidth;\n\n    if (!_isIncentiveActive(incentive)) revert incentiveStopped();\n\n    IAlgebraPool pool;\n    (pool, tickLower, tickUpper, liquidity) = NFTPositionInfo.getPositionInfo(deployer, nonfungiblePositionManager, tokenId);\n\n    if (pool != key.pool) revert invalidPool();\n    if (liquidity == 0) revert zeroLiquidity();\n\n    unchecked {\n      if (int256(tickUpper) - int256(tickLower) < int256(uint256(minimalAllowedTickWidth))) revert positionIsTooNarrow();\n    }\n\n    int24 tick = _getTickInPool(pool);\n    _updatePositionInVirtualPool(virtualPool, tickLower, tickUpper, int256(uint256(liquidity)).toInt128(), tick);\n  }\n\n  function _claimReward(IERC20Minimal rewardToken, address from, address to, uint256 amountRequested) internal returns (uint256 reward) {\n    if (to == address(0)) revert claimToZeroAddress();\n    mapping(IERC20Minimal => uint256) storage userRewards = rewards[from];\n    reward = userRewards[rewardToken];\n\n    if (amountRequested == 0 || amountRequested > reward) amountRequested = reward;\n\n    if (amountRequested > 0) {\n      unchecked {\n        userRewards[rewardToken] = reward - amountRequested;\n      }\n      TransferHelper.safeTransfer(address(rewardToken), to, amountRequested);\n      emit RewardClaimed(to, amountRequested, address(rewardToken), from);\n    }\n  }\n\n  function _getIncentiveByKey(IncentiveKey memory key) internal view returns (bytes32 incentiveId, Incentive storage incentive) {\n    incentiveId = IncentiveId.compute(key);\n    incentive = incentives[incentiveId];\n    if (incentive.totalReward == 0) revert incentiveNotExist();\n  }\n\n  function _getTickInPool(IAlgebraPool pool) internal view returns (int24 tick) {\n    (, tick, , , , ) = pool.globalState();\n  }\n\n  function _getBalanceOf(IERC20Minimal token) internal view returns (uint256) {\n    return token.balanceOf(address(this));\n  }\n\n  function _updatePositionInVirtualPool(address virtualPool, int24 tickLower, int24 tickUpper, int128 liquidityDelta, int24 currentTick) internal {\n    IAlgebraEternalVirtualPool(virtualPool).applyLiquidityDeltaToPosition(tickLower, tickUpper, liquidityDelta, currentTick);\n  }\n}"
    }
  ]
}