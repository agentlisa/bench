{
  "Title": "There is a more efficient and secure way to compute `wstETH:ETH` price using Chainlink",
  "Content": "# There is a more efficient and secure way to compute `wstETH:ETH` price using Chainlink\n\n### Severity\nLow Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-04-beanstalk-2/blob/27ff8c87c9164c1fbff054be5f22e56f86cdf127/protocol/contracts/libraries/Oracle/LibWstethEthOracle.sol#L24-L37\">https://github.com/Cyfrin/2024-04-beanstalk-2/blob/27ff8c87c9164c1fbff054be5f22e56f86cdf127/protocol/contracts/libraries/Oracle/LibWstethEthOracle.sol#L24-L37</a>\n\n\n## Summary\n\nThe chosen `stETH:ETH` Chainlink Oracle has a huge heartbeat, which exposes the protocol to unnecessary risk that could be easily mitigated by chosing another path of computing the same price with two different Chainlink Oracles that have a better heartbeat.\n\n\n## Vulnerability Details\nAccording to the handy comments in `LibWstethEthOracle.sol` the price of`wstETH:ETH` is computed as follows:\n\n```\nThe oracle reads from 4 data sources:\na. wstETH:stETH Redemption Rate\nb. stETH:ETH Chainlink Oracle\nc. wstETH:ETH Uniswap Pool\nd. stETH:ETH Redemption (1:1)\n \nIt then computes the wstETH:ETH price in 3 ways:\n1. wstETH -> ETH via Chainlink: a * b \n2. wstETH -> ETH via wstETH:ETH Uniswap Pool: c * 1\n3. wstETH -> ETH via stETH redemption: a * d\n```\n\nLooking at the feed details on [Chainlink's Price Feed page](https://docs.chain.link/data-feeds/price-feeds/addresses?network=ethereum&page=1&search=stETH) we can see the following details:\n```\nPair: STETH / ETH\nDeviation 0.5%\t\nHeartbeat 86400s\nDecimals 18\n```\n\nOn the same page we find the following:\n```\nPair: STETH / USD\nDeviation 1%\t\nHeartbeat 3600s\nDecimals 8\n\t\nPair: ETH / USD\nDeviation 0.5%\t\nHeartbeat 3600s\nDecimals 8\n```\nChanging the way the Chainlink price is computed from `a * b` to `a * (STETH / USD) * 1/(ETH / USD)(adjusted for decimals)` would yield an overall heartbeat of 3600s (1 hour) vs the existing one of 86400s (1 day).\n\nA similar finding is available [here](https://solodit.xyz/issues/m-1-stetheth-chainlink-oracle-has-too-long-of-heartbeat-and-deviation-threshold-which-can-cause-loss-of-funds-sherlock-olympus-olympus-update-git). \n\nMoreover there's a strong chance this was the intention of the developer given that the [RFC](https://github.com/BeanstalkFarms/Beanstalk/issues/731) doesn't specify the `stETH:ETH Chainlink Oracle` but specifies the `stETH:USD Chainlink Oracle` and a different method of computing the `wstETH:ETH` price.\n\n## Impact\n\nProtocol could use inaccurate prices, or at least could benefit from a more accurate price feed in case the proposed changed is implemented.\n\nLikelihood: Low to Extremely Low\n\nImpact: The consumption of stale prices is usually Medium-High depending on how bad the consumed price is.\n\nOverall I consider the severity Low.\n\n## Tools Used\n\nManual review\n\n## Recommendations\n\nImplement the `a * (STETH / USD) * 1/(ETH / USD)(adjusted for decimals)` instead of `wstETH -> ETH via Chainlink: a * b` used currently.",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clu7665bs0001fmt5yahc8tyh",
  "Code": [
    {
      "filename": "protocol/contracts/libraries/Oracle/LibWstethEthOracle.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {LibChainlinkOracle} from \"./LibChainlinkOracle.sol\";\nimport {LibUniswapOracle} from \"./LibUniswapOracle.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {LibAppStorage, AppStorage} from \"contracts/libraries/LibAppStorage.sol\";\nimport {C} from \"contracts/C.sol\";\nimport {LibOracleHelpers} from \"contracts/libraries/Oracle/LibOracleHelpers.sol\";\n\ninterface IWsteth {\n    function stEthPerToken() external view returns (uint256);\n}\n\n/**\n * @title Wsteth Eth Oracle Library\n * @author brendan\n * @notice Computes the wstETH:ETH price.\n * @dev\n * The oracle reads from 4 data sources:\n * a. wstETH:stETH Redemption Rate: (0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0)\n * b. stETH:ETH Chainlink Oracle: (0x86392dC19c0b719886221c78AB11eb8Cf5c52812)\n * c. wstETH:ETH Uniswap Pool: (0x109830a1AAaD605BbF02a9dFA7B0B92EC2FB7dAa)\n * d. stETH:ETH Redemption: (1:1)\n *\n * It then computes the wstETH:ETH price in 3 ways:\n * 1. wstETH -> ETH via Chainlink: a * b\n * 2. wstETH -> ETH via wstETH:ETH Uniswap Pool: c * 1\n * 3. wstETH -> ETH via stETH redemption: a * d\n *\n * It then computes a wstETH:ETH price by taking the minimum of (3) and either the average of (1) and (2)\n * if (1) and (2) are within `MAX_DIFFERENCE` from each other or (1).\n **/\nlibrary LibWstethEthOracle {\n    using SafeMath for uint256;\n\n    // The maximum percent difference such that the oracle assumes no manipulation is occuring.\n    uint256 constant MAX_DIFFERENCE = 0.01e18; // 1%\n    uint256 constant CHAINLINK_DENOMINATOR = 1e6;\n    uint128 constant ONE = 1e18;\n    uint128 constant AVERAGE_DENOMINATOR = 2;\n    uint128 constant PRECISION_DENOMINATOR = 1e12;\n\n    /////////////////// ORACLES ///////////////////\n    address constant WSTETH_ETH_CHAINLINK_PRICE_AGGREGATOR =\n        0x86392dC19c0b719886221c78AB11eb8Cf5c52812;\n    address internal constant WSTETH_ETH_UNIV3_01_POOL = 0x109830a1AAaD605BbF02a9dFA7B0B92EC2FB7dAa; // 0.01% pool\n    ///////////////////////////////////////////////\n\n    /**\n     * @dev Returns the instantaneous wstETH/ETH price\n     * Return value has 6 decimal precision.\n     * Returns 0 if the either the Chainlink Oracle or Uniswap Oracle cannot fetch a valid price.\n     **/\n    function getWstethEthPrice() internal view returns (uint256) {\n        return getWstethEthPrice(0);\n    }\n\n    /**\n     * @dev Returns the wstETH/ETH price with the option of using a TWA lookback.\n     * Return value has 6 decimal precision.\n     * Returns 0 if the either the Chainlink Oracle or Uniswap Oracle cannot fetch a valid price.\n     **/\n    function getWstethEthPrice(uint256 lookback) internal view returns (uint256 wstethEthPrice) {\n\n        uint256 chainlinkPrice = lookback == 0 ? \n            LibChainlinkOracle.getPrice(WSTETH_ETH_CHAINLINK_PRICE_AGGREGATOR, LibChainlinkOracle.FOUR_DAY_TIMEOUT) :\n            LibChainlinkOracle.getTwap(WSTETH_ETH_CHAINLINK_PRICE_AGGREGATOR, LibChainlinkOracle.FOUR_DAY_TIMEOUT, lookback);\n\n        // Check if the chainlink price is broken or frozen.\n        if (chainlinkPrice == 0) return 0;\n\n        uint256 stethPerWsteth = IWsteth(C.WSTETH).stEthPerToken();\n        \n        chainlinkPrice = chainlinkPrice.mul(stethPerWsteth).div(CHAINLINK_DENOMINATOR);\n\n\n        // Uniswap V3 only supports a uint32 lookback.\n        if (lookback > type(uint32).max) return 0;\n        uint256 uniswapPrice = LibUniswapOracle.getTwap(\n            lookback == 0 ? LibUniswapOracle.FIFTEEN_MINUTES :\n            uint32(lookback),\n            WSTETH_ETH_UNIV3_01_POOL, C.WSTETH, C.WETH, ONE\n        );\n\n        // Check if the uniswapPrice oracle fails.\n        if (uniswapPrice == 0) return 0;\n\n        if (LibOracleHelpers.getPercentDifference(chainlinkPrice, uniswapPrice) < MAX_DIFFERENCE) {\n            wstethEthPrice = chainlinkPrice.add(uniswapPrice).div(AVERAGE_DENOMINATOR);\n            if (wstethEthPrice > stethPerWsteth) wstethEthPrice = stethPerWsteth;\n            wstethEthPrice = wstethEthPrice.div(PRECISION_DENOMINATOR);\n        }\n    }\n}"
    }
  ]
}