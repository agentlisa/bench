{
  "Title": "[H-08] `StrategyPUSDConvex.balanceOfJPEG` uses incorrect function signature while calling `extraReward.earned`, causing the function to unexpectedly revert everytime",
  "Content": "_Submitted by rayn_\n\n[StrategyPUSDConvex.sol#L234](https://github.com/code-423n4/2022-04-jpegd/blob/main/contracts/vaults/yVault/strategies/StrategyPUSDConvex.sol#L234)<br>\n\nAs specified in Convex [BaseRewardPool.sol](https://github.com/convex-eth/platform/blob/main/contracts/contracts/BaseRewardPool.sol#L149) and [VirtualRewardPool.sol](https://github.com/convex-eth/platform/blob/main/contracts/contracts/VirtualBalanceRewardPool.sol#L127), the function signature of `earned` is `earned(address)`. However, `balanceOfJPEG` did not pass any arguments to `earned`, which would cause `balanceOfJPEG` to always revert.\n\nThis bug will propagate through `Controller` and `YVault` until finally reaching the source of the call in `YVaultLPFarming ._computeUpdate`, and render the entire farming contract unuseable.\n\n### Proof of Concept\n\nBoth `BaseRewardPool.earned` and `VirtualBalanceRewardPool.earned` takes an address as argument\n\n        function earned(address account) public view returns (uint256) {\n            return\n                balanceOf(account)\n                    .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                    .div(1e18)\n                    .add(rewards[account]);\n        }\n\n        function earned(address account) public view returns (uint256) {\n            return\n                balanceOf(account)\n                    .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                    .div(1e18)\n                    .add(rewards[account]);\n        }\n\nBut `balanceOfJPEG` does not pass any address to `extraReward.earned`, causing the entire function to revert when called\n\n        function balanceOfJPEG() external view returns (uint256) {\n            uint256 availableBalance = jpeg.balanceOf(address(this));\n\n            IBaseRewardPool baseRewardPool = convexConfig.baseRewardPool;\n            uint256 length = baseRewardPool.extraRewardsLength();\n            for (uint256 i = 0; i < length; i++) {\n                IBaseRewardPool extraReward = IBaseRewardPool(baseRewardPool.extraRewards(i));\n                if (address(jpeg) == extraReward.rewardToken()) {\n                    availableBalance += extraReward.earned();\n                    //we found jpeg, no need to continue the loop\n                    break;\n                }\n            }\n\n            return availableBalance;\n        }\n\n### Tools Used\n\nvim, ganache-cli\n\n### Recommended Mitigation Steps\n\nPass `address(this)` as argument of `earned`.\n\nNotice how we modify the fetching of reward. This is reported in a separate bug report, but for completeness, the entire fix is shown in both report entries.\n\n        function balanceOfJPEG() external view returns (uint256) {\n            uint256 availableBalance = jpeg.balanceOf(address(this));\n\n            IBaseRewardPool baseRewardPool = convexConfig.baseRewardPool;\n            availableBalance += baseRewardPool.earned(address(this));\n            uint256 length = baseRewardPool.extraRewardsLength();\n            for (uint256 i = 0; i < length; i++) {\n                IBaseRewardPool extraReward = IBaseRewardPool(baseRewardPool.extraRewards(i));\n                if (address(jpeg) == extraReward.rewardToken()) {\n                    availableBalance += extraReward.earned(address(this));\n                }\n            }\n\n            return availableBalance;\n        }\n\n**[spaghettieth (JPEG'd) confirmed, but disagreed with High severity](https://github.com/code-423n4/2022-04-jpegd-findings/issues/139)**\n\n**[spaghettieth (JPEG'd) resolved and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/139#issuecomment-1099248200):**\n > Fixed in [jpegd/core#15](https://github.com/jpegd/core/pull/15).\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/139#issuecomment-1109915863):**\n > Leaving this as high risk. The issue would cause a loss of funds.\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2022-04-jpegd",
  "Code": [
    {
      "filename": "contracts/vaults/yVault/strategies/StrategyPUSDConvex.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../../interfaces/ISwapRouter.sol\";\nimport \"../../../interfaces/IUniswapV2Router.sol\";\nimport \"../../../interfaces/ICurve.sol\";\nimport \"../../../interfaces/IBooster.sol\";\nimport \"../../../interfaces/IBaseRewardPool.sol\";\n\nimport \"../../../interfaces/IController.sol\";\nimport \"../../../interfaces/IFungibleAssetVaultForDAO.sol\";\n\n/// @title JPEG'd PUSD Convex autocompounding strategy\n/// @notice This strategy autocompounds Convex rewards from the PUSD/USDC/USDT/MIM Curve pool.\n/// @dev The strategy deposits either USDC or PUSD in the Curve pool depending on which one has lower liquidity.\n/// The strategy sells reward tokens for USDC. If the pool has less PUSD than USDC, this contract uses the\n/// USDC {FungibleAssetVaultForDAO} to mint PUSD using USDC as collateral\ncontract StrategyPUSDConvex is AccessControl {\n    using SafeERC20 for IERC20;\n\n    event Harvested(uint256 wantEarned);\n\n    struct Rate {\n        uint128 numerator;\n        uint128 denominator;\n    }\n\n    /// @param booster Convex Booster's address\n    /// @param baseRewardPool Convex BaseRewardPool's address\n    /// @param pid The Convex pool id for PUSD/USDC/USDT/MIM LP tokens\n    struct ConvexConfig {\n        IBooster booster;\n        IBaseRewardPool baseRewardPool;\n        uint256 pid;\n    }\n\n    /// @param curve Curve's PUSD/USDC/USDT/MIM pool address\n    /// @param usdcIndex The USDC token index in curve's pool\n    /// @param pusdIndex The PUSD token index in curve's pool\n    struct CurveConfig {\n        ICurve curve;\n        uint256 usdcIndex;\n        uint256 pusdIndex;\n    }\n\n    /// @param uniswapV2 The UniswapV2 (or Sushiswap) router address\n    /// @param uniswapV3 The UniswapV3 router address\n    struct DexConfig {\n        IUniswapV2Router uniswapV2;\n        ISwapRouter uniswapV3;\n    }\n\n    /// @param rewardTokens The Convex reward tokens\n    /// @param controller The strategy controller\n    /// @param usdcVault The JPEG'd USDC {FungibleAssetVaultForDAO} address\n    struct StrategyConfig {\n        IERC20[] rewardTokens;\n        IController controller;\n        IFungibleAssetVaultForDAO usdcVault;\n    }\n\n    bytes32 public constant STRATEGIST_ROLE = keccak256(\"STRATEGIST_ROLE\");\n\n    /// @notice The PUSD/USDC/USDT/MIM Curve LP token\n    IERC20 public immutable want;\n    IERC20 public immutable jpeg;\n    IERC20 public immutable pusd;\n    IERC20 public immutable weth;\n    IERC20 public immutable usdc;\n\n    DexConfig public dexConfig;\n    CurveConfig public curveConfig;\n    ConvexConfig public convexConfig;\n    StrategyConfig public strategyConfig;\n\n    /// @notice The performance fee to be sent to the DAO/strategists\n    Rate public performanceFee;\n\n    /// @notice lifetime strategy earnings denominated in `want` token\n    uint256 public earned;\n\n    /// @param _want The PUSD/USDC/USDT/MIM Curve LP token\n    /// @param _jpeg The JPEG token address\n    /// @param _pusd The PUSD token address\n    /// @param _weth The WETH token address\n    /// @param _usdc The USDC token address\n    /// @param _dexConfig See {DexConfig} struct\n    /// @param _curveConfig See {CurveConfig} struct\n    /// @param _convexConfig See {ConvexConfig} struct\n    /// @param _strategyConfig See {StrategyConfig} struct\n    /// @param _performanceFee The rate of USDC to be sent to the DAO/strategists\n    constructor(\n        address _want,\n        address _jpeg,\n        address _pusd,\n        address _weth,\n        address _usdc,\n        DexConfig memory _dexConfig,\n        CurveConfig memory _curveConfig,\n        ConvexConfig memory _convexConfig,\n        StrategyConfig memory _strategyConfig,\n        Rate memory _performanceFee\n    ) {\n        require(_want != address(0), \"INVALID_WANT\");\n        require(_jpeg != address(0), \"INVALID_JPEG\");\n        require(_pusd != address(0), \"INVALID_PUSD\");\n        require(_weth != address(0), \"INVALID_WETH\");\n        require(_usdc != address(0), \"INVALID_USDC\");\n        require(\n            address(_dexConfig.uniswapV2) != address(0),\n            \"INVALID_UNISWAP_V2\"\n        );\n        require(\n            address(_dexConfig.uniswapV3) != address(0),\n            \"INVALID_UNISWAP_V3\"\n        );\n        require(address(_curveConfig.curve) != address(0), \"INVALID_CURVE\");\n        require(\n            _curveConfig.pusdIndex != _curveConfig.usdcIndex,\n            \"INVALID_CURVE_INDEXES\"\n        );\n        require(_curveConfig.pusdIndex < 4, \"INVALID_PUSD_CURVE_INDEX\");\n        require(_curveConfig.usdcIndex < 4, \"INVALID_USDC_CURVE_INDEX\");\n        require(\n            address(_convexConfig.booster) != address(0),\n            \"INVALID_CONVEX_BOOSTER\"\n        );\n        require(\n            address(_convexConfig.baseRewardPool) != address(0),\n            \"INVALID_CONVEX_BASE_REWARD_POOL\"\n        );\n        require(\n            address(_strategyConfig.controller) != address(0),\n            \"INVALID_CONTROLLER\"\n        );\n        require(\n            address(_strategyConfig.usdcVault) != address(0),\n            \"INVALID_USDC_VAULT\"\n        );\n\n        for (uint256 i = 0; i < _strategyConfig.rewardTokens.length; i++) {\n            require(\n                address(_strategyConfig.rewardTokens[i]) != address(0),\n                \"INVALID_REWARD_TOKEN\"\n            );\n        }\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        setPerformanceFee(_performanceFee);\n\n        want = IERC20(_want);\n        jpeg = IERC20(_jpeg);\n        pusd = IERC20(_pusd);\n        weth = IERC20(_weth);\n        usdc = IERC20(_usdc);\n\n        dexConfig = _dexConfig;\n        curveConfig = _curveConfig;\n        convexConfig = _convexConfig;\n        strategyConfig = _strategyConfig;\n    }\n\n    modifier onlyController() {\n        require(\n            msg.sender == address(strategyConfig.controller),\n            \"NOT_CONTROLLER\"\n        );\n        _;\n    }\n\n    /// @notice Allows the DAO to set the performance fee\n    /// @param _performanceFee The new performance fee\n    function setPerformanceFee(Rate memory _performanceFee)\n        public\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(\n            _performanceFee.denominator > 0 &&\n                _performanceFee.denominator >= _performanceFee.numerator,\n            \"INVALID_RATE\"\n        );\n        performanceFee = _performanceFee;\n    }\n\n    /// @notice Allows the DAO to set the strategy controller\n    /// @param _controller The new strategy controller\n    function setController(address _controller)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_controller != address(0), \"INVALID_CONTROLLER\");\n        strategyConfig.controller = IController(_controller);\n    }\n\n    /// @notice Allows the DAO to set the USDC vault\n    /// @param _vault The new USDC vault\n    function setUSDCVault(address _vault)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_vault != address(0), \"INVALID_USDC_VAULT\");\n        strategyConfig.usdcVault = IFungibleAssetVaultForDAO(_vault);\n    }\n\n    /// @return The strategy's name\n    function getName() external pure returns (string memory) {\n        return \"StrategyPUSDConvex\";\n    }\n\n    /// @return The amount of `want` tokens held by this contract\n    function balanceOfWant() public view returns (uint256) {\n        return want.balanceOf(address(this));\n    }\n\n    /// @return The amount of `want` tokens deposited in the Convex pool by this contract\n    function balanceOfPool() public view returns (uint256) {\n        return convexConfig.baseRewardPool.balanceOf(address(this));\n    }\n\n    /// @return The amount of JPEG currently held by this contract and the amount of JPEG\n    /// rewards available from Convex\n    function balanceOfJPEG() external view returns (uint256) {\n        uint256 availableBalance = jpeg.balanceOf(address(this));\n\n        IBaseRewardPool baseRewardPool = convexConfig.baseRewardPool;\n        uint256 length = baseRewardPool.extraRewardsLength();\n        for (uint256 i = 0; i < length; i++) {\n            IBaseRewardPool extraReward = IBaseRewardPool(baseRewardPool.extraRewards(i));\n            if (address(jpeg) == extraReward.rewardToken()) {\n                availableBalance += extraReward.earned();\n                //we found jpeg, no need to continue the loop\n                break;\n            }\n        }\n\n        return availableBalance;\n    }\n\n    /// @return The total amount of `want` tokens this contract manages (held + deposited)\n    function balanceOf() external view returns (uint256) {\n        return balanceOfWant() + balanceOfPool();\n    }\n\n    /// @notice Allows anyone to deposit the total amount of `want` tokens in this contract into Convex\n    function deposit() public {\n        uint256 balance = want.balanceOf(address(this));\n        ConvexConfig memory convex = convexConfig;\n        want.safeIncreaseAllowance(address(convex.booster), balance);\n        convex.booster.depositAll(convex.pid, true);\n    }\n\n    /// @notice Controller only function that allows to withdraw non-strategy tokens (e.g tokens sent accidentally)\n    function withdraw(IERC20 _asset)\n        external\n        onlyController\n        returns (uint256 balance)\n    {\n        require(want != _asset, \"want\");\n        require(pusd != _asset, \"pusd\");\n        require(usdc != _asset, \"usdc\");\n        require(weth != _asset, \"weth\");\n        require(jpeg != _asset, \"jpeg\");\n        balance = _asset.balanceOf(address(this));\n        _asset.safeTransfer(address(strategyConfig.controller), balance);\n    }\n\n    /// @notice Allows the controller to withdraw `want` tokens. Normally used with a vault withdrawal\n    /// @param _amount The amount of `want` tokens to withdraw\n    function withdraw(uint256 _amount) external onlyController {\n        address vault = strategyConfig.controller.vaults(address(want));\n        require(vault != address(0), \"ZERO_VAULT\"); // additional protection so we don't burn the funds\n\n        uint256 balance = want.balanceOf(address(this));\n        //if the contract doesn't have enough want, withdraw from Convex\n        if (balance < _amount)\n            convexConfig.baseRewardPool.withdrawAndUnwrap(\n                _amount - balance,\n                false\n            );\n\n        want.safeTransfer(vault, _amount);\n    }\n\n    /// @notice Allows the controller to withdraw all `want` tokens. Normally used when migrating strategies\n    /// @return balance The total amount of funds that have been withdrawn\n    function withdrawAll() external onlyController returns (uint256 balance) {\n        address vault = strategyConfig.controller.vaults(address(want));\n        require(vault != address(0), \"ZERO_VAULT\"); // additional protection so we don't burn the funds\n\n        convexConfig.baseRewardPool.withdrawAllAndUnwrap(false);\n\n        balance = want.balanceOf(address(this));\n        want.safeTransfer(vault, balance);\n    }\n\n    /// @notice Allows the controller to claim JPEG rewards from Convex\n    /// and withdraw JPEG to the `_to` address\n    /// @param _to The address to send JPEG to\n    function withdrawJPEG(address _to) external onlyController {\n        // claim from convex rewards pool\n        convexConfig.baseRewardPool.getReward(address(this), true);\n        jpeg.safeTransfer(_to, jpeg.balanceOf(address(this)));\n    }\n\n    /// @notice Allows members of the `STRATEGIST_ROLE` to compound Convex rewards into Curve\n    /// @param minOutCurve The minimum amount of `want` tokens to receive\n    function harvest(uint256 minOutCurve) external onlyRole(STRATEGIST_ROLE) {\n        convexConfig.baseRewardPool.getReward(address(this), true);\n\n        //Prevent `Stack too deep` errors\n        {\n            DexConfig memory dex = dexConfig;\n            IERC20[] memory rewardTokens = strategyConfig.rewardTokens;\n            IERC20 _weth = weth;\n            for (uint256 i = 0; i < rewardTokens.length; i++) {\n                uint256 balance = rewardTokens[i].balanceOf(address(this));\n\n                if (balance > 0)\n                    //minOut is not needed here, we already have it on the Curve deposit\n                    _swapUniswapV2(\n                        dex.uniswapV2,\n                        rewardTokens[i],\n                        _weth,\n                        balance,\n                        0\n                    );\n            }\n\n            uint256 wethBalance = _weth.balanceOf(address(this));\n            require(wethBalance > 0, \"NOOP\");\n\n            //handle sending jpeg here\n\n            _weth.safeIncreaseAllowance(address(dex.uniswapV3), wethBalance);\n\n            //minOut is not needed here, we already have it on the Curve deposit\n            ISwapRouter.ExactInputParams memory params = ISwapRouter\n                .ExactInputParams(\n                    abi.encodePacked(weth, uint24(500), usdc),\n                    address(this),\n                    block.timestamp,\n                    wethBalance,\n                    0\n                );\n\n            dex.uniswapV3.exactInput(params);\n        }\n\n        StrategyConfig memory strategy = strategyConfig;\n        CurveConfig memory curve = curveConfig;\n\n        uint256 usdcBalance = usdc.balanceOf(address(this));\n\n        //take the performance fee\n        uint256 fee = (usdcBalance * performanceFee.numerator) /\n            performanceFee.denominator;\n        usdc.safeTransfer(strategy.controller.feeAddress(), fee);\n        usdcBalance -= fee;\n\n        uint256 pusdCurveBalance = curve.curve.balances(curve.pusdIndex);\n        //USDC has 6 decimals while PUSD has 18. We need to convert the USDC\n        //balance to 18 decimals to compare it with the PUSD balance\n        uint256 usdcCurveBalance = curve.curve.balances(curve.usdcIndex) *\n            10**12;\n\n        //The curve pool has 4 tokens, we are doing a single asset deposit with either USDC or PUSD\n        uint256[4] memory liquidityAmounts = [uint256(0), 0, 0, 0];\n        if (usdcCurveBalance > pusdCurveBalance) {\n            //if there's more USDC than PUSD in the pool, use USDC as collateral to mint PUSD\n            //and deposit it into the Curve pool\n            usdc.safeIncreaseAllowance(\n                address(strategy.usdcVault),\n                usdcBalance\n            );\n            strategy.usdcVault.deposit(usdcBalance);\n\n            //check the vault's credit limit, it should be 1:1 for USDC\n            uint256 toBorrow = strategy.usdcVault.getCreditLimit(usdcBalance);\n\n            strategy.usdcVault.borrow(toBorrow);\n            liquidityAmounts[curve.pusdIndex] = toBorrow;\n\n            pusd.safeIncreaseAllowance(address(curve.curve), toBorrow);\n        } else {\n            //if there's more PUSD than USDC in the pool, deposit USDC\n            liquidityAmounts[curve.usdcIndex] = usdcBalance;\n            usdc.safeIncreaseAllowance(address(curve.curve), usdcBalance);\n        }\n\n        curve.curve.add_liquidity(liquidityAmounts, minOutCurve);\n\n        uint256 wantBalance = balanceOfWant();\n\n        deposit();\n\n        earned += wantBalance;\n        emit Harvested(wantBalance);\n    }\n\n    /// @dev Swaps `tokenIn` for `tokenOut` on UniswapV2 (or Sushiswap)\n    /// @param router The UniswapV2 (or Sushiswap) router\n    /// @param tokenIn The input token for the swap\n    /// @param tokenOut The output token for the swap\n    /// @param amountIn The amount of `tokenIn` to swap\n    /// @param minOut The minimum amount of `tokenOut` to receive for the TX not to revert\n    function _swapUniswapV2(\n        IUniswapV2Router router,\n        IERC20 tokenIn,\n        IERC20 tokenOut,\n        uint256 amountIn,\n        uint256 minOut\n    ) internal {\n        tokenIn.safeIncreaseAllowance(address(router), amountIn);\n\n        address[] memory path = new address[](2);\n        path[0] = address(tokenIn);\n        path[1] = address(tokenOut);\n\n        router.swapExactTokensForTokens(\n            amountIn,\n            minOut,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n}"
    },
    {
      "filename": "contracts/contracts/BaseRewardPool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n/**\n *Submitted for verification at Etherscan.io on 2020-07-17\n */\n\n/*\n   ____            __   __        __   _\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\n     /___/\n\n* Synthetix: BaseRewardPool.sol\n*\n* Docs: https://docs.synthetix.io/\n*\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\nimport \"./Interfaces.sol\";\nimport \"./interfaces/MathUtil.sol\";\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\n\n\n\ncontract BaseRewardPool {\n     using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public rewardToken;\n    IERC20 public stakingToken;\n    uint256 public constant duration = 7 days;\n\n    address public operator;\n    address public rewardManager;\n\n    uint256 public pid;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    uint256 public queuedRewards = 0;\n    uint256 public currentRewards = 0;\n    uint256 public historicalRewards = 0;\n    uint256 public constant newRewardRatio = 830;\n    uint256 private _totalSupply;\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) private _balances;\n\n    address[] public extraRewards;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n\n    constructor(\n        uint256 pid_,\n        address stakingToken_,\n        address rewardToken_,\n        address operator_,\n        address rewardManager_\n    ) public {\n        pid = pid_;\n        stakingToken = IERC20(stakingToken_);\n        rewardToken = IERC20(rewardToken_);\n        operator = operator_;\n        rewardManager = rewardManager_;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function extraRewardsLength() external view returns (uint256) {\n        return extraRewards.length;\n    }\n\n    function addExtraReward(address _reward) external returns(bool){\n        require(msg.sender == rewardManager, \"!authorized\");\n        require(_reward != address(0),\"!reward setting\");\n\n        extraRewards.push(_reward);\n        return true;\n    }\n    function clearExtraRewards() external{\n        require(msg.sender == rewardManager, \"!authorized\");\n        delete extraRewards;\n    }\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return MathUtil.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e18)\n                    .div(totalSupply())\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            balanceOf(account)\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n\n    function stake(uint256 _amount)\n        public\n        updateReward(msg.sender)\n        returns(bool)\n    {\n        require(_amount > 0, 'RewardPool : Cannot stake 0');\n        \n        //also stake to linked rewards\n        for(uint i=0; i < extraRewards.length; i++){\n            IRewards(extraRewards[i]).stake(msg.sender, _amount);\n        }\n\n        _totalSupply = _totalSupply.add(_amount);\n        _balances[msg.sender] = _balances[msg.sender].add(_amount);\n\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Staked(msg.sender, _amount);\n\n        \n        return true;\n    }\n\n    function stakeAll() external returns(bool){\n        uint256 balance = stakingToken.balanceOf(msg.sender);\n        stake(balance);\n        return true;\n    }\n\n    function stakeFor(address _for, uint256 _amount)\n        public\n        updateReward(_for)\n        returns(bool)\n    {\n        require(_amount > 0, 'RewardPool : Cannot stake 0');\n        \n        //also stake to linked rewards\n        for(uint i=0; i < extraRewards.length; i++){\n            IRewards(extraRewards[i]).stake(_for, _amount);\n        }\n\n        //give to _for\n        _totalSupply = _totalSupply.add(_amount);\n        _balances[_for] = _balances[_for].add(_amount);\n\n        //take away from sender\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Staked(_for, _amount);\n        \n        return true;\n    }\n\n\n    function withdraw(uint256 amount, bool claim)\n        public\n        updateReward(msg.sender)\n        returns(bool)\n    {\n        require(amount > 0, 'RewardPool : Cannot withdraw 0');\n\n        //also withdraw from linked rewards\n        for(uint i=0; i < extraRewards.length; i++){\n            IRewards(extraRewards[i]).withdraw(msg.sender, amount);\n        }\n\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        stakingToken.safeTransfer(msg.sender, amount);\n        emit Withdrawn(msg.sender, amount);\n     \n        if(claim){\n            getReward(msg.sender,true);\n        }\n\n        return true;\n    }\n\n    function withdrawAll(bool claim) external{\n        withdraw(_balances[msg.sender],claim);\n    }\n\n    function withdrawAndUnwrap(uint256 amount, bool claim) public updateReward(msg.sender) returns(bool){\n\n        //also withdraw from linked rewards\n        for(uint i=0; i < extraRewards.length; i++){\n            IRewards(extraRewards[i]).withdraw(msg.sender, amount);\n        }\n        \n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        //tell operator to withdraw from here directly to user\n        IDeposit(operator).withdrawTo(pid,amount,msg.sender);\n        emit Withdrawn(msg.sender, amount);\n\n        //get rewards too\n        if(claim){\n            getReward(msg.sender,true);\n        }\n        return true;\n    }\n\n    function withdrawAllAndUnwrap(bool claim) external{\n        withdrawAndUnwrap(_balances[msg.sender],claim);\n    }\n\n    function getReward(address _account, bool _claimExtras) public updateReward(_account) returns(bool){\n        uint256 reward = earned(_account);\n        if (reward > 0) {\n            rewards[_account] = 0;\n            rewardToken.safeTransfer(_account, reward);\n            IDeposit(operator).rewardClaimed(pid, _account, reward);\n            emit RewardPaid(_account, reward);\n        }\n\n        //also get rewards from linked rewards\n        if(_claimExtras){\n            for(uint i=0; i < extraRewards.length; i++){\n                IRewards(extraRewards[i]).getReward(_account);\n            }\n        }\n        return true;\n    }\n\n    function getReward() external returns(bool){\n        getReward(msg.sender,true);\n        return true;\n    }\n\n    function donate(uint256 _amount) external returns(bool){\n        IERC20(rewardToken).safeTransferFrom(msg.sender, address(this), _amount);\n        queuedRewards = queuedRewards.add(_amount);\n    }\n\n    function queueNewRewards(uint256 _rewards) external returns(bool){\n        require(msg.sender == operator, \"!authorized\");\n\n        _rewards = _rewards.add(queuedRewards);\n\n        if (block.timestamp >= periodFinish) {\n            notifyRewardAmount(_rewards);\n            queuedRewards = 0;\n            return true;\n        }\n\n        //et = now - (finish-duration)\n        uint256 elapsedTime = block.timestamp.sub(periodFinish.sub(duration));\n        //current at now: rewardRate * elapsedTime\n        uint256 currentAtNow = rewardRate * elapsedTime;\n        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);\n\n        //uint256 queuedRatio = currentRewards.mul(1000).div(_rewards);\n        if(queuedRatio < newRewardRatio){\n            notifyRewardAmount(_rewards);\n            queuedRewards = 0;\n        }else{\n            queuedRewards = _rewards;\n        }\n        return true;\n    }\n\n    function notifyRewardAmount(uint256 reward)\n        internal\n        updateReward(address(0))\n    {\n        historicalRewards = historicalRewards.add(reward);\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(duration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            reward = reward.add(leftover);\n            rewardRate = reward.div(duration);\n        }\n        currentRewards = reward;\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(duration);\n        emit RewardAdded(reward);\n    }\n}"
    }
  ]
}