{
  "Title": "[G-14] Functions guaranteed to revert when called by normal users can be marked payable",
  "Content": "\nIf a function modifier or require such as `onlyOwner`/`onlyX` is used, the function will revert if a normal user tries to pay the function. Marking the function as payable will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are `CALLVALUE`(2), `DUP1`(3), `ISZERO`(3), `PUSH2`(3), `JUMPI`(10), `PUSH1`(3), `DUP1`(3), `REVERT`(0), `JUMPDEST`(1), `POP`(2) which costs an average of about 21 gas per call to the function, in addition to the extra deployment cost.\n\nThe recommended mitigation steps is that functions guaranteed to revert when called by normal users can be marked payable.\n\n**Instances:**\n\n<details>\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L859-#L896\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L939-#L967\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L1055-#L1080\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L1412-#L1428\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseSecurity/WiseSecurity.sol#L85-#L100\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseSecurity/WiseSecurity.sol#L142-#L187\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseSecurity/WiseSecurity.sol#L193-#L232\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseSecurity/WiseSecurity.sol#L405-#L436\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseSecurity/WiseSecurity.sol#L980-#L988\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseSecurity/WiseSecurity.sol#L995-#L1003\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseSecurity/WiseSecurity.sol#L1032-#L1039\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseSecurity/WiseSecurity.sol#L1111-#L1122\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L592-#L603\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L49-#L60\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L66-#L77\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L82-#L102\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L108-#L129\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L135-#L166\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L173-#L189\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L214-#L226\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L232-#L244\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L390-#L406\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L412-#L432\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L438-#L487\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L494-#L508\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L514-#L531\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L538-#L565\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L571-#L598\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L32-#L51\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L211-#L291\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L293-#L319\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L321-#L332\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L334-#L359\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L364-#L429\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L431-#L449\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L451-#L495\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L497-#L524\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L526-#L542\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L544-#L564\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L566-#L579\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L600-#L610\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmController.sol#L612-#L644\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLendingDeclaration.sol#L140-#L159\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseOracleHub/WiseOracleHub.sol#L218-#L260\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseOracleHub/WiseOracleHub.sol#L266-#L321\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseOracleHub/WiseOracleHub.sol#L359-#L372\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseOracleHub/WiseOracleHub.sol#L379-#L401\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseOracleHub/WiseOracleHub.sol#L403-#L412\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WrapperHub/AaveHub.sol#L44-#L56\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WrapperHub/AaveHub.sol#L64-#L77\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WrapperHub/AaveHub.sol#L611-#L628\n\n</details>\n\n### Conclusion\n\nAs you embark on incorporating the recommended optimizations, we want to emphasize the utmost importance of proceeding with vigilance and dedicating thorough efforts to comprehensive testing. It is of paramount significance to ensure that the proposed alterations do not inadvertently introduce fresh vulnerabilities, while also successfully achieving the anticipated enhancements in performance.\n\nWe strongly advise conducting a meticulous and exhaustive evaluation of the modifications made to the codebase. This rigorous scrutiny and exhaustive assessment will play a pivotal role in affirming both the security and efficacy of the refactored code. Your careful attention to detail, coupled with the implementation of a robust testing framework, will provide the necessary assurance that the refined code aligns with your security objectives and effectively fulfills the intended performance optimizations.\n\n**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/248#issuecomment-2020202798):**\n > Highest quality submission and includes estimated gas savings which line up with opcode costs.\n\n***\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-02-wise-lending",
  "Code": [
    {
      "filename": "contracts/WiseLending.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\n/**\n * @author RenÃ© Hochmuth\n * @author Christoph Krpoun\n * @author Vitally Marinchenko\n */\n\nimport \"./PoolManager.sol\";\n\n/**\n * @dev WISE lending is an automated lending platform on which users can collateralize\n * their assets and borrow tokens against them.\n *\n * Users need to pay borrow rates for debt tokens, which are reflected in a borrow APY for\n * each asset type (pool). This borrow rate is variable over time and determined through the\n * utilization of the pool. The bounding curve is a family of different bonding curves adjusted\n * automatically by LASA (Lending Automated Scaling Algorithm). For more information, see:\n * [https://wisesoft.gitbook.io/wise/wise-lending-protocol/lasa-ai]\n *\n * In addition to normal deposit, withdraw, borrow, and payback functions, there are other\n * interacting modes:\n *\n * - Solely deposit and withdraw allows the user to keep their funds private, enabling\n *    them to withdraw even when the pools are borrowed empty.\n *\n * - Aave pools  allow for maximal capital efficiency by earning aave supply APY for not\n *   borrowed funds.\n *\n * - Special curve pools nside beefy farms can be used as collateral, opening up new usage\n *   possibilities for these asset types.\n *\n * - Users can pay back their borrow with lending shares of the same asset type, making it\n *   easier to manage their positions.\n *\n * - Users save their collaterals and borrows inside a position NFT, making it possible\n *   to trade their whole positions or use them in second-layer contracts\n *   (e.g., spot trading with PTP NFT trading platforms).\n */\n\ncontract WiseLending is PoolManager {\n\n    /**\n     * @dev Standard receive functions forwarding\n     * directly send ETH to the master address.\n     */\n    receive()\n        external\n        payable\n    {\n        if (msg.sender == WETH_ADDRESS) {\n            return;\n        }\n\n        _sendValue(\n            master,\n            msg.value\n        );\n    }\n\n    /**\n     * @dev Checks if position is healthy\n     * after all state changes are done.\n     */\n    modifier healthStateCheck(\n        uint256 _nftId\n    ) {\n        _;\n\n        _healthStateCheck(\n            _nftId\n        );\n    }\n\n    function _healthStateCheck(\n        uint256 _nftId\n    )\n        private\n    {\n        _checkHealthState(\n            _nftId,\n            powerFarmCheck\n        );\n\n        if (powerFarmCheck == true) {\n            powerFarmCheck = false;\n        }\n    }\n\n    /**\n     * @dev Runs the LASA algorithm known as\n     * Lending Automated Scaling Algorithm\n     * and updates pool data based on token\n     */\n    modifier syncPool(\n        address _poolToken\n    ) {\n        (\n            uint256 lendSharePrice,\n            uint256 borrowSharePrice\n        ) = _syncPoolBeforeCodeExecution(\n            _poolToken\n        );\n\n        _;\n\n        _syncPoolAfterCodeExecution(\n            _poolToken,\n            lendSharePrice,\n            borrowSharePrice\n        );\n    }\n\n    constructor(\n        address _master,\n        address _wiseOracleHubAddress,\n        address _nftContract\n    )\n        WiseLendingDeclaration(\n            _master,\n            _wiseOracleHubAddress,\n            _nftContract\n        )\n    {}\n\n    function _emitFundsSolelyWithdrawn(\n        address _caller,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        private\n    {\n        emit FundsSolelyWithdrawn(\n            _caller,\n            _nftId,\n            _poolToken,\n            _amount,\n            block.timestamp\n        );\n    }\n\n    function _emitFundsSolelyDeposited(\n        address _caller,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        private\n    {\n        emit FundsSolelyDeposited(\n            _caller,\n            _nftId,\n            _poolToken,\n            _amount,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Fetches share price of lending shares.\n     */\n    function _getSharePrice(\n        address _poolToken\n    )\n        private\n        view\n        returns (\n            uint256,\n            uint256\n        )\n    {\n        uint256 borrowSharePrice = borrowPoolData[_poolToken].pseudoTotalBorrowAmount\n            * PRECISION_FACTOR_E18\n            / borrowPoolData[_poolToken].totalBorrowShares;\n\n        _validateParameter(\n            MIN_BORROW_SHARE_PRICE,\n            borrowSharePrice\n        );\n\n        return (\n            lendingPoolData[_poolToken].pseudoTotalPool\n                * PRECISION_FACTOR_E18\n                / lendingPoolData[_poolToken].totalDepositShares,\n            borrowSharePrice\n        );\n    }\n\n    function _checkHealthState(\n        uint256 _nftId,\n        bool _powerFarm\n    )\n        internal\n        view\n    {\n        WISE_SECURITY.checkHealthState(\n            _nftId,\n            _powerFarm\n        );\n    }\n\n    /**\n     * @dev Compares share prices before and after\n     * execution. If borrow share price increased\n     * or lending share price decreased, revert.\n     */\n    function _compareSharePrices(\n        address _poolToken,\n        uint256 _lendSharePriceBefore,\n        uint256 _borrowSharePriceBefore\n    )\n        private\n        view\n    {\n        (\n            uint256 lendSharePriceAfter,\n            uint256 borrowSharePriceAfter\n        ) = _getSharePrice(\n            _poolToken\n        );\n\n        uint256 currentSharePriceMax = _getCurrentSharePriceMax(\n            _poolToken\n        );\n\n        _validateParameter(\n            _lendSharePriceBefore,\n            lendSharePriceAfter\n        );\n\n        _validateParameter(\n            lendSharePriceAfter,\n            currentSharePriceMax\n        );\n\n        _validateParameter(\n            _borrowSharePriceBefore,\n            currentSharePriceMax\n        );\n\n        _validateParameter(\n            borrowSharePriceAfter,\n            _borrowSharePriceBefore\n        );\n    }\n\n    /**\n    * @dev Since pool inception share price\n    * increase for both lending and borrow shares\n    * is capped at 500% apr max in between a transaction.\n    */\n    function _getCurrentSharePriceMax(\n        address _poolToken\n    )\n        private\n        view\n        returns (uint256)\n    {\n        uint256 timeDifference = block.timestamp\n            - timestampsPoolData[_poolToken].initialTimeStamp;\n\n        return timeDifference\n            * RESTRICTION_FACTOR\n            + PRECISION_FACTOR_E18;\n    }\n\n    /**\n     * @dev First part of pool sync updating pseudo\n     * amounts. Is skipped when powerFarms or aaveHub\n     * is calling the function.\n     */\n    function _syncPoolBeforeCodeExecution(\n        address _poolToken\n    )\n        private\n        returns (\n            uint256 lendSharePrice,\n            uint256 borrowSharePrice\n        )\n    {\n        _checkReentrancy();\n\n        _preparePool(\n            _poolToken\n        );\n\n        if (_aboveThreshold(_poolToken) == true) {\n            _scalingAlgorithm(\n                _poolToken\n            );\n        }\n\n        (\n            lendSharePrice,\n            borrowSharePrice\n        ) = _getSharePrice(\n            _poolToken\n        );\n    }\n\n    /**\n     * @dev Second part of pool sync updating\n     * the borrow pool rate and share price.\n     */\n    function _syncPoolAfterCodeExecution(\n        address _poolToken,\n        uint256 _lendSharePriceBefore,\n        uint256 _borrowSharePriceBefore\n    )\n        private\n    {\n        _newBorrowRate(\n            _poolToken\n        );\n\n        _compareSharePrices(\n            _poolToken,\n            _lendSharePriceBefore,\n            _borrowSharePriceBefore\n        );\n    }\n\n    /**\n     * @dev Enables _poolToken to be used as a collateral.\n     */\n    function collateralizeDeposit(\n        uint256 _nftId,\n        address _poolToken\n    )\n        external\n        syncPool(_poolToken)\n    {\n        WISE_SECURITY.checksCollateralizeDeposit(\n            _nftId,\n            msg.sender,\n            _poolToken\n        );\n\n        userLendingData[_nftId][_poolToken].unCollateralized = false;\n    }\n\n    /**\n     * @dev Disables _poolToken to be used as a collateral.\n     */\n    function unCollateralizeDeposit(\n        uint256 _nftId,\n        address _poolToken\n    )\n        external\n        syncPool(_poolToken)\n    {\n        _checkOwnerPosition(\n            _nftId,\n            msg.sender\n        );\n\n        (\n            address[] memory lendTokens,\n            address[] memory borrowTokens\n        ) = _prepareAssociatedTokens(\n            _nftId,\n            _poolToken,\n            ZERO_ADDRESS\n        );\n\n        userLendingData[_nftId][_poolToken].unCollateralized = true;\n\n        WISE_SECURITY.checkUncollateralizedDeposit(\n            _nftId,\n            _poolToken\n        );\n\n        _curveSecurityChecks(\n            lendTokens,\n            borrowTokens\n        );\n    }\n\n    // --------------- Deposit Functions -------------\n\n    /**\n     * @dev Allows to supply funds using ETH.\n     * Without converting to WETH, use ETH directly.\n     */\n    function depositExactAmountETH(\n        uint256 _nftId\n    )\n        external\n        payable\n        syncPool(WETH_ADDRESS)\n        returns (uint256)\n    {\n        return _depositExactAmountETH(\n            _nftId\n        );\n    }\n\n    function _depositExactAmountETH(\n        uint256 _nftId\n    )\n        private\n        returns (uint256)\n    {\n        uint256 shareAmount = _handleDeposit(\n            msg.sender,\n            _nftId,\n            WETH_ADDRESS,\n            msg.value\n        );\n\n        _wrapETH(\n            msg.value\n        );\n\n        return shareAmount;\n    }\n\n    /**\n     * @dev Allows to supply funds using ETH.\n     * Without converting to WETH, use ETH directly,\n     * also mints position to avoid extra transaction.\n     */\n    function depositExactAmountETHMint()\n        external\n        payable\n        syncPool(WETH_ADDRESS)\n        returns (uint256)\n    {\n        return _depositExactAmountETH(\n            _reservePosition()\n        );\n    }\n\n    /**\n     * @dev Allows to supply _poolToken and user\n     * can decide if _poolToken should be collateralized,\n     * also mints position to avoid extra transaction.\n     */\n    function depositExactAmountMint(\n        address _poolToken,\n        uint256 _amount\n    )\n        external\n        returns (uint256)\n    {\n        return depositExactAmount(\n            _reservePosition(),\n            _poolToken,\n            _amount\n        );\n    }\n\n    /**\n     * @dev Allows to supply _poolToken and user\n     * can decide if _poolToken should be collateralized.\n     */\n    function depositExactAmount(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        public\n        syncPool(_poolToken)\n        returns (uint256)\n    {\n        uint256 shareAmount = _handleDeposit(\n            msg.sender,\n            _nftId,\n            _poolToken,\n            _amount\n        );\n\n        _safeTransferFrom(\n            _poolToken,\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        return shareAmount;\n    }\n\n    /**\n     * @dev Allows to supply funds using ETH in solely mode,\n     * which does not earn APY, but keeps the funds private.\n     * Other users are restricted from borrowing these funds,\n     * owner can always withdraw even if all funds are borrowed.\n     * Also mints position to avoid extra transaction.\n     */\n    function solelyDepositETHMint()\n        external\n        payable\n    {\n        solelyDepositETH(\n            _reservePosition()\n        );\n    }\n\n    /**\n     * @dev Allows to supply funds using ETH in solely mode,\n     * which does not earn APY, but keeps the funds private.\n     * Other users are restricted from borrowing these funds,\n     * owner can always withdraw even if all funds are borrowed.\n     */\n    function solelyDepositETH(\n        uint256 _nftId\n    )\n        public\n        payable\n        syncPool(WETH_ADDRESS)\n    {\n        _handleSolelyDeposit(\n            msg.sender,\n            _nftId,\n            WETH_ADDRESS,\n            msg.value\n        );\n\n        _wrapETH(\n            msg.value\n        );\n\n        _emitFundsSolelyDeposited(\n            msg.sender,\n            _nftId,\n            WETH_ADDRESS,\n            msg.value\n        );\n    }\n\n    /**\n     * @dev Core function combining\n     * supply logic with security\n     * checks for solely deposit.\n     */\n    function _handleSolelyDeposit(\n        address _caller,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        private\n    {\n        _checkDeposit(\n            _nftId,\n            _caller,\n            _poolToken,\n            _amount\n        );\n\n        _increaseMappingValue(\n            pureCollateralAmount,\n            _nftId,\n            _poolToken,\n            _amount\n        );\n\n        _increaseTotalBareToken(\n            _poolToken,\n            _amount\n        );\n\n        _addPositionTokenData(\n            _nftId,\n            _poolToken,\n            hashMapPositionLending,\n            positionLendTokenData\n        );\n    }\n\n    /**\n     * @dev Allows to supply funds using ERC20 in solely mode,\n     * which does not earn APY, but keeps the funds private.\n     * Other users are restricted from borrowing these funds,\n     * owner can always withdraw even if all funds are borrowed.\n     * Also mints position to avoid extra transaction.\n     */\n    function solelyDepositMint(\n        address _poolToken,\n        uint256 _amount\n    )\n        external\n    {\n        solelyDeposit(\n            _reservePosition(),\n            _poolToken,\n            _amount\n        );\n    }\n\n    /**\n     * @dev Allows to supply funds using ERC20 in solely mode,\n     * which does not earn APY, but keeps the funds private.\n     * Other users are restricted from borrowing these funds,\n     * owner can always withdraw even if all funds are borrowed.\n     */\n    function solelyDeposit(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        public\n        syncPool(_poolToken)\n    {\n        _handleSolelyDeposit(\n            msg.sender,\n            _nftId,\n            _poolToken,\n            _amount\n        );\n\n        _emitFundsSolelyDeposited(\n            msg.sender,\n            _nftId,\n            _poolToken,\n            _amount\n        );\n\n        _safeTransferFrom(\n            _poolToken,\n            msg.sender,\n            address(this),\n            _amount\n        );\n    }\n\n    // --------------- Withdraw Functions -------------\n\n    /**\n     * @dev Allows to withdraw publicly\n     * deposited ETH funds using exact amount.\n     */\n    function withdrawExactAmountETH(\n        uint256 _nftId,\n        uint256 _amount\n    )\n        external\n        syncPool(WETH_ADDRESS)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        uint256 withdrawShares = _handleWithdrawAmount(\n            {\n                _caller: msg.sender,\n                _nftId: _nftId,\n                _poolToken: WETH_ADDRESS,\n                _amount: _amount,\n                _onBehalf: false\n            }\n        );\n\n        _validateNonZero(\n            withdrawShares\n        );\n\n        _unwrapETH(\n            _amount\n        );\n\n        _sendValue(\n            msg.sender,\n            _amount\n        );\n\n        return withdrawShares;\n    }\n\n    /**\n     * @dev Allows to withdraw publicly\n     * deposited ETH funds using exact shares.\n     */\n    function withdrawExactSharesETH(\n        uint256 _nftId,\n        uint256 _shares\n    )\n        external\n        syncPool(WETH_ADDRESS)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        uint256 withdrawAmount = _handleWithdrawShares(\n            {\n                _caller: msg.sender,\n                _nftId: _nftId,\n                _poolToken: WETH_ADDRESS,\n                _shares: _shares,\n                _onBehalf: false\n            }\n        );\n\n        _validateNonZero(\n            withdrawAmount\n        );\n\n        _unwrapETH(\n            withdrawAmount\n        );\n\n        _sendValue(\n            msg.sender,\n            withdrawAmount\n        );\n\n        return withdrawAmount;\n    }\n\n    /**\n     * @dev Allows to withdraw publicly\n     * deposited ERC20 funds using exact amount.\n     */\n    function withdrawExactAmount(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _withdrawAmount\n    )\n        external\n        syncPool(_poolToken)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        uint256 withdrawShares = _handleWithdrawAmount(\n            {\n                _caller: msg.sender,\n                _nftId: _nftId,\n                _poolToken: _poolToken,\n                _amount: _withdrawAmount,\n                _onBehalf: false\n            }\n        );\n\n        _validateNonZero(\n            withdrawShares\n        );\n\n        _safeTransfer(\n            _poolToken,\n            msg.sender,\n            _withdrawAmount\n        );\n\n        return withdrawShares;\n    }\n\n    /**\n     * @dev Allows to withdraw privately\n     * deposited ETH funds using input amount.\n     */\n    function solelyWithdrawETH(\n        uint256 _nftId,\n        uint256 _withdrawAmount\n    )\n        external\n        syncPool(WETH_ADDRESS)\n        healthStateCheck(_nftId)\n    {\n        _handleSolelyWithdraw(\n            msg.sender,\n            _nftId,\n            WETH_ADDRESS,\n            _withdrawAmount\n        );\n\n        _unwrapETH(\n            _withdrawAmount\n        );\n\n        _sendValue(\n            msg.sender,\n            _withdrawAmount\n        );\n    }\n\n    /**\n     * @dev Allows to withdraw privately\n     * deposited ERC20 funds using input amount.\n     */\n    function solelyWithdraw(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _withdrawAmount\n    )\n        external\n        syncPool(_poolToken)\n        healthStateCheck(_nftId)\n    {\n        _handleSolelyWithdraw(\n            msg.sender,\n            _nftId,\n            _poolToken,\n            _withdrawAmount\n        );\n\n        _safeTransfer(\n            _poolToken,\n            msg.sender,\n            _withdrawAmount\n        );\n    }\n\n    /**\n     * @dev Core function combining\n     * withdraw logic for solely\n     * withdraw with security checks.\n     */\n    function _coreSolelyWithdraw(\n        address _caller,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        private\n    {\n        (\n            address[] memory lendTokens,\n            address[] memory borrowTokens\n        ) = _prepareAssociatedTokens(\n            _nftId,\n            _poolToken,\n            ZERO_ADDRESS\n        );\n\n        powerFarmCheck = WISE_SECURITY.checksSolelyWithdraw(\n            _nftId,\n            _caller,\n            _poolToken\n        );\n\n        _decreasePositionMappingValue(\n            pureCollateralAmount,\n            _nftId,\n            _poolToken,\n            _amount\n        );\n\n        _decreaseTotalBareToken(\n            _poolToken,\n            _amount\n        );\n\n        _removeEmptyLendingData(\n            _nftId,\n            _poolToken\n        );\n\n        _curveSecurityChecks(\n            lendTokens,\n            borrowTokens\n        );\n    }\n\n    /**\n     * @dev Allows to withdraw privately\n     * deposited ERC20 on behalf of owner.\n     * Requires approval by _nftId owner.\n     */\n    function withdrawOnBehalfExactAmount(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _withdrawAmount\n    )\n        external\n        onlyAaveHub\n        syncPool(_poolToken)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        uint256 withdrawShares = calculateLendingShares(\n            {\n                _poolToken: _poolToken,\n                _amount: _withdrawAmount,\n                _maxSharePrice: true\n            }\n        );\n\n        _coreWithdrawToken(\n            {\n                _caller: msg.sender,\n                _nftId: _nftId,\n                _poolToken: _poolToken,\n                _amount: _withdrawAmount,\n                _shares: withdrawShares,\n                _onBehalf: true\n            }\n        );\n\n        _safeTransfer(\n            _poolToken,\n            msg.sender,\n            _withdrawAmount\n        );\n\n        return withdrawShares;\n    }\n\n    /**\n     * @dev Allows to withdraw ERC20\n     * funds using shares as input value\n     */\n    function withdrawExactShares(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _shares\n    )\n        external\n        syncPool(_poolToken)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        uint256 withdrawAmount = _handleWithdrawShares(\n            {\n                _caller: msg.sender,\n                _nftId: _nftId,\n                _poolToken: _poolToken,\n                _shares: _shares,\n                _onBehalf: false\n            }\n        );\n\n        _validateNonZero(\n            withdrawAmount\n        );\n\n        _safeTransfer(\n            _poolToken,\n            msg.sender,\n            withdrawAmount\n        );\n\n        return withdrawAmount;\n    }\n\n    /**\n     * @dev Withdraws ERC20 funds on behalf\n     * of _nftId owner, requires approval.\n     */\n    function withdrawOnBehalfExactShares(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _shares\n    )\n        external\n        onlyAaveHub\n        syncPool(_poolToken)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        uint256 withdrawAmount = _handleWithdrawShares(\n            {\n                _caller: msg.sender,\n                _nftId: _nftId,\n                _poolToken: _poolToken,\n                _shares: _shares,\n                _onBehalf: true\n            }\n        );\n\n        _safeTransfer(\n            _poolToken,\n            msg.sender,\n            withdrawAmount\n        );\n\n        return withdrawAmount;\n    }\n\n    // --------------- Borrow Functions -------------\n\n    /**\n     * @dev Allows to borrow ETH funds\n     * Requires user to have collateral.\n     */\n    function borrowExactAmountETH(\n        uint256 _nftId,\n        uint256 _amount\n    )\n        external\n        syncPool(WETH_ADDRESS)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        _checkOwnerPosition(\n            _nftId,\n            msg.sender\n        );\n\n        uint256 shares = _handleBorrowExactAmount({\n            _nftId: _nftId,\n            _poolToken: WETH_ADDRESS,\n            _amount: _amount,\n            _onBehalf: false\n        });\n\n        _validateNonZero(\n            shares\n        );\n\n        _unwrapETH(\n            _amount\n        );\n\n        _sendValue(\n            msg.sender,\n            _amount\n        );\n\n        return shares;\n    }\n\n    /**\n     * @dev Allows to borrow ERC20 funds\n     * Requires user to have collateral.\n     */\n    function borrowExactAmount(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        external\n        syncPool(_poolToken)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        _checkOwnerPosition(\n            _nftId,\n            msg.sender\n        );\n\n        uint256 shares = _handleBorrowExactAmount({\n            _nftId: _nftId,\n            _poolToken: _poolToken,\n            _amount: _amount,\n            _onBehalf: false\n        });\n\n        _validateNonZero(\n            shares\n        );\n\n        _safeTransfer(\n            _poolToken,\n            msg.sender,\n            _amount\n        );\n\n        return shares;\n    }\n\n    /**\n     * @dev Allows to borrow ERC20 funds\n     * on behalf of _nftId owner, if approved.\n     */\n    function borrowOnBehalfExactAmount(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        external\n        onlyAaveHub\n        syncPool(_poolToken)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        uint256 shares = _handleBorrowExactAmount({\n            _nftId: _nftId,\n            _poolToken: _poolToken,\n            _amount: _amount,\n            _onBehalf: true\n        });\n\n        _safeTransfer(\n            _poolToken,\n            msg.sender,\n            _amount\n        );\n\n        return shares;\n    }\n\n    // --------------- Payback Functions ------------\n\n    /**\n     * @dev Ability to payback ETH loans\n     * by providing exact payback amount.\n     */\n    function paybackExactAmountETH(\n        uint256 _nftId\n    )\n        external\n        payable\n        syncPool(WETH_ADDRESS)\n        returns (uint256)\n    {\n        uint256 maxBorrowShares = userBorrowShares[_nftId][WETH_ADDRESS];\n\n        _validateNonZero(\n            maxBorrowShares\n        );\n\n        uint256 maxPaybackAmount = paybackAmount(\n            WETH_ADDRESS,\n            maxBorrowShares\n        );\n\n        uint256 paybackShares = calculateBorrowShares(\n            {\n                _poolToken: WETH_ADDRESS,\n                _amount: msg.value,\n                _maxSharePrice: false\n            }\n        );\n\n        _validateNonZero(\n            paybackShares\n        );\n\n        uint256 refundAmount;\n        uint256 requiredAmount = msg.value;\n\n        if (msg.value > maxPaybackAmount) {\n\n            unchecked {\n                refundAmount = msg.value\n                    - maxPaybackAmount;\n            }\n\n            requiredAmount = requiredAmount\n                - refundAmount;\n\n            paybackShares = maxBorrowShares;\n        }\n\n        _handlePayback(\n            msg.sender,\n            _nftId,\n            WETH_ADDRESS,\n            requiredAmount,\n            paybackShares\n        );\n\n        _wrapETH(\n            requiredAmount\n        );\n\n        if (refundAmount > 0) {\n            _sendValue(\n                msg.sender,\n                refundAmount\n            );\n        }\n\n        return paybackShares;\n    }\n\n    /**\n     * @dev Ability to payback ERC20 loans\n     * by providing exact payback amount.\n     */\n    function paybackExactAmount(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        external\n        syncPool(_poolToken)\n        returns (uint256)\n    {\n        uint256 paybackShares = calculateBorrowShares(\n            {\n                _poolToken: _poolToken,\n                _amount: _amount,\n                _maxSharePrice: false\n            }\n        );\n\n        _validateNonZero(\n            paybackShares\n        );\n\n        _handlePayback(\n            msg.sender,\n            _nftId,\n            _poolToken,\n            _amount,\n            paybackShares\n        );\n\n        _safeTransferFrom(\n            _poolToken,\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        return paybackShares;\n    }\n\n    /**\n     * @dev Ability to payback ERC20 loans\n     * by providing exact payback shares.\n     */\n    function paybackExactShares(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _shares\n    )\n        external\n        syncPool(_poolToken)\n        returns (uint256)\n    {\n        uint256 repaymentAmount = paybackAmount(\n            _poolToken,\n            _shares\n        );\n\n        _validateNonZero(\n            repaymentAmount\n        );\n\n        _handlePayback(\n            msg.sender,\n            _nftId,\n            _poolToken,\n            repaymentAmount,\n            _shares\n        );\n\n        _safeTransferFrom(\n            _poolToken,\n            msg.sender,\n            address(this),\n            repaymentAmount\n        );\n\n        return repaymentAmount;\n    }\n\n    // --------------- Liquidation Functions ------------\n\n    /**\n     * @dev Function to liquidate a postion which reaches\n     * a debt ratio greater than 100%. The liquidator can choose\n     * token to payback and receive. (Both can differ!). The\n     * amount is in shares of the payback token. The liquidator\n     * gets an incentive which is calculated inside the liquidation\n     * logic.\n     */\n    function liquidatePartiallyFromTokens(\n        uint256 _nftId,\n        uint256 _nftIdLiquidator,\n        address _paybackToken,\n        address _receiveToken,\n        uint256 _shareAmountToPay\n    )\n        external\n        syncPool(_paybackToken)\n        syncPool(_receiveToken)\n        returns (uint256)\n    {\n        CoreLiquidationStruct memory data;\n\n        data.nftId = _nftId;\n        data.nftIdLiquidator = _nftIdLiquidator;\n\n        data.caller = msg.sender;\n\n        data.tokenToPayback = _paybackToken;\n        data.tokenToRecieve = _receiveToken;\n        data.shareAmountToPay = _shareAmountToPay;\n\n        data.maxFeeETH = WISE_SECURITY.maxFeeETH();\n        data.baseRewardLiquidation = WISE_SECURITY.baseRewardLiquidation();\n\n        (\n            data.lendTokens,\n            data.borrowTokens\n        ) = _prepareAssociatedTokens(\n            _nftId,\n            _receiveToken,\n            _paybackToken\n        );\n\n        data.paybackAmount = paybackAmount(\n            _paybackToken,\n            _shareAmountToPay\n        );\n\n        _checkPositionLocked(\n            _nftId,\n            msg.sender\n        );\n\n        _checkLiquidatorNft(\n            _nftId,\n            _nftIdLiquidator\n        );\n\n        WISE_SECURITY.checksLiquidation(\n            _nftId,\n            _paybackToken,\n            _shareAmountToPay\n        );\n\n        return _coreLiquidation(\n            data\n        );\n    }\n\n    /**\n     * @dev Wrapper function for liqudaiton flow\n     */\n    function coreLiquidationIsolationPools(\n        uint256 _nftId,\n        uint256 _nftIdLiquidator,\n        address _caller,\n        address _paybackToken,\n        address _receiveToken,\n        uint256 _paybackAmount,\n        uint256 _shareAmountToPay\n    )\n        external\n        syncPool(_paybackToken)\n        syncPool(_receiveToken)\n        returns (uint256)\n    {\n        CoreLiquidationStruct memory data;\n\n        data.nftId = _nftId;\n        data.nftIdLiquidator = _nftIdLiquidator;\n\n        data.caller = _caller;\n\n        data.paybackAmount = _paybackAmount;\n        data.tokenToPayback = _paybackToken;\n        data.tokenToRecieve = _receiveToken;\n        data.shareAmountToPay = _shareAmountToPay;\n\n        data.maxFeeETH = WISE_SECURITY.maxFeeFarmETH();\n        data.baseRewardLiquidation = WISE_SECURITY.baseRewardLiquidationFarm();\n\n        _validateIsolationPoolLiquidation(\n            msg.sender,\n            data.nftId,\n            data.nftIdLiquidator\n        );\n\n        (\n            data.lendTokens,\n            data.borrowTokens\n        ) = _prepareAssociatedTokens(\n            data.nftId,\n            data.tokenToRecieve,\n            data.tokenToPayback\n        );\n\n        return _coreLiquidation(\n            data\n        );\n    }\n\n    /**\n     * @dev Allows to sync pool manually\n     * so that the pool is up to date.\n     */\n    function syncManually(\n        address _poolToken\n    )\n        external\n        syncPool(_poolToken)\n    {\n        address[] memory tokens = new address[](1);\n        tokens[0] = _poolToken;\n\n        _curveSecurityChecks(\n            new address[](0),\n            tokens\n        );\n    }\n\n    /**\n     * @dev Registers position _nftId\n     * for isolation pool functionality\n     */\n    function setRegistrationIsolationPool(\n        uint256 _nftId,\n        bool _registerState\n    )\n        external\n    {\n        _onlyIsolationPool(\n            msg.sender\n        );\n\n        _validateZero(\n            WISE_SECURITY.overallETHCollateralsBare(_nftId)\n        );\n\n        _validateZero(\n            WISE_SECURITY.overallETHBorrowBare(_nftId)\n        );\n\n        positionLocked[_nftId] = _registerState;\n    }\n\n    /**\n    * @dev External wrapper for\n    * {_corePayback} logic callable\n    * by feeMananger.\n    */\n    function corePaybackFeeManager(\n        address _poolToken,\n        uint256 _nftId,\n        uint256 _amount,\n        uint256 _shares\n    )\n        external\n        onlyFeeManager\n        syncPool(_poolToken)\n    {\n        _corePayback(\n            _nftId,\n            _poolToken,\n            _amount,\n            _shares\n        );\n    }\n\n    /**\n     * @dev Internal function combining payback\n     * logic and emit of an event.\n     */\n    function _handlePayback(\n        address _caller,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount,\n        uint256 _shares\n    )\n        private\n    {\n        _corePayback(\n            _nftId,\n            _poolToken,\n            _amount,\n            _shares\n        );\n\n        emit FundsReturned(\n            _caller,\n            _poolToken,\n            _nftId,\n            _amount,\n            _shares,\n            block.timestamp\n        );\n    }\n\n    function _handleWithdrawAmount(\n        address _caller,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount,\n        bool _onBehalf\n    )"
    }
  ]
}