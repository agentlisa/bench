{
  "Title": "[G-13] No need to cache a function call if used only once",
  "Content": "\n### Instance 1\n\nNo need to cache `params.tokenIn.balanceOf(address(this))` and `params.tokenOut.balanceOf(address(this))` in stack variable in `balanceInAfter` and `balanceOutAfter` respectively, since they are used only once.\n\n```solidity\nFile  : utils/Swapper.sol\n\n104:   uint256 balanceInAfter = params.tokenIn.balanceOf(address(this));\n105:   uint256 balanceOutAfter = params.tokenOut.balanceOf(address(this));\n...\n107:   amountInDelta = balanceInBefore - balanceInAfter;\n108:   amountOutDelta = balanceOutAfter - balanceOutBefore;\n```\n\n[Swapper.sol#L104-L108](https://github.com/code-423n4/2024-03-revert-lend/blob/main/src/utils/Swapper.sol#L104-L108)\n\n### Recommended Mitigation Steps\n\n```diff\nFile  : utils/Swapper.sol\n\n-104:   uint256 balanceInAfter = params.tokenIn.balanceOf(address(this));\n-105:   uint256 balanceOutAfter = params.tokenOut.balanceOf(address(this));\n...\n-107:   amountInDelta = balanceInBefore - balanceInAfter;\n-108:   amountOutDelta = balanceOutAfter - balanceOutBefore;\n+107:   amountInDelta = balanceInBefore - params.tokenIn.balanceOf(address(this));\n+108:   amountOutDelta = params.tokenOut.balanceOf(address(this)) - balanceOutBefore;\n```\n\n### Instance 2\n\nNo need to cache `nonfungiblePositionManager.ownerOf(tokenId)` in stack variable `owner` since this is used only once in the function.\n\n```solidity\nFile : automators/AutoExit.sol\n\n219:  address owner = nonfungiblePositionManager.ownerOf(tokenId);\n220:     if (owner != msg.sender) {\n221:        revert Unauthorized();\n222:     }\n```\n\n[AutoExit.sol#L219-L222](https://github.com/code-423n4/2024-03-revert-lend/blob/main/src/automators/AutoExit.sol#L219-L222)\n\n### Recommended Mitigation Steps\n\n```diff\nFile : automators/AutoExit.sol\n\n-219:  address owner = nonfungiblePositionManager.ownerOf(tokenId);\n-220:     if (owner != msg.sender) {\n+220:     if (nonfungiblePositionManager.ownerOf(tokenId) != msg.sender) {\n221:        revert Unauthorized();\n222:     }\n```\n\n**[kalinbas (Revert) confirmed](https://github.com/code-423n4/2024-03-revert-lend-findings/issues/514#issuecomment-2020624410)**\n\n***\n\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-03-revert-lend",
  "Code": [
    {
      "filename": "src/utils/Swapper.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"v3-core/interfaces/callback/IUniswapV3SwapCallback.sol\";\nimport \"v3-core/interfaces/IUniswapV3Pool.sol\";\nimport \"v3-core/libraries/TickMath.sol\";\n\nimport \"v3-periphery/interfaces/INonfungiblePositionManager.sol\";\n\nimport \"../../lib/IWETH9.sol\";\nimport \"../../lib/IUniversalRouter.sol\";\nimport \"../interfaces/IErrors.sol\";\n\n// base functionality to do swaps with different routing protocols\nabstract contract Swapper is IUniswapV3SwapCallback, IErrors {\n    event Swap(address indexed tokenIn, address indexed tokenOut, uint256 amountIn, uint256 amountOut);\n\n    /// @notice Wrapped native token address\n    IWETH9 public immutable weth;\n\n    address public immutable factory;\n\n    /// @notice Uniswap v3 position manager\n    INonfungiblePositionManager public immutable nonfungiblePositionManager;\n\n    /// @notice 0x Exchange Proxy\n    address public immutable zeroxRouter;\n\n    /// @notice Uniswap Universal Router\n    address public immutable universalRouter;\n\n    /// @notice Constructor\n    /// @param _nonfungiblePositionManager Uniswap v3 position manager\n    /// @param _zeroxRouter 0x Exchange Proxy\n    constructor(\n        INonfungiblePositionManager _nonfungiblePositionManager,\n        address _zeroxRouter,\n        address _universalRouter\n    ) {\n        weth = IWETH9(_nonfungiblePositionManager.WETH9());\n        factory = _nonfungiblePositionManager.factory();\n        nonfungiblePositionManager = _nonfungiblePositionManager;\n        zeroxRouter = _zeroxRouter;\n        universalRouter = _universalRouter;\n    }\n\n    // swap data for 0x\n    struct ZeroxRouterData {\n        address allowanceTarget;\n        bytes data;\n    }\n\n    // swap data for uni - must include sweep for input token\n    struct UniversalRouterData {\n        bytes commands;\n        bytes[] inputs;\n        uint256 deadline;\n    }\n\n    struct RouterSwapParams {\n        IERC20 tokenIn;\n        IERC20 tokenOut;\n        uint256 amountIn;\n        uint256 amountOutMin;\n        bytes swapData;\n    }\n\n    // general swap function which uses external router with off-chain calculated swap instructions\n    // does slippage check with amountOutMin param\n    // returns token amounts deltas after swap\n    function _routerSwap(RouterSwapParams memory params)\n        internal\n        returns (uint256 amountInDelta, uint256 amountOutDelta)\n    {\n        if (params.amountIn != 0 && params.swapData.length != 0 && address(params.tokenOut) != address(0)) {\n            uint256 balanceInBefore = params.tokenIn.balanceOf(address(this));\n            uint256 balanceOutBefore = params.tokenOut.balanceOf(address(this));\n\n            // get router specific swap data\n            (address router, bytes memory routerData) = abi.decode(params.swapData, (address, bytes));\n\n            if (router == zeroxRouter) {\n                ZeroxRouterData memory data = abi.decode(routerData, (ZeroxRouterData));\n                // approve needed amount\n                SafeERC20.safeApprove(params.tokenIn, data.allowanceTarget, params.amountIn);\n                // execute swap\n                (bool success,) = zeroxRouter.call(data.data);\n                if (!success) {\n                    revert SwapFailed();\n                }\n                // reset approval\n                SafeERC20.safeApprove(params.tokenIn, data.allowanceTarget, 0);\n            } else if (router == universalRouter) {\n                UniversalRouterData memory data = abi.decode(routerData, (UniversalRouterData));\n                // tokens are transfered to Universalrouter directly (data.commands must include sweep action!)\n                SafeERC20.safeTransfer(params.tokenIn, universalRouter, params.amountIn);\n                IUniversalRouter(universalRouter).execute(data.commands, data.inputs, data.deadline);\n            } else {\n                revert WrongContract();\n            }\n\n            uint256 balanceInAfter = params.tokenIn.balanceOf(address(this));\n            uint256 balanceOutAfter = params.tokenOut.balanceOf(address(this));\n\n            amountInDelta = balanceInBefore - balanceInAfter;\n            amountOutDelta = balanceOutAfter - balanceOutBefore;\n\n            // amountMin slippage check\n            if (amountOutDelta < params.amountOutMin) {\n                revert SlippageError();\n            }\n\n            // event for any swap with exact swapped value\n            emit Swap(address(params.tokenIn), address(params.tokenOut), amountInDelta, amountOutDelta);\n        }\n    }\n\n    struct PoolSwapParams {\n        IUniswapV3Pool pool;\n        IERC20 token0;\n        IERC20 token1;\n        uint24 fee;\n        bool swap0For1;\n        uint256 amountIn;\n        uint256 amountOutMin;\n    }\n\n    // execute swap directly on specified pool\n    // amounts must be available on the contract for both tokens\n    function _poolSwap(PoolSwapParams memory params) internal returns (uint256 amountInDelta, uint256 amountOutDelta) {\n        if (params.amountIn > 0) {\n            (int256 amount0Delta, int256 amount1Delta) = params.pool.swap(\n                address(this),\n                params.swap0For1,\n                int256(params.amountIn),\n                (params.swap0For1 ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1),\n                abi.encode(\n                    params.swap0For1 ? params.token0 : params.token1,\n                    params.swap0For1 ? params.token1 : params.token0,\n                    params.fee\n                )\n            );\n            amountInDelta = params.swap0For1 ? uint256(amount0Delta) : uint256(amount1Delta);\n            amountOutDelta = params.swap0For1 ? uint256(-amount1Delta) : uint256(-amount0Delta);\n\n            // amountMin slippage check\n            if (amountOutDelta < params.amountOutMin) {\n                revert SlippageError();\n            }\n        }\n    }\n\n    // swap callback function where amount for swap is payed\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external override {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n\n        // check if really called from pool\n        (address tokenIn, address tokenOut, uint24 fee) = abi.decode(data, (address, address, uint24));\n        if (address(_getPool(tokenIn, tokenOut, fee)) != msg.sender) {\n            revert Unauthorized();\n        }\n\n        // transfer needed amount of tokenIn\n        uint256 amountToPay = amount0Delta > 0 ? uint256(amount0Delta) : uint256(amount1Delta);\n        SafeERC20.safeTransfer(IERC20(tokenIn), msg.sender, amountToPay);\n    }\n\n    // get pool for token\n    function _getPool(address tokenA, address tokenB, uint24 fee) internal view returns (IUniswapV3Pool) {\n        return IUniswapV3Pool(PoolAddress.computeAddress(address(factory), PoolAddress.getPoolKey(tokenA, tokenB, fee)));\n    }\n}"
    },
    {
      "filename": "src/automators/AutoExit.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./Automator.sol\";\n\n/// @title AutoExit\n/// @notice Lets a v3 position to be automatically removed (limit order) or swapped to the opposite token (stop loss order) when it reaches a certain tick.\n/// A revert controlled bot (operator) is responsable for the execution of optimized swaps (using external swap router)\n/// Positions need to be approved (approve or setApprovalForAll) for the contract and configured with configToken method\ncontract AutoExit is Automator {\n    event Executed(\n        uint256 indexed tokenId,\n        address account,\n        bool isSwap,\n        uint256 amountReturned0,\n        uint256 amountReturned1,\n        address token0,\n        address token1\n    );\n    event PositionConfigured(\n        uint256 indexed tokenId,\n        bool isActive,\n        bool token0Swap,\n        bool token1Swap,\n        int24 token0TriggerTick,\n        int24 token1TriggerTick,\n        uint64 token0SlippageX64,\n        uint64 token1SlippageX64,\n        bool onlyFees,\n        uint64 maxRewardX64\n    );\n\n    constructor(\n        INonfungiblePositionManager _npm,\n        address _operator,\n        address _withdrawer,\n        uint32 _TWAPSeconds,\n        uint16 _maxTWAPTickDifference,\n        address _zeroxRouter,\n        address _universalRouter\n    ) Automator(_npm, _operator, _withdrawer, _TWAPSeconds, _maxTWAPTickDifference, _zeroxRouter, _universalRouter) {}\n\n    // define how stoploss / limit should be handled\n    struct PositionConfig {\n        bool isActive; // if position is active\n        // should swap token to other token when triggered\n        bool token0Swap;\n        bool token1Swap;\n        // when should action be triggered (when this tick is reached - allow execute)\n        int24 token0TriggerTick; // when tick is below this one\n        int24 token1TriggerTick; // when tick is equal or above this one\n        // max price difference from current pool price for swap / Q64\n        uint64 token0SlippageX64; // when token 0 is swapped to token 1\n        uint64 token1SlippageX64; // when token 1 is swapped to token 0\n        bool onlyFees; // if only fees maybe used for protocol reward\n        uint64 maxRewardX64; // max allowed reward percentage of fees or full position\n    }\n\n    // configured tokens\n    mapping(uint256 => PositionConfig) public positionConfigs;\n\n    /// @notice params for execute()\n    struct ExecuteParams {\n        uint256 tokenId; // tokenid to process\n        bytes swapData; // if its a swap order - must include swap data\n        uint128 liquidity; // liquidity the calculations are based on\n        uint256 amountRemoveMin0; // min amount to be removed from liquidity\n        uint256 amountRemoveMin1; // min amount to be removed from liquidity\n        uint256 deadline; // for uniswap operations - operator promises fair value\n        uint64 rewardX64; // which reward will be used for protocol, can be max configured amount (considering onlyFees)\n    }\n\n    struct ExecuteState {\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint128 liquidity;\n        uint256 amount0;\n        uint256 amount1;\n        uint256 feeAmount0;\n        uint256 feeAmount1;\n        uint256 amountOutMin;\n        uint256 amountInDelta;\n        uint256 amountOutDelta;\n        IUniswapV3Pool pool;\n        uint256 swapAmount;\n        int24 tick;\n        bool isSwap;\n        bool isAbove;\n        address owner;\n    }\n\n    /**\n     * @notice Handle token (must be in correct state)\n     * Can only be called only from configured operator account\n     * Swap needs to be done with max price difference from current pool price - otherwise reverts\n     */\n    function execute(ExecuteParams calldata params) external {\n        if (!operators[msg.sender]) {\n            revert Unauthorized();\n        }\n\n        ExecuteState memory state;\n        PositionConfig memory config = positionConfigs[params.tokenId];\n\n        if (!config.isActive) {\n            revert NotConfigured();\n        }\n\n        if (\n            config.onlyFees && params.rewardX64 > config.maxRewardX64\n                || !config.onlyFees && params.rewardX64 > config.maxRewardX64\n        ) {\n            revert ExceedsMaxReward();\n        }\n\n        // get position info\n        (,, state.token0, state.token1, state.fee, state.tickLower, state.tickUpper, state.liquidity,,,,) =\n            nonfungiblePositionManager.positions(params.tokenId);\n\n        // so can be executed only once\n        if (state.liquidity == 0) {\n            revert NoLiquidity();\n        }\n        if (state.liquidity != params.liquidity) {\n            revert LiquidityChanged();\n        }\n\n        state.pool = _getPool(state.token0, state.token1, state.fee);\n        (, state.tick,,,,,) = state.pool.slot0();\n\n        // not triggered\n        if (config.token0TriggerTick <= state.tick && state.tick < config.token1TriggerTick) {\n            revert NotReady();\n        }\n\n        state.isAbove = state.tick >= config.token1TriggerTick;\n        state.isSwap = !state.isAbove && config.token0Swap || state.isAbove && config.token1Swap;\n\n        // decrease full liquidity for given position - and return fees as well\n        (state.amount0, state.amount1, state.feeAmount0, state.feeAmount1) = _decreaseFullLiquidityAndCollect(\n            params.tokenId, state.liquidity, params.amountRemoveMin0, params.amountRemoveMin1, params.deadline\n        );\n\n        // swap to other token\n        if (state.isSwap) {\n            if (params.swapData.length == 0) {\n                revert MissingSwapData();\n            }\n\n            // reward is taken before swap - if from fees only\n            if (config.onlyFees) {\n                state.amount0 -= state.feeAmount0 * params.rewardX64 / Q64;\n                state.amount1 -= state.feeAmount1 * params.rewardX64 / Q64;\n            }\n\n            state.swapAmount = state.isAbove ? state.amount1 : state.amount0;\n\n            // checks if price in valid oracle range and calculates amountOutMin\n            (state.amountOutMin,,,) = _validateSwap(\n                !state.isAbove,\n                state.swapAmount,\n                state.pool,\n                TWAPSeconds,\n                maxTWAPTickDifference,\n                state.isAbove ? config.token1SlippageX64 : config.token0SlippageX64\n            );\n\n            (state.amountInDelta, state.amountOutDelta) = _routerSwap(\n                Swapper.RouterSwapParams(\n                    state.isAbove ? IERC20(state.token1) : IERC20(state.token0),\n                    state.isAbove ? IERC20(state.token0) : IERC20(state.token1),\n                    state.swapAmount,\n                    state.amountOutMin,\n                    params.swapData\n                )\n            );\n\n            state.amount0 = state.isAbove ? state.amount0 + state.amountOutDelta : state.amount0 - state.amountInDelta;\n            state.amount1 = state.isAbove ? state.amount1 - state.amountInDelta : state.amount1 + state.amountOutDelta;\n\n            // when swap and !onlyFees - protocol reward is removed only from target token (to incentivize optimal swap done by operator)\n            if (!config.onlyFees) {\n                if (state.isAbove) {\n                    state.amount0 -= state.amount0 * params.rewardX64 / Q64;\n                } else {\n                    state.amount1 -= state.amount1 * params.rewardX64 / Q64;\n                }\n            }\n        } else {\n            // reward is taken as configured\n            state.amount0 -= (config.onlyFees ? state.feeAmount0 : state.amount0) * params.rewardX64 / Q64;\n            state.amount1 -= (config.onlyFees ? state.feeAmount1 : state.amount1) * params.rewardX64 / Q64;\n        }\n\n        state.owner = nonfungiblePositionManager.ownerOf(params.tokenId);\n        if (state.amount0 > 0) {\n            _transferToken(state.owner, IERC20(state.token0), state.amount0, true);\n        }\n        if (state.amount1 > 0) {\n            _transferToken(state.owner, IERC20(state.token1), state.amount1, true);\n        }\n\n        // delete config for position\n        delete positionConfigs[params.tokenId];\n        emit PositionConfigured(params.tokenId, false, false, false, 0, 0, 0, 0, false, 0);\n\n        // log event\n        emit Executed(\n            params.tokenId, msg.sender, state.isSwap, state.amount0, state.amount1, state.token0, state.token1\n        );\n    }\n\n    // function to configure a token to be used with this runner\n    // it needs to have approvals set for this contract beforehand\n    function configToken(uint256 tokenId, PositionConfig calldata config) external {\n        address owner = nonfungiblePositionManager.ownerOf(tokenId);\n        if (owner != msg.sender) {\n            revert Unauthorized();\n        }\n\n        if (config.isActive) {\n            if (config.token0TriggerTick >= config.token1TriggerTick) {\n                revert InvalidConfig();\n            }\n        }\n\n        positionConfigs[tokenId] = config;\n\n        emit PositionConfigured(\n            tokenId,\n            config.isActive,\n            config.token0Swap,\n            config.token1Swap,\n            config.token0TriggerTick,\n            config.token1TriggerTick,\n            config.token0SlippageX64,\n            config.token1SlippageX64,\n            config.onlyFees,\n            config.maxRewardX64\n        );\n    }\n}"
    }
  ]
}