{
  "Title": "minDelay Set to Zero Undermines Security Council Purpose",
  "Content": "The `Governance` contract is a timelock that allows scheduling operations that make critical changes to the protocol. These scheduled operations can be executed after waiting for a [`minDelay`](https://github.com/matter-labs/era-contracts/blob/2e0734b1ff9cbf3a88aadba6a19c4c4bc8645d33/ethereum/contracts/governance/Governance.sol#L35) period in seconds. During construction or through a scheduled operation, this `minDelay` can be set to zero (or a low value).\n\n\nThis option of a zero `minDelay` has the following implications:\n\n\n* A compromised owner can perform malicious actions immediately.\n* Hence, the role of the security council to skip the delay is obsolete.\n* Users do not have enough time to withdraw their funds.\n\n\nTo mitigate these risks, consider defining a constant minimum limit for `minDelay` (e.g., by facilitating the [`UPGRADE_NOTICE_PERIOD` constant](https://github.com/matter-labs/era-contracts/blob/2e0734b1ff9cbf3a88aadba6a19c4c4bc8645d33/ethereum/contracts/zksync/Config.sol#L50)), thereby allowing adequate time for stakeholders to respond to any proposed modifications.\n\n\n***Update:** Acknowledged, not resolved. While the team intends to have a non-zero `minDelay` after the initial stage, a minimal `minDelay` has not been hard coded. The Matter Labs team stated:*\n\n\n\n> *At the initial stage of the protocol, the `minDelay` is 0. It is part of the initial training wheels of the protocol to allow for swift reaction in case of a needed emergency upgrade. While the alternative to achieve the same effect is to leverage the security council (basically set the security council to be the same entity as the owner of the Governance), having it as zero is more explicit and easier to maintain.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "ethereum/contracts/governance/Governance.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {Ownable2Step} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport {IGovernance} from \"./IGovernance.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @dev Contract design is inspired by OpenZeppelin TimelockController and in-house Diamond Proxy upgrade mechanism.\n/// @notice This contract manages operations (calls with preconditions) for governance tasks.\n/// The contract allows for operations to be scheduled, executed, and canceled with\n/// appropriate permissions and delays. It is used for managing and coordinating upgrades\n/// and changes in all zkSync Era governed contracts.\n///\n/// Operations can be proposed as either fully transparent upgrades with on-chain data,\n/// or \"shadow\" upgrades where upgrade data is not published on-chain before execution. Proposed operations\n/// are subject to a delay before they can be executed, but they can be executed instantly\n/// with the security councilâ€™s permission.\ncontract Governance is IGovernance, Ownable2Step {\n    /// @notice A constant representing the timestamp for completed operations.\n    uint256 internal constant EXECUTED_PROPOSAL_TIMESTAMP = uint256(1);\n\n    /// @notice The address of the security council.\n    /// @dev It is supposed to be multisig contract.\n    address public securityCouncil;\n\n    /// @notice A mapping to store timestamps where each operation will be ready for execution.\n    /// @dev - 0 means the operation is not created.\n    /// @dev - 1 (EXECUTED_PROPOSAL_TIMESTAMP) means the operation is already executed.\n    /// @dev - any other value means timestamp in seconds when the operation will be ready for execution.\n    mapping(bytes32 => uint256) public timestamps;\n\n    /// @notice The minimum delay in seconds for operations to be ready for execution.\n    uint256 public minDelay;\n\n    /// @notice Initializes the contract with the admin address, security council address, and minimum delay.\n    /// @param _admin The address to be assigned as the admin of the contract.\n    /// @param _securityCouncil The address to be assigned as the security council of the contract.\n    /// @param _minDelay The initial minimum delay (in seconds) to be set for operations.\n    constructor(address _admin, address _securityCouncil, uint256 _minDelay) {\n        require(_admin != address(0), \"Admin should be non zero address\");\n\n        _transferOwnership(_admin);\n\n        securityCouncil = _securityCouncil;\n        emit ChangeSecurityCouncil(address(0), _securityCouncil);\n\n        minDelay = _minDelay;\n        emit ChangeMinDelay(0, _minDelay);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Checks that the message sender is contract itself.\n    modifier onlySelf() {\n        require(msg.sender == address(this), \"Only governance contract itself allowed to call this function\");\n        _;\n    }\n\n    /// @notice Checks that the message sender is an active security council.\n    modifier onlySecurityCouncil() {\n        require(msg.sender == securityCouncil, \"Only security council allowed to call this function\");\n        _;\n    }\n\n    /// @notice Checks that the message sender is an active owner or an active security council.\n    modifier onlyOwnerOrSecurityCouncil() {\n        require(\n            msg.sender == owner() || msg.sender == securityCouncil,\n            \"Only the owner and security council are allowed to call this function\"\n        );\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            OPERATION GETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Returns whether an id corresponds to a registered operation. This\n    /// includes both Waiting, Ready, and Done operations.\n    function isOperation(bytes32 _id) public view returns (bool) {\n        return getOperationState(_id) != OperationState.Unset;\n    }\n\n    /// @dev Returns whether an operation is pending or not. Note that a \"pending\" operation may also be \"ready\".\n    function isOperationPending(bytes32 _id) public view returns (bool) {\n        OperationState state = getOperationState(_id);\n        return state == OperationState.Waiting || state == OperationState.Ready;\n    }\n\n    /// @dev Returns whether an operation is ready for execution. Note that a \"ready\" operation is also \"pending\".\n    function isOperationReady(bytes32 _id) public view returns (bool) {\n        return getOperationState(_id) == OperationState.Ready;\n    }\n\n    /// @dev Returns whether an operation is done or not.\n    function isOperationDone(bytes32 _id) public view returns (bool) {\n        return getOperationState(_id) == OperationState.Done;\n    }\n\n    /// @dev Returns operation state.\n    function getOperationState(bytes32 _id) public view returns (OperationState) {\n        uint256 timestamp = timestamps[_id];\n        if (timestamp == 0) {\n            return OperationState.Unset;\n        } else if (timestamp == EXECUTED_PROPOSAL_TIMESTAMP) {\n            return OperationState.Done;\n        } else if (timestamp > block.timestamp) {\n            return OperationState.Waiting;\n        } else {\n            return OperationState.Ready;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            SCHEDULING CALLS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Propose a fully transparent upgrade, providing upgrade data on-chain.\n    /// @notice The owner will be able to execute the proposal either:\n    /// - With a `delay` timelock on its own.\n    /// - With security council instantly.\n    /// @dev Only the current owner can propose an upgrade.\n    /// @param _operation The operation parameters will be executed with the upgrade.\n    /// @param _delay The delay time (in seconds) after which the proposed upgrade can be executed by the owner.\n    function scheduleTransparent(Operation calldata _operation, uint256 _delay) external onlyOwner {\n        bytes32 id = hashOperation(_operation);\n        _schedule(id, _delay);\n        emit TransparentOperationScheduled(id, _delay, _operation);\n    }\n\n    /// @notice Propose \"shadow\" upgrade, upgrade data is not publishing on-chain.\n    /// @notice The owner will be able to execute the proposal either:\n    /// - With a `delay` timelock on its own.\n    /// - With security council instantly.\n    /// @dev Only the current owner can propose an upgrade.\n    /// @param _id The operation hash (see `hashOperation` function)\n    /// @param _delay The delay time (in seconds) after which the proposed upgrade may be executed by the owner.\n    function scheduleShadow(bytes32 _id, uint256 _delay) external onlyOwner {\n        _schedule(_id, _delay);\n        emit ShadowOperationScheduled(_id, _delay);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            CANCELING CALLS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Cancel the scheduled operation.\n    /// @dev Both the owner and security council may cancel an operation.\n    /// @param _id Proposal id value (see `hashOperation`)\n    function cancel(bytes32 _id) external onlyOwner {\n        require(isOperationPending(_id), \"Operation must be pending\");\n        delete timestamps[_id];\n        emit OperationCancelled(_id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            EXECUTING CALLS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Executes the scheduled operation after the delay passed.\n    /// @dev Both the owner and security council may execute delayed operations.\n    /// @param _operation The operation parameters will be executed with the upgrade.\n    function execute(Operation calldata _operation) external payable onlyOwnerOrSecurityCouncil {\n        bytes32 id = hashOperation(_operation);\n        // Check if the predecessor operation is completed.\n        _checkPredecessorDone(_operation.predecessor);\n        // Ensure that the operation is ready to proceed.\n        require(isOperationReady(id), \"Operation must be ready before execution\");\n        // Execute operation.\n        _execute(_operation.calls);\n        // Reconfirming that the operation is still ready after execution.\n        // This is needed to avoid unexpected reentrancy attacks of re-executing the same operation.\n        require(isOperationReady(id), \"Operation must be ready after execution\");\n        // Set operation to be done\n        timestamps[id] = EXECUTED_PROPOSAL_TIMESTAMP;\n        emit OperationExecuted(id);\n    }\n\n    /// @notice Executes the scheduled operation with the security council instantly.\n    /// @dev Only the security council may execute an operation instantly.\n    /// @param _operation The operation parameters will be executed with the upgrade.\n    function executeInstant(Operation calldata _operation) external payable onlySecurityCouncil {\n        bytes32 id = hashOperation(_operation);\n        // Check if the predecessor operation is completed.\n        _checkPredecessorDone(_operation.predecessor);\n        // Ensure that the operation is in a pending state before proceeding.\n        require(isOperationPending(id), \"Operation must be pending before execution\");\n        // Execute operation.\n        _execute(_operation.calls);\n        // Reconfirming that the operation is still pending before execution.\n        // This is needed to avoid unexpected reentrancy attacks of re-executing the same operation.\n        require(isOperationPending(id), \"Operation must be pending after execution\");\n        // Set operation to be done\n        timestamps[id] = EXECUTED_PROPOSAL_TIMESTAMP;\n        emit OperationExecuted(id);\n    }\n\n    /// @dev Returns the identifier of an operation.\n    /// @param _operation The operation object to compute the identifier for.\n    function hashOperation(Operation calldata _operation) public pure returns (bytes32) {\n        return keccak256(abi.encode(_operation));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Schedule an operation that is to become valid after a given delay.\n    /// @param _id The operation hash (see `hashOperation` function)\n    /// @param _delay The delay time (in seconds) after which the proposed upgrade can be executed by the owner.\n    function _schedule(bytes32 _id, uint256 _delay) internal {\n        require(!isOperation(_id), \"Operation with this proposal id already exists\");\n        require(_delay >= minDelay, \"Proposed delay is less than minimum delay\");\n\n        timestamps[_id] = block.timestamp + _delay;\n    }\n\n    /// @dev Execute an operation's calls.\n    /// @param _calls The array of calls to be executed.\n    function _execute(Call[] calldata _calls) internal {\n        for (uint256 i = 0; i < _calls.length; ++i) {\n            (bool success, bytes memory returnData) = _calls[i].target.call{value: _calls[i].value}(_calls[i].data);\n            if (!success) {\n                // Propage an error if the call fails.\n                assembly {\n                    revert(add(returnData, 0x20), mload(returnData))\n                }\n            }\n        }\n    }\n\n    /// @notice Verifies if the predecessor operation is completed.\n    /// @param _predecessorId The hash of the operation that should be completed.\n    /// @dev Doesn't check the operation to be complete if the input is zero.\n    function _checkPredecessorDone(bytes32 _predecessorId) internal view {\n        require(_predecessorId == bytes32(0) || isOperationDone(_predecessorId), \"Predecessor operation not completed\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            SELF UPGRADES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Changes the minimum timelock duration for future operations.\n    /// @param _newDelay The new minimum delay time (in seconds) for future operations.\n    function updateDelay(uint256 _newDelay) external onlySelf {\n        emit ChangeMinDelay(minDelay, _newDelay);\n        minDelay = _newDelay;\n    }\n\n    /// @dev Updates the address of the security council.\n    /// @param _newSecurityCouncil The address of the new security council.\n    function updateSecurityCouncil(address _newSecurityCouncil) external onlySelf {\n        emit ChangeSecurityCouncil(securityCouncil, _newSecurityCouncil);\n        securityCouncil = _newSecurityCouncil;\n    }\n\n    /// @dev Contract might receive/hold ETH as part of the maintenance process.\n    receive() external payable {}\n}"
    },
    {
      "filename": "ethereum/contracts/zksync/Config.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\n/// @dev `keccak256(\"\")`\nbytes32 constant EMPTY_STRING_KECCAK = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n/// @dev Bytes in raw L2 log\n/// @dev Equal to the bytes size of the tuple - (uint8 ShardId, bool isService, uint16 txNumberInBatch, address sender,\n/// bytes32 key, bytes32 value)\nuint256 constant L2_TO_L1_LOG_SERIALIZE_SIZE = 88;\n\n/// @dev The maximum length of the bytes array with L2 -> L1 logs\nuint256 constant MAX_L2_TO_L1_LOGS_COMMITMENT_BYTES = 4 + L2_TO_L1_LOG_SERIALIZE_SIZE * 512;\n\n/// @dev The value of default leaf hash for L2 -> L1 logs Merkle tree\n/// @dev An incomplete fixed-size tree is filled with this value to be a full binary tree\n/// @dev Actually equal to the `keccak256(new bytes(L2_TO_L1_LOG_SERIALIZE_SIZE))`\nbytes32 constant L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH = 0x72abee45b59e344af8a6e520241c4744aff26ed411f4c4b00f8af09adada43ba;\n\n/// @dev Number of bytes in a one initial storage change\n/// @dev Equal to the bytes size of the tuple - (bytes32 key, bytes32 value)\nuint256 constant INITIAL_STORAGE_CHANGE_SERIALIZE_SIZE = 64;\n\n/// @dev Number of bytes in a one repeated storage change\n/// @dev Equal to the bytes size of the tuple - (bytes8 key, bytes32 value)\nuint256 constant REPEATED_STORAGE_CHANGE_SERIALIZE_SIZE = 40;\n\n// TODO: change constant to the real root hash of empty Merkle tree (SMA-184)\nbytes32 constant DEFAULT_L2_LOGS_TREE_ROOT_HASH = bytes32(0);\n\n/// @dev Denotes the type of the zkSync transaction that came from L1.\nuint256 constant PRIORITY_OPERATION_L2_TX_TYPE = 255;\n\n/// @dev Denotes the type of the zkSync transaction that is used for system upgrades.\nuint256 constant SYSTEM_UPGRADE_L2_TX_TYPE = 254;\n\n/// @dev The maximal allowed difference between protocol versions in an upgrade. The 100 gap is needed\n/// in case a protocol version has been tested on testnet, but then not launched on mainnet, e.g.\n/// due to a bug found.\nuint256 constant MAX_ALLOWED_PROTOCOL_VERSION_DELTA = 100;\n\n/// @dev The amount of time in seconds the validator has to process the priority transaction\n/// NOTE: The constant is set to zero for the Alpha release period\nuint256 constant PRIORITY_EXPIRATION = 0 days;\n\n/// @dev Notice period before activation preparation status of upgrade mode (in seconds)\n/// @dev NOTE: we must reserve for users enough time to send full exit operation, wait maximum time for processing this\n/// operation and withdraw funds from it.\nuint256 constant UPGRADE_NOTICE_PERIOD = $$(defined(UPGRADE_NOTICE_PERIOD) ? UPGRADE_NOTICE_PERIOD : \"14 days\");\n\n/// @dev Timestamp - seconds since unix epoch.\nuint256 constant COMMIT_TIMESTAMP_NOT_OLDER = 3 days;\n\n/// @dev Maximum available error between real commit batch timestamp and analog used in the verifier (in seconds)\n/// @dev Must be used cause miner's `block.timestamp` value can differ on some small value (as we know - 12 seconds)\nuint256 constant COMMIT_TIMESTAMP_APPROXIMATION_DELTA = 1 hours;\n\n/// @dev Shift to apply to verify public input before verifying.\nuint256 constant PUBLIC_INPUT_SHIFT = 32;\n\n/// @dev The maximum number of L2 gas that a user can request for an L2 transaction\nuint256 constant L2_TX_MAX_GAS_LIMIT = $(L2_TX_MAX_GAS_LIMIT);\n\n/// @dev The maximum number of the pubdata an L2 operation should be allowed to use.\nuint256 constant MAX_PUBDATA_PER_BATCH = $(MAX_PUBDATA_PER_BATCH);\n\n/// @dev The maximum number of the pubdata an priority operation should be allowed to use.\n/// For now, it is somewhat lower than the maximum number of pubdata allowed for an L2 transaction,\n/// to ensure that the transaction is definitely processable on L2 despite any potential overhead.\nuint256 constant PRIORITY_TX_MAX_PUBDATA = $(PRIORITY_TX_MAX_PUBDATA);\n\n/// @dev Even though the price for 1 byte of pubdata is 16 L1 gas, we have a slightly increased\n/// value.\nuint256 constant L1_GAS_PER_PUBDATA_BYTE = $(L1_GAS_PER_PUBDATA_BYTE);\n\n/// @dev The intrinsic cost of the L1->l2 transaction in computational L2 gas\nuint256 constant L1_TX_INTRINSIC_L2_GAS = $(L1_TX_INTRINSIC_L2_GAS);\n\n/// @dev The intrinsic cost of the L1->l2 transaction in pubdata\nuint256 constant L1_TX_INTRINSIC_PUBDATA = $(L1_TX_INTRINSIC_PUBDATA);\n\n/// @dev The minimal base price for L1 transaction\nuint256 constant L1_TX_MIN_L2_GAS_BASE = $(L1_TX_MIN_L2_GAS_BASE);\n\n/// @dev The number of L2 gas the transaction starts costing more with each 544 bytes of encoding\nuint256 constant L1_TX_DELTA_544_ENCODING_BYTES = $(L1_TX_DELTA_544_ENCODING_BYTES);\n\n/// @dev The number of L2 gas an L1->L2 transaction gains with each new factory dependency\nuint256 constant L1_TX_DELTA_FACTORY_DEPS_L2_GAS = $(L1_TX_DELTA_FACTORY_DEPS_L2_GAS);\n\n/// @dev The number of L2 gas an L1->L2 transaction gains with each new factory dependency\nuint256 constant L1_TX_DELTA_FACTORY_DEPS_PUBDATA = $(L1_TX_DELTA_FACTORY_DEPS_PUBDATA);\n\n/// @dev The number of pubdata an L1->L2 transaction requires with each new factory dependency\nuint256 constant MAX_NEW_FACTORY_DEPS = $(MAX_NEW_FACTORY_DEPS);\n\n/// @dev The L2 gasPricePerPubdata required to be used in bridges.\nuint256 constant REQUIRED_L2_GAS_PRICE_PER_PUBDATA = $(REQUIRED_L2_GAS_PRICE_PER_PUBDATA);\n\n/// @dev The mask which should be applied to the packed batch and L2 block timestamp in order\n/// to obtain the L2 block timestamp. Applying this mask is equivalent to calculating modulo 2**128\nuint256 constant PACKED_L2_BLOCK_TIMESTAMP_MASK = 0xffffffffffffffffffffffffffffffff;\n\n/// @dev The overhead for a transaction slot in L2 gas.\n/// It is roughly equal to 80kk/MAX_TRANSACTIONS_PER_BATCH, i.e. how many gas would an L1->L2 transaction\n/// need to pay to compensate for the batch being closed.\n/// @dev It is expected that the L1 contracts will enforce that the L2 gas price will be high enough to compensate\n/// the operator in case the batch is closed because of tx slots filling up.\nuint256 constant TX_SLOT_OVERHEAD_L2_GAS = 80000;\n\n/// @dev The overhead for each byte of the bootloader memory that the encoding of the transaction.\n/// It is roughly equal to 80kk/BOOTLOADER_MEMORY_FOR_TXS, i.e. how many gas would an L1->L2 transaction\n/// need to pay to compensate for the batch being closed.\n/// @dev It is expected that the L1 contracts will enforce that the L2 gas price will be high enough to compensate\n/// the operator in case the batch is closed because of the memory for transactions being filled up.\nuint256 constant MEMORY_OVERHEAD_GAS = 10;"
    }
  ]
}