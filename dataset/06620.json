{
  "Title": "[H-05] Incorrect calculation of the remaining `updatedRewards` leads to possible underflow error",
  "Content": "\n<https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/RewardsManager.sol#L549><br>\n<https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/RewardsManager.sol#L725>\n\n`RewardsManage.sol` keeps track of the **total number of rewards collected per epoch** for all pools:\n\n```c\nFile: 2023-05-ajna\\ajna-core\\src\\RewardsManager.sol\n73:    /// @dev `epoch => rewards claimed` mapping.\n74:    mapping(uint256 => uint256) public override rewardsClaimed;\n75:    /// @dev `epoch => update bucket rate rewards claimed` mapping.\n76:    mapping(uint256 => uint256) public override updateRewardsClaimed;\n```\n\nAnd the `rewardsCap` calculation when calculating the reward applies only to the pool, which leads to a situation when the condition is fulfilled `rewardsClaimedInEpoch + updatedRewards_ >= rewardsCap`, **But `rewardsCap` is less than `rewardsClaimedInEpoch`**:\n\n```diff\nFile: 2023-05-ajna\\ajna-core\\src\\RewardsManager.sol\n\n-543:         uint256 rewardsCapped = Maths.wmul(REWARD_CAP, totalBurnedInPeriod);\n545:         // Check rewards claimed - check that less than 80% of the tokens for a given burn event have been claimed.\n-546:         if (rewardsClaimedInEpoch_ + newRewards_ > rewardsCapped) {\n548:             // set claim reward to difference between cap and reward\n-549:             newRewards_ = rewardsCapped - rewardsClaimedInEpoch_; // @audit rewardsCapped can be less then  rewardsClaimedInEpoch_\n550:         }\n\n719:         uint256 rewardsCap            = Maths.wmul(UPDATE_CAP, totalBurned); // @audit in one pool\n-720:        uint256 rewardsClaimedInEpoch = updateRewardsClaimed[curBurnEpoch];\n722:         // update total tokens claimed for updating bucket exchange rates tracker\n723:         if (rewardsClaimedInEpoch + updatedRewards_ >= rewardsCap) {\n724:              // if update reward is greater than cap, set to remaining difference\n-725:             updatedRewards_ = rewardsCap - rewardsClaimedInEpoch; // @audit rewardsCap can be less then rewardsClaimedInEpoch\n726:         }\n728:         // accumulate the full amount of additional rewards\n-729:        updateRewardsClaimed[curBurnEpoch] += updatedRewards_; // @audit increase per epoch\n```\n\nWhich causes an `underflow` erorr in the result `updatedRewards_ = rewardsCap - rewardsClaimedInEpoch` where `rewardsCap < rewardsClaimedInEpoch`, this error **leads to a transaction fail**, which will further temporarily/permanently block actions with NFT as `unstake/claimRewards` for pools in which `rewardsCap` will fail less than the total `rewardsClaimedInEpoch`.\n\nWe have 2 instances of this problem::\n\n1.  during the call `_calculateNewRewards`\n2.  during the call `_updateBucketExchangeRates`\n\nA failure in any of these will result in users of certain pools being unable to withdraw their NFTs as well as the reward.\n\n### Proof of Concept\n\nLet's take a closer look at the problem and why this is possible:\n\n1.  We have a general calculation of rewards taken per epoch:\n\n```javascript\nFile: ajna-core\\src\\RewardsManager.sol\n\n71:     /// @dev `epoch => rewards claimed` mapping.\n72:     mapping(uint256 => uint256) public override rewardsClaimed;\n73:     /// @dev `epoch => update bucket rate rewards claimed` mapping.\n74:     mapping(uint256 => uint256) public override updateRewardsClaimed;\n```\n\n2.  The state is updated for the epoch by the amount calculated for each pool:\n\n```javascript\nFile: ajna-core\\src\\RewardsManager.sol\n\n_calculateAndClaimRewards\n396:         for (uint256 epoch = lastClaimedEpoch; epoch < epochToClaim_; ) {\n\n410:             // update epoch token claim trackers\n411:             rewardsClaimed[epoch]           += nextEpochRewards;\n\n413:         }\n\n_updateBucketExchangeRates\n676:         uint256 curBurnEpoch = IPool(pool_).currentBurnEpoch();\n\n728:                 // accumulate the full amount of additional rewards\n729:                 updateRewardsClaimed[curBurnEpoch] += updatedRewards_;\n```\n\n3.  At the time of calculation of the reward for the update:\n\n```diff\nFile: 2023-05-ajna\\ajna-core\\src\\RewardsManager.sol\n\n526:         (\n527:             ,\n528:             // total interest accumulated by the pool over the claim period\n+529:             uint256 totalBurnedInPeriod,\n530:             // total tokens burned over the claim period\n531:             uint256 totalInterestEarnedInPeriod\n532:         ) = _getPoolAccumulators(ajnaPool_, nextEpoch_, epoch_);\n533:\n534:         // calculate rewards earned\n                ...\n542:\n+543:         uint256 rewardsCapped = Maths.wmul(REWARD_CAP, totalBurnedInPeriod);\n544:\n545:         // Check rewards claimed - check that less than 80% of the tokens for a given burn event have been claimed.\n546:         if (rewardsClaimedInEpoch_ + newRewards_ > rewardsCapped) {\n547:\n548:             // set claim reward to difference between cap and reward\n+549:             newRewards_ = rewardsCapped - rewardsClaimedInEpoch_; // @audit\n550:         }\n```\n\nWe have a situation where `rewardsClaimedInEpoch_` has been updated by other pools to something like `100e18`,\nand `rewardsCapped` for the other pool was `30e18`, resulting in:<br>\n`  rewardsClaimedInEpoch_ + newRewards_ > rewardsCapped `<br>\nand of course we catch the underflow at the time of calculating the remainder, `30e18 - 100e18`, since there is no remainder\n`newRewards_ = rewardsCapped - rewardsClaimedInEpoch_`.\n\nTo check the problem, you need to raise `rewardsClaimedInEpoch_` more than the `rewardsCap` of a certain pool, with the help of other pools, `rewardsCap` is a percentage of burned tokens in the pool... so it's possible.\n\n### Tools Used\n\n*   Manual review\n*   Foundry\n\n### Recommended Mitigation Steps\n\n*   Add additional requirements that if `rewardsClaimedInEpoch > rewardsCap` that `updatedRewards_` should be zero, not need calculate remaining difference.\n\n**[MikeHathaway (Ajna) confirmed](https://github.com/code-423n4/2023-05-ajna-findings/issues/440#issuecomment-1555156243)**\n\n**[Picodes (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-05-ajna-findings/issues/440#issuecomment-1569154687):**\n > Giving Medium severity for \"Assets not at direct risk, but the function of the protocol or its availability could be impacted\"\n\n**[Haipls (warden) commented](https://github.com/code-423n4/2023-05-ajna-findings/issues/440#issuecomment-1573707899):**\n > Hi @Picodes - I would like to ask you to reconsider the severity of the issue. You've classified it as `Med` - `Assets not at direct risk, but the function of the protocol or its availability could be impacted`.\n> \n> Upon review, in my opinion, this issue leans more towards HIGH - `Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals)`. \n> \n> Below, I will attempt to present my reasoning and why I think this way:\n> \n> I've considered `2` metrics to determine severity:\n> \n> 1. Consequences\n> 2. The likelihood of it happening\n> \n> And came up with the following results:\n> \n> 1. Consequences\n>    \n>     The consequence of this issue is that in the event of it happening, NFTs are blocked on the RewardsManager.sol contract with no possibility of their further withdrawal. This is critical and falls under: `Assets can be stolen/lost/compromised directly`. Moreover, these are not just NFTs, they are LP positions.\n>     \n>     When this problem occurs, the ability for `stake/unstake/claimRewards` of the affected pools is closed due to a mathematical error, leading to a simple blockage of interaction with these pools. As it becomes impossible to process the reward update for a given epoch. For pools that weren't affected and managed to process before, they will be able to operate further until the situation repeats.\n> \n> 2. The main point in deciding whether it's `Medium/High` is how likely this problem is to occur. \n>    \n>     Here I looked at the dependence in calculations on the number of pools\n>     ```c\n>       uint256 rewardsCapped = Maths.wmul(REWARD_CAP, totalBurnedInPeriod);\n> \n>         // Check rewards claimed - check that less than 80% of the tokens for a given burn event have been claimed.\n>         if (rewardsClaimedInEpoch_ + newRewards_ > rewardsCapped) {\n> \n>             // set claim reward to difference between cap and reward\n>             newRewards_ = rewardsCapped - rewardsClaimedInEpoch_; \n>         }\n>     ```\n> \n>     `rewardsClaimedInEpoch_` is a value that sums up across all pools\n> \n>     `rewardsCapped` is a value related to the calculation of a single pool and depends on the number of coins burned in the epoch in the selected pool\n> \n>     And there arises a situation when `n1 - (n2 + n3...+ nn)` by pools. In reality, it's all more complex and depends on the number of burned coins in the pools, but the essence is that the more pools we have, the higher the chances that this condition simply reverts. And this is no longer an unlikely situation.\n> \n> **Also an example of a highly probable situation:**\n> \n> When there's a HUGE pool and several small ones in the middle. It's enough for only the HUGE pool to update the epoch's reward. This will cause a problem with the condition's execution for all other small pools\n> \n> \n> This can also be a vector of an attacker who purposely burns an extra amount of coins to increase the reward update on the pool. And causes positions blocking in the contract.\n> \n> After these considerations, I would like you to reconsider the severity of the problem, as we have two points:\n> \n> 1. Direct blocking of funds on the contract.\n> 2. The situation is not theoretical.\n> \n> I hope my thoughts will be useful. I understand that I can be wrong and I hope you can clarify if I am not understanding something correctly. Thank you.\n\n**[Picodes (judge) increased severity to High and commented](https://github.com/code-423n4/2023-05-ajna-findings/issues/440#issuecomment-1574940585):**\n > Hi @Haipls - thanks for your comment. Upon review, I agree with your take and will upgrade to High.\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-05-ajna",
  "Code": [
    {
      "filename": "ajna-core/src/RewardsManager.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport { IERC20 }          from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport { IERC721 }         from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport { ReentrancyGuard } from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport { SafeERC20 }       from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport { IPool }                        from './interfaces/pool/IPool.sol';\nimport { IPositionManager }             from './interfaces/position/IPositionManager.sol';\nimport { IPositionManagerOwnerActions } from './interfaces/position/IPositionManagerOwnerActions.sol';\nimport {\n    IRewardsManager,\n    IRewardsManagerOwnerActions,\n    IRewardsManagerState,\n    IRewardsManagerDerivedState\n} from './interfaces/rewards/IRewardsManager.sol';\nimport { StakeInfo, BucketState } from './interfaces/rewards/IRewardsManagerState.sol';\n\nimport { PositionManager } from './PositionManager.sol';\n\nimport { Maths } from './libraries/internal/Maths.sol';\n\n/**\n *  @title  Rewards (staking) Manager contract\n *  @notice Pool lenders can optionally mint `NFT` that represents their positions.\n *          The Rewards contract allows pool lenders with positions `NFT` to stake and earn `Ajna` tokens. \n *          Lenders with `NFT`s can:\n *          - `stake` token\n *          - `update bucket exchange rate` and earn rewards\n *          - `claim` rewards\n *          - `unstake` token\n */\ncontract RewardsManager is IRewardsManager, ReentrancyGuard {\n\n    using SafeERC20 for IERC20;\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    /**\n     * @notice Maximum percentage of tokens burned that can be claimed as `Ajna` token `LP` `NFT` rewards.\n     */\n    uint256 internal constant REWARD_CAP = 0.8 * 1e18;\n    /**\n     * @notice Maximum percentage of tokens burned that can be claimed as `Ajna` token update rewards.\n     */\n    uint256 internal constant UPDATE_CAP = 0.1 * 1e18;\n    /**\n     * @notice Reward factor by which to scale the total rewards earned.\n     * @dev ensures that rewards issued to staked lenders in a given pool are less than the `Ajna` tokens burned in that pool.\n     */\n    uint256 internal constant REWARD_FACTOR = 0.5 * 1e18;\n    /**\n     * @notice Reward factor by which to scale rewards earned for updating a buckets exchange rate.\n     */\n    uint256 internal constant UPDATE_CLAIM_REWARD = 0.05 * 1e18;\n    /**\n     * @notice Time period after a burn event in which buckets exchange rates can be updated.\n     */\n    uint256 internal constant UPDATE_PERIOD = 2 weeks;\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    /// @dev `tokenID => epoch => bool has claimed` mapping.\n    mapping(uint256 => mapping(uint256 => bool)) public override isEpochClaimed;\n    /// @dev `epoch => rewards claimed` mapping.\n    mapping(uint256 => uint256) public override rewardsClaimed;\n    /// @dev `epoch => update bucket rate rewards claimed` mapping.\n    mapping(uint256 => uint256) public override updateRewardsClaimed;\n\n    /// @dev Mapping of per pool bucket exchange rates at a given burn event `poolAddress => bucketIndex => epoch => bucket exchange rate`.\n    mapping(address => mapping(uint256 => mapping(uint256 => uint256))) internal bucketExchangeRates;\n\n    /// @dev Mapping `tokenID => Stake info`.\n    mapping(uint256 => StakeInfo) internal stakes;\n\n    /******************/\n    /*** Immutables ***/\n    /******************/\n\n    /// @dev Address of the `Ajna` token.\n    address public immutable ajnaToken;\n    /// @dev The `PositionManager` contract\n    IPositionManager public immutable positionManager;\n\n    /*******************/\n    /*** Constructor ***/\n    /*******************/\n\n    constructor(address ajnaToken_, IPositionManager positionManager_) {\n        if (ajnaToken_ == address(0)) revert DeployWithZeroAddress();\n\n        ajnaToken = ajnaToken_;\n        positionManager = positionManager_;\n    }\n\n    /**************************/\n    /*** External Functions ***/\n    /**************************/\n\n    /**\n     *  @inheritdoc IRewardsManagerOwnerActions\n     *  @dev    === Revert on ===\n     *  @dev    not owner `NotOwnerOfDeposit()`\n     *  @dev    already claimed `AlreadyClaimed()`\n     *  @dev    === Emit events ===\n     *  @dev    - `ClaimRewards`\n     */\n    function claimRewards(\n        uint256 tokenId_,\n        uint256 epochToClaim_\n    ) external override {\n        StakeInfo storage stakeInfo = stakes[tokenId_];\n\n        if (msg.sender != stakeInfo.owner) revert NotOwnerOfDeposit();\n\n        if (isEpochClaimed[tokenId_][epochToClaim_]) revert AlreadyClaimed();\n\n        _claimRewards(stakeInfo, tokenId_, epochToClaim_, true, stakeInfo.ajnaPool);\n    }\n\n    /**\n     *  @inheritdoc IRewardsManagerOwnerActions\n     *  @dev    === Revert on ===\n     *  @dev    not owner `NotOwnerOfDeposit()`\n     *  @dev    invalid index params `MoveStakedLiquidityInvalid()`\n     *  @dev    === Emit events ===\n     *  @dev    - `MoveStakedLiquidity`\n     */\n    function moveStakedLiquidity(\n        uint256 tokenId_,\n        uint256[] memory fromBuckets_,\n        uint256[] memory toBuckets_,\n        uint256 expiry_\n    ) external nonReentrant override {\n        StakeInfo storage stakeInfo = stakes[tokenId_];\n\n        if (msg.sender != stakeInfo.owner) revert NotOwnerOfDeposit();\n\n        // check move array sizes match to be able to match on index\n        uint256 fromBucketLength = fromBuckets_.length;\n        if (fromBucketLength != toBuckets_.length) revert MoveStakedLiquidityInvalid();\n\n        address ajnaPool = stakeInfo.ajnaPool;\n        uint256 curBurnEpoch = IPool(ajnaPool).currentBurnEpoch();\n\n        // claim rewards before moving liquidity, if any\n        _claimRewards(\n            stakeInfo,\n            tokenId_,\n            curBurnEpoch,\n            false,\n            ajnaPool\n        );\n\n        uint256 fromIndex;\n        uint256 toIndex;\n        for (uint256 i = 0; i < fromBucketLength; ) {\n            fromIndex = fromBuckets_[i];\n            toIndex = toBuckets_[i];\n\n            // call out to position manager to move liquidity between buckets\n            IPositionManagerOwnerActions.MoveLiquidityParams memory moveLiquidityParams = IPositionManagerOwnerActions.MoveLiquidityParams(\n                tokenId_,\n                ajnaPool,\n                fromIndex,\n                toIndex,\n                expiry_\n            );\n            positionManager.moveLiquidity(moveLiquidityParams);\n\n            // update to bucket state\n            BucketState storage toBucket = stakeInfo.snapshot[toIndex];\n            toBucket.lpsAtStakeTime  = uint128(positionManager.getLP(tokenId_, toIndex));\n            toBucket.rateAtStakeTime = uint128(IPool(ajnaPool).bucketExchangeRate(toIndex));\n            delete stakeInfo.snapshot[fromIndex];\n\n            // iterations are bounded by array length (which is itself bounded), preventing overflow / underflow\n            unchecked { ++i; }\n        }\n\n        emit MoveStakedLiquidity(tokenId_, fromBuckets_, toBuckets_);\n\n        // update to bucket list exchange rates, from buckets are aready updated on claim\n        // calculate rewards for updating exchange rates, if any\n        uint256 updateReward = _updateBucketExchangeRates(\n            ajnaPool,\n            toBuckets_\n        );\n\n        // transfer rewards to sender\n        _transferAjnaRewards(updateReward);\n    }\n\n    /**\n     *  @inheritdoc IRewardsManagerOwnerActions\n     *  @dev    === Revert on ===\n     *  @dev    not owner `NotOwnerOfDeposit()`\n     *  @dev    === Emit events ===\n     *  @dev    - `Stake`\n     */\n    function stake(\n        uint256 tokenId_\n    ) external override {\n        address ajnaPool = PositionManager(address(positionManager)).poolKey(tokenId_);\n\n        // check that msg.sender is owner of tokenId\n        if (IERC721(address(positionManager)).ownerOf(tokenId_) != msg.sender) revert NotOwnerOfDeposit();\n\n        StakeInfo storage stakeInfo = stakes[tokenId_];\n        stakeInfo.owner    = msg.sender;\n        stakeInfo.ajnaPool = ajnaPool;\n\n        uint256 curBurnEpoch = IPool(ajnaPool).currentBurnEpoch();\n\n        // record the staking epoch\n        stakeInfo.stakingEpoch = uint96(curBurnEpoch);\n\n        // initialize last time interaction at staking epoch\n        stakeInfo.lastClaimedEpoch = uint96(curBurnEpoch);\n\n        uint256[] memory positionIndexes = positionManager.getPositionIndexes(tokenId_);\n\n        for (uint256 i = 0; i < positionIndexes.length; ) {\n\n            uint256 bucketId = positionIndexes[i];\n\n            BucketState storage bucketState = stakeInfo.snapshot[bucketId];\n\n            // record the number of lps in bucket at the time of staking\n            bucketState.lpsAtStakeTime = uint128(positionManager.getLP(\n                tokenId_,\n                bucketId\n            ));\n            // record the bucket exchange rate at the time of staking\n            bucketState.rateAtStakeTime = uint128(IPool(ajnaPool).bucketExchangeRate(bucketId));\n\n            // iterations are bounded by array length (which is itself bounded), preventing overflow / underflow\n            unchecked { ++i; }\n        }\n\n        emit Stake(msg.sender, ajnaPool, tokenId_);\n\n        // transfer LP NFT to this contract\n        IERC721(address(positionManager)).transferFrom(msg.sender, address(this), tokenId_);\n\n        // calculate rewards for updating exchange rates, if any\n        uint256 updateReward = _updateBucketExchangeRates(\n            ajnaPool,\n            positionIndexes\n        );\n\n        // transfer rewards to sender\n        _transferAjnaRewards(updateReward);\n    }\n\n    /**\n     *  @inheritdoc IRewardsManagerOwnerActions\n     *  @dev    === Revert on ===\n     *  @dev    not owner `NotOwnerOfDeposit()`\n     *  @dev    === Emit events ===\n     *  @dev    - `ClaimRewards`\n     *  @dev    - `Unstake`\n     */\n    function unstake(\n        uint256 tokenId_\n    ) external override {\n        StakeInfo storage stakeInfo = stakes[tokenId_];\n\n        if (msg.sender != stakeInfo.owner) revert NotOwnerOfDeposit();\n\n        address ajnaPool = stakeInfo.ajnaPool;\n\n        // claim rewards, if any\n        _claimRewards(\n            stakeInfo,\n            tokenId_,\n            IPool(ajnaPool).currentBurnEpoch(),\n            false,\n            ajnaPool\n        );\n\n        // remove bucket snapshots recorded at the time of staking\n        uint256[] memory positionIndexes = positionManager.getPositionIndexes(tokenId_);\n        for (uint256 i = 0; i < positionIndexes.length; ) {\n            delete stakeInfo.snapshot[positionIndexes[i]]; // reset BucketState struct for current position\n\n            unchecked { ++i; }\n        }\n\n        // remove recorded stake info\n        delete stakes[tokenId_];\n\n        emit Unstake(msg.sender, ajnaPool, tokenId_);\n\n        // transfer LP NFT from contract to sender\n        IERC721(address(positionManager)).transferFrom(address(this), msg.sender, tokenId_);\n    }\n\n    /**\n     *  @inheritdoc IRewardsManagerOwnerActions\n     *  @dev    === Emit events ===\n     *  @dev    - `UpdateExchangeRates`\n     */\n    function updateBucketExchangeRatesAndClaim(\n        address pool_,\n        uint256[] calldata indexes_\n    ) external override returns (uint256 updateReward) {\n        updateReward = _updateBucketExchangeRates(pool_, indexes_);\n\n        // transfer rewards to sender\n        _transferAjnaRewards(updateReward);\n    }\n\n    /*******************************/\n    /*** External View Functions ***/\n    /*******************************/\n\n    /// @inheritdoc IRewardsManagerDerivedState\n    function calculateRewards(\n        uint256 tokenId_,\n        uint256 epochToClaim_\n    ) external view override returns (uint256 rewards_) {\n\n        address ajnaPool         = stakes[tokenId_].ajnaPool;\n        uint256 lastClaimedEpoch = stakes[tokenId_].lastClaimedEpoch;\n        uint256 stakingEpoch     = stakes[tokenId_].stakingEpoch;\n\n        uint256[] memory positionIndexes = positionManager.getPositionIndexesFiltered(tokenId_);\n\n        // iterate through all burn periods to calculate and claim rewards\n        for (uint256 epoch = lastClaimedEpoch; epoch < epochToClaim_; ) {\n\n            rewards_ += _calculateNextEpochRewards(\n                tokenId_,\n                epoch,\n                stakingEpoch,\n                ajnaPool,\n                positionIndexes\n            );\n\n            unchecked { ++epoch; }\n        }\n    }\n\n    /// @inheritdoc IRewardsManagerState\n    function getStakeInfo(\n        uint256 tokenId_\n    ) external view override returns (address, address, uint256) {\n        return (\n            stakes[tokenId_].owner,\n            stakes[tokenId_].ajnaPool,\n            stakes[tokenId_].lastClaimedEpoch\n        );\n    }\n\n    /// @inheritdoc IRewardsManagerState\n    function getBucketStateStakeInfo(\n        uint256 tokenId_,\n        uint256 bucketId_\n    ) external view override returns (uint256, uint256) {\n        return (\n            stakes[tokenId_].snapshot[bucketId_].lpsAtStakeTime,\n            stakes[tokenId_].snapshot[bucketId_].rateAtStakeTime\n        );\n    }\n\n    /**************************/\n    /*** Internal Functions ***/\n    /**************************/\n\n    /**\n     *  @notice Calculate the amount of rewards that have been accumulated by a staked `NFT`.\n     *  @dev    Rewards are calculated as the difference in exchange rates between the last interaction burn event and the current burn event.\n     *  @param  tokenId_      `ID` of the staked `LP` `NFT`.\n     *  @param  epochToClaim_ The burn epoch to claim rewards for (rewards calculation starts from the last claimed epoch).\n     *  @return rewards_      Amount of rewards earned by the `NFT`.\n     */\n    function _calculateAndClaimRewards(\n        uint256 tokenId_,\n        uint256 epochToClaim_\n    ) internal returns (uint256 rewards_) {\n\n        address ajnaPool         = stakes[tokenId_].ajnaPool;\n        uint256 lastClaimedEpoch = stakes[tokenId_].lastClaimedEpoch;\n        uint256 stakingEpoch     = stakes[tokenId_].stakingEpoch;\n\n        uint256[] memory positionIndexes = positionManager.getPositionIndexesFiltered(tokenId_);\n\n        // iterate through all burn periods to calculate and claim rewards\n        for (uint256 epoch = lastClaimedEpoch; epoch < epochToClaim_; ) {\n\n            uint256 nextEpochRewards = _calculateNextEpochRewards(\n                tokenId_,\n                epoch,\n                stakingEpoch,\n                ajnaPool,\n                positionIndexes\n            );\n\n            rewards_ += nextEpochRewards;\n\n            unchecked { ++epoch; }\n\n            // update epoch token claim trackers\n            rewardsClaimed[epoch]           += nextEpochRewards;\n            isEpochClaimed[tokenId_][epoch] = true;\n        }\n    }\n\n    /**\n     *  @notice Calculate the amount of rewards that have been accumulated by a staked `NFT` in next epoch.\n     *  @dev    Rewards are calculated as the difference in exchange rates between the last interaction burn event and the current burn event.\n     *  @param  tokenId_         `ID` of the staked `LP` `NFT`.\n     *  @param  epoch_           The current epoch.\n     *  @param  stakingEpoch_    The epoch in which token was staked.\n     *  @param  ajnaPool_        Address of the pool.\n     *  @param  positionIndexes_ Bucket ids associated with `NFT` staked.\n     *  @return epochRewards_    Calculated rewards in epoch.\n     */\n    function _calculateNextEpochRewards(\n        uint256 tokenId_,\n        uint256 epoch_,\n        uint256 stakingEpoch_,\n        address ajnaPool_,\n        uint256[] memory positionIndexes_\n    ) internal view returns (uint256 epochRewards_) {\n\n        uint256 nextEpoch = epoch_ + 1;\n        uint256 claimedRewardsInNextEpoch = rewardsClaimed[nextEpoch];\n        uint256 bucketIndex;\n        uint256 interestEarned;\n\n        // iterate through all buckets and calculate epoch rewards for\n        for (uint256 i = 0; i < positionIndexes_.length; ) {\n            bucketIndex = positionIndexes_[i];\n            BucketState memory bucketSnapshot = stakes[tokenId_].snapshot[bucketIndex];\n\n            uint256 bucketRate;\n            if (epoch_ != stakingEpoch_) {\n\n                // if staked in a previous epoch then use the initial exchange rate of epoch\n                bucketRate = bucketExchangeRates[ajnaPool_][bucketIndex][epoch_];\n            } else {\n\n                // if staked during the epoch then use the bucket rate at the time of staking\n                bucketRate = bucketSnapshot.rateAtStakeTime;\n            }\n\n            // calculate the amount of interest accrued in current epoch\n            interestEarned += _calculateExchangeRateInterestEarned(\n                ajnaPool_,\n                nextEpoch,\n                bucketIndex,\n                bucketSnapshot.lpsAtStakeTime,\n                bucketRate\n            ); \n            unchecked { ++i; }\n        }\n\n        // calculate and accumulate rewards if interest earned\n        if (interestEarned != 0) {\n            epochRewards_ = _calculateNewRewards(\n                ajnaPool_,\n                interestEarned,\n                nextEpoch,\n                epoch_,\n                claimedRewardsInNextEpoch\n            );\n        }\n    }\n\n    /**\n     *  @notice Calculate the amount of interest that has accrued to a lender in a bucket based upon their `LP`.\n     *  @param  pool_           Address of the pool whose exchange rates are being checked.\n     *  @param  nextEventEpoch_ The next event epoch to check the exchange rate for.\n     *  @param  bucketIndex_    Index of the bucket to check the exchange rate for.\n     *  @param  bucketLP_       Amount of `LP` in bucket.\n     *  @param  exchangeRate_   Exchange rate in current epoch.\n     *  @return interestEarned_ The amount of interest accrued.\n     */\n    function _calculateExchangeRateInterestEarned(\n        address pool_,\n        uint256 nextEventEpoch_,\n        uint256 bucketIndex_,\n        uint256 bucketLP_,\n        uint256 exchangeRate_\n    ) internal view returns (uint256 interestEarned_) {\n\n        if (exchangeRate_ != 0) {\n\n            uint256 nextExchangeRate = bucketExchangeRates[pool_][bucketIndex_][nextEventEpoch_];\n\n            // calculate interest earned only if next exchange rate is higher than current exchange rate\n            if (nextExchangeRate > exchangeRate_) {\n\n                // calculate the equivalent amount of quote tokens given the stakes lp balance,\n                // and the exchange rate at the next and current burn events\n                interestEarned_ = Maths.wmul(nextExchangeRate - exchangeRate_, bucketLP_);\n            }\n\n        }\n    }\n\n    /**\n     *  @notice Calculate new rewards between current and next epoch, based on earned interest.\n     *  @param  ajnaPool_              Address of the pool.\n     *  @param  interestEarned_        The amount of interest accrued to current epoch.\n     *  @param  nextEpoch_             The next burn event epoch to calculate new rewards.\n     *  @param  epoch_                 The current burn event epoch to calculate new rewards.\n     *  @param  rewardsClaimedInEpoch_ Rewards claimed in epoch.\n     *  @return newRewards_            New rewards between current and next burn event epoch.\n     */\n    function _calculateNewRewards(\n        address ajnaPool_,\n        uint256 interestEarned_,\n        uint256 nextEpoch_,\n        uint256 epoch_,\n        uint256 rewardsClaimedInEpoch_\n    ) internal view returns (uint256 newRewards_) {\n        (\n            ,\n            // total interest accumulated by the pool over the claim period\n            uint256 totalBurnedInPeriod,\n            // total tokens burned over the claim period\n            uint256 totalInterestEarnedInPeriod\n        ) = _getPoolAccumulators(ajnaPool_, nextEpoch_, epoch_);\n\n        // calculate rewards earned\n        newRewards_ = totalInterestEarnedInPeriod == 0 ? 0 : Maths.wmul(\n            REWARD_FACTOR,\n            Maths.wdiv(\n                Maths.wmul(interestEarned_, totalBurnedInPeriod),\n                totalInterestEarnedInPeriod\n            )\n        );\n\n        uint256 rewardsCapped = Maths.wmul(REWARD_CAP, totalBurnedInPeriod);\n\n        // Check rewards claimed - check that less than 80% of the tokens for a given burn event have been claimed.\n        if (rewardsClaimedInEpoch_ + newRewards_ > rewardsCapped) {\n\n            // set claim reward to difference between cap and reward\n            newRewards_ = rewardsCapped - rewardsClaimedInEpoch_;\n        }\n    }\n\n    /**\n     *  @notice Claim rewards that have been accumulated by a staked `NFT`.\n     *  @param  stakeInfo_     `StakeInfo` struct containing details of stake to claim rewards for.\n     *  @param  tokenId_       `ID` of the staked `LP` `NFT`.\n     *  @param  epochToClaim_  The burn epoch to claim rewards for (rewards calculation starts from the last claimed epoch)\n     *  @param  validateEpoch_ True if the epoch is received as a parameter and needs to be validated (lower or equal with latest epoch).\n     *  @param  ajnaPool_      Address of `Ajna` pool associated with the stake.\n     */\n    function _claimRewards(\n        StakeInfo storage stakeInfo_,\n        uint256 tokenId_,\n        uint256 epochToClaim_,\n        bool validateEpoch_,\n        address ajnaPool_\n    ) internal {\n\n        // revert if higher epoch to claim than current burn epoch\n        if (validateEpoch_ && epochToClaim_ > IPool(ajnaPool_).currentBurnEpoch()) revert EpochNotAvailable();\n\n        // update bucket exchange rates and claim associated rewards\n        uint256 rewardsEarned = _updateBucketExchangeRates(\n            ajnaPool_,\n            positionManager.getPositionIndexes(tokenId_)\n        );\n\n        rewardsEarned += _calculateAndClaimRewards(tokenId_, epochToClaim_);\n\n        uint256[] memory burnEpochsClaimed = _getBurnEpochsClaimed(\n            stakeInfo_.lastClaimedEpoch,\n            epochToClaim_\n        );\n\n        emit ClaimRewards(\n            msg.sender,\n            ajnaPool_,\n            tokenId_,\n            burnEpochsClaimed,\n            rewardsEarned\n        );\n\n        // update last interaction burn event\n        stakeInfo_.lastClaimedEpoch = uint96(epochToClaim_);\n\n        // transfer rewards to sender\n        _transferAjnaRewards(rewardsEarned);\n    }\n\n    /**\n     *  @notice Retrieve an array of burn epochs from which a depositor has claimed rewards.\n     *  @param  lastClaimedEpoch_      The last burn period in which a depositor claimed rewards.\n     *  @param  burnEpochToStartClaim_ The most recent burn period from a depositor earned rewards.\n     *  @return burnEpochsClaimed_     Array of burn epochs from which a depositor has claimed rewards.\n     */\n    function _getBurnEpochsClaimed(\n        uint256 lastClaimedEpoch_,\n        uint256 burnEpochToStartClaim_\n    ) internal pure returns (uint256[] memory burnEpochsClaimed_) {\n        uint256 numEpochsClaimed = burnEpochToStartClaim_ - lastClaimedEpoch_;\n\n        burnEpochsClaimed_ = new uint256[](numEpochsClaimed);\n\n        uint256 i;\n        uint256 claimEpoch = lastClaimedEpoch_ + 1;\n        while (claimEpoch <= burnEpochToStartClaim_) {\n            burnEpochsClaimed_[i] = claimEpoch;\n\n            // iterations are bounded by array length (which is itself bounded), preventing overflow / underflow\n            unchecked {\n                ++i;\n                ++claimEpoch;\n            }\n        }\n    }\n\n    /**\n     *  @notice Retrieve the total ajna tokens burned and total interest earned by a pool since a given block.\n     *  @param  pool_                  Address of the `Ajna` pool to retrieve accumulators of.\n     *  @param  currentBurnEventEpoch_ The latest burn event.\n     *  @param  lastBurnEventEpoch_    The burn event to use as checkpoint since which values have accumulated.\n     *  @return Timestamp of the latest burn event.\n     *  @return Total `Ajna` tokens burned by the pool since the last burn event.\n     *  @return Total interest earned by the pool since the last burn event.\n     */\n    function _getPoolAccumulators(\n        address pool_,\n        uint256 currentBurnEventEpoch_,\n        uint256 lastBurnEventEpoch_\n    ) internal view returns (uint256, uint256, uint256) {\n        (\n            uint256 currentBurnTime,\n            uint256 totalInterestLatest,\n            uint256 totalBurnedLatest\n        ) = IPool(pool_).burnInfo(currentBurnEventEpoch_);\n\n        (\n            ,\n            uint256 totalInterestAtBlock,\n            uint256 totalBurnedAtBlock\n        ) = IPool(pool_).burnInfo(lastBurnEventEpoch_);\n\n        uint256 totalBurned   = totalBurnedLatest   != 0 ? totalBurnedLatest   - totalBurnedAtBlock   : totalBurnedAtBlock;\n        uint256 totalInterest = totalInterestLatest != 0 ? totalInterestLatest - totalInterestAtBlock : totalInterestAtBlock;\n\n        return (\n            currentBurnTime,\n            totalBurned,\n            totalInterest\n        );\n    }\n\n    /**\n     *  @notice Update the exchange rate of a list of buckets.\n     *  @dev    Called as part of `stake`, `unstake`, and `claimRewards`, as well as `updateBucketExchangeRatesAndClaim`.\n     *  @dev    Caller can claim `5%` of the rewards that have accumulated to each bucket since the last burn event, if it hasn't already been updated.\n     *  @param  pool_           Address of the pool whose exchange rates are being updated.\n     *  @param  indexes_        List of bucket indexes to be updated.\n     *  @return updatedRewards_ Update exchange rate rewards.\n     */\n    function _updateBucketExchangeRates(\n        address pool_,\n        uint256[] memory indexes_\n    ) internal returns (uint256 updatedRewards_) {\n        // get the current burn epoch from the given pool\n        uint256 curBurnEpoch = IPool(pool_).currentBurnEpoch();\n\n        // update exchange rates only if the pool has not yet burned any tokens without calculating any reward\n        if (curBurnEpoch == 0) {\n            for (uint256 i = 0; i < indexes_.length; ) {\n\n                _updateBucketExchangeRate(\n                    pool_,\n                    indexes_[i],\n                    curBurnEpoch\n                );\n\n                // iterations are bounded by array length (which is itself bounded), preventing overflow / underflow\n                unchecked { ++i; }\n            }\n        }\n\n        else {\n            // retrieve accumulator values used to calculate rewards accrued\n            (\n                uint256 curBurnTime,\n                uint256 totalBurned,\n                uint256 totalInterestEarned\n            ) = _getPoolAccumulators(pool_, curBurnEpoch, curBurnEpoch - 1);\n\n            if (block.timestamp <= curBurnTime + UPDATE_PERIOD) {\n\n                // update exchange rates and calculate rewards if tokens were burned and within allowed time period\n                for (uint256 i = 0; i < indexes_.length; ) {\n\n                    // calculate rewards earned for updating bucket exchange rate\n                    updatedRewards_ += _updateBucketExchangeRateAndCalculateRewards(\n                        pool_,\n                        indexes_[i],\n                        curBurnEpoch,\n                        totalBurned,\n                        totalInterestEarned\n                    );\n\n                    // iterations are bounded by array length (which is itself bounded), preventing overflow / underflow\n                    unchecked { ++i; }\n                }\n\n                uint256 rewardsCap            = Maths.wmul(UPDATE_CAP, totalBurned);\n                uint256 rewardsClaimedInEpoch = updateRewardsClaimed[curBurnEpoch];\n\n                // update total tokens claimed for updating bucket exchange rates tracker\n                if (rewardsClaimedInEpoch + updatedRewards_ >= rewardsCap) {\n                    // if update reward is greater than cap, set to remaining difference\n                    updatedRewards_ = rewardsCap - rewardsClaimedInEpoch;\n                }\n\n                // accumulate the full amount of additional rewards\n                updateRewardsClaimed[curBurnEpoch] += updatedRewards_;\n            }\n        }\n\n        // emit event with the list of bucket indexes updated\n        emit UpdateExchangeRates(msg.sender, pool_, indexes_, updatedRewards_);\n    }\n\n    /**\n     *  @notice Update the exchange rate of a specific bucket.\n     *  @param  pool_        Address of the pool whose exchange rates are being updated.\n     *  @param  bucketIndex_ Bucket index to update exchange rate.\n     *  @param  burnEpoch_   Current burn epoch of the pool.\n     */\n    function _updateBucketExchangeRate(\n        address pool_,\n        uint256 bucketIndex_,\n        uint256 burnEpoch_\n    ) internal {\n        uint256 burnExchangeRate = bucketExchangeRates[pool_][bucketIndex_][burnEpoch_];\n\n        // update bucket exchange rate at epoch only if it wasn't previously updated\n        if (burnExchangeRate == 0) {\n            uint256 curBucketExchangeRate = IPool(pool_).bucketExchangeRate(bucketIndex_);\n\n            // record bucket exchange rate at epoch\n            bucketExchangeRates[pool_][bucketIndex_][burnEpoch_] = curBucketExchangeRate;\n        }\n    }\n\n    /**\n     *  @notice Update the exchange rate of a specific bucket and calculate rewards based on prev exchange rate.\n     *  @param  pool_           Address of the pool whose exchange rates are being updated.\n     *  @param  bucketIndex_    Bucket index to update exchange rate.\n     *  @param  burnEpoch_      Current burn epoch of the pool.\n     *  @param  totalBurned_    Total `Ajna` tokens burned in pool.\n     *  @param  interestEarned_ Total interest rate earned in pool.\n     *  @return rewards_        Rewards for bucket exchange rate update.\n     */\n    function _updateBucketExchangeRateAndCalculateRewards(\n        address pool_,\n        uint256 bucketIndex_,\n        uint256 burnEpoch_,\n        uint256 totalBurned_,\n        uint256 interestEarned_\n    ) internal returns (uint256 rewards_) {\n        uint256 burnExchangeRate = bucketExchangeRates[pool_][bucketIndex_][burnEpoch_];\n\n        // update bucket exchange rate at epoch only if it wasn't previously updated\n        if (burnExchangeRate == 0) {\n            uint256 curBucketExchangeRate = IPool(pool_).bucketExchangeRate(bucketIndex_);\n\n            // record bucket exchange rate at epoch\n            bucketExchangeRates[pool_][bucketIndex_][burnEpoch_] = curBucketExchangeRate;\n\n            // retrieve the bucket exchange rate at the previous epoch\n            uint256 prevBucketExchangeRate = bucketExchangeRates[pool_][bucketIndex_][burnEpoch_ - 1];\n\n            // skip reward calculation if update at the previous epoch was missed and if exchange rate decreased due to bad debt\n            // prevents excess rewards from being provided from using a 0 value as an input to the interestFactor calculation below.\n            if (prevBucketExchangeRate != 0 && prevBucketExchangeRate < curBucketExchangeRate) {\n\n                // retrieve current deposit of the bucket\n                (, , , uint256 bucketDeposit, ) = IPool(pool_).bucketInfo(bucketIndex_);\n\n                uint256 burnFactor     = Maths.wmul(totalBurned_, bucketDeposit);\n                uint256 interestFactor = interestEarned_ == 0 ? 0 : Maths.wdiv(\n                    Maths.WAD - Maths.wdiv(prevBucketExchangeRate, curBucketExchangeRate),\n                    interestEarned_\n                );\n\n                // calculate rewards earned for updating bucket exchange rate \n                rewards_ += Maths.wmul(UPDATE_CLAIM_REWARD, Maths.wmul(burnFactor, interestFactor));\n            }\n        }\n    }\n\n    /** @notice Utility method to transfer `Ajna` rewards to the sender\n     *  @dev   This method is used to transfer rewards to the `msg.sender` after a successful claim or update.\n     *  @dev   It is used to ensure that rewards claimers will be able to claim some portion of the remaining tokens if a claim would exceed the remaining contract balance.\n     *  @param rewardsEarned_ Amount of rewards earned by the caller.\n     */\n    function _transferAjnaRewards(uint256 rewardsEarned_) internal {\n        // check that rewards earned isn't greater than remaining balance\n        // if remaining balance is greater, set to remaining balance\n        uint256 ajnaBalance = IERC20(ajnaToken).balanceOf(address(this));\n        if (rewardsEarned_ > ajnaBalance) rewardsEarned_ = ajnaBalance;\n\n        if (rewardsEarned_ != 0) {\n            // transfer rewards to sender\n            IERC20(ajnaToken).safeTransfer(msg.sender, rewardsEarned_);\n        }\n    }\n\n}"
    },
    {
      "filename": "ajna-core/src/RewardsManager.sol",
      "content": "// SPDX-Lice"
    }
  ]
}