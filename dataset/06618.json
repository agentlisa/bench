{
  "Title": "[H-03] Position NFT can be spammed with insignificant positions by anyone until rewards DoS",
  "Content": "\n<https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L170-L216><br>\n<https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L466-L485>\n\nThe [PositionManager.memorializePositions(params\\_)](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L170-L216) method can be called by **anyone** (per design, see 3rd party test cases) and allows **insignificantly** small (any value > 0) positions to be attached to **anyone** else's positions NFT, see PoC. As a result, the `positionIndexes[params_.tokenId]` storage array for an NFT with given token ID can be spammed with positions without the NFT owner's consent.\n\nTherefore, the [PositionManager.getPositionIndexesFiltered(tokenId\\_)](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L466-L485) method might exceed the block gas limit when iterating the `positionIndexes[tokenId_]` storage array. However, the [RewardsManager.calculateRewards(...)](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/RewardsManager.sol#L325-L349) and [RewardsManager.\\_calculateAndClaimRewards(...)](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/RewardsManager.sol#L384-L414) methods rely on the aforementioned method to succeed in order to calculate and pay rewards.\n\nAll in all, a griefer can spam anyone's position NFT with insignificant positions until the rewards mechanism fails for the NFT owner due to DoS (gas limit). Side note: A position NFT also cannot be burned as long as such insignificant positions are attached to it, see [PositionManager.burn(...)](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L142-L154).\n\n### Proof of Concept\n\nThe following *diff* is based on the existing test case `testMemorializePositions` in `PositionManager.t.sol` and demonstrates that insignificant positions can be attached by anyone.\n\n```diff\ndiff --git a/ajna-core/tests/forge/unit/PositionManager.t.sol b/ajna-core/tests/forge/unit/PositionManager.t.sol\nindex bf3aa40..56c85d1 100644\n--- a/ajna-core/tests/forge/unit/PositionManager.t.sol\n+++ b/ajna-core/tests/forge/unit/PositionManager.t.sol\n@@ -122,6 +122,7 @@ contract PositionManagerERC20PoolTest is PositionManagerERC20PoolHelperContract\n      */\n     function testMemorializePositions() external {\n         address testAddress = makeAddr(\"testAddress\");\n+        address otherAddress = makeAddr(\"otherAddress\");\n         uint256 mintAmount  = 10000 * 1e18;\n\n         _mintQuoteAndApproveManagerTokens(testAddress, mintAmount);\n@@ -134,17 +135,17 @@ contract PositionManagerERC20PoolTest is PositionManagerERC20PoolHelperContract\n\n         _addInitialLiquidity({\n             from:   testAddress,\n-            amount: 3_000 * 1e18,\n+            amount: 1, //3_000 * 1e18,\n             index:  indexes[0]\n         });\n         _addInitialLiquidity({\n             from:   testAddress,\n-            amount: 3_000 * 1e18,\n+            amount: 1, //3_000 * 1e18,\n             index:  indexes[1]\n         });\n         _addInitialLiquidity({\n             from:   testAddress,\n-            amount: 3_000 * 1e18,\n+            amount: 1, // 3_000 * 1e18,\n             index:  indexes[2]\n         });\n\n@@ -165,17 +166,20 @@ contract PositionManagerERC20PoolTest is PositionManagerERC20PoolHelperContract\n\n         // allow position manager to take ownership of the position\n         uint256[] memory amounts = new uint256[](3);\n-        amounts[0] = 3_000 * 1e18;\n-        amounts[1] = 3_000 * 1e18;\n-        amounts[2] = 3_000 * 1e18;\n+        amounts[0] = 1; //3_000 * 1e18;\n+        amounts[1] = 1; //3_000 * 1e18;\n+        amounts[2] = 1; //3_000 * 1e18;\n         _pool.increaseLPAllowance(address(_positionManager), indexes, amounts);\n\n         // memorialize quote tokens into minted NFT\n+        changePrank(otherAddress); // switch other address (not owner of NFT)\n         vm.expectEmit(true, true, true, true);\n-        emit TransferLP(testAddress, address(_positionManager), indexes, 9_000 * 1e18);\n+        emit TransferLP(testAddress, address(_positionManager), indexes, 3 /*9_000 * 1e18*/);\n         vm.expectEmit(true, true, true, true);\n         emit MemorializePosition(testAddress, tokenId, indexes);\n-        _positionManager.memorializePositions(memorializeParams);\n+        _positionManager.memorializePositions(memorializeParams);  // switch back to test address (owner of NFT)\n+        changePrank(testAddress);\n+\n\n         // check memorialization success\n         uint256 positionAtPriceOneLP = _positionManager.getLP(tokenId, indexes[0]);\n\n```\n\n### Tools Used\n\nVS Code, Foundry\n\n### Recommended Mitigation Steps\n\nRequiring that The [PositionManager.memorializePositions(params\\_)](https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L170-L216) can only be called by the NFT owner or anyone who has approval would help but break the 3rd party test cases.\n\nAlternatively, one could enforce a minimum position value to make this griefing attack extremely unattractive.\n\n**[ith-harvey (Ajna) confirmed](https://github.com/code-423n4/2023-05-ajna-findings/issues/488#issuecomment-1554799142)**\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-05-ajna",
  "Code": [
    {
      "filename": "ajna-core/src/PositionManager.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport { ERC20 }           from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport { IERC20 }          from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport { ERC721 }          from '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport { EnumerableSet }   from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport { Multicall }       from '@openzeppelin/contracts/utils/Multicall.sol';\nimport { ReentrancyGuard } from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport { SafeERC20 }       from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport { IPool }                        from './interfaces/pool/IPool.sol';\nimport { IPositionManager }             from './interfaces/position/IPositionManager.sol';\nimport { IPositionManagerOwnerActions } from './interfaces/position/IPositionManagerOwnerActions.sol';\nimport { IPositionManagerDerivedState } from './interfaces/position/IPositionManagerDerivedState.sol';\nimport { Position }                     from './interfaces/position/IPositionManagerState.sol';\n\nimport { ERC20PoolFactory }  from './ERC20PoolFactory.sol';\nimport { ERC721PoolFactory } from './ERC721PoolFactory.sol';\n\nimport { PermitERC721 } from './base/PermitERC721.sol';\n\nimport {\n    _lpToQuoteToken,\n    _priceAt\n}                      from './libraries/helpers/PoolHelper.sol';\nimport { tokenSymbol } from './libraries/helpers/SafeTokenNamer.sol';\n\nimport { PositionNFTSVG } from './libraries/external/PositionNFTSVG.sol';\n\n/**\n *  @title  Position Manager Contract\n *  @notice Used by Pool lenders to optionally mint `NFT` that represents their positions.\n *          `Lenders` can:\n *          - `mint` positions `NFT` token for a specific pool\n *          - `memorialize` positions for given buckets\n *          - `move liquidity` in pool\n *          - `redeem` positions for given buckets\n *          - `burn` positions `NFT`\n */\ncontract PositionManager is ERC721, PermitERC721, IPositionManager, Multicall, ReentrancyGuard {\n\n    using EnumerableSet for EnumerableSet.UintSet;\n    using SafeERC20     for ERC20;\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    /// @dev Mapping of `token id => ajna pool address` for which token was minted.\n    mapping(uint256 => address) public override poolKey;\n\n    /// @dev Mapping of `token id => ajna pool address` for which token was minted.\n    mapping(uint256 => mapping(uint256 => Position)) internal positions;\n    /// @dev Mapping of `token id => nonce` value used for permit.\n    mapping(uint256 => uint96)                       internal nonces;\n    /// @dev Mapping of `token id => bucket indexes` associated with position.\n    mapping(uint256 => EnumerableSet.UintSet)        internal positionIndexes;\n\n    /// @dev Id of the next token that will be minted. Skips `0`.\n    uint176 private _nextId = 1;\n\n    /******************/\n    /*** Immutables ***/\n    /******************/\n\n    /// @dev The `ERC20` pools factory contract, used to check if address is an `Ajna` pool.\n    ERC20PoolFactory  private immutable erc20PoolFactory;\n    /// @dev The `ERC721` pools factory contract, used to check if address is an `Ajna` pool.\n    ERC721PoolFactory private immutable erc721PoolFactory;\n\n    /*************************/\n    /*** Local Var Structs ***/\n    /*************************/\n\n    /// @dev Struct used for `moveLiquidity` function local vars.\n    struct MoveLiquidityLocalVars {\n        uint256 bucketLP;         // [WAD] amount of LP in from bucket\n        uint256 bucketCollateral; // [WAD] amount of collateral in from bucket\n        uint256 bankruptcyTime;   // from bucket bankruptcy time\n        uint256 bucketDeposit;    // [WAD] from bucket deposit\n        uint256 depositTime;      // lender deposit time in from bucekt\n        uint256 maxQuote;         // [WAD] max amount that can be moved from bucket\n        uint256 lpbAmountFrom;    // [WAD] the LP redeemed from bucket\n        uint256 lpbAmountTo;      // [WAD] the LP awarded in to bucket\n    }\n\n    /*****************/\n    /*** Modifiers ***/\n    /*****************/\n\n    /**\n     *  @dev   Modifier used to check if sender can interact with token id.\n     *  @param pool_    `Ajna` pool address.\n     *  @param tokenId_ Id of positions `NFT`.\n     */\n    modifier mayInteract(address pool_, uint256 tokenId_) {\n\n        // revert if token id is not a valid / minted id\n        _requireMinted(tokenId_);\n\n        // revert if sender is not owner of or entitled to operate on token id\n        if (!_isApprovedOrOwner(msg.sender, tokenId_)) revert NoAuth();\n\n        // revert if the token id is not minted for given pool address\n        if (pool_ != poolKey[tokenId_]) revert WrongPool();\n\n        _;\n    }\n\n    /*******************/\n    /*** Constructor ***/\n    /*******************/\n\n    constructor(\n        ERC20PoolFactory erc20Factory_,\n        ERC721PoolFactory erc721Factory_\n    ) PermitERC721(\"Ajna Positions NFT-V1\", \"AJNA-V1-POS\", \"1\") {\n        erc20PoolFactory  = erc20Factory_;\n        erc721PoolFactory = erc721Factory_;\n    }\n\n    /********************************/\n    /*** Owner External Functions ***/\n    /********************************/\n\n    /**\n     *  @inheritdoc IPositionManagerOwnerActions\n     *  @dev    === Write state ===\n     *  @dev    `nonces`: remove `tokenId` nonce\n     *  @dev    `poolKey`: remove `tokenId => pool` mapping\n     *  @dev    === Revert on ===\n     *  @dev    - `mayInteract`:\n     *  @dev       token id is not a valid / minted id\n     *  @dev       sender is not owner `NoAuth()`\n     *  @dev       token id not minted for given pool `WrongPool()`\n     *  @dev    - positions token to burn has liquidity `LiquidityNotRemoved()`\n     *  @dev    === Emit events ===\n     *  @dev    - `Burn`\n     */\n    function burn(\n        BurnParams calldata params_\n    ) external override mayInteract(params_.pool, params_.tokenId) {\n        // revert if trying to burn an positions token that still has liquidity\n        if (positionIndexes[params_.tokenId].length() != 0) revert LiquidityNotRemoved();\n\n        // remove permit nonces and pool mapping for burned token\n        delete nonces[params_.tokenId];\n        delete poolKey[params_.tokenId];\n\n        _burn(params_.tokenId);\n\n        emit Burn(msg.sender, params_.tokenId);\n    }\n\n    /**\n     *  @inheritdoc IPositionManagerOwnerActions\n     *  @dev    External calls to `Pool` contract:\n     *  @dev    - `lenderInfo()`: get lender position in bucket\n     *  @dev    - `transferLP()`: transfer `LP` ownership to `PositionManager` contract\n     *  @dev    === Write state ===\n     *  @dev    `positionIndexes`: add bucket index\n     *  @dev    `positions`: update `tokenId => bucket id` position\n     *  @dev    === Revert on ===\n     *  @dev    positions token to burn has liquidity `LiquidityNotRemoved()`\n     *  @dev    === Emit events ===\n     *  @dev    - `MemorializePosition`\n     */\n    function memorializePositions(\n        MemorializePositionsParams calldata params_\n    ) external override {\n        EnumerableSet.UintSet storage positionIndex = positionIndexes[params_.tokenId];\n\n        IPool   pool  = IPool(poolKey[params_.tokenId]);\n        address owner = ownerOf(params_.tokenId);\n\n        uint256 indexesLength = params_.indexes.length;\n        uint256 index;\n\n        for (uint256 i = 0; i < indexesLength; ) {\n            index = params_.indexes[i];\n\n            // record bucket index at which a position has added liquidity\n            // slither-disable-next-line unused-return\n            positionIndex.add(index);\n\n            (uint256 lpBalance, uint256 depositTime) = pool.lenderInfo(index, owner);\n\n            Position memory position = positions[params_.tokenId][index];\n\n            // check for previous deposits\n            if (position.depositTime != 0) {\n                // check that bucket didn't go bankrupt after prior memorialization\n                if (_bucketBankruptAfterDeposit(pool, index, position.depositTime)) {\n                    // if bucket did go bankrupt, zero out the LP tracked by position manager\n                    position.lps = 0;\n                }\n            }\n\n            // update token position LP\n            position.lps += lpBalance;\n            // set token's position deposit time to the original lender's deposit time\n            position.depositTime = depositTime;\n\n            // save position in storage\n            positions[params_.tokenId][index] = position;\n\n            unchecked { ++i; }\n        }\n\n        // update pool LP accounting and transfer ownership of LP to PositionManager contract\n        pool.transferLP(owner, address(this), params_.indexes);\n\n        emit MemorializePosition(owner, params_.tokenId, params_.indexes);\n    }\n\n    /**\n     *  @inheritdoc IPositionManagerOwnerActions\n     *  @dev    === Write state ===\n     *  @dev    `poolKey`: update `tokenId => pool` mapping\n     *  @dev    === Revert on ===\n     *  @dev    provided pool not valid `NotAjnaPool()`\n     *  @dev    === Emit events ===\n     *  @dev    - `Mint`\n     */\n    function mint(\n        MintParams calldata params_\n    ) external override nonReentrant returns (uint256 tokenId_) {\n        tokenId_ = _nextId++;\n\n        // revert if the address is not a valid Ajna pool\n        if (!_isAjnaPool(params_.pool, params_.poolSubsetHash)) revert NotAjnaPool();\n\n        // record which pool the tokenId was minted in\n        poolKey[tokenId_] = params_.pool;\n\n        _mint(params_.recipient, tokenId_);\n\n        emit Mint(params_.recipient, params_.pool, tokenId_);\n    }\n\n    /**\n     *  @inheritdoc IPositionManagerOwnerActions\n     *  @dev    External calls to `Pool` contract:\n     *  @dev    `bucketInfo()`: get from bucket info\n     *  @dev    `moveQuoteToken()`: move liquidity between buckets\n     *  @dev    === Write state ===\n     *  @dev    `positionIndexes`: remove from bucket index\n     *  @dev    `positionIndexes`: add to bucket index\n     *  @dev    `positions`: update from bucket position\n     *  @dev    `positions`: update to bucket position\n     *  @dev    === Revert on ===\n     *  @dev    - `mayInteract`:\n     *  @dev      token id is not a valid / minted id\n     *  @dev      sender is not owner `NoAuth()`\n     *  @dev      token id not minted for given pool `WrongPool()`\n     *  @dev    - positions token to burn has liquidity `LiquidityNotRemoved()`\n     *  @dev    === Emit events ===\n     *  @dev    - `MoveLiquidity`\n     */\n    function moveLiquidity(\n        MoveLiquidityParams calldata params_\n    ) external override mayInteract(params_.pool, params_.tokenId) nonReentrant {\n        Position storage fromPosition = positions[params_.tokenId][params_.fromIndex];\n\n        MoveLiquidityLocalVars memory vars;\n        vars.depositTime = fromPosition.depositTime;\n\n        // handle the case where owner attempts to move liquidity after they've already done so\n        if (vars.depositTime == 0) revert RemovePositionFailed();\n\n        // ensure bucketDeposit accounts for accrued interest\n        IPool(params_.pool).updateInterest();\n\n        // retrieve info of bucket from which liquidity is moved  \n        (\n            vars.bucketLP,\n            vars.bucketCollateral,\n            vars.bankruptcyTime,\n            vars.bucketDeposit,\n        ) = IPool(params_.pool).bucketInfo(params_.fromIndex);\n\n        // check that bucket hasn't gone bankrupt since memorialization\n        if (vars.depositTime <= vars.bankruptcyTime) revert BucketBankrupt();\n\n        // calculate the max amount of quote tokens that can be moved, given the tracked LP\n        vars.maxQuote = _lpToQuoteToken(\n            vars.bucketLP,\n            vars.bucketCollateral,\n            vars.bucketDeposit,\n            fromPosition.lps,\n            vars.bucketDeposit,\n            _priceAt(params_.fromIndex)\n        );\n\n        EnumerableSet.UintSet storage positionIndex = positionIndexes[params_.tokenId];\n\n        // remove bucket index from which liquidity is moved from tracked positions\n        if (!positionIndex.remove(params_.fromIndex)) revert RemovePositionFailed();\n\n        // update bucket set at which a position has liquidity\n        // slither-disable-next-line unused-return\n        positionIndex.add(params_.toIndex);\n\n        // move quote tokens in pool\n        (\n            vars.lpbAmountFrom,\n            vars.lpbAmountTo,\n        ) = IPool(params_.pool).moveQuoteToken(\n            vars.maxQuote,\n            params_.fromIndex,\n            params_.toIndex,\n            params_.expiry\n        );\n\n        Position storage toPosition = positions[params_.tokenId][params_.toIndex];\n\n        // update position LP state\n        fromPosition.lps -= vars.lpbAmountFrom;\n        toPosition.lps   += vars.lpbAmountTo;\n        // update position deposit time to the from bucket deposit time\n        toPosition.depositTime = vars.depositTime;\n\n        emit MoveLiquidity(\n            ownerOf(params_.tokenId),\n            params_.tokenId,\n            params_.fromIndex,\n            params_.toIndex,\n            vars.lpbAmountFrom,\n            vars.lpbAmountTo\n        );\n    }\n\n    /**\n     *  @inheritdoc IPositionManagerOwnerActions\n     *  @dev    External calls to `Pool` contract:\n     *  @dev    `increaseLPAllowance()`: approve ownership for transfer\n     *  @dev    `transferLP()`: transfer `LP` ownership from `PositionManager` contract\n     *  @dev    === Write state ===\n     *  @dev    `positionIndexes`: remove from bucket index\n     *  @dev    `positions`: delete bucket position\n     *  @dev    === Revert on ===\n     *  @dev    - `mayInteract`:\n     *  @dev      token id is not a valid / minted id\n     *  @dev      sender is not owner `NoAuth()`\n     *  @dev      token id not minted for given pool `WrongPool()`\n     *  @dev    - position not tracked `RemoveLiquidityFailed()`\n     *  @dev    === Emit events ===\n     *  @dev    - `RedeemPosition`\n     */\n    function reedemPositions(\n        RedeemPositionsParams calldata params_\n    ) external override mayInteract(params_.pool, params_.tokenId) {\n        EnumerableSet.UintSet storage positionIndex = positionIndexes[params_.tokenId];\n\n        IPool pool = IPool(params_.pool);\n\n        uint256 indexesLength = params_.indexes.length;\n        uint256[] memory lpAmounts = new uint256[](indexesLength);\n\n        uint256 index;\n\n        for (uint256 i = 0; i < indexesLength; ) {\n            index = params_.indexes[i];\n\n            Position memory position = positions[params_.tokenId][index];\n\n            if (position.depositTime == 0 || position.lps == 0) revert RemovePositionFailed();\n\n            // check that bucket didn't go bankrupt after memorialization\n            if (_bucketBankruptAfterDeposit(pool, index, position.depositTime)) revert BucketBankrupt();\n\n            // remove bucket index at which a position has added liquidity\n            if (!positionIndex.remove(index)) revert RemovePositionFailed();\n\n            lpAmounts[i] = position.lps;\n\n            // remove LP tracked by position manager at bucket index\n            delete positions[params_.tokenId][index];\n\n            unchecked { ++i; }\n        }\n\n        address owner = ownerOf(params_.tokenId);\n\n        // approve owner to take over the LP ownership (required for transferLP pool call)\n        pool.increaseLPAllowance(owner, params_.indexes, lpAmounts);\n        // update pool lps accounting and transfer ownership of lps from PositionManager contract\n        pool.transferLP(address(this), owner, params_.indexes);\n\n        emit RedeemPosition(owner, params_.tokenId, params_.indexes);\n    }\n\n    /**************************/\n    /*** Internal Functions ***/\n    /**************************/\n\n    /**\n     *  @notice Retrieves token's next nonce for permit.\n     *  @param  tokenId_ Address of the `Ajna` pool to retrieve accumulators of.\n     *  @return Incremented token permit nonce.\n     */\n    function _getAndIncrementNonce(\n        uint256 tokenId_\n    ) internal override returns (uint256) {\n        return uint256(nonces[tokenId_]++);\n    }\n\n    /**\n     *  @notice Checks that a provided pool address was deployed by an `Ajna` factory.\n     *  @param  pool_       Address of the `Ajna` pool.\n     *  @param  subsetHash_ Factory's subset hash pool.\n     *  @return `True` if a valid `Ajna` pool, `false` otherwise.\n     */\n    function _isAjnaPool(\n        address pool_,\n        bytes32 subsetHash_\n    ) internal view returns (bool) {\n        address collateralAddress = IPool(pool_).collateralAddress();\n        address quoteAddress      = IPool(pool_).quoteTokenAddress();\n\n        address erc20DeployedPoolAddress  = erc20PoolFactory.deployedPools(subsetHash_, collateralAddress, quoteAddress);\n        address erc721DeployedPoolAddress = erc721PoolFactory.deployedPools(subsetHash_, collateralAddress, quoteAddress);\n\n        return (pool_ == erc20DeployedPoolAddress || pool_ == erc721DeployedPoolAddress);\n    }\n\n    /**\n     *  @notice Checks that a bucket index associated with a given `NFT` didn't go bankrupt after memorialization.\n     *  @param  pool_        The address of the pool of memorialized position.\n     *  @param  index_       The bucket index to check deposit time for.\n     *  @param  depositTime_ The recorded deposit time of the position.\n     *  @return `True` if the bucket went bankrupt after that position memorialzied their `LP`.\n     */\n    function _bucketBankruptAfterDeposit(\n        IPool pool_,\n        uint256 index_,\n        uint256 depositTime_\n    ) internal view returns (bool) {\n        (, , uint256 bankruptcyTime, , ) = pool_.bucketInfo(index_);\n        return depositTime_ <= bankruptcyTime;\n    }\n\n    /**********************/\n    /*** View Functions ***/\n    /**********************/\n\n    /// @inheritdoc IPositionManagerDerivedState\n    function getLP(\n        uint256 tokenId_,\n        uint256 index_\n    ) external override view returns (uint256) {\n        Position memory position = positions[tokenId_][index_];\n        return _bucketBankruptAfterDeposit(IPool(poolKey[tokenId_]), index_, position.depositTime) ? 0 : position.lps;\n    }\n\n    /// @inheritdoc IPositionManagerDerivedState\n    function getPositionIndexes(\n        uint256 tokenId_\n    ) external view override returns (uint256[] memory) {\n        return positionIndexes[tokenId_].values();\n    }\n\n    /// @inheritdoc IPositionManagerDerivedState\n    function getPositionIndexesFiltered(\n        uint256 tokenId_\n    ) external view override returns (uint256[] memory filteredIndexes_) {\n        uint256[] memory indexes = positionIndexes[tokenId_].values();\n        uint256 indexesLength = indexes.length;\n\n        // filter out bankrupt buckets\n        filteredIndexes_ = new uint256[](indexesLength);\n        uint256 filteredIndexesLength = 0;\n        IPool pool = IPool(poolKey[tokenId_]);\n        for (uint256 i = 0; i < indexesLength; ) {\n            if (!_bucketBankruptAfterDeposit(pool, indexes[i], positions[tokenId_][indexes[i]].depositTime)) {\n                filteredIndexes_[filteredIndexesLength++] = indexes[i];\n            }\n            unchecked { ++i; }\n        }\n\n        // resize array\n        assembly { mstore(filteredIndexes_, filteredIndexesLength) }\n    }\n\n    /// @inheritdoc IPositionManagerDerivedState\n    function getPositionInfo(\n        uint256 tokenId_,\n        uint256 index_\n    ) external view override returns (uint256, uint256) {\n        return (\n            positions[tokenId_][index_].lps,\n            positions[tokenId_][index_].depositTime\n        );\n    }\n\n    /// @inheritdoc IPositionManagerDerivedState\n    function isPositionBucketBankrupt(\n        uint256 tokenId_,\n        uint256 index_\n    ) external view override returns (bool) {\n        return _bucketBankruptAfterDeposit(IPool(poolKey[tokenId_]), index_, positions[tokenId_][index_].depositTime);\n    }\n\n    /// @inheritdoc IPositionManagerDerivedState\n    function isIndexInPosition(\n        uint256 tokenId_,\n        uint256 index_\n    ) external override view returns (bool) {\n        return positionIndexes[tokenId_].contains(index_);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(\n        uint256 tokenId_\n    ) public view override(ERC721) returns (string memory) {\n        require(_exists(tokenId_));\n\n        address collateralTokenAddress = IPool(poolKey[tokenId_]).collateralAddress();\n        address quoteTokenAddress      = IPool(poolKey[tokenId_]).quoteTokenAddress();\n\n        PositionNFTSVG.ConstructTokenURIParams memory params = PositionNFTSVG.ConstructTokenURIParams({\n            collateralTokenSymbol: tokenSymbol(collateralTokenAddress),\n            quoteTokenSymbol:      tokenSymbol(quoteTokenAddress),\n            tokenId:               tokenId_,\n            pool:                  poolKey[tokenId_],\n            owner:                 ownerOf(tokenId_),\n            indexes:               positionIndexes[tokenId_].values()\n        });\n\n        return PositionNFTSVG.constructTokenURI(params);\n    }\n\n}"
    },
    {
      "filename": "ajna-core/src/PositionManager.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport { ERC20 }           from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport { IERC20 }          from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport { ERC721 }          from '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport { EnumerableSet }   from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport { Multicall }       from '@openzeppelin/contracts/utils/Multicall.sol';\nimport { ReentrancyGuard } from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport { SafeERC20 }       from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport { IPool }                        from './interfaces/pool/IPool.sol';\nimport { IPositionManager }             from './interfaces/position/IPositionManager.sol';\nimport { IPositionManagerOwnerActions } from './interfaces/position/IPositionManagerOwnerActions.sol';\nimport { IPositionManagerDerivedState } from './interfaces/position/IPositionManagerDerivedState.sol';\nimport { Position }                     from './interfaces/position/IPositionManagerState.sol';\n\nimport { ERC20PoolFactory }  from './ERC20PoolFactory.sol';\nimport { ERC721PoolFactory } from './ERC721PoolFactory.sol';\n\nimport { PermitERC721 } from './base/PermitERC721.sol';\n\nimport {\n    _lpToQuoteToken,\n    _priceAt\n}                      from './libraries/helpers/PoolHelper.sol';\nimport { tokenSymbol } from './libraries/helpers/SafeTokenNamer.sol';\n\nimport { PositionNFTSVG } from './libraries/external/PositionNFTSVG.sol';\n\n/**\n *  @title  Position Manager Contract\n *  @notice Used by Pool lenders to optionally mint `NFT` that represents their positions.\n *          `Lenders` can:\n *          - `mint` positions `NFT` token for a specific pool\n *          - `memorialize` positions for given buckets\n *          - `move liquidity` in pool\n *          - `redeem` positions for given buckets\n *          - `burn` positions `NFT`\n */\ncontract PositionManager is ERC721, PermitERC721, IPositionManager, Multicall, ReentrancyGuard {\n\n    using EnumerableSet for EnumerableSet.UintSet;\n    using SafeERC20     for ERC20;\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    /// @dev Mapping of `token id => ajna pool address` for which token was minted.\n    mapping(uint256 => address) public override poolKey;\n\n    /// @dev Mapping of `token id => ajna pool address` for which token was minted.\n    mapping(uint256 => mapping(uint256 => Position)) internal positions;\n    /// @dev Mapping of `token id => nonce` value used for permit.\n    mapping(uint256 => uint96)                       internal nonces;\n    /// @dev Mapping of `token id => bucket indexes` associated with position.\n    mapping(uint256 => EnumerableSet.UintSet)        internal positionIndexes;\n\n    /// @dev Id of the next token that will be minted. Skips `0`.\n    uint176 private _nextId = 1;\n\n    /******************/\n    /*** Immutables ***/\n    /******************/\n\n    /// @dev The `ERC20` pools factory contract, used to check if address is an `Ajna` pool.\n    ERC20PoolFactory  private immutable erc20PoolFactory;\n    /// @dev The `ERC721` pools factory contract, used to check if address is an `Ajna` pool.\n    ERC721PoolFactory private immutable erc721PoolFactory;\n\n    /*************************/\n    /*** Local Var Structs ***/\n    /*************************/\n\n    /// @dev Struct used for `moveLiquidity` function local vars.\n    struct MoveLiquidityLocalVars {\n        uint256 bucketLP;         // [WAD] amount of LP in from bucket\n        uint256 bucketCollateral; // [WAD] amount of collateral in from bucket\n        uint256 bankruptcyTime;   // from bucket bankruptcy time\n        uint256 bucketDeposit;    // [WAD] from bucket deposit\n        uint256 depositTime;      // lender deposit time in from bucekt\n        uint256 maxQuote;         // [WAD] max amount that can be moved from bucket\n        uint256 lpbAmountFrom;    // [WAD] the LP redeemed from bucket\n        uint256 lpbAmountTo;      // [WAD] the LP awarded in to bucket\n    }\n\n    /*****************/\n    /*** Modifiers ***/\n    /*****************/\n\n    /**\n     *  @dev   Modifier used to check if sender can interact with token id.\n     *  @param pool_    `Ajna` pool address.\n     *  @param tokenId_ Id of positions `NFT`.\n     */\n    modifier mayInteract(address pool_, uint256 tokenId_) {\n\n        // revert if token id is not a valid / minted id\n        _requireMinted(tokenId_);\n\n        // revert if sender is not owner of or entitled to operate on token id\n        if (!_isApprovedOrOwner(msg.sender, tokenId_)) revert NoAuth();\n\n        // revert if the token id is not minted for given pool address\n        if (pool_ != poolKey[tokenId_]) revert WrongPool();\n\n        _;\n    }\n\n    /*******************/\n    /*** Constructor ***/\n    /*******************/\n\n    constructor(\n        ERC20PoolFactory erc20Factory_,\n        ERC721PoolFactory erc721Factory_\n    ) PermitERC721(\"Ajna Positions NFT-V1\", \"AJNA-V1-POS\", \"1\") {\n        erc20PoolFactory  = erc20Factory_;\n        erc721PoolFactory = erc721Factory_;\n    }\n\n    /********************************/\n    /*** Owner External Functions ***/\n    /********************************/\n\n    /**\n     *  @inheritdoc IPositionManagerOwnerActions\n     *  @dev    === Write state ===\n     *  @dev    `nonces`: remove `tokenId` nonce\n     *  @dev    `poolKey`: remove `tokenId => pool` mapping\n     *  @dev    === Revert on ===\n     *  @dev    - `mayInteract`:\n     *  @dev       token id is not a valid / minted id\n     *  @dev       sender is not owner `NoAuth()`\n     *  @dev       token id not minted for given pool `WrongPool()`\n     *  @dev    - positions token to burn has liquidity `LiquidityNotRemoved()`\n     *  @dev    === Emit events ===\n     *  @dev    - `Burn`\n     */\n    function burn(\n        BurnParams calldata params_\n    ) external override mayInteract(params_.pool, params_.tokenId) {\n        // revert if trying to burn an positions token that still has liquidity\n        if (positionIndexes[params_.tokenId].length() != 0) revert LiquidityNotRemoved();\n\n        // remove permit nonces and pool mapping for burned token\n        delete nonces[params_.tokenId];\n        delete poolKey[params_.tokenId];\n\n        _burn(params_.tokenId);\n\n        emit Burn(msg.sender, params_.tokenId);\n    }\n\n    /**\n     *  @inheritdoc IPositionManagerOwnerActions\n     *  @dev    External calls to `Pool` contract:\n     *  @dev    - `lenderInfo()`: get lender position in bucket\n     *  @dev    - `transferLP()`: transfer `LP` ownership to `PositionManager` contract\n     *  @dev    === Write state ===\n     *  @dev    `positionIndexes`: add bucket index\n     *  @dev    `positions`: update `tokenId => bucket id` position\n     *  @dev    === Revert on ===\n     *  @dev    positions token to burn has liquidity `LiquidityNotRemoved()`\n     *  @dev    === Emit events ===\n     *  @dev    - `MemorializePosition`\n     */\n    function memorializePositions(\n        MemorializePositionsParams calldata params_\n    ) external override {\n        EnumerableSet.UintSet storage positionIndex = positionIndexes[params_.tokenId];\n\n        IPool   pool  = IPool(poolKey[params_.tokenId]);\n        address owner = ownerOf(params_.tokenId);\n\n        uint256 indexesLength = params_.indexes.length;\n        uint256 index;\n\n        for (uint256 i = 0; i < indexesLength; ) {\n            index = params_.indexes[i];\n\n            // record bucket index at which a position has added liquidity\n            // slither-disable-next-line unused-return\n            positionIndex.add(index);\n\n            (uint256 lpBalance, uint256 depositTime) = pool.lenderInfo(index, owner);\n\n            Position memory position = positions[params_.tokenId][index];\n\n            // check for previous deposits\n            if (position.depositTime != 0) {\n                // check that bucket didn't go bankrupt after prior memorialization\n                if (_bucketBankruptAfterDeposit(pool, index, position.depositTime)) {\n                    // if bucket did go bankrupt, zero out the LP tracked by position manager\n                    position.lps = 0;\n                }\n            }\n\n            // update token position LP\n            position.lps += lpBalance;\n            // set token's position deposit time to the original lender's deposit time\n            position.depositTime = depositTime;\n\n            // save position in storage\n            positions[params_.tokenId][index] = position;\n\n            unchecked { ++i; }\n        }\n\n        // update pool LP accounting and transfer ownership of LP to PositionManager contract\n        pool.transferLP(owner, address(this), params_.indexes);\n\n        emit MemorializePosition(owner, params_.tokenId, params_.indexes);\n    }\n\n    /**\n     *  @inheritdoc IPositionManagerOwnerActions\n     *  @dev    === Write state ===\n     *  @dev    `poolKey`: update `tokenId => pool` mapping\n     *  @dev    === Revert on ===\n     *  @dev    provided pool not valid `NotAjnaPool()`\n     *  @dev    === Emit events ===\n     *  @dev    - `Mint`\n     */\n    function mint(\n        MintParams calldata params_\n    ) external override nonReentrant returns (uint256 tokenId_) {\n        tokenId_ = _nextId++;\n\n        // revert if the address is not a valid Ajna pool\n        if (!_isAjnaPool(params_.pool, params_.poolSubsetHash)) revert NotAjnaPool();\n\n        // record which pool the tokenId was minted in\n        poolKey[tokenId_] = params_.pool;\n\n        _mint(params_.recipient, tokenId_);\n\n        emit Mint(params_.recipient, params_.pool, tokenId_);\n    }\n\n    /**\n     *  @inheritdoc IPositionManagerOwnerActions\n     *  @dev    External calls to `Pool` contract:\n     *  @dev    `bucketInfo()`: get from bucket info\n     *  @dev    `moveQuoteToken()`: move liquidity between buckets\n     *  @dev    === Write state ===\n     *  @dev    `positionIndexes`: remove from bucket index\n     *  @dev    `positionIndexes`: add to bucket index\n     *  @dev    `positions`: update from bucket position\n     *  @dev    `positions`: update to bucket position\n     *  @dev    === Revert on ===\n     *  @dev    - `mayInteract`:\n     *  @dev      token id is not a valid / minted id\n     *  @dev      sender is not owner `NoAuth()`\n     *  @dev      token id not minted for given pool `WrongPool()`\n     *  @dev    - positions token to burn has liquidity `LiquidityNotRemoved()`\n     *  @dev    === Emit events ===\n     *  @dev    - `MoveLiquidity`\n     */\n    function moveLiquidity(\n        MoveLiquidityParams calldata params_\n    ) external override mayInteract(params_.pool, params_.tokenId) nonReentrant {\n        Position storage fromPosition = positions[params_.tokenId][params_.fromIndex];\n\n        MoveLiquidityLocalVars memory vars;\n        vars.depositTime = fromPosition.depositTime;\n\n        // handle the case where owner attempts to move liquidity after they've already done so\n        if (vars.depositTime == 0) revert RemovePositionFailed();\n\n        // ensure bucketDeposit accounts for accrued interest\n        IPool(params_.pool).updateInterest();\n\n        // retrieve info of bucket from which liquidity is moved  \n        (\n            vars.bucketLP,\n            vars.bucketCollateral,\n            vars.bankruptcyTime,\n            vars.bucketDeposit,\n        ) = IPool(params_.pool).bucketInfo(params_.fromIndex);\n\n        // check that bucket hasn't gone bankrupt since memorialization\n        if (vars.depositTime <= vars.bankruptcyTime) revert BucketBankrupt();\n\n        // calcula"
    }
  ]
}