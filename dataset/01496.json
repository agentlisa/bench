{
  "Title": "M-4: Mainnet oracles are incompatible with wstETH causing many popular yields strategies to be broken",
  "Content": "# Issue M-4: Mainnet oracles are incompatible with wstETH causing many popular yields strategies to be broken \n\nSource: https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/96 \n\n## Found by \n0x52\n\nMainnet oracles are incompatible with wstETH causing many popular yields strategies to be broken. Chainlink and Band do not have wstETH oracles and using Uniswap LP pairs would be very dangerous given their low liquidity. \n\n## Vulnerability Detail\n\n[ChainlinkAdapterOracle.sol#L111-L125](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/oracle/ChainlinkAdapterOracle.sol#L111-L125)\n\n        uint256 decimals = registry.decimals(token, USD);\n        (\n            uint80 roundID,\n            int256 answer,\n            ,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        ) = registry.latestRoundData(token, USD);\n        if (updatedAt < block.timestamp - maxDelayTime)\n            revert Errors.PRICE_OUTDATED(token_);\n        if (answer <= 0) revert Errors.PRICE_NEGATIVE(token_);\n        if (answeredInRound < roundID) revert Errors.PRICE_OUTDATED(token_);\n\n        return\n            (answer.toUint256() * Constants.PRICE_PRECISION) / 10 ** decimals;\n\nChainlinkAdapterOracle only supports single asset price data. This makes it completely incompatible with wstETH because chainlink doesn't have a wstETH oracle on mainnet. Additionally Band protocol doesn't offer a wstETH oracle either. This only leaves Uniswap oracles which are highly dangerous given their low liquidity.\n\n## Impact\n\nMainnet oracles are incompatible with wstETH causing many popular yields strategies to be broken\n\n## Code Snippet\n\n[ChainlinkAdapterOracle.sol#L102-L126](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/oracle/ChainlinkAdapterOracle.sol#L102-L126)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCreate a special bypass specifically for wstETH utilizing the stETH oracle and it's current exchange rate. \n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**0xyPhilic** commented:\n> invalid because this issue can be considered informational or at best low - tokens used are whitelisted\n\n**Kral01** commented:\n> low severity\n\n\n\n**IAm0x52**\n\nEscalate\n\nThis was wrongly excluded. Protocol is meant to be compatible with these pools but can't work with them. I believe this is a valid medium because the protocol is nonfunctional in this area.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This was wrongly excluded. Protocol is meant to be compatible with these pools but can't work with them. I believe this is a valid medium because the protocol is nonfunctional in this area.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Shogoki**\n\n> Escalate\n> \n> This was wrongly excluded. Protocol is meant to be compatible with these pools but can't work with them. I believe this is a valid medium because the protocol is nonfunctional in this area.\n\nNot sure were it says that the protcol is meant to be compatible with `WSTETH` pools on mainnet. \n\nIf that is the case it can be a valid issue, i guess. \nHowever if it is not, i think the Whitelisting of tokens would count for invalidating it.\n\n**IAm0x52**\n\nProtocol is meant to be compatible with Aura/Convex. wstETH is a component of many highly attractive pools. Not being able to support wstETH as an underlying asset will break support for these.\n\n**hrishibhat**\n\n@Gornutz \n\n**Gornutz**\n\nConfirm this is valid. \n\n**hrishibhat**\n\nResult:\nMedium\nUnique\nConsidering this issue a valid medium\n\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [IAm0x52](https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/96/#issuecomment-1694747143): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/104",
  "Code": [
    {
      "filename": "blueberry-core/contracts/oracle/ChainlinkAdapterOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"./BaseAdapter.sol\";\nimport \"../interfaces/IBaseOracle.sol\";\nimport \"../interfaces/chainlink/IFeedRegistry.sol\";\n\n/// @title ChainlinkAdapterOracle for L1 Chains\n/// @author BlueberryProtocol\n/// @notice This Oracle Adapter leverages Chainlink's decentralized price feeds to provide accurate price data.\n///         It also supports remapping of tokens to their canonical forms (e.g., WBTC to BTC).\ncontract ChainlinkAdapterOracle is IBaseOracle, BaseAdapter {\n    using SafeCast for int256;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      PUBLIC STORAGE \n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// Chainlink feed registry for accessing price feeds.\n    /// (source: https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/Denominations.sol)\n    IFeedRegistry public registry;\n    /// Address representing USD in Chainlink's denominations.\n    address public constant USD = address(840);\n\n    /// @dev Maps tokens to their canonical form for price querying.\n    ///      For example, WETH may be remapped to ETH, WBTC to BTC, etc.\n    mapping(address => address) public remappedTokens;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     EVENTS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Emitted when the Chainlink feed registry used by the adapter is updated.\n    /// @param registry The new Chainlink feed registry address.\n    event SetRegistry(address registry);\n\n    /// @notice Emitted when a token is remapped to its canonical form.\n    /// @param token The original token address that's being remapped.\n    /// @param remappedToken The canonical form of the token to which the original is remapped.\n    event SetTokenRemapping(\n        address indexed token,\n        address indexed remappedToken\n    );\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    /// @param registry_ Chainlink feed registry address.\n    constructor(IFeedRegistry registry_) {\n        if (address(registry_) == address(0)) revert Errors.ZERO_ADDRESS();\n\n        registry = registry_;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Updates the Chainlink feed registry used by this adapter.\n    /// @param registry_ The new Chainlink feed registry address.\n    /// @dev Can only be called by the contract owner.\n    function setFeedRegistry(IFeedRegistry registry_) external onlyOwner {\n        if (address(registry_) == address(0)) revert Errors.ZERO_ADDRESS();\n        registry = registry_;\n        emit SetRegistry(address(registry_));\n    }\n\n    /// @notice Maps a list of tokens to their canonical form for price queries.\n    /// @param tokens_ The list of tokens to be remapped.\n    /// @param remappedTokens_ The list of tokens to remap to.\n    /// @dev Both arrays should have the same length. Can only be called by the contract owner.\n    function setTokenRemappings(\n        address[] calldata tokens_,\n        address[] calldata remappedTokens_\n    ) external onlyOwner {\n        if (remappedTokens_.length != tokens_.length)\n            revert Errors.INPUT_ARRAY_MISMATCH();\n        for (uint256 idx = 0; idx < tokens_.length; idx++) {\n            if (tokens_[idx] == address(0)) revert Errors.ZERO_ADDRESS();\n\n            remappedTokens[tokens_[idx]] = remappedTokens_[idx];\n            emit SetTokenRemapping(tokens_[idx], remappedTokens_[idx]);\n        }\n    }\n\n    /// @notice Fetches the USD price of the specified token from Chainlink's feed.\n    ///         If the token has been remapped, it uses the canonical form for price querying.\n    /// @param token_ Address of the token for which to fetch the price.\n    /// @return price The USD price of the token, represented with 18 decimals.\n    function getPrice(address token_) external override returns (uint256) {\n        /// remap token if possible\n        address token = remappedTokens[token_];\n        if (token == address(0)) token = token_;\n\n        uint256 maxDelayTime = timeGaps[token];\n        if (maxDelayTime == 0) revert Errors.NO_MAX_DELAY(token_);\n\n        /// Get token-USD price\n        uint256 decimals = registry.decimals(token, USD);\n        (\n            uint80 roundID,\n            int256 answer,\n            ,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        ) = registry.latestRoundData(token, USD);\n        if (updatedAt < block.timestamp - maxDelayTime)\n            revert Errors.PRICE_OUTDATED(token_);\n        if (answer <= 0) revert Errors.PRICE_NEGATIVE(token_);\n        if (answeredInRound < roundID) revert Errors.PRICE_OUTDATED(token_);\n\n        return\n            (answer.toUint256() * Constants.PRICE_PRECISION) / 10 ** decimals;\n    }\n}"
    },
    {
      "filename": "blueberry-core/contracts/oracle/ChainlinkAdapterOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"./BaseAdapter.sol\";\nimport \"../interfaces/IBaseOracle.sol\";\nimport \"../interfaces/chainlink/IFeedRegistry.sol\";\n\n/// @title ChainlinkAdapterOracle for L1 Chains\n/// @author BlueberryProtocol\n/// @notice This Oracle Adapter leverages Chainlink's decentralized price feeds to provide accurate price data.\n///         It also supports remapping of tokens to their canonical forms (e.g., WBTC to BTC).\ncontract ChainlinkAdapterOracle is IBaseOracle, BaseAdapter {\n    using SafeCast for int256;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      PUBLIC STORAGE \n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// Chainlink feed registry for accessing price feeds.\n    /// (source: https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/Denominations.sol)\n    IFeedRegistry public registry;\n    /// Address representing USD in Chainlink's denominations.\n    address public constant USD = address(840);\n\n    /// @dev Maps tokens to their canonical form for price querying.\n    ///      For example, WETH may be remapped to ETH, WBTC to BTC, etc.\n    mapping(address => address) public remappedTokens;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     EVENTS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Emitted when the Chainlink feed registry used by the adapter is updated.\n    /// @param registry The new Chainlink feed registry address.\n    event SetRegistry(address registry);\n\n    /// @notice Emitted when a token is remapped to its canonical form.\n    /// @param token The original token address that's being remapped.\n    /// @param remappedToken The canonical form of the token to which the original is remapped.\n    event SetTokenRemapping(\n        address indexed token,\n        address indexed remappedToken\n    );\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    /// @param registry_ Chainlink feed registry address.\n    constructor(IFeedRegistry registry_) {\n        if (address(registry_) == address(0)) revert Errors.ZERO_ADDRESS();\n\n        registry = registry_;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Updates the Chainlink feed registry used by this adapter.\n    /// @param registry_ The new Chainlink feed registry address.\n    /// @dev Can only be called by the contract owner.\n    function setFeedRegistry(IFeedRegistry registry_) external onlyOwner {\n        if (address(registry_) == address(0)) revert Errors.ZERO_ADDRESS();\n        registry = registry_;\n        emit SetRegistry(address(registry_));\n    }\n\n    /// @notice Maps a list of tokens to their canonical form for price queries.\n    /// @param tokens_ The list of tokens to be remapped.\n    /// @param remappedTokens_ The list of tokens to remap to.\n    /// @dev Both arrays should have the same length. Can only be called by the contract owner.\n    function setTokenRemappings(\n        address[] calldata tokens_,\n        address[] calldata remappedTokens_\n    ) external onlyOwner {\n        if (remappedTokens_.length != tokens_.length)\n            revert Errors.INPUT_ARRAY_MISMATCH();\n        for (uint256 idx = 0; idx < tokens_.length; idx++) {\n            if (tokens_[idx] == address(0)) revert Errors.ZERO_ADDRESS();\n\n            remappedTokens[tokens_[idx]] = remappedTokens_[idx];\n            emit SetTokenRemapping(tokens_[idx], remappedTokens_[idx]);\n        }\n    }\n\n    /// @notice Fetches the USD price of the specified token from Chainlink's feed.\n    ///         If the token has been remapped, it uses the canonical form for price querying.\n    /// @param token_ Address of the token for which to fetch the price.\n    /// @return price The USD price of the token, represented with 18 decimals.\n    function getPrice(address token_) external override returns (uint256) {\n        /// remap token if possible\n        address token = remappedTokens[token_];\n        if (token == address(0)) token = token_;\n\n        uint256 maxDelayTime = timeGaps[token];\n        if (maxDelayTime == 0) revert Errors.NO_MAX_DELAY(token_);\n\n        /// Get token-USD price\n        uint256 decimals = registry.decimals(token, USD);\n        (\n            uint80 roundID,\n            int256 answer,\n            ,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        ) = registry.latestRoundData(token, USD);\n        if (updatedAt < block.timestamp - maxDelayTime)\n            revert Errors.PRICE_OUTDATED(token_);\n        if (answer <= 0) revert Errors.PRICE_NEGATIVE(token_);\n        if (answeredInRound < roundID) revert Errors.PRICE_OUTDATED(token_);\n\n        return\n            (answer.toUint256() * Constants.PRICE_PRECISION) / 10 ** decimals;\n    }\n}"
    }
  ]
}