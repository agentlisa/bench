{
  "Title": "[H-26] Accessing the incorrect offset to get the nonce when a flag is 0x06 in `RootBridgeAgent::anyExecute()` will lead to marked as executed incorrect nonces and could potentially cause a DoS",
  "Content": "\nNot reading the correct offset where the `nonce` is located can lead to the set being executed the incorrect nonce, which will cause unexpected behavior and potentially a DoS when attempting to execute a `nonce` that was incorrectly marked as already executed.\n\n### Proof of Concept\n\nThe structure of the data is encoded as detailed in the [`IRootBridgeAgent` contract](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/interfaces/IRootBridgeAgent.sol#L144):\n\n```solidity\n -        |            Flag               |        Deposit Info        |             Token Info             |   DATA   |  Gas Info   |\n -        |           1 byte              |         4-25 bytes         |     3 + (105 or 128) * n bytes     |   ---\t |  32 bytes   |\n -        |_______________________________|____________________________|____________________________________|__________|_____________|\n\n -        | callOutSignedMultiple = 0x6   |   20b + 1b(n) + 4b(nonce)  |      32b + 32b + 32b + 32b + 3b \t  |   ---\t |  16b + 16b  |\n```\n\nThe actual encoding of the data happens on the `BranchBridgeAgent` contract, [on these lines](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L288-L301).\n\nBased on the data structure, we can decode and determine which offset is located on what data:\n- `data[0]` => flag\n- `data[1:21]` => an address\n- `data[21]` => hTokens.length\n- `data[22:26]` => The 4 bytes of the nonce\n\nSo, when flag is `0x06`, the nonce is located at the offset `data[22:26]`, which indicates that the current offset that is been accessed is wrong [(`data[PARAMS_START_SIGNED:25]` === `data[21:]`)](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L1083-L1085).\n\n### Recommended Mitigation Steps\n\nMake sure to read the `nonce` from the correct offset, based on the data structure as explained in the [`IRootBridgeAgent` contract](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/interfaces/IRootBridgeAgent.sol).\n\nFor `flag 0x06`, read the offset as follows. Either of the two options are correct:\n- **`nonce` is located at: `data[22:26]`**\n\n```solidity\nnonce = uint32(bytes4(data[PARAMS_START_SIGNED + PARAMS_START : 26]));\nnonce = uint32(bytes4(data[22:26]));\n```\n\n### Assessed type\n\nen/de-code\n\n**[Trust (judge) increased severity to High](https://github.com/code-423n4/2023-05-maia-findings/issues/267#issuecomment-1631217285)**\n\n**[0xBugsy (Maia) confirmed](https://github.com/code-423n4/2023-05-maia-findings/issues/267#issuecomment-1653165461)**\n\n**[0xLightt (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/267#issuecomment-1709928867):**\n > Addressed [here](https://github.com/Maia-DAO/eco-c4-contest/commit/1a2c244e5167778ef79626a0c9238ffb19b64c5d).\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/ulysses-omnichain/interfaces/IRootBridgeAgent.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IApp} from \"./IApp.sol\";\n\n/*///////////////////////////////////////////////////////////////\n                            STRUCTS\n//////////////////////////////////////////////////////////////*/\n\nstruct SwapCallbackData {\n    address tokenIn; //Token being sold\n}\n\nstruct UserFeeInfo {\n    uint128 depositedGas; //Gas deposited by user\n    uint128 gasToBridgeOut; //Gas to be sent to bridge\n}\n\nstruct GasPoolInfo {\n    //zeroForOne when swapping gas from branch chain into root chain gas\n    bool zeroForOneOnInflow;\n    uint24 priceImpactPercentage; //Price impact percentage\n    address poolAddress; //Uniswap V3 Pool Address\n}\n\nenum SettlementStatus {\n    Success, //Settlement was successful\n    Failed //Settlement failed\n}\n\nstruct Settlement {\n    uint24 toChain; //Destination chain for interaction.\n    uint128 gasToBridgeOut; //Gas owed to user\n    address owner; //Owner of the settlement\n    address recipient; //Recipient of the settlement.\n    SettlementStatus status; //Status of the settlement\n    address[] hTokens; //Input Local hTokens Addresses.\n    address[] tokens; //Input Native / underlying Token Addresses.\n    uint256[] amounts; //Amount of Local hTokens deposited for interaction.\n    uint256[] deposits; //Amount of native tokens deposited for interaction.\n    bytes callData; //Call data for settlement\n}\n\nstruct SettlementParams {\n    uint32 settlementNonce; //Settlement nonce.\n    address recipient; //Recipient of the settlement.\n    address hToken; //Input Local hTokens Address.\n    address token; //Input Native / underlying Token Address.\n    uint256 amount; //Amount of Local hTokens deposited for interaction.\n    uint256 deposit; //Amount of native tokens deposited for interaction.\n}\n\nstruct SettlementMultipleParams {\n    uint8 numberOfAssets; //Number of assets to deposit.\n    uint32 settlementNonce; //Settlement nonce.\n    address recipient; //Recipient of the settlement.\n    address[] hTokens; //Input Local hTokens Addresses.\n    address[] tokens; //Input Native / underlying Token Addresses.\n    uint256[] amounts; //Amount of Local hTokens deposited for interaction.\n    uint256[] deposits; //Amount of native tokens deposited for interaction.\n}\n\nstruct DepositParams {\n    //Deposit Info\n    uint32 depositNonce; //Deposit nonce.\n    address hToken; //Input Local hTokens Address.\n    address token; //Input Native / underlying Token Address.\n    uint256 amount; //Amount of Local hTokens deposited for interaction.\n    uint256 deposit; //Amount of native tokens deposited for interaction.\n    uint24 toChain; //Destination chain for interaction.\n}\n\nstruct DepositMultipleParams {\n    //Deposit Info\n    uint8 numberOfAssets; //Number of assets to deposit.\n    uint32 depositNonce; //Deposit nonce.\n    address[] hTokens; //Input Local hTokens Address.\n    address[] tokens; //Input Native / underlying Token Address.\n    uint256[] amounts; //Amount of Local hTokens deposited for interaction.\n    uint256[] deposits; //Amount of native tokens deposited for interaction.\n    uint24 toChain; //Destination chain for interaction.\n}\n\n/**\n * @title  Root Bridge Agent Contract\n * @author MaiaDAO\n * @notice Contract responsible for interfacing with Users and Routers acting as a middleman to\n *         access Anycall cross-chain messaging and Port communication for asset management.\n * @dev    Bridge Agents allow for the encapsulation of business logic as well as the standardize\n *         cross-chain communication, allowing for the creation of custom Routers to perform\n *         actions as a response to remote user requests. This contract is for deployment in the Root\n *         Chain Omnichain Environment based on Arbitrum.\n *         This contract manages gas spenditure calling `_replenishingGas` after each remote initiated\n *         execution, as well as requests tokens clearances and tx execution from the `RootBridgeAgentExecutor`.\n *         Remote execution is \"sandboxed\" in 3 different nestings:\n *         - 1: Anycall Messaging Layer will revert execution if by the end of the call the\n *              balance in the executionBudget AnycallConfig contract to the Root Bridge Agent\n *              being called is inferior to the  executionGasSpent, throwing the error `no enough budget`.\n *         - 2: The `RootBridgeAgent` will trigger a revert all state changes if by the end of the remote initiated call\n *              Router interaction the userDepositedGas < executionGasSpent. This is done by calling the `_forceRevert()`\n *              internal function clearing all executionBudget from the AnycallConfig contract forcing the error `no enough budget`.\n *         - 3: The `RootBridgeAgentExecutor` is in charge of requesting token deposits for each remote interaction as well\n *              as performing the Router calls, if any of the calls initiated by the Router lead to an invlaid state change\n *              both the token deposit clearances as well as the external interactions will be reverted. Yet executionGas\n *              will still be credited by the `RootBridgeAgent`.\n *\n *          Func IDs for calling these  functions through messaging layer:\n *\n *          ROOT BRIDGE AGENT DEPOSIT FLAGS\n *          --------------------------------------\n *          ID           | DESCRIPTION\n *          -------------+------------------------\n *          0x00         | Branch Router Response.\n *          0x01         | Call to Root Router without Deposit.\n *          0x02         | Call to Root Router with Deposit.\n *          0x03         | Call to Root Router with Deposit of Multiple Tokens.\n *          0x04         | Call to Root Router without Deposit + singned message.\n *          0x05         | Call to Root Router with Deposit + singned message.\n *          0x06         | Call to Root Router with Deposit of Multiple Tokens + singned message.\n *          0x07         | Call to `retrySettlement()´. (retries sending a settlement + calldata for branch execution with new gas)\n *          0x08         | Call to `clearDeposit()´. (clears a deposit that has not been executed yet triggering `anyFallback`)\n *\n *\n *          Encoding Scheme for different Root Bridge Agent Deposit Flags:\n *\n *           - ht = hToken\n *           - t = Token\n *           - A = Amount\n *           - D = Destination\n *           - C = ChainId\n *           - b = bytes\n *           - n = number of assets\n *           ___________________________________________________________________________________________________________________________\n *          |            Flag               |        Deposit Info        |             Token Info             |   DATA   |  Gas Info   |\n *          |           1 byte              |         4-25 bytes         |     3 + (105 or 128) * n bytes     |   ---\t |  32 bytes   |\n *          |                               |                            |          hT - t - A - D - C        |          |             |\n *          |_______________________________|____________________________|____________________________________|__________|_____________|\n *          | callOutSystem = 0x0   \t    |                 4b(nonce)  |            -------------           |   ---\t |  dep + bOut |\n *          | callOut = 0x1                 |                 4b(nonce)  |            -------------           |   ---\t |  dep + bOut |\n *          | callOutSingle = 0x2           |                 4b(nonce)  |      20b + 20b + 32b + 32b + 3b    |   ---\t |  16b + 16b  |\n *          | callOutMulti = 0x3            |         1b(n) + 4b(nonce)  |   \t32b + 32b + 32b + 32b + 3b    |   ---\t |  16b + 16b  |\n *          | callOutSigned = 0x4           |    20b(recip) + 4b(nonce)  |   \t      -------------           |   ---    |  16b + 16b  |\n *          | callOutSignedSingle = 0x5     |           20b + 4b(nonce)  |      20b + 20b + 32b + 32b + 3b \t  |   ---\t |  16b + 16b  |\n *          | callOutSignedMultiple = 0x6   |   20b + 1b(n) + 4b(nonce)  |      32b + 32b + 32b + 32b + 3b \t  |   ---\t |  16b + 16b  |\n *          |_______________________________|____________________________|____________________________________|__________|_____________|\n *\n *          Contract Interaction Flows:\n *\n *          - 1) Remote to Remote:\n *                  RootBridgeAgent.anyExecute**() -> BridgeAgentExecutor.execute**() -> Router.anyExecute**() -> BridgeAgentExecutor (txExecuted) -> RootBridgeAgent (replenishedGas)\n *\n *          - 2) Remote to Arbitrum:\n *                  RootBridgeAgent.anyExecute**() -> BridgeAgentExecutor.execute**() -> Router.anyExecute**() -> BridgeAgentExecutor (txExecuted) -> RootBridgeAgent (replenishedGas)\n *\n *          - 3) Arbitrum to Arbitrum:\n *                  RootBridgeAgent.anyExecute**() -> BridgeAgentExecutor.execute**() -> Router.anyExecute**() -> BridgeAgentExecutor (txExecuted)\n *\n */\ninterface IRootBridgeAgent is IApp {\n    /*///////////////////////////////////////////////////////////////\n                            VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice External function to get the intial gas available for remote request execution.\n     *   @return uint256 Initial gas available for remote request execution.\n     */\n    function initialGas() external view returns (uint256);\n\n    /**\n     * @notice External get gas fee details for current remote request being executed.\n     *   @return uint256 Gas fee for remote request execution.\n     *   @return uint256 Gas fee for remote request execution.\n     */\n    function userFeeInfo() external view returns (uint128, uint128);\n\n    /**\n     * @notice External function to get the Bridge Agent Executor Address.\n     * @return address Bridge Agent Executor Address.\n     */\n    function bridgeAgentExecutorAddress() external view returns (address);\n\n    /**\n     * @notice External function to get the Root Bridge Agent's Factory Address.\n     *   @return address Root Bridge Agent's Factory Address.\n     */\n    function factoryAddress() external view returns (address);\n\n    /**\n     * @notice External function to get the attached Branch Bridge Agent for a given chain.\n     *   @param _chainId Chain ID of the Branch Bridge Agent.\n     *   @return address Branch Bridge Agent Address.\n     */\n    function getBranchBridgeAgent(uint256 _chainId) external view returns (address);\n\n    /**\n     * @notice External function to verify a given chain has been allowed by the Root Bridge Agent's Manager for new Branch Bridge Agent creation.\n     *   @param _chainId Chain ID of the Branch Bridge Agent.\n     *   @return bool True if the chain has been allowed for new Branch Bridge Agent creation.\n     */\n    function isBranchBridgeAgentAllowed(uint256 _chainId) external view returns (bool);\n\n    /*///////////////////////////////////////////////////////////////\n                            REMOTE CALL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice External function performs call to AnycallProxy Contract for cross-chain messaging.\n     *   @param _recipient address to receive any outstanding gas on the destination chain.\n     *   @param _calldata Calldata for function call.\n     *   @param _toChain Chain to bridge to.\n     *   @dev Internal function performs call to AnycallProxy Contract for cross-chain messaging.\n     */\n    function callOut(address _recipient, bytes memory _calldata, uint24 _toChain) external payable;\n\n    /**\n     * @notice External function to move assets from root chain to branch omnichain envirsonment.\n     *   @param _owner address allowed for redeeming assets after a failed settlement fallback. This address' Virtual Account is also allowed.\n     *   @param _recipient recipient of bridged tokens and any outstanding gas on the destination chain.\n     *   @param _data parameters for function call on branch chain.\n     *   @param _globalAddress global token to be moved.\n     *   @param _amount amount of ´token´.\n     *   @param _deposit amount of native / underlying token.\n     *   @param _toChain chain to bridge to.\n     *\n     */\n    function callOutAndBridge(\n        address _owner,\n        address _recipient,\n        bytes memory _data,\n        address _globalAddress,\n        uint256 _amount,\n        uint256 _deposit,\n        uint24 _toChain\n    ) external payable;\n\n    /**\n     * @notice External function to move assets from branch chain to root omnichain environment.\n     *   @param _owner address allowed for redeeming assets after a failed settlement fallback. This address' Virtual Account is also allowed.\n     *   @param _recipient recipient of bridged tokens.\n     *   @param _data parameters for function call on branch chain.\n     *   @param _globalAddresses global tokens to be moved.\n     *   @param _amounts amounts of token.\n     *   @param _deposits amounts of underlying / token.\n     *   @param _toChain chain to bridge to.\n     *\n     *\n     */\n    function callOutAndBridgeMultiple(\n        address _owner,\n        address _recipient,\n        bytes memory _data,\n        address[] memory _globalAddresses,\n        uint256[] memory _amounts,\n        uint256[] memory _deposits,\n        uint24 _toChain\n    ) external payable;\n\n    /*///////////////////////////////////////////////////////////////\n                        TOKEN MANAGEMENT FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function to move assets from branch chain to root omnichain environment. Called in response to Bridge Agent Executor.\n     *   @param _dParams Cross-Chain Deposit of Multiple Tokens Params.\n     *   @param _fromChain chain to bridge from.\n     *\n     */\n    function bridgeIn(address _recipient, DepositParams memory _dParams, uint24 _fromChain) external;\n\n    /**\n     * @notice Function to move assets from branch chain to root omnichain environment. Called in response to Bridge Agent Executor.\n     *   @param _dParams Cross-Chain Deposit of Multiple Tokens Params.\n     *   @param _fromChain chain to bridge from.\n     *   @dev Since the input data is encodePacked we need to parse it:\n     *     1. First byte is the number of assets to be bridged in. Equals length of all arrays.\n     *     2. Next 4 bytes are the nonce of the deposit.\n     *     3. Last 32 bytes after the token related information are the chain to bridge to.\n     *     4. Token related information starts at index PARAMS_TKN_START is encoded as follows:\n     *         1. N * 32 bytes for the hToken address.\n     *         2. N * 32 bytes for the underlying token address.\n     *         3. N * 32 bytes for the amount of hTokens to be bridged in.\n     *         4. N * 32 bytes for the amount of underlying tokens to be bridged in.\n     *     5. Each of the 4 token related arrays are of length N and start at the following indexes:\n     *         1. PARAMS_TKN_START [hToken address has no offset from token information start].\n     *         2. PARAMS_TKN_START + (PARAMS_ADDRESS_SIZE * N)\n     *         3. PARAMS_TKN_START + (PARAMS_AMT_OFFSET * N)\n     *         4. PARAMS_TKN_START + (PARAMS_DEPOSIT_OFFSET * N)\n     *\n     */\n    function bridgeInMultiple(address _recipient, DepositMultipleParams memory _dParams, uint24 _fromChain) external;\n\n    /*///////////////////////////////////////////////////////////////\n                        SETTLEMENT FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function that returns the current settlement nonce.\n     *   @return nonce bridge agent's current settlement nonce\n     *\n     */\n    function settlementNonce() external view returns (uint32 nonce);\n\n    /**\n     * @notice Function that allows redemption of failed Settlement's global tokens.\n     *   @param _depositNonce Identifier for token deposit.\n     *\n     */\n    function redeemSettlement(uint32 _depositNonce) external;\n\n    /**\n     * @notice Function to retry a user's Settlement balance.\n     *   @param _settlementNonce Identifier for token settlement.\n     *   @param _remoteExecutionGas Identifier for token settlement.\n     *\n     */\n    function retrySettlement(uint32 _settlementNonce, uint128 _remoteExecutionGas) external payable;\n\n    /**\n     * @notice External function that returns a given settlement entry.\n     *   @param _settlementNonce Identifier for token settlement.\n     *\n     */\n    function getSettlementEntry(uint32 _settlementNonce) external view returns (Settlement memory);\n\n    /**\n     * @notice Updates the address of the branch bridge agent\n     *   @param _newBranchBridgeAgent address of the new branch bridge agent\n     *   @param _branchChainId chainId of the branch chain\n     */\n    function syncBranchBridgeAgent(address _newBranchBridgeAgent, uint24 _branchChainId) external;\n\n    /*///////////////////////////////////////////////////////////////\n                            GAS SWAP FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Checks if a pool is eligible to call uniswapV3SwapCallback\n     *   @param amount0 amount of token0 to swap\n     *   @param amount1 amount of token1 to swap\n     *   @param _data abi encoded data\n     */\n    function uniswapV3SwapCallback(int256 amount0, int256 amount1, bytes calldata _data) external;\n\n    /*///////////////////////////////////////////////////////////////\n                            ANYCALL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function to force revert when a remote action does not have enough gas or is being retried after having been previously executed.\n     */\n    function forceRevert() external;\n\n    /**\n     * @notice Function to deposit gas for use by the Branch Bridge Agent.\n     */\n    function depositGasAnycallConfig() external payable;\n\n    /**\n     * @notice Function to collect excess gas fees.\n     *   @dev only callable by the DAO.\n     */\n    function sweep() external;\n\n    /*///////////////////////////////////////////////////////////////\n                            ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Adds a new branch bridge agent to a given branch chainId\n     *   @param _branchChainId chainId of the branch chain\n     */\n    function approveBranchBridgeAgent(uint256 _branchChainId) external;\n\n    /*///////////////////////////////////////////////////////////////\n                             EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event LogCallin(bytes1 selector, bytes data, uint24 fromChainId);\n    event LogCallout(bytes1 selector, bytes data, uint256, uint24 toChainId);\n    event LogCalloutFail(bytes1 selector, bytes data, uint24 toChainId);\n\n    /*///////////////////////////////////////////////////////////////\n                            ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error GasErrorOrRepeatedTx();\n\n    error NotDao();\n    error AnycallUnauthorizedCaller();\n\n    error AlreadyAddedBridgeAgent();\n    error UnrecognizedExecutor();\n    error UnrecognizedPort();\n    error UnrecognizedBridgeAgent();\n    error UnrecognizedBridgeAgentManager();\n    error UnrecognizedCallerNotRouter();\n\n    error UnrecognizedUnderlyingAddress();\n    error UnrecognizedLocalAddress();\n    error UnrecognizedGlobalAddress();\n    error UnrecognizedAddressInDestination();\n\n    error SettlementRedeemUnavailable();\n    error NotSettlementOwner();\n\n    error InsufficientBalanceForSettlement();\n    error InsufficientGasForFees();\n    error InvalidInputParams();\n    error InvalidGasPool();\n\n    error CallerIsNotPool();\n    error AmountsAreZero();\n}"
    },
    {
      "filename": "src/ulysses-omnichain/BranchBridgeAgent.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {WETH9} from \"./interfaces/IWETH9.sol\";\n\nimport {AnycallFlags} from \"./lib/AnycallFlags.sol\";\nimport {IAnycallProxy} from \"./interfaces/IAnycallProxy.sol\";\nimport {IAnycallConfig} from \"./interfaces/IAnycallConfig.sol\";\nimport {IAnycallExecutor} from \"./interfaces/IAnycallExecutor.sol\";\nimport {IApp, IBranchBridgeAgent} from \"./interfaces/IBranchBridgeAgent.sol\";\nimport {IBranchRouter as IRouter} from \"./interfaces/IBranchRouter.sol\";\nimport {IBranchPort as IPort} from \"./interfaces/IBranchPort.sol\";\n\nimport {ERC20hTokenBranch as ERC20hToken} from \"./token/ERC20hTokenBranch.sol\";\nimport {BranchBridgeAgentExecutor, DeployBranchBridgeAgentExecutor} from \"./BranchBridgeAgentExecutor.sol\";\nimport {\n    Deposit,\n    DepositStatus,\n    DepositInput,\n    DepositMultipleInput,\n    DepositParams,\n    DepositMultipleParams,\n    SettlementParams,\n    SettlementMultipleParams\n} from \"./interfaces/IBranchBridgeAgent.sol\";\n\n/// @title Library for Branch Bridge Agent Deployment\nlibrary DeployBranchBridgeAgent {\n    function deploy(\n        WETH9 _wrappedNativeToken,\n        uint256 _rootChainId,\n        uint256 _localChainId,\n        address _rootBridgeAgentAddress,\n        address _localAnyCallAddress,\n        address _localAnyCallExecutorAddress,\n        address _localRouterAddress,\n        address _localPortAddress\n    ) external returns (BranchBridgeAgent) {\n        return new BranchBridgeAgent(\n            _wrappedNativeToken,\n            _rootChainId,\n            _localChainId,\n            _rootBridgeAgentAddress,\n            _localAnyCallAddress,\n            _localAnyCallExecutorAddress,\n            _localRouterAddress,\n            _localPortAddress\n        );\n    }\n}\n\n/// @title Branch Bridge Agent Contract\ncontract BranchBridgeAgent is IBranchBridgeAgent {\n    using SafeTransferLib for address;\n    using SafeCastLib for uint256;\n\n    /*///////////////////////////////////////////////////////////////\n                            ENCODING CONSTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// AnyExec Decode Consts\n\n    uint8 internal constant PARAMS_START = 1;\n\n    uint8 internal constant PARAMS_START_SIGNED = 21;\n\n    uint8 internal constant PARAMS_ENTRY_SIZE = 32;\n\n    uint8 internal constant PARAMS_GAS_OUT = 16;\n\n    /// ClearTokens Decode Consts\n\n    uint8 internal constant PARAMS_TKN_START = 5;\n\n    uint8 internal constant PARAMS_AMT_OFFSET = 64;\n\n    uint8 internal constant PARAMS_DEPOSIT_OFFSET = 96;\n\n    /*///////////////////////////////////////////////////////////////\n                        BRIDGE AGENT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Chain Id for Root Chain where liqudity is virtualized(e.g. 4).\n    uint256 public immutable rootChainId;\n\n    /// @notice Chain Id for Local Chain.\n    uint256 public immutable localChainId;\n\n    /// @notice Address for Local Wrapped Native Token.\n    WETH9 public immutable wrappedNativeToken;\n\n    /// @notice Address for Bridge Agent who processes requests submitted for the Root Router Address where cross-chain requests are executed in the Root Chain.\n    address public immutable rootBridgeAgentAddress;\n\n    /// @notice Address for Local AnycallV7 Proxy Address where cross-chain requests are sent to the Root Chain Router.\n    address public immutable localAnyCallAddress;\n\n    /// @notice Address for Local Anyexec Address where cross-chain requests from the Root Chain Router are received locally.\n    address public immutable localAnyCallExecutorAddress;\n\n    /// @notice Address for Local Router used for custom actions for different hApps.\n    address public immutable localRouterAddress;\n\n    /// @notice Address for Local Port Address where funds deposited from this chain are kept, managed and supplied to different Port Strategies.\n    address public immutable localPortAddress;\n\n    address public bridgeAgentExecutorAddress;\n\n    /*///////////////////////////////////////////////////////////////\n                        DEPOSITS STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Deposit nonce used for identifying transaction.\n    uint32 public depositNonce;\n\n    /// @notice Mapping from Pending deposits hash to Deposit Struct.\n    mapping(uint32 => Deposit) public getDeposit;\n\n    /*///////////////////////////////////////////////////////////////\n                            EXECUTOR STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice If true, bridge agent has already served a request with this nonce from  a given chain. Chain -> Nonce -> Bool\n    mapping(uint32 => bool) public executionHistory;\n\n    /*///////////////////////////////////////////////////////////////\n                        GAS MANAGEMENT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public remoteCallDepositedGas;\n\n    uint256 internal constant MIN_FALLBACK_RESERVE = 185_000; // 100_000 for anycall + 85_000 fallback execution overhead\n    uint256 internal constant MIN_EXECUTION_OVERHEAD = 160_000; // 100_000 for anycall + 35_000 Pre 1st Gas Checkpoint Execution + 25_000 Post last Gas Checkpoint Executions\n    uint256 internal constant TRANSFER_OVERHEAD = 24_000;\n\n    constructor(\n        WETH9 _wrappedNativeToken,\n        uint256 _rootChainId,\n        uint256 _localChainId,\n        address _rootBridgeAgentAddress,\n        address _localAnyCallAddress,\n        address _localAnyCallExecutorAddress,\n        address _localRouterAddress,\n        address _localPortAddress\n    ) {\n        require(_rootBridgeAgentAddress != address(0), \"Root Bridge Agent Address cannot be the zero address.\");\n        require(_localAnyCallAddress != address(0), \"AnyCall Address cannot be the zero address.\");\n        require(_localAnyCallExecutorAddress != address(0), \"AnyCall Executor Address cannot be the zero address.\");\n        require(_localRouterAddress != address(0), \"Local Router Address cannot be the zero address.\");\n        require(_localPortAddress != address(0), \"Local Port Address cannot be the zero address.\");\n\n        wrappedNativeToken = _wrappedNativeToken;\n        localChainId = _localChainId;\n        rootChainId = _rootChainId;\n        rootBridgeAgentAddress = _rootBridgeAgentAddress;\n        localAnyCallAddress = _localAnyCallAddress;\n        localAnyCallExecutorAddress = _localAnyCallExecutorAddress;\n        localRouterAddress = _localRouterAddress;\n        localPortAddress = _localPortAddress;\n        bridgeAgentExecutorAddress = DeployBranchBridgeAgentExecutor.deploy();\n        depositNonce = 1;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchBridgeAgent\n    function getDepositEntry(uint32 _depositNonce) external view returns (Deposit memory) {\n        return getDeposit[_depositNonce];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        USER EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOut(bytes calldata _params, uint128 _remoteExecutionGas) external payable lock requiresFallbackGas {\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Perform Call without deposit\n        _callOut(msg.sender, _params, msg.value.toUint128(), _remoteExecutionGas);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutAndBridge(bytes calldata _params, DepositInput memory _dParams, uint128 _remoteExecutionGas)\n        external\n        payable\n        lock\n        requiresFallbackGas\n    {\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Perform Call with deposit\n        _callOutAndBridge(msg.sender, _params, _dParams, msg.value.toUint128(), _remoteExecutionGas);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutAndBridgeMultiple(\n        bytes calldata _params,\n        DepositMultipleInput memory _dParams,\n        uint128 _remoteExecutionGas\n    ) external payable lock requiresFallbackGas {\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Perform Call with multiple deposits\n        _callOutAndBridgeMultiple(msg.sender, _params, _dParams, msg.value.toUint128(), _remoteExecutionGas);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutSigned(bytes calldata _params, uint128 _remoteExecutionGas)\n        external\n        payable\n        lock\n        requiresFallbackGas\n    {\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(\n            bytes1(0x04), msg.sender, depositNonce, _params, msg.value.toUint128(), _remoteExecutionGas\n        );\n\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Perform Signed Call without deposit\n        _noDepositCall(msg.sender, packedData, msg.value.toUint128());\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutSignedAndBridge(bytes calldata _params, DepositInput memory _dParams, uint128 _remoteExecutionGas)\n        external\n        payable\n        lock\n        requiresFallbackGas\n    {\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(\n            bytes1(0x05),\n            msg.sender,\n            depositNonce,\n            _dParams.hToken,\n            _dParams.token,\n            _dParams.amount,\n            _normalizeDecimals(_dParams.deposit, ERC20(_dParams.token).decimals()),\n            _dParams.toChain,\n            _params,\n            msg.value.toUint128(),\n            _remoteExecutionGas\n        );\n\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Create Deposit and Send Cross-Chain request\n        _depositAndCall(\n            msg.sender,\n            packedData,\n            _dParams.hToken,\n            _dParams.token,\n            _dParams.amount,\n            _dParams.deposit,\n            msg.value.toUint128()\n        );\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutSignedAndBridgeMultiple(\n        bytes calldata _params,\n        DepositMultipleInput memory _dParams,\n        uint128 _remoteExecutionGas\n    ) external payable lock requiresFallbackGas {\n        //Normalize Deposits\n        uint256[] memory _deposits = new uint256[](_dParams.hTokens.length);\n\n        for (uint256 i = 0; i < _dParams.hTokens.length; i++) {\n            _deposits[i] = _normalizeDecimals(_dParams.deposits[i], ERC20(_dParams.tokens[i]).decimals());\n        }\n\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(\n            bytes1(0x06),\n            msg.sender,\n            uint8(_dParams.hTokens.length),\n            depositNonce,\n            _dParams.hTokens,\n            _dParams.tokens,\n            _dParams.amounts,\n            _deposits,\n            _dParams.toChain,\n            _params,\n            msg.value.toUint128(),\n            _remoteExecutionGas\n        );\n\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Create Deposit and Send Cross-Chain request\n        _depositAndCallMultiple(\n            msg.sender,\n            packedData,\n            _dParams.hTokens,\n            _dParams.tokens,\n            _dParams.amounts,\n            _dParams.deposits,\n            msg.value.toUint128()\n        );\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function retryDeposit(\n        bool _isSigned,\n        uint32 _depositNonce,\n        bytes calldata _params,\n        uint128 _remoteExecutionGas,\n        uint24 _toChain\n    ) external payable lock requiresFallbackGas {\n        //Check if deposit belongs to message sender\n        if (getDeposit[_depositNonce].owner != msg.sender) revert NotDepositOwner();\n\n        //Encode Data for cross-chain call.\n        bytes memory packedData;\n\n        if (uint8(getDeposit[_depositNonce].hTokens.length) == 1) {\n            if (_isSigned) {\n                packedData = abi.encodePacked(\n                    bytes1(0x05),\n                    msg.sender,\n                    _depositNonce,\n                    getDeposit[_depositNonce].hTokens[0],\n                    getDeposit[_depositNonce].tokens[0],"
    }
  ]
}