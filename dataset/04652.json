{
  "Title": "Use latest version ofÂ Solidity",
  "Content": "[Current code](https://github.com/iExecBlockchainComputing/rlc-token/blob/3d9aa99ba33bb035c59740a621b1f21cd45cbac5/contracts/RLC.sol#L1) is written for an old version of solc (0.4.8). We recommend changing the solidity version pragma for the latest version (`pragma solidity ^0.4.10;`) to enforce latest compiler version to be used.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/RLC.sol",
      "content": "pragma solidity ^0.4.8;\n\nimport \"./Ownable.sol\";\nimport \"./SafeMath.sol\";\nimport \"./ERC20.sol\";\nimport \"./TokenSpender.sol\";\n\ncontract RLC is ERC20, SafeMath, Ownable {\n\n    /* Public variables of the token */\n  string public name;       //fancy name\n  string public symbol;\n  uint8 public decimals;    //How many decimals to show.\n  string public version = 'v0.1'; \n  uint256 public initialSupply;\n  address public burnAddress;\n  uint256 public totalSupply;\n  bool public locked;\n  uint public unlockBlock;\n\n  mapping(address => uint) balances;\n  mapping (address => mapping (address => uint)) allowed;\n\n  // lock transfer during the ICO\n  modifier onlyUnlocked() {\n    if (msg.sender != owner && locked) throw;\n    _;\n  }\n\n  /*\n   *  The RLC Token created with the time at which the crowdsale end\n   */\n\n  function RLC() {\n    // lock the transfer function during the crowdsale\n    locked = true;\n    unlockBlock=  now + 45 days; // (testnet) - for mainnet put the block number\n\n    initialSupply = 87000000000000000;\n    totalSupply = initialSupply;\n    balances[msg.sender] = initialSupply;// Give the creator all initial tokens                    \n    name = 'iEx.ec Network Token';        // Set the name for display purposes     \n    symbol = 'RLC';                       // Set the symbol for display purposes  \n    decimals = 9;                        // Amount of decimals for display purposes\n    burnAddress = 0x1b32000000000000000000000000000000000000;\n  }\n\n  function unlock() {\n    if (now < unlockBlock) throw;\n    if (!locked) throw;   // to allow only 1 call\n    locked = false;\n  }\n\n  function burn(uint256 _value) returns (bool success){\n    balances[msg.sender] = safeSub(balances[msg.sender], _value) ;\n    balances[burnAddress] = safeAdd(balances[burnAddress], _value);\n    totalSupply = safeSub(totalSupply, _value);\n    Transfer(msg.sender, burnAddress, _value);\n    return true;\n  }\n\n  function transfer(address _to, uint _value) onlyUnlocked returns (bool success) {\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\n    balances[_to] = safeAdd(balances[_to], _value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  function transferFrom(address _from, address _to, uint _value) onlyUnlocked returns (bool success) {\n    var _allowance = allowed[_from][msg.sender];\n    \n    balances[_to] = safeAdd(balances[_to], _value);\n    balances[_from] = safeSub(balances[_from], _value);\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  function balanceOf(address _owner) constant returns (uint balance) {\n    return balances[_owner];\n  }\n\n  function approve(address _spender, uint _value) returns (bool success) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n    /* Approve and then comunicate the approved contract in a single tx */\n  function approveAndCall(address _spender, uint256 _value, bytes _extraData, bytes _extraData2){    \n      TokenSpender spender = TokenSpender(_spender);\n      if (approve(_spender, _value)) {\n          spender.receiveApproval(msg.sender, _value, this, _extraData, _extraData2);\n      }\n  }\n\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n    return allowed[_owner][_spender];\n  }\n  \n    /* This unnamed function is called whenever someone tries to send ether to it */\n    function () {\n        throw;     // Prevents accidental sending of ether\n    }\n}"
    }
  ]
}