{
  "Title": "M-2: Fault game factory can be manipulated to DOS game type using malicious `l2BlockNumber`",
  "Content": "# Issue M-2: Fault game factory can be manipulated to DOS game type using malicious `l2BlockNumber` \n\nSource: https://github.com/sherlock-audit/2024-02-optimism-2024-judging/issues/90 \n\nThe protocol has acknowledged this issue.\n\n## Found by \n0xdeadbeef, GalloDaSballo, Trust, bin2chen, ctf\\_sec, fibonacci, haxatron, nirohgo, obront, tallo, zigtur\n## Summary\n\nAll new games are proven against the most recent L2 block number in the `ANCHOR_STATE_REGISTRY`. This includes requiring that the block number we are intending to prove is greater than the latest proven block number in the registry. Due to insufficient validations of the passed L2 block number, it is possible for a user to set the latest block to `type(uint256).max`, blocking all possible future games from being initialized.\n\n## Vulnerability Detail\n\nNew games are created for a given root claim and L2 block number using the factory, by cloning the implementation of the specified game type and passing these values as immutable args (where `_extraData` is the L2 block number).\n```solidity\nproxy_ = IDisputeGame(address(impl).clone(abi.encodePacked(_rootClaim, parentHash, _extraData)));\nproxy_.initialize{ value: msg.value }();\n```\nAs a part of the initialize function, we pull the latest confirmed `root` and `rootBlockNumber` from the `ANCHOR_STATE_REGISTRY`. These will be used as the \"starting points\" for our proof. In order to confirm they are valid starting points, we require that the L2 block number we passed is greater than the last proven root block number.\n```solidity\n(Hash root, uint256 rootBlockNumber) = ANCHOR_STATE_REGISTRY.anchors(GAME_TYPE);\n\n// Should only happen if this is a new game type that hasn't been set up yet.\nif (root.raw() == bytes32(0)) revert AnchorRootNotFound();\n\n// Set the starting output root.\nstartingOutputRoot = OutputRoot({ l2BlockNumber: rootBlockNumber, root: root });\n\n// Do not allow the game to be initialized if the root claim corresponds to a block at or before the\n// configured starting block number.\nif (l2BlockNumber() <= rootBlockNumber) revert UnexpectedRootClaim(rootClaim());\n```\nHowever, the L2 block number we pass does not appear to be sufficiently validated. If we look at the Fault Dispute Game, we can see that disputed L2 block number passed to the oracle is calculated using the `_execLeafIdx` and does not make any reference to the L2 block number passed via `extraData`:\n```solidity\nuint256 l2Number = startingOutputRoot.l2BlockNumber + disputedPos.traceIndex(SPLIT_DEPTH) + 1;\n\noracle.loadLocalData(_ident, uuid.raw(), bytes32(l2Number << 0xC0), 8, _partOffset);\n```\nThis allows us to pass an L2 block number that is disconnected from the proof being provided.\n\nAfter the claim is resolved, we update the `ANCHOR_STATE_REGISTRY` to include our new root by calling `tryUpdateAnchorState()`.\n```solidity\nfunction tryUpdateAnchorState() external {\n    // Grab the game and game data.\n    IFaultDisputeGame game = IFaultDisputeGame(msg.sender);\n    (GameType gameType, Claim rootClaim, bytes memory extraData) = game.gameData();\n\n    // Grab the verified address of the game based on the game data.\n    // slither-disable-next-line unused-return\n    (IDisputeGame factoryRegisteredGame,) =\n        DISPUTE_GAME_FACTORY.games({ _gameType: gameType, _rootClaim: rootClaim, _extraData: extraData });\n\n    // Must be a valid game.\n    require(\n        address(factoryRegisteredGame) == address(game),\n        \"AnchorStateRegistry: fault dispute game not registered with factory\"\n    );\n\n    // No need to update anything if the anchor state is already newer.\n    if (game.l2BlockNumber() <= anchors[gameType].l2BlockNumber) {\n        return;\n    }\n\n    // Must be a game that resolved in favor of the state.\n    if (game.status() != GameStatus.DEFENDER_WINS) {\n        return;\n    }\n\n    // Actually update the anchor state.\n    anchors[gameType] = OutputRoot({ l2BlockNumber: game.l2BlockNumber(), root: Hash.wrap(game.rootClaim().raw()) });\n}\n```\nAs long as the L2 block number we passed is greater than the last proven one, we update it with our new root. This allows us to set the `ANCHOR_STATE_REGISTRY` to contain an arbitrarily high `blockRootNumber`.\n\nIf we were to pass `type(uint256).max` as this value, it would be set in the `anchors` mapping, and would cause all other games to fail to initialize, because there is no value they could pass for the L2 block number that would be greater, and would therefore fail the check described above.\n\n## Proof of Concept\n\nThe following test can be dropped into `DisputeGameFactory.t.sol` to demonstrate the vulnerability:\n```solidity\nfunction testZach_DOSWithMaxBlockNumber(uint256 newBlockNum) public {\n    // propose a root with a block number of max uint256\n    bytes memory maxBlock = abi.encode(type(uint256).max);\n    IDisputeGame game = disputeGameFactory.create(GameType.wrap(0), Claim.wrap(bytes32(uint(1))), maxBlock);\n    assertEq(game.l2BlockNumber(), type(uint256).max);\n\n    // when the game passes, it's saved in the anchor registry\n    vm.warp(block.timestamp + 4 days);\n    game.resolveClaim(0);\n    game.resolve();\n\n    // now we can fuzz newly proposed block numbers, and all fail for the same reason\n    bytes memory maxBlock2 = abi.encode(newBlockNum);\n    vm.expectRevert(abi.encodeWithSelector(UnexpectedRootClaim.selector, 1));\n    disputeGameFactory.create(GameType.wrap(0), Claim.wrap(bytes32(uint(1))), maxBlock2);\n}\n```\n\n## Impact\n\nFor no cost, the factory can be DOS'd from creating new games of a given type.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-02-optimism-2024/blob/main/optimism/packages/contracts-bedrock/src/dispute/FaultDisputeGame.sol#L528-L539\n\nhttps://github.com/sherlock-audit/2024-02-optimism-2024/blob/main/optimism/packages/contracts-bedrock/src/dispute/AnchorStateRegistry.sol#L59-L87\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIn order to ensure that ordering does not need to be preserved, `ANCHOR_STATE_REGISTRY` should store a mapping of claims to booleans. This would allow users to prove against any proven state, instead of being restricted to proving against the latest state, which could be manipulated.\n\n\n\n## Discussion\n\n**smartcontracts**\n\nFactually valid although the impact here isn't different than having any game resolve incorrectly which would poison the `AnchorStateRegistry` and require the game type to be changed.\n\n**nevillehuang**\n\nBased on scoping details below, I believe this issue is valid and in-scope of the contest, as the root cause stems from the lack of a sanity check within the dispute game factory allowing large `l2BlockNumber` to be appended\n\nhttps://docs.google.com/document/d/1xjvPwAzD2Zxtx8-P6UE69TuoBwtZPbpwf5zBHAvBJBw/edit\n\nThe potential to block the entire fault proofs system entirely by preventing further creation of new games is significant, so I believe it warrants high severity given the potential to block withdrawals from an OP bridge. Although the admin can temporarily resolve this by switching game type, I believe it is not a valid solution given the attack can be easily repeated.\n\n**0xjuaan**\n\n just a thought @nevillehuang:\n> I believe it is not a valid solution given the attack can be easily repeated\n\nIs this actually true? If they change the game type, the new FaultDisputeGame implementation will be fixed and won't have this vulnerability so the attack can't be repeated. Because of that, the sponsor's comment seems to make the most sense and calling this a high severity issue is quite sus. \n\n\n**Evert0x**\n\nForwarding a comment from the protocol team\n\n--\n\nThis issue isn't valid because the decoupling of the L2 block number that's determined during output bisection and the one on the root claim is intentional.\nThey claim that you can propose an output belonging to block n (so, right hash), but for the wrong block number in the future (i.e. n + 1).\nThe challenger would be able to challenge this, as they would see that the output at the claimed block is wrong (or that the block just doesn't exist)\nThe program, once ran, can either show:\n- The output at the given block number isn't correct (i.e. the proposed block number is part of the safe chain captured by the data available on L1 at the L1 head hash persisted when the game starts)\n- The given block number cannot be derived with the data available on L1 (i.e. the block number is super far in the future, and doesn't even exist)\n\nEssentially a proposal of this form would be invalidated by the current fault proof system so the bug itself wouldn't be possible\n\n\n**Haxatron**\n\nThis bug operates under assumption that the FP system can cause a invalid game to be resolved as valid, and there were multiple ways to do this in the contest (see #8). If this can occur then no more dispute games can be created for the same game type which will lead to DoS. Only possible solution is to update game type as pointed out by comments above.\n\n**JeffCX**\n\nIn this case, one single invalid game resolution with very large block number DOS the whole game type, \n\nupdate game type does not seems to be a long term solution, there are not many game type to update.\n\nThe fix is still add proper validation for block number or the fix in this report can be used as well\n\n> In order to ensure that ordering does not need to be preserved, ANCHOR_STATE_REGISTRY should store a mapping of claims to booleans. This would allow users to prove against any proven state, instead of being restricted to proving against the latest state, which could be manipulated.\n\n**lemonmon1984**\n\n> For no cost, the factory can be DOS'd from creating new games of a given type.\n\nI want to note that the attacker is risking the bonds. They will likely to lose it if any honest party challenges them.\n\n**JeffCX**\n\nWhether the attacker get challenged or not is not in-scope,\n\nthe audit and report is under the assumption that the game can be resolved incorrectly\n\n> FaultDisputeGame resolution logic is not included in the scope of this contest. Participants should assume that the FaultDisputeGame can resolve incorrectly (i.e.g, can resolve to DEFENDER_WINS when it should resolve to CHALLENGER_WINS or vice versa).\n\nand in case the game resolved incorrectly, massive DOS for game type occurs as outlined in the report.\n\n**zobront**\n\nTo share my perspective here:\n\n**TLDR:** This is a difficult case, because the issue should be in scope, but the outcome that it causes is no worse than the manual fixes that would happen when the safeguards work properly.\n\n**Severity:** As much as I'd like to, I can't see a justification for High. The outcome does not seem bad enough.\n\n**Scope:** This does seem to meet the definitions laid out in the scope document. The issue is in the in scope contracts, and the outcome (DOS of game type) should be sufficient for a Medium. However, it is a weird dynamic because when safeguards are used, it also causes a DOS of game type, so it seems strange that the same outcome could be a valid issue.\n\n**Conclusion:** My assessment is that this should remain as a valid Medium, because the contest rules didn't rule out all game type DOS, only those caused by game contract logic. That being said, I recognize this is difficult to judge and respect whatever decision the judge makes.\n\n**JeffCX**\n\nas the original well-written report highlights\n\n> As long as the L2 block number we passed is greater than the last proven one, we update it with our new root. This allows us to set the ANCHOR_STATE_REGISTRY to contain an arbitrarily high blockRootNumber.\n\n> If we were to pass type(uint256).max as this value, it would be set in the anchors mapping, and would cause all other games to fail to initialize, because there is no value they could pass for the L2 block number that would be greater, and would therefore fail the check described above.\n\nthe impact of DOS game creation and game type means no user can finalize their withdraw transaction / execution l2 -> l1 message, which is a leads to clearly loss of fund and lock of fund as multiple duplicates highlight such as #206 \n\n**nevillehuang**\n\nThis issue seems invalid per sponsor comments [here](https://github.com/sherlock-audit/2024-02-optimism-2024-judging/issues/90#issuecomment-2076645104).\n\nAny reasons addressing sponsor comments why this should be a valid issue?\n\n@zobront @JeffCX @Haxatron \n\n\n\n**Haxatron**\n\nHi,\n\nAlready given my reasoning above.\n\nI will defer to @zobront and @JeffCX for any additional comments\n\nAcknowledge this one is quite tricky to judge.\n\n**zobront**\n\nI explained my assessment based on that sponsor comment here:\nhttps://github.com/sherlock-audit/2024-02-optimism-2024-judging/issues/90#issuecomment-2090639437\n\nOn Fri, May 3, 2024 at 4:02 PM Haxatron ***@***.***> wrote:\n\n> Hi,\n>\n> Already given my reasoning above.\n>\n> I will defer to @zobront <https://github.com/zobront> and @JeffCX\n> <https://github.com/JeffCX> for any additional comments\n>\n> Acknowledge this one is quite tricky to judge.\n>\n> —\n> Reply to this email directly, view it on GitHub\n> <https://github.com/sherlock-audit/2024-02-optimism-2024-judging/issues/90#issuecomment-2093758255>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/ABL3ULAOEIBLV2L6ENQ5SL3ZAP3OPAVCNFSM6AAAAABFXP5JESVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDAOJTG42TQMRVGU>\n> .\n> You are receiving this because you were mentioned.Message ID:\n> ***@***.***\n> com>\n>\n\n\n**JeffCX**\n\n> Forwarding a comment from the protocol team\n> \n> --\n> \n> This issue isn't valid because the decoupling of the L2 block number that's determined during output bisection and the one on the root claim is intentional. They claim that you can propose an output belonging to block n (so, right hash), but for the wrong block number in the future (i.e. n + 1). The challenger would be able to challenge this, as they would see that the output at the claimed block is wrong (or that the block just doesn't exist) The program, once ran, can either show:\n> \n> * The output at the given block number isn't correct (i.e. the proposed block number is part of the safe chain captured by the data available on L1 at the L1 head hash persisted when the game starts)\n> * The given block number cannot be derived with the data available on L1 (i.e. the block number is super far in the future, and doesn't even exist)\n> \n> Essentially a proposal of this form would be invalidated by the current fault proof system so the bug itself wouldn't be possible\n\nEmm seems like this is saying that the game cannot be resolved incorrectly....\n\nbut during judging, we mark the game resolution logic out of scope and use the argument to invalid many issue\n\nIt is contradictory to use the argument \"incorrect game resolution out of scope\" to invalid many other issue.\n\nwhile use the argument \"game cannot be resolved incorrectly\" to invalid this issue.\n\nthe comments strongly contradicts the readme as well:\n\nfrom read me\n\n> Participants should assume that the FaultDisputeGame can resolve incorrectly (i.e.g, can resolve to DEFENDER_WINS when it should resolve to CHALLENGER_WINS or vice versa).\n\nthe report is perfect derivation from the statement above without worrying about the game dispute logic...\n\n> Participants should assume that the FaultDisputeGame can resolve incorrectly (i.e.g, can resolve to DEFENDER_WINS when it should resolve to CHALLENGER_WINS or vice versa).\n\nthen I think the original judging decision still stands.\n\n**guhu95**\n\nI actually don't understand why the [sponsor's claim](https://github.com/sherlock-audit/2024-02-optimism-2024-judging/issues/90#issuecomment-2076645104) is correct. If it does make sense to anyone else, can someone please explain?\n\nWhat I understand they're saying is that the game can't resolve correctly in this way. But I don't understand how that is possible if the `extraData`'s `l2Blocknumber` is never actually used by the proof system? The only user of that value is `AnchorStateRegistry` and it doesn't validate it.\n\nThere is no check I can see that checks that `extraData`'s `l2Blocknumber` is actually in the `rootClaim` in any way. \n\nFrom the point of view of the proof system, the block number it is using is unrelated to the one later being passed to `AnchorStateRegistry`.\n\nIf so, isn't it the case that anyone can always frontrun the legitimate proposals and use the legitimate data, but pass in `type(uint).max` as l2BlockNumber? Isn't that a perpetual DoS of the system?\n\nWhat am I missing here?\n\n**Haxatron**\n\nIf I am not wrong, it will be used in VM.step() after adding the block\nnumber into the preimage oracle via addLocalData()\n\nOn Sun, 5 May 2024, 10:04 Guhu, ***@***.***> wrote:\n\n> I actually don't understand why the sponsor's claim\n> <https://github.com/sherlock-audit/2024-02-optimism-2024-judging/issues/90#issuecomment-2076645104>\n> is correct. If it does make sense to anyone else, can someone please\n> explain?\n>\n> What I understand they're saying is that the game can't resolve correctly\n> in this way. But I don't understand how that is possible if the extraData's\n> l2Blocknumber is never actually used by the proof system? The only user\n> of that value is AnchorStateRegistry and it doesn't validate it.\n>\n> There is no check I can see that checks that extraData's l2Blocknumber is\n> actually in the rootClaim in any way.\n>\n> From the point of view of the proof system, the block number it is using\n> is unrelated to the one later being passed to AnchorStateRegistry.\n>\n> If so, isn't it the case that anyone can always frontrun the legitimate\n> proposals and use the legitimate data, but pass in type(uint).max as\n> l2BlockNumber? Isn't that a perpetual DoS of the system?\n>\n> What am I missing here?\n>\n> —\n> Reply to this email directly, view it on GitHub\n> <https://github.com/sherlock-audit/2024-02-optimism-2024-judging/issues/90#issuecomment-2094551960>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/ASHOYPIERRIR4LDWW7ZS5YTZAWHSBAVCNFSM6AAAAABFXP5JESVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDAOJUGU2TCOJWGA>\n> .\n> You are receiving this because you were mentioned.Message ID:\n> ***@***.***\n> com>\n>\n\n\n**guhu95**\n\n@Haxatron [here?](https://github.com/sherlock-audit/2024-02-optimism-2024/blob/main/optimism/packages/contracts-bedrock/src/dispute/FaultDisputeGame.sol#L355). It doesn't seem to be using the l2number value from `extraData` here (or anywhere else in the game itself).\n\nIt does use the `l1head()` from `extraData` [above](https://github.com/sherlock-audit/2024-02-optimism-2024/blob/main/optimism/packages/contracts-bedrock/src/dispute/FaultDisputeGame.sol#L342C54-L342C62) but not the L2 number.\n\n**Haxatron**\n\nApologies, you are correct, the L2 block number referenced on that line is the anchor root block number rather than the l2 block number passed via the extraData. Perhaps, this requires more clarification from protocol team...\n\n**guhu95**\n\n@Evert0x @nevillehuang it looks like the sponsor's argument for this being invalid is not well understood. The finding is also marked \"won't fix\", so if it is valid, it is not mitigated. It would appear that a mitigation would be needed at both game level and at the registry level, as fixing one without the other would leave the other vulnerable.\n\nCan @smartcontracts maybe have another look at this, and possibly address the questions in https://github.com/sherlock-audit/2024-02-optimism-2024-judging/issues/90#issuecomment-2094551960?\n\n**Evert0x**\n\nAfter a discussion with the protocol it's clear that this issue should be a valid Medium\n\n**trust1995**\n\nSo permissionless shutdown of withdrawals/messaging until redeploy (Freeze of Funds of 2 weeks) is considered a Medium on Sherlock? Was the magnitude of effect this would have on the Optimism ecosystem considered?\n\nA 1-hour shutdown of Blast was the most talked about incident for months, how would a 2-week FoF be interpreted? \n\n**guhu95**\n\nIn addition to the prolonged DoS, the DoS appears to be **repeatable**, and require changes to the registry and portal, and not just updating the game. \n\nIn order for the **DoS to NOT be repeatable**, the fix must be possible at the **game level**, such that updating the game type is sufficient. But it doesn't appear to be the case:\n\nPlease see these (new) fix PRs in OP dealing with this issue: https://github.com/ethereum-optimism/optimism/pull/10431/files, https://github.com/ethereum-optimism/optimism/pull/10434/files. \n\nThey add extensive changes to both the ASR and the Portal to deal with the l2BlockNumber issue. The changes to the game are minimal, and it appears that this issue is NOT fixable by just updating the game implementation. \n\n[I suspect this is because in the game, the l2blocknumber is PART of disputed L2 output state, so is not a mutually agreed on external input, unlike the L1 number, which comes directly from the L1 `block.number` itself. The dispute is about the rootClaim output state, not about the input l2blocknumber and something about the proving setup prevents it from being used this way (or from the game being able to distinguish which one of these inputs is incorrect). But this is just my limited and possibly wrong understanding]\n\nSummary: because the issue is not fixable by updating ONLY the game, and an upgrade of the ASR and Portal are needed, the safety measures are inadequate and the DoS WITHOUT the full fix is repeatable.\n\n**spearfish5609**\n\n> most talked about incident for months\n\nthis incident has not even happened 2 months ago and people cared about it for a few days at most\n\n**nirohgo**\n\n> After a discussion with the protocol it's clear that this issue should be a valid Medium\n\n@Evert0x can you elaborate why? (for those of us who weren't on that discussion) \n\n**Evert0x**\n\nThe justification for Medium severity is as follows\n\n> The Proxy Admin Owner is a TRUSTED role that can:\n> - Upgrade all smart contracts that sit behind a Proxy contract.\n> - Set the implementation contract for any dispute game type within the DisputeGameFactory.\n> - Modify the initial bond cost for any dispute game type within the DisputeGameFactory.\n> - Remove ETH from the DelayedWETH contract.\n> \n> The Proxy Admin Owner is assumed to be honest and responsive with an SLA of 72 hours.\n\nAs stated in the README, part of the security model is a honest and responsive admin that can recover from a DoS within 72 hours. \n\n> **Are there any off-chain mechanisms or off-chain procedures for the protocol (keeper bots, arbitrage bots, etc.)?**\n\n> Off-chain mechanisms exist as part of the system but are not in scope for this competition. Assume that comprehensive monitoring exists **that will detect most obviously detectable malicious activity.**\n\nThe supplied block being higher than the actual block number in the EVM is obviously detectable malicious activity. \n\nIn conclusion, once the proposal is detected, the Proxy Admin Owner is trusted to be responsive within 72 hours and is able to switch the game type to a permissioned implementation within a new AnchorStateRegistry to mitigate the DoS. \n\nNote: It’s important to note that there’s a difference between switching the game type (which invalidates all withdrawals with that game type) and switching the implementation (which does not invalidate withdrawals).\n\n**guhu95**\n\n@Evert0x but can switching to a permissioned implementation be considered final \"recovery\"?\n\nIf assumed permanent - it permanently breaks core functionality (no fraud proofs from that point).\n\nIf assumed temporary - it only postpones the switch of the game type and the withdrawals DoS.\n\n**trust1995**\n\nThis downplayed take is plagued with intellectual dishonesty.\n\n> The supplied block being higher than the actual block number in the EVM is obviously detectable malicious activity.\n\nIf it was obvious as something to look for, Opt would have validated the l2BlockNumber is the same as the VM block number.  Detection is highly unprobable. Please provide the defender off-chain code to show awareness of this vulnerability. Once again the benefit of the doubt is given to an opaque statement by the sponsor and against honest Watsons. For fairness of discussion, it must be assumed Opt is aware only at the moment games cannot be created.\n\n> able to switch the game type to a permissioned implementation within a new AnchorStateRegistry to mitigate the DoS.\n\nFor the past month where Optimism had access to the repo, their suggested fix was moving to a new game type, confirming the 2 week DOS. Only couple of days ago came the idea of overriding the same game type to avoid the DOS. Using this to reduce severity is unacceptable. It essentially extended their 3 day SLA to 1 month, letting them theorize over best response over a tremendously long time and then argue the optimized response would be what they would be rolling with on day 1. Clear intellectual dishonesty. \n\nAdditionally, from an air-gap perspective (up to High according to the README), the resolution and updating of the anchor state registry is instantaneous, making new withdrawals impossible from day 0 and bypassing intended airgaps. \nA combination of FoF impact (High impact) + airgap bypass (High focus of contest) + permissionless attacker (High likelihood) makes it verry clear high severity is in order.\n\n\nI will also state that over the past week Optimism has catapulted a variety of arguments against the submission which were technically proven wrong, showing they have no problem misrepresenting an issue or its characteristics in order to reduce its severity.\n\n**spearfish5609**\n\nI dont know why the optimism team is trying to find some weird loopholes to argue for downgrade if they could just use official sherlock docs to justify it:\n\naccording to https://docs.sherlock.xyz/audits/judging/judging#v.-how-to-identify-a-medium-issue : \n`Breaks core contract functionality, rendering the contract useless or leading to loss of funds.` is a medium\n\nabout DOS: https://docs.sherlock.xyz/audits/judging/judging#iii.-sherlocks-standards\nrequires both\n1. `The issue causes locking of funds for users for more than a week` \n2. `The issue impacts the availability of time-sensitive functions`\n\nto be high severity\n\n1 is true and 2 is questionable if we assume that admin deploys a new game type in time so funds can be recovered and users can just make new game instance, where these functions are available again.\n\nI dont see any air-gap bypass unless we use different definitions. My understanding is that the air-gap is the delay before withdraw of funds can happen and its not possible for users to withdraw early\n\n**Evert0x**\n\n@guhu95 It's not a final recovery, but safety mechanisms are put in place first to mitigate the DoS and, secondly, to remove the DoS factor. \n\n\n\n\n\n**Evert0x**\n\n@trust1995 Forwarding from the protocol team the detection code for this case.\n\n---\n\nSo in a nutshell the monitoring service is here: https://github.com/ethereum-optimism/optimism/blob/5137f3b74c6ebcac4f0f5a118b0f4909df03aec6/op-dispute-mon/mon/monitor.go#L87\n\nThis service calls out to a forecasting function which checks the L2 block number and the claim provided against the real output root for that block number: https://github.com/ethereum-optimism/optimism/blob/5137f3b74c6ebcac4f0f5a118b0f4909df03aec6/op-dispute-mon/mon/forecast.go#L69\n\nClaimed L2 block number and output are pulled from the game’s metadata: https://github.com/ethereum-optimism/optimism/blob/5137f3b74c6ebcac4f0f5a118b0f4909df03aec6/op-dispute-mon/mon/extract/extractor.go#L54\n\nSo in the case of that bug, the service would try to get the block number for the future block that doesn’t exist yet, get the following error, disagree, and raise an alert: https://github.com/ethereum-optimism/optimism/blob/5137f3b74c6ebcac4f0f5a118b0f4909df03aec6/op-dispute-mon/mon/validator.go#L40\n\n\n\n\n**Evert0x**\n\n@spearfish5609 I don't think I'm using weird loopholes to decide on the severity of this issue. \n\nIt's not always clear if the DoS should be judged as indefinite just because the admin can recover from it. However, in this case, the language in the README makes it clear.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/205",
  "Code": [
    {
      "filename": "optimism/packages/contracts-bedrock/src/dispute/FaultDisputeGame.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { FixedPointMathLib } from \"solady/utils/FixedPointMathLib.sol\";\n\nimport { IDelayedWETH } from \"src/dispute/interfaces/IDelayedWETH.sol\";\nimport { IDisputeGame } from \"src/dispute/interfaces/IDisputeGame.sol\";\nimport { IFaultDisputeGame } from \"src/dispute/interfaces/IFaultDisputeGame.sol\";\nimport { IInitializable } from \"src/dispute/interfaces/IInitializable.sol\";\nimport { IBigStepper, IPreimageOracle } from \"src/dispute/interfaces/IBigStepper.sol\";\nimport { IAnchorStateRegistry } from \"src/dispute/interfaces/IAnchorStateRegistry.sol\";\n\nimport { Clone } from \"src/libraries/Clone.sol\";\nimport { Types } from \"src/libraries/Types.sol\";\nimport { ISemver } from \"src/universal/ISemver.sol\";\nimport { LibClock } from \"src/dispute/lib/LibUDT.sol\";\n\nimport \"src/libraries/DisputeTypes.sol\";\nimport \"src/libraries/DisputeErrors.sol\";\n\n/// @title FaultDisputeGame\n/// @notice An implementation of the `IFaultDisputeGame` interface.\ncontract FaultDisputeGame is IFaultDisputeGame, Clone, ISemver {\n    ////////////////////////////////////////////////////////////////\n    //                         State Vars                         //\n    ////////////////////////////////////////////////////////////////\n\n    /// @notice The absolute prestate of the instruction trace. This is a constant that is defined\n    ///         by the program that is being used to execute the trace.\n    Claim internal immutable ABSOLUTE_PRESTATE;\n\n    /// @notice The max depth of the game.\n    uint256 internal immutable MAX_GAME_DEPTH;\n\n    /// @notice The max depth of the output bisection portion of the position tree. Immediately beneath\n    ///         this depth, execution trace bisection begins.\n    uint256 internal immutable SPLIT_DEPTH;\n\n    /// @notice The duration of the game.\n    Duration internal immutable GAME_DURATION;\n\n    /// @notice An onchain VM that performs single instruction steps on a fault proof program trace.\n    IBigStepper internal immutable VM;\n\n    /// @notice The game type ID.\n    GameType internal immutable GAME_TYPE;\n\n    /// @notice WETH contract for holding ETH.\n    IDelayedWETH internal immutable WETH;\n\n    /// @notice The anchor state registry.\n    IAnchorStateRegistry internal immutable ANCHOR_STATE_REGISTRY;\n\n    /// @notice The chain ID of the L2 network this contract argues about.\n    uint256 internal immutable L2_CHAIN_ID;\n\n    /// @notice The global root claim's position is always at gindex 1.\n    Position internal constant ROOT_POSITION = Position.wrap(1);\n\n    /// @notice The flag set in the `bond` field of a `ClaimData` struct to indicate that the bond has been claimed.\n    uint128 internal constant CLAIMED_BOND_FLAG = type(uint128).max;\n\n    /// @notice The starting timestamp of the game\n    Timestamp public createdAt;\n\n    /// @notice The timestamp of the game's global resolution.\n    Timestamp public resolvedAt;\n\n    /// @inheritdoc IDisputeGame\n    GameStatus public status;\n\n    /// @notice An append-only array of all claims made during the dispute game.\n    ClaimData[] public claimData;\n\n    /// @notice Credited balances for winning participants.\n    mapping(address => uint256) public credit;\n\n    /// @notice An internal mapping to allow for constant-time lookups of existing claims.\n    mapping(ClaimHash => bool) internal claims;\n\n    /// @notice An internal mapping of subgames rooted at a claim index to other claim indices in the subgame.\n    mapping(uint256 => uint256[]) internal subgames;\n\n    /// @notice Indicates whether the subgame rooted at the root claim has been resolved.\n    bool internal subgameAtRootResolved;\n\n    /// @notice Flag for the `initialize` function to prevent re-initialization.\n    bool internal initialized;\n\n    /// @notice The latest finalized output root, serving as the anchor for output bisection.\n    OutputRoot public startingOutputRoot;\n\n    /// @notice Semantic version.\n    /// @custom:semver 0.9.0\n    string public constant version = \"0.9.0\";\n\n    /// @param _gameType The type ID of the game.\n    /// @param _absolutePrestate The absolute prestate of the instruction trace.\n    /// @param _maxGameDepth The maximum depth of bisection.\n    /// @param _splitDepth The final depth of the output bisection portion of the game.\n    /// @param _gameDuration The duration of the game.\n    /// @param _vm An onchain VM that performs single instruction steps on an FPP trace.\n    /// @param _weth WETH contract for holding ETH.\n    /// @param _anchorStateRegistry The contract that stores the anchor state for each game type.\n    /// @param _l2ChainId Chain ID of the L2 network this contract argues about.\n    constructor(\n        GameType _gameType,\n        Claim _absolutePrestate,\n        uint256 _maxGameDepth,\n        uint256 _splitDepth,\n        Duration _gameDuration,\n        IBigStepper _vm,\n        IDelayedWETH _weth,\n        IAnchorStateRegistry _anchorStateRegistry,\n        uint256 _l2ChainId\n    ) {\n        // The split depth cannot be greater than or equal to the max game depth.\n        if (_splitDepth >= _maxGameDepth) revert InvalidSplitDepth();\n\n        GAME_TYPE = _gameType;\n        ABSOLUTE_PRESTATE = _absolutePrestate;\n        MAX_GAME_DEPTH = _maxGameDepth;\n        SPLIT_DEPTH = _splitDepth;\n        GAME_DURATION = _gameDuration;\n        VM = _vm;\n        WETH = _weth;\n        ANCHOR_STATE_REGISTRY = _anchorStateRegistry;\n        L2_CHAIN_ID = _l2ChainId;\n    }\n\n    /// @notice Receive function to allow the contract to receive ETH.\n    receive() external payable { }\n\n    /// @notice Fallback function to allow the contract to receive ETH.\n    fallback() external payable { }\n\n    ////////////////////////////////////////////////////////////////\n    //                  `IFaultDisputeGame` impl                  //\n    ////////////////////////////////////////////////////////////////\n\n    /// @inheritdoc IFaultDisputeGame\n    function step(\n        uint256 _claimIndex,\n        bool _isAttack,\n        bytes calldata _stateData,\n        bytes calldata _proof\n    )\n        public\n        virtual\n    {\n        // INVARIANT: Steps cannot be made unless the game is currently in progress.\n        if (status != GameStatus.IN_PROGRESS) revert GameNotInProgress();\n\n        // Get the parent. If it does not exist, the call will revert with OOB.\n        ClaimData storage parent = claimData[_claimIndex];\n\n        // Pull the parent position out of storage.\n        Position parentPos = parent.position;\n        // Determine the position of the step.\n        Position stepPos = parentPos.move(_isAttack);\n\n        // INVARIANT: A step cannot be made unless the move position is 1 below the `MAX_GAME_DEPTH`\n        if (stepPos.depth() != MAX_GAME_DEPTH + 1) revert InvalidParent();\n\n        // Determine the expected pre & post states of the step.\n        Claim preStateClaim;\n        ClaimData storage postState;\n        if (_isAttack) {\n            // If the step position's index at depth is 0, the prestate is the absolute\n            // prestate.\n            // If the step is an attack at a trace index > 0, the prestate exists elsewhere in\n            // the game state.\n            // NOTE: We localize the `indexAtDepth` for the current execution trace subgame by finding\n            //       the remainder of the index at depth divided by 2 ** (MAX_GAME_DEPTH - SPLIT_DEPTH),\n            //       which is the number of leaves in each execution trace subgame. This is so that we can\n            //       determine whether or not the step position is represents the `ABSOLUTE_PRESTATE`.\n            preStateClaim = (stepPos.indexAtDepth() % (1 << (MAX_GAME_DEPTH - SPLIT_DEPTH))) == 0\n                ? ABSOLUTE_PRESTATE\n                : _findTraceAncestor(Position.wrap(parentPos.raw() - 1), parent.parentIndex, false).claim;\n            // For all attacks, the poststate is the parent claim.\n            postState = parent;\n        } else {\n            // If the step is a defense, the poststate exists elsewhere in the game state,\n            // and the parent claim is the expected pre-state.\n            preStateClaim = parent.claim;\n            postState = _findTraceAncestor(Position.wrap(parentPos.raw() + 1), parent.parentIndex, false);\n        }\n\n        // INVARIANT: The prestate is always invalid if the passed `_stateData` is not the\n        //            preimage of the prestate claim hash.\n        //            We ignore the highest order byte of the digest because it is used to\n        //            indicate the VM Status and is added after the digest is computed.\n        if (keccak256(_stateData) << 8 != preStateClaim.raw() << 8) revert InvalidPrestate();\n\n        // Compute the local preimage context for the step.\n        Hash uuid = _findLocalContext(_claimIndex);\n\n        // INVARIANT: If a step is an attack, the poststate is valid if the step produces\n        //            the same poststate hash as the parent claim's value.\n        //            If a step is a defense:\n        //              1. If the parent claim and the found post state agree with each other\n        //                 (depth diff % 2 == 0), the step is valid if it produces the same\n        //                 state hash as the post state's claim.\n        //              2. If the parent claim and the found post state disagree with each other\n        //                 (depth diff % 2 != 0), the parent cannot be countered unless the step\n        //                 produces the same state hash as `postState.claim`.\n        // SAFETY:    While the `attack` path does not need an extra check for the post\n        //            state's depth in relation to the parent, we don't need another\n        //            branch because (n - n) % 2 == 0.\n        bool validStep = VM.step(_stateData, _proof, uuid.raw()) == postState.claim.raw();\n        bool parentPostAgree = (parentPos.depth() - postState.position.depth()) % 2 == 0;\n        if (parentPostAgree == validStep) revert ValidStep();\n\n        // INVARIANT: A step cannot be made against a claim for a second time.\n        if (parent.counteredBy != address(0)) revert DuplicateStep();\n\n        // Set the parent claim as countered. We do not need to append a new claim to the game;\n        // instead, we can just set the existing parent as countered.\n        parent.counteredBy = msg.sender;\n    }\n\n    /// @notice Generic move function, used for both `attack` and `defend` moves.\n    /// @param _challengeIndex The index of the claim being moved against.\n    /// @param _claim The claim at the next logical position in the game.\n    /// @param _isAttack Whether or not the move is an attack or defense.\n    function move(uint256 _challengeIndex, Claim _claim, bool _isAttack) public payable virtual {\n        // INVARIANT: Moves cannot be made unless the game is currently in progress.\n        if (status != GameStatus.IN_PROGRESS) revert GameNotInProgress();\n\n        // Get the parent. If it does not exist, the call will revert with OOB.\n        ClaimData memory parent = claimData[_challengeIndex];\n\n        // Compute the position that the claim commits to. Because the parent's position is already\n        // known, we can compute the next position by moving left or right depending on whether\n        // or not the move is an attack or defense.\n        Position parentPos = parent.position;\n        Position nextPosition = parentPos.move(_isAttack);\n        uint256 nextPositionDepth = nextPosition.depth();\n\n        // INVARIANT: A defense can never be made against the root claim of either the output root game or any\n        //            of the execution trace bisection subgames. This is because the root claim commits to the\n        //            entire state. Therefore, the only valid defense is to do nothing if it is agreed with.\n        if ((_challengeIndex == 0 || nextPositionDepth == SPLIT_DEPTH + 2) && !_isAttack) {\n            revert CannotDefendRootClaim();\n        }\n\n        // INVARIANT: A move can never surpass the `MAX_GAME_DEPTH`. The only option to counter a\n        //            claim at this depth is to perform a single instruction step on-chain via\n        //            the `step` function to prove that the state transition produces an unexpected\n        //            post-state.\n        if (nextPositionDepth > MAX_GAME_DEPTH) revert GameDepthExceeded();\n\n        // When the next position surpasses the split depth (i.e., it is the root claim of an execution\n        // trace bisection sub-game), we need to perform some extra verification steps.\n        if (nextPositionDepth == SPLIT_DEPTH + 1) {\n            _verifyExecBisectionRoot(_claim, _challengeIndex, parentPos, _isAttack);\n        }\n\n        // INVARIANT: The `msg.value` must exactly equal the required bond.\n        if (getRequiredBond(nextPosition) != msg.value) revert IncorrectBondAmount();\n\n        // Fetch the grandparent clock, if it exists.\n        // The grandparent clock should always exist unless the parent is the root claim.\n        Clock grandparentClock;\n        if (parent.parentIndex != type(uint32).max) {\n            grandparentClock = claimData[parent.parentIndex].clock;\n        }\n\n        // Compute the duration of the next clock. This is done by adding the duration of the\n        // grandparent claim to the difference between the current block timestamp and the\n        // parent's clock timestamp.\n        Duration nextDuration = Duration.wrap(\n            uint64(\n                // First, fetch the duration of the grandparent claim.\n                grandparentClock.duration().raw()\n                // Second, add the difference between the current block timestamp and the\n                // parent's clock timestamp.\n                + block.timestamp - parent.clock.timestamp().raw()\n            )\n        );\n\n        // INVARIANT: A move can never be made once its clock has exceeded `GAME_DURATION / 2`\n        //            seconds of time.\n        if (nextDuration.raw() > GAME_DURATION.raw() >> 1) revert ClockTimeExceeded();\n\n        // Construct the next clock with the new duration and the current block timestamp.\n        Clock nextClock = LibClock.wrap(nextDuration, Timestamp.wrap(uint64(block.timestamp)));\n\n        // INVARIANT: There cannot be multiple identical claims with identical moves on the same challengeIndex. Multiple\n        //            claims at the same position may dispute the same challengeIndex. However, they must have different\n        //            values.\n        ClaimHash claimHash = _claim.hashClaimPos(nextPosition, _challengeIndex);\n        if (claims[claimHash]) revert ClaimAlreadyExists();\n        claims[claimHash] = true;\n\n        // Create the new claim.\n        claimData.push(\n            ClaimData({\n                parentIndex: uint32(_challengeIndex),\n                // This is updated during subgame resolution\n                counteredBy: address(0),\n                claimant: msg.sender,\n                bond: uint128(msg.value),\n                claim: _claim,\n                position: nextPosition,\n                clock: nextClock\n            })\n        );\n\n        // Update the subgame rooted at the parent claim.\n        subgames[_challengeIndex].push(claimData.length - 1);\n\n        // Deposit the bond.\n        WETH.deposit{ value: msg.value }();\n\n        // Emit the appropriate event for the attack or defense.\n        emit Move(_challengeIndex, _claim, msg.sender);\n    }\n\n    /// @inheritdoc IFaultDisputeGame\n    function attack(uint256 _parentIndex, Claim _claim) external payable {\n        move(_parentIndex, _claim, true);\n    }\n\n    /// @inheritdoc IFaultDisputeGame\n    function defend(uint256 _parentIndex, Claim _claim) external payable {\n        move(_parentIndex, _claim, false);\n    }\n\n    /// @inheritdoc IFaultDisputeGame\n    function addLocalData(uint256 _ident, uint256 _execLeafIdx, uint256 _partOffset) external {\n        // INVARIANT: Local data can only be added if the game is currently in progress.\n        if (status != GameStatus.IN_PROGRESS) revert GameNotInProgress();\n\n        (Claim starting, Position startingPos, Claim disputed, Position disputedPos) =\n            _findStartingAndDisputedOutputs(_execLeafIdx);\n        Hash uuid = _computeLocalContext(starting, startingPos, disputed, disputedPos);\n\n        IPreimageOracle oracle = VM.oracle();\n        if (_ident == LocalPreimageKey.L1_HEAD_HASH) {\n            // Load the L1 head hash\n            oracle.loadLocalData(_ident, uuid.raw(), l1Head().raw(), 32, _partOffset);\n        } else if (_ident == LocalPreimageKey.STARTING_OUTPUT_ROOT) {\n            // Load the starting proposal's output root.\n            oracle.loadLocalData(_ident, uuid.raw(), starting.raw(), 32, _partOffset);\n        } else if (_ident == LocalPreimageKey.DISPUTED_OUTPUT_ROOT) {\n            // Load the disputed proposal's output root\n            oracle.loadLocalData(_ident, uuid.raw(), disputed.raw(), 32, _partOffset);\n        } else if (_ident == LocalPreimageKey.DISPUTED_L2_BLOCK_NUMBER) {\n            // Load the disputed proposal's L2 block number as a big-endian uint64 in the\n            // high order 8 bytes of the word.\n\n            // We add the index at depth + 1 to the starting block number to get the disputed L2\n            // block number.\n            uint256 l2Number = startingOutputRoot.l2BlockNumber + disputedPos.traceIndex(SPLIT_DEPTH) + 1;\n\n            oracle.loadLocalData(_ident, uuid.raw(), bytes32(l2Number << 0xC0), 8, _partOffset);\n        } else if (_ident == LocalPreimageKey.CHAIN_ID) {\n            // Load the chain ID as a big-endian uint64 in the high order 8 bytes of the word.\n            oracle.loadLocalData(_ident, uuid.raw(), bytes32(L2_CHAIN_ID << 0xC0), 8, _partOffset);\n        } else {\n            revert InvalidLocalIdent();\n        }\n    }\n\n    /// @inheritdoc IFaultDisputeGame\n    function l1Head() public pure returns (Hash l1Head_) {\n        l1Head_ = Hash.wrap(_getArgFixedBytes(0x20));\n    }\n\n    /// @inheritdoc IFaultDisputeGame\n    function l2BlockNumber() public pure returns (uint256 l2BlockNumber_) {\n        l2BlockNumber_ = _getArgUint256(0x40);\n    }\n\n    ////////////////////////////////////////////////////////////////\n    //                    `IDisputeGame` impl                     //\n    ////////////////////////////////////////////////////////////////\n\n    /// @inheritdoc IDisputeGame\n    function gameType() public view override returns (GameType gameType_) {\n        gameType_ = GAME_TYPE;\n    }\n\n    /// @inheritdoc IDisputeGame\n    function resolve() external returns (GameStatus status_) {\n        // INVARIANT: Resolution cannot occur unless the game is currently in progress.\n        if (status != GameStatus.IN_PROGRESS) revert GameNotInProgress();\n\n        // INVARIANT: Resolution cannot occur unless the absolute root subgame has been resolved.\n        if (!subgameAtRootResolved) revert OutOfOrderResolution();\n\n        // Update the global game status; The dispute has concluded.\n        status_ = claimData[0].counteredBy == address(0) ? GameStatus.DEFENDER_WINS : GameStatus.CHALLENGER_WINS;\n        resolvedAt = Timestamp.wrap(uint64(block.timestamp));\n\n        // Update the status and emit the resolved event, note that we're performing an assignment here.\n        emit Resolved(status = status_);\n\n        // Try to update the anchor state, this should not revert.\n        ANCHOR_STATE_REGISTRY.tryUpdateAnchorState();\n    }\n\n    /// @inheritdoc IFaultDisputeGame\n    function resolveClaim(uint256 _claimIndex) external payable {\n        // INVARIANT: Resolution cannot occur unless the game is currently in progress.\n        if (status != GameStatus.IN_PROGRESS) revert GameNotInProgress();\n\n        ClaimData storage parent = claimData[_claimIndex];\n\n        // INVARIANT: Cannot resolve a subgame unless the clock of its root has expired\n        uint64 parentClockDuration = parent.clock.duration().raw();\n        uint64 timeSinceParentMove = uint64(block.timestamp) - parent.clock.timestamp().raw();\n        if (parentClockDuration + timeSinceParentMove <= GAME_DURATION.raw() >> 1) {\n            revert ClockNotExpired();\n        }\n\n        uint256[] storage challengeIndices = subgames[_claimIndex];\n        uint256 challengeIndicesLen = challengeIndices.length;\n\n        // INVARIANT: Cannot resolve subgames twice\n        if (_claimIndex == 0 && subgameAtRootResolved) {\n            revert ClaimAlreadyResolved();\n        }\n\n        // Uncontested claims are resolved implicitly unless they are the root claim. Pay out the bond to the claimant\n        // and return early.\n        if (challengeIndicesLen == 0 && _claimIndex != 0) {\n            // In the event that the parent claim is at the max depth, there will always be 0 subgames. If the\n            // `counteredBy` field is set and there are no subgames, this implies that the parent claim was successfully\n            // stepped against. In this case, we pay out the bond to the party that stepped against the parent claim.\n            // Otherwise, the parent claim is uncontested, and the bond is returned to the claimant.\n            address counteredBy = parent.counteredBy;\n            address recipient = counteredBy == address(0) ? parent.claimant : counteredBy;\n            _distributeBond(recipient, parent);\n            return;\n        }\n\n        // Assume parent is honest until proven otherwise\n        address countered = address(0);\n        Position leftmostCounter = Position.wrap(type(uint128).max);\n        for (uint256 i = 0; i < challengeIndicesLen; ++i) {\n            uint256 challengeIndex = challengeIndices[i];\n\n            // INVARIANT: Cannot resolve a subgame containing an unresolved claim\n            if (subgames[challengeIndex].length != 0) revert OutOfOrderResolution();\n\n            ClaimData storage claim = claimData[challengeIndex];\n\n            // If the child subgame is uncountered and further left than the current left-most counter,\n            // update the parent subgame's `countered` address and the current `leftmostCounter`.\n            // The left-most correct counter is preferred in bond payouts in order to discourage attackers\n            // from countering invalid subgame roots via an invalid defense position. As such positions\n            // cannot be correctly countered.\n            // Note that correctly positioned defense, but invalid claimes can still be successfully countered.\n            if (claim.counteredBy == address(0) && leftmostCounter.raw() > claim.position.raw()) {\n                countered = claim.claimant;\n                leftmostCounter = claim.position;\n            }\n        }\n\n        // If the parent was not successfully countered, pay out the parent's bond to the claimant.\n        // If the parent was successfully countered, pay out the parent's bond to the challenger.\n        _distributeBond(countered == address(0) ? parent.claimant : countered, parent);\n\n        // Once a subgame is resolved, we percolate the result up the DAG so subsequent calls to\n        // resolveClaim will not need to traverse this subgame.\n        parent.counteredBy = countered;\n\n        // Resolved subgames have no entries\n        delete subgames[_claimIndex];\n\n        // Indicate the game is ready to be resolved globally.\n        if (_claimIndex == 0) {\n            subgameAtRootResolved = true;\n        }\n    }\n\n    /// @inheritdoc IDisputeGame\n    function rootClaim() public pure returns (Claim rootClaim_) {\n        rootClaim_ = Claim.wrap(_getArgFixedBytes(0x00));\n    }\n\n    /// @inheritdoc IDisputeGame\n    function extraData() public pure returns (bytes memory extraData_) {\n        // The extra data starts at the second word within the cwia calldata and\n        // is 32 bytes long.\n        extraData_ = _getArgDynBytes(0x40, 0x20);\n    }\n\n    /// @inheritdoc IDisputeGame\n    function gameData() external view returns (GameType gameType_, Claim rootClaim_, bytes memory extraData_) {\n        gameType_ = gameType();\n        rootClaim_ = rootClaim();\n        extraData_ = extraData();\n    }\n\n    /// @inheritdoc IFaultDisputeGame\n    function startingBlockNumber() external view returns (uint256 startingBlockNumber_) {\n        startingBlockNumber_ = startingOutputRoot.l2BlockNumber;\n    }\n\n    /// @inheritdoc IFaultDisputeGame\n    function startingRootHash() external view returns (Hash startingRootHash_) {\n        startingRootHash_ = startingOutputRoot.root;\n    }\n\n    ////////////////////////////////////////////////////////////////\n    //                       MISC EXTERNAL                        //\n    ////////////////////////////////////////////////////////////////\n\n    /// @inheritdoc IInitializable\n    function initialize() public payable virtual {\n        // SAFETY: Any revert in this function will bubble up to the DisputeGameFactory and\n        // prevent the game from being created.\n        //\n        // Implicit assumptions:\n        // - The `gameStatus` state variable defaults to 0, which is `GameStatus.IN_PROGRESS`\n        // - The dispute game factory will enforce the required bond to initialize the game.\n        //\n        // Explicit checks:\n        // - The game must not have already been initialized.\n        // - An output root cannot be proposed at or before the starting block number.\n\n        // INVARIANT: The game must not have already been initialized.\n        if (initialized) revert AlreadyInitialized();\n\n        // Grab the latest anchor root.\n        (Hash root, uint256 rootBlockNumber) = ANCHOR_STATE_REGISTRY.anchors(GAME_TYPE);\n\n        // Should only happen if this is a new game type that hasn't been set up yet.\n        if (root.raw() == bytes32(0)) revert AnchorRootNotFound();\n\n        // Set the starting output root.\n        startingOutputRoot = OutputRoot({ l2BlockNumber: rootBlockNumber, root: root });\n\n        // Do not allow the game to be initialized if the root claim corresponds to a block at or before the\n        // configured starting block number.\n        if (l2BlockNumber() <= rootBlockNumber) revert UnexpectedRootClaim(rootClaim());\n\n        // Revert if the calldata size is too large, which signals that the `extraData` contains more than expected.\n        // This is to prevent adding extra bytes to the `extraData` that result in a different game UUID in the factory,\n        // but are not used by the game, which would allow for multiple dispute games for the same output proposal to\n        // be created.\n        // Expected length: 0x66 (0x04 selector + 0x20 root claim + 0x20 l1 head + 0x20 extraData + 0x02 CWIA bytes)\n        assembly {\n            if gt(calldatasize(), 0x66) {\n                // Store the selector for `ExtraDataTooLong()` & revert\n                mstore(0x00, 0xc407e025)\n                revert(0x1C, 0x04)\n            }\n        }\n\n        // Set the root claim\n        claimData.push(\n            ClaimData({\n                parentIndex: type(uint32).max,\n                counteredBy: address(0),\n                claimant: tx.origin,\n                bond: uint128(msg.value),\n                claim: rootClaim(),\n                position: ROOT_POSITION,\n                clock: LibClock.wrap(Duration.wrap(0), Timestamp.wrap(uint64(block.timestamp)))\n            })\n        );\n\n        // Deposit the bond.\n        WETH.deposit{ value: msg.value }();\n\n        // Set the game's starting timestamp\n        createdAt = Timestamp.wrap(uint64(block.timestamp));\n\n        // Set the game as initialized.\n        initialized = true;\n    }\n\n    /// @notice Returns the length of the `claimData` array.\n    function claimDataLen() external view returns (uint256 len_) {\n        len_ = claimData.length;\n    }\n\n    /// @notice Returns the required bond for a given move kind.\n    /// @param _position The position of the bonded interaction.\n    /// @return requiredBond_ The required ETH bond for the given move, in wei.\n    function getRequiredBond(Position _position) public view returns (uint256 requiredBond_) {\n        uint256 depth = uint256(_position.depth());\n        if (depth > MAX_GAME_DEPTH) revert GameDepthExceeded();\n\n        // Values taken from Big Bonds v1.5 (TM) spec.\n        uint256 assumedBaseFee = 200 gwei;\n        uint256 baseGasCharged = 400_000;\n        uint256 highGasCharged = 200_000_000;\n\n        // Goal here is to compute the fixed multiplier that will be applied to the base gas\n        // charged to get the required gas amount for the given depth. We apply this multiplier\n        // some `n` times where `n` is the depth of the position. We are looking for some number\n        // that, when multiplied by itself `MAX_GAME_DEPTH` times and then multiplied by the base\n        // gas charged, will give us the maximum gas that we want to charge.\n        // We want to solve for (highGasCharged/baseGasCharged) ** (1/MAX_GAME_DEPTH).\n        // We know that a ** (b/c) is equal to e ** (ln(a) * (b/c)).\n        // We can compute e ** (ln(a) * (b/c)) quite easily with FixedPointMathLib.\n\n        // Set up a, b, and c.\n        uint256 a = highGasCharged / baseGasCharged;\n        uint256 b = FixedPointMathLib.WAD;\n        uint256 c = MAX_GAME_DEPTH * FixedPointMathLib.WAD;\n\n        // Compute ln(a).\n        // slither-disable-next-line divide-before-multiply\n        uint256 lnA = uint256(FixedPointMathLib.lnWad(int256(a * FixedPointMathLib.WAD)));\n\n        // Computes (b / c) with full precision using WAD = 1e18.\n        uint256 bOverC = FixedPointMathLib.divWad(b, c);\n\n        // Compute e ** (ln(a) * (b/c))\n        // sMulWad can be used here since WAD = 1e18 maintains the same precision.\n        uint256 numerator = FixedPointMathLib.mulWad(lnA, bOverC);\n        int256 base = FixedPointMathLib.expWad(int256(numerator));\n\n        // Compute the required gas amount.\n        int256 rawGas = FixedPointMathLib.powWad(base, int256(depth * FixedPointMathLib.WAD));\n        uint256 requiredGas = FixedPointMathLib.mulWad(baseGasCharged, uint256(rawGas));\n\n        // Compute the required bond.\n        requiredBond_ = assumedBaseFee * requiredGas;\n    }\n\n    /// @notice Claim the credit belonging to the recipient address.\n    /// @param _recipient The owner and recipient of the credit.\n    function claimCredit(address _recipient) external {\n        // Remove the credit from the recipient prior to performing the external call.\n        uint256 recipientCredit = credit[_recipient];\n        credit[_recipient] = 0;\n\n        // Revert if the recipient has no credit to claim.\n        if (recipientCredit == 0) {\n            revert NoCreditToClaim();\n        }\n\n        // Try to withdraw the WETH amount so it can be used here.\n        WETH.withdraw(_recipient, recipientCredit);\n\n        // Transfer the credit to the recipient.\n        (bool success,) = _recipient.call{ value: recipientCredit }(hex\"\");\n        if (!success) revert BondTransferFailed();\n    }\n\n    ////////////////////////////////////////////////////////////////\n    //                     IMMUTABLE GETTERS                      //\n    ////////////////////////////////////////////////////////////////\n\n    /// @notice Returns the absolute prestate of the instruction trace.\n    function absolutePrestate() external view returns (Claim absolutePrestate_) {\n        absolutePrestate_ = ABSOLUTE_PRESTATE;\n    }\n\n    /// @notice Returns the max game depth.\n    function maxGameDepth() external view returns (uint256 maxGameDepth_) {\n        maxGameDepth_ = MAX_GAME_DEPTH;\n    }\n\n    /// @notice Returns the split depth.\n    function splitDepth() external view returns (uint256 splitDepth_) {\n        splitDepth_ = SPLIT_DEPTH;\n    }\n\n    /// @notice Returns the game duration.\n    function gameDuration() external view returns (Duration gameDuration_) {\n        gameDuration_ = GAME_DURATION;\n    }\n\n    /// @notice Returns the address of the VM.\n    function vm() external view returns (IBigStepper vm_) {\n        vm_ = VM;\n    }\n\n    /// @notice Returns the WETH contract for holding ETH.\n    function weth() external view returns (IDelayedWETH weth_) {\n        weth_ = WETH;\n    }\n\n    /// @notice Returns the chain ID of the L2 network this contract argues about.\n    function l2ChainId() external view returns (uint256 l2ChainId_) {\n        l2ChainId_ = L2_CHAIN_ID;\n    }\n\n    ////////////////////////////////////////////////////////////////\n    //                          HELPERS                           //\n    ////////////////////////////////////////////////////////////////\n\n    /// @notice Pays out the bond of a claim to a given recipient.\n    /// @param _recipient The recipient of the bond.\n    /// @param _bonded The claim to pay out the bond of.\n    function _distributeBond(address _re"
    }
  ]
}