{
  "Title": "[10] All the four functions `buy()`, `sell()`, `mintNFT()` and `burnNFT()` call `_splitFees()` to split the fees, but when `shareData[_id].tokensInCirculation ==0`, `shareHolderFee` will be added to `plantformFee`.",
  "Content": "\n[Market.sol#L280-L296](https://github.com/code-423n4/2023-11-canto/blob/335930cd53cf9a137504a57f1215be52c6d67cb3/1155tech-contracts/src/Market.sol#L280-L296)\n\nIn this case, a user can front-run these transactions with a `buy()` to buy a share so that `shareData[_id].tokensInCirculation > 0` and therefore, effectively be able to steal all such `shareHolderFee` in these situations.\n\nMitigation: Implement a snapshot mechanism for market so that a user can not just suddenly buy shares and enjoy rewards immediately. See ERC20Snapshot for an example:\n\n[ERC20Snapshot](https://docs.openzeppelin.com/contracts/3.x/api/token/erc20#ERC20Snapshot)\n\n\n**[0xTheC0der (judge) commented](https://github.com/code-423n4/2023-11-canto-findings/issues/106#issuecomment-1832881518):**\n > Although this report lacks formatting and therefore probably didn't get a high quality tag, its QA findings provide great value. Therefore, it's selected for report.  \n> \n> 01: Low. <br>\n> 02: Non-Critical.<br>\n> 03: Low.<br>\n> 04: Non-Critical.<br>\n> 05: Non-Critical.<br>\n> 06: Low.<br>\n> 07: Low.<br>\n> 08: Non-Critical (possibly undesired, but valid to mention).<br>\n> 09: Non-Critical (possibly undesired, but valid to mention).<br>\n> 10: Low.\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-11-canto",
  "Code": [
    {
      "filename": "1155tech-contracts/src/Market.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.19;\n\nimport {ERC1155} from \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Ownable, Ownable2Step} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport {IBondingCurve} from \"../interface/IBondingCurve.sol\";\nimport {Turnstile} from \"../interface/Turnstile.sol\";\n\ncontract Market is ERC1155, Ownable2Step {\n    /*//////////////////////////////////////////////////////////////\n                                 CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n    uint256 public constant NFT_FEE_BPS = 1_000; // 10%\n    uint256 public constant HOLDER_CUT_BPS = 3_300; // 33%\n    uint256 public constant CREATOR_CUT_BPS = 3_300; // 33%\n    // Platform cut: 100% - HOLDER_CUT_BPS - CREATOR_CUT_BPS\n\n    /// @notice Payment token\n    IERC20 public immutable token;\n\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Number of shares created\n    uint256 public shareCount;\n\n    /// @notice Stores the share ID of a given share name\n    mapping(string => uint256) public shareIDs;\n\n    struct ShareData {\n        uint256 tokenCount; // Number of outstanding tokens\n        uint256 tokensInCirculation; // Number of outstanding tokens - tokens that are minted as NFT, i.e. the number of tokens that receive fees\n        uint256 shareHolderRewardsPerTokenScaled; // Accrued funds for the share holder per token, multiplied by 1e18 to avoid precision loss\n        uint256 shareCreatorPool; // Unclaimed funds for the share creators\n        address bondingCurve; // Bonding curve used for this share\n        address creator; // Creator of the share\n        string metadataURI; // URI of the metadata\n    }\n\n    /// @notice Stores the data for a given share ID\n    mapping(uint256 => ShareData) public shareData;\n\n    /// @notice Stores the bonding curve per share\n    mapping(uint256 => address) public shareBondingCurves;\n\n    /// @notice Bonding curves that can be used for shares\n    mapping(address => bool) public whitelistedBondingCurves;\n\n    /// @notice Stores the number of outstanding tokens per share and address\n    mapping(uint256 => mapping(address => uint256)) public tokensByAddress;\n\n    /// @notice Value of ShareData.shareHolderRewardsPerTokenScaled at the last time a user claimed their rewards\n    mapping(uint256 => mapping(address => uint256)) public rewardsLastClaimedValue;\n\n    /// @notice Unclaimed funds for the platform\n    uint256 public platformPool;\n\n    /// @notice If true, only the whitelisted addresses can create shares\n    bool public shareCreationRestricted = true;\n\n    /// @notice List of addresses that can add new shares when shareCreationRestricted is true\n    mapping(address => bool) public whitelistedShareCreators;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event BondingCurveStateChange(address indexed curve, bool isWhitelisted);\n    event ShareCreated(uint256 indexed id, string name, address indexed bondingCurve, address indexed creator);\n    event SharesBought(uint256 indexed id, address indexed buyer, uint256 amount, uint256 price, uint256 fee);\n    event SharesSold(uint256 indexed id, address indexed seller, uint256 amount, uint256 price, uint256 fee);\n    event NFTsCreated(uint256 indexed id, address indexed creator, uint256 amount, uint256 fee);\n    event NFTsBurned(uint256 indexed id, address indexed burner, uint256 amount, uint256 fee);\n    event PlatformFeeClaimed(address indexed claimer, uint256 amount);\n    event CreatorFeeClaimed(address indexed claimer, uint256 indexed id, uint256 amount);\n    event HolderFeeClaimed(address indexed claimer, uint256 indexed id, uint256 amount);\n    event ShareCreationRestricted(bool isRestricted);\n\n    modifier onlyShareCreator() {\n        require(\n            !shareCreationRestricted || whitelistedShareCreators[msg.sender] || msg.sender == owner(),\n            \"Not allowed\"\n        );\n        _;\n    }\n\n    /// @notice Initiates CSR on main- and testnet\n    /// @param _uri ERC1155 Base URI\n    /// @param _paymentToken Address of the payment token\n    constructor(string memory _uri, address _paymentToken) ERC1155(_uri) Ownable() {\n        token = IERC20(_paymentToken);\n        if (block.chainid == 7700 || block.chainid == 7701) {\n            // Register CSR on Canto main- and testnet\n            Turnstile turnstile = Turnstile(0xEcf044C5B4b867CFda001101c617eCd347095B44);\n            turnstile.register(tx.origin);\n        }\n    }\n\n    /// @notice Whitelist or remove whitelist for a bonding curve.\n    /// @dev Whitelisting status is only checked when adding a share\n    /// @param _bondingCurve Address of the bonding curve\n    /// @param _newState True if whitelisted, false if not\n    function changeBondingCurveAllowed(address _bondingCurve, bool _newState) external onlyOwner {\n        require(whitelistedBondingCurves[_bondingCurve] != _newState, \"State already set\");\n        whitelistedBondingCurves[_bondingCurve] = _newState;\n        emit BondingCurveStateChange(_bondingCurve, _newState);\n    }\n\n    /// @notice Creates a new share\n    /// @param _shareName Name of the share\n    /// @param _bondingCurve Address of the bonding curve, has to be whitelisted\n    /// @param _metadataURI URI of the metadata\n    function createNewShare(\n        string memory _shareName,\n        address _bondingCurve,\n        string memory _metadataURI\n    ) external onlyShareCreator returns (uint256 id) {\n        require(whitelistedBondingCurves[_bondingCurve], \"Bonding curve not whitelisted\");\n        require(shareIDs[_shareName] == 0, \"Share already exists\");\n        id = ++shareCount;\n        shareIDs[_shareName] = id;\n        shareData[id].bondingCurve = _bondingCurve;\n        shareData[id].creator = msg.sender;\n        shareData[id].metadataURI = _metadataURI;\n        emit ShareCreated(id, _shareName, _bondingCurve, msg.sender);\n    }\n\n    /// @notice Returns the price and fee for buying a given number of shares.\n    /// @param _id The ID of the share\n    /// @param _amount The number of shares to buy.\n    function getBuyPrice(uint256 _id, uint256 _amount) public view returns (uint256 price, uint256 fee) {\n        // If id does not exist, this will return address(0), causing a revert in the next line\n        address bondingCurve = shareData[_id].bondingCurve;\n        (price, fee) = IBondingCurve(bondingCurve).getPriceAndFee(shareData[_id].tokenCount + 1, _amount);\n    }\n\n    /// @notice Returns the price and fee for selling a given number of shares.\n    /// @param _id The ID of the share\n    /// @param _amount The number of shares to sell.\n    function getSellPrice(uint256 _id, uint256 _amount) public view returns (uint256 price, uint256 fee) {\n        // If id does not exist, this will return address(0), causing a revert in the next line\n        address bondingCurve = shareData[_id].bondingCurve;\n        (price, fee) = IBondingCurve(bondingCurve).getPriceAndFee(shareData[_id].tokenCount - _amount + 1, _amount);\n    }\n\n    /// @notice Buy amount of tokens for a given share ID\n    /// @param _id ID of the share\n    /// @param _amount Amount of shares to buy\n    function buy(uint256 _id, uint256 _amount) external {\n        require(shareData[_id].creator != msg.sender, \"Creator cannot buy\");\n        (uint256 price, uint256 fee) = getBuyPrice(_id, _amount); // Reverts for non-existing ID\n        SafeERC20.safeTransferFrom(token, msg.sender, address(this), price + fee);\n        // The reward calculation has to use the old rewards value (pre fee-split) to not include the fees of this buy\n        // The rewardsLastClaimedValue then needs to be updated with the new value such that the user cannot claim fees of this buy\n        uint256 rewardsSinceLastClaim = _getRewardsSinceLastClaim(_id);\n        // Split the fee among holder, creator and platform\n        _splitFees(_id, fee, shareData[_id].tokensInCirculation);\n        rewardsLastClaimedValue[_id][msg.sender] = shareData[_id].shareHolderRewardsPerTokenScaled;\n\n        shareData[_id].tokenCount += _amount;\n        shareData[_id].tokensInCirculation += _amount;\n        tokensByAddress[_id][msg.sender] += _amount;\n\n        if (rewardsSinceLastClaim > 0) {\n            SafeERC20.safeTransfer(token, msg.sender, rewardsSinceLastClaim);\n        }\n        emit SharesBought(_id, msg.sender, _amount, price, fee);\n    }\n\n    /// @notice Sell amount of tokens for a given share ID\n    /// @param _id ID of the share\n    /// @param _amount Amount of shares to sell\n    function sell(uint256 _id, uint256 _amount) external {\n        (uint256 price, uint256 fee) = getSellPrice(_id, _amount);\n        // Split the fee among holder, creator and platform\n        _splitFees(_id, fee, shareData[_id].tokensInCirculation);\n        // The user also gets the rewards of his own sale (which is not the case for buys)\n        uint256 rewardsSinceLastClaim = _getRewardsSinceLastClaim(_id);\n        rewardsLastClaimedValue[_id][msg.sender] = shareData[_id].shareHolderRewardsPerTokenScaled;\n\n        shareData[_id].tokenCount -= _amount;\n        shareData[_id].tokensInCirculation -= _amount;\n        tokensByAddress[_id][msg.sender] -= _amount; // Would underflow if user did not have enough tokens\n\n        // Send the funds to the user\n        SafeERC20.safeTransfer(token, msg.sender, rewardsSinceLastClaim + price - fee);\n        emit SharesSold(_id, msg.sender, _amount, price, fee);\n    }\n\n    /// @notice Returns the price and fee for minting a given number of NFTs.\n    /// @param _id The ID of the share\n    /// @param _amount The number of NFTs to mint.\n    function getNFTMintingPrice(uint256 _id, uint256 _amount) public view returns (uint256 fee) {\n        address bondingCurve = shareData[_id].bondingCurve;\n        (uint256 priceForOne, ) = IBondingCurve(bondingCurve).getPriceAndFee(shareData[_id].tokenCount, 1);\n        fee = (priceForOne * _amount * NFT_FEE_BPS) / 10_000;\n    }\n\n    /// @notice Convert amount of tokens to NFTs for a given share ID\n    /// @param _id ID of the share\n    /// @param _amount Amount of tokens to convert. User needs to have this many tokens.\n    function mintNFT(uint256 _id, uint256 _amount) external {\n        uint256 fee = getNFTMintingPrice(_id, _amount);\n\n        SafeERC20.safeTransferFrom(token, msg.sender, address(this), fee);\n        _splitFees(_id, fee, shareData[_id].tokensInCirculation);\n        // The user also gets the proportional rewards for the minting\n        uint256 rewardsSinceLastClaim = _getRewardsSinceLastClaim(_id);\n        rewardsLastClaimedValue[_id][msg.sender] = shareData[_id].shareHolderRewardsPerTokenScaled;\n        tokensByAddress[_id][msg.sender] -= _amount;\n        shareData[_id].tokensInCirculation -= _amount;\n\n        _mint(msg.sender, _id, _amount, \"\");\n\n        if (rewardsSinceLastClaim > 0) {\n            SafeERC20.safeTransfer(token, msg.sender, rewardsSinceLastClaim);\n        }\n        // ERC1155 already logs, but we add this to have the price information\n        emit NFTsCreated(_id, msg.sender, _amount, fee);\n    }\n\n    /// @notice Burn amount of NFTs for a given share ID to get back tokens\n    /// @param _id ID of the share\n    /// @param _amount Amount of NFTs to burn\n    function burnNFT(uint256 _id, uint256 _amount) external {\n        uint256 fee = getNFTMintingPrice(_id, _amount);\n\n        SafeERC20.safeTransferFrom(token, msg.sender, address(this), fee);\n        _splitFees(_id, fee, shareData[_id].tokensInCirculation);\n        // The user does not get the proportional rewards for the burning (unless they have additional tokens that are not in the NFT)\n        uint256 rewardsSinceLastClaim = _getRewardsSinceLastClaim(_id);\n        rewardsLastClaimedValue[_id][msg.sender] = shareData[_id].shareHolderRewardsPerTokenScaled;\n        tokensByAddress[_id][msg.sender] += _amount;\n        shareData[_id].tokensInCirculation += _amount;\n        _burn(msg.sender, _id, _amount);\n\n        SafeERC20.safeTransfer(token, msg.sender, rewardsSinceLastClaim);\n        // ERC1155 already logs, but we add this to have the price information\n        emit NFTsBurned(_id, msg.sender, _amount, fee);\n    }\n\n    /// @notice Withdraws the accrued platform fee\n    function claimPlatformFee() external onlyOwner {\n        uint256 amount = platformPool;\n        platformPool = 0;\n        SafeERC20.safeTransfer(token, msg.sender, amount);\n        emit PlatformFeeClaimed(msg.sender, amount);\n    }\n\n    /// @notice Withdraws the accrued share creator fee\n    /// @param _id ID of the share\n    function claimCreatorFee(uint256 _id) external {\n        require(shareData[_id].creator == msg.sender, \"Not creator\");\n        uint256 amount = shareData[_id].shareCreatorPool;\n        shareData[_id].shareCreatorPool = 0;\n        SafeERC20.safeTransfer(token, msg.sender, amount);\n        emit CreatorFeeClaimed(msg.sender, _id, amount);\n    }\n\n    /// @notice Withdraws the accrued share holder fee\n    /// @param _id ID of the share\n    function claimHolderFee(uint256 _id) external {\n        uint256 amount = _getRewardsSinceLastClaim(_id);\n        rewardsLastClaimedValue[_id][msg.sender] = shareData[_id].shareHolderRewardsPerTokenScaled;\n        if (amount > 0) {\n            SafeERC20.safeTransfer(token, msg.sender, amount);\n        }\n        emit HolderFeeClaimed(msg.sender, _id, amount);\n    }\n\n    function _getRewardsSinceLastClaim(uint256 _id) internal view returns (uint256 amount) {\n        uint256 lastClaimedValue = rewardsLastClaimedValue[_id][msg.sender];\n        amount =\n            ((shareData[_id].shareHolderRewardsPerTokenScaled - lastClaimedValue) * tokensByAddress[_id][msg.sender]) /\n            1e18;\n    }\n\n    /// @notice Splits the fee among the share holder, creator and platform\n    function _splitFees(\n        uint256 _id,\n        uint256 _fee,\n        uint256 _tokenCount\n    ) internal {\n        uint256 shareHolderFee = (_fee * HOLDER_CUT_BPS) / 10_000;\n        uint256 shareCreatorFee = (_fee * CREATOR_CUT_BPS) / 10_000;\n        uint256 platformFee = _fee - shareHolderFee - shareCreatorFee;\n        shareData[_id].shareCreatorPool += shareCreatorFee;\n        if (_tokenCount > 0) {\n            shareData[_id].shareHolderRewardsPerTokenScaled += (shareHolderFee * 1e18) / _tokenCount;\n        } else {\n            // If there are no tokens in circulation, the fee goes to the platform\n            platformFee += shareHolderFee;\n        }\n        platformPool += platformFee;\n    }\n\n    /// @notice Restricts or unrestricts share creation\n    /// @param _isRestricted True if restricted, false if not\n    function restrictShareCreation(bool _isRestricted) external onlyOwner {\n        require(shareCreationRestricted != _isRestricted, \"State already set\");\n        shareCreationRestricted = _isRestricted;\n        emit ShareCreationRestricted(_isRestricted);\n    }\n\n    /// @notice Adds or removes an address from the whitelist of share creators\n    /// @param _address Address to add or remove\n    /// @param _isWhitelisted True if whitelisted, false if not\n    function changeShareCreatorWhitelist(address _address, bool _isWhitelisted) external onlyOwner {\n        require(whitelistedShareCreators[_address] != _isWhitelisted, \"State already set\");\n        whitelistedShareCreators[_address] = _isWhitelisted;\n    }\n}"
    }
  ]
}