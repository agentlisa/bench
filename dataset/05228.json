{
  "Title": "[L-03] Lack of `deadline` protection for swap",
  "Content": "There are 2 instances of these\n- https://github.com/code-423n4/2024-01-decent/blob/07ef78215e3d246d47a410651906287c6acec3ef/src/swappers/UniSwapper.sol#L153\n- https://github.com/code-423n4/2024-01-decent/blob/07ef78215e3d246d47a410651906287c6acec3ef/src/swappers/UniSwapper.sol#L130C13-L134C55\n\nThe `swapExactIn` and `swapExactOut` functions did not add `deadline` protection on swap. \nThis can allow a miner delay your transaction from being mined until the swap transaction incurs maximum slippage that would allow the miner profit from the swap transaction through sandwich attack.\n\nAccording to the Uniswap docs: \n\n>deadline: the unix time after which a swap will fail, to protect against long->pending transactions and wild swings in prices\n\nDuring high price swings, a miner can delay the transaction as possible until it incurs maximum slippage since there is no unix timestamp supplied at which the swap transaction must revert.\n```\nFile: Uniswapper.sol\nfunction swapExactIn(\n        SwapParams memory swapParams, // SwapParams is a struct\n        address receiver\n    ) public payable routerIsSet returns (uint256 amountOut) {\n        swapParams = _receiveAndWrapIfNeeded(swapParams);\n\n        IV3SwapRouter.ExactInputParams memory params = IV3SwapRouter\n            .ExactInputParams({\n                path: swapParams.path,\n                recipient: address(this),\n                amountIn: swapParams.amountIn,\n                amountOutMinimum: swapParams.amountOut\n            });//@audit no deadline specified.\n\n        IERC20(swapParams.tokenIn).approve(uniswap_router, swapParams.amountIn);\n        amountOut = IV3SwapRouter(uniswap_router).exactInput(params);\n\n```\n\n### Impact:\n\nLoss of asset through a combination of swap transaction delay and sandwich attack to profit from some slippage due to market swings.\n\n### Recommendation:\n\nAllow users to pass a `deadline` for example 20 minutes in the future at which a swap transaction must fail if it has not been executed.\n\nThis is handled by most swap frontends like Uniswap frontend. A user just gets to choose how many minutes in the future should be set as the `deadline` for the swap.\nThe user can select for example 20 minutes on the frontend and the frontend handles the calculation of the timestamp literal to be supplied to the swap function.\n\nFor example deadline is `unix timestamp` + `20 minutes`.\n \n`unix timestamp` = `number of seconds from 1970 till the current moment` = `block.timestamp`.\n`20 minutes` = 20 * 60.\n\ndeadline = 2578383 + 1800  = 2579583 seconds.\n \n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-01-decent",
  "Code": [
    {
      "filename": "src/swappers/UniSwapper.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {UTBOwned} from \"../UTBOwned.sol\";\nimport {SwapParams} from \"./SwapParams.sol\";\nimport {SwapDirection} from \"./SwapParams.sol\";\nimport {IERC20} from \"forge-std/interfaces/IERC20.sol\";\nimport {IWETH} from \"decent-bridge/src/interfaces/IWETH.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {ISwapper} from \"../UTB.sol\";\nimport {IV3SwapRouter} from \"@uniswap/swap-contracts/interfaces/IV3SwapRouter.sol\";\n\ncontract UniSwapper is UTBOwned, ISwapper {\n    constructor() UTBOwned() {}\n\n    uint8 public constant SWAPPER_ID = 0;\n    address public uniswap_router;\n    address payable public wrapped;\n\n    function setRouter(address _router) public onlyOwner {\n        uniswap_router = _router;\n    }\n\n    function setWrapped(address payable _wrapped) public onlyOwner {\n        wrapped = _wrapped;\n    }\n\n    function getId() public pure returns (uint8) {\n        return SWAPPER_ID;\n    }\n\n    function updateSwapParams(\n        SwapParams memory newSwapParams,\n        bytes memory payload\n    ) external pure returns (bytes memory) {\n        (, address receiver, address refund) = abi.decode(\n            payload,\n            (SwapParams, address, address)\n        );\n        return abi.encode(newSwapParams, receiver, refund);\n    }\n\n    function _refundUser(address user, address token, uint amount) private {\n        IERC20(token).transfer(user, amount);\n    }\n\n    function _sendToRecipient(\n        address recipient,\n        address token,\n        uint amount\n    ) private {\n        if (token == address(0)) {\n            token = wrapped;\n        }\n        IERC20(token).transfer(recipient, amount);\n    }\n\n    function swap(\n        bytes memory swapPayload\n    )\n        external\n        onlyUtb\n        returns (address tokenOut, uint256 amountOut)\n    {\n        (SwapParams memory swapParams, address receiver, address refund) = abi\n            .decode(swapPayload, (SwapParams, address, address));\n        tokenOut = swapParams.tokenOut;\n        if (swapParams.path.length == 0) {\n            return swapNoPath(swapParams, receiver, refund);\n        }\n        if (swapParams.direction == SwapDirection.EXACT_IN) {\n            amountOut = swapExactIn(swapParams, receiver);\n        } else {\n            swapExactOut(swapParams, receiver, refund);\n            amountOut = swapParams.amountOut;\n        }\n    }\n\n    function _receiveAndWrapIfNeeded(\n        SwapParams memory swapParams\n    ) private returns (SwapParams memory _swapParams) {\n        if (swapParams.tokenIn != address(0)) {\n            IERC20(swapParams.tokenIn).transferFrom(\n                msg.sender,\n                address(this),\n                swapParams.amountIn\n            );\n            return swapParams;\n        }\n        swapParams.tokenIn = wrapped;\n        IWETH(wrapped).deposit{value: swapParams.amountIn}();\n        return swapParams;\n    }\n\n    modifier routerIsSet() {\n        require(uniswap_router != address(0), \"router not set\");\n        _;\n    }\n\n    function swapNoPath(\n        SwapParams memory swapParams,\n        address receiver,\n        address refund\n    ) public payable returns (address tokenOut, uint256 amountOut) {\n        swapParams = _receiveAndWrapIfNeeded(swapParams);\n\n        if (swapParams.direction == SwapDirection.EXACT_OUT) {\n            _refundUser(\n                refund,\n                swapParams.tokenIn,\n                swapParams.amountIn - swapParams.amountOut\n            );\n        }\n\n        uint amt2Recipient = swapParams.direction == SwapDirection.EXACT_OUT\n            ? swapParams.amountOut\n            : swapParams.amountIn;\n\n        _sendToRecipient(receiver, swapParams.tokenOut, amt2Recipient);\n        return (swapParams.tokenOut, amt2Recipient);\n    }\n\n    function swapExactIn(\n        SwapParams memory swapParams, // SwapParams is a struct\n        address receiver\n    ) public payable routerIsSet returns (uint256 amountOut) {\n        swapParams = _receiveAndWrapIfNeeded(swapParams);\n\n        IV3SwapRouter.ExactInputParams memory params = IV3SwapRouter\n            .ExactInputParams({\n                path: swapParams.path,\n                recipient: address(this),\n                amountIn: swapParams.amountIn,\n                amountOutMinimum: swapParams.amountOut\n            });\n\n        IERC20(swapParams.tokenIn).approve(uniswap_router, swapParams.amountIn);\n        amountOut = IV3SwapRouter(uniswap_router).exactInput(params);\n\n        _sendToRecipient(receiver, swapParams.tokenOut, amountOut);\n    }\n\n    function swapExactOut(\n        SwapParams memory swapParams,\n        address receiver,\n        address refundAddress\n    ) public payable routerIsSet returns (uint256 amountIn) {\n        swapParams = _receiveAndWrapIfNeeded(swapParams);\n        IV3SwapRouter.ExactOutputParams memory params = IV3SwapRouter\n            .ExactOutputParams({\n                path: swapParams.path,\n                recipient: address(this),\n                //deadline: block.timestamp,\n                amountOut: swapParams.amountOut,\n                amountInMaximum: swapParams.amountIn\n            });\n\n        IERC20(swapParams.tokenIn).approve(uniswap_router, swapParams.amountIn);\n        amountIn = IV3SwapRouter(uniswap_router).exactOutput(params);\n\n        // refund sender\n        _refundUser(\n            refundAddress,\n            swapParams.tokenIn,\n            params.amountInMaximum - amountIn\n        );\n\n        _sendToRecipient(receiver, swapParams.tokenOut, swapParams.amountOut);\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n}"
    },
    {
      "filename": "src/swappers/UniSwapper.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {UTBOwned} from \"../UTBOwned.sol\";\nimport {SwapParams} from \"./SwapParams.sol\";\nimport {SwapDirection} from \"./SwapParams.sol\";\nimport {IERC20} from \"forge-std/interfaces/IERC20.sol\";\nimport {IWETH} from \"decent-bridge/src/interfaces/IWETH.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {ISwapper} from \"../UTB.sol\";\nimport {IV3SwapRouter} from \"@uniswap/swap-contracts/interfaces/IV3SwapRouter.sol\";\n\ncontract UniSwapper is UTBOwned, ISwapper {\n    constructor() UTBOwned() {}\n\n    uint8 public constant SWAPPER_ID = 0;\n    address public uniswap_router;\n    address payable public wrapped;\n\n    function setRouter(address _router) public onlyOwner {\n        uniswap_router = _router;\n    }\n\n    function setWrapped(address payable _wrapped) public onlyOwner {\n        wrapped = _wrapped;\n    }\n\n    function getId() public pure returns (uint8) {\n        return SWAPPER_ID;\n    }\n\n    function updateSwapParams(\n        SwapParams memory newSwapParams,\n        bytes memory payload\n    ) external pure returns (bytes memory) {\n        (, address receiver, address refund) = abi.decode(\n            payload,\n            (SwapParams, address, address)\n        );\n        return abi.encode(newSwapParams, receiver, refund);\n    }\n\n    function _refundUser(address user, address token, uint amount) private {\n        IERC20(token).transfer(user, amount);\n    }\n\n    function _sendToRecipient(\n        address recipient,\n        address token,\n        uint amount\n    ) private {\n        if (token == address(0)) {\n            token = wrapped;\n        }\n        IERC20(token).transfer(recipient, amount);\n    }\n\n    function swap(\n        bytes memory swapPayload\n    )\n        external\n        onlyUtb\n        returns (address tokenOut, uint256 amountOut)\n    {\n        (SwapParams memory swapParams, address receiver, address refund) = abi\n            .decode(swapPayload, (SwapParams, address, address));\n        tokenOut = swapParams.tokenOut;\n        if (swapParams.path.length == 0) {\n            return swapNoPath(swapParams, receiver, refund);\n        }\n        if (swapParams.direction == SwapDirection.EXACT_IN) {\n            amountOut = swapExactIn(swapParams, receiver);\n        } else {\n            swapExactOut(swapParams, receiver, refund);\n            amountOut = swapParams.amountOut;\n        }\n    }\n\n    function _receiveAndWrapIfNeeded(\n        SwapParams memory swapParams\n    ) private returns (SwapParams memory _swapParams) {\n        if (swapParams.tokenIn != address(0)) {\n            IERC20(swapParams.tokenIn).transferFrom(\n                msg.sender,\n                address(this),\n                swapParams.amountIn\n            );\n            return swapParams;\n        }\n        swapParams.tokenIn = wrapped;\n        IWETH(wrapped).deposit{value: swapParams.amountIn}();\n        return swapParams;\n    }\n\n    modifier routerIsSet() {\n        require(uniswap_router != address(0), \"router not set\");\n        _;\n    }\n\n    function swapNoPath(\n        SwapParams memory swapParams,\n        address receiver,\n        address refund\n    ) public payable returns (address tokenOut, uint256 amountOut) {\n        swapParams = _receiveAndWrapIfNeeded(swapParams);\n\n        if (swapParams.direction == SwapDirection.EXACT_OUT) {\n            _refundUser(\n                refund,\n                swapParams.tokenIn,\n                swapParams.amountIn - swapParams.amountOut\n            );\n        }\n\n        uint amt2Recipient = swapParams.direction == SwapDirection.EXACT_OUT\n            ? swapParams.amountOut\n            : swapParams.amountIn;\n\n        _sendToRecipient(receiver, swapParams.tokenOut, amt2Recipient);\n        return (swapParams.tokenOut, amt2Recipient);\n    }\n\n    function swapExactIn(\n        SwapParams memory swapParams, // SwapParams is a struct\n        address receiver\n    ) public payable routerIsSet returns (uint256 amountOut) {\n        swapParams = _receiveAndWrapIfNeeded(swapParams);\n\n        IV3SwapRouter.ExactInputParams memory params = IV3SwapRouter\n            .ExactInputParams({\n                path: swapParams.path,\n                recipient: address(this),\n                amountIn: swapParams.amountIn,\n                amountOutMinimum: swapParams.amountOut\n            });\n\n        IERC20(swapParams.tokenIn).approve(uniswap_router, swapParams.amountIn);\n        amountOut = IV3SwapRouter(uniswap_router).exactInput(params);\n\n        _sendToRecipient(receiver, swapParams.tokenOut, amountOut);\n    }\n\n    function swapExactOut(\n        SwapParams memory swapParams,\n        address receiver,\n        address refundAddress\n    ) public payable routerIsSet returns (uint256 amountIn) {\n        swapParams = _receiveAndWrapIfNeeded(swapParams);\n        IV3SwapRouter.ExactOutputParams memory params = IV3SwapRouter\n            .ExactOutputParams({\n                path: swapParams.path,\n                recipient: address(this),\n                //deadline: block.timestamp,\n                amountOut: swapParams.amountOut,\n                amountInMaximum: swapParams.amountIn\n            });\n\n        IERC20(swapParams.tokenIn).approve(uniswap_router, swapParams.amountIn);\n        amountIn = IV3SwapRouter(uniswap_router).exactOutput(params);\n\n        // refund sender\n        _refundUser(\n            refundAddress,\n            swapParams.tokenIn,\n            params.amountInMaximum - amountIn\n        );\n\n        _sendToRecipient(receiver, swapParams.tokenOut, swapParams.amountOut);\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n}"
    }
  ]
}