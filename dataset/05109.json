{
  "Title": "[G-03] Refactor the following function to reduce number of `SLOAD`",
  "Content": "\n**Instance 1:**\n\nRefactor the `WiseLending._healthStateCheck()` function such that the number of storage reads is reduced.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLending.sol#L77-#L90\n\nWe can make the `WiseLending._healthStateCheck()` function more gas efficient if we reduce the number of state reads in the function. We can do this by caching state variables that are read more than once into stack variables. The `powerFarmCheck` variable was read twice in the function we should instead read it once and cache its value into a stack variable then use the stack variable for subsequent reads for the variable. Implementing this would avoid `SLOAD`(warmaccess) `100` gas units and replace it with cheaper stack read. The diff below shows how the function should be refactored.\n\n```solidity\nfile: contracts/WiseLending.sol\n\n77:    function _healthStateCheck(\n78:        uint256 _nftId\n79:    )\n80:        private\n81:    {\n82:        _checkHealthState(\n83:            _nftId,\n84:            powerFarmCheck   //@audit 1st powerFarmCheck SLOAD\n85:        );\n86:\n87:        if (powerFarmCheck == true) {       //@audit 2nd powerFarmCheck SLOAD\n88:            powerFarmCheck = false;\n89:        }\n90:    }\n```\n\n```diff\ndiff --git a/contracts/WiseLending.sol b/contracts/WiseLending.sol\nindex 045678d..a35c653 100644\n--- a/contracts/WiseLending.sol\n+++ b/contracts/WiseLending.sol\n@@ -79,12 +79,13 @@ contract WiseLending is PoolManager {\n     )\n         private\n     {\n+        bool _powerFarmCheck = powerFarmCheck;\n         _checkHealthState(\n             _nftId,\n-            powerFarmCheck\n+            _powerFarmCheck\n         );\n\n-        if (powerFarmCheck == true) {\n+        if (_powerFarmCheck == true) {\n             powerFarmCheck = false;\n         }\n     }\n```\n\nEstimated gas saved: 97 gas units.\n\n**Instance 2:**\n\nRefactor the `PendlePowerFarmToken.addCompoundRewards()` function such that the number of storage reads is reduced.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L502-#L524\n\nWe can make the `PendlePowerFarmToken.addCompoundRewards()` function more gas efficient if we reduce the number of state reads in the function. We can do this by caching state variables that are read more than once into stack variables. The `PENDLE_POWER_FARM_CONTROLLER` variable was read twice in the function we should instead read it once and cache its value into a stack variable then use the stack variable for subsequent reads for the variable. Implementing this would avoid `SLOAD`(warmaccess) `100` gas units and replace it with cheaper stack read. The diff below shows how the function should be refactored:\n\n```solidity\nfile: contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\n\n502:    function addCompoundRewards(\n503:        uint256 _amount\n504:    )\n505:        external\n506:        syncSupply\n507:    {\n508:        if (_amount == 0) {\n509:            revert ZeroAmount();\n510:        }\n511:\n512:        totalLpAssetsToDistribute += _amount;\n513:\n514:        if (msg.sender == PENDLE_POWER_FARM_CONTROLLER) {   // @audit 1st PENDLE_POWER_FARM_CONTROLLER SLOAD\n515:            return;\n516:        }\n517:\n518:        _safeTransferFrom(\n519:            UNDERLYING_PENDLE_MARKET,\n520:            msg.sender,\n521:            PENDLE_POWER_FARM_CONTROLLER,      // @audit 1st PENDLE_POWER_FARM_CONTROLLER SLOAD\n522:            _amount\n523:        );\n524:    }\n```\n\n```diff\ndiff --git a/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol b/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\nindex 9f7bb58..2f13a79 100644\n--- a/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\n+++ b/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\n@@ -510,15 +510,15 @@ contract PendlePowerFarmToken is SimpleERC20, TransferHelper {\n         }\n\n         totalLpAssetsToDistribute += _amount;\n-\n-        if (msg.sender == PENDLE_POWER_FARM_CONTROLLER) {\n+        address _PENDLE_POWER_FARM_CONTROLLER = PENDLE_POWER_FARM_CONTROLLER;\n+        if (msg.sender == _PENDLE_POWER_FARM_CONTROLLER) {\n             return;\n         }\n\n         _safeTransferFrom(\n             UNDERLYING_PENDLE_MARKET,\n             msg.sender,\n-            PENDLE_POWER_FARM_CONTROLLER,\n+            _PENDLE_POWER_FARM_CONTROLLER,\n             _amount\n         );\n     }\n```\n\nEstimated gas saved: 97 gas units.\n\n**Instance 3:**\n\nRefactor the `PendlePowerFarmToken.withdrawExactShares()` function such that the number of storage reads is reduced.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L608-#L645\n\nWe can make the `PendlePowerFarmToken.withdrawExactShares()` function more gas efficient if we reduce the number of state reads in the function. We can do this by caching state variables that are read more than once into stack variables. The `underlyingLpAssetsCurrent` variable was read twice in the function we should instead read it once and cache its value into a stack variable then use the stack variable for subsequent reads for the variable. Implementing this would avoid `SLOAD`(warmaccess) `100` gas units and replace it with cheaper stack read. The diff below shows how the function should be refactored:\n\n```solidity\nfile: contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\n\n608:    function withdrawExactShares(\n609:        uint256 _shares\n610:    )\n611:        external\n612:        syncSupply\n613:        returns (uint256)\n614:    {\n615:        if (_shares == 0) {\n616:            revert ZeroAmount();\n617:        }\n618:\n619:        if (_shares > balanceOf(msg.sender)) {\n620:            revert InsufficientShares();\n621:        }\n622:\n623:        uint256 tokenAmount = previewAmountWithdrawShares(\n624:            _shares,\n625:            underlyingLpAssetsCurrent   // @audit underlyingLpAssetsCurrent 1st SLOAD\n626:        );\n627:\n628:        underlyingLpAssetsCurrent -= tokenAmount;   // @audit underlyingLpAssetsCurrent 2nd SLOAD\n629:\n630:        _burn(\n631:            msg.sender,\n632:            _shares\n633:        );\n634:\n635:        if (msg.sender == PENDLE_POWER_FARM_CONTROLLER) {\n636:            return tokenAmount;\n637:        }\n638:\n639:        _withdrawLp(\n640:            msg.sender,\n641:            tokenAmount\n642:        );\n643:\n644:        return tokenAmount;\n645:    }\n```\n\n```diff\ndiff --git a/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol b/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\nindex 9f7bb58..436d8be 100644\n--- a/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\n+++ b/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\n@@ -620,12 +620,14 @@ contract PendlePowerFarmToken is SimpleERC20, TransferHelper {\n             revert InsufficientShares();\n         }\n\n+        uint256 _underlyingLpAssetsCurrent = underlyingLpAssetsCurrent;\n+\n         uint256 tokenAmount = previewAmountWithdrawShares(\n             _shares,\n-            underlyingLpAssetsCurrent\n+            _underlyingLpAssetsCurrent\n         );\n\n-        underlyingLpAssetsCurrent -= tokenAmount;\n+        underlyingLpAssetsCurrent = _underlyingLpAssetsCurrent - tokenAmount;\n\n         _burn(\n             msg.sender,\n```\n\nEstimated gas saved: 97 gas units.\n\n**Instance 4:**\n\nRefactor the `PendlePowerFarmToken.withdrawExactAmount()` function such that the number of storage reads is reduced.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol#L647-#L680\n\nWe can make the `PendlePowerFarmToken.withdrawExactAmount()` function more gas efficient if we reduce the number of state reads in the function. We can do this by caching state variables that are read more than once into stack variables. The `underlyingLpAssetsCurrent` variable was read twice in the function we should instead read it once and cache its value into a stack variable then use the stack variable for subsequent reads for the variable. Implementing this would avoid `SLOAD`(warmaccess) `100` gas units and replace it with cheaper stack read. The diff below shows how the function should be refactored:\n\n```solidity\nfile: contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\n\n647:    function withdrawExactAmount(\n648:        uint256 _underlyingLpAssetAmount\n649:    )\n650:        external\n651:        syncSupply\n652:        returns (uint256)\n653:    {\n654:        if (_underlyingLpAssetAmount == 0) {\n655:            revert ZeroAmount();\n656:        }\n657:\n658:        uint256 shares = previewBurnShares(\n659:            _underlyingLpAssetAmount,\n660:            underlyingLpAssetsCurrent   // @audit underlyingLpAssetsCurrent 1st SLOAD\n661:        );\n662:\n663:        if (shares > balanceOf(msg.sender)) {\n664:            revert NotEnoughShares();\n665:        }\n666:\n667:        _burn(\n668:            msg.sender,\n669:            shares\n670:        );\n671:\n672:        underlyingLpAssetsCurrent -= _underlyingLpAssetAmount; // @audit underlyingLpAssetsCurrent 2nd SLOAD\n673:\n674:        _withdrawLp(\n675:            msg.sender,\n676:            _underlyingLpAssetAmount\n677:        );\n678:\n679:        return shares;\n680:    }\n```\n\n```diff\ndiff --git a/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol b/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\nindex 9f7bb58..5912c50 100644\n--- a/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\n+++ b/contracts/PowerFarms/PendlePowerFarmController/PendlePowerFarmToken.sol\n@@ -655,9 +655,10 @@ contract PendlePowerFarmToken is SimpleERC20, TransferHelper {\n             revert ZeroAmount();\n         }\n\n+        uint256 _underlyingLpAssetsCurrent = underlyingLpAssetsCurrent;\n         uint256 shares = previewBurnShares(\n             _underlyingLpAssetAmount,\n-            underlyingLpAssetsCurrent\n+            _underlyingLpAssetsCurrent\n         );\n\n         if (shares > balanceOf(msg.sender)) {\n@@ -669,7 +670,7 @@ contract PendlePowerFarmToken is SimpleERC20, TransferHelper {\n             shares\n         );\n\n-        underlyingLpAssetsCurrent -= _underlyingLpAssetAmount;\n+        underlyingLpAssetsCurrent = _underlyingLpAssetsCurrent - _underlyingLpAssetAmount;\n\n         _withdrawLp(\n             msg.sender,\n```\n\nEstimated gas saved: 97 gas units.\n\n**Instance 5:**\n\nRefactor the `FeeManager.claimOwnershipIncentiveMaster()` function such that the number of storage reads is reduced.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L194-#L208\n\nWe can make the `FeeManager.claimOwnershipIncentiveMaster()` function more gas efficient if we reduce the number of state reads in the function. We can do this by caching state variables that are read more than once into stack variables. The `proposedIncentiveMaster` variable was read twice in the function we should instead read it once and cache its value into a stack variable then use the stack variable for subsequent reads for the variable also the `proposedIncentiveMaster` was assigned to `incentiveMaster` which is also used in the event `ClaimedOwnershipIncentiveMaster` rather than using `incentiveMaster` in the event we should use the cached stack variable. Implementing this would avoid 2 `SLOAD`(warmaccess) `200` gas units and replace it with cheaper stack reads. The diff below shows how the function should be refactored:\n\n```solidity\nfile: contracts/FeeManager/FeeManager.sol\n\n194:    function claimOwnershipIncentiveMaster()\n195:        external\n196:    {\n197:        if (msg.sender != proposedIncentiveMaster) { // @audit proposedIncentiveMaster 1st SLOAD\n198:            revert NotAllowed();\n199:        }\n200:\n201:        incentiveMaster = proposedIncentiveMaster; // @audit proposedIncentiveMaster 2nd SLOAD\n202:        proposedIncentiveMaster = ZERO_ADDRESS;\n203:\n204:        emit ClaimedOwnershipIncentiveMaster(\n205:            incentiveMaster,\n206:            block.timestamp\n207:        );\n208:    }\n```\n\n```diff\ndiff --git a/contracts/FeeManager/FeeManager.sol b/contracts/FeeManager/FeeManager.sol\nindex f176113..1ef0ae7 100644\n--- a/contracts/FeeManager/FeeManager.sol\n+++ b/contracts/FeeManager/FeeManager.sol\n@@ -194,15 +194,16 @@ contract FeeManager is FeeManagerHelper {\n     function claimOwnershipIncentiveMaster()\n         external\n     {\n-        if (msg.sender != proposedIncentiveMaster) {\n+        address _proposedIncentiveMaster = proposedIncentiveMaster;\n+        if (msg.sender != _proposedIncentiveMaster) {\n             revert NotAllowed();\n         }\n\n-        incentiveMaster = proposedIncentiveMaster;\n+        incentiveMaster = _proposedIncentiveMaster;\n         proposedIncentiveMaster = ZERO_ADDRESS;\n\n         emit ClaimedOwnershipIncentiveMaster(\n-            incentiveMaster,\n+            _proposedIncentiveMaster,\n             block.timestamp\n         );\n     }\n```\n\nEstimated gas saved: 194 gas units.\n\n**Instance 6:**\n\nRefactor the `WiseOracleHub.getTokensFromUSD()` function such that the number of storage reads is reduced.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseOracleHub/WiseOracleHub.sol#L171-#L192\n\nWe can make the `WiseOracleHub.getTokensFromUSD()` function more gas efficient if we reduce the number of state reads in the function. We can do this by caching state variables that are read more than once into stack variables. The `_decimalsETH` variable was read twice in the function we should instead read it once and cache its value into a stack variable then use the stack variable for subsequent reads for the variable. Implementing this would avoid `SLOAD`(warmaccess) `100` gas units and replace it with cheaper stack read. The diff below shows how the function should be refactored:\n\n```solidity\nfile: contracts/WiseOracleHub/WiseOracleHub.sol\n\n171:    function getTokensFromUSD(\n172:        address _tokenAddress,\n173:        uint256 _usdValue\n174:    )\n175:        external\n176:        view\n177:        returns (uint256)\n178:    {\n179:        uint8 tokenDecimals = _tokenDecimals[\n180:            _tokenAddress\n181:        ];\n182:\n183:        return _decimalsETH < tokenDecimals  // @audit _decimalsETH 1st SLOAD\n184:            ? _usdValue\n185:                * 10 ** (tokenDecimals - _decimalsETH)    // @audit _decimalsETH 2nd SLOAD\n186:                * 10 ** decimals(_tokenAddress)\n187:                / latestResolver(_tokenAddress)\n188:            : _usdValue\n189:                * 10 ** decimals(_tokenAddress)\n190:                / latestResolver(_tokenAddress)\n191:                / 10 ** (_decimalsETH - tokenDecimals);  // @audit _decimalsETH 2nd SLOAD\n192:    }\n```\n\n```diff\ndiff --git a/contracts/WiseOracleHub/WiseOracleHub.sol b/contracts/WiseOracleHub/WiseOracleHub.sol\nindex 12fe0c8..8d08417 100644\n--- a/contracts/WiseOracleHub/WiseOracleHub.sol\n+++ b/contracts/WiseOracleHub/WiseOracleHub.sol\n@@ -179,16 +179,16 @@ contract WiseOracleHub is OracleHelper {\n         uint8 tokenDecimals = _tokenDecimals[\n             _tokenAddress\n         ];\n-\n-        return _decimalsETH < tokenDecimals\n+        uint8 decimalsEth = _decimalsETH;\n+        return decimalsEth < tokenDecimals\n             ? _usdValue\n-                * 10 ** (tokenDecimals - _decimalsETH)\n+                * 10 ** (tokenDecimals - decimalsEth)\n                 * 10 ** decimals(_tokenAddress)\n                 / latestResolver(_tokenAddress)\n             : _usdValue\n                 * 10 ** decimals(_tokenAddress)\n                 / latestResolver(_tokenAddress)\n-                / 10 ** (_decimalsETH - tokenDecimals);\n+                / 10 ** (decimalsEth - tokenDecimals);\n     }\n\n     /**\n```\n\nEstimated gas saved: 97 gas units.\n\n**Instance 7:**\n\nRefactor the `WiseOracleHub.getTokensFromETH()` function such that the number of storage reads is reduced.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseOracleHub/WiseOracleHub.sol#L327-#L352\n\nWe can make the `WiseOracleHub.getTokensFromETH()` function more gas efficient if we reduce the number of state reads in the function. We can do this by caching state variables that are read more than once into stack variables. The `_decimalsETH` variable was read twice in the function we should instead read it once and cache its value into a stack variable then use the stack variable for subsequent reads for the variable. Implementing this would avoid `SLOAD`(warmaccess) `100` gas units and replace it with cheaper stack read. The diff below shows how the function should be refactored:\n\n```solidity\nfile: contracts/WiseOracleHub/WiseOracleHub.sol\n\n327:    function getTokensFromETH(\n328:        address _tokenAddress,\n329:        uint256 _ethAmount\n330:    )\n331:        public\n332:        view\n333:        returns (uint256)\n334:    {\n335:        if (_tokenAddress == WETH_ADDRESS) {\n336:            return _ethAmount;\n337:        }\n338:\n339:        uint8 tokenDecimals = _tokenDecimals[\n340:            _tokenAddress\n341:        ];\n342:\n343:        return _decimalsETH < tokenDecimals       // @audit _decimalsETH 1st SLOAD\n344:            ? _ethAmount\n345:                * 10 ** (tokenDecimals - _decimalsETH)        // @audit _decimalsETH 2nd SLOAD\n346:                * 10 ** decimals(_tokenAddress)\n347:                / latestResolver(_tokenAddress)\n348:            : _ethAmount\n349:                * 10 ** decimals(_tokenAddress)\n350:                / latestResolver(_tokenAddress)\n351:                / 10 ** (_decimalsETH - tokenDecimals);   // @audit _decimalsETH 3rd SLOAD\n352:    }\n```\n\n```diff\ndiff --git a/contracts/WiseOracleHub/WiseOracleHub.sol b/contracts/WiseOracleHub/WiseOracleHub.sol\nindex 12fe0c8..78004fe 100644\n--- a/contracts/WiseOracleHub/WiseOracleHub.sol\n+++ b/contracts/WiseOracleHub/WiseOracleHub.sol\n@@ -339,16 +339,16 @@ contract WiseOracleHub is OracleHelper {\n         uint8 tokenDecimals = _tokenDecimals[\n             _tokenAddress\n         ];\n-\n-        return _decimalsETH < tokenDecimals\n+        uint8 decimalsEth = _decimalsETH;\n+        return decimalsEth < tokenDecimals\n             ? _ethAmount\n-                * 10 ** (tokenDecimals - _decimalsETH)\n+                * 10 ** (tokenDecimals - decimalsEth)\n                 * 10 ** decimals(_tokenAddress)\n                 / latestResolver(_tokenAddress)\n             : _ethAmount\n                 * 10 ** decimals(_tokenAddress)\n                 / latestResolver(_tokenAddress)\n-                / 10 ** (_decimalsETH - tokenDecimals);\n+                / 10 ** (decimalsEth - tokenDecimals);\n     }\n\n     /**\n```\n\nEstimated gas saved: 97 gas units.\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-02-wise-lending",
  "Code": [
    {
      "filename": "contracts/WiseLending.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\n/**\n * @author RenÃ© Hochmuth\n * @author Christoph Krpoun\n * @author Vitally Marinchenko\n */\n\nimport \"./PoolManager.sol\";\n\n/**\n * @dev WISE lending is an automated lending platform on which users can collateralize\n * their assets and borrow tokens against them.\n *\n * Users need to pay borrow rates for debt tokens, which are reflected in a borrow APY for\n * each asset type (pool). This borrow rate is variable over time and determined through the\n * utilization of the pool. The bounding curve is a family of different bonding curves adjusted\n * automatically by LASA (Lending Automated Scaling Algorithm). For more information, see:\n * [https://wisesoft.gitbook.io/wise/wise-lending-protocol/lasa-ai]\n *\n * In addition to normal deposit, withdraw, borrow, and payback functions, there are other\n * interacting modes:\n *\n * - Solely deposit and withdraw allows the user to keep their funds private, enabling\n *    them to withdraw even when the pools are borrowed empty.\n *\n * - Aave pools  allow for maximal capital efficiency by earning aave supply APY for not\n *   borrowed funds.\n *\n * - Special curve pools nside beefy farms can be used as collateral, opening up new usage\n *   possibilities for these asset types.\n *\n * - Users can pay back their borrow with lending shares of the same asset type, making it\n *   easier to manage their positions.\n *\n * - Users save their collaterals and borrows inside a position NFT, making it possible\n *   to trade their whole positions or use them in second-layer contracts\n *   (e.g., spot trading with PTP NFT trading platforms).\n */\n\ncontract WiseLending is PoolManager {\n\n    /**\n     * @dev Standard receive functions forwarding\n     * directly send ETH to the master address.\n     */\n    receive()\n        external\n        payable\n    {\n        if (msg.sender == WETH_ADDRESS) {\n            return;\n        }\n\n        _sendValue(\n            master,\n            msg.value\n        );\n    }\n\n    /**\n     * @dev Checks if position is healthy\n     * after all state changes are done.\n     */\n    modifier healthStateCheck(\n        uint256 _nftId\n    ) {\n        _;\n\n        _healthStateCheck(\n            _nftId\n        );\n    }\n\n    function _healthStateCheck(\n        uint256 _nftId\n    )\n        private\n    {\n        _checkHealthState(\n            _nftId,\n            powerFarmCheck\n        );\n\n        if (powerFarmCheck == true) {\n            powerFarmCheck = false;\n        }\n    }\n\n    /**\n     * @dev Runs the LASA algorithm known as\n     * Lending Automated Scaling Algorithm\n     * and updates pool data based on token\n     */\n    modifier syncPool(\n        address _poolToken\n    ) {\n        (\n            uint256 lendSharePrice,\n            uint256 borrowSharePrice\n        ) = _syncPoolBeforeCodeExecution(\n            _poolToken\n        );\n\n        _;\n\n        _syncPoolAfterCodeExecution(\n            _poolToken,\n            lendSharePrice,\n            borrowSharePrice\n        );\n    }\n\n    constructor(\n        address _master,\n        address _wiseOracleHubAddress,\n        address _nftContract\n    )\n        WiseLendingDeclaration(\n            _master,\n            _wiseOracleHubAddress,\n            _nftContract\n        )\n    {}\n\n    function _emitFundsSolelyWithdrawn(\n        address _caller,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        private\n    {\n        emit FundsSolelyWithdrawn(\n            _caller,\n            _nftId,\n            _poolToken,\n            _amount,\n            block.timestamp\n        );\n    }\n\n    function _emitFundsSolelyDeposited(\n        address _caller,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        private\n    {\n        emit FundsSolelyDeposited(\n            _caller,\n            _nftId,\n            _poolToken,\n            _amount,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Fetches share price of lending shares.\n     */\n    function _getSharePrice(\n        address _poolToken\n    )\n        private\n        view\n        returns (\n            uint256,\n            uint256\n        )\n    {\n        uint256 borrowSharePrice = borrowPoolData[_poolToken].pseudoTotalBorrowAmount\n            * PRECISION_FACTOR_E18\n            / borrowPoolData[_poolToken].totalBorrowShares;\n\n        _validateParameter(\n            MIN_BORROW_SHARE_PRICE,\n            borrowSharePrice\n        );\n\n        return (\n            lendingPoolData[_poolToken].pseudoTotalPool\n                * PRECISION_FACTOR_E18\n                / lendingPoolData[_poolToken].totalDepositShares,\n            borrowSharePrice\n        );\n    }\n\n    function _checkHealthState(\n        uint256 _nftId,\n        bool _powerFarm\n    )\n        internal\n        view\n    {\n        WISE_SECURITY.checkHealthState(\n            _nftId,\n            _powerFarm\n        );\n    }\n\n    /**\n     * @dev Compares share prices before and after\n     * execution. If borrow share price increased\n     * or lending share price decreased, revert.\n     */\n    function _compareSharePrices(\n        address _poolToken,\n        uint256 _lendSharePriceBefore,\n        uint256 _borrowSharePriceBefore\n    )\n        private\n        view\n    {\n        (\n            uint256 lendSharePriceAfter,\n            uint256 borrowSharePriceAfter\n        ) = _getSharePrice(\n            _poolToken\n        );\n\n        uint256 currentSharePriceMax = _getCurrentSharePriceMax(\n            _poolToken\n        );\n\n        _validateParameter(\n            _lendSharePriceBefore,\n            lendSharePriceAfter\n        );\n\n        _validateParameter(\n            lendSharePriceAfter,\n            currentSharePriceMax\n        );\n\n        _validateParameter(\n            _borrowSharePriceBefore,\n            currentSharePriceMax\n        );\n\n        _validateParameter(\n            borrowSharePriceAfter,\n            _borrowSharePriceBefore\n        );\n    }\n\n    /**\n    * @dev Since pool inception share price\n    * increase for both lending and borrow shares\n    * is capped at 500% apr max in between a transaction.\n    */\n    function _getCurrentSharePriceMax(\n        address _poolToken\n    )\n        private\n        view\n        returns (uint256)\n    {\n        uint256 timeDifference = block.timestamp\n            - timestampsPoolData[_poolToken].initialTimeStamp;\n\n        return timeDifference\n            * RESTRICTION_FACTOR\n            + PRECISION_FACTOR_E18;\n    }\n\n    /**\n     * @dev First part of pool sync updating pseudo\n     * amounts. Is skipped when powerFarms or aaveHub\n     * is calling the function.\n     */\n    function _syncPoolBeforeCodeExecution(\n        address _poolToken\n    )\n        private\n        returns (\n            uint256 lendSharePrice,\n            uint256 borrowSharePrice\n        )\n    {\n        _checkReentrancy();\n\n        _preparePool(\n            _poolToken\n        );\n\n        if (_aboveThreshold(_poolToken) == true) {\n            _scalingAlgorithm(\n                _poolToken\n            );\n        }\n\n        (\n            lendSharePrice,\n            borrowSharePrice\n        ) = _getSharePrice(\n            _poolToken\n        );\n    }\n\n    /**\n     * @dev Second part of pool sync updating\n     * the borrow pool rate and share price.\n     */\n    function _syncPoolAfterCodeExecution(\n        address _poolToken,\n        uint256 _lendSharePriceBefore,\n        uint256 _borrowSharePriceBefore\n    )\n        private\n    {\n        _newBorrowRate(\n            _poolToken\n        );\n\n        _compareSharePrices(\n            _poolToken,\n            _lendSharePriceBefore,\n            _borrowSharePriceBefore\n        );\n    }\n\n    /**\n     * @dev Enables _poolToken to be used as a collateral.\n     */\n    function collateralizeDeposit(\n        uint256 _nftId,\n        address _poolToken\n    )\n        external\n        syncPool(_poolToken)\n    {\n        WISE_SECURITY.checksCollateralizeDeposit(\n            _nftId,\n            msg.sender,\n            _poolToken\n        );\n\n        userLendingData[_nftId][_poolToken].unCollateralized = false;\n    }\n\n    /**\n     * @dev Disables _poolToken to be used as a collateral.\n     */\n    function unCollateralizeDeposit(\n        uint256 _nftId,\n        address _poolToken\n    )\n        external\n        syncPool(_poolToken)\n    {\n        _checkOwnerPosition(\n            _nftId,\n            msg.sender\n        );\n\n        (\n            address[] memory lendTokens,\n            address[] memory borrowTokens\n        ) = _prepareAssociatedTokens(\n            _nftId,\n            _poolToken,\n            ZERO_ADDRESS\n        );\n\n        userLendingData[_nftId][_poolToken].unCollateralized = true;\n\n        WISE_SECURITY.checkUncollateralizedDeposit(\n            _nftId,\n            _poolToken\n        );\n\n        _curveSecurityChecks(\n            lendTokens,\n            borrowTokens\n        );\n    }\n\n    // --------------- Deposit Functions -------------\n\n    /**\n     * @dev Allows to supply funds using ETH.\n     * Without converting to WETH, use ETH directly.\n     */\n    function depositExactAmountETH(\n        uint256 _nftId\n    )\n        external\n        payable\n        syncPool(WETH_ADDRESS)\n        returns (uint256)\n    {\n        return _depositExactAmountETH(\n            _nftId\n        );\n    }\n\n    function _depositExactAmountETH(\n        uint256 _nftId\n    )\n        private\n        returns (uint256)\n    {\n        uint256 shareAmount = _handleDeposit(\n            msg.sender,\n            _nftId,\n            WETH_ADDRESS,\n            msg.value\n        );\n\n        _wrapETH(\n            msg.value\n        );\n\n        return shareAmount;\n    }\n\n    /**\n     * @dev Allows to supply funds using ETH.\n     * Without converting to WETH, use ETH directly,\n     * also mints position to avoid extra transaction.\n     */\n    function depositExactAmountETHMint()\n        external\n        payable\n        syncPool(WETH_ADDRESS)\n        returns (uint256)\n    {\n        return _depositExactAmountETH(\n            _reservePosition()\n        );\n    }\n\n    /**\n     * @dev Allows to supply _poolToken and user\n     * can decide if _poolToken should be collateralized,\n     * also mints position to avoid extra transaction.\n     */\n    function depositExactAmountMint(\n        address _poolToken,\n        uint256 _amount\n    )\n        external\n        returns (uint256)\n    {\n        return depositExactAmount(\n            _reservePosition(),\n            _poolToken,\n            _amount\n        );\n    }\n\n    /**\n     * @dev Allows to supply _poolToken and user\n     * can decide if _poolToken should be collateralized.\n     */\n    function depositExactAmount(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        public\n        syncPool(_poolToken)\n        returns (uint256)\n    {\n        uint256 shareAmount = _handleDeposit(\n            msg.sender,\n            _nftId,\n            _poolToken,\n            _amount\n        );\n\n        _safeTransferFrom(\n            _poolToken,\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        return shareAmount;\n    }\n\n    /**\n     * @dev Allows to supply funds using ETH in solely mode,\n     * which does not earn APY, but keeps the funds private.\n     * Other users are restricted from borrowing these funds,\n     * owner can always withdraw even if all funds are borrowed.\n     * Also mints position to avoid extra transaction.\n     */\n    function solelyDepositETHMint()\n        external\n        payable\n    {\n        solelyDepositETH(\n            _reservePosition()\n        );\n    }\n\n    /**\n     * @dev Allows to supply funds using ETH in solely mode,\n     * which does not earn APY, but keeps the funds private.\n     * Other users are restricted from borrowing these funds,\n     * owner can always withdraw even if all funds are borrowed.\n     */\n    function solelyDepositETH(\n        uint256 _nftId\n    )\n        public\n        payable\n        syncPool(WETH_ADDRESS)\n    {\n        _handleSolelyDeposit(\n            msg.sender,\n            _nftId,\n            WETH_ADDRESS,\n            msg.value\n        );\n\n        _wrapETH(\n            msg.value\n        );\n\n        _emitFundsSolelyDeposited(\n            msg.sender,\n            _nftId,\n            WETH_ADDRESS,\n            msg.value\n        );\n    }\n\n    /**\n     * @dev Core function combining\n     * supply logic with security\n     * checks for solely deposit.\n     */\n    function _handleSolelyDeposit(\n        address _caller,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        private\n    {\n        _checkDeposit(\n            _nftId,\n            _caller,\n            _poolToken,\n            _amount\n        );\n\n        _increaseMappingValue(\n            pureCollateralAmount,\n            _nftId,\n            _poolToken,\n            _amount\n        );\n\n        _increaseTotalBareToken(\n            _poolToken,\n            _amount\n        );\n\n        _addPositionTokenData(\n            _nftId,\n            _poolToken,\n            hashMapPositionLending,\n            positionLendTokenData\n        );\n    }\n\n    /**\n     * @dev Allows to supply funds using ERC20 in solely mode,\n     * which does not earn APY, but keeps the funds private.\n     * Other users are restricted from borrowing these funds,\n     * owner can always withdraw even if all funds are borrowed.\n     * Also mints position to avoid extra transaction.\n     */\n    function solelyDepositMint(\n        address _poolToken,\n        uint256 _amount\n    )\n        external\n    {\n        solelyDeposit(\n            _reservePosition(),\n            _poolToken,\n            _amount\n        );\n    }\n\n    /**\n     * @dev Allows to supply funds using ERC20 in solely mode,\n     * which does not earn APY, but keeps the funds private.\n     * Other users are restricted from borrowing these funds,\n     * owner can always withdraw even if all funds are borrowed.\n     */\n    function solelyDeposit(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        public\n        syncPool(_poolToken)\n    {\n        _handleSolelyDeposit(\n            msg.sender,\n            _nftId,\n            _poolToken,\n            _amount\n        );\n\n        _emitFundsSolelyDeposited(\n            msg.sender,\n            _nftId,\n            _poolToken,\n            _amount\n        );\n\n        _safeTransferFrom(\n            _poolToken,\n            msg.sender,\n            address(this),\n            _amount\n        );\n    }\n\n    // --------------- Withdraw Functions -------------\n\n    /**\n     * @dev Allows to withdraw publicly\n     * deposited ETH funds using exact amount.\n     */\n    function withdrawExactAmountETH(\n        uint256 _nftId,\n        uint256 _amount\n    )\n        external\n        syncPool(WETH_ADDRESS)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        uint256 withdrawShares = _handleWithdrawAmount(\n            {\n                _caller: msg.sender,\n                _nftId: _nftId,\n                _poolToken: WETH_ADDRESS,\n                _amount: _amount,\n                _onBehalf: false\n            }\n        );\n\n        _validateNonZero(\n            withdrawShares\n        );\n\n        _unwrapETH(\n            _amount\n        );\n\n        _sendValue(\n            msg.sender,\n            _amount\n        );\n\n        return withdrawShares;\n    }\n\n    /**\n     * @dev Allows to withdraw publicly\n     * deposited ETH funds using exact shares.\n     */\n    function withdrawExactSharesETH(\n        uint256 _nftId,\n        uint256 _shares\n    )\n        external\n        syncPool(WETH_ADDRESS)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        uint256 withdrawAmount = _handleWithdrawShares(\n            {\n                _caller: msg.sender,\n                _nftId: _nftId,\n                _poolToken: WETH_ADDRESS,\n                _shares: _shares,\n                _onBehalf: false\n            }\n        );\n\n        _validateNonZero(\n            withdrawAmount\n        );\n\n        _unwrapETH(\n            withdrawAmount\n        );\n\n        _sendValue(\n            msg.sender,\n            withdrawAmount\n        );\n\n        return withdrawAmount;\n    }\n\n    /**\n     * @dev Allows to withdraw publicly\n     * deposited ERC20 funds using exact amount.\n     */\n    function withdrawExactAmount(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _withdrawAmount\n    )\n        external\n        syncPool(_poolToken)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        uint256 withdrawShares = _handleWithdrawAmount(\n            {\n                _caller: msg.sender,\n                _nftId: _nftId,\n                _poolToken: _poolToken,\n                _amount: _withdrawAmount,\n                _onBehalf: false\n            }\n        );\n\n        _validateNonZero(\n            withdrawShares\n        );\n\n        _safeTransfer(\n            _poolToken,\n            msg.sender,\n            _withdrawAmount\n        );\n\n        return withdrawShares;\n    }\n\n    /**\n     * @dev Allows to withdraw privately\n     * deposited ETH funds using input amount.\n     */\n    function solelyWithdrawETH(\n        uint256 _nftId,\n        uint256 _withdrawAmount\n    )\n        external\n        syncPool(WETH_ADDRESS)\n        healthStateCheck(_nftId)\n    {\n        _handleSolelyWithdraw(\n            msg.sender,\n            _nftId,\n            WETH_ADDRESS,\n            _withdrawAmount\n        );\n\n        _unwrapETH(\n            _withdrawAmount\n        );\n\n        _sendValue(\n            msg.sender,\n            _withdrawAmount\n        );\n    }\n\n    /**\n     * @dev Allows to withdraw privately\n     * deposited ERC20 funds using input amount.\n     */\n    function solelyWithdraw(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _withdrawAmount\n    )\n        external\n        syncPool(_poolToken)\n        healthStateCheck(_nftId)\n    {\n        _handleSolelyWithdraw(\n            msg.sender,\n            _nftId,\n            _poolToken,\n            _withdrawAmount\n        );\n\n        _safeTransfer(\n            _poolToken,\n            msg.sender,\n            _withdrawAmount\n        );\n    }\n\n    /**\n     * @dev Core function combining\n     * withdraw logic for solely\n     * withdraw with security checks.\n     */\n    function _coreSolelyWithdraw(\n        address _caller,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        private\n    {\n        (\n            address[] memory lendTokens,\n            address[] memory borrowTokens\n        ) = _prepareAssociatedTokens(\n            _nftId,\n            _poolToken,\n            ZERO_ADDRESS\n        );\n\n        powerFarmCheck = WISE_SECURITY.checksSolelyWithdraw(\n            _nftId,\n            _caller,\n            _poolToken\n        );\n\n        _decreasePositionMappingValue(\n            pureCollateralAmount,\n            _nftId,\n            _poolToken,\n            _amount\n        );\n\n        _decreaseTotalBareToken(\n            _poolToken,\n            _amount\n        );\n\n        _removeEmptyLendingData(\n            _nftId,\n            _poolToken\n        );\n\n        _curveSecurityChecks(\n            lendTokens,\n            borrowTokens\n        );\n    }\n\n    /**\n     * @dev Allows to withdraw privately\n     * deposited ERC20 on behalf of owner.\n     * Requires approval by _nftId owner.\n     */\n    function withdrawOnBehalfExactAmount(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _withdrawAmount\n    )\n        external\n        onlyAaveHub\n        syncPool(_poolToken)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        uint256 withdrawShares = calculateLendingShares(\n            {\n                _poolToken: _poolToken,\n                _amount: _withdrawAmount,\n                _maxSharePrice: true\n            }\n        );\n\n        _coreWithdrawToken(\n            {\n                _caller: msg.sender,\n                _nftId: _nftId,\n                _poolToken: _poolToken,\n                _amount: _withdrawAmount,\n                _shares: withdrawShares,\n                _onBehalf: true\n            }\n        );\n\n        _safeTransfer(\n            _poolToken,\n            msg.sender,\n            _withdrawAmount\n        );\n\n        return withdrawShares;\n    }\n\n    /**\n     * @dev Allows to withdraw ERC20\n     * funds using shares as input value\n     */\n    function withdrawExactShares(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _shares\n    )\n        external\n        syncPool(_poolToken)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        uint256 withdrawAmount = _handleWithdrawShares(\n            {\n                _caller: msg.sender,\n                _nftId: _nftId,\n                _poolToken: _poolToken,\n                _shares: _shares,\n                _onBehalf: false\n            }\n        );\n\n        _validateNonZero(\n            withdrawAmount\n        );\n\n        _safeTransfer(\n            _poolToken,\n            msg.sender,\n            withdrawAmount\n        );\n\n        return withdrawAmount;\n    }\n\n    /**\n     * @dev Withdraws ERC20 funds on behalf\n     * of _nftId owner, requires approval.\n     */\n    function withdrawOnBehalfExactShares(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _shares\n    )\n        external\n        onlyAaveHub\n        syncPool(_poolToken)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        uint256 withdrawAmount = _handleWithdrawShares(\n            {\n                _caller: msg.sender,\n                _nftId: _nftId,\n                _poolToken: _poolToken,\n                _shares: _shares,\n                _onBehalf: true\n            }\n        );\n\n        _safeTransfer(\n            _poolToken,\n            msg.sender,\n            withdrawAmount\n        );\n\n        return withdrawAmount;\n    }\n\n    // --------------- Borrow Functions -------------\n\n    /**\n     * @dev Allows to borrow ETH funds\n     * Requires user to have collateral.\n     */\n    function borrowExactAmountETH(\n        uint256 _nftId,\n        uint256 _amount\n    )\n        external\n        syncPool(WETH_ADDRESS)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        _checkOwnerPosition(\n            _nftId,\n            msg.sender\n        );\n\n        uint256 shares = _handleBorrowExactAmount({\n            _nftId: _nftId,\n            _poolToken: WETH_ADDRESS,\n            _amount: _amount,\n            _onBehalf: false\n        });\n\n        _validateNonZero(\n            shares\n        );\n\n        _unwrapETH(\n            _amount\n        );\n\n        _sendValue(\n            msg.sender,\n            _amount\n        );\n\n        return shares;\n    }\n\n    /**\n     * @dev Allows to borrow ERC20 funds\n     * Requires user to have collateral.\n     */\n    function borrowExactAmount(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        external\n        syncPool(_poolToken)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        _checkOwnerPosition(\n            _nftId,\n            msg.sender\n        );\n\n        uint256 shares = _handleBorrowExactAmount({\n            _nftId: _nftId,\n            _poolToken: _poolToken,\n            _amount: _amount,\n            _onBehalf: false\n        });\n\n        _validateNonZero(\n            shares\n        );\n\n        _safeTransfer(\n            _poolToken,\n            msg.sender,\n            _amount\n        );\n\n        return shares;\n    }\n\n    /**\n     * @dev Allows to borrow ERC20 funds\n     * on behalf of _nftId owner, if approved.\n     */\n    function borrowOnBehalfExactAmount(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        external\n        onlyAaveHub\n        syncPool(_poolToken)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        uint256 shares = _handleBorrowExactAmount({\n            _nftId: _nftId,\n            _poolToken: _poolToken,\n            _amount: _amount,\n            _onBehalf: true\n        });\n\n        _safeTransfer(\n            _poolToken,\n            msg.sender,\n            _amount\n        );\n\n        return shares;\n    }\n\n    // --------------- Payback Functions ------------\n\n    /**\n     * @dev Ability to payback ETH loans\n     * by providing exact payback amount.\n     */\n    function paybackExactAmountETH(\n        uint256 _nftId\n    )\n        external\n        payable\n        syncPool(WETH_ADDRESS)\n        returns (uint256)\n    {\n        uint256 maxBorrowShares = userBorrowShares[_nftId][WETH_ADDRESS];\n\n        _validateNonZero(\n            maxBorrowShares\n        );\n\n        uint256 maxPaybackAmount = paybackAmount(\n            WETH_ADDRESS,\n            maxBorrowShares\n        );\n\n        uint256 paybackShares = calculateBorrowShares(\n            {\n                _poolToken: WETH_ADDRESS,\n                _amount: msg.value,\n                _maxSharePrice: false\n            }\n        );\n\n        _validateNonZero(\n            paybackShares\n        );\n\n        uint256 refundAmount;\n        uint256 requiredAmount = msg.value;\n\n        if (msg.value > maxPaybackAmount) {\n\n            unchecked {\n                refundAmount = msg.value\n                    - maxPaybackAmount;\n            }\n\n            requiredAmount = requiredAmount\n                - refundAmount;\n\n            paybackShares = maxBorrowShares;\n        }\n\n        _handlePayback(\n            msg.sender,\n            _nftId,\n            WETH_ADDRESS,\n            requiredAmount,\n            paybackShares\n        );\n\n        _wrapETH(\n            requiredAmount\n        );\n\n        if (refundAmount > 0) {\n            _sendValue(\n                msg.sender,\n                refundAmount\n            );\n        }\n\n        return paybackShares;\n    }\n\n    /**\n     * @dev Ability to payback ERC20 loans\n     * by providing exact payback amount.\n     */\n    function paybackExactAmount(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        external\n        syncPool(_poolToken)\n        returns (uint256)\n    {\n        uint256 paybackShares = calculateBorrowShares(\n            {\n                _poolToken: _poolToken,\n                _amount: _amount,\n                _maxSharePrice: false\n            }\n        );\n\n        _validateNonZero(\n            paybackShares\n        );\n\n        _handlePayback(\n            msg.sender,\n            _nftId,\n            _poolToken,\n            _amount,\n            paybackShares\n        );\n\n        _safeTransferFrom(\n            _poolToken,\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        return paybackShares;\n    }\n\n    /**\n     * @dev Ability to payback ERC20 loans\n     * by providing exact payback shares.\n     */\n    function paybackExactShares(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _shares\n    )\n        external\n        syncPool(_poolToken)\n        returns (uint256)\n    {\n        uint256 repaymentAmount = paybackAmount(\n            _poolToken,\n            _shares\n        );\n\n        _validateNonZero(\n            repaymentAmount\n        );\n\n        _handlePayback(\n            msg.sender,\n            _nftId,\n            _poolToken,\n            repaymentAmount,\n            _shares\n        );\n\n        _safeTransferFrom(\n            _poolToken,\n            msg.sender,\n            address(this),\n            repaymentAmount\n        );\n\n        return repaymentAmount;\n    }\n\n    // --------------- Liquidation Functions ------------\n\n    /**\n     * @dev Function to liquidate a postion which reaches\n     * a debt ratio greater than 100%. The liquidator can choose\n     * token to payback and receive. (Both can differ!). The\n     * amount is in shares of the payback token. The liquidator\n     * gets an incentive which is calculated inside the liquidation\n     * logic.\n     */\n    function liquidatePartiallyFromTokens(\n        uint256 _nftId,\n        uint256 _nftIdLiquidator,\n        address _paybackToken,\n        address _receiveToken,\n        uint256 _shareAmountToPay\n    )\n        external\n        syncPool(_paybackToken)\n        syncPool(_receiveToken)\n        returns (uint256)\n    {\n        CoreLiquidationStruct memory data;\n\n        data.nftId = _nftId;\n        data.nftIdLiquidator = _nftIdLiquidator;\n\n        data.caller = msg.sender;\n\n        data.tokenToPayback = _paybackToken;\n        data.tokenToRecieve = _receiveToken;\n        data.shareAmountToPay = _shareAmountToPay;\n\n        data.maxFeeETH = WISE_SECURITY.maxFeeETH();\n        data.baseRewardLiquidation = WISE_SECURITY.baseRewardLiquidation();\n\n        (\n            data.lendTokens,\n            data.borrowTokens\n        ) = _prepareAssociatedTokens(\n            _nftId,\n            _receiveToken,\n            _paybackToken\n        );\n\n        data.paybackAmount = paybackAmount(\n            _paybackToken,\n            _shareAmountToPay\n        );\n\n        _checkPositionLocked(\n            _nftId,\n            msg.sender\n        );\n\n        _checkLiquidatorNft(\n            _nftId,\n            _nftIdLiquidator\n        );\n\n        WISE_SECURITY.checksLiquidation(\n            _nftId,\n            _paybackToken,\n            _shareAmountToPay\n        );\n\n        return _coreLiquidation(\n            data\n        );\n    }\n\n    /**\n     * @dev Wrapper function for liqudaiton flow\n     */\n    function coreLiquidationIsolationPools(\n        uint256 _nftId,\n        uint256 _nftIdLiquidator,\n        address _caller,\n        address _paybackToken,\n        address _receiveToken,\n        uint256 _paybackAmount,\n        uint256 _shareAmountToPay\n    )\n        external\n        syncPool(_paybackToken)\n        syncPool(_receiveToken)\n        returns (uint256)\n    {\n        CoreLiquidationStruct memory data;\n\n        data.nftId = _nftId;\n        data.nftIdLiquidator = _nftIdLiquidator;\n\n        data.caller = _caller;\n\n        data.paybackAmount = _paybackAmount;\n        data.tokenToPayback = _paybackToken;\n        data.tokenToRecieve = _receiveToken;\n        data.shareAmountToPay = _shareAmountToPay;\n\n        data.maxFeeETH = WISE_SECURITY.maxFeeFarmETH();\n        data.baseRewardLiquidation = WISE_SECURITY.baseRewardLiquidationFarm();\n\n        _validateIsolationPoolLiquidation(\n            msg.sender,\n            data.nftId,\n            data.nftIdLiquidator\n        );\n\n        (\n            data.lendTokens,\n            data.borrowTokens\n        ) = _prepareAssociatedTokens(\n            data.nftId,\n            data.tokenToRecieve,\n            data.tokenToPayback\n        );\n\n        return _coreLiquidation(\n            data\n        );\n    }\n\n    /**\n     * @dev Allows to sync pool manually\n     * so that the pool is up to date.\n     */\n    function syncManually(\n        address _poolToken\n    )\n        external\n        syncPool(_poolToken)\n    {\n        address[] memory tokens = new address[](1);\n        tokens[0] = _poolToken;\n\n        _curveSecurityChecks(\n            new address[](0),\n            tokens\n        );\n    }\n\n    /**\n     * @dev Registers position _nftId\n     * for isolation pool functionality\n     */\n    function setRegistrationIsolationPool(\n        uint256 _nftId,\n        bool _registerState\n    )\n        external\n    {\n        _onlyIsolationPool(\n            msg.sender\n        );\n\n        _validateZero(\n            WISE_SECURITY.overallETHCollateralsBare(_nftId)\n        );\n\n        _validateZero(\n            WISE_SECURITY.overallETHBorrowBare(_nftId)\n        );\n\n        positionLocked[_nftId] = _registerState;\n    }\n\n    /**\n    * @dev External wrapper for\n    * {_corePayback} logic callable\n    * by feeMananger.\n    */\n    function corePaybackFeeManager(\n        address _poolToken,\n        uint256 _nftId,\n        uint256 _amount,\n        uint256 _shares\n    )\n        external\n        onlyFeeManager\n        syncPool(_poolToken)\n    {\n        _corePayback(\n            _nftId,\n            _poolToken,\n            _amount,\n            _shares\n        );\n    }\n\n    /**\n     * @dev Internal function combining payback\n     * logic and emit of an event.\n     */\n    function _handlePayback(\n        address _caller,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount,\n        uint256 _shares\n    )\n        private\n    {\n        _corePayback(\n            _nftId,\n            _poolToken,\n            _amount,\n            _shares\n        );\n\n        emit FundsReturned(\n            _caller,\n            _poolToken,\n            _nftId,\n            _amount,\n            _shares,\n            block.timestamp\n        );\n    }\n\n    function _handleWithdrawAmount(\n        address _caller,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount,\n        bool _onBehalf\n    )"
    }
  ]
}