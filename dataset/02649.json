{
  "Title": "M-6: Dangerous assumption on the peg of USDC can lead to manipulations",
  "Content": "# Issue M-6: Dangerous assumption on the peg of USDC can lead to manipulations \n\nSource: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/224 \n\n## Found by \nDeivitto, yixxas, Jeiwan\n\n## Summary\nDangerous assumption on the peg of USDC can lead to manipulations\n## Vulnerability Detail\nWhen pricing liquidity of a Velodrome USDC pool, it's assumed that hte price of USDC is exactly $1 ([DepositReceipt_USDC.sol#L100](https://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_USDC.sol#L100), [DepositReceipt_USDC.sol#L123](https://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_USDC.sol#L123)). However, in reality, there's no hard peg, the price can go both above or below $1 (https://coinmarketcap.com/currencies/usd-coin/).\n\nThe volatility of USDC will also affect the price of the other token in the pool since it's priced in USDC ([DepositReceipt_USDC.sol#L87](https://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_USDC.sol#L87), [DepositReceipt_USDC.sol#L110](https://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_USDC.sol#L110)) and then compared to its USD price from a Chainlink oracle ([DepositReceipt_USDC.sol#L90-L98](https://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_USDC.sol#L90-L98)).\n\nThis issue is also applicable to the hard coded peg of sUSD when evaluating the USD price of a Synthetix collateral ([Vault_Synths.sol#L76](https://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/Vault_Synths.sol#L76)):\n```solidity\n/// @return returns the value of the given synth in sUSD which is assumed to be pegged at $1.\nfunction priceCollateralToUSD(bytes32 _currencyKey, uint256 _amount) public view override returns(uint256){\n    //As it is a synth use synthetix for pricing\n    return (synthetixExchangeRates.effectiveValue(_currencyKey, _amount, SUSD_CODE));      \n}\n```\nAnd sUSD is even less stable than USDC (https://coinmarketcap.com/currencies/susd/).\n\nTogether with isoUSD not having a stability mechanism, these assumptions can lead to different manipulations with the price of isoUSD and the arbitraging opportunities created by the hard peg assumptions (sUSD and USDC will be priced differently on exchanges and on Isomorph).\n\n## Impact\nIf the price of USDC falls below $1, collateral will be priced higher than expected. This will keep borrowers from being liquidated. And it will probably affect the price of isoUSD since there will be an arbitrage opportunity: the cheaper USDC will be priced higher as collateral on Isomorph.\nIf hte price of USDC raises above $1, borrowers' collateral will be undervalued and some liquidations will be possible that wouldn't have be allowed if the actual price of USDC was used.\n\n## Code Snippet\nThe value of USDC equals its amount ([DepositReceipt_USDC.sol#L100](https://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_USDC.sol#L100), [DepositReceipt_USDC.sol#L123](https://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_USDC.sol#L123)):\n```solidity\nvalue0 = token0Amount * SCALE_SHIFT;\n```\n\nThe other token in a pool is priced in USDC ([DepositReceipt_USDC.sol#L87](https://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_USDC.sol#L87), [DepositReceipt_USDC.sol#L110](https://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_USDC.sol#L110)):\n```solidity\n(amountOut, stablePool) = router.getAmountOut(HUNDRED_TOKENS, token1, USDC);\n```\n## Tool used\nManual Review\n\n## Recommendation\nConsider using the Chainlink USDC/USD feed to get the price of USDC and price liquidity using the actual price of USDC. Also, consider converting sUSD prices of Synthetix collaterals to USD to mitigate the discrepancy in prices between external exchanges and Isomorph.\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor confirmed however this is part of the protocol design. That said now that we have the duel oracle system for DepositReceipt_ETH it should not be too difficult to replicate this with minor changes so that the USDC value in DepositReceipt_USDC uses a chainlink oracle also.\n\nAs for sUSD, we will explore how changes might impact the system. The system is already designed to absorb small fluctuations in the value of sUSD by having a gap between the opening margin and the liquidation margin. However we can see that it can be unfair to a user if they get liquidated because they fairly price their Synth collateral using sUSD = $1.01 rather than the hardcoded exchange rate. \n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/22",
  "Code": [
    {
      "filename": "contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_USDC.sol",
      "content": "pragma solidity =0.8.9;\n\nimport \"./DepositReceipt_Base.sol\";\n\ncontract DepositReceipt_USDC is  DepositReceipt_Base {\n\n    uint256 private constant SCALE_SHIFT = 1e12; //brings USDC 6.d.p up to 18d.p. standard\n    uint256 private constant USDC_BASE = 1e6; //used for division in USDC 6.d.p scale\n    uint256 private constant ALLOWED_DEVIATION = 5e16; //5% in 1e18 / ETH scale\n    address private constant USDC = 0x7F5c764cBc14f9669B88837ca1490cCa17c31607; \n\n    //Chainlink oracle source\n    IAggregatorV3 public priceFeed;\n    // ten to the power of the number of decimals given by the price feed\n    uint256 private immutable oracleBase;\n\n    /**\n    *    @notice Zero address checks done in Templater that generates DepositReceipt and so not needed here.\n    **/\n    constructor(string memory _name, \n                string memory _symbol, \n                address _router, \n                address _token0,\n                address _token1,\n                bool _stable,\n                address _priceFeed) \n                ERC721(_name, _symbol){\n\n        //we dont want the `DEFAULT_ADMIN_ROLE` to exist as this doesn't require a \n        // time delay to add/remove any role and so is dangerous. \n        //So we ignore it and set our weaker admin role.\n        _setupRole(ADMIN_ROLE, msg.sender);\n        currentLastId = 1; //avoid id 0\n        //set up details for underlying tokens\n        router = IRouter(_router);\n\n        //here we check one token is USDC and that the other token has 18d.p.\n        //this prevents pricing mistakes and is defensive design against dev oversight.\n        //Obvious this is not a full check, a malicious ERC20 can set it's own symbol as USDC too \n        //but in practice as only the multi-sig should be deploying via Templater this is not a concern \n        \n        bytes memory USDCSymbol = abi.encodePacked(\"USDC\");\n        bytes memory token0Symbol = abi.encodePacked(IERC20Metadata(_token0).symbol());\n        //equality cannot be checked for strings so we hash them first.\n        if (keccak256(token0Symbol) == keccak256(USDCSymbol)){\n            require( IERC20Metadata(_token1).decimals() == 18, \"Token does not have 18dp\");\n        }\n        else\n        {   \n            bytes memory token1Symbol = abi.encodePacked(IERC20Metadata(_token1).symbol());\n            \n            require( keccak256(token1Symbol) == keccak256(USDCSymbol), \"One token must be USDC\");\n            require( IERC20Metadata(_token0).decimals() == 18, \"Token does not have 18dp\");\n            \n        }\n\n        token0 = _token0;\n        token1 = _token1;\n        stable = _stable;\n        priceFeed = IAggregatorV3(_priceFeed);\n        IAccessControlledOffchainAggregator  aggregator = IAccessControlledOffchainAggregator(priceFeed.aggregator());\n        //fetch the pricefeeds hard limits so we can be aware if these have been reached.\n        tokenMinPrice = aggregator.minAnswer();\n        tokenMaxPrice = aggregator.maxAnswer();\n        oracleBase = 10 ** priceFeed.decimals();  //Chainlink USD oracles have 8d.p.\n    }\n\n   /**\n    *  @notice this is used to price pooled Tokens by determining their underlying assets and then pricing these\n    *  @notice the two ways to do this are to price to USDC as  a dollar equivalent or to ETH then use Chainlink price feeds\n    *  @dev each DepositReceipt has a bespoke valuation method, make sure it fits the tokens\n    *  @dev each DepositReceipt's valuation method is sensitive to available liquidity keep this in mind as liquidating a pooled token by using the same pool will reduce overall liquidity\n\n    */\n    function priceLiquidity(uint256 _liquidity) external override view returns(uint256){\n        uint256 token0Amount;\n        uint256 token1Amount;\n        (token0Amount, token1Amount) = viewQuoteRemoveLiquidity(_liquidity);\n        //USDC route \n        uint256 value0;\n        uint256 value1;\n        if (token0 == USDC){\n            //hardcode value of USDC at $1\n            //check swap value of 100tokens to USDC to protect against flash loan attacks\n            uint256 amountOut; //amount received by trade\n            bool stablePool; //if the traded pool is stable or volatile.\n            (amountOut, stablePool) = router.getAmountOut(HUNDRED_TOKENS, token1, USDC);\n            require(stablePool == stable, \"pricing occuring through wrong pool\" );\n\n            uint256 oraclePrice = getOraclePrice(priceFeed, tokenMaxPrice, tokenMinPrice);\n            amountOut = (amountOut * oracleBase) / USDC_BASE / HUNDRED; //shift USDC amount to same scale as oracle\n\n            //calculate acceptable deviations from oracle price\n            uint256 lowerBound = (oraclePrice * (BASE - ALLOWED_DEVIATION)) / BASE;\n            uint256 upperBound = (oraclePrice * (BASE + ALLOWED_DEVIATION)) / BASE;\n            //because 1 USDC = $1 we can compare its amount directly to bounds\n            require(lowerBound < amountOut, \"Price shift low detected\");\n            require(upperBound > amountOut, \"Price shift high detected\");\n\n            value0 = token0Amount * SCALE_SHIFT;\n            \n            value1 = (token1Amount * oraclePrice) / oracleBase;\n        }\n        //token1 must be USDC \n        else {\n            //hardcode value of USDC at $1\n            //check swap value of 100tokens to USDC to protect against flash loan attacks\n            uint256 amountOut; //amount received by trade\n            bool stablePool; //if the traded pool is stable or volatile.\n            (amountOut, stablePool) = router.getAmountOut(HUNDRED_TOKENS, token0, USDC);\n            require(stablePool == stable, \"pricing occuring through wrong pool\" );\n\n            uint256 oraclePrice = getOraclePrice(priceFeed, tokenMaxPrice, tokenMinPrice);\n            amountOut = (amountOut * oracleBase) / USDC_BASE / HUNDRED; //shift USDC amount to same scale as oracle\n\n            //calculate acceptable deviations from oracle price\n            uint256 lowerBound = (oraclePrice * (BASE - ALLOWED_DEVIATION)) / BASE;\n            uint256 upperBound = (oraclePrice * (BASE + ALLOWED_DEVIATION)) / BASE;\n            //because 1 USDC = $1 we can compare its amount directly to bounds\n            require(lowerBound < amountOut, \"Price shift low detected\");\n            require(upperBound > amountOut, \"Price shift high detected\");\n\n            value1 = token1Amount * SCALE_SHIFT;\n           \n            value0 = (token0Amount * oraclePrice) / oracleBase;\n        }\n        //Invariant: both value0 and value1 are in ETH scale 18.d.p now\n        //USDC has only 6 decimals so we bring it up to the same scale as other 18d.p ERC20s\n        return(value0 + value1);\n    }\n}"
    },
    {
      "filename": "contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_USDC.sol",
      "content": "pragma solidity =0.8.9;\n\nimport \"./DepositReceipt_Base.sol\";\n\ncontract DepositReceipt_USDC is  DepositReceipt_Base {\n\n    uint256 private constant SCALE_SHIFT = 1e12; //brings USDC 6.d.p up to 18d.p. standard\n    uint256 private constant USDC_BASE = 1e6; //used for division in USDC 6.d.p scale\n    uint256 private constant ALLOWED_DEVIATION = 5e16; //5% in 1e18 / ETH scale\n    address private constant USDC = 0x7F5c764cBc14f9669B88837ca1490cCa17c31607; \n\n    //Chainlink oracle source\n    IAggregatorV3 public priceFeed;\n    // ten to the power of the number of decimals given by the price feed\n    uint256 private immutable oracleBase;\n\n    /**\n    *    @notice Zero address checks done in Templater that generates DepositReceipt and so not needed here.\n    **/\n    constructor(string memory _name, \n                string memory _symbol, \n                address _router, \n                address _token0,\n                address _token1,\n                bool _stable,\n                address _priceFeed) \n                ERC721(_name, _symbol){\n\n        //we dont want the `DEFAULT_ADMIN_ROLE` to exist as this doesn't require a \n        // time delay to add/remove any role and so is dangerous. \n        //So we ignore it and set our weaker admin role.\n        _setupRole(ADMIN_ROLE, msg.sender);\n        currentLastId = 1; //avoid id 0\n        //set up details for underlying tokens\n        router = IRouter(_router);\n\n        //here we check one token is USDC and that the other token has 18d.p.\n        //this prevents pricing mistakes and is defensive design against dev oversight.\n        //Obvious this is not a full check, a malicious ERC20 can set it's own symbol as USDC too \n        //but in practice as only the multi-sig should be deploying via Templater this is not a concern \n        \n        bytes memory USDCSymbol = abi.encodePacked(\"USDC\");\n        bytes memory token0Symbol = abi.encodePacked(IERC20Metadata(_token0).symbol());\n        //equality cannot be checked for strings so we hash them first.\n        if (keccak256(token0Symbol) == keccak256(USDCSymbol)){\n            require( IERC20Metadata(_token1).decimals() == 18, \"Token does not have 18dp\");\n        }\n        else\n        {   \n            bytes memory token1Symbol = abi.encodePacked(IERC20Metadata(_token1).symbol());\n            \n            require( keccak256(token1Symbol) == keccak256(USDCSymbol), \"One token must be USDC\");\n            require( IERC20Metadata(_token0).decimals() == 18, \"Token does not have 18dp\");\n            \n        }\n\n        token0 = _token0;\n        token1 = _token1;\n        stable = _stable;\n        priceFeed = IAggregatorV3(_priceFeed);\n        IAccessControlledOffchainAggregator  aggregator = IAccessControlledOffchainAggregator(priceFeed.aggregator());\n        //fetch the pricefeeds hard limits so we can be aware if these have been reached.\n        tokenMinPrice = aggregator.minAnswer();\n        tokenMaxPrice = aggregator.maxAnswer();\n        oracleBase = 10 ** priceFeed.decimals();  //Chainlink USD oracles have 8d.p.\n    }\n\n   /**\n    *  @notice this is used to price pooled Tokens by determining their underlying assets and then pricing these\n    *  @notice the two ways to do this are to price to USDC as  a dollar equivalent or to ETH then use Chainlink price feeds\n    *  @dev each DepositReceipt has a bespoke valuation method, make sure it fits the tokens\n    *  @dev each DepositReceipt's valuation method is sensitive to available liquidity keep this in mind as liquidating a pooled token by using the same pool will reduce overall liquidity\n\n    */\n    function priceLiquidity(uint256 _liquidity) external override view returns(uint256){\n        uint256 token0Amount;\n        uint256 token1Amount;\n        (token0Amount, token1Amount) = viewQuoteRemoveLiquidity(_liquidity);\n        //USDC route \n        uint256 value0;\n        uint256 value1;\n        if (token0 == USDC){\n            //hardcode value of USDC at $1\n            //check swap value of 100tokens to USDC to protect against flash loan attacks\n            uint256 amountOut; //amount received by trade\n            bool stablePool; //if the traded pool is stable or volatile.\n            (amountOut, stablePool) = router.getAmountOut(HUNDRED_TOKENS, token1, USDC);\n            require(stablePool == stable, \"pricing occuring through wrong pool\" );\n\n            uint256 oraclePrice = getOraclePrice(priceFeed, tokenMaxPrice, tokenMinPrice);\n            amountOut = (amountOut * oracleBase) / USDC_BASE / HUNDRED; //shift USDC amount to same scale as oracle\n\n            //calculate acceptable deviations from oracle price\n            uint256 lowerBound = (oraclePrice * (BASE - ALLOWED_DEVIATION)) / BASE;\n            uint256 upperBound = (oraclePrice * (BASE + ALLOWED_DEVIATION)) / BASE;\n            //because 1 USDC = $1 we can compare its amount directly to bounds\n            require(lowerBound < amountOut, \"Price shift low detected\");\n            require(upperBound > amountOut, \"Price shift high detected\");\n\n            value0 = token0Amount * SCALE_SHIFT;\n            \n            value1 = (token1Amount * oraclePrice) / oracleBase;\n        }\n        //token1 must be USDC \n        else {\n            //hardcode value of USDC at $1\n            //check swap value of 100tokens to USDC to protect against flash loan attacks\n            uint256 amountOut; //amount received by trade\n            bool stablePool; //if the traded pool is stable or volatile.\n            (amountOut, stablePool) = router.getAmountOut(HUNDRED_TOKENS, token0, USDC);\n            require(stablePool == stable, \"pricing occuring through wrong pool\" );\n\n            uint256 oraclePrice = getOraclePrice(priceFeed, tokenMaxPrice, tokenMinPrice);\n            amountOut = (amountOut * oracleBase) / USDC_BASE / HUNDRED; //shift USDC amount to same scale as oracle\n\n            //calculate acceptable deviations from oracle price\n            uint256 lowerBound = (oraclePrice * (BASE - ALLOWED_DEVIATION)) / BASE;\n            uint256 upperBound = (oraclePrice * (BASE + ALLOWED_DEVIATION)) / BASE;\n            //because 1 USDC = $1 we can compare its amount directly to bounds\n            require(lowerBound < amountOut, \"Price shift low detected\");\n            require(upperBound > amountOut, \"Price shift high detected\");\n\n            value1 = token1Amount * SCALE_SHIFT;\n           \n            value0 = (token0Amount * oraclePrice) / oracleBase;\n        }\n        //Invariant: both value0 and value1 are in ETH scale 18.d.p now\n        //USDC has only 6 decimals so we bring it up to the same scale as other 18d.p ERC20s\n        return(value0 + value1);\n    }\n}"
    },
    {
      "filename": "contracts/Isomorph/contracts/Vault_Synths.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Vault_Synths.sol for isomorph.loans\n// Bug bounties available\n\npragma solidity =0.8.9; \npragma abicoder v2;\n\n// External Synthetix interfaces\nimport \"./helper/interfaces/ISynthetix.sol\";\nimport \"./helper/interfaces/IExchangeRates.sol\";\nimport \"./helper/interfaces/ISystemStatus.sol\";\n\n//Vault Base for common functions\nimport \"./Vault_Base_ERC20.sol\";\n\n\ncontract Vault_Synths is Vault_Base_ERC20 {\n    \n    //Constants, private to reduce code size\n    bytes32 private constant SUSD_CODE = \"sUSD\"; \n    uint256 private constant ONE_HUNDRED_DOLLARS = 100 ether;\n    \n    //Optimism Mainnet addresses\n    \n    address public constant EXCHANGE_RATES = 0x22602469d704BfFb0936c7A7cfcD18f7aA269375;\n    address public constant PROXY_ERC20 = 0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4;\n    address public constant SUSD_ADDR = 0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9;\n    address public constant SYSTEM_STATUS = 0xE8c41bE1A167314ABAF2423b72Bf8da826943FFD;\n    \n    IExchangeRates private synthetixExchangeRates = IExchangeRates(EXCHANGE_RATES);\n    ISystemStatus private synthetixSystemStatus = ISystemStatus(SYSTEM_STATUS);\n   \n    \n    \n    constructor(\n        address _isoUSD, //isoUSD address\n        address _treasury, //treasury address\n        address _collateralBook //collateral structure book address\n        ){\n        require(_isoUSD != address(0), \"Zero Address used isoUSD\");\n        require(_treasury != address(0), \"Zero Address used Treasury\");\n        require(_collateralBook != address(0), \"Zero Address used Collateral\");\n        isoUSD = IisoUSDToken(_isoUSD);\n        treasury = _treasury;\n        collateralBook = ICollateralBook(_collateralBook);\n        _setupRole(ADMIN_ROLE, msg.sender);\n        _setupRole(PAUSER_ROLE, msg.sender);\n       \n    } \n\n\n    /**\n        Internal helper and check functions\n     */\n\n    /// @dev process for Synthetix assets\n    /// @dev leverages synthetix system to verify that the collateral in question is currently trading\n    /// @dev this prevents people frontrunning closed weekend markets for expected price crashes etc\n    /// @notice this call verifies Synthetix system, exchange and the synths in question are all available.\n    /// @notice if any of them aren't the function will revert.\n    /// @param _currencyKey the code used by synthetix to identify different synths, linked in collateral structure to collateral address\n    function _checkIfCollateralIsActive(bytes32 _currencyKey) internal view override {\n             synthetixSystemStatus.requireExchangeBetweenSynthsAllowed(_currencyKey, SUSD_CODE);\n         \n    }\n\n    /**\n        Public functions \n    */\n\n\n    //isoUSD is assumed to be valued at $1 by all of the system to avoid oracle attacks. \n    /// @param _currencyKey code used by Synthetix to identify each collateral/synth\n    /// @param _amount quantity of collateral to price into sUSD\n    /// @return returns the value of the given synth in sUSD which is assumed to be pegged at $1.\n    function priceCollateralToUSD(bytes32 _currencyKey, uint256 _amount) public view override returns(uint256){\n        //As it is a synth use synthetix for pricing\n        return (synthetixExchangeRates.effectiveValue(_currencyKey, _amount, SUSD_CODE));      \n    }\n\n    /**\n        External user loan interaction functions\n     */\n\n\n     /**\n      * @notice Only Vaults can mint isoUSD.\n      * @dev Mints 'USDborrowed' amount of isoUSD to vault and transfers to msg.sender and emits transfer event.\n      * @param _collateralAddress address of collateral token being used.\n      * @param _colAmount amount of collateral tokens being used.\n      * @param _USDborrowed amount of isoUSD to be minted, it is then split into the amount sent and the opening fee.\n     **/\n    function openLoan(\n        address _collateralAddress,\n        uint256 _colAmount,\n        uint256 _USDborrowed\n        ) external override whenNotPaused \n        {\n        _collateralExists(_collateralAddress);\n        IERC20 collateral = IERC20(_collateralAddress);\n        require(collateral.balanceOf(msg.sender) >= _colAmount, \"User lacks collateral quantity!\");\n        //make sure virtual price is related to current time before fetching collateral details\n        //slither-disable-next-line reentrancy-vulnerabilities-1\n        _updateVirtualPrice(block.timestamp, _collateralAddress);  \n        \n        (   \n            bytes32 currencyKey,\n            uint256 minOpeningMargin,\n            ,\n            ,\n            ,\n            uint256 virtualPrice,\n            \n        ) = _getCollateral(_collateralAddress);\n        //check for frozen or paused collateral\n        _checkIfCollateralIsActive(currencyKey);\n\n        //make sure the total isoUSD borrowed doesn't exceed the opening borrow margin ratio\n        uint256 colInUSD = priceCollateralToUSD(currencyKey, _colAmount + collateralPosted[_collateralAddress][msg.sender]);\n        uint256 totalUSDborrowed = _USDborrowed +  (isoUSDLoaned[_collateralAddress][msg.sender] * virtualPrice)/LOAN_SCALE;\n        require(totalUSDborrowed >= ONE_HUNDRED_DOLLARS, \"Loan Requested too small\"); \n        uint256 borrowMargin = (totalUSDborrowed * minOpeningMargin) / LOAN_SCALE;\n        require(colInUSD >= borrowMargin, \"Minimum margin not met!\");\n\n        //update mappings with new loan amounts\n        collateralPosted[_collateralAddress][msg.sender] = collateralPosted[_collateralAddress][msg.sender] + _colAmount;\n        isoUSDLoaned[_collateralAddress][msg.sender] = isoUSDLoaned[_collateralAddress][msg.sender] + _USDborrowed;\n        isoUSDLoanAndInterest[_collateralAddress][msg.sender] = isoUSDLoanAndInterest[_collateralAddress][msg.sender] + ((_USDborrowed * LOAN_SCALE) / virtualPrice);\n        \n        emit OpenOrIncreaseLoan(msg.sender, _USDborrowed, currencyKey, _colAmount);\n\n        //Now all effects are handled, transfer the assets so we follow CEI pattern\n        _increaseCollateral(collateral, _colAmount);\n        _increaseLoan(_USDborrowed);\n        \n        \n    }\n\n\n    /**\n      * @dev Increases collateral supplied against an existing loan. \n      * @notice Checks adding the collateral will keep the user above liquidation, \n      * @notice this debatable check isn't technically needed but feels fairer to end users.\n      * @param _collateralAddress address of collateral token being used.\n      * @param _colAmount amount of collateral tokens being used.\n     **/\n    function increaseCollateralAmount(\n        address _collateralAddress,\n        uint256 _colAmount\n        ) external override whenNotPaused \n        {\n        _collateralExists(_collateralAddress);\n        require(collateralPosted[_collateralAddress][msg.sender] > 0, \"No existing collateral!\"); //feels like semantic overloading and also problematic for dust after a loan is 'closed'\n        require(_colAmount > 0 , \"Zero amount\"); //Not strictly needed, prevents event spamming though\n        //make sure virtual price is related to current time before fetching collateral details\n        //slither-disable-next-line reentrancy-vulnerabilities-1\n        _updateVirtualPrice(block.timestamp, _collateralAddress);\n        IERC20 collateral = IERC20(_collateralAddress);\n        require(collateral.balanceOf(msg.sender) >= _colAmount, \"User lacks collateral amount\");\n        (   \n            bytes32 currencyKey,\n            ,\n            uint256 liquidatableMargin,\n            ,\n            ,\n            uint256 virtualPrice,\n            \n        ) = _getCollateral(_collateralAddress);\n        //check for frozen or paused collateral\n        _checkIfCollateralIsActive(currencyKey);\n        //debatable check begins here \n        uint256 totalCollat = collateralPosted[_collateralAddress][msg.sender] + _colAmount;\n        uint256 colInUSD = priceCollateralToUSD(currencyKey, totalCollat);\n        uint256 USDborrowed = (isoUSDLoanAndInterest[_collateralAddress][msg.sender] * virtualPrice) / LOAN_SCALE;\n        uint256 borrowMargin = (USDborrowed * liquidatableMargin) / LOAN_SCALE;\n        require(colInUSD >= borrowMargin, \"Liquidation margin not met!\");\n        //debatable check ends here\n        //update mapping with new collateral amount\n        collateralPosted[_collateralAddress][msg.sender] = collateralPosted[_collateralAddress][msg.sender] + _colAmount;\n        emit IncreaseCollateral(msg.sender, currencyKey, _colAmount);\n        //Now all effects are handled, transfer the collateral so we follow CEI pattern\n        _increaseCollateral(collateral, _colAmount);\n        \n    }\n\n\n     /**\n      * @notice Only Vault can destroy isoUSD.\n      * @dev destroys USDreturned of isoUSD held by caller, returns user collateral, close debt \n      * @dev if debt remains, checks minimum collateral ratio is upheld \n      * @dev if cost of a transaction can be <$0.01 YOU MUST UPDATE TENTH_OF_CENT check otherwise users can open microloans and close, withdrawing collateral without repaying. \n      * @param _collateralAddress address of collateral token being used.\n      * @param _collateralToUser amount of collateral tokens being returned to user.\n      * @param _USDToVault amount of isoUSD to be burnt.\n     **/\n\n    function closeLoan(\n        address _collateralAddress,\n        uint256 _collateralToUser,\n        uint256 _USDToVault\n        ) external override whenNotPaused \n        {\n        _collateralExists(_collateralAddress);\n        _closeLoanChecks(_collateralAddress, _collateralToUser, _USDToVault);\n        //make sure virtual price is related to current time before fetching collateral details\n        //slither-disable-next-line reentrancy-vulnerabilities-1\n        _updateVirtualPrice(block.timestamp, _collateralAddress);\n        (   \n            bytes32 currencyKey,\n            uint256 minOpeningMargin,\n            ,\n            ,\n            ,\n            uint256 virtualPrice,\n            \n        ) = _getCollateral(_collateralAddress);\n        //check for frozen or paused collateral\n        _checkIfCollateralIsActive(currencyKey);\n        uint256 isoUSDdebt = (isoUSDLoanAndInterest[_collateralAddress][msg.sender] * virtualPrice) / LOAN_SCALE;\n        require( isoUSDdebt >= _USDToVault, \"Trying to return more isoUSD than borrowed!\");\n        uint256 outstandingisoUSD = isoUSDdebt - _USDToVault;\n        if(outstandingisoUSD >= TENTH_OF_CENT){ //ignore leftover debts less than $0.001\n            uint256 collateralLeft = collateralPosted[_collateralAddress][msg.sender] - _collateralToUser;\n            uint256 colInUSD = priceCollateralToUSD(currencyKey, collateralLeft); \n            uint256 borrowMargin = (outstandingisoUSD * minOpeningMargin) / LOAN_SCALE;\n            require(colInUSD > borrowMargin , \"Remaining debt fails to meet minimum margin!\");\n        }\n        \n        //record paying off loan principle before interest\n        //slither-disable-next-line uninitialized-local-variables\n        uint256 interestPaid;\n        uint256 loanPrinciple = isoUSDLoaned[_collateralAddress][msg.sender];\n        if( loanPrinciple >= _USDToVault){\n            //pay off loan principle first\n            isoUSDLoaned[_collateralAddress][msg.sender] = loanPrinciple - _USDToVault;\n        }\n        else{\n            interestPaid = _USDToVault - loanPrinciple;\n            //loan principle is fully repaid so record this.\n            isoUSDLoaned[_collateralAddress][msg.sender] = 0;\n        }\n        //update mappings with reduced amounts\n        isoUSDLoanAndInterest[_collateralAddress][msg.sender] = isoUSDLoanAndInterest[_collateralAddress][msg.sender] - ((_USDToVault * LOAN_SCALE) / virtualPrice);\n        collateralPosted[_collateralAddress][msg.sender] = collateralPosted[_collateralAddress][msg.sender] - _collateralToUser;\n        emit ClosedLoan(msg.sender, _USDToVault, currencyKey, _collateralToUser);\n        //Now all effects are handled, transfer the assets so we follow CEI pattern\n        _decreaseLoan(_collateralAddress, _collateralToUser, _USDToVault, interestPaid);\n        }\n    \n    \n\n    /**\n        Liquidation functions\n     \n    */\n\n     /**\n      * @notice Anyone can liquidate any other undercollateralised loan.\n      * @notice The max acceptable liquidation quantity is calculated using viewLiquidatableAmount\n      * @dev checks that partial liquidation would be insufficient to recollaterize the loanHolder's debt \n      * @dev caller is paid 1e18 -`LIQUIDATION_RETURN` as reward for calling the liquidation.\n      * @dev In the event of full liquidation being insufficient the leftover debt is written off and an event tracking this is emitted.\n      * @param _loanHolder address of loanee being liquidated.\n      * @param _collateralAddress address of collateral token being used.\n     **/\n        \n        function callLiquidation(\n            address _loanHolder,\n            address _collateralAddress\n        ) external override whenNotPaused  \n        {   \n            _collateralExists(_collateralAddress);\n            require(_loanHolder != address(0), \"Zero address used\"); \n             //make sure virtual price is related to current time before fetching collateral details\n            //slither-disable-next-line reentrancy-vulnerabilities-1\n            _updateVirtualPrice(block.timestamp, _collateralAddress);\n            (\n                bytes32 currencyKey,\n                ,\n                uint256 liquidatableMargin,\n                ,\n                ,\n                uint256 virtualPrice,\n                \n            ) = _getCollateral(_collateralAddress);\n            //check for frozen or paused collateral\n            _checkIfCollateralIsActive(currencyKey);\n            //check how much of the specified loan should be closed\n            uint256 isoUSDBorrowed = (isoUSDLoanAndInterest[_collateralAddress][_loanHolder] * virtualPrice) / LOAN_SCALE;\n            uint256 totalUserCollateral = collateralPosted[_collateralAddress][_loanHolder];\n            uint256 currentPrice = priceCollateralToUSD(currencyKey, LOAN_SCALE); //assumes LOAN_SCALE = 1 ether, i.e. one unit of collateral!\n            uint256 liquidationAmount = viewLiquidatableAmount(totalUserCollateral, currentPrice, isoUSDBorrowed, liquidatableMargin);\n            require(liquidationAmount > 0 , \"Loan not liquidatable\");\n            //if complete liquidation falls short of recovering the position we settle for complete liquidation\n            if(liquidationAmount > totalUserCollateral){\n                liquidationAmount = totalUserCollateral;\n            }\n            uint256 isoUSDreturning = liquidationAmount*currentPrice*LIQUIDATION_RETURN/LOAN_SCALE/LOAN_SCALE;  \n            \n            //if the liquidation is the entire loan we need to record more\n            if(totalUserCollateral == liquidationAmount){\n                //and some of the loan is not being repaid.\n                if(isoUSDBorrowed > isoUSDreturning){\n                    //if a user is being fully liquidated we will forgive any remaining debt and interest so it\n                    // doesn't roll over if they open a new loan of the same collateral.\n                    delete isoUSDLoanAndInterest[_collateralAddress][_loanHolder];\n                    emit BadDebtCleared(_loanHolder, msg.sender, isoUSDBorrowed - isoUSDreturning, currencyKey);\n                    \n                }\n            }\n            //finally we call an internal function that updates mappings\n            // burns the liquidator's isoUSD and transfers the collateral to the liquidator as payment\n            _liquidate(_loanHolder, _collateralAddress, liquidationAmount, isoUSDreturning, currencyKey, virtualPrice);\n            \n        } \n}"
    },
    {
      "filename": "contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_USDC.sol",
      "content": "pragma solidity =0.8.9;\n\nimport \"./DepositReceipt_Base.sol\";\n\ncontract DepositReceipt_USDC is  DepositReceipt_Base {\n\n    uint256 private constant SCALE_SHIFT = 1e12; //brings USDC 6.d.p up to 18d.p. standard\n    uint256 private constant USDC_BASE = 1e6; //used for division in USDC 6.d.p scale\n    uint256 private constant ALLOWED_DEVIATION = 5e16; //5% in 1e18 / ETH scale\n    address private constant USDC = 0x7F5c764cBc14f9669B88837ca1490cCa17c31607; \n\n    //Chainlink oracle source\n    IAggregatorV3 public priceFeed;\n    // ten to the power of the number of decimals given by the price feed\n    uint256 private immutable oracleBase;\n\n    /**\n    *    @notice Zero address checks done in Templater that generates DepositReceipt and so not needed here.\n    **/\n    constructor(string memory _name, \n                string memory _symbol, \n                address _router, \n                address _token0,\n                address _token1,\n                bool _stable,\n                address _priceFeed) \n                ERC721(_name, _symbol){\n\n        //we dont want the `DEFAULT_ADMIN_ROLE` to exist as this doesn't require a \n        // time delay to add/remove any role and so is dangerous. \n        //So we ignore it and set our weaker admin role.\n        _setupRole(ADMIN_ROLE, msg.sender);\n        currentLastId = 1; //avoid id 0\n        //set up details for underlying tokens\n        router = IRouter(_router);\n\n        //here we check one token is USDC and that the other token has 18d.p.\n        //this prevents pricing mistakes and is defensive design against dev oversight.\n        //Obvious this is not a full check, a malicious ERC20 can set it's own symbol as USDC too \n        //but in practice as only the multi-sig should be deploying via Templater this is not a concern \n        \n        bytes memory USDCSymbol = abi.encodePacked(\"USDC\");\n        bytes memory token0Symbol = abi.encodePacked(IERC20Metadata(_token0).symbol());\n        //equality cannot be checked for strings so we hash them first.\n        if (keccak256(token0Symbol) == keccak256(USDCSymbol)){\n            require( IERC20Metadata(_token1).decimals() == 18, \"Token does not have 18dp\");\n        }\n        else\n        {   \n            bytes memory token1Symbol = abi.encodePacked(IERC20Metadata(_token1).symbol());\n            \n            require( keccak256(token1Symbol) == keccak256(USDCSymbol), \"One token must be USDC\");\n            require( IERC20Metadata(_token0).decimals() == 18, \"Token does not have 18dp\");\n            \n        }\n\n        token0 = _token0;\n        token1 = _token1;\n        stable = _stable;\n        priceFeed = IAggregatorV3(_priceFeed);\n        IAccessControlledOffchainAggregator  aggregator = IAccessControlledOffchainAggregator(priceFeed.aggregator());\n        //fetch the pricefeeds hard limits so we can be aware if these have been reached.\n        tokenMinPrice = aggregator.minAnswer();\n        tokenMaxPrice = aggregator.maxAnswer();\n        oracleBase = 10 ** priceFeed.decimals();  //Chainlink USD oracles have 8d.p.\n    }\n\n   /**\n    *  @notice this is used to price pooled Tokens by determining their underlying assets and then pricing these\n    *  @notice the two ways to do this are to price to USDC as  a dollar equivalent or to ETH then use Chainlink price feeds\n    *  @dev each DepositReceipt has a bespoke valuation method, make sure it fits the tokens\n    *  @dev each DepositReceipt's valuation method is sensitive to available liquidity keep this in mind as liquidating a pooled token by using the same pool will reduce over"
    }
  ]
}