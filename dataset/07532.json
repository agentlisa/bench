{
  "Title": "[M-02] Value can be stuck in Adapters",
  "Content": "\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/marketplaces/LooksRareAdapter.sol#L73-L94><br>\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/marketplaces/SeaportAdapter.sol#L93-L107><br>\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/marketplaces/X2Y2Adapter.sol#L88-L102>\n\nmatchAskWithTakerBid is payable, it calls `functionCallWithValue` with the value parameter. There are no checks to make sure `msg.value == value\\`, if excess value is sent user will not receive a refund.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/marketplaces/LooksRareAdapter.sol#L73-L94>\n\n```solidity\n    function matchAskWithTakerBid(\n        address marketplace,\n        bytes calldata params,\n        uint256 value\n    ) external payable override returns (bytes memory) {\n        bytes4 selector;\n        if (value == 0) {\n            selector = ILooksRareExchange.matchAskWithTakerBid.selector;\n        } else {\n            selector = ILooksRareExchange\n                .matchAskWithTakerBidUsingETHAndWETH\n                .selector;\n        }\n        bytes memory data = abi.encodePacked(selector, params);\n        return\n            Address.functionCallWithValue(\n                marketplace,\n                data,\n                value,\n                Errors.CALL_MARKETPLACE_FAILED\n            );\n    }\n```\n\nSame code exists in LooksRareAdapter, SeaportAdapter, and X2Y2Adapter.\n\n### Recommended Mitigation Steps\n\nCheck `msg.value == value`<br>\nIf the function is only supposed to be delegate called into, consider adding a check to prevent direct call.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-11-paraspace-contest",
  "Code": [
    {
      "filename": "paraspace-core/contracts/misc/marketplaces/LooksRareAdapter.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {DataTypes} from \"../../protocol/libraries/types/DataTypes.sol\";\nimport {Errors} from \"../../protocol/libraries/helpers/Errors.sol\";\nimport {OrderTypes} from \"../../dependencies/looksrare/contracts/libraries/OrderTypes.sol\";\nimport {SeaportInterface} from \"../../dependencies/seaport/contracts/interfaces/SeaportInterface.sol\";\nimport {ILooksRareExchange} from \"../../dependencies/looksrare/contracts/interfaces/ILooksRareExchange.sol\";\nimport {SignatureChecker} from \"../../dependencies/looksrare/contracts/libraries/SignatureChecker.sol\";\nimport {ConsiderationItem} from \"../../dependencies/seaport/contracts/lib/ConsiderationStructs.sol\";\nimport {AdvancedOrder, CriteriaResolver, Fulfillment, OfferItem, ItemType} from \"../../dependencies/seaport/contracts/lib/ConsiderationStructs.sol\";\nimport {Address} from \"../../dependencies/openzeppelin/contracts/Address.sol\";\nimport {IERC1271} from \"../../dependencies/openzeppelin/contracts/IERC1271.sol\";\nimport {IMarketplace} from \"../../interfaces/IMarketplace.sol\";\nimport {PoolStorage} from \"../../protocol/pool/PoolStorage.sol\";\n\n/**\n * @title LooksRare Adapter\n *\n * @notice Implements the NFT <=> ERC20 exchange logic via LooksRare marketplace\n */\ncontract LooksRareAdapter is IMarketplace {\n    constructor() {}\n\n    function getAskOrderInfo(bytes memory params, address weth)\n        external\n        pure\n        override\n        returns (DataTypes.OrderInfo memory orderInfo)\n    {\n        (\n            OrderTypes.TakerOrder memory takerBid,\n            OrderTypes.MakerOrder memory makerAsk\n        ) = abi.decode(params, (OrderTypes.TakerOrder, OrderTypes.MakerOrder));\n        orderInfo.maker = makerAsk.signer;\n\n        OfferItem[] memory offer = new OfferItem[](1);\n        offer[0] = OfferItem(\n            ItemType.ERC721,\n            makerAsk.collection,\n            makerAsk.tokenId,\n            1,\n            1\n        );\n        orderInfo.offer = offer;\n\n        ConsiderationItem[] memory consideration = new ConsiderationItem[](1);\n\n        ItemType itemType = ItemType.ERC20;\n        address token = makerAsk.currency;\n        if (token == weth) {\n            itemType = ItemType.NATIVE;\n            token = address(0);\n        }\n        consideration[0] = ConsiderationItem(\n            itemType,\n            token,\n            0,\n            makerAsk.price, // TODO: take minPercentageToAsk into account\n            makerAsk.price,\n            payable(takerBid.taker)\n        );\n        orderInfo.id = abi.encodePacked(makerAsk.r, makerAsk.s, makerAsk.v);\n        orderInfo.consideration = consideration;\n    }\n\n    function getBidOrderInfo(\n        bytes memory /*params*/\n    ) external pure override returns (DataTypes.OrderInfo memory) {\n        revert(Errors.CALL_MARKETPLACE_FAILED);\n    }\n\n    function matchAskWithTakerBid(\n        address marketplace,\n        bytes calldata params,\n        uint256 value\n    ) external payable override returns (bytes memory) {\n        bytes4 selector;\n        if (value == 0) {\n            selector = ILooksRareExchange.matchAskWithTakerBid.selector;\n        } else {\n            selector = ILooksRareExchange\n                .matchAskWithTakerBidUsingETHAndWETH\n                .selector;\n        }\n        bytes memory data = abi.encodePacked(selector, params);\n        return\n            Address.functionCallWithValue(\n                marketplace,\n                data,\n                value,\n                Errors.CALL_MARKETPLACE_FAILED\n            );\n    }\n\n    function matchBidWithTakerAsk(address, bytes calldata)\n        external\n        pure\n        override\n        returns (bytes memory)\n    {\n        revert(Errors.CALL_MARKETPLACE_FAILED);\n    }\n}"
    },
    {
      "filename": "paraspace-core/contracts/misc/marketplaces/SeaportAdapter.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {DataTypes} from \"../../protocol/libraries/types/DataTypes.sol\";\nimport {Errors} from \"../../protocol/libraries/helpers/Errors.sol\";\nimport {OrderTypes} from \"../../dependencies/looksrare/contracts/libraries/OrderTypes.sol\";\nimport {SeaportInterface} from \"../../dependencies/seaport/contracts/interfaces/SeaportInterface.sol\";\nimport {ILooksRareExchange} from \"../../dependencies/looksrare/contracts/interfaces/ILooksRareExchange.sol\";\nimport {SignatureChecker} from \"../../dependencies/looksrare/contracts/libraries/SignatureChecker.sol\";\nimport {ConsiderationItem} from \"../../dependencies/seaport/contracts/lib/ConsiderationStructs.sol\";\nimport {AdvancedOrder, CriteriaResolver, Fulfillment, OfferItem, ItemType} from \"../../dependencies/seaport/contracts/lib/ConsiderationStructs.sol\";\nimport {Address} from \"../../dependencies/openzeppelin/contracts/Address.sol\";\nimport {IERC1271} from \"../../dependencies/openzeppelin/contracts/IERC1271.sol\";\nimport {IMarketplace} from \"../../interfaces/IMarketplace.sol\";\nimport {PoolStorage} from \"../../protocol/pool/PoolStorage.sol\";\n\n/**\n * @title Seaport Adapter\n *\n * @notice Implements the NFT <=> ERC20 exchange logic via OpenSea Seaport marketplace\n */\ncontract SeaportAdapter is IMarketplace {\n    constructor() {}\n\n    function getAskOrderInfo(bytes memory params, address)\n        external\n        pure\n        override\n        returns (DataTypes.OrderInfo memory orderInfo)\n    {\n        (\n            AdvancedOrder memory advancedOrder,\n            CriteriaResolver[] memory resolvers,\n            ,\n\n        ) = abi.decode(\n                params,\n                (AdvancedOrder, CriteriaResolver[], bytes32, address)\n            );\n        // support advanced order in the future\n        require(\n            // NOT criteria based and must be basic order\n            resolvers.length == 0 && isBasicOrder(advancedOrder),\n            Errors.INVALID_MARKETPLACE_ORDER\n        );\n        // the person who listed NFT to sell\n        orderInfo.maker = advancedOrder.parameters.offerer;\n        orderInfo.id = advancedOrder.signature;\n        // NFT, items will be checked inside MarketplaceLogic\n        orderInfo.offer = advancedOrder.parameters.offer;\n        require(orderInfo.offer.length > 0, Errors.INVALID_MARKETPLACE_ORDER);\n        // ERC20, items will be checked inside MarketplaceLogic\n        orderInfo.consideration = advancedOrder.parameters.consideration;\n        require(\n            orderInfo.consideration.length > 0,\n            Errors.INVALID_MARKETPLACE_ORDER\n        );\n    }\n\n    function getBidOrderInfo(bytes memory params)\n        external\n        pure\n        override\n        returns (DataTypes.OrderInfo memory orderInfo)\n    {\n        (AdvancedOrder[] memory advancedOrders, , ) = abi.decode(\n            params,\n            (AdvancedOrder[], CriteriaResolver[], Fulfillment[])\n        );\n        // support advanced order in the future\n        require(\n            // NOT criteria based and must be basic order\n            advancedOrders.length == 2 &&\n                isBasicOrder(advancedOrders[0]) &&\n                isBasicOrder(advancedOrders[1]),\n            Errors.INVALID_MARKETPLACE_ORDER\n        );\n        // the person who sends bid to buy NFT\n        orderInfo.maker = advancedOrders[0].parameters.offerer;\n        orderInfo.taker = advancedOrders[1].parameters.offerer;\n        orderInfo.id = advancedOrders[0].signature;\n        // NFT, items will be checked inside MarketplaceLogic\n        orderInfo.offer = advancedOrders[1].parameters.offer;\n        require(orderInfo.offer.length > 0, Errors.INVALID_MARKETPLACE_ORDER);\n        // ERC20, items will be checked inside MarketplaceLogic\n        orderInfo.consideration = advancedOrders[1].parameters.consideration;\n        require(\n            orderInfo.consideration.length > 0,\n            Errors.INVALID_MARKETPLACE_ORDER\n        );\n    }\n\n    function matchAskWithTakerBid(\n        address marketplace,\n        bytes calldata params,\n        uint256 value\n    ) external payable override returns (bytes memory) {\n        bytes4 selector = SeaportInterface.fulfillAdvancedOrder.selector;\n        bytes memory data = abi.encodePacked(selector, params);\n        return\n            Address.functionCallWithValue(\n                marketplace,\n                data,\n                value,\n                Errors.CALL_MARKETPLACE_FAILED\n            );\n    }\n\n    function matchBidWithTakerAsk(address marketplace, bytes calldata params)\n        external\n        override\n        returns (bytes memory)\n    {\n        bytes4 selector = SeaportInterface.matchAdvancedOrders.selector;\n        bytes memory data = abi.encodePacked(selector, params);\n        return\n            Address.functionCall(\n                marketplace,\n                data,\n                Errors.CALL_MARKETPLACE_FAILED\n            );\n    }\n\n    function isBasicOrder(AdvancedOrder memory advancedOrder)\n        private\n        pure\n        returns (bool)\n    {\n        return\n            // FULL_OPEN || FULL_RESTRICTED\n            (uint256(advancedOrder.parameters.orderType) == 0 ||\n                uint256(advancedOrder.parameters.orderType) == 2) &&\n            // NOT PARTIAL_FULFILLABLE\n            advancedOrder.numerator == 1 &&\n            advancedOrder.denominator == 1 &&\n            // NO ZONE\n            advancedOrder.extraData.length == 0;\n    }\n}"
    },
    {
      "filename": "paraspace-core/contracts/misc/marketplaces/X2Y2Adapter.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {DataTypes} from \"../../protocol/libraries/types/DataTypes.sol\";\nimport {Errors} from \"../../protocol/libraries/helpers/Errors.sol\";\nimport {OrderTypes} from \"../../dependencies/looksrare/contracts/libraries/OrderTypes.sol\";\nimport {SeaportInterface} from \"../../dependencies/seaport/contracts/interfaces/SeaportInterface.sol\";\nimport {ILooksRareExchange} from \"../../dependencies/looksrare/contracts/interfaces/ILooksRareExchange.sol\";\nimport {IX2Y2} from \"../../interfaces/IX2Y2.sol\";\nimport {SignatureChecker} from \"../../dependencies/looksrare/contracts/libraries/SignatureChecker.sol\";\nimport {ConsiderationItem} from \"../../dependencies/seaport/contracts/lib/ConsiderationStructs.sol\";\nimport {AdvancedOrder, CriteriaResolver, Fulfillment, OfferItem, ItemType} from \"../../dependencies/seaport/contracts/lib/ConsiderationStructs.sol\";\nimport {Address} from \"../../dependencies/openzeppelin/contracts/Address.sol\";\nimport {IERC1271} from \"../../dependencies/openzeppelin/contracts/IERC1271.sol\";\nimport {IMarketplace} from \"../../interfaces/IMarketplace.sol\";\nimport {PoolStorage} from \"../../protocol/pool/PoolStorage.sol\";\n\n/**\n * @title X2Y2 Adapter\n *\n * @notice Implements the NFT <=> ERC20 exchange logic via X2Y2 marketplace\n */\ncontract X2Y2Adapter is IMarketplace {\n    constructor() {}\n\n    struct ERC721Pair {\n        address token;\n        uint256 tokenId;\n    }\n\n    function getAskOrderInfo(bytes memory params, address)\n        external\n        pure\n        override\n        returns (DataTypes.OrderInfo memory orderInfo)\n    {\n        IX2Y2.RunInput memory runInput = abi.decode(params, (IX2Y2.RunInput));\n        require(runInput.details.length == 1, Errors.INVALID_MARKETPLACE_ORDER);\n\n        IX2Y2.SettleDetail memory detail = runInput.details[0];\n        IX2Y2.Order memory order = runInput.orders[detail.orderIdx];\n        IX2Y2.OrderItem memory item = order.items[detail.itemIdx];\n\n        require(\n            IX2Y2.Op.COMPLETE_SELL_OFFER == detail.op,\n            Errors.INVALID_MARKETPLACE_ORDER\n        );\n\n        ERC721Pair[] memory nfts = abi.decode(item.data, (ERC721Pair[]));\n\n        require(nfts.length == 1, Errors.INVALID_MARKETPLACE_ORDER);\n\n        OfferItem[] memory offer = new OfferItem[](1);\n        offer[0] = OfferItem(\n            ItemType.ERC721,\n            nfts[0].token,\n            nfts[0].tokenId,\n            1,\n            1\n        );\n        orderInfo.offer = offer;\n\n        ConsiderationItem[] memory consideration = new ConsiderationItem[](1);\n\n        ItemType itemType = ItemType.ERC20;\n        address token = order.currency;\n        consideration[0] = ConsiderationItem(\n            itemType,\n            token,\n            0,\n            detail.price,\n            detail.price,\n            payable(order.user)\n        );\n        orderInfo.id = abi.encodePacked(order.r, order.s, order.v);\n        orderInfo.consideration = consideration;\n    }\n\n    function getBidOrderInfo(bytes memory)\n        external\n        pure\n        override\n        returns (DataTypes.OrderInfo memory)\n    {\n        revert(Errors.CALL_MARKETPLACE_FAILED);\n    }\n\n    function matchAskWithTakerBid(\n        address marketplace,\n        bytes calldata params,\n        uint256 value\n    ) external payable override returns (bytes memory) {\n        bytes4 selector = IX2Y2.run.selector;\n        bytes memory data = abi.encodePacked(selector, params);\n        return\n            Address.functionCallWithValue(\n                marketplace,\n                data,\n                value,\n                Errors.CALL_MARKETPLACE_FAILED\n            );\n    }\n\n    function matchBidWithTakerAsk(address, bytes calldata)\n        external\n        pure\n        override\n        returns (bytes memory)\n    {\n        revert(Errors.CALL_MARKETPLACE_FAILED);\n    }\n}"
    },
    {
      "filename": "paraspace-core/contracts/misc/marketplaces/LooksRareAdapter.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {DataTypes} from \"../../protocol/libraries/types/DataTypes.sol\";\nimport {Errors} from \"../../protocol/libraries/helpers/Errors.sol\";\nimport {OrderTypes} from \"../../dependencies/looksrare/contracts/libraries/OrderTypes.sol\";\nimport {SeaportInterface} from \"../../dependencies/seaport/contracts/interfaces/SeaportInterface.sol\";\nimport {ILooksRareExchange} from \"../../dependencies/looksrare/contracts/interfaces/ILooksRareExchange.sol\";\nimport {SignatureChecker} from \"../../dependencies/looksrare/contracts/libraries/SignatureChecker.sol\";\nimport {ConsiderationItem} from \"../../dependencies/seaport/contracts/lib/ConsiderationStructs.sol\";\nimport {AdvancedOrder, CriteriaResolver, Fulfillment, OfferItem, ItemType} from \"../../dependencies/seaport/contracts/lib/ConsiderationStructs.sol\";\nimport {Address} from \"../../dependencies/openzeppelin/contracts/Address.sol\";\nimport {IERC1271} from \"../../dependencies/openzeppelin/contracts/IERC1271.sol\";\nimport {IMarketplace} from \"../../interfaces/IMarketplace.sol\";\nimport {PoolStorage} from \"../../protocol/pool/PoolStorage.sol\";\n\n/**\n * @title LooksRare Adapter\n *\n * @notice Implements the NFT <=> ERC20 exchange logic via LooksRare marketplace\n */\ncontract LooksRareAdapter is IMarketplace {\n    constructor() {}\n\n    function getAskOrderInfo(bytes memory params, address weth)\n        external\n        pure\n        override\n        returns (DataTypes.OrderInfo memory orderInfo)\n    {\n        (\n            OrderTypes.TakerOrder memory takerBid,\n            OrderTypes.MakerOrder memory makerAsk\n        ) = abi.decode(params, (OrderTypes.TakerOrder, OrderTypes.MakerOrder));\n        orderInfo.maker = makerAsk.signer;\n\n        OfferItem[] memory offer = new OfferItem[](1);\n        offer[0] = OfferItem(\n            ItemType.ERC721,\n            makerAsk.collection,\n            makerAsk.tokenId,\n            1,\n            1\n        );\n        orderInfo.offer = offer;\n\n        ConsiderationItem[] memory consideration = new ConsiderationItem[](1);\n\n        ItemType itemType = ItemType.ERC20;\n        address token = makerAsk.currency;\n        if (token == weth) {\n            itemType = ItemType.NATIVE;\n            token = address(0);\n        }\n        consideration[0] = ConsiderationItem(\n            itemType,\n            token,\n            0,\n            makerAsk.price, // TODO: take minPercentageToAsk into account\n            makerAsk.price,\n            payable(takerBid.taker)\n        );\n        orderInfo.id = abi.encodePacked(makerAsk.r, makerAsk.s, makerAsk.v);\n        orderInfo.consideration = consideration;\n    }\n\n    function getBidOrderInfo(\n        bytes memory /*params*/\n    ) external pure override returns (DataTypes.OrderInfo memory) {\n        revert(Errors.CALL_MARKETPLACE_FAILED);\n    }\n\n    function matchAskWithTakerBid(\n        address marketplace,\n        bytes calldata params,\n        uint256 value\n    ) external payable override returns (bytes memory) {\n        bytes4 selector;\n        if (value == 0) {\n            selector = ILooksRareExchange.matchAskWithTakerBid.selector;\n        } else {\n            selector = ILooksRareExchange\n                .matchAskWithTakerBidUsingETHAndWETH\n                .selector;\n        }\n        bytes memory data = abi.encodePacked(selector, params);\n        return\n            Address.functionCallWithValue(\n                marketplace,\n                data,\n                value,\n                Errors.CALL_MARKETPLACE_FAILED\n            );\n    }\n\n    function matchBidWithTakerAsk(address, bytes calldata)\n        external\n        pure\n        override\n        returns (bytes memory)\n    {\n        revert(Errors.CALL_MARKETPLACE_FAILED);\n    }\n}"
    }
  ]
}