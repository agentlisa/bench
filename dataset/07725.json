{
  "Title": "[M-06] Public to all funds escape",
  "Content": "\n<https://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/TokenRescuer.sol#L22>\n\n<https://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/TokenRescuer.sol#L34>\n\n<https://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/LooksRareAggregator.sol#L27>\n\n<https://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/LooksRareAggregator.sol#L108>\n\n<https://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/LooksRareAggregator.sol#L109>\n\n<https://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/LooksRareAggregator.sol#L245>\n\n<https://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/lowLevelCallers/LowLevelETH.sol#L43>\n\n### Vulnerability Details\n\nThe `LooksRareAggregator` smart contract implements a bunch of functions to escape funds by the contract owner (see `rescueETH`, `rescueERC20`, `rescueERC721`, and `rescueERC1155`). In this way, any funds that were accidentally sent to the contract or were locked due to incorrect contract implementation can be returned to the owner. However, locked funds can be rescued by anyone without the owner's permission. This is completely contrary to the idea of having rescue functions.\n\nIn order to withdraw funds from the contract, a user may just call the `execute` function in the `ERC20EnabledLooksRareAggregator` with `tokenTransfers` that contains the addresses of tokens to be withdrawn. \n\nThus, after the order execution `_returnERC20TokensIfAny` and `_returnETHIfAny` will be called, and the whole balance of provided ERC20 tokens and Ether will be returned to `msg.sender`.\n\nPlease note, that means that the owner can be front-ran with `rescue` functions and an attacker will receive funds instead.\n\n### Impact\n\nUseless of rescue functionality and vulnerability to jamming funds.\n\n### Recommended Mitigation Steps\n\n`_returnETHIfAny` and `_returnERC20TokensIfAny` should return the amount of the token that was deposited.\n\n**[Picodes (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-11-looksrare-findings/issues/277#issuecomment-1322298900):**\n > As only stuck funds are at risk, and as the aggregator contract itself is not supposed to handle funds, I don't think this qualifies for High Severity.\n\n**[0xhiroshi (LooksRare) disputed and commented](https://github.com/code-423n4/2022-11-looksrare-findings/issues/277#issuecomment-1326396672):**\n > We have decided that any ERC20 tokens sent there accidentally are free for all.\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2022-11-looksrare-findings/issues/277#issuecomment-1345540962):**\n > Keeping the Medium severity because the contract implements `TokenRescuer`, so the intent \"that any ERC20 tokens sent there accidentally are free for all\" totally makes sense but wasn't clear prior to the audit. So I consider this a case where tokens that should belong to the protocol could be withdrawn by anyone.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-11-looksrare",
  "Code": [
    {
      "filename": "contracts/TokenRescuer.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {IERC20} from \"./interfaces/IERC20.sol\";\nimport {OwnableTwoSteps} from \"./OwnableTwoSteps.sol\";\nimport {LowLevelERC20Transfer} from \"./lowLevelCallers/LowLevelERC20Transfer.sol\";\nimport {LowLevelETH} from \"./lowLevelCallers/LowLevelETH.sol\";\n\n/**\n * @title TokenRescuer\n * @notice This contract contains functions to move tokens\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract TokenRescuer is OwnableTwoSteps, LowLevelETH, LowLevelERC20Transfer {\n    error InsufficientAmount();\n\n    /**\n     * @notice Rescue the contract's trapped ETH\n     * @dev Must be called by the current owner\n     * @param to Send the contract's ETH balance to this address\n     */\n    function rescueETH(address to) external onlyOwner {\n        uint256 withdrawAmount = address(this).balance - 1;\n        if (withdrawAmount == 0) revert InsufficientAmount();\n        _transferETH(to, withdrawAmount);\n    }\n\n    /**\n     * @notice Rescue any of the contract's trapped ERC20 tokens\n     * @dev Must be called by the current owner\n     * @param currency The address of the ERC20 token to rescue from the contract\n     * @param to Send the contract's specified ERC20 token balance to this address\n     */\n    function rescueERC20(address currency, address to) external onlyOwner {\n        uint256 withdrawAmount = IERC20(currency).balanceOf(address(this)) - 1;\n        if (withdrawAmount == 0) revert InsufficientAmount();\n        _executeERC20DirectTransfer(currency, to, withdrawAmount);\n    }\n}"
    },
    {
      "filename": "contracts/TokenRescuer.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {IERC20} from \"./interfaces/IERC20.sol\";\nimport {OwnableTwoSteps} from \"./OwnableTwoSteps.sol\";\nimport {LowLevelERC20Transfer} from \"./lowLevelCallers/LowLevelERC20Transfer.sol\";\nimport {LowLevelETH} from \"./lowLevelCallers/LowLevelETH.sol\";\n\n/**\n * @title TokenRescuer\n * @notice This contract contains functions to move tokens\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract TokenRescuer is OwnableTwoSteps, LowLevelETH, LowLevelERC20Transfer {\n    error InsufficientAmount();\n\n    /**\n     * @notice Rescue the contract's trapped ETH\n     * @dev Must be called by the current owner\n     * @param to Send the contract's ETH balance to this address\n     */\n    function rescueETH(address to) external onlyOwner {\n        uint256 withdrawAmount = address(this).balance - 1;\n        if (withdrawAmount == 0) revert InsufficientAmount();\n        _transferETH(to, withdrawAmount);\n    }\n\n    /**\n     * @notice Rescue any of the contract's trapped ERC20 tokens\n     * @dev Must be called by the current owner\n     * @param currency The address of the ERC20 token to rescue from the contract\n     * @param to Send the contract's specified ERC20 token balance to this address\n     */\n    function rescueERC20(address currency, address to) external onlyOwner {\n        uint256 withdrawAmount = IERC20(currency).balanceOf(address(this)) - 1;\n        if (withdrawAmount == 0) revert InsufficientAmount();\n        _executeERC20DirectTransfer(currency, to, withdrawAmount);\n    }\n}"
    },
    {
      "filename": "contracts/LooksRareAggregator.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {ReentrancyGuard} from \"./ReentrancyGuard.sol\";\nimport {LowLevelERC20Approve} from \"./lowLevelCallers/LowLevelERC20Approve.sol\";\nimport {LowLevelERC721Transfer} from \"./lowLevelCallers/LowLevelERC721Transfer.sol\";\nimport {LowLevelERC1155Transfer} from \"./lowLevelCallers/LowLevelERC1155Transfer.sol\";\nimport {IERC20} from \"./interfaces/IERC20.sol\";\nimport {LooksRareProxy} from \"./proxies/LooksRareProxy.sol\";\nimport {BasicOrder, TokenTransfer} from \"./libraries/OrderStructs.sol\";\nimport {TokenRescuer} from \"./TokenRescuer.sol\";\nimport {TokenReceiver} from \"./TokenReceiver.sol\";\nimport {ILooksRareAggregator} from \"./interfaces/ILooksRareAggregator.sol\";\nimport {BasicOrder, FeeData, TokenTransfer} from \"./libraries/OrderStructs.sol\";\nimport {LooksRareProxy} from \"./proxies/LooksRareProxy.sol\";\nimport {TokenReceiver} from \"./TokenReceiver.sol\";\nimport {TokenRescuer} from \"./TokenRescuer.sol\";\n\n/**\n * @title LooksRareAggregator\n * @notice This contract allows NFT sweepers to buy NFTs from different marketplaces\n *         by passing high-level structs + low-level bytes as calldata.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract LooksRareAggregator is\n    ILooksRareAggregator,\n    TokenRescuer,\n    TokenReceiver,\n    ReentrancyGuard,\n    LowLevelERC20Approve,\n    LowLevelERC721Transfer,\n    LowLevelERC1155Transfer\n{\n    /**\n     * @notice Transactions that only involve ETH orders should be submitted to this contract\n     *         directly. Transactions that involve ERC20 orders should be submitted to the contract\n     *         ERC20EnabledLooksRareAggregator and it will call this contract's execution function.\n     *         The purpose is to prevent a malicious proxy from stealing users' ERC20 tokens if\n     *         this contract's ownership is compromised. By not providing any allowances to this\n     *         aggregator, even if a malicious proxy is added, it cannot call\n     *         token.transferFrom(victim, attacker, amount) inside the proxy within the context of the\n     *         aggregator.\n     */\n    address public erc20EnabledLooksRareAggregator;\n    mapping(address => mapping(bytes4 => bool)) private _proxyFunctionSelectors;\n    mapping(address => FeeData) private _proxyFeeData;\n\n    /**\n     * @inheritdoc ILooksRareAggregator\n     */\n    function execute(\n        TokenTransfer[] calldata tokenTransfers,\n        TradeData[] calldata tradeData,\n        address originator,\n        address recipient,\n        bool isAtomic\n    ) external payable nonReentrant {\n        if (recipient == address(0)) revert ZeroAddress();\n        uint256 tradeDataLength = tradeData.length;\n        if (tradeDataLength == 0) revert InvalidOrderLength();\n\n        uint256 tokenTransfersLength = tokenTransfers.length;\n        if (tokenTransfersLength == 0) {\n            originator = msg.sender;\n        } else if (msg.sender != erc20EnabledLooksRareAggregator) {\n            revert UseERC20EnabledLooksRareAggregator();\n        }\n\n        for (uint256 i; i < tradeDataLength; ) {\n            TradeData calldata singleTradeData = tradeData[i];\n            if (!_proxyFunctionSelectors[singleTradeData.proxy][singleTradeData.selector]) revert InvalidFunction();\n\n            (bytes memory proxyCalldata, bool maxFeeBpViolated) = _encodeCalldataAndValidateFeeBp(\n                singleTradeData,\n                recipient,\n                isAtomic\n            );\n            if (maxFeeBpViolated) {\n                if (isAtomic) {\n                    revert FeeTooHigh();\n                } else {\n                    unchecked {\n                        ++i;\n                    }\n                    continue;\n                }\n            }\n            (bool success, bytes memory returnData) = singleTradeData.proxy.delegatecall(proxyCalldata);\n\n            if (!success) {\n                if (isAtomic) {\n                    if (returnData.length > 0) {\n                        assembly {\n                            let returnDataSize := mload(returnData)\n                            revert(add(32, returnData), returnDataSize)\n                        }\n                    } else {\n                        revert TradeExecutionFailed();\n                    }\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (tokenTransfersLength > 0) _returnERC20TokensIfAny(tokenTransfers, originator);\n        _returnETHIfAny(originator);\n\n        emit Sweep(originator);\n    }\n\n    /**\n     * @notice Enable making ERC20 trades by setting the ERC20 enabled LooksRare aggregator\n     * @dev Must be called by the current owner. It can only be set once to prevent\n     *      a malicious aggregator from being set in case of an ownership compromise.\n     * @param _erc20EnabledLooksRareAggregator The ERC20 enabled LooksRare aggregator's address\n     */\n    function setERC20EnabledLooksRareAggregator(address _erc20EnabledLooksRareAggregator) external onlyOwner {\n        if (erc20EnabledLooksRareAggregator != address(0)) revert AlreadySet();\n        erc20EnabledLooksRareAggregator = _erc20EnabledLooksRareAggregator;\n        emit ERC20EnabledLooksRareAggregatorSet();\n    }\n\n    /**\n     * @notice Enable calling the specified proxy's trade function\n     * @dev Must be called by the current owner\n     * @param proxy The marketplace proxy's address\n     * @param selector The marketplace proxy's function selector\n     */\n    function addFunction(address proxy, bytes4 selector) external onlyOwner {\n        _proxyFunctionSelectors[proxy][selector] = true;\n        emit FunctionAdded(proxy, selector);\n    }\n\n    /**\n     * @notice Disable calling the specified proxy's trade function\n     * @dev Must be called by the current owner\n     * @param proxy The marketplace proxy's address\n     * @param selector The marketplace proxy's function selector\n     */\n    function removeFunction(address proxy, bytes4 selector) external onlyOwner {\n        delete _proxyFunctionSelectors[proxy][selector];\n        emit FunctionRemoved(proxy, selector);\n    }\n\n    /**\n     * @param proxy Proxy to apply the fee to\n     * @param bp Fee basis point\n     * @param recipient Fee recipient\n     */\n    function setFee(\n        address proxy,\n        uint256 bp,\n        address recipient\n    ) external onlyOwner {\n        if (bp > 10000) revert FeeTooHigh();\n        _proxyFeeData[proxy].bp = bp;\n        _proxyFeeData[proxy].recipient = recipient;\n\n        emit FeeUpdated(proxy, bp, recipient);\n    }\n\n    /**\n     * @notice Approve marketplaces to transfer ERC20 tokens from the aggregator\n     * @param marketplace The marketplace address to approve\n     * @param currency The ERC20 token address to approve\n     * @param amount The amount of ERC20 token to approve\n     */\n    function approve(\n        address marketplace,\n        address currency,\n        uint256 amount\n    ) external onlyOwner {\n        _executeERC20Approve(currency, marketplace, amount);\n    }\n\n    /**\n     * @param proxy The marketplace proxy's address\n     * @param selector The marketplace proxy's function selector\n     * @return Whether the marketplace proxy's function can be called from the aggregator\n     */\n    function supportsProxyFunction(address proxy, bytes4 selector) external view returns (bool) {\n        return _proxyFunctionSelectors[proxy][selector];\n    }\n\n    /**\n     * @notice Rescue any of the contract's trapped ERC721 tokens\n     * @dev Must be called by the current owner\n     * @param collection The address of the ERC721 token to rescue from the contract\n     * @param tokenId The token ID of the ERC721 token to rescue from the contract\n     * @param to Send the contract's specified ERC721 token ID to this address\n     */\n    function rescueERC721(\n        address collection,\n        address to,\n        uint256 tokenId\n    ) external onlyOwner {\n        _executeERC721TransferFrom(collection, address(this), to, tokenId);\n    }\n\n    /**\n     * @notice Rescue any of the contract's trapped ERC1155 tokens\n     * @dev Must be called by the current owner\n     * @param collection The address of the ERC1155 token to rescue from the contract\n     * @param tokenIds The token IDs of the ERC1155 token to rescue from the contract\n     * @param amounts The amount of each token ID to rescue\n     * @param to Send the contract's specified ERC1155 token ID to this address\n     */\n    function rescueERC1155(\n        address collection,\n        address to,\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts\n    ) external onlyOwner {\n        _executeERC1155SafeBatchTransferFrom(collection, address(this), to, tokenIds, amounts);\n    }\n\n    receive() external payable {}\n\n    function _encodeCalldataAndValidateFeeBp(\n        TradeData calldata singleTradeData,\n        address recipient,\n        bool isAtomic\n    ) private view returns (bytes memory proxyCalldata, bool maxFeeBpViolated) {\n        FeeData memory feeData = _proxyFeeData[singleTradeData.proxy];\n        maxFeeBpViolated = singleTradeData.maxFeeBp < feeData.bp;\n        proxyCalldata = abi.encodeWithSelector(\n            singleTradeData.selector,\n            singleTradeData.orders,\n            singleTradeData.ordersExtraData,\n            singleTradeData.extraData,\n            recipient,\n            isAtomic,\n            feeData.bp,\n            feeData.recipient\n        );\n    }\n\n    function _returnERC20TokensIfAny(TokenTransfer[] calldata tokenTransfers, address recipient) private {\n        uint256 tokenTransfersLength = tokenTransfers.length;\n        for (uint256 i; i < tokenTransfersLength; ) {\n            uint256 balance = IERC20(tokenTransfers[i].currency).balanceOf(address(this));\n            if (balance > 0) _executeERC20DirectTransfer(tokenTransfers[i].currency, recipient, balance);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/LooksRareAggregator.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {ReentrancyGuard} from \"./ReentrancyGuard.sol\";\nimport {LowLevelERC20Approve} from \"./lowLevelCallers/LowLevelERC20Approve.sol\";\nimport {LowLevelERC721Transfer} from \"./lowLevelCallers/LowLevelERC721Transfer.sol\";\nimport {LowLevelERC1155Transfer} from \"./lowLevelCallers/LowLevelERC1155Transfer.sol\";\nimport {IERC20} from \"./interfaces/IERC20.sol\";\nimport {LooksRareProxy} from \"./proxies/LooksRareProxy.sol\";\nimport {BasicOrder, TokenTransfer} from \"./libraries/OrderStructs.sol\";\nimport {TokenRescuer} from \"./TokenRescuer.sol\";\nimport {TokenReceiver} from \"./TokenReceiver.sol\";\nimport {ILooksRareAggregator} from \"./interfaces/ILooksRareAggregator.sol\";\nimport {BasicOrder, FeeData, TokenTransfer} from \"./libraries/OrderStructs.sol\";\nimport {LooksRareProxy} from \"./proxies/LooksRareProxy.sol\";\nimport {TokenReceiver} from \"./TokenReceiver.sol\";\nimport {TokenRescuer} from \"./TokenRescuer.sol\";\n\n/**\n * @title LooksRareAggregator\n * @notice This contract allows NFT sweepers to buy NFTs from different marketplaces\n *         by passing high-level structs + low-level bytes as calldata.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract LooksRareAggregator is\n    ILooksRareAggregator,\n    TokenRescuer,\n    TokenReceiver,\n    ReentrancyGuard,\n    LowLevelERC20Approve,\n    LowLevelERC721Transfer,\n    LowLevelERC1155Transfer\n{\n    /**\n     * @notice Transactions that only involve ETH orders should be submitted to this contract\n     *         directly. Transactions that involve ERC20 orders should be submitted to the contract\n     *         ERC20EnabledLooksRareAggregator and it will call this contract's execution function.\n     *         The purpose is to prevent a malicious proxy from stealing users' ERC20 tokens if\n     *         this contract's ownership is compromised. By not providing any allowances to this\n     *         aggregator, even if a malicious proxy is added, it cannot call\n     *         token.transferFrom(victim, attacker, amount) inside the proxy within the context of the\n     *         aggregator.\n     */\n    address public erc20EnabledLooksRareAggregator;\n    mapping(address => mapping(bytes4 => bool)) private _proxyFunctionSelectors;\n    mapping(address => FeeData) private _proxyFeeData;\n\n    /**\n     * @inheritdoc ILooksRareAggregator\n     */\n    function execute(\n        TokenTransfer[] calldata tokenTransfers,\n        TradeData[] calldata tradeData,\n        address originator,\n        address recipient,\n        bool isAtomic\n    ) external payable nonReentrant {\n        if (recipient == address(0)) revert ZeroAddress();\n        uint256 tradeDataLength = tradeData.length;\n        if (tradeDataLength == 0) revert InvalidOrderLength();\n\n        uint256 tokenTransfersLength = tokenTransfers.length;\n        if (tokenTransfersLength == 0) {\n            originator = msg.sender;\n        } else if (msg.sender != erc20EnabledLooksRareAggregator) {\n            revert UseERC20EnabledLooksRareAggregator();\n        }\n\n        for (uint256 i; i < tradeDataLength; ) {\n            TradeData calldata singleTradeData = tradeData[i];\n            if (!_proxyFunctionSelectors[singleTradeData.proxy][singleTradeData.selector]) revert InvalidFunction();\n\n            (bytes memory proxyCalldata, bool maxFeeBpViolated) = _encodeCalldataAndValidateFeeBp(\n                singleTradeData,\n                recipient,\n                isAtomic\n            );\n            if (maxFeeBpViolated) {\n                if (isAtomic) {\n                    revert FeeTooHigh();\n                } else {\n                    unchecked {\n                        ++i;\n                    }\n                    continue;\n                }\n            }\n            (bool success, bytes memory returnData) = singleTradeData.proxy.delegatecall(proxyCalldata);\n\n            if (!success) {\n                if (isAtomic) {\n                    if (returnData.length > 0) {\n                        assembly {\n                            let returnDataSize := mload(returnData)\n                            revert(add(32, returnData), returnDataSize)\n                        }\n                    } else {\n                        revert TradeExecutionFailed();\n                    }\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (tokenTransfersLength > 0) _returnERC20TokensIfAny(tokenTransfers, originator);\n        _returnETHIfAny(originator);\n\n        emit Sweep(originator);\n    }\n\n    /**\n     * @notice Enable making ERC20 trades by setting the ERC20 enabled LooksRare aggregator\n     * @dev Must be called by the current owner. It can only be set once to prevent\n     *      a malicious aggregator from being set in case of an ownership compromise.\n     * @param _erc20EnabledLooksRareAggregator The ERC20 enabled LooksRare aggregator's address\n     */\n    function setERC20EnabledLooksRareAggregator(address _erc20EnabledLooksRareAggregator) external onlyOwner {\n        if (erc20EnabledLooksRareAggregator != address(0)) revert AlreadySet();\n        erc20EnabledLooksRareAggregator = _erc20EnabledLooksRareAggregator;\n        emit ERC20EnabledLooksRareAggregatorSet();\n    }\n\n    /**\n     * @notice Enable calling the specified proxy's trade function\n     * @dev Must be called by the current owner\n     * @param proxy The marketplace proxy's address\n     * @param selector The marketplace proxy's function selector\n     */\n    function addFunction(address proxy, bytes4 selector) external onlyOwner {\n        _proxyFunctionSelectors[proxy][selector] = true;\n        emit FunctionAdded(proxy, selector);\n    }\n\n    /**\n     * @notice Disable calling the specified proxy's trade function\n     * @dev Must be called by the current owner\n     * @param proxy The marketplace proxy's address\n     * @param selector The marketplace proxy's function selector\n     */\n    function removeFunction(address proxy, bytes4 selector) external onlyOwner {\n        delete _proxyFunctionSelectors[proxy][selector];\n        emit FunctionRemoved(proxy, selector);\n    }\n\n    /**\n     * @param proxy Proxy to apply the fee to\n     * @param bp Fee basis point\n     * @param recipient Fee recipient\n     */\n    function setFee(\n        address proxy,\n        uint256 bp,\n        address recipient\n    ) external onlyOwner {\n        if (bp > 10000) revert FeeTooHigh();\n        _proxyFeeData[proxy].bp = bp;\n        _proxyFeeData[proxy].recipient = recipient;\n\n        emit FeeUpdated(proxy, bp, recipient);\n    }\n\n    /**\n     * @notice Approve marketplaces to transfer ERC20 tokens from the aggregator\n     * @param marketplace The marketplace address to approve\n     * @param currency The ERC20 token address to approve\n     * @param amount The amount of ERC20 token to approve\n     */\n    function approve(\n        address marketplace,\n        address currency,\n        uint256 amount\n    ) external onlyOwner {\n        _executeERC20Approve(currency, marketplace, amount);\n    }\n\n    /**\n     * @param proxy The marketplace proxy's address\n     * @param selector The marketplace proxy's function selector\n     * @return Whether the marketplace proxy's function can be called from the aggregator\n     */\n    function supportsProxyFunction(address proxy, bytes4 selector) external view returns (bool) {\n        return _proxyFunctionSelectors[proxy][selector];\n    }\n\n    /**\n     * @notice Rescue any of the contract's trapped ERC721 tokens\n     * @dev Must be called by the current owner\n     * @param collection The address of the ERC721 token to rescue from the contract\n     * @param tokenId The token ID of the ERC721 token to rescue from the contract\n     * @param to Send the contract's specified ERC721 token ID to this address\n     */\n    function rescueERC721(\n        address collection,\n        address to,\n        uint256 tokenId\n    ) external onlyOwner {\n        _executeERC721TransferFrom(collection, address(this), to, tokenId);\n    }\n\n    /**\n     * @notice Rescue any of the contract's trapped ERC1155 tokens\n     * @dev Must be called by the current owner\n     * @param collection The address of the ERC1155 token to rescue from the contract\n     * @param tokenIds The token IDs of the ERC1155 token to rescue from the contract\n     * @param amounts The amount of each token ID to rescue\n     * @param to Send the contract's specified ERC1155 token ID to this address\n     */\n    function rescueERC1155(\n        address collection,\n        address to,\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts\n    ) external onlyOwner {\n        _executeERC1155SafeBatchTransferFrom(collection, address(this), to, tokenIds, amounts);\n    }\n\n    receive() external payable {}\n\n    function _encodeCalldataAndValidateFeeBp(\n        TradeData calldata singleTradeData,\n        address recipient,\n        bool isAtomic\n    ) private view returns (bytes memory proxyCalldata, bool maxFeeBpViolated) {\n        FeeData memory feeData = _proxyFeeData[singleTradeData.proxy];\n        maxFeeBpViolated = singleTradeData.maxFeeBp < feeData.bp;\n        proxyCalldata = abi.encodeWithSelector(\n            singleTradeData.selector,\n            singleTradeData.orders,\n            singleTradeData.ordersExtraData,\n            singleTradeData.extraData,\n            recipient,\n            isAtomic,\n            feeData.bp,\n            feeData.recipient\n        );\n    }\n\n    function _returnERC20TokensIfAny(TokenTransfer[] calldata tokenTransfers, address recipient) private {\n        uint256 tokenTransfersLength = tokenTransfers.length;\n        for (uint256 i; i < tokenTransfersLength; ) {\n            uint256 balance = IERC20(tokenTransfers[i].currency).balanceOf(address(this));\n            if (balance > 0) _executeERC20DirectTransfer(tokenTransfers[i].currency, recipient, balance);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/LooksRareAggregator.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {ReentrancyGuard} from \"./ReentrancyGuard.sol\";\nimport {LowLevelERC20Approve} from \"./lowLevelCallers/LowLevelERC20Approve.sol\";\nimport {LowLevelERC721Transfer} from \"./lowLevelCallers/LowLevelERC721Transfer.sol\";\nimport {LowLevelERC1155Transfer} from \"./lowLevelCallers/LowLevelERC1155Transfer.sol\";\nimport {IERC20} from \"./interfaces/IERC20.sol\";\nimport {LooksRareProxy} from \"./proxies/LooksRareProxy.sol\";\nimport {BasicOrder, TokenTransfer} from \"./libraries/OrderStructs.sol\";\nimport {TokenRescuer} from \"./TokenRescuer.sol\";\nimport {TokenReceiver} from \"./TokenReceiver.sol\";\nimport {ILooksRareAggregator} from \"./interfaces/ILooksRareAggregator.sol\";\nimport {BasicOrder, FeeData, TokenTransfer} from \"./libraries/OrderStructs.sol\";\nimport {LooksRareProxy} from \"./proxies/LooksRareProxy.sol\";\nimport {TokenReceiver} from \"./TokenReceiver.sol\";\nimport {TokenRescuer} from \"./TokenRescuer.sol\";\n\n/**\n * @title LooksRareAggregator\n * @notice This contract allows NFT sweepers to buy NFTs from different marketplaces\n *         by passing high-level structs + low-level bytes as calldata.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract LooksRareAggregator is\n    ILooksRareAggregator,\n    TokenRescuer,\n    TokenReceiver,\n    ReentrancyGuard,\n    LowLevelERC20Approve,\n    LowLevelERC721Transfer,\n    LowLevelERC1155Transfer\n{\n    /**\n     * @notice Transactions that only involve ETH orders should be submitted to this contract\n     *         directly. Transactions that involve ERC20 orders should be submitted to the contract\n     *         ERC20EnabledLooksRareAggregator and it will call this contract's execution function.\n     *         The purpose is to prevent a malicious proxy from stealing users' ERC20 tokens if\n     *         this contract's ownership is compromised. By not providing any allowances to this\n     *         aggregator, even if a malicious proxy is added, it cannot call\n     *         token.transferFrom(victim, attacker, amount) inside the proxy within the context of the\n     *         aggregator.\n     */\n    address public erc20EnabledLooksRareAggregator;\n    mapping(address => mapping(bytes4 => bool)) private _proxyFunctionSelectors;\n    mapping(address => FeeData) private _proxyFeeData;\n\n    /**\n     * @inheritdoc ILooksRareAggregator\n     */\n    function execute(\n        TokenTransfer[] calldata tokenTransfers,\n        TradeData[] calldata tradeData,\n        address originator,\n        address recipient,\n        bool isAtomic\n    ) external payable nonReentrant {\n        if (recipient == address(0)) revert ZeroAddress();\n        uint256 tradeDataLength = tradeData.length;\n        if (tradeDataLength == 0) revert InvalidOrderLength();\n\n        uint256 tokenTransfersLength = tokenTransfers.length;\n        if (tokenTransfersLength == 0) {\n            originator = msg.sender;\n        } else if (msg.sender != erc20EnabledLooksRareAggregator) {\n            revert UseERC20EnabledLooksRareAggregator();\n        }\n\n        for (uint256 i; i < tradeDataLength; ) {\n            TradeData calldata singleTradeData = tradeData[i];\n            if (!_proxyFunctionSelectors[singleTradeData.proxy][singleTradeData.selector]) revert InvalidFunction();\n\n            (bytes memory proxyCalldata, bool maxFeeBpViolated) = _encodeCalldataAndValidateFeeBp(\n                singleTradeData,\n                recipient,\n                isAtomic\n            );\n            if (maxFeeBpViolated) {\n                if (isAtomic) {\n                    revert FeeTooHigh();\n                } else {\n                    unchecked {\n                        ++i;\n                    }\n                    continue;\n                }\n            }\n            (bool success, bytes memory returnData) = singleTradeData.proxy.delegatecall(proxyCalldata);\n\n            if (!success) {\n                if (isAtomic) {\n                    if (returnData.length > 0) {\n                        assembly {\n                            let returnDataSize := mload(returnData)\n                            revert(add(32, returnData), returnDataSize)\n                        }\n                    } else {\n                        revert TradeExecutionFailed();\n                    }\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (tokenTransfersLength > 0) _returnERC20TokensIfAny(tokenTransfers, originator);\n        _returnETHIfAny(originator);\n\n        emit Sweep(originator);\n    }\n\n    /**\n     * @notice Enable making ERC20 trades by setting the ERC20 enabled LooksRare aggregator\n     * @dev Must be called by the current owner. It can only be set once to prevent\n     *      a malicious aggregator from being set in case of an ownership compromise.\n     * @param _erc20EnabledLooksRareAggregator The ERC20 enabled LooksRare aggregator's address\n     */\n    function setERC20EnabledLooksRareAggregator(address _erc20EnabledLooksRareAggregator) external onlyOwner {\n        if (erc20EnabledLooksRareAggregator != address(0)) revert AlreadySet();\n        erc20EnabledLooksRareAggregator = _erc20EnabledLooksRareAggregator;\n        emit ERC20EnabledLooksRareAggregatorSet();\n    }\n\n    /**\n     * @notice Enable calling the specified proxy's trade function\n     * @dev Must be called by the current owner\n     * @param proxy The marketplace proxy's address\n     * @param selector The marketplace proxy's function selector\n     */\n    function addFunction(address proxy, bytes4 selector) external onlyOwner {\n        _proxyFunctionSelectors[proxy][selector] = true;\n        emit FunctionAdded(proxy, selector);\n    }\n\n    /**\n     * @notice Disable calling the specified proxy's trade function\n     * @dev Must be called by the current owner\n     * @param proxy The marketplace proxy's address\n     * @param selector The marketplace proxy's function selector\n     */\n    function removeFunction(address proxy, bytes4 selector) external onlyOwner {\n        delete _proxyFunctionSelectors[proxy][selector];\n        emit FunctionRemoved(proxy, selector);\n    }\n\n    /**\n     * @param proxy Proxy to apply the fee to\n     * @param bp Fee basis point\n     * @param recipient Fee recipient\n     */\n    function setFee(\n        address proxy,\n        uint256 bp,\n        address recipient\n    ) external onlyOwner {\n        if (bp > 10000) revert FeeTooHigh();\n        _proxyFeeData[proxy].bp = bp;\n        _proxyFeeData[proxy].recipient = recipient;\n\n        emit FeeUpdated(proxy, bp, recipient);\n    }\n\n    /**\n     * @notice Approve marketplaces to transfer ERC20 tokens from the aggregator\n     * @param marketplace The marketplace address to approve\n     * @param currency The ERC20 token address to approve\n     * @param amount The amount of ERC20 token to approve\n     */\n    function approve(\n        address marketplace,\n        address currency,\n        uint256 amount\n    ) external onlyOwner {\n        _executeERC20Approve(currency, marketplace, amount);\n    }\n\n    /**\n     * @param proxy The marketplace proxy's address\n     * @param selector The marketplace proxy's function selector\n     * @return Whether the marketplace proxy's function can be called from the aggregator\n     */\n    function supportsProxyFunction(address proxy, bytes4 selector) external view returns (bool) {\n        return _proxyFunctionSelectors[proxy][selector];\n    }\n\n    /**\n     * @notice Rescue any of the contract's trapped ERC721 tokens\n     * @dev Must be called by the current owner\n     * @param collection The address of the ERC721 token to rescue from the contract\n     * @param tokenId The token ID of the ERC721 token to rescue from the contract\n     * @param to Send the contract's specified ERC721 token ID to this address\n     */\n    function rescueERC721(\n        address collection,\n        address to,\n        uint256 tokenId\n    ) external onlyOwner {\n        _executeERC721TransferFrom(collection, address(this), to, tokenId);\n    }\n\n    /**\n     * @notice Rescue any of the contract's trapped ERC1155 tokens\n     * @dev Must be called by the current owner\n     * @param collection The address of the ERC1155 token to rescue from the contract\n     * @param tokenIds The token IDs of the ERC1155 token to rescue from the contract\n     * @param amounts The amount of each token ID to rescue\n     * @param to Send the contract's specified ERC1155 token ID to this address\n     */\n    function rescueERC1155(\n        address collection,\n        address to,\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts\n    ) external onlyOwner {\n        _executeERC1155SafeBatchTransferFrom(collection, address(this), to, tokenIds, amounts);\n    }\n\n    receive() external payable {}\n\n    function _encodeCalldataAndValidateFeeBp(\n        TradeData calldata singleTradeData,\n        address recipient,\n        bool isAtomic\n    ) private view returns (bytes memory proxyCalldata, bool maxFeeBpViolated) {\n        FeeData memory feeData = _proxyFeeData[singleTradeData.proxy];\n        maxFeeBpViolated = singleTradeData.maxFeeBp < feeData.bp;\n        proxyCalldata = abi.encodeWithSelector(\n            singleTradeData.selector,\n            singleTradeData.orders,\n            singleTradeData.ordersExtraData,\n            singleTradeData.extraData,\n            recipient,\n            isAtomic,\n            feeData.bp,\n            feeData.recipient\n        );\n    }\n\n    function _returnERC20TokensIfAny(TokenTransfer[] calldata tokenTransfers, address recipient) private {\n        uint256 tokenTransfersLength = tokenTransfers.length;\n        for (uint256 i; i < tok"
    }
  ]
}