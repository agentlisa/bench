{
  "Title": "[09] Don't allow adding a new derivative when staking/unstaking is paused",
  "Content": "\nWhen the system is in pause mode, e.g. staking and unstaking is blocked, consider adding a check to prevent new derivatives from being added, e.g.\n\n```\nrequire(!pausedStaking && !pauseUnstaking, \"error\");\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L182-L195\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-03-asymmetry",
  "Code": [
    {
      "filename": "contracts/SafEth/SafEth.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"../interfaces/uniswap/ISwapRouter.sol\";\nimport \"../interfaces/lido/IWStETH.sol\";\nimport \"../interfaces/lido/IstETH.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./SafEthStorage.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\n/// @title Contract that mints/burns and provides owner functions for safETH\n/// @author Asymmetry Finance\ncontract SafEth is\n    Initializable,\n    ERC20Upgradeable,\n    OwnableUpgradeable,\n    SafEthStorage\n{\n    event ChangeMinAmount(uint256 indexed minAmount);\n    event ChangeMaxAmount(uint256 indexed maxAmount);\n    event StakingPaused(bool indexed paused);\n    event UnstakingPaused(bool indexed paused);\n    event SetMaxSlippage(uint256 indexed index, uint256 slippage);\n    event Staked(address indexed recipient, uint ethIn, uint safEthOut);\n    event Unstaked(address indexed recipient, uint ethOut, uint safEthIn);\n    event WeightChange(uint indexed index, uint weight);\n    event DerivativeAdded(\n        address indexed contractAddress,\n        uint weight,\n        uint index\n    );\n    event Rebalanced();\n\n    // As recommended by https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n        @notice - Function to initialize values for the contracts\n        @dev - This replaces the constructor for upgradeable contracts\n        @param _tokenName - name of erc20\n        @param _tokenSymbol - symbol of erc20\n    */\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol\n    ) external initializer {\n        ERC20Upgradeable.__ERC20_init(_tokenName, _tokenSymbol);\n        _transferOwnership(msg.sender);\n        minAmount = 5 * 10 ** 17; // initializing with .5 ETH as minimum\n        maxAmount = 200 * 10 ** 18; // initializing with 200 ETH as maximum\n    }\n\n    /**\n        @notice - Stake your ETH into safETH\n        @dev - Deposits into each derivative based on its weight\n        @dev - Mints safEth in a redeemable value which equals to the correct percentage of the total staked value\n    */\n    function stake() external payable {\n        require(pauseStaking == false, \"staking is paused\");\n        require(msg.value >= minAmount, \"amount too low\");\n        require(msg.value <= maxAmount, \"amount too high\");\n\n        uint256 underlyingValue = 0;\n\n        // Getting underlying value in terms of ETH for each derivative\n        for (uint i = 0; i < derivativeCount; i++)\n            underlyingValue +=\n                (derivatives[i].ethPerDerivative(derivatives[i].balance()) *\n                    derivatives[i].balance()) /\n                10 ** 18;\n\n        uint256 totalSupply = totalSupply();\n        uint256 preDepositPrice; // Price of safETH in regards to ETH\n        if (totalSupply == 0)\n            preDepositPrice = 10 ** 18; // initializes with a price of 1\n        else preDepositPrice = (10 ** 18 * underlyingValue) / totalSupply;\n\n        uint256 totalStakeValueEth = 0; // total amount of derivatives worth of ETH in system\n        for (uint i = 0; i < derivativeCount; i++) {\n            uint256 weight = weights[i];\n            IDerivative derivative = derivatives[i];\n            if (weight == 0) continue;\n            uint256 ethAmount = (msg.value * weight) / totalWeight;\n\n            // This is slightly less than ethAmount because slippage\n            uint256 depositAmount = derivative.deposit{value: ethAmount}();\n            uint derivativeReceivedEthValue = (derivative.ethPerDerivative(\n                depositAmount\n            ) * depositAmount) / 10 ** 18;\n            totalStakeValueEth += derivativeReceivedEthValue;\n        }\n        // mintAmount represents a percentage of the total assets in the system\n        uint256 mintAmount = (totalStakeValueEth * 10 ** 18) / preDepositPrice;\n        _mint(msg.sender, mintAmount);\n        emit Staked(msg.sender, msg.value, mintAmount);\n    }\n\n    /**\n        @notice - Unstake your safETH into ETH\n        @dev - unstakes a percentage of safEth based on its total value\n        @param _safEthAmount - amount of safETH to unstake into ETH\n    */\n    function unstake(uint256 _safEthAmount) external {\n        require(pauseUnstaking == false, \"unstaking is paused\");\n        uint256 safEthTotalSupply = totalSupply();\n        uint256 ethAmountBefore = address(this).balance;\n\n        for (uint256 i = 0; i < derivativeCount; i++) {\n            // withdraw a percentage of each asset based on the amount of safETH\n            uint256 derivativeAmount = (derivatives[i].balance() *\n                _safEthAmount) / safEthTotalSupply;\n            if (derivativeAmount == 0) continue; // if derivative empty ignore\n            derivatives[i].withdraw(derivativeAmount);\n        }\n        _burn(msg.sender, _safEthAmount);\n        uint256 ethAmountAfter = address(this).balance;\n        uint256 ethAmountToWithdraw = ethAmountAfter - ethAmountBefore;\n        // solhint-disable-next-line\n        (bool sent, ) = address(msg.sender).call{value: ethAmountToWithdraw}(\n            \"\"\n        );\n        require(sent, \"Failed to send Ether\");\n        emit Unstaked(msg.sender, ethAmountToWithdraw, _safEthAmount);\n    }\n\n    /**\n        @notice - Rebalance each derivative to resemble the weight set for it\n        @dev - Withdraws all derivative and re-deposit them to have the correct weights\n        @dev - Depending on the balance of the derivative this could cause bad slippage\n        @dev - If weights are updated then it will slowly change over time to the correct weight distribution\n        @dev - Probably not going to be used often, if at all\n    */\n    function rebalanceToWeights() external onlyOwner {\n        uint256 ethAmountBefore = address(this).balance;\n        for (uint i = 0; i < derivativeCount; i++) {\n            if (derivatives[i].balance() > 0)\n                derivatives[i].withdraw(derivatives[i].balance());\n        }\n        uint256 ethAmountAfter = address(this).balance;\n        uint256 ethAmountToRebalance = ethAmountAfter - ethAmountBefore;\n\n        for (uint i = 0; i < derivativeCount; i++) {\n            if (weights[i] == 0 || ethAmountToRebalance == 0) continue;\n            uint256 ethAmount = (ethAmountToRebalance * weights[i]) /\n                totalWeight;\n            // Price will change due to slippage\n            derivatives[i].deposit{value: ethAmount}();\n        }\n        emit Rebalanced();\n    }\n\n    /**\n        @notice - Adds new derivative to the index fund\n        @dev - Weights are only in regards to each other, total weight changes with this function\n        @dev - If you want exact weights either do the math off chain or reset all existing derivates to the weights you want\n        @dev - Weights are approximate as it will slowly change as people stake\n        @param _derivativeIndex - index of the derivative you want to update the weight\n        @param _weight - new weight for this derivative.\n    */\n    function adjustWeight(\n        uint256 _derivativeIndex,\n        uint256 _weight\n    ) external onlyOwner {\n        weights[_derivativeIndex] = _weight;\n        uint256 localTotalWeight = 0;\n        for (uint256 i = 0; i < derivativeCount; i++)\n            localTotalWeight += weights[i];\n        totalWeight = localTotalWeight;\n        emit WeightChange(_derivativeIndex, _weight);\n    }\n\n    /**\n        @notice - Adds new derivative to the index fund\n        @param _contractAddress - Address of the derivative contract launched by AF\n        @param _weight - new weight for this derivative. \n    */\n    function addDerivative(\n        address _contractAddress,\n        uint256 _weight\n    ) external onlyOwner {\n        derivatives[derivativeCount] = IDerivative(_contractAddress);\n        weights[derivativeCount] = _weight;\n        derivativeCount++;\n\n        uint256 localTotalWeight = 0;\n        for (uint256 i = 0; i < derivativeCount; i++)\n            localTotalWeight += weights[i];\n        totalWeight = localTotalWeight;\n        emit DerivativeAdded(_contractAddress, _weight, derivativeCount);\n    }\n\n    /**\n        @notice - Sets the max slippage for a certain derivative index\n        @param _derivativeIndex - index of the derivative you want to update the slippage\n        @param _slippage - new slippage amount in wei\n    */\n    function setMaxSlippage(\n        uint _derivativeIndex,\n        uint _slippage\n    ) external onlyOwner {\n        derivatives[_derivativeIndex].setMaxSlippage(_slippage);\n        emit SetMaxSlippage(_derivativeIndex, _slippage);\n    }\n\n    /**\n        @notice - Sets the minimum amount a user is allowed to stake\n        @param _minAmount - amount to set as minimum stake value\n    */\n    function setMinAmount(uint256 _minAmount) external onlyOwner {\n        minAmount = _minAmount;\n        emit ChangeMinAmount(minAmount);\n    }\n\n    /**\n        @notice - Owner only function that sets the maximum amount a user is allowed to stake\n        @param _maxAmount - amount to set as maximum stake value\n    */\n    function setMaxAmount(uint256 _maxAmount) external onlyOwner {\n        maxAmount = _maxAmount;\n        emit ChangeMaxAmount(maxAmount);\n    }\n\n    /**\n        @notice - Owner only function that Enables/Disables the stake function\n        @param _pause - true disables staking / false enables staking\n    */\n    function setPauseStaking(bool _pause) external onlyOwner {\n        pauseStaking = _pause;\n        emit StakingPaused(pauseStaking);\n    }\n\n    /**\n        @notice - Owner only function that enables/disables the unstake function\n        @param _pause - true disables unstaking / false enables unstaking\n    */\n    function setPauseUnstaking(bool _pause) external onlyOwner {\n        pauseUnstaking = _pause;\n        emit UnstakingPaused(pauseUnstaking);\n    }\n\n    receive() external payable {}\n}"
    }
  ]
}