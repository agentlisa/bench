{
  "Title": "[M-10] The user is enforced to overpay for the `fallback` gas when calling `retryDeposit`",
  "Content": "\n`BranchBridgeAgent.retryDeposit` is used to top up a previous deposit and perform a call afterward. The modifier `requiresFallbackGas` is added to the method to verify that enough gas is deposited to pay for an eventual `fallback` call. The same is done when creating a new deposit.\n\n- `retryDeposit`\n\n```\n\n    \tfunction retryDeposit(\n    \t\tbool _isSigned,\n    \t\tuint32 _depositNonce,\n    \t\tbytes calldata _params,\n    \t\tuint128 _remoteExecutionGas,\n    \t\tuint24 _toChain\n    \t) external payable lock requiresFallbackGas {\n    \t\t//Check if deposit belongs to message sender\n    \t\tif (getDeposit[_depositNonce].owner != msg.sender) revert NotDepositOwner();\n\n    \t.\n    \t.\n    \t.\n    \t.\n\n```\n\n<https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L319-L328>\n\n- An example of a new deposit/call:\n\n```solidity\n// One example\n    function callOutSignedAndBridge(bytes calldata _params, DepositInput memory _dParams, uint128 _remoteExecutionGas)\n        external\n        payable\n        lock\n        requiresFallbackGas\n    {\n\n// Another one\n    function callOutSignedAndBridgeMultiple(\n        bytes calldata _params,\n        DepositMultipleInput memory _dParams,\n        uint128 _remoteExecutionGas\n    ) external payable lock requiresFallbackGas {\n\n```\n\nLet's have a look at the modifier `requiresFallbackGas`:\n```\n\n        /// @notice Modifier that verifies enough gas is deposited to pay for an eventual fallback call.\n        modifier requiresFallbackGas() {\n            _requiresFallbackGas();\n            _;\n        }\n\n        /// @notice Verifies enough gas is deposited to pay for an eventual fallback call. Reuse to reduce contract bytesize.\n        function _requiresFallbackGas() internal view virtual {\n            if (msg.value <= MIN_FALLBACK_RESERVE * tx.gasprice) revert InsufficientGas();\n        }\n\n```\n\n<https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1404-L1412>\n\nIt checks if the `msg.value` (deposited gas) is sufficient. This is used for both a new deposit and topping up an existing deposit. For a new deposit, it makes sense. However, for topping up an existing deposit, it doesn't consider the old deposited amount which enforces the user to overpay for the gas when `retryDeposit` is called Please have a look at the PoC to get a clearer picture.\n\n### Proof of Concept\n\nImagine the following scenario:\n\n- Bob makes a request by `BaseBranchRouter.callOutAndBridge` with `msg.value` 0.1 ETH (deposited gas is 0.1 ETH), assuming the cost of `MIN_FALLBACK_RESERVE` is 0.1 ETH.\n- This calls `BranchBridgeAgent.performCallOutAndBridge`.\n- `BranchBridgeAgent` creates deposit and sends the Cross-Chain request by calling `AnycallProxy.anyCall`.\n- Now, the ``AnyCall` Executor` calls `RootBridgeAgent.anyExecute`.\n\nLet's say `RootBridgeAgent.anyExecute` couldn't complete due to insufficient available gas:\n\n```solidity\n\t//Get Available Gas\n\tuint256 availableGas = _depositedGas - _gasToBridgeOut;\n\n\t//Get Root Environment Execution Cost\n\tuint256 minExecCost = tx.gasprice * (MIN_EXECUTION_OVERHEAD + _initialGas - gasleft());\n\n\t//Check if sufficient balance\n\tif (minExecCost > availableGas) {\n\t\t_forceRevert();\n\t\treturn;\n\t}\n```\n\n<https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L810-L817>\n\nNotice that this `_forceReverts` and doesn't revert directly. This is to avoid triggering the `fallback` in `BranchBridgeAgent` (below is an explanation of `_forceRevert`):\n\n- Let's assume that the additional required deposit was 0.05 ETH.\n- So now Bob should top up the deposit with 0.05 ETH.\n- Bob calls `BranchBridgeAgent.retryDeposit` and since there is a `requiresFallbackGas` modifier, they have to pass at least 0.1 ETH cost of `MIN_FALLBACK_RESERVE`. Thus, overpaying when it is not necessary.\n\nThis happens due to the lack of considering the already existing deposited gas amount.\n\n*Note: for simplicity, we assumed that `tx.gasPrice` didn't change.*\n\n### About `_forceRevert`\n\n`_forceRevert` withdraws all of the execution budget:\n\n    \t// Withdraw all execution gas budget from anycall for tx to revert with \"no enough budget\"\n    \tif (executionBudget > 0) try anycallConfig.withdraw(executionBudget) {} catch {}\n\nSo `Anycall Executor` will revert if there is not enough budget. This is done at:\n\n```solidity\n\tuint256 budget = executionBudget[_from];\n\trequire(budget > totalCost, \"no enough budget\");\n\texecutionBudget[_from] = budget - totalCost;\n```\n\n<https://github.com/anyswap/multichain-smart-contracts/blob/main/contracts/anycall/v7/AnycallV7Config.sol#L206C42-L206C58>\n\nThis way, we avoid reverting directly. Instead, we let the `Anycall Executor` to revert, to avoid triggering the `fallback`.\n\n### Recommended Mitigation Steps\n\nFor `retryDeposit`, use the internal function `_requiresFallbackGas(uint256 _depositedGas)` instead of the modifier. Pass the existing deposited `gas + msg.value` to the function.\n\nExample:\n\n```solidity\n_requiresFallbackGas(getDeposit[_depositNonce].depositedGas+msg.value)\n```\n\n<https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1415-L1417>\n\n**[0xBugsy (Maia) disputed and commented](https://github.com/code-423n4/2023-05-maia-findings/issues/710#issuecomment-1632858333):**\n > It is intended. There are no gas refunds on failures, as it would be hard/expensive to gauge how much gas was spent on the remote execution before failure.\n\n**[Trust (judge) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/710#issuecomment-1647942751):**\n > Similar to [#718](https://github.com/code-423n4/2023-05-maia-findings/issues/718).\n >\n> @0xBugsy - Did you document anywhere that this is intended?\n\n**[0xBugsy (Maia) confirmed and commented](https://github.com/code-423n4/2023-05-maia-findings/issues/710#issuecomment-1651955210):**\n > Upon further thought, if a given deposit has not been set to `redeemable` via `fallback`, the user could be allowed to `retryDeposit` without paying for the `fallback` gas, since it has not yet been spent.\n\n**[0xLightt (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/710#issuecomment-1708807323):**\n > We recognize the audit's findings on Anycall Gas Management. These will not be rectified due to the upcoming migration of this section to LayerZero.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/ulysses-omnichain/BranchBridgeAgent.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {WETH9} from \"./interfaces/IWETH9.sol\";\n\nimport {AnycallFlags} from \"./lib/AnycallFlags.sol\";\nimport {IAnycallProxy} from \"./interfaces/IAnycallProxy.sol\";\nimport {IAnycallConfig} from \"./interfaces/IAnycallConfig.sol\";\nimport {IAnycallExecutor} from \"./interfaces/IAnycallExecutor.sol\";\nimport {IApp, IBranchBridgeAgent} from \"./interfaces/IBranchBridgeAgent.sol\";\nimport {IBranchRouter as IRouter} from \"./interfaces/IBranchRouter.sol\";\nimport {IBranchPort as IPort} from \"./interfaces/IBranchPort.sol\";\n\nimport {ERC20hTokenBranch as ERC20hToken} from \"./token/ERC20hTokenBranch.sol\";\nimport {BranchBridgeAgentExecutor, DeployBranchBridgeAgentExecutor} from \"./BranchBridgeAgentExecutor.sol\";\nimport {\n    Deposit,\n    DepositStatus,\n    DepositInput,\n    DepositMultipleInput,\n    DepositParams,\n    DepositMultipleParams,\n    SettlementParams,\n    SettlementMultipleParams\n} from \"./interfaces/IBranchBridgeAgent.sol\";\n\n/// @title Library for Branch Bridge Agent Deployment\nlibrary DeployBranchBridgeAgent {\n    function deploy(\n        WETH9 _wrappedNativeToken,\n        uint256 _rootChainId,\n        uint256 _localChainId,\n        address _rootBridgeAgentAddress,\n        address _localAnyCallAddress,\n        address _localAnyCallExecutorAddress,\n        address _localRouterAddress,\n        address _localPortAddress\n    ) external returns (BranchBridgeAgent) {\n        return new BranchBridgeAgent(\n            _wrappedNativeToken,\n            _rootChainId,\n            _localChainId,\n            _rootBridgeAgentAddress,\n            _localAnyCallAddress,\n            _localAnyCallExecutorAddress,\n            _localRouterAddress,\n            _localPortAddress\n        );\n    }\n}\n\n/// @title Branch Bridge Agent Contract\ncontract BranchBridgeAgent is IBranchBridgeAgent {\n    using SafeTransferLib for address;\n    using SafeCastLib for uint256;\n\n    /*///////////////////////////////////////////////////////////////\n                            ENCODING CONSTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// AnyExec Decode Consts\n\n    uint8 internal constant PARAMS_START = 1;\n\n    uint8 internal constant PARAMS_START_SIGNED = 21;\n\n    uint8 internal constant PARAMS_ENTRY_SIZE = 32;\n\n    uint8 internal constant PARAMS_GAS_OUT = 16;\n\n    /// ClearTokens Decode Consts\n\n    uint8 internal constant PARAMS_TKN_START = 5;\n\n    uint8 internal constant PARAMS_AMT_OFFSET = 64;\n\n    uint8 internal constant PARAMS_DEPOSIT_OFFSET = 96;\n\n    /*///////////////////////////////////////////////////////////////\n                        BRIDGE AGENT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Chain Id for Root Chain where liqudity is virtualized(e.g. 4).\n    uint256 public immutable rootChainId;\n\n    /// @notice Chain Id for Local Chain.\n    uint256 public immutable localChainId;\n\n    /// @notice Address for Local Wrapped Native Token.\n    WETH9 public immutable wrappedNativeToken;\n\n    /// @notice Address for Bridge Agent who processes requests submitted for the Root Router Address where cross-chain requests are executed in the Root Chain.\n    address public immutable rootBridgeAgentAddress;\n\n    /// @notice Address for Local AnycallV7 Proxy Address where cross-chain requests are sent to the Root Chain Router.\n    address public immutable localAnyCallAddress;\n\n    /// @notice Address for Local Anyexec Address where cross-chain requests from the Root Chain Router are received locally.\n    address public immutable localAnyCallExecutorAddress;\n\n    /// @notice Address for Local Router used for custom actions for different hApps.\n    address public immutable localRouterAddress;\n\n    /// @notice Address for Local Port Address where funds deposited from this chain are kept, managed and supplied to different Port Strategies.\n    address public immutable localPortAddress;\n\n    address public bridgeAgentExecutorAddress;\n\n    /*///////////////////////////////////////////////////////////////\n                        DEPOSITS STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Deposit nonce used for identifying transaction.\n    uint32 public depositNonce;\n\n    /// @notice Mapping from Pending deposits hash to Deposit Struct.\n    mapping(uint32 => Deposit) public getDeposit;\n\n    /*///////////////////////////////////////////////////////////////\n                            EXECUTOR STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice If true, bridge agent has already served a request with this nonce from  a given chain. Chain -> Nonce -> Bool\n    mapping(uint32 => bool) public executionHistory;\n\n    /*///////////////////////////////////////////////////////////////\n                        GAS MANAGEMENT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public remoteCallDepositedGas;\n\n    uint256 internal constant MIN_FALLBACK_RESERVE = 185_000; // 100_000 for anycall + 85_000 fallback execution overhead\n    uint256 internal constant MIN_EXECUTION_OVERHEAD = 160_000; // 100_000 for anycall + 35_000 Pre 1st Gas Checkpoint Execution + 25_000 Post last Gas Checkpoint Executions\n    uint256 internal constant TRANSFER_OVERHEAD = 24_000;\n\n    constructor(\n        WETH9 _wrappedNativeToken,\n        uint256 _rootChainId,\n        uint256 _localChainId,\n        address _rootBridgeAgentAddress,\n        address _localAnyCallAddress,\n        address _localAnyCallExecutorAddress,\n        address _localRouterAddress,\n        address _localPortAddress\n    ) {\n        require(_rootBridgeAgentAddress != address(0), \"Root Bridge Agent Address cannot be the zero address.\");\n        require(_localAnyCallAddress != address(0), \"AnyCall Address cannot be the zero address.\");\n        require(_localAnyCallExecutorAddress != address(0), \"AnyCall Executor Address cannot be the zero address.\");\n        require(_localRouterAddress != address(0), \"Local Router Address cannot be the zero address.\");\n        require(_localPortAddress != address(0), \"Local Port Address cannot be the zero address.\");\n\n        wrappedNativeToken = _wrappedNativeToken;\n        localChainId = _localChainId;\n        rootChainId = _rootChainId;\n        rootBridgeAgentAddress = _rootBridgeAgentAddress;\n        localAnyCallAddress = _localAnyCallAddress;\n        localAnyCallExecutorAddress = _localAnyCallExecutorAddress;\n        localRouterAddress = _localRouterAddress;\n        localPortAddress = _localPortAddress;\n        bridgeAgentExecutorAddress = DeployBranchBridgeAgentExecutor.deploy();\n        depositNonce = 1;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchBridgeAgent\n    function getDepositEntry(uint32 _depositNonce) external view returns (Deposit memory) {\n        return getDeposit[_depositNonce];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        USER EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOut(bytes calldata _params, uint128 _remoteExecutionGas) external payable lock requiresFallbackGas {\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Perform Call without deposit\n        _callOut(msg.sender, _params, msg.value.toUint128(), _remoteExecutionGas);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutAndBridge(bytes calldata _params, DepositInput memory _dParams, uint128 _remoteExecutionGas)\n        external\n        payable\n        lock\n        requiresFallbackGas\n    {\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Perform Call with deposit\n        _callOutAndBridge(msg.sender, _params, _dParams, msg.value.toUint128(), _remoteExecutionGas);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutAndBridgeMultiple(\n        bytes calldata _params,\n        DepositMultipleInput memory _dParams,\n        uint128 _remoteExecutionGas\n    ) external payable lock requiresFallbackGas {\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Perform Call with multiple deposits\n        _callOutAndBridgeMultiple(msg.sender, _params, _dParams, msg.value.toUint128(), _remoteExecutionGas);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutSigned(bytes calldata _params, uint128 _remoteExecutionGas)\n        external\n        payable\n        lock\n        requiresFallbackGas\n    {\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(\n            bytes1(0x04), msg.sender, depositNonce, _params, msg.value.toUint128(), _remoteExecutionGas\n        );\n\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Perform Signed Call without deposit\n        _noDepositCall(msg.sender, packedData, msg.value.toUint128());\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutSignedAndBridge(bytes calldata _params, DepositInput memory _dParams, uint128 _remoteExecutionGas)\n        external\n        payable\n        lock\n        requiresFallbackGas\n    {\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(\n            bytes1(0x05),\n            msg.sender,\n            depositNonce,\n            _dParams.hToken,\n            _dParams.token,\n            _dParams.amount,\n            _normalizeDecimals(_dParams.deposit, ERC20(_dParams.token).decimals()),\n            _dParams.toChain,\n            _params,\n            msg.value.toUint128(),\n            _remoteExecutionGas\n        );\n\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Create Deposit and Send Cross-Chain request\n        _depositAndCall(\n            msg.sender,\n            packedData,\n            _dParams.hToken,\n            _dParams.token,\n            _dParams.amount,\n            _dParams.deposit,\n            msg.value.toUint128()\n        );\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutSignedAndBridgeMultiple(\n        bytes calldata _params,\n        DepositMultipleInput memory _dParams,\n        uint128 _remoteExecutionGas\n    ) external payable lock requiresFallbackGas {\n        //Normalize Deposits\n        uint256[] memory _deposits = new uint256[](_dParams.hTokens.length);\n\n        for (uint256 i = 0; i < _dParams.hTokens.length; i++) {\n            _deposits[i] = _normalizeDecimals(_dParams.deposits[i], ERC20(_dParams.tokens[i]).decimals());\n        }\n\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(\n            bytes1(0x06),\n            msg.sender,\n            uint8(_dParams.hTokens.length),\n            depositNonce,\n            _dParams.hTokens,\n            _dParams.tokens,\n            _dParams.amounts,\n            _deposits,\n            _dParams.toChain,\n            _params,\n            msg.value.toUint128(),\n            _remoteExecutionGas\n        );\n\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Create Deposit and Send Cross-Chain request\n        _depositAndCallMultiple(\n            msg.sender,\n            packedData,\n            _dParams.hTokens,\n            _dParams.tokens,\n            _dParams.amounts,\n            _dParams.deposits,\n            msg.value.toUint128()\n        );\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function retryDeposit(\n        bool _isSigned,\n        uint32 _depositNonce,\n        bytes calldata _params,\n        uint128 _remoteExecutionGas,\n        uint24 _toChain\n    ) external payable lock requiresFallbackGas {\n        //Check if deposit belongs to message sender\n        if (getDeposit[_depositNonce].owner != msg.sender) revert NotDepositOwner();\n\n        //Encode Data for cross-chain call.\n        bytes memory packedData;\n\n        if (uint8(getDeposit[_depositNonce].hTokens.length) == 1) {\n            if (_isSigned) {\n                packedData = abi.encodePacked(\n                    bytes1(0x05),\n                    msg.sender,\n                    _depositNonce,\n                    getDeposit[_depositNonce].hTokens[0],\n                    getDeposit[_depositNonce].tokens[0],\n                    getDeposit[_depositNonce].amounts[0],\n                    _normalizeDecimals(\n                        getDeposit[_depositNonce].deposits[0], ERC20(getDeposit[_depositNonce].tokens[0]).decimals()\n                    ),\n                    _toChain,\n                    _params,\n                    msg.value.toUint128(),\n                    _remoteExecutionGas\n                );\n            } else {\n                packedData = abi.encodePacked(\n                    bytes1(0x02),\n                    _depositNonce,\n                    getDeposit[_depositNonce].hTokens[0],\n                    getDeposit[_depositNonce].tokens[0],\n                    getDeposit[_depositNonce].amounts[0],\n                    _normalizeDecimals(\n                        getDeposit[_depositNonce].deposits[0], ERC20(getDeposit[_depositNonce].tokens[0]).decimals()\n                    ),\n                    _toChain,\n                    _params,\n                    msg.value.toUint128(),\n                    _remoteExecutionGas\n                );\n            }\n        } else if (uint8(getDeposit[_depositNonce].hTokens.length) > 1) {\n            //Nonce\n            uint32 nonce = _depositNonce;\n\n            if (_isSigned) {\n                packedData = abi.encodePacked(\n                    bytes1(0x06),\n                    msg.sender,\n                    uint8(getDeposit[_depositNonce].hTokens.length),\n                    nonce,\n                    getDeposit[nonce].hTokens,\n                    getDeposit[nonce].tokens,\n                    getDeposit[nonce].amounts,\n                    _normalizeDecimalsMultiple(getDeposit[nonce].deposits, getDeposit[nonce].tokens),\n                    _toChain,\n                    _params,\n                    msg.value.toUint128(),\n                    _remoteExecutionGas\n                );\n            } else {\n                packedData = abi.encodePacked(\n                    bytes1(0x03),\n                    uint8(getDeposit[nonce].hTokens.length),\n                    _depositNonce,\n                    getDeposit[nonce].hTokens,\n                    getDeposit[nonce].tokens,\n                    getDeposit[nonce].amounts,\n                    _normalizeDecimalsMultiple(getDeposit[nonce].deposits, getDeposit[nonce].tokens),\n                    _toChain,\n                    _params,\n                    msg.value.toUint128(),\n                    _remoteExecutionGas\n                );\n            }\n        }\n\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Deposit Gas to Port\n        _depositGas(msg.value.toUint128());\n\n        //Ensure success Status\n        getDeposit[_depositNonce].status = DepositStatus.Success;\n\n        //Update Deposited Gas\n        getDeposit[_depositNonce].depositedGas = msg.value.toUint128();\n\n        //Perform Call\n        _performCall(packedData);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function retrySettlement(uint32 _settlementNonce, uint128 _gasToBoostSettlement)\n        external\n        payable\n        lock\n        requiresFallbackGas\n    {\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(\n            bytes1(0x07), depositNonce++, _settlementNonce, msg.value.toUint128(), _gasToBoostSettlement\n        );\n        //Update State and Perform Call\n        _sendRetrieveOrRetry(packedData);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function retrieveDeposit(uint32 _depositNonce) external payable lock requiresFallbackGas {\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(bytes1(0x08), _depositNonce, msg.value.toUint128(), uint128(0));\n\n        //Update State and Perform Call\n        _sendRetrieveOrRetry(packedData);\n    }\n\n    function _sendRetrieveOrRetry(bytes memory _data) internal {\n        //Deposit Gas for call.\n        _createGasDeposit(msg.sender, msg.value.toUint128());\n\n        //Perform Call\n        _performCall(_data);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function redeemDeposit(uint32 _depositNonce) external lock {\n        //Update Deposit\n        if (getDeposit[_depositNonce].status != DepositStatus.Failed) {\n            revert DepositRedeemUnavailable();\n        }\n        _redeemDeposit(_depositNonce);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    BRANCH ROUTER EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchBridgeAgent\n    function performSystemCallOut(\n        address _depositor,\n        bytes calldata _params,\n        uint128 _gasToBridgeOut,\n        uint128 _remoteExecutionGas\n    ) external payable lock requiresRouter {\n        //Get remote call execution deposited gas.\n        (uint128 gasToBridgeOut, bool isRemote) =\n            (remoteCallDepositedGas > 0 ? (_gasToBridgeOut, true) : (msg.value.toUint128(), false));\n\n        //Wrap the gas allocated for omnichain execution.\n        if (!isRemote && gasToBridgeOut > 0) wrappedNativeToken.deposit{value: msg.value}();\n\n        //Check Fallback Gas\n        _requiresFallbackGas(gasToBridgeOut);\n\n        //Encode Data for cross-chain call.\n        bytes memory packedData =\n            abi.encodePacked(bytes1(0x00), depositNonce, _params, gasToBridgeOut, _remoteExecutionGas);\n\n        //Perform Call\n        _noDepositCall(_depositor, packedData, gasToBridgeOut);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function performCallOut(\n        address _depositor,\n        bytes calldata _params,\n        uint128 _gasToBridgeOut,\n        uint128 _remoteExecutionGas\n    ) external payable lock requiresRouter {\n        //Get remote call execution deposited gas.\n        (uint128 gasToBridgeOut, bool isRemote) =\n            (remoteCallDepositedGas > 0 ? (_gasToBridgeOut, true) : (msg.value.toUint128(), false));\n\n        //Wrap the gas allocated for omnichain execution.\n        if (!isRemote && gasToBridgeOut > 0) wrappedNativeToken.deposit{value: msg.value}();\n\n        //Check Fallback Gas\n        _requiresFallbackGas(gasToBridgeOut);\n\n        //Perform Call\n        _callOut(_depositor, _params, gasToBridgeOut, _remoteExecutionGas);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function performCallOutAndBridge(\n        address _depositor,\n        bytes calldata _params,\n        DepositInput memory _dParams,\n        uint128 _gasToBridgeOut,\n        uint128 _remoteExecutionGas\n    ) external payable lock requiresRouter {\n        //Get remote call execution deposited gas.\n        (uint128 gasToBridgeOut, bool isRemote) =\n            (remoteCallDepositedGas > 0 ? (_gasToBridgeOut, true) : (msg.value.toUint128(), false));\n\n        //Wrap the gas allocated for omnichain execution.\n        if (!isRemote && gasToBridgeOut > 0) wrappedNativeToken.deposit{value: msg.value}();\n\n        //Check Fallback Gas\n        _requiresFallbackGas(gasToBridgeOut);\n\n        //Perform Call\n        _callOutAndBridge(_depositor, _params, _dParams, gasToBridgeOut, _remoteExecutionGas);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function performCallOutAndBridgeMultiple(\n        address _depositor,\n        bytes calldata _params,\n        DepositMultipleInput memory _dParams,\n        uint128 _gasToBridgeOut,\n        uint128 _remoteExecutionGas\n    ) external payable lock requiresRouter {\n        //Get remote call execution deposited gas.\n        (uint128 gasToBridgeOut, bool isRemote) =\n            (remoteCallDepositedGas > 0 ? (_gasToBridgeOut, true) : (msg.value.toUint128(), false));\n\n        //Wrap the gas allocated for omnichain execution.\n        if (!isRemote && gasToBridgeOut > 0) wrappedNativeToken.deposit{value: msg.value}();\n\n        //Check Fallback Gas\n        _requiresFallbackGas(gasToBridgeOut);\n\n        //Perform Call\n        _callOutAndBridgeMultiple(_depositor, _params, _dParams, gasToBridgeOut, _remoteExecutionGas);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                TOKEN MANAGEMENT EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchBridgeAgent\n    function clearToken(address _recipient, address _hToken, address _token, uint256 _amount, uint256 _deposit)\n        external\n        requiresAgentExecutor\n    {\n        _clearToken(_recipient, _hToken, _token, _amount, _deposit);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function clearTokens(bytes calldata _sParams, address _recipient)\n        external\n        requiresAgentExecutor\n        returns (SettlementMultipleParams memory)\n    {\n        //Parse Params\n        uint8 numOfAssets = uint8(bytes1(_sParams[0]));\n        uint32 nonce = uint32(bytes4(_sParams[PARAMS_START:PARAMS_TKN_START]));\n\n        address[] memory _hTokens = new address[](numOfAssets);\n        address[] memory _tokens = new address[](numOfAssets);\n        uint256[] memory _amounts = new uint256[](numOfAssets);\n        uint256[] memory _deposits = new uint256[](numOfAssets);\n\n        //Transfer token to recipient\n        for (uint256 i = 0; i < numOfAssets;) {\n            //Parse Params\n            _hTokens[i] = address(\n                uint160(\n                    bytes20(\n                        bytes32(\n                            _sParams[\n                                PARAMS_TKN_START + (PARAMS_ENTRY_SIZE * i) + 12:\n                                    PARAMS_TKN_START + (PARAMS_ENTRY_SIZE * (PARAMS_START + i))\n                            ]\n                        )\n                    )\n                )\n            );\n            _tokens[i] = address(\n                uint160(\n                    bytes20(\n                        _sParams[\n                            PARAMS_TKN_START + PARAMS_ENTRY_SIZE * uint16(i + numOfAssets) + 12:\n                                PARAMS_TKN_START + PARAMS_ENTRY_SIZE * uint16(PARAMS_START + i + numOfAssets)\n                        ]\n                    )\n                )\n            );\n            _amounts[i] = uint256(\n                bytes32(\n                    _sParams[\n                        PARAMS_TKN_START + PARAMS_AMT_OFFSET * uint16(numOfAssets) + (PARAMS_ENTRY_SIZE * uint16(i)):\n                            PARAMS_TKN_START + PARAMS_AMT_OFFSET * uint16(numOfAssets)\n                                + PARAMS_ENTRY_SIZE * uint16(PARAMS_START + i)\n                    ]\n                )\n            );\n            _deposits[i] = uint256(\n                bytes32(\n                    _sParams[\n                        PARAMS_TKN_START + PARAMS_DEPOSIT_OFFSET * uint16(numOfAssets) + (PARAMS_ENTRY_SIZE * uint16(i)):\n                            PARAMS_TKN_START + PARAMS_DEPOSIT_OFFSET * uint16(numOfAssets)\n                                + PARAMS_ENTRY_SIZE * uint16(PARAMS_START + i)\n                    ]\n                )\n            );\n            //Clear Tokens to destination\n            if (_amounts[i] - _deposits[i] > 0) {\n                IPort(localPortAddress).bridgeIn(_recipient, _hTokens[i], _amounts[i] - _deposits[i]);\n            }\n\n            if (_deposits[i] > 0) {\n                IPort(localPortAddress).withdraw(_recipient, _tokens[i], _deposits[i]);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return SettlementMultipleParams(numOfAssets, _recipient, nonce, _hTokens, _tokens, _amounts, _deposits);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                LOCAL USER DEPOSIT INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function to perform a call to the Root Omnichain Router without token deposit.\n     *   @param _depositor address of the user that will deposit the funds.\n     *   @param _params RLP enconded parameters to execute on the root chain.\n     *   @param _gasToBridgeOut gas allocated for the cross-chain call.\n     *   @param _remoteExecutionGas gas allocated for branch chain execution.\n     *   @dev ACTION ID: 1 (Call without deposit)\n     *\n     */\n    function _callOut(address _depositor, bytes calldata _params, uint128 _gasToBridgeOut, uint128 _remoteExecutionGas)\n        internal\n    {\n        //Encode Data for cross-chain call.\n        bytes memory packedData =\n            abi.encodePacked(bytes1(0x01), depositNonce, _params, _gasToBridgeOut, _remoteExecutionGas);\n\n        //Perform Call\n        _noDepositCall(_depositor, packedData, _gasToBridgeOut);\n    }\n\n    /**\n     * @notice Function to perform a call to the Root Omnichain Router while depositing a single asset.\n     *   @param _depositor address of the user that will deposit the funds.\n     *   @param _params RLP enconded parameters to execute on the root chain.\n     *   @param _dParams additional token deposit parameters.\n     *   @param _gasToBridgeOut gas allocated for the cross-chain call.\n     *   @param _remoteExecutionGas gas allocated for branch chain execution.\n     *   @dev ACTION ID: 2 (Call with single deposit)\n     *\n     */\n    function _callOutAndBridge(\n        address _depositor,\n        bytes calldata _params,\n        DepositInput memory _dParams,\n        uint128 _gasToBridgeOut,\n        uint128 _remoteExecutionGas\n    ) internal {\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(\n            bytes1(0x02),\n            depositNonce,\n            _dParams.hToken,\n            _dParams.token,\n            _dParams.amount,\n            _normalizeDecimals(_dParams.deposit, ERC20(_dParams.token).decimals()),\n            _dParams.toChain,\n            _params,\n            _gasToBridgeOut,\n            _remoteExecutionGas\n        );\n\n        //Create Deposit and Send Cross-Chain request\n        _depositAndCall(\n            _depositor, packedData, _dParams.hToken, _dParams.token, _dParams.amount, _dParams.deposit, _gasToBridgeOut\n        );\n    }\n\n    /**\n     * @notice Function to perform a call to the Root Omnichain Router while depositing two or more assets.\n     *   @param _params RLP enconded parameters to execute on the root chain.\n     *   @param _dParams additional token deposit parameters.\n     *   @param _gasToBridgeOut gas allocated for the cross-chain call.\n     *   @param _remoteExecutionGas gas allocated for branch chain execution.\n     *   @dev ACTION ID: 3 (Call with multiple deposit)\n     *\n     */\n    function _callOutAndBridgeMultiple(\n        address _depositor,\n        bytes calldata _params,\n        DepositMultipleInput memory _dParams,\n        uint128 _gasToBridgeOut,\n        uint128 _remoteExecutionGas\n    ) internal {\n        //Normalize Deposits\n        uint256[] memory deposits = new uint256[](_dParams.hTokens.length);\n\n        for (uint256 i = 0; i < _dParams.hTokens.length; i++) {\n            deposits[i] = _normalizeDecimals(_dParams.deposits[i], ERC20(_dParams.tokens[i]).decimals());\n        }\n\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(\n            bytes1(0x03),\n            uint8(_dParams.hTokens.length),\n            depositNonce,\n            _dParams.hTokens,\n            _dParams.tokens,\n            _dParams.amounts,\n            deposits,\n            _dParams.toChain,\n            _params,\n            _gasToBridgeOut,\n            _remoteExecutionGas\n        );\n\n        //Create Deposit and Send Cross-Chain request\n        _depositAndCallMultiple(\n            _depositor,\n            packedData,\n            _dParams.hTokens,\n            _dParams.tokens,\n            _dParams.amounts,\n            _dParams.deposits,\n            _gasToBridgeOut\n        );\n    }\n\n    /**\n     * @notice Internal function to move assets from branch chain to root omnichain environment. Naive assets are deposited and hTokens are bridgedOut.\n     *   @param _depositor token depositor.\n     *   @param _data data to be sent to cross-chain messaging layer.\n     *   @param _gasToBridgeOut gas allocated for the cross-chain call.\n     *\n     */\n    function _noDepositCall(address _depositor, bytes memory _data, uint128 _gasToBridgeOut) internal {\n        //Deposit Gas for call.\n        _createGasDeposit(_depositor, _gasToBridgeOut);\n\n        //Perform Call\n        _performCall(_data);\n    }\n\n    /**\n     * @notice Internal function to move assets from branch chain to root omnichain environment. Naive assets are deposited and hTokens are bridgedOut.\n     *   @param _depositor token depositor.\n     *   @param _data data to be sent to cross-chain messaging layer.\n     *   @param _hToken Local Input hToken Address.\n     *   @param _token Native / Underlying Token Address.\n     *   @param _amount Amount of Local hTokens deposited for trade.\n     *   @param _deposit Amount of native tokens deposited for trade.\n     *   @param _gasToBridgeOut gas allocated for the cross-chain call.\n     *\n     */\n    function _depositAndCall(\n        address _depositor,\n        bytes memory _data,\n        address _hToken,\n        address _token,\n        uint256 _amount,\n        uint256 _deposit,\n        uint128 _gasToBridgeOut\n    ) internal {\n        //Deposit and Store Info\n        _createDepositSingle(_depositor, _hToken, _token, _amount, _deposit, _gasToBridgeOut);\n\n        //Perform Call\n        _performCall(_data);\n    }\n\n    /**\n     * @dev Internal function to move assets from branch chain to root omnichain environment. Naive assets are deposited and hTokens are bridgedOut.\n     *   @param _depositor token depositor.\n     *   @param _data data to be sent to cross-chain messaging layer.\n     *   @param _hTokens Local Input hToken Address.\n     *   @param _tokens Native / Underlying Token Address.\n     *   @param _amounts Amount of Local hTokens deposited for trade.\n     *   @param _deposits  Amount of native tokens deposited for trade.\n     *   @param _gasToBridgeOut gas allocated for the cross-chain call.\n     *\n     */\n    function _depositAndCallMultiple(\n        address _depositor,\n        bytes memory _data,\n        address[] memory _hTokens,\n        address[] memory _tokens,\n        uint256[] memory _amounts,\n        uint256[] memory _deposits,\n        uint128 _gasToBridgeOut\n    ) internal {\n        //Validate Input\n        if (\n            _hTokens.length != _tokens.length || _tokens.length != _amounts.length\n                || _amounts.length != _deposits.length\n        ) revert InvalidInput();\n\n        //Deposit and Store Info\n        _createDepositMultiple(_depositor, _hTokens, _tokens, _amounts, _deposits, _gasToBridgeOut);\n\n        //Perform Call\n        _performCall(_data);\n    }\n\n    /**\n     * @dev Function to create a pending deposit.\n     *    @param _user user address.\n     *    @param _gasToBridgeOut gas allocated for omnichain execution.\n     *\n     */\n    function _createGasDeposit(address _user, uint128 _gasToBridgeOut) internal {\n        //Deposit Gas to Port\n        _depositGas(_gasToBridgeOut);\n\n        // Update State\n        getDeposit[_getAndIncrementDepositNonce()] = Deposit({\n            owner: _user,\n            hTokens: new address[](0),\n            tokens: new address[](0),\n            amounts: new uint256[](0),\n            deposits: new uint256[](0),\n            status: DepositStatus.Success,\n            depositedGas: _gasToBridgeOut\n        });\n    }\n\n    /**\n     * @dev Function to create a pending deposit.\n     *    @param _user user address.\n     *    @param _hToken deposited local hToken addresses.\n     *    @param _token deposited native / underlying Token addresses.\n     *    @param _amount amounts of hTokens input.\n     *    @param _deposit amount of deposited underlying / native tokens.\n     *    @param _gasToBridgeOut gas allocated for omnichain execution.\n     *\n     */\n    function _createDepositSingle(\n        address _user,\n        address _hToken,"
    }
  ]
}