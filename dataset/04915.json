{
  "Title": "[L-08] Protocol does not refund extra ETH but implements strict check",
  "Content": "\n[See spec here](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/bridge/IBridge.sol#L105)\n\nThe IBridge.sol contract specifies that extra ETH provided when sending a message is refunded back to the user. This currently does not happen since the code implements strict equality check. Using strict equality is better but pointing out the spec described, which would either be followed in the code implemented or the spec should be described properly in the IBridge.sol contract.\n\n```solidity\nFile: Bridge.sol\n146:         uint256 expectedAmount = _message.value + _message.fee;\n147:         if (expectedAmount != msg.value) revert B_INVALID_VALUE();\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-taiko",
  "Code": [
    {
      "filename": "packages/protocol/contracts/bridge/IBridge.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\n/// @title IBridge\n/// @notice The bridge used in conjunction with the {ISignalService}.\n/// @dev Ether is held by Bridges on L1 and L2s.\n/// @custom:security-contact security@taiko.xyz\ninterface IBridge {\n    enum Status {\n        NEW,\n        RETRIABLE,\n        DONE,\n        FAILED,\n        RECALLED\n    }\n\n    struct Message {\n        // Message ID whose value is automatically assigned.\n        uint128 id;\n        // The address, EOA or contract, that interacts with this bridge.\n        // The value is automatically assigned.\n        address from;\n        // Source chain ID whose value is automatically assigned.\n        uint64 srcChainId;\n        // Destination chain ID where the `to` address lives.\n        uint64 destChainId;\n        // The owner of the message on the source chain.\n        address srcOwner;\n        // The owner of the message on the destination chain.\n        address destOwner;\n        // The destination address on the destination chain.\n        address to;\n        // Alternate address to send any refund on the destination chain.\n        // If blank, defaults to destOwner.\n        address refundTo;\n        // value to invoke on the destination chain.\n        uint256 value;\n        // Processing fee for the relayer. Zero if owner will process themself.\n        uint256 fee;\n        // gasLimit to invoke on the destination chain.\n        uint256 gasLimit;\n        // callData to invoke on the destination chain.\n        bytes data;\n        // Optional memo.\n        string memo;\n    }\n\n    // Note that this struct shall take only 1 slot to minimize gas cost\n    struct ProofReceipt {\n        // The time a message is marked as received on the destination chain\n        uint64 receivedAt;\n        // The address that can execute the message after the invocation delay without an extra\n        // delay.\n        // For a failed message, preferredExecutor's value doesn't matter as only the owner can\n        // invoke the message.\n        address preferredExecutor;\n    }\n\n    // Struct representing the context of a bridge operation.\n    struct Context {\n        bytes32 msgHash; // Message hash.\n        address from; // Sender's address.\n        uint64 srcChainId; // Source chain ID.\n    }\n\n    /// @notice Emitted when a message is sent.\n    /// @param msgHash The hash of the message.\n    /// @param message The message.\n    event MessageSent(bytes32 indexed msgHash, Message message);\n\n    /// @notice Emitted when a message is received.\n    /// @param msgHash The hash of the message.\n    /// @param message The message.\n    /// @param isRecall True if the message is a recall.\n    event MessageReceived(bytes32 indexed msgHash, Message message, bool isRecall);\n\n    /// @notice Emitted when a message is recalled.\n    /// @param msgHash The hash of the message.\n    event MessageRecalled(bytes32 indexed msgHash);\n\n    /// @notice Emitted when a message is executed.\n    /// @param msgHash The hash of the message.\n    event MessageExecuted(bytes32 indexed msgHash);\n\n    /// @notice Emitted when a message is retried.\n    /// @param msgHash The hash of the message.\n    event MessageRetried(bytes32 indexed msgHash);\n\n    /// @notice Emitted when the status of a message changes.\n    /// @param msgHash The hash of the message.\n    /// @param status The new status of the message.\n    event MessageStatusChanged(bytes32 indexed msgHash, Status status);\n\n    /// @notice Emitted when a message is suspended or unsuspended.\n    /// @param msgHash The hash of the message.\n    /// @param suspended True if the message is suspended.\n    event MessageSuspended(bytes32 msgHash, bool suspended);\n\n    /// @notice Emitted when an address is banned or unbanned.\n    /// @param addr The address to ban or unban.\n    /// @param banned True if the address is banned.\n    event AddressBanned(address indexed addr, bool banned);\n\n    /// @notice Sends a message to the destination chain and takes custody\n    /// of Ether required in this contract. All extra Ether will be refunded.\n    /// @param _message The message to be sent.\n    /// @return msgHash_ The hash of the sent message.\n    /// @return message_ The updated message sent.\n    function sendMessage(Message calldata _message)\n        external\n        payable\n        returns (bytes32 msgHash_, Message memory message_);\n\n    /// @notice Recalls a failed message on its source chain, releasing\n    /// associated assets.\n    /// @dev This function checks if the message failed on the source chain and\n    /// releases associated Ether or tokens.\n    /// @param _message The message whose associated Ether should be released.\n    /// @param _proof The merkle inclusion proof.\n    function recallMessage(Message calldata _message, bytes calldata _proof) external;\n\n    /// @notice Processes a bridge message on the destination chain. This\n    /// function is callable by any address, including the `message.destOwner`.\n    /// @dev The process begins by hashing the message and checking the message\n    /// status in the bridge  If the status is \"NEW\", the message is invoked. The\n    /// status is updated accordingly, and processing fees are refunded as\n    /// needed.\n    /// @param _message The message to be processed.\n    /// @param _proof The merkle inclusion proof.\n    function processMessage(Message calldata _message, bytes calldata _proof) external;\n\n    /// @notice Retries to invoke the messageCall after releasing associated\n    /// Ether and tokens.\n    /// @dev This function can be called by any address, including the\n    /// `message.destOwner`.\n    /// It attempts to invoke the messageCall and updates the message status\n    /// accordingly.\n    /// @param _message The message to retry.\n    /// @param _isLastAttempt Specifies if this is the last attempt to retry the\n    /// message.\n    function retryMessage(Message calldata _message, bool _isLastAttempt) external;\n\n    /// @notice Returns the bridge state context.\n    /// @return ctx_ The context of the current bridge operation.\n    function context() external view returns (Context memory ctx_);\n\n    /// @notice Checks if the message was sent.\n    /// @param _message The message.\n    /// @return true if the message was sent.\n    function isMessageSent(Message calldata _message) external view returns (bool);\n\n    /// @notice Hash the message\n    /// @param _message The message struct variable to be hashed.\n    /// @return The message's hash.\n    function hashMessage(Message memory _message) external pure returns (bytes32);\n}\n\n/// @title IRecallableSender\n/// @notice An interface that all recallable message senders shall implement.\ninterface IRecallableSender {\n    /// @notice Called when a message is recalled.\n    /// @param _message The recalled message.\n    /// @param _msgHash The hash of the recalled message.\n    function onMessageRecalled(\n        IBridge.Message calldata _message,\n        bytes32 _msgHash\n    )\n        external\n        payable;\n}\n\n/// @title IMessageInvocable\n/// @notice An interface that all bridge message receiver shall implement\ninterface IMessageInvocable {\n    /// @notice Called when this contract is the bridge target.\n    /// @param _data The data for this contract to interpret.\n    /// @dev This method should be guarded with `onlyFromNamed(\"bridge\")`.\n    function onMessageInvocation(bytes calldata _data) external payable;\n}"
    }
  ]
}