{
  "Title": "[M-07] Missing recursive calls handling in `OffchainDNSResolver` CCIP-aware contract",
  "Content": "\n<https://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnsregistrar/OffchainDNSResolver.sol#L109-L113><br>\n<https://github.com/code-423n4/2023-04-ens/blob/main/contracts/dnsregistrar/OffchainDNSResolver.sol#L119>\n\nThe `resolveCallback` function from `OffchainDNSResolver` is used as part of the EIP-3668 standard to properly resolve DNS names using an off-chain gateway and validating RRsets against the DNSSEC oracle.\n\nThe issue is that the function lacks proper error handling, specifically, a try/catch block to properly bubble up `OffchainLookup` error from the `dnsresolver` extracted from the RRset. As the EIP specifies,\n\n> *When a CCIP-aware contract wishes to make a call to another contract, and the possibility exists that the callee may implement CCIP read, the calling contract MUST catch all `OffchainLookup` errors thrown by the callee, and revert with a different error if the `sender` field of the error does not match the callee address.*<br>\n> *\\[...]*<br>\n> *Where the possibility exists that a callee implements CCIP read, a CCIP-aware contract MUST NOT allow the default solidity behaviour of bubbling up reverts from nested calls.*\n\n### Impact\n\nAs per the EIP, the result would be an OffchainLookup that looks valid to the client, as the sender field matches the address of the contract that was called, but does not execute correctly.\n\n### Proof of Concept\n\n1.  Client calls `OffchainDNSResolver.resolve`, which reverts with `OffchainLookup`, and prompts the client to execute `resolveCallback` after having fetched the necessary data from the `gatewayURL`\n2.  The RRset returned by the gateway contains a `dnsresolver` that is a CCIP-aware contract, and also supports the `IExtendedDNSResolver.resolve.selector` interface\n3.  Calling `IExtendedDNSResolver(dnsresolver).resolve(name,query,context);` could trigger another `OffchainLookup` error, but with a `sender` that does not match the `dnsresolver`, which would be just returned to the client without any modifications\n4.  As a result, the `sender` field would be incorrect as per the EIP\n\n### Recommended Mitigation Steps\n\nUse the [recommended example](https://eips.ethereum.org/EIPS/eip-3668#example-1) from the EIP in order to support nested lookups.\n\n**[Arachnid (ENS) confirmed](https://github.com/code-423n4/2023-04-ens-findings/issues/124#issuecomment-1536309975)**\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-04-ens",
  "Code": [
    {
      "filename": "contracts/dnsregistrar/OffchainDNSResolver.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../../contracts/resolvers/profiles/IAddrResolver.sol\";\nimport \"../../contracts/resolvers/profiles/IExtendedResolver.sol\";\nimport \"../../contracts/resolvers/profiles/IExtendedDNSResolver.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"../dnssec-oracle/BytesUtils.sol\";\nimport \"../dnssec-oracle/DNSSEC.sol\";\nimport \"../dnssec-oracle/RRUtils.sol\";\nimport \"../registry/ENSRegistry.sol\";\nimport \"../utils/HexUtils.sol\";\n\nerror OffchainLookup(\n    address sender,\n    string[] urls,\n    bytes callData,\n    bytes4 callbackFunction,\n    bytes extraData\n);\n\ninterface IDNSGateway {\n    function resolve(\n        bytes memory name,\n        uint16 qtype\n    ) external returns (DNSSEC.RRSetWithSignature[] memory);\n}\n\nuint16 constant CLASS_INET = 1;\nuint16 constant TYPE_TXT = 16;\n\ncontract OffchainDNSResolver is IExtendedResolver {\n    using RRUtils for *;\n    using BytesUtils for bytes;\n    using HexUtils for bytes;\n\n    ENS public immutable ens;\n    DNSSEC public immutable oracle;\n    string public gatewayURL;\n\n    error CouldNotResolve(bytes name);\n\n    constructor(ENS _ens, DNSSEC _oracle, string memory _gatewayURL) {\n        ens = _ens;\n        oracle = _oracle;\n        gatewayURL = _gatewayURL;\n    }\n\n    function resolve(\n        bytes calldata name,\n        bytes calldata data\n    ) external view returns (bytes memory) {\n        string[] memory urls = new string[](1);\n        urls[0] = gatewayURL;\n\n        revert OffchainLookup(\n            address(this),\n            urls,\n            abi.encodeCall(IDNSGateway.resolve, (name, TYPE_TXT)),\n            OffchainDNSResolver.resolveCallback.selector,\n            abi.encode(name, data)\n        );\n    }\n\n    function resolveCallback(\n        bytes calldata response,\n        bytes calldata extraData\n    ) external view returns (bytes memory) {\n        (bytes memory name, bytes memory query) = abi.decode(\n            extraData,\n            (bytes, bytes)\n        );\n        DNSSEC.RRSetWithSignature[] memory rrsets = abi.decode(\n            response,\n            (DNSSEC.RRSetWithSignature[])\n        );\n\n        (bytes memory data, ) = oracle.verifyRRSet(rrsets);\n        for (\n            RRUtils.RRIterator memory iter = data.iterateRRs(0);\n            !iter.done();\n            iter.next()\n        ) {\n            // Ignore records with wrong name, type, or class\n            bytes memory rrname = RRUtils.readName(iter.data, iter.offset);\n            if (\n                !rrname.equals(name) ||\n                iter.class != CLASS_INET ||\n                iter.dnstype != TYPE_TXT\n            ) {\n                continue;\n            }\n\n            // Look for a valid ENS-DNS TXT record\n            (address dnsresolver, bytes memory context) = parseRR(\n                iter.data,\n                iter.rdataOffset,\n                iter.nextOffset\n            );\n\n            // If we found a valid record, try to resolve it\n            if (dnsresolver != address(0)) {\n                if (\n                    IERC165(dnsresolver).supportsInterface(\n                        IExtendedDNSResolver.resolve.selector\n                    )\n                ) {\n                    return\n                        IExtendedDNSResolver(dnsresolver).resolve(\n                            name,\n                            query,\n                            context\n                        );\n                } else if (\n                    IERC165(dnsresolver).supportsInterface(\n                        IExtendedResolver.resolve.selector\n                    )\n                ) {\n                    return IExtendedResolver(dnsresolver).resolve(name, query);\n                } else {\n                    (bool ok, bytes memory ret) = address(dnsresolver)\n                        .staticcall(query);\n                    if (ok) {\n                        return ret;\n                    } else {\n                        revert CouldNotResolve(name);\n                    }\n                }\n            }\n        }\n\n        // No valid records; revert.\n        revert CouldNotResolve(name);\n    }\n\n    function parseRR(\n        bytes memory data,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal view returns (address, bytes memory) {\n        bytes memory txt = readTXT(data, idx, lastIdx);\n\n        // Must start with the magic word\n        if (txt.length < 5 || !txt.equals(0, \"ENS1 \", 0, 5)) {\n            return (address(0), \"\");\n        }\n\n        // Parse the name or address\n        uint256 lastTxtIdx = txt.find(5, txt.length - 5, \" \");\n        if (lastTxtIdx > txt.length) {\n            address dnsResolver = parseAndResolve(txt, 5, txt.length);\n            return (dnsResolver, \"\");\n        } else {\n            address dnsResolver = parseAndResolve(txt, 5, lastTxtIdx);\n            return (\n                dnsResolver,\n                txt.substring(lastTxtIdx + 1, txt.length - lastTxtIdx - 1)\n            );\n        }\n    }\n\n    function readTXT(\n        bytes memory data,\n        uint256 startIdx,\n        uint256 lastIdx\n    ) internal pure returns (bytes memory) {\n        // TODO: Concatenate multiple text fields\n        uint256 fieldLength = data.readUint8(startIdx);\n        assert(startIdx + fieldLength < lastIdx);\n        return data.substring(startIdx + 1, fieldLength);\n    }\n\n    function parseAndResolve(\n        bytes memory nameOrAddress,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal view returns (address) {\n        if (nameOrAddress[idx] == \"0\" && nameOrAddress[idx + 1] == \"x\") {\n            (address ret, bool valid) = nameOrAddress.hexToAddress(\n                idx + 2,\n                lastIdx\n            );\n            if (valid) {\n                return ret;\n            }\n        }\n        return resolveName(nameOrAddress, idx, lastIdx);\n    }\n\n    function resolveName(\n        bytes memory name,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal view returns (address) {\n        bytes32 node = textNamehash(name, idx, lastIdx);\n        address resolver = ens.resolver(node);\n        if (resolver == address(0)) {\n            return address(0);\n        }\n        return IAddrResolver(resolver).addr(node);\n    }\n\n    /**\n     * @dev Namehash function that operates on dot-separated names (not dns-encoded names)\n     * @param name Name to hash\n     * @param idx Index to start at\n     * @param lastIdx Index to end at\n     */\n    function textNamehash(\n        bytes memory name,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal view returns (bytes32) {\n        uint256 separator = name.find(idx, name.length - idx, bytes1(\".\"));\n        bytes32 parentNode = bytes32(0);\n        if (separator < lastIdx) {\n            parentNode = textNamehash(name, separator + 1, lastIdx);\n        } else {\n            separator = lastIdx;\n        }\n        return\n            keccak256(\n                abi.encodePacked(parentNode, name.keccak(idx, separator - idx))\n            );\n    }\n}"
    },
    {
      "filename": "contracts/dnsregistrar/OffchainDNSResolver.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../../contracts/resolvers/profiles/IAddrResolver.sol\";\nimport \"../../contracts/resolvers/profiles/IExtendedResolver.sol\";\nimport \"../../contracts/resolvers/profiles/IExtendedDNSResolver.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"../dnssec-oracle/BytesUtils.sol\";\nimport \"../dnssec-oracle/DNSSEC.sol\";\nimport \"../dnssec-oracle/RRUtils.sol\";\nimport \"../registry/ENSRegistry.sol\";\nimport \"../utils/HexUtils.sol\";\n\nerror OffchainLookup(\n    address sender,\n    string[] urls,\n    bytes callData,\n    bytes4 callbackFunction,\n    bytes extraData\n);\n\ninterface IDNSGateway {\n    function resolve(\n        bytes memory name,\n        uint16 qtype\n    ) external returns (DNSSEC.RRSetWithSignature[] memory);\n}\n\nuint16 constant CLASS_INET = 1;\nuint16 constant TYPE_TXT = 16;\n\ncontract OffchainDNSResolver is IExtendedResolver {\n    using RRUtils for *;\n    using BytesUtils for bytes;\n    using HexUtils for bytes;\n\n    ENS public immutable ens;\n    DNSSEC public immutable oracle;\n    string public gatewayURL;\n\n    error CouldNotResolve(bytes name);\n\n    constructor(ENS _ens, DNSSEC _oracle, string memory _gatewayURL) {\n        ens = _ens;\n        oracle = _oracle;\n        gatewayURL = _gatewayURL;\n    }\n\n    function resolve(\n        bytes calldata name,\n        bytes calldata data\n    ) external view returns (bytes memory) {\n        string[] memory urls = new string[](1);\n        urls[0] = gatewayURL;\n\n        revert OffchainLookup(\n            address(this),\n            urls,\n            abi.encodeCall(IDNSGateway.resolve, (name, TYPE_TXT)),\n            OffchainDNSResolver.resolveCallback.selector,\n            abi.encode(name, data)\n        );\n    }\n\n    function resolveCallback(\n        bytes calldata response,\n        bytes calldata extraData\n    ) external view returns (bytes memory) {\n        (bytes memory name, bytes memory query) = abi.decode(\n            extraData,\n            (bytes, bytes)\n        );\n        DNSSEC.RRSetWithSignature[] memory rrsets = abi.decode(\n            response,\n            (DNSSEC.RRSetWithSignature[])\n        );\n\n        (bytes memory data, ) = oracle.verifyRRSet(rrsets);\n        for (\n            RRUtils.RRIterator memory iter = data.iterateRRs(0);\n            !iter.done();\n            iter.next()\n        ) {\n            // Ignore records with wrong name, type, or class\n            bytes memory rrname = RRUtils.readName(iter.data, iter.offset);\n            if (\n                !rrname.equals(name) ||\n                iter.class != CLASS_INET ||\n                iter.dnstype != TYPE_TXT\n            ) {\n                continue;\n            }\n\n            // Look for a valid ENS-DNS TXT record\n            (address dnsresolver, bytes memory context) = parseRR(\n                iter.data,\n                iter.rdataOffset,\n                iter.nextOffset\n            );\n\n            // If we found a valid record, try to resolve it\n            if (dnsresolver != address(0)) {\n                if (\n                    IERC165(dnsresolver).supportsInterface(\n                        IExtendedDNSResolver.resolve.selector\n                    )\n                ) {\n                    return\n                        IExtendedDNSResolver(dnsresolver).resolve(\n                            name,\n                            query,\n                            context\n                        );\n                } else if (\n                    IERC165(dnsresolver).supportsInterface(\n                        IExtendedResolver.resolve.selector\n                    )\n                ) {\n                    return IExtendedResolver(dnsresolver).resolve(name, query);\n                } else {\n                    (bool ok, bytes memory ret) = address(dnsresolver)\n                        .staticcall(query);\n                    if (ok) {\n                        return ret;\n                    } else {\n                        revert CouldNotResolve(name);\n                    }\n                }\n            }\n        }\n\n        // No valid records; revert.\n        revert CouldNotResolve(name);\n    }\n\n    function parseRR(\n        bytes memory data,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal view returns (address, bytes memory) {\n        bytes memory txt = readTXT(data, idx, lastIdx);\n\n        // Must start with the magic word\n        if (txt.length < 5 || !txt.equals(0, \"ENS1 \", 0, 5)) {\n            return (address(0), \"\");\n        }\n\n        // Parse the name or address\n        uint256 lastTxtIdx = txt.find(5, txt.length - 5, \" \");\n        if (lastTxtIdx > txt.length) {\n            address dnsResolver = parseAndResolve(txt, 5, txt.length);\n            return (dnsResolver, \"\");\n        } else {\n            address dnsResolver = parseAndResolve(txt, 5, lastTxtIdx);\n            return (\n                dnsResolver,\n                txt.substring(lastTxtIdx + 1, txt.length - lastTxtIdx - 1)\n            );\n        }\n    }\n\n    function readTXT(\n        bytes memory data,\n        uint256 startIdx,\n        uint256 lastIdx\n    ) internal pure returns (bytes memory) {\n        // TODO: Concatenate multiple text fields\n        uint256 fieldLength = data.readUint8(startIdx);\n        assert(startIdx + fieldLength < lastIdx);\n        return data.substring(startIdx + 1, fieldLength);\n    }\n\n    function parseAndResolve(\n        bytes memory nameOrAddress,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal view returns (address) {\n        if (nameOrAddress[idx] == \"0\" && nameOrAddress[idx + 1] == \"x\") {\n            (address ret, bool valid) = nameOrAddress.hexToAddress(\n                idx + 2,\n                lastIdx\n            );\n            if (valid) {\n                return ret;\n            }\n        }\n        return resolveName(nameOrAddress, idx, lastIdx);\n    }\n\n    function resolveName(\n        bytes memory name,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal view returns (address) {\n        bytes32 node = textNamehash(name, idx, lastIdx);\n        address resolver = ens.resolver(node);\n        if (resolver == address(0)) {\n            return address(0);\n        }\n        return IAddrResolver(resolver).addr(node);\n    }\n\n    /**\n     * @dev Namehash function that operates on dot-separated names (not dns-encoded names)\n     * @param name Name to hash\n     * @param idx Index to start at\n     * @param lastIdx Index to end at\n     */\n    function textNamehash(\n        bytes memory name,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal view returns (bytes32) {\n        uint256 separator = name.find(idx, name.length - idx, bytes1(\".\"));\n        bytes32 parentNode = bytes32(0);\n        if (separator < lastIdx) {\n            parentNode = textNamehash(name, separator + 1, lastIdx);\n        } else {\n            separator = lastIdx;\n        }\n        return\n            keccak256(\n                abi.encodePacked(parentNode, name.keccak(idx, separator - idx))\n            );\n    }\n}"
    }
  ]
}