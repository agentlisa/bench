{
  "Title": "[M-07] Changing `bribeVault` in `RewardDistributor.sol` will Lock Current ETH Rewards",
  "Content": "_Submitted by kirk-baird, also found by WatchPug_\n\n[RewardDistributor.sol#L178-#L182](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L178-#L182)<br>\n[RewardDistributor.sol#L65-#L73](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L65-#L73)\n\nClaiming of the ETH native currency requires `token` to be set to `bribeVault`. If the `bribeVault` is modified in `setBribeVault()` then users who have ETH rewards will now be considered to have `ERC20(bribeVault)` tokens. Since `bribeVault` is not an ERC20 token the `transfer()` call will fail and the users will not be able to claim their funds.\n\n### Recommended Mitigation Steps\n\nConsider removing the functionality to change the `bribeVault` or ensuring all funds have been withdraw i.e. `balanceOf(address(this)) == 0` before changing the `bribeVault`.\n\n**[kphed (Redacted Cartel) confirmed and commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/7#issuecomment-1040568870):**\n > Good find, we're going to address this by making `bribeVault` immutable and removing the setter.\n> \n> Thanks again for participating in our contest kirk-baird, looking forward to more feedback/suggestions/comments.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/7#issuecomment-1059788677):**\n > Agree with the finding, ultimately preventing `bribeVault` from changing will provide users further security guarantees.\n> \n> An alternative solution would be to use a different code for ETH (I've seen protocols use address(0) or perhaps 0xeeeeeeee).\n> \n> However I believe that making `bribeVault` immutable will provide the stronger guarantees.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-redacted-cartel-contest",
  "Code": [
    {
      "filename": "contracts/RewardDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {MerkleProof} from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport {Common} from \"./libraries/Common.sol\";\n\ncontract RewardDistributor is AccessControl, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    struct Reward {\n        address token;\n        bytes32 merkleRoot;\n        bytes32 proof;\n        uint256 updateCount;\n    }\n\n    struct Claim {\n        bytes32 identifier;\n        address account;\n        uint256 index;\n        uint256 amount;\n        bytes32[] merkleProof;\n    }\n\n    address public bribeVault;\n    mapping(bytes32 => Reward) public rewards; // Maps each of the reward identifier to its metadata\n    mapping(bytes32 => mapping(uint256 => mapping(uint256 => uint256)))\n        private claimed; // Tracks whether a specific reward claim has been done\n\n    event SetBribeVault(address _bribeVault);\n    event RewardClaimed(\n        bytes32 indexed identifier,\n        address indexed tokenAddress,\n        address indexed account,\n        uint256 updateCount,\n        uint256 index,\n        uint256 amount\n    );\n    event RewardMetadataUpdated(\n        bytes32 indexed identifier,\n        address indexed token,\n        bytes32 merkleRoot,\n        bytes32 proof,\n        uint256 indexed updateCount\n    );\n\n    constructor(address _bribeVault) {\n        require(_bribeVault != address(0), \"Invalid bribeVault\");\n        bribeVault = _bribeVault;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    // Enables BribeVault to transfer native tokens\n    receive() external payable {}\n\n    /**\n        @notice Set bribe vault\n        @param  _bribeVault address New address of the bribe vault\n     */\n    function setBribeVault(address _bribeVault)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_bribeVault != address(0), \"Invalid bribeVault\");\n        bribeVault = _bribeVault;\n\n        emit SetBribeVault(bribeVault);\n    }\n\n    /**\n        @notice Claim rewards based on the specified metadata\n        @param  _claims   Claim[] List of claim metadata\n     */\n    function claim(Claim[] calldata _claims) external nonReentrant {\n        require(_claims.length > 0, \"Invalid _claims\");\n\n        for (uint256 i = 0; i < _claims.length; i++) {\n            _claim(\n                _claims[i].identifier,\n                _claims[i].index,\n                _claims[i].account,\n                _claims[i].amount,\n                _claims[i].merkleProof\n            );\n        }\n    }\n\n    /**\n        @notice Update the overall metadata of the specified reward identifiers\n        @param  _distributions    Distribution[] List of reward distribution details\n     */\n    function updateRewardsMetadata(\n        Common.Distribution[] calldata _distributions\n    ) external {\n        require(msg.sender == bribeVault, \"Invalid access\");\n        require(_distributions.length > 0, \"Invalid _distributions\");\n\n        for (uint256 i = 0; i < _distributions.length; i++) {\n            // Update the metadata and also increment the update to reset the claimed tracker\n            Reward storage reward = rewards[_distributions[i].rewardIdentifier];\n            reward.token = _distributions[i].token;\n            reward.merkleRoot = _distributions[i].merkleRoot;\n            reward.proof = _distributions[i].proof;\n            reward.updateCount += 1;\n\n            emit RewardMetadataUpdated(\n                _distributions[i].rewardIdentifier,\n                _distributions[i].token,\n                _distributions[i].merkleRoot,\n                _distributions[i].proof,\n                reward.updateCount\n            );\n        }\n    }\n\n    /**\n        @notice Check if the reward on the specified identifier and index has been claimed\n        @param  _identifier    bytes32 The specified identifier\n        @param  _index         bytes32 The specified index\n        @return  claimed       bool    Whether reward has been claimed\n     */\n    function isRewardClaimed(bytes32 _identifier, uint256 _index)\n        public\n        view\n        returns (bool)\n    {\n        // Get the group index for the specified index along with the bit index\n        // and check if the corresponding bit index is flipped\n        Reward memory reward = rewards[_identifier];\n        uint256 claimedGroup = _index / 256;\n        uint256 claimedIndex = _index % 256;\n        uint256 claimedGroupState = claimed[_identifier][reward.updateCount][\n            claimedGroup\n        ];\n        uint256 mask = (1 << claimedIndex);\n        return claimedGroupState & mask == mask;\n    }\n\n    /**\n        @notice Claim a reward\n        @param  _rewardIdentifier  bytes32    Reward identifier\n        @param  _index             uint256    Node index\n        @param  _account           address    Eligible user account\n        @param  _amount            bytes32    Reward amount\n        @param  _merkleProof       bytes32[]  Merkle proof\n     */\n    function _claim(\n        bytes32 _rewardIdentifier,\n        uint256 _index,\n        address _account,\n        uint256 _amount,\n        bytes32[] calldata _merkleProof\n    ) internal {\n        Reward memory reward = rewards[_rewardIdentifier];\n        require(reward.merkleRoot != 0, \"Distribution not enabled\");\n        require(\n            !isRewardClaimed(_rewardIdentifier, _index),\n            \"Reward already claimed\"\n        );\n\n        // Verify the merkle proof\n        bytes32 node = keccak256(abi.encodePacked(_index, _account, _amount));\n        require(\n            MerkleProof.verify(_merkleProof, reward.merkleRoot, node),\n            \"Invalid proof\"\n        );\n\n        _setClaimed(_rewardIdentifier, _index);\n\n        // Check whether the reward is in the form of native tokens or ERC20\n        // by checking if the token address is set to the bribe vault or not\n        address token = reward.token;\n        if (token != bribeVault) {\n            IERC20(token).safeTransfer(_account, _amount);\n        } else {\n            payable(_account).transfer(_amount);\n        }\n\n        emit RewardClaimed(\n            _rewardIdentifier,\n            token,\n            _account,\n            reward.updateCount,\n            _index,\n            _amount\n        );\n    }\n\n    /**\n        @notice Set a reward as claimed\n        @param  _identifier  bytes32    Reward identifier\n        @param  _index       uint256    Node index\n     */\n    function _setClaimed(bytes32 _identifier, uint256 _index) internal {\n        Reward memory reward = rewards[_identifier];\n        uint256 claimedGroup = _index / 256;\n        uint256 claimedIndex = _index % 256;\n\n        // Flip the bit state to mark the corresponding index as claimed\n        claimed[_identifier][reward.updateCount][claimedGroup] =\n            claimed[_identifier][reward.updateCount][claimedGroup] |\n            (1 << claimedIndex);\n    }\n}"
    },
    {
      "filename": "contracts/RewardDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {MerkleProof} from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport {Common} from \"./libraries/Common.sol\";\n\ncontract RewardDistributor is AccessControl, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    struct Reward {\n        address token;\n        bytes32 merkleRoot;\n        bytes32 proof;\n        uint256 updateCount;\n    }\n\n    struct Claim {\n        bytes32 identifier;\n        address account;\n        uint256 index;\n        uint256 amount;\n        bytes32[] merkleProof;\n    }\n\n    address public bribeVault;\n    mapping(bytes32 => Reward) public rewards; // Maps each of the reward identifier to its metadata\n    mapping(bytes32 => mapping(uint256 => mapping(uint256 => uint256)))\n        private claimed; // Tracks whether a specific reward claim has been done\n\n    event SetBribeVault(address _bribeVault);\n    event RewardClaimed(\n        bytes32 indexed identifier,\n        address indexed tokenAddress,\n        address indexed account,\n        uint256 updateCount,\n        uint256 index,\n        uint256 amount\n    );\n    event RewardMetadataUpdated(\n        bytes32 indexed identifier,\n        address indexed token,\n        bytes32 merkleRoot,\n        bytes32 proof,\n        uint256 indexed updateCount\n    );\n\n    constructor(address _bribeVault) {\n        require(_bribeVault != address(0), \"Invalid bribeVault\");\n        bribeVault = _bribeVault;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    // Enables BribeVault to transfer native tokens\n    receive() external payable {}\n\n    /**\n        @notice Set bribe vault\n        @param  _bribeVault address New address of the bribe vault\n     */\n    function setBribeVault(address _bribeVault)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_bribeVault != address(0), \"Invalid bribeVault\");\n        bribeVault = _bribeVault;\n\n        emit SetBribeVault(bribeVault);\n    }\n\n    /**\n        @notice Claim rewards based on the specified metadata\n        @param  _claims   Claim[] List of claim metadata\n     */\n    function claim(Claim[] calldata _claims) external nonReentrant {\n        require(_claims.length > 0, \"Invalid _claims\");\n\n        for (uint256 i = 0; i < _claims.length; i++) {\n            _claim(\n                _claims[i].identifier,\n                _claims[i].index,\n                _claims[i].account,\n                _claims[i].amount,\n                _claims[i].merkleProof\n            );\n        }\n    }\n\n    /**\n        @notice Update the overall metadata of the specified reward identifiers\n        @param  _distributions    Distribution[] List of reward distribution details\n     */\n    function updateRewardsMetadata(\n        Common.Distribution[] calldata _distributions\n    ) external {\n        require(msg.sender == bribeVault, \"Invalid access\");\n        require(_distributions.length > 0, \"Invalid _distributions\");\n\n        for (uint256 i = 0; i < _distributions.length; i++) {\n            // Update the metadata and also increment the update to reset the claimed tracker\n            Reward storage reward = rewards[_distributions[i].rewardIdentifier];\n            reward.token = _distributions[i].token;\n            reward.merkleRoot = _distributions[i].merkleRoot;\n            reward.proof = _distributions[i].proof;\n            reward.updateCount += 1;\n\n            emit RewardMetadataUpdated(\n                _distributions[i].rewardIdentifier,\n                _distributions[i].token,\n                _distributions[i].merkleRoot,\n                _distributions[i].proof,\n                reward.updateCount\n            );\n        }\n    }\n\n    /**\n        @notice Check if the reward on the specified identifier and index has been claimed\n        @param  _identifier    bytes32 The specified identifier\n        @param  _index         bytes32 The specified index\n        @return  claimed       bool    Whether reward has been claimed\n     */\n    function isRewardClaimed(bytes32 _identifier, uint256 _index)\n        public\n        view\n        returns (bool)\n    {\n        // Get the group index for the specified index along with the bit index\n        // and check if the corresponding bit index is flipped\n        Reward memory reward = rewards[_identifier];\n        uint256 claimedGroup = _index / 256;\n        uint256 claimedIndex = _index % 256;\n        uint256 claimedGroupState = claimed[_identifier][reward.updateCount][\n            claimedGroup\n        ];\n        uint256 mask = (1 << claimedIndex);\n        return claimedGroupState & mask == mask;\n    }\n\n    /**\n        @notice Claim a reward\n        @param  _rewardIdentifier  bytes32    Reward identifier\n        @param  _index             uint256    Node index\n        @param  _account           address    Eligible user account\n        @param  _amount            bytes32    Reward amount\n        @param  _merkleProof       bytes32[]  Merkle proof\n     */\n    function _claim(\n        bytes32 _rewardIdentifier,\n        uint256 _index,\n        address _account,\n        uint256 _amount,\n        bytes32[] calldata _merkleProof\n    ) internal {\n        Reward memory reward = rewards[_rewardIdentifier];\n        require(reward.merkleRoot != 0, \"Distribution not enabled\");\n        require(\n            !isRewardClaimed(_rewardIdentifier, _index),\n            \"Reward already claimed\"\n        );\n\n        // Verify the merkle proof\n        bytes32 node = keccak256(abi.encodePacked(_index, _account, _amount));\n        require(\n            MerkleProof.verify(_merkleProof, reward.merkleRoot, node),\n            \"Invalid proof\"\n        );\n\n        _setClaimed(_rewardIdentifier, _index);\n\n        // Check whether the reward is in the form of native tokens or ERC20\n        // by checking if the token address is set to the bribe vault or not\n        address token = reward.token;\n        if (token != bribeVault) {\n            IERC20(token).safeTransfer(_account, _amount);\n        } else {\n            payable(_account).transfer(_amount);\n        }\n\n        emit RewardClaimed(\n            _rewardIdentifier,\n            token,\n            _account,\n            reward.updateCount,\n            _index,\n            _amount\n        );\n    }\n\n    /**\n        @notice Set a reward as claimed\n        @param  _identifier  bytes32    Reward identifier\n        @param  _index       uint256    Node index\n     */\n    function _setClaimed(bytes32 _identifier, uint256 _index) internal {\n        Reward memory reward = rewards[_identifier];\n        uint256 claimedGroup = _index / 256;\n        uint256 claimedIndex = _index % 256;\n\n        // Flip the bit state to mark the corresponding index as claimed\n        claimed[_identifier][reward.updateCount][claimedGroup] =\n            claimed[_identifier][reward.updateCount][claimedGroup] |\n            (1 << claimedIndex);\n    }\n}"
    }
  ]
}