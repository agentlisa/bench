{
  "Title": "[L02] Authorized burners can burn FEI balances without an amount restriction",
  "Content": "The Protocol uses a [“Burner” role](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/core/Permissions.sol#L10) to manage permissions around token burning, which the incentivization model requires.\n\n\nThe [`burnFrom` function](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/token/Fei.sol#L54) in the [`Fei` contract](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/token/Fei.sol) uses the internal [`_burn` function](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/ae69ecaf014beac078b4c21da8a83cf005713469/contracts/token/ERC20/ERC20.sol#L250) from the OpenZeppelin `ERC20` implementation instead of using the [`burnFrom` function](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/ae69ecaf014beac078b4c21da8a83cf005713469/contracts/token/ERC20/ERC20Burnable.sol#L34) from the OpenZeppelin `ERC20Burnable` implementation.\n\n\nThe `_burn` function from `ERC20` does not check allowances before performing the burn action. Currently, calling the `burnFrom` function from the `Fei` contract will allow a Burner to burn *any amount* of `FEI` from *any account* without restriction. In the event that a Burner role address gets compromised, this could present more risk to the protocol than necessary. On the other hand, the more restrictive `burnFrom` function from `ERC20Burnable` considers allowances before burning tokens, which could help lessen the impact of a rogue Burner.\n\n\nFor the `FEI` token, consider using the `burnFrom` function from `ERC20Burnable` rather than the `_burn` function from the `ERC20` contract to minimize risk.\n\n\n**Update:** *Acknowledged. In the words of the Fei team: “We feel that this risk is appropriate as the burner should not need ERC20 approval and is only given to one contract”.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/core/Permissions.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"./IPermissions.sol\";\n\n/// @title IPermissions implementation\n/// @author Fei Protocol\ncontract Permissions is IPermissions, AccessControl {\n\tbytes32 public constant BURNER_ROLE = keccak256(\"BURNER_ROLE\");\n\tbytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\tbytes32 public constant PCV_CONTROLLER_ROLE = keccak256(\"PCV_CONTROLLER_ROLE\");\n\tbytes32 public constant GOVERN_ROLE = keccak256(\"GOVERN_ROLE\");\n\tbytes32 public constant REVOKE_ROLE = keccak256(\"REVOKE_ROLE\");\n\n\tconstructor() public {\n\t\t_setupGovernor(address(this));\n\t\t_setRoleAdmin(MINTER_ROLE, GOVERN_ROLE);\n\t\t_setRoleAdmin(BURNER_ROLE, GOVERN_ROLE);\n\t\t_setRoleAdmin(PCV_CONTROLLER_ROLE, GOVERN_ROLE);\n\t\t_setRoleAdmin(GOVERN_ROLE, GOVERN_ROLE);\n\t\t_setRoleAdmin(REVOKE_ROLE, GOVERN_ROLE);\n\t}\n\n\tmodifier onlyGovernor() {\n\t\trequire(isGovernor(msg.sender), \"Permissions: Caller is not a governor\");\n\t\t_;\n\t}\n\n\tmodifier onlyRevoker() {\n\t\trequire(isRevoker(msg.sender), \"Permissions: Caller is not a revoker\");\n\t\t_;\n\t}\n\n\tfunction createRole(bytes32 role, bytes32 adminRole) external override onlyGovernor {\n\t\t_setRoleAdmin(role, adminRole);\n\t}\n\n\tfunction grantMinter(address minter) external override onlyGovernor {\n\t\tgrantRole(MINTER_ROLE, minter);\n\t} \n\n\tfunction grantBurner(address burner) external override onlyGovernor {\n\t\tgrantRole(BURNER_ROLE, burner);\n\t} \n\n\tfunction grantPCVController(address pcvController) external override onlyGovernor {\n\t\tgrantRole(PCV_CONTROLLER_ROLE, pcvController);\n\t}\n\n\tfunction grantGovernor(address governor) external override onlyGovernor {\n\t\tgrantRole(GOVERN_ROLE, governor);\n\t}\n\n\tfunction grantRevoker(address revoker) external override onlyGovernor {\n\t\tgrantRole(REVOKE_ROLE, revoker);\n\t}\n\n\tfunction revokeMinter(address minter) external override onlyGovernor {\n\t\trevokeRole(MINTER_ROLE, minter);\n\t} \n\n\tfunction revokeBurner(address burner) external override onlyGovernor {\n\t\trevokeRole(BURNER_ROLE, burner);\n\t} \n\n\tfunction revokePCVController(address pcvController) external override onlyGovernor {\n\t\trevokeRole(PCV_CONTROLLER_ROLE, pcvController);\n\t}\n\n\tfunction revokeGovernor(address governor) external override onlyGovernor {\n\t\trevokeRole(GOVERN_ROLE, governor);\n\t}\n\n\tfunction revokeRevoker(address revoker) external override onlyGovernor {\n\t\trevokeRole(REVOKE_ROLE, revoker);\n\t}\n\n\tfunction revokeOverride(bytes32 role, address account) external override onlyRevoker {\n\t\tthis.revokeRole(role, account);\n\t}\n\n\tfunction isMinter(address _address) external override view returns (bool) {\n\t\treturn hasRole(MINTER_ROLE, _address);\n\t}\n\n\tfunction isBurner(address _address) external override view returns (bool) {\n\t\treturn hasRole(BURNER_ROLE, _address);\n\t}\n\n\tfunction isPCVController(address _address) external override view returns (bool) {\n\t\treturn hasRole(PCV_CONTROLLER_ROLE, _address);\n\t}\n\n\t// only virtual for testing mock override\n\tfunction isGovernor(address _address) public override view virtual returns (bool) {\n\t\treturn hasRole(GOVERN_ROLE, _address);\n\t}\n\n\tfunction isRevoker(address _address) public override view returns (bool) {\n\t\treturn hasRole(REVOKE_ROLE, _address);\n\t}\n\n\tfunction _setupGovernor(address governor) internal {\n\t\t_setupRole(GOVERN_ROLE, governor);\n\t}\n}"
    },
    {
      "filename": "contracts/token/Fei.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./IIncentive.sol\";\nimport \"./IFei.sol\";\nimport \"../refs/CoreRef.sol\";\n\n/// @title IFei implementation\n/// @author Fei Protocol\ncontract Fei is IFei, ERC20, ERC20Burnable, CoreRef {\n\n    mapping (address => address) public override incentiveContract;\n\n    bytes32 public DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint) public nonces;\n\n    /// @notice Fei token constructor\n    /// @param core Fei Core address to reference\n\tconstructor(address core) public ERC20(\"Fei USD\", \"FEI\") CoreRef(core) {\n        uint chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n                keccak256(bytes(name())),\n                keccak256(bytes('1')),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    function setIncentiveContract(address account, address incentive) external override onlyGovernor {\n        incentiveContract[account] = incentive;\n        emit IncentiveContractUpdate(account, incentive);\n    }\n\n    function mint(address account, uint amount) external override onlyMinter {\n        _mint(account, amount);\n        emit Minting(account, msg.sender, amount);\n    }\n\n    function burn(uint amount) public override(IFei, ERC20Burnable) {\n        super.burn(amount);\n        emit Burning(msg.sender, msg.sender, amount);\n    }\n\n    function burnFrom(address account, uint amount) public override(IFei, ERC20Burnable) onlyBurner {\n        _burn(account, amount);\n        emit Burning(account, msg.sender, amount);\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint amount) internal override {\n        // If not minting or burning\n        if (from != address(0) && to != address(0)) {\n            _checkAndApplyIncentives(from, to, amount);      \n        }\n    }\n\n    function _checkAndApplyIncentives(address sender, address recipient, uint amount) internal {\n        // incentive on sender\n        address senderIncentive = incentiveContract[sender];\n        if (senderIncentive != address(0)) {\n            IIncentive(senderIncentive).incentivize(sender, recipient, msg.sender, amount);\n        }\n\n        // incentive on recipient\n        address recipientIncentive = incentiveContract[recipient];\n        if (recipientIncentive != address(0)) {\n            IIncentive(recipientIncentive).incentivize(sender, recipient, msg.sender, amount);\n        }\n\n        // incentive on operator\n        address operatorIncentive = incentiveContract[msg.sender];\n        if (msg.sender != sender && msg.sender != recipient && operatorIncentive != address(0)) {\n            IIncentive(operatorIncentive).incentivize(sender, recipient, msg.sender, amount);\n        }\n\n        // all incentive\n        address allIncentive = incentiveContract[address(0)];\n        if (allIncentive != address(0)) {\n            IIncentive(allIncentive).incentivize(sender, recipient, msg.sender, amount);\n        }\n    }\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n        require(deadline >= block.timestamp, 'Fei: EXPIRED');\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                '\\x19\\x01',\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'Fei: INVALID_SIGNATURE');\n        _approve(owner, spender, value);\n    }\n}"
    }
  ]
}