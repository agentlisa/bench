{
  "Title": "[L15] New Oracle instance has to be deployed after a new StabilizerImpl deployment",
  "Content": "The [`Oracle` contract](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/oracle/Oracle.sol#L34) has the functionality to adapt and retrieve the prices for the [`ESD` token](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/token/Dollar.sol#L30). It is owned by the [`StabilizerComptroller` contract](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/stabilizer/StabilizerComptroller.sol#L35).\n\n\nTo set the configuration on both contracts, the owner of the `StabilizerComptroller` contract has to call the [`setup` function](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/stabilizer/StabilizerComptroller.sol#L117) which would [set as one the conversion between `ESD` and `USDC`](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/stabilizer/StabilizerComptroller.sol#L124) but also it will call the [`setup` function](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/stabilizer/StabilizerComptroller.sol#L123) from the `Oracle` contract. There, the new pair will be created and it will be [stored in the variables](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/oracle/Oracle.sol#L108-L109).\n\n\nHowever, in case a new `StabilizerComptroller` is deployed, the setup of it will not be able to succeed by using the same `Oracle` contract, because [a requirement](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/stabilizer/StabilizerComptroller.sol#L121) that checks if the pair has been already setup for `ESD` will revert, preventing to [set as one](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/stabilizer/StabilizerComptroller.sol#L124) the moving average for that token.\n\n\nConsider either allowing to set the initial value of the moving average in the `StabilizerComptroller` when deploying a new version of it without deploying a new `Oracle` contract, or documenting the reason to setup both contracts under the same call.\n\n\n***Update**: Acknowledged. The EmptySetSquad team statement for this issue:*\n\n\n\n> \n> *Won’t fix – this behavior is ok.*\n> \n> \n> \n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/src/oracle/Oracle.sol",
      "content": "/*\n    Copyright 2020, 2021 Empty Set Squad <emptysetsquad@protonmail.com>\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol';\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\nimport '../lib/UniswapV2OracleLibrary.sol';\nimport '../lib/UniswapV2Library.sol';\nimport \"../lib/Decimal.sol\";\nimport \"../Interfaces.sol\";\n\n/**\n * @title Oracle\n * @notice Generic ownable USDC-based Uniswap V2 TWAP oracle\n * @dev Tracks the USDC price for any registered ERC20 token\n *      The owner may capture TWAP updates at any interval\n */\ncontract Oracle is IOracle, Ownable {\n    using Decimal for Decimal.D256;\n\n    /**\n     * @notice Uniswap V2 factory address\n     */\n    address private constant UNISWAP_FACTORY = address(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\n\n    /**\n     * @notice Minimum USDC liquidity for a pool to be considered healthy\n     */\n    uint256 private constant ORACLE_RESERVE_MINIMUM = 1e10; // 10,000 USDC\n\n    /**\n     * @notice State for a single ERC20 token's TWAP oracle\n     */\n    struct Market {\n\n        /**\n         * @notice ERC20 token that is being tracked\n         */\n        address token;\n\n        /**\n         * @notice Corresponding Uniswap V2 USDC-token pair\n         */\n        IUniswapV2Pair pair;\n\n        /**\n         * @notice Index of token in the pair: 0, token == token0; 1, token == token1\n         */\n        uint256 index;\n\n        /**\n         * @notice Has this market been initialized\n         */\n        bool initialized;\n\n        /**\n         * @notice The last recorded cumulative price counter\n         */\n        uint256 cumulative;\n\n        /**\n         * @notice The timestamp of the last recorded cumulative price counter\n         */\n        uint32 timestamp;\n    }\n\n    /**\n     * @notice Address of the USDC token\n     */\n    address public usdc;\n\n    /**\n     * @notice Mapping of all registered markets\n     */\n    mapping(address => Market) internal _markets;\n\n    /**\n     * @notice Construct the oracle contract\n     * @param usdc_ Address of the USDC token\n     */\n    constructor(address usdc_) public {\n        usdc = usdc_;\n    }\n\n    /**\n     * @notice Setup the token for price tracking\n     * @dev Owner only\n     *      Must be called before capture will return a healthy state for the token\n     * @param token EC20 token to register\n     */\n    function setup(address token) public onlyOwner {\n        _markets[token].token = token;\n        _markets[token].pair = _createOrGetPair(token);\n\n        IUniswapV2Pair pair = pairFor(token);\n        (address token0, address token1) = (pair.token0(), pair.token1());\n        _markets[token].index = token == token0 ? 0 : 1;\n\n        require(token == token0 || token == token1, \"Oracle: token not found\");\n        require(usdc == token0 || usdc == token1, \"Oracle: USDC not found\");\n        require(token0 != token1, \"Oracle: token is USDC\");\n    }\n\n    /**\n     * @notice Capture the TWAP price since last capture\n     * @dev Owner only\n     *\n     *      Can be called at any cadence by the owner, returns the elapsed seconds since last call\n     *      for further computation by the consumer\n     *\n     *      Trades/Liquidity: (1) Initializes reserve and blockTimestampLast (can calculate a price)\n     *                        (2) Has non-zero cumulative prices\n     *\n     *      Steps: (1) Captures a reference blockTimestampLast\n     *             (2) First reported value\n     *\n     * @param token EC20 token to capture\n     * @return The price decimal-normalized as a Decimal.256, seconds since last capture, and oracle health flag\n     */\n    function capture(address token) public onlyOwner returns (Decimal.D256 memory, uint256, bool) {\n\n        // The owner has not yet setup this market\n        if (!setupFor(token)) {\n            return (Decimal.one(), 0, false);\n        }\n\n        // This is the first capture call for the market, initialize\n        if (!initializedFor(token)) {\n            _initializeOracle(token);\n            return (Decimal.one(), 0, false);\n        }\n\n        // Market is setup and initialized, proceed as normal\n        return _updateOracle(token);\n    }\n\n    /**\n     * @notice Capture the initial window and initial state for the specific market\n     * @dev Internal only - helper\n     *      Is called on the first capture for each market\n     * @param token EC20 token to initialize\n     */\n    function _initializeOracle(address token) private {\n        IUniswapV2Pair pair = pairFor(token);\n        uint256 priceCumulative = _choose(token, pair.price0CumulativeLast(), pair.price1CumulativeLast());\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = pair.getReserves();\n        if(reserve0 != 0 && reserve1 != 0 && blockTimestampLast != 0) {\n            _updateMarket(token, priceCumulative, blockTimestampLast);\n            _markets[token].initialized = true;\n        }\n    }\n\n    /**\n    /**\n     * @notice Captures TWAP data then checks the health of the oracle\n     * @dev Internal only - helper\n     * @param token EC20 token to capture\n     * @return The price decimal-normalized as a Decimal.256, seconds since last capture, and oracle health flag\n     */\n    function _updateOracle(address token) private returns (Decimal.D256 memory price, uint256 elapsed, bool valid) {\n        (price, elapsed) = _updatePrice(token);\n        bool isBlacklisted = IUSDC(usdc).isBlacklisted(address(pairFor(token)));\n        valid = !isBlacklisted && (_liquidity(token) >= ORACLE_RESERVE_MINIMUM);\n    }\n\n    /**\n     * @notice Captures oracle data from Uniswap V2, computes and stores the new TWAP oracle state\n     * @dev Internal only - helper\n     *      If no time has passed, returns a default 1.00 price\n     * @param token EC20 token to capture\n     * @return The price decimal-normalized as a Decimal.256, seconds since last capture\n     */\n    function _updatePrice(address token) private returns (Decimal.D256 memory, uint256) {\n        (uint256 price0Cumulative, uint256 price1Cumulative, uint32 blockTimestamp) =\n            UniswapV2OracleLibrary.currentCumulativePrices(address(pairFor(token)));\n        uint32 timeElapsed = blockTimestamp - timestampFor(token); // overflow is desired\n        if (timeElapsed == 0) return (Decimal.one(), 0);\n\n        uint256 priceCumulative = _choose(token, price0Cumulative, price1Cumulative);\n        Decimal.D256 memory price = Decimal.ratio((priceCumulative - cumulativeFor(token)) / timeElapsed, 2**112);\n\n        _updateMarket(token, priceCumulative, blockTimestamp);\n\n        return (_normalize(token, price), uint256(timeElapsed));\n    }\n\n    // GETTERS\n\n    /**\n     * @notice Whether the `token` has been setup by the owner\n     * @param token EC20 token to check\n     * @return token setup status\n     */\n    function setupFor(address token) public view returns (bool) {\n        return _markets[token].token != address(0);\n    }\n\n    /**\n     * @notice Whether the market for `token` has been initialized\n     * @param token EC20 token to check\n     * @return token initialization status\n     */\n    function initializedFor(address token) public view returns (bool) {\n        return _markets[token].initialized;\n    }\n\n    /**\n     * @notice The cumulative price counter for the `token` market\n     * @param token EC20 token to check\n     * @return Cumulative price counter\n     */\n    function cumulativeFor(address token) public view returns (uint256) {\n        return _markets[token].cumulative;\n    }\n\n    /**\n     * @notice The last timestamp cumulative price counter was updated for the `token` market\n     * @param token EC20 token to check\n     * @return Last update timestamp\n     */\n    function timestampFor(address token) public view returns (uint32) {\n        return _markets[token].timestamp;\n    }\n\n    /**\n     * @notice The address of the USDC-`token` Uniswap V2 pair\n     * @param token EC20 token to check\n     * @return Uniswap V2 pair address\n     */\n    function pairFor(address token) public view returns (IUniswapV2Pair) {\n        return _markets[token].pair;\n    }\n\n    // INTERNAL\n\n    /**\n     * @notice Creates the USDC-`token` Uniswap V2 if it does not already exist\n     * @dev Internal only - helper\n     * @param token EC20 token to create for\n     * @return The existing or new pair address\n     */\n    function _createOrGetPair(address token) internal returns (IUniswapV2Pair) {\n        address pair = IUniswapV2Factory(UNISWAP_FACTORY).getPair(usdc, token);\n        if (pair == address(0)) {\n            return IUniswapV2Pair(IUniswapV2Factory(UNISWAP_FACTORY).createPair(usdc, token));\n        }\n        return IUniswapV2Pair(pair);\n    }\n\n    /**\n     * @notice Stores the new `cumulative` and `timestamp` state for the `token` market\n     * @dev Internal only\n     * @param token EC20 token to update\n     * @param cumulative New cumulative price counter value\n     * @param timestamp New latest updated timestamp value\n     */\n    function _updateMarket(address token, uint256 cumulative, uint32 timestamp) private {\n        _markets[token].timestamp = timestamp;\n        _markets[token].cumulative = cumulative;\n    }\n\n    /**\n     * @notice Normalizes `price` for the difference in decimals between USDC and `token`\n     * @dev Internal only - helper\n     * @param token EC20 token for the price that is being normalized\n     * @param price Decimal.D256 price to normalize\n     * @return normalized Decimal.D256 price\n     */\n    function _normalize(address token, Decimal.D256 memory price) private view returns (Decimal.D256 memory) {\n        uint8 decimals = IToken(token).decimals();\n        if (decimals > 6) {\n            return price.mul(10 ** (uint256(decimals) - 6));\n        } else if (decimals < 6) {\n            return price.mul(10 ** (6 - uint256(decimals)));\n        }\n        return price;\n    }\n\n    /**\n     * @notice Retrieve the total amount of USDC liquidity currently in the `token` market\n     * @dev Internal only - helper\n     * @param token EC20 token to retrieve liquidity for\n     * @return total USDC supplied to USDC-`token` market\n     */\n    function _liquidity(address token) private view returns (uint256) {\n        (uint112 reserve0, uint112 reserve1,) = _markets[token].pair.getReserves();\n        return _choose(token, uint256(reserve1), uint256(reserve0)); // get counter's reserve\n    }\n\n    /**\n     * @notice Choose between two values based on the index of the `token` market\n     * @dev Internal only - helper\n     * @param token EC20 token to choose for\n     * @param index0Value Value if market index is 0\n     * @param index1Value Value if market index is 1\n     * @return index == 0, index0Value; index == 1, index1Value\n     */\n    function _choose(address token, uint256 index0Value, uint256 index1Value) private view returns (uint256) {\n        return _markets[token].index == 0 ? index0Value : index1Value;\n    }\n}"
    },
    {
      "filename": "protocol/contracts/src/stabilizer/StabilizerComptroller.sol",
      "content": "/*\n    Copyright 2021 Empty Set Squad <emptysetsquad@protonmail.com>\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../Interfaces.sol\";\nimport \"../lib/Decimal.sol\";\nimport \"../lib/TimeUtils.sol\";\nimport \"./StabilizerState.sol\";\nimport \"./StabilizerToken.sol\";\n\n/**\n * @title StabilizerComptroller\n * @notice Stabilizer core accounting logic supplying, redeeming, and managing ESD.\n * @dev Any ESD that is airdropped into the stabilizer will be automatically become part of the pool\n */\ncontract StabilizerComptroller is StabilizerAccessors, StabilizerToken {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Emitted when `account` supplies `amount` ESD to the stabilizer for `mintAmount` sESD\n     */\n    event Supply(address indexed account, uint256 amount, uint256 mintAmount);\n\n    /**\n     * @notice Emitted when `account` redeems `amount` ESD from the stabilizer for `burnAmount` sESD\n     */\n    event Redeem(address indexed account, uint256 amount, uint256 burnAmount);\n\n    /**\n     * @notice Emitted every time the stabilizer borrows `amount` ESD from the reserve to accrue rewards\n     */\n    event Settle(uint256 amount);\n\n    // EXTERNAL\n\n    /**\n     * @notice The total amount of ESD held by the stabilizer\n     * @return Total ESD holdings\n     */\n    function totalUnderlying() public view returns (uint256) {\n        return IERC20(registry().dollar()).balanceOf(address(this));\n    }\n\n    /**\n     * @notice The ESD balance for `account`\n     * @param account Account to retrieve balance information for\n     * @return ESD balance\n     */\n    function balanceOfUnderlying(address account) public view returns (uint256) {\n        return balanceOf(account).mul(totalUnderlying()).div(totalSupply());\n    }\n\n    /**\n     * @notice Deposits ESD into the stabilizer in exchange for sESD reward-accruing tokens\n     * @param amount Amount of ESD to supply\n     */\n    function supply(uint256 amount) external {\n        _settle();\n\n        uint256 mintAmount = totalUnderlying() == 0 ? amount : amount.mul(totalSupply()).div(totalUnderlying());\n\n        _supply(msg.sender, amount, mintAmount);\n    }\n\n    /**\n     * @notice Withdraws ESD from the stabilizer in exchange for sESD reward-accruing tokens\n     * @param amount Amount of sESD to redeem\n     */\n    function redeem(uint256 amount) external {\n        _settle();\n\n        uint256 redeemAmount = amount.mul(totalUnderlying()).div(totalSupply(), \"StabilizerComptroller: no supply\");\n\n        _redeem(msg.sender, redeemAmount, amount);\n    }\n\n    /**\n     * @notice Withdraws ESD from the stabilizer in exchange for sESD reward-accruing tokens\n     * @param amount Amount of ESD to redeem\n     */\n    function redeemUnderlying(uint256 amount) external {\n        _settle();\n\n        uint256 burnAmount = amount.mul(totalSupply()).div(totalUnderlying(), \"StabilizerComptroller: no underlying\");\n\n        _redeem(msg.sender, amount, burnAmount);\n    }\n\n    // FLYWHEEL\n\n    /**\n     * @notice The stabilizer's current effective reward rate\n     * @dev In terms of % of the totalUnderlying per day\n     *      Uses EMA floored at the current reserve redemption price and maxed at 1.00\n     * @return Current effective reward rate\n     */\n    function setup() external onlyOwner {\n        IOracle oracle = IOracle(registry().oracle());\n        address dollar = registry().dollar();\n\n        require(!oracle.setupFor(dollar), \"StabilizerComptroller: already setup\");\n\n        oracle.setup(dollar);\n        _state.oracle.ema = Decimal.one();\n    }\n\n    /**\n     * @notice The stabilizer's current effective reward rate\n     * @dev In terms of % of the totalUnderlying per day\n     *      Uses EMA floored at the current reserve redemption price and maxed at 1.00\n     * @return Current effective reward rate\n     */\n    function rate() public view returns (Decimal.D256 memory) {\n        Decimal.D256 memory emaMin = IReserve(registry().reserve()).redeemPrice();\n        Decimal.D256 memory emaMax = Decimal.one();\n        Decimal.D256 memory ema = ema();\n        Decimal.D256 memory emaLimited = Decimal.min(Decimal.max(ema, emaMin), emaMax);\n\n        return Decimal.one().sub(emaLimited).mul(rewardRate());\n    }\n\n    /**\n     * @notice Core flywheel which captures the oracle TWAP, updates the EMA, and borrows the corresponding amount\n     * @dev EMA_1 = (alpha * price) + ((1 - alpha) * EMA_0)\n     *      alpha = decayRate * elapsedDays, maxed out at maxAlpha()\n     *      If oracle becomes unhealthy immediately set EMA to 1\n     *\n     *      Borrows rate() * elapsedDays * totalUnderlying() ESD from the stabilizer\n     *      Uses rate() before EMA update to prevent same-block price manipulation\n     */\n    function _settle() internal {\n\n        // Get current oracle snapshot\n        (Decimal.D256 memory price, uint256 elapsed, bool healthy) =\n            IOracle(registry().oracle()).capture(registry().dollar());\n        Decimal.D256 memory elapsedDays = TimeUtils.secondsToDays(elapsed);\n\n        // Borrow ESD per prior rate\n        uint256 borrowAmount = rate().mul(elapsedDays).mul(totalUnderlying()).asUint256();\n        if (borrowAmount != 0) IReserve(registry().reserve()).borrow(borrowAmount);\n\n        // Update EMA\n        if (healthy) {\n            Decimal.D256 memory alpha = Decimal.min(decayRate().mul(elapsedDays), maxAlpha());\n            _updateEma(alpha.mul(price).add(Decimal.one().sub(alpha).mul(ema())));\n        } else {\n            _updateEma(Decimal.one());\n        }\n\n        emit Settle(borrowAmount);\n    }\n\n    // INTERNAL\n\n    /**\n     * @notice Deposits ESD into the stabilizer in exchange for sESD reward-accruing tokens\n     * @dev Internal only - generic helper\n     * @param account Account that is supplying\n     * @param supplyAmount ESD amount to supply\n     * @param mintAmount sESD amount to mint\n     */\n    function _supply(address account, uint256 supplyAmount, uint256 mintAmount) internal {\n        IERC20(registry().dollar()).safeTransferFrom(account, address(this), supplyAmount);\n        _mint(msg.sender, mintAmount);\n\n        emit Supply(account, supplyAmount, mintAmount);\n    }\n\n    /**\n     * @notice Deposits ESD into the stabilizer in exchange for sESD reward-accruing tokens\n     * @dev Internal only - generic helper\n     * @param account Account that is redeeming\n     * @param redeemAmount ESD amount to redeem\n     * @param burnAmount sESD amount to burn\n     */\n    function _redeem(address account, uint256 redeemAmount, uint256 burnAmount) internal {\n        _burn(msg.sender, burnAmount);\n        IERC20(registry().dollar()).safeTransfer(msg.sender, redeemAmount);\n\n        emit Redeem(account, redeemAmount, burnAmount);\n    }\n}"
    },
    {
      "filename": "protocol/contracts/src/stabilizer/StabilizerComptroller.sol",
      "content": "/*\n    Copyright 2021 Empty Set Squad <emptysetsquad@protonmail.com>\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../Interfaces.sol\";\nimport \"../lib/Decimal.sol\";\nimport \"../lib/TimeUtils.sol\";\nimport \"./StabilizerState.sol\";\nimport \"./StabilizerToken.sol\";\n\n/**\n * @title StabilizerComptroller\n * @notice Stabilizer core accounting logic supplying, redeeming, and managing ESD.\n * @dev Any ESD that is airdropped into the stabilizer will be automatically become part of the pool\n */\ncontract StabilizerComptroller is StabilizerAccessors, StabilizerToken {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Emitted when `account` supplies `amount` ESD to the stabilizer for `mintAmount` sESD\n     */\n    event Supply(address indexed account, uint256 amount, uint256 mintAmount);\n\n    /**\n     * @notice Emitted when `account` redeems `amount` ESD from the stabilizer for `burnAmount` sESD\n     */\n    event Redeem(address indexed account, uint256 amount, uint256 burnAmount);\n\n    /**\n     * @notice Emitted every time the stabilizer borrows `amount` ESD from the reserve to accrue rewards\n     */\n    event Settle(uint256 amount);\n\n    // EXTERNAL\n\n    /**\n     * @notice The total amount of ESD held by the stabilizer\n     * @return Total ESD holdings\n     */\n    function totalUnderlying() public view returns (uint256) {\n        return IERC20(registry().dollar()).balanceOf(address(this));\n    }\n\n    /**\n     * @notice The ESD balance for `account`\n     * @param account Account to retrieve balance information for\n     * @return ESD balance\n     */\n    function balanceOfUnderlying(address account) public view returns (uint256) {\n        return balanceOf(account).mul(totalUnderlying()).div(totalSupply());\n    }\n\n    /**\n     * @notice Deposits ESD into the stabilizer in exchange for sESD reward-accruing tokens\n     * @param amount Amount of ESD to supply\n     */\n    function supply(uint256 amount) external {\n        _settle();\n\n        uint256 mintAmount = totalUnderlying() == 0 ? amount : amount.mul(totalSupply()).div(totalUnderlying());\n\n        _supply(msg.sender, amount, mintAmount);\n    }\n\n    /**\n     * @notice Withdraws ESD from the stabilizer in exchange for sESD reward-accruing tokens\n     * @param amount Amount of sESD to redeem\n     */\n    function redeem(uint256 amount) external {\n        _settle();\n\n        uint256 redeemAmount = amount.mul(totalUnderlying()).div(totalSupply(), \"StabilizerComptroller: no supply\");\n\n        _redeem(msg.sender, redeemAmount, amount);\n    }\n\n    /**\n     * @notice Withdraws ESD from the stabilizer in exchange for sESD reward-accruing tokens\n     * @param amount Amount of ESD to redeem\n     */\n    function redeemUnderlying(uint256 amount) external {\n        _settle();\n\n        uint256 burnAmount = amount.mul(totalSupply()).div(totalUnderlying(), \"StabilizerComptroller: no underlying\");\n\n        _redeem(msg.sender, amount, burnAmount);\n    }\n\n    // FLYWHEEL\n\n    /**\n     * @notice The stabilizer's current effective reward rate\n     * @dev In terms of % of the totalUnderlying per day\n     *      Uses EMA floored at the current reserve redemption price and maxed at 1.00\n     * @return Current effective reward rate\n     */\n    function setup() external onlyOwner {\n        IOracle oracle = IOracle(registry().oracle());\n        address dollar = registry().dollar();\n\n        require(!oracle.setupFor(dollar), \"StabilizerComptroller: already setup\");\n\n        oracle.setup(dollar);\n        _state.oracle.ema = Decimal.one();\n    }\n\n    /**\n     * @notice The stabilizer's current effective reward rate\n     * @dev In terms of % of the totalUnderlying per day\n     *      Uses EMA floored at the current reserve redemption price and maxed at 1.00\n     * @return Current effective reward rate\n     */\n    function rate() public view returns (Decimal.D256 memory) {\n        Decimal.D256 memory emaMin = IReserve(registry().reserve()).redeemPrice();\n        Decimal.D256 memory emaMax = Decimal.one();\n        Decimal.D256 memory ema = ema();\n        Decimal.D256 memory emaLimited = Decimal.min(Decimal.max(ema, emaMin), emaMax);\n\n        return Decimal.one().sub(emaLimited).mul(rewardRate());\n    }\n\n    /**\n     * @notice Core flywheel which captures the oracle TWAP, updates the EMA, and borrows the corresponding amount\n     * @dev EMA_1 = (alpha * price) + ((1 - alpha) * EMA_0)\n     *      alpha = decayRate * elapsedDays, maxed out at maxAlpha()\n     *      If oracle becomes unhealthy immediately set EMA to 1\n     *\n     *      Borrows rate() * elapsedDays * totalUnderlying() ESD from the stabilizer\n     *      Uses rate() before EMA update to prevent same-block price manipulation\n     */\n    function _settle() internal {\n\n        // Get current oracle snapshot\n        (Decimal.D256 memory price, uint256 elapsed, bool healthy) =\n            IOracle(registry().oracle()).capture(registry().dollar());\n        Decimal.D256 memory elapsedDays = TimeUtils.secondsToDays(elapsed);\n\n        // Borrow ESD per prior rate\n        uint256 borrowAmount = rate().mul(elapsedDays).mul(totalUnderlying()).asUint256();\n        if (borrowAmount != 0) IReserve(registry().reserve()).borrow(borrowAmount);\n\n        // Update EMA\n        if (healthy) {\n            Decimal.D256 memory alpha = Decimal.min(decayRate().mul(elapsedDays), maxAlpha());\n            _updateEma(alpha.mul(price).add(Decimal.one().sub(alpha).mul(ema())));\n        } else {\n            _updateEma(Decimal.one());\n        }\n\n        emit Settle(borrowAmount);\n    }\n\n    // INTERNAL\n\n    /**\n     * @notice Deposits ESD into the stabilizer in exchange for sESD reward-accruing tokens\n     * @dev Internal only - generic helper\n     * @param account Account that is supplying\n     * @param supplyAmount ESD amount to supply\n     * @param mintAmount sESD amount to mint\n     */\n    function _supply(address account, uint256 supplyAmount, uint256 mintAmount) internal {\n        IERC20(registry().dollar()).safeTransferFrom(account, address(this), supplyAmount);\n        _mint(msg.sender, mintAmount);\n\n        emit Supply(account, supplyAmount, mintAmount);\n    }\n\n    /**\n     * @notice Deposits ESD into the stabilizer in exchange for sESD reward-accruing tokens\n     * @dev Internal only - generic helper\n     * @param account Account that is redeeming\n     * @param redeemAmount ESD amount to redeem\n     * @param burnAmount sESD amount to burn\n     */\n    function _redeem(address account, uint256 redeemAmount, uint256 burnAmount) internal {\n        _burn(msg.sender, burnAmount);\n        IERC20(registry().dollar()).safeTransfer(msg.sender, redeemAmount);\n\n        emit Redeem(account, redeemAmount, burnAmount);\n    }\n}"
    }
  ]
}