{
  "Title": "[01] `CR` could be over/undervalued due to its unsafe dependence on `vault.getUsdValue()`",
  "Content": "\nhttps://github.com/code-423n4/2024-04-dyad/blob/4a987e536576139793a1c04690336d06c93fca90/src/core/Vault.kerosine.unbounded.sol#L50-L68\n\n```solidity\n  function assetPrice()\n    public\n    view\n    override\n    returns (uint) {\n      uint tvl;\n      //@audit\n      address[] memory vaults = kerosineManager.getVaults();\n      uint numberOfVaults = vaults.length;\n      for (uint i = 0; i < numberOfVaults; i++) {\n        Vault vault = Vault(vaults[i]);\n        tvl += vault.asset().balanceOf(address(vault))\n                * vault.assetPrice() * 1e18\n                / (10**vault.asset().decimals())\n                / (10**vault.oracle().decimals());\n      }\n      uint numerator   = tvl - dyad.totalSupply();\n      uint denominator = kerosineDenominator.denominator();\n      return numerator * 1e8 / denominator;\n  }\n```\n\nThis function is used to get the price of an asset, and it gets that by querying the specific vault of that asset for it's balance and price.\n\nKeep in mind that this function is also used whenever getting price from the bounded vault as shown [here](https://github.com/code-423n4/2024-04-dyad/blob/4a987e536576139793a1c04690336d06c93fca90/src/core/Vault.kerosine.bounded.sol#L44-L50).\n\n```solidity\n\n  function assetPrice()\n    public\n    view\n    override\n    returns (uint) {\n      return unboundedKerosineVault.assetPrice() * 2;\n        }\n```\n\nGoing back to the `VaultManagerV2.sol`, we can see that the line `usdValue = vault.getUsdValue(id);` is queried whenever there is a need to get the collateral ratio for asset as confirmed by [this search command](https://github.com/search?q=repo%3Acode-423n4%2F2024-04-dyad+usdValue+%3D+vault.getUsdValue%28id%29%3B+++NOT+language%3AMarkdown&type=code) and queries the two aforementioned functions as shown [here](https://github.com/code-423n4/2024-04-dyad/blob/4a987e536576139793a1c04690336d06c93fca90/src/core/Vault.sol#L79-L104).\n\n```solidity\n  function getUsdValue(\n    uint id\n  )\n    external\n    view\n    returns (uint) {\n      return id2asset[id] * assetPrice()\n              * 1e18\n              / 10**oracle.decimals()\n              / 10**asset.decimals();\n  }\n\n\n\n  function assetPrice()\n    public\n    view\n    returns (uint) {\n      (\n        ,\n        int256 answer,\n        ,\n        uint256 updatedAt,\n      ) = oracle.latestRoundData();\n      if (block.timestamp > updatedAt + STALE_DATA_TIMEOUT) revert StaleData();\n      return answer.toUint256();\n  }\n```\n\nThat is to say that the pricing logic requires us to query chainlink at the end of the calls, but evidently, we can see that this call lacks any check on the in-aggregator built min/max circuits; which would make protocol either overvalue or undervalue the collateral depending on which boundary is crossed.\n\nA little bit more on the min/max circuits is that, Chainlink price feeds have in-built minimum & maximum prices they will return; if during a flash crash, bridge compromise, or depegging event, an asset’s value falls below the price feed’s minimum price, the oracle price feed will continue to report the (now incorrect) minimum price, so an an attacker could:\n\n- Have their asset in protocol.\n- Real price of value dropped very low.\n- Attacker buys these assets in bulk from an exchange.\n- Brings it back to mint undercolaterized DYAD, since protocol would assume a way higher price than really is for the asset.\n\n### Impact\n\nBorderline medium/low, as this essentially breaks core functionalities like documented collateralization level of DYAD to always be `>` 150%, and in severe cases, this could even cause the DYAD to depeg.\n\n### Recommended Mitigation Steps\n\nStore the asset's min/max checks, reimplement the way `vault.getUsdValue()` is being queried and have direct access to the price data being returned and check if it's at these boundaries and revert or alternatively integrate a fallback oracle and then use the price from this instead.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-04-dyad",
  "Code": [
    {
      "filename": "src/core/Vault.kerosine.unbounded.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.17;\n\nimport {KerosineVault}        from \"./Vault.kerosine.sol\";\nimport {IVaultManager}        from \"../interfaces/IVaultManager.sol\";\nimport {Vault}                from \"./Vault.sol\";\nimport {Dyad}                 from \"./Dyad.sol\";\nimport {KerosineManager}      from \"./KerosineManager.sol\";\nimport {BoundedKerosineVault} from \"./Vault.kerosine.bounded.sol\";\nimport {KerosineDenominator}  from \"../staking/KerosineDenominator.sol\";\n\nimport {ERC20}           from \"@solmate/src/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"@solmate/src/utils/SafeTransferLib.sol\";\n\ncontract UnboundedKerosineVault is KerosineVault {\n  using SafeTransferLib for ERC20;\n\n  Dyad                 public immutable dyad;\n  KerosineDenominator  public kerosineDenominator;\n\n  constructor(\n      IVaultManager   _vaultManager,\n      ERC20           _asset, \n      Dyad            _dyad, \n      KerosineManager _kerosineManager\n  ) KerosineVault(_vaultManager, _asset, _kerosineManager) {\n      dyad = _dyad;\n  }\n\n  function withdraw(\n    uint    id,\n    address to,\n    uint    amount\n  ) \n    external \n      onlyVaultManager\n  {\n    id2asset[id] -= amount;\n    asset.safeTransfer(to, amount); \n    emit Withdraw(id, to, amount);\n  }\n\n  function setDenominator(KerosineDenominator _kerosineDenominator) \n    external \n      onlyOwner\n  {\n    kerosineDenominator = _kerosineDenominator;\n  }\n\n  function assetPrice() \n    public \n    view \n    override\n    returns (uint) {\n      uint tvl;\n      address[] memory vaults = kerosineManager.getVaults();\n      uint numberOfVaults = vaults.length;\n      for (uint i = 0; i < numberOfVaults; i++) {\n        Vault vault = Vault(vaults[i]);\n        tvl += vault.asset().balanceOf(address(vault)) \n                * vault.assetPrice() * 1e18\n                / (10**vault.asset().decimals()) \n                / (10**vault.oracle().decimals());\n      }\n      uint numerator   = tvl - dyad.totalSupply();\n      uint denominator = kerosineDenominator.denominator();\n      return numerator * 1e8 / denominator;\n  }\n}"
    },
    {
      "filename": "src/core/Vault.kerosine.bounded.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.17;\n\nimport {KerosineVault}          from \"./Vault.kerosine.sol\";\nimport {IVaultManager}          from \"../interfaces/IVaultManager.sol\";\nimport {Dyad}                   from \"./Dyad.sol\";\nimport {KerosineManager}        from \"./KerosineManager.sol\";\nimport {UnboundedKerosineVault} from \"./Vault.kerosine.unbounded.sol\";\n\nimport {ERC20} from \"@solmate/src/tokens/ERC20.sol\";\n\ncontract BoundedKerosineVault is KerosineVault {\n  error NotWithdrawable(uint id, address to, uint amount);\n\n  UnboundedKerosineVault public unboundedKerosineVault;\n\n  constructor(\n    IVaultManager   _vaultManager,\n    ERC20           _asset, \n    KerosineManager _kerosineManager\n  ) KerosineVault(_vaultManager, _asset, _kerosineManager) {}\n\n  function setUnboundedKerosineVault(\n    UnboundedKerosineVault _unboundedKerosineVault\n  )\n    external\n    onlyOwner\n  {\n    unboundedKerosineVault = _unboundedKerosineVault;\n  }\n\n  function withdraw(\n    uint    id,\n    address to,\n    uint    amount\n  ) \n    external \n    view\n      onlyVaultManager\n  {\n    revert NotWithdrawable(id, to, amount);\n  }\n\n  function assetPrice() \n    public \n    view \n    override\n    returns (uint) {\n      return unboundedKerosineVault.assetPrice() * 2;\n  }\n}"
    }
  ]
}