{
  "Title": "[M-01] `SecurityCouncilMemberElectionGovernor` Owner Can Change `votingPeriod` During an Active Election",
  "Content": "\n<https://github.com/ArbitrumFoundation/governance/blob/c18de53820c505fc459f766c1b224810eaeaabc5/src/security-council-mgmt/governors/SecurityCouncilMemberElectionGovernor.sol#L103-L110><br>\n<https://github.com/ArbitrumFoundation/governance/blob/c18de53820c505fc459f766c1b224810eaeaabc5/src/security-council-mgmt/governors/modules/SecurityCouncilMemberElectionGovernorCountingUpgradeable.sol#L77-L84>\n\n### Impact\n\n*   In `SecurityCouncilMemberElectionGovernor` contract : `relay` function enables the contract owner from making calls to any contract address.\n\n*   And in `SecurityCouncilMemberElectionGovernorCountingUpgradeable` contract: `setFullWeightDuration` can be accessed only by invoking it from `SecurityCouncilMemberElectionGovernor` which is possible only via `relay` function.\n\n*   So the owner can set a new value for `fullWeightDuration` that is used to determine the deadline after which the voting weight will linearly decrease.\n\n*   But when setting it; there's no check if there's a current active proposal.\n\n*   This makes the voting unfair and the results unreliable as the owner can control the voting power during the election; as increasing the voting power of late voters if `fullWeightDuration` is set to a higher value during active election.\n\n### Proof of Concept\n\n*   Code:\n\n    [SecurityCouncilMemberElectionGovernor contract/relay function](https://github.com/ArbitrumFoundation/governance/blob/c18de53820c505fc459f766c1b224810eaeaabc5/src/security-council-mgmt/governors/SecurityCouncilMemberElectionGovernor.sol#L103-L110)\n\n    ```solidity\n    File:governance/src/security-council-mgmt/governors/SecurityCouncilMemberElectionGovernor.sol\n    Line 103-110:\n        function relay(address target, uint256 value, bytes calldata data)\n            external\n            virtual\n            override\n            onlyOwner\n        {\n            AddressUpgradeable.functionCallWithValue(target, data, value);\n        }\n    ```\n\n    [SecurityCouncilMemberElectionGovernorCountingUpgradeable contract/setFullWeightDuration function](https://github.com/ArbitrumFoundation/governance/blob/c18de53820c505fc459f766c1b224810eaeaabc5/src/security-council-mgmt/governors/modules/SecurityCouncilMemberElectionGovernorCountingUpgradeable.sol#L77-L84)\n\n    ```solidity\n    File: governance/src/security-council-mgmt/governors/modules/SecurityCouncilMemberElectionGovernorCountingUpgradeable.sol\n    Line 77-84:\n       function setFullWeightDuration(uint256 newFullWeightDuration) public onlyGovernance {\n          if (newFullWeightDuration > votingPeriod()) {\n              revert FullWeightDurationGreaterThanVotingPeriod(newFullWeightDuration, votingPeriod());\n          }\n\n          fullWeightDuration = newFullWeightDuration;\n          emit FullWeightDurationSet(newFullWeightDuration);\n      }\n    ```\n\n*   Foundry PoC:\n\n1.  `testSetVotingPeriodDuringActiveProposal()` test is added to `SecurityCouncilMemberElectionGovernorTest.t.sol` file; where the relay function is invoked by the contract owner to change the `fullWeightDuration` during an active proposal:\n\n    ```solidity\n    function testSetVotingPeriodDuringActiveProposal() public {\n     //1. initiate a proposal\n     _propose(0);\n     //2. change fullWeightDuration while the proposal is still active\n     assertEq(governor.votingPeriod(), initParams.votingPeriod);\n     vm.prank(initParams.owner);\n     governor.relay(\n       address(governor),\n       0,\n       abi.encodeWithSelector(governor.setVotingPeriod.selector, 121_212)\n     );\n     assertEq(governor.votingPeriod(), 121_212);\n    }\n    ```\n\n2.  Test result:\n\n    ```bash\n    $ forge test --match-test testSetVotingPeriodDuringActiveProposal\n    [PASS] testSetVotingPeriodDuringActiveProposal() (gas: 118129)\n    Test result: ok. 1 passed; 0 failed; 0 skipped; finished in 4.51ms\n    Ran 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests)\n    ```\n\n### Tools Used\n\nManual Testing & Foundry.\n\n### Recommended Mitigation Steps\n\nEnable setting a new value for `fullWeightDuration` only if there's no active election.\n\n### Assessed type\n\nGovernance\n\n**[yahgwai (Arbitrum) confirmed and commented via duplicate issue `#52`](https://github.com/code-423n4/2023-08-arbitrum-findings/issues/52#issuecomment-1678796082):**\n > Fix: https://github.com/ArbitrumFoundation/governance/pull/184. Fix is just add comments informing the caller not to set during certain times.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-08-arbitrum",
  "Code": [
    {
      "filename": "src/security-council-mgmt/governors/SecurityCouncilMemberElectionGovernor.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorSettingsUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./modules/SecurityCouncilMemberElectionGovernorCountingUpgradeable.sol\";\nimport \"../interfaces/ISecurityCouncilMemberElectionGovernor.sol\";\nimport \"../interfaces/ISecurityCouncilNomineeElectionGovernor.sol\";\nimport \"../interfaces/ISecurityCouncilManager.sol\";\nimport \"./modules/ElectionGovernor.sol\";\n\n/// @title  SecurityCouncilMemberElectionGovernor\n/// @notice Narrows a set of nominees down to a set of members.\n/// @dev    Proposals are created by the SecurityCouncilNomineeElectionGovernor.\n///         This governor is responsible for executing the final election result by calling the SecurityCouncilManager.\ncontract SecurityCouncilMemberElectionGovernor is\n    Initializable,\n    GovernorUpgradeable,\n    GovernorVotesUpgradeable,\n    SecurityCouncilMemberElectionGovernorCountingUpgradeable,\n    GovernorSettingsUpgradeable,\n    OwnableUpgradeable,\n    ElectionGovernor,\n    ISecurityCouncilMemberElectionGovernor\n{\n    /// @notice The SecurityCouncilNomineeElectionGovernor that creates proposals for this governor and contains the list of compliant nominees\n    ISecurityCouncilNomineeElectionGovernor public nomineeElectionGovernor;\n\n    /// @notice The SecurityCouncilManager that will execute the election result\n    ISecurityCouncilManager public securityCouncilManager;\n\n    error InvalidDurations(uint256 fullWeightDuration, uint256 votingPeriod);\n    error OnlyNomineeElectionGovernor();\n    error ProposeDisabled();\n    error CastVoteDisabled();\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @param _nomineeElectionGovernor The SecurityCouncilNomineeElectionGovernor\n    /// @param _securityCouncilManager The SecurityCouncilManager\n    /// @param _token The token used for voting\n    /// @param _owner The owner of the governor\n    /// @param _votingPeriod The duration of voting on a proposal\n    /// @param _fullWeightDuration Duration of full weight voting (blocks)\n    function initialize(\n        ISecurityCouncilNomineeElectionGovernor _nomineeElectionGovernor,\n        ISecurityCouncilManager _securityCouncilManager,\n        IVotesUpgradeable _token,\n        address _owner,\n        uint256 _votingPeriod,\n        uint256 _fullWeightDuration\n    ) public initializer {\n        if (_fullWeightDuration > _votingPeriod) {\n            revert InvalidDurations(_fullWeightDuration, _votingPeriod);\n        }\n\n        __Governor_init(\"SecurityCouncilMemberElectionGovernor\");\n        __GovernorVotes_init(_token);\n        __SecurityCouncilMemberElectionGovernorCounting_init({\n            initialFullWeightDuration: _fullWeightDuration\n        });\n        __GovernorSettings_init(0, _votingPeriod, 0);\n        _transferOwnership(_owner);\n\n        if (!Address.isContract(address(_nomineeElectionGovernor))) {\n            revert NotAContract(address(_nomineeElectionGovernor));\n        }\n        nomineeElectionGovernor = _nomineeElectionGovernor;\n        if (!Address.isContract(address(_securityCouncilManager))) {\n            revert NotAContract(address(_securityCouncilManager));\n        }\n        securityCouncilManager = _securityCouncilManager;\n    }\n\n    modifier onlyNomineeElectionGovernor() {\n        if (msg.sender != address(nomineeElectionGovernor)) {\n            revert OnlyNomineeElectionGovernor();\n        }\n        _;\n    }\n\n    /// @inheritdoc ISecurityCouncilMemberElectionGovernor\n    function proposeFromNomineeElectionGovernor(uint256 electionIndex)\n        external\n        onlyNomineeElectionGovernor\n        returns (uint256)\n    {\n        // we use the same getProposeArgs to ensure the proposal id is consistent across governors\n        (\n            address[] memory targets,\n            uint256[] memory values,\n            bytes[] memory callDatas,\n            string memory description\n        ) = getProposeArgs(electionIndex);\n        return GovernorUpgradeable.propose(targets, values, callDatas, description);\n    }\n\n    /// @notice Allows the owner to make calls from the governor\n    /// @dev    See {L2ArbitrumGovernor-relay}\n    function relay(address target, uint256 value, bytes calldata data)\n        external\n        virtual\n        override\n        onlyOwner\n    {\n        AddressUpgradeable.functionCallWithValue(target, data, value);\n    }\n\n    /// @dev    `GovernorUpgradeable` function to execute a proposal overridden to handle member elections.\n    ///         We know that topNominees() will return a full list.\n    ///         Calls `SecurityCouncilManager.replaceCohort` with the list of nominees.\n    function _execute(\n        uint256 proposalId,\n        address[] memory, /* targets */\n        uint256[] memory, /* values */\n        bytes[] memory callDatas,\n        bytes32 /* descriptionHash */\n    ) internal override {\n        // we know that the election index is part of the calldatas\n        uint256 electionIndex = extractElectionIndex(callDatas);\n\n        // it's possible for this call to fail because of checks in the security council manager\n        // getting into a state inconsistent with the elections, if it does the Security Council\n        // will need to update the Manager so that this replaceCohort can go through\n        // Otherwise this and future elections will remain blocked.\n        securityCouncilManager.replaceCohort({\n            _newCohort: topNominees(proposalId),\n            _cohort: electionIndexToCohort(electionIndex)\n        });\n    }\n\n    /// @notice Normally \"the number of votes required in order for a voter to become a proposer.\" But in our case it is 0.\n    /// @dev    Since we only want proposals to be created via `proposeFromNomineeElectionGovernor`, we set the proposal threshold to 0.\n    ///         `proposeFromNomineeElectionGovernor` determines the rules for creating a proposal.\n    function proposalThreshold()\n        public\n        pure\n        override(GovernorSettingsUpgradeable, GovernorUpgradeable)\n        returns (uint256)\n    {\n        return 0;\n    }\n\n    /// @notice Quorum is always 0.\n    function quorum(uint256) public pure override returns (uint256) {\n        return 0;\n    }\n\n    /// @dev Whether the account is a compliant nominee.\n    ///      checks the SecurityCouncilNomineeElectionGovernor to see if the account is a compliant nominee\n    function _isCompliantNominee(uint256 proposalId, address possibleNominee)\n        internal\n        view\n        override\n        returns (bool)\n    {\n        return nomineeElectionGovernor.isCompliantNominee(proposalId, possibleNominee);\n    }\n\n    /// @dev Returns all the compliant (non excluded) nominees for the requested proposal\n    function _compliantNominees(uint256 proposalId)\n        internal\n        view\n        override\n        returns (address[] memory)\n    {\n        return nomineeElectionGovernor.compliantNominees(proposalId);\n    }\n\n    /// @inheritdoc SecurityCouncilMemberElectionGovernorCountingUpgradeable\n    function _targetMemberCount() internal view override returns (uint256) {\n        return securityCouncilManager.cohortSize();\n    }\n\n    /// @notice Always reverts.\n    /// @dev    `GovernorUpgradeable` function to create a proposal overridden to just revert.\n    ///         We only want proposals to be created via `proposeFromNomineeElectionGovernor`.\n    function propose(address[] memory, uint256[] memory, bytes[] memory, string memory)\n        public\n        virtual\n        override\n        returns (uint256)\n    {\n        revert ProposeDisabled();\n    }\n\n    /// @notice Always reverts. Use castVoteWithReasonAndParams instead\n    function castVote(uint256, uint8) public virtual override returns (uint256) {\n        revert CastVoteDisabled();\n    }\n\n    /// @notice Always reverts. Use castVoteWithReasonAndParams instead\n    function castVoteWithReason(uint256, uint8, string calldata)\n        public\n        virtual\n        override\n        returns (uint256)\n    {\n        revert CastVoteDisabled();\n    }\n\n    /// @notice Always reverts. Use castVoteWithReasonAndParamsBySig instead\n    function castVoteBySig(uint256, uint8, uint8, bytes32, bytes32)\n        public\n        virtual\n        override\n        returns (uint256)\n    {\n        revert CastVoteDisabled();\n    }\n}"
    },
    {
      "filename": "src/security-council-mgmt/governors/modules/SecurityCouncilMemberElectionGovernorCountingUpgradeable.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/governance/GovernorUpgradeable.sol\";\n\nimport \"solady/utils/LibSort.sol\";\n\n/// @title  SecurityCouncilMemberElectionGovernorCountingUpgradeable\n/// @notice Counting module for the SecurityCouncilMemberElectionGovernor.\n///         Voters can spread their votes across multiple nominees.\n///         Implements linearly decreasing voting weights over time.\n///         The `_targetMemberCount()` nominees with the most votes are selected as the winners.\nabstract contract SecurityCouncilMemberElectionGovernorCountingUpgradeable is\n    Initializable,\n    GovernorUpgradeable\n{\n    struct ElectionInfo {\n        /// @dev The total votes used by a delegate.\n        mapping(address => uint256) votesUsed;\n        /// @dev The weight of votes received by a nominee. At the start of the election\n        ///      each vote has weight 1, however after a cutoff point the weight of each\n        ///      vote decreases linearly until it is 0 by the end of the election.\n        ///      Using uint240 because of the sorting implementation, see `selectTopNominees`\n        mapping(address => uint240) weightReceived;\n    }\n\n    /// @notice Duration of full weight voting (expressed in blocks)\n    uint256 public fullWeightDuration;\n\n    /// @dev proposalId => ElectionInfo\n    mapping(uint256 => ElectionInfo) private _elections;\n\n    /// @notice Emitted when a vote is cast for a nominee\n    /// @param voter The account that is casting the vote\n    /// @param proposalId The id of the proposal\n    /// @param nominee The nominee that is receiving the vote\n    /// @param votes The amount of votes that were just cast for the nominee\n    /// @param weight The weight of the vote that was just cast for the nominee\n    /// @param totalUsedVotes The total amount of votes the voter has used for this proposal\n    /// @param usableVotes The total amount of votes the voter has available for this proposal\n    /// @param weightReceived The total amount of voting weight the nominee has received for this proposal\n    event VoteCastForNominee(\n        address indexed voter,\n        uint256 indexed proposalId,\n        address indexed nominee,\n        uint256 votes,\n        uint256 weight,\n        uint256 totalUsedVotes,\n        uint256 usableVotes,\n        uint256 weightReceived\n    );\n    /// @notice Emitted when the a new full weight duration is set\n    event FullWeightDurationSet(uint256 newFullWeightDuration);\n\n    error FullWeightDurationGreaterThanVotingPeriod(\n        uint256 fullWeightDuration, uint256 votingPeriod\n    );\n    error UnexpectedParamsLength(uint256 paramLength);\n    error NotCompliantNominee(address nominee);\n    error ZeroWeightVote(uint256 blockNumber, uint256 votes);\n    error InsufficientVotes(uint256 prevVotesUsed, uint256 votes, uint256 availableVotes);\n    error LengthsDontMatch(uint256 nomineesLength, uint256 weightsLength);\n    error NotEnoughNominees(uint256 numNominees, uint256 k);\n    error UintTooLarge(uint256 x);\n    error InvalidSupport(uint8 support);\n\n    /// @param initialFullWeightDuration Duration of full weight voting (expressed in blocks)\n    function __SecurityCouncilMemberElectionGovernorCounting_init(uint256 initialFullWeightDuration)\n        internal\n        onlyInitializing\n    {\n        fullWeightDuration = initialFullWeightDuration;\n        emit FullWeightDurationSet(initialFullWeightDuration);\n    }\n\n    /// @notice Set the full weight duration\n    function setFullWeightDuration(uint256 newFullWeightDuration) public onlyGovernance {\n        if (newFullWeightDuration > votingPeriod()) {\n            revert FullWeightDurationGreaterThanVotingPeriod(newFullWeightDuration, votingPeriod());\n        }\n\n        fullWeightDuration = newFullWeightDuration;\n        emit FullWeightDurationSet(newFullWeightDuration);\n    }\n\n    /// @notice Register a vote by some account for a nominee.\n    /// @dev    Reverts if the account does not have enough votes.\n    ///         Reverts if the provided nominee is not a compliant nominee of the election.\n    ///         Weight of the vote is determined using the votesToWeight function.\n    /// @param  proposalId The id of the proposal\n    /// @param  account The account that is voting\n    /// @param  support The support of the vote (forced to 1)\n    /// @param  availableVotes The amount of votes that account had at the time of the proposal snapshot\n    /// @param  params Abi encoded (address nominee, uint256 votes)\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 availableVotes,\n        bytes memory params\n    ) internal virtual override {\n        if (support != 1) {\n            revert InvalidSupport(support);\n        }\n\n        if (params.length != 64) {\n            revert UnexpectedParamsLength(params.length);\n        }\n\n        (address nominee, uint256 votes) = abi.decode(params, (address, uint256));\n        if (!_isCompliantNominee(proposalId, nominee)) {\n            revert NotCompliantNominee(nominee);\n        }\n\n        uint240 weight = votesToWeight(proposalId, block.number, votes);\n        if (weight == 0) {\n            revert ZeroWeightVote(block.number, votes);\n        }\n\n        ElectionInfo storage election = _elections[proposalId];\n        uint256 prevVotesUsed = election.votesUsed[account];\n        if (prevVotesUsed + votes > availableVotes) {\n            revert InsufficientVotes(prevVotesUsed, votes, availableVotes);\n        }\n\n        uint240 prevWeightReceived = election.weightReceived[nominee];\n        election.votesUsed[account] = prevVotesUsed + votes;\n        election.weightReceived[nominee] = prevWeightReceived + weight;\n\n        emit VoteCastForNominee({\n            voter: account,\n            proposalId: proposalId,\n            nominee: nominee,\n            votes: votes,\n            weight: weight,\n            totalUsedVotes: prevVotesUsed + votes,\n            usableVotes: availableVotes,\n            weightReceived: election.weightReceived[nominee]\n        });\n    }\n\n    /// @inheritdoc IGovernorUpgradeable\n    function COUNTING_MODE() public pure virtual override returns (string memory) {\n        return \"support=for&params=account&counting=n-winners\";\n    }\n\n    /// @notice Number of votes used by an account for a given proposal\n    function votesUsed(uint256 proposalId, address account) public view returns (uint256) {\n        return _elections[proposalId].votesUsed[account];\n    }\n\n    /// @notice Weight received by a nominee for a given proposal\n    function weightReceived(uint256 proposalId, address nominee) public view returns (uint256) {\n        return _elections[proposalId].weightReceived[nominee];\n    }\n\n    /// @notice Whether the account has voted any amount for any nominee in the proposal\n    function hasVoted(uint256 proposalId, address account) public view override returns (bool) {\n        return votesUsed(proposalId, account) > 0;\n    }\n\n    /// @notice The deadline after which voting weight will linearly decrease\n    /// @param proposalId The proposal to check the deadline for\n    function fullWeightVotingDeadline(uint256 proposalId) public view returns (uint256) {\n        uint256 startBlock = proposalSnapshot(proposalId);\n        return startBlock + fullWeightDuration;\n    }\n\n    /// @notice Gets the top K nominees with greatest weight for a given proposal,\n    ///         where K is the manager.cohortSize()\n    /// @dev    Care must be taken of gas usage in this function.\n    ///         This is an O(n) operation on all compliant nominees in the nominees governor.\n    ///         The maximum number of nominees is set by the threshold of votes required to become a nominee.\n    ///         Currently this is 0.2% of votable tokens, which corresponds to 500 max nominees.\n    ///         Absolute worst case, this function uses 4502345 with 500 nominees, or about 9k gas per nominee (when called externally).\n    /// @param proposalId The proposal to find the top nominees for\n    function topNominees(uint256 proposalId) public view returns (address[] memory) {\n        address[] memory nominees = _compliantNominees(proposalId);\n        uint240[] memory weights = new uint240[](nominees.length);\n        ElectionInfo storage election = _elections[proposalId];\n        for (uint256 i = 0; i < nominees.length; i++) {\n            weights[i] = election.weightReceived[nominees[i]];\n        }\n        return selectTopNominees(nominees, weights, _targetMemberCount());\n    }\n\n    /// @notice Gets the top K nominees from a list of nominees and weights.\n    /// @param nominees The nominees to select from\n    /// @param weights  The weights of the nominees\n    /// @param k        The number of nominees to select\n    function selectTopNominees(address[] memory nominees, uint240[] memory weights, uint256 k)\n        public\n        pure\n        returns (address[] memory)\n    {\n        if (nominees.length != weights.length) {\n            revert LengthsDontMatch(nominees.length, weights.length);\n        }\n        if (nominees.length < k) {\n            revert NotEnoughNominees(nominees.length, k);\n        }\n\n        uint256[] memory topNomineesPacked = new uint256[](k);\n\n        for (uint16 i = 0; i < nominees.length; i++) {\n            uint256 packed = (uint256(weights[i]) << 16) | i;\n\n            if (topNomineesPacked[0] < packed) {\n                topNomineesPacked[0] = packed;\n                LibSort.insertionSort(topNomineesPacked);\n            }\n        }\n\n        address[] memory topNomineesAddresses = new address[](k);\n        for (uint16 i = 0; i < k; i++) {\n            topNomineesAddresses[i] = nominees[uint16(topNomineesPacked[i])];\n        }\n\n        return topNomineesAddresses;\n    }\n\n    /// @notice Returns the weight of a vote for a given proposal, block number, and number of votes.\n    ///         Each vote has weight 1 until the fullWeightVotingDeadline is reached, after which each vote has linearly\n    ///         deacreasing weight, reaching 0 at the proposalDeadline.\n    function votesToWeight(uint256 proposalId, uint256 blockNumber, uint256 votes)\n        public\n        view\n        returns (uint240)\n    {\n        // Before proposalSnapshot all votes have 0 weight\n        uint256 startBlock = proposalSnapshot(proposalId);\n        if (blockNumber <= startBlock) {\n            return 0;\n        }\n        // After proposalDeadline all votes have zero weight\n        uint256 endBlock = proposalDeadline(proposalId);\n        if (blockNumber > endBlock) {\n            return 0;\n        }\n\n        // Between proposalSnapshot and fullWeightVotingDeadline all votes will have 100% weight - each vote has weight 1\n        uint256 fullWeightVotingDeadline_ = fullWeightVotingDeadline(proposalId);\n        if (blockNumber <= fullWeightVotingDeadline_) {\n            return _downCast(votes);\n        }\n\n        // Between the fullWeightVotingDeadline and the proposalDeadline each vote will have weight linearly decreased by time since fullWeightVotingDeadline\n        // slope denominator\n        uint256 decreasingWeightDuration = endBlock - fullWeightVotingDeadline_;\n        // slope numerator is -votes, slope denominator is decreasingWeightDuration, delta x is blockNumber - fullWeightVotingDeadline_\n        // y intercept is votes\n        uint256 decreaseAmount =\n            votes * (blockNumber - fullWeightVotingDeadline_) / decreasingWeightDuration;\n        // subtract the decreased amount to get the remaining weight\n        return _downCast(votes - decreaseAmount);\n    }\n\n    /// @notice Downcasts a uint256 to a uint240, reverting if the input is too large\n    function _downCast(uint256 x) internal pure returns (uint240) {\n        if (x > type(uint240).max) {\n            revert UintTooLarge(x);\n        }\n        return uint240(x);\n    }\n\n    /// @notice True, since there is no minimum quorum\n    function _quorumReached(uint256) internal pure override returns (bool) {\n        return true;\n    }\n\n    /// @notice True, since an election can only be only started if there are enough nominees\n    ///         and candidates cannot be excluded after the election has started\n    function _voteSucceeded(uint256) internal pure override returns (bool) {\n        return true;\n    }\n\n    /// @dev Whether the possibleNominee is a compliant nominee for the given proposal\n    function _isCompliantNominee(uint256 proposalId, address possibleNominee)\n        internal\n        view\n        virtual\n        returns (bool);\n\n    /// @dev The list of all compliant (non excluded) nominees for the requested proposal\n    function _compliantNominees(uint256 proposalId)\n        internal\n        view\n        virtual\n        returns (address[] memory);\n\n    /// @dev The target number of members to elect\n    function _targetMemberCount() internal view virtual returns (uint256);\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[48] private __gap;\n}"
    },
    {
      "filename": "src/security-council-mgmt/governors/SecurityCouncilMemberElectionGovernor.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorSettingsUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./modules/SecurityCouncilMemberElectionGovernorCountingUpgradeable.sol\";\nimport \"../interfaces/ISecurityCouncilMemberElectionGovernor.sol\";\nimport \"../interfaces/ISecurityCouncilNomineeElectionGovernor.sol\";\nimport \"../interfaces/ISecurityCouncilManager.sol\";\nimport \"./modules/ElectionGovernor.sol\";\n\n/// @title  SecurityCouncilMemberElectionGovernor\n/// @notice Narrows a set of nominees down to a set of members.\n/// @dev    Proposals are created by the SecurityCouncilNomineeElectionGovernor.\n///         This governor is responsible for executing the final election result by calling the SecurityCouncilManager.\ncontract SecurityCouncilMemberElectionGovernor is\n    Initializable,\n    GovernorUpgradeable,\n    GovernorVotesUpgradeable,\n    SecurityCouncilMemberElectionGovernorCountingUpgradeable,\n    GovernorSettingsUpgradeable,\n    OwnableUpgradeable,\n    ElectionGovernor,\n    ISecurityCouncilMemberElectionGovernor\n{\n    /// @notice The SecurityCouncilNomineeElectionGovernor that creates proposals for this governor and contains the list of compliant nominees\n    ISecurityCouncilNomineeElectionGovernor public nomineeElectionGovernor;\n\n    /// @notice The SecurityCouncilManager that will execute the election result\n    ISecurityCouncilManager public securityCouncilManager;\n\n    error InvalidDurations(uint256 fullWeightDuration, uint256 votingPeriod);\n    error OnlyNomineeElectionGovernor();\n    error ProposeDisabled();\n    error CastVoteDisabled();\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @param _nomineeElectionGovernor The SecurityCouncilNomineeElectionGovernor\n    /// @param _securityCouncilManager The SecurityCouncilManager\n    /// @param _token The token used for voting\n    /// @param _owner The owner of the governor\n    /// @param _votingPeriod The duration of voting on a proposal\n    /// @param _fullWeightDuration Duration of full weight voting (blocks)\n    function initialize(\n        ISecurityCouncilNomineeElectionGovernor _nomineeElectionGovernor,\n        ISecurityCouncilManager _securityCouncilManager,\n        IVotesUpgradeable _token,\n        address _owner,\n        uint256 _votingPeriod,\n        uint256 _fullWeightDuration\n    ) public initializer {\n        if (_fullWeightDuration > _votingPeriod) {\n            revert InvalidDurations(_fullWeightDuration, _votingPeriod);\n        }\n\n        __Governor_init(\"SecurityCouncilMemberElectionGovernor\");\n        __GovernorVotes_init(_token);\n        __SecurityCouncilMemberElectionGovernorCounting_init({\n            initialFullWeightDuration: _fullWeightDuration\n        });\n        __GovernorSettings_init(0, _votingPeriod, 0);\n        _transferOwnership(_owner);\n\n        if (!Address.isContract(address(_nomineeElectionGovernor))) {\n            revert NotAContract(address(_nomineeElectionGovernor));\n        }\n        nomineeElectionGovernor = _nomineeElectionGovernor;\n        if (!Address.isContract(address(_securityCouncilManager))) {\n            revert NotAContract(address(_securityCouncilManager));\n        }\n        securityCouncilManager = _securityCouncilManager;\n    }\n\n    modifier onlyNomineeElectionGovernor() {\n        if (msg.sender != address(nomineeElectionGovernor)) {\n            revert OnlyNomineeElectionGovernor();\n        }\n        _;\n    }\n\n    /// @inheritdoc ISecurityCouncilMemberElectionGovernor\n    function proposeFromNomineeElectionGovernor(uint256 electionIndex)\n        external\n        onlyNomineeElectionGovernor\n        returns (uint256)\n    {\n        // we use the same getProposeArgs to ensure the proposal id is consistent across governors\n        (\n            address[] memory targets,\n            uint256[] memory values,\n            bytes[] memory callDatas,\n            string memory description\n        ) = getProposeArgs(electionIndex);\n        return GovernorUpgradeable.propose(targets, values, callDatas, description);\n    }\n\n    /// @notice Allows the owner to make calls from the governor\n    /// @dev    See {L2ArbitrumGovernor-relay}\n    function relay(address target, uint256 value, bytes calldata data)\n        external\n        virtual\n        override\n        onlyOwner\n    {\n        AddressUpgradeable.functionCallWithValue(target, data, value);\n    }\n\n    /// @dev    `GovernorUpgradeable` function to execute a proposal overridden to handle member elections.\n    ///         We know that topNominees() will return a full list.\n    ///         Calls `SecurityCouncilManager.replaceCohort` with the list of nominees.\n    function _execute(\n        uint256 proposalId,\n        address[] memory, /* targets */\n        uint256[] memory, /* values */\n        bytes[] memory callDatas,\n        bytes32 /* descriptionHash */\n    ) internal override {\n        // we know that the election index is part of the calldatas\n        uint256 electionIndex = extractElectionIndex(callDatas);\n\n        // it's possible for this call to fail because of checks in the security council manager\n        // getting into a state inconsistent with the elections, if it does the Security Council\n        // will need to update the Manager so that this replaceCohort can go through\n        // Otherwise this and future elections will remain blocked.\n        securityCouncilManager.replaceCohort({\n            _newCohort: topNominees(proposalId),\n            _cohort: electionIndexToCohort(electionIndex)\n        });\n    }\n\n    /// @notice Normally \"the number of votes required in order for a voter to become a proposer.\" But in our case it is 0.\n    /// @dev    Since we only want proposals to be created via `proposeFromNomineeElectionGovernor`, we set the proposal threshold to 0.\n    ///         `proposeFromNomineeElectionGovernor` determines the rules for creating a proposal.\n    function proposalThreshold()\n        public\n        pure\n        override(GovernorSettingsUpgradeable, GovernorUpgradeable)\n        returns (uint256)\n    {\n        return 0;\n    }\n\n    /// @notice Quorum is always 0.\n    function quorum(uint256) public pure override returns (uint256) {\n        return 0;\n    }\n\n    /// @dev Whether the account is a compliant nominee.\n    ///      checks the SecurityCouncilNomineeElectionGovernor to see if the account is a compliant nominee\n    function _isCompliantNominee(uint256 proposalId, address possibleNominee)\n        internal\n        view\n        override\n        returns (bool)\n    {\n        return nomineeElectionGovernor.isCompliantNominee(proposalId, possibleNominee);\n    }\n\n    /// @dev Returns all the compliant (non excluded) nominees for the requested proposal\n    function _compliantNominees(uint256 proposalId)\n        internal\n        view\n        override\n        returns (address[] memory)\n    {\n        return nomineeElectionGovernor.compliantNominees(proposalId);\n    }\n\n    /// @inheritdoc SecurityCouncilMemberElectionGovernorCountingUpgradeable\n    function _targetMemberCount() internal view override returns (uint256) {\n        return securityCouncilManager.cohortSize();\n    }\n\n    /// @notice Always reverts.\n    /// @dev    `GovernorUpgradeable` function to create a proposal overridden to just revert.\n    ///         We only want proposals to be created via `proposeFromNomineeElectionGovernor`.\n    function propose(address[] memory, uint256[] memory, bytes[] memory, string memory)\n        public\n        virtual\n        override\n        returns (uint256)\n    {\n        revert ProposeDisabled();\n    }\n\n    /// @notice Always reverts. Use castVoteWithReasonAndParams instead\n    function castVote(uint256, uint8) public virtual override returns (uint256) {\n        revert CastVoteDisabled();\n    }\n\n    /// @notice Always reverts. Use castVoteWithReasonAndParams instead\n    function castVoteWithReason(uint256, uint8, string calldata)\n        public\n        virtual\n        override\n        returns (uint256)\n    {\n        revert CastVoteDisabled();\n    }\n\n    /// @notice Always reverts. Use castVoteWithReasonAndParamsBySig instead\n    function castVoteBySig(uint256, uint8, uint8, bytes32, bytes32)\n        public\n        virtual\n        override\n        returns (uint256)\n    {\n        revert CastVoteDisabled();\n    }\n}"
    },
    {
      "filename": "src/security-council-mgmt/governors/modules/SecurityCouncilMemberElectionGovernorCountingUpgradeable.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/governance/GovernorUpgradeable.sol\";\n\nimport \"solady/utils/LibSort.sol\";\n\n/// @title  SecurityCouncilMemberElectionGovernorCountingUpgradeable\n/// @notice Counting module for the SecurityCouncilMemberElectionGovernor.\n///         Voters can spread their votes across multiple nominees.\n///         Implements linearly decreasing voting weights over time.\n///         The `_targetMemberCount()` nominees with the most votes are selected as the winners.\nabstract contract SecurityCouncilMemberElectionGovernorCountingUpgradeable is\n    Initializable,\n    GovernorUpgradeable\n{\n    struct ElectionInfo {\n        /// @dev The total votes used by a delegate.\n        mapping(address => uint256) votesUsed;\n        /// @dev The weight of votes received by a nominee. At the start of the election\n        ///      each vote has weight 1, however after a cutoff point the weight of each\n        ///      vote decreases linearly until it is 0 by the end of the election.\n        ///      Using uint240 because of the sorting implementation, see `selectTopNominees`\n        mapping(address => uint240) weightReceived;\n    }\n\n    /// @notice Duration of full weight voting (expressed in blocks)\n    uint256 public fullWeightDuration;\n\n    /// @dev proposalId => ElectionInfo\n    mapping(uint256 => ElectionInfo) private _elections;\n\n    /// @notice Emitted when a vote is cast for a nominee\n    /// @param voter The account that is casting the vote\n    /// @param proposalId The id of the proposal\n    /// @param nominee The nominee that is receiving the vote\n    /// @param votes The amount of votes that were just cast for the nominee\n    /// @param weight The weight of the vote that was just cast for the nominee\n    /// @param totalUsedVotes The total amount of votes the voter has used for this proposal\n    /// @param usableVotes The total amount of votes the voter has available for this proposal\n    /// @param weightReceived The total amount of voting weight the nominee has received for this proposal\n    event VoteCastForNominee(\n        address indexed voter,\n        uint256 indexed"
    }
  ]
}