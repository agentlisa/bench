{
  "Title": "Miscellaneous comments on `TokenSilo` NatSpec and legacy references",
  "Content": "Beanstalk previously implemented a withdrawal queue that was later replaced by a per-Season vesting period. The `TokenSilo` contract NatSpec currently still [references](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/silo/SiloFacet/TokenSilo.sol#L20-L21) this legacy withdrawal system but should be updated to reflect the current implementation pertaining to the removal of Stem-based deposits.\n\nAdditionally, references to \"Crates\" and [`crateBdv`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/silo/SiloFacet/TokenSilo.sol#L348) should be removed and updated to `bdvRemoved` respectively. The [NatSpec of `TokenSilo::tokenSettings`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/silo/SiloFacet/TokenSilo.sol#L430-L446) is missing references to [`milestoneStem`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/AppStorage.sol#L403-L406) and [`encodeType`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/AppStorage.sol#L408-L411) which are also present in the `SiloSettings` storage struct. Consider reordering this comment to accurately reflect the order of elements in the [declaration](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/AppStorage.sol#L373) within `AppStorage.sol`.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/beanstalk/silo/SiloFacet/TokenSilo.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport \"./Silo.sol\";\n\n/**\n * @title TokenSilo\n * @author Publius, Brean, Pizzaman1337\n * @notice This contract contains functions for depositing, withdrawing and \n * claiming whitelisted Silo tokens.\n *\n *\n * - LibTokenSilo offers `incrementTotalDeposited` and `decrementTotalDeposited`\n *   but these operations are performed directly for withdrawals.\n * - \"Removing a Deposit\" only removes from the `account`; the total amount\n *   deposited in the Silo is decremented during withdrawal, _after_ a Withdrawal\n *   is created. See \"Finish Removal\".\n */\ncontract TokenSilo is Silo {\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n    using LibSafeMath32 for uint32;\n\n\n    /**\n     * @notice Emitted when `account` adds a single Deposit to the Silo.\n     *\n     * There is no \"AddDeposits\" event because there is currently no operation in which Beanstalk\n     * creates multiple Deposits in different stems:\n     *\n     *  - `deposit()` always places the user's deposit in the current `_season()`.\n     *  - `convert()` collapses multiple deposits into a single Season to prevent loss of Stalk.\n     *\n     * @param account The account that added a Deposit.\n     * @param token Address of the whitelisted ERC20 token that was deposited.\n     * @param stem The stem index that this `amount` was added to.\n     * @param amount Amount of `token` added to `stem`.\n     * @param bdv The BDV associated with `amount` of `token` at the time of Deposit.\n     */\n    event AddDeposit(\n        address indexed account,\n        address indexed token,\n        int96 stem,\n        uint256 amount,\n        uint256 bdv\n    );\n\n    /**\n     * @notice Emitted when `account` removes a single Deposit from the Silo.\n     * \n     * Occurs during `withdraw()` and `convert()` operations.\n     * \n     * @param account The account that removed a Deposit.\n     * @param token Address of the whitelisted ERC20 token that was removed.\n     * @param stem The stem that this `amount` was removed from.\n     * @param amount Amount of `token` removed from `stem`.\n     */\n    event RemoveDeposit(\n        address indexed account,\n        address indexed token,\n        int96 stem,\n        uint256 amount,\n        uint256 bdv\n    );\n\n    /**\n     * @notice Emitted when `account` removes multiple Deposits from the Silo.\n     * Occurs during `withdraw()` and `convert()` operations. \n     * Gas optimization: emit 1 `RemoveDeposits` instead of N `RemoveDeposit` events.\n     * \n     * @param account The account that removed Deposits.\n     * @param token Address of the whitelisted ERC20 token that was removed.\n     * @param stems stems of Deposit to remove from.\n     * @param amounts Amounts of `token` to remove from corresponding `stems`.\n     * @param amount Sum of `amounts`.\n     */\n    event RemoveDeposits(\n        address indexed account,\n        address indexed token,\n        int96[] stems,\n        uint256[] amounts,\n        uint256 amount,\n        uint256[] bdvs\n    ); //add bdv[] here? in favor of array\n\n    // ERC1155 events\n    \n    /**\n     * @notice Emitted when a Deposit is created, removed, or transferred.\n     * \n     * @param operator the address that performed the operation.\n     * @param from the address the Deposit is being transferred from.\n     * @param to the address the Deposit is being transferred to.\n     * @param id the depositID of the Deposit.\n     * @param value the amount of the Deposit.\n     */\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 value\n    );\n\n    /**\n     * @notice Emitted when multiple deposits are withdrawn or transferred.\n     * \n     * @dev This event is emitted in `convert()`\n     * \n     * @param operator the address that performed the operation.\n     * @param from the address the Deposit is being transferred from.\n     * @param to the address the Deposit is being transferred to.\n     * @param ids the depositIDs of the Deposit.\n     * @param values the amounts of the Deposit.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n    \n    // LEGACY EVENTS\n\n    /**\n     * @notice these events are kept for backwards compatability, \n     * and therefore should not be changed. \n     * placed here in order for the ABI to generate properly. \n     * See {LibLegacyTokenSilo} for implmentation.\n     */\n    event RemoveWithdrawals(\n        address indexed account,\n        address indexed token,\n        uint32[] seasons,\n        uint256 amount\n    );\n    \n    event RemoveWithdrawal(\n        address indexed account,\n        address indexed token,\n        uint32 season,\n        uint256 amount\n    );\n\n    \n\n    //////////////////////// DEPOSIT ////////////////////////\n\n    /**\n     * @dev Handle deposit accounting.\n     *\n     * - {LibTokenSilo.deposit} calculates BDV, adds a Deposit to `account`, and\n     *   increments the total amount Deposited.\n     * - {LibSilo.mintStalk} mints the Stalk associated with\n     *   the Deposit.\n     * \n     * This step should enforce that new Deposits are placed into the current \n     * `LibTokenSilo.stemTipForToken(token)`.\n     */\n    function _deposit(\n        address account,\n        address token,\n        uint256 amount\n    ) internal returns (uint256 stalk, int96 stem) {\n        stalk = LibTokenSilo.deposit(\n            account,\n            token,\n            stem = LibTokenSilo.stemTipForToken(token),\n            amount\n        );\n        LibSilo.mintStalk(account, stalk);\n    }\n\n    //////////////////////// WITHDRAW ////////////////////////\n\n    /**\n     * @notice Handles withdraw accounting.\n     *\n     * - {LibSilo._removeDepositFromAccount} calculates the stalk\n     * assoicated with a given deposit, and removes the deposit from the account.\n     * emits `RemoveDeposit` and `TransferSingle` events. \n     * \n     * - {_withdraw} updates the total value deposited in the silo, and burns \n     * the stalk assoicated with the deposits.\n     * \n     */\n    function _withdrawDeposit(\n        address account,\n        address token,\n        int96 stem,\n        uint256 amount\n    ) internal {\n        // Remove the Deposit from `account`.\n        (uint256 stalkRemoved, uint256 bdvRemoved) = LibSilo._removeDepositFromAccount(\n            account,\n            token,\n            stem,\n            amount,\n            LibTokenSilo.Transfer.emitTransferSingle\n        );\n        \n        _withdraw(\n            account,\n            address(token),\n            amount,\n            bdvRemoved,\n            stalkRemoved\n        );\n    }\n\n    /**\n     * @notice Handles withdraw accounting for multiple deposits.\n     *\n     * - {LibSilo._removeDepositsFromAccount} removes the deposits from the account,\n     * and returns the total tokens, stalk, and bdv removed from the account.\n     * \n     * - {_withdraw} updates the total value deposited in the silo, and burns \n     * the stalk assoicated with the deposits.\n     * \n     */\n    function _withdrawDeposits(\n        address account,\n        address token,\n        int96[] calldata stems,\n        uint256[] calldata amounts\n    ) internal returns (uint256) {\n        require(\n            stems.length == amounts.length,\n            \"Silo: Crates, amounts are diff lengths.\"\n        );\n\n        LibSilo.AssetsRemoved memory ar = LibSilo._removeDepositsFromAccount(\n            account,\n            token,\n            stems,\n            amounts\n        );\n\n        _withdraw(\n            account,\n            token,\n            ar.tokensRemoved,\n            ar.bdvRemoved,\n            ar.stalkRemoved\n        );\n\n        // we return the total tokens removed from the deposits,\n        // to be used in {SiloFacet.withdrawDeposits}.\n        return ar.tokensRemoved;\n    }\n\n    /**\n     * @dev internal helper function for withdraw accounting.\n     */\n    function _withdraw(\n        address account,\n        address token,\n        uint256 amount,\n        uint256 bdv,\n        uint256 stalk\n    ) private {\n        LibTokenSilo.decrementTotalDeposited(token, amount, bdv); // Decrement total Deposited in the silo.\n        LibSilo.burnStalk(account, stalk); // Burn stalk and roots associated with the stalk.\n    }\n\n    //////////////////////// TRANSFER ////////////////////////\n\n    /**\n     * @notice Intenral transfer logic accounting. \n     * \n     * @dev Removes `amount` of a single Deposit from `sender` and transfers\n     * it to `recipient`. No Stalk are burned, and the total amount of\n     * Deposited `token` in the Silo doesn't change. \n     */\n    function _transferDeposit(\n        address sender,\n        address recipient,\n        address token,\n        int96 stem,\n        uint256 amount\n    ) internal returns (uint256) {\n        (uint256 stalk, uint256 bdv) = LibSilo._removeDepositFromAccount(\n            sender,\n            token,\n            stem,\n            amount,\n            LibTokenSilo.Transfer.noEmitTransferSingle\n        );\n        LibTokenSilo.addDepositToAccount(\n            recipient, \n            token, \n            stem, \n            amount, \n            bdv,\n            LibTokenSilo.Transfer.noEmitTransferSingle\n        );\n        LibSilo.transferStalk(sender, recipient, stalk);\n\n        /** \n         * the current beanstalk system uses {AddDeposit}\n         * and {RemoveDeposit} events to represent a transfer.\n         * However, the ERC1155 standard has a dedicated {TransferSingle} event,\n         * which is used here.\n         */\n        emit TransferSingle(\n            msg.sender, \n            sender, \n            recipient, \n            LibBytes.packAddressAndStem(token, stem),\n            amount\n        );\n\n        return bdv;\n    }\n\n    /**\n     * @notice Intenral transfer logic accounting for multiple deposits.\n     * \n     * @dev Removes `amounts` of multiple Deposits from `sender` and transfers\n     * them to `recipient`. No Stalk are burned, and the total amount of\n     * Deposited `token` in the Silo doesn't change. \n     */\n    function _transferDeposits(\n        address sender,\n        address recipient,\n        address token,\n        int96[] calldata stems,\n        uint256[] calldata amounts\n    ) internal returns (uint256[] memory) {\n        require(\n            stems.length == amounts.length,\n            \"Silo: Crates, amounts are diff lengths.\"\n        );\n\n        LibSilo.AssetsRemoved memory ar;\n        uint256[] memory bdvs = new uint256[](stems.length);\n        uint256[] memory removedDepositIDs = new uint256[](stems.length);\n\n        // Similar to {removeDepositsFromAccount}, however the Deposit is also \n        // added to the recipient's account during each iteration.\n        for (uint256 i; i < stems.length; ++i) {\n            uint256 depositID = uint256(LibBytes.packAddressAndStem(token, stems[i]));\n            uint256 crateBdv = LibTokenSilo.removeDepositFromAccount(\n                sender,\n                token,\n                stems[i],\n                amounts[i]\n            );\n            LibTokenSilo.addDepositToAccount(\n                recipient,\n                token,\n                stems[i],\n                amounts[i],\n                crateBdv,\n                LibTokenSilo.Transfer.noEmitTransferSingle\n            );\n            ar.bdvRemoved = ar.bdvRemoved.add(crateBdv);\n            ar.tokensRemoved = ar.tokensRemoved.add(amounts[i]);\n            ar.stalkRemoved = ar.stalkRemoved.add(\n                LibSilo.stalkReward(\n                    stems[i],\n                    LibTokenSilo.stemTipForToken(token),\n                    crateBdv.toUint128()\n                )\n            );\n            bdvs[i] = crateBdv;\n            removedDepositIDs[i] = depositID;\n\n        }\n\n        ar.stalkRemoved = ar.stalkRemoved.add(\n            ar.bdvRemoved.mul(s.ss[token].stalkIssuedPerBdv)\n        );\n\n        /** \n         *  The current beanstalk system uses a mix of {AddDeposit}\n         *  and {RemoveDeposits} events to represent a batch transfer.\n         *  However, the ERC1155 standard has a dedicated {batchTransfer} event,\n         *  which is used here.\n         */\n        emit LibSilo.TransferBatch(msg.sender, sender, recipient, removedDepositIDs, amounts);\n        emit RemoveDeposits(sender, token, stems, amounts, ar.tokensRemoved, bdvs);\n\n        LibSilo.transferStalk(\n            sender,\n            recipient,\n            ar.stalkRemoved\n        );\n\n        return bdvs;\n    }\n\n    //////////////////////// GETTERS ////////////////////////\n\n    /**\n     * @notice Find the amount and BDV of `token` that `account` has Deposited in stem index `stem`.\n     * \n     * Returns a deposit tuple `(uint256 amount, uint256 bdv)`.\n     *\n     * @return amount The number of tokens contained in this Deposit.\n     * @return bdv The BDV associated with this Deposit.\n     */\n    function getDeposit(\n        address account,\n        address token,\n        int96 stem\n    ) external view returns (uint256, uint256) {\n        return LibTokenSilo.getDeposit(account, token, stem);\n    }\n\n    /**\n     * @notice Get the total amount of `token` currently Deposited in the Silo across all users.\n     */\n    function getTotalDeposited(address token) external view returns (uint256) {\n        return s.siloBalances[token].deposited;\n    }\n\n    /**\n     * @notice Get the total bdv of `token` currently Deposited in the Silo across all users.\n     */\n    function getTotalDepositedBdv(address token) external view returns (uint256) {\n        return s.siloBalances[token].depositedBdv;\n    }\n\n    /**\n     * @notice Get the Storage.SiloSettings for a whitelisted Silo token.\n     *\n     * Contains:\n     *  - the BDV function selector\n     *  - Stalk per BDV\n     *  - stalkEarnedPerSeason\n     *  - milestoneSeason\n     *  - lastStem\n     */\n    function tokenSettings(address token)\n        external\n        view\n        returns (Storage.SiloSettings memory)\n    {\n        return s.ss[token];\n    }\n\n    //////////////////////// ERC1155 ////////////////////////\n\n    /**\n     * @notice returns the amount of tokens in a Deposit.\n     * \n     * @dev see {getDeposit} for both the bdv and amount.\n     */\n    function balanceOf(\n        address account, \n        uint256 depositId\n    ) external view returns (uint256 amount) {\n        return s.a[account].deposits[depositId].amount;\n    }\n\n    /**\n     * @notice returns an array of amounts corresponding to Deposits.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts, \n        uint256[] calldata depositIds\n    ) external view returns (uint256[] memory) {\n        require(\n            accounts.length == depositIds.length, \n            \"ERC1155: ids and amounts length mismatch\"\n        );\n        uint256[] memory balances = new uint256[](accounts.length);\n        for (uint256 i = 0; i < accounts.length; i++) {\n            balances[i] = s.a[accounts[i]].deposits[depositIds[i]].amount;\n        }\n        return balances;\n    }\n\n    /**\n     * @notice outputs the depositID given an token address and stem.\n     */\n    function getDepositId(\n        address token, \n        int96 stem\n    ) external pure returns (uint256) {\n        return LibBytes.packAddressAndStem(token, stem);\n    }\n}"
    },
    {
      "filename": "protocol/contracts/beanstalk/silo/SiloFacet/TokenSilo.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport \"./Silo.sol\";\n\n/**\n * @title TokenSilo\n * @author Publius, Brean, Pizzaman1337\n * @notice This contract contains functions for depositing, withdrawing and \n * claiming whitelisted Silo tokens.\n *\n *\n * - LibTokenSilo offers `incrementTotalDeposited` and `decrementTotalDeposited`\n *   but these operations are performed directly for withdrawals.\n * - \"Removing a Deposit\" only removes from the `account`; the total amount\n *   deposited in the Silo is decremented during withdrawal, _after_ a Withdrawal\n *   is created. See \"Finish Removal\".\n */\ncontract TokenSilo is Silo {\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n    using LibSafeMath32 for uint32;\n\n\n    /**\n     * @notice Emitted when `account` adds a single Deposit to the Silo.\n     *\n     * There is no \"AddDeposits\" event because there is currently no operation in which Beanstalk\n     * creates multiple Deposits in different stems:\n     *\n     *  - `deposit()` always places the user's deposit in the current `_season()`.\n     *  - `convert()` collapses multiple deposits into a single Season to prevent loss of Stalk.\n     *\n     * @param account The account that added a Deposit.\n     * @param token Address of the whitelisted ERC20 token that was deposited.\n     * @param stem The stem index that this `amount` was added to.\n     * @param amount Amount of `token` added to `stem`.\n     * @param bdv The BDV associated with `amount` of `token` at the time of Deposit.\n     */\n    event AddDeposit(\n        address indexed account,\n        address indexed token,\n        int96 stem,\n        uint256 amount,\n        uint256 bdv\n    );\n\n    /**\n     * @notice Emitted when `account` removes a single Deposit from the Silo.\n     * \n     * Occurs during `withdraw()` and `convert()` operations.\n     * \n     * @param account The account that removed a Deposit.\n     * @param token Address of the whitelisted ERC20 token that was removed.\n     * @param stem The stem that this `amount` was removed from.\n     * @param amount Amount of `token` removed from `stem`.\n     */\n    event RemoveDeposit(\n        address indexed account,\n        address indexed token,\n        int96 stem,\n        uint256 amount,\n        uint256 bdv\n    );\n\n    /**\n     * @notice Emitted when `account` removes multiple Deposits from the Silo.\n     * Occurs during `withdraw()` and `convert()` operations. \n     * Gas optimization: emit 1 `RemoveDeposits` instead of N `RemoveDeposit` events.\n     * \n     * @param account The account that removed Deposits.\n     * @param token Address of the whitelisted ERC20 token that was removed.\n     * @param stems stems of Deposit to remove from.\n     * @param amounts Amounts of `token` to remove from corresponding `stems`.\n     * @param amount Sum of `amounts`.\n     */\n    event RemoveDeposits(\n        address indexed account,\n        address indexed token,\n        int96[] stems,\n        uint256[] amounts,\n        uint256 amount,\n        uint256[] bdvs\n    ); //add bdv[] here? in favor of array\n\n    // ERC1155 events\n    \n    /**\n     * @notice Emitted when a Deposit is created, removed, or transferred.\n     * \n     * @param operator the address that performed the operation.\n     * @param from the address the Deposit is being transferred from.\n     * @param to the address the Deposit is being transferred to.\n     * @param id the depositID of the Deposit.\n     * @param value the amount of the Deposit.\n     */\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 value\n    );\n\n    /**\n     * @notice Emitted when multiple deposits are withdrawn or transferred.\n     * \n     * @dev This event is emitted in `convert()`\n     * \n     * @param operator the address that performed the operation.\n     * @param from the address the Deposit is being transferred from.\n     * @param to the address the Deposit is being transferred to.\n     * @param ids the depositIDs of the Deposit.\n     * @param values the amounts of the Deposit.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n    \n    // LEGACY EVENTS\n\n    /**\n     * @notice these events are kept for backwards compatability, \n     * and therefore should not be changed. \n     * placed here in order for the ABI to generate properly. \n     * See {LibLegacyTokenSilo} for implmentation.\n     */\n    event RemoveWithdrawals(\n        address indexed account,\n        address indexed token,\n        uint32[] seasons,\n        uint256 amount\n    );\n    \n    event RemoveWithdrawal(\n        address indexed account,\n        address indexed token,\n        uint32 season,\n        uint256 amount\n    );\n\n    \n\n    //////////////////////// DEPOSIT ////////////////////////\n\n    /**\n     * @dev Handle deposit accounting.\n     *\n     * - {LibTokenSilo.deposit} calculates BDV, adds a Deposit to `account`, and\n     *   increments the total amount Deposited.\n     * - {LibSilo.mintStalk} mints the Stalk associated with\n     *   the Deposit.\n     * \n     * This step should enforce that new Deposits are placed into the current \n     * `LibTokenSilo.stemTipForToken(token)`.\n     */\n    function _deposit(\n        address account,\n        address token,\n        uint256 amount\n    ) internal returns (uint256 stalk, int96 stem) {\n        stalk = LibTokenSilo.deposit(\n            account,\n            token,\n            stem = LibTokenSilo.stemTipForToken(token),\n            amount\n        );\n        LibSilo.mintStalk(account, stalk);\n    }\n\n    //////////////////////// WITHDRAW ////////////////////////\n\n    /**\n     * @notice Handles withdraw accounting.\n     *\n     * - {LibSilo._removeDepositFromAccount} calculates the stalk\n     * assoicated with a given deposit, and removes the deposit from the account.\n     * emits `RemoveDeposit` and `TransferSingle` events. \n     * \n     * - {_withdraw} updates the total value deposited in the silo, and burns \n     * the stalk assoicated with the deposits.\n     * \n     */\n    function _withdrawDeposit(\n        address account,\n        address token,\n        int96 stem,\n        uint256 amount\n    ) internal {\n        // Remove the Deposit from `account`.\n        (uint256 stalkRemoved, uint256 bdvRemoved) = LibSilo._removeDepositFromAccount(\n            account,\n            token,\n            stem,\n            amount,\n            LibTokenSilo.Transfer.emitTransferSingle\n        );\n        \n        _withdraw(\n            account,\n            address(token),\n            amount,\n            bdvRemoved,\n            stalkRemoved\n        );\n    }\n\n    /**\n     * @notice Handles withdraw accounting for multiple deposits.\n     *\n     * - {LibSilo._removeDepositsFromAccount} removes the deposits from the account,\n     * and returns the total tokens, stalk, and bdv removed from the account.\n     * \n     * - {_withdraw} updates the total value deposited in the silo, and burns \n     * the stalk assoicated with the deposits.\n     * \n     */\n    function _withdrawDeposits(\n        address account,\n        address token,\n        int96[] calldata stems,\n        uint256[] calldata amounts\n    ) internal returns (uint256) {\n        require(\n            stems.length == amounts.length,\n            \"Silo: Crates, amounts are diff lengths.\"\n        );\n\n        LibSilo.AssetsRemoved memory ar = LibSilo._removeDepositsFromAccount(\n            account,\n            token,\n            stems,\n            amounts\n        );\n\n        _withdraw(\n            account,\n            token,\n            ar.tokensRemoved,\n            ar.bdvRemoved,\n            ar.stalkRemoved\n        );\n\n        // we return the total tokens removed from the deposits,\n        // to be used in {SiloFacet.withdrawDeposits}.\n        return ar.tokensRemoved;\n    }\n\n    /**\n     * @dev internal helper function for withdraw accounting.\n     */\n    function _withdraw(\n        address account,\n        address token,\n        uint256 amount,\n        uint256 bdv,\n        uint256 stalk\n    ) private {\n        LibTokenSilo.decrementTotalDeposited(token, amount, bdv); // Decrement total Deposited in the silo.\n        LibSilo.burnStalk(account, stalk); // Burn stalk and roots associated with the stalk.\n    }\n\n    //////////////////////// TRANSFER ////////////////////////\n\n    /**\n     * @notice Intenral transfer logic accounting. \n     * \n     * @dev Removes `amount` of a single Deposit from `sender` and transfers\n     * it to `recipient`. No Stalk are burned, and the total amount of\n     * Deposited `token` in the Silo doesn't change. \n     */\n    function _transferDeposit(\n        address sender,\n        address recipient,\n        address token,\n        int96 stem,\n        uint256 amount\n    ) internal returns (uint256) {\n        (uint256 stalk, uint256 bdv) = LibSilo._removeDepositFromAccount(\n            sender,\n            token,\n            stem,\n            amount,\n            LibTokenSilo.Transfer.noEmitTransferSingle\n        );\n        LibTokenSilo.addDepositToAccount(\n            recipient, \n            token, \n            stem, \n            amount, \n            bdv,\n            LibTokenSilo.Transfer.noEmitTransferSingle\n        );\n        LibSilo.transferStalk(sender, recipient, stalk);\n\n        /** \n         * the current beanstalk system uses {AddDeposit}\n         * and {RemoveDeposit} events to represent a transfer.\n         * However, the ERC1155 standard has a dedicated {TransferSingle} event,\n         * which is used here.\n         */\n        emit TransferSingle(\n            msg.sender, \n            sender, \n            recipient, \n            LibBytes.packAddressAndStem(token, stem),\n            amount\n        );\n\n        return bdv;\n    }\n\n    /**\n     * @notice Intenral transfer logic accounting for multiple deposits.\n     * \n     * @dev Removes `amounts` of multiple Deposits from `sender` and transfers\n     * them to `recipient`. No Stalk are burned, and the total amount of\n     * Deposited `token` in the Silo doesn't change. \n     */\n    function _transferDeposits(\n        address sender,\n        address recipient,\n        address token,\n        int96[] calldata stems,\n        uint256[] calldata amounts\n    ) internal returns (uint256[] memory) {\n        require(\n            stems.length == amounts.length,\n            \"Silo: Crates, amounts are diff lengths.\"\n        );\n\n        LibSilo.AssetsRemoved memory ar;\n        uint256[] memory bdvs = new uint256[](stems.length);\n        uint256[] memory removedDepositIDs = new uint256[](stems.length);\n\n        // Similar to {removeDepositsFromAccount}, however the Deposit is also \n        // added to the recipient's account during each iteration.\n        for (uint256 i; i < stems.length; ++i) {\n            uint256 depositID = uint256(LibBytes.packAddressAndStem(token, stems[i]));\n            uint256 crateBdv = LibTokenSilo.removeDepositFromAccount(\n                sender,\n                token,\n                stems[i],\n                amounts[i]\n            );\n            LibTokenSilo.addDepositToAccount(\n                recipient,\n                token,\n                stems[i],\n                amounts[i],\n                crateBdv,\n                LibTokenSilo.Transfer.noEmitTransferSingle\n            );\n            ar.bdvRemoved = ar.bdvRemoved.add(crateBdv);\n            ar.tokensRemoved = ar.tokensRemoved.add(amounts[i]);\n            ar.stalkRemoved = ar.stalkRemoved.add(\n                LibSilo.stalkReward(\n                    stems[i],\n                    LibTokenSilo.stemTipForToken(token),\n                    crateBdv.toUint128()\n                )\n            );\n            bdvs[i] = crateBdv;\n            removedDepositIDs[i] = depositID;\n\n        }\n\n        ar.stalkRemoved = ar.stalkRemoved.add(\n            ar.bdvRemoved.mul(s.ss[token].stalkIssuedPerBdv)\n        );\n\n        /** \n         *  The current beanstalk system uses a mix of {AddDeposit}\n         *  and {RemoveDeposits} events to represent a batch transfer.\n         *  However, the ERC1155 standard has a dedicated {batchTransfer} event,\n         *  which is used here.\n         */\n        emit LibSilo.TransferBatch(msg.sender, sender, recipient, removedDepositIDs, amounts);\n        emit RemoveDeposits(sender, token, stems, amounts, ar.tokensRemoved, bdvs);\n\n        LibSilo.transferStalk(\n            sender,\n            recipient,\n            ar.stalkRemoved\n        );\n\n        return bdvs;\n    }\n\n    //////////////////////// GETTERS ////////////////////////\n\n    /**\n     * @notice Find the amount and BDV of `token` that `account` has Deposited in stem index `stem`.\n     * \n     * Returns a deposit tuple `(uint256 amount, uint256 bdv)`.\n     *\n     * @return amount The number of tokens contained in this Deposit.\n     * @return bdv The BDV associated with this Deposit.\n     */\n    function getDeposit(\n        address account,\n        address token,\n        int96 stem\n    ) external view returns (uint256, uint256) {\n        return LibTokenSilo.getDeposit(account, token, stem);\n    }\n\n    /**\n     * @notice Get the total amount of `token` currently Deposited in the Silo across all users.\n     */\n    function getTotalDeposited(address token) external view returns (uint256) {\n        return s.siloBalances[token].deposited;\n    }\n\n    /**\n     * @notice Get the total bdv of `token` currently Deposited in the Silo across all users.\n     */\n    function getTotalDepositedBdv(address token) external view returns (uint256) {\n        return s.siloBalances[token].depositedBdv;\n    }\n\n    /**\n     * @notice Get the Storage.SiloSettings for a whitelisted Silo token.\n     *\n     * Contains:\n     *  - the BDV function selector\n     *  - Stalk per BDV\n     *  - stalkEarnedPerSeason\n     *  - milestoneSeason\n     *  - lastStem\n     */\n    function tokenSettings(address token)\n        external\n        view\n        returns (Storage.SiloSettings memory)\n    {\n        return s.ss[token];\n    }\n\n    //////////////////////// ERC1155 ////////////////////////\n\n    /**\n     * @notice returns the amount of tokens in a Deposit.\n     * \n     * @dev see {getDeposit} for both the bdv and amount.\n     */\n    function balanceOf(\n        address account, \n        uint256 depositId\n    ) external view returns (uint256 amount) {\n        return s.a[account].deposits[depositId].amount;\n    }\n\n    /**\n     * @notice returns an array of amounts corresponding to Deposits.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts, \n        uint256[] calldata depositIds\n    ) external view returns (uint256[] memory) {\n        require(\n            accounts.length == depositIds.length, \n            \"ERC1155: ids and amounts length mismatch\"\n        );\n        uint256[] memory balances = new uint256[](accounts.length);\n        for (uint256 i = 0; i < accounts.length; i++) {\n            balances[i] = s.a[accounts[i]].deposits[depositIds[i]].amount;\n        }\n        return balances;\n    }\n\n    /**\n     * @notice outputs the depositID given an token address and stem.\n     */\n    function getDepositId(\n        address token, \n        int96 stem\n    ) external pure returns (uint256) {\n        return LibBytes.packAddressAndStem(token, stem);\n    }\n}"
    }
  ]
}