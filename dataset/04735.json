{
  "Title": "[L-04] The `asdUSDC` contract insufficiently supports `USDC` tokens with more than 18 decimals, resulting in a DoS scenario",
  "Content": "\nInstances: [`deposit`(...)](https://github.com/code-423n4/2024-03-canto/blob/1516028017a34ccfb4b0b19f5c5f17f5fa4cad42/contracts/asd/asdUSDC.sol#L40), [`withdraw`(...)](https://github.com/code-423n4/2024-03-canto/blob/1516028017a34ccfb4b0b19f5c5f17f5fa4cad42/contracts/asd/asdUSDC.sol#L58), [`recover`(...)](https://github.com/code-423n4/2024-03-canto/blob/1516028017a34ccfb4b0b19f5c5f17f5fa4cad42/contracts/asd/asdUSDC.sol#L78).\n\n```solidity\n...\nuint256 amountTo... = _amount * (10 ** (this.decimals() - ERC20(_usdcVersion).decimals()));\n...\n```\n\nThe `asdUDSC` token has 18 decimals. In case of a `USDC` token having more than 18 decimals (see [ERC20 token behaviors in scope](https://github.com/code-423n4/2024-03-canto?tab=readme-ov-file#erc20-token-behaviors-in-scope)), the code above will revert due to an \"arithmetic underflow\" error (of `uint8`), which effectively causes DoS of the `asdUSDC` contract for such tokens.\n\n### Recommendation \n\nAlso covers the case when `ERC20(_usdcVersion).decimals() > 18`:\n\n```solidity\n...\nif (this.decimals() >= ERC20(_usdcVersion).decimals()) {\n    amountTo... = _amount * (10 ** (this.decimals() - ERC20(_usdcVersion).decimals()));\n}\nelse {\n    amountTo... = _amount / (10 ** (ERC20(_usdcVersion).decimals() - this.decimals()));\n}\n...\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-canto",
  "Code": [
    {
      "filename": "contracts/asd/asdUSDC.sol",
      "content": "pragma solidity ^0.8.22;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title ASDUSDC\n * @notice This contract wraps multiple versions of USDC into one token\n */\ncontract ASDUSDC is ERC20, Ownable {\n    mapping(address => bool) public whitelistedUSDCVersions;\n    mapping(address => uint256) public usdcBalances;\n\n    event Deposit(address _version, uint _amount);\n    event Withdrawal(address _version, uint _amount);\n\n    constructor() ERC20(\"ASD USDC\", \"asdUSDC\") {}\n\n    /**\n     * @notice Add a USDC version to the whitelist\n     * @param _usdcVersion Address of the USDC version to add\n     */\n    function updateWhitelist(address _usdcVersion, bool _isWhitelisted) external onlyOwner {\n        whitelistedUSDCVersions[_usdcVersion] = _isWhitelisted;\n    }\n\n    /**\n     * @notice Deposit USDC and mint asdUSDC tokens\n     * @param _usdcVersion Address of the USDC version to deposit\n     * @param _amount Amount of USDC to deposit\n     * @return Amount of asdUSDC tokens minted\n     */\n    function deposit(address _usdcVersion, uint256 _amount) external returns (uint256) {\n        // check whitelist\n        require(whitelistedUSDCVersions[_usdcVersion], \"ASDUSDC: USDC version not whitelisted\");\n        SafeERC20.safeTransferFrom(ERC20(_usdcVersion), msg.sender, address(this), _amount);\n        usdcBalances[_usdcVersion] += _amount;\n        // Mint the same amount of asdUSDC tokens but take decimals into account\n        uint256 amountToMint = _amount * (10 ** (this.decimals() - ERC20(_usdcVersion).decimals()));\n        _mint(msg.sender, amountToMint);\n        emit Deposit(_usdcVersion, _amount);\n        return amountToMint;\n    }\n\n    /**\n     * @notice Withdraw USDC and burn asdUSDC tokens\n     * @param _usdcVersion Address of the USDC version to withdraw\n     * @param _amount Amount of asdUSDC tokens to burn\n     * @return Amount of USDC withdrawn\n     */\n    function withdraw(address _usdcVersion, uint256 _amount) external returns (uint256) {\n        // check whitelist\n        require(whitelistedUSDCVersions[_usdcVersion], \"ASDUSDC: USDC version not whitelisted\");\n        // burn tokens\n        _burn(msg.sender, _amount);\n        // calculate amount to withdraw\n        uint256 amountToWithdraw = _amount / (10 ** (this.decimals() - ERC20(_usdcVersion).decimals()));\n        // check balance\n        require(usdcBalances[_usdcVersion] >= amountToWithdraw, \"ASDUSDC: Not enough USDC balance\");\n        // transfer USDC\n        usdcBalances[_usdcVersion] -= amountToWithdraw;\n        SafeERC20.safeTransfer(ERC20(_usdcVersion), msg.sender, amountToWithdraw);\n        emit Withdrawal(_usdcVersion, amountToWithdraw);\n        return amountToWithdraw;\n    }\n\n    /**\n     * @notice Recover any USDC that was sent to the contract by mistake\n     * @param _usdcVersion Address of the USDC version to recover\n     * @return Amount of USDC minted\n     */\n    function recover(address _usdcVersion) external onlyOwner returns (uint256) {\n        // recover amount\n        uint amountToRecover = ERC20(_usdcVersion).balanceOf(address(this)) - usdcBalances[_usdcVersion];\n        usdcBalances[_usdcVersion] += amountToRecover;\n        // mint tokens\n        uint256 amountToMint = amountToRecover * (10 ** (this.decimals() - ERC20(_usdcVersion).decimals()));\n        _mint(msg.sender, amountToMint);\n        return amountToMint;\n    }\n}"
    }
  ]
}