{
  "Title": "[L-03] Dropping a dust to grief the staking process",
  "Content": "After an amount of lst being transferred to a specified `NodeDelegator`, the stake on EigenLayer is expected to happen. However, if there is a possibility to grief `depositAssetIntoStrategy`, adversary might drop some dust and front-run the tx submitted by `LRTManager`. This forces to transfer some assets back to the pool in order to successfully stake at EigenLayer.\n  \n### Example of an occurrence\n\nIt's better to provide an opportunity for `LRTManager` to decide, how much lst amount is about to be transferred and not blindly rely on the total balance [here](https://github.com/code-423n4/2023-11-kelp/blob/main/src/NodeDelegator.sol#L63).\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-11-kelp",
  "Code": [
    {
      "filename": "src/NodeDelegator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.21;\n\nimport { UtilLib } from \"./utils/UtilLib.sol\";\nimport { LRTConstants } from \"./utils/LRTConstants.sol\";\nimport { LRTConfigRoleChecker, ILRTConfig } from \"./utils/LRTConfigRoleChecker.sol\";\n\nimport { INodeDelegator } from \"./interfaces/INodeDelegator.sol\";\nimport { IStrategy } from \"./interfaces/IStrategy.sol\";\nimport { IEigenStrategyManager } from \"./interfaces/IEigenStrategyManager.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\n/// @title NodeDelegator Contract\n/// @notice The contract that handles the depositing of assets into strategies\ncontract NodeDelegator is INodeDelegator, LRTConfigRoleChecker, PausableUpgradeable, ReentrancyGuardUpgradeable {\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @dev Initializes the contract\n    /// @param lrtConfigAddr LRT config address\n    function initialize(address lrtConfigAddr) external initializer {\n        UtilLib.checkNonZeroAddress(lrtConfigAddr);\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        lrtConfig = ILRTConfig(lrtConfigAddr);\n        emit UpdatedLRTConfig(lrtConfigAddr);\n    }\n\n    /// @notice Approves the maximum amount of an asset to the eigen strategy manager\n    /// @dev only supported assets can be deposited and only called by the LRT manager\n    /// @param asset the asset to deposit\n    function maxApproveToEigenStrategyManager(address asset)\n        external\n        override\n        onlySupportedAsset(asset)\n        onlyLRTManager\n    {\n        address eigenlayerStrategyManagerAddress = lrtConfig.getContract(LRTConstants.EIGEN_STRATEGY_MANAGER);\n        IERC20(asset).approve(eigenlayerStrategyManagerAddress, type(uint256).max);\n    }\n\n    /// @notice Deposits an asset lying in this NDC into its strategy\n    /// @dev only supported assets can be deposited and only called by the LRT manager\n    /// @param asset the asset to deposit\n    function depositAssetIntoStrategy(address asset)\n        external\n        override\n        whenNotPaused\n        nonReentrant\n        onlySupportedAsset(asset)\n        onlyLRTManager\n    {\n        address strategy = lrtConfig.assetStrategy(asset);\n        IERC20 token = IERC20(asset);\n        address eigenlayerStrategyManagerAddress = lrtConfig.getContract(LRTConstants.EIGEN_STRATEGY_MANAGER);\n\n        uint256 balance = token.balanceOf(address(this));\n\n        emit AssetDepositIntoStrategy(asset, strategy, balance);\n\n        IEigenStrategyManager(eigenlayerStrategyManagerAddress).depositIntoStrategy(IStrategy(strategy), token, balance);\n    }\n\n    /// @notice Transfers an asset back to the LRT deposit pool\n    /// @dev only supported assets can be transferred and only called by the LRT manager\n    /// @param asset the asset to transfer\n    /// @param amount the amount to transfer\n    function transferBackToLRTDepositPool(\n        address asset,\n        uint256 amount\n    )\n        external\n        whenNotPaused\n        nonReentrant\n        onlySupportedAsset(asset)\n        onlyLRTManager\n    {\n        address lrtDepositPool = lrtConfig.getContract(LRTConstants.LRT_DEPOSIT_POOL);\n\n        if (!IERC20(asset).transfer(lrtDepositPool, amount)) {\n            revert TokenTransferFailed();\n        }\n    }\n\n    /// @notice Fetches balance of all assets staked in eigen layer through this contract\n    /// @return assets the assets that the node delegator has deposited into strategies\n    /// @return assetBalances the balances of the assets that the node delegator has deposited into strategies\n    function getAssetBalances()\n        external\n        view\n        override\n        returns (address[] memory assets, uint256[] memory assetBalances)\n    {\n        address eigenlayerStrategyManagerAddress = lrtConfig.getContract(LRTConstants.EIGEN_STRATEGY_MANAGER);\n\n        (IStrategy[] memory strategies,) =\n            IEigenStrategyManager(eigenlayerStrategyManagerAddress).getDeposits(address(this));\n\n        uint256 strategiesLength = strategies.length;\n        assets = new address[](strategiesLength);\n        assetBalances = new uint256[](strategiesLength);\n\n        for (uint256 i = 0; i < strategiesLength;) {\n            assets[i] = address(IStrategy(strategies[i]).underlyingToken());\n            assetBalances[i] = IStrategy(strategies[i]).userUnderlyingView(address(this));\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Returns the balance of an asset that the node delegator has deposited into the strategy\n    /// @param asset the asset to get the balance of\n    /// @return stakedBalance the balance of the asset\n    function getAssetBalance(address asset) external view override returns (uint256) {\n        address strategy = lrtConfig.assetStrategy(asset);\n        return IStrategy(strategy).userUnderlyingView(address(this));\n    }\n\n    /// @dev Triggers stopped state. Contract must not be paused.\n    function pause() external onlyLRTManager {\n        _pause();\n    }\n\n    /// @dev Returns to normal state. Contract must be paused\n    function unpause() external onlyLRTAdmin {\n        _unpause();\n    }\n}"
    }
  ]
}