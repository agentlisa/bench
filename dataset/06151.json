{
  "Title": "[M-01] Interchain token transfer can be dossed due to flow limit",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/its/token-manager/TokenManager.sol#L83-L173><br>\n<https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/its/interchain-token/InterchainToken.sol#L1-L106>\n\n### Impact\n\nA large token holder can send back and forth tokens using the flow limit to the capacity in the start of every epoch, making the system unusable for everyone else.\n\n### Proof of Concept\n\nInterchain tokens can be transferred from one chain to another via the token manager and interchain token service. There is a limit imposed for both the flow out and flow in.\n\nFlow out happens when you send the token from one chain to another. Lets say arbitrum to optimism and you are sending USDC. So in this case, in context of arbitrum, it will be flow out and in context of optimism. Then, it will be flow in and the receiver on optimism will get the tokens via the token manager `giveToken()` callable by the inter chain token service; however, there is a flow limit imposed per epoch.\n\nOne Epoch `=` 6 hours long.\n\nSo there cannot be more than a certain amount of tokens sent between the chain per 6 hours. This is done to protect from the uncertain conditions, like a security breach, and to secure as many of the tokens as possible. However, the problem with such a design, is a big token holder or whale could easily exploit it to DOS the other users.\n\nConsider the following scenario:\n\n1. The Epoch starts.\n2. Limit imposed for the flow is 10 million USDC (considering USDC to be interchain token for ease of understanding).\n3. A big whale transfer 10 million USDC at the start of the epoch. Those are there, but may or may not receive them on other end right away.\n4. But the limit has been reached for the specific epoch. Now, no other user can use the axelar interchain token service to transfer that particular token on the dossed lane.\n5. Now, an attacker can repeat the process across multiple lanes on a multiple chain or one, in the start of every epoch, making it unusable for everyone with a very minimum cost.\n\nThis attack is pretty simple and easy to achieve and also very cheap to do; specifically, on the L2's or other cheap chains due to low gas prices.\n\nThe functions using the flow limit utility in `tokenManager.sol` are the following:\n\n```solidity\n    function sendToken(\n        string calldata destinationChain,\n        bytes calldata destinationAddress,\n        uint256 amount,\n        bytes calldata metadata\n    ) external payable virtual {\n        address sender = msg.sender;\n        amount = _takeToken(sender, amount);\n        _addFlowOut(amount);\n        interchainTokenService.transmitSendToken{ value: msg.value }(\n            _getTokenId(),\n            sender,\n            destinationChain,\n            destinationAddress,\n            amount,\n            metadata\n        );\n    }\n\n    /**\n     * @notice Calls the service to initiate the a cross-chain transfer with data after taking the appropriate amount of tokens from the user.\n     * @param destinationChain the name of the chain to send tokens to.\n     * @param destinationAddress the address of the user to send tokens to.\n     * @param amount the amount of tokens to take from msg.sender.\n     * @param data the data to pass to the destination contract.\n     */\n    function callContractWithInterchainToken(\n        string calldata destinationChain,\n        bytes calldata destinationAddress,\n        uint256 amount,\n        bytes calldata data\n    ) external payable virtual {\n        address sender = msg.sender;\n        amount = _takeToken(sender, amount);\n        _addFlowOut(amount);\n        uint32 version = 0;\n        interchainTokenService.transmitSendToken{ value: msg.value }(\n            _getTokenId(),\n            sender,\n            destinationChain,\n            destinationAddress,\n            amount,\n            abi.encodePacked(version, data)\n        );\n    }\n\n    /**\n     * @notice Calls the service to initiate the a cross-chain transfer after taking the appropriate amount of tokens from the user. This can only be called by the token itself.\n     * @param sender the address of the user paying for the cross chain transfer.\n     * @param destinationChain the name of the chain to send tokens to.\n     * @param destinationAddress the address of the user to send tokens to.\n     * @param amount the amount of tokens to take from msg.sender.\n     */\n    function transmitInterchainTransfer(\n        address sender,\n        string calldata destinationChain,\n        bytes calldata destinationAddress,\n        uint256 amount,\n        bytes calldata metadata\n    ) external payable virtual onlyToken {\n        amount = _takeToken(sender, amount);\n        _addFlowOut(amount);\n        interchainTokenService.transmitSendToken{ value: msg.value }(\n            _getTokenId(),\n            sender,\n            destinationChain,\n            destinationAddress,\n            amount,\n            metadata\n        );\n    }\n\n    /**\n     * @notice This function gives token to a specified address. Can only be called by the service.\n     * @param destinationAddress the address to give tokens to.\n     * @param amount the amount of token to give.\n     * @return the amount of token actually given, which will only be different than `amount` in cases where the token takes some on-transfer fee.\n     */\n    function giveToken(address destinationAddress, uint256 amount) external onlyService returns (uint256) {\n        amount = _giveToken(destinationAddress, amount);\n        _addFlowIn(amount);\n        return amount;\n    }\n\n    /**\n     * @notice This function sets the flow limit for this TokenManager. Can only be called by the operator.\n     * @param flowLimit the maximum difference between the tokens flowing in and/or out at any given interval of time (6h)\n     */\n    function setFlowLimit(uint256 flowLimit) external onlyOperator {\n        _setFlowLimit(flowLimit);\n    }\n```\n\n### Recommended Mitigation Steps\n\nThere could be many solutions for this. But two solutions are:\n\n1. Do the Chainlink CCIP way, Chainlink recently launched cross chain service that solved a similar problem by imposing the token bps fee. By imposing such a fee along with a gas fee, the cost of attack becomes way higher and the system can be protected from such an attack.\n\n2. Introduce the mechanism of limit per account instead of whole limit. But that can be exploited too by doing it through multiple accounts.\n\nChainlink's way would be the better solution to go with IMO.\n\n### Assessed type\n\nDoS\n\n**[deanamiel (Axelar) disagreed with severity and commented](https://github.com/code-423n4/2023-07-axelar-findings/issues/484#issuecomment-1693709234):**\n> Corrected Severity: QA\n>\n> This behavior is intentional. If an attacker tries to block one way (either in or out), the operator can respond by increasing the `flowLimit` (or setting it to `0`, meaning there's no limit at all) to help handle the attack. We prefer to keep fees as low as possible, so we would not want to use the Chainlink method that was suggested.\n\n**[berndartmueller (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-07-axelar-findings/issues/484#issuecomment-1702476186):**\n > Even though this is intentional, the demonstrated issue can cause temporary availability (inability to transfer tokens) issues for the token service. This qualifies for medium severity, according to the [C4 judging criteria](https://docs.code4rena.com/awarding/judging-criteria/severity-categorization):\n> \n> > Assets not at direct risk, but the **function of the protocol or its availability could be impacted**\n\n**[milapsheth (Axelar) commented](https://github.com/code-423n4/2023-07-axelar-findings/issues/484#issuecomment-1801749159):**\n> We consider this QA for the following reasons:\n> 1. Rate limits are intended to reduce availability/liveness on large transfers, so liveness concern by itself isn't applicable to judge this issue.\n> 2. Rate limits are opt-in and updatable, operators are recommended to choose the parameters carefully to determine the risk/liveness trade-off, and take operational responsibility to maintain it.\n> 3. The design is intentional. We consider other proposed designs to have worse trade-offs. A bps fee introduces a fee-on-transfer behaviour, and a high cost to otherwise honest large transfers. Per account limits are not Sybil resistant. We're happy to consider other designs if they're better, but the report doesn't cover that.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-07-axelar",
  "Code": [
    {
      "filename": "contracts/its/token-manager/TokenManager.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ITokenManager } from '../interfaces/ITokenManager.sol';\nimport { IInterchainTokenService } from '../interfaces/IInterchainTokenService.sol';\nimport { ITokenManagerProxy } from '../interfaces/ITokenManagerProxy.sol';\n\nimport { Operatable } from '../utils/Operatable.sol';\nimport { FlowLimit } from '../utils/FlowLimit.sol';\nimport { AddressBytesUtils } from '../libraries/AddressBytesUtils.sol';\nimport { Implementation } from '../utils/Implementation.sol';\n\n/**\n * @title The main functionality of TokenManagers.\n * @notice This contract is responsible for handling tokens before initiating a cross chain token transfer, or after receiving one.\n */\nabstract contract TokenManager is ITokenManager, Operatable, FlowLimit, Implementation {\n    using AddressBytesUtils for bytes;\n\n    IInterchainTokenService public immutable interchainTokenService;\n\n    /**\n     * @notice Constructs the TokenManager contract.\n     * @param interchainTokenService_ The address of the interchain token service\n     */\n    constructor(address interchainTokenService_) {\n        if (interchainTokenService_ == address(0)) revert TokenLinkerZeroAddress();\n        interchainTokenService = IInterchainTokenService(interchainTokenService_);\n    }\n\n    /**\n     * @dev A modifier that allows only the interchain token service to execute the function.\n     */\n    modifier onlyService() {\n        if (msg.sender != address(interchainTokenService)) revert NotService();\n        _;\n    }\n\n    /**\n     * @dev A modifier that allows only the token to execute the function.\n     */\n    modifier onlyToken() {\n        if (msg.sender != tokenAddress()) revert NotToken();\n        _;\n    }\n\n    /**\n     * @notice A function that should return the address of the token.\n     * Must be overridden in the inheriting contract.\n     * @return address address of the token.\n     */\n    function tokenAddress() public view virtual returns (address);\n\n    /**\n     * @dev This function should only be called by the proxy, and only once from the proxy constructor\n     * @param params the parameters to be used to initialize the TokenManager. The exact format depends\n     * on the type of TokenManager used but the first 32 bytes are reserved for the address of the operator,\n     * stored as bytes (to be compatible with non-EVM chains)\n     */\n    function setup(bytes calldata params) external override onlyProxy {\n        bytes memory operatorBytes = abi.decode(params, (bytes));\n        address operator_;\n        /**\n         * @dev Specifying an empty operator will default to the service being the operator. This makes it easy to deploy\n         * remote standardized tokens without knowing anything about the service address at the destination.\n         */\n        if (operatorBytes.length == 0) {\n            operator_ = address(interchainTokenService);\n        } else {\n            operator_ = operatorBytes.toAddress();\n        }\n        _setOperator(operator_);\n        _setup(params);\n    }\n\n    /**\n     * @notice Calls the service to initiate the a cross-chain transfer after taking the appropriate amount of tokens from the user.\n     * @param destinationChain the name of the chain to send tokens to.\n     * @param destinationAddress the address of the user to send tokens to.\n     * @param amount the amount of tokens to take from msg.sender.\n     */\n    function sendToken(\n        string calldata destinationChain,\n        bytes calldata destinationAddress,\n        uint256 amount,\n        bytes calldata metadata\n    ) external payable virtual {\n        address sender = msg.sender;\n        amount = _takeToken(sender, amount);\n        _addFlowOut(amount);\n        interchainTokenService.transmitSendToken{ value: msg.value }(\n            _getTokenId(),\n            sender,\n            destinationChain,\n            destinationAddress,\n            amount,\n            metadata\n        );\n    }\n\n    /**\n     * @notice Calls the service to initiate the a cross-chain transfer with data after taking the appropriate amount of tokens from the user.\n     * @param destinationChain the name of the chain to send tokens to.\n     * @param destinationAddress the address of the user to send tokens to.\n     * @param amount the amount of tokens to take from msg.sender.\n     * @param data the data to pass to the destination contract.\n     */\n    function callContractWithInterchainToken(\n        string calldata destinationChain,\n        bytes calldata destinationAddress,\n        uint256 amount,\n        bytes calldata data\n    ) external payable virtual {\n        address sender = msg.sender;\n        amount = _takeToken(sender, amount);\n        _addFlowOut(amount);\n        uint32 version = 0;\n        interchainTokenService.transmitSendToken{ value: msg.value }(\n            _getTokenId(),\n            sender,\n            destinationChain,\n            destinationAddress,\n            amount,\n            abi.encodePacked(version, data)\n        );\n    }\n\n    /**\n     * @notice Calls the service to initiate the a cross-chain transfer after taking the appropriate amount of tokens from the user. This can only be called by the token itself.\n     * @param sender the address of the user paying for the cross chain transfer.\n     * @param destinationChain the name of the chain to send tokens to.\n     * @param destinationAddress the address of the user to send tokens to.\n     * @param amount the amount of tokens to take from msg.sender.\n     */\n    function transmitInterchainTransfer(\n        address sender,\n        string calldata destinationChain,\n        bytes calldata destinationAddress,\n        uint256 amount,\n        bytes calldata metadata\n    ) external payable virtual onlyToken {\n        amount = _takeToken(sender, amount);\n        _addFlowOut(amount);\n        interchainTokenService.transmitSendToken{ value: msg.value }(\n            _getTokenId(),\n            sender,\n            destinationChain,\n            destinationAddress,\n            amount,\n            metadata\n        );\n    }\n\n    /**\n     * @notice This function gives token to a specified address. Can only be called by the service.\n     * @param destinationAddress the address to give tokens to.\n     * @param amount the amount of token to give.\n     * @return the amount of token actually given, which will onle be differen than `amount` in cases where the token takes some on-transfer fee.\n     */\n    function giveToken(address destinationAddress, uint256 amount) external onlyService returns (uint256) {\n        amount = _giveToken(destinationAddress, amount);\n        _addFlowIn(amount);\n        return amount;\n    }\n\n    /**\n     * @notice This function sets the flow limit for this TokenManager. Can only be called by the operator.\n     * @param flowLimit the maximum difference between the tokens flowing in and/or out at any given interval of time (6h)\n     */\n    function setFlowLimit(uint256 flowLimit) external onlyOperator {\n        _setFlowLimit(flowLimit);\n    }\n\n    /**\n     * @notice Transfers tokens from a specific address to this contract.\n     * Must be overridden in the inheriting contract.\n     * @param from The address from which the tokens will be sent\n     * @param amount The amount of tokens to receive\n     * @return uint amount of tokens received\n     */\n    function _takeToken(address from, uint256 amount) internal virtual returns (uint256);\n\n    /**\n     * @notice Transfers tokens from this contract to a specific address.\n     * Must be overridden in the inheriting contract.\n     * @param from The address to which the tokens will be sent\n     * @param amount The amount of tokens to send\n     * @return uint amount of tokens sent\n     */\n    function _giveToken(address from, uint256 amount) internal virtual returns (uint256);\n\n    /**\n     * @dev Additional setup logic to perform\n     * Must be overridden in the inheriting contract.\n     * @param params The setup parameters\n     */\n    function _setup(bytes calldata params) internal virtual;\n\n    /**\n     * @notice Gets the token ID from the token manager proxy.\n     * @return tokenId The ID of the token\n     */\n    function _getTokenId() internal view returns (bytes32 tokenId) {\n        tokenId = ITokenManagerProxy(address(this)).tokenId();\n    }\n}"
    },
    {
      "filename": "contracts/its/interchain-token/InterchainToken.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IInterchainToken } from '../interfaces/IInterchainToken.sol';\nimport { ITokenManager } from '../interfaces/ITokenManager.sol';\nimport { ERC20 } from '../token-implementations/ERC20.sol';\n\n/**\n * @title An example implementation of the IInterchainToken.\n * @notice The implementation ERC20 can be done in any way, however this example assumes that an _approve internal function exists\n * that can be used to create approvals, and that `allowance` is a mapping.\n * @dev You can skip the `tokenManagerRequiresApproval()` function altogether if you know what it should return for your token.\n */\nabstract contract InterchainToken is IInterchainToken, ERC20 {\n    /**\n     * @notice Getter for the tokenManager used for this token.\n     * @dev Needs to be overwitten.\n     * @return tokenManager the TokenManager called to facilitate cross chain transfers.\n     */\n    function getTokenManager() public view virtual returns (ITokenManager tokenManager);\n\n    /**\n     * @notice Getter function specifiying if the tokenManager requires approval to facilitate cross-chain transfers.\n     * Usually, only mint/burn tokenManagers do not need approval.\n     * @dev The return value depends on the implementation of ERC20.\n     * In case of lock/unlock and liquidity pool TokenManagers it is possible to implement transferFrom to allow the\n     * TokenManager specifically to do it permissionlesly.\n     * On the other hand you can implement burn in a way that requires approval for a mint/burn TokenManager\n     * @return tokenManager the TokenManager called to facilitate cross chain transfers.\n     */\n    function tokenManagerRequiresApproval() public view virtual returns (bool);\n\n    /**\n     * @notice Implementation of the interchainTransfer method\n     * @dev We chose to either pass `metadata` as raw data on a remote contract call, or, if no data is passed, just do a transfer.\n     * A different implementation could have `metadata` that tells this function which function to use or that it is used for anything else as well.\n     * @param destinationChain The destination chain identifier.\n     * @param recipient The bytes representation of the address of the recipient.\n     * @param amount The amount of token to be transfered.\n     * @param metadata Either empty, to just facilitate an interchain transfer, or the data can be passed for an interchain contract call with transfer as per semantics defined by the token service.\n     */\n    function interchainTransfer(\n        string calldata destinationChain,\n        bytes calldata recipient,\n        uint256 amount,\n        bytes calldata metadata\n    ) external payable {\n        address sender = msg.sender;\n        ITokenManager tokenManager = getTokenManager();\n        /**\n         * @dev if you know the value of `tokenManagerRequiresApproval()` you can just skip the if statement and just do nothing or _approve.\n         */\n        if (tokenManagerRequiresApproval()) {\n            uint256 allowance_ = allowance[sender][address(tokenManager)];\n            if (allowance_ != type(uint256).max) {\n                if (allowance_ > type(uint256).max - amount) {\n                    allowance_ = type(uint256).max - amount;\n                }\n\n                _approve(sender, address(tokenManager), allowance_ + amount);\n            }\n        }\n\n        // Metadata semantics are defined by the token service and thus should be passed as-is.\n        tokenManager.transmitInterchainTransfer{ value: msg.value }(sender, destinationChain, recipient, amount, metadata);\n    }\n\n    /**\n     * @notice Implementation of the interchainTransferFrom method\n     * @dev We chose to either pass `metadata` as raw data on a remote contract call, or, if no data is passed, just do a transfer.\n     * A different implementation could have `metadata` that tells this function which function to use or that it is used for anything else as well.\n     * @param sender the sender of the tokens. They need to have approved `msg.sender` before this is called.\n     * @param destinationChain the string representation of the destination chain.\n     * @param recipient the bytes representation of the address of the recipient.\n     * @param amount the amount of token to be transfered.\n     * @param metadata either empty, to just facilitate a cross-chain transfer, or the data to be passed to a cross-chain contract call and transfer.\n     */\n    function interchainTransferFrom(\n        address sender,\n        string calldata destinationChain,\n        bytes calldata recipient,\n        uint256 amount,\n        bytes calldata metadata\n    ) external payable {\n        uint256 _allowance = allowance[sender][msg.sender];\n\n        if (_allowance != type(uint256).max) {\n            _approve(sender, msg.sender, _allowance - amount);\n        }\n\n        ITokenManager tokenManager = getTokenManager();\n        if (tokenManagerRequiresApproval()) {\n            uint256 allowance_ = allowance[sender][address(tokenManager)];\n            if (allowance_ != type(uint256).max) {\n                if (allowance_ > type(uint256).max - amount) {\n                    allowance_ = type(uint256).max - amount;\n                }\n\n                _approve(sender, address(tokenManager), allowance_ + amount);\n            }\n        }\n\n        tokenManager.transmitInterchainTransfer{ value: msg.value }(sender, destinationChain, recipient, amount, metadata);\n    }\n}"
    }
  ]
}