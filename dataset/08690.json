{
  "Title": "[2] Critical changes should use two-step procedure",
  "Content": "\nThe critical procedures should be two step process.\n\n### Proof of Concept\n\n1.  Navigate to the following contracts:\n\nhttps://github.com/code-423n4/2022-06-illuminate/blob/main/marketplace/MarketPlace.sol#L109<br>\n\nhttps://github.com/code-423n4/2022-06-illuminate/blob/main/marketplace/MarketPlace.sol#L98<br>\n\nhttps://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L129<br>\n\nhttps://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L137<br>\n\n### Recommended Mitigation Steps\n\nLack of two-step procedure for critical operations leaves them error-prone. Consider adding two step procedure on the critical functions.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-06-illuminate",
  "Code": [
    {
      "filename": "marketplace/MarketPlace.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Interfaces.sol';\nimport './ERC5095.sol';\nimport './Safe.sol';\n\n/// @title MarketPlace\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice This contract is in charge of managing the avaialable principals for each loan market.\n/// @notice In addition, this contract routes swap orders between metaprincipal tokens and their respective underlying to YieldSpace pools.\ncontract MarketPlace {\n    /// @notice the available principals\n    /// @dev the order of this enum is used to select principals from the markets\n    /// mapping (e.g. Illuminate => 0, Swivel => 1, and so on)\n    enum Principals {\n        Illuminate,\n        Swivel,\n        Yield,\n        Element,\n        Pendle,\n        Tempus,\n        Sense,\n        Apwine,\n        Notional\n    }\n\n    error Exists(string);\n    error Unauthorized();\n    error Invalid(string);\n\n    /// @notice markets are defined by a market pair which point to a fixed length array of principal token addresses. \n    /// @notice The principal tokens those addresses represent correspond to their Principals enum value, thus the array should be ordered in that way\n    mapping(address => mapping(uint256 => address[9])) public markets;\n\n    /// @notice pools map markets to their respective YieldSpace pools for the MetaPrincipal token\n    mapping(address => mapping(uint256 => address)) public pools;\n\n    /// @notice address that is allowed to create markets, set fees, etc. It is commonly used in the authorized modifier.\n    address public admin;\n    /// @notice address of the deployed redeemer contract\n    address public immutable redeemer;\n    /// @notice address of the deployed lender contract\n    address public immutable lender;\n\n    /// @notice emitted upon the creation of a new market\n    event CreateMarket(address indexed underlying, uint256 indexed maturity);\n\n    /// @notice intializes the MarketPlace contract\n    /// @param r address of the deployed redeemer contract\n    /// @param l address of the deployed lender contract\n    constructor(address r, address l) {\n        admin = msg.sender;\n        redeemer = r;\n        lender = l;\n    }\n\n    /// @notice creates a new market for the given underlying token and maturity\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param t principal token addresses for this market minus the illuminate principal (which is added here)\n    /// @param n name for the illuminate token\n    /// @param s symbol for the illuminate token\n    /// @param d decimals for the illuminate token\n    /// @return bool true if successful\n    function createMarket(\n        address u,\n        uint256 m,\n        address[8] memory t,\n        string calldata n,\n        string calldata s,\n        uint8 d\n    ) external authorized(admin) returns (bool) {\n        if (markets[u][m][uint256(Principals.Illuminate)] != address(0)) {\n            revert Exists('market already exists');\n        }\n\n        // deploy an illuminate token with this new market\n        address iToken = address(new ERC5095(u, m, redeemer, lender, n, s, d));\n\n        // the market will have the illuminate principal as its zeroth item, thus t should have Principals[1] as [0]\n        address[9] memory market = [iToken, t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7]];\n\n        // set the market\n        markets[u][m] = market;\n\n        emit CreateMarket(u, m);\n        return true;\n    }\n\n    /// @notice allows the admin to set an individual market\n    /// @param p enum value of the principal token\n    /// @param u underlying token address\n    /// @param m maturity timestamp for the market\n    /// @param a address of the new market\n    /// @return bool true if successful\n    function setPrincipal(uint8 p, address u, uint256 m, address a) external authorized(admin) returns (bool) {\n        if (markets[u][m][p] != address(0)) {\n            revert Exists('Market already exists');\n        }\n        markets[u][m][p] = a;\n        return true;\n    }\n\n    /// @notice sets the admin address\n    /// @param a Address of a new admin\n    /// @return bool true if successful\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        return true;\n    }\n\n    /// @notice sets the address for a pool\n    /// @param u address of the underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a address of the pool\n    /// @return bool true if successful\n    function setPool(\n        address u,\n        uint256 m,\n        address a\n    ) external authorized(admin) returns (bool) {\n        if (pools[u][m] != address(0)) {\n            revert Exists('pool already exists');\n        }\n        pools[u][m] = a;\n        return true;\n    }\n\n    /// @notice sells the PT for the PT via the pool\n    /// @param u address of the underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of PT to swap\n    /// @return uint128 amount of PT bought\n    function sellPrincipalToken(\n        address u,\n        uint256 m,\n        uint128 a\n    ) external returns (uint128) {\n        IPool pool = IPool(pools[u][m]);\n        Safe.transfer(IERC20(address(pool.fyToken())), address(pool), a);\n        return pool.sellFYToken(msg.sender, pool.sellFYTokenPreview(a));\n    }\n\n    /// @notice buys the underlying for the PT via the pool\n    /// @param u address of the underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to sell\n    /// @return uint128 amount of PT received\n    function buyPrincipalToken(\n        address u,\n        uint256 m,\n        uint128 a\n    ) external returns (uint128) {\n        IPool pool = IPool(pools[u][m]);\n        Safe.transfer(IERC20(address(pool.base())), address(pool), a);\n        return pool.buyFYToken(msg.sender, pool.buyFYTokenPreview(a), a);\n    }\n\n    /// @notice sells the underlying for the PT via the pool\n    /// @param u address of the underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying to swap\n    /// @return uint128 amount of underlying sold\n    function sellUnderlying(\n        address u,\n        uint256 m,\n        uint128 a\n    ) external returns (uint128) {\n        IPool pool = IPool(pools[u][m]);\n        Safe.transfer(IERC20(address(pool.base())), address(pool), a);\n        return pool.sellBase(msg.sender, pool.sellBasePreview(a));\n    }\n\n    /// @notice buys the underlying for the PT via the pool\n    /// @param u address of the underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of PT to swap\n    /// @return uint128 amount of underlying bought\n    function buyUnderlying(\n        address u,\n        uint256 m,\n        uint128 a\n    ) external returns (uint128) {\n        IPool pool = IPool(pools[u][m]);\n        Safe.transfer(IERC20(address(pool.fyToken())), address(pool), a);\n        return pool.buyBase(msg.sender, pool.buyBasePreview(a), a);\n    }\n\n    /// @notice mint liquidity tokens in exchange for adding underlying and PT\n    /// @dev amount of liquidity tokens to mint is calculated from the amount of unaccounted for PT in this contract.\n    /// @dev A proportional amount of underlying tokens need to be present in this contract, also unaccounted for.\n    /// @param u the address of the underlying token\n    /// @param m the maturity of the principal token\n    /// @param uA the underlying amount being sent\n    /// @param ptA the principal token amount being sent\n    /// @param minRatio minimum ratio of underlying to PT in the pool.\n    /// @param maxRatio maximum ratio of underlying to PT in the pool.\n    /// @return uint256 the amount of liquidity tokens minted.\n    function mint(address u, uint256 m, uint256 uA, uint256 ptA, uint256 minRatio, uint256 maxRatio) external returns (uint256, uint256, uint256) {\n        IPool pool = IPool(pools[u][m]);\n        Safe.transferFrom(ERC20(address(pool.base())), msg.sender, address(pool), uA);  \n        Safe.transferFrom(ERC20(address(pool.fyToken())), msg.sender, address(pool), ptA);\n        return pool.mint(msg.sender, msg.sender, minRatio, maxRatio);\n    }\n\n    /// @notice Mint liquidity tokens in exchange for adding only underlying\n    /// @dev amount of liquidity tokens is calculated from the amount of PT to buy from the pool,\n    /// plus the amount of unaccounted for PT in this contract.\n    /// @param u the address of the underlying token\n    /// @param m the maturity of the principal token\n    /// @param a the underlying amount being sent\n    /// @param ptBought amount of `PT` being bought in the Pool, from this we calculate how much underlying it will be taken in.\n    /// @param minRatio minimum ratio of underlying to PT in the pool.\n    /// @param maxRatio maximum ratio of underlying to PT in the pool.\n    /// @return uint256 the amount of liquidity tokens minted\n    function mintWithUnderlying(address u, uint256 m, uint256 a, uint256 ptBought, uint256 minRatio, uint256 maxRatio) external returns (uint256, uint256, uint256) {\n        IPool pool = IPool(pools[u][m]);\n        Safe.transferFrom(ERC20(address(pool.base())), msg.sender, address(pool), a);\n        return pool.mintWithBase(msg.sender, msg.sender, ptBought, minRatio, maxRatio);\n    }\n\n    /// @notice burn liquidity tokens in exchange for underlying and PT.\n    /// @param u the address of the underlying token\n    /// @param m the maturity of the principal token\n    /// @param minRatio minimum ratio of underlying to PT in the pool.\n    /// @param maxRatio maximum ratio of underlying to PT in the pool.\n    /// @return uint256 amount of tokens burned and returned (tokensBurned, underlyings, PTs).\n    function burn(address u, uint256 m, uint256 minRatio, uint256 maxRatio) external returns (uint256, uint256, uint256) {\n        return IPool(pools[u][m]).burn(msg.sender, msg.sender, minRatio, maxRatio);\n    }\n\n    /// @notice burn liquidity tokens in exchange for underlying.\n    /// @param u the address of the underlying token\n    /// @param m the maturity of the principal token\n    /// @param minRatio minimum ratio of underlying to PT in the pool.\n    /// @param maxRatio minimum ratio of underlying to PT in the pool.\n    /// @return uint256 amount of underlying tokens returned\n    /// @return uint256 amount of PT tokens sent to the pool\n    function burnForUnderlying(address u, uint256 m, uint256 minRatio, uint256 maxRatio) external returns (uint256, uint256) {\n        return IPool(pools[u][m]).burnForBase(msg.sender, minRatio, maxRatio);\n    }\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Unauthorized();\n        }\n        _;\n    }\n}"
    },
    {
      "filename": "marketplace/MarketPlace.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Interfaces.sol';\nimport './ERC5095.sol';\nimport './Safe.sol';\n\n/// @title MarketPlace\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice This contract is in charge of managing the avaialable principals for each loan market.\n/// @notice In addition, this contract routes swap orders between metaprincipal tokens and their respective underlying to YieldSpace pools.\ncontract MarketPlace {\n    /// @notice the available principals\n    /// @dev the order of this enum is used to select principals from the markets\n    /// mapping (e.g. Illuminate => 0, Swivel => 1, and so on)\n    enum Principals {\n        Illuminate,\n        Swivel,\n        Yield,\n        Element,\n        Pendle,\n        Tempus,\n        Sense,\n        Apwine,\n        Notional\n    }\n\n    error Exists(string);\n    error Unauthorized();\n    error Invalid(string);\n\n    /// @notice markets are defined by a market pair which point to a fixed length array of principal token addresses. \n    /// @notice The principal tokens those addresses represent correspond to their Principals enum value, thus the array should be ordered in that way\n    mapping(address => mapping(uint256 => address[9])) public markets;\n\n    /// @notice pools map markets to their respective YieldSpace pools for the MetaPrincipal token\n    mapping(address => mapping(uint256 => address)) public pools;\n\n    /// @notice address that is allowed to create markets, set fees, etc. It is commonly used in the authorized modifier.\n    address public admin;\n    /// @notice address of the deployed redeemer contract\n    address public immutable redeemer;\n    /// @notice address of the deployed lender contract\n    address public immutable lender;\n\n    /// @notice emitted upon the creation of a new market\n    event CreateMarket(address indexed underlying, uint256 indexed maturity);\n\n    /// @notice intializes the MarketPlace contract\n    /// @param r address of the deployed redeemer contract\n    /// @param l address of the deployed lender contract\n    constructor(address r, address l) {\n        admin = msg.sender;\n        redeemer = r;\n        lender = l;\n    }\n\n    /// @notice creates a new market for the given underlying token and maturity\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param t principal token addresses for this market minus the illuminate principal (which is added here)\n    /// @param n name for the illuminate token\n    /// @param s symbol for the illuminate token\n    /// @param d decimals for the illuminate token\n    /// @return bool true if successful\n    function createMarket(\n        address u,\n        uint256 m,\n        address[8] memory t,\n        string calldata n,\n        string calldata s,\n        uint8 d\n    ) external authorized(admin) returns (bool) {\n        if (markets[u][m][uint256(Principals.Illuminate)] != address(0)) {\n            revert Exists('market already exists');\n        }\n\n        // deploy an illuminate token with this new market\n        address iToken = address(new ERC5095(u, m, redeemer, lender, n, s, d));\n\n        // the market will have the illuminate principal as its zeroth item, thus t should have Principals[1] as [0]\n        address[9] memory market = [iToken, t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7]];\n\n        // set the market\n        markets[u][m] = market;\n\n        emit CreateMarket(u, m);\n        return true;\n    }\n\n    /// @notice allows the admin to set an individual market\n    /// @param p enum value of the principal token\n    /// @param u underlying token address\n    /// @param m maturity timestamp for the market\n    /// @param a address of the new market\n    /// @return bool true if successful\n    function setPrincipal(uint8 p, address u, uint256 m, address a) external authorized(admin) returns (bool) {\n        if (markets[u][m][p] != address(0)) {\n            revert Exists('Market already exists');\n        }\n        markets[u][m][p] = a;\n        return true;\n    }\n\n    /// @notice sets the admin address\n    /// @param a Address of a new admin\n    /// @return bool true if successful\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        return true;\n    }\n\n    /// @notice sets the address for a pool\n    /// @param u address of the underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a address of the pool\n    /// @return bool true if successful\n    function setPool(\n        address u,\n        uint256 m,\n        address a\n    ) external authorized(admin) returns (bool) {\n        if (pools[u][m] != address(0)) {\n            revert Exists('pool already exists');\n        }\n        pools[u][m] = a;\n        return true;\n    }\n\n    /// @notice sells the PT for the PT via the pool\n    /// @param u address of the underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of PT to swap\n    /// @return uint128 amount of PT bought\n    function sellPrincipalToken(\n        address u,\n        uint256 m,\n        uint128 a\n    ) external returns (uint128) {\n        IPool pool = IPool(pools[u][m]);\n        Safe.transfer(IERC20(address(pool.fyToken())), address(pool), a);\n        return pool.sellFYToken(msg.sender, pool.sellFYTokenPreview(a));\n    }\n\n    /// @notice buys the underlying for the PT via the pool\n    /// @param u address of the underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to sell\n    /// @return uint128 amount of PT received\n    function buyPrincipalToken(\n        address u,\n        uint256 m,\n        uint128 a\n    ) external returns (uint128) {\n        IPool pool = IPool(pools[u][m]);\n        Safe.transfer(IERC20(address(pool.base())), address(pool), a);\n        return pool.buyFYToken(msg.sender, pool.buyFYTokenPreview(a), a);\n    }\n\n    /// @notice sells the underlying for the PT via the pool\n    /// @param u address of the underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying to swap\n    /// @return uint128 amount of underlying sold\n    function sellUnderlying(\n        address u,\n        uint256 m,\n        uint128 a\n    ) external returns (uint128) {\n        IPool pool = IPool(pools[u][m]);\n        Safe.transfer(IERC20(address(pool.base())), address(pool), a);\n        return pool.sellBase(msg.sender, pool.sellBasePreview(a));\n    }\n\n    /// @notice buys the underlying for the PT via the pool\n    /// @param u address of the underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of PT to swap\n    /// @return uint128 amount of underlying bought\n    function buyUnderlying(\n        address u,\n        uint256 m,\n        uint128 a\n    ) external returns (uint128) {\n        IPool pool = IPool(pools[u][m]);\n        Safe.transfer(IERC20(address(pool.fyToken())), address(pool), a);\n        return pool.buyBase(msg.sender, pool.buyBasePreview(a), a);\n    }\n\n    /// @notice mint liquidity tokens in exchange for adding underlying and PT\n    /// @dev amount of liquidity tokens to mint is calculated from the amount of unaccounted for PT in this contract.\n    /// @dev A proportional amount of underlying tokens need to be present in this contract, also unaccounted for.\n    /// @param u the address of the underlying token\n    /// @param m the maturity of the principal token\n    /// @param uA the underlying amount being sent\n    /// @param ptA the principal token amount being sent\n    /// @param minRatio minimum ratio of underlying to PT in the pool.\n    /// @param maxRatio maximum ratio of underlying to PT in the pool.\n    /// @return uint256 the amount of liquidity tokens minted.\n    function mint(address u, uint256 m, uint256 uA, uint256 ptA, uint256 minRatio, uint256 maxRatio) external returns (uint256, uint256, uint256) {\n        IPool pool = IPool(pools[u][m]);\n        Safe.transferFrom(ERC20(address(pool.base())), msg.sender, address(pool), uA);  \n        Safe.transferFrom(ERC20(address(pool.fyToken())), msg.sender, address(pool), ptA);\n        return pool.mint(msg.sender, msg.sender, minRatio, maxRatio);\n    }\n\n    /// @notice Mint liquidity tokens in exchange for adding only underlying\n    /// @dev amount of liquidity tokens is calculated from the amount of PT to buy from the pool,\n    /// plus the amount of unaccounted for PT in this contract.\n    /// @param u the address of the underlying token\n    /// @param m the maturity of the principal token\n    /// @param a the underlying amount being sent\n    /// @param ptBought amount of `PT` being bought in the Pool, from this we calculate how much underlying it will be taken in.\n    /// @param minRatio minimum ratio of underlying to PT in the pool.\n    /// @param maxRatio maximum ratio of underlying to PT in the pool.\n    /// @return uint256 the amount of liquidity tokens minted\n    function mintWithUnderlying(address u, uint256 m, uint256 a, uint256 ptBought, uint256 minRatio, uint256 maxRatio) external returns (uint256, uint256, uint256) {\n        IPool pool = IPool(pools[u][m]);\n        Safe.transferFrom(ERC20(address(pool.base())), msg.sender, address(pool), a);\n        return pool.mintWithBase(msg.sender, msg.sender, ptBought, minRatio, maxRatio);\n    }\n\n    /// @notice burn liquidity tokens in exchange for underlying and PT.\n    /// @param u the address of the underlying token\n    /// @param m the maturity of the principal token\n    /// @param minRatio minimum ratio of underlying to PT in the pool.\n    /// @param maxRatio maximum ratio of underlying to PT in the pool.\n    /// @return uint256 amount of tokens burned and returned (tokensBurned, underlyings, PTs).\n    function burn(address u, uint256 m, uint256 minRatio, uint256 maxRatio) external returns (uint256, uint256, uint256) {\n        return IPool(pools[u][m]).burn(msg.sender, msg.sender, minRatio, maxRatio);\n    }\n\n    /// @notice burn liquidity tokens in exchange for underlying.\n    /// @param u the address of the underlying token\n    /// @param m the maturity of the principal token\n    /// @param minRatio minimum ratio of underlying to PT in the pool.\n    /// @param maxRatio minimum ratio of underlying to PT in the pool.\n    /// @return uint256 amount of underlying tokens returned\n    /// @return uint256 amount of PT tokens sent to the pool\n    function burnForUnderlying(address u, uint256 m, uint256 minRatio, uint256 maxRatio) external returns (uint256, uint256) {\n        return IPool(pools[u][m]).burnForBase(msg.sender, minRatio, maxRatio);\n    }\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Unauthorized();\n        }\n        _;\n    }\n}"
    },
    {
      "filename": "lender/Lender.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Interfaces.sol';\nimport './MarketPlace.sol'; // library of market place specific constructs\nimport './Swivel.sol'; // library of swivel specific constructs\nimport './Element.sol'; // library of element specific constructs\nimport './Safe.sol';\nimport './Cast.sol';\n\n/// @title Lender.sol\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice The lender contract executes loans on behalf of users. \n/// @notice The contract holds the principal tokens for each market and mints an ERC-5095 position to users to represent their lent positions.\ncontract Lender {\n    error Unauthorized();\n    error NotEqual(string);\n    error Exists(address);\n    error Invalid(string);\n\n    /// @notice minimum amount of time the admin must wait before executing a withdrawl\n    uint256 constant public HOLD = 3 days;\n\n    /// @notice address that is allowed to create markets, set fees, etc. It is commonly used in the authorized modifier.\n    address public admin;\n    /// @notice address of the MarketPlace.sol contract, used to access the markets mapping\n    address public marketPlace;\n    /// @notice mapping that determines if a principal may be used by a lender\n    mapping(uint8 => bool) public paused;\n\n    /// @notice third party contract needed to lend on Swivel\n    address public swivelAddr;\n    /// @notice third party contract needed to lend on Pendle\n    address public immutable pendleAddr;\n    /// @notice third party contract needed to lend on Tempus\n    address public immutable tempusAddr;\n\n    /// @notice this value determines the amount of fees paid on loans\n    uint256 public feenominator;\n\n    /// @notice maps underlying tokens to the amount of fees accumulated for that token\n    mapping(address => uint256) public fees;\n    /// @notice maps a token address to a point in time, a hold, after which a withdrawal can be made\n    mapping (address => uint256) public withdrawals;\n\n    /// @notice emitted upon executed lend\n    event Lend(uint8 principal, address indexed underlying, uint256 indexed maturity, uint256 returned);\n    /// @notice emitted upon minted ERC5095 to user\n    event Mint(uint8 principal, address indexed underlying, uint256 indexed maturity, uint256 amount);\n    /// @notice emitted on token withdrawal scheduling\n    event ScheduleWithdrawal(address indexed token, uint256 hold);\n    /// @notice emitted on token withdrawal blocking\n    event BlockWithdrawal(address indexed token);\n    /// @notice emitted on a change to the feenominators array\n\n    /// @notice initializes the Lender contract\n    /// @param s the swivel contract\n    /// @param p the pendle contract\n    /// @param t the tempus contract\n    constructor(\n        address s,\n        address p,\n        address t\n    ) {\n        admin = msg.sender;\n        swivelAddr = s;\n        pendleAddr = p;\n        tempusAddr = t;\n        feenominator = 1000;\n    }\n\n    /// @notice approves the redeemer contract to spend the principal tokens held by the lender contract.\n    /// @param u underlying token's address, used to define the market being approved\n    /// @param m maturity of the underlying token, used to define the market being approved\n    /// @param r the address being approved, in this case the redeemer contract\n    /// @return bool true if the approval was successful, false otherwise\n    function approve(\n        address u,\n        uint256 m,\n        address r\n    ) external authorized(admin) returns (bool) {\n        // max is the maximum integer value for a 256 unsighed integer\n        uint256 max = 2**256 - 1;\n\n        // approve the underlying for max per given principal\n        for (uint8 i; i < 9; ) {\n            // get the principal token's address\n            address token = IMarketPlace(marketPlace).markets(u, m, i);\n            // check that the token is defined for this particular market\n            if (token != address(0)) {\n                // max approve the token\n                Safe.approve(IERC20(token), r, max);\n            }\n            unchecked {\n                i++;\n            }\n        }\n        return true;\n    }\n\n    /// @notice bulk approves the usage of addresses at the given ERC20 addresses. \n    /// @dev the lengths of the inputs must match because the arrays are paired by index\n    /// @param u array of ERC20 token addresses that will be approved on\n    /// @param a array of addresses that will be approved\n    /// @return true if successful\n    function approve(address[] calldata u, address[] calldata a) external authorized(admin) returns (bool) {\n        uint256 len = u.length;\n        if (len != a.length) {\n            revert NotEqual('array length');\n        }\n        uint256 max = 2**256 - 1;\n\n        for (uint256 i; i < len; ) {\n            IERC20 uToken = IERC20(u[i]);\n            if (address(0) != (address(uToken))) {\n                Safe.approve(uToken, a[i], max);\n            }\n            unchecked {\n                i++;\n            }\n        }\n        return true;\n    }\n\n    /// @notice sets the admin address\n    /// @param a address of a new admin\n    /// @return bool true if successful\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        return true;\n    }\n\n    /// @notice sets the feenominator to the given value\n    /// @param f the new value of the feenominator, fees are not collected when the feenominator is 0\n    /// @return bool true if successful\n    function setFee(uint256 f) external authorized(admin) returns (bool) {\n        feenominator = f;\n        return true;\n    }\n\n    /// @notice sets the address of the marketplace contract which contains the addresses of all the fixed rate markets\n    /// @param m the address of the marketplace contract\n    /// @return bool true if the address was set, false otherwise\n    function setMarketPlace(address m) external authorized(admin) returns (bool) {\n        if (marketPlace != address(0)) {\n            revert Exists(marketPlace);\n        }\n        marketPlace = m;\n        return true;\n    }\n\n    /// @notice sets the feenominator to the given value\n    /// @param s the address of the Swivel.sol Router\n    /// @return bool true if successful\n    function setSwivel(address s) external authorized(admin) returns (bool) {\n        swivelAddr = s;\n        return true;\n    }\n\n    /// @notice mint swaps the sender's principal tokens for illuminate's ERC5095 tokens in effect, this opens a new fixed rate position for the sender on illuminate\n    /// @param p value of a specific principal according to the MarketPlace Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount being minted\n    /// @return bool true if the mint was successful, false otherwise\n    function mint(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a\n    ) public returns (bool) {\n        //use market interface to fetch the market for the given market pair\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n        //use safe transfer lib and ERC interface...\n        Safe.transferFrom(IERC20(principal), msg.sender, address(this), a);\n        //use ERC5095 interface...\n        IERC5095(principalToken(u, m)).mint(msg.sender, a);\n\n        emit Mint(p, u, m, a);\n\n        return true;\n    }\n\n    /// @notice lend method signature for both illuminate and yield\n    /// @param p value of a specific principal according to the MarketPlace Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param y yieldspace pool that will execute the swap for the principal token\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        address y\n    ) public unpaused(p) returns (uint256) {\n        // check the principal is illuminate or yield\n        if (p != uint8(MarketPlace.Principals.Illuminate) && p != uint8(MarketPlace.Principals.Yield)) {\n            revert Invalid('principal');\n        }\n\n        // uses yield token interface...\n        IYield pool = IYield(y);\n\n        // the yield token must match the market pair\n        if (address(pool.base()) != u) {\n            revert NotEqual('underlying');\n        } else if (pool.maturity() > m) {\n            revert NotEqual('maturity');\n        }\n\n        // transfer from user to illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        if (p == uint8(MarketPlace.Principals.Yield)) {\n            // Purchase yield PTs to lender.sol (address(this))\n            uint256 returned = yield(u, y, a - calculateFee(a), address(this));\n            // Mint and distribute equivalent illuminate PTs\n            IERC5095(principalToken(u, m)).mint(msg.sender, returned);\n            \n            emit Lend(p, u, m, returned);\n\n            return returned;\n        }\n        else {\n            // Purchase illuminate PTs directly to msg.sender\n            uint256 returned = yield(u, y, a - calculateFee(a), msg.sender);\n\n            emit Lend(p, u, m, returned);\n\n            return returned;\n        }\n    }\n\n    /// @notice lend method signature for swivel\n    /// @dev lends to yield pool. remaining balance is sent to the yield pool\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a array of amounts of underlying tokens lent to each order in the orders array\n    /// @param y yield pool\n    /// @param o array of swivel orders being filled\n    /// @param s array of signatures for each order in the orders array\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256[] memory a,\n        address y,\n        Swivel.Order[] calldata o,\n        Swivel.Components[] calldata s\n    ) public unpaused(p) returns (uint256) {\n\n        // lent represents the number of underlying tokens lent\n        uint256 lent;\n        {\n            // returned represents the number of underlying tokens to lend to yield\n            uint256 returned;\n\n            uint256 totalFee;\n            // iterate through each order a calculate the total lent and returned\n            for (uint256 i = 0; i < o.length; ) {\n                Swivel.Order memory order = o[i];\n                // Require the Swivel order provided matches the underlying and maturity market provided\n                if (order.underlying != u) {\n                    revert NotEqual('underlying');\n                } else if (order.maturity > m) {"
    }
  ]
}