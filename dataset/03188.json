{
  "Title": "[L14] DepositPaymaster warning [sample]",
  "Content": "The `DepositPaymaster` contract is non-compliant with the current version of the EIP, because it [accesses an external oracle](https://github.com/eth-infinitism/account-abstraction/blob/8832d6e04b9f4f706f612261c6e46b3f1745d61a/contracts/samples/DepositPaymaster.sol#L108) during validation. Consider including a warning at the top of the contract to explain the associated risks and how bundlers should decide whether to support this paymaster.\n\n\n***Update**: Fixed in pull request [#64](https://github.com/eth-infinitism/account-abstraction/pull/64/files).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/samples/DepositPaymaster.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../BasePaymaster.sol\";\nimport \"./IOracle.sol\";\n\n/**\n * A token-based paymaster that accepts token deposit\n * The deposit is only a safeguard: the user pays with his token balance.\n *  only if the user didn't approve() the paymaster, or if the token balance is not enough, the deposit will be used.\n *  thus the required deposit is to cover just one method call.\n * The deposit is locked for the current block: the user must issue unlockTokenDeposit() to be allowed to withdraw\n *  (but can't use the deposit for this or further operations)\n *\n * paymasterData should hold the token to use.\n*/\ncontract DepositPaymaster is BasePaymaster {\n\n    using UserOperationLib for UserOperation;\n\n    IOracle constant nullOracle = IOracle(address(0));\n    mapping(IERC20 => IOracle) public oracles;\n    mapping(IERC20 => mapping(address => uint)) public balances;\n    mapping(address => uint) unlockBlock;\n\n    constructor(EntryPoint _entryPoint) BasePaymaster(_entryPoint) {\n        //owner account is unblocked, to allow withdraw of paid tokens;\n        unlockTokenDeposit();\n    }\n\n    /**\n     * owner of the paymaster should add supported tokens\n     */\n    function addToken(IERC20 token, IOracle tokenPriceOracle) external onlyOwner {\n        require(oracles[token] == nullOracle);\n        oracles[token] = tokenPriceOracle;\n    }\n\n    /**\n     * deposit tokens that a specific account can use to pay for gas.\n     * The sender must first approve this paymaster to withdraw these tokens (they are only withdrawn in this method).\n     * Note depositing the tokens is equivalent to transferring them to the \"account\" - only the account can later\n     *  use them - either as gas, or using withdrawTo()\n     *\n     * @param token the token to deposit.\n     * @param account the account to deposit for.\n     * @param amount the amount of token to deposit.\n     */\n    function addDepositFor(IERC20 token, address account, uint amount) external {\n        //(sender must have approval for the paymaster)\n        token.transferFrom(msg.sender, address(this), amount);\n        require(oracles[token] != nullOracle, \"unsupported token\");\n        balances[token][account] += amount;\n        if (msg.sender == account) {\n            lockTokenDeposit();\n        }\n    }\n\n    function depositInfo(IERC20 token, address account) public view returns (uint amount, uint _unlockBlock) {\n        amount = balances[token][account];\n        _unlockBlock = unlockBlock[account];\n    }\n\n    /**\n     * unlock deposit, so that it can be withdrawn.\n     * can't be called on in the same block as withdrawTo()\n     */\n    function unlockTokenDeposit() public {\n        unlockBlock[msg.sender] = block.number;\n    }\n\n    /**\n     * lock the tokens deposited for this account so they can be used to pay for gas.\n     * after calling unlockTokenDeposit(), the account can't use this paymaster until the deposit is locked.\n     */\n    function lockTokenDeposit() public {\n        unlockBlock[msg.sender] = 0;\n    }\n\n    /**\n     * withdraw tokens.\n     * can only be called after unlock() is called in a previous block.\n     */\n    function withdrawTokensTo(IERC20 token, address target, uint amount) public {\n        require(unlockBlock[msg.sender] != 0 && block.number > unlockBlock[msg.sender], \"DepositPaymaster: must unlockTokenDeposit\");\n        balances[token][msg.sender] -= amount;\n        token.transfer(target, amount);\n    }\n\n    function getTokenToEthOutputPrice(IERC20 token, uint ethBought) internal view virtual returns (uint requiredTokens) {\n        IOracle oracle = oracles[token];\n        require(oracle != nullOracle, \"DepositPaymaster: unsupported token\");\n        return oracle.getTokenToEthOutputPrice(ethBought);\n    }\n\n    function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 requestId, uint maxCost)\n    external view override returns (bytes memory context) {\n\n        (requestId);\n        // make sure that verificationGas is high enough to handle postOp\n        require(userOp.verificationGas > 35000, \"DepositPaymaster: gas too low for postOp\");\n\n        require(userOp.paymasterData.length == 32, \"DepositPaymaster: paymasterData must specify token\");\n        IERC20 token = abi.decode(userOp.paymasterData, (IERC20));\n        address account = userOp.getSender();\n        uint maxTokenCost = getTokenToEthOutputPrice(token, maxCost);\n        require(unlockBlock[account] == 0, \"DepositPaymaster: deposit not locked\");\n        require(balances[token][account] >= maxTokenCost, \"DepositPaymaster: deposit too low\");\n        return abi.encode(account, token, maxTokenCost, maxCost);\n    }\n\n    function _postOp(PostOpMode mode, bytes calldata context, uint actualGasCost) internal override {\n        (mode);\n\n        (address account, IERC20 token, uint maxTokenCost, uint maxCost) = abi.decode(context, (address, IERC20, uint, uint));\n        //use same conversion rate as used for validation.\n        uint actualTokenCost = actualGasCost * maxTokenCost / maxCost;\n        if (mode != PostOpMode.postOpReverted) {\n            // attempt to pay with tokens:\n            token.transferFrom(account, address(this), actualTokenCost);\n        } else {\n            //in case above transferFrom failed, pay with deposit:\n            balances[token][account] -= actualTokenCost;\n        }\n        balances[token][owner()] += actualTokenCost;\n    }\n}"
    }
  ]
}