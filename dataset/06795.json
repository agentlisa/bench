{
  "Title": "[L-04] Use `delegationsByContributor[contributor]` instead of `delegate` when minting party card",
  "Content": "The `ÃŒnitialETHCrowdfund._contribute` function currently uses `delegate` as the delegate when minting a party card [Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/InitialETHCrowdfund.sol#L302).  \n\nThis is wrong. Instead `delegationsByContributor[contributor]` should be used. This is because if User A contributes for another User B and User B has already set a delegate, i.e. `delegationsByContributor[contributor]!=address(0)` then this delegate should be used and not the `delegate` parameter supplied by User A.  \n\nHowever I don't see any impact in this behavior because if `delegationsByContributor[contributor]!=address(0)` then the party also has a delegate set for the `contributor`. And so this delegate is used above the delegate from the crowdfund anyway. So this finding is Low severity at most.  \n\nFix:  \n```diff\ndiff --git a/contracts/crowdfund/InitialETHCrowdfund.sol b/contracts/crowdfund/InitialETHCrowdfund.sol\nindex 8ab3b5c..6c76e88 100644\n--- a/contracts/crowdfund/InitialETHCrowdfund.sol\n+++ b/contracts/crowdfund/InitialETHCrowdfund.sol\n@@ -299,7 +299,7 @@ contract InitialETHCrowdfund is ETHCrowdfundBase {\n \n         if (tokenId == 0) {\n             // Mint contributor a new party card.\n-            party.mint(contributor, votingPower, delegate);\n+            party.mint(contributor, votingPower, delegationsByContributor[contributor]);\n         } else if (disableContributingForExistingCard) {\n             revert ContributingForExistingCardDisabledError();\n         } else if (party.ownerOf(tokenId) == contributor) {\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-04-party",
  "Code": [
    {
      "filename": "contracts/crowdfund/InitialETHCrowdfund.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./ETHCrowdfundBase.sol\";\nimport \"../utils/LibAddress.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/LibSafeCast.sol\";\nimport \"../tokens/ERC721Receiver.sol\";\nimport \"../party/Party.sol\";\nimport \"../crowdfund/Crowdfund.sol\";\nimport \"../gatekeepers/IGateKeeper.sol\";\n\n/// @notice A crowdfund for raising the initial funds for new parties.\n///         Unlike other crowdfunds that are started for the purpose of\n///         acquiring NFT(s), this crowdfund simply bootstraps a party with\n///         funds and lets its members coordinate on what to do with it after.\ncontract InitialETHCrowdfund is ETHCrowdfundBase {\n    using LibRawResult for bytes;\n    using LibSafeCast for uint256;\n    using LibAddress for address payable;\n\n    // Options to be passed into `initialize()` when the crowdfund is created.\n    struct InitialETHCrowdfundOptions {\n        address payable initialContributor;\n        address initialDelegate;\n        uint96 minContribution;\n        uint96 maxContribution;\n        bool disableContributingForExistingCard;\n        uint96 minTotalContributions;\n        uint96 maxTotalContributions;\n        uint16 exchangeRateBps;\n        uint16 fundingSplitBps;\n        address payable fundingSplitRecipient;\n        uint40 duration;\n        IGateKeeper gateKeeper;\n        bytes12 gateKeeperId;\n    }\n\n    struct ETHPartyOptions {\n        string name;\n        string symbol;\n        uint256 customizationPresetId;\n        Crowdfund.FixedGovernanceOpts governanceOpts;\n        ProposalStorage.ProposalEngineOpts proposalEngineOpts;\n        IERC721[] preciousTokens;\n        uint256[] preciousTokenIds;\n    }\n\n    struct BatchContributeArgs {\n        // IDs of cards to credit the contributions to. When set to 0, it means\n        uint256[] tokenIds;\n        // The address to which voting power will be delegated for all contributions.\n        address delegate;\n        // The contribution amounts in wei. The length of this array must be\n        // equal to the length of `tokenIds`.\n        uint96[] values;\n        // The data required to be validated by the `gatekeeper`, if set. If no\n        // `gatekeeper` is set, this can be empty.\n        bytes[] gateDatas;\n    }\n\n    struct BatchContributeForArgs {\n        // IDs of cards to credit the contributions to. When set to 0, it means\n        // a new one should be minted.\n        uint256[] tokenIds;\n        // Addresses of to credit the contributions under. Each contribution\n        // amount in `values` corresponds to a recipient in this array.\n        address payable[] recipients;\n        // The delegate to set for each recipient if they have not delegated\n        // before.\n        address[] initialDelegates;\n        // The contribution amounts in wei. The length of this array must be\n        // equal to the length of `recipients`.\n        uint96[] values;\n        // The data required to be validated by the `gatekeeper`, if set. If no\n        // `gatekeeper` is set, this can be empty.\n        bytes[] gateDatas;\n        // Whether to revert if any individual contribution fails or continue.\n        bool revertOnFailure;\n    }\n\n    error NoContributionError();\n\n    event Refunded(address indexed contributor, uint256 indexed tokenId, uint256 amount);\n\n    /// @notice Initializer to be delegatecalled by `Proxy` constructor. Will\n    ///         revert if called outside the constructor.\n    /// @param crowdfundOpts Options to initialize the crowdfund with.\n    /// @param partyOpts Options to initialize the party with.\n    function initialize(\n        InitialETHCrowdfundOptions memory crowdfundOpts,\n        ETHPartyOptions memory partyOpts\n    ) external payable onlyConstructor {\n        // Create party the initial crowdfund will be for.\n        Party party_ = _createParty(partyOpts);\n\n        // Initialize the crowdfund.\n        _initialize(\n            ETHCrowdfundOptions({\n                party: party_,\n                initialContributor: crowdfundOpts.initialContributor,\n                initialDelegate: crowdfundOpts.initialDelegate,\n                minContribution: crowdfundOpts.minContribution,\n                maxContribution: crowdfundOpts.maxContribution,\n                disableContributingForExistingCard: crowdfundOpts\n                    .disableContributingForExistingCard,\n                minTotalContributions: crowdfundOpts.minTotalContributions,\n                maxTotalContributions: crowdfundOpts.maxTotalContributions,\n                exchangeRateBps: crowdfundOpts.exchangeRateBps,\n                fundingSplitBps: crowdfundOpts.fundingSplitBps,\n                fundingSplitRecipient: crowdfundOpts.fundingSplitRecipient,\n                duration: crowdfundOpts.duration,\n                gateKeeper: crowdfundOpts.gateKeeper,\n                gateKeeperId: crowdfundOpts.gateKeeperId\n            })\n        );\n\n        // If the deployer passed in some ETH during deployment, credit them\n        // for the initial contribution.\n        uint96 initialContribution = msg.value.safeCastUint256ToUint96();\n        if (initialContribution > 0) {\n            // If this contract has ETH, either passed in during deployment or\n            // pre-existing, credit it to the `initialContributor`.\n            _contribute(\n                crowdfundOpts.initialContributor,\n                crowdfundOpts.initialDelegate,\n                initialContribution,\n                0,\n                \"\"\n            );\n        }\n\n        // Set up gatekeeper after initial contribution (initial always gets in).\n        gateKeeper = crowdfundOpts.gateKeeper;\n        gateKeeperId = crowdfundOpts.gateKeeperId;\n    }\n\n    /// @notice Contribute ETH to this crowdfund on behalf of a contributor.\n    /// @param delegate The address to which voting power will be delegated to\n    ///                 during the governance phase.\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility.\n    /// @return votingPower The voting power the contributor receives for their\n    ///                     contribution.\n    function contribute(\n        address delegate,\n        bytes memory gateData\n    ) public payable onlyDelegateCall returns (uint96 votingPower) {\n        return\n            _contribute(\n                payable(msg.sender),\n                delegate,\n                msg.value.safeCastUint256ToUint96(),\n                0, // Mint a new party card for the contributor.\n                gateData\n            );\n    }\n\n    /// @notice Contribute ETH to this crowdfund on behalf of a contributor.\n    /// @param tokenId The ID of the card the contribution is being made towards.\n    /// @param delegate The address to which voting power will be delegated to\n    ///                 during the governance phase.\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility.\n    /// @return votingPower The voting power the contributor receives for their\n    ///                     contribution.\n    function contribute(\n        uint256 tokenId,\n        address delegate,\n        bytes memory gateData\n    ) public payable onlyDelegateCall returns (uint96 votingPower) {\n        return\n            _contribute(\n                payable(msg.sender),\n                delegate,\n                msg.value.safeCastUint256ToUint96(),\n                tokenId,\n                gateData\n            );\n    }\n\n    /// @notice `contribute()` in batch form.\n    ///         May not revert if any individual contribution fails.\n    /// @param args The arguments to pass to each `contribute()` call.\n    /// @return votingPowers The voting power received for each contribution.\n    function batchContribute(\n        BatchContributeArgs calldata args\n    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {\n        uint256 numContributions = args.tokenIds.length;\n        votingPowers = new uint96[](numContributions);\n\n        uint256 ethAvailable = msg.value;\n        for (uint256 i; i < numContributions; ++i) {\n            ethAvailable -= args.values[i];\n\n            votingPowers[i] = _contribute(\n                payable(msg.sender),\n                args.delegate,\n                args.values[i],\n                args.tokenIds[i],\n                args.gateDatas[i]\n            );\n        }\n\n        // Refund any unused ETH.\n        if (ethAvailable > 0) payable(msg.sender).transfer(ethAvailable);\n    }\n\n    /// @notice Contribute to this crowdfund on behalf of another address.\n    /// @param tokenId The ID of the token to credit the contribution to, or\n    ///                zero to mint a new party card for the recipient\n    /// @param recipient The address to record the contribution under\n    /// @param initialDelegate The address to delegate to for the governance\n    ///                        phase if recipient hasn't delegated\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility\n    /// @return votingPower The voting power received for the contribution\n    function contributeFor(\n        uint256 tokenId,\n        address payable recipient,\n        address initialDelegate,\n        bytes memory gateData\n    ) external payable onlyDelegateCall returns (uint96 votingPower) {\n        return\n            _contribute(\n                recipient,\n                initialDelegate,\n                msg.value.safeCastUint256ToUint96(),\n                tokenId,\n                gateData\n            );\n    }\n\n    /// @notice `contributeFor()` in batch form.\n    ///         May not revert if any individual contribution fails.\n    /// @param args The arguments for the batched `contributeFor()` calls.\n    /// @return votingPowers The voting power received for each contribution.\n    function batchContributeFor(\n        BatchContributeForArgs calldata args\n    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {\n        uint256 numContributions = args.recipients.length;\n        votingPowers = new uint96[](numContributions);\n\n        uint256 ethAvailable = msg.value;\n        for (uint256 i; i < numContributions; ++i) {\n            ethAvailable -= args.values[i];\n\n            (bool s, bytes memory r) = address(this).call{ value: args.values[i] }(\n                abi.encodeCall(\n                    this.contributeFor,\n                    (\n                        args.tokenIds[i],\n                        args.recipients[i],\n                        args.initialDelegates[i],\n                        args.gateDatas[i]\n                    )\n                )\n            );\n\n            if (!s) {\n                if (args.revertOnFailure) {\n                    r.rawRevert();\n                }\n            } else {\n                votingPowers[i] = abi.decode(r, (uint96));\n            }\n        }\n\n        // Refund any unused ETH.\n        if (ethAvailable > 0) payable(msg.sender).transfer(ethAvailable);\n    }\n\n    function _contribute(\n        address payable contributor,\n        address delegate,\n        uint96 amount,\n        uint256 tokenId,\n        bytes memory gateData\n    ) private returns (uint96 votingPower) {\n        // Require a non-null delegate.\n        if (delegate == address(0)) {\n            revert InvalidDelegateError();\n        }\n\n        // Must not be blocked by gatekeeper.\n        IGateKeeper _gateKeeper = gateKeeper;\n        if (_gateKeeper != IGateKeeper(address(0))) {\n            if (!_gateKeeper.isAllowed(contributor, gateKeeperId, gateData)) {\n                revert NotAllowedByGateKeeperError(\n                    contributor,\n                    _gateKeeper,\n                    gateKeeperId,\n                    gateData\n                );\n            }\n        }\n\n        votingPower = _processContribution(contributor, delegate, amount);\n\n        // OK to contribute with zero just to update delegate.\n        if (amount == 0) return 0;\n\n        if (tokenId == 0) {\n            // Mint contributor a new party card.\n            party.mint(contributor, votingPower, delegate);\n        } else if (disableContributingForExistingCard) {\n            revert ContributingForExistingCardDisabledError();\n        } else if (party.ownerOf(tokenId) == contributor) {\n            // Increase voting power of contributor's existing party card.\n            party.addVotingPower(tokenId, votingPower);\n        } else {\n            revert NotOwnerError();\n        }\n    }\n\n    /// @notice Refund the owner of a party card and burn it. Only available if\n    ///         the crowdfund lost. Can be called to refund for self or on\n    ///         another's behalf.\n    /// @param tokenId The ID of the party card to refund the owner of then burn.\n    /// @return amount The amount of ETH refunded to the contributor.\n    function refund(uint256 tokenId) external returns (uint96 amount) {\n        // Check crowdfund lifecycle.\n        {\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\n            if (lc != CrowdfundLifecycle.Lost) {\n                revert WrongLifecycleError(lc);\n            }\n        }\n\n        // Get amount to refund.\n        uint96 votingPower = party.votingPowerByTokenId(tokenId).safeCastUint256ToUint96();\n        amount = _calculateRefundAmount(votingPower);\n\n        if (amount > 0) {\n            // Get contributor to refund.\n            address payable contributor = payable(party.ownerOf(tokenId));\n\n            // Burn contributor's party card.\n            party.burn(tokenId);\n\n            // Refund contributor.\n            contributor.transferEth(amount);\n\n            emit Refunded(contributor, tokenId, amount);\n        }\n    }\n\n    /// @notice `refund()` in batch form.\n    ///         May not revert if any individual refund fails.\n    /// @param tokenIds The IDs of the party cards to burn and refund the owners of.\n    /// @param revertOnFailure If true, revert if any refund fails.\n    /// @return amounts The amounts of ETH refunded for each refund.\n    function batchRefund(\n        uint256[] calldata tokenIds,\n        bool revertOnFailure\n    ) external returns (uint96[] memory amounts) {\n        uint256 numRefunds = tokenIds.length;\n        amounts = new uint96[](numRefunds);\n\n        for (uint256 i; i < numRefunds; ++i) {\n            (bool s, bytes memory r) = address(this).call(\n                abi.encodeCall(this.refund, (tokenIds[i]))\n            );\n\n            if (!s) {\n                if (revertOnFailure) {\n                    r.rawRevert();\n                }\n            } else {\n                amounts[i] = abi.decode(r, (uint96));\n            }\n        }\n    }\n\n    function _createParty(ETHPartyOptions memory opts) private returns (Party) {\n        address[] memory authorities = new address[](1);\n        authorities[0] = address(this);\n\n        return\n            opts.governanceOpts.partyFactory.createParty(\n                opts.governanceOpts.partyImpl,\n                authorities,\n                Party.PartyOptions({\n                    name: opts.name,\n                    symbol: opts.symbol,\n                    customizationPresetId: opts.customizationPresetId,\n                    governance: PartyGovernance.GovernanceOpts({\n                        hosts: opts.governanceOpts.hosts,\n                        voteDuration: opts.governanceOpts.voteDuration,\n                        executionDelay: opts.governanceOpts.executionDelay,\n                        passThresholdBps: opts.governanceOpts.passThresholdBps,\n                        totalVotingPower: 0,\n                        feeBps: opts.governanceOpts.feeBps,\n                        feeRecipient: opts.governanceOpts.feeRecipient\n                    }),\n                    proposalEngine: opts.proposalEngineOpts\n                }),\n                opts.preciousTokens,\n                opts.preciousTokenIds\n            );\n    }\n}"
    }
  ]
}