{
  "Title": "[11] `_assertValidSignature` allows malleable `secp256k1` signatures",
  "Content": "\nThe `ecrecover()` call [here](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/lib/SignatureVerification.sol#L91) does not verify `0 < s < secp256k1.n ÷ 2 + 1`.\n\nThis restriction was introduced Homestead ([EIP-2](https://eips.ethereum.org/EIPS/eip-2)), but left the precompile unchanged. Most libraries, such as OpenZeppelin, [perform this check](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.6.0/contracts/utils/cryptography/ECDSA.sol#L152-L166).\n\nThere does not seem to be an immediate risk in the current use cases, because an order can be verified only once and its hash is stored. These places are [`_validateBasicOrderAndUpdateStatus`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/lib/OrderValidator.sol#L48), [`_validateOrderAndUpdateStatus`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/lib/OrderValidator.sol#L104) and [`validate`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/lib/OrderValidator.sol#L333).\n\n### Proof of Concept\n**Context:** [SignatureVerification.sol#L91](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/lib/SignatureVerification.sol#L91)\n\n### Recommended Mitigation Steps\n\nPerform the check.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-05-opensea-seaport",
  "Code": [
    {
      "filename": "contracts/lib/SignatureVerification.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport { EIP1271Interface } from \"../interfaces/EIP1271Interface.sol\";\n\n// prettier-ignore\nimport {\n    SignatureVerificationErrors\n} from \"../interfaces/SignatureVerificationErrors.sol\";\n\nimport { LowLevelHelpers } from \"./LowLevelHelpers.sol\";\n\nimport \"./ConsiderationConstants.sol\";\n\n/**\n * @title SignatureVerification\n * @author 0age\n * @notice SignatureVerification contains logic for verifying signatures.\n */\ncontract SignatureVerification is SignatureVerificationErrors, LowLevelHelpers {\n    /**\n     * @dev Internal view function to verify the signature of an order. An\n     *      ERC-1271 fallback will be attempted if either the signature length\n     *      is not 32 or 33 bytes or if the recovered signer does not match the\n     *      supplied signer. Note that in cases where a 32 or 33 byte signature\n     *      is supplied, only standard ECDSA signatures that recover to a\n     *      non-zero address are supported.\n     *\n     * @param signer    The signer for the order.\n     * @param digest    The digest to verify the signature against.\n     * @param signature A signature from the signer indicating that the order\n     *                  has been approved.\n     */\n    function _assertValidSignature(\n        address signer,\n        bytes32 digest,\n        bytes memory signature\n    ) internal view {\n        // Declare r, s, and v signature parameters.\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // If signature contains 64 bytes, parse as EIP-2098 signature (r+s&v).\n        if (signature.length == 64) {\n            // Declare temporary vs that will be decomposed into s and v.\n            bytes32 vs;\n\n            // Read each parameter directly from the signature's memory region.\n            assembly {\n                // Put the first word from the signature onto the stack as r.\n                r := mload(add(signature, OneWord))\n\n                // Put the second word from the signature onto the stack as vs.\n                vs := mload(add(signature, TwoWords))\n\n                // Extract canonical s from vs (all but the highest bit).\n                s := and(vs, EIP2098_allButHighestBitMask)\n\n                // Extract yParity from highest bit of vs and add 27 to get v.\n                v := add(shr(255, vs), 27)\n            }\n        } else if (signature.length == 65) {\n            // If signature is 65 bytes, parse as a standard signature (r+s+v).\n            // Read each parameter directly from the signature's memory region.\n            assembly {\n                // Place first word on the stack at r.\n                r := mload(add(signature, OneWord))\n\n                // Place second word on the stack at s.\n                s := mload(add(signature, TwoWords))\n\n                // Place final byte on the stack at v.\n                v := byte(0, mload(add(signature, ThreeWords)))\n            }\n\n            // Ensure v value is properly formatted.\n            if (v != 27 && v != 28) {\n                revert BadSignatureV(v);\n            }\n        } else {\n            // For all other signature lengths, try verification via EIP-1271.\n            // Attempt EIP-1271 static call to signer in case it's a contract.\n            _assertValidEIP1271Signature(signer, digest, signature);\n\n            // Return early if the ERC-1271 signature check succeeded.\n            return;\n        }\n\n        // Attempt to recover signer using the digest and signature parameters.\n        address recoveredSigner = ecrecover(digest, v, r, s);\n\n        // Disallow invalid signers.\n        if (recoveredSigner == address(0)) {\n            revert InvalidSignature();\n            // Should a signer be recovered, but it doesn't match the signer...\n        } else if (recoveredSigner != signer) {\n            // Attempt EIP-1271 static call to signer in case it's a contract.\n            _assertValidEIP1271Signature(signer, digest, signature);\n        }\n    }\n\n    /**\n     * @dev Internal view function to verify the signature of an order using\n     *      ERC-1271 (i.e. contract signatures via `isValidSignature`). Note\n     *      that, in contrast to standard ECDSA signatures, 1271 signatures may\n     *      be valid in certain contexts and invalid in others, or vice versa;\n     *      orders that validate signatures ahead of time must explicitly cancel\n     *      those orders to invalidate them.\n     *\n     * @param signer    The signer for the order.\n     * @param digest    The signature digest, derived from the domain separator\n     *                  and the order hash.\n     * @param signature A signature (or other data) used to validate the digest.\n     */\n    function _assertValidEIP1271Signature(\n        address signer,\n        bytes32 digest,\n        bytes memory signature\n    ) internal view {\n        // Attempt an EIP-1271 staticcall to the signer.\n        bool success = _staticcall(\n            signer,\n            abi.encodeWithSelector(\n                EIP1271Interface.isValidSignature.selector,\n                digest,\n                signature\n            )\n        );\n\n        // If the call fails...\n        if (!success) {\n            // Revert and pass reason along if one was returned.\n            _revertWithReasonIfOneIsReturned();\n\n            // Otherwise, revert with a generic error message.\n            revert BadContractSignature();\n        }\n\n        // Ensure result was extracted and matches EIP-1271 magic value.\n        if (_doesNotMatchMagic(EIP1271Interface.isValidSignature.selector)) {\n            revert InvalidSigner();\n        }\n    }\n}"
    },
    {
      "filename": "contracts/utils/cryptography/ECDSA.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}"
    },
    {
      "filename": "contracts/lib/OrderValidator.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport { OrderType } from \"./ConsiderationEnums.sol\";\n\n// prettier-ignore\nimport {\n    OrderParameters,\n    Order,\n    AdvancedOrder,\n    OrderComponents,\n    OrderStatus,\n    CriteriaResolver\n} from \"./ConsiderationStructs.sol\";\n\nimport { Executor } from \"./Executor.sol\";\n\nimport { ZoneInteraction } from \"./ZoneInteraction.sol\";\n\n/**\n * @title OrderValidator\n * @author 0age\n * @notice OrderValidator contains functionality related to validating orders\n *         and updating their status.\n */\ncontract OrderValidator is Executor, ZoneInteraction {\n    // Track status of each order (validated, cancelled, and fraction filled).\n    mapping(bytes32 => OrderStatus) private _orderStatus;\n\n    /**\n     * @dev Derive and set hashes, reference chainId, and associated domain\n     *      separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(address conduitController) Executor(conduitController) {}\n\n    /**\n     * @dev Internal function to verify and update the status of a basic order.\n     *\n     * @param orderHash The hash of the order.\n     * @param offerer   The offerer of the order.\n     * @param signature A signature from the offerer indicating that the order\n     *                  has been approved.\n     */\n    function _validateBasicOrderAndUpdateStatus(\n        bytes32 orderHash,\n        address offerer,\n        bytes memory signature\n    ) internal {\n        // Retrieve the order status for the given order hash.\n        OrderStatus memory orderStatus = _orderStatus[orderHash];\n\n        // Ensure order is fillable and is not cancelled.\n        _verifyOrderStatus(\n            orderHash,\n            orderStatus,\n            true, // Only allow unused orders when fulfilling basic orders.\n            true // Signifies to revert if the order is invalid.\n        );\n\n        // If the order is not already validated, verify the supplied signature.\n        if (!orderStatus.isValidated) {\n            _verifySignature(offerer, orderHash, signature);\n        }\n\n        // Update order status as fully filled, packing struct values.\n        _orderStatus[orderHash].isValidated = true;\n        _orderStatus[orderHash].isCancelled = false;\n        _orderStatus[orderHash].numerator = 1;\n        _orderStatus[orderHash].denominator = 1;\n    }\n\n    /**\n     * @dev Internal function to validate an order, determine what portion to\n     *      fill, and update its status. The desired fill amount is supplied as\n     *      a fraction, as is the returned amount to fill.\n     *\n     * @param advancedOrder     The order to fulfill as well as the fraction to\n     *                          fill. Note that all offer and consideration\n     *                          amounts must divide with no remainder in order\n     *                          for a partial fill to be valid.\n     * @param criteriaResolvers An array where each element contains a reference\n     *                          to a specific offer or consideration, a token\n     *                          identifier, and a proof that the supplied token\n     *                          identifier is contained in the order's merkle\n     *                          root. Note that a criteria of zero indicates\n     *                          that any (transferrable) token identifier is\n     *                          valid and that no proof needs to be supplied.\n     * @param revertOnInvalid   A boolean indicating whether to revert if the\n     *                          order is invalid due to the time or status.\n     * @param priorOrderHashes  The order hashes of each order supplied prior to\n     *                          the current order as part of a \"match\" variety\n     *                          of order fulfillment (e.g. this array will be\n     *                          empty for single or \"fulfill available\").\n     *\n     * @return orderHash      The order hash.\n     * @return newNumerator   A value indicating the portion of the order that\n     *                        will be filled.\n     * @return newDenominator A value indicating the total size of the order.\n     */\n    function _validateOrderAndUpdateStatus(\n        AdvancedOrder memory advancedOrder,\n        CriteriaResolver[] memory criteriaResolvers,\n        bool revertOnInvalid,\n        bytes32[] memory priorOrderHashes\n    )\n        internal\n        returns (\n            bytes32 orderHash,\n            uint256 newNumerator,\n            uint256 newDenominator\n        )\n    {\n        // Retrieve the parameters for the order.\n        OrderParameters memory orderParameters = advancedOrder.parameters;\n\n        // Ensure current timestamp falls between order start time and end time.\n        if (\n            !_verifyTime(\n                orderParameters.startTime,\n                orderParameters.endTime,\n                revertOnInvalid\n            )\n        ) {\n            // Assuming an invalid time and no revert, return zeroed out values.\n            return (bytes32(0), 0, 0);\n        }\n\n        // Read numerator and denominator from memory and place on the stack.\n        uint256 numerator = uint256(advancedOrder.numerator);\n        uint256 denominator = uint256(advancedOrder.denominator);\n\n        // Ensure that the supplied numerator and denominator are valid.\n        if (numerator > denominator || numerator == 0) {\n            revert BadFraction();\n        }\n\n        // If attempting partial fill (n < d) check order type & ensure support.\n        if (\n            numerator < denominator &&\n            _doesNotSupportPartialFills(orderParameters.orderType)\n        ) {\n            // Revert if partial fill was attempted on an unsupported order.\n            revert PartialFillsNotEnabledForOrder();\n        }\n\n        // Retrieve current nonce and use it w/ parameters to derive order hash.\n        orderHash = _assertConsiderationLengthAndGetNoncedOrderHash(\n            orderParameters\n        );\n\n        // Ensure restricted orders have a valid submitter or pass a zone check.\n        _assertRestrictedAdvancedOrderValidity(\n            advancedOrder,\n            criteriaResolvers,\n            priorOrderHashes,\n            orderHash,\n            orderParameters.zoneHash,\n            orderParameters.orderType,\n            orderParameters.offerer,\n            orderParameters.zone\n        );\n\n        // Retrieve the order status using the derived order hash.\n        OrderStatus memory orderStatus = _orderStatus[orderHash];\n\n        // Ensure order is fillable and is not cancelled.\n        if (\n            !_verifyOrderStatus(\n                orderHash,\n                orderStatus,\n                false, // Allow partially used orders to be filled.\n                revertOnInvalid\n            )\n        ) {\n            // Assuming an invalid order status and no revert, return zero fill.\n            return (orderHash, 0, 0);\n        }\n\n        // If the order is not already validated, verify the supplied signature.\n        if (!orderStatus.isValidated) {\n            _verifySignature(\n                orderParameters.offerer,\n                orderHash,\n                advancedOrder.signature\n            );\n        }\n\n        // Read filled amount as numerator and denominator and put on the stack.\n        uint256 filledNumerator = orderStatus.numerator;\n        uint256 filledDenominator = orderStatus.denominator;\n\n        // If order currently has a non-zero denominator it is partially filled.\n        if (filledDenominator != 0) {\n            // If denominator of 1 supplied, fill all remaining amount on order.\n            if (denominator == 1) {\n                // Scale numerator & denominator to match current denominator.\n                numerator = filledDenominator;\n                denominator = filledDenominator;\n            }\n            // Otherwise, if supplied denominator differs from current one...\n            else if (filledDenominator != denominator) {\n                // scale current numerator by the supplied denominator, then...\n                filledNumerator *= denominator;\n\n                // the supplied numerator & denominator by current denominator.\n                numerator *= filledDenominator;\n                denominator *= filledDenominator;\n            }\n\n            // Once adjusted, if current+supplied numerator exceeds denominator:\n            if (filledNumerator + numerator > denominator) {\n                // Skip underflow check: denominator >= orderStatus.numerator\n                unchecked {\n                    // Reduce current numerator so it + supplied = denominator.\n                    numerator = denominator - filledNumerator;\n                }\n            }\n\n            // Skip overflow check: checked above unless numerator is reduced.\n            unchecked {\n                // Update order status and fill amount, packing struct values.\n                _orderStatus[orderHash].isValidated = true;\n                _orderStatus[orderHash].isCancelled = false;\n                _orderStatus[orderHash].numerator = uint120(\n                    filledNumerator + numerator\n                );\n                _orderStatus[orderHash].denominator = uint120(denominator);\n            }\n        } else {\n            // Update order status and fill amount, packing struct values.\n            _orderStatus[orderHash].isValidated = true;\n            _orderStatus[orderHash].isCancelled = false;\n            _orderStatus[orderHash].numerator = uint120(numerator);\n            _orderStatus[orderHash].denominator = uint120(denominator);\n        }\n\n        // Return order hash, a modified numerator, and a modified denominator.\n        return (orderHash, numerator, denominator);\n    }\n\n    /**\n     * @dev Internal function to cancel an arbitrary number of orders. Note that\n     *      only the offerer or the zone of a given order may cancel it. Callers\n     *      should ensure that the intended order was cancelled by calling\n     *      `getOrderStatus` and confirming that `isCancelled` returns `true`.\n     *\n     * @param orders The orders to cancel.\n     *\n     * @return cancelled A boolean indicating whether the supplied orders were\n     *                   successfully cancelled.\n     */\n    function _cancel(OrderComponents[] calldata orders)\n        internal\n        returns (bool cancelled)\n    {\n        // Ensure that the reentrancy guard is not currently set.\n        _assertNonReentrant();\n\n        address offerer;\n        address zone;\n\n        // Skip overflow check as for loop is indexed starting at zero.\n        unchecked {\n            // Read length of the orders array from memory and place on stack.\n            uint256 totalOrders = orders.length;\n\n            // Iterate over each order.\n            for (uint256 i = 0; i < totalOrders; ) {\n                // Retrieve the order.\n                OrderComponents calldata order = orders[i];\n\n                offerer = order.offerer;\n                zone = order.zone;\n\n                // Ensure caller is either offerer or zone of the order.\n                if (msg.sender != offerer && msg.sender != zone) {\n                    revert InvalidCanceller();\n                }\n\n                // Derive order hash using the order parameters and the nonce.\n                bytes32 orderHash = _deriveOrderHash(\n                    OrderParameters(\n                        offerer,\n                        zone,\n                        order.offer,\n                        order.consideration,\n                        order.orderType,\n                        order.startTime,\n                        order.endTime,\n                        order.zoneHash,\n                        order.salt,\n                        order.conduitKey,\n                        order.consideration.length\n                    ),\n                    order.nonce\n                );\n\n                // Update the order status as not valid and cancelled.\n                _orderStatus[orderHash].isValidated = false;\n                _orderStatus[orderHash].isCancelled = true;\n\n                // Emit an event signifying that the order has been cancelled.\n                emit OrderCancelled(orderHash, offerer, zone);\n\n                // Increment counter inside body of loop for gas efficiency.\n                ++i;\n            }\n        }\n\n        // Return a boolean indicating that orders were successfully cancelled.\n        cancelled = true;\n    }\n\n    /**\n     * @dev Internal function to validate an arbitrary number of orders, thereby\n     *      registering their signatures as valid and allowing the fulfiller to\n     *      skip signature verification on fulfillment. Note that validated\n     *      orders may still be unfulfillable due to invalid item amounts or\n     *      other factors; callers should determine whether validated orders are\n     *      fulfillable by simulating the fulfillment call prior to execution.\n     *      Also note that anyone can validate a signed order, but only the\n     *      offerer can validate an order without supplying a signature.\n     *\n     * @param orders The orders to validate.\n     *\n     * @return validated A boolean indicating whether the supplied orders were\n     *                   successfully validated.\n     */\n    function _validate(Order[] calldata orders)\n        internal\n        returns (bool validated)\n    {\n        // Ensure that the reentrancy guard is not currently set.\n        _assertNonReentrant();\n\n        // Declare variables outside of the loop.\n        bytes32 orderHash;\n        address offerer;\n\n        // Skip overflow check as for loop is indexed starting at zero.\n        unchecked {\n            // Read length of the orders array from memory and place on stack.\n            uint256 totalOrders = orders.length;\n\n            // Iterate over each order.\n            for (uint256 i = 0; i < totalOrders; ) {\n                // Retrieve the order.\n                Order calldata order = orders[i];\n\n                // Retrieve the order parameters.\n                OrderParameters calldata orderParameters = order.parameters;\n\n                // Move offerer from memory to the stack.\n                offerer = orderParameters.offerer;\n\n                // Get current nonce and use it w/ params to derive order hash.\n                orderHash = _assertConsiderationLengthAndGetNoncedOrderHash(\n                    orderParameters\n                );\n\n                // Retrieve the order status using the derived order hash.\n                OrderStatus memory orderStatus = _orderStatus[orderHash];\n\n                // Ensure order is fillable and retrieve the filled amount.\n                _verifyOrderStatus(\n                    orderHash,\n                    orderStatus,\n                    false, // Signifies that partially filled orders are valid.\n                    true // Signifies to revert if the order is invalid.\n                );\n\n                // If the order has not already been validated...\n                if (!orderStatus.isValidated) {\n                    // Verify the supplied signature.\n                    _verifySignature(offerer, orderHash, order.signature);\n\n                    // Update order status to mark the order as valid.\n                    _orderStatus[orderHash].isValidated = true;\n\n                    // Emit an event signifying the order has been validated.\n                    emit OrderValidated(\n                        orderHash,\n                        offerer,\n                        orderParameters.zone\n                    );\n                }\n\n                // Increment counter inside body of the loop for gas efficiency.\n                ++i;\n            }\n        }\n\n        // Return a boolean indicating that orders were successfully validated.\n        validated = true;\n    }\n\n    /**\n     * @dev Internal view function to retrieve the status of a given order by\n     *      hash, including whether the order has been cancelled or validated\n     *      and the fraction of the order that has been filled.\n     *\n     * @param orderHash The order hash in question.\n     *\n     * @return isValidated A boolean indicating whether the order in question\n     *                     has been validated (i.e. previously approved or\n     *                     partially filled).\n     * @return isCancelled A boolean indicating whether the order in question\n     *                     has been cancelled.\n     * @return totalFilled The total portion of the order that has been filled\n     *                     (i.e. the \"numerator\").\n     * @return totalSize   The total size of the order that is either filled or\n     *                     unfilled (i.e. the \"denominator\").\n     */\n    function _getOrderStatus(bytes32 orderHash)\n        internal\n        view\n        returns (\n            bool isValidated,\n            bool isCancelled,\n            uint256 totalFilled,\n            uint256 totalSize\n        )\n    {\n        // Retrieve the order status using the order hash.\n        OrderStatus memory orderStatus = _orderStatus[orderHash];\n\n        // Return the fields on the order status.\n        return (\n            orderStatus.isValidated,\n            orderStatus.isCancelled,\n            orderStatus.numerator,\n            orderStatus.denominator\n        );\n    }\n\n    /**\n     * @dev Internal pure function to check whether a given order type indicates\n     *      that partial fills are not supported (e.g. only \"full fills\" are\n     *      allowed for the order in question)"
    }
  ]
}