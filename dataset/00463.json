{
  "Title": "Trie Depth Is Not Explicitly Capped",
  "Content": "By using the Poseidon Hash, the node uses a [maximum depth of 248 levels](https://docs.scroll.io/en/technology/sequencer/zktrie/#tree-construction). However, the `ZkTrieVerifier` library does not impose a limit on the [first byte](https://github.com/scroll-tech/scroll/blob/c68f4283b15e9816427caedf372ed2daac7f2e66/contracts/src/libraries/verifier/ZkTrieVerifier.sol#L81) that represents the length added to the proofs, making it possible to pass proofs with a length that exceeds the limit and continue with the operation. Even though it is challenging to craft a proof that would allow a user to pass the validations performed when constructing the leaf hash, not asserting the length exposes some un-mitigated attack surface which could be targeted by a malicious user in a different attack.\n\n\nConsider asserting that the maximum depth is not exceeded by the crafted proof.\n\n\n***Update:** Resolved in [pull request #1137](https://github.com/scroll-tech/scroll/pull/1137) at commit [`daaf600`](https://github.com/scroll-tech/scroll/pull/1137/commits/daaf600a2d0ed070c9ca8c59d4cf5a2981124609).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/libraries/verifier/ZkTrieVerifier.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\n// solhint-disable no-inline-assembly\n\nlibrary ZkTrieVerifier {\n    /// @notice Internal function to validates a proof from eth_getProof.\n    /// @param poseidon The address of poseidon hash contract.\n    /// @param account The address of the contract.\n    /// @param storageKey The storage slot to verify.\n    /// @param proof The rlp encoding result of eth_getProof.\n    /// @return stateRoot The computed state root. Must be checked by the caller.\n    /// @return storageValue The value of `storageKey`.\n    ///\n    /// @dev The code is based on\n    /// 1. https://github.com/scroll-tech/go-ethereum/blob/staging/trie/zk_trie.go#L176\n    /// 2. https://github.com/scroll-tech/zktrie/blob/main/trie/zk_trie_proof.go#L30\n    ///\n    /// The encoding order of `proof` is\n    /// ```text\n    /// |        1 byte        |      ...      |        1 byte        |      ...      |\n    /// | account proof length | account proof | storage proof length | storage proof |\n    /// ```\n    function verifyZkTrieProof(\n        address poseidon,\n        address account,\n        bytes32 storageKey,\n        bytes calldata proof\n    ) internal view returns (bytes32 stateRoot, bytes32 storageValue) {\n        assembly {\n            // reverts with error `msg`.\n            // make sure the length of error string <= 32\n            function revertWith(msg) {\n                // keccak(\"Error(string)\")\n                mstore(0x00, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n                mstore(0x04, 0x20) // str.offset\n                mstore(0x44, msg)\n                let msgLen\n                for {\n\n                } msg {\n\n                } {\n                    msg := shl(8, msg)\n                    msgLen := add(msgLen, 1)\n                }\n                mstore(0x24, msgLen) // str.length\n                revert(0x00, 0x64)\n            }\n            // reverts with `msg` when condition is not matched.\n            // make sure the length of error string <= 32\n            function require(cond, msg) {\n                if iszero(cond) {\n                    revertWith(msg)\n                }\n            }\n            // compute poseidon hash of two uint256\n            function poseidon_hash(hasher, v0, v1, domain) -> r {\n                let x := mload(0x40)\n                // keccack256(\"poseidon(uint256[2],uint256)\")\n                mstore(x, 0xa717016c00000000000000000000000000000000000000000000000000000000)\n                mstore(add(x, 0x04), v0)\n                mstore(add(x, 0x24), v1)\n                mstore(add(x, 0x44), domain)\n                let success := staticcall(gas(), hasher, x, 0x64, 0x20, 0x20)\n                require(success, \"poseidon hash failed\")\n                r := mload(0x20)\n            }\n            // compute poseidon hash of 1 uint256\n            function hash_uint256(hasher, v) -> r {\n                r := poseidon_hash(hasher, shr(128, v), and(v, 0xffffffffffffffffffffffffffffffff), 512)\n            }\n\n            // traverses the tree from the root to the node before the leaf.\n            // based on https://github.com/ethereum/go-ethereum/blob/master/trie/proof.go#L114\n            function walkTree(hasher, key, _ptr) -> ptr, rootHash, expectedHash {\n                ptr := _ptr\n\n                // the first byte is the number of nodes + 1\n                let nodes := sub(byte(0, calldataload(ptr)), 1)\n                ptr := add(ptr, 1)\n\n                // treat the leaf node with different logic\n                for {\n                    let depth := 1\n                } lt(depth, nodes) {\n                    depth := add(depth, 1)\n                } {\n                    // must be a parent node with two children\n                    let nodeType := byte(0, calldataload(ptr))\n                    // 6 <= nodeType && nodeType < 10\n                    require(lt(sub(nodeType, 6), 4), \"InvalidBranchNodeType\")\n                    ptr := add(ptr, 1)\n\n                    // load left/right child hash\n                    let childHashL := calldataload(ptr)\n                    ptr := add(ptr, 0x20)\n                    let childHashR := calldataload(ptr)\n                    ptr := add(ptr, 0x20)\n                    let hash := poseidon_hash(hasher, childHashL, childHashR, nodeType)\n\n                    // first item is considered the root node.\n                    // Otherwise verifies that the hash of the current node\n                    // is the same as the previous choosen one.\n                    switch depth\n                    case 1 {\n                        rootHash := hash\n                    }\n                    default {\n                        require(eq(hash, expectedHash), \"BranchHashMismatch\")\n                    }\n\n                    // decide which path to walk based on key\n                    switch and(key, 1)\n                    case 0 {\n                        expectedHash := childHashL\n                    }\n                    default {\n                        expectedHash := childHashR\n                    }\n                    key := shr(1, key)\n                }\n            }\n\n            function checkProofMagicBytes(hasher, _ptr) -> ptr {\n                ptr := _ptr\n                let x := mload(0x40)\n                calldatacopy(x, ptr, 0x2d)\n                x := keccak256(x, 0x2d)\n                require(\n                    eq(x, 0x950654da67865a81bc70e45f3230f5179f08e29c66184bf746f71050f117b3b8),\n                    \"InvalidProofMagicBytes\"\n                )\n                ptr := add(ptr, 0x2d) // skip ProofMagicBytes\n            }\n\n            function verifyAccountProof(hasher, _account, _ptr) -> ptr, storageRootHash, _stateRoot {\n                ptr := _ptr\n\n                let leafHash\n                let key := hash_uint256(hasher, shl(96, _account))\n\n                // `stateRoot` is a return value and must be checked by the caller\n                ptr, _stateRoot, leafHash := walkTree(hasher, key, ptr)\n\n                switch byte(0, calldataload(ptr))\n                case 4 {\n                    // nonempty leaf node\n                    ptr := add(ptr, 0x01) // skip NodeType\n                    require(eq(calldataload(ptr), key), \"AccountKeyMismatch\")\n                    ptr := add(ptr, 0x20) // skip NodeKey\n                    require(eq(shr(224, calldataload(ptr)), 0x05080000), \"InvalidAccountCompressedFlag\")\n                    ptr := add(ptr, 0x04) // skip CompressedFlag\n\n                    // compute value hash for State Account Leaf Node, details can be found in\n                    // https://github.com/scroll-tech/mpt-circuit/blob/v0.7/spec/mpt-proof.md#account-segmenttypes\n                    // [nonce||codesize||0, balance, storage_root, keccak codehash, poseidon codehash]\n                    mstore(0x00, calldataload(ptr))\n                    ptr := add(ptr, 0x20) // skip nonce||codesize||0\n                    mstore(0x00, poseidon_hash(hasher, mload(0x00), calldataload(ptr), 1280))\n                    ptr := add(ptr, 0x20) // skip balance\n                    storageRootHash := calldataload(ptr)\n                    ptr := add(ptr, 0x20) // skip StorageRoot\n                    let tmpHash := hash_uint256(hasher, calldataload(ptr))\n                    ptr := add(ptr, 0x20) // skip KeccakCodeHash\n                    tmpHash := poseidon_hash(hasher, storageRootHash, tmpHash, 1280)\n                    tmpHash := poseidon_hash(hasher, mload(0x00), tmpHash, 1280)\n                    tmpHash := poseidon_hash(hasher, tmpHash, calldataload(ptr), 1280)\n                    ptr := add(ptr, 0x20) // skip PoseidonCodeHash\n\n                    tmpHash := poseidon_hash(hasher, key, tmpHash, 4)\n                    require(eq(leafHash, tmpHash), \"InvalidAccountLeafNodeHash\")\n\n                    require(eq(0x20, byte(0, calldataload(ptr))), \"InvalidAccountKeyPreimageLength\")\n                    ptr := add(ptr, 0x01) // skip KeyPreimage length\n                    require(eq(shl(96, _account), calldataload(ptr)), \"InvalidAccountKeyPreimage\")\n                    ptr := add(ptr, 0x20) // skip KeyPreimage\n                }\n                case 5 {\n                    ptr := add(ptr, 0x01) // skip NodeType\n                }\n                default {\n                    revertWith(\"InvalidAccountLeafNodeType\")\n                }\n\n                // compare ProofMagicBytes\n                ptr := checkProofMagicBytes(hasher, ptr)\n            }\n\n            function verifyStorageProof(hasher, _storageKey, storageRootHash, _ptr) -> ptr, _storageValue {\n                ptr := _ptr\n\n                let leafHash\n                let key := hash_uint256(hasher, _storageKey)\n                let rootHash\n                ptr, rootHash, leafHash := walkTree(hasher, key, ptr)\n\n                // The root hash of the storage tree must match the value from the account leaf.\n                // But when the leaf node is the same as the root node, the function `walkTree` will return\n                // `rootHash=0` and `leafHash=0`. In such case, we don't need to check the value of `rootHash`.\n                // And the value of `leafHash` should be the same as `storageRootHash`.\n                switch rootHash\n                case 0 {\n                    leafHash := storageRootHash\n                }\n                default {\n                    require(eq(rootHash, storageRootHash), \"StorageRootMismatch\")\n                }\n\n                switch byte(0, calldataload(ptr))\n                case 4 {\n                    ptr := add(ptr, 0x01) // skip NodeType\n                    require(eq(calldataload(ptr), key), \"StorageKeyMismatch\")\n                    ptr := add(ptr, 0x20) // skip NodeKey\n                    require(eq(shr(224, calldataload(ptr)), 0x01010000), \"InvalidStorageCompressedFlag\")\n                    ptr := add(ptr, 0x04) // skip CompressedFlag\n                    _storageValue := calldataload(ptr)\n                    ptr := add(ptr, 0x20) // skip StorageValue\n\n                    // compute leaf node hash and compare, details can be found in\n                    // https://github.com/scroll-tech/mpt-circuit/blob/v0.7/spec/mpt-proof.md#storage-segmenttypes\n                    mstore(0x00, hash_uint256(hasher, _storageValue))\n                    mstore(0x00, poseidon_hash(hasher, key, mload(0x00), 4))\n                    require(eq(leafHash, mload(0x00)), \"InvalidStorageLeafNodeHash\")\n\n                    require(eq(0x20, byte(0, calldataload(ptr))), \"InvalidStorageKeyPreimageLength\")\n                    ptr := add(ptr, 0x01) // skip KeyPreimage length\n                    require(eq(_storageKey, calldataload(ptr)), \"InvalidStorageKeyPreimage\")\n                    ptr := add(ptr, 0x20) // skip KeyPreimage\n                }\n                case 5 {\n                    ptr := add(ptr, 0x01) // skip NodeType\n                    require(eq(leafHash, 0), \"InvalidStorageEmptyLeafNodeHash\")\n                }\n                default {\n                    revertWith(\"InvalidStorageLeafNodeType\")\n                }\n\n                // compare ProofMagicBytes\n                ptr := checkProofMagicBytes(hasher, ptr)\n            }\n\n            let storageRootHash\n            let ptr := proof.offset\n\n            // check the correctness of account proof\n            ptr, storageRootHash, stateRoot := verifyAccountProof(poseidon, account, ptr)\n\n            // check the correctness of storage proof\n            ptr, storageValue := verifyStorageProof(poseidon, storageKey, storageRootHash, ptr)\n\n            // the one and only boundary check\n            // in case an attacker crafted a malicous payload\n            // and succeeds in the prior verification steps\n            // then this should catch any bogus accesses\n            if iszero(eq(ptr, add(proof.offset, proof.length))) {\n                revertWith(\"ProofLengthMismatch\")\n            }\n        }\n    }\n}"
    }
  ]
}