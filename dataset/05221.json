{
  "Title": "[H-03] When `DecentBridgeExecutor.execute` fails, funds will be sent to a random address",
  "Content": "\n<https://github.com/decentxyz/decent-bridge/blob/7f90fd4489551b69c20d11eeecb17a3f564afb18/src/DecentEthRouter.sol#L101-L105> \n\n<https://github.com/decentxyz/decent-bridge/blob/7f90fd4489551b69c20d11eeecb17a3f564afb18/src/DecentBridgeExecutor.sol#L63>\n\nWhen the `DecentBridgeExecutor._executeWeth/_executeEth` target call fails, a refund is issued to the `from` address.\n\nHowever, this address is wrongly set, so those refunds will be permanently lost.\n\n### Proof of Concept\n\n`UTB.bridgeAndExecute` ([Link](https://github.com/code-423n4/2024-01-decent/blob/main/src/UTB.sol#L259)) calls `DecentBridgeAdapter.bridge` ([Link](https://github.com/code-423n4/2024-01-decent/blob/main/src/UTB.sol#L289)), which calls `DecentEthRouter.bridgeWithPayload` ([Link](https://github.com/code-423n4/2024-01-decent/blob/main/src/bridge_adapters/DecentBridgeAdapter.sol#L117)), where the payload is constructed ([Link](https://github.com/decentxyz/decent-bridge/blob/7f90fd4489551b69c20d11eeecb17a3f564afb18/src/DecentEthRouter.sol#L148)):\n\n```solidity\n\tfunction _bridgeWithPayload(\n\t    uint8 msgType,\n\t    uint16 _dstChainId,\n\t    address _toAddress,\n\t    uint _amount,\n\t    uint64 _dstGasForCall,\n\t    bytes memory additionalPayload,\n\t    bool deliverEth\n\t) internal {\n\t    (\n\t        bytes32 destinationBridge,\n\t        bytes memory adapterParams,\n\t        bytes memory payload\n\t    ) = _getCallParams(\n\t            msgType,\n\t            _toAddress,\n\t            _dstChainId,\n\t            _dstGasForCall,\n\t            deliverEth,\n\t            additionalPayload\n\t        );\n\t    ...\n```\n\nInside `_getCallParams` the `from` address is the `msg.sender`, i.e. the `DecentBridgeAdapter` address on the source chain ([Link](https://github.com/decentxyz/decent-bridge/blob/7f90fd4489551b69c20d11eeecb17a3f564afb18/src/DecentEthRouter.sol#L101-L105)):\n\n```solidity\n\tfunction _getCallParams(\n\t    uint8 msgType,\n\t    address _toAddress,\n\t    uint16 _dstChainId,\n\t    uint64 _dstGasForCall,\n\t    bool deliverEth,\n\t    bytes memory additionalPayload\n\t)\n\t    private\n\t    view\n\t    returns (\n\t        bytes32 destBridge,\n\t        bytes memory adapterParams,\n\t        bytes memory payload\n\t    )\n\t{\n\t    uint256 GAS_FOR_RELAY = 100000;\n\t    uint256 gasAmount = GAS_FOR_RELAY + _dstGasForCall;\n\t    adapterParams = abi.encodePacked(PT_SEND_AND_CALL, gasAmount);\n\t    destBridge = bytes32(abi.encode(destinationBridges[_dstChainId]));\n\t    if (msgType == MT_ETH_TRANSFER) {\n@>\t        payload = abi.encode(msgType, msg.sender, _toAddress, deliverEth);\n\t    } else {\n\t        payload = abi.encode(\n\t            msgType,\n@>\t            msg.sender, //@audit 'from' address\n\t            _toAddress,\n\t            deliverEth,\n\t            additionalPayload\n\t        );\n\t    }\n\t}\n```\n\nAfter the payload is constructed, `DecentEthRouter` sends the message:\n\n```solidity\n\tdcntEth.sendAndCall{value: gasValue}(\n\t    address(this), // from address that has dcntEth (so DecentRouter)\n\t    _dstChainId,\n\t    destinationBridge, // toAddress\n\t    _amount, // amount\n\t    payload, //payload (will have recipients address)\n\t    _dstGasForCall, // dstGasForCall\n\t    callParams // refundAddress, zroPaymentAddress, adapterParams\n\t);\n```\n\nFinally, on the destination chain, `DecentEthRouter` will receive the message ([Link](https://github.com/decentxyz/decent-bridge/blob/7f90fd4489551b69c20d11eeecb17a3f564afb18/src/DecentEthRouter.sol#L245-L246)):\n\n```solidity\n\tfunction onOFTReceived(\n\t    uint16 _srcChainId,\n\t    bytes calldata,\n\t    uint64,\n\t    bytes32,\n\t    uint _amount,\n\t    bytes memory _payload\n\t) external override onlyLzApp {\n\t\t//@audit from is the decentBridgeAdapter address on the source chain\n\t    (uint8 msgType, address _from, address _to, bool deliverEth) = abi\n\t        .decode(_payload, (uint8, address, address, bool));\n\t    ...\n\t}\n```\n\nAt the end of this function, the `executor` is invoked with the same `_from` address:\n\n```solidity\n\t} else {\n\t    weth.approve(address(executor), _amount);\n\t    executor.execute(_from, _to, deliverEth, _amount, callPayload);\n\t}\n```\n\nFinally, this is the `execute` function in `DecentBridgeExecutor` ([Link](https://github.com/decentxyz/decent-bridge/blob/7f90fd4489551b69c20d11eeecb17a3f564afb18/src/DecentBridgeExecutor.sol#L68)):\n\n```solidity\n\tfunction execute(\n\t    address from,\n\t    address target,\n\t    bool deliverEth,\n\t    uint256 amount,\n\t    bytes memory callPayload\n\t) public onlyOwner {\n\t    weth.transferFrom(msg.sender, address(this), amount);\n\t    if (!gasCurrencyIsEth || !deliverEth) {\n\t        _executeWeth(from, target, amount, callPayload);\n\t    } else {\n\t        _executeEth(from, target, amount, callPayload);\n\t    }\n\t}\n```\n\nBoth `_executeWeth` and `_executeEth` have the same issue and funds will be lost when the target call fails, for example `_executeEth` ([Link](https://github.com/decentxyz/decent-bridge/blob/7f90fd4489551b69c20d11eeecb17a3f564afb18/src/DecentBridgeExecutor.sol#L63)):\n\n```solidity\n\tfunction _executeEth(\n\t    address from,\n\t    address target,\n\t    uint256 amount,\n\t    bytes memory callPayload\n\t) private {\n\t    weth.withdraw(amount);\n\t    (bool success, ) = target.call{value: amount}(callPayload);\n\t    if (!success) {\n@>\t        payable(from).transfer(amount); //@audit wrong address as it uses the source address, not destination\n\t    }\n\t}\n```\n\nNow, `DecentBridgeAdapter` as a refund address seems wrong, as I disclosed in another issue, but let's suppose that it isn't, as it's possible to prove both scenarios.\n\n[As proof by contradiction](https://en.wikipedia.org/wiki/Proof_by_contradiction), funds should be sent to `DecentBridgeAdapter`, and this would be a non-issue if these contracts are deployed with `CREATE2`, as they would have the same address. But they are not deployed like that.\n\nThere is hard evidence that they have different addresses, for example, these are the addresses for `DcntEth` and `DecentEthRouter` in two different chains, which are already deployed:\n\n*   `lib/decent-bridge/actual-deployments/latest/arbitrumAddresses.json`\n\n```js\n{\n  \"arbitrum_DcntEth\": \"0x8450e1A0DebF76fd211A03c0c7F4DdbB1eEF8A85\",\n  \"done\": true,\n  \"arbitrum_DecentEthRouter\": \"0x17479B712A1FE1FFaeaf155379DE3ad1440fA99e\"\n}\n```\n\n*   `lib/decent-bridge/actual-deployments/latest/optimismAddresses.json`\n\n```js\n{\n  \"DcntEth\": \"0x4DB4ea27eA4b713E766bC13296A90bb42C5438D0\",\n  \"done\": true,\n  \"DecentEthRouter\": \"0x57beDF28C3CB3F019f40F330A2a2B0e0116AA0c2\"\n}\n```\n\nIf we take a look at the deploy script for `DecentBridgeAdapter` it also doesn't use `CREATE2`, as there isn't a factory:\n\n```solidity\n\tfunction deployDecentBridgeAdapter(\n\t    address utb,\n\t    address decentEthRouter,\n\t    address decentBridgeExecutor\n\t) internal returns (\n\t    DecentBridgeAdapter decentBridgeAdapter\n\t) {\n\t    string memory chain = vm.envString(\"CHAIN\");\n\t    bool gasIsEth = gasEthLookup[chain];\n\t    address weth = wethLookup[chain];\n\t    address bridgeToken = gasIsEth ? address(0) : weth;\n\n@>\t    decentBridgeAdapter = new DecentBridgeAdapter(gasIsEth, bridgeToken);\n\t    decentBridgeAdapter.setUtb(utb);\n\t    decentBridgeAdapter.setRouter(decentEthRouter);\n\t    decentBridgeAdapter.setBridgeExecutor(decentBridgeExecutor);\n\t    UTB(payable(utb)).registerBridge(address(decentBridgeAdapter));\n\t}\n```\n\nSo these funds will be sent to a random address in any case.\n\n### Recommended Mitigation Steps\n\nThe `executor.execute` call in `DecentEthRouter.onOFTReceived` should be changed to an appropriate address (**e.g. the user refund address**) instead of using `_from`:\n\n```solidity\n\t} else {\n\t    weth.approve(address(executor), _amount);\n\t    executor.execute(_from, _to, deliverEth, _amount, callPayload);\n\t}\n```\n\n**[0xsomeone (Judge) commented](https://github.com/code-423n4/2024-01-decent-findings/issues/436#issuecomment-1924325469):**\n > The Warden has detailed how the encoding of the cross-chain payload will use an incorrect `_from` parameter under normal operating conditions, leading to failed transfers at the target chain refunding the wrong address.\n> \n> This submission was selected as the best given that it precisely details that the `_from` address is known to be incorrect at all times when the protocol is used normally.\n> \n> A high-risk rating is appropriate as any failed call will lead to **full fund loss for the cross-chain call**.\n\n**[wkantaros (Decent) confirmed](https://github.com/code-423n4/2024-01-decent-findings/issues/436#issuecomment-1942661007)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2024-01-decent",
  "Code": [
    {
      "filename": "src/DecentEthRouter.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport {IWETH} from \"./interfaces/IWETH.sol\";\nimport {IDcntEth} from \"./interfaces/IDcntEth.sol\";\nimport {ICommonOFT} from \"solidity-examples/token/oft/v2/interfaces/ICommonOFT.sol\";\nimport {IOFTReceiverV2} from \"solidity-examples/token/oft/v2/interfaces/IOFTReceiverV2.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {IDecentBridgeExecutor} from \"./interfaces/IDecentBridgeExecutor.sol\";\nimport {IDecentEthRouter} from \"./interfaces/IDecentEthRouter.sol\";\n\ncontract DecentEthRouter is IDecentEthRouter, IOFTReceiverV2, Owned {\n    IWETH public weth;\n    IDcntEth public dcntEth;\n    IDecentBridgeExecutor public executor;\n\n    uint8 public constant MT_ETH_TRANSFER = 0;\n    uint8 public constant MT_ETH_TRANSFER_WITH_PAYLOAD = 1;\n\n    uint16 public constant PT_SEND_AND_CALL = 1;\n\n    bool public gasCurrencyIsEth; // for chains that use ETH as gas currency\n\n    mapping(uint16 => address) public destinationBridges;\n    mapping(address => uint256) public balanceOf;\n\n    constructor(\n        address payable _wethAddress,\n        bool gasIsEth,\n        address _executor\n    ) Owned(msg.sender) {\n        weth = IWETH(_wethAddress);\n        gasCurrencyIsEth = gasIsEth;\n        executor = IDecentBridgeExecutor(payable(_executor));\n    }\n\n    modifier onlyEthChain() {\n        require(gasCurrencyIsEth, \"Gas currency is not ETH\");\n        _;\n    }\n\n    modifier onlyLzApp() {\n        require(\n            address(dcntEth) == msg.sender,\n            \"DecentEthRouter: only lz App can call\"\n        );\n        _;\n    }\n\n    modifier onlyIfWeHaveEnoughReserves(uint256 amount) {\n        require(weth.balanceOf(address(this)) > amount, \"not enough reserves\");\n        _;\n    }\n\n    modifier userDepositing(uint256 amount) {\n        balanceOf[msg.sender] += amount;\n        _;\n    }\n\n    modifier userIsWithdrawing(uint256 amount) {\n        uint256 balance = balanceOf[msg.sender];\n        require(balance >= amount, \"not enough balance\");\n        _;\n        balanceOf[msg.sender] -= amount;\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function registerDcntEth(address _addr) public onlyOwner {\n        dcntEth = IDcntEth(_addr);\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function addDestinationBridge(\n        uint16 _dstChainId,\n        address _routerAddress\n    ) public onlyOwner {\n        destinationBridges[_dstChainId] = _routerAddress;\n    }\n\n    function _getCallParams(\n        uint8 msgType,\n        address _toAddress,\n        uint16 _dstChainId,\n        uint64 _dstGasForCall,\n        bool deliverEth,\n        bytes memory additionalPayload\n    )\n        private\n        view\n        returns (\n            bytes32 destBridge,\n            bytes memory adapterParams,\n            bytes memory payload\n        )\n    {\n        uint256 GAS_FOR_RELAY = 100000;\n        uint256 gasAmount = GAS_FOR_RELAY + _dstGasForCall;\n        adapterParams = abi.encodePacked(PT_SEND_AND_CALL, gasAmount);\n        destBridge = bytes32(abi.encode(destinationBridges[_dstChainId]));\n        if (msgType == MT_ETH_TRANSFER) {\n            payload = abi.encode(msgType, msg.sender, _toAddress, deliverEth);\n        } else {\n            payload = abi.encode(\n                msgType,\n                msg.sender,\n                _toAddress,\n                deliverEth,\n                additionalPayload\n            );\n        }\n    }\n\n    function estimateSendAndCallFee(\n        uint8 msgType,\n        uint16 _dstChainId,\n        address _toAddress,\n        uint _amount,\n        uint64 _dstGasForCall,\n        bool deliverEth,\n        bytes memory payload\n    ) public view returns (uint nativeFee, uint zroFee) {\n        (\n            bytes32 destinationBridge,\n            bytes memory adapterParams,\n            bytes memory _payload\n        ) = _getCallParams(\n                msgType,\n                _toAddress,\n                _dstChainId,\n                _dstGasForCall,\n                deliverEth,\n                payload\n            );\n\n        return\n            dcntEth.estimateSendAndCallFee(\n                _dstChainId,\n                destinationBridge,\n                _amount,\n                _payload,\n                _dstGasForCall,\n                false, // useZero\n                adapterParams // Relayer adapter parameters\n                // contains packet type (send and call in this case) and gasAmount\n            );\n    }\n\n    function _bridgeWithPayload(\n        uint8 msgType,\n        uint16 _dstChainId,\n        address _toAddress,\n        uint _amount,\n        uint64 _dstGasForCall,\n        bytes memory additionalPayload,\n        bool deliverEth\n    ) internal {\n        (\n            bytes32 destinationBridge,\n            bytes memory adapterParams,\n            bytes memory payload\n        ) = _getCallParams(\n                msgType,\n                _toAddress,\n                _dstChainId,\n                _dstGasForCall,\n                deliverEth,\n                additionalPayload\n            );\n\n        ICommonOFT.LzCallParams memory callParams = ICommonOFT.LzCallParams({\n            refundAddress: payable(msg.sender),\n            zroPaymentAddress: address(0x0),\n            adapterParams: adapterParams\n        });\n\n        uint gasValue;\n        if (gasCurrencyIsEth) {\n            weth.deposit{value: _amount}();\n            gasValue = msg.value - _amount;\n        } else {\n            weth.transferFrom(msg.sender, address(this), _amount);\n            gasValue = msg.value;\n        }\n\n        dcntEth.sendAndCall{value: gasValue}(\n            address(this), // from address that has dcntEth (so DecentRouter)\n            _dstChainId,\n            destinationBridge, // toAddress\n            _amount, // amount\n            payload, //payload (will have recipients address)\n            _dstGasForCall, // dstGasForCall\n            callParams // refundAddress, zroPaymentAddress, adapterParams\n        );\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function bridgeWithPayload(\n        uint16 _dstChainId,\n        address _toAddress,\n        uint _amount,\n        bool deliverEth,\n        uint64 _dstGasForCall,\n        bytes memory additionalPayload\n    ) public payable {\n        return\n            _bridgeWithPayload(\n                MT_ETH_TRANSFER_WITH_PAYLOAD,\n                _dstChainId,\n                _toAddress,\n                _amount,\n                _dstGasForCall,\n                additionalPayload,\n                deliverEth\n            );\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function bridge(\n        uint16 _dstChainId,\n        address _toAddress,\n        uint _amount,\n        uint64 _dstGasForCall,\n        bool deliverEth // if false, delivers WETH\n    ) public payable {\n        _bridgeWithPayload(\n            MT_ETH_TRANSFER,\n            _dstChainId,\n            _toAddress,\n            _amount,\n            _dstGasForCall,\n            bytes(\"\"),\n            deliverEth\n        );\n    }\n\n    /// @inheritdoc IOFTReceiverV2\n    function onOFTReceived(\n        uint16 _srcChainId,\n        bytes calldata,\n        uint64,\n        bytes32,\n        uint _amount,\n        bytes memory _payload\n    ) external override onlyLzApp {\n        (uint8 msgType, address _from, address _to, bool deliverEth) = abi\n            .decode(_payload, (uint8, address, address, bool));\n\n        bytes memory callPayload = \"\";\n\n        if (msgType == MT_ETH_TRANSFER_WITH_PAYLOAD) {\n            (, , , , callPayload) = abi.decode(\n                _payload,\n                (uint8, address, address, bool, bytes)\n            );\n        }\n\n        emit ReceivedDecentEth(\n            msgType,\n            _srcChainId,\n            _from,\n            _to,\n            _amount,\n            callPayload\n        );\n\n        if (weth.balanceOf(address(this)) < _amount) {\n            dcntEth.transfer(_to, _amount);\n            return;\n        }\n\n        if (msgType == MT_ETH_TRANSFER) {\n            if (!gasCurrencyIsEth || !deliverEth) {\n                weth.transfer(_to, _amount);\n            } else {\n                weth.withdraw(_amount);\n                payable(_to).transfer(_amount);\n            }\n        } else {\n            weth.approve(address(executor), _amount);\n            executor.execute(_from, _to, deliverEth, _amount, callPayload);\n        }\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function redeemEth(\n        uint256 amount\n    ) public onlyIfWeHaveEnoughReserves(amount) {\n        dcntEth.transferFrom(msg.sender, address(this), amount);\n        weth.withdraw(amount);\n        payable(msg.sender).transfer(amount);\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function redeemWeth(\n        uint256 amount\n    ) public onlyIfWeHaveEnoughReserves(amount) {\n        dcntEth.transferFrom(msg.sender, address(this), amount);\n        weth.transfer(msg.sender, amount);\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function addLiquidityEth()\n        public\n        payable\n        onlyEthChain\n        userDepositing(msg.value)\n    {\n        weth.deposit{value: msg.value}();\n        dcntEth.mint(address(this), msg.value);\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function removeLiquidityEth(\n        uint256 amount\n    ) public onlyEthChain userIsWithdrawing(amount) {\n        dcntEth.burn(address(this), amount);\n        weth.withdraw(amount);\n        payable(msg.sender).transfer(amount);\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function addLiquidityWeth(\n        uint256 amount\n    ) public payable userDepositing(amount) {\n        weth.transferFrom(msg.sender, address(this), amount);\n        dcntEth.mint(address(this), amount);\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function removeLiquidityWeth(\n        uint256 amount\n    ) public userIsWithdrawing(amount) {\n        dcntEth.burn(address(this), amount);\n        weth.transfer(msg.sender, amount);\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n}"
    },
    {
      "filename": "src/DecentBridgeExecutor.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {IWETH} from \"./interfaces/IWETH.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {IDecentBridgeExecutor} from \"./interfaces/IDecentBridgeExecutor.sol\";\n\ncontract DecentBridgeExecutor is IDecentBridgeExecutor, Owned {\n    IWETH weth;\n    bool public gasCurrencyIsEth; // for chains that use ETH as gas currency\n\n    constructor(address _weth, bool gasIsEth) Owned(msg.sender) {\n        weth = IWETH(payable(_weth));\n        gasCurrencyIsEth = gasIsEth;\n    }\n\n    /**\n     * @dev helper function for execute\n     * @param from caller of the function\n     * @param target target contract\n     * @param amount amount of the in eth\n     * @param callPayload payload for the tx\n     */\n    function _executeWeth(\n        address from,\n        address target,\n        uint256 amount,\n        bytes memory callPayload\n    ) private {\n        uint256 balanceBefore = weth.balanceOf(address(this));\n        weth.approve(target, amount);\n\n        (bool success, ) = target.call(callPayload);\n\n        if (!success) {\n            weth.transfer(from, amount);\n            return;\n        }\n\n        uint256 remainingAfterCall = amount -\n            (balanceBefore - weth.balanceOf(address(this)));\n\n        // refund the sender with excess WETH\n        weth.transfer(from, remainingAfterCall);\n    }\n\n    /**\n     * @dev helper function for execute\n     * @param from caller of the function\n     * @param target target contract\n     * @param amount amount of the transaction\n     * @param callPayload payload for the tx\n     */\n    function _executeEth(\n        address from,\n        address target,\n        uint256 amount,\n        bytes memory callPayload\n    ) private {\n        weth.withdraw(amount);\n        (bool success, ) = target.call{value: amount}(callPayload);\n        if (!success) {\n            payable(from).transfer(amount);\n        }\n    }\n\n    /// @inheritdoc IDecentBridgeExecutor\n    function execute(\n        address from,\n        address target,\n        bool deliverEth,\n        uint256 amount,\n        bytes memory callPayload\n    ) public onlyOwner {\n        weth.transferFrom(msg.sender, address(this), amount);\n\n        if (!gasCurrencyIsEth || !deliverEth) {\n            _executeWeth(from, target, amount, callPayload);\n        } else {\n            _executeEth(from, target, amount, callPayload);\n        }\n    }\n\n    // Function to receive Ether. msg.data must be empty\n    receive() external payable {}\n\n    // Fallback function is called when msg.data is not empty\n    fallback() external payable {}\n}"
    },
    {
      "filename": "src/UTB.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {SwapParams} from \"./swappers/SwapParams.sol\";\nimport {IUTBExecutor} from \"./interfaces/IUTBExecutor.sol\";\nimport {IERC20} from \"forge-std/interfaces/IERC20.sol\";\nimport {IWETH} from \"decent-bridge/src/interfaces/IWETH.sol\";\nimport {IUTBFeeCollector} from \"./interfaces/IUTBFeeCollector.sol\";\nimport {IBridgeAdapter} from \"./interfaces/IBridgeAdapter.sol\";\nimport {ISwapper} from \"./interfaces/ISwapper.sol\";\nimport {SwapInstructions, FeeStructure, BridgeInstructions, SwapAndExecuteInstructions} from \"./CommonTypes.sol\";\n\n\ncontract UTB is Owned {\n    constructor() Owned(msg.sender) {}\n\n    IUTBExecutor executor;\n    IUTBFeeCollector feeCollector;\n    IWETH wrapped;\n    mapping(uint8 => address) public swappers;\n    mapping(uint8 => address) public bridgeAdapters;\n\n    /**\n     * @dev Sets the executor.\n     * @param _executor The address of the executor.\n     */\n    function setExecutor(address _executor) public onlyOwner {\n        executor = IUTBExecutor(_executor);\n    }\n\n    /**\n     * @dev Sets the wrapped native token.\n     * @param _wrapped The address of the wrapped token.\n     */\n    function setWrapped(address payable _wrapped) public onlyOwner {\n        wrapped = IWETH(_wrapped);\n    }\n\n    /**\n     * @dev Sets the fee collector.\n     * @param _feeCollector The address of the fee collector.\n     */\n    function setFeeCollector(address payable _feeCollector) public onlyOwner {\n        feeCollector = IUTBFeeCollector(_feeCollector);\n    }\n\n    /**\n     * @dev Performs a swap with a default setting to retrieve ERC20.\n     * @param swapInstructions The swapper ID and calldata to execute a swap.\n     */\n    function performSwap(\n        SwapInstructions memory swapInstructions\n    ) private returns (address tokenOut, uint256 amountOut) {\n        return performSwap(swapInstructions, true);\n    }\n\n    /**\n     * @dev Performs a swap with the requested swapper and swap calldata.\n     * @param swapInstructions The swapper ID and calldata to execute a swap.\n     * @param retrieveTokenIn Flag indicating whether to transfer ERC20 for the swap.\n     */\n    function performSwap(\n        SwapInstructions memory swapInstructions,\n        bool retrieveTokenIn\n    ) private returns (address tokenOut, uint256 amountOut) {\n        ISwapper swapper = ISwapper(swappers[swapInstructions.swapperId]);\n\n        SwapParams memory swapParams = abi.decode(\n            swapInstructions.swapPayload,\n            (SwapParams)\n        );\n\n        if (swapParams.tokenIn == address(0)) {\n            require(msg.value >= swapParams.amountIn, \"not enough native\");\n            wrapped.deposit{value: swapParams.amountIn}();\n            swapParams.tokenIn = address(wrapped);\n            swapInstructions.swapPayload = swapper.updateSwapParams(\n                swapParams,\n                swapInstructions.swapPayload\n            );\n        } else if (retrieveTokenIn) {\n            IERC20(swapParams.tokenIn).transferFrom(\n                msg.sender,\n                address(this),\n                swapParams.amountIn\n            );\n        }\n\n        IERC20(swapParams.tokenIn).approve(\n            address(swapper),\n            swapParams.amountIn\n        );\n\n        (tokenOut, amountOut) = swapper.swap(swapInstructions.swapPayload);\n\n        if (tokenOut == address(0)) {\n            wrapped.withdraw(amountOut);\n        }\n    }\n\n    /**\n     * @dev Swaps currency from the incoming to the outgoing token and executes a transaction with payment.\n     * @param instructions The token swap data and payment transaction payload.\n     * @param fees The bridge fee in native, as well as utb fee token and amount.\n     * @param signature The ECDSA signature to verify the fee structure.\n     */\n    function swapAndExecute(\n        SwapAndExecuteInstructions calldata instructions,\n        FeeStructure calldata fees,\n        bytes calldata signature\n    )\n        public\n        payable\n        retrieveAndCollectFees(fees, abi.encode(instructions, fees), signature)\n    {\n        _swapAndExecute(\n            instructions.swapInstructions,\n            instructions.target,\n            instructions.paymentOperator,\n            instructions.payload,\n            instructions.refund\n        );\n    }\n\n    /**\n     * @dev Swaps currency from the incoming to the outgoing token and executes a transaction with payment.\n     * @param swapInstructions The swapper ID and calldata to execute a swap.\n     * @param target The address of the target contract for the payment transaction.\n     * @param paymentOperator The operator address for payment transfers requiring ERC20 approvals.\n     * @param payload The calldata to execute the payment transaction.\n     * @param refund The account receiving any refunds, typically the EOA which initiated the transaction.\n     */\n    function _swapAndExecute(\n        SwapInstructions memory swapInstructions,\n        address target,\n        address paymentOperator,\n        bytes memory payload,\n        address payable refund\n    ) private {\n        (address tokenOut, uint256 amountOut) = performSwap(swapInstructions);\n        if (tokenOut == address(0)) {\n            executor.execute{value: amountOut}(\n                target,\n                paymentOperator,\n                payload,\n                tokenOut,\n                amountOut,\n                refund\n            );\n        } else {\n            IERC20(tokenOut).approve(address(executor), amountOut);\n            executor.execute(\n                target,\n                paymentOperator,\n                payload,\n                tokenOut,\n                amountOut,\n                refund\n            );\n        }\n    }\n\n    /**\n     * @dev Performs the pre bridge swap and modifies the post bridge swap to utilize the bridged amount.\n     * @param instructions The bridge data, token swap data, and payment transaction payload.\n     */\n    function swapAndModifyPostBridge(\n        BridgeInstructions memory instructions\n    )\n        private\n        returns (\n            uint256 amount2Bridge,\n            BridgeInstructions memory updatedInstructions\n        )\n    {\n        (address tokenOut, uint256 amountOut) = performSwap(\n            instructions.preBridge\n        );\n\n        SwapParams memory newPostSwapParams = abi.decode(\n            instructions.postBridge.swapPayload,\n            (SwapParams)\n        );\n\n        newPostSwapParams.amountIn = IBridgeAdapter(\n            bridgeAdapters[instructions.bridgeId]\n        ).getBridgedAmount(amountOut, tokenOut, newPostSwapParams.tokenIn);\n\n        updatedInstructions = instructions;\n\n        updatedInstructions.postBridge.swapPayload = ISwapper(swappers[\n            instructions.postBridge.swapperId\n        ]).updateSwapParams(\n            newPostSwapParams,\n            instructions.postBridge.swapPayload\n        );\n\n        amount2Bridge = amountOut;\n    }\n\n    /**\n     * @dev Checks if the bridge token is native, and approves the bridge adapter to transfer ERC20 if required.\n     * @param instructions The bridge data, token swap data, and payment transaction payload.\n     * @param amt2Bridge The amount of the bridge token being transferred to the bridge adapter.\n     */\n    function approveAndCheckIfNative(\n        BridgeInstructions memory instructions,\n        uint256 amt2Bridge\n    ) private returns (bool) {\n        IBridgeAdapter bridgeAdapter = IBridgeAdapter(bridgeAdapters[instructions.bridgeId]);\n        address bridgeToken = bridgeAdapter.getBridgeToken(\n            instructions.additionalArgs\n        );\n        if (bridgeToken != address(0)) {\n            IERC20(bridgeToken).approve(address(bridgeAdapter), amt2Bridge);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @dev Transfers fees from the sender to UTB, and finally to the Fee Collector.\n     * @param fees The bridge fee in native, as well as utb fee token and amount.\n     * @param packedInfo The fees and swap instructions which were used to generate the signature.\n     * @param signature The ECDSA signature to verify the fee structure.\n     */\n    modifier retrieveAndCollectFees(\n        FeeStructure calldata fees,\n        bytes memory packedInfo,\n        bytes calldata signature\n    ) {\n        if (address(feeCollector) != address(0)) {\n            uint value = 0;\n            if (fees.feeToken != address(0)) {\n                IERC20(fees.feeToken).transferFrom(\n                    msg.sender,\n                    address(this),\n                    fees.feeAmount\n                );\n                IERC20(fees.feeToken).approve(\n                    address(feeCollector),\n                    fees.feeAmount\n                );\n            } else {\n                value = fees.feeAmount;\n            }\n            feeCollector.collectFees{value: value}(fees, packedInfo, signature);\n        }\n        _;\n    }\n\n    /**\n     * @dev Bridges funds in native or ERC20 and a payment transaction payload to the destination chain\n     * @param instructions The bridge data, token swap data, and payment transaction payload.\n     * @param fees The bridge fee in native, as well as utb fee token and amount.\n     * @param signature The ECDSA signature to verify the fee structure.\n     */\n    function bridgeAndExecute(\n        BridgeInstructions calldata instructions,\n        FeeStructure calldata fees,\n        bytes calldata signature\n    )\n        public\n        payable\n        retrieveAndCollectFees(fees, abi.encode(instructions, fees), signature)\n        returns (bytes memory)\n    {\n        (\n            uint256 amt2Bridge,\n            BridgeInstructions memory updatedInstructions\n        ) = swapAndModifyPostBridge(instructions);\n        return callBridge(amt2Bridge, fees.bridgeFee, updatedInstructions);\n    }\n\n    /**\n     * @dev Calls the bridge adapter to bridge funds, and approves the bridge adapter to transfer ERC20 if required.\n     * @param amt2Bridge The amount of the bridge token being bridged via the bridge adapter.\n     * @param bridgeFee The fee being transferred to the bridge adapter and finally to the bridge.\n     * @param instructions The bridge data, token swap data, and payment transaction payload.\n     */\n    function callBridge(\n        uint256 amt2Bridge,\n        uint bridgeFee,\n        BridgeInstructions memory instructions\n    ) private returns (bytes memory) {\n        bool native = approveAndCheckIfNative(instructions, amt2Bridge);\n        return\n            IBridgeAdapter(bridgeAdapters[instructions.bridgeId]).bridge{\n                value: bridgeFee + (native ? amt2Bridge : 0)\n            }(\n                amt2Bridge,\n                instructions.postBridge,\n                instructions.dstChainId,\n                instructions.target,\n                instructions.paymentOperator,\n                instructions.payload,\n                instructions.additionalArgs,\n                instructions.refund\n            );\n    }\n\n    /**\n     * @dev Receives funds from the bridge adapter, executes a swap, and executes a payment transaction.\n     * @param postBridge The swapper ID and calldata to execute a swap.\n     * @param target The address of the target contract for the payment transaction.\n     * @param paymentOperator The operator address for payment transfers requiring ERC20 approvals.\n     * @param payload The calldata to execute the payment transaction.\n     * @param refund The account receiving any refunds, typically the EOA which initiated the transaction.\n     */\n    function receiveFromBridge(\n        SwapInstructions memory postBridge,\n        address target,\n        address paymentOperator,\n        bytes memory payload,\n        address payable refund\n    ) public {\n        _swapAndExecute(postBridge, target, paymentOperator, payload, refund);\n    }\n\n    /**\n     * @dev Registers and maps a swapper to a swapper ID.\n     * @param swapper The address of the swapper.\n     */\n    function registerSwapper(address swapper) public onlyOwner {\n        ISwapper s = ISwapper(swapper);\n        swappers[s.getId()] = swapper;\n    }\n\n    /**\n     * @dev Registers and maps a bridge adapter to a bridge adapter ID.\n     * @param bridge The address of the bridge adapter.\n     */\n    function registerBridge(address bridge) public onlyOwner {\n        IBridgeAdapter b = IBridgeAdapter(bridge);\n        bridgeAdapters[b.getId()] = bridge;\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n}"
    },
    {
      "filename": "src/DecentEthRouter.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport {IWETH} from \"./interfaces/IWETH.sol\";\nimport {IDcntEth} from \"./interfaces/IDcntEth.sol\";\nimport {ICommonOFT} from \"solidity-examples/token/oft/v2/interfaces/ICommonOFT.sol\";\nimport {IOFTReceiverV2} from \"solidity-examples/token/oft/v2/interfaces/IOFTReceiverV2.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {IDecentBridgeExecutor} from \"./interfaces/IDecentBridgeExecutor.sol\";\nimport {IDecentEthRouter} from \"./interfaces/IDecentEthRouter.sol\";\n\ncontract DecentEthRouter is IDecentEthRouter, IOFTReceiverV2, Owned {\n    IWETH public weth;\n    IDcntEth public dcntEth;\n    IDecentBridgeExecutor public executor;\n\n    uint8 public constant MT_ETH_TRANSFER = 0;\n    uint8 public constant MT_ETH_TRANSFER_WITH_PAYLOAD = 1;\n\n    uint16 public constant PT_SEND_AND_CALL = 1;\n\n    bool public gasCurrencyIsEth; // for chains that use ETH as gas currency\n\n    mapping(uint16 => address) public destinationBridges;\n    mapping(address => uint256) public balanceOf;\n\n    constructor(\n        address payable _wethAddress,\n        bool gasIsEth,\n        address _executor\n    ) Owned(msg.sender) {\n        weth = IWETH(_wethAddress);\n        gasCurrencyIsEth = gasIsEth;\n        executor = IDecentBridgeExecutor(payable(_executor));\n    }\n\n    modifier onlyEthChain() {\n        require(gasCurrencyIsEth, \"Gas currency is not ETH\");\n        _;\n    }\n\n    modifier onlyLzApp() {\n        require(\n            address(dcntEth) == msg.sender,\n            \"DecentEthRouter: only lz App can call\"\n        );\n        _;\n    }\n\n    modifier onlyIfWeHaveEnoughReserves(uint256 amount) {\n        require(weth.balanceOf(address(this)) > amount, \"not enough reserves\");\n        _;\n    }\n\n    modifier userDepositing(uint256 amount) {\n        balanceOf[msg.sender] += amount;\n        _;\n    }\n\n    modifier userIsWithdrawing(uint256 amount) {\n        uint256 balance = balanceOf[msg.sender];\n        require(balance >= amount, \"not enough balance\");\n        _;\n        balanceOf[msg.sender] -= amount;\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function registerDcntEth(address _addr) public onlyOwner {\n        dcntEth = IDcntEth(_addr);\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function addDestinationBridge(\n        uint16 _dstChainId,\n        address _routerAddress\n    ) public onlyOwner {\n        destinationBridges[_dstChainId] = _routerAddress;\n    }\n\n    function _getCallParams(\n        uint8 msgType,\n        address _toAddress,\n        uint16 _dstChainId,\n        uint64 _dstGasForCall,\n        bool deliverEth,\n        bytes memory additionalPayload\n    )\n        private\n        view\n        returns (\n            bytes32 destBridge,\n            bytes memory adapterParams,\n            bytes memory payload\n        )\n    {\n        uint256 GAS_FOR_RELAY = 100000;\n        uint256 gasAmount = GAS_FOR_RELAY + _dstGasForCall;\n        adapterParams = abi.encodePacked(PT_SEND_AND_CALL, gasAmount);\n        destBridge = bytes32(abi.encode(destinationBridges[_dstChainId]));\n        if (msgType == MT_ETH_TRANSFER) {\n            payload = abi.encode(msgType, msg.sender, _toAddress, deliverEth);\n        } else {\n            payload = abi.encode(\n                msgType,\n                msg.sender,\n                _toAddress,\n                deliverEth,\n                additionalPayload\n            );\n        }\n    }\n\n    function estimateSendAndCallFee(\n        uint8 msgType,\n        uint16 _dstChainId,\n        address _toAddress,\n        uint _amount,\n        uint64 _dstGasForCall,\n        bool deliverEth,\n        bytes memory payload\n    ) public view returns (uint nativeFee, uint zroFee) {\n        (\n            bytes32 destinationBridge,\n            bytes memory adapterParams,\n            bytes memory _payload\n        ) = _getCallParams(\n                msgType,\n                _toAddress,\n                _dstChainId,\n                _dstGasForCall,\n                deliverEth,\n                payload\n            );\n\n        return\n            dcntEth.estimateSendAndCallFee(\n                _dstChainId,\n                destinationBridge,\n                _amount,\n                _payload,\n                _dstGasForCall,\n                false, // useZero\n                adapterParams // Relayer adapter parameters\n                // contains packet type (send and call in this case) and gasAmount\n            );\n    }\n\n    function _bridgeWithPayload(\n        uint8 msgType,\n        uint16 _dstChainId,\n        address _toAddress,\n        uint _amount,\n        uint64 _dstGasForCall,\n        bytes memory additionalPayload,\n        bool deliverEth\n    ) internal {\n        (\n            bytes32 destinationBridge,\n            bytes memory adapterParams,\n            bytes memory payload\n        ) = _getCallParams(\n                msgType,\n                _toAddress,\n                _dstChainId,\n                _dstGasForCall,\n                deliverEth,\n                additionalPayload\n            );\n\n        ICommonOFT.LzCallParams memory callParams = ICommonOFT.LzCallParams({\n            refundAddress: payable(msg.sender),\n            zroPaymentAddress: address(0x0),\n            adapterParams: adapterParams\n        });\n\n        uint gasValue;\n        if (gasCurrencyIsEth) {\n            weth.deposit{value: _amount}();\n            gasValue = msg.value - _amount;\n        } else {\n            weth.transferFrom(msg.sender, address(this), _amount);\n            gasValue = msg.value;\n        }\n\n        dcntEth.sendAndCall{value: gasValue}(\n            address(this), // from address that has dcntEth (so DecentRouter)\n            _dstChainId,\n            destinationBridge, // toAddress\n            _amount, // amount\n            payload, //payload (will have recipients address)\n            _dstGasForCall, // dstGasForCall\n            callParams // refundAddress, zroPaymentAddress, adapterParams\n        );\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function bridgeWithPayload(\n        uint16 _dstChainId,\n        address _toAddress,\n        uint _amount,\n        bool deliverEth,\n        uint64 _dstGasForCall,\n        bytes memory additionalPayload\n    ) public payable {\n        return\n            _bridgeWithPayload(\n                MT_ETH_TRANSFER_WITH_PAYLOAD,\n                _dstChainId,\n                _toAddress,\n                _amount,\n                _dstGasForCall,\n                additionalPayload,\n                deliverEth\n            );\n    }\n\n    /// @inheritdoc IDecentEthRouter\n    function bridge(\n        uint16 _dstChainId,\n        address _toAddress,\n        uint _amount,\n        uint64 _dstGasForCall,\n        bool deliverEth // if false, delivers WETH\n    ) public payable {\n        _bridgeWithPayload(\n            MT_ETH_TRANSFER,\n            _dstChainId,\n            _toAddress,\n            _amount,\n            _dstGasForCall,\n            bytes(\"\"),\n            deliverEth\n        );\n    }\n\n    /// @inheritdoc IOFTReceiverV2\n    function onOFTReceived(\n        uint16 _srcChainId,\n        bytes calldata,\n        uint64,\n        bytes32,\n        uint _amount,\n        bytes memory _payload\n    ) external override onlyLzApp {\n        (uint8 msgType, address _from, address _to, bool deliverEth) = abi\n            .decode(_payload, (uint8, address, address, bool));\n\n        bytes memory callPayload = \"\";\n\n        if (msgType == MT_ETH_TRANSFER_WITH_PAYLOAD) {\n            (, , , , callPayload) = abi.decode(\n                _payload,\n                (uint8, address, address, bool, bytes)\n            );\n        }\n\n        emit ReceivedDecentEth("
    }
  ]
}