{
  "Title": "[M-01] QuestFactory is suspicious of the reorg attack",
  "Content": "# Lines of code\n\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/QuestFactory.sol#L75\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/QuestFactory.sol#L108\n\n\n# Vulnerability details\n\n## Description\n\nThe `createQuest` function deploys a quest contract using the `create`, where the address derivation depends only on the `QuestFactory` nonce. \n\nAt the same time, some of the chains (Polygon, Optimism, Arbitrum) to which the `QuestFactory` will be deployed are suspicious of the reorg attack.\n\n- https://polygonscan.com/blocks_forked\n\n![](https://i.imgur.com/N8tDUVX.png)\n\nHere you may be convinced that the Polygon has in practice subject to reorgs. Even more, the reorg on the picture is 1.5 minutes long. So, it is quite enough to create the quest and transfer funds to that address, especially when someone uses a script, and not doing it by hand.\n\nOptimistic rollups (Optimism/Arbitrum) are also suspect to reorgs since if someone finds a fraud the blocks will be reverted, even though the user receives a confirmation and already created a quest.\n\n## Attack scenario\n\nImagine that Alice deploys a quest, and then sends funds to it. Bob sees that the network block reorg happens and calls `createQuest`. Thus, it creates `quest` with an address to which Alice sends funds. Then Alices' transactions are executed and Alice transfers funds to Bob's controlled quest. \n\n## Impact\n\nIf users rely on the address derivation in advance or try to deploy the wallet with the same address on different EVM chains, any funds sent to the wallet could potentially be withdrawn by anyone else. All in all, it could lead to the theft of user funds.\n\n## Recommended Mitigation Steps\n\nDeploy the quest contract via `create2` with `salt` that includes `msg.sender` and `rewardTokenAddress_`.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-01-rabbithole-quest-protocol-contest",
  "Code": [
    {
      "filename": "contracts/QuestFactory.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.15;\n\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport {Erc20Quest} from './Erc20Quest.sol';\nimport {IQuestFactory} from './interfaces/IQuestFactory.sol';\nimport {Erc1155Quest} from './Erc1155Quest.sol';\nimport {RabbitHoleReceipt} from './RabbitHoleReceipt.sol';\nimport {OwnableUpgradeable} from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\n\n/// @title QuestFactory\n/// @author RabbitHole.gg\n/// @dev This contract is used to create quests and mint receipts\ncontract QuestFactory is Initializable, OwnableUpgradeable, AccessControlUpgradeable, IQuestFactory {\n    bytes32 public constant CREATE_QUEST_ROLE = keccak256('CREATE_QUEST_ROLE');\n    // storage vars. Insert new vars at the end to keep the storage layout the same.\n    struct Quest {\n        mapping(address => bool) addressMinted;\n        address questAddress;\n        uint totalParticipants;\n        uint numberMinted;\n    }\n\n    address public claimSignerAddress;\n    address public protocolFeeRecipient;\n    mapping(string => Quest) public quests;\n    RabbitHoleReceipt public rabbitholeReceiptContract;\n    mapping(address => bool) public rewardAllowlist;\n    uint public questFee;\n    uint public questIdCount;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    function initialize(\n        address claimSignerAddress_,\n        address rabbitholeReceiptContract_,\n        address protocolFeeRecipient_\n    ) public initializer {\n        __Ownable_init();\n        __AccessControl_init();\n        grantDefaultAdminAndCreateQuestRole(msg.sender);\n        claimSignerAddress = claimSignerAddress_;\n        rabbitholeReceiptContract = RabbitHoleReceipt(rabbitholeReceiptContract_);\n        setProtocolFeeRecipient(protocolFeeRecipient_);\n        setQuestFee(2_000);\n        questIdCount = 1;\n    }\n\n    /// @dev Create either an erc20 or erc1155 quest, only accounts with the CREATE_QUEST_ROLE can create quests\n    /// @param rewardTokenAddress_ The contract address of the reward token\n    /// @param endTime_ The end time of the quest\n    /// @param startTime_ The start time of the quest\n    /// @param totalParticipants_ The total amount of participants (accounts) the quest will have\n    /// @param rewardAmountOrTokenId_ The reward amount for an erc20 quest or the token id for an erc1155 quest\n    /// @param contractType_ The type of quest, either erc20 or erc1155\n    /// @param questId_ The id of the quest\n    /// @return address the quest contract address\n    function createQuest(\n        address rewardTokenAddress_,\n        uint256 endTime_,\n        uint256 startTime_,\n        uint256 totalParticipants_,\n        uint256 rewardAmountOrTokenId_,\n        string memory contractType_,\n        string memory questId_\n    ) public onlyRole(CREATE_QUEST_ROLE) returns (address) {\n        if (quests[questId_].questAddress != address(0)) revert QuestIdUsed();\n\n        if (keccak256(abi.encodePacked(contractType_)) == keccak256(abi.encodePacked('erc20'))) {\n            if (rewardAllowlist[rewardTokenAddress_] == false) revert RewardNotAllowed();\n\n            Erc20Quest newQuest = new Erc20Quest(\n                rewardTokenAddress_,\n                endTime_,\n                startTime_,\n                totalParticipants_,\n                rewardAmountOrTokenId_,\n                questId_,\n                address(rabbitholeReceiptContract),\n                questFee,\n                protocolFeeRecipient\n            );\n\n            emit QuestCreated(\n                msg.sender,\n                address(newQuest),\n                questId_,\n                contractType_,\n                rewardTokenAddress_,\n                endTime_,\n                startTime_,\n                totalParticipants_,\n                rewardAmountOrTokenId_\n            );\n            quests[questId_].questAddress = address(newQuest);\n            quests[questId_].totalParticipants = totalParticipants_;\n            newQuest.transferOwnership(msg.sender);\n            ++questIdCount;\n            return address(newQuest);\n        }\n\n        if (keccak256(abi.encodePacked(contractType_)) == keccak256(abi.encodePacked('erc1155'))) {\n            if (msg.sender != owner()) revert OnlyOwnerCanCreate1155Quest();\n\n            Erc1155Quest newQuest = new Erc1155Quest(\n                rewardTokenAddress_,\n                endTime_,\n                startTime_,\n                totalParticipants_,\n                rewardAmountOrTokenId_,\n                questId_,\n                address(rabbitholeReceiptContract)\n            );\n\n            emit QuestCreated(\n                msg.sender,\n                address(newQuest),\n                questId_,\n                contractType_,\n                rewardTokenAddress_,\n                endTime_,\n                startTime_,\n                totalParticipants_,\n                rewardAmountOrTokenId_\n            );\n            quests[questId_].questAddress = address(newQuest);\n            quests[questId_].totalParticipants = totalParticipants_;\n            newQuest.transferOwnership(msg.sender);\n            ++questIdCount;\n            return address(newQuest);\n        }\n\n        revert QuestTypeInvalid();\n    }\n\n    /// @dev grant the create quest role to an account\n    /// @param account_ The account to grant or revoke the create quest role to\n    /// @param canCreateQuest_ Boolean to grant or revoke the create quest role. True grants access\n    function changeCreateQuestRole(address account_, bool canCreateQuest_) public onlyOwner {\n        if (canCreateQuest_) {\n            _grantRole(CREATE_QUEST_ROLE, account_);\n        } else {\n            _revokeRole(CREATE_QUEST_ROLE, account_);\n        }\n    }\n\n    /// @dev grant the default admin role and the create quest role to the owner\n    /// @param account_ The account to grant admin and create quest roles\n    function grantDefaultAdminAndCreateQuestRole(address account_) internal {\n        _grantRole(DEFAULT_ADMIN_ROLE, account_);\n        _grantRole(CREATE_QUEST_ROLE, account_);\n    }\n\n    /// @dev set the claim signer address\n    /// @param claimSignerAddress_ The address of the claim signer\n    function setClaimSignerAddress(address claimSignerAddress_) public onlyOwner {\n        claimSignerAddress = claimSignerAddress_;\n    }\n\n    /// @dev set the protocol fee recipient\n    /// @param protocolFeeRecipient_ The address of the protocol fee recipient\n    function setProtocolFeeRecipient(address protocolFeeRecipient_) public onlyOwner {\n        if (protocolFeeRecipient_ == address(0)) revert AddressZeroNotAllowed();\n        protocolFeeRecipient = protocolFeeRecipient_;\n    }\n\n    /// @dev set the rabbithole receipt contract\n    /// @param rabbitholeReceiptContract_ The address of the rabbithole receipt contract\n    function setRabbitHoleReceiptContract(address rabbitholeReceiptContract_) public onlyOwner {\n        rabbitholeReceiptContract = RabbitHoleReceipt(rabbitholeReceiptContract_);\n    }\n\n    /// @dev set or remave a contract address to be used as a reward\n    /// @param rewardAddress_ The contract address to set\n    /// @param allowed_ Whether the contract address is allowed or not\n    function setRewardAllowlistAddress(address rewardAddress_, bool allowed_) public onlyOwner {\n        rewardAllowlist[rewardAddress_] = allowed_;\n    }\n\n    /// @dev set the quest fee\n    /// @notice the quest fee should be in Basis Point units: https://www.investopedia.com/terms/b/basispoint.asp\n    /// @param questFee_ The quest fee value\n    function setQuestFee(uint256 questFee_) public onlyOwner {\n        if (questFee_ > 10_000) revert QuestFeeTooHigh();\n        questFee = questFee_;\n    }\n\n    /// @dev return the number of minted receipts for a quest\n    /// @param questId_ The id of the quest\n    function getNumberMinted(string memory questId_) external view returns (uint) {\n        return quests[questId_].numberMinted;\n    }\n\n    /// @dev return data in the quest struct for a questId\n    /// @param questId_ The id of the quest\n    function questInfo(string memory questId_) external view returns (address, uint, uint) {\n        return (\n            quests[questId_].questAddress,\n            quests[questId_].totalParticipants,\n            quests[questId_].numberMinted\n        );\n    }\n\n    /// @dev recover the signer from a hash and signature\n    /// @param hash_ The hash of the message\n    /// @param signature_ The signature of the hash\n    function recoverSigner(bytes32 hash_, bytes memory signature_) public pure returns (address) {\n        bytes32 messageDigest = keccak256(abi.encodePacked('\\x19Ethereum Signed Message:\\n32', hash_));\n        return ECDSAUpgradeable.recover(messageDigest, signature_);\n    }\n\n    /// @dev mint a RabbitHole Receipt. Note: this contract must be set as Minter on the receipt contract\n    /// @param questId_ The id of the quest\n    /// @param hash_ The hash of the message\n    /// @param signature_ The signature of the hash\n    function mintReceipt(string memory questId_, bytes32 hash_, bytes memory signature_) public {\n        if (quests[questId_].numberMinted + 1 > quests[questId_].totalParticipants) revert OverMaxAllowedToMint();\n        if (quests[questId_].addressMinted[msg.sender] == true) revert AddressAlreadyMinted();\n        if (keccak256(abi.encodePacked(msg.sender, questId_)) != hash_) revert InvalidHash();\n        if (recoverSigner(hash_, signature_) != claimSignerAddress) revert AddressNotSigned();\n\n        quests[questId_].addressMinted[msg.sender] = true;\n        quests[questId_].numberMinted++;\n        emit ReceiptMinted(msg.sender, questId_);\n        rabbitholeReceiptContract.mint(msg.sender, questId_);\n    }\n}"
    },
    {
      "filename": "contracts/QuestFactory.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.15;\n\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport {Erc20Quest} from './Erc20Quest.sol';\nimport {IQuestFactory} from './interfaces/IQuestFactory.sol';\nimport {Erc1155Quest} from './Erc1155Quest.sol';\nimport {RabbitHoleReceipt} from './RabbitHoleReceipt.sol';\nimport {OwnableUpgradeable} from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\n\n/// @title QuestFactory\n/// @author RabbitHole.gg\n/// @dev This contract is used to create quests and mint receipts\ncontract QuestFactory is Initializable, OwnableUpgradeable, AccessControlUpgradeable, IQuestFactory {\n    bytes32 public constant CREATE_QUEST_ROLE = keccak256('CREATE_QUEST_ROLE');\n    // storage vars. Insert new vars at the end to keep the storage layout the same.\n    struct Quest {\n        mapping(address => bool) addressMinted;\n        address questAddress;\n        uint totalParticipants;\n        uint numberMinted;\n    }\n\n    address public claimSignerAddress;\n    address public protocolFeeRecipient;\n    mapping(string => Quest) public quests;\n    RabbitHoleReceipt public rabbitholeReceiptContract;\n    mapping(address => bool) public rewardAllowlist;\n    uint public questFee;\n    uint public questIdCount;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    function initialize(\n        address claimSignerAddress_,\n        address rabbitholeReceiptContract_,\n        address protocolFeeRecipient_\n    ) public initializer {\n        __Ownable_init();\n        __AccessControl_init();\n        grantDefaultAdminAndCreateQuestRole(msg.sender);\n        claimSignerAddress = claimSignerAddress_;\n        rabbitholeReceiptContract = RabbitHoleReceipt(rabbitholeReceiptContract_);\n        setProtocolFeeRecipient(protocolFeeRecipient_);\n        setQuestFee(2_000);\n        questIdCount = 1;\n    }\n\n    /// @dev Create either an erc20 or erc1155 quest, only accounts with the CREATE_QUEST_ROLE can create quests\n    /// @param rewardTokenAddress_ The contract address of the reward token\n    /// @param endTime_ The end time of the quest\n    /// @param startTime_ The start time of the quest\n    /// @param totalParticipants_ The total amount of participants (accounts) the quest will have\n    /// @param rewardAmountOrTokenId_ The reward amount for an erc20 quest or the token id for an erc1155 quest\n    /// @param contractType_ The type of quest, either erc20 or erc1155\n    /// @param questId_ The id of the quest\n    /// @return address the quest contract address\n    function createQuest(\n        address rewardTokenAddress_,\n        uint256 endTime_,\n        uint256 startTime_,\n        uint256 totalParticipants_,\n        uint256 rewardAmountOrTokenId_,\n        string memory contractType_,\n        string memory questId_\n    ) public onlyRole(CREATE_QUEST_ROLE) returns (address) {\n        if (quests[questId_].questAddress != address(0)) revert QuestIdUsed();\n\n        if (keccak256(abi.encodePacked(contractType_)) == keccak256(abi.encodePacked('erc20'))) {\n            if (rewardAllowlist[rewardTokenAddress_] == false) revert RewardNotAllowed();\n\n            Erc20Quest newQuest = new Erc20Quest(\n                rewardTokenAddress_,\n                endTime_,\n                startTime_,\n                totalParticipants_,\n                rewardAmountOrTokenId_,\n                questId_,\n                address(rabbitholeReceiptContract),\n                questFee,\n                protocolFeeRecipient\n            );\n\n            emit QuestCreated(\n                msg.sender,\n                address(newQuest),\n                questId_,\n                contractType_,\n                rewardTokenAddress_,\n                endTime_,\n                startTime_,\n                totalParticipants_,\n                rewardAmountOrTokenId_\n            );\n            quests[questId_].questAddress = address(newQuest);\n            quests[questId_].totalParticipants = totalParticipants_;\n            newQuest.transferOwnership(msg.sender);\n            ++questIdCount;\n            return address(newQuest);\n        }\n\n        if (keccak256(abi.encodePacked(contractType_)) == keccak256(abi.encodePacked('erc1155'))) {\n            if (msg.sender != owner()) revert OnlyOwnerCanCreate1155Quest();\n\n            Erc1155Quest newQuest = new Erc1155Quest(\n                rewardTokenAddress_,\n                endTime_,\n                startTime_,\n                totalParticipants_,\n                rewardAmountOrTokenId_,\n                questId_,\n                address(rabbitholeReceiptContract)\n            );\n\n            emit QuestCreated(\n                msg.sender,\n                address(newQuest),\n                questId_,\n                contractType_,\n                rewardTokenAddress_,\n                endTime_,\n                startTime_,\n                totalParticipants_,\n                rewardAmountOrTokenId_\n            );\n            quests[questId_].questAddress = address(newQuest);\n            quests[questId_].totalParticipants = totalParticipants_;\n            newQuest.transferOwnership(msg.sender);\n            ++questIdCount;\n            return address(newQuest);\n        }\n\n        revert QuestTypeInvalid();\n    }\n\n    /// @dev grant the create quest role to an account\n    /// @param account_ The account to grant or revoke the create quest role to\n    /// @param canCreateQuest_ Boolean to grant or revoke the create quest role. True grants access\n    function changeCreateQuestRole(address account_, bool canCreateQuest_) public onlyOwner {\n        if (canCreateQuest_) {\n            _grantRole(CREATE_QUEST_ROLE, account_);\n        } else {\n            _revokeRole(CREATE_QUEST_ROLE, account_);\n        }\n    }\n\n    /// @dev grant the default admin role and the create quest role to the owner\n    /// @param account_ The account to grant admin and create quest roles\n    function grantDefaultAdminAndCreateQuestRole(address account_) internal {\n        _grantRole(DEFAULT_ADMIN_ROLE, account_);\n        _grantRole(CREATE_QUEST_ROLE, account_);\n    }\n\n    /// @dev set the claim signer address\n    /// @param claimSignerAddress_ The address of the claim signer\n    function setClaimSignerAddress(address claimSignerAddress_) public onlyOwner {\n        claimSignerAddress = claimSignerAddress_;\n    }\n\n    /// @dev set the protocol fee recipient\n    /// @param protocolFeeRecipient_ The address of the protocol fee recipient\n    function setProtocolFeeRecipient(address protocolFeeRecipient_) public onlyOwner {\n        if (protocolFeeRecipient_ == address(0)) revert AddressZeroNotAllowed();\n        protocolFeeRecipient = protocolFeeRecipient_;\n    }\n\n    /// @dev set the rabbithole receipt contract\n    /// @param rabbitholeReceiptContract_ The address of the rabbithole receipt contract\n    function setRabbitHoleReceiptContract(address rabbitholeReceiptContract_) public onlyOwner {\n        rabbitholeReceiptContract = RabbitHoleReceipt(rabbitholeReceiptContract_);\n    }\n\n    /// @dev set or remave a contract address to be used as a reward\n    /// @param rewardAddress_ The contract address to set\n    /// @param allowed_ Whether the contract address is allowed or not\n    function setRewardAllowlistAddress(address rewardAddress_, bool allowed_) public onlyOwner {\n        rewardAllowlist[rewardAddress_] = allowed_;\n    }\n\n    /// @dev set the quest fee\n    /// @notice the quest fee should be in Basis Point units: https://www.investopedia.com/terms/b/basispoint.asp\n    /// @param questFee_ The quest fee value\n    function setQuestFee(uint256 questFee_) public onlyOwner {\n        if (questFee_ > 10_000) revert QuestFeeTooHigh();\n        questFee = questFee_;\n    }\n\n    /// @dev return the number of minted receipts for a quest\n    /// @param questId_ The id of the quest\n    function getNumberMinted(string memory questId_) external view returns (uint) {\n        return quests[questId_].numberMinted;\n    }\n\n    /// @dev return data in the quest struct for a questId\n    /// @param questId_ The id of the quest\n    function questInfo(string memory questId_) external view returns (address, uint, uint) {\n        return (\n            quests[questId_].questAddress,\n            quests[questId_].totalParticipants,\n            quests[questId_].numberMinted\n        );\n    }\n\n    /// @dev recover the signer from a hash and signature\n    /// @param hash_ The hash of the message\n    /// @param signature_ The signature of the hash\n    function recoverSigner(bytes32 hash_, bytes memory signature_) public pure returns (address) {\n        bytes32 messageDigest = keccak256(abi.encodePacked('\\x19Ethereum Signed Message:\\n32', hash_));\n        return ECDSAUpgradeable.recover(messageDigest, signature_);\n    }\n\n    /// @dev mint a RabbitHole Receipt. Note: this contract must be set as Minter on the receipt contract\n    /// @param questId_ The id of the quest\n    /// @param hash_ The hash of the message\n    /// @param signature_ The signature of the hash\n    function mintReceipt(string memory questId_, bytes32 hash_, bytes memory signature_) public {\n        if (quests[questId_].numberMinted + 1 > quests[questId_].totalParticipants) revert OverMaxAllowedToMint();\n        if (quests[questId_].addressMinted[msg.sender] == true) revert AddressAlreadyMinted();\n        if (keccak256(abi.encodePacked(msg.sender, questId_)) != hash_) revert InvalidHash();\n        if (recoverSigner(hash_, signature_) != claimSignerAddress) revert AddressNotSigned();\n\n        quests[questId_].addressMinted[msg.sender] = true;\n        quests[questId_].numberMinted++;\n        emit ReceiptMinted(msg.sender, questId_);\n        rabbitholeReceiptContract.mint(msg.sender, questId_);\n    }\n}"
    }
  ]
}