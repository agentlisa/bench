{
  "Title": "[L09] Misleading comments and typographical errors",
  "Content": "Several docstrings and inline comments throughout the code base were found to be erroneous and / or incomplete and should be fixed. In particular:\n\n\n* In [line 37](https://github.com/celo-org/celo-monorepo/blob/b2f0a58fcc7667d41585123aae5b24c47aa894f6/packages/protocol/contracts/common/TransferWhitelist.sol#L37) from the `TransferWhitelist.sol` file it states “removedAddress The address to add” instead of “removedAddress The address to remove”.\n* In [line 185](https://github.com/celo-org/celo-monorepo/blob/b2f0a58fcc7667d41585123aae5b24c47aa894f6/packages/protocol/contracts/identity/Attestations.sol#L185) of the `Attestations.sol` file it states “attestion” instead of “attestation”.\n* In [lines 919 to 920](https://github.com/celo-org/celo-monorepo/blob/b2f0a58fcc7667d41585123aae5b24c47aa894f6/packages/protocol/contracts/governance/Validators.sol#L919-L920) of `Validators.sol` file, the comment states `Add a bit of \"wiggle room\" to accommodate the fact that vote activation can result in a 1 // wei rounding error`. However, in [line 921](https://github.com/celo-org/celo-monorepo/blob/b2f0a58fcc7667d41585123aae5b24c47aa894f6/packages/protocol/contracts/governance/Validators.sol#L921) the value added as “wiggle room” is 10 wei instead of the 1 stated in the comment.\n\n\nClear docstrings are fundamental to outline the intentions of the code. Mismatches between them and the implementation can lead to serious misconceptions about how the system is expected to behave. Therefore, consider fixing these errors to avoid confusions in developers, users, auditors alike.\n\n\n***Update**: Fixed on [pull request 4929](https://github.com/celo-org/celo-monorepo/pull/4929/files).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/common/TransferWhitelist.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"./UsingRegistry.sol\";\n\n/**\n * @title Holds a whitelist of addresses for which transfers should not be\n * frozen so that network initialization can take place.\n */\ncontract TransferWhitelist is Ownable, UsingRegistry {\n  using SafeMath for uint256;\n\n  address[] private directlyWhitelistedAddresses;\n  bytes32[] public whitelistedContractIdentifiers;\n\n  event WhitelistedAddress(address indexed addr);\n  event WhitelistedAddressRemoved(address indexed addr);\n  event WhitelistedContractIdentifier(bytes32 indexed contractIdentifier);\n\n  constructor(address registryAddress) public {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n  }\n\n  /**\n   * @notice Add an address to the whitelist.\n   * @param newAddress The address to add.\n   */\n  function whitelistAddress(address newAddress) public onlyOwner {\n    directlyWhitelistedAddresses.push(newAddress);\n    emit WhitelistedAddress(newAddress);\n  }\n\n  /**\n   * @notice Remove an address from the whitelist.\n   * @param removedAddress The address to add.\n   * @param index Index of address in the whitelist.\n   */\n  function removeAddress(address removedAddress, uint256 index) external onlyOwner {\n    require(index < directlyWhitelistedAddresses.length, \"Whitelist index out of range\");\n    require(directlyWhitelistedAddresses[index] == removedAddress, \"Bad whitelist index\");\n    uint256 tailIndex = directlyWhitelistedAddresses.length.sub(1);\n    if (index != tailIndex) {\n      directlyWhitelistedAddresses[index] = directlyWhitelistedAddresses[tailIndex];\n    }\n    directlyWhitelistedAddresses.length = tailIndex;\n    emit WhitelistedAddressRemoved(removedAddress);\n  }\n\n  /**\n   * @notice Adds the registry id of a whitelisted contract.\n   * @param contractIdentifier The id of the contract to be added.\n   */\n  function whitelistRegisteredContract(bytes32 contractIdentifier) external onlyOwner {\n    require(\n      registry.getAddressFor(contractIdentifier) != address(0),\n      \"contractIdentifier does not correspond to a registered address\"\n    );\n    whitelistedContractIdentifiers.push(contractIdentifier);\n    emit WhitelistedContractIdentifier(contractIdentifier);\n  }\n\n  /**\n   * @notice Gets the number of registered contracts\n   * @return The length of whitelistedContractIdentifiers\n   */\n  function getNumberOfWhitelistedContractIdentifiers() external view returns (uint256 length) {\n    return whitelistedContractIdentifiers.length;\n  }\n\n  /**\n   * @notice Set the whitelist of addresses.\n   * @param  _whitelist The new whitelist of addresses.\n   */\n  function setDirectlyWhitelistedAddresses(address[] calldata _whitelist) external onlyOwner {\n    for (uint256 i = 0; i < directlyWhitelistedAddresses.length; i = i.add(1)) {\n      emit WhitelistedAddressRemoved(directlyWhitelistedAddresses[i]);\n    }\n    directlyWhitelistedAddresses.length = 0;\n    for (uint256 i = 0; i < _whitelist.length; i = i.add(1)) {\n      whitelistAddress(_whitelist[i]);\n    }\n  }\n\n  /**\n   * @notice Set the whitelist of registered contracts.\n   * @param  _registeredContracts The new whitelist of registered contract ids.\n   */\n  function setWhitelistedContractIdentifiers(bytes32[] calldata _registeredContracts)\n    external\n    onlyOwner\n  {\n    whitelistedContractIdentifiers = _registeredContracts;\n  }\n\n  /**\n   * @notice Appends the addresses of registered contracts to the\n   * whitelist before returning the list.\n   * @dev If a registry id is not yet registered, the null address\n   * will be appended to the list instead.\n   * @return  The full whitelist of addresses.\n   */\n  function getWhitelist() external view returns (address[] memory) {\n    uint256 len = directlyWhitelistedAddresses.length.add(whitelistedContractIdentifiers.length);\n    address[] memory _whitelist = new address[](len);\n    uint256 i = 0;\n    while (i < directlyWhitelistedAddresses.length) {\n      _whitelist[i] = directlyWhitelistedAddresses[i];\n      i = i.add(1);\n    }\n    for (uint256 j = 0; j < whitelistedContractIdentifiers.length; j = j.add(1)) {\n      _whitelist[i] = registry.getAddressFor(whitelistedContractIdentifiers[j]);\n      i = i.add(1);\n    }\n    return _whitelist;\n  }\n\n  /**\n   * @notice Clears all data (storage and bytecode) at this contract's address.\n   * @dev The balance of this contract is returned to the owner.\n   */\n  function selfDestruct() external onlyOwner {\n    selfdestruct(msg.sender);\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/identity/Attestations.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-solidity/contracts/utils/SafeCast.sol\";\n\nimport \"./interfaces/IAttestations.sol\";\nimport \"./interfaces/IRandom.sol\";\nimport \"../common/interfaces/IAccounts.sol\";\nimport \"../common/interfaces/ICeloVersionedContract.sol\";\n\nimport \"../common/Initializable.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/Signatures.sol\";\nimport \"../common/UsingPrecompiles.sol\";\nimport \"../common/interfaces/ICeloVersionedContract.sol\";\nimport \"../common/libraries/ReentrancyGuard.sol\";\n\n/**\n * @title Contract mapping identifiers to accounts\n */\ncontract Attestations is\n  IAttestations,\n  ICeloVersionedContract,\n  Ownable,\n  Initializable,\n  UsingRegistry,\n  ReentrancyGuard,\n  UsingPrecompiles\n{\n  using SafeMath for uint256;\n  using SafeCast for uint256;\n\n  enum AttestationStatus { None, Incomplete, Complete }\n\n  struct Attestation {\n    AttestationStatus status;\n    // For outstanding attestations, this is the block number of the request.\n    // For completed attestations, this is the block number of the attestation completion.\n    uint32 blockNumber;\n    // The token with which attestation request fees were paid.\n    address attestationRequestFeeToken;\n  }\n\n  // Stores attestations state for a single (identifier, account address) pair.\n  struct AttestedAddress {\n    // Total number of requested attestations.\n    uint32 requested;\n    // Total number of completed attestations.\n    uint32 completed;\n    // List of selected issuers responsible for attestations. The length of this list\n    // might be smaller than `requested` (which represents the total number of requested\n    // attestations) if users are not calling `selectIssuers` on unselected requests.\n    address[] selectedIssuers;\n    // State of each attestation keyed by issuer.\n    mapping(address => Attestation) issuedAttestations;\n  }\n\n  struct UnselectedRequest {\n    // The block at which the attestations were requested.\n    uint32 blockNumber;\n    // The number of attestations that were requested.\n    uint32 attestationsRequested;\n    // The token with which attestation request fees were paid in this request.\n    address attestationRequestFeeToken;\n  }\n\n  struct IdentifierState {\n    // All account addresses associated with this identifier.\n    address[] accounts;\n    // Keeps the state of attestations for account addresses for this identifier.\n    mapping(address => AttestedAddress) attestations;\n    // Temporarily stores attestation requests for which issuers should be selected by the account.\n    mapping(address => UnselectedRequest) unselectedRequests;\n  }\n\n  mapping(bytes32 => IdentifierState) identifiers;\n\n  // The duration in blocks in which an attestation can be completed from the block in which the\n  // attestation was requested.\n  uint256 public attestationExpiryBlocks;\n\n  // The duration to wait until selectIssuers can be called for an attestation request.\n  uint256 public selectIssuersWaitBlocks;\n\n  // Limit the maximum number of attestations that can be requested\n  uint256 public maxAttestations;\n\n  // The fees that are associated with attestations for a particular token.\n  mapping(address => uint256) public attestationRequestFees;\n\n  // Maps a token and attestation issuer to the amount that they're owed.\n  mapping(address => mapping(address => uint256)) public pendingWithdrawals;\n\n  // Attestation transfer approvals, keyed by user and keccak(identifier, from, to)\n  mapping(address => mapping(bytes32 => bool)) public transferApprovals;\n\n  event AttestationsRequested(\n    bytes32 indexed identifier,\n    address indexed account,\n    uint256 attestationsRequested,\n    address attestationRequestFeeToken\n  );\n\n  event AttestationIssuerSelected(\n    bytes32 indexed identifier,\n    address indexed account,\n    address indexed issuer,\n    address attestationRequestFeeToken\n  );\n\n  event AttestationCompleted(\n    bytes32 indexed identifier,\n    address indexed account,\n    address indexed issuer\n  );\n\n  event Withdrawal(address indexed account, address indexed token, uint256 amount);\n  event AttestationExpiryBlocksSet(uint256 value);\n  event AttestationRequestFeeSet(address indexed token, uint256 value);\n  event SelectIssuersWaitBlocksSet(uint256 value);\n  event MaxAttestationsSet(uint256 value);\n  event AttestationsTransferred(\n    bytes32 indexed identifier,\n    address indexed fromAccount,\n    address indexed toAccount\n  );\n  event TransferApproval(\n    address indexed approver,\n    bytes32 indexed indentifier,\n    address from,\n    address to,\n    bool approved\n  );\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param registryAddress The address of the registry core smart contract.\n   * @param _attestationExpiryBlocks The new limit on blocks allowed to come between requesting\n   * an attestation and completing it.\n   * @param _selectIssuersWaitBlocks The wait period in blocks to call selectIssuers on attestation\n   * requests.\n   * @param attestationRequestFeeTokens The address of tokens that fees should be payable in.\n   * @param attestationRequestFeeValues The corresponding fee values.\n   */\n  function initialize(\n    address registryAddress,\n    uint256 _attestationExpiryBlocks,\n    uint256 _selectIssuersWaitBlocks,\n    uint256 _maxAttestations,\n    address[] calldata attestationRequestFeeTokens,\n    uint256[] calldata attestationRequestFeeValues\n  ) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setAttestationExpiryBlocks(_attestationExpiryBlocks);\n    setSelectIssuersWaitBlocks(_selectIssuersWaitBlocks);\n    setMaxAttestations(_maxAttestations);\n\n    require(\n      attestationRequestFeeTokens.length > 0 &&\n        attestationRequestFeeTokens.length == attestationRequestFeeValues.length,\n      \"attestationRequestFeeTokens specification was invalid\"\n    );\n    for (uint256 i = 0; i < attestationRequestFeeTokens.length; i = i.add(1)) {\n      setAttestationRequestFee(attestationRequestFeeTokens[i], attestationRequestFeeValues[i]);\n    }\n  }\n\n  /**\n   * @notice Returns the storage, major, minor, and patch version of the contract.\n   * @return The storage, major, minor, and patch version of the contract.\n   */\n  function getVersionNumber() external pure returns (uint256, uint256, uint256, uint256) {\n    return (1, 1, 1, 0);\n  }\n\n  /**\n   * @notice Commit to the attestation request of a hashed identifier.\n   * @param identifier The hash of the identifier to be attested.\n   * @param attestationsRequested The number of requested attestations for this request.\n   * @param attestationRequestFeeToken The address of the token with which the attestation fee will\n   * be paid.\n   * @dev Note that if an attestion expires before it is completed, the fee is forfeited. This is\n   * to prevent folks from attacking validators by requesting attestations that they do not\n   * complete, and to increase the cost of validators attempting to manipulate the attestations\n   * protocol.\n   */\n  function request(\n    bytes32 identifier,\n    uint256 attestationsRequested,\n    address attestationRequestFeeToken\n  ) external nonReentrant {\n    require(\n      attestationRequestFees[attestationRequestFeeToken] > 0,\n      \"Invalid attestationRequestFeeToken\"\n    );\n    require(\n      IERC20(attestationRequestFeeToken).transferFrom(\n        msg.sender,\n        address(this),\n        attestationRequestFees[attestationRequestFeeToken].mul(attestationsRequested)\n      ),\n      \"Transfer of attestation request fees failed\"\n    );\n\n    require(attestationsRequested > 0, \"You have to request at least 1 attestation\");\n    require(attestationsRequested <= maxAttestations, \"Too many attestations requested\");\n\n    IdentifierState storage state = identifiers[identifier];\n\n    require(\n      state.unselectedRequests[msg.sender].blockNumber == 0 ||\n        isAttestationExpired(state.unselectedRequests[msg.sender].blockNumber) ||\n        !isAttestationRequestSelectable(state.unselectedRequests[msg.sender].blockNumber),\n      \"There exists an unexpired, unselected attestation request\"\n    );\n\n    state.unselectedRequests[msg.sender].blockNumber = block.number.toUint32();\n    state.unselectedRequests[msg.sender].attestationsRequested = attestationsRequested.toUint32();\n    state.unselectedRequests[msg.sender].attestationRequestFeeToken = attestationRequestFeeToken;\n\n    state.attestations[msg.sender].requested = uint256(state.attestations[msg.sender].requested)\n      .add(attestationsRequested)\n      .toUint32();\n\n    emit AttestationsRequested(\n      identifier,\n      msg.sender,\n      attestationsRequested,\n      attestationRequestFeeToken\n    );\n  }\n\n  /**\n   * @notice Selects the issuers for the most recent attestation request.\n   * @param identifier The hash of the identifier to be attested.\n   */\n  function selectIssuers(bytes32 identifier) external {\n    IdentifierState storage state = identifiers[identifier];\n\n    require(\n      state.unselectedRequests[msg.sender].blockNumber > 0,\n      \"No unselected attestation request to select issuers for\"\n    );\n\n    require(\n      !isAttestationExpired(state.unselectedRequests[msg.sender].blockNumber),\n      \"The attestation request has expired\"\n    );\n\n    addIncompleteAttestations(identifier);\n    delete state.unselectedRequests[msg.sender];\n  }\n\n  /**\n   * @notice Submit the secret message sent by the issuer to complete the attestation request.\n   * @param identifier The hash of the identifier for this attestation.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Throws if there is no matching outstanding attestation request.\n   * @dev Throws if the attestation window has passed.\n   */\n  function complete(bytes32 identifier, uint8 v, bytes32 r, bytes32 s) external {\n    address issuer = validateAttestationCode(identifier, msg.sender, v, r, s);\n\n    Attestation storage attestation = identifiers[identifier].attestations[msg.sender]\n      .issuedAttestations[issuer];\n\n    address token = attestation.attestationRequestFeeToken;\n\n    // solhint-disable-next-line not-rely-on-time\n    attestation.blockNumber = block.number.toUint32();\n    attestation.status = AttestationStatus.Complete;\n    delete attestation.attestationRequestFeeToken;\n    AttestedAddress storage attestedAddress = identifiers[identifier].attestations[msg.sender];\n    require(\n      attestedAddress.completed < attestedAddress.completed + 1,\n      \"SafeMath32 integer overflow\"\n    );\n    attestedAddress.completed = attestedAddress.completed + 1;\n\n    pendingWithdrawals[token][issuer] = pendingWithdrawals[token][issuer].add(\n      attestationRequestFees[token]\n    );\n\n    IdentifierState storage state = identifiers[identifier];\n    if (identifiers[identifier].attestations[msg.sender].completed == 1) {\n      state.accounts.push(msg.sender);\n    }\n\n    emit AttestationCompleted(identifier, msg.sender, issuer);\n  }\n\n  /**\n   * @notice Revokes an account for an identifier.\n   * @param identifier The identifier for which to revoke.\n   * @param index The index of the account in the accounts array.\n   */\n  function revoke(bytes32 identifier, uint256 index) external {\n    uint256 numAccounts = identifiers[identifier].accounts.length;\n    require(index < numAccounts, \"Index is invalid\");\n    require(\n      msg.sender == identifiers[identifier].accounts[index],\n      \"Index does not match msg.sender\"\n    );\n\n    uint256 newNumAccounts = numAccounts.sub(1);\n    if (index != newNumAccounts) {\n      identifiers[identifier].accounts[index] = identifiers[identifier].accounts[newNumAccounts];\n    }\n    identifiers[identifier].accounts[newNumAccounts] = address(0x0);\n    identifiers[identifier].accounts.length = identifiers[identifier].accounts.length.sub(1);\n  }\n\n  /**\n   * @notice Allows issuers to withdraw accumulated attestation rewards.\n   * @param token The address of the token that will be withdrawn.\n   * @dev Throws if msg.sender does not have any rewards to withdraw.\n   */\n  function withdraw(address token) external {\n    address issuer = getAccounts().attestationSignerToAccount(msg.sender);\n    uint256 value = pendingWithdrawals[token][issuer];\n    require(value > 0, \"value was negative/zero\");\n    pendingWithdrawals[token][issuer] = 0;\n    require(IERC20(token).transfer(issuer, value), \"token transfer failed\");\n    emit Withdrawal(issuer, token, value);\n  }\n\n  /**\n   * @notice Returns the unselected attestation request for an identifier/account pair, if any.\n   * @param identifier Hash of the identifier.\n   * @param account Address of the account.\n   * @return [\n   *           Block number at which was requested,\n   *           Number of unselected requests,\n   *           Address of the token with which this attestation request was paid for\n   *         ]\n   */\n  function getUnselectedRequest(bytes32 identifier, address account)\n    external\n    view\n    returns (uint32, uint32, address)\n  {\n    return (\n      identifiers[identifier].unselectedRequests[account].blockNumber,\n      identifiers[identifier].unselectedRequests[account].attestationsRequested,\n      identifiers[identifier].unselectedRequests[account].attestationRequestFeeToken\n    );\n  }\n\n  /**\n   * @notice Returns selected attestation issuers for a identifier/account pair.\n   * @param identifier Hash of the identifier.\n   * @param account Address of the account.\n   * @return Addresses of the selected attestation issuers.\n   */\n  function getAttestationIssuers(bytes32 identifier, address account)\n    external\n    view\n    returns (address[] memory)\n  {\n    return identifiers[identifier].attestations[account].selectedIssuers;\n  }\n\n  /**\n   * @notice Returns attestation stats for a identifier/account pair.\n   * @param identifier Hash of the identifier.\n   * @param account Address of the account.\n   * @return [Number of completed attestations, Number of total requested attestations]\n   */\n  function getAttestationStats(bytes32 identifier, address account)\n    external\n    view\n    returns (uint32, uint32)\n  {\n    return (\n      identifiers[identifier].attestations[account].completed,\n      identifiers[identifier].attestations[account].requested\n    );\n  }\n\n  /**\n   * @notice Batch lookup function to determine attestation stats for a list of identifiers.\n   * @param identifiersToLookup Array of n identifiers.\n   * @return [0] Array of number of matching accounts per identifier.\n   * @return [1] Array of sum([0]) matching walletAddresses.\n   * @return [2] Array of sum([0]) numbers indicating the completions for each account.\n   * @return [3] Array of sum([0]) numbers indicating the total number of requested\n                 attestations for each account.\n   */\n  function batchGetAttestationStats(bytes32[] calldata identifiersToLookup)\n    external\n    view\n    returns (uint256[] memory, address[] memory, uint64[] memory, uint64[] memory)\n  {\n    require(identifiersToLookup.length > 0, \"You have to pass at least one identifier\");\n\n    uint256[] memory matches;\n    address[] memory addresses;\n\n    (matches, addresses) = batchlookupAccountsForIdentifier(identifiersToLookup);\n\n    uint64[] memory completed = new uint64[](addresses.length);\n    uint64[] memory total = new uint64[](addresses.length);\n\n    uint256 currentIndex = 0;\n    for (uint256 i = 0; i < identifiersToLookup.length; i = i.add(1)) {\n      address[] memory addrs = identifiers[identifiersToLookup[i]].accounts;\n      for (uint256 matchIndex = 0; matchIndex < matches[i]; matchIndex = matchIndex.add(1)) {\n        addresses[currentIndex] = getAccounts().getWalletAddress(addrs[matchIndex]);\n        completed[currentIndex] = identifiers[identifiersToLookup[i]]\n          .attestations[addrs[matchIndex]]\n          .completed;\n        total[currentIndex] = identifiers[identifiersToLookup[i]].attestations[addrs[matchIndex]]\n          .requested;\n        currentIndex = currentIndex.add(1);\n      }\n    }\n\n    return (matches, addresses, completed, total);\n  }\n\n  /**\n   * @notice Returns the state of a specific attestation.\n   * @param identifier Hash of the identifier.\n   * @param account Address of the account.\n   * @param issuer Address of the issuer.\n   * @return [\n   *           Status of the attestation,\n   *           Block number of request/completion the attestation,\n   *           Address of the token with which this attestation request was paid for\n   *         ]\n   */\n  function getAttestationState(bytes32 identifier, address account, address issuer)\n    external\n    view\n    returns (uint8, uint32, address)\n  {\n    Attestation storage attestation = identifiers[identifier].attestations[account]\n      .issuedAttestations[issuer];\n    return (\n      uint8(attestation.status),\n      attestation.blockNumber,\n      attestation.attestationRequestFeeToken\n    );\n\n  }\n\n  /**\n    * @notice Returns the state of all attestations that are completable\n    * @param identifier Hash of the identifier.\n    * @param account Address of the account.\n    * @return ( blockNumbers[] - Block number of request/completion the attestation,\n    *           issuers[] - Address of the issuer,\n    *           stringLengths[] - The length of each metadataURL string for each issuer,\n    *           stringData - All strings concatenated\n    *         )\n    */\n  function getCompletableAttestations(bytes32 identifier, address account)\n    external\n    view\n    returns (uint32[] memory, address[] memory, uint256[] memory, bytes memory)\n  {\n    AttestedAddress storage state = identifiers[identifier].attestations[account];\n    address[] storage issuers = state.selectedIssuers;\n\n    uint256 num = 0;\n    for (uint256 i = 0; i < issuers.length; i = i.add(1)) {\n      if (isAttestationCompletable(state.issuedAttestations[issuers[i]])) {\n        num = num.add(1);\n      }\n    }\n\n    uint32[] memory blockNumbers = new uint32[](num);\n    address[] memory completableIssuers = new address[](num);\n\n    uint256 pointer = 0;\n    for (uint256 i = 0; i < issuers.length; i = i.add(1)) {\n      if (isAttestationCompletable(state.issuedAttestations[issuers[i]])) {\n        blockNumbers[pointer] = state.issuedAttestations[issuers[i]].blockNumber;\n        completableIssuers[pointer] = issuers[i];\n        pointer = pointer.add(1);\n      }\n    }\n\n    uint256[] memory stringLengths;\n    bytes memory stringData;\n    (stringLengths, stringData) = getAccounts().batchGetMetadataURL(completableIssuers);\n    return (blockNumbers, completableIssuers, stringLengths, stringData);\n  }\n\n  /**\n   * @notice Returns the fee set for a particular token.\n   * @param token Address of the attestationRequestFeeToken.\n   * @return The fee.\n   */\n  function getAttestationRequestFee(address token) external view returns (uint256) {\n    return attestationRequestFees[token];\n  }\n\n  /**\n   * @notice Updates the fee  for a particular token.\n   * @param token The address of the attestationRequestFeeToken.\n   * @param fee The fee in 'token' that is required for each attestation.\n   */\n  function setAttestationRequestFee(address token, uint256 fee) public onlyOwner {\n    require(fee > 0, \"You have to specify a fee greater than 0\");\n    attestationRequestFees[token] = fee;\n    emit AttestationRequestFeeSet(token, fee);\n  }\n\n  /**\n   * @notice Updates 'attestationExpiryBlocks'.\n   * @param _attestationExpiryBlocks The new limit on blocks allowed to come between requesting\n   * an attestation and completing it.\n   */\n  function setAttestationExpiryBlocks(uint256 _attestationExpiryBlocks) public onlyOwner {\n    require(_attestationExpiryBlocks > 0, \"attestationExpiryBlocks has to be greater than 0\");\n    attestationExpiryBlocks = _attestationExpiryBlocks;\n    emit AttestationExpiryBlocksSet(_attestationExpiryBlocks);\n  }\n\n  /**\n   * @notice Updates 'selectIssuersWaitBlocks'.\n   * @param _selectIssuersWaitBlocks The wait period in blocks to call selectIssuers on attestation\n   *                                 requests.\n   */\n  function setSelectIssuersWaitBlocks(uint256 _selectIssuersWaitBlocks) public onlyOwner {\n    require(_selectIssuersWaitBlocks > 0, \"selectIssuersWaitBlocks has to be greater than 0\");\n    selectIssuersWaitBlocks = _selectIssuersWaitBlocks;\n    emit SelectIssuersWaitBlocksSet(_selectIssuersWaitBlocks);\n  }\n\n  /**\n   * @notice Updates 'maxAttestations'.\n   * @param _maxAttestations Maximum number of attestations that can be requested.\n   */\n  function setMaxAttestations(uint256 _maxAttestations) public onlyOwner {\n    require(_maxAttestations > 0, \"maxAttestations has to be greater than 0\");\n    maxAttestations = _maxAttestations;\n    emit MaxAttestationsSet(_maxAttestations);\n  }\n\n  /**\n   * @notice Query 'maxAttestations'\n   * @return Maximum number of attestations that can be requested.\n   */\n  function getMaxAttestations() external view returns (uint256) {\n    return maxAttestations;\n  }\n\n  /**\n   * @notice Validates the given attestation code.\n   * @param identifier The hash of the identifier to be attested.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @return The issuer of the corresponding attestation.\n   * @dev Throws if there is no matching outstanding attestation request.\n   * @dev Throws if the attestation window has passed.\n   */\n  function validateAttestationCode(\n    bytes32 identifier,\n    address account,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public view returns (address) {\n    bytes32 codehash = keccak256(abi.encodePacked(identifier, account));\n    address signer = Signatures.getSignerOfMessageHash(codehash, v, r, s);\n    address issuer = getAccounts().attestationSignerToAccount(signer);\n\n    Attestation storage attestation = identifiers[identifier].attestations[account]\n      .issuedAttestations[issuer];\n\n    require(\n      attestation.status == AttestationStatus.Incomplete,\n      \"Attestation code does not match any outstanding attestation\"\n    );\n    require(!isAttestationExpired(attestation.blockNumber), \"Attestation timed out\");\n\n    return issuer;\n  }\n\n  function lookupAccountsForIdentifier(bytes32 identifier)\n    external\n    view\n    returns (address[] memory)\n  {\n    return identifiers[identifier].accounts;\n  }\n\n  /**\n   * @notice Require that a given identifier/address pair has\n   * requested a specific number of attestations.\n   * @param identifier Hash of the identifier.\n   * @param account Address of the account.\n   * @param expected Number of expected attestations\n   * @dev It can be used when batching meta-transactions to validate\n   * attestation are requested as expected in untrusted scenarios\n   */\n  function requireNAttestationsRequested(bytes32 identifier, address account, uint32 expected)\n    external\n    view\n  {\n    uint256 requested = identifiers[identifier].attestations[account].requested;\n    require(requested == expected, \"requested attestations does not match expected\");\n  }\n\n  /**\n   * @notice Helper function for batchGetAttestationStats to calculate the\n             total number of addresses that have >0 complete attestations for the identifiers.\n   * @param identifiersToLookup Array of n identifiers.\n   * @return Array of n numbers that indicate the number of matching addresses per identifier\n   *         and array of addresses preallocated for total number of matches.\n   */\n  function batchlookupAccountsForIdentifier(bytes32[] memory identifiersToLookup)\n    internal\n    view\n    returns (uint256[] memory, address[] memory)\n  {\n    require(identifiersToLookup.length > 0, \"You have to pass at least one identifier\");\n    uint256 totalAddresses = 0;\n    uint256[] memory matches = new uint256[](identifiersToLookup.length);\n\n    for (uint256 i = 0; i < identifiersToLookup.length; i = i.add(1)) {\n      uint256 count = identifiers[identifiersToLookup[i]].accounts.length;\n\n      totalAddresses = totalAddresses + count;\n      matches[i] = count;\n    }\n\n    return (matches, new address[](totalAddresses));\n  }\n\n  /**\n   * @notice Adds additional attestations given the current randomness.\n   * @param identifier The hash of the identifier to be attested.\n   */\n  function addIncompleteAttestations(bytes32 identifier) internal {\n    AttestedAddress storage state = identifiers[identifier].attestations[msg.sender];\n    UnselectedRequest storage unselectedRequest = identifiers[identifier].unselectedRequests[msg\n      .sender];\n\n    bytes32 seed = getRandom().getBlockRandomness(\n      uint256(unselectedRequest.blockNumber).add(selectIssuersWaitBlocks)\n    );\n    IAccounts accounts = getAccounts();\n    uint256 issuersLength = numberValidatorsInCurrentSet();\n    uint256[] memory issuers = new uint256[](issuersLength);\n    for (uint256 i = 0; i < issuersLength; i++) issuers[i] = i;\n\n    require(unselectedRequest.attestationsRequested <= issuersLength, \"not enough issuers\");\n\n    uint256 currentIndex = 0;\n\n    // The length of the list (variable issuersLength) is decremented in each round,\n    // so the loop always terminates\n    while (currentIndex < unselectedRequest.attestationsRequested) {\n      require(issuersLength > 0, \"not enough issuers\");\n      seed = keccak256(abi.encodePacked(seed));\n      uint256 idx = uint256(seed) % issuersLength;\n      address signer = validatorSignerAddressFromCurrentSet(issuers[idx]);\n      address issuer = accounts.signerToAccount(signer);\n\n      Attestation storage attestation = state.issuedAttestations[issuer];\n\n      if (\n        attestation.status == AttestationStatus.None &&\n        accounts.hasAuthorizedAttestationSigner(issuer)\n      ) {\n        currentIndex = currentIndex.add(1);\n        attestation.status = AttestationStatus.Incomplete;\n        attestation.blockNumber = unselectedRequest.blockNumber;\n        attestation.attestationRequestFeeToken = unselectedRequest.attestationRequestFeeToken;\n        state.selectedIssuers.push(issuer);\n\n        emit AttestationIssuerSelected(\n          identifier,\n          msg.sender,\n          issuer,\n          unselectedRequest.attestationRequestFeeToken\n        );\n      }\n\n      // Remove the validator that was selected from the list,\n      // by replacing it by the last element in the list\n      issuersLength = issuersLength.sub(1);\n      issuers[idx] = issuers[issuersLength];\n    }\n  }\n\n  /**\n   * @notice Update the approval status of allowing an attestation identifier\n   * mapping to be transfered from an address to another.  The \"to\" or \"from\"\n   * addresses must both approve.  If the other has already approved, then the transfer\n   * is executed.\n   * @param identifier The identifier for this attestation.\n   * @param from The current attestation address to which the identifier is mapped.\n   * @param to The new address to map to identifier.\n   * @param status The approval status\n   */\n  function approveTransfer(bytes32 identifier, uint256 index, address from, address to, bool status)\n    external\n  {\n    require(msg.sender == from || msg.sender == to);\n    bytes32 key = keccak256(abi.encodePacked(identifier, from, to));\n    address other = msg.sender == from ? to : from;\n    if (status && transferApprovals[other][key]) {\n      _transfer(identifier, index, from, to);\n      transferApprovals[other][key] = false;\n    } else {\n      transferApprovals[msg.sender][key] = status;\n      emit TransferApproval(msg.sender, identifier, from, to, status);\n    }\n  }\n\n  /**\n   * @notice Transfer an attestation identifier mapping from the sender address to a\n   * replacement address.\n   * @param identifier The identifier for this attestation.\n   * @param index The index of the account in the accounts array.\n   * @param from The current attestation address to which the identifier is mapped.\n   * @param to The address to replace the sender address in the indentifier mapping.\n   * @dev Throws if"
    }
  ]
}