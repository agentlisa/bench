{
  "Title": "[02] Bootloader wrongly identifies the `RIGHT_PADDED_GET_ACCOUNT_VERSION_SELECTOR` as not attached with the `Contract Deployer` deployment execution",
  "Content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/bootloader/bootloader.yul#L1937-L1961\n\n```yul\n            function shouldMsgValueMimicCallBeSystem(to, dataPtr) -> ret {\n                let dataLen := mload(dataPtr)\n                // Note, that this point it is not fully known whether it is indeed the selector\n                // of the calldata (it might not be the case if the `dataLen` < 4), but it will be checked later on\n                let selector := shr(224, mload(add(dataPtr, 32)))\n\n                let isSelectorCreate := or(\n                    eq(selector, {{CREATE_SELECTOR}}),\n                    eq(selector, {{CREATE_ACCOUNT_SELECTOR}})\n                )\n                let isSelectorCreate2 := or(\n                    eq(selector, {{CREATE2_SELECTOR}}),\n                    eq(selector, {{CREATE2_ACCOUNT_SELECTOR}})\n                )\n\n                // Firstly, ensure that the selector is a valid deployment function\n                ret := or(\n                    isSelectorCreate,\n                    isSelectorCreate2\n                )\n                // Secondly, ensure that the callee is ContractDeployer\n                ret := and(ret, eq(to, CONTRACT_DEPLOYER_ADDR()))\n                // Thirdly, ensure that the calldata is long enough to contain the selector\n                ret := and(ret, gt(dataLen, 3))\n            }\n```\n\nThis function returns whether the mimicCall should use the `isSystem` flag, note that his flag should only be used for contract deployments and nothing else, now navigating to the bootloaders preprocess script here https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/scripts/preprocess-bootloader.ts, we can see that, not all contract deployments selectors would be tagged with the flag, note that this is the intended behaviour since calls to the deployer system contract are the only ones allowed to be system calls.\n\n```json\n...\n  RIGHT_PADDED_GET_ACCOUNT_VERSION_SELECTOR: getPaddedSelector(\"ContractDeployer\", \"extendedAccountVersion\"),\n...\n  CREATE_SELECTOR: getSelector(\"ContractDeployer\", \"create\"),\n  CREATE2_SELECTOR: getSelector(\"ContractDeployer\", \"create2\"),\n  CREATE_ACCOUNT_SELECTOR: getSelector(\"ContractDeployer\", \"createAccount\"),\n  CREATE2_ACCOUNT_SELECTOR: getSelector(\"ContractDeployer\", \"create2Account\"),\n...\n\n```\n\nEvidently there are 5 contract deployment functionalities attached with the bootloader's preprocessor, but only 4 of those would be tagged with the `isSystem` flag in the bootloader, since the \"extendedAccountVersion\" has not been attached.\n\n### Impact\n\nThe current implementation of the `bootloader::shouldMsgValueMimicCallBeSystem` would wrongly assume that the contract deployment of the \"extendedAccountVersion\" is not a system call, i.e [this instance of using the `isSystem` flag in the bootloader](https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/bootloader/bootloader.yul#L1972) wrongly assumes that this is not a system call, making the ABI returned by `getFarCallABI()` for low-level innvocations of calls and mimicCalls wrong.\n\nThe route for this logic is : `executeL1Tx-> msgValueSimulatorMimicCall -> shouldMsgValueMimicCallBeSystem /mimicCallOnlyResult -> getFarCallABI `\n\n> Submitting this as QA, leaving to the judge to upgrade if they see fit\n\n### Recommended Mitigation Steps\n\nInclude the `RIGHT_PADDED_GET_ACCOUNT_VERSION_SELECTOR` in `bootloader::shouldMsgValueMimicCallBeSystem` as an `isSystem` call.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-zksync",
  "Code": [
    {
      "filename": "code/system-contracts/bootloader/bootloader.yul",
      "content": "object \"Bootloader\" {\n    code {\n    }\n    object \"Bootloader_deployed\" {\n        code {\n            {{CODE_START_PLACEHOLDER}}\n\n            ////////////////////////////////////////////////////////////////////////////\n            //                      Function Declarations\n            ////////////////////////////////////////////////////////////////////////////\n\n            // While we definitely cannot control the pubdata price on L1,\n            // we need to check the operator does not provide any absurd numbers there\n            function MAX_ALLOWED_FAIR_PUBDATA_PRICE() -> ret {\n                // 1M gwei\n                ret := 1000000000000000\n            }\n\n            function MAX_ALLOWED_FAIR_L2_GAS_PRICE() -> ret {\n                // 10k gwei\n                ret := 10000000000000\n            }\n\n            /// @dev This method ensures that the prices provided by the operator\n            /// are not absurdly high\n            function validateOperatorProvidedPrices(fairL2GasPrice, pubdataPrice) {\n                // The limit is the same for pubdata price and L1 gas price\n                if gt(pubdataPrice, MAX_ALLOWED_FAIR_PUBDATA_PRICE()) {\n                    assertionError(\"Fair pubdata price too high\")\n                }\n\n                if gt(fairL2GasPrice, MAX_ALLOWED_FAIR_L2_GAS_PRICE()) {\n                    assertionError(\"L2 fair gas price too high\")\n                }\n            }\n\n            /// @dev The overhead for a transaction slot in L2 gas. \n            /// It is roughly equal to 80kk/MAX_TRANSACTIONS_IN_BATCH, i.e. how many gas would an L1->L2 transaction\n            /// need to pay to compensate for the batch being closed.\n            /// @dev It is expected of the operator to set the \"fair L2 gas price\" appropriately to ensure that it is \n            /// compensated enough in case the batch might be prematurely sealed because of the transaction slots being filled up.\n            function TX_SLOT_OVERHEAD_GAS() -> ret {\n                ret := 10000\n            }\n\n            /// @dev The overhead for each byte of the bootloader memory that the encoding of the transaction.\n            /// It is roughly equal to 80kk/BOOTLOADER_MEMORY_FOR_TXS, i.e. how many gas would an L1->L2 transaction\n            /// need to pay to compensate for the batch being closed.\n            /// @dev It is expected of the operator to set the \"fair L2 gas price\" appropriately to ensure that it is\n            /// compensated enough in case the batch might be prematurely sealed because of the memory being filled up.\n            function MEMORY_OVERHEAD_GAS() -> ret {\n                ret := 10\n            }\n\n            /// @dev Returns the base fee and gas per pubdata based on the fair pubdata price and L2 gas price provided by the operator\n            /// @param pubdataPrice The price of a single byte of pubdata in Wei\n            /// @param fairL2GasPrice The price of an L2 gas in Wei\n            /// @return baseFee and gasPerPubdata The base fee and the gas per pubdata to be used by L2 transactions in this batch.\n            function getFeeParams(\n                fairPubdataPrice,\n                fairL2GasPrice,\n            ) -> baseFee, gasPerPubdata {\n                baseFee := max(\n                    fairL2GasPrice,\n                    ceilDiv(fairPubdataPrice, MAX_L2_GAS_PER_PUBDATA())\n                )\n\n                gasPerPubdata := gasPerPubdataFromBaseFee(baseFee, fairPubdataPrice)\n            }\n\n            /// @dev Calculates the gas per pubdata based on the pubdata price provided by the operator\n            /// as well the the fixed baseFee.\n            function gasPerPubdataFromBaseFee(baseFee, pubdataPrice) -> ret {\n                ret := ceilDiv(pubdataPrice, baseFee)\n            }\n\n            /// @dev It should be always possible to submit a transaction \n            /// that consumes such amount of public data.\n            function GUARANTEED_PUBDATA_PER_TX() -> ret {\n                ret := {{GUARANTEED_PUBDATA_BYTES}}\n            }\n\n            /// @dev The maximal allowed gasPerPubdata, we want it multiplied by the u32::MAX \n            /// (i.e. the maximal possible value of the pubdata counter) to be a safe JS integer with a good enough margin.\n            function MAX_L2_GAS_PER_PUBDATA() -> ret {\n                ret := 1048576\n            }\n\n            /// @dev The overhead for the interaction with L1.\n            /// It should cover proof verification as well as other minor \n            /// overheads for committing/executing a transaction in a batch.\n            function BATCH_OVERHEAD_L1_GAS() -> ret {\n                ret := {{BATCH_OVERHEAD_L1_GAS}}\n            }\n\n            /// @dev The maximal number of gas available to the transaction\n            function MAX_GAS_PER_TRANSACTION() -> ret {\n                ret := {{MAX_GAS_PER_TRANSACTION}}\n            }\n\n            /// @dev The number of L1 gas needed to be spent for\n            /// L1 byte. While a single pubdata byte costs `16` gas, \n            /// we demand at least 17 to cover up for the costs of additional\n            /// hashing of it, etc.\n            function L1_GAS_PER_PUBDATA_BYTE() -> ret {\n                ret := 17\n            }\n\n            /// @dev Whether the batch is allowed to accept transactions with\n            /// gasPerPubdataByteLimit = 0. On mainnet, this is forbidden for safety reasons.\n            function FORBID_ZERO_GAS_PER_PUBDATA() -> ret {\n                ret := {{FORBID_ZERO_GAS_PER_PUBDATA}}\n            }\n            \n            /// @dev The maximum number of transactions per L1 batch.\n            function MAX_TRANSACTIONS_IN_BATCH() -> ret {\n                ret := {{MAX_TRANSACTIONS_IN_BATCH}}\n            }\n\n            /// @dev The slot from which the scratch space starts.\n            /// Scratch space is used for various temporary values\n            function SCRATCH_SPACE_BEGIN_SLOT() -> ret {\n                ret := 8\n            }\n\n            /// @dev The byte from which the scratch space starts.\n            /// Scratch space is used for various temporary values\n            function SCRATCH_SPACE_BEGIN_BYTE() -> ret {\n                ret := mul(SCRATCH_SPACE_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The first 32 slots are reserved for event emitting for the \n            /// debugging purposes\n            function SCRATCH_SPACE_SLOTS() -> ret {\n                ret := 32\n            }\n\n            /// @dev Slots reserved for saving the paymaster context\n            /// @dev The paymasters are allowed to consume at most \n            /// 32 slots (1024 bytes) for their context.\n            /// The 33 slots are required since the first one stores the length of the calldata.\n            function PAYMASTER_CONTEXT_SLOTS() -> ret {\n                ret := 33\n            }\n        \n            /// @dev Bytes reserved for saving the paymaster context\n            function PAYMASTER_CONTEXT_BYTES() -> ret {\n                ret := mul(PAYMASTER_CONTEXT_SLOTS(), 32)\n            }\n\n            /// @dev Slot from which the paymaster context starts\n            function PAYMASTER_CONTEXT_BEGIN_SLOT() -> ret {\n                ret := add(SCRATCH_SPACE_BEGIN_SLOT(), SCRATCH_SPACE_SLOTS())\n            }\n\n            /// @dev The byte from which the paymaster context starts\n            function PAYMASTER_CONTEXT_BEGIN_BYTE() -> ret {\n                ret := mul(PAYMASTER_CONTEXT_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev Each tx must have at least this amount of unused bytes before them to be able to \n            /// encode the postOp operation correctly.\n            function MAX_POSTOP_SLOTS() -> ret {\n                // Before the actual transaction encoding, the postOp contains 6 slots:\n                // 1. Context offset\n                // 2. Transaction offset\n                // 3. Transaction hash\n                // 4. Suggested signed hash\n                // 5. Transaction result\n                // 6. Maximum refunded gas\n                // And one more slot for the padding selector\n                ret := add(PAYMASTER_CONTEXT_SLOTS(), 7)\n            }\n\n            /// @dev Slots needed to store the canonical and signed hash for the current L2 transaction.\n            function CURRENT_L2_TX_HASHES_RESERVED_SLOTS() -> ret {\n                ret := 2\n            }\n\n            /// @dev Slot from which storing of the current canonical and signed hashes begins\n            function CURRENT_L2_TX_HASHES_BEGIN_SLOT() -> ret {\n                ret := add(PAYMASTER_CONTEXT_BEGIN_SLOT(), PAYMASTER_CONTEXT_SLOTS())\n            }\n\n            /// @dev The byte from which storing of the current canonical and signed hashes begins\n            function CURRENT_L2_TX_HASHES_BEGIN_BYTE() -> ret {\n                ret := mul(CURRENT_L2_TX_HASHES_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The maximum number of new factory deps that are allowed in a transaction\n            function MAX_NEW_FACTORY_DEPS() -> ret {\n                ret := 32\n            }\n\n            /// @dev Besides the factory deps themselves, we also need another 4 slots for: \n            /// selector, marker of whether the user should pay for the pubdata,\n            /// the offset for the encoding of the array as well as the length of the array.\n            function NEW_FACTORY_DEPS_RESERVED_SLOTS() -> ret {\n                ret := add(MAX_NEW_FACTORY_DEPS(), 4)\n            }\n\n            /// @dev The slot starting from which the factory dependencies are stored\n            function NEW_FACTORY_DEPS_BEGIN_SLOT() -> ret {\n                ret := add(CURRENT_L2_TX_HASHES_BEGIN_SLOT(), CURRENT_L2_TX_HASHES_RESERVED_SLOTS())\n            }\n\n            /// @dev The byte starting from which the factory dependencies are stored\n            function NEW_FACTORY_DEPS_BEGIN_BYTE() -> ret {\n                ret := mul(NEW_FACTORY_DEPS_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The slot starting from which the refunds provided by the operator are stored\n            function TX_OPERATOR_REFUND_BEGIN_SLOT() -> ret {\n                ret := add(NEW_FACTORY_DEPS_BEGIN_SLOT(), NEW_FACTORY_DEPS_RESERVED_SLOTS())\n            }\n\n            /// @dev The byte starting from which the refunds provided by the operator are stored\n            function TX_OPERATOR_REFUND_BEGIN_BYTE() -> ret {\n                ret := mul(TX_OPERATOR_REFUND_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The number of slots dedicated for the refunds for the transactions.\n            /// It is equal to the number of transactions in the batch.\n            function TX_OPERATOR_REFUNDS_SLOTS() -> ret {\n                ret := MAX_TRANSACTIONS_IN_BATCH()\n            }\n\n            /// @dev The slot starting from which the overheads proposed by the operator will be stored\n            function TX_SUGGESTED_OVERHEAD_BEGIN_SLOT() -> ret {\n                ret := add(TX_OPERATOR_REFUND_BEGIN_SLOT(), TX_OPERATOR_REFUNDS_SLOTS())\n            }\n\n            /// @dev The byte starting from which the overheads proposed by the operator will be stored\n            function TX_SUGGESTED_OVERHEAD_BEGIN_BYTE() -> ret {\n                ret := mul(TX_SUGGESTED_OVERHEAD_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The number of slots dedicated for the overheads for the transactions.\n            /// It is equal to the number of transactions in the batch.\n            function TX_SUGGESTED_OVERHEAD_SLOTS() -> ret {\n                ret := MAX_TRANSACTIONS_IN_BATCH()\n            }\n\n            /// @dev The slot starting from which the maximum number of gas that the operator \"trusts\"\n            /// the transaction to use for its execution is stored. Sometimes, the operator may know that\n            /// a certain transaction can be allowed more gas that what the protocol-level worst-case allows.\n            function TX_OPERATOR_TRUSTED_GAS_LIMIT_BEGIN_SLOT() -> ret {\n                ret := add(TX_SUGGESTED_OVERHEAD_BEGIN_SLOT(), TX_SUGGESTED_OVERHEAD_SLOTS())\n            }\n\n            /// @dev byte starting from which the maximum number of gas that the operator \"trusts\"\n            /// the transaction to use for its execution is stored. \n            function TX_OPERATOR_TRUSTED_GAS_LIMIT_BEGIN_BYTE() -> ret {\n                ret := mul(TX_OPERATOR_TRUSTED_GAS_LIMIT_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The number of slots dedicated for the trusted gas limits for the transactions.\n            /// It is equal to the number of transactions in the batch.\n            function TX_OPERATOR_TRUSTED_GAS_LIMIT_SLOTS() -> ret {\n                ret := MAX_TRANSACTIONS_IN_BATCH()\n            }\n\n            /// @dev The slot starting from the L2 block information for transactions is stored.\n            function TX_OPERATOR_L2_BLOCK_INFO_BEGIN_SLOT() -> ret {\n                ret := add(TX_OPERATOR_TRUSTED_GAS_LIMIT_BEGIN_SLOT(), TX_OPERATOR_TRUSTED_GAS_LIMIT_SLOTS())\n            }\n\n            /// @dev The byte starting from which the L2 block information for transactions is stored.\n            function TX_OPERATOR_L2_BLOCK_INFO_BEGIN_BYTE() -> ret {\n                ret := mul(TX_OPERATOR_L2_BLOCK_INFO_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The size of each of the L2 block information. Each L2 block information contains four fields:\n            /// - number of the block\n            /// - timestamp of the block\n            /// - hash of the previous block\n            /// - the maximal number of virtual blocks to create\n            function TX_OPERATOR_L2_BLOCK_INFO_SLOT_SIZE() -> ret {\n                ret := 4\n            }\n\n            /// @dev The size of each of the L2 block information in bytes.\n            function TX_OPERATOR_L2_BLOCK_INFO_SIZE_BYTES() -> ret {\n                ret := mul(TX_OPERATOR_L2_BLOCK_INFO_SLOT_SIZE(), 32)\n            }\n\n            /// @dev The number of slots dedicated for the L2 block information for the transactions.\n            /// Note, that an additional slot is required for the fictive L2 block at the end of the batch. \n            /// For technical reasons inside the sequencer implementation, \n            /// each batch ends with a fictive block with no transactions.\n            function TX_OPERATOR_L2_BLOCK_INFO_SLOTS() -> ret {\n                ret := mul(add(MAX_TRANSACTIONS_IN_BATCH(), 1), TX_OPERATOR_L2_BLOCK_INFO_SLOT_SIZE())\n            }\n\n            /// @dev The slot starting from which the compressed bytecodes are located in the bootloader's memory.\n            /// Each compressed bytecode is provided in the following format:\n            /// - 32 byte formatted bytecode hash\n            /// - 32 byte of zero (it will be replaced within the code with left-padded selector of the `publishCompressedBytecode`).\n            /// - ABI-encoding of the parameters of the `publishCompressedBytecode` method. \n            /// \n            /// At the slot `TX_OPERATOR_TRUSTED_GAS_LIMIT_BEGIN_SLOT()` the pointer to the currently processed compressed bytecode\n            /// is stored, i.e. this pointer will be increased once the current bytecode which the pointer points to is published.\n            /// At the start of the bootloader, the value stored at the `TX_OPERATOR_TRUSTED_GAS_LIMIT_BEGIN_SLOT` is equal to \n            /// `TX_OPERATOR_TRUSTED_GAS_LIMIT_BEGIN_SLOT + 32`, where the hash of the first compressed bytecode to publish should be stored.\n            function COMPRESSED_BYTECODES_BEGIN_SLOT() -> ret {\n                ret := add(TX_OPERATOR_L2_BLOCK_INFO_BEGIN_SLOT(), TX_OPERATOR_L2_BLOCK_INFO_SLOTS())\n            }\n\n            /// @dev The byte starting from which the compressed bytecodes are located in the bootloader's memory.\n            function COMPRESSED_BYTECODES_BEGIN_BYTE() -> ret {\n                ret := mul(COMPRESSED_BYTECODES_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The number of slots dedicated to the compressed bytecodes.\n            function COMPRESSED_BYTECODES_SLOTS() -> ret {\n                ret := {{COMPRESSED_BYTECODES_SLOTS}}\n            }\n\n            /// @dev The slot right after the last slot of the compressed bytecodes memory area.\n            function COMPRESSED_BYTECODES_END_SLOT() -> ret {\n                ret := add(COMPRESSED_BYTECODES_BEGIN_SLOT(), COMPRESSED_BYTECODES_SLOTS())\n            }\n\n            /// @dev The first byte in memory right after the compressed bytecodes memory area.\n            function COMPRESSED_BYTECODES_END_BYTE() -> ret {\n                ret := mul(COMPRESSED_BYTECODES_END_SLOT(), 32)\n            }\n\n            /// @dev Slots needed to store priority txs L1 data (`chainedPriorityTxsHash` and `numberOfLayer1Txs`).\n            function PRIORITY_TXS_L1_DATA_RESERVED_SLOTS() -> ret {\n                ret := 2\n            }\n\n            /// @dev Slot from which storing of the priority txs L1 data begins.\n            function PRIORITY_TXS_L1_DATA_BEGIN_SLOT() -> ret {\n                ret := add(COMPRESSED_BYTECODES_BEGIN_SLOT(), COMPRESSED_BYTECODES_SLOTS())\n            }\n\n            /// @dev The byte from which storing of the priority txs L1 data begins.\n            function PRIORITY_TXS_L1_DATA_BEGIN_BYTE() -> ret {\n                ret := mul(PRIORITY_TXS_L1_DATA_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev Slot from which storing of the L1 Messenger pubdata begins.\n            function OPERATOR_PROVIDED_L1_MESSENGER_PUBDATA_BEGIN_SLOT() -> ret {\n                ret := add(PRIORITY_TXS_L1_DATA_BEGIN_SLOT(), PRIORITY_TXS_L1_DATA_RESERVED_SLOTS())\n            }\n\n            /// @dev The byte storing of the L1 Messenger pubdata begins.\n            function OPERATOR_PROVIDED_L1_MESSENGER_PUBDATA_BEGIN_BYTE() -> ret {\n                ret := mul(OPERATOR_PROVIDED_L1_MESSENGER_PUBDATA_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev Slots needed to store L1 Messenger pubdata.\n            /// @dev Note that are many more these than the maximal pubdata in batch, since \n            /// it needs to also accommodate uncompressed state diffs that are required for the state diff\n            /// compression verification.\n            function OPERATOR_PROVIDED_L1_MESSENGER_PUBDATA_SLOTS() -> ret {\n                ret := {{OPERATOR_PROVIDED_L1_MESSENGER_PUBDATA_SLOTS}}\n            }\n\n            /// @dev The slot right after the last slot of the L1 Messenger pubdata memory area.\n            function OPERATOR_PROVIDED_L1_MESSENGER_PUBDATA_END_SLOT() -> ret {\n                ret := add(OPERATOR_PROVIDED_L1_MESSENGER_PUBDATA_BEGIN_SLOT(), OPERATOR_PROVIDED_L1_MESSENGER_PUBDATA_SLOTS())\n            }\n\n            /// @dev The slot from which the bootloader transactions' descriptions begin\n            function TX_DESCRIPTION_BEGIN_SLOT() -> ret {\n                ret := OPERATOR_PROVIDED_L1_MESSENGER_PUBDATA_END_SLOT()\n            }\n\n            /// @dev The byte from which the bootloader transactions' descriptions begin\n            function TX_DESCRIPTION_BEGIN_BYTE() -> ret {\n                ret := mul(TX_DESCRIPTION_BEGIN_SLOT(), 32)\n            }\n\n            // Each tx description has the following structure\n            // \n            // struct BootloaderTxDescription {\n            //     uint256 txMeta;\n            //     uint256 txDataOffset;\n            // }\n            //\n            // `txMeta` contains flags to manipulate the transaction execution flow.\n            // For playground batches:\n            //      It can have the following information (0 byte is LSB and 31 byte is MSB):\n            //      0 byte: `execute`, bool. Denotes whether transaction should be executed by the bootloader.\n            //      31 byte: server-side tx execution mode\n            // For proved batches:\n            //      It can simply denotes whether to execute the transaction (0 to stop executing the batch, 1 to continue) \n            //\n            // Each such encoded struct consumes 2 words\n            function TX_DESCRIPTION_SIZE() -> ret {\n                ret := 64\n            }\n\n            /// @dev The byte right after the basic description of bootloader transactions\n            function TXS_IN_BATCH_LAST_PTR() -> ret {\n                ret := add(TX_DESCRIPTION_BEGIN_BYTE(), mul(MAX_TRANSACTIONS_IN_BATCH(), TX_DESCRIPTION_SIZE()))\n            }\n\n            /// @dev The memory page consists of 30000000 / 32 VM words.\n            /// Each execution result is a single boolean, but \n            /// for the sake of simplicity we will spend 32 bytes on each\n            /// of those for now. \n            function MAX_MEM_SIZE() -> ret {\n                ret := 30000000\n            }\n\n            function L1_TX_INTRINSIC_L2_GAS() -> ret {\n                ret := {{L1_TX_INTRINSIC_L2_GAS}}\n            }\n\n            function L1_TX_INTRINSIC_PUBDATA() -> ret {\n                ret := {{L1_TX_INTRINSIC_PUBDATA}}\n            }\n\n            function L2_TX_INTRINSIC_GAS() -> ret {\n                ret := {{L2_TX_INTRINSIC_GAS}}\n            }\n\n            function L2_TX_INTRINSIC_PUBDATA() -> ret {\n                ret := {{L2_TX_INTRINSIC_PUBDATA}}\n            }\n\n            /// @dev The byte from which the pointers on the result of transactions are stored\n            function RESULT_START_PTR() -> ret {\n                ret := sub(MAX_MEM_SIZE(), mul(MAX_TRANSACTIONS_IN_BATCH(), 32))\n            }\n\n            /// @dev The pointer writing to which invokes the VM hooks\n            function VM_HOOK_PTR() -> ret {\n                ret := sub(RESULT_START_PTR(), 32)\n            }\n\n            /// @dev The maximum number the VM hooks may accept\n            function VM_HOOK_PARAMS() -> ret {\n                ret := 3\n            }\n\n            /// @dev The offset starting from which the parameters for VM hooks are located\n            function VM_HOOK_PARAMS_OFFSET() -> ret {\n                ret := sub(VM_HOOK_PTR(), mul(VM_HOOK_PARAMS(), 32))\n            }\n\n            function LAST_FREE_SLOT() -> ret {\n                // The slot right before the vm hooks is the last slot that\n                // can be used for transaction's descriptions\n                ret := sub(VM_HOOK_PARAMS_OFFSET(), 32)\n            }\n\n            /// @dev The formal address of the bootloader\n            function BOOTLOADER_FORMAL_ADDR() -> ret {\n                ret := 0x0000000000000000000000000000000000008001\n            }\n\n            function ACCOUNT_CODE_STORAGE_ADDR() -> ret {\n                ret := 0x0000000000000000000000000000000000008002\n            }\n\n            function NONCE_HOLDER_ADDR() -> ret {\n                ret := 0x0000000000000000000000000000000000008003\n            }\n\n            function KNOWN_CODES_CONTRACT_ADDR() -> ret {\n                ret := 0x0000000000000000000000000000000000008004\n            }\n\n            function CONTRACT_DEPLOYER_ADDR() -> ret {\n                ret := 0x0000000000000000000000000000000000008006\n            }\n            \n            function FORCE_DEPLOYER() -> ret {\n                ret := 0x0000000000000000000000000000000000008007\n            }\n\n            function L1_MESSENGER_ADDR() -> ret {\n                ret := 0x0000000000000000000000000000000000008008\n            }\n\n            function MSG_VALUE_SIMULATOR_ADDR() -> ret {\n                ret := 0x0000000000000000000000000000000000008009\n            }\n\n            function ETH_L2_TOKEN_ADDR() -> ret {\n                ret := 0x000000000000000000000000000000000000800a\n            }\n\n            function SYSTEM_CONTEXT_ADDR() -> ret {\n                ret := 0x000000000000000000000000000000000000800b\n            }\n\n            function BOOTLOADER_UTILITIES() -> ret {\n                ret := 0x000000000000000000000000000000000000800c\n            }\n\n            function BYTECODE_COMPRESSOR_ADDR() -> ret {\n                ret := 0x000000000000000000000000000000000000800e\n            }\n\n            function KECCAK256_ADDR() -> ret {\n                ret := 0x0000000000000000000000000000000000008010\n            }\n\n            function MAX_SYSTEM_CONTRACT_ADDR() -> ret {\n                ret := 0x000000000000000000000000000000000000ffff\n            }\n\n            /// @dev The minimal allowed distance in bytes between the pointer to the compressed data\n            /// and the end of the area dedicated for the compressed bytecodes. \n            /// In fact, only distance of 192 should be sufficient: there it would be possible to insert\n            /// the hash of the bytecode, the 32 bytes buffer for selector and 2 offsets of the calldata,\n            /// but we keep it at 512 just in case.\n            function MIN_ALLOWED_OFFSET_FOR_COMPRESSED_BYTES_POINTER() -> ret {\n                ret := 512\n            }\n\n            /// @dev Whether the bootloader should enforce that accounts have returned the correct\n            /// magic value for signature. This value is enforced to be \"true\" on the main proved batch, but \n            /// we need the ability to ignore invalid signature results during fee estimation,\n            /// where the signature for the transaction is usually not known beforehand.\n            function SHOULD_ENSURE_CORRECT_RETURNED_MAGIC() -> ret {\n                ret := {{ENSURE_RETURNED_MAGIC}}\n            }\n\n            /// @notice The type of the transaction used for system upgrades.\n            function UPGRADE_TRANSACTION_TX_TYPE() -> ret {\n                ret := 254\n            }\n\n            /// @notice The type of every non-upgrade transaction that comes from L1.\n            function L1_TX_TYPE() -> ret {\n                ret := 255\n            }\n\n            /// @dev The overhead in gas that will be used when checking whether the context has enough gas, i.e. \n            /// when checking for X gas, the context should have at least X+CHECK_ENOUGH_GAS_OVERHEAD() gas.\n            function CHECK_ENOUGH_GAS_OVERHEAD() -> ret {\n                ret := 1000000\n            }\n\n            /// @dev The maximal amount of pubdata that can be safely used by a transaction. \n            /// If a transaction uses more pubdata than this, it will be reverted.\n            function MAX_PUBDATA_FOR_TX() -> ret {\n                ret := 120000\n            }\n\n            /// @dev Ceil division of integers\n            function ceilDiv(x, y) -> ret {\n                switch or(eq(x, 0), eq(y, 0))\n                case 0 {\n                    // (x + y - 1) / y can overflow on addition, so we distribute.\n                    ret := add(div(sub(x, 1), y), 1)\n                }\n                default {\n                    ret := 0\n                }\n            }\n            \n            /// @dev Calculates the length of a given number of bytes rounded up to the nearest multiple of 32.\n            function lengthRoundedByWords(len) -> ret {\n                let neededWords := div(add(len, 31), 32)\n                ret := safeMul(neededWords, 32, \"xv\")\n            }\n\n            /// @dev Function responsible for processing the transaction\n            /// @param txDataOffset The offset to the ABI-encoding of the structure\n            /// @param resultPtr The pointer at which the result of the transaction's execution should be stored\n            /// @param transactionIndex The index of the transaction in the batch\n            /// @param isETHCall Whether the call is an ethCall. \n            /// @param gasPerPubdata The number of L2 gas to charge users for each byte of pubdata \n            /// On proved batch this value should always be zero\n            function processTx(\n                txDataOffset, \n                resultPtr,\n                transactionIndex,\n                isETHCall,\n                gasPerPubdata\n            ) {\n                // We set the L2 block info for this particular transaction\n                setL2Block(transactionIndex)\n\n                let innerTxDataOffset := add(txDataOffset, 32)\n\n                // By default we assume that the transaction has failed.\n                mstore(resultPtr, 0)\n\n                let userProvidedPubdataPrice := getGasPerPubdataByteLimit(innerTxDataOffset)\n                debugLog(\"userProvidedPubdataPrice:\", userProvidedPubdataPrice)\n\n                debugLog(\"gasPerPubdata:\", gasPerPubdata)\n\n                switch getTxType(innerTxDataOffset) \n                    case 254 {\n                        // This is an upgrade transaction.\n                        // Protocol upgrade transactions are processed totally in the same manner as the normal L1->L2 transactions,\n                        // the only difference are:\n                        // - They must be the first one in the batch\n                        // - They have a different type to prevent tx hash collisions and preserve the expectation that the \n                        // L1->L2 transactions have priorityTxId inside them.\n                        if transactionIndex {    \n                            assertionError(\"Protocol upgrade tx not first\")\n                        }\n\n                        // This is to be called in the event that the L1 Transaction is a protocol upgrade txn.\n                        // Since this is upgrade transactions, we are okay that the gasUsed by the transaction will \n                        // not cover this additional hash computation\n                        let canonicalL1TxHash := getCanonicalL1TxHash(txDataOffset)\n                        sendToL1Native(true, protocolUpgradeTxHashKey(), canonicalL1TxHash)\n\n                        processL1Tx(txDataOffset, resultPtr, transactionIndex, userProvidedPubdataPrice, false)\n                    }\n                    case 255 {\n                        // This is an L1->L2 transaction.\n                        processL1Tx(txDataOffset, resultPtr, transactionIndex, userProvidedPubdataPrice, true)\n                    }\n                    default {\n                        // The user has not agreed to this pubdata price\n                        if lt(userProvidedPubdataPrice, gasPerPubdata) {\n                            revertWithReason(UNACCEPTABLE_GAS_PRICE_ERR_CODE(), 0)\n                        }\n                        \n                        <!-- @if BOOTLOADER_TYPE=='proved_batch' -->\n                        processL2Tx(txDataOffset, resultPtr, transactionIndex, gasPerPubdata)\n                        <!-- @endif -->\n\n                        <!-- @if BOOTLOADER_TYPE=='playground_batch' -->\n                        switch isETHCall \n                            case 1 {\n                                let gasLimit := getGasLimit(innerTxDataOffset)\n                                let nearCallAbi := getNearCallABI(gasLimit)\n                                checkEnoughGas(gasLimit)\n\n                                if iszero(gasLimit) {\n                                    // If success is 0, we need to revert\n                                    revertWithReason(\n                                        ETH_CALL_ERR_CODE(),\n                                        0\n                                    )\n                                }\n\n                                ZKSYNC_NEAR_CALL_ethCall(\n                                    nearCallAbi,\n                                    txDataOffset,\n                                    resultPtr\n                                )\n                            }\n                            default { \n                                processL2Tx(txDataOffset, resultPtr, transactionIndex, gasPerPubdata)\n                            }\n                        <!-- @endif -->\n                    }\n            }\n\n            /// @notice Returns \"raw\" code hash of the address. \"Raw\" means that it returns exactly the value\n            /// that is stored in the AccountCodeStorage system contract for that address, without applying any\n            /// additional transformations, which the standard `extcodehash` does for EVM-compatibility\n            /// @param addr The address of the account to get the code hash of.\n            /// @param assertSuccess Whether to revert the bootloader if the call to the AccountCodeStorage fails. If `false`, only\n            /// `nearCallPanic` will be issued in case of failure, which is helpful for cases, when the reason for failure is user providing not\n            /// enough gas.\n            function getRawCodeHash(addr, assertSuccess) -> ret {\n                mstore(0, {{RIGHT_PADDED_GET_RAW_CODE_HASH_SELECTOR}})\n                mstore(4, addr)\n                let success := staticcall(\n                    gas(),\n                    ACCOUNT_CODE_STORAGE_ADDR(),\n                    0,\n                    36,\n                    0,\n                    32\n                )\n\n                // In case the call to the account code storage fails,"
    }
  ]
}