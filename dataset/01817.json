{
  "Title": "M-3: PositionUtils.validatePosition() uses ``isIncrease`` instead of ``false`` when calling isPositionLiquidatable(), making it not work properly for the case of ``isIncrease = true``.",
  "Content": "# Issue M-3: PositionUtils.validatePosition() uses ``isIncrease`` instead of ``false`` when calling isPositionLiquidatable(), making it not work properly for the case of ``isIncrease = true``. \n\nSource: https://github.com/sherlock-audit/2023-04-gmx-judging/issues/180 \n\n## Found by \nchaduke\n## Summary\n``PositionUtils.validatePosition()`` uses ``isIncrease`` instead of ``false`` when calling isPositionLiquidatable(), making it not work properly for the case of ``isIncrease = true``. The main problem is that when calling ``isPositionLiquidatable()``, we should always consider decreasing the position since we are proposing a liquidation trade (which is a decrease in position). Therefore, it should not use ``isIncrease`` for the input parameter for ``isPositionLiquidatable()``.  We should always use ``false`` instead.\n\n## Vulnerability Detail\n``PositionUtils.validatePosition()`` is called to validate whether a position is valid in both collateral size and position size, and in addition, to check if the position is liquidable:\n\n[https://github.com/sherlock-audit/2023-04-gmx/blob/main/gmx-synthetics/contracts/position/PositionUtils.sol#L261-L296](https://github.com/sherlock-audit/2023-04-gmx/blob/main/gmx-synthetics/contracts/position/PositionUtils.sol#L261-L296)\n\nIt calls function ``isPositionLiquidatable()`` to check if a position is liquidable. However, it passes the ``isIncrease`` to function ``isPositionLiquidatable()`` as an argument. Actually, the ``false`` value should always be used for calling function ``isPositionLiquidatable()`` since  a liquidation is always a decrease position operation. A position is liquidable or not has nothing to do with exiting trade operations and only depend on the parameters of the position per se.\n\nCurrent implementation has a problem for an increase order: Given a Increase order, for example, increase a position by $200, when ``PositionUtils.validatePosition()`` is called, which is after the position has been increased, we should not consider another $200 increase in ``isPositionLiquidatable()`` again as part of the price impact calculation. This is double-accouting for price impact calculation, one during the position increasing process, and another in the position validation process. On the other hand, if we use ``false`` here, then we are considering a decrease order (since a liquidation is a decrease order) and evaluate the hypothetical price impact if the position will be liquidated. \n\n[https://github.com/sherlock-audit/2023-04-gmx/blob/main/gmx-synthetics/contracts/position/PositionUtils.sol#L304-L412](https://github.com/sherlock-audit/2023-04-gmx/blob/main/gmx-synthetics/contracts/position/PositionUtils.sol#L304-L412)\n\nOur POC code confirms my finding: intially, we don't have any positions, after executing a LimitIncrease order, the priceImpactUsd is evaluaed as follows (notice initialDiffUsd = 0):\n\n>PositionPricingUtils.getPriceImpactUsd started...\n>  openInterestParams.longOpenInterest: 0\n>  openInterestParams.shortOpenInterest: 0\n>  initialDiffUsd: 0\n>  nextDiffUsd: 1123456700000000000000000000000\n>  positiveImpactFactor: 50000000000000000000000\n>  negativeImpactFactor: 100000000000000000000000\n>  positiveImpactUsd: 0\n>  negativeImpactUsd: 63107747838744499100000\n>  deltaDiffUsd: 63107747838744499100000\n>  priceImpactUsd: -63107747838744499100000\n>  PositionPricingUtils.getPriceImpactUsd() completed.\n>  Initial priceImpactUsd: -63107747838744499100000\n>  Capped priceImpactUsd: -63107747838744499100000\n\nThen, during validation, when ``PositionUtils.validatePosition()`` is called, the double accouting occurs, notice the ``nextDiffUsd`` is doubled, as if the limitOrder was executed for another time!\n\n> PositionPricingUtils.getPriceImpactUsd started...\n>  openInterestParams.longOpenInterest: 1123456700000000000000000000000\n>  openInterestParams.shortOpenInterest: 0\n>  initialDiffUsd: 1123456700000000000000000000000\n>  nextDiffUsd: 2246913400000000000000000000000\n> impactFactor: 100000000000000000000000\n>  impactExponentFactor: 2000000000000000000000000000000\n>  deltaDiffUsd: 189323243516233497450000\n>  priceImpactUsd: -189323243516233497450000\n>  priceImpactUsd: -189323243516233497450000\n>  adjusted 2: priceImpactUsd: 0\n \nThe POC code is as follows, pay attention to the ``testLimit()`` and the execution of ``createLimitIncreaseOrder()``. Please comment out the checks for signature, timestamp and block number for oracle price in the source code to run the testing smoothly without revert.\n\n```javascript\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"../contracts/role/RoleStore.sol\";\nimport \"../contracts/router/ExchangeRouter.sol\";\nimport \"../contracts/data/DataStore.sol\";\nimport \"../contracts/referral/ReferralStorage.sol\";\n\nimport \"../contracts/token/IWNT.sol\";\nimport \"../contracts/token/WNT.sol\";\nimport \"../contracts/token/SOLToken.sol\";\nimport \"../contracts/token/USDC.sol\";\nimport \"../contracts/token/tokenA.sol\";\nimport \"../contracts/token/tokenB.sol\";\nimport \"../contracts/token/tokenC.sol\";\n\nimport \"../contracts/market/MarketFactory.sol\";\nimport \"../contracts/deposit/DepositUtils.sol\";\nimport \"../contracts/oracle/OracleUtils.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport \"../contracts/withdrawal/WithdrawalUtils.sol\";\nimport \"../contracts/order/Order.sol\";\nimport \"../contracts/order/BaseOrderUtils.sol\";\nimport \"../contracts/price/Price.sol\";\nimport \"../contracts/utils/Debug.sol\";\nimport \"../contracts/position/Position.sol\";\nimport \"../contracts/exchange/LiquidationHandler.sol\";\nimport \"../contracts/utils/Calc.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n\ncontract CounterTest is Test, Debug{\n     using SignedMath for int256;\n    using SafeCast for uint256;\n\n\n    WNT _wnt; \n    USDC _usdc;\n    SOLToken _sol;\n    tokenA _tokenA;\n    tokenB _tokenB;\n    tokenC _tokenC;\n\n    RoleStore _roleStore;\n    Router _router;\n    DataStore _dataStore;\n    EventEmitter _eventEmitter;\n    DepositVault _depositVault;\n    OracleStore _oracleStore; \n    Oracle _oracle;\n    DepositHandler _depositHandler;\n    WithdrawalVault _withdrawalVault;\n    WithdrawalHandler _withdrawalHandler;\n    OrderHandler _orderHandler;\n    SwapHandler _swapHandler;\n    LiquidationHandler _liquidationHandler;\n    ReferralStorage _referralStorage;\n    OrderVault _orderVault;\n    ExchangeRouter _erouter;\n    MarketFactory _marketFactory;\n    Market.Props _marketProps1;\n    Market.Props _marketPropsAB;\n    Market.Props _marketPropsBC;\n    Market.Props _marketPropsCwnt;\n    \n    \n    address depositor1;\n    address depositor2;\n    address depositor3;\n    address uiFeeReceiver = address(333);\n\n\n    function testGetFundingAmountPerSizeDelta() public{\n        uint result = MarketUtils.getFundingAmountPerSizeDelta(2e15, 1e15+1, true);\n        console2.log(\"result: %d\", result);\n        uint256 correctResult = 2e15 * 1e15 * 1e30 + 1e15; // this is a real round up\n        correctResult = correctResult/(1e15+1);\n        console2.log(\"correctResult: %d\", correctResult);\n        assertTrue(result  == 1e15 * 1e30);\n    }\n\n   \n\n    function setUp() public {\n        _wnt = new WNT();\n        _usdc = new USDC();\n        _sol = new SOLToken();\n        _tokenA = new tokenA();\n        _tokenB = new tokenB();\n         _tokenC = new tokenC();\n        \n\n\n         _roleStore = new RoleStore();\n         _router = new Router(_roleStore);\n         _dataStore = new DataStore(_roleStore);\n         \n         _eventEmitter= new EventEmitter(_roleStore);\n        _depositVault = new DepositVault(_roleStore, _dataStore);\n        _oracleStore = new OracleStore(_roleStore, _eventEmitter);\n        _oracle = new Oracle(_roleStore, _oracleStore);\n        console2.logString(\"_oracle:\"); console2.logAddress(address(_oracle));\n        \n         _depositHandler = new DepositHandler(_roleStore, _dataStore, _eventEmitter, _depositVault, _oracle);\n         console2.logString(\"_depositHandler:\"); console2.logAddress(address(_depositHandler));\n        \n\n       _withdrawalVault = new WithdrawalVault(_roleStore, _dataStore);\n        _withdrawalHandler = new WithdrawalHandler(_roleStore, _dataStore, _eventEmitter, _withdrawalVault, _oracle);\n \n \n        _swapHandler = new SwapHandler(_roleStore);\n        _orderVault = new OrderVault(_roleStore, _dataStore);\n        _referralStorage = new ReferralStorage();\n\n\n        \n        _orderHandler = new OrderHandler(_roleStore, _dataStore, _eventEmitter, _orderVault, _oracle, _swapHandler, _referralStorage);  \n        _erouter = new ExchangeRouter(_router, _roleStore, _dataStore, _eventEmitter, _depositHandler, _withdrawalHandler, _orderHandler);\n         console2.logString(\"_erouter:\"); console2.logAddress(address(_erouter));\n         _liquidationHandler = new LiquidationHandler(_roleStore, _dataStore, _eventEmitter, _orderVault, _oracle, _swapHandler, _referralStorage);\n       \n        _referralStorage.setHandler(address(_orderHandler), true);  \n\n        /* set myself as the controller so that I can set the address of WNT (wrapped native token contracdt) */\n        _roleStore.grantRole(address(this), Role.CONTROLLER);\n        _roleStore.grantRole(address(this), Role.MARKET_KEEPER);\n        \n        _dataStore.setUint(Keys.MAX_SWAP_PATH_LENGTH, 5); // at most 5 markets in the path\n        \n        _dataStore.setAddress(Keys.WNT, address(_wnt));\n\n        /* set the token transfer gas limit for wnt as 3200 */\n        _dataStore.setUint(Keys.tokenTransferGasLimit(address(_wnt)), 32000);  \n        _dataStore.setUint(Keys.tokenTransferGasLimit(address(_usdc)), 32000);  \n             \n\n        /* create a market (SQL, WNT, ETH, USDC) */\n        _marketFactory = new MarketFactory(_roleStore, _dataStore, _eventEmitter);\n        console2.logString(\"_marketFactory:\"); console2.logAddress(address(_marketFactory));\n        _roleStore.grantRole(address(_marketFactory), Role.CONTROLLER); // to save a market's props\n        _roleStore.grantRole(address(_erouter), Role.CONTROLLER); \n        _roleStore.grantRole(address(_depositHandler), Role.CONTROLLER); \n        _roleStore.grantRole(address(_withdrawalHandler), Role.CONTROLLER); \n         _roleStore.grantRole(address(_swapHandler), Role.CONTROLLER);\n        _roleStore.grantRole(address(_orderHandler), Role.CONTROLLER);   \n        _roleStore.grantRole(address(_liquidationHandler), Role.CONTROLLER);     \n        _roleStore.grantRole(address(_oracleStore), Role.CONTROLLER); // so it can call EventEmitter\n        _roleStore.grantRole(address(_oracle), Role.CONTROLLER); // so it can call EventEmitter\n        _roleStore.grantRole(address(this), Role.ORDER_KEEPER);\n        _roleStore.grantRole(address(this), Role.LIQUIDATION_KEEPER);\n\n        \n        _marketProps1 = _marketFactory.createMarket(address(_sol), address(_wnt), address(_usdc), keccak256(abi.encode(\"sol-wnt-usdc\"))); \n        _marketPropsAB = _marketFactory.createMarket(address(0), address(_tokenA), address(_tokenB), keccak256(abi.encode(\"swap-tokenA-tokenB\"))); \n        _marketPropsBC = _marketFactory.createMarket(address(0), address(_tokenB), address(_tokenC), keccak256(abi.encode(\"swap-tokenB-tokenC\"))); \n        _marketPropsCwnt = _marketFactory.createMarket(address(0), address(_tokenC), address(_wnt), keccak256(abi.encode(\"swap-tokenC-wnt\"))); \n        \n        \n        _dataStore.setUint(Keys.minCollateralFactorForOpenInterestMultiplierKey(_marketProps1.marketToken, true), 1e25);\n        _dataStore.setUint(Keys.minCollateralFactorForOpenInterestMultiplierKey(_marketProps1.marketToken, false), 1e25);\n        \n        // see fees for the market\n        _dataStore.setUint(Keys.swapFeeFactorKey(_marketProps1.marketToken), 0.05e30); // 5%\n        _dataStore.setUint(Keys.SWAP_FEE_RECEIVER_FACTOR, 0.5e30);\n        _dataStore.setUint(Keys.positionFeeFactorKey(_marketProps1.marketToken), 0.00001234e30); // 2%\n        _dataStore.setUint(Keys.POSITION_FEE_RECEIVER_FACTOR, 0.15e30);\n         _dataStore.setUint(Keys.MAX_UI_FEE_FACTOR, 0.01e30);\n        _dataStore.setUint(Keys.uiFeeFactorKey(uiFeeReceiver), 0.01e30); // only when this is set, one can receive ui fee, so stealing is not easy\n        _dataStore.setInt(Keys.poolAmountAdjustmentKey(_marketProps1.marketToken, _marketProps1.longToken), 1);\n        _dataStore.setInt(Keys.poolAmountAdjustmentKey(_marketProps1.marketToken, _marketProps1.shortToken), 1);\n        _dataStore.setUint(Keys.swapImpactExponentFactorKey(_marketProps1.marketToken), 10e28);\n        _dataStore.setUint(Keys.swapImpactFactorKey(_marketProps1.marketToken, true), 0.99e30);\n        _dataStore.setUint(Keys.swapImpactFactorKey(_marketProps1.marketToken, false), 0.99e30);\n\n       \n        \n        \n        // set gas limit to transfer a token\n        _dataStore.setUint(Keys.tokenTransferGasLimit(address(_sol)), 32000);  \n        _dataStore.setUint(Keys.tokenTransferGasLimit(address(_wnt)), 32000);  \n        _dataStore.setUint(Keys.tokenTransferGasLimit(address(_usdc)), 32000);  \n        _dataStore.setUint(Keys.tokenTransferGasLimit(address(_tokenA)), 32000);  \n        _dataStore.setUint(Keys.tokenTransferGasLimit(address(_tokenB)), 32000);  \n        _dataStore.setUint(Keys.tokenTransferGasLimit(address(_tokenC)), 32000); \n        _dataStore.setUint(Keys.tokenTransferGasLimit(address(_marketProps1.marketToken)), 32000);  \n        _dataStore.setUint(Keys.tokenTransferGasLimit(address(_marketPropsAB.marketToken)), 32000);\n        _dataStore.setUint(Keys.tokenTransferGasLimit(address(_marketPropsBC.marketToken)), 32000);\n        _dataStore.setUint(Keys.tokenTransferGasLimit(address(_marketPropsCwnt.marketToken)), 32000);\n\n\n        /* Configure the system parameters/limits here */\n        _dataStore.setUint(Keys.MAX_CALLBACK_GAS_LIMIT, 10000);\n        _dataStore.setUint(Keys.EXECUTION_GAS_FEE_BASE_AMOUNT, 100);\n        _dataStore.setUint(Keys.MAX_ORACLE_PRICE_AGE, 2 hours);\n        _dataStore.setUint(Keys.MIN_ORACLE_BLOCK_CONFIRMATIONS, 3);\n        _dataStore.setUint(Keys.MIN_COLLATERAL_USD, 1e30);  // just require $1 as min collateral usd\n        _dataStore.setUint(Keys.reserveFactorKey(_marketProps1.marketToken, true), 5e29); // 50%\n        _dataStore.setUint(Keys.reserveFactorKey(_marketProps1.marketToken, false), 5e29);\n        _dataStore.setUint(Keys.fundingExponentFactorKey(_marketProps1.marketToken), 1.1e30); // 2 in 30 decimals like a square, cube, etc\n         _dataStore.setUint(Keys.fundingFactorKey(_marketProps1.marketToken), 0.0000001e30);\n         _dataStore.setUint(Keys.borrowingFactorKey(_marketProps1.marketToken, true), 0.87e30);\n         _dataStore.setUint(Keys.borrowingFactorKey(_marketProps1.marketToken, false), 0.96e30);\n         _dataStore.setUint(Keys.borrowingExponentFactorKey(_marketProps1.marketToken, true), 2.1e30);\n         _dataStore.setUint(Keys.borrowingExponentFactorKey(_marketProps1.marketToken, false), 2.3e30);\n         _dataStore.setUint(Keys.positionImpactExponentFactorKey(_marketProps1.marketToken), 2e30);\n         _dataStore.setUint(Keys.positionImpactFactorKey(_marketProps1.marketToken, true), 5e22); \n         _dataStore.setUint(Keys.positionImpactFactorKey(_marketProps1.marketToken, false), 1e23);\n\n        // set the limit of market tokens\n\n        _dataStore.setUint(Keys.maxPoolAmountKey(_marketProps1.marketToken, _marketProps1.longToken), 1000e18);\n        _dataStore.setUint(Keys.maxPoolAmountKey(_marketProps1.marketToken, _marketProps1.shortToken), 1000e18);\n        _dataStore.setUint(Keys.maxPoolAmountKey(_marketPropsAB.marketToken, _marketPropsAB.longToken), 1000e18);\n        _dataStore.setUint(Keys.maxPoolAmountKey(_marketPropsAB.marketToken, _marketPropsAB.shortToken), 1000e18);\n        _dataStore.setUint(Keys.maxPoolAmountKey(_marketPropsBC.marketToken, _marketPropsBC.longToken), 1000e18);\n        _dataStore.setUint(Keys.maxPoolAmountKey(_marketPropsBC.marketToken, _marketPropsBC.shortToken), 1000e18);\n        _dataStore.setUint(Keys.maxPoolAmountKey(_marketPropsCwnt.marketToken, _marketPropsCwnt.longToken), 1000e18);\n        _dataStore.setUint(Keys.maxPoolAmountKey(_marketPropsCwnt.marketToken, _marketPropsCwnt.shortToken), 1000e18);\n        \n        \n        // set max open interest for each market\n        _dataStore.setUint(Keys.maxOpenInterestKey(_marketProps1.marketToken, true), 1e39); // 1B $ \n        _dataStore.setUint(Keys.maxOpenInterestKey(_marketProps1.marketToken, false), 1e39); // 1B $\n\n        _dataStore.setUint(Keys.maxPnlFactorKey(Keys.MAX_PNL_FACTOR_FOR_WITHDRAWALS, _marketProps1.marketToken, true), 10**29); // maxPnlFactor = 10% for long\n         _dataStore.setUint(Keys.maxPnlFactorKey(Keys.MAX_PNL_FACTOR_FOR_WITHDRAWALS, _marketProps1.marketToken, false), 10**29); // maxPnlFactor = 10% for short\n        // _dataStore.setBool(Keys.cancelDepositFeatureDisabledKey(address(_depositHandler)), true);\n        _dataStore.setBool(Keys.cancelOrderFeatureDisabledKey(address(_orderHandler), uint256(Order.OrderType.MarketIncrease)), true);\n\n         addFourSigners();\n         address(_wnt).call{value: 10000e18}(\"\");\n         depositor1 = address(0x801);\n         depositor2 = address(0x802);\n         depositor3 = address(0x803);\n\n         // make sure each depositor has some tokens.\n         _wnt.transfer(depositor1, 1000e18);\n         _wnt.transfer(depositor2, 1000e18);\n         _wnt.transfer(depositor3, 1000e18);  \n         _usdc.transfer(depositor1, 1000e18);\n         _usdc.transfer(depositor2, 1000e18);\n         _usdc.transfer(depositor3, 1000e18);\n         _tokenA.transfer(depositor1, 1000e18);\n         _tokenB.transfer(depositor1, 1000e18);\n         _tokenC.transfer(depositor1, 1000e18);   \n\n         printAllTokens();                 \n    }\n\n    error Unauthorized(string);\n   // error Error(string);\n\n\nfunction testLimit() public{\n          OracleUtils.SetPricesParams memory priceParams = createSetPricesParams();\n          \n          vm.roll(block.number+2); // block 3\n\n          \n          bytes32 key = createDepositNoSwap(_marketProps1, depositor1, 90e18, true); // create a deposit at block 3 which is within range (2, 6)          \n          _depositHandler.executeDeposit(key, priceParams);  \n          uint mintedMarketTokens = IERC20(_marketProps1.marketToken).balanceOf(depositor1);\n          key = createDepositNoSwap(_marketProps1, depositor1, 100e18, false); // create a deposit at block 3 which is within range (2, 6)          \n          _depositHandler.executeDeposit(key, priceParams);  \n          mintedMarketTokens = IERC20(_marketProps1.marketToken).balanceOf(depositor1);\n          console2.log(\"Experiment 1  is completed.\");     \n      \n          // console2.log(\"PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP\");\n          \n          key = createMarketSwapOrder(depositor1,  address(_wnt), 1e15); // create a deposit at block 3 which is within range (2, 6)          \n          _orderHandler.executeOrder(key, priceParams);  \n          console2.log(\"Experiment 2  is completed.\");    \n   \n\n        console2.log(\"\\n\\n depositor 1 createMarketIncreaseOrder\");\n         key = createMarketIncreaseOrder(depositor1, _marketProps1.marketToken, _marketProps1.longToken, 20e18, 1001e30, 106000000000000, true); // \n         console2.log(\"\\nExecuting the order...\");\n         _orderHandler.executeOrder(key, priceParams);\n         Position.printPosition(_dataStore, depositor1, _marketProps1.marketToken, _marketProps1.longToken, true);\n         console2.log(\"Experiment 3  is completed.\");     \n      \n          \n\n        console2.log(\"\\n\\n depositor 2 createMarketIncreaseOrder\");\n         key = createMarketIncreaseOrder(depositor2, _marketProps1.marketToken, _marketProps1.longToken, 110e18, 13e30, 101000000000000, false); // 110 usdc as collateral\n         console2.log(\"\\nExecuting the order...\");\n         _orderHandler.executeOrder(key, priceParams);\n         Position.printPosition(_dataStore, depositor2, _marketProps1.marketToken, _marketProps1.longToken, false);\n       console2.log(\"Experiment 4  is completed.\");     \n      \n\n\n        console2.log(\"PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP\");\n        vm.warp(2 days);\n        setIndexTokenPrice(priceParams, 98, 100); // send 20e18 USDC, increase $13.123 in a long position with trigger price 101\n        key = createLimitIncreaseOrder(depositor3, _marketProps1.marketToken, _marketProps1.shortToken, 23e18, 1.1234567e30, 101000000000000, true); // collateral token, usdsize, price\n        console2.log(\"a LimitIncrease order created by depositor3 with key: \");\n         console2.logBytes32(key);\n         Position.printPosition(_dataStore, depositor3, _marketProps1.marketToken, _marketProps1.shortToken, true);\n         console2.log(\"\\n\\nExecuting the order, exiting moment...\\n\\n\");\n         _orderHandler.executeOrder(key, priceParams);\n         Position.printPosition(_dataStore, depositor3, _marketProps1.marketToken, _marketProps1.shortToken, true);\n         console2.log(\"Experiment  5 is completed.\\n\");     \n      \n\n        // depositor3 creates a LimitDecrease order\n        /*\n        setIndexTokenPrice(priceParams, 120, 125);\n        key = createLimitDecreaseOrder(depositor3, _marketProps1.marketToken, _marketProps1.shortToken, 7e18, 58e30, 120000000000000, 120000000000000, true); // retrieve $50? collateral token, usdsize, acceptible price\n        console2.log(\"a LimitIncrease order created by depositor3 with key: \");\n         console2.logBytes32(key);\n         Position.printPosition(_dataStore, depositor3, _marketProps1.marketToken, _marketProps1.shortToken, true);\n         console2.log(\"\\n\\nExecuting the order, exiting moment...\\n\\n\");\n          _orderHandler.executeOrder(key, priceParams);          \n        console2.log(\"Experiment 7 for is completed.\");     \n        */\n}\n\nfunction testMarketDecrease() public{\n    \n          OracleUtils.SetPricesParams memory priceParams = createSetPricesParams();\n          \n          vm.roll(block.number+2); // block 3\n\n          \n          bytes32 key = createDepositNoSwap(_marketProps1, depositor1, 90e18, true); // create a deposit at block 3 which is within range (2, 6)          \n          _depositHandler.executeDeposit(key, priceParams);  \n          uint mintedMarketTokens = IERC20(_marketProps1.marketToken).balanceOf(depositor1);\n          key = createDepositNoSwap(_marketProps1, depositor1, 100e18, false); // create a deposit at block 3 which is within range (2, 6)          \n          _depositHandler.executeDeposit(key, priceParams);  \n          mintedMarketTokens = IERC20(_marketProps1.marketToken).balanceOf(depositor1);\n         console2.log(\"Experiment 1  is completed.\");     \n      \n          \n          \n        \n          console2.log(\"\\n\\n depositor 2 deposit into marketProps1\");\n          key = createDepositNoSwap(_marketProps1, depositor2, 100e18, true);\n          _depositHandler.executeDeposit(key, priceParams);\n         mintedMarketTokens = IERC20(_marketProps1.marketToken).balanceOf(depositor2);\n          printPoolsAmounts();\n         console2.log(\"Experiment 2  is completed.\");     \n      \n       \n        console2.log(\"\\n\\n depositor 1 createMarketIncreaseOrder\");\n         key = createMarketIncreaseOrder(depositor1, _marketProps1.marketToken, _marketProps1.longToken, 20e18, 1e25, 106000000000000, true); // \n         console2.log(\"\\nExecuting the order...\");\n         _orderHandler.executeOrder(key, priceParams);\n         Position.printPosition(_dataStore, depositor1, _marketProps1.marketToken, _marketProps1.longToken, true);\n         console2.log(\"Experiment 3  is completed.\");     \n      \n          \n\n        console2.log(\"\\n\\n depositor 2 createMarketIncreaseOrder\");\n         key = createMarketIncreaseOrder(depositor2, _marketProps1.marketToken, _marketProps1.longToken, 110e18, 1e25, 101000000000000, false); // 110 usdc as collateral\n         console2.log(\"\\nExecuting the order...\");\n         _orderHandler.executeOrder(key, priceParams);\n         Position.printPosition(_dataStore, depositor2, _marketProps1.marketToken, _marketProps1.longToken, false);\n       console2.log(\"Experiment 4  is completed.\");     \n      \n        console2.log(\"********************************************\");\n\n         // deposit 2 will execute a marketDecreaseOrder now\n         key =  createMarketDecreaseOrder(depositor2, _marketProps1.marketToken, _marketProps1.longToken, 70000000000000, 5e23, false) ; // decrease by 5%\n         console2.log(\"a market desced order created with key: \");\n         console2.logBytes32(key);\n         console2.log(\"\\nExecuting the order...\");         \n         setIndexTokenPrice(priceParams, 60, 65); // we have a profit for a short position\n         _orderHandler.executeOrder(key, priceParams);\n         Position.printPosition(_dataStore, depositor2, _marketProps1.marketToken, _marketProps1.longToken, false);\n         console2.log(\"Experiment 5  is completed.\");  \n\n          printAllTokens();\n}   \n\n   \n\nfunction  testLiquidation() public{\n          // blockrange (2, 6)\n          OracleUtils.SetPricesParams memory priceParams = createSetPricesParams();\n          \n          vm.roll(block.number+2); // block 3\n\n          \n          bytes32 key = createDepositNoSwap(_marketProps1, depositor1, 90e18, true); // create a deposit at block 3 which is within range (2, 6)          \n          _depositHandler.executeDeposit(key, priceParams);  \n          uint mintedMarketTokens = IERC20(_marketProps1.marketToken).balanceOf(depositor1);\n          key = createDepositNoSwap(_marketProps1, depositor1, 100e18, false); // create a deposit at block 3 which is within range (2, 6)          \n          _depositHandler.executeDeposit(key, priceParams);  \n          mintedMarketTokens = IERC20(_marketProps1.marketToken).balanceOf(depositor1);\n         console2.log(\"Experiment 1  is completed.\");     \n      \n          \n          \n        \n          console2.log(\"\\n\\n depositor 2 deposit into marketProps1\");\n          key = createDepositNoSwap(_marketProps1, depositor2, 100e18, true);\n          _depositHandler.executeDeposit(key, priceParams);\n         mintedMarketTokens = IERC20(_marketProps1.marketToken).balanceOf(depositor2);\n          printPoolsAmounts();\n         console2.log(\"Experiment 2  is completed.\");     \n      \n       \n        console2.log(\"\\n\\n depositor 1 createMarketIncreaseOrder\");\n         key = createMarketIncreaseOrder(depositor1, _marketProps1.marketToken, _marketProps1.longToken, 10e18, 1e25, 106000000000000, true);\n         console2.log(\"\\nExecuting the order...\");\n         _orderHandler.executeOrder(key, priceParams);\n         Position.printPosition(_dataStore, depositor1, _marketProps1.marketToken, _marketProps1.longToken, true);\n         console2.log(\"Experiment 3  is completed.\");     \n      \n          \n\n        console2.log(\"\\n\\n depositor 2 createMarketIncreaseOrder\");\n         key = createMarketIncreaseOrder(depositor2, _marketProps1.marketToken, _marketProps1.shortToken, 100e18, 1e25, 101000000000000, false);\n         console2.log(\"\\nExecuting the order...\");\n         _orderHandler.executeOrder(key, priceParams);\n         Position.printPosition(_dataStore, depositor2, _marketProps1.marketToken, _marketProps1.shortToken, false);\n       console2.log(\"Experiment 4  is completed.\");     \n      \n          \n\n         // deposit 2 will execute a marketDecreaseOrder now\n         key =  createMarketDecreaseOrder(depositor2, _marketProps1.marketToken, _marketProps1.shortToken, 106000000000000, 5e23, false) ; // decrease by 5%\n         console2.log(\"a market desced order created with key: \");\n         console2.logBytes32(key);\n         console2.log(\"\\nExecuting the order...\");         \n         setIndexTokenPrice(priceParams, 84, 90);\n         _orderHandler.executeOrder(key, priceParams);\n         Position.printPosition(_dataStore, depositor2, _marketProps1.marketToken, _marketProps1.shortToken, false);\n         console2.log(\"Experiment 5  is completed.\");     \n      \n          \n\n        \n        // depositor3 will execute a LimitIncrease Order now\n        key = createMarketIncreaseOrder(depositor3, _marketProps1.marketToken, _marketProps1.shortToken, 20e18, 200e30, 101000000000000, true); // collateral token, usdsize, price\n        console2.log(\"a LimitIncrease order created by depositor3 with key: \");\n         console2.logBytes32(key);\n         Position.printPosition(_dataStore, depositor3, _marketProps1.marketToken, _marketProps1.shortToken, true);\n         console2.log(\"\\n\\nExecuting the order, exiting moment...\\n\\n\");\n         _orderHandler.executeOrder(key, priceParams);\n         Position.printPosition(_dataStore, depositor3, _marketProps1.marketToken, _marketProps1.shortToken, true);\n         console2.log(\"Experiment  6 is completed.\\n\");     \n      \n\n        // depositor3 creates a LimitDecrease order\n        setIndexTokenPrice(priceParams, 120, 125);\n        key = createLimitDecreaseOrder(depositor3, _marketProps1.marketToken, _marketProps1.shortToken, 7e18, 58e30, 120000000000000, 120000000000000, true); // retrieve $50? collateral token, usdsize, acceptible price\n        console2.log(\"a LimitIncrease order created by depositor3 with key: \");\n         console2.logBytes32(key);\n         Position.printPosition(_dataStore, depositor3, _marketProps1.marketToken, _marketProps1.shortToken, true);\n         console2.log(\"\\n\\nExecuting the order, exiting moment...\\n\\n\");\n          _orderHandler.executeOrder(key, priceParams);          \n        console2.log(\"Experiment 7 for is completed.\");     \n      \n        // depositor3 creates a stopLossDecrease order\n        setIndexTokenPrice(priceParams, 97, 99);\n        key = createStopLossDecrease(depositor3, _marketProps1.marketToken, _marketProps1.shortToken, 7e18, 58e30, 95000000000000, 92000000000000, true); // retrieve $50? collateral token, usdsize, acceptible price\n        console2.log(\"a StopLossDecrease order created by depositor3 with key: \");\n         console2.logBytes32(key);\n         // Position.printPosition(_dataStore, depositor3, _marketProps1.marketToken, _marketProps1.shortToken, true);\n\n        console2.log(\"\\n\\nExecuting the order, exiting moment...\\n\\n\");\n        _orderHandler.executeOrder(key, priceParams);\n        console2.log(\"Experiment 8 is completed.\");     \n      \n        \n         console2.log(\"\\n\\n*************************************************\\n\\n\");\n\n\n        // depositor3 creates a Liquidation order\n        setIndexTokenPrice(priceParams, 75, 75);\n        console2.log(\"Liquidate a position...\");\n        Position.printPosition(_dataStore, depositor3, _marketProps1.marketToken, _marketProps1.shortToken, true);\n        _liquidationHandler.executeLiquidation(depositor3, _marketProps1.marketToken, _marketProps1.shortToken, true, priceParams);\n        console2.log(\"Experiment 9 is completed.\");     \n      \n\n         // printPoolsAmounts();\n         printAllTokens();\n\n             \n      \n         \n}\n\nfunction printAllTokens() startedCompleted(\"printAllTokens\") public\n{\n      console2.log(\"\\nTokens used in this test:\");\n        console2.log(\"_wnt: \"); console2.logAddress(address(_wnt));\n        console2.log(\"_usdc: \"); console2.logAddress(address(_usdc));\n        console2.log(\"_sol: \"); console2.logAddress(address(_sol));\n        console2.log(\"_tokenA: \"); console2.logAddress(address(_tokenA));\n        console2.log(\"_tokenB: \"); console2.logAddress(address(_tokenB));\n        console2.log(\"_tokenC: \"); console2.logAddress(address(_tokenC));\n        console2.logString(\"test contract address:\"); console2.logAddress(address(this));\n        \n        console2.log(\"_marketProps1 market token: \"); console2.logAddress(address(_marketProps1.marketToken));\n        console2.log(\"_marketPropsAB market token: \"); console2.logAddress(address(_marketPropsAB.marketToken));\n        console2.log(\"_marketPropsBC market token: \"); console2.logAddress(address(_marketPropsBC.marketToken));\n        console2.log(\"_marketProps1Cwnt market token: \"); console2.logAddress(address(_marketPropsCwnt.marketToken));\n        console2.log(\"\\n\");\n        \n        \n}\n\n\nfunction printMarketTokenAmount() public \n{   console2.log(\"Market token address: \");\n    console2.logAddress(address(_marketProps1.marketToken));\n    console2.log(\"depositor1 market token amount: %d\", IERC20(_marketProps1.marketToken).balanceOf(depositor1));\n    console2.log(\"depositor2 market token amount: %d\", IERC20(_marketProps1.marketToken).balanceOf(depositor2));\n    console2.log(\"depositor3 market token amount: %d\", IERC20(_marketProps1.marketToken).balanceOf(depositor3));\n}\n\nfunction printLongShortTokens(address account) public\n{\n    console2.log(\"balance for \"); console2.logAddress(account);\n    console2.log(\"_wnt balance",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/74",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/position/PositionUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"../utils/Precision.sol\";\n\nimport \"./Position.sol\";\n\nimport \"../data/DataStore.sol\";\nimport \"../data/Keys.sol\";\n\nimport \"../pricing/PositionPricingUtils.sol\";\nimport \"../order/BaseOrderUtils.sol\";\n\n// @title PositionUtils\n// @dev Library for position functions\nlibrary PositionUtils {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using Price for Price.Props;\n    using Position for Position.Props;\n    using Order for Order.Props;\n\n    // @dev UpdatePositionParams struct used in increasePosition to avoid\n    // stack too deep errors\n    //\n    // @param contracts BaseOrderUtils.ExecuteOrderParamsContracts\n    // @param market the values of the trading market\n    // @param order the decrease position order\n    // @param orderKey the key of the order\n    // @param position the order's position\n    // @param positionKey the key of the order's position\n    struct UpdatePositionParams {\n        BaseOrderUtils.ExecuteOrderParamsContracts contracts;\n        Market.Props market;\n        Order.Props order;\n        bytes32 orderKey;\n        Position.Props position;\n        bytes32 positionKey;\n    }\n\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param oracle Oracle\n    // @param referralStorage IReferralStorage\n    struct UpdatePositionParamsContracts {\n        DataStore dataStore;\n        EventEmitter eventEmitter;\n        Oracle oracle;\n        SwapHandler swapHandler;\n        IReferralStorage referralStorage;\n    }\n\n    struct WillPositionCollateralBeSufficientValues {\n        uint256 positionSizeInUsd;\n        uint256 positionCollateralAmount;\n        int256 realizedPnlUsd;\n        int256 openInterestDelta;\n    }\n\n    struct DecreasePositionCollateralValuesOutput {\n        address outputToken;\n        uint256 outputAmount;\n        address secondaryOutputToken;\n        uint256 secondaryOutputAmount;\n    }\n\n    // @dev ProcessCollateralValues struct used to contain the values in processCollateral\n    // @param executionPrice the order execution price\n    // @param remainingCollateralAmount the remaining collateral amount of the position\n    // @param outputAmount the output amount\n    // @param positionPnlUsd the pnl of the position in USD\n    // @param pnlAmountForPool the pnl for the pool in token amount\n    // @param pnlAmountForUser the pnl for the user in token amount\n    // @param sizeDeltaInTokens the change in position size in tokens\n    // @param priceImpactAmount the price impact in tokens\n    struct DecreasePositionCollateralValues {\n        address pnlTokenForPool;\n        uint256 executionPrice;\n        int256 remainingCollateralAmount;\n        int256 positionPnlUsd;\n        int256 pnlAmountForPool;\n        uint256 pnlAmountForUser;\n        uint256 sizeDeltaInTokens;\n        int256 priceImpactAmount;\n        uint256 priceImpactDiffUsd;\n        uint256 priceImpactDiffAmount;\n        DecreasePositionCollateralValuesOutput output;\n    }\n\n    // @dev DecreasePositionCache struct used in decreasePosition to\n    // avoid stack too deep errors\n    // @param prices the prices of the tokens in the market\n    // @param pnlToken the token that the pnl for the user is in, for long positions\n    // this is the market.longToken, for short positions this is the market.shortToken\n    // @param pnlTokenPrice the price of the pnlToken\n    // @param initialCollateralAmount the initial collateral amount\n    // @param nextPositionSizeInUsd the new position size in USD\n    // @param nextPositionBorrowingFactor the new position borrowing factor\n    struct DecreasePositionCache {\n        MarketUtils.MarketPrices prices;\n        int256 estimatedPositionPnlUsd;\n        int256 estimatedRealizedPnlUsd;\n        int256 estimatedRemainingPnlUsd;\n        address pnlToken;\n        Price.Props pnlTokenPrice;\n        uint256 initialCollateralAmount;\n        uint256 nextPositionSizeInUsd;\n        uint256 nextPositionBorrowingFactor;\n    }\n\n\n    struct GetPositionPnlUsdCache {\n        int256 positionValue;\n        int256 totalPositionPnl;\n        address pnlToken;\n        uint256 poolTokenAmount;\n        uint256 poolTokenPrice;\n        uint256 poolTokenUsd;\n        int256 poolPnl;\n        int256 cappedPoolPnl;\n        uint256 sizeDeltaInTokens;\n        int256 positionPnlUsd;\n    }\n\n    // @dev IsPositionLiquidatableCache struct used in isPositionLiquidatable\n    // to avoid stack too deep errors\n    // @param positionPnlUsd the position's pnl in USD\n    // @param minCollateralFactor the min collateral factor\n    // @param collateralTokenPrice the collateral token price\n    // @param collateralUsd the position's collateral in USD\n    // @param usdDeltaForPriceImpact the usdDelta value for the price impact calculation\n    // @param priceImpactUsd the price impact of closing the position in USD\n    // @param minCollateralUsd the minimum allowed collateral in USD\n    // @param remainingCollateralUsd the remaining position collateral in USD\n    struct IsPositionLiquidatableCache {\n        int256 positionPnlUsd;\n        uint256 minCollateralFactor;\n        Price.Props collateralTokenPrice;\n        uint256 collateralUsd;\n        int256 usdDeltaForPriceImpact;\n        int256 priceImpactUsd;\n        int256 minCollateralUsd;\n        int256 minCollateralUsdForLeverage;\n        int256 remainingCollateralUsd;\n    }\n\n    // @dev get the position pnl in USD\n    //\n    // for long positions, pnl is calculated as:\n    // (position.sizeInTokens * indexTokenPrice) - position.sizeInUsd\n    // if position.sizeInTokens is larger for long positions, the position will have\n    // larger profits and smaller losses for the same changes in token price\n    //\n    // for short positions, pnl is calculated as:\n    // position.sizeInUsd -  (position.sizeInTokens * indexTokenPrice)\n    // if position.sizeInTokens is smaller for long positions, the position will have\n    // larger profits and smaller losses for the same changes in token price\n    //\n    // @param position the position values\n    // @param sizeDeltaUsd the change in position size\n    // @param indexTokenPrice the price of the index token\n    //\n    // @return (positionPnlUsd, sizeDeltaInTokens)\n    function getPositionPnlUsd(\n        DataStore dataStore,\n        Market.Props memory market,\n        MarketUtils.MarketPrices memory prices,\n        Position.Props memory position,\n        uint256 indexTokenPrice,\n        uint256 sizeDeltaUsd\n    ) public view returns (int256, uint256) {\n        GetPositionPnlUsdCache memory cache;\n\n        // position.sizeInUsd is the cost of the tokens, positionValue is the current worth of the tokens\n        cache.positionValue = (position.sizeInTokens() * indexTokenPrice).toInt256();\n        cache.totalPositionPnl = position.isLong() ? cache.positionValue - position.sizeInUsd().toInt256() : position.sizeInUsd().toInt256() - cache.positionValue;\n\n        if (cache.totalPositionPnl > 0) {\n            cache.pnlToken = position.isLong() ? market.longToken : market.shortToken;\n            cache.poolTokenAmount = MarketUtils.getPoolAmount(dataStore, market, cache.pnlToken);\n            cache.poolTokenPrice = position.isLong() ? prices.longTokenPrice.min : prices.shortTokenPrice.min;\n            cache.poolTokenUsd = cache.poolTokenAmount * cache.poolTokenPrice;\n            cache.poolPnl = MarketUtils.getPnl(\n                dataStore,\n                market,\n                indexTokenPrice,\n                position.isLong(),\n                true\n            );\n\n            cache.cappedPoolPnl = MarketUtils.getCappedPnl(\n                dataStore,\n                market.marketToken,\n                position.isLong(),\n                cache.poolPnl,\n                cache.poolTokenUsd,\n                Keys.MAX_PNL_FACTOR_FOR_TRADERS\n            );\n\n            if (cache.cappedPoolPnl != cache.poolPnl && cache.cappedPoolPnl > 0 && cache.poolPnl > 0) {\n                cache.totalPositionPnl = Precision.applyFraction(cache.totalPositionPnl.toUint256(), cache.cappedPoolPnl, cache.poolPnl.toUint256());\n            }\n        }\n\n        cache.sizeDeltaInTokens;\n\n        if (position.sizeInUsd() == sizeDeltaUsd) {\n            cache.sizeDeltaInTokens = position.sizeInTokens();\n        } else {\n            if (position.isLong()) {\n                cache.sizeDeltaInTokens = Calc.roundUpDivision(position.sizeInTokens() * sizeDeltaUsd, position.sizeInUsd());\n            } else {\n                cache.sizeDeltaInTokens = position.sizeInTokens() * sizeDeltaUsd / position.sizeInUsd();\n            }\n        }\n\n        cache.positionPnlUsd = cache.totalPositionPnl * cache.sizeDeltaInTokens.toInt256() / position.sizeInTokens().toInt256();\n\n        return (cache.positionPnlUsd, cache.sizeDeltaInTokens);\n    }\n\n    // @dev get the key for a position\n    // @param account the position's account\n    // @param market the position's market\n    // @param collateralToken the position's collateralToken\n    // @param isLong whether the position is long or short\n    // @return the position key\n    function getPositionKey(address account, address market, address collateralToken, bool isLong) internal pure returns (bytes32) {\n        bytes32 key = keccak256(abi.encode(account, market, collateralToken, isLong));\n        return key;\n    }\n\n    // @dev validate that a position is not empty\n    // @param position the position values\n    function validateNonEmptyPosition(Position.Props memory position) internal pure {\n        if (position.sizeInUsd() == 0 && position.sizeInTokens() == 0 && position.collateralAmount() == 0) {\n            revert Errors.EmptyPosition();\n        }\n    }\n\n    // @dev check if a position is valid\n    // @param dataStore DataStore\n    // @param referralStorage IReferralStorage\n    // @param position the position values\n    // @param market the market values\n    // @param prices the prices of the tokens in the market\n    // @param shouldValidateMinCollateralUsd whether min collateral usd needs to be validated\n    // validation is skipped for decrease position to prevent reverts in case the order size\n    // is just slightly smaller than the position size\n    // in decrease position, the remaining collateral is estimated at the start, and the order\n    // size is updated to match the position size if the remaining collateral will be less than\n    // the min collateral usd\n    // since this is an estimate, there may be edge cases where there is a small remaining position size\n    // and small amount of collateral remaining\n    // validation is skipped for this case as it is preferred for the order to be executed\n    // since the small amount of collateral remaining only impacts the potential payment of liquidation\n    // keepers\n    function validatePosition(\n        DataStore dataStore,\n        IReferralStorage referralStorage,\n        Position.Props memory position,\n        Market.Props memory market,\n        MarketUtils.MarketPrices memory prices,\n        bool isIncrease,\n        bool shouldValidateMinPositionSize,\n        bool shouldValidateMinCollateralUsd\n    ) public view {\n        if (position.sizeInUsd() == 0 || position.sizeInTokens() == 0) {\n            revert Errors.InvalidPositionSizeValues(position.sizeInUsd(), position.sizeInTokens());\n        }\n\n        MarketUtils.validateEnabledMarket(dataStore, market.marketToken);\n        MarketUtils.validateMarketCollateralToken(market, position.collateralToken());\n\n        if (shouldValidateMinPositionSize) {\n            uint256 minPositionSizeUsd = dataStore.getUint(Keys.MIN_POSITION_SIZE_USD);\n            if (position.sizeInUsd() < minPositionSizeUsd) {\n                revert Errors.MinPositionSize(position.sizeInUsd(), minPositionSizeUsd);\n            }\n        }\n\n        if (isPositionLiquidatable(\n            dataStore,\n            referralStorage,\n            position,\n            market,\n            prices,\n            isIncrease,\n            shouldValidateMinCollateralUsd\n        )) {\n            revert Errors.LiquidatablePosition();\n        }\n    }\n\n    // @dev check if a position is liquidatable\n    // @param dataStore DataStore\n    // @param referralStorage IReferralStorage\n    // @param position the position values\n    // @param market the market values\n    // @param prices the prices of the tokens in the market\n    function isPositionLiquidatable(\n        DataStore dataStore,\n        IReferralStorage referralStorage,\n        Position.Props memory position,\n        Market.Props memory market,\n        MarketUtils.MarketPrices memory prices,\n        bool isIncrease,\n        bool shouldValidateMinCollateralUsd\n    ) public view returns (bool) {\n        IsPositionLiquidatableCache memory cache;\n\n        (cache.positionPnlUsd, ) = getPositionPnlUsd(\n            dataStore,\n            market,\n            prices,\n            position,\n            prices.indexTokenPrice.pickPriceForPnl(position.isLong(), false),\n            position.sizeInUsd()\n        );\n\n        cache.collateralTokenPrice = MarketUtils.getCachedTokenPrice(\n            position.collateralToken(),\n            market,\n            prices\n        );\n\n        cache.collateralUsd = position.collateralAmount() * cache.collateralTokenPrice.min;\n\n        cache.usdDeltaForPriceImpact = isIncrease ? position.sizeInUsd().toInt256() : -position.sizeInUsd().toInt256();\n\n        cache.priceImpactUsd = PositionPricingUtils.getPriceImpactUsd(\n            PositionPricingUtils.GetPriceImpactUsdParams(\n                dataStore,\n                market,\n                cache.usdDeltaForPriceImpact,\n                position.isLong()\n            )\n        );\n\n        // even if there is a large positive price impact, positions that would be liquidated\n        // if the positive price impact is reduced should not be allowed to be created\n        // as they would be easily liquidated if the price impact changes\n        // cap the priceImpactUsd to zero to prevent these positions from being created\n        if (cache.priceImpactUsd >= 0) {\n            cache.priceImpactUsd = 0;\n        } else {\n            uint256 maxPriceImpactFactor = MarketUtils.getMaxPositionImpactFactorForLiquidations(\n                dataStore,\n                market.marketToken\n            );\n\n            // if there is a large build up of open interest and a sudden large price movement\n            // it may result in a large imbalance between longs and shorts\n            // this could result in very large price impact temporarily\n            // cap the max negative price impact to prevent cascading liquidations\n            int256 maxNegativePriceImpactUsd = -Precision.applyFactor(position.sizeInUsd(), maxPriceImpactFactor).toInt256();\n            if (cache.priceImpactUsd < maxNegativePriceImpactUsd) {\n                cache.priceImpactUsd = maxNegativePriceImpactUsd;\n            }\n        }\n\n        PositionPricingUtils.GetPositionFeesParams memory getPositionFeesParams = PositionPricingUtils.GetPositionFeesParams(\n            dataStore,\n            referralStorage,\n            position,\n            cache.collateralTokenPrice,\n            market.longToken,\n            market.shortToken,\n            position.sizeInUsd(),\n            address(0) // uiFeeReceiver\n        );\n\n        PositionPricingUtils.PositionFees memory fees = PositionPricingUtils.getPositionFees(getPositionFeesParams);\n\n        uint256 collateralCostUsd = fees.collateralCostAmount * cache.collateralTokenPrice.min;\n\n        // the position's pnl is counted as collateral for the liquidation check\n        // as a position in profit should not be liquidated if the pnl is sufficient\n        // to cover the position's fees\n        cache.remainingCollateralUsd =\n            cache.collateralUsd.toInt256()\n            + cache.positionPnlUsd\n            + cache.priceImpactUsd\n            - collateralCostUsd.toInt256();\n\n        if (shouldValidateMinCollateralUsd) {\n            cache.minCollateralUsd = dataStore.getUint(Keys.MIN_COLLATERAL_USD).toInt256();\n            if (cache.remainingCollateralUsd < cache.minCollateralUsd) {\n                return true;\n            }\n        }\n\n        if (cache.remainingCollateralUsd <= 0) {\n            return true;\n        }\n\n        cache.minCollateralFactor = MarketUtils.getMinCollateralFactor(dataStore, market.marketToken);\n\n        // validate if (remaining collateral) / position.size is less than the min collateral factor (max leverage exceeded)\n        // this validation includes the position fee to be paid when closing the position\n        // i.e. if the position does not have sufficient collateral after closing fees it is considered a liquidatable position\n        cache.minCollateralUsdForLeverage = Precision.applyFactor(position.sizeInUsd(), cache.minCollateralFactor).toInt256();\n\n        if (cache.remainingCollateralUsd < cache.minCollateralUsdForLeverage) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function willPositionCollateralBeSufficient(\n        DataStore dataStore,\n        Market.Props memory market,\n        MarketUtils.MarketPrices memory prices,\n        address collateralToken,\n        bool isLong,\n        WillPositionCollateralBeSufficientValues memory values\n    ) public view returns (bool, int256) {\n        Price.Props memory collateralTokenPrice = MarketUtils.getCachedTokenPrice(\n            collateralToken,\n            market,\n            prices\n        );\n\n        // the min collateral factor will increase as the open interest for a market increases\n        // this may lead to previously created limit increase orders not being executable\n        //\n        // price impact could be gamed by opening high leverage positions, if the price impact\n        // that should be charged is higher than the amount of collateral in the position\n        // then a user could pay less price impact than what is required\n        //\n        // this check helps to prevent gaming of price impact\n        uint256 minCollateralFactor = MarketUtils.getMinCollateralFactorForOpenInterest(\n            dataStore,\n            market,\n            values.openInterestDelta,\n            isLong\n        );\n\n        int256 remainingCollateralUsd = values.positionCollateralAmount.toInt256() * collateralTokenPrice.min.toInt256();\n\n        // deduct realized pnl if it is negative since this would be paid from\n        // the position's collateral\n        if (values.realizedPnlUsd < 0) {\n            remainingCollateralUsd = remainingCollateralUsd + values.realizedPnlUsd;\n        }\n\n        if (remainingCollateralUsd < 0) {\n            return (false, remainingCollateralUsd);\n        }\n\n        int256 minCollateralUsdForLeverage = Precision.applyFactor(values.positionSizeInUsd, minCollateralFactor).toInt256();\n        bool willBeSufficient = remainingCollateralUsd >= minCollateralUsdForLeverage;\n\n        return (willBeSufficient, remainingCollateralUsd);\n    }\n\n    function updateFundingAndBorrowingState(\n        PositionUtils.UpdatePositionParams memory params,\n        MarketUtils.MarketPrices memory prices\n    ) internal {\n        // update the funding amount per size for the market\n        MarketUtils.updateFundingAmountPerSize(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.market,\n            prices\n        );\n\n        // update the cumulative borrowing factor for the market\n        MarketUtils.updateCumulativeBorrowingFactor(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.market,\n            prices,\n            params.order.isLong()\n        );\n    }\n\n    function updateTotalBorrowing(\n        PositionUtils.UpdatePositionParams memory params,\n        uint256 nextPositionSizeInUsd,\n        uint256 nextPositionBorrowingFactor\n    ) internal {\n        MarketUtils.updateTotalBorrowing(\n            params.contracts.dataStore, // dataStore\n            params.market.marketToken, // market\n            params.position.isLong(), // isLong\n            params.position.sizeInUsd(), // prevPositionSizeInUsd\n            params.position.borrowingFactor(), // prevPositionBorrowingFactor\n            nextPositionSizeInUsd, // nextPositionSizeInUsd\n            nextPositionBorrowingFactor // nextPositionBorrowingFactor\n        );\n    }\n\n    // the order.receiver is meant to allow the output of an order to be\n    // received by an address that is different from the position.account\n    // address\n    // for funding fees, the funds are still credited to the owner\n    // of the position indicated by order.account\n    function incrementClaimableFundingAmount(\n        PositionUtils.UpdatePositionParams memory params,\n        PositionPricingUtils.PositionFees memory fees\n    ) internal {\n        // if the position has negative funding fees, distribute it to allow it to be claimable\n        if (fees.funding.claimableLongTokenAmount > 0) {\n            MarketUtils.incrementClaimableFundingAmount(\n                params.contracts.dataStore,\n                params.contracts.eventEmitter,\n                params.market.marketToken,\n                params.market.longToken,\n                params.order.account(),\n                fees.funding.claimableLongTokenAmount\n            );\n        }\n\n        if (fees.funding.claimableShortTokenAmount > 0) {\n            MarketUtils.incrementClaimableFundingAmount(\n                params.contracts.dataStore,\n                params.contracts.eventEmitter,\n                params.market.marketToken,\n                params.market.shortToken,\n                params.order.account(),\n                fees.funding.claimableShortTokenAmount\n            );\n        }\n    }\n\n    function updateOpenInterest(\n        PositionUtils.UpdatePositionParams memory params,\n        int256 sizeDeltaUsd,\n        int256 sizeDeltaInTokens\n    ) internal {\n        if (sizeDeltaUsd != 0) {\n            MarketUtils.applyDeltaToOpenInterest(\n                params.contracts.dataStore,\n                params.contracts.eventEmitter,\n                params.market,\n                params.position.collateralToken(),\n                params.position.isLong(),\n                sizeDeltaUsd\n            );\n\n            MarketUtils.applyDeltaToOpenInterestInTokens(\n                params.contracts.dataStore,\n                params.contracts.eventEmitter,\n                params.position.market(),\n                params.position.collateralToken(),\n                params.position.isLong(),\n                sizeDeltaInTokens\n            );\n        }\n    }\n\n    function handleReferral(\n        PositionUtils.UpdatePositionParams memory params,\n        PositionPricingUtils.PositionFees memory fees\n    ) internal {\n        ReferralUtils.incrementAffiliateReward(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.position.market(),\n            params.position.collateralToken(),\n            fees.referral.affiliate,\n            fees.referral.affiliateRewardAmount\n        );\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/position/PositionUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"../utils/Precision.sol\";\n\nimport \"./Position.sol\";\n\nimport \"../data/DataStore.sol\";\nimport \"../data/Keys.sol\";\n\nimport \"../pricing/PositionPricingUtils.sol\";\nimport \"../order/BaseOrderUtils.sol\";\n\n// @title PositionUtils\n// @dev Library for position functions\nlibrary PositionUtils {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using Price for Price.Props;\n    using Position for Position.Props;\n    using Order for Order.Props;\n\n    // @dev UpdatePositionParams struct used in increasePosition to avoid\n    // stack too deep errors\n    //\n    // @param contracts BaseOrderUtils.ExecuteOrderParamsContracts\n    // @param market the values of the trading market\n    // @param order the decrease position order\n    // @param orderKey the key of the order\n    // @param position the order's position\n    // @param positionKey the key of the order's position\n    struct UpdatePositionParams {\n        BaseOrderUtils.ExecuteOrderParamsContracts contracts;\n        Market.Props market;\n        Order.Props order;\n        bytes32 orderKey;\n        Position.Props position;\n        bytes32 positionKey;\n    }\n\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param oracle Oracle\n    // @param referralStorage IReferralStorage\n    struct UpdatePositionParamsContracts {\n        DataStore dataStore;\n        EventEmitter eventEmitter;\n        Oracle oracle;\n        SwapHandler swapHandler;\n        IReferralStorage referralStorage;\n    }\n\n    struct WillPositionCollateralBeSufficientValues {\n        uint256 positionSizeInUsd;\n        uint256 positionCollateralAmount;\n        int256 realizedPnlUsd;\n        int256 openInterestDelta;\n    }\n\n    struct DecreasePositionCollateralValuesOutput {\n        address outputToken;\n        uint256 outputAmount;\n        address secondaryOutputToken;\n        uint256 secondaryOutputAmount;\n    }\n\n    // @dev ProcessCollateralValues struct used to contain the values in processCollateral\n    // @param executionPrice the order execution price\n    // @param remainingCollateralAmount the remaining collateral amount of the position\n    // @param outputAmount the output amount\n    // @param positionPnlUsd the pnl of the position in USD\n    // @param pnlAmountForPool the pnl for the pool in token amount\n    // @param pnlAmountForUser the pnl for the user in token amount\n    // @param sizeDeltaInTokens the change in position size in tokens\n    // @param priceImpactAmount the price impact in tokens\n    struct DecreasePositionCollateralValues {\n        address pnlTokenForPool;\n        uint256 executionPrice;\n        int256 remainingCollateralAmount;\n        int256 positionPnlUsd;\n        int256 pnlAmountForPool;\n        uint256 pnlAmountForUser;\n        uint256 sizeDeltaInTokens;\n        int256 priceImpactAmount;\n        uint256 priceImpactDiffUsd;\n        uint256 priceImpactDiffAmount;\n        DecreasePositionCollateralValuesOutput output;\n    }\n\n    // @dev DecreasePositionCache struct used in decreasePosition to\n    // avoid stack too deep errors\n    // @param prices the prices of the tokens in the market\n    // @param pnlToken the token that the pnl for the user is in, for long positions\n    // this is the market.longToken, for short positions this is the market.shortToken\n    // @param pnlTokenPrice the price of the pnlToken\n    // @param initialCollateralAmount the initial collateral amount\n    // @param nextPositionSizeInUsd the new position size in USD\n    // @param nextPositionBorrowingFactor the new position borrowing factor\n    struct DecreasePositionCache {\n        MarketUtils.MarketPrices prices;\n        int256 estimatedPositionPnlUsd;\n        int256 estimatedRealizedPnlUsd;\n        int256 estimatedRemainingPnlUsd;\n        address pnlToken;\n        Price.Props pnlTokenPrice;\n        uint256 initialCollateralAmount;\n        uint256 nextPositionSizeInUsd;\n        uint256 nextPositionBorrowingFactor;\n    }\n\n\n    struct GetPositionPnlUsdCache {\n        int256 positionValue;\n        int256 totalPositionPnl;\n        address pnlToken;\n        uint256 poolTokenAmount;\n        uint256 poolTokenPrice;\n        uint256 poolTokenUsd;\n        int256 poolPnl;\n        int256 cappedPoolPnl;\n        uint256 sizeDeltaInTokens;\n        int256 positionPnlUsd;\n    }\n\n    // @dev IsPositionLiquidatableCache struct used in isPositionLiquidatable\n    // to avoid stack too deep errors\n    // @param positionPnlUsd the position's pnl in USD\n    // @param minCollateralFactor the min collateral factor\n    // @param collateralTokenPrice the collateral token price\n    // @param collateralUsd the position's collateral in USD\n    // @param usdDeltaForPriceImpact the usdDelta value for the price impact calculation\n    // @param priceImpactUsd the price impact of closing the position in USD\n    // @param minCollateralUsd the minimum allowed collateral in USD\n    // @param remainingCollateralUsd the remaining position collateral in USD\n    struct IsPositionLiquidatableCache {\n        int256 positionPnlUsd;\n        uint256 minCollateralFactor;\n        Price.Props collateralTokenPrice;\n        uint256 collateralUsd;\n        int256 usdDeltaForPriceImpact;\n        int256 priceImpactUsd;\n        int256 minCollateralUsd;\n        int256 minCollateralUsdForLeverage;\n        int256 remainingCollateralUsd;\n    }\n\n    // @dev get the position pnl in USD\n    //\n    // for long positions, pnl is calculated as:\n    // (position.sizeInTokens * indexTokenPrice) - position.sizeInUsd\n    // if position.sizeInTokens is larger for long positions, the position will have\n    // larger profits and smaller losses for the same changes in token price\n    //\n    // for short positions, pnl is calculated as:\n    // position.sizeInUsd -  (position.sizeInTokens * indexTokenPrice)\n    // if position.sizeInTokens is smaller for long positions, the position will have\n    // larger profits and smaller losses for the same changes in token price\n    //\n    // @param position the position values\n    // @param sizeDeltaUsd the change in position size\n    // @param indexTokenPrice the price of the index token\n    //\n    // @return (positionPnlUsd, sizeDeltaInTokens)\n    function getPositionPnlUsd(\n        DataStore dataStore,\n        Market.Props memory market,\n        MarketUtils.MarketPrices memory prices,\n        Position.Props memory position,\n        uint256 indexTokenPrice,\n        uint256 sizeDeltaUsd\n    ) public view returns (int256, uint256) {\n        GetPositionPnlUsdCache memory cache;\n\n        // position.sizeInUsd is the cost of the tokens, positionValue is the current worth of the tokens\n        cache.positionValue = (position.sizeInTokens() * indexTokenPrice).toInt256();\n        cache.totalPositionPnl = position.isLong() ? cache.positionValue - position.sizeInUsd().toInt256() : position.sizeInUsd().toInt256() - cache.positionValue;\n\n        if (cache.totalPositionPnl > 0) {\n            cache.pnlToken = position.isLong() ? market.longToken : market.shortToken;\n            cache.poolTokenAmount = MarketUtils.getPoolAmount(dataStore, market, cache.pnlToken);\n            cache.poolTokenPrice = position.isLong() ? prices.longTokenPrice.min : prices.shortTokenPrice.min;\n            cache.poolTokenUsd = cache.poolTokenAmount * cache.poolTokenPrice;\n            cache.poolPnl = MarketUtils.getPnl(\n                dataStore,\n                market,\n                indexTokenPrice,\n                position.isLong(),\n                true\n            );\n\n            cache.cappedPoolPnl = MarketUtils.getCappedPnl(\n                dataStore,\n                market.marketToken,\n                position.isLong(),\n                cache.poolPnl,\n                cache.poolTokenUsd,\n                Keys.MAX_PNL_FACTOR_FOR_TRADERS\n            );\n\n            if (cache.cappedPoolPnl != cache.poolPnl && cache.cappedPoolPnl > 0 && cache.poolPnl > 0) {\n                cache.totalPositionPnl = Precision.applyFraction(cache.totalPositionPnl.toUint256(), cache.cappedPoolPnl, cache.poolPnl.toUint256());\n            }\n        }\n\n        cache.sizeDeltaInTokens;\n\n        if (position.sizeInUsd() == sizeDeltaUsd) {\n            cache.sizeDeltaInTokens = position.sizeInTokens();\n        } else {\n            if (position.isLong()) {\n                cache.sizeDeltaInTokens = Calc.roundUpDivision(position.sizeInTokens() * sizeDeltaUsd, position.sizeInUsd());\n            } else {\n                cache.sizeDeltaInTokens = position.sizeInTokens() * sizeDeltaUsd / position.sizeInUsd();\n            }\n        }\n\n        cache.positionPnlUsd = cache.totalPositionPnl * cache.sizeDeltaInTokens.toInt256() / position.sizeInTokens().toInt256();\n\n        return (cache.positionPnlUsd, cache.sizeDeltaInTokens);\n    }\n\n    // @dev get the key for a position\n    // @param account the position's account\n    // @param market the position's market\n    // @param collateralToken the position's collateralToken\n    // @param isLong whether the position is long or short\n    // @return the position key\n    function getPositionKey(address account, address market, address collateralToken, bool isLong) internal pure returns (bytes32) {\n        bytes32 key = keccak256(abi.encode(account, market, collateralToken, isLong));\n        return key;\n    }\n\n    // @dev validate that a position is not empty\n    // @param position the position values\n    function validateNonEmptyPosition(Position.Props memory posi"
    }
  ]
}