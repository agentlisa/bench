{
  "Title": "Missing threshold invariant check when adding/removing transceivers",
  "Content": "**Description:** [`NttManagerState::_checkThresholdInvariants`](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/NttManager/NttManagerState.sol#L371-L385) is intended to check invariant properties related to the threshold storage and is called on initialization, migration, and access-controlled setting of the threshold storage directly. However, this function is not currently called when the [`setTransceiver()`](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/NttManager/NttManagerState.sol#L205-L228) and [removeTransceiver()](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/NttManager/NttManagerState.sol#L230-L242) functions execute, which also access and modify the relevant state.\n\n**Impact:** A bug in the addition/removal of transceivers could go unnoticed since the inline invariant checks on the threshold storage are not being performed here despite being modified.\n\n**Recommended Mitigation:** Ensure `NttManagerState::_checkThresholdInvariants` is called within `NttManagerState::setTransceiver` and `NttManagerState::removeTransceiver`.\n\n**Wormhole Foundation:** Fixed in [PR \\#381](https://github.com/wormhole-foundation/example-native-token-transfers/pull/381).\n\n**Cyfrin:** Verified. The threshold invariants are now checked when Transceivers are both added and removed. As noted, this change prevents an admin from disabling all the transceivers from an NTT manager, meaning there has to be at least 1 enabled Transceiver at all times whenÂ `numRegisteredTransceivers > 0`.\n\n\\clearpage",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "evm/src/NttManager/NttManagerState.sol",
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity >=0.8.8 <0.9.0;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\n\nimport \"wormhole-solidity-sdk/Utils.sol\";\nimport \"wormhole-solidity-sdk/libraries/BytesParsing.sol\";\n\nimport \"../libraries/external/OwnableUpgradeable.sol\";\nimport \"../libraries/external/ReentrancyGuardUpgradeable.sol\";\nimport \"../libraries/TransceiverStructs.sol\";\nimport \"../libraries/TransceiverHelpers.sol\";\nimport \"../libraries/RateLimiter.sol\";\nimport \"../libraries/PausableOwnable.sol\";\nimport \"../libraries/Implementation.sol\";\nimport \"../libraries/TrimmedAmount.sol\";\n\nimport \"../interfaces/INttManager.sol\";\nimport \"../interfaces/INttManagerState.sol\";\nimport \"../interfaces/INttManagerEvents.sol\";\nimport \"../interfaces/INTTToken.sol\";\nimport \"../interfaces/ITransceiver.sol\";\n\nimport \"./TransceiverRegistry.sol\";\n\nabstract contract NttManagerState is\n    INttManagerState,\n    INttManagerEvents,\n    RateLimiter,\n    TransceiverRegistry,\n    PausableOwnable,\n    ReentrancyGuardUpgradeable,\n    Implementation\n{\n    using TrimmedAmountLib for uint256;\n    using TrimmedAmountLib for TrimmedAmount;\n    // =============== Immutables ============================================================\n\n    address public immutable token;\n    address immutable deployer;\n    INttManager.Mode public immutable mode;\n    uint16 public immutable chainId;\n    uint256 immutable evmChainId;\n    uint8 public immutable tokenDecimals_;\n\n    // =============== Setup =================================================================\n\n    constructor(\n        address _token,\n        INttManager.Mode _mode,\n        uint16 _chainId,\n        uint64 _rateLimitDuration,\n        bool _skipRateLimiting\n    ) RateLimiter(_rateLimitDuration, _skipRateLimiting) {\n        token = _token;\n        tokenDecimals_ = _initializeTokenDecimals();\n        mode = _mode;\n        chainId = _chainId;\n        evmChainId = block.chainid;\n        // save the deployer (check this on initialization)\n        deployer = msg.sender;\n    }\n\n    function __NttManager_init() internal onlyInitializing {\n        // check if the owner is the deployer of this contract\n        if (msg.sender != deployer) {\n            revert UnexpectedDeployer(deployer, msg.sender);\n        }\n        __PausedOwnable_init(msg.sender, msg.sender);\n        __ReentrancyGuard_init();\n        _setOutboundLimit(TrimmedAmountLib.max(tokenDecimals_));\n    }\n\n    function _initialize() internal virtual override {\n        __NttManager_init();\n        _checkThresholdInvariants();\n        _checkTransceiversInvariants();\n    }\n\n    function _migrate() internal virtual override {\n        _checkThresholdInvariants();\n        _checkTransceiversInvariants();\n    }\n\n    // =============== Storage ==============================================================\n\n    bytes32 private constant MESSAGE_ATTESTATIONS_SLOT =\n        bytes32(uint256(keccak256(\"ntt.messageAttestations\")) - 1);\n\n    bytes32 private constant MESSAGE_SEQUENCE_SLOT =\n        bytes32(uint256(keccak256(\"ntt.messageSequence\")) - 1);\n\n    bytes32 private constant PEERS_SLOT = bytes32(uint256(keccak256(\"ntt.peers\")) - 1);\n\n    bytes32 private constant THRESHOLD_SLOT = bytes32(uint256(keccak256(\"ntt.threshold\")) - 1);\n\n    // =============== Storage Getters/Setters ==============================================\n\n    function _getThresholdStorage() private pure returns (INttManager._Threshold storage $) {\n        uint256 slot = uint256(THRESHOLD_SLOT);\n        assembly (\"memory-safe\") {\n            $.slot := slot\n        }\n    }\n\n    function _getMessageAttestationsStorage()\n        internal\n        pure\n        returns (mapping(bytes32 => INttManager.AttestationInfo) storage $)\n    {\n        uint256 slot = uint256(MESSAGE_ATTESTATIONS_SLOT);\n        assembly (\"memory-safe\") {\n            $.slot := slot\n        }\n    }\n\n    function _getMessageSequenceStorage() internal pure returns (INttManager._Sequence storage $) {\n        uint256 slot = uint256(MESSAGE_SEQUENCE_SLOT);\n        assembly (\"memory-safe\") {\n            $.slot := slot\n        }\n    }\n\n    function _getPeersStorage()\n        internal\n        pure\n        returns (mapping(uint16 => NttManagerPeer) storage $)\n    {\n        uint256 slot = uint256(PEERS_SLOT);\n        assembly (\"memory-safe\") {\n            $.slot := slot\n        }\n    }\n\n    // =============== Public Getters ========================================================\n\n    /// @inheritdoc INttManagerState\n    function getMode() public view returns (uint8) {\n        return uint8(mode);\n    }\n\n    /// @inheritdoc INttManagerState\n    function getThreshold() public view returns (uint8) {\n        return _getThresholdStorage().num;\n    }\n\n    /// @inheritdoc INttManagerState\n    function isMessageApproved(bytes32 digest) public view returns (bool) {\n        uint8 threshold = getThreshold();\n        return messageAttestations(digest) >= threshold && threshold > 0;\n    }\n\n    /// @inheritdoc INttManagerState\n    function nextMessageSequence() external view returns (uint64) {\n        return _getMessageSequenceStorage().num;\n    }\n\n    /// @inheritdoc INttManagerState\n    function isMessageExecuted(bytes32 digest) public view returns (bool) {\n        return _getMessageAttestationsStorage()[digest].executed;\n    }\n\n    /// @inheritdoc INttManagerState\n    function getPeer(uint16 chainId_) external view returns (NttManagerPeer memory) {\n        return _getPeersStorage()[chainId_];\n    }\n\n    /// @inheritdoc INttManagerState\n    function transceiverAttestedToMessage(bytes32 digest, uint8 index) public view returns (bool) {\n        return\n            _getMessageAttestationsStorage()[digest].attestedTransceivers & uint64(1 << index) > 0;\n    }\n\n    /// @inheritdoc INttManagerState\n    function messageAttestations(bytes32 digest) public view returns (uint8 count) {\n        return countSetBits(_getMessageAttestations(digest));\n    }\n\n    // =============== ADMIN ==============================================================\n\n    /// @inheritdoc INttManagerState\n    function upgrade(address newImplementation) external onlyOwner {\n        _upgrade(newImplementation);\n    }\n\n    /// @inheritdoc INttManagerState\n    function pause() public onlyOwnerOrPauser {\n        _pause();\n    }\n\n    /// @notice Transfer ownership of the Manager contract and all Endpoint contracts to a new owner.\n    function transferOwnership(address newOwner) public override onlyOwner {\n        super.transferOwnership(newOwner);\n        // loop through all the registered transceivers and set the new owner of each transceiver to the newOwner\n        address[] storage _registeredTransceivers = _getRegisteredTransceiversStorage();\n        _checkRegisteredTransceiversInvariants();\n\n        for (uint256 i = 0; i < _registeredTransceivers.length; i++) {\n            ITransceiver(_registeredTransceivers[i]).transferTransceiverOwnership(newOwner);\n        }\n    }\n\n    /// @inheritdoc INttManagerState\n    function setTransceiver(address transceiver) external onlyOwner {\n        _setTransceiver(transceiver);\n\n        INttManager._Threshold storage _threshold = _getThresholdStorage();\n        // We do not automatically increase the threshold here.\n        // Automatically increasing the threshold can result in a scenario\n        // where in-flight messages can't be redeemed.\n        // For example: Assume there is 1 Transceiver and the threshold is 1.\n        // If we were to add a new Transceiver, the threshold would increase to 2.\n        // However, all messages that are either in-flight or that are sent on\n        // a source chain that does not yet have 2 Transceivers will only have been\n        // sent from a single transceiver, so they would never be able to get\n        // redeemed.\n        // Instead, we leave it up to the owner to manually update the threshold\n        // after some period of time, ideally once all chains have the new Transceiver\n        // and transfers that were sent via the old configuration are all complete.\n        // However if the threshold is 0 (the initial case) we do increment to 1.\n        if (_threshold.num == 0) {\n            _threshold.num = 1;\n        }\n\n        emit TransceiverAdded(transceiver, _getNumTransceiversStorage().enabled, _threshold.num);\n    }\n\n    /// @inheritdoc INttManagerState\n    function removeTransceiver(address transceiver) external onlyOwner {\n        _removeTransceiver(transceiver);\n\n        INttManager._Threshold storage _threshold = _getThresholdStorage();\n        uint8 numEnabledTransceivers = _getNumTransceiversStorage().enabled;\n\n        if (numEnabledTransceivers < _threshold.num) {\n            _threshold.num = numEnabledTransceivers;\n        }\n\n        emit TransceiverRemoved(transceiver, _threshold.num);\n    }\n\n    /// @inheritdoc INttManagerState\n    function setThreshold(uint8 threshold) external onlyOwner {\n        if (threshold == 0) {\n            revert ZeroThreshold();\n        }\n\n        INttManager._Threshold storage _threshold = _getThresholdStorage();\n        uint8 oldThreshold = _threshold.num;\n\n        _threshold.num = threshold;\n        _checkThresholdInvariants();\n\n        emit ThresholdChanged(oldThreshold, threshold);\n    }\n\n    /// @inheritdoc INttManagerState\n    function setPeer(uint16 peerChainId, bytes32 peerContract, uint8 decimals) public onlyOwner {\n        if (peerChainId == 0) {\n            revert InvalidPeerChainIdZero();\n        }\n        if (peerContract == bytes32(0)) {\n            revert InvalidPeerZeroAddress();\n        }\n        if (decimals == 0) {\n            revert InvalidPeerDecimals();\n        }\n\n        NttManagerPeer memory oldPeer = _getPeersStorage()[peerChainId];\n\n        _getPeersStorage()[peerChainId].peerAddress = peerContract;\n        _getPeersStorage()[peerChainId].tokenDecimals = decimals;\n\n        _setInboundLimit(TrimmedAmountLib.max(tokenDecimals_), peerChainId);\n\n        emit PeerUpdated(\n            peerChainId, oldPeer.peerAddress, oldPeer.tokenDecimals, peerContract, decimals\n        );\n    }\n\n    /// @inheritdoc INttManagerState\n    function setOutboundLimit(uint256 limit) external onlyOwner {\n        _setOutboundLimit(limit.trim(tokenDecimals_, tokenDecimals_));\n    }\n\n    /// @inheritdoc INttManagerState\n    function setInboundLimit(uint256 limit, uint16 chainId_) external onlyOwner {\n        _setInboundLimit(limit.trim(tokenDecimals_, tokenDecimals_), chainId_);\n    }\n\n    // =============== Internal ==============================================================\n\n    function _setTransceiverAttestedToMessage(bytes32 digest, uint8 index) internal {\n        _getMessageAttestationsStorage()[digest].attestedTransceivers |= uint64(1 << index);\n    }\n\n    function _setTransceiverAttestedToMessage(bytes32 digest, address transceiver) internal {\n        _setTransceiverAttestedToMessage(digest, _getTransceiverInfosStorage()[transceiver].index);\n\n        emit MessageAttestedTo(\n            digest, transceiver, _getTransceiverInfosStorage()[transceiver].index\n        );\n    }\n\n    /// @dev Returns the bitmap of attestations from enabled transceivers for a given message.\n    function _getMessageAttestations(bytes32 digest) internal view returns (uint64) {\n        uint64 enabledTransceiverBitmap = _getEnabledTransceiversBitmap();\n        return\n            _getMessageAttestationsStorage()[digest].attestedTransceivers & enabledTransceiverBitmap;\n    }\n\n    function _getEnabledTransceiverAttestedToMessage(\n        bytes32 digest,\n        uint8 index\n    ) internal view returns (bool) {\n        return _getMessageAttestations(digest) & uint64(1 << index) != 0;\n    }\n\n    /// @dev Verify that the peer address saved for `sourceChainId` matches the `peerAddress`.\n    function _verifyPeer(uint16 sourceChainId, bytes32 peerAddress) internal view {\n        if (_getPeersStorage()[sourceChainId].peerAddress != peerAddress) {\n            revert InvalidPeer(sourceChainId, peerAddress);\n        }\n    }\n\n    // @dev Mark a message as executed.\n    // This function will retuns `true` if the message has already been executed.\n    function _replayProtect(bytes32 digest) internal returns (bool) {\n        // check if this message has already been executed\n        if (isMessageExecuted(digest)) {\n            return true;\n        }\n\n        // mark this message as executed\n        _getMessageAttestationsStorage()[digest].executed = true;\n\n        return false;\n    }\n\n    function _useMessageSequence() internal returns (uint64 currentSequence) {\n        currentSequence = _getMessageSequenceStorage().num;\n        _getMessageSequenceStorage().num++;\n    }\n\n    function _initializeTokenDecimals() internal view returns (uint8) {\n        (, bytes memory queriedDecimals) = token.staticcall(abi.encodeWithSignature(\"decimals()\"));\n        return abi.decode(queriedDecimals, (uint8));\n    }\n\n    /// ============== Invariants =============================================\n\n    /// @dev When we add new immutables, this function should be updated\n    function _checkImmutables() internal view override {\n        assert(this.token() == token);\n        assert(this.tokenDecimals_() == tokenDecimals_);\n        assert(this.mode() == mode);\n        assert(this.chainId() == chainId);\n        assert(this.rateLimitDuration() == rateLimitDuration);\n    }\n\n    function _checkRegisteredTransceiversInvariants() internal view {\n        if (_getRegisteredTransceiversStorage().length != _getNumTransceiversStorage().registered) {\n            revert RetrievedIncorrectRegisteredTransceivers(\n                _getRegisteredTransceiversStorage().length, _getNumTransceiversStorage().registered\n            );\n        }\n    }\n\n    function _checkThresholdInvariants() internal view {\n        uint8 threshold = _getThresholdStorage().num;\n        _NumTransceivers memory numTransceivers = _getNumTransceiversStorage();\n\n        // invariant: threshold <= enabledTransceivers.length\n        if (threshold > numTransceivers.enabled) {\n            revert ThresholdTooHigh(threshold, numTransceivers.enabled);\n        }\n\n        if (numTransceivers.registered > 0) {\n            if (threshold == 0) {\n                revert ZeroThreshold();\n            }\n        }\n    }\n}"
    }
  ]
}