{
  "Title": "[M-30] `StakingRewards` reward rate can be dragged out and diluted",
  "Content": "_Submitted by cmichel_\n\n[StakingRewards.sol#L161](https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L161)<br>\n\nThe `StakingRewards.notifyRewardAmount` function receives a `reward` amount and extends the current reward end time to `now + rewardsDuration`.<br>\nIt rebases the currently remaining rewards + the new rewards (`reward + leftover`) over this new `rewardsDuration` period.\n\n```solidity\nfunction withdraw(IERC20 _token, address _to) external override {\n    require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD < block.timestamp, \"shelter not activated\");\n    // @audit uses `msg.sender`'s share but sets `claimed` for _to! can claim for many `_to`s\n    uint256 amount = savedTokens[_token] * client.shareOf(_token, msg.sender) / client.totalShare(_token);\n    claimed[_token][_to] = true;\n    emit ExitShelter(_token, msg.sender, _to, amount);\n    _token.safeTransfer(_to, amount);\n}\n```\n\nThis can lead to a dilution of the reward rate and rewards being dragged out forever by malicious new reward deposits.\n\n### Proof of Concept\n\nImagine the current rewardRate is `1000 rewards / rewardsDuration`.<br>\n20% of the `rewardsDuration` passed, i.e., `now = lastUpdateTime + 20% * rewardsDuration`.<br>\nA malicious actor notifies the contract with a reward of `0`: `notifyRewardAmount(0)`.<br>\nThen the new `rewardRate = (reward + leftover) / rewardsDuration = (0 + 800) / rewardsDuration = 800 / rewardsDuration`.<br>\nThe `rewardRate` just dropped by 20%.<br>\nThis can be repeated infinitely.<br>\nAfter another 20% of reward time passed, they trigger `notifyRewardAmount(0)` to reduce it by another 20% again:<br>\n`rewardRate = (0 + 640) / rewardsDuration = 640 / rewardsDuration`.\n\n### Recommended Mitigation Steps\n\nImo, the `rewardRate` should never decrease by a `notifyRewardAmount` call.<br>\nConsider not extending the reward payouts by `rewardsDuration` on every call.<br>\n`periodFinish` probably shouldn't change at all, the `rewardRate` should just increase by `rewardRate += reward / (periodFinish - block.timestamp)`.\n\nAlternatively, consider keeping the `rewardRate` constant but extend `periodFinish` time by `+= reward / rewardRate`.\n\n**[ryuheimat (Concur) disputed and commented](https://github.com/code-423n4/2022-02-concur-findings/issues/183#issuecomment-1043693880):**\n > notifyRewardAmount check msg.sender's permission.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-02-concur-findings/issues/183#issuecomment-1103139704):**\n > The warden is pointing out an admin privilege that would allow the admin to dilute current rewards.\n> \n> While the sponsor claims this won't happen, I can only judge based on the code that is available to me.<br>\n> And at this point there seems to be no code for the `rewardsDistribution` contract that would be calling `notifyRewardAmount`\n> \n> Given this, I believe the finding to be valid as the POC works out to demonstrate how a malicious owner could dilute the rewardRate.\n> \n> This would cause loss of yield for all depositors, which makes the finding of Medium Severity.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-concur-finance-contest",
  "Code": [
    {
      "filename": "contracts/StakingRewards.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./MasterChef.sol\";\n\ncontract StakingRewards is Ownable, ReentrancyGuard, Pausable {\n    using SafeERC20 for IERC20;\n\n    MasterChef public immutable masterChef;\n\n    /* ========== STATE VARIABLES ========== */\n\n    IERC20 public rewardsToken;\n    IERC20 public stakingToken;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public rewardsDuration = 7 days;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    address public rewardsDistribution;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _rewardsDistribution,\n        address _rewardsToken,\n        address _stakingToken,\n        MasterChef _masterChef\n    ) {\n        rewardsToken = IERC20(_rewardsToken);\n        stakingToken = IERC20(_stakingToken);\n        rewardsDistribution = _rewardsDistribution;\n        masterChef = _masterChef;\n    }\n\n    /* ========== VIEWS ========== */\n\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return block.timestamp < periodFinish ? block.timestamp : periodFinish;\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored +\n            (((lastTimeRewardApplicable() - lastUpdateTime) *\n                rewardRate *\n                1e18) / _totalSupply);\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            (_balances[account] *\n                (rewardPerToken() - userRewardPerTokenPaid[account])) /\n            1e18 +\n            rewards[account];\n    }\n\n    function getRewardForDuration() external view returns (uint256) {\n        return rewardRate * rewardsDuration;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function stake(uint256 amount)\n        external\n        nonReentrant\n        whenNotPaused\n        updateReward(msg.sender)\n    {\n        require(amount > 0, \"Cannot stake 0\");\n        _totalSupply += amount;\n        _balances[msg.sender] += amount;\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\n        uint256 pid = masterChef.pid(address(stakingToken));\n        masterChef.deposit(msg.sender, pid, amount);\n        emit Staked(msg.sender, amount);\n    }\n\n    function withdraw(uint256 amount)\n        public\n        nonReentrant\n        updateReward(msg.sender)\n    {\n        require(amount > 0, \"Cannot withdraw 0\");\n        _totalSupply -= amount;\n        _balances[msg.sender] -= amount;\n        stakingToken.safeTransfer(msg.sender, amount);\n        uint256 pid = masterChef.pid(address(stakingToken));\n        masterChef.withdraw(msg.sender, pid, amount);\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    function getReward() public nonReentrant updateReward(msg.sender) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            rewardsToken.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n\n    function exit() external {\n        withdraw(_balances[msg.sender]);\n        getReward();\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function notifyRewardAmount(uint256 reward)\n        external\n        updateReward(address(0))\n    {\n        require(\n            msg.sender == rewardsDistribution,\n            \"Caller is not RewardsDistribution contract\"\n        );\n\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward / rewardsDuration;\n        } else {\n            uint256 remaining = periodFinish - block.timestamp;\n            uint256 leftover = remaining * rewardRate;\n            rewardRate = (reward + leftover) / rewardsDuration;\n        }\n\n        // Ensure the provided reward amount is not more than the balance in the contract.\n        // This keeps the reward rate in the right range, preventing overflows due to\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n        uint256 balance = rewardsToken.balanceOf(address(this));\n        require(\n            rewardRate <= balance / rewardsDuration,\n            \"Provided reward too high\"\n        );\n\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp + rewardsDuration;\n        emit RewardAdded(reward);\n    }\n\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n    function recoverERC20(address tokenAddress, uint256 tokenAmount)\n        external\n        onlyOwner\n    {\n        require(\n            tokenAddress != address(stakingToken),\n            \"Cannot withdraw the staking token\"\n        );\n        IERC20(tokenAddress).safeTransfer(owner(), tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }\n\n    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n        require(\n            block.timestamp > periodFinish,\n            \"Previous rewards period must be complete before changing the duration for the new period\"\n        );\n        rewardsDuration = _rewardsDuration;\n        emit RewardsDurationUpdated(rewardsDuration);\n    }\n\n    function setRewardsDistribution(address _rewardsDistribution)\n        external\n        onlyOwner\n    {\n        require(\n            block.timestamp > periodFinish,\n            \"Previous rewards period must be complete before changing the duration for the new period\"\n        );\n        rewardsDistribution = _rewardsDistribution;\n        emit RewardsDistributionUpdated(rewardsDistribution);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event RewardsDurationUpdated(uint256 newDuration);\n    event RewardsDistributionUpdated(address indexed newDistribution);\n    event Recovered(address token, uint256 amount);\n}"
    }
  ]
}