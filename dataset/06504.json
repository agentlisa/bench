{
  "Title": "[G-14] `abi.encode()` is less efficient than `abi.encodePacked()`",
  "Content": "\nIn terms of efficiency, `abi.encodePacked()` is generally considered to be more gas-efficient than `abi.encode()` because it skips the step of adding function signatures and other metadata to the encoded data. However, this comes at the cost of reduced safety, as `abi.encodePacked()` does not perform any type of checking or padding of data.\n\n```solidity\nFile:   src/governance/GovernorBravoDelegateMaia.sol\n346   keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainIdInternal(), address(this)));\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/governance/GovernorBravoDelegateMaia.sol#L346\n\n```solidity\nFile:  src/talos/libraries/PoolActions.sol\n51   abi.encode(SwapCallbackData({zeroForOne: zeroForOne}))\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/talos/libraries/PoolActions.sol#L51\n\n```solidity\nFile:   src/ulysses-omnichain/RootBridgeAgent.sol\n689   abi.encode(SwapCallbackData({tokenIn: gasTokenGlobalAddress}))\n\n733   abi.encode(SwapCallbackData({tokenIn: address(wrappedNativeToken)}))\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L689\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/governance/GovernorBravoDelegateMaia.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./GovernorBravoInterfaces.sol\";\n\n/// @title Governor Bravo Constants Contract\ncontract GovernorBravoConstants {\n    /// @notice The name of this contract\n    string public constant name = \"vMaia Governor Bravo\";\n\n    /// @notice The minimum setable proposal threshold\n    uint256 public constant MIN_PROPOSAL_THRESHOLD = 0.005 ether; // 0.5% of GovToken\n\n    /// @notice The maximum setable proposal threshold\n    uint256 public constant MAX_PROPOSAL_THRESHOLD = 0.05 ether; // 5% of GovToken\n\n    /// @notice The minimum setable voting period\n    uint256 public constant MIN_VOTING_PERIOD = 80640; // About 2 weeks\n\n    /// @notice The max setable voting period\n    uint256 public constant MAX_VOTING_PERIOD = 161280; // About 4 weeks\n\n    /// @notice The min setable voting delay\n    uint256 public constant MIN_VOTING_DELAY = 40320; // About 1 weeks\n\n    /// @notice The max setable voting delay\n    uint256 public constant MAX_VOTING_DELAY = 80640; // About 2 weeks\n\n    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n    uint256 public constant quorumVotes = 0.35 ether; // 35% of GovToken\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    uint256 public constant proposalMaxOperations = 10; // 10 actions\n\n    /// @notice The divisor value used in percentage calculations\n    uint256 public constant DIVISIONER = 1 ether;\n}\n\n/// @title Governor Bravo Delegate Contract\ncontract GovernorBravoDelegate is GovernorBravoDelegateStorageV2, GovernorBravoEvents, GovernorBravoConstants {\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,uint8 support)\");\n\n    /**\n     * @notice Used to initialize the contract during delegator constructor\n     * @param timelock_ The address of the Timelock\n     * @param govToken_ The address of the GOV token\n     * @param votingPeriod_ The initial voting period\n     * @param votingDelay_ The initial voting delay\n     * @param proposalThreshold_ The initial proposal threshold\n     */\n    function initialize(\n        address timelock_,\n        address govToken_,\n        uint256 votingPeriod_,\n        uint256 votingDelay_,\n        uint256 proposalThreshold_\n    ) public virtual {\n        require(address(timelock) == address(0), \"GovernorBravo::initialize: can only initialize once\");\n        require(msg.sender == admin, \"GovernorBravo::initialize: admin only\");\n        require(timelock_ != address(0), \"GovernorBravo::initialize: invalid timelock address\");\n        require(govToken_ != address(0), \"GovernorBravo::initialize: invalid govToken address\");\n        require(\n            votingPeriod_ >= MIN_VOTING_PERIOD && votingPeriod_ <= MAX_VOTING_PERIOD,\n            \"GovernorBravo::initialize: invalid voting period\"\n        );\n        require(\n            votingDelay_ >= MIN_VOTING_DELAY && votingDelay_ <= MAX_VOTING_DELAY,\n            \"GovernorBravo::initialize: invalid voting delay\"\n        );\n        require(\n            proposalThreshold_ >= MIN_PROPOSAL_THRESHOLD && proposalThreshold_ <= MAX_PROPOSAL_THRESHOLD,\n            \"GovernorBravo::initialize: invalid proposal threshold\"\n        );\n\n        timelock = TimelockInterface(timelock_);\n        govToken = GovTokenInterface(govToken_);\n        votingPeriod = votingPeriod_;\n        votingDelay = votingDelay_;\n        proposalThreshold = proposalThreshold_;\n    }\n\n    function getProposalThresholdAmount() public view returns (uint256) {\n        return govToken.totalSupply() * proposalThreshold / DIVISIONER;\n    }\n\n    function getQuorumVotesAmount() public view returns (uint256) {\n        return govToken.totalSupply() * quorumVotes / DIVISIONER;\n    }\n\n    /**\n     * @notice Function used to propose a new proposal. Sender must have delegates above the proposal threshold\n     * @param targets Target addresses for proposal calls\n     * @param values Eth values for proposal calls\n     * @param signatures Function signatures for proposal calls\n     * @param calldatas Calldatas for proposal calls\n     * @param description String description of the proposal\n     * @return Proposal id of new proposal\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) public returns (uint256) {\n        // Reject proposals before initiating as Governor\n        require(initialProposalId != 0, \"GovernorBravo::propose: Governor Bravo not active\");\n        // Allow addresses above proposal threshold and whitelisted addresses to propose\n        require(\n            govToken.getPriorVotes(msg.sender, sub256(block.number, 1)) > getProposalThresholdAmount()\n                || isWhitelisted(msg.sender),\n            \"GovernorBravo::propose: proposer votes below proposal threshold\"\n        );\n        require(\n            targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length,\n            \"GovernorBravo::propose: proposal function information arity mismatch\"\n        );\n        require(targets.length != 0, \"GovernorBravo::propose: must provide actions\");\n        require(targets.length <= proposalMaxOperations, \"GovernorBravo::propose: too many actions\");\n\n        uint256 latestProposalId = latestProposalIds[msg.sender];\n        if (latestProposalId != 0) {\n            ProposalState proposersLatestProposalState = state(latestProposalId);\n            require(\n                proposersLatestProposalState != ProposalState.Active,\n                \"GovernorBravo::propose: one live proposal per proposer, found an already active proposal\"\n            );\n            require(\n                proposersLatestProposalState != ProposalState.Pending,\n                \"GovernorBravo::propose: one live proposal per proposer, found an already pending proposal\"\n            );\n        }\n\n        uint256 startBlock = add256(block.number, votingDelay);\n        uint256 endBlock = add256(startBlock, votingPeriod);\n\n        proposalCount++;\n        uint256 newProposalID = proposalCount;\n        Proposal storage newProposal = proposals[newProposalID];\n        // This should never happen but add a check in case.\n        require(newProposal.id == 0, \"GovernorBravo::propose: ProposalID collsion\");\n        newProposal.id = newProposalID;\n        newProposal.proposer = msg.sender;\n        newProposal.eta = 0;\n        newProposal.targets = targets;\n        newProposal.values = values;\n        newProposal.signatures = signatures;\n        newProposal.calldatas = calldatas;\n        newProposal.startBlock = startBlock;\n        newProposal.endBlock = endBlock;\n        newProposal.forVotes = 0;\n        newProposal.againstVotes = 0;\n        newProposal.abstainVotes = 0;\n        newProposal.canceled = false;\n        newProposal.executed = false;\n\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        emit ProposalCreated(\n            newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description\n        );\n        return newProposal.id;\n    }\n\n    /**\n     * @notice Queues a proposal of state succeeded\n     * @param proposalId The id of the proposal to queue\n     */\n    function queue(uint256 proposalId) external {\n        require(\n            state(proposalId) == ProposalState.Succeeded,\n            \"GovernorBravo::queue: proposal can only be queued if it is succeeded\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        uint256 eta = add256(block.timestamp, timelock.delay());\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            queueOrRevertInternal(\n                proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta\n            );\n        }\n        proposal.eta = eta;\n        emit ProposalQueued(proposalId, eta);\n    }\n\n    function queueOrRevertInternal(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        require(\n            !timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))),\n            \"GovernorBravo::queueOrRevertInternal: identical proposal action already queued at eta\"\n        );\n        timelock.queueTransaction(target, value, signature, data, eta);\n    }\n\n    /**\n     * @notice Executes a queued proposal if eta has passed\n     * @param proposalId The id of the proposal to execute\n     */\n    function execute(uint256 proposalId) external payable {\n        require(\n            state(proposalId) == ProposalState.Queued,\n            \"GovernorBravo::execute: proposal can only be executed if it is queued\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        proposal.executed = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.executeTransaction{value: proposal.values[i]}(\n                proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta\n            );\n        }\n        emit ProposalExecuted(proposalId);\n    }\n\n    /**\n     * @notice Cancels a proposal only if sender is the proposer, or proposer delegates dropped below proposal threshold\n     * @param proposalId The id of the proposal to cancel\n     */\n    function cancel(uint256 proposalId) external {\n        require(state(proposalId) != ProposalState.Executed, \"GovernorBravo::cancel: cannot cancel executed proposal\");\n\n        Proposal storage proposal = proposals[proposalId];\n\n        // Proposer can cancel\n        // admin is Emergency DAO and can cancel any proposal\n        if (msg.sender != proposal.proposer && msg.sender != admin) {\n            // Whitelisted proposers can't be canceled for falling below proposal threshold\n            if (isWhitelisted(proposal.proposer)) {\n                require(\n                    (govToken.getPriorVotes(proposal.proposer, sub256(block.number, 1)) < getProposalThresholdAmount())\n                        && msg.sender == whitelistGuardian,\n                    \"GovernorBravo::cancel: whitelisted proposer\"\n                );\n            } else {\n                require(\n                    (govToken.getPriorVotes(proposal.proposer, sub256(block.number, 1)) < getProposalThresholdAmount()),\n                    \"GovernorBravo::cancel: proposer above threshold\"\n                );\n            }\n        }\n\n        proposal.canceled = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.cancelTransaction(\n                proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta\n            );\n        }\n\n        emit ProposalCanceled(proposalId);\n    }\n\n    /**\n     * @notice Gets actions of a proposal\n     * @param proposalId the id of the proposal\n     * @return targets of the proposal actions\n     * @return values of the proposal actions\n     * @return signatures of the proposal actions\n     * @return calldatas of the proposal actions\n     */\n    function getActions(uint256 proposalId)\n        external\n        view\n        returns (\n            address[] memory targets,\n            uint256[] memory values,\n            string[] memory signatures,\n            bytes[] memory calldatas\n        )\n    {\n        Proposal storage p = proposals[proposalId];\n        return (p.targets, p.values, p.signatures, p.calldatas);\n    }\n\n    /**\n     * @notice Gets the receipt for a voter on a given proposal\n     * @param proposalId the id of proposal\n     * @param voter The address of the voter\n     * @return The voting receipt\n     */\n    function getReceipt(uint256 proposalId, address voter) external view returns (Receipt memory) {\n        return proposals[proposalId].receipts[voter];\n    }\n\n    /**\n     * @notice Gets the state of a proposal\n     * @param proposalId The id of the proposal\n     * @return Proposal state\n     */\n    function state(uint256 proposalId) public view returns (ProposalState) {\n        require(\n            proposalCount >= proposalId && proposalId > initialProposalId, \"GovernorBravo::state: invalid proposal id\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (block.number <= proposal.startBlock) {\n            return ProposalState.Pending;\n        } else if (block.number <= proposal.endBlock) {\n            return ProposalState.Active;\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < getQuorumVotesAmount()) {\n            return ProposalState.Defeated;\n        } else if (proposal.eta == 0) {\n            return ProposalState.Succeeded;\n        } else if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    /**\n     * @notice Cast a vote for a proposal\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     */\n    function castVote(uint256 proposalId, uint8 support) external {\n        emit VoteCast(msg.sender, proposalId, support, castVoteInternal(msg.sender, proposalId, support), \"\");\n    }\n\n    /**\n     * @notice Cast a vote for a proposal with a reason\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @param reason The reason given for the vote by the voter\n     */\n    function castVoteWithReason(uint256 proposalId, uint8 support, string calldata reason) external {\n        emit VoteCast(msg.sender, proposalId, support, castVoteInternal(msg.sender, proposalId, support), reason);\n    }\n\n    /**\n     * @notice Cast a vote for a proposal by signature\n     * @dev External function that accepts EIP-712 signatures for voting on proposals.\n     */\n    function castVoteBySig(uint256 proposalId, uint8 support, uint8 v, bytes32 r, bytes32 s) external {\n        bytes32 domainSeparator =\n            keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainIdInternal(), address(this)));\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"GovernorBravo::castVoteBySig: invalid signature\");\n        emit VoteCast(signatory, proposalId, support, castVoteInternal(signatory, proposalId, support), \"\");\n    }\n\n    /**\n     * @notice Internal function that caries out voting logic\n     * @param voter The voter that is casting their vote\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @return The number of votes cast\n     */\n    function castVoteInternal(address voter, uint256 proposalId, uint8 support) internal returns (uint96) {\n        require(state(proposalId) == ProposalState.Active, \"GovernorBravo::castVoteInternal: voting is closed\");\n        require(support <= 2, \"GovernorBravo::castVoteInternal: invalid vote type\");\n        Proposal storage proposal = proposals[proposalId];\n        Receipt storage receipt = proposal.receipts[voter];\n        require(receipt.hasVoted == false, \"GovernorBravo::castVoteInternal: voter already voted\");\n        uint96 votes = govToken.getPriorVotes(voter, proposal.startBlock);\n\n        if (support == 0) {\n            proposal.againstVotes = add256(proposal.againstVotes, votes);\n        } else if (support == 1) {\n            proposal.forVotes = add256(proposal.forVotes, votes);\n        } else if (support == 2) {\n            proposal.abstainVotes = add256(proposal.abstainVotes, votes);\n        }\n\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = votes;\n\n        return votes;\n    }\n\n    /**\n     * @notice View function which returns if an account is whitelisted\n     * @param account Account to check white list status of\n     * @return If the account is whitelisted\n     */\n    function isWhitelisted(address account) public view returns (bool) {\n        return (whitelistAccountExpirations[account] > block.timestamp);\n    }\n\n    /**\n     * @notice Admin function for setting the voting delay\n     * @param newVotingDelay new voting delay, in blocks\n     */\n    function _setVotingDelay(uint256 newVotingDelay) external {\n        require(msg.sender == admin, \"GovernorBravo::_setVotingDelay: admin only\");\n        require(\n            newVotingDelay >= MIN_VOTING_DELAY && newVotingDelay <= MAX_VOTING_DELAY,\n            \"GovernorBravo::_setVotingDelay: invalid voting delay\"\n        );\n        uint256 oldVotingDelay = votingDelay;\n        votingDelay = newVotingDelay;\n\n        emit VotingDelaySet(oldVotingDelay, votingDelay);\n    }\n\n    /**\n     * @notice Admin function for setting the voting period\n     * @param newVotingPeriod new voting period, in blocks\n     */\n    function _setVotingPeriod(uint256 newVotingPeriod) external {\n        require(msg.sender == admin, \"GovernorBravo::_setVotingPeriod: admin only\");\n        require(\n            newVotingPeriod >= MIN_VOTING_PERIOD && newVotingPeriod <= MAX_VOTING_PERIOD,\n            \"GovernorBravo::_setVotingPeriod: invalid voting period\"\n        );\n        uint256 oldVotingPeriod = votingPeriod;\n        votingPeriod = newVotingPeriod;\n\n        emit VotingPeriodSet(oldVotingPeriod, votingPeriod);\n    }\n\n    /**\n     * @notice Admin function for setting the proposal threshold\n     * @dev newProposalThreshold must be greater than the hardcoded min\n     * @param newProposalThreshold new proposal threshold\n     */\n    function _setProposalThreshold(uint256 newProposalThreshold) external {\n        require(msg.sender == admin, \"GovernorBravo::_setProposalThreshold: admin only\");\n        require(\n            newProposalThreshold >= MIN_PROPOSAL_THRESHOLD && newProposalThreshold <= MAX_PROPOSAL_THRESHOLD,\n            \"GovernorBravo::_setProposalThreshold: invalid proposal threshold\"\n        );\n        uint256 oldProposalThreshold = proposalThreshold;\n        proposalThreshold = newProposalThreshold;\n\n        emit ProposalThresholdSet(oldProposalThreshold, proposalThreshold);\n    }\n\n    /**\n     * @notice Admin function for setting the whitelist expiration as a timestamp for an account. Whitelist status allows accounts to propose without meeting threshold\n     * @param account Account address to set whitelist expiration for\n     * @param expiration Expiration for account whitelist status as timestamp (if now < expiration, whitelisted)\n     */\n    function _setWhitelistAccountExpiration(address account, uint256 expiration) external {\n        require(\n            msg.sender == admin || msg.sender == whitelistGuardian,\n            \"GovernorBravo::_setWhitelistAccountExpiration: admin only\"\n        );\n        whitelistAccountExpirations[account] = expiration;\n\n        emit WhitelistAccountExpirationSet(account, expiration);\n    }\n\n    /**\n     * @notice Admin function for setting the whitelistGuardian. WhitelistGuardian can cancel proposals from whitelisted addresses\n     * @param account Account to set whitelistGuardian to (0x0 to remove whitelistGuardian)\n     */\n    function _setWhitelistGuardian(address account) external {\n        require(msg.sender == admin, \"GovernorBravo::_setWhitelistGuardian: admin only\");\n        address oldGuardian = whitelistGuardian;\n        whitelistGuardian = account;\n\n        emit WhitelistGuardianSet(oldGuardian, whitelistGuardian);\n    }\n\n    /**\n     * @notice Initiate the GovernorBravo contract\n     * @dev Admin only. Sets initial proposal id which initiates the contract, ensuring a continuous proposal id count\n     * @param governorAlpha The address for the Governor to continue the proposal id count from\n     */\n    function _initiate(address governorAlpha) external {\n        require(msg.sender == admin, \"GovernorBravo::_initiate: admin only\");\n        require(initialProposalId == 0, \"GovernorBravo::_initiate: can only initiate once\");\n        proposalCount = GovernorAlpha(governorAlpha).proposalCount();\n        initialProposalId = proposalCount;\n        timelock.acceptAdmin();\n    }\n\n    /**\n     * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @param newPendingAdmin New pending admin.\n     */\n    function _setPendingAdmin(address newPendingAdmin) external {\n        // Check caller = admin\n        require(msg.sender == admin, \"GovernorBravo:_setPendingAdmin: admin only\");\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n    }\n\n    /**\n     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n     * @dev Admin function for pending admin to accept role and update admin\n     */\n    function _acceptAdmin() external {\n        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\n        require(\n            msg.sender == pendingAdmin && msg.sender != address(0), \"GovernorBravo:_acceptAdmin: pending admin only\"\n        );\n\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n\n        // Clear the pending value\n        pendingAdmin = address(0);\n\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n    }\n\n    function add256(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"addition overflow\");\n        return c;\n    }\n\n    function sub256(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"subtraction underflow\");\n        return a - b;\n    }\n\n    function getChainIdInternal() internal view returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n}"
    },
    {
      "filename": "src/talos/libraries/PoolActions.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Logic inspired by Popsicle Finance Contracts (PopsicleV3Optimizer/contracts/libraries/PoolActions.sol)\npragma solidity ^0.8.0;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IUniswapV3Pool} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {INonfungiblePositionManager} from \"@uniswap/v3-periphery/contracts/interfaces/INonfungiblePositionManager.sol\";\n\nimport {ITalosOptimizer} from \"@talos/interfaces/ITalosOptimizer.sol\";\n\nimport {PoolVariables} from \"./PoolVariables.sol\";\n\n/// @title Pool Actions - Library for conducting uniswap v3 pool actions\n/// @author MaiaDAO\n/// @notice This library is created to conduct a variety of swap, burn and add liquidity methods.\nlibrary PoolActions {\n    using PoolVariables for IUniswapV3Pool;\n\n    /// @notice Shows current Optimizer's balances\n    /// @param totalAmount0 Current token0 Optimizer's balance\n    /// @param totalAmount1 Current token1 Optimizer's balance\n    event Snapshot(uint256 totalAmount0, uint256 totalAmount1);\n\n    //Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    struct SwapCallbackData {\n        bool zeroForOne;\n    }\n\n    struct ActionParams {\n        IUniswapV3Pool pool;\n        ITalosOptimizer optimizer;\n        ERC20 token0;\n        ERC20 token1;\n        int24 tickSpacing;\n    }\n\n    function swapToEqualAmounts(ActionParams memory actionParams, int24 baseThreshold) internal {\n        (bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96) = actionParams\n            .pool\n            .getSwapToEqualAmountsParams(\n            actionParams.optimizer, actionParams.tickSpacing, baseThreshold, actionParams.token0, actionParams.token1\n        );\n\n        //Swap imbalanced token as long as we haven't used the entire amountSpecified and haven't reached the price limit\n        actionParams.pool.swap(\n            address(this),\n            zeroForOne,\n            amountSpecified,\n            sqrtPriceLimitX96,\n            abi.encode(SwapCallbackData({zeroForOne: zeroForOne}))\n        );\n    }\n\n    // Rerange a pool according to ITalosOptimizer's parameters\n    function rerange(\n        INonfungiblePositionManager nonfungiblePositionManager,\n        ActionParams memory actionParams,\n        uint24 poolFee\n    )\n        internal\n        returns (int24 tickLower, int24 tickUpper, uint256 amount0, uint256 amount1, uint256 tokenId, uint128 liquidity)\n    {\n        int24 baseThreshold = actionParams.tickSpacing * actionParams.optimizer.tickRangeMultiplier();\n\n        uint256 balance0;\n        uint256 balance1;\n        (balance0, balance1, tickLower, tickUpper) = getThisPositionTicks(\n            actionParams.pool, actionParams.token0, actionParams.token1, baseThreshold, actionParams.tickSpacing\n        );\n        emit Snapshot(balance0, balance1);\n\n        (tokenId, liquidity, amount0, amount1) = nonfungiblePositionManager.mint(\n            INonfungiblePositionManager.MintParams({\n                token0: address(actionParams.token0),\n                token1: address(actionParams.token1),\n                fee: poolFee,\n                tickLower: tickLower,\n                tickUpper: tickUpper,\n                amount0Desired: balance0,\n                amount1Desired: balance1,\n                amount0Min: 0,\n                amount1Min: 0,\n                recipient: address(this),\n                deadline: block.timestamp\n            })\n        );\n    }\n\n    function getThisPositionTicks(\n        IUniswapV3Pool pool,\n        ERC20 token0,\n        ERC20 token1,\n        int24 baseThreshold,\n        int24 tickSpacing\n    ) private view returns (uint256 balance0, uint256 balance1, int24 tickLower, int24 tickUpper) {\n        // Emit snapshot to record balances\n        balance0 = token0.balanceOf(address(this));\n        balance1 = token1.balanceOf(address(this));\n\n        //Get exact ticks depending on Optimizer's balances\n        (tickLower, tickUpper) = pool.getPositionTicks(balance0, balance1, baseThreshold, tickSpacing);\n    }\n}"
    },
    {
      "filename": "src/ulysses-omnichain/RootBridgeAgent.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {WETH9} from \"./interfaces/IWETH9.sol\";\nimport {IUniswapV3Pool} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\n\nimport {AnycallFlags} from \"./lib/AnycallFlags.sol\";\n\nimport {IAnycallProxy} from \"./interfaces/IAnycallProxy.sol\";\nimport {IAnycallConfig} from \"./interfaces/IAnycallConfig.sol\";\nimport {IAnycallExecutor} from \"./interfaces/IAnycallExecutor.sol\";\n\nimport {IApp, IRootBridgeAgent} from \"./interfaces/IRootBridgeAgent.sol\";\nimport {IBranchBridgeAgent} from \"./interfaces/IBranchBridgeAgent.sol\";\nimport {IERC20hTokenRoot} from \"./interfaces/IERC20hTokenRoot.sol\";\nimport {IRootPort as IPort} from \"./interfaces/IRootPort.sol\";\nimport {IRootRouter as IRouter} from \"./interfaces/IRootRouter.sol\";\n\nimport {VirtualAccount} from \"./VirtualAccount.sol\";\nimport {\n    IRootBridgeAgent,\n    DepositParams,\n    DepositMultipleParams,\n    Settlement,\n    SettlementStatus,\n    SettlementParams,\n    SettlementMultipleParams,\n    UserFeeInfo,\n    SwapCallbackData\n} from \"./interfaces/IRootBridgeAgent.sol\";\n\nimport {DeployRootBridgeAgentExecutor, RootBridgeAgentExecutor} from \"./RootBridgeAgentExecutor.sol\";\n\n/// @title Library for Cross Chain Deposit Parameters Validation.\nlibrary CheckParamsLib {\n    /**\n     * @notice Function to check cross-chain deposit parameters and verify deposits made on branch chain are valid.\n     * @param _localPortAddress Address of local Port.\n     * @param _dParams Cross Chain swap parameters.\n     * @param _fromChain Chain ID of the chain where the deposit was made.\n     * @dev Local hToken must be recognized and address must match underlying if exists otherwise only local hToken is checked.\n     *\n     */\n    function checkParams(address _localPortAddress, DepositParams memory _dParams, uint24 _fromChain)\n        internal\n        view\n        returns (bool)\n    {\n        if (\n            (_dParams.amount < _dParams.deposit) //Deposit can't be greater than amount.\n                || (_dParams.amount > 0 && !IPort(_localPortAddress).isLocalToken(_dParams.hToken, _fromChain)) //Check local exists.\n                || (_dParams.deposit > 0 && !IPort(_localPortAddress).isUnderlyingToken(_dParams.token, _fromChain)) //Check underlying exists.\n        ) {\n            return false;\n        }\n        return true;\n    }\n}\n\n/// @title Library for Root Bridge Agent Deployment.\nlibrary DeployRootBridgeAgent {\n    function deploy(\n        WETH9 _wrappedNativeToken,\n        uint24 _localChainId,\n        address _daoAddress,\n        address _localAnyCallAddress,\n        address _localAnyCallExecutorAddress,\n        address _localPortAddress,\n        address _localRouterAddress\n    ) external returns (RootBridgeAgent) {\n        return new RootBridgeAgent(\n            _wrappedNativeToken,\n            _localChainId,\n            _daoAddress,\n            _localAnyCallAddress,\n            _localAnyCallExecutorAddress,\n            _localPortAddress,\n            _localRouterAddress\n        );\n    }\n}\n\n/// @title  Root Bridge Agent Contract\ncontract RootBridgeAgent is IRootBridgeAgent {\n    using SafeTransferLib for address;\n    using SafeCastLib for uint256;\n\n    /*///////////////////////////////////////////////////////////////\n                            ENCODING CONSTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// AnyExec Consts\n\n    uint8 internal constant PARAMS_START = 1;\n\n    uint8 internal constant PARAMS_START_SIGNED = 21;\n\n    uint8 internal constant PARAMS_ADDRESS_SIZE = 20;\n\n    uint8 internal constant PARAMS_GAS_IN = 32;\n\n    uint8 internal constant PARAMS_GAS_OUT = 16;\n\n    /// BridgeIn Consts\n\n    uint8 internal constant PARAMS_TKN_START = 5;\n\n    uint8 internal constant PARAMS_AMT_OFFSET = 64;\n\n    uint8 internal constant PARAMS_DEPOSIT_OFFSET = 96;\n\n    /*///////////////////////////////////////////////////////////////\n                        ROOT BRIDGE AGENT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Local Chain Id\n    uint24 public immutable localChainId;\n\n    /// @notice Local Wrapped Native Token\n    WETH9 public immutable wrappedNativeToken;\n\n    /// @notice Bridge Agent Factory Address.\n    address public immutable factoryAddress;\n\n    /// @notice Address of DAO.\n    address public immutable daoAddress;\n\n    /// @notice Local Core Root Router Address\n    address public immutable localRouterAddress;\n\n    /// @notice Address for Local Port Address where funds deposited from this chain are stored.\n    address public immutable localPortAddress;\n\n    /// @notice Local Anycall Address\n    address public immutable localAnyCallAddress;\n\n    /// @notice Local Anyexec Address\n    address public immutable localAnyCallExecutorAddress;\n\n    /// @notice Address of Root Bridge Agent Executor.\n    address public immutable bridgeAgentExecutorAddress;\n\n    /*///////////////////////////////////////////////////////////////\n                    BRANCH BRIDGE AGENTS STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Chain -> Branch Bridge Agent Address. For N chains, each Root Bridge Agent Address has M =< N Branch Bridge Agent Address.\n    mapping("
    }
  ]
}