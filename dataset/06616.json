{
  "Title": "[H-01] PositionManager's `moveLiquidity` can freeze funds by removing destination index even when the move was partial",
  "Content": "\n`positionIndex.remove(params_.fromIndex)`removes the PositionManager entry even when it is only partial removal as a result of `IPool(params_.pool).moveQuoteToken(...)` call.\n\nI.e. it is correct to do `fromPosition.lps -= vars.lpbAmountFrom`, but the resulting amount might not be zero, moveQuoteToken() are not guaranteed to clear the position as it has available liquidity constraint. In the case of partial quote funds removal `positionIndex.remove(params_.fromIndex)` operation will freeze the remaining position.\n\n### Impact\n\nPermanent fund freeze for the remaining position of LP beneficiary.\n\n### Proof of Concept\n\nWhile `positions[params_.tokenId][params_.fromIndex]` LP shares are correctly reduced by the amount returned by pool's moveQuoteToken(), the position itself is unconditionally removed from the `positionIndexes[params_.tokenId]`, making any remaining funds unavailable:\n\n<https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L262-L323>\n\n```solidity\n    function moveLiquidity(\n        MoveLiquidityParams calldata params_\n    ) external override mayInteract(params_.pool, params_.tokenId) nonReentrant {\n        Position storage fromPosition = positions[params_.tokenId][params_.fromIndex];\n\n        MoveLiquidityLocalVars memory vars;\n        vars.depositTime = fromPosition.depositTime;\n\n        // handle the case where owner attempts to move liquidity after they've already done so\n        if (vars.depositTime == 0) revert RemovePositionFailed();\n\n        // ensure bucketDeposit accounts for accrued interest\n        IPool(params_.pool).updateInterest();\n\n        // retrieve info of bucket from which liquidity is moved  \n        (\n            vars.bucketLP,\n            vars.bucketCollateral,\n            vars.bankruptcyTime,\n            vars.bucketDeposit,\n        ) = IPool(params_.pool).bucketInfo(params_.fromIndex);\n\n        // check that bucket hasn't gone bankrupt since memorialization\n        if (vars.depositTime <= vars.bankruptcyTime) revert BucketBankrupt();\n\n        // calculate the max amount of quote tokens that can be moved, given the tracked LP\n        vars.maxQuote = _lpToQuoteToken(\n            vars.bucketLP,\n            vars.bucketCollateral,\n            vars.bucketDeposit,\n            fromPosition.lps,\n            vars.bucketDeposit,\n            _priceAt(params_.fromIndex)\n        );\n\n        EnumerableSet.UintSet storage positionIndex = positionIndexes[params_.tokenId];\n\n        // remove bucket index from which liquidity is moved from tracked positions\n>>      if (!positionIndex.remove(params_.fromIndex)) revert RemovePositionFailed();\n\n        // update bucket set at which a position has liquidity\n        // slither-disable-next-line unused-return\n        positionIndex.add(params_.toIndex);\n\n        // move quote tokens in pool\n        (\n            vars.lpbAmountFrom,\n            vars.lpbAmountTo,\n        ) = IPool(params_.pool).moveQuoteToken(\n            vars.maxQuote,\n            params_.fromIndex,\n            params_.toIndex,\n            params_.expiry\n        );\n\n        Position storage toPosition = positions[params_.tokenId][params_.toIndex];\n\n        // update position LP state\n>>      fromPosition.lps -= vars.lpbAmountFrom;\n        toPosition.lps   += vars.lpbAmountTo;\n        // update position deposit time to the from bucket deposit time\n        toPosition.depositTime = vars.depositTime;\n```\n\nBucket can contain a mix of quote and collateral tokens, but moveLiquidity() aims to retrieve `vars.maxQuote = _lpToQuoteToken(...)` quote funds per current exchange rate:\n\n<https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/libraries/helpers/PoolHelper.sol#L222-L236>\n\n```solidity\n    function _lpToQuoteToken(\n        uint256 bucketLP_,\n        uint256 bucketCollateral_,\n        uint256 deposit_,\n        uint256 lenderLPBalance_,\n        uint256 maxQuoteToken_,\n        uint256 bucketPrice_\n    ) pure returns (uint256 quoteTokenAmount_) {\n        uint256 rate = Buckets.getExchangeRate(bucketCollateral_, bucketLP_, deposit_, bucketPrice_);\n\n        quoteTokenAmount_ = Maths.wmul(lenderLPBalance_, rate);\n\n        if (quoteTokenAmount_ > deposit_)       quoteTokenAmount_ = deposit_;\n        if (quoteTokenAmount_ > maxQuoteToken_) quoteTokenAmount_ = maxQuoteToken_;\n    }\n```\n\nThere might be not enough quote deposit funds available to redeem the whole quote amount requested, which is controlled by the corresponding liquidity constraint:\n\n<https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/libraries/external/LenderActions.sol#L711-L719>\n\n```solidity\n        uint256 scaledLpConstraint = Maths.wmul(params_.lpConstraint, exchangeRate);\n        if (\n>>          params_.depositConstraint < scaledDepositAvailable &&\n            params_.depositConstraint < scaledLpConstraint\n        ) {\n            // depositConstraint is binding constraint\n            removedAmount_ = params_.depositConstraint;\n>>          redeemedLP_    = Maths.wdiv(removedAmount_, exchangeRate);\n        }\n```\n\n### Recommended Mitigation Steps\n\nAs a most straightforward solution consider reverting when there is a remainder, i.e. when `fromPosition.lps > dust_threshold`:\n\n<https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L262-L323>\n\n```diff\n    function moveLiquidity(\n        MoveLiquidityParams calldata params_\n    ) external override mayInteract(params_.pool, params_.tokenId) nonReentrant {\n        Position storage fromPosition = positions[params_.tokenId][params_.fromIndex];\n\n        MoveLiquidityLocalVars memory vars;\n        vars.depositTime = fromPosition.depositTime;\n\n        // handle the case where owner attempts to move liquidity after they've already done so\n        if (vars.depositTime == 0) revert RemovePositionFailed();\n\n        // ensure bucketDeposit accounts for accrued interest\n        IPool(params_.pool).updateInterest();\n\n        // retrieve info of bucket from which liquidity is moved  \n        (\n            vars.bucketLP,\n            vars.bucketCollateral,\n            vars.bankruptcyTime,\n            vars.bucketDeposit,\n        ) = IPool(params_.pool).bucketInfo(params_.fromIndex);\n\n        // check that bucket hasn't gone bankrupt since memorialization\n        if (vars.depositTime <= vars.bankruptcyTime) revert BucketBankrupt();\n\n        // calculate the max amount of quote tokens that can be moved, given the tracked LP\n        vars.maxQuote = _lpToQuoteToken(\n            vars.bucketLP,\n            vars.bucketCollateral,\n            vars.bucketDeposit,\n            fromPosition.lps,\n            vars.bucketDeposit,\n            _priceAt(params_.fromIndex)\n        );\n\n        EnumerableSet.UintSet storage positionIndex = positionIndexes[params_.tokenId];\n\n        // remove bucket index from which liquidity is moved from tracked positions\n        if (!positionIndex.remove(params_.fromIndex)) revert RemovePositionFailed();\n\n        // update bucket set at which a position has liquidity\n        // slither-disable-next-line unused-return\n        positionIndex.add(params_.toIndex);\n\n        // move quote tokens in pool\n        (\n            vars.lpbAmountFrom,\n            vars.lpbAmountTo,\n        ) = IPool(params_.pool).moveQuoteToken(\n            vars.maxQuote,\n            params_.fromIndex,\n            params_.toIndex,\n            params_.expiry\n        );\n\n        Position storage toPosition = positions[params_.tokenId][params_.toIndex];\n\n        // update position LP state\n>>      fromPosition.lps -= vars.lpbAmountFrom;\n        toPosition.lps   += vars.lpbAmountTo;\n        // update position deposit time to the from bucket deposit time\n        toPosition.depositTime = vars.depositTime;\n```\n\n**[ith-harvey (Ajna) confirmed](https://github.com/code-423n4/2023-05-ajna-findings/issues/503#issuecomment-1554797037)**\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-05-ajna",
  "Code": [
    {
      "filename": "ajna-core/src/PositionManager.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport { ERC20 }           from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport { IERC20 }          from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport { ERC721 }          from '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport { EnumerableSet }   from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport { Multicall }       from '@openzeppelin/contracts/utils/Multicall.sol';\nimport { ReentrancyGuard } from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport { SafeERC20 }       from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport { IPool }                        from './interfaces/pool/IPool.sol';\nimport { IPositionManager }             from './interfaces/position/IPositionManager.sol';\nimport { IPositionManagerOwnerActions } from './interfaces/position/IPositionManagerOwnerActions.sol';\nimport { IPositionManagerDerivedState } from './interfaces/position/IPositionManagerDerivedState.sol';\nimport { Position }                     from './interfaces/position/IPositionManagerState.sol';\n\nimport { ERC20PoolFactory }  from './ERC20PoolFactory.sol';\nimport { ERC721PoolFactory } from './ERC721PoolFactory.sol';\n\nimport { PermitERC721 } from './base/PermitERC721.sol';\n\nimport {\n    _lpToQuoteToken,\n    _priceAt\n}                      from './libraries/helpers/PoolHelper.sol';\nimport { tokenSymbol } from './libraries/helpers/SafeTokenNamer.sol';\n\nimport { PositionNFTSVG } from './libraries/external/PositionNFTSVG.sol';\n\n/**\n *  @title  Position Manager Contract\n *  @notice Used by Pool lenders to optionally mint `NFT` that represents their positions.\n *          `Lenders` can:\n *          - `mint` positions `NFT` token for a specific pool\n *          - `memorialize` positions for given buckets\n *          - `move liquidity` in pool\n *          - `redeem` positions for given buckets\n *          - `burn` positions `NFT`\n */\ncontract PositionManager is ERC721, PermitERC721, IPositionManager, Multicall, ReentrancyGuard {\n\n    using EnumerableSet for EnumerableSet.UintSet;\n    using SafeERC20     for ERC20;\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    /// @dev Mapping of `token id => ajna pool address` for which token was minted.\n    mapping(uint256 => address) public override poolKey;\n\n    /// @dev Mapping of `token id => ajna pool address` for which token was minted.\n    mapping(uint256 => mapping(uint256 => Position)) internal positions;\n    /// @dev Mapping of `token id => nonce` value used for permit.\n    mapping(uint256 => uint96)                       internal nonces;\n    /// @dev Mapping of `token id => bucket indexes` associated with position.\n    mapping(uint256 => EnumerableSet.UintSet)        internal positionIndexes;\n\n    /// @dev Id of the next token that will be minted. Skips `0`.\n    uint176 private _nextId = 1;\n\n    /******************/\n    /*** Immutables ***/\n    /******************/\n\n    /// @dev The `ERC20` pools factory contract, used to check if address is an `Ajna` pool.\n    ERC20PoolFactory  private immutable erc20PoolFactory;\n    /// @dev The `ERC721` pools factory contract, used to check if address is an `Ajna` pool.\n    ERC721PoolFactory private immutable erc721PoolFactory;\n\n    /*************************/\n    /*** Local Var Structs ***/\n    /*************************/\n\n    /// @dev Struct used for `moveLiquidity` function local vars.\n    struct MoveLiquidityLocalVars {\n        uint256 bucketLP;         // [WAD] amount of LP in from bucket\n        uint256 bucketCollateral; // [WAD] amount of collateral in from bucket\n        uint256 bankruptcyTime;   // from bucket bankruptcy time\n        uint256 bucketDeposit;    // [WAD] from bucket deposit\n        uint256 depositTime;      // lender deposit time in from bucekt\n        uint256 maxQuote;         // [WAD] max amount that can be moved from bucket\n        uint256 lpbAmountFrom;    // [WAD] the LP redeemed from bucket\n        uint256 lpbAmountTo;      // [WAD] the LP awarded in to bucket\n    }\n\n    /*****************/\n    /*** Modifiers ***/\n    /*****************/\n\n    /**\n     *  @dev   Modifier used to check if sender can interact with token id.\n     *  @param pool_    `Ajna` pool address.\n     *  @param tokenId_ Id of positions `NFT`.\n     */\n    modifier mayInteract(address pool_, uint256 tokenId_) {\n\n        // revert if token id is not a valid / minted id\n        _requireMinted(tokenId_);\n\n        // revert if sender is not owner of or entitled to operate on token id\n        if (!_isApprovedOrOwner(msg.sender, tokenId_)) revert NoAuth();\n\n        // revert if the token id is not minted for given pool address\n        if (pool_ != poolKey[tokenId_]) revert WrongPool();\n\n        _;\n    }\n\n    /*******************/\n    /*** Constructor ***/\n    /*******************/\n\n    constructor(\n        ERC20PoolFactory erc20Factory_,\n        ERC721PoolFactory erc721Factory_\n    ) PermitERC721(\"Ajna Positions NFT-V1\", \"AJNA-V1-POS\", \"1\") {\n        erc20PoolFactory  = erc20Factory_;\n        erc721PoolFactory = erc721Factory_;\n    }\n\n    /********************************/\n    /*** Owner External Functions ***/\n    /********************************/\n\n    /**\n     *  @inheritdoc IPositionManagerOwnerActions\n     *  @dev    === Write state ===\n     *  @dev    `nonces`: remove `tokenId` nonce\n     *  @dev    `poolKey`: remove `tokenId => pool` mapping\n     *  @dev    === Revert on ===\n     *  @dev    - `mayInteract`:\n     *  @dev       token id is not a valid / minted id\n     *  @dev       sender is not owner `NoAuth()`\n     *  @dev       token id not minted for given pool `WrongPool()`\n     *  @dev    - positions token to burn has liquidity `LiquidityNotRemoved()`\n     *  @dev    === Emit events ===\n     *  @dev    - `Burn`\n     */\n    function burn(\n        BurnParams calldata params_\n    ) external override mayInteract(params_.pool, params_.tokenId) {\n        // revert if trying to burn an positions token that still has liquidity\n        if (positionIndexes[params_.tokenId].length() != 0) revert LiquidityNotRemoved();\n\n        // remove permit nonces and pool mapping for burned token\n        delete nonces[params_.tokenId];\n        delete poolKey[params_.tokenId];\n\n        _burn(params_.tokenId);\n\n        emit Burn(msg.sender, params_.tokenId);\n    }\n\n    /**\n     *  @inheritdoc IPositionManagerOwnerActions\n     *  @dev    External calls to `Pool` contract:\n     *  @dev    - `lenderInfo()`: get lender position in bucket\n     *  @dev    - `transferLP()`: transfer `LP` ownership to `PositionManager` contract\n     *  @dev    === Write state ===\n     *  @dev    `positionIndexes`: add bucket index\n     *  @dev    `positions`: update `tokenId => bucket id` position\n     *  @dev    === Revert on ===\n     *  @dev    positions token to burn has liquidity `LiquidityNotRemoved()`\n     *  @dev    === Emit events ===\n     *  @dev    - `MemorializePosition`\n     */\n    function memorializePositions(\n        MemorializePositionsParams calldata params_\n    ) external override {\n        EnumerableSet.UintSet storage positionIndex = positionIndexes[params_.tokenId];\n\n        IPool   pool  = IPool(poolKey[params_.tokenId]);\n        address owner = ownerOf(params_.tokenId);\n\n        uint256 indexesLength = params_.indexes.length;\n        uint256 index;\n\n        for (uint256 i = 0; i < indexesLength; ) {\n            index = params_.indexes[i];\n\n            // record bucket index at which a position has added liquidity\n            // slither-disable-next-line unused-return\n            positionIndex.add(index);\n\n            (uint256 lpBalance, uint256 depositTime) = pool.lenderInfo(index, owner);\n\n            Position memory position = positions[params_.tokenId][index];\n\n            // check for previous deposits\n            if (position.depositTime != 0) {\n                // check that bucket didn't go bankrupt after prior memorialization\n                if (_bucketBankruptAfterDeposit(pool, index, position.depositTime)) {\n                    // if bucket did go bankrupt, zero out the LP tracked by position manager\n                    position.lps = 0;\n                }\n            }\n\n            // update token position LP\n            position.lps += lpBalance;\n            // set token's position deposit time to the original lender's deposit time\n            position.depositTime = depositTime;\n\n            // save position in storage\n            positions[params_.tokenId][index] = position;\n\n            unchecked { ++i; }\n        }\n\n        // update pool LP accounting and transfer ownership of LP to PositionManager contract\n        pool.transferLP(owner, address(this), params_.indexes);\n\n        emit MemorializePosition(owner, params_.tokenId, params_.indexes);\n    }\n\n    /**\n     *  @inheritdoc IPositionManagerOwnerActions\n     *  @dev    === Write state ===\n     *  @dev    `poolKey`: update `tokenId => pool` mapping\n     *  @dev    === Revert on ===\n     *  @dev    provided pool not valid `NotAjnaPool()`\n     *  @dev    === Emit events ===\n     *  @dev    - `Mint`\n     */\n    function mint(\n        MintParams calldata params_\n    ) external override nonReentrant returns (uint256 tokenId_) {\n        tokenId_ = _nextId++;\n\n        // revert if the address is not a valid Ajna pool\n        if (!_isAjnaPool(params_.pool, params_.poolSubsetHash)) revert NotAjnaPool();\n\n        // record which pool the tokenId was minted in\n        poolKey[tokenId_] = params_.pool;\n\n        _mint(params_.recipient, tokenId_);\n\n        emit Mint(params_.recipient, params_.pool, tokenId_);\n    }\n\n    /**\n     *  @inheritdoc IPositionManagerOwnerActions\n     *  @dev    External calls to `Pool` contract:\n     *  @dev    `bucketInfo()`: get from bucket info\n     *  @dev    `moveQuoteToken()`: move liquidity between buckets\n     *  @dev    === Write state ===\n     *  @dev    `positionIndexes`: remove from bucket index\n     *  @dev    `positionIndexes`: add to bucket index\n     *  @dev    `positions`: update from bucket position\n     *  @dev    `positions`: update to bucket position\n     *  @dev    === Revert on ===\n     *  @dev    - `mayInteract`:\n     *  @dev      token id is not a valid / minted id\n     *  @dev      sender is not owner `NoAuth()`\n     *  @dev      token id not minted for given pool `WrongPool()`\n     *  @dev    - positions token to burn has liquidity `LiquidityNotRemoved()`\n     *  @dev    === Emit events ===\n     *  @dev    - `MoveLiquidity`\n     */\n    function moveLiquidity(\n        MoveLiquidityParams calldata params_\n    ) external override mayInteract(params_.pool, params_.tokenId) nonReentrant {\n        Position storage fromPosition = positions[params_.tokenId][params_.fromIndex];\n\n        MoveLiquidityLocalVars memory vars;\n        vars.depositTime = fromPosition.depositTime;\n\n        // handle the case where owner attempts to move liquidity after they've already done so\n        if (vars.depositTime == 0) revert RemovePositionFailed();\n\n        // ensure bucketDeposit accounts for accrued interest\n        IPool(params_.pool).updateInterest();\n\n        // retrieve info of bucket from which liquidity is moved  \n        (\n            vars.bucketLP,\n            vars.bucketCollateral,\n            vars.bankruptcyTime,\n            vars.bucketDeposit,\n        ) = IPool(params_.pool).bucketInfo(params_.fromIndex);\n\n        // check that bucket hasn't gone bankrupt since memorialization\n        if (vars.depositTime <= vars.bankruptcyTime) revert BucketBankrupt();\n\n        // calculate the max amount of quote tokens that can be moved, given the tracked LP\n        vars.maxQuote = _lpToQuoteToken(\n            vars.bucketLP,\n            vars.bucketCollateral,\n            vars.bucketDeposit,\n            fromPosition.lps,\n            vars.bucketDeposit,\n            _priceAt(params_.fromIndex)\n        );\n\n        EnumerableSet.UintSet storage positionIndex = positionIndexes[params_.tokenId];\n\n        // remove bucket index from which liquidity is moved from tracked positions\n        if (!positionIndex.remove(params_.fromIndex)) revert RemovePositionFailed();\n\n        // update bucket set at which a position has liquidity\n        // slither-disable-next-line unused-return\n        positionIndex.add(params_.toIndex);\n\n        // move quote tokens in pool\n        (\n            vars.lpbAmountFrom,\n            vars.lpbAmountTo,\n        ) = IPool(params_.pool).moveQuoteToken(\n            vars.maxQuote,\n            params_.fromIndex,\n            params_.toIndex,\n            params_.expiry\n        );\n\n        Position storage toPosition = positions[params_.tokenId][params_.toIndex];\n\n        // update position LP state\n        fromPosition.lps -= vars.lpbAmountFrom;\n        toPosition.lps   += vars.lpbAmountTo;\n        // update position deposit time to the from bucket deposit time\n        toPosition.depositTime = vars.depositTime;\n\n        emit MoveLiquidity(\n            ownerOf(params_.tokenId),\n            params_.tokenId,\n            params_.fromIndex,\n            params_.toIndex,\n            vars.lpbAmountFrom,\n            vars.lpbAmountTo\n        );\n    }\n\n    /**\n     *  @inheritdoc IPositionManagerOwnerActions\n     *  @dev    External calls to `Pool` contract:\n     *  @dev    `increaseLPAllowance()`: approve ownership for transfer\n     *  @dev    `transferLP()`: transfer `LP` ownership from `PositionManager` contract\n     *  @dev    === Write state ===\n     *  @dev    `positionIndexes`: remove from bucket index\n     *  @dev    `positions`: delete bucket position\n     *  @dev    === Revert on ===\n     *  @dev    - `mayInteract`:\n     *  @dev      token id is not a valid / minted id\n     *  @dev      sender is not owner `NoAuth()`\n     *  @dev      token id not minted for given pool `WrongPool()`\n     *  @dev    - position not tracked `RemoveLiquidityFailed()`\n     *  @dev    === Emit events ===\n     *  @dev    - `RedeemPosition`\n     */\n    function reedemPositions(\n        RedeemPositionsParams calldata params_\n    ) external override mayInteract(params_.pool, params_.tokenId) {\n        EnumerableSet.UintSet storage positionIndex = positionIndexes[params_.tokenId];\n\n        IPool pool = IPool(params_.pool);\n\n        uint256 indexesLength = params_.indexes.length;\n        uint256[] memory lpAmounts = new uint256[](indexesLength);\n\n        uint256 index;\n\n        for (uint256 i = 0; i < indexesLength; ) {\n            index = params_.indexes[i];\n\n            Position memory position = positions[params_.tokenId][index];\n\n            if (position.depositTime == 0 || position.lps == 0) revert RemovePositionFailed();\n\n            // check that bucket didn't go bankrupt after memorialization\n            if (_bucketBankruptAfterDeposit(pool, index, position.depositTime)) revert BucketBankrupt();\n\n            // remove bucket index at which a position has added liquidity\n            if (!positionIndex.remove(index)) revert RemovePositionFailed();\n\n            lpAmounts[i] = position.lps;\n\n            // remove LP tracked by position manager at bucket index\n            delete positions[params_.tokenId][index];\n\n            unchecked { ++i; }\n        }\n\n        address owner = ownerOf(params_.tokenId);\n\n        // approve owner to take over the LP ownership (required for transferLP pool call)\n        pool.increaseLPAllowance(owner, params_.indexes, lpAmounts);\n        // update pool lps accounting and transfer ownership of lps from PositionManager contract\n        pool.transferLP(address(this), owner, params_.indexes);\n\n        emit RedeemPosition(owner, params_.tokenId, params_.indexes);\n    }\n\n    /**************************/\n    /*** Internal Functions ***/\n    /**************************/\n\n    /**\n     *  @notice Retrieves token's next nonce for permit.\n     *  @param  tokenId_ Address of the `Ajna` pool to retrieve accumulators of.\n     *  @return Incremented token permit nonce.\n     */\n    function _getAndIncrementNonce(\n        uint256 tokenId_\n    ) internal override returns (uint256) {\n        return uint256(nonces[tokenId_]++);\n    }\n\n    /**\n     *  @notice Checks that a provided pool address was deployed by an `Ajna` factory.\n     *  @param  pool_       Address of the `Ajna` pool.\n     *  @param  subsetHash_ Factory's subset hash pool.\n     *  @return `True` if a valid `Ajna` pool, `false` otherwise.\n     */\n    function _isAjnaPool(\n        address pool_,\n        bytes32 subsetHash_\n    ) internal view returns (bool) {\n        address collateralAddress = IPool(pool_).collateralAddress();\n        address quoteAddress      = IPool(pool_).quoteTokenAddress();\n\n        address erc20DeployedPoolAddress  = erc20PoolFactory.deployedPools(subsetHash_, collateralAddress, quoteAddress);\n        address erc721DeployedPoolAddress = erc721PoolFactory.deployedPools(subsetHash_, collateralAddress, quoteAddress);\n\n        return (pool_ == erc20DeployedPoolAddress || pool_ == erc721DeployedPoolAddress);\n    }\n\n    /**\n     *  @notice Checks that a bucket index associated with a given `NFT` didn't go bankrupt after memorialization.\n     *  @param  pool_        The address of the pool of memorialized position.\n     *  @param  index_       The bucket index to check deposit time for.\n     *  @param  depositTime_ The recorded deposit time of the position.\n     *  @return `True` if the bucket went bankrupt after that position memorialzied their `LP`.\n     */\n    function _bucketBankruptAfterDeposit(\n        IPool pool_,\n        uint256 index_,\n        uint256 depositTime_\n    ) internal view returns (bool) {\n        (, , uint256 bankruptcyTime, , ) = pool_.bucketInfo(index_);\n        return depositTime_ <= bankruptcyTime;\n    }\n\n    /**********************/\n    /*** View Functions ***/\n    /**********************/\n\n    /// @inheritdoc IPositionManagerDerivedState\n    function getLP(\n        uint256 tokenId_,\n        uint256 index_\n    ) external override view returns (uint256) {\n        Position memory position = positions[tokenId_][index_];\n        return _bucketBankruptAfterDeposit(IPool(poolKey[tokenId_]), index_, position.depositTime) ? 0 : position.lps;\n    }\n\n    /// @inheritdoc IPositionManagerDerivedState\n    function getPositionIndexes(\n        uint256 tokenId_\n    ) external view override returns (uint256[] memory) {\n        return positionIndexes[tokenId_].values();\n    }\n\n    /// @inheritdoc IPositionManagerDerivedState\n    function getPositionIndexesFiltered(\n        uint256 tokenId_\n    ) external view override returns (uint256[] memory filteredIndexes_) {\n        uint256[] memory indexes = positionIndexes[tokenId_].values();\n        uint256 indexesLength = indexes.length;\n\n        // filter out bankrupt buckets\n        filteredIndexes_ = new uint256[](indexesLength);\n        uint256 filteredIndexesLength = 0;\n        IPool pool = IPool(poolKey[tokenId_]);\n        for (uint256 i = 0; i < indexesLength; ) {\n            if (!_bucketBankruptAfterDeposit(pool, indexes[i], positions[tokenId_][indexes[i]].depositTime)) {\n                filteredIndexes_[filteredIndexesLength++] = indexes[i];\n            }\n            unchecked { ++i; }\n        }\n\n        // resize array\n        assembly { mstore(filteredIndexes_, filteredIndexesLength) }\n    }\n\n    /// @inheritdoc IPositionManagerDerivedState\n    function getPositionInfo(\n        uint256 tokenId_,\n        uint256 index_\n    ) external view override returns (uint256, uint256) {\n        return (\n            positions[tokenId_][index_].lps,\n            positions[tokenId_][index_].depositTime\n        );\n    }\n\n    /// @inheritdoc IPositionManagerDerivedState\n    function isPositionBucketBankrupt(\n        uint256 tokenId_,\n        uint256 index_\n    ) external view override returns (bool) {\n        return _bucketBankruptAfterDeposit(IPool(poolKey[tokenId_]), index_, positions[tokenId_][index_].depositTime);\n    }\n\n    /// @inheritdoc IPositionManagerDerivedState\n    function isIndexInPosition(\n        uint256 tokenId_,\n        uint256 index_\n    ) external override view returns (bool) {\n        return positionIndexes[tokenId_].contains(index_);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(\n        uint256 tokenId_\n    ) public view override(ERC721) returns (string memory) {\n        require(_exists(tokenId_));\n\n        address collateralTokenAddress = IPool(poolKey[tokenId_]).collateralAddress();\n        address quoteTokenAddress      = IPool(poolKey[tokenId_]).quoteTokenAddress();\n\n        PositionNFTSVG.ConstructTokenURIParams memory params = PositionNFTSVG.ConstructTokenURIParams({\n            collateralTokenSymbol: tokenSymbol(collateralTokenAddress),\n            quoteTokenSymbol:      tokenSymbol(quoteTokenAddress),\n            tokenId:               tokenId_,\n            pool:                  poolKey[tokenId_],\n            owner:                 ownerOf(tokenId_),\n            indexes:               positionIndexes[tokenId_].values()\n        });\n\n        return PositionNFTSVG.constructTokenURI(params);\n    }\n\n}"
    },
    {
      "filename": "ajna-core/src/libraries/helpers/PoolHelper.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport { PRBMathSD59x18 } from \"@prb-math/contracts/PRBMathSD59x18.sol\";\n\nimport { PoolType } from '../../interfaces/pool/IPool.sol';\n\nimport { Buckets } from '../internal/Buckets.sol';\nimport { Maths }   from '../internal/Maths.sol';\n\n    error BucketIndexOutOfBounds();\n    error BucketPriceOutOfBounds();\n\n    /*************************/\n    /*** Price Conversions ***/\n    /*************************/\n\n    /// @dev constant price indices defining the min and max of the potential price range\n    int256  constant MAX_BUCKET_INDEX  =  4_156;\n    int256  constant MIN_BUCKET_INDEX  = -3_232;\n    uint256 constant MAX_FENWICK_INDEX =  7_388;\n\n    uint256 constant MIN_PRICE = 99_836_282_890;\n    uint256 constant MAX_PRICE = 1_004_968_987.606512354182109771 * 1e18;\n\n    /// @dev step amounts in basis points. This is a constant across pools at `0.005`, achieved by dividing `WAD` by `10,000`\n    int256 constant FLOAT_STEP_INT = 1.005 * 1e18;\n\n    /**\n     *  @notice Calculates the price for a given `Fenwick` index.\n     *  @dev    Reverts with `BucketIndexOutOfBounds` if index exceeds maximum constant.\n     *  @dev    Uses fixed-point math to get around lack of floating point numbers in `EVM`.\n     *  @dev    Price expected to be inputted as a `WAD` (`18` decimal).\n     *  @dev    Fenwick index is converted to bucket index.\n     *  @dev    Fenwick index to bucket index conversion:\n     *  @dev      `1.00`      : bucket index `0`,     fenwick index `4156`: `7388-4156-3232=0`.\n     *  @dev      `MAX_PRICE` : bucket index `4156`,  fenwick index `0`:    `7388-0-3232=4156`.\n     *  @dev      `MIN_PRICE` : bucket index - `3232`, fenwick index `7388`: `7388-7388-3232=-3232`.\n     *  @dev    `V1`: `price = MIN_PRICE + (FLOAT_STEP * index)`\n     *  @dev    `V2`: `price = MAX_PRICE * (FLOAT_STEP ** (abs(int256(index - MAX_PRICE_INDEX))));`\n     *  @dev    `V3 (final)`: `x^y = 2^(y*log_2(x))`\n     */\n    function _priceAt(\n        uint256 index_\n    ) pure returns (uint256) {\n        // Lowest Fenwick index is highest price, so invert the index and offset by highest bucket index.\n        int256 bucketIndex = MAX_BUCKET_INDEX - int256(index_);\n        if (bucketIndex < MIN_BUCKET_INDEX || bucketIndex > MAX_BUCKET_INDEX) revert BucketIndexOutOfBounds();\n\n        return uint256(\n            PRBMathSD59x18.exp2(\n                PRBMathSD59x18.mul(\n                    PRBMathSD59x18.fromInt(bucketIndex),\n                    PRBMathSD59x18.log2(FLOAT_STEP_INT)\n                )\n            )\n        );\n    }\n\n    /**\n     *  @notice Calculates the  Fenwick  index for a given price.\n     *  @dev    Reverts with `BucketPriceOutOfBounds` if price exceeds maximum constant.\n     *  @dev    Price expected to be inputted as a `WAD` (`18` decimal).\n     *  @dev    `V1`: `bucket index = (price - MIN_PRICE) / FLOAT_STEP`\n     *  @dev    `V2`: `bucket index = (log(FLOAT_STEP) * price) /  MAX_PRICE`\n     *  @dev    `V3 (final)`: `bucket index =  log_2(price) / log_2(FLOAT_STEP)`\n     *  @dev    `Fenwick index = 7388 - bucket index + 3232`\n     */\n    function _indexOf(\n        uint256 price_\n    ) pure returns (uint256) {\n        if (price_ < MIN_PRICE || price_ > MAX_PRICE) revert BucketPriceOutOfBounds();\n\n        int256 index = PRBMathSD59x18.div(\n            PRBMathSD59x18.log2(int256(price_)),\n            PRBMathSD59x18.log2(FLOAT_STEP_INT)\n        );\n\n        int256 ceilIndex = PRBMathSD59x18.ceil(index);\n        if (index < 0 && ceilIndex - index > 0.5 * 1e18) {\n            return uint256(4157 - PRBMathSD59x18.toInt(ceilIndex));\n        }\n        return uint256(4156 - PRBMathSD59x18.toInt(ceilIndex));\n    }\n\n    /**********************/\n    /*** Pool Utilities ***/\n    /**********************/\n\n    /**\n     *  @notice Calculates the minimum debt amount that can be borrowed or can remain in a loan in pool.\n     *  @param  debt_          The debt amount to calculate minimum debt amount for.\n     *  @param  loansCount_    The number of loans in pool.\n     *  @return minDebtAmount_ Minimum debt amount value of the pool.\n     */\n    function _minDebtAmount(\n        uint256 debt_,\n        uint256 loansCount_\n    ) pure returns (uint256 minDebtAmount_) {\n        if (loansCount_ != 0) {\n            minDebtAmount_ = Maths.wdiv(Maths.wdiv(debt_, Maths.wad(loansCount_)), 10**19);\n        }\n    }\n\n    /**\n     *  @notice Calculates origination fee for a given interest rate.\n     *  @notice Calculated as greater of the current annualized interest rate divided by `52` (one week of interest) or `5` bps.\n     *  @param  interestRate_ The current interest rate.\n     *  @return Fee rate based upon the given interest rate.\n     */\n    function _borrowFeeRate(\n        uint256 interestRate_\n    ) pure returns (uint256) {\n        // greater of the current annualized interest rate divided by 52 (one week of interest) or 5 bps\n        return Maths.max(Maths.wdiv(interestRate_, 52 * 1e18), 0.0005 * 1e18);\n    }\n\n    /**\n     * @notice Calculates the unutilized deposit fee, charged to lenders who deposit below the `LUP`.\n     * @param  interestRate_ The current interest rate.\n     * @return Fee rate based upon the given interest rate.\n     */\n    function _depositFeeRate(\n        uint256 interestRate_\n    ) pure returns (uint256) {\n        // current annualized rate divided by 365 (24 hours of interest)\n        return Maths.wdiv(interestRate_, 365 * 1e18);\n    }\n\n    /**\n     *  @notice Calculates debt-weighted average threshold price.\n     *  @param  t0Debt_              Pool debt owed by borrowers in `t0` terms.\n     *  @param  inflator_            Pool's borrower inflator.\n     *  @param  t0Debt2ToCollateral_ `t0-debt-squared-to-collateral` accumulator. \n     */\n    function _dwatp(\n        uint256 t0Debt_,\n        uint256 inflator_,\n        uint256 t0Debt2ToCollateral_\n    ) pure returns (uint256) {\n        return t0Debt_ == 0 ? 0 : Maths.wdiv(Maths.wmul(inflator_, t0Debt2ToCollateral_), t0Debt_);\n    }\n\n    /**\n     *  @notice Collateralization calculation.\n     *  @param debt_       Debt to calculate collateralization for.\n     *  @param collateral_ Collateral to calculate collateralization for.\n     *  @param price_      Price to calculate collateralization for.\n     *  @param type_       Type of the pool.\n     *  @return `True` if collateralization calculated is equal or greater than `1`.\n     */\n    function _isCollateralized(\n        uint256 debt_,\n        uint256 collateral_,\n        uint256 price_,\n        uint8 type_\n    ) pure returns (bool) {\n        if (type_ == uint8(PoolType.ERC20)) return Maths.wmul(collateral_, price_) >= debt_;\n        else {\n            //slither-disable-next-line divide-before-multiply\n            collateral_ = (collateral_ / Maths.WAD) * Maths.WAD; // use collateral floor\n            return Maths.wmul(collateral_, price_) >= debt_;\n        }\n    }\n\n    /**\n     *  @notice Price precision adjustment used in calculating collateral dust for a bucket.\n     *          To ensure the accuracy of the exchange rate calculation, buckets with smaller prices require\n     *          larger minimum amounts of collateral.  This formula imposes a lower bound independent of token scale.\n     *  @param  bucketIndex_              Index of the bucket, or `0` for encumbered collateral with no bucket affinity.\n     *  @return pricePrecisionAdjustment_ Unscaled integer of the minimum number of decimal places the dust limit requires.\n     */\n    function _getCollateralDustPricePrecisionAdjustment(\n        uint256 bucketIndex_\n    ) pure returns (uint256 pricePrecisionAdjustment_) {\n        // conditional is a gas optimization\n        if (bucketIndex_ > 3900) {\n            int256 bucketOffset = int256(bucketIndex_ - 3900);\n            int256 result = PRBMathSD59x18.sqrt(PRBMathSD59x18.div(bucketOffset * 1e18, int256(36 * 1e18)));\n            pricePrecisionAdjustment_ = uint256(result / 1e18);\n        }\n    }\n\n    /**\n     *  @notice Returns the amount of collateral calculated for the given amount of `LP`.\n     *  @param  bucketCollateral_ Amount of collateral in bucket.\n     *  @param  bucketLP_         Amount of `LP` in bucket.\n     *  @param  deposit_          Current bucket deposit (quote tokens). Used to calculate bucket's exchange rate / `LP`.\n     *  @param  lenderLPBalance_  The amount of `LP` to calculate collateral for.\n     *  @param  bucketPrice_      Bucket's price.\n     *  @return collateralAmount_ Amount of collateral calculated for the given `LP `amount.\n     */\n    function _lpToCollateral(\n        uint256 bucketCollateral_,\n        uint256 bucketLP_,\n        uint256 deposit_,\n        uint256 lenderLPBalance_,\n        uint256 bucketPrice_\n    ) pure returns (uint256 collateralAmount_) {\n        // max collateral to lp\n        uint256 rate = Buckets.getExchangeRate(bucketCollateral_, bucketLP_, deposit_, bucketPrice_);\n\n        collateralAmount_ = Maths.wdiv(Maths.wmul(lenderLPBalance_, rate), bucketPrice_);\n\n        if (collateralAmount_ > bucketCollateral_) {\n            // user is owed more collateral than is available in the bucket\n            collateralAmount_ = bucketCollateral_;\n        }\n    }\n\n    /**\n     *  @notice Returns the amount of quote tokens calculated for the given amount of `LP`.\n     *  @param  bucketLP_         Amount of `LP` in bucket.\n     *  @param  bucketCollateral_ Amount of collateral in bucket.\n     *  @param  deposit_          Current bucket deposit (quote tokens). Used to calculate bucket's exchange rate / `LP`.\n     *  @param  lenderLPBalance_  The amount of `LP` to calculate quote token amount for.\n     *  @param  maxQuoteToken_    The max quote token amount to calculate `LP` for.\n     *  @param  bucketPrice_      Bucket's price.\n     *  @return quoteTokenAmount_ Amount of quote tokens calculated for the given `LP` amount.\n     */\n    function _lpToQuoteToken(\n        uint256 bucketLP_,\n        uint256 bucketCollateral_,\n        uint256 deposit_,\n        uint256 lenderLPBalance_,\n        uint256 maxQuoteToken_,\n        uint256 bucketPrice_\n    ) pure returns (uint256 quoteTokenAmount_) {\n        uint256 rate = Buckets.getExchangeRate(bucketCollateral_, bucketLP_, deposit_, bucketPrice_);\n\n        quoteTokenAmount_ = Maths.wmul(lenderLPBalance_, rate);\n\n        if (quoteTokenAmount_ > deposit_)       quoteTokenAmount_ = deposit_;\n        if (quoteTokenAmount_ > maxQuoteToken_) quoteTokenAmount_ = maxQuoteToken_;\n    }\n\n    /**\n     *  @notice Rounds a token amount down to the minimum amount permissible by the token scale.\n     *  @param  amount_       Value to be rounded.\n     *  @param  tokenScale_   Scale of the token, presented as a power of `10`.\n     *  @return scaledAmount_ Rounded value.\n     */\n    function _roundToScale(\n        uint256 amount_,\n        uint256 tokenScale_\n    ) pure returns (uint256 scaledAmount_) {\n        scaledAmount_ = (amount_ / tokenScale_) * tokenScale_;\n    }\n\n    /**\n     *  @notice Rounds a token amount up to the next amount permissible by the token scale.\n     *  @param  amount_       Value to be rounded.\n     *  @param  tokenScale_   Scale of the token, presented as a power of `10`.\n     *  @return scaledAmount_ Rounded value.\n     */\n    function _roundUpToScale(\n        uint256 amount_,\n        uint256 tokenScale_\n    ) pure returns (uint256 scaledAmount_) {\n        if (amount_ % tokenScale_ == 0)\n            scaledAmount_ = amount_;\n        else\n            scaledAmount_ = _roundToScale(amount_, tokenScale_) + tokenScale_;\n    }\n\n    /********************"
    }
  ]
}