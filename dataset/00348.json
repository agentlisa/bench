{
  "Title": "M-6: Inaccurate value is used for partial fill quote amount when calculating fees",
  "Content": "# Issue M-6: Inaccurate value is used for partial fill quote amount when calculating fees \n\nSource: https://github.com/sherlock-audit/2024-03-axis-finance-judging/issues/182 \n\n## Found by \nhash\n## Summary\nInaccurate value is used for partial fill quote amount when calculating fees which can cause reward claiming / payment withdrawal to revert\n\n## Vulnerability Detail\n\nThe fees of an auction is managed as follows:\n\n1. Whenever a bidder claims their payout, calculate the amount of quote tokens that should be collected as fees (instead of giving the entire quote amount to the seller) and add this to the protocol / referrers rewards\n\n```solidity\n    function claimBids(uint96 lotId_, uint64[] calldata bidIds_) external override nonReentrant {\n        \n        ....\n\n        for (uint256 i = 0; i < bidClaimsLen; i++) {\n            Auction.BidClaim memory bidClaim = bidClaims[i];\n\n            if (bidClaim.payout > 0) {\n               \n=>              _allocateQuoteFees(\n                    protocolFee,\n                    referrerFee,\n                    bidClaim.referrer,\n                    routing.seller,\n                    routing.quoteToken,\n=>                  bidClaim.paid\n                );\n```\n\nHere bidClaim.paid is the amount of quote tokens that was transferred in by the bidder for the purchase\n\n```solidity\n    function _allocateQuoteFees(\n        uint96 protocolFee_,\n        uint96 referrerFee_,\n        address referrer_,\n        address seller_,\n        ERC20 quoteToken_,\n        uint96 amount_\n    ) internal returns (uint96 totalFees) {\n        // Calculate fees for purchase\n        (uint96 toReferrer, uint96 toProtocol) = calculateQuoteFees(\n            protocolFee_, referrerFee_, referrer_ != address(0) && referrer_ != seller_, amount_\n        );\n\n        // Update fee balances if non-zero\n        if (toReferrer > 0) rewards[referrer_][quoteToken_] += uint256(toReferrer);\n        if (toProtocol > 0) rewards[_protocol][quoteToken_] += uint256(toProtocol);\n\n\n        return toReferrer + toProtocol;\n    }\n```\n\n2. Whenever the seller calls claimProceeds to withdraw the amount of quote tokens received from the auction, subtract the quote fees and give out the remaining\n\n```solidity\n    function claimProceeds(\n        uint96 lotId_,\n        bytes calldata callbackData_\n    ) external override nonReentrant {\n        \n        ....\n        \n        uint96 totalInLessFees;\n        {\n=>          (, uint96 toProtocol) = calculateQuoteFees(\n                lotFees[lotId_].protocolFee, lotFees[lotId_].referrerFee, false, purchased_\n            );\n            unchecked {\n=>              totalInLessFees = purchased_ - toProtocol;\n            }\n        }\n```\n\nHere purchased is the total quote token amount that was collected for this auction.\n\nIn case the fees calculated in claimProceeds is less than the sum of fees allocated to the protocol / referrer via claimBids, there will be a mismatch causing the sum of (fees allocated + seller purchased quote tokens) to be greater than the total quote token amount that was transferred in for the auction. This could cause either the protocol/referrer to not obtain their rewards or the seller to not be able to claim the purchased tokens in case there are no excess quote token present in the auction house contract.\n\nIn case, totalPurchased is >= sum of all individual bid quote token amounts (as it is supposed to be), the fee allocation would be correct. But due to the inaccurate computation of the input quote token amount associated with a partial fill, it is possible for the above scenario (ie. `fees calculated in claimProceeds is less than the sum of fees allocated to the protocol / referrer via claimBids`) to occur\n\n```solidity\n    function settle(uint96 lotId_) external override nonReentrant {\n        \n        ....\n\n            if (settlement.pfBidder != address(0)) {\n\n                _allocateQuoteFees(\n                    feeData.protocolFee,\n                    feeData.referrerFee,\n                    settlement.pfReferrer,\n                    routing.seller,\n                    routing.quoteToken,\n\n                    // @audit this method of calculating the input quote token amount associated with a partial fill is not accurate\n                    uint96(\n=>                      Math.mulDivDown(\n                            settlement.pfPayout, settlement.totalIn, settlement.totalOut\n                        )\n                    )\n```\n\nThe above method of calculating the input token amount associated with a partial fill can cause this value to be higher than the acutal value and hence the fees allocated will be less than what the fees that will be captured from the seller will be\n\n### POC\nApply the following diff to `test/AuctionHouse/AuctionHouseTest.sol` and run `forge test --mt testHash_SpecificPartialRounding -vv`\n\nIt is asserted that the tokens allocated as fees is greater than the tokens that will be captured from a seller for fees\n\n```diff\ndiff --git a/moonraker/test/AuctionHouse/AuctionHouseTest.sol b/moonraker/test/AuctionHouse/AuctionHouseTest.sol\nindex 44e717d..9b32834 100644\n--- a/moonraker/test/AuctionHouse/AuctionHouseTest.sol\n+++ b/moonraker/test/AuctionHouse/AuctionHouseTest.sol\n@@ -6,6 +6,8 @@ import {Test} from \"forge-std/Test.sol\";\n import {ERC20} from \"solmate/tokens/ERC20.sol\";\n import {Transfer} from \"src/lib/Transfer.sol\";\n import {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n+import {SafeCastLib} from \"solmate/utils/SafeCastLib.sol\";\n+\n \n // Mocks\n import {MockAtomicAuctionModule} from \"test/modules/Auction/MockAtomicAuctionModule.sol\";\n@@ -134,6 +136,158 @@ abstract contract AuctionHouseTest is Test, Permit2User {\n         _bidder = vm.addr(_bidderKey);\n     }\n \n+        function testHash_SpecificPartialRounding() public {\n+        /*\n+            capacity 1056499719758481066\n+            previous total amount 1000000000000000000\n+            bid amount 2999999999999999999997\n+            price 2556460687578254783645\n+            fullFill 1173497411705521567\n+            excess 117388857750942341\n+            pfPayout 1056108553954579226\n+            pfRefund 300100000000000000633\n+            new totalAmountIn 2700899999999999999364\n+            usedContributionForQuoteFees 2699900000000000000698\n+            quoteTokens1 1000000\n+            quoteTokens2 2699900000\n+            quoteTokensAllocated 2700899999\n+        */\n+\n+        uint bidAmount = 2999999999999999999997;\n+        uint marginalPrice = 2556460687578254783645;\n+        uint capacity = 1056499719758481066;\n+        uint previousTotalAmount = 1000000000000000000;\n+        uint baseScale = 1e18;\n+\n+        // hasn't reached the capacity with previousTotalAmount\n+        assert(\n+            FixedPointMathLib.mulDivDown(previousTotalAmount, baseScale, marginalPrice) <\n+                capacity\n+        );\n+\n+        uint capacityExpended = FixedPointMathLib.mulDivDown(\n+            previousTotalAmount + bidAmount,\n+            baseScale,\n+            marginalPrice\n+        );\n+        assert(capacityExpended > capacity);\n+\n+        uint totalAmountIn = previousTotalAmount + bidAmount;\n+\n+        uint256 fullFill = FixedPointMathLib.mulDivDown(\n+            uint256(bidAmount),\n+            baseScale,\n+            marginalPrice\n+        );\n+\n+        uint256 excess = capacityExpended - capacity;\n+\n+        uint pfPayout = SafeCastLib.safeCastTo96(fullFill - excess);\n+        uint pfRefund = SafeCastLib.safeCastTo96(\n+            FixedPointMathLib.mulDivDown(uint256(bidAmount), excess, fullFill)\n+        );\n+\n+        totalAmountIn -= pfRefund;\n+\n+        uint usedContributionForQuoteFees;\n+        {\n+            uint totalOut = SafeCastLib.safeCastTo96(\n+                capacityExpended > capacity ? capacity : capacityExpended\n+            );\n+\n+            usedContributionForQuoteFees = FixedPointMathLib.mulDivDown(\n+                pfPayout,\n+                totalAmountIn,\n+                totalOut\n+            );\n+        }\n+\n+        {\n+            uint actualContribution = bidAmount - pfRefund;\n+\n+            // acutal contribution is less than the usedContributionForQuoteFees\n+            assert(actualContribution < usedContributionForQuoteFees);\n+            console2.log(\"actual contribution\", actualContribution);\n+            console2.log(\n+                \"used contribution for fees\",\n+                usedContributionForQuoteFees\n+            );\n+        }\n+\n+        // calculating quote fees allocation\n+        // quote fees captured from the seller\n+        {\n+            (, uint96 quoteTokensAllocated) = calculateQuoteFees(\n+                1e3,\n+                0,\n+                false,\n+                SafeCastLib.safeCastTo96(totalAmountIn)\n+            );\n+\n+            // quote tokens that will be allocated for the earlier bid\n+            (, uint96 quoteTokens1) = calculateQuoteFees(\n+                1e3,\n+                0,\n+                false,\n+                SafeCastLib.safeCastTo96(previousTotalAmount)\n+            );\n+\n+            // quote tokens that will be allocated for the partial fill\n+            (, uint96 quoteTokens2) = calculateQuoteFees(\n+                1e3,\n+                0,\n+                false,\n+                SafeCastLib.safeCastTo96(usedContributionForQuoteFees)\n+            );\n+            \n+            console2.log(\"quoteTokens1\", quoteTokens1);\n+            console2.log(\"quoteTokens2\", quoteTokens2);\n+            console2.log(\"quoteTokensAllocated\", quoteTokensAllocated);\n+\n+            // quoteToken fees allocated is greater than what will be captured from seller\n+            assert(quoteTokens1 + quoteTokens2 > quoteTokensAllocated);\n+        }\n+    }\n+\n+        function calculateQuoteFees(\n+        uint96 protocolFee_,\n+        uint96 referrerFee_,\n+        bool hasReferrer_,\n+        uint96 amount_\n+    ) public pure returns (uint96 toReferrer, uint96 toProtocol) {\n+        uint _FEE_DECIMALS = 5;\n+        uint96 feeDecimals = uint96(_FEE_DECIMALS);\n+\n+        if (hasReferrer_) {\n+            // In this case we need to:\n+            // 1. Calculate referrer fee\n+            // 2. Calculate protocol fee as the total expected fee amount minus the referrer fee\n+            //    to avoid issues with rounding from separate fee calculations\n+            toReferrer = uint96(\n+                FixedPointMathLib.mulDivDown(amount_, referrerFee_, feeDecimals)\n+            );\n+            toProtocol =\n+                uint96(\n+                    FixedPointMathLib.mulDivDown(\n+                        amount_,\n+                        protocolFee_ + referrerFee_,\n+                        feeDecimals\n+                    )\n+                ) -\n+                toReferrer;\n+        } else {\n+            // If there is no referrer, the protocol gets the entire fee\n+            toProtocol = uint96(\n+                FixedPointMathLib.mulDivDown(\n+                    amount_,\n+                    protocolFee_ + referrerFee_,\n+                    feeDecimals\n+                )\n+            );\n+        }\n+    }\n+\n+\n     // ===== Helper Functions ===== //\n \n     function _mulDivUp(uint96 mul1_, uint96 mul2_, uint96 div_) internal pure returns (uint96) {\n\n```\n\n## Impact\n\nRewards might not be collectible or seller might not be able to claim the proceeds due to lack of tokens\n\n## Code Snippet\n\ninaccurate computation of the input quote token value for allocating fees\nhttps://github.com/sherlock-audit/2024-03-axis-finance/blob/cadf331f12b485bac184111cdc9ba1344d9fbf01/moonraker/src/AuctionHouse.sol#L512-L515\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse `bidAmount - pfRefund` as the quote token input amount value instead of computing the current way\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/Axis-Fi/moonraker/pull/140\n\n\n**10xhash**\n\n> The protocol team fixed this issue in the following PRs/commits: [Axis-Fi/moonraker#140](https://github.com/Axis-Fi/moonraker/pull/140)\n\nFixed\nThe partial bid amount for quote fees is now calculated as `bidClaim.paid - bidClaim.refund`\n\n**sherlock-admin4**\n\nThe Lead Senior Watson signed off on the fix.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/206",
  "Code": [
    {
      "filename": "moonraker/src/AuctionHouse.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport {Transfer} from \"src/lib/Transfer.sol\";\nimport {FixedPointMathLib as Math} from \"lib/solmate/src/utils/FixedPointMathLib.sol\";\n\nimport {Auctioneer} from \"src/bases/Auctioneer.sol\";\nimport {FeeManager} from \"src/bases/FeeManager.sol\";\n\nimport {DerivativeModule} from \"src/modules/Derivative.sol\";\nimport {Auction, AuctionModule} from \"src/modules/Auction.sol\";\n\nimport {\n    Veecode, fromVeecode, Keycode, keycodeFromVeecode, WithModules\n} from \"src/modules/Modules.sol\";\n\nimport {ICallback} from \"src/interfaces/ICallback.sol\";\nimport {Callbacks} from \"src/lib/Callbacks.sol\";\n\n/// @title      Router\n/// @notice     An interface to define the AuctionHouse's buyer-facing functions\nabstract contract Router {\n    // ========== DATA STRUCTURES ========== //\n\n    /// @notice     Parameters used by the purchase function\n    /// @dev        This reduces the number of variables in scope for the purchase function\n    ///\n    /// @param      recipient           Address to receive payout\n    /// @param      referrer            Address of referrer\n    /// @param      lotId               Lot ID\n    /// @param      amount              Amount of quoteToken to purchase with (in native decimals)\n    /// @param      minAmountOut        Minimum amount of baseToken to receive\n    /// @param      auctionData         Custom data used by the auction module\n    /// @param      permit2Data_        Permit2 approval for the quoteToken\n    struct PurchaseParams {\n        address recipient;\n        address referrer;\n        uint96 lotId;\n        uint96 amount;\n        uint96 minAmountOut;\n        bytes auctionData;\n        bytes permit2Data;\n    }\n\n    /// @notice     Parameters used by the bid function\n    /// @dev        This reduces the number of variables in scope for the bid function\n    ///\n    /// @param      lotId               Lot ID\n    /// @param      recipient           Address to receive payout\n    /// @param      referrer            Address of referrer\n    /// @param      amount              Amount of quoteToken to purchase with (in native decimals)\n    /// @param      auctionData         Custom data used by the auction module\n    /// @param      permit2Data_        Permit2 approval for the quoteToken (abi-encoded Permit2Approval struct)\n    struct BidParams {\n        uint96 lotId;\n        address referrer;\n        uint96 amount;\n        bytes auctionData;\n        bytes permit2Data;\n    }\n\n    // ========== ATOMIC AUCTIONS ========== //\n\n    /// @notice     Purchase a lot from an atomic auction\n    /// @notice     Permit2 is utilised to simplify token transfers\n    ///\n    /// @param      params_         Purchase parameters\n    /// @param      callbackData_   Custom data provided to the onPurchase callback\n    /// @return     payout          Amount of baseToken received by `recipient_` (in native decimals)\n    function purchase(\n        PurchaseParams memory params_,\n        bytes calldata callbackData_\n    ) external virtual returns (uint96 payout);\n\n    // ========== BATCH AUCTIONS ========== //\n\n    /// @notice     Bid on a lot in a batch auction\n    /// @dev        The implementing function must perform the following:\n    ///             1. Validate the bid\n    ///             2. Store the bid\n    ///             3. Transfer the amount of quote token from the bidder\n    ///\n    /// @param      params_         Bid parameters\n    /// @param      callbackData_   Custom data provided to the onBid callback\n    /// @return     bidId           Bid ID\n    function bid(\n        BidParams memory params_,\n        bytes calldata callbackData_\n    ) external virtual returns (uint64 bidId);\n\n    /// @notice     Refund a bid on a lot in a batch auction\n    /// @dev        The implementing function must perform the following:\n    ///             1. Validate the bid\n    ///             2. Pass the request to the auction module to validate and update data\n    ///             3. Send the refund to the bidder\n    ///\n    /// @param      lotId_          Lot ID\n    /// @param      bidId_          Bid ID\n    function refundBid(uint96 lotId_, uint64 bidId_) external virtual;\n\n    /// @notice     Claim bid payouts and/or refunds after a batch auction has settled\n    /// @dev        The implementing function must perform the following:\n    ///             1. Validate the lot ID\n    ///             2. Pass the request to the auction module to validate and update bid data\n    ///             3. Send the refund and/or payout to the bidders\n    ///\n    /// @param      lotId_          Lot ID\n    /// @param      bidIds_         Bid IDs\n    function claimBids(uint96 lotId_, uint64[] calldata bidIds_) external virtual;\n\n    /// @notice     Settle a batch auction\n    /// @notice     This function is used for versions with on-chain storage of bids and settlement\n    /// @dev        The implementing function must perform the following:\n    ///             1. Validate the lot\n    ///             2. Pass the request to the auction module to calculate winning bids\n    ///             3. Collect the payout from the seller (if not pre-funded)\n    ///             4. If there is a partial fill, sends the refund and payout to the bidder\n    ///             5. Send the fees to the curator\n    ///\n    /// @param      lotId_          Lot ID\n    function settle(uint96 lotId_) external virtual;\n\n    /// @notice     Claim the proceeds of a settled auction\n    /// @dev        The implementing function must perform the following:\n    ///             1. Validate the lot\n    ///             2. Pass the request to the auction module to get the proceeds data\n    ///             3. Send the proceeds (quote tokens) to the seller\n    ///             4. Refund any unused base tokens to the seller\n    ///\n    /// @param      lotId_          Lot ID\n    /// @param      callbackData_   Custom data provided to the onClaimProceeds callback\n    function claimProceeds(uint96 lotId_, bytes calldata callbackData_) external virtual;\n}\n\n/// @title      AuctionHouse\n/// @notice     As its name implies, the AuctionHouse is where auctions are created, bid on, and settled. The core protocol logic is implemented here.\ncontract AuctionHouse is Auctioneer, Router, FeeManager {\n    using Callbacks for ICallback;\n\n    // ========== ERRORS ========== //\n\n    error AmountLessThanMinimum();\n    error InsufficientFunding();\n\n    // ========== EVENTS ========== //\n\n    event Purchase(\n        uint96 indexed lotId,\n        address indexed buyer,\n        address referrer,\n        uint256 amount,\n        uint256 payout\n    );\n\n    event Bid(uint96 indexed lotId, uint96 indexed bidId, address indexed bidder, uint256 amount);\n\n    event RefundBid(uint96 indexed lotId, uint96 indexed bidId, address indexed bidder);\n\n    // TODO events for ClaimBid, ClaimProceeds?\n\n    event Settle(uint96 indexed lotId);\n\n    // ========== STATE VARIABLES ========== //\n\n    address internal immutable _PERMIT2;\n\n    // ========== CONSTRUCTOR ========== //\n\n    constructor(\n        address owner_,\n        address protocol_,\n        address permit2_\n    ) FeeManager(protocol_) WithModules(owner_) {\n        _PERMIT2 = permit2_;\n    }\n\n    // ========== ATOMIC AUCTIONS ========== //\n\n    /// @inheritdoc Router\n    /// @dev        This fuction handles the following:\n    ///             1. Calculates the fees for the purchase\n    ///             2. Sends the purchase amount to the auction module\n    ///             3. Records the purchase on the auction module\n    ///             4. Transfers the quote token from the caller\n    ///             5. Transfers the quote token to the seller\n    ///             5. Transfers the base token from the seller or executes the callback\n    ///             6. Transfers the base token to the recipient\n    ///\n    ///             Note that this function will deduct from the payment amount to cover the protocol and referrer fees. The fees at the time of purchase are used.\n    ///\n    ///             This function reverts if:\n    ///             - `lotId_` is invalid\n    ///             - The respective auction module reverts\n    ///             - `payout` is less than `minAmountOut_`\n    ///             - The caller does not have sufficient balance of the quote token\n    ///             - The seller does not have sufficient balance of the payout token\n    ///             - Any of the callbacks fail\n    ///             - Any of the token transfers fail\n    ///             - re-entrancy is detected\n    function purchase(\n        PurchaseParams memory params_,\n        bytes calldata callbackData_\n    ) external override nonReentrant returns (uint96 payoutAmount) {\n        _isLotValid(params_.lotId);\n\n        // Load routing data for the lot\n        Routing storage routing = lotRouting[params_.lotId];\n\n        // Calculate quote fees for purchase\n        // Note: this enables protocol and referrer fees to be changed between purchases\n        uint96 amountLessFees;\n        {\n            Keycode auctionKeycode = keycodeFromVeecode(routing.auctionReference);\n            uint96 totalFees = _allocateQuoteFees(\n                fees[auctionKeycode].protocol,\n                fees[auctionKeycode].referrer,\n                params_.referrer,\n                routing.seller,\n                routing.quoteToken,\n                params_.amount\n            );\n            unchecked {\n                amountLessFees = params_.amount - totalFees;\n            }\n        }\n\n        // Send purchase to auction house and get payout plus any extra output\n        bytes memory auctionOutput;\n        (payoutAmount, auctionOutput) = _getModuleForId(params_.lotId).purchase(\n            params_.lotId, amountLessFees, params_.auctionData\n        );\n\n        // Check that payout is at least minimum amount out\n        // @dev Moved the slippage check from the auction to the AuctionHouse to allow different routing and purchase logic\n        if (payoutAmount < params_.minAmountOut) revert AmountLessThanMinimum();\n\n        // Collect payment from the purchaser\n        _collectPayment(\n            params_.amount, routing.quoteToken, Transfer.decodePermit2Approval(params_.permit2Data)\n        );\n\n        // Send payment, this function handles routing of the quote tokens correctly\n        _sendPayment(routing.seller, amountLessFees, routing.quoteToken, routing.callbacks);\n\n        // Calculate the curator fee (if applicable)\n        uint96 curatorFeePayout = _calculatePayoutFees(\n            lotFees[params_.lotId].curated, lotFees[params_.lotId].curatorFee, payoutAmount\n        );\n\n        // If not prefunded, collect payout from auction owner or callbacks contract, if not prefunded\n        // If prefunded, call the onPurchase callback\n        if (routing.funding == 0) {\n            // If callbacks contract is configured to send base tokens, then source the payout from the callbacks contract\n            if (Callbacks.hasPermission(routing.callbacks, Callbacks.SEND_BASE_TOKENS_FLAG)) {\n                uint256 balanceBefore = routing.baseToken.balanceOf(address(this));\n\n                // The onPurchase callback is expected to transfer the base tokens\n                Callbacks.onPurchase(\n                    routing.callbacks,\n                    params_.lotId,\n                    msg.sender,\n                    amountLessFees,\n                    payoutAmount + curatorFeePayout,\n                    false,\n                    callbackData_\n                );\n\n                // Check that the mid hook transferred the expected amount of payout tokens\n                if (\n                    routing.baseToken.balanceOf(address(this))\n                        < balanceBefore + payoutAmount + curatorFeePayout\n                ) {\n                    revert InvalidCallback();\n                }\n            }\n            // Otherwise, transfer directly from the auction owner\n            // Still call the onPurchase callback to allow for custom logic\n            else {\n                Transfer.transferFrom(\n                    routing.baseToken,\n                    routing.seller,\n                    address(this),\n                    payoutAmount + curatorFeePayout,\n                    true\n                );\n\n                // Call the onPurchase callback\n                Callbacks.onPurchase(\n                    routing.callbacks,\n                    params_.lotId,\n                    msg.sender,\n                    amountLessFees,\n                    payoutAmount + curatorFeePayout,\n                    true,\n                    callbackData_\n                );\n            }\n        } else {\n            // If the auction is prefunded, call the onPurchase callback\n            Callbacks.onPurchase(\n                routing.callbacks,\n                params_.lotId,\n                msg.sender,\n                amountLessFees,\n                payoutAmount + curatorFeePayout,\n                true,\n                callbackData_\n            );\n\n            // Decrease the funding amount (if applicable)\n            // Check invariant\n            if (routing.funding < payoutAmount + curatorFeePayout) revert InsufficientFunding();\n            unchecked {\n                routing.funding -= payoutAmount + curatorFeePayout;\n            }\n        }\n\n        // Send payout to recipient\n        _sendPayout(params_.recipient, payoutAmount, routing, auctionOutput);\n\n        // Send curator fee to curator\n        if (curatorFeePayout > 0) {\n            _sendPayout(lotFees[params_.lotId].curator, curatorFeePayout, routing, auctionOutput);\n        }\n\n        // Emit event\n        emit Purchase(params_.lotId, msg.sender, params_.referrer, params_.amount, payoutAmount);\n    }\n\n    // ========== BATCH AUCTIONS ========== //\n\n    /// @inheritdoc Router\n    /// @dev        This function reverts if:\n    ///             - lotId is invalid\n    ///             - the bidder is not on the optional allowlist\n    ///             - the auction module reverts when creating a bid\n    ///             - the quote token transfer fails\n    ///             - re-entrancy is detected\n    function bid(\n        BidParams memory params_,\n        bytes calldata callbackData_\n    ) external override nonReentrant returns (uint64 bidId) {\n        _isLotValid(params_.lotId);\n\n        // Record the bid on the auction module\n        // The module will determine if the bid is valid - minimum bid size, minimum price, auction status, etc\n        bidId = _getModuleForId(params_.lotId).bid(\n            params_.lotId, msg.sender, params_.referrer, params_.amount, params_.auctionData\n        );\n\n        // Transfer the quote token from the bidder\n        _collectPayment(\n            params_.amount,\n            lotRouting[params_.lotId].quoteToken,\n            Transfer.decodePermit2Approval(params_.permit2Data)\n        );\n\n        // Call the onBid callback\n        Callbacks.onBid(\n            lotRouting[params_.lotId].callbacks,\n            params_.lotId,\n            bidId,\n            msg.sender,\n            params_.amount,\n            callbackData_\n        );\n\n        // Emit event\n        emit Bid(params_.lotId, bidId, msg.sender, params_.amount);\n\n        return bidId;\n    }\n\n    /// @inheritdoc Router\n    /// @dev        This function reverts if:\n    ///             - the lot ID is invalid\n    ///             - the auction module reverts when cancelling the bid\n    ///             - re-entrancy is detected\n    function refundBid(uint96 lotId_, uint64 bidId_) external override nonReentrant {\n        _isLotValid(lotId_);\n\n        // Transfer the quote token to the bidder\n        // The ownership of the bid has already been verified by the auction module\n        Transfer.transfer(\n            lotRouting[lotId_].quoteToken,\n            msg.sender,\n            // Refund the bid on the auction module\n            // The auction module is responsible for validating the bid and authorizing the caller\n            _getModuleForId(lotId_).refundBid(lotId_, bidId_, msg.sender),\n            false\n        );\n\n        // Emit event\n        emit RefundBid(lotId_, bidId_, msg.sender);\n    }\n\n    /// @inheritdoc Router\n    /// @dev        This function reverts if:\n    ///             - the lot ID is invalid\n    ///             - the auction module reverts when claiming the bids\n    ///             - re-entrancy is detected\n    function claimBids(uint96 lotId_, uint64[] calldata bidIds_) external override nonReentrant {\n        _isLotValid(lotId_);\n\n        // Claim the bids on the auction module\n        // The auction module is responsible for validating the bid and authorizing the caller\n        (Auction.BidClaim[] memory bidClaims, bytes memory auctionOutput) =\n            _getModuleForId(lotId_).claimBids(lotId_, bidIds_);\n\n        // Load routing data for the lot\n        Routing storage routing = lotRouting[lotId_];\n\n        // Load fee data\n        uint48 protocolFee = lotFees[lotId_].protocolFee;\n        uint48 referrerFee = lotFees[lotId_].referrerFee;\n\n        // Iterate through the bid claims and handle each one\n        uint256 bidClaimsLen = bidClaims.length;\n        for (uint256 i = 0; i < bidClaimsLen; i++) {\n            Auction.BidClaim memory bidClaim = bidClaims[i];\n\n            // If payout is greater than zero, then the bid was filled.\n            // Otherwise, it was not and the bidder is refunded the paid amount.\n            if (bidClaim.payout > 0) {\n                // Allocate quote and protocol fees for bid\n                _allocateQuoteFees(\n                    protocolFee,\n                    referrerFee,\n                    bidClaim.referrer,\n                    routing.seller,\n                    routing.quoteToken,\n                    bidClaim.paid\n                );\n\n                // Reduce funding by the payout amount\n                unchecked {\n                    routing.funding -= bidClaim.payout;\n                }\n\n                // Send the payout to the bidder\n                _sendPayout(bidClaim.bidder, bidClaim.payout, routing, auctionOutput);\n            } else {\n                // Refund the paid amount to the bidder\n                Transfer.transfer(routing.quoteToken, bidClaim.bidder, bidClaim.paid, false);\n            }\n        }\n    }\n\n    /// @inheritdoc Router\n    /// @dev        This function handles the following:\n    ///             - Settles the auction on the auction module\n    ///             - Calculates the payout amount, taking partial fill into consideration\n    ///             - Caches the fees for the lot\n    ///             - Calculates the fees taken on the quote token\n    ///             - Collects the payout from the seller (if necessary)\n    ///             - Sends the refund and payout to the bidder (if there is a partial fill)\n    ///             - Sends the payout to the curator (if curation is approved)\n    ///\n    ///             This function reverts if:\n    ///             - the lot ID is invalid\n    ///             - the auction module reverts when settling the auction\n    ///             - collecting the payout from the seller fails\n    ///             - re-entrancy is detected\n    function settle(uint96 lotId_) external override nonReentrant {\n        // Validation\n        _isLotValid(lotId_);\n\n        // Settle the lot on the auction module and get the winning bids\n        // Reverts if the auction cannot be settled yet\n        AuctionModule module = _getModuleForId(lotId_);\n\n        // Store the capacity before settling\n        uint96 capacity = module.remainingCapacity(lotId_);\n\n        // Settle the auction\n        (Auction.Settlement memory settlement, bytes memory auctionOutput) = module.settle(lotId_);\n\n        // Check if the auction settled\n        // If so, calculate fees, handle partial bid, transfer proceeds + (possible) refund to seller, and curator fee\n        if (settlement.totalIn > 0 && settlement.totalOut > 0) {\n            // Load curator data and calculate fee (excluding any refunds of capacity)\n            FeeData storage feeData = lotFees[lotId_];\n\n            // Load routing data for the lot\n            Routing storage routing = lotRouting[lotId_];\n\n            // Store the protocol and referrer fees\n            // If this is not done, the amount that the seller receives could be modified after settlement\n            {\n                Keycode auctionKeycode = keycodeFromVeecode(routing.auctionReference);\n                feeData.protocolFee = fees[auctionKeycode].protocol;\n                feeData.referrerFee = fees[auctionKeycode].referrer;\n            }\n\n            uint96 curatorFeePayout =\n                _calculatePayoutFees(feeData.curated, feeData.curatorFee, capacity);\n\n            // settle() is for batch auctions only, and all batch auctions are prefunded.\n            // Payout has already been collected at the time of auction creation and curation\n\n            // Check if there was a partial fill and handle the payout + refund\n            if (settlement.pfBidder != address(0)) {\n                // Allocate quote and protocol fees for bid\n                _allocateQuoteFees(\n                    feeData.protocolFee,\n                    feeData.referrerFee,\n                    settlement.pfReferrer,\n                    routing.seller,\n                    routing.quoteToken,\n                    // Reconstruct bid amount from the settlement price and the amount out\n                    uint96(\n                        Math.mulDivDown(\n                            settlement.pfPayout, settlement.totalIn, settlement.totalOut\n                        )\n                    )\n                );\n\n                // Reduce funding by the payout amount\n                unchecked {\n                    routing.funding -= uint96(settlement.pfPayout);\n                }\n\n                // Send refund and payout to the bidder\n                Transfer.transfer(\n                    routing.quoteToken, settlement.pfBidder, settlement.pfRefund, false\n                );\n                _sendPayout(settlement.pfBidder, settlement.pfPayout, routing, auctionOutput);\n            }\n\n            // If the lot is under capacity, adjust the curator payout\n            if (settlement.totalOut < capacity && curatorFeePayout > 0) {\n                uint96 capacityRefund;\n                unchecked {\n                    capacityRefund = capacity - settlement.totalOut;\n                }\n\n                uint96 feeRefund =\n                    uint96(Math.mulDivDown(curatorFeePayout, capacityRefund, capacity));\n                // Can't be more than curatorFeePayout\n                unchecked {\n                    curatorFeePayout -= feeRefund;\n                }\n            }\n\n            // Reduce funding by curator fee and send, if applicable\n            if (curatorFeePayout > 0) {\n                unchecked {\n                    routing.funding -= curatorFeePayout;\n                }\n                _sendPayout(feeData.curator, curatorFeePayout, routing, auctionOutput);\n            }\n        }\n\n        // Emit event\n        emit Settle(lotId_);\n    }\n\n    /// @inheritdoc Router\n    /// @dev        This function handles the following:\n    ///             1. Validates the lot\n    ///             2. Sends the proceeds to the seller\n    ///             3. If the auction lot is pre-funded, any unused capacity and curator fees are refunded to the seller\n    ///             4. Calls the onClaimProceeds callback on the hooks contract (if provided)\n    ///\n    ///             This function reverts if:\n    ///             - the lot ID is invalid\n    ///             - the lot is not settled\n    ///             - the proceeds have already been claimed\n    function claimProceeds(\n        uint96 lotId_,\n        bytes calldata callbackData_\n    ) external override nonReentrant {\n        // Validation\n        _isLotValid(lotId_);\n\n        // Call auction module to validate and update data\n        (uint96 purchased_, uint96 sold_, uint96 payoutSent_) =\n            _getModuleForId(lotId_).claimProceeds(lotId_);\n\n        // Load data for the lot\n        Routing storage routing = lotRouting[lotId_];\n\n        // Calculate the referrer and protocol fees for the amount in\n        // Fees are not allocated until the user claims their payout so that we don't have to iterate through them here\n        // If a referrer is not set, that portion of the fee defaults to the protocol\n        uint96 totalInLessFees;\n        {\n            (, uint96 toProtocol) = calculateQuoteFees(\n                lotFees[lotId_].protocolFee, lotFees[lotId_].referrerFee, false, purchased_\n            );\n            unchecked {\n                totalInLessFees = purchased_ - toProtocol;\n            }\n        }\n\n        // Send payment in bulk to the address dictated by the callbacks address\n        // If the callbacks contract is configured to receive quote tokens, send the quote tokens to the callbacks contract and call the onClaimProceeds callback\n        // If not, send the quote tokens to the seller and call the onClaimProceeds callback\n        _sendPayment(routing.seller, totalInLessFees, routing.quoteToken, routing.callbacks);\n\n        // Refund any unused capacity and curator fees to the address dictated by the callbacks address\n        // By this stage, a partial payout (if applicable) and curator fees have been paid, leaving only the payout amount (`totalOut`) remaining.\n        uint96 prefundingRefund = routing.funding + payoutSent_ - sold_;\n        unchecked {\n            routing.funding -= prefundingRefund;\n        }\n        Transfer.transfer(\n            routing.baseToken,\n            _getAddressGivenCallbackBaseTokenFlag(routing.callbacks, routing.seller),\n            prefundingRefund,\n            false\n        );\n\n        // Call the onClaimProceeds callback\n        Callbacks.onClaimProceeds(\n            routing.callbacks, lotId_, totalInLessFees, prefundingRefund, callbackData_\n        );\n    }\n\n    // ========== CURATION ========== //\n\n    /// @notice     Accept curation request for a lot.\n    /// @notice     If the curator wishes to charge a fee, it must be set before this function is called.\n    /// @notice     Access controlled. Must be proposed curator for lot.\n    /// @dev        This function reverts if:\n    ///             - the lot ID is invalid\n    ///             - the caller is not the proposed curator\n    ///             - the auction has ended or been cancelled\n    ///             - the auction is prefunded and the fee cannot be collected\n    ///             - re-entrancy is detected\n    ///\n    /// @param     lotId_       Lot ID\n    function curate(uint96 lotId_, bytes calldata callbackData_) external nonReentrant {\n        _isLotValid(lotId_);\n\n        FeeData storage feeData = lotFees[lotId_];\n\n        // Check that the caller is the proposed curator\n        if (msg.sender != feeData.curator) revert NotPermitted(msg.sender);\n\n        AuctionModule module = _getModuleForId(lotId_);\n\n        // Check that the curator has not already approved the auction\n        // Check that the auction has not ended or been cancelled\n        if (feeData.curated || module.hasEnded(lotId_) == true) revert InvalidState();\n\n        Routing storage routing = lotRouting[lotId_];\n\n        // Set the curator as approved\n        feeData.curated = true;\n        feeData.curatorFee = fees[keycodeFromVeecode(routing.auctionReference)].curator[msg.sender];\n\n        // Calculate the fee amount based on the remaining capacity (must be in base token if auction is pre-funded)\n        uint96 curatorFeePayout = uint96(\n            _calculatePayoutFees(\n                feeData.curated, feeData.curatorFee, module.remainingCapacity(lotId_)\n            )\n        );\n\n        // If the auction is pre-funded (required for batch auctions), transfer the fee amount from the seller\n        if (routing.funding > 0) {\n            // Increment the funding\n            // Cannot overflow, as capacity is bounded by uint96 and the curator fee has a maximum percentage\n            unchecked {\n                routing.funding += curatorFeePayout;\n            }\n\n            // If the callbacks contract is configured to send base tokens, then source the fee from the callbacks contract\n            // Otherwise, transfer from the auction owner\n            if (Callbacks.hasPermission(routing.callbacks, Callbacks.SEND_BASE_TOKENS_FLAG)) {\n                uint256 balanceBefore = routing.baseToken.balanceOf(address(this));\n\n                // The onCurate callback is expected to transfer the base tokens\n                Callbacks.onCurate(routing.callbacks, lotId_, curatorFeePayout, true, callbackData_);\n\n                // Check that the callback transferred the expected amount of base tokens\n                if (routing.baseToken.balanceOf(address(this)) < balanceBefore + curatorFeePayout) {\n                    revert InvalidCallback();\n                }\n            } else {\n                // Don't need to check for fee on transfer here because it was checked on auction creation\n                Transfer.transferFrom(\n                    routing.baseToken, routing.seller, address(this), curatorFeePayout, false\n                );\n\n                // Call the onCurate callback\n                Callbacks.onCurate(\n                    routing.callbacks, lotId_, curatorFeePayout, false, callbackData_\n                );\n            }\n        } else {\n            // If the auction is not pre-funded, call the onCurate callback\n            Callbacks.onCurate(routing.callbacks, lotId_, curatorFeePayout, false, callbackData_);\n        }\n\n        // Emit event that the lot is curated by the proposed curator\n        emit Curated(lotId_, msg.sender);\n    }\n\n    // ========== ADMIN FUNCTIONS ========== //\n\n    /// @inheritdoc FeeManager\n    function setFee(Keycode auctionType_, FeeType type_, uint48 fee_) external override onlyOwner {\n        // Check that the fee is a valid percentage\n        if (fee_ > _FEE_DECIMALS) revert InvalidFee();\n\n        // Set fee based on type\n        // Or a combination of protocol and referrer fee since they are both in the quoteToken?\n        if (type_ == FeeType.Protocol) {\n            fees[auctionType_].protocol = fee_;\n        } else if (type_ == FeeType.Referrer) {\n            fees[auctionType_].referrer = fee_;\n        } else if (type_ == FeeType.MaxCurator) {\n            fees[auctionType_].maxCuratorFee = fee_;\n        }\n    }\n\n    /// @inheritdoc FeeManager\n    function setProtocol(address protocol_) external override onlyOwner {\n        _protocol = protocol_;\n    }\n\n    // ========== TOKEN TRANSFERS ========== //\n\n    /// @notice     Collects payment of the quote token from the user\n    /// @dev        This function handles the following:\n    ///             1. Transfers the quote token from the user\n    ///             1a. Uses Permit2 to transfer if approval signature is provided\n    ///             1b. Otherwise uses a standard ERC20 transfer\n    ///\n    ///             This function reverts if:\n    ///             - The Permit2 approval is invalid\n    ///             - The caller does not have sufficient balance of the quote token\n    ///             - Approval has not been granted to transfer the quote token\n    ///             - The quote token transfer fails\n    ///             - Transferring the quote token would result in a lesser amount being received\n    ///\n    /// @param      amount_             Amount of quoteToken to collect (in native decimals)\n    /// @param      quoteToken_         Quote token to collect\n    /// @param      permit2Approval_    Permit2 approval data (optional)\n    function _collectPayment(\n        uint256 amount_,\n        ERC20 quoteToken_,\n        Transfer.Permit2Approval memory permit2Approval_\n    ) internal {\n        Transfer.permit2OrTransferFrom(\n            quoteToken_, _PERMIT2, msg.sender, address(this), amount_, permit2Approval_, true\n        );\n    }\n\n    /// @notice     Sends payment of the quote token to the seller\n    /// @dev        This function handles the following:\n    ///             1. Sends the payment amount to the seller or hook (if provided)\n    ///             This function assumes:\n    ///             - The quote token has already been transferred to this contract\n    ///             - The quote token is supported (e.g. not fee-on-transfer)\n    ///\n    ///             This function reverts if:\n    ///             - The transfer fails\n    ///\n    /// @param      lotOwner_       Owner of the lot\n    /// @param      amount_         Amount of quoteToken to send (in native decimals)\n    /// @param      quoteToken_     Quote token to send\n    /// @par"
    }
  ]
}