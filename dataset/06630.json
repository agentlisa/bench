{
  "Title": "[M-05] Calculating new rewards is susceptible to precision loss due to division before multiplication",
  "Content": "\nThis issue is similar to <https://github.com/ajna-finance/audits/blob/main/sherlock/Contest1.md#issue-m-7-calculating-new-rewards-is-susceptible-to-precision-loss-due-to-division-before-multiplication> which is not fixed properly. Still, the final multiplication is being performed after the division.\n\n### Impact\n\nRewards may be lost (0) due to division before multiplication precision issues.\n\n### Proof of Concept\n\nThe `RewardsManager._calculateNewRewards` function calculates the new rewards for a staker by first multiplying `interestEarned_` by `totalBurnedInPeriod` and then dividing by `totalInterestEarnedInPeriod` and then again multiplying by `REWARD_FACTOR`.\n\nSince the division is being performed before the final multiplication, this can lead to precision loss.\n\n```solidity\n    function _calculateNewRewards(\n        address ajnaPool_,\n        uint256 interestEarned_,\n        uint256 nextEpoch_,\n        uint256 epoch_,\n        uint256 rewardsClaimedInEpoch_\n    ) internal view returns (uint256 newRewards_) {\n        (\n            ,\n            // total interest accumulated by the pool over the claim period\n            uint256 totalBurnedInPeriod,\n            // total tokens burned over the claim period\n            uint256 totalInterestEarnedInPeriod\n        ) = _getPoolAccumulators(ajnaPool_, nextEpoch_, epoch_);\n\n        // calculate rewards earned \n        newRewards_ = totalInterestEarnedInPeriod == 0 ? 0 : Maths.wmul(\n            REWARD_FACTOR,\n            Maths.wdiv(\n                Maths.wmul(interestEarned_, totalBurnedInPeriod), \n                totalInterestEarnedInPeriod\n            )\n        );\n```\n\n### Recommended Mitigation Steps\n\nAll the multiplication should be performed in step 1 and then division at the end.\n\n**[MikeHathaway (Ajna) confirmed](https://github.com/code-423n4/2023-05-ajna-findings/issues/367#issuecomment-1555143862)**\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-ajna",
  "Code": [
    {
      "filename": "sherlock/Contest1.md",
      "content": "# Issue H-1: RewardsManager doesn't delete old bucket snapshot info on unstaking \n\nSource: https://github.com/sherlock-audit/2023-01-ajna-judging/issues/183 \n\n## Found by \nhyh\n\n## Summary\n\nRewardsManager's unstake() use `delete stakes[tokenId_]` to clear old stake state, but `snapshot` is the nested mapping in the `StakeInfo` structure and will not be reset this way as delete operation do not traverse through nested mappings as it lacks key set information.\n\n## Vulnerability Detail\n\n`stakes[tokenId_]` gets written on staking and `mapping(uint256 => BucketState) snapshot` is written for the *current* list of buckets. This means if this list persists and there were no bucket changes it's ok as new values will be overwritten on next stake.\n\nBut, if Bob the staker has changed his composition of buckets and his second stake takes place over another set, possibly intersecting with the first one, old part will persist. If then Bob's `positionIndexes = positionManager.getPositionIndexes(tokenId_)` changed after the second stake, say as a result of PositionManager's moveLiquidity(), and indices from the first set were added there, their snapshot values from the first stake will be reused.\n\n## Impact\n\nIf Bob knows this it will be straightforward for him to exploit the mechanics, obtaining extra rewards (interest earned will be counted from the first stake time for old positions) at the expense of other stakers.\n\n## Code Snippet\n\nRewardsManager's unstake() deletes `stakes[tokenId_]`:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/RewardsManager.sol#L187-L203\n\n```solidity\n    function unstake(\n        uint256 tokenId_\n    ) external override {\n        if (msg.sender != stakes[tokenId_].owner) revert NotOwnerOfDeposit();\n\n        address ajnaPool = stakes[tokenId_].ajnaPool;\n\n        // claim rewards, if any\n        _claimRewards(tokenId_, IPool(ajnaPool).currentBurnEpoch());\n\n        delete stakes[tokenId_];\n\n        emit Unstake(msg.sender, ajnaPool, tokenId_);\n\n        // transfer LP NFT from contract to sender\n        IERC721(address(positionManager)).safeTransferFrom(address(this), msg.sender, tokenId_);\n    }\n```\n\n`stakes[tokenId_]` is `StakeInfo` structure:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/RewardsManager.sol#L76\n\n```solidity\n    mapping(uint256 => StakeInfo) internal stakes;  // tokenID => Stake info\n```\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/RewardsManager.sol#L21\n\n```solidity\nimport { StakeInfo, BucketState } from './interfaces/rewards/IRewardsManagerState.sol';\n```\n\nIt contains `snapshot` mapping elemewnt that will not be cleared on delete:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/interfaces/rewards/IRewardsManagerState.sol#L56-L62\n\n```solidity\nstruct StakeInfo {\n    address ajnaPool;                         // address of the Ajna pool the NFT corresponds to\n    uint96  lastInteractionBurnEpoch;         // last burn event the stake interacted with the rewards contract\n    address owner;                            // owner of the LP NFT\n    uint96  stakingEpoch;                     // epoch at staking time\n    mapping(uint256 => BucketState) snapshot; // the LP NFT's balances and exchange rates in each bucket at the time of staking\n}\n```\n\nPer operation docs:\n\nhttps://docs.soliditylang.org/en/latest/types.html#delete\n\n`So if you delete a struct, it will reset all members that are not mappings and also recurse into the members unless they are mappings`\n\nThis way restaking the `tokenId_` will reuse the old `snapshot` mapping.\n\n`BucketState` structure consists of `rateAtStakeTime` and `lpsAtStakeTime`:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/interfaces/rewards/IRewardsManagerState.sol#L64-L67\n\n```solidity\nstruct BucketState {\n    uint256 lpsAtStakeTime;  // [RAY] LP amount the NFT owner is entitled in current bucket at the time of staking\n    uint256 rateAtStakeTime; // [RAY] current bucket exchange rate at the time of staking (RAY)\n}\n```\n\nBoth are written on staking, but only for the list of indices as of time of staking:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/RewardsManager.sol#L144-L162\n\n```solidity\n    uint256[] memory positionIndexes = positionManager.getPositionIndexes(tokenId_);\n\n    for (uint256 i = 0; i < positionIndexes.length; ) {\n\n        uint256 bucketId = positionIndexes[i];\n\n        BucketState storage bucketState = stakeInfo.snapshot[bucketId];\n\n        // record the number of lp tokens in bucket at the time of staking\n        bucketState.lpsAtStakeTime = positionManager.getLPTokens(\n            tokenId_,\n            bucketId\n        );\n        // record the bucket exchange rate at the time of staking\n        bucketState.rateAtStakeTime = IPool(ajnaPool).bucketExchangeRate(bucketId);\n\n        // iterations are bounded by array length (which is itself bounded), preventing overflow / underflow\n        unchecked { ++i; }\n    }\n```\n\n`rateAtStakeTime` and `lpsAtStakeTime` are used for the accrued interest calculation in the _calculateNextEpochRewards():\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/RewardsManager.sol#L333-L351\n\n```solidity\n        uint256 bucketRate;\n        if (epoch_ != stakingEpoch_) {\n\n            // if staked in a previous epoch then use the initial exchange rate of epoch\n            bucketRate = bucketExchangeRates[ajnaPool_][bucketIndex][epoch_];\n        } else {\n\n            // if staked during the epoch then use the bucket rate at the time of staking\n            bucketRate = bucketSnapshot.rateAtStakeTime;\n        }\n\n        // calculate the amount of interest accrued in current epoch\n        uint256 interestEarned = _calculateExchangeRateInterestEarned(\n            ajnaPool_,\n            nextEpoch,\n            bucketIndex,\n            bucketSnapshot.lpsAtStakeTime,\n            bucketRate\n        );\n```\n\nThis happens for the current `positionIndexes = positionManager.getPositionIndexes(tokenId_)`:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/RewardsManager.sol#L272-L292\n\n```solidity\n    function _calculateAndClaimRewards(\n        uint256 tokenId_,\n        uint256 epochToClaim_\n    ) internal returns (uint256 rewards_) {\n\n        address ajnaPool      = stakes[tokenId_].ajnaPool;\n        uint256 lastBurnEpoch = stakes[tokenId_].lastInteractionBurnEpoch;\n        uint256 stakingEpoch  = stakes[tokenId_].stakingEpoch;\n\n        uint256[] memory positionIndexes = positionManager.getPositionIndexes(tokenId_);\n\n        // iterate through all burn periods to calculate and claim rewards\n        for (uint256 epoch = lastBurnEpoch; epoch < epochToClaim_; ) {\n\n            uint256 nextEpochRewards = _calculateNextEpochRewards(\n                tokenId_,\n                epoch,\n                stakingEpoch,\n                ajnaPool,\n                positionIndexes\n            );\n```\n\nSay Bob restaked, the `snapshot` persisted. Then if positions changed since the second stake and new indices have been there before (i.e. old ones were *readded*, so they weren't reset on the second stake() as were added later, but their values end up not being void as they were there on the first stake and persisted), then their values will be reused from the first Bob's staking.\n\nThis will expand Bob's interest earned reading:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/RewardsManager.sol#L368-L398\n\n```solidity\n    /**\n     *  @notice Calculate the amount of interest that has accrued to a lender in a bucket based upon their LPs.\n     *  @param  pool_           Address of the pool whose exchange rates are being checked.\n     *  @param  nextEventEpoch_ The next event epoch to check the exchange rate for.\n     *  @param  bucketIndex_    Index of the bucket to check the exchange rate for.\n     *  @param  bucketLPs       Amount of LPs in bucket.\n     *  @param  exchangeRate_   Exchange rate in current epoch.\n     *  @return interestEarned_ The amount of interest accrued.\n     */\n    function _calculateExchangeRateInterestEarned(\n        address pool_,\n        uint256 nextEventEpoch_,\n        uint256 bucketIndex_,\n        uint256 bucketLPs,\n        uint256 exchangeRate_\n    ) internal view returns (uint256 interestEarned_) {\n\n        if (exchangeRate_ != 0) {\n\n            uint256 nextExchangeRate = bucketExchangeRates[pool_][bucketIndex_][nextEventEpoch_];\n\n            // calculate interest earned only if next exchange rate is higher than current exchange rate\n            if (nextExchangeRate > exchangeRate_) {\n\n                // calculate the equivalent amount of quote tokens given the stakes lp balance,\n                // and the exchange rate at the next and current burn events\n                interestEarned_ = Maths.rayToWad(Maths.rmul(nextExchangeRate - exchangeRate_, bucketLPs));\n            }\n\n        }\n    }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIRewardsManagerState.BucketState doesn't contain any nested structures, so `delete bucketState` will reset it fully:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/interfaces/rewards/IRewardsManagerState.sol#L64-L67\n\n```solidity\nstruct BucketState {\n    uint256 lpsAtStakeTime;  // [RAY] LP amount the NFT owner is entitled in current bucket at the time of staking\n    uint256 rateAtStakeTime; // [RAY] current bucket exchange rate at the time of staking (RAY)\n}\n```\n\nConsider clearing the current stake snapshots on unstaking, for example:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/RewardsManager.sol#L187-L203\n\n```solidity\n    function unstake(\n        uint256 tokenId_\n    ) external override {\n        if (msg.sender != stakes[tokenId_].owner) revert NotOwnerOfDeposit();\n\n        address ajnaPool = stakes[tokenId_].ajnaPool;\n\n        // claim rewards, if any\n        _claimRewards(tokenId_, IPool(ajnaPool).currentBurnEpoch());\n\n+       uint256[] memory positionIndexes = positionManager.getPositionIndexes(tokenId_);\n+       for (uint256 i = 0; i < positionIndexes.length; ) {\n+           delete stakeInfo.snapshot[positionIndexes[i]]; // BucketState\n+           unchecked { ++i; }\n+       }\n        delete stakes[tokenId_];\n\n        emit Unstake(msg.sender, ajnaPool, tokenId_);\n\n        // transfer LP NFT from contract to sender\n        IERC721(address(positionManager)).safeTransferFrom(address(this), msg.sender, tokenId_);\n    }\n```\n\n\n\n# Issue H-2: Anyone who approved quote tokens to a pool can be forced to take \n\nSource: https://github.com/sherlock-audit/2023-01-ajna-judging/issues/145 \n\n## Found by \nJeiwan\n\n## Summary\nTaking may be executed on behalf of any address who approved spending of quote tokens to a pool: such address will pay quote tokens and will receive collateral.\n## Vulnerability Detail\n[ERC20Pool](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/ERC20Pool.sol#L403) and [ERC721Pool](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/ERC721Pool.sol#L405) implement the `take` functions, which buy collateral from auction in exchange for quote tokens. The address to pull quote tokens from is specified in the `callee_` argument, which allows anyone to call the functions and pass an address that has previously approved spending of the quote token to the pool. As a result, such an address will pay for the liquidation and will receive the collateral.\n## Impact\nAnyone can initiate a take on behalf of another user. Such user can be a lender who has previously approved spending of the quote token to the pool. Calling `take` with the user's address specified as the `callee_` argument will result in:\n1. the user [receiving collateral](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/ERC20Pool.sol#L450), which may have low value;\n1. the user [paying the quote token](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/ERC20Pool.sol#L460) to repay the debt being taken.\n## Code Snippet\n[ERC20Pool.sol#L460](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/ERC20Pool.sol#L460)\n[ERC721Pool.sol#L463](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/ERC721Pool.sol#L463)\n## Tool used\nManual Review\n## Recommendation\nIn the `ERC20Pool.take` and `ERC721Pool.take` functions, consider transferring collateral only from `msg.sender`. Alternatively, consider checking that `callee_` has approved spending quote tokens to `msg.sender`.\n\n# Issue H-3: CryptoPunks NFTs may be stolen via deposit frontrunning \n\nSource: https://github.com/sherlock-audit/2023-01-ajna-judging/issues/140 \n\n## Found by \nJeiwan\n\n## Summary\nDepositing of CryptoPunks NFTs may be front run, a malicious actor may deposit someone else's CryptoPunks NFT.\n## Vulnerability Detail\nDue to the CryptoPunks NFT collection not implementing the ERC721 standard, depositing of CryptoPunks NFTs is implemented via a direct sale:\n1. token owner needs to call [offerPunkForSaleToAddress](https://etherscan.io/address/0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb#code) and set the `toAddress` value to the address of the pool the token will be deposited to;\n1. token owner then calls the [addCollateral](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/ERC721Pool.sol#L251) function of the ERC721 pool;\n1. the pool [buys the token](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/ERC721Pool.sol#L577) from its owner.\n\nHowever, `addCollateral` can be called by anyone: the pool will buy the token and will deposit it on the caller's account even if the caller is not the owner of the token.\n## Impact\nCryptoPunks NFTs owner may lose their NFTs when trying to deposit them to an ERC721 pool. A malicious actor may front run the depositing and deposit the NFTs to their account. The malicious actor may then withdraw the NFTs.\n## Code Snippet\n[ERC721Pool.sol#L577](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/ERC721Pool.sol#L577)\n[CryptoPunksMarket](https://etherscan.io/address/0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb#code):\n```solidity\nfunction offerPunkForSaleToAddress(uint punkIndex, uint minSalePriceInWei, address toAddress) {\n    if (!allPunksAssigned) throw;\n    if (punkIndexToAddress[punkIndex] != msg.sender) throw;\n    if (punkIndex >= 10000) throw;\n    punksOfferedForSale[punkIndex] = Offer(true, punkIndex, msg.sender, minSalePriceInWei, toAddress);\n    PunkOffered(punkIndex, minSalePriceInWei, toAddress);\n}\n\nfunction buyPunk(uint punkIndex) payable {\n    if (!allPunksAssigned) throw;\n    Offer offer = punksOfferedForSale[punkIndex];\n    if (punkIndex >= 10000) throw;\n    if (!offer.isForSale) throw;                // punk not actually for sale\n    if (offer.onlySellTo != 0x0 && offer.onlySellTo != msg.sender) throw;  // punk not supposed to be sold to this user\n    if (msg.value < offer.minValue) throw;      // Didn't send enough ETH\n    if (offer.seller != punkIndexToAddress[punkIndex]) throw; // Seller no longer owner of punk\n\n    address seller = offer.seller;\n\n    punkIndexToAddress[punkIndex] = msg.sender;\n    balanceOf[seller]--;\n    balanceOf[msg.sender]++;\n    Transfer(seller, msg.sender, 1);\n\n    punkNoLongerForSale(punkIndex);\n    pendingWithdrawals[seller] += msg.value;\n    PunkBought(punkIndex, msg.value, seller, msg.sender);\n\n    // Check for the case where there is a bid from the new owner and refund it.\n    // Any other bid can stay in place.\n    Bid bid = punkBids[punkIndex];\n    if (bid.bidder == msg.sender) {\n        // Kill bid and refund value\n        pendingWithdrawals[msg.sender] += bid.value;\n        punkBids[punkIndex] = Bid(false, punkIndex, 0x0, 0);\n    }\n}\n```\n## Tool used\nManual Review\n## Recommendation\nBefore buying a CryptoPunks NFT, consider checking that `msg.sender` is the owner of the token. For example:\n```diff\ndiff --git a/contracts/src/ERC721Pool.sol b/contracts/src/ERC721Pool.sol\nindex b1bf36b..a512a9d 100644\n--- a/contracts/src/ERC721Pool.sol\n+++ b/contracts/src/ERC721Pool.sol\n@@ -574,6 +574,7 @@ contract ERC721Pool is FlashloanablePool, IERC721Pool {\n                 ICryptoKitties(_getArgAddress(COLLATERAL_ADDRESS)).transferFrom(msg.sender ,address(this), tokenId);\n             }\n             else{\n+                require(ICryptoPunks(_getArgAddress(COLLATERAL_ADDRESS)).punkIndexToAddress(tokenId) == msg.sender);\n                 ICryptoPunks(_getArgAddress(COLLATERAL_ADDRESS)).buyPunk(tokenId);\n             }\n\n```\n\n## Discussion\n\n**grandizzy**\n\nwill fix with the fix for https://github.com/sherlock-audit/2023-01-ajna-judging/issues/163\n\n\n\n# Issue H-4: scaledQuoteTokenAmount isn't updated to be collateral sell value in the quote token constraint case of _calculateTakeFlowsAndBondChange \n\nSource: https://github.com/sherlock-audit/2023-01-ajna-judging/issues/139 \n\n## Found by \nhyh\n\n## Summary\n\n`scaledQuoteTokenAmount` isn't `C * p`, but `C * p * (1 - BFP)` for quote token amount constraint case of _calculateTakeFlowsAndBondChange().\n\n## Vulnerability Detail\n\nFirst case of the _calculateTakeFlowsAndBondChange() logic needs to use `scaledQuoteTokenAmount` in two steps, first as a constraint, then as a total collateral value. The second update is now missed. It affects kicker's reward as the difference takes place when `borrowerPrice < auctionPrice`, i.e. when `vars.isRewarded` is true.\n\n## Impact\n\n`scaledQuoteTokenAmount` is then used for kicker's bond change calculation, so in the quote token constraint case kickers will have the reward based on `C * p * (1 - BFP)`. As this value is proportional to `BFP`, the higher the reward should be, the more incorrect it will be, i.e. `(1 - BFP) * BFP` instead of `BFP`.\n\nAs this is regular functionality, there is no low probability prerequisites, and kicker's reward loss is material, setting the severity to be high.\n\n## Code Snippet\n\n_calculateTakeFlowsAndBondChange() has first logic branch where quote token used to purchase is a constraint:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/external/Auctions.sol#L1139-L1149\n\n```solidity\n        vars.scaledQuoteTokenAmount = (vars.unscaledDeposit != type(uint256).max) ? Maths.wmul(vars.unscaledDeposit, vars.bucketScale) : type(uint256).max;\n\n        uint256 borrowerCollateralValue = Maths.wmul(totalCollateral_, borrowerPrice);\n        \n        if (vars.scaledQuoteTokenAmount <= vars.borrowerDebt && vars.scaledQuoteTokenAmount <= borrowerCollateralValue) {\n            // quote token used to purchase is constraining factor\n            vars.collateralAmount         = _roundToScale(Maths.wdiv(vars.scaledQuoteTokenAmount, borrowerPrice), collateralScale_);\n            vars.t0RepayAmount            = Maths.wdiv(vars.scaledQuoteTokenAmount, inflator_);\n            vars.unscaledQuoteTokenAmount = vars.unscaledDeposit;\n\n        }\n```\n\n`vars.scaledQuoteTokenAmount` is used for the `bondChange` calculation and per documentation has to be equal to `C * p`:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/external/Auctions.sol#L1166-L1172\n\n```solidity\n        if (vars.isRewarded) {\n            // take is above neutralPrice, Kicker is rewarded\n            vars.bondChange = Maths.wmul(vars.scaledQuoteTokenAmount, uint256(vars.bpf));\n        } else {\n            // take is above neutralPrice, Kicker is penalized\n            vars.bondChange = Maths.wmul(vars.scaledQuoteTokenAmount, uint256(-vars.bpf));\n        }\n```\n\nAnd it is `vars.scaledQuoteTokenAmount = CollateralAmount * Price` in 2nd and 3rd cases, not not in 1st:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/external/Auctions.sol#L1124-L1175\n\n```solidity\n    function _calculateTakeFlowsAndBondChange(\n        uint256              totalCollateral_,\n        uint256              inflator_,\n        uint256              collateralScale_,\n        TakeLocalVars memory vars\n    ) internal pure returns (\n        TakeLocalVars memory\n    ) {\n        // price is the current auction price, which is the price paid by the LENDER for collateral\n        // from the borrower point of view, the price is actually (1-bpf) * price, as the rewards to the\n        // bond holder are effectively paid for by the borrower.\n        uint256 borrowerPayoffFactor = (vars.isRewarded) ? Maths.WAD - uint256(vars.bpf)                       : Maths.WAD;\n        uint256 borrowerPrice        = (vars.isRewarded) ? Maths.wmul(borrowerPayoffFactor, vars.auctionPrice) : vars.auctionPrice;\n\n        // If there is no unscaled quote token bound, then we pass in max, but that cannot be scaled without an overflow.  So we check in the line below.\n        vars.scaledQuoteTokenAmount = (vars.unscaledDeposit != type(uint256).max) ? Maths.wmul(vars.unscaledDeposit, vars.bucketScale) : type(uint256).max;\n\n        uint256 borrowerCollateralValue = Maths.wmul(totalCollateral_, borrowerPrice);\n        \n        if (vars.scaledQuoteTokenAmount <= vars.borrowerDebt && vars.scaledQuoteTokenAmount <= borrowerCollateralValue) {\n            // quote token used to purchase is constraining factor\n            vars.collateralAmount         = _roundToScale(Maths.wdiv(vars.scaledQuoteTokenAmount, borrowerPrice), collateralScale_);\n            vars.t0RepayAmount            = Maths.wdiv(vars.scaledQuoteTokenAmount, inflator_);\n            vars.unscaledQuoteTokenAmount = vars.unscaledDeposit;\n\n        } else if (vars.borrowerDebt <= borrowerCollateralValue) {\n            // borrower debt is constraining factor\n            vars.collateralAmount         = _roundToScale(Maths.wdiv(vars.borrowerDebt, borrowerPrice), collateralScale_);\n            vars.t0RepayAmount            = vars.t0Debt;\n            vars.unscaledQuoteTokenAmount = Maths.wdiv(vars.borrowerDebt, vars.bucketScale);\n\n            vars.scaledQuoteTokenAmount   = (vars.isRewarded) ? Maths.wdiv(vars.borrowerDebt, borrowerPayoffFactor) : vars.borrowerDebt;\n\n        } else {\n            // collateral available is constraint\n            vars.collateralAmount         = totalCollateral_;\n            vars.t0RepayAmount            = Maths.wdiv(borrowerCollateralValue, inflator_);\n            vars.unscaledQuoteTokenAmount = Maths.wdiv(borrowerCollateralValue, vars.bucketScale);\n\n            vars.scaledQuoteTokenAmount   = Maths.wmul(vars.collateralAmount, vars.auctionPrice);\n        }\n\n        if (vars.isRewarded) {\n            // take is above neutralPrice, Kicker is rewarded\n            vars.bondChange = Maths.wmul(vars.scaledQuoteTokenAmount, uint256(vars.bpf));\n        } else {\n            // take is above neutralPrice, Kicker is penalized\n            vars.bondChange = Maths.wmul(vars.scaledQuoteTokenAmount, uint256(-vars.bpf));\n        }\n\n        return vars;\n    }\n```\n\n`vars.scaledQuoteTokenAmount` in the first case has dual role, at first it is a constraint, then it is `C * p` computation base value, so it is to be used iteratively, first as a constraint, then updated to be `CollateralAmount * Price`.\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider setting the `scaledQuoteTokenAmount` to the `C * p` as a final step of quote token amount constraint case:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/external/Auctions.sol#L1139-L1149\n\n```solidity\n        vars.scaledQuoteTokenAmount = (vars.unscaledDeposit != type(uint256).max) ? Maths.wmul(vars.unscaledDeposit, vars.bucketScale) : type(uint256).max;\n\n        uint256 borrowerCollateralValue = Maths.wmul(totalCollateral_, borrowerPrice);\n        \n        if (vars.scaledQuoteTokenAmount <= vars.borrowerDebt && vars.scaledQuoteTokenAmount <= borrowerCollateralValue) {\n            // quote token used to purchase is constraining factor\n            vars.collateralAmount         = _roundToScale(Maths.wdiv(vars.scaledQuoteTokenAmount, borrowerPrice), collateralScale_);\n            vars.t0RepayAmount            = Maths.wdiv(vars.scaledQuoteTokenAmount, inflator_);\n            vars.unscaledQuoteTokenAmount = vars.unscaledDeposit;\n+           vars.scaledQuoteTokenAmount   = Maths.wmul(vars.collateralAmount, vars.auctionPrice);\n        }\n```\n\n# Issue H-5: removeCollateral miss bankrupcy logic and can make future LPs sharing losses with the current ones \n\nSource: https://github.com/sherlock-audit/2023-01-ajna-judging/issues/133 \n\n## Found by \nhyh, Jeiwan, yixxas\n\n## Summary\n\nLenderActions' removeCollateral() do not checks for bucket solvency after it has removed a collateral from there. This can lead to losses for future depositors of the bucket.\n\n## Vulnerability Detail\n\nBankrupcy check logic now exist in all asset removing functions. That prevent a situation when a bucket defaults, but next LP deposit makes in solvent again and next LP shared losses with the old ones this way without having such intent.\n\nFor example, mergeOrRemoveCollateral() calls _removeMaxCollateral() that do check affected bucket for bankrupcy. removeCollateral() do not check for that despite insolvency situation for a bucket can occur after collateral was removed.\n\n## Impact\n\nWhen bucket defaults, but no bankrupcy is checked and no such flag is set, the next LP depositors have to bail out previous, i.e. have to share their losses.\n\nThat's a loss for next LPs by unconditional transfer from them to the previous ones.\n\nAs removeCollateral() is a part of base functionality that to be used frequently and bucket defaults can routinely happen, so there is no low probability prerequisites, and given the loss for future bucket depositors, setting the severity to be high.\n\n## Code Snippet\n\nThere is no bucket bankrupcy logic in removeCollateral(), i.e. when there is no quote tokens in the bucket, `lpAmount_ < bucketLPs`, but `bucketCollateral <= collateralAmount_`, bucket de facto defaults, but no such flag is set:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/external/LenderActions.sol#L379-L414\n\n```solidity\n    function removeCollateral(\n        ...\n    ) external returns (uint256 lpAmount_) {\n        ...\n\n        Lender storage lender = bucket.lenders[msg.sender];\n\n        uint256 lenderLpBalance;\n        if (bucket.bankruptcyTime < lender.depositTime) lenderLpBalance = lender.lps;\n        if (lenderLpBalance == 0 || lpAmount_ > lenderLpBalance) revert InsufficientLPs();\n\n        // update lender LPs balance\n        lender.lps -= lpAmount_;\n\n        // update bucket LPs and collateral balance\n        bucket.lps        -= Maths.min(bucketLPs, lpAmount_);\n        bucket.collateral -= Maths.min(bucketCollateral, amount_);\n    }\n```\n\nThe check is present in _removeMaxCollateral():\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/external/LenderActions.sol#L619-L630\n\n```solidity\n        // update bucket LPs and collateral balance\n        bucketLPs         -= Maths.min(bucketLPs, lpAmount_);\n        bucketCollateral  -= Maths.min(bucketCollateral, collateralAmount_);\n        bucket.collateral  = bucketCollateral;\n        if (bucketCollateral == 0 && bucketDeposit == 0 && bucketLPs != 0) {\n            emit BucketBankruptcy(index_, bucketLPs);\n            bucket.lps            = 0;\n            bucket.bankruptcyTime = block.timestamp;\n        } else {\n            bucket.lps = bucketLPs;\n        }\n    }\n```\n\nAnd removeQuoteToken():\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/external/LenderActions.sol#L310-L368\n\n```solidity\n    function removeQuoteToken(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        PoolState calldata poolState_,\n        RemoveQuoteParams calldata params_\n    ) external returns (uint256 removedAmount_, uint256 redeemedLPs_, uint256 lup_) {\n        ...\n\n        // update lender and bucket LPs balances\n        lender.lps -= redeemedLPs_;\n\n        uint256 lpsRemaining = removeParams.bucketLPs - redeemedLPs_;\n\n        if (removeParams.bucketCollateral == 0 && unscaledRemaining == 0 && lpsRemaining != 0) {\n            emit BucketBankruptcy(params_.index, lpsRemaining);\n            bucket.lps            = 0;\n            bucket.bankruptcyTime = block.timestamp;\n        } else {\n            bucket.lps = lpsRemaining;\n        }\n\n        emit RemoveQuoteToken(msg.sender, params_.index, removedAmount_, redeemedLPs_, lup_);\n    }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adding the bankruptcy check similarly to other asset removal functions:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/external/LenderActions.sol#L379-L414\n\n```solidity\n    function removeCollateral(\n        ...\n    ) external returns (uint256 lpAmount_) {\n        ...\n\n        Lender storage lender = bucket.lenders[msg.sender];\n\n        uint256 lenderLpBalance;\n        if (bucket.bankruptcyTime < lender.depositTime) lenderLpBalance = lender.lps;\n        if (lenderLpBalance == 0 || lpAmount_ > lenderLpBalance) revert InsufficientLPs();\n\n        // update lender LPs balance\n        lender.lps -= lpAmount_;\n\n        // update bucket LPs and collateral balance\n-       bucket.lps        -= Maths.min(bucketLPs, lpAmount_);\n-       bucket.collateral -= Maths.min(bucketCollateral, amount_);\n+       uint256 bucketLPs = bucket.lps - Maths.min(bucketLPs, lpAmount_);\n+       uint256 bucketCollateral = bucket.collateral - Maths.min(bucketCollateral, amount_);\n+       uint256 bucketDeposit = Deposits.valueAt(deposits_, index_);\n\n+       if (bucketCollateral == 0 && bucketDeposit == 0 && bucketLPs != 0) {\n+           emit BucketBankruptcy(index_, bucketLPs);\n+           bucket.lps = 0;\n+           bucket.bankruptcyTime = block.timestamp;\n+       } else {\n+           bucket.lps = bucketLPs;\n+       }\n+       bucket.collateral = bucketCollateral;\n+   }\n```\n\n# Issue H-6: Executing funded standard proposals can be prevented by a proposal slate with duplicate proposals \n\nSource: https://github.com/sherlock-audit/2023-01-ajna-judging/issues/119 \n\n## Found by \nberndartmueller\n\n## Summary\n\nAnyone can propose a slate of standard proposals to be funded in a distribution period with the `StandardFunding.checkSlate` function. The proposal slate can contain duplicate proposal ids, which, if the slate is the top slate, can be used to prevent a standard proposal from being executed (funded).\n\n## Vulnerability Detail\n\nA funded standard proposal is executed by calling the `StandardFunding.executeStandard` function. A proposal is considered successfully funded if its state returned by the `GrantFund.state` function is `IGovernor.ProposalState.Succeeded`. This is the case if `StandardFunding._standardFundingVoteSucceeded` returns `true`.\n\n`StandardFunding._standardFundingVoteSucceeded` checks if the given proposal id is included in the currently funded proposal slate.\n\nHowever, as mentioned in the beginning, the proposal slate can contain duplicate proposal ids. A slate can therefore be maximized (in regard to the allocated budget) with the same proposal id. Worst case, this \"malicious\" slate can not be replaced with a correct slate, as the allocated budget of a correct slate can not exceed the allocated budget of the malicious slate.\n\nIn this case, the `StandardFunding.executeStandard` function will not execute the proposal, which is not included in the \"malicious\" proposal slate.\n\n## Impact\n\nStandard proposals can be prevented from being funded in a distribution period.\n\n## Code Snippet\n\n[ecosystem-coordination/src/grants/base/StandardFunding.sol#L198-L219](https://github.com/sherlock-audit/2023-01-ajna/blob/main/ecosystem-coordination/src/grants/base/StandardFunding.sol#L198-L219)\n\n```solidity\n198: for (uint i = 0; i < proposalIds_.length; ) {\n199:     // check if Proposal is in the topTenProposals list\n200:     if (_findProposalIndex(proposalIds_[i], topTenProposals[distributionId_]) == -1) return false;\n201:\n202:     Proposal memory proposal = standardFundingProposals[proposalIds_[i]];\n203:\n204:     // account for qvBudgetAllocated possibly being negative\n205:     if (proposal.qvBudgetAllocated < 0) return false;\n206:\n207:     // update counters\n208:     sum += uint256(proposal.qvBudgetAllocated);\n209:     totalTokensRequested += proposal.tokensRequested;\n210:\n211:     // check if slate of proposals exceeded budget constraint ( 90% of GBC )\n212:     if (totalTokensRequested > (gbc * 9 / 10)) {\n213:         return false;\n214:     }\n215:\n216:     unchecked {\n217:         ++i;\n218:     }\n219: }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider checking for duplicate proposal ids in the `checkSlate` function.\n\n# Issue H-7: ERC721Pool's mergeOrRemoveCollateral allows to remove"
    }
  ]
}