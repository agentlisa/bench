{
  "Title": "H-1: An attacker can gain an inflated amount of Sherlock shares by staking when TrueFiPool2 pool has its value temporary reduced during loan closure",
  "Content": "# Issue H-1: An attacker can gain an inflated amount of Sherlock shares by staking when TrueFiPool2 pool has its value temporary reduced during loan closure \n\nSource: https://github.com/sherlock-audit/2022-09-sherlock-judging/tree/main/018-H \n\n## Found by \nhyh\n\n## Summary\n\nSherlock's initial staking can be performed while TrueFiStrategy balance is reduced with TrueFi's FixedTermLoanAgency loan token reclaim call. This is possible as the 1inch fee swapping call with user-supplied parameters is performed when the system is in the reduced pool value state, while FixedTermLoanAgency's reclaim() has no access controls, and the functions involved allow reentrancy. The net result is an artificially increased number of Sherlock shares being issued to the attacker. \n\n## Vulnerability Detail\n\nTrueFiStrategy balance is based on TrueFiPool2 poolValue(), which drops on FixedTermLoanAgency loan reclaiming as the loan token is being removed from the active tokens array. Right after that and before reclaimed tokens end up on the TrueFiPool2 balance, the 1inch call is performed aimed to swap the corresponding fees.\n\nFixedTermLoanAgency's reclaim() is permissionless, 1inch call uses user supplied parameters, so an attacker can supply a pre-cooked contract instead of DEX pool, which does the swap, so all the corresponding checks pass, i.e. proper amount of tokens needed are placed on the target balance, but also performs initial Sherlock staking, which issues inflated number of the shares for the attacker as TrueFiPool2 poolValue() is reduced during this call by the value of the loan being closed. Right after that the reclaimed token less fees are transferred to the TrueFiPool2 balance, so TrueFiStrategy _balanceOf() display the full value, and the attacker's shares are priced with a premium compared to her investment. This premium is proportional to the value of the closed loan, and is effectively stolen from all other stakers.\n\n## Impact\n\nAs a result of increased issuance of the shares, the attacker will steal from the all other stakers proportionally to the size of a loan she be able to run reclaim for.\n\n## Code Snippet\n    \nThe call sequence is: `FixedTermLoanAgency.reclaim() -> _redeemAndRepay() -> _swapFee() -> OneInchExchange.exchange() -> AggregationRouterV4.swap()`.\n\nFixedTermLoanAgency's reclaim() removes the loan token and calls _redeemAndRepay():\n\nhttps://github.com/trusttoken/contracts-pre22/blob/986fefb91fb0619217d17ecf0b4c5b7b921130ed/contracts/truefi2/FixedTermLoanAgency.sol#L384-L407\n\n```solidity\n    function reclaim(IFixedTermLoan loanToken, bytes calldata data) external {\n        IFixedTermLoan.Status status = loanToken.status();\n        require(\n            status == IFixedTermLoan.Status.Settled || status == IFixedTermLoan.Status.Defaulted,\n            \"FixedTermLoanAgency: LoanToken is not closed yet\"\n        );\n        if (status == IFixedTermLoan.Status.Defaulted) {\n            require(msg.sender == owner(), \"FixedTermLoanAgency: Only owner can reclaim from defaulted loan\");\n        }\n\n        // find the token, repay loan and remove loan from loan array\n        ITrueFiPool2 pool = loanToken.pool();\n        IFixedTermLoan[] storage _loans = poolLoans[pool];\n        uint256 loansLength = _loans.length;\n        for (uint256 index = 0; index < loansLength; index++) {\n            if (_loans[index] == loanToken) {\n                _loans[index] = _loans[loansLength - 1];\n                _loans.pop();\n\n                uint256 fundsReclaimed = _redeemAndRepay(loanToken, pool, data);\n                emit Reclaimed(address(pool), address(loanToken), fundsReclaimed);\n                return;\n            }\n        }\n```\n\nAt that moment FixedTermLoanAgency's value() drops by the currentValue() of the removed loan token, let's denote it `loan_value = loanToken.currentValue(address(ftlAgency))`:\n\nhttps://github.com/trusttoken/contracts-pre22/blob/986fefb91fb0619217d17ecf0b4c5b7b921130ed/contracts/truefi2/FixedTermLoanAgency.sol#L371-L378\n\n```solidity\n    function value(ITrueFiPool2 pool) external view override returns (uint256) {\n        IFixedTermLoan[] memory _loans = poolLoans[pool];\n        uint256 totalValue;\n        for (uint256 index = 0; index < _loans.length; index++) {\n            totalValue = totalValue.add(_loans[index].currentValue(address(this)));\n        }\n        return totalValue;\n    }\n```\n\nWhich means TrueFiPool2's loansValue() and poolValue() drop by the same `loan_value`:\n\nhttps://github.com/trusttoken/contracts-pre22/blob/986fefb91fb0619217d17ecf0b4c5b7b921130ed/contracts/truefi2/TrueFiPool2.sol#L419-L428\n\n```solidity\n    function loansValue() public view returns (uint256) {\n        if (inSync) {\n            return loansValueCache;\n        }\n        uint256 lenderLoansValue = 0;\n        if (address(lender) != address(0)) {\n            lenderLoansValue = lender.value(this);\n        }\n        return lenderLoansValue.add(ftlAgency.value(this));\n    }\n```\n\nhttps://github.com/trusttoken/contracts-pre22/blob/986fefb91fb0619217d17ecf0b4c5b7b921130ed/contracts/truefi2/TrueFiPool2.sol#L382-L390\n\n```solidity\n    /**\n     * @dev Calculate pool value in underlying token\n     * \"virtual price\" of entire pool - LoanTokens, UnderlyingTokens, strategy value\n     * @return pool value denominated in underlying token\n     */\n    function poolValue() public view override returns (uint256) {\n        // this assumes defaulted loans are worth their full value\n        return liquidValue().add(loansValue()).add(deficitValue()).add(creditValue()).add(debtValue);\n    }\n```\n\n_redeemAndRepay() first calls _swapFee(), and only then repays the `fundsReclaimed.sub(feeAmount)` to the pool, reimbursing the token removal skew:\n\nhttps://github.com/trusttoken/contracts-pre22/blob/986fefb91fb0619217d17ecf0b4c5b7b921130ed/contracts/truefi2/FixedTermLoanAgency.sol#L455-L475\n\n```solidity\n    function _redeemAndRepay(\n        IFixedTermLoan loanToken,\n        ITrueFiPool2 pool,\n        bytes calldata data\n    ) internal returns (uint256) {\n        // call redeem function on LoanToken\n        uint256 balanceBefore = pool.token().balanceOf(address(this));\n        loanToken.redeem();\n        uint256 balanceAfter = pool.token().balanceOf(address(this));\n\n        // gets reclaimed amount and pays back to pool\n        uint256 fundsReclaimed = balanceAfter.sub(balanceBefore);\n\n        uint256 feeAmount;\n        if (address(feeToken) != address(0)) {\n            // swap fee for feeToken\n            feeAmount = _swapFee(pool, loanToken, data);\n        }\n\n        pool.token().safeApprove(address(pool), fundsReclaimed.sub(feeAmount));\n        pool.repay(fundsReclaimed.sub(feeAmount));\n```\n\nThis way when _swapFee() is called the TrueFiPool2's poolValue() is still reduced by `loan_value`.\n\nThis allows Megan the attacker to enter Sherlock's pool at a depressed valuation.\n\nNotice, that _swapFee() and all the previous function calls just redirect user-supplied `data`, that is finally passed to the 1inch's exchange():\n\nhttps://github.com/trusttoken/contracts-pre22/blob/986fefb91fb0619217d17ecf0b4c5b7b921130ed/contracts/truefi2/FixedTermLoanAgency.sol#L484-L511\n\n```solidity\n    /// @dev Swap `token` for `feeToken` on 1inch\n    function _swapFee(\n        ITrueFiPool2 pool,\n        IFixedTermLoan loanToken,\n        bytes calldata data\n    ) internal returns (uint256) {\n        uint256 feeAmount = loanToken.interest().mul(fee).div(BASIS_RATIO);\n        IERC20WithDecimals token = IERC20WithDecimals(address(pool.token()));\n        if (token == feeToken) {\n            return feeAmount;\n        }\n        if (feeAmount == 0) {\n            return 0;\n        }\n        (I1Inch3.SwapDescription memory swap, uint256 balanceDiff) = _1inch.exchange(data);\n        uint256 expectedDiff = pool.oracle().tokenToUsd(feeAmount).mul(uint256(10)**feeToken.decimals()).div(1 ether);\n\n        require(swap.srcToken == address(token), \"FixedTermLoanAgency: Source token is not same as pool's token\");\n        require(swap.dstToken == address(feeToken), \"FixedTermLoanAgency: Destination token is not fee token\");\n        require(swap.dstReceiver == address(this), \"FixedTermLoanAgency: Receiver is not agency\");\n        require(swap.amount == feeAmount, \"FixedTermLoanAgency: Incorrect fee swap amount\");\n        require(swap.flags & ONE_INCH_PARTIAL_FILL_FLAG == 0, \"FixedTermLoanAgency: Partial fill is not allowed\");\n        require(\n            balanceDiff >= expectedDiff.mul(BASIS_RATIO.sub(swapFeeSlippage)).div(BASIS_RATIO),\n            \"FixedTermLoanAgency: Fee returned from swap is too small\"\n        );\n\n        return feeAmount;\n```\n\nOneInchExchange's exchange() uses user supplied `data`, filling the basic swap description from it.\n\n_swapFee() then verify tokens, amounts and receiving address from the filled swap structure.\n\nHowever, `data` also contains the route, whom to call with what parameters to perform the swap, which is passed to `_1inchExchange`:\n\nhttps://github.com/trusttoken/contracts-pre22/blob/986fefb91fb0619217d17ecf0b4c5b7b921130ed/contracts/truefi2/libraries/OneInchExchange.sol#L34-L70\n\n```solidity\n    function exchange(I1Inch3 _1inchExchange, bytes calldata data)\n        internal\n        returns (I1Inch3.SwapDescription memory description, uint256 returnedAmount)\n    {\n        if (data[0] == 0x7c) {\n            // call `swap()`\n            (, description, ) = abi.decode(data[4:], (address, I1Inch3.SwapDescription, bytes));\n        } else {\n            // call `unoswap()`\n            (address srcToken, uint256 amount, uint256 minReturn, bytes32[] memory pathData) = abi.decode(\n                data[4:],\n                (address, uint256, uint256, bytes32[])\n            );\n            description.srcToken = srcToken;\n            description.amount = amount;\n            description.minReturnAmount = minReturn;\n            description.flags = 0;\n            uint256 lastPath = uint256(pathData[pathData.length - 1]);\n            IUniRouter uniRouter = IUniRouter(address(lastPath & ADDRESS_MASK));\n            bool isReverse = lastPath & REVERSE_MASK > 0;\n            description.dstToken = isReverse ? uniRouter.token0() : uniRouter.token1();\n            description.dstReceiver = address(this);\n        }\n\n        IERC20(description.srcToken).safeApprove(address(_1inchExchange), description.amount);\n        uint256 balanceBefore = IERC20(description.dstToken).balanceOf(description.dstReceiver);\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = address(_1inchExchange).call(data);\n        if (!success) {\n            // Revert with original error message\n            assembly {\n                let ptr := mload(0x40)\n                let size := returndatasize()\n                returndatacopy(ptr, 0, size)\n                revert(ptr, size)\n            }\n        }\n```\n\nFor 1inch the `data` above contains not only swap description, but `calls` array (also named `data` in the docs), which is used by 1inch as is to perform the swapping, i.e. 1inch calls the supplied addresses with the supplied parameters, only checking the destination address has received the required number of output tokens:\n\nhttps://docs.1inch.io/docs/aggregation-protocol/smart-contract/AggregationRouterV4#swap\n\n```solidity\nfunction swap(\n  contract IAggregationExecutor caller,\n  struct AggregationRouterV4.SwapDescription desc,\n  bytes data\n) external returns (uint256 returnAmount, uint256 gasLeft)\n```\n\nhttps://github.com/1inch/1inch-v2-contracts/blob/master/contracts/OneInchExchange.sol#L92-L127\n\n```solidity\n    function swap(\n        IOneInchCaller caller,\n        SwapDescription calldata desc,\n        IOneInchCaller.CallDescription[] calldata calls\n    )\n        external\n        payable\n        whenNotPaused\n        returns (uint256 returnAmount)\n    {\n        require(desc.minReturnAmount > 0, \"Min return should not be 0\");\n        require(calls.length > 0, \"Call data should exist\");\n\n        uint256 flags = desc.flags;\n        IERC20 srcToken = desc.srcToken;\n        IERC20 dstToken = desc.dstToken;\n\n        if (flags & _REQUIRES_EXTRA_ETH != 0) {\n            require(msg.value > (srcToken.isETH() ? desc.amount : 0), \"Invalid msg.value\");\n        } else {\n            require(msg.value == (srcToken.isETH() ? desc.amount : 0), \"Invalid msg.value\");\n        }\n\n        if (flags & _SHOULD_CLAIM != 0) {\n            require(!srcToken.isETH(), \"Claim token is ETH\");\n            _claim(srcToken, desc.srcReceiver, desc.amount, desc.permit);\n        }\n\n        address dstReceiver = (desc.dstReceiver == address(0)) ? msg.sender : desc.dstReceiver;\n        uint256 initialSrcBalance = (flags & _PARTIAL_FILL != 0) ? srcToken.uniBalanceOf(msg.sender) : 0;\n        uint256 initialDstBalance = dstToken.uniBalanceOf(dstReceiver);\n\n        caller.makeCalls{value: msg.value}(calls);\n\n        uint256 spentAmount = desc.amount;\n        returnAmount = dstToken.uniBalanceOf(dstReceiver).sub(initialDstBalance);\n```\n\nThis way Megan can supply pre-cooked contract that will do the swap (so all the conditions above be satisfied) and call Sherlock to enter the deposit in the same time.\n\nI.e. only passing the control is needed here so an additional action, Sherlock deposit, can be performed while TrueFiPool2 poolValue() and TrueFiStrategy's _balanceOf() are depressed.\n\nAs Sherlock's shares are constant, this will mean that USDC amount supplied by Megan to Sherlock's initialStake() will be credited with an inflated number fo shares:\n\nhttps://github.com/sherlock-audit/2022-09-sherlock/blob/main/sherlock-v2-core/contracts/Sherlock.sol#L523-L553\n\nI.e. inflated `stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount)` to be issued as part of totalTokenBalanceStakers() is strategy's balanceOf():\n\nhttps://github.com/sherlock-audit/2022-09-sherlock/blob/main/sherlock-v2-core/contracts/Sherlock.sol#L159-L164\n\nWhich uses current TrueFiPool2 poolValue():\n\nhttps://github.com/sherlock-audit/2022-09-sherlock/blob/main/sherlock-v2-core/contracts/strategy/TrueFiStrategy.sol#L131-L147\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adding reentrancy guarding modifiers to TrueFi's reclaim() and liquidValue().\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/5",
  "Code": [
    {
      "filename": "contracts/truefi2/FixedTermLoanAgency.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.10;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport {ERC20} from \"../common/UpgradeableERC20.sol\";\nimport {UpgradeableClaimable} from \"../common/UpgradeableClaimable.sol\";\nimport {OneInchExchange} from \"./libraries/OneInchExchange.sol\";\n\nimport {IFixedTermLoan} from \"./interface/IFixedTermLoan.sol\";\nimport {ILoanFactory2} from \"./interface/ILoanFactory2.sol\";\nimport {IStakingPool} from \"../truefi/interface/IStakingPool.sol\";\nimport {IFixedTermLoanAgency} from \"./interface/IFixedTermLoanAgency.sol\";\nimport {ITrueFiPool2} from \"./interface/ITrueFiPool2.sol\";\nimport {I1Inch3} from \"./interface/I1Inch3.sol\";\nimport {IPoolFactory} from \"./interface/IPoolFactory.sol\";\nimport {IERC20WithDecimals} from \"./interface/IERC20WithDecimals.sol\";\nimport {ITrueFiCreditOracle} from \"./interface/ITrueFiCreditOracle.sol\";\nimport {IRateModel} from \"./interface/IRateModel.sol\";\nimport {IBorrowingMutex} from \"./interface/IBorrowingMutex.sol\";\nimport {IStakingVault} from \"./interface/IStakingVault.sol\";\n\ninterface ITrueFiPool2WithDecimals is ITrueFiPool2 {\n    function decimals() external view returns (uint8);\n}\n\n/**\n * @title FixedTermLoanAgency\n * @dev Loans management helper\n * This contract is a bridge that helps to transfer funds from pool to the loans and back\n * FixedTermLoanAgency holds all LoanTokens\n */\ncontract FixedTermLoanAgency is IFixedTermLoanAgency, UpgradeableClaimable {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n    using SafeERC20 for IERC20WithDecimals;\n    using SafeERC20 for ITrueFiPool2;\n    using OneInchExchange for I1Inch3;\n\n    // basis point for ratio\n    uint256 private constant BASIS_RATIO = 10000;\n\n    uint256 private constant ONE_INCH_PARTIAL_FILL_FLAG = 0x01;\n\n    // ================ WARNING ==================\n    // ===== THIS CONTRACT IS INITIALIZABLE ======\n    // === STORAGE VARIABLES ARE DECLARED BELOW ==\n    // REMOVAL OR REORDER OF VARIABLES WILL RESULT\n    // ========= IN STORAGE CORRUPTION ===========\n\n    mapping(ITrueFiPool2 => IFixedTermLoan[]) public poolLoans;\n\n    // maximum amount of loans agency can handle at once\n    uint256 public maxLoans;\n\n    // which part of interest should be paid to the stakers\n    uint256 public fee;\n\n    IStakingPool public stakingPool;\n\n    IPoolFactory public poolFactory;\n\n    I1Inch3 public _1inch;\n\n    // Loan fees should be swapped for this token, deposited into the feePool\n    // and pool's LP tokens should be sent to the stakers\n    IERC20WithDecimals public feeToken;\n    ITrueFiPool2 public feePool;\n\n    // Minimal possible fee swap slippage\n    // basis precision: 10000 = 100%\n    uint256 public swapFeeSlippage;\n\n    ITrueFiCreditOracle public creditOracle;\n\n    uint256 public maxLoanTerm;\n\n    uint256 public longTermLoanThreshold;\n\n    uint8 public longTermLoanScoreThreshold;\n\n    IRateModel public rateModel;\n\n    // mutex ensuring there's only one running loan or credit line for borrower\n    IBorrowingMutex public borrowingMutex;\n\n    ILoanFactory2 public loanFactory;\n\n    mapping(address => bool) public isBorrowerAllowed;\n\n    IStakingVault public stakingVault;\n\n    // ======= STORAGE DECLARATION END ============\n\n    /**\n     * @dev Emitted when loans limit is changed\n     * @param maxLoans new maximum amount of loans\n     */\n    event LoansLimitChanged(uint256 maxLoans);\n\n    /**\n     * @dev Emitted when max loan term changed\n     * @param maxLoanTerm New max loan term\n     */\n    event MaxLoanTermChanged(uint256 maxLoanTerm);\n\n    /**\n     * @dev Emitted when long term loan's minimal term changed\n     * @param longTermLoanThreshold New long term loan minimal term\n     */\n    event LongTermLoanThresholdChanged(uint256 longTermLoanThreshold);\n\n    /**\n     * @dev Emitted when minimal credit score threshold for long term loan changed\n     * @param longTermLoanScoreThreshold New minimal credit score threshold for long term loan\n     */\n    event LongTermLoanScoreThresholdChanged(uint256 longTermLoanScoreThreshold);\n\n    /**\n     * @dev Emitted when loan fee is changed\n     * @param newFee New fee value in basis points\n     */\n    event FeeChanged(uint256 newFee);\n\n    /**\n     * @dev Emitted when fee pool is changed\n     * @param newFeePool New fee pool address\n     */\n    event FeePoolChanged(ITrueFiPool2 newFeePool);\n\n    /**\n     * @dev Emitted when credit oracle is changed\n     * @param newCreditOracle New credit oracle address\n     */\n    event CreditOracleChanged(ITrueFiCreditOracle newCreditOracle);\n\n    /**\n     * @dev Emitted when a loan is funded\n     * @param loanToken LoanToken contract which was funded\n     * @param amount Amount funded\n     */\n    event Funded(address indexed pool, address loanToken, uint256 amount);\n\n    /**\n     * @dev Emitted when funds are reclaimed from the LoanToken contract\n     * @param loanToken LoanToken from which funds were reclaimed\n     * @param amount Amount repaid\n     */\n    event Reclaimed(address indexed pool, address loanToken, uint256 amount);\n\n    /**\n     * @dev Emitted when borrowingMutex address is changed\n     * @param borrowingMutex new borrowingMutex address\n     */\n    event BorrowingMutexChanged(IBorrowingMutex borrowingMutex);\n\n    event BorrowerAllowed(address indexed who);\n    event BorrowerBlocked(address indexed who);\n\n    /**\n     * @dev Can be only called by a pool\n     */\n    modifier onlySupportedPool() {\n        require(poolFactory.isSupportedPool(ITrueFiPool2(msg.sender)), \"FixedTermLoanAgency: Pool not supported by the factory\");\n        _;\n    }\n\n    modifier onlyAllowedBorrowers() {\n        require(isBorrowerAllowed[msg.sender], \"FixedTermLoanAgency: Sender is not allowed to borrow\");\n        _;\n    }\n\n    /**\n     * @dev Initialize the contract with parameters\n     * @param _stakingPool stkTRU address\n     * @param _poolFactory PoolFactory address\n     * @param __1inch 1Inch exchange address (0x11111112542d85b3ef69ae05771c2dccff4faa26 for mainnet)\n     */\n    function initialize(\n        IStakingPool _stakingPool,\n        IPoolFactory _poolFactory,\n        I1Inch3 __1inch,\n        ITrueFiCreditOracle _creditOracle,\n        IRateModel _rateModel,\n        IBorrowingMutex _borrowingMutex,\n        ILoanFactory2 _loanFactory,\n        IStakingVault _stakingVault\n    ) public initializer {\n        UpgradeableClaimable.initialize(msg.sender);\n\n        stakingPool = _stakingPool;\n        poolFactory = _poolFactory;\n        _1inch = __1inch;\n        creditOracle = _creditOracle;\n        rateModel = _rateModel;\n        borrowingMutex = _borrowingMutex;\n        loanFactory = _loanFactory;\n        stakingVault = _stakingVault;\n\n        swapFeeSlippage = 100; // 1%\n        fee = 1000;\n        maxLoans = 100;\n        maxLoanTerm = 180 days;\n        longTermLoanThreshold = 90 days;\n        longTermLoanScoreThreshold = 200;\n    }\n\n    /**\n     * @dev Set new credit oracle address.\n     * Only owner can change credit oracle\n     * @param _creditOracle new credit oracle\n     */\n    function setCreditOracle(ITrueFiCreditOracle _creditOracle) external onlyOwner {\n        require(address(_creditOracle) != address(0), \"FixedTermLoanAgency: CreditOracle cannot be set to zero address\");\n        creditOracle = _creditOracle;\n        emit CreditOracleChanged(_creditOracle);\n    }\n\n    /**\n     * @dev set borrowingMutex\n     * @param newMutex borrowing mutex address to be set\n     */\n    function setBorrowingMutex(IBorrowingMutex newMutex) public onlyOwner {\n        require(address(newMutex) != address(0), \"FixedTermLoanAgency: BorrowingMutex cannot be set to zero address\");\n        borrowingMutex = newMutex;\n        emit BorrowingMutexChanged(newMutex);\n    }\n\n    /**\n     * @dev Set max loan term. Only owner can change parameters.\n     * @param _maxLoanTerm New maxLoanTerm\n     */\n    function setMaxLoanTerm(uint256 _maxLoanTerm) external onlyOwner {\n        maxLoanTerm = _maxLoanTerm;\n        emit MaxLoanTermChanged(_maxLoanTerm);\n    }\n\n    /**\n     * @dev Set minimal term of a long term loan. Only owner can change parameters.\n     * @param _longTermLoanThreshold New longTermLoanThreshold\n     */\n    function setLongTermLoanThreshold(uint256 _longTermLoanThreshold) external onlyOwner {\n        longTermLoanThreshold = _longTermLoanThreshold;\n        emit LongTermLoanThresholdChanged(_longTermLoanThreshold);\n    }\n\n    /**\n     * @dev Set long term loan credit score threshold. Only owner can change parameters.\n     * @param _longTermLoanScoreThreshold New longTermLoanScoreThreshold\n     */\n    function setLongTermLoanScoreThreshold(uint8 _longTermLoanScoreThreshold) external onlyOwner {\n        longTermLoanScoreThreshold = _longTermLoanScoreThreshold;\n        emit LongTermLoanScoreThresholdChanged(_longTermLoanScoreThreshold);\n    }\n\n    /**\n     * @dev Set new loans limit. Only owner can change parameters.\n     * @param newLoansLimit New loans limit\n     */\n    function setLoansLimit(uint256 newLoansLimit) external onlyOwner {\n        maxLoans = newLoansLimit;\n        emit LoansLimitChanged(maxLoans);\n    }\n\n    /**\n     * @dev Set new fee pool and fee token.\n     * Only owner can change parameters\n     * @param newFeePool new pool address\n     */\n    function setFeePool(ITrueFiPool2 newFeePool) external onlyOwner {\n        feeToken = IERC20WithDecimals(address(newFeePool.token()));\n        feePool = newFeePool;\n        emit FeePoolChanged(newFeePool);\n    }\n\n    /**\n     * @dev Set loan interest fee that goes to the stakers.\n     * @param newFee New loans limit\n     */\n    function setFee(uint256 newFee) external onlyOwner {\n        require(newFee <= BASIS_RATIO, \"FixedTermLoanAgency: fee cannot be more than 100%\");\n        fee = newFee;\n        emit FeeChanged(newFee);\n    }\n\n    function allowBorrower(address who) external onlyOwner {\n        isBorrowerAllowed[who] = true;\n        emit BorrowerAllowed(who);\n    }\n\n    function blockBorrower(address who) external onlyOwner {\n        isBorrowerAllowed[who] = false;\n        emit BorrowerBlocked(who);\n    }\n\n    /**\n     * @dev Get currently funded loans for a pool\n     * @param pool pool address\n     * @return result Array of loans currently funded\n     */\n    function loans(ITrueFiPool2 pool) public view returns (IFixedTermLoan[] memory result) {\n        result = poolLoans[pool];\n    }\n\n    function rate(\n        ITrueFiPool2 pool,\n        address borrower,\n        uint256 amount,\n        uint256 term\n    ) public view returns (uint256) {\n        uint8 rawScore = creditOracle.score(borrower);\n        uint256 stakedAmount = stakingVault.stakedAmount(borrower);\n        uint8 effectiveScore = rateModel.effectiveScore(pool, rawScore, stakedAmount, amount);\n        uint256 fixedTermLoanAdjustment = rateModel.fixedTermLoanAdjustment(term);\n        return rateModel.rate(pool, effectiveScore, amount).add(fixedTermLoanAdjustment);\n    }\n\n    /**\n     * @dev Create and fund a loan via LoanFactory for a pool supported by PoolFactory\n     * Method should be called by the loan borrower\n     *\n     * When called, agency takes funds from the pool, gives it to the loan and holds all LoanTokens\n     * Origination fee is transferred to the stake\n     */\n    function borrow(\n        ITrueFiPool2 pool,\n        uint256 amount,\n        uint256 term,\n        uint256 _maxApy\n    ) external onlyAllowedBorrowers {\n        require(poolFactory.isSupportedPool(pool), \"FixedTermLoanAgency: Pool not supported by the factory\");\n        require(poolLoans[pool].length < maxLoans, \"FixedTermLoanAgency: Loans number has reached the limit\");\n\n        address borrower = msg.sender;\n        require(borrowingMutex.isUnlocked(borrower), \"FixedTermLoanAgency: There is an ongoing loan or credit line\");\n        require(\n            creditOracle.status(borrower) == ITrueFiCreditOracle.Status.Eligible,\n            \"FixedTermLoanAgency: Sender is not eligible for loan\"\n        );\n\n        require(amount > 0, \"FixedTermLoanAgency: Loans of amount 0, will not be approved\");\n        require(\n            pool.oracle().tokenToUsd(amount) <= borrowLimit(pool, borrower),\n            \"FixedTermLoanAgency: Loan amount cannot exceed borrow limit\"\n        );\n\n        require(term > 0, \"FixedTermLoanAgency: Loans cannot have instantaneous term of repay\");\n        require(isTermBelowMax(term), \"FixedTermLoanAgency: Loan's term is too long\");\n        require(isCredibleForTerm(term), \"FixedTermLoanAgency: Credit score is too low for loan's term\");\n\n        uint256 apy = rate(pool, borrower, amount, term);\n        require(apy <= _maxApy, \"FixedTermLoanAgency: Calculated apy is higher than max apy\");\n\n        IFixedTermLoan loanToken = loanFactory.createLoanToken(pool, borrower, amount, term, apy);\n        borrowingMutex.lock(borrower, address(loanToken));\n        poolLoans[pool].push(loanToken);\n        pool.borrow(amount);\n        pool.token().safeTransfer(borrower, amount);\n\n        emit Funded(address(pool), address(loanToken), amount);\n    }\n\n    /**\n     * @dev Loop through loan tokens for the pool and calculate theoretical value of all loans\n     * There should never be too many loans in the pool to run out of gas\n     * @param pool pool address\n     * @return Theoretical value of all the loans funded by this strategy\n     */\n    function value(ITrueFiPool2 pool) external view override returns (uint256) {\n        IFixedTermLoan[] memory _loans = poolLoans[pool];\n        uint256 totalValue;\n        for (uint256 index = 0; index < _loans.length; index++) {\n            totalValue = totalValue.add(_loans[index].currentValue(address(this)));\n        }\n        return totalValue;\n    }\n\n    /**\n     * @dev For settled loans, redeem LoanTokens for underlying funds\n     * @param loanToken Loan to reclaim capital from (must be previously funded)\n     */\n    function reclaim(IFixedTermLoan loanToken, bytes calldata data) external {\n        IFixedTermLoan.Status status = loanToken.status();\n        require(\n            status == IFixedTermLoan.Status.Settled || status == IFixedTermLoan.Status.Defaulted,\n            \"FixedTermLoanAgency: LoanToken is not closed yet\"\n        );\n        if (status == IFixedTermLoan.Status.Defaulted) {\n            require(msg.sender == owner(), \"FixedTermLoanAgency: Only owner can reclaim from defaulted loan\");\n        }\n\n        // find the token, repay loan and remove loan from loan array\n        ITrueFiPool2 pool = loanToken.pool();\n        IFixedTermLoan[] storage _loans = poolLoans[pool];\n        uint256 loansLength = _loans.length;\n        for (uint256 index = 0; index < loansLength; index++) {\n            if (_loans[index] == loanToken) {\n                _loans[index] = _loans[loansLength - 1];\n                _loans.pop();\n\n                uint256 fundsReclaimed = _redeemAndRepay(loanToken, pool, data);\n                emit Reclaimed(address(pool), address(loanToken), fundsReclaimed);\n                return;\n            }\n        }\n        // If we reach this, it means loanToken was not present in _loans array\n        // This prevents invalid loans from being reclaimed\n        revert(\"FixedTermLoanAgency: This loan has not been funded by the agency\");\n    }\n\n    /**\n     * @dev Get total amount borrowed for `borrower` from fixed term loans in USD\n     * Total borrowed amount would be 0 if no Fixed Term Loan is taken by the borrower at the moment\n     * And total loan amount + interest otherwise.\n     * @param borrower Borrower to get amount borrowed for\n     * @param decimals Precision to use when calculating total borrowed\n     * @return Total amount borrowed for `borrower` in USD\n     */\n    function totalBorrowed(address borrower, uint8 decimals) public view returns (uint256) {\n        IFixedTermLoan loan = IFixedTermLoan(borrowingMutex.locker(borrower));\n        if (!loanFactory.isLoanToken(loan)) {\n            return 0;\n        }\n        uint256 borrowed = loan.debt();\n        uint256 resultPrecision = uint256(10)**decimals;\n\n        return loan.pool().oracle().tokenToUsd(borrowed).mul(resultPrecision).div(1 ether);\n    }\n\n    /**\n     * @dev Get borrow limit for `borrower` in `pool` using rate model\n     * @param pool Pool to get borrow limit for\n     * @param borrower Borrower to get borrow limit for\n     * @return borrow limit for `borrower` in `pool`\n     */\n    function borrowLimit(ITrueFiPool2 pool, address borrower) public view returns (uint256) {\n        uint8 poolDecimals = ITrueFiPool2WithDecimals(address(pool)).decimals();\n        return\n            rateModel.borrowLimit(\n                pool,\n                creditOracle.score(borrower),\n                creditOracle.maxBorrowerLimit(borrower),\n                stakingVault.stakedAmount(borrower),\n                totalBorrowed(borrower, poolDecimals)\n            );\n    }\n\n    /**\n     * @dev Helper function to redeem funds from `loanToken` and repay them into the `pool`\n     * @param loanToken Loan to reclaim capital from\n     * @param pool Pool from which the loan was funded\n     */\n    function _redeemAndRepay(\n        IFixedTermLoan loanToken,\n        ITrueFiPool2 pool,\n        bytes calldata data\n    ) internal returns (uint256) {\n        // call redeem function on LoanToken\n        uint256 balanceBefore = pool.token().balanceOf(address(this));\n        loanToken.redeem();\n        uint256 balanceAfter = pool.token().balanceOf(address(this));\n\n        // gets reclaimed amount and pays back to pool\n        uint256 fundsReclaimed = balanceAfter.sub(balanceBefore);\n\n        uint256 feeAmount;\n        if (address(feeToken) != address(0)) {\n            // swap fee for feeToken\n            feeAmount = _swapFee(pool, loanToken, data);\n        }\n\n        pool.token().safeApprove(address(pool), fundsReclaimed.sub(feeAmount));\n        pool.repay(fundsReclaimed.sub(feeAmount));\n\n        if (address(feeToken) != address(0)) {\n            // join pool and reward stakers\n            _transferFeeToStakers();\n        }\n        return fundsReclaimed;\n    }\n\n    /// @dev Swap `token` for `feeToken` on 1inch\n    function _swapFee(\n        ITrueFiPool2 pool,\n        IFixedTermLoan loanToken,\n        bytes calldata data\n    ) internal returns (uint256) {\n        uint256 feeAmount = loanToken.interest().mul(fee).div(BASIS_RATIO);\n        IERC20WithDecimals token = IERC20WithDecimals(address(pool.token()));\n        if (token == feeToken) {\n            return feeAmount;\n        }\n        if (feeAmount == 0) {\n            return 0;\n        }\n        (I1Inch3.SwapDescription memory swap, uint256 balanceDiff) = _1inch.exchange(data);\n        uint256 expectedDiff = pool.oracle().tokenToUsd(feeAmount).mul(uint256(10)**feeToken.decimals()).div(1 ether);\n\n        require(swap.srcToken == address(token), \"FixedTermLoanAgency: Source token is not same as pool's token\");\n        require(swap.dstToken == address(feeToken), \"FixedTermLoanAgency: Destination token is not fee token\");\n        require(swap.dstReceiver == address(this), \"FixedTermLoanAgency: Receiver is not agency\");\n        require(swap.amount == feeAmount, \"FixedTermLoanAgency: Incorrect fee swap amount\");\n        require(swap.flags & ONE_INCH_PARTIAL_FILL_FLAG == 0, \"FixedTermLoanAgency: Partial fill is not allowed\");\n        require(\n            balanceDiff >= expectedDiff.mul(BASIS_RATIO.sub(swapFeeSlippage)).div(BASIS_RATIO),\n            \"FixedTermLoanAgency: Fee returned from swap is too small\"\n        );\n\n        return feeAmount;\n    }\n\n    /// @dev Deposit feeToken to pool and transfer LP tokens to the stakers\n    function _transferFeeToStakers() internal {\n        uint256 amount = feeToken.balanceOf(address(this));\n        if (amount == 0) {\n            return;\n        }\n        feeToken.safeApprove(address(feePool), amount);\n        feePool.join(amount);\n        feePool.safeTransfer(address(stakingPool), feePool.balanceOf(address(this)));\n    }\n\n    function isCredibleForTerm(uint256 term) internal view returns (bool) {\n        return term <= longTermLoanThreshold || creditOracle.score(msg.sender) >= longTermLoanScoreThreshold;\n    }\n\n    function isTermBelowMax(uint256 term) internal view returns (bool) {\n        return term <= maxLoanTerm;\n    }\n}"
    },
    {
      "filename": "contracts/truefi2/FixedTermLoanAgency.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.10;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport {ERC20} from \"../common/UpgradeableERC20.sol\";\nimport {UpgradeableClaimable} from \"../common/UpgradeableClaimable.sol\";\nimport {OneInchExchange} from \"./libraries/OneInchExchange.sol\";\n\nimport {IFixedTermLoan} from \"./interface/IFixedTermLoan.sol\";\nimport {ILoanFactory2} from \"./interface/ILoanFactory2.sol\";\nimport {IStakingPool} from \"../truefi/interface/IStakingPool.sol\";\nimport {IFixedTermLoanAgency} from \"./interface/IFixedTermLoanAgency.sol\";\nimport {ITrueFiPool2} from \"./interface/ITrueFiPool2.sol\";\nimport {I1Inch3} from \"./interface/I1Inch3.sol\";\nimport {IPoolFactory} from \"./interface/IPoolFactory.sol\";\nimport {IERC20WithDecimals} from \"./interface/IERC20WithDecimals.sol\";\nimport {ITrueFiCreditOracle} from \"./interface/ITrueFiCreditOracle.sol\";\nimport {IRateModel} from \"./interface/IRateModel.sol\";\nimport {IBorrowingMutex} from \"./interface/IBorrowingMutex.sol\";\nimport {IStakingVault} from \"./interface/IStakingVault.sol\";\n\ninterface ITrueFiPool2WithDecimals is ITrueFiPool2 {\n    function decimals() external view returns (uint8);\n}\n\n/**\n * @title FixedTermLoanAgency\n * @dev Loans management helper\n * This contract is a bridge that helps to transfer funds from pool to the loans and back\n * FixedTermLoanAgency holds all LoanTokens\n */\ncontract FixedTermLoanAgency is IFixedTermLoanAgency, UpgradeableClaimable {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n    using SafeERC20 for IERC20WithDecimals;\n    using SafeERC20 for ITrueFiPool2;\n    using OneInchExchange for I1Inch3;\n\n    // basis point for ratio\n    uint256 private constant BASIS_RATIO = 10000;\n\n    uint256 private constant ONE_INCH_PARTIAL_FILL_FLAG = 0x01;\n\n    // ================ WARNING ==================\n    // ===== THIS CONTRACT IS INITIALIZABLE ======\n    // === STORAGE VARIABLES ARE DECLARED BELOW ==\n    // REMOVAL OR REORDER OF VARIABLES WILL RESULT\n    // ========= IN STORAGE CORRUPTION ===========\n\n    mapping(ITrueFiPool2 => IFixedTermLoan[]) public poolLoans;\n\n    // maximum amount of loans agency can handle at once\n    uint256 public maxLoans;\n\n    // which part of interest should be paid to the stakers\n    uint256 public fee;\n\n    IStakingPool public stakingPool;\n\n    IPoolFactory public poolFactory;\n\n    I1Inch3 public _1inch;\n\n    // Loan fees should be swapped for this token, deposited into the feePool\n    // and pool's LP tokens should be sent to the stakers\n    IERC20WithDecimals public feeToken;\n    ITrueFiPool2 public feePool;\n\n    // Minimal possible fee swap slippage\n    // basis precision: 10000 = 100%\n    uint256 public swapFeeSlippage;\n\n    ITrueFiCreditOracle public creditOracle;\n\n    uint256 public maxLoanTerm;\n\n    uint256 public longTermLoanThreshold;\n\n    uint8 public longTermLoanScoreThreshold;\n\n    IRateModel public rateModel;\n\n    // mutex ensuring there's only one running loan or credit line for borrower\n    IBorrowingMutex public borrowingMutex;\n\n    ILoanFactory2 public loanFactory;\n\n    mapping(address => bool) public isBorrowerAllowed;\n\n    IStakingVault public stakingVault;\n\n    // ======= STORAGE DECLARATION END ============\n\n    /**\n     * @dev Emitted when loans limit is changed\n     * @param maxLoans new maximum amount of loans\n     */\n    event LoansLimitChanged(uint256 maxLoans);\n\n    /**\n     * @dev Emitted when max loan term changed\n     * @param maxLoanTerm New max loan term\n     */\n    event MaxLoanTermChanged(uint256 maxLoanTerm);\n\n    /**\n     * @dev Emitted when long term loan's minimal term changed\n     * @param longTermLoanThreshold New long term loan minimal term\n     */\n    event LongTermLoanThresholdChanged(uint256 longTermLoanThreshold);\n\n    /**\n     * @dev Emitted when minimal credit score threshold for long term loan changed\n     * @param longTermLoanScoreThreshold New minimal credit score threshold for long term loan\n     */\n    event LongTermLoanScoreThresholdChanged(uint256 longTermLoanScoreThreshold);\n\n    /**\n     * @dev Emitted when loan fee is changed\n     * @param newFee New fee value in basis points\n     */\n    event FeeChanged(uint256 newFee);\n\n    /**\n     * @dev Emitted when fee pool is changed\n     * @param newFeePool New fee pool address\n     */\n    event FeePoolChanged(ITrueFiPool2 newFeePool);\n\n    /**\n     * @dev Emitted when credit oracle is changed\n     * @param newCreditOracle New credit oracle address\n     */\n    event CreditOracleChanged(ITrueFiCreditOracle newCreditOracle);\n\n    /**\n     * @dev Emitted when a loan is funded\n     * @param loanToken LoanToken contract which was funded\n     * @param amount Amount funded\n     */\n    event Funded(address indexed pool, address loanToken, uint256 amount);\n\n    /**\n     * @dev Emitted when funds are reclaimed from the LoanToken contract\n     * @param loanToken LoanToken from which funds were reclaimed\n     * @param amount Amount repaid\n     */\n    event Reclaimed(address indexed pool, address loanToken, uint256 amount);\n\n    /**\n     * @dev Emitted when borrowingMutex address is changed\n     * @param borrowingMutex new borrowingMutex address\n     */\n    event BorrowingMutexChanged(IBorrowingMutex borrowingMutex);\n\n    event BorrowerAllowed(address indexed who);\n    event BorrowerBlocked(address indexed who);\n\n    /**\n     * @dev Can be only called by a pool\n     */\n    modifier onlySupportedPool() {\n        require(poolFactory.isSupportedPool(ITrueFiPool2(msg.sender)), \"FixedTermLoanAgency: Pool not supported by the factory\");\n        _;\n    }\n\n    modifier onlyAllowedBorrowers() {\n        require(isBorrowerAllowed[msg.sender], \"FixedTermLoanAgency: Sender is not allowed to borrow\");\n        _;\n    }\n\n    /**\n     * @dev Initialize the contract with parameters\n     * @param _stakingPool stkTRU address\n     * @param _poolFactory PoolFactory address\n     * @param __1inch 1Inch exchange address (0x11111112542d85b3ef69ae05771c2dccff4faa26 for mainnet)\n     */\n    function initialize(\n        IStakingPool _stakingPool,\n        IPoolFactory _poolFactory,\n        I1Inch3 __1inch,\n        ITrueFiCreditOracle _creditOracle,\n        IRateModel _rateModel,\n        IBorrowingMutex _borrowingMutex,\n        ILoanFactory2 _loanFactory,\n        IStakingVault _stakingVault\n    ) public initializer {\n        UpgradeableClaimable.initialize(msg.sender);\n\n        stakingPool = _stakingPool;\n        poolFactory = _poolFactory;\n        _1inch = __1inch;\n        creditOracle = _creditOracle;\n        rateModel = _rateModel;\n        borrowingMutex = _borrowingMutex;\n        loanFactory = _loanFactory;\n        stakingVault = _stakingVault;\n\n        swapFeeSlippage = 100; // 1%\n        fee = 1000;\n        maxLoans = 100;\n        maxLoanTerm = 180 days;\n        longTermLoanThreshold = 90 days;\n        longTermLoanScoreThreshold = 200;\n    }\n\n    /**\n     * @dev Set new credit oracle address.\n     * Only owner can change credit oracle\n     * @param _creditOracle new credit oracle\n     */\n    function setCreditOracle(ITrueFiCreditOracle _creditOracle) external onlyOwner {\n        require(address(_creditOracle) != address(0), \"FixedTermLoanAgency: CreditOracle cannot be set to zero address\");\n        creditOracle = _creditOracle;\n        emit CreditOracleChanged(_creditOracle);\n    }\n\n    /**\n     * @dev set borrowingMutex\n     * @param newMutex borrowing mutex address to be set\n     */\n    function setBorrowingMutex(IBorrowingMutex newMutex) public onlyOwner {\n        require(address(newMutex) != address(0), \"FixedTermLoanAgency: BorrowingMutex cannot be set to zero address\");\n        borrowingMutex = newMutex;\n        emit BorrowingMutexChanged(newMutex);\n    }\n\n    /**\n     * @dev Set max loan term. Only owner can change parameters.\n     * @param _maxLoanTerm New maxLoanTerm\n     */\n    function setMaxLoanTerm(uint256 _maxLoanTerm) external onlyOwner {\n        maxLoanTerm = _maxLoanTerm;\n        emit MaxLoanTermChanged(_maxLoanTerm);\n    }\n\n    /**\n     * @dev Set minimal term of a long term loan. Only owner can change parameters.\n     * @param _longTermLoanThreshold New longTermLoanThreshold\n     */\n    function setLongTermLoanThreshold(uint256 _longTermLoanThreshold) external onlyOwner {\n        longTermLoanThreshold = _longTermLoanThreshold;\n        emit LongTermLoanThresholdChanged(_longTermLoanThreshold);\n    }\n\n    /**\n     * @dev Set long term loan credit score threshold. Only owner can change parameters.\n     * @param _longTermLoanScoreThreshold New longTermLoanScoreThreshold\n     */\n    function setLongTermLoanScoreThreshold(uint8 _longTermLoanScoreThreshold) external onlyOwner {\n        longTermLoanScoreThreshold = _longTermLoanScoreThreshold;\n        emit LongTermLoanScoreThresholdChanged(_longTermLoanScoreThreshold);\n    }\n\n    /**\n     * @dev Set new loans limit. Only owner can change parameters.\n     * @param newLoansLimit New loans limit\n     */\n    function setLoansLimit(uint256 newLoansLimit) external onlyOwner {\n        maxLoans = newLoansLimit;\n        emit LoansLimitChanged(maxLoans);\n    }\n\n    /**\n     * @dev Set new fee pool and fee token.\n     * Only owner can change parameters\n     * @param newFeePool new pool address\n     */\n    function setFeePool(ITrueFiPool2 newFeePool) external onlyOwner {\n        feeToken = IERC20WithDecimals(address(newFeePool.token()));\n        feePool = newFeePool;\n        emit FeePoolChanged(newFeePool);\n    }\n\n    /**\n     * @dev Set loan interest fee that goes to the stakers.\n     * @param newFee New loans limit\n     */\n    function setFee(uint256 newFee) external onlyOwner {\n        require(newFee <= BASIS_RATIO, \"FixedTermLoanAgency: fee cannot be more than 100%\");\n        fee = newFee;\n        emit FeeChanged(newFee);\n    }\n\n    function allowBorrower(address who) external onlyOwner {\n        isBorrowerAllowed[who] = true;\n        emit BorrowerAllowed(who);\n    }\n\n    function blockBorrower(address who) external onlyOwner {\n        isBorrowerAllowed[who] = false;\n        emit BorrowerBlocked(who);\n    }\n\n    /**\n     * @dev Get currently funded loans for a pool\n     * @param pool pool address\n     * @return result Array of loans currently funded\n     */\n    function loans(ITrueFiPool2 pool) public view returns (IFixedTermLoan[] memory result) {\n        result = poolLoans[pool];\n    }\n\n    function rate(\n        ITrueFiPool2 pool,\n        address borrower,\n        uint256 amount,\n        uint256 term\n    ) public view returns (uint256) {\n        uint8 rawScore = creditOracle.score(borrower);\n        uint256 stakedAmount = stakingVault.stakedAmount(borrower);\n        uint8 effectiveScore = rateModel.effectiveScore(pool, rawScore, stakedAmount, amount);\n        uint256 fixedTermLoanAdjustment = rateModel.fixedTermLoanAdjustment(term);\n        return rateModel.rate(pool, effectiveScore, amount).add(fixedTermLoanAdjustment);\n    }\n\n    /**\n     * @dev Create and fund a loan via LoanFactory for a pool supported by PoolFactory\n     * Method should be called by the loan borrower\n     *\n     * When called, agency takes funds from the pool, gives it to the loan and holds all LoanTokens\n     * Origination fee is transferred to the stake\n     */\n    function borrow(\n        ITrueFiPool2 pool,\n        uint256 amount,\n        uint256 term,\n        uint256 _maxApy\n    ) external onlyAllowedBorrowers {\n        require(poolFactory.isSupportedPool(pool), \"FixedTermLoanAgency: Pool not supported by the factory\");\n        require(poolLoans[pool].length < maxLoans, \"FixedTermLoanAgency: Loans number has reached the limit\");\n\n        address borrower = msg.sender;\n        require(borrowingMutex.isUnlocked(borrower), \"FixedTermLoanAgency: There is an ongoing loan or credit line\");\n        require(\n            creditOracle.status(borrower) == ITrueFiCreditOracle.Status.Eligible,\n            \"FixedTermLoanAgency: Sender is not eligible for loan\"\n        );\n\n        require(amount > 0, \"FixedTermLoanAgency: Loans of amount 0, will not be approved\");\n        require(\n            pool.oracle().tokenToUsd(amount) <= borrowLimit(pool, borrower),\n            \"FixedTermLoanAgency: Loan amount cannot exceed borrow limit\"\n        );\n\n        require(term > 0, \"FixedTermLoanAgency: Loans cannot hav"
    }
  ]
}