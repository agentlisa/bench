{
  "Title": "[M-02] [WP-H3] `L1Migrator.sol#migrateETH()` Improper implementation of `L1Migrator` causing `migrateETH()` always reverts, can lead to ETH in `BridgeMinter` getting stuck in the contract",
  "Content": "_Submitted by WatchPug, also found by gzeon_.\n\n<https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L308-L310>\n\n```solidity\nuint256 amount = IBridgeMinter(bridgeMinterAddr).withdrawETHToL1Migrator();\n```\n\n`L1Migrator.sol#migrateETH()` will call `IBridgeMinter(bridgeMinterAddr).withdrawETHToL1Migrator()` to withdraw ETH from `BridgeMinter`.\n\nHowever, the current implementation of `L1Migrator` is unable to receive ETH.\n\n<https://github.com/livepeer/protocol/blob/20e7ebb86cdb4fe9285bf5fea02eb603e5d48805/contracts/token/BridgeMinter.sol#L94-L94>\n\n```solidity\n(bool ok, ) = l1MigratorAddr.call.value(address(this).balance)(\"\");\n```\n\nA contract receiving Ether must have at least one of the functions below:\n\n*   `receive() external payable`\n*   `fallback() external payable`\n\n`receive()` is called if `msg.data` is empty, otherwise `fallback()` is called.\n\nBecause `L1Migrator` implement neither `receive()` or `fallback()`, the `call` at L94 will always revert.\n\n#### Impact\n\nAll the ETH held by the `BridgeMinter` can get stuck in the contract.\n\n#### Recommendation\n\nAdd `receive() external payable {}` in `L1Migrator`.\n\n**[yondonfu (Livepeer) confirmed and disagreed with severity](https://github.com/code-423n4/2022-01-livepeer-findings/issues/198#issuecomment-1019663325):**\n > Severity: 2 (Med)\n> \n> We'll fix this, but noting that the funds are recoverable because the BridgeMinter can set a new L1Migrator that does have the receive() function which is why the suggested severity is 2 (Med).\n\n**[yondonfu (Livepeer) resolved](https://github.com/code-423n4/2022-01-livepeer-findings/issues/198#issuecomment-1021379439):**\n > Fixed in https://github.com/livepeer/arbitrum-lpt-bridge/pull/50\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-01-livepeer-findings/issues/198#issuecomment-1025009024):**\n > Agree with sponsor, these funds are recoverable. However, the warden has identified a DOS attack, which is a valid `medium` severity issue.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-01-livepeer",
  "Code": [
    {
      "filename": "contracts/L1/gateway/L1Migrator.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {L1ArbitrumMessenger} from \"./L1ArbitrumMessenger.sol\";\nimport {IL1LPTGateway} from \"./IL1LPTGateway.sol\";\nimport {IMigrator} from \"../../interfaces/IMigrator.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ninterface IBondingManager {\n    function isRegisteredTranscoder(address _addr) external view returns (bool);\n\n    function pendingStake(address _addr, uint256 _endRound)\n        external\n        view\n        returns (uint256);\n\n    function pendingFees(address _addr, uint256 _endRound)\n        external\n        view\n        returns (uint256);\n\n    function getDelegator(address _addr)\n        external\n        view\n        returns (\n            uint256 bondedAmount,\n            uint256 fees,\n            address delegateAddress,\n            uint256 delegatedAmount,\n            uint256 startRound,\n            uint256 lastClaimRound,\n            uint256 nextUnbondingLockId\n        );\n\n    function getDelegatorUnbondingLock(address _addr, uint256 _unbondingLockId)\n        external\n        view\n        returns (uint256 amount, uint256 withdrawRound);\n}\n\ninterface ITicketBroker {\n    struct Sender {\n        uint256 deposit;\n        uint256 withdrawRound;\n    }\n\n    struct ReserveInfo {\n        uint256 fundsRemaining;\n        uint256 claimedInCurrentRound;\n    }\n\n    function getSenderInfo(address _addr)\n        external\n        view\n        returns (Sender memory sender, ReserveInfo memory reserve);\n}\n\ninterface IBridgeMinter {\n    function withdrawETHToL1Migrator() external returns (uint256);\n\n    function withdrawLPTToL1Migrator() external returns (uint256);\n}\n\ninterface ApproveLike {\n    function approve(address _addr, uint256 _amount) external;\n}\n\ninterface IL2Migrator is IMigrator {\n    function finalizeMigrateDelegator(MigrateDelegatorParams memory _params)\n        external;\n\n    function finalizeMigrateUnbondingLocks(\n        MigrateUnbondingLocksParams memory _params\n    ) external;\n\n    function finalizeMigrateSender(MigrateSenderParams memory _params) external;\n}\n\ncontract L1Migrator is\n    L1ArbitrumMessenger,\n    IMigrator,\n    EIP712,\n    AccessControl,\n    Pausable\n{\n    address public immutable bondingManagerAddr;\n    address public immutable ticketBrokerAddr;\n    address public immutable bridgeMinterAddr;\n    address public immutable tokenAddr;\n    address public immutable l1LPTGatewayAddr;\n    address public immutable l2MigratorAddr;\n\n    event MigrateDelegatorInitiated(\n        uint256 indexed seqNo,\n        MigrateDelegatorParams params\n    );\n\n    event MigrateUnbondingLocksInitiated(\n        uint256 indexed seqNo,\n        MigrateUnbondingLocksParams params\n    );\n\n    event MigrateSenderInitiated(\n        uint256 indexed seqNo,\n        MigrateSenderParams params\n    );\n\n    bytes32 public constant GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\");\n\n    bytes32 private constant MIGRATE_DELEGATOR_TYPE_HASH =\n        keccak256(\"MigrateDelegator(address l1Addr,address l2Addr)\");\n\n    bytes32 private constant MIGRATE_UNBONDING_LOCKS_TYPE_HASH =\n        keccak256(\n            \"MigrateUnbondingLocks(address l1Addr,address l2Addr,uint256[] unbondingLockIds)\"\n        );\n\n    bytes32 private constant MIGRATE_SENDER_TYPE_HASH =\n        keccak256(\"MigrateSender(address l1Addr,address l2Addr)\");\n\n    constructor(\n        address _inbox,\n        address _bondingManagerAddr,\n        address _ticketBrokerAddr,\n        address _bridgeMinterAddr,\n        address _tokenAddr,\n        address _l1LPTGatewayAddr,\n        address _l2MigratorAddr\n    ) L1ArbitrumMessenger(_inbox) EIP712(\"Livepeer L1Migrator\", \"1\") {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        _setRoleAdmin(GOVERNOR_ROLE, DEFAULT_ADMIN_ROLE);\n\n        bondingManagerAddr = _bondingManagerAddr;\n        ticketBrokerAddr = _ticketBrokerAddr;\n        bridgeMinterAddr = _bridgeMinterAddr;\n        tokenAddr = _tokenAddr;\n        l1LPTGatewayAddr = _l1LPTGatewayAddr;\n        l2MigratorAddr = _l2MigratorAddr;\n\n        _pause();\n    }\n\n    /**\n     * @notice Executes a L2 call to L2Migrator to migrate transcoder/delegator state from the L1 BondingManager.\n     * @dev The term \"delegator\" here can refer to both a transcoder (self-delegated delegator) and delegator.\n     * @param _l1Addr Address migrating from L1\n     * @param _l2Addr Address to use on L2\n     * @param _sig Optional EIP-712 signature over a payload that includes _l1Addr and _l2Addr\n     * @param _maxGas Gas limit for L2 execution\n     * @param _gasPriceBid Gas price bid for L2 execution\n     * @param _maxSubmissionCost Max ETH to pay for retryable ticket base submission fee\n     */\n    function migrateDelegator(\n        address _l1Addr,\n        address _l2Addr,\n        bytes memory _sig,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost\n    ) external payable whenNotPaused {\n        // Authorization\n        // Either msg.sender == _l1Addr OR signer for _sig == _l1Addr\n        requireValidMigration(\n            _l1Addr,\n            _l2Addr,\n            keccak256(\n                abi.encode(MIGRATE_DELEGATOR_TYPE_HASH, _l1Addr, _l2Addr)\n            ),\n            _sig\n        );\n\n        (\n            bytes memory data,\n            MigrateDelegatorParams memory params\n        ) = getMigrateDelegatorParams(_l1Addr, _l2Addr);\n\n        // We do not prevent migration replays here to minimize L1 gas costs\n        // The L2Migrator is responsible for rejecting migration replays\n\n        uint256 seqNo = sendTxToL2(\n            l2MigratorAddr,\n            _l2Addr, // Refunds to the L2 address\n            _maxSubmissionCost,\n            _maxGas,\n            _gasPriceBid,\n            data\n        );\n\n        emit MigrateDelegatorInitiated(seqNo, params);\n    }\n\n    /**\n     * @notice Executes a L2 call to L2Migrator to migrate unbonding locks state from the L1 BondingManager.\n     * @param _l1Addr Address migrating from L1\n     * @param _l2Addr Address to use on L2\n     * @param _unbondingLockIds IDs of unbonding locks in the L1 BondingManager to migrate\n     * @param _sig Optional EIP-712 signature over a payload that includes _l1Addr, _l2Addr and _unbondingLockIds\n     * @param _maxGas Gas limit for L2 execution\n     * @param _gasPriceBid Gas price bid for L2 execution\n     * @param _maxSubmissionCost Max ETH to pay for retryable ticket base submission fee\n     */\n    function migrateUnbondingLocks(\n        address _l1Addr,\n        address _l2Addr,\n        uint256[] calldata _unbondingLockIds,\n        bytes memory _sig,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost\n    ) external payable whenNotPaused {\n        // Authorization\n        // Either msg.sender == _l1Addr OR signer for _sig == _l1Addr\n        requireValidMigration(\n            _l1Addr,\n            _l2Addr,\n            keccak256(\n                abi.encode(\n                    MIGRATE_UNBONDING_LOCKS_TYPE_HASH,\n                    _l1Addr,\n                    _l2Addr,\n                    keccak256(abi.encodePacked(_unbondingLockIds))\n                )\n            ),\n            _sig\n        );\n\n        (\n            bytes memory data,\n            MigrateUnbondingLocksParams memory params\n        ) = getMigrateUnbondingLocksParams(_l1Addr, _l2Addr, _unbondingLockIds);\n\n        // We do not prevent migration replays here to minimize L1 gas costs\n        // The L2Migrator is responsible for rejecting migration replays\n\n        uint256 seqNo = sendTxToL2(\n            l2MigratorAddr,\n            _l2Addr, // Refund to the L2 address\n            _maxSubmissionCost,\n            _maxGas,\n            _gasPriceBid,\n            data\n        );\n\n        emit MigrateUnbondingLocksInitiated(seqNo, params);\n    }\n\n    /**\n     * @notice Executes a L2 call to L2Migrator to migrate sender deposit/reserve state from the L1 TicketBroker.\n     * @param _l1Addr Address migrating from L1\n     * @param _l2Addr Address to use on L2\n     * @param _sig Optional EIP-712 signature over a payload that includes _l1Addr and _l2Addr\n     * @param _maxGas Gas limit for L2 execution\n     * @param _gasPriceBid Gas price bid for L2 execution\n     * @param _maxSubmissionCost Max ETH to pay for retryable ticket base submission fee\n     */\n    function migrateSender(\n        address _l1Addr,\n        address _l2Addr,\n        bytes memory _sig,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost\n    ) external payable whenNotPaused {\n        // Authorization\n        // Either msg.sender == _l1Addr OR signer for _sig == _l1Addr\n        requireValidMigration(\n            _l1Addr,\n            _l2Addr,\n            keccak256(abi.encode(MIGRATE_SENDER_TYPE_HASH, _l1Addr, _l2Addr)),\n            _sig\n        );\n\n        (\n            bytes memory data,\n            MigrateSenderParams memory params\n        ) = getMigrateSenderParams(_l1Addr, _l2Addr);\n\n        // We do not prevent migration replays here to minimize L1 gas costs\n        // The L2Migrator is responsible for rejecting migration replays\n\n        uint256 seqNo = sendTxToL2(\n            l2MigratorAddr,\n            _l2Addr, // Refund to the L2 address\n            _maxSubmissionCost,\n            _maxGas,\n            _gasPriceBid,\n            data\n        );\n\n        emit MigrateSenderInitiated(seqNo, params);\n    }\n\n    /**\n     * @notice Executes a L2 call to send ETH from the L1BridgeMinter to the L2Migrator.\n     * @dev Anyone can call this function.\n     * @param _maxGas Gas limit for L2 execution\n     * @param _gasPriceBid Gas price bid for L2 execution\n     * @param _maxSubmissionCost Max ETH to pay for retryable ticket base submission fee\n     */\n    function migrateETH(\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost\n    ) external payable whenNotPaused {\n        uint256 amount = IBridgeMinter(bridgeMinterAddr)\n            .withdrawETHToL1Migrator();\n\n        // Any ETH refunded to the L2 alias of this contract can be used for\n        // other cross-chain txs sent by this contract.\n        // The retryable ticket created will not be cancellable since this contract\n        // currently does not support cross-chain txs to call ArbRetryableTx.cancel().\n        // Regarding the comment below on this contract receiving refunds:\n        // msg.sender also cannot be the address to receive refunds as beneficiary because otherwise\n        // msg.sender could cancel the ticket before it is executed on L2 to receive the L2 call value.\n        sendTxToL2(\n            l2MigratorAddr,\n            address(this), // L2 alias of this contract will receive refunds\n            msg.value,\n            amount,\n            _maxSubmissionCost,\n            _maxGas,\n            _gasPriceBid,\n            \"\"\n        );\n    }\n\n    /**\n     * @notice Executes a L2 call to send LPT from the L1BridgeMinter to the L2Migrator.\n     * @dev Anyone can call this function.\n     * @param _maxGas Gas limit for L2 execution\n     * @param _gasPriceBid Gas price bid for L2 execution\n     * @param _maxSubmissionCost Max ETH to pay for retryable ticket base submission fee\n     */\n    function migrateLPT(\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost\n    ) external payable whenNotPaused {\n        uint256 amount = IBridgeMinter(bridgeMinterAddr)\n            .withdrawLPTToL1Migrator();\n\n        // Approve L1LPTGateway to pull tokens\n        ApproveLike(tokenAddr).approve(l1LPTGatewayAddr, amount);\n        // Trigger cross-chain transfer with L1LPTGateway which will pull and escrow tokens\n        // Forward msg.value to outboundTransfer() to be used for cross-chain tx\n        IL1LPTGateway(l1LPTGatewayAddr).outboundTransfer{value: msg.value}(\n            tokenAddr,\n            l2MigratorAddr,\n            amount,\n            _maxGas,\n            _gasPriceBid,\n            abi.encode(_maxSubmissionCost, \"\")\n        );\n    }\n\n    /**\n     * @notice Pause the contract\n     * @dev Only callable by addresses with governor role\n     */\n    function pause() external onlyRole(GOVERNOR_ROLE) {\n        _pause();\n    }\n\n    /**\n     * @notice Unpause the contract\n     * @dev Only callable by addresses with governor role\n     */\n    function unpause() external onlyRole(GOVERNOR_ROLE) {\n        _unpause();\n    }\n\n    /**\n     * @notice Return L2 calldata and MigrateDelegatorParams to use for a L2 call on L2Migrator\n     * @param _l1Addr Address migrating from L1\n     * @param _l2Addr Address to use on L2\n     * @return data L2 calldata for finalizeMigrateDelegator() in L2Migrator\n     * @return params MigrateDelegatorParams to use for finalizeMigrateDelegator() in L2Migrator\n     */\n    function getMigrateDelegatorParams(address _l1Addr, address _l2Addr)\n        public\n        view\n        returns (bytes memory data, MigrateDelegatorParams memory params)\n    {\n        IBondingManager bondingManager = IBondingManager(bondingManagerAddr);\n\n        // pendingStake() ignores the _endRound arg\n        uint256 stake = bondingManager.pendingStake(_l1Addr, 0);\n        // pendingFees() ignores the _endRound arg\n        uint256 fees = bondingManager.pendingFees(_l1Addr, 0);\n        (\n            ,\n            ,\n            address delegateAddress,\n            uint256 delegatedAmount,\n            ,\n            ,\n\n        ) = bondingManager.getDelegator(_l1Addr);\n\n        // Construct params and L2 calldata for finalizeMigrateDelegator() on L2Migrator\n        params = MigrateDelegatorParams({\n            l1Addr: _l1Addr,\n            l2Addr: _l2Addr,\n            stake: stake,\n            delegatedStake: delegatedAmount,\n            fees: fees,\n            delegate: delegateAddress\n        });\n\n        data = abi.encodeWithSelector(\n            IL2Migrator.finalizeMigrateDelegator.selector,\n            params\n        );\n    }\n\n    /**\n     * @notice Return L2 calldata and MigrateSenderParams to use for a L2 call on L2Migrator\n     * @param _l1Addr Address migrating from L1\n     * @param _l2Addr Address to use on L2\n     * @return data L2 calldata for finalizeMigrateSender() in L2Migrator\n     * @return params MigrateSenderParams to use for finalizeMigrateSender() in L2Migrator\n     */\n    function getMigrateSenderParams(address _l1Addr, address _l2Addr)\n        public\n        view\n        returns (bytes memory data, MigrateSenderParams memory params)\n    {\n        ITicketBroker ticketBroker = ITicketBroker(ticketBrokerAddr);\n\n        (\n            ITicketBroker.Sender memory sender,\n            ITicketBroker.ReserveInfo memory reserveInfo\n        ) = ticketBroker.getSenderInfo(_l1Addr);\n\n        // Construct params and L2 calldata for finalizeMigrateSender() on L2Migrator\n        params = MigrateSenderParams({\n            l1Addr: _l1Addr,\n            l2Addr: _l2Addr,\n            deposit: sender.deposit,\n            reserve: reserveInfo.fundsRemaining\n        });\n\n        data = abi.encodeWithSelector(\n            IL2Migrator.finalizeMigrateSender.selector,\n            params\n        );\n    }\n\n    /**\n     * @notice Return L2 calldata and MigrateUnbondingLocksParams to use for a L2 call on L2Migrator\n     * @param _l1Addr Address migrating from L1\n     * @param _l2Addr Address to use on L2\n     * @param _unbondingLockIds IDs of unbonding locks in L1 BondingManager to migrate\n     * @return data L2 calldata for finalizeMigrateUnbondingLocks() in L2Migrator\n     * @return params MigrateUnbondingLocksParams to use for finalizeMigrateUnbondingLocks() in L2Migrator\n     */\n    function getMigrateUnbondingLocksParams(\n        address _l1Addr,\n        address _l2Addr,\n        uint256[] memory _unbondingLockIds\n    )\n        public\n        view\n        returns (bytes memory data, MigrateUnbondingLocksParams memory params)\n    {\n        IBondingManager bondingManager = IBondingManager(bondingManagerAddr);\n\n        uint256 total = 0;\n        for (uint256 i = 0; i < _unbondingLockIds.length; i++) {\n            (uint256 amount, ) = bondingManager.getDelegatorUnbondingLock(\n                _l1Addr,\n                _unbondingLockIds[i]\n            );\n\n            total += amount;\n        }\n\n        (, , address delegateAddress, , , , ) = bondingManager.getDelegator(\n            _l1Addr\n        );\n\n        // Construct params and L2 calldata for finalizeMigrateUnbondingLocks() on L2Migrator\n        params = MigrateUnbondingLocksParams({\n            l1Addr: _l1Addr,\n            l2Addr: _l2Addr,\n            total: total,\n            unbondingLockIds: _unbondingLockIds,\n            delegate: delegateAddress\n        });\n\n        data = abi.encodeWithSelector(\n            IL2Migrator.finalizeMigrateUnbondingLocks.selector,\n            params\n        );\n    }\n\n    function requireValidMigration(\n        address _l1Addr,\n        address _l2Addr,\n        bytes32 _structHash,\n        bytes memory _sig\n    ) internal view {\n        require(\n            _l2Addr != address(0),\n            \"L1Migrator#requireValidMigration: INVALID_L2_ADDR\"\n        );\n        require(\n            msg.sender == _l1Addr ||\n                recoverSigner(_structHash, _sig) == _l1Addr,\n            \"L1Migrator#requireValidMigration: FAIL_AUTH\"\n        );\n    }\n\n    function recoverSigner(bytes32 _structHash, bytes memory _sig)\n        internal\n        view\n        returns (address)\n    {\n        if (_sig.length == 0) {\n            return address(0);\n        }\n\n        bytes32 hash = _hashTypedDataV4(_structHash);\n        return ECDSA.recover(hash, _sig);\n    }\n}"
    },
    {
      "filename": "contracts/token/BridgeMinter.sol",
      "content": "pragma solidity ^0.5.11;\n\nimport \"../Manager.sol\";\n\ninterface IBridgeMinterToken {\n    function transfer(address _to, uint256 _amount) external;\n\n    function mint(address _to, uint256 _amount) external;\n\n    function transferOwnership(address _owner) external;\n\n    function balanceOf(address _addr) external view returns (uint256);\n}\n\ncontract BridgeMinter is Manager {\n    address public tokenAddr;\n    address public l1MigratorAddr;\n    address public l1LPTGatewayAddr;\n\n    modifier onlyL1Migrator() {\n        require(msg.sender == l1MigratorAddr, \"NOT_L1_MIGRATOR\");\n        _;\n    }\n\n    modifier onlyL1LPTGateway() {\n        require(msg.sender == l1LPTGatewayAddr, \"NOT_L1_LPT_GATEWAY\");\n        _;\n    }\n\n    constructor(\n        address _controller,\n        address _tokenAddr,\n        address _l1MigratorAddr,\n        address _l1LPTGatewayAddr\n    ) public Manager(_controller) {\n        tokenAddr = _tokenAddr;\n        l1MigratorAddr = _l1MigratorAddr;\n        l1LPTGatewayAddr = _l1LPTGatewayAddr;\n    }\n\n    /**\n     * @notice Set LPT address. Only callable by Controller owner\n     * @param _tokenAddr LPT address\n     */\n    function setToken(address _tokenAddr) external onlyControllerOwner {\n        tokenAddr = _tokenAddr;\n    }\n\n    /**\n     * @notice Set L1Migrator address. Only callable by Controller owner\n     * @param _l1MigratorAddr L1Migrator address\n     */\n    function setL1Migrator(address _l1MigratorAddr) external onlyControllerOwner {\n        l1MigratorAddr = _l1MigratorAddr;\n    }\n\n    /**\n     * @notice Set L1LPTGateway address. Only callable by Controller owner\n     * @param _l1LPTGatewayAddr L1LPTGateway address\n     */\n    function setL1LPTGateway(address _l1LPTGatewayAddr) external onlyControllerOwner {\n        l1LPTGatewayAddr = _l1LPTGatewayAddr;\n    }\n\n    /**\n     * @notice Migrate to a new Minter. Only callable by Controller owner\n     * @param _newMinterAddr New Minter address\n     */\n    function migrateToNewMinter(address _newMinterAddr) external onlyControllerOwner {\n        require(\n            _newMinterAddr != address(this) && _newMinterAddr != address(0),\n            \"BridgeMinter#migrateToNewMinter: INVALID_MINTER\"\n        );\n\n        IBridgeMinterToken token = IBridgeMinterToken(tokenAddr);\n        // Transfer ownership of token to new Minter\n        token.transferOwnership(_newMinterAddr);\n        // Transfer current Minter's LPT balance to new Minter\n        token.transfer(_newMinterAddr, token.balanceOf(address(this)));\n        // Transfer current Minter's ETH balance to new Minter\n        // call() should be safe from re-entrancy here because the Controller owner and _newMinterAddr are trusted\n        (bool ok, ) = _newMinterAddr.call.value(address(this).balance)(\"\");\n        require(ok, \"BridgeMinter#migrateToNewMinter: FAIL_CALL\");\n    }\n\n    /**\n     * @notice Send contract's ETH to L1Migrator. Only callable by L1Migrator\n     * @return Amount of ETH sent\n     */\n    function withdrawETHToL1Migrator() external onlyL1Migrator returns (uint256) {\n        uint256 balance = address(this).balance;\n\n        // call() should be safe from re-entrancy here because the L1Migrator and l1MigratorAddr are trusted\n        (bool ok, ) = l1MigratorAddr.call.value(address(this).balance)(\"\");\n        require(ok, \"BridgeMinter#withdrawETHToL1Migrator: FAIL_CALL\");\n\n        return balance;\n    }\n\n    /**\n     * @notice Send contract's LPT to L1Migrator. Only callable by L1Migrator\n     * @return Amount of LPT sent\n     */\n    function withdrawLPTToL1Migrator() external onlyL1Migrator returns (uint256) {\n        IBridgeMinterToken token = IBridgeMinterToken(tokenAddr);\n\n        uint256 balance = token.balanceOf(address(this));\n\n        token.transfer(l1MigratorAddr, balance);\n\n        return balance;\n    }\n\n    /**\n     * @notice Mint LPT to address. Only callable by L1LPTGateway\n     * @dev Relies on L1LPTGateway for minting rules\n     * @param _to Address to receive LPT\n     * @param _amount Amount of LPT to mint\n     */\n    function bridgeMint(address _to, uint256 _amount) external onlyL1LPTGateway {\n        IBridgeMinterToken(tokenAddr).mint(_to, _amount);\n    }\n\n    /**\n     * @notice Deposit ETH. Required for migrateToNewMinter() from older Minter implementation\n     */\n    function depositETH() external payable returns (bool) {\n        return true;\n    }\n\n    /**\n     * @notice Returns Controller address. Required for migrateToNewMinter() from older Minter implementation\n     * @return Controller address\n     */\n    function getController() public view returns (address) {\n        return address(controller);\n    }\n}"
    }
  ]
}