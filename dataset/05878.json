{
  "Title": "[M-02] Fully slashed transcoder can vote with 0 weight messing up the voting calculations",
  "Content": "\nIf a transcoder gets slashed fully he can still vote with 0 amount of `weight` making any other delegated user that wants to change his vote to subtract their `weight` amount from other delegators/transcoders.\n\n### Proof of Concept\n\nIn `BondingManager.sol` any transcoder can gets slashed by a specific percentage, and that specific transcoder gets resigned and that specific percentage gets deducted from his `bondedAmount`.<br>\n<https://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/bonding/BondingManager.sol#L394-L411>\n\nIf any `bondedAmount` will remain then the penalty will also gets subtracted from the `delegatedAmount`, if not, nothing happens.<br>\n<https://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/bonding/BondingManager.sol#L412-L417>\n\nAfter that the `penalty` gets burned and the fees gets paid to the finder, if that is the case.<br>\n<https://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/bonding/BondingManager.sol#L420-L440>\n\nThe problem relies in the fact that a fully slashed transcoder, even if it gets resigned, he is still seen as an active transcoder in the case of voting. Let's assume this case:\n\n*   A transcoder gets fully slashed and gets resigned from the transcoder pools, getting his `bondedAmount` to 0, but he still has `delegatedAmount` to his address since nothing happens this variable.<br>\n<https://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/bonding/BondingManager.sol#L402-L418>\n\n*   Transcoder vote a proposal and when his weighting gets calculated [here](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/f34a3a7e5a1d698d87d517fda698d48286310bee/contracts/governance/GovernorUpgradeable.sol#L581), it will use the `_getVotes` from `GovernorVotesUpgradeable.sol`.<br>\n<https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/f34a3a7e5a1d698d87d517fda698d48286310bee/contracts/governance/extensions/GovernorVotesUpgradeable.sol#L55-L61>\n\n*   `_getVotes` calls `getPastVotes` on `BondingVotes.sol` <https://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/bonding/BondingVotes.sol#L167-L170> which returns the amount of weight specific to this transcoder and as you can see, because the transcoder has a `bondedAmount` equal to 0, the first if statement will be true and 0 will be returned.<br>\n<https://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/bonding/BondingVotes.sol#L372-L373>\n\n*   0 weight will be passed into `_countVote` which will then be passed into `_handleVoteOverrides`.<br>\n<https://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/treasury/GovernorCountingOverridable.sol#L151>\n\n*   Then it will check if the caller is a transcoder, which will be true in our case, because nowhere in the `slashTranscoder` function, or any other function the transcoder `delegateAddress` gets changed, so this if statement will be true <https://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/treasury/GovernorCountingOverridable.sol#L182-L184>, which will try to deduct the weight from any previous delegators.<br>\n<https://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/treasury/GovernorCountingOverridable.sol#L184-L189>\n\n*   If any delegator already overridden any amount this subtraction would revert, but if that is not the case, 0 weight will be returned, which is then used to vote `for`, `against` , `abstain`, but since 0 weight is passed no changed will be made.\n\n*   Now the big problem arise, if any delegator that delegated their votes to this specific transcoder want to change their vote, when his weight gets calculated, `delegatorCumulativeStakeAt` gets called <https://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/bonding/BondingVotes.sol#L459-L487> which will return most of the time his `bondedAmount`, amount which is greater than 0, since he didn't unbound.\n\n*   Because of that when `_handleVoteOverrides` gets called in `_countVote`, to override the vote, this if statement will be true, since the transcoder voted already, but with 0 weight <https://github.com/code-423n4/2023-08-livepeer/blob/a3d801fa4690119b6f96aeb5508e58d752bda5bc/contracts/treasury/GovernorCountingOverridable.sol#L195> and the delegator weight gets subtracted from the support that the transcoder used in his vote.\n\n*   The system in this case expects the transcoder to vote with the whole `delegatedAmount`, which will make the subtraction viable, since the weight of the delegator should be included in the full `delegatedAmount` of that specific transcoder, but since the transcoder voted with 0 weight, the subtraction would be done from other delegators/transcoders votes.\n\n*   Also this can be abused by a transcoder by voting a category which he knows will not get a lot of votes, if let's say a transcoder used his 0 weight to vote for `abstain` and every other voter will vote on `for` or `against`, every time one of his delegators want to change the vote the subtraction can revert, which will force those delegators out of the vote, until they will change their transcoder.\n\n### Recommended Mitigation Steps\n\nIf a transcoder gets fully slashed and resigned, delete his address from `delegateAddress` so he will not appear as a transcoder in the mechanism of counting the votes. If he still wants to participate in the system he can act as a delegator to another transcoder. Another solution would be to not let 0 weight votes happen, since they don't modify the vote state at all.\n\n### Assessed type\n\nGovernance\n\n**[victorges (Livepeer) confirmed and commented](https://github.com/code-423n4/2023-08-livepeer-findings/issues/194#issuecomment-1720133531):**\n > Slashing is turned off in the protocol, so this specific issue is not that important. It did point towards an issue in `BondingVotes` though in the way that the `getBondingState` function checks if transcoder is a transcoder or not and defaults to 0 when `bondedAmount` is `0`. There are other ways that this logic can be triggered (not through `slashTranscoder`) that can show inconsistencies as well, so I'm flagging this as valid for the underlying issue that it hints to, even though it does not describe a realistic scenario about how this issue could happen.\n\n**[hickuphh3 (judge) commented](https://github.com/code-423n4/2023-08-livepeer-findings/issues/194#issuecomment-1722731950):**\n > I found the POC hard to follow. A coded instance would have tremendously helped, but what I gather is:\n> - fully slashed transcoder that votes will do so with 0 weight.\n> - any delegator that delegated their votes to this specific transcoder intending to change their vote may face an issue with sub overflow because `_handleVoteOverrides()` uses the slashed transcoder's `bondedAmount` instead of the 0 weight.\n> so this issue seems valid, although its premise is that the slashing functionality is in place.\n> \n> The README did not indicate that slashing was turned off, though I see it's mentioned a couple of times in the Discord channel. Should've been added in the \"Known caveats / limitations\" section.\n> \n> Hence, IMO it isn't entirely fair to wardens if I invalidate their issue because they weren't aware of this fact.\n> \n> Leaning towards a downgrade to M because of the external requirement of the active slashing mechanism, but am open to discussion.\n\n**[hickuphh3 (judge) decreased severity to Medium](https://github.com/code-423n4/2023-08-livepeer-findings/issues/194#issuecomment-1723153394)**\n\n**[hickuphh3 (judge) commented](https://github.com/code-423n4/2023-08-livepeer-findings/issues/194#issuecomment-1732530336):**\n > Revisiting this issue, IMO it's unreasonable to expect the sponsor to explicitly list out all the gotchas / limitations of the protocol. Some will only pop into mind through discussions with wardens, which seemed to be the case here when the slashing deprecation was mentioned a couple of times in the Discord channel.\n> \n> On the flip side, the fact remains that the slashing mechanism is part of the audit scope, and was counted towards the sLOC, plus the points I raised above. There wasn't an indication in the code that slashing had been deprecated.\n> \n> It's a difficult decision here, considering the different parties' POV. There could be some wardens who didn't submit issues related to slashing because of what was brought up in the Discord channel, and those that did (as one can see referenced above) because they didn't monitor the channel.\n\n**[victorges (Livepeer) mitigated]():**\n > https://github.com/livepeer/protocol/pull/625\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-08-livepeer",
  "Code": [
    {
      "filename": "contracts/bonding/BondingManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"../ManagerProxyTarget.sol\";\nimport \"./IBondingManager.sol\";\nimport \"../libraries/SortedDoublyLL.sol\";\nimport \"../libraries/MathUtils.sol\";\nimport \"../libraries/PreciseMathUtils.sol\";\nimport \"./libraries/EarningsPool.sol\";\nimport \"./libraries/EarningsPoolLIP36.sol\";\nimport \"../token/ILivepeerToken.sol\";\nimport \"../token/IMinter.sol\";\nimport \"../rounds/IRoundsManager.sol\";\nimport \"../snapshots/IMerkleSnapshot.sol\";\nimport \"./IBondingVotes.sol\";\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n/**\n * @title BondingManager\n * @notice Manages bonding, transcoder and rewards/fee accounting related operations of the Livepeer protocol\n */\ncontract BondingManager is ManagerProxyTarget, IBondingManager {\n    using SafeMath for uint256;\n    using SortedDoublyLL for SortedDoublyLL.Data;\n    using EarningsPool for EarningsPool.Data;\n    using EarningsPoolLIP36 for EarningsPool.Data;\n\n    // Constants\n    // Occurances are replaced at compile time\n    // and computed to a single value if possible by the optimizer\n    uint256 constant MAX_FUTURE_ROUND = 2**256 - 1;\n\n    // Time between unbonding and possible withdrawl in rounds\n    uint64 public unbondingPeriod;\n\n    // Represents a transcoder's current state\n    struct Transcoder {\n        uint256 lastRewardRound; // Last round that the transcoder called reward\n        uint256 rewardCut; // % of reward paid to transcoder by a delegator\n        uint256 feeShare; // % of fees paid to delegators by transcoder\n        mapping(uint256 => EarningsPool.Data) earningsPoolPerRound; // Mapping of round => earnings pool for the round\n        uint256 lastActiveStakeUpdateRound; // Round for which the stake was last updated while the transcoder is active\n        uint256 activationRound; // Round in which the transcoder became active - 0 if inactive\n        uint256 deactivationRound; // Round in which the transcoder will become inactive\n        uint256 activeCumulativeRewards; // The transcoder's cumulative rewards that are active in the current round\n        uint256 cumulativeRewards; // The transcoder's cumulative rewards (earned via the its active staked rewards and its reward cut).\n        uint256 cumulativeFees; // The transcoder's cumulative fees (earned via the its active staked rewards and its fee share)\n        uint256 lastFeeRound; // Latest round in which the transcoder received fees\n    }\n\n    // The various states a transcoder can be in\n    enum TranscoderStatus {\n        NotRegistered,\n        Registered\n    }\n\n    // Represents a delegator's current state\n    struct Delegator {\n        uint256 bondedAmount; // The amount of bonded tokens\n        uint256 fees; // The amount of fees collected\n        address delegateAddress; // The address delegated to\n        uint256 delegatedAmount; // The amount of tokens delegated to the delegator\n        uint256 startRound; // The round the delegator transitions to bonded phase and is delegated to someone\n        uint256 lastClaimRound; // The last round during which the delegator claimed its earnings\n        uint256 nextUnbondingLockId; // ID for the next unbonding lock created\n        mapping(uint256 => UnbondingLock) unbondingLocks; // Mapping of unbonding lock ID => unbonding lock\n    }\n\n    // The various states a delegator can be in\n    enum DelegatorStatus {\n        Pending,\n        Bonded,\n        Unbonded\n    }\n\n    // Represents an amount of tokens that are being unbonded\n    struct UnbondingLock {\n        uint256 amount; // Amount of tokens being unbonded\n        uint256 withdrawRound; // Round at which unbonding period is over and tokens can be withdrawn\n    }\n\n    // Keep track of the known transcoders and delegators\n    mapping(address => Delegator) private delegators;\n    mapping(address => Transcoder) private transcoders;\n\n    // The total active stake (sum of the stake of active set members) for the current round\n    uint256 public currentRoundTotalActiveStake;\n    // The total active stake (sum of the stake of active set members) for the next round\n    uint256 public nextRoundTotalActiveStake;\n\n    // The transcoder pool is used to keep track of the transcoders that are eligible for activation.\n    // The pool keeps track of the pending active set in round N and the start of round N + 1 transcoders\n    // in the pool are locked into the active set for round N + 1\n    SortedDoublyLL.Data private transcoderPool;\n\n    // The % of newly minted rewards to be routed to the treasury. Represented as a PreciseMathUtils percPoint value.\n    uint256 public treasuryRewardCutRate;\n    // The value for `treasuryRewardCutRate` to be set on the next round initialization.\n    uint256 public nextRoundTreasuryRewardCutRate;\n\n    // If the balance of the treasury in LPT is above this value, automatic treasury contributions will halt.\n    uint256 public treasuryBalanceCeiling;\n\n    // Check if sender is TicketBroker\n    modifier onlyTicketBroker() {\n        _onlyTicketBroker();\n        _;\n    }\n\n    // Check if sender is RoundsManager\n    modifier onlyRoundsManager() {\n        _onlyRoundsManager();\n        _;\n    }\n\n    // Check if sender is Verifier\n    modifier onlyVerifier() {\n        _onlyVerifier();\n        _;\n    }\n\n    // Check if current round is initialized\n    modifier currentRoundInitialized() {\n        _currentRoundInitialized();\n        _;\n    }\n\n    // Automatically claim earnings from lastClaimRound through the current round\n    modifier autoClaimEarnings(address _delegator) {\n        _autoClaimEarnings(_delegator);\n        _;\n    }\n\n    modifier autoCheckpoint(address _account) {\n        _;\n        _checkpointBondingState(_account, delegators[_account], transcoders[_account]);\n    }\n\n    /**\n     * @notice BondingManager constructor. Only invokes constructor of base Manager contract with provided Controller address\n     * @dev This constructor will not initialize any state variables besides `controller`. The following setter functions\n     * should be used to initialize state variables post-deployment:\n     * - setUnbondingPeriod()\n     * - setNumActiveTranscoders()\n     * - setMaxEarningsClaimsRounds()\n     * @param _controller Address of Controller that this contract will be registered with\n     */\n    constructor(address _controller) Manager(_controller) {}\n\n    /**\n     * @notice Set unbonding period. Only callable by Controller owner\n     * @param _unbondingPeriod Rounds between unbonding and possible withdrawal\n     */\n    function setUnbondingPeriod(uint64 _unbondingPeriod) external onlyControllerOwner {\n        unbondingPeriod = _unbondingPeriod;\n\n        emit ParameterUpdate(\"unbondingPeriod\");\n    }\n\n    /**\n     * @notice Set treasury reward cut rate. Only callable by Controller owner. Notice that the change will only be\n     * effective on the next round.\n     * @param _cutRate Percentage of newly minted rewards to route to the treasury. Must be a valid PreciseMathUtils\n     * percentage (<100% specified with 27-digits precision).\n     */\n    function setTreasuryRewardCutRate(uint256 _cutRate) external onlyControllerOwner {\n        _setTreasuryRewardCutRate(_cutRate);\n    }\n\n    /**\n     * @notice Set treasury balance ceiling. Only callable by Controller owner\n     * @param _ceiling Balance at which treasury reward contributions should halt. Specified in LPT fractional units\n     * (18-digit precision).\n     */\n    function setTreasuryBalanceCeiling(uint256 _ceiling) external onlyControllerOwner {\n        treasuryBalanceCeiling = _ceiling;\n\n        emit ParameterUpdate(\"treasuryBalanceCeiling\");\n    }\n\n    /**\n     * @notice Set maximum number of active transcoders. Only callable by Controller owner\n     * @param _numActiveTranscoders Number of active transcoders\n     */\n    function setNumActiveTranscoders(uint256 _numActiveTranscoders) external onlyControllerOwner {\n        transcoderPool.setMaxSize(_numActiveTranscoders);\n\n        emit ParameterUpdate(\"numActiveTranscoders\");\n    }\n\n    /**\n     * @notice Sets commission rates as a transcoder and if the caller is not in the transcoder pool tries to add it\n     * @dev Percentages are represented as numerators of fractions over MathUtils.PERC_DIVISOR\n     * @param _rewardCut % of reward paid to transcoder by a delegator\n     * @param _feeShare % of fees paid to delegators by a transcoder\n     */\n    function transcoder(uint256 _rewardCut, uint256 _feeShare) external {\n        transcoderWithHint(_rewardCut, _feeShare, address(0), address(0));\n    }\n\n    /**\n     * @notice Delegate stake towards a specific address\n     * @param _amount The amount of tokens to stake\n     * @param _to The address of the transcoder to stake towards\n     */\n    function bond(uint256 _amount, address _to) external {\n        bondWithHint(_amount, _to, address(0), address(0), address(0), address(0));\n    }\n\n    /**\n     * @notice Unbond an amount of the delegator's bonded stake\n     * @param _amount Amount of tokens to unbond\n     */\n    function unbond(uint256 _amount) external {\n        unbondWithHint(_amount, address(0), address(0));\n    }\n\n    /**\n     * @notice Rebond tokens for an unbonding lock to a delegator's current delegate while a delegator is in the Bonded or Pending status\n     * @param _unbondingLockId ID of unbonding lock to rebond with\n     */\n    function rebond(uint256 _unbondingLockId) external {\n        rebondWithHint(_unbondingLockId, address(0), address(0));\n    }\n\n    /**\n     * @notice Rebond tokens for an unbonding lock to a delegate while a delegator is in the Unbonded status\n     * @param _to Address of delegate\n     * @param _unbondingLockId ID of unbonding lock to rebond with\n     */\n    function rebondFromUnbonded(address _to, uint256 _unbondingLockId) external {\n        rebondFromUnbondedWithHint(_to, _unbondingLockId, address(0), address(0));\n    }\n\n    /**\n     * @notice Checkpoints the bonding state for a given account.\n     * @dev This is to allow checkpointing an account that has an inconsistent checkpoint with its current state.\n     * @param _account The account to make the checkpoint for\n     */\n    function checkpointBondingState(address _account) external {\n        _checkpointBondingState(_account, delegators[_account], transcoders[_account]);\n    }\n\n    /**\n     * @notice Withdraws tokens for an unbonding lock that has existed through an unbonding period\n     * @param _unbondingLockId ID of unbonding lock to withdraw with\n     */\n    function withdrawStake(uint256 _unbondingLockId) external whenSystemNotPaused currentRoundInitialized {\n        Delegator storage del = delegators[msg.sender];\n        UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];\n\n        require(isValidUnbondingLock(msg.sender, _unbondingLockId), \"invalid unbonding lock ID\");\n        require(\n            lock.withdrawRound <= roundsManager().currentRound(),\n            \"withdraw round must be before or equal to the current round\"\n        );\n\n        uint256 amount = lock.amount;\n        uint256 withdrawRound = lock.withdrawRound;\n        // Delete unbonding lock\n        delete del.unbondingLocks[_unbondingLockId];\n\n        // Tell Minter to transfer stake (LPT) to the delegator\n        minter().trustedTransferTokens(msg.sender, amount);\n\n        emit WithdrawStake(msg.sender, _unbondingLockId, amount, withdrawRound);\n    }\n\n    /**\n     * @notice Withdraws fees to the caller\n     */\n    function withdrawFees(address payable _recipient, uint256 _amount)\n        external\n        whenSystemNotPaused\n        currentRoundInitialized\n        autoClaimEarnings(msg.sender)\n    {\n        require(_recipient != address(0), \"invalid recipient\");\n        uint256 fees = delegators[msg.sender].fees;\n        require(fees >= _amount, \"insufficient fees to withdraw\");\n        delegators[msg.sender].fees = fees.sub(_amount);\n\n        // Tell Minter to transfer fees (ETH) to the address\n        minter().trustedWithdrawETH(_recipient, _amount);\n\n        emit WithdrawFees(msg.sender, _recipient, _amount);\n    }\n\n    /**\n     * @notice Mint token rewards for an active transcoder and its delegators\n     */\n    function reward() external {\n        rewardWithHint(address(0), address(0));\n    }\n\n    /**\n     * @notice Update transcoder's fee pool. Only callable by the TicketBroker\n     * @param _transcoder Transcoder address\n     * @param _fees Fees to be added to the fee pool\n     */\n    function updateTranscoderWithFees(\n        address _transcoder,\n        uint256 _fees,\n        uint256 _round\n    ) external whenSystemNotPaused onlyTicketBroker {\n        // Silence unused param compiler warning\n        _round;\n\n        require(isRegisteredTranscoder(_transcoder), \"transcoder must be registered\");\n\n        uint256 currentRound = roundsManager().currentRound();\n\n        Transcoder storage t = transcoders[_transcoder];\n\n        uint256 lastRewardRound = t.lastRewardRound;\n        uint256 activeCumulativeRewards = t.activeCumulativeRewards;\n\n        // LIP-36: Add fees for the current round instead of '_round'\n        // https://github.com/livepeer/LIPs/issues/35#issuecomment-673659199\n        EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[currentRound];\n        EarningsPool.Data memory prevEarningsPool = latestCumulativeFactorsPool(t, currentRound.sub(1));\n\n        // if transcoder hasn't called 'reward()' for '_round' its 'transcoderFeeShare', 'transcoderRewardCut' and 'totalStake'\n        // on the 'EarningsPool' for '_round' would not be initialized and the fee distribution wouldn't happen as expected\n        // for cumulative fee calculation this would result in division by zero.\n        if (currentRound > lastRewardRound) {\n            earningsPool.setCommission(t.rewardCut, t.feeShare);\n\n            uint256 lastUpdateRound = t.lastActiveStakeUpdateRound;\n            if (lastUpdateRound < currentRound) {\n                earningsPool.setStake(t.earningsPoolPerRound[lastUpdateRound].totalStake);\n            }\n\n            // If reward() has not been called yet in the current round, then the transcoder's activeCumulativeRewards has not\n            // yet been set in for the round. When the transcoder calls reward() its activeCumulativeRewards will be set to its\n            // current cumulativeRewards. So, we can just use the transcoder's cumulativeRewards here because this will become\n            // the transcoder's activeCumulativeRewards if it calls reward() later on in the current round\n            activeCumulativeRewards = t.cumulativeRewards;\n        }\n\n        uint256 totalStake = earningsPool.totalStake;\n        if (prevEarningsPool.cumulativeRewardFactor == 0 && lastRewardRound == currentRound) {\n            // if transcoder called reward for 'currentRound' but not for 'currentRound - 1' (missed reward call)\n            // retroactively calculate what its cumulativeRewardFactor would have been for 'currentRound - 1' (cfr. previous lastRewardRound for transcoder)\n            // based on rewards for currentRound\n            IMinter mtr = minter();\n            uint256 rewards = PreciseMathUtils.percOf(\n                mtr.currentMintableTokens().add(mtr.currentMintedTokens()),\n                totalStake,\n                currentRoundTotalActiveStake\n            );\n\n            // Deduct what would have been the treasury rewards\n            uint256 treasuryRewards = MathUtils.percOf(rewards, treasuryRewardCutRate);\n            rewards = rewards.sub(treasuryRewards);\n\n            uint256 transcoderCommissionRewards = MathUtils.percOf(rewards, earningsPool.transcoderRewardCut);\n            uint256 delegatorsRewards = rewards.sub(transcoderCommissionRewards);\n\n            prevEarningsPool.cumulativeRewardFactor = PreciseMathUtils.percOf(\n                earningsPool.cumulativeRewardFactor,\n                totalStake,\n                delegatorsRewards.add(totalStake)\n            );\n        }\n\n        uint256 delegatorsFees = MathUtils.percOf(_fees, earningsPool.transcoderFeeShare);\n        uint256 transcoderCommissionFees = _fees.sub(delegatorsFees);\n        // Calculate the fees earned by the transcoder's earned rewards\n        uint256 transcoderRewardStakeFees = PreciseMathUtils.percOf(\n            delegatorsFees,\n            activeCumulativeRewards,\n            totalStake\n        );\n        // Track fees earned by the transcoder based on its earned rewards and feeShare\n        t.cumulativeFees = t.cumulativeFees.add(transcoderRewardStakeFees).add(transcoderCommissionFees);\n        // Update cumulative fee factor with new fees\n        // The cumulativeFeeFactor is used to calculate fees for all delegators including the transcoder (self-delegated)\n        // Note that delegatorsFees includes transcoderRewardStakeFees, but no delegator will claim that amount using\n        // the earnings claiming algorithm and instead that amount is accounted for in the transcoder's cumulativeFees field\n        earningsPool.updateCumulativeFeeFactor(prevEarningsPool, delegatorsFees);\n\n        t.lastFeeRound = currentRound;\n    }\n\n    /**\n     * @notice Slash a transcoder. Only callable by the Verifier\n     * @param _transcoder Transcoder address\n     * @param _finder Finder that proved a transcoder violated a slashing condition. Null address if there is no finder\n     * @param _slashAmount Percentage of transcoder bond to be slashed\n     * @param _finderFee Percentage of penalty awarded to finder. Zero if there is no finder\n     */\n    function slashTranscoder(\n        address _transcoder,\n        address _finder,\n        uint256 _slashAmount,\n        uint256 _finderFee\n    ) external whenSystemNotPaused onlyVerifier autoClaimEarnings(_transcoder) autoCheckpoint(_transcoder) {\n        Delegator storage del = delegators[_transcoder];\n\n        if (del.bondedAmount > 0) {\n            uint256 penalty = MathUtils.percOf(delegators[_transcoder].bondedAmount, _slashAmount);\n\n            // If active transcoder, resign it\n            if (transcoderPool.contains(_transcoder)) {\n                resignTranscoder(_transcoder);\n            }\n\n            // Decrease bonded stake\n            del.bondedAmount = del.bondedAmount.sub(penalty);\n\n            // If still bonded decrease delegate's delegated amount\n            if (delegatorStatus(_transcoder) == DelegatorStatus.Bonded) {\n                delegators[del.delegateAddress].delegatedAmount = delegators[del.delegateAddress].delegatedAmount.sub(\n                    penalty\n                );\n            }\n\n            // Account for penalty\n            uint256 burnAmount = penalty;\n\n            // Award finder fee if there is a finder address\n            if (_finder != address(0)) {\n                uint256 finderAmount = MathUtils.percOf(penalty, _finderFee);\n                minter().trustedTransferTokens(_finder, finderAmount);\n\n                // Minter burns the slashed funds - finder reward\n                minter().trustedBurnTokens(burnAmount.sub(finderAmount));\n\n                emit TranscoderSlashed(_transcoder, _finder, penalty, finderAmount);\n            } else {\n                // Minter burns the slashed funds\n                minter().trustedBurnTokens(burnAmount);\n\n                emit TranscoderSlashed(_transcoder, address(0), penalty, 0);\n            }\n        } else {\n            emit TranscoderSlashed(_transcoder, _finder, 0, 0);\n        }\n    }\n\n    /**\n     * @notice Claim token pools shares for a delegator from its lastClaimRound through the end round\n     * @param _endRound The last round for which to claim token pools shares for a delegator\n     */\n    function claimEarnings(uint256 _endRound)\n        external\n        whenSystemNotPaused\n        currentRoundInitialized\n        autoCheckpoint(msg.sender)\n    {\n        // Silence unused param compiler warning\n        _endRound;\n\n        _autoClaimEarnings(msg.sender);\n    }\n\n    /**\n     * @notice Called during round initialization to set the total active stake for the round. Only callable by the RoundsManager\n     */\n    function setCurrentRoundTotalActiveStake() external onlyRoundsManager {\n        currentRoundTotalActiveStake = nextRoundTotalActiveStake;\n\n        if (nextRoundTreasuryRewardCutRate != treasuryRewardCutRate) {\n            treasuryRewardCutRate = nextRoundTreasuryRewardCutRate;\n            // The treasury cut rate changes in a delayed fashion so we want to emit the parameter update event here\n            emit ParameterUpdate(\"treasuryRewardCutRate\");\n        }\n\n        bondingVotes().checkpointTotalActiveStake(currentRoundTotalActiveStake, roundsManager().currentRound());\n    }\n\n    /**\n     * @notice Sets commission rates as a transcoder and if the caller is not in the transcoder pool tries to add it using an optional list hint\n     * @dev Percentages are represented as numerators of fractions over MathUtils.PERC_DIVISOR. If the caller is going to be added to the pool, the\n     * caller can provide an optional hint for the insertion position in the pool via the `_newPosPrev` and `_newPosNext` params. A linear search will\n     * be executed starting at the hint to find the correct position - in the best case, the hint is the correct position so no search is executed.\n     * See SortedDoublyLL.sol for details on list hints\n     * @param _rewardCut % of reward paid to transcoder by a delegator\n     * @param _feeShare % of fees paid to delegators by a transcoder\n     * @param _newPosPrev Address of previous transcoder in pool if the caller joins the pool\n     * @param _newPosNext Address of next transcoder in pool if the caller joins the pool\n     */\n    function transcoderWithHint(\n        uint256 _rewardCut,\n        uint256 _feeShare,\n        address _newPosPrev,\n        address _newPosNext\n    ) public whenSystemNotPaused currentRoundInitialized {\n        require(!roundsManager().currentRoundLocked(), \"can't update transcoder params, current round is locked\");\n        require(MathUtils.validPerc(_rewardCut), \"invalid rewardCut percentage\");\n        require(MathUtils.validPerc(_feeShare), \"invalid feeShare percentage\");\n        require(isRegisteredTranscoder(msg.sender), \"transcoder must be registered\");\n\n        Transcoder storage t = transcoders[msg.sender];\n        uint256 currentRound = roundsManager().currentRound();\n\n        require(\n            !isActiveTranscoder(msg.sender) || t.lastRewardRound == currentRound,\n            \"caller can't be active or must have already called reward for the current round\"\n        );\n\n        t.rewardCut = _rewardCut;\n        t.feeShare = _feeShare;\n\n        if (!transcoderPool.contains(msg.sender)) {\n            tryToJoinActiveSet(\n                msg.sender,\n                delegators[msg.sender].delegatedAmount,\n                currentRound.add(1),\n                _newPosPrev,\n                _newPosNext\n            );\n        }\n\n        emit TranscoderUpdate(msg.sender, _rewardCut, _feeShare);\n    }\n\n    /**\n     * @notice Delegates stake \"on behalf of\" another address towards a specific address\n     * and updates the transcoder pool using optional list hints if needed\n     * @dev If the caller is decreasing the stake of its old delegate in the transcoder pool, the caller can provide an optional hint\n     * for the insertion position of the old delegate via the `_oldDelegateNewPosPrev` and `_oldDelegateNewPosNext` params.\n     * If the caller is delegating to a delegate that is in the transcoder pool, the caller can provide an optional hint for the\n     * insertion position of the delegate via the `_currDelegateNewPosPrev` and `_currDelegateNewPosNext` params.\n     * In both cases, a linear search will be executed starting at the hint to find the correct position. In the best case, the hint\n     * is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints\n     * @param _amount The amount of tokens to stake.\n     * @param _owner The address of the owner of the bond\n     * @param _to The address of the transcoder to stake towards\n     * @param _oldDelegateNewPosPrev The address of the previous transcoder in the pool for the old delegate\n     * @param _oldDelegateNewPosNext The address of the next transcoder in the pool for the old delegate\n     * @param _currDelegateNewPosPrev The address of the previous transcoder in the pool for the current delegate\n     * @param _currDelegateNewPosNext The address of the next transcoder in the pool for the current delegate\n     */\n    function bondForWithHint(\n        uint256 _amount,\n        address _owner,\n        address _to,\n        address _oldDelegateNewPosPrev,\n        address _oldDelegateNewPosNext,\n        address _currDelegateNewPosPrev,\n        address _currDelegateNewPosNext\n    ) public whenSystemNotPaused currentRoundInitialized {\n        // the `autoClaimEarnings` modifier has been replaced with its internal function as a `Stack too deep` error work-around\n        _autoClaimEarnings(_owner);\n        Delegator storage del = delegators[_owner];\n\n        uint256 currentRound = roundsManager().currentRound();\n        // Amount to delegate\n        uint256 delegationAmount = _amount;\n        // Current delegate\n        address currentDelegate = del.delegateAddress;\n        // Current bonded amount\n        uint256 currentBondedAmount = del.bondedAmount;\n\n        // Requirements for a third party caller that is not the L2Migrator\n        if (msg.sender != _owner && msg.sender != l2Migrator()) {\n            // Does not trigger self-delegation\n            // Does not change the delegate if it is already non-null\n            if (delegatorStatus(_owner) == DelegatorStatus.Unbonded) {\n                require(_to != _owner, \"INVALID_DELEGATE\");\n            } else {\n                require(currentDelegate == _to, \"INVALID_DELEGATE_CHANGE\");\n            }\n        }\n\n        if (delegatorStatus(_owner) == DelegatorStatus.Unbonded) {\n            // New delegate\n            // Set start round\n            // Don't set start round if delegator is in pending state because the start round would not change\n            del.startRound = currentRound.add(1);\n            // Unbonded state = no existing delegate and no bonded stake\n            // Thus, delegation amount = provided amount\n        } else if (currentBondedAmount > 0 && currentDelegate != _to) {\n            // A registered transcoder cannot delegate its bonded stake toward another address\n            // because it can only be delegated toward itself\n            // In the future, if delegation towards another registered transcoder as an already\n            // registered transcoder becomes useful (i.e. for transitive delegation), this restriction\n            // could be removed\n            require(!isRegisteredTranscoder(_owner), \"registered transcoders can't delegate towards other addresses\");\n            // Changing delegate\n            // Set start round\n            del.startRound = currentRound.add(1);\n            // Update amount to delegate with previous delegation amount\n            delegationAmount = delegationAmount.add(currentBondedAmount);\n\n            decreaseTotalStake(currentDelegate, currentBondedAmount, _oldDelegateNewPosPrev, _oldDelegateNewPosNext);\n        }\n\n        {\n            Transcoder storage newDelegate = transcoders[_to];\n            EarningsPool.Data storage currPool = newDelegate.earningsPoolPerRound[currentRound];\n            if (currPool.cumulativeRewardFactor == 0) {\n                currPool.cumulativeRewardFactor = cumulativeFactorsPool(newDelegate, newDelegate.lastRewardRound)\n                    .cumulativeRewardFactor;\n            }\n            if (currPool.cumulativeFeeFactor == 0) {\n                currPool.cumulativeFeeFactor = cumulativeFactorsPool(newDelegate, newDelegate.lastFeeRound)\n                    .cumulativeFeeFactor;\n            }\n        }\n\n        // cannot delegate to someone without having bonded stake\n        require(delegationAmount > 0, \"delegation amount must be greater than 0\");\n        // Update delegate\n        del.delegateAddress = _to;\n        // Update bonded amount\n        del.bondedAmount = currentBondedAmount.add(_amount);\n\n        increaseTotalStake(_to, delegationAmount, _currDelegateNewPosPrev, _currDelegateNewPosNext);\n\n        if (_amount > 0) {\n            // Transfer the LPT to the Minter\n            livepeerToken().transferFrom(msg.sender, address(minter()), _amount);\n        }\n\n        emit Bond(_to, currentDelegate, _owner, _amount, del.bondedAmount);\n\n        // the `autoCheckpoint` modifier has been replaced with its internal function as a `Stack too deep` error work-around\n        _checkpointBondingState(_owner, del, transcoders[_owner]);\n    }\n\n    /**\n     * @notice Delegates stake towards a specific address and updates the transcoder pool using optional list hints if needed\n     * @dev If the caller is decreasing the stake of its old delegate in the transcoder pool, the caller can provide an optional hint\n     * for the insertion position of the old delegate via the `_oldDelegateNewPosPrev` and `_oldDelegateNewPosNext` params.\n     * If the caller is delegating to a delegate that is in the transcoder pool, the caller can provide an optional hint for the\n     * insertion position of the delegate via the `_currDelegateNewPosPrev` and `_currDelegateNewPosNext` params.\n     * In both cases, a linear search will be executed starting at the hint to find the correct position. In the best case, the hint\n     * is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints\n     * @param _amount The amount of tokens to stake.\n     * @param _to The address of the transcoder to stake towards\n     * @param _oldDelegateNewPosPrev The address of the previous transcoder in the pool for the old delegate\n     * @param _oldDelegateNewPosNext The address of the next transcoder in the pool for the old delegate\n     * @param _currDelegateNewPosPrev The address of the previous transcoder in the pool for the current delegate\n     * @param _currDelegateNewPosNext The address of the next transcoder in the pool for the current delegate\n     */\n    function bondWithHint(\n        uint256 _amount,\n        address _to,\n        address _oldDelegateNewPosPrev,\n        address _oldDelegateNewPosNext,\n        address _currDelegateNewPosPrev,\n        address _currDelegateNewPosNext\n    ) public {\n        bondForWithHint(\n            _amount,\n            msg.sender,\n            _to,\n            _oldDelegateNewPosPrev,\n            _oldDelegateNewPosNext,\n            _currDelegateNewPosPrev,\n            _currDelegateNewPosNext\n        );\n    }\n\n    /**\n     * @notice Transfers ownership of a bond to a new delegator using optional hints if needed\n     *\n     * If the receiver is already bonded to a different delegate than the bond owner then the stake goes\n     * to the receiver's delegate otherwise the receiver's delegate is set as the owner's delegate\n     *\n     * @dev If the original delegate is in the transcoder pool, the caller can provide an optional hint for the\n     * insertion position of the delegate via the `_oldDelegateNewPosPrev` and `_oldDelegateNewPosNext` params.\n     * If the target delegate is in the transcoder pool, the caller can provide an optional hint for the\n     * insertion position of the delegate via the `_newDelegateNewPosPrev` and `_newDelegateNewPosNext` params.\n     *\n     * In both cases, a linear search will be executed starting at the hint to find the correct position. In the best case, the hint\n     * is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints\n     * @param _delegator Receiver of the bond\n     * @param _amount Portion of the bond to transfer to receiver\n     * @param _oldDelegateNewPosPrev Address of previous transcoder in pool if the delegate remains in the pool\n     * @param _oldDelegateNewPosNext Address of next transcoder in pool if the delegate remains in the pool\n     * @param _newDelegateNewPosPrev Address of previous transcoder in pool if the delegate is in the pool\n     * @param _newDelegateNewPosNext Address of next transcoder in pool if the delegate is in the pool\n     */\n    function transferBond(\n        address _delegator,\n        uint256 _amount,\n        address _oldDelegateNewPosPrev,\n        address _oldDelegateNewPosNext,\n        address _newDelegateNewPosPrev,\n        address _newDelegateNewPosNext\n    ) public whenSystemNotPaused currentRoundInitialized {\n        // the `autoClaimEarnings` modifier has been replaced with its internal function as a `Stack too deep` error work-around\n        _autoClaimEarnings(msg.sender);\n        Delegator storage oldDel = delegators[msg.sender];\n        Delegator storage newDel"
    }
  ]
}