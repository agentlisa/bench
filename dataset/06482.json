{
  "Title": "[M-34] `UlyssesToken.setWeights(...)` can cause user loss of assets on vault deposits/withdrawals",
  "Content": "\nThe [ERC-4626](https://eips.ethereum.org/EIPS/eip-4626) paradigm of deposit/mint and withdraw/redeem, where a **single** underlying asset amount can always be converted to a number of vault shares and vice-versa, breaks as soon as there are **multiple weighted** underlying assets involved.\n\nWhile it's easy to convert from shares to asset amounts using the weight factors, it's hard to convert from asset amounts to shares, in case they are not exactly distributed according to the weight factors.\n\nIn the Ulysses protocol this was solved the following way:\n\n- On `UlyssesToken.deposit(...)` every asset amount is converted to shares and the **smallest** of them is the one received for the deposit, see [ERC4626MultiToken.convertToShares(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/erc-4626/ERC4626MultiToken.sol#L200-L207). As a consequence, excess assets provided on the deposit are lost for the user and cannot be redeemed with the received shares.\n- On `UlyssesToken.withdraw(...)` every asset amount is converted to shares and the **greatest** of them is the one required to withdraw the given asset amounts, see [ERC4626MultiToken.previewWithdraw(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/erc-4626/ERC4626MultiToken.sol#L250-L255). As a consequence, less assets than are entitled to, according to the share count, can be withdrawn from the vault incurring a loss for the user.\n\nOne might argue that this issue is of low severity, due to user error and the user being responsible to only use asset amounts in accordance with the vault's asset weights. However, the asset weights are not fixed and can be changed at any time by the owner of the `UlyssesToken` contract via the [setWeights(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-amm/UlyssesToken.sol#L88-L105) method. That is what makes this an actual issue.\n\nConsider the scenario when a user is about to deposit/withdraw assets not knowing their respective weights have changed, or even worse the deposit/withdraw transaction is already in the `mempool`, but the call to `setWeights(...)` is executed before. Depending on the new asset weights, this will inevitably lead to a loss for the user.\n\n### Proof of Concept\n\nThe following in-line documented PoC demonstrates the above claims for the deposit case. Just add the new test case below to `test/ulysses-amm/UlyssesTokenTest.t.sol:InvariantUlyssesToken` and run it with `forge test -vv --match-test test_UlyssesToken`:\n\n```solidity\nfunction test_UlyssesTokenSetWeightsDepositLoss() public {\n    UlyssesToken token = UlyssesToken(_vault_);\n\n    // initialize asset amounts according to weights, mint tokens & give approval to UlyssesToken vault\n    uint256[] memory assetsAmounts = new uint256[](NUM_ASSETS);\n    for (uint256 i = 0; i < NUM_ASSETS; i++) {\n        assetsAmounts[i] = 1000 * token.weights(i);\n        MockERC20(token.assets(i)).mint(address(this), 1e18);\n        MockERC20(token.assets(i)).approve(address(token), 1e18);\n    }\n\n    // deposit assets & check if we got the expected number of shares\n    uint256 expectedShares = token.previewDeposit(assetsAmounts);\n    uint256 receivedShares = token.deposit(assetsAmounts, address(this));\n    assertEq(expectedShares, receivedShares); // OK\n\n    // check if we can redeem the same asset amounts as we deposited\n    uint256[] memory redeemAssetsAmounts = token.previewRedeem(receivedShares);\n    assertEq(assetsAmounts, redeemAssetsAmounts); // OK\n\n    // assuming everything is fine, we submit another deposit transaction to the mempool\n    // meanwhile the UlyssesToken owner changes the asset weights\n    uint256[] memory weights = new uint256[](NUM_ASSETS);\n    for (uint256 i = 0; i < NUM_ASSETS; i++) {\n        weights[i] = token.weights(i);\n    }\n    weights[0] *= 2; // double the weight of first asset\n    token.setWeights(weights);\n\n    // now our deposit transaction gets executed, but due to the changed asset weights\n    // we got less shares than expected while sending too many assets (except for asset[0])\n    receivedShares = token.deposit(assetsAmounts, address(this));\n    assertEq(expectedShares, receivedShares, \"got less shares than expected\");\n\n    // due to the reduced share amount we cannot redeem all the assets we deposited,\n    // we lost the excess assets we have deposited (except for asset[0])\n    redeemAssetsAmounts = token.previewRedeem(receivedShares);\n    assertEq(assetsAmounts, redeemAssetsAmounts, \"can redeem less assets than deposited\");\n}\n```\n\nThe test case shows that less shares than expected are received, in the case of changed weights and any deposited excess assets cannot be redeemed any more:\n\n    Running 1 test for test/ulysses-amm/UlyssesTokenTest.t.sol:InvariantUlyssesToken\n    [FAIL. Reason: Assertion failed.] test_UlyssesTokenSetWeightsDepositLoss() (gas: 631678)\n    Logs:\n      Error: got less shares than expected\n      Error: a == b not satisfied [uint]\n            Left: 45000\n           Right: 27500\n      Error: can redeem less assets than deposited\n      Error: a == b not satisfied [uint[]]\n            Left: [10000, 10000, 20000, 5000]\n           Right: [10000, 5000, 10000, 2500]\n\nFor the sake of simplicity, the test for the withdrawal case was skipped, since it's exactly the same problem just in the reverse direction.\n\n### Tools Used\n\nVS Code, Foundry\n\n### Recommended Mitigation Steps\n\n- On `UlyssesToken.deposit(...)`, only transfer the necessary token amounts (according to the computed share count) from the sender, like the `UlyssesToken.mint(...)` method does.\n- On `UlyssesToken.withdraw(...)`, transfer all the asset amounts the sender is entitled to (according to the computed share count) to the receiver, like the `UlyssesToken.redeem(...)` method does.\n\n### Assessed type\n\nRug-Pull\n\n**[Trust (judge) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/281#issuecomment-1628648135):**\n> The time-sensitivity consideration seems to be valid.\n\n**[0xLightt (Maia) disputed and commented](https://github.com/code-423n4/2023-05-maia-findings/issues/281#issuecomment-1632811699):**\n> This is intended. The goal is that the user gets the same number of assets, but can be in a different ratio, according to weights. That is the reason behind the first failing statement. The second failed statement is because you are passing the incorrect share obtained by the incorrect `assetsAmounts` array.\n>\n> This is a working version of the test passing all tests:\n> ```solidity\n>     function test_UlyssesTokenSetWeightsDepositLoss() public {\n>         UlyssesToken token = UlyssesToken(_vault_);\n> \n>         // initialize asset amounts according to weights, mint tokens & give approval to UlyssesToken vault\n>         uint256[] memory assetsAmounts = new uint256[](NUM_ASSETS);\n>         for (uint256 i = 0; i < NUM_ASSETS; i++) {\n>             assetsAmounts[i] = 1 ether * token.weights(i);\n>             MockERC20(token.assets(i)).mint(address(this), 100 ether);\n>             MockERC20(token.assets(i)).approve(address(token), 100 ether);\n>         }\n> \n>         // deposit assets & check if we got the expected number of shares\n>         uint256 expectedShares = token.previewDeposit(assetsAmounts);\n>         uint256 receivedShares = token.deposit(assetsAmounts, address(this));\n>         assertEq(expectedShares, receivedShares); // OK\n> \n>         // check if we can redeem the same asset amounts as we deposited\n>         uint256[] memory redeemAssetsAmounts = token.previewRedeem(receivedShares);\n>         assertEq(assetsAmounts, redeemAssetsAmounts); // OK\n> \n>         // assuming everything is fine, we submit another deposit transaction to the mempool\n>         // meanwhile the UlyssesToken owner changes the asset weights\n>         uint256[] memory weights = new uint256[](NUM_ASSETS);\n>         for (uint256 i = 0; i < NUM_ASSETS; i++) {\n>             weights[i] = token.weights(i);\n>         }\n>         weights[0] *= 2; // double the weight of first asset\n>         token.setWeights(weights);\n> \n>         // due to the reduced share amount we cannot redeem all the assets we deposited,\n>         // we lost the excess assets we have deposited (except for asset[0])\n>         redeemAssetsAmounts = token.previewRedeem(expectedShares);\n>         uint256 expectedSum;\n>         uint256 sum;\n>         for (uint256 i = 0; i < NUM_ASSETS; i++) {\n>             expectedSum += assetsAmounts[i];\n>             sum += redeemAssetsAmounts[i];\n>         }\n>         assertApproxEqAbs(expectedSum, sum, 1, \"can redeem less assets than deposited\");\n> \n>         // now our deposit transaction gets executed, but due to the changed asset weights\n>         // we got less shares than expected while sending too many assets (except for asset[0])\n>         receivedShares = token.deposit(redeemAssetsAmounts, address(this));\n>         assertApproxEqAbs(expectedShares, receivedShares, 1, \"got less shares than expected\");\n>     }\n> ```\n\n**[0xTheC0der (warden) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/281#issuecomment-1650965734):**\n > @Trust - Providing some additional context:\n> - The sponsor has shown in their version of the test case that the impermanent loss due to re-weighting is intentional and works correctly. This is typical behaviour for mulit-asset vaults and does **not invalidate** the original issue in any way.  \n> - The real problem is the race condition, which was correctly assessed by the judge as \"time-sensitivity consideration\", which causes undesired user loss (involuntary donation of assets) in case of a transaction order of `previewDeposit` -> `setWeights` -> `deposit`. (There is a related race condition issue on withdrawal.)   \n> - In the sponsor's test case: `setWeights` should be to moved between `previewRedeem` and `deposit` to replicate the original issue.  \n> \n> Appreciate everyone's efforts and have a nice day!\n\n**[0xLightt (Maia) confirmed and commented](https://github.com/code-423n4/2023-05-maia-findings/issues/281#issuecomment-1655701757):**\n > We recognize the audit's findings on Ulysses Token. These will not be rectified due to the upcoming migration of this section to Balancer Stable Pools Wrapper.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/erc-4626/ERC4626MultiToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\n\nimport {IERC4626MultiToken} from \"./interfaces/IERC4626MultiToken.sol\";\n\n/// @title Minimal ERC4626 tokenized Vault multi asset implementation\n/// @author Maia DAO (https://github.com/Maia-DAO)\nabstract contract ERC4626MultiToken is ERC20, ReentrancyGuard, IERC4626MultiToken {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626MultiToken\n    address[] public assets;\n\n    /// @inheritdoc IERC4626MultiToken\n    uint256[] public weights;\n\n    /// @inheritdoc IERC4626MultiToken\n    mapping(address => uint256) public assetId;\n\n    /// @inheritdoc IERC4626MultiToken\n    uint256 public totalWeights;\n\n    /// @inheritdoc IERC4626MultiToken\n    function getAssets() external view returns (address[] memory) {\n        return assets;\n    }\n\n    constructor(address[] memory _assets, uint256[] memory _weights, string memory _name, string memory _symbol)\n        ERC20(_name, _symbol, 18)\n    {\n        assets = _assets;\n        weights = _weights;\n\n        uint256 length = _weights.length;\n        uint256 _totalWeights;\n\n        if (length != _assets.length || length == 0) revert InvalidLength();\n\n        for (uint256 i = 0; i < length;) {\n            require(ERC20(_assets[i]).decimals() == 18);\n            require(_weights[i] > 0);\n\n            _totalWeights += _weights[i];\n            assetId[_assets[i]] = i + 1;\n\n            emit AssetAdded(_assets[i], _weights[i]);\n\n            unchecked {\n                i++;\n            }\n        }\n        totalWeights = _totalWeights;\n    }\n\n    function receiveAssets(uint256[] memory assetsAmounts) private {\n        uint256 length = assetsAmounts.length;\n        for (uint256 i = 0; i < length;) {\n            assets[i].safeTransferFrom(msg.sender, address(this), assetsAmounts[i]);\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    function sendAssets(uint256[] memory assetsAmounts, address receiver) private {\n        uint256 length = assetsAmounts.length;\n        for (uint256 i = 0; i < length;) {\n            assets[i].safeTransfer(receiver, assetsAmounts[i]);\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626MultiToken\n    function deposit(uint256[] calldata assetsAmounts, address receiver)\n        public\n        virtual\n        nonReentrant\n        returns (uint256 shares)\n    {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assetsAmounts)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        receiveAssets(assetsAmounts);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assetsAmounts, shares);\n\n        afterDeposit(assetsAmounts, shares);\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function mint(uint256 shares, address receiver)\n        public\n        virtual\n        nonReentrant\n        returns (uint256[] memory assetsAmounts)\n    {\n        assetsAmounts = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        receiveAssets(assetsAmounts);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assetsAmounts, shares);\n\n        afterDeposit(assetsAmounts, shares);\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function withdraw(uint256[] calldata assetsAmounts, address receiver, address owner)\n        public\n        virtual\n        nonReentrant\n        returns (uint256 shares)\n    {\n        shares = previewWithdraw(assetsAmounts); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(assetsAmounts, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assetsAmounts, shares);\n\n        sendAssets(assetsAmounts, receiver);\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function redeem(uint256 shares, address receiver, address owner)\n        public\n        virtual\n        nonReentrant\n        returns (uint256[] memory assetsAmounts)\n    {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        assetsAmounts = previewRedeem(shares);\n        uint256 length = assetsAmounts.length;\n        for (uint256 i = 0; i < length;) {\n            // Check for rounding error since we round down in previewRedeem.\n            if (assetsAmounts[i] == 0) revert ZeroAssets();\n            unchecked {\n                i++;\n            }\n        }\n\n        beforeWithdraw(assetsAmounts, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assetsAmounts, shares);\n\n        sendAssets(assetsAmounts, receiver);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    /// @inheritdoc IERC4626MultiToken\n    function convertToShares(uint256[] calldata assetsAmounts) public view virtual returns (uint256 shares) {\n        uint256 _totalWeights = totalWeights;\n        uint256 length = assetsAmounts.length;\n\n        if (length != assets.length) revert InvalidLength();\n\n        shares = type(uint256).max;\n        for (uint256 i = 0; i < length;) {\n            uint256 share = assetsAmounts[i].mulDiv(_totalWeights, weights[i]);\n            if (share < shares) shares = share;\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function convertToAssets(uint256 shares) public view virtual returns (uint256[] memory assetsAmounts) {\n        uint256 _totalWeights = totalWeights;\n        uint256 length = assets.length;\n\n        assetsAmounts = new uint256[](length);\n        for (uint256 i = 0; i < length;) {\n            assetsAmounts[i] = shares.mulDiv(weights[i], _totalWeights);\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function previewDeposit(uint256[] calldata assetsAmounts) public view virtual returns (uint256) {\n        return convertToShares(assetsAmounts);\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function previewMint(uint256 shares) public view virtual returns (uint256[] memory assetsAmounts) {\n        uint256 _totalWeights = totalWeights;\n        uint256 length = assets.length;\n\n        assetsAmounts = new uint256[](length);\n        for (uint256 i = 0; i < length;) {\n            assetsAmounts[i] = shares.mulDivUp(weights[i], _totalWeights);\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function previewWithdraw(uint256[] calldata assetsAmounts) public view virtual returns (uint256 shares) {\n        uint256 _totalWeights = totalWeights;\n        uint256 length = assetsAmounts.length;\n\n        if (length != assets.length) revert InvalidLength();\n\n        for (uint256 i = 0; i < length;) {\n            uint256 share = assetsAmounts[i].mulDivUp(_totalWeights, weights[i]);\n            if (share > shares) shares = share;\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function previewRedeem(uint256 shares) public view virtual returns (uint256[] memory) {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626MultiToken\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function maxWithdraw(address owner) public view virtual returns (uint256[] memory) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(uint256[] memory assetsAmounts, uint256 shares) internal virtual {}\n\n    function afterDeposit(uint256[] memory assetsAmounts, uint256 shares) internal virtual {}\n}"
    },
    {
      "filename": "src/erc-4626/ERC4626MultiToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\n\nimport {IERC4626MultiToken} from \"./interfaces/IERC4626MultiToken.sol\";\n\n/// @title Minimal ERC4626 tokenized Vault multi asset implementation\n/// @author Maia DAO (https://github.com/Maia-DAO)\nabstract contract ERC4626MultiToken is ERC20, ReentrancyGuard, IERC4626MultiToken {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626MultiToken\n    address[] public assets;\n\n    /// @inheritdoc IERC4626MultiToken\n    uint256[] public weights;\n\n    /// @inheritdoc IERC4626MultiToken\n    mapping(address => uint256) public assetId;\n\n    /// @inheritdoc IERC4626MultiToken\n    uint256 public totalWeights;\n\n    /// @inheritdoc IERC4626MultiToken\n    function getAssets() external view returns (address[] memory) {\n        return assets;\n    }\n\n    constructor(address[] memory _assets, uint256[] memory _weights, string memory _name, string memory _symbol)\n        ERC20(_name, _symbol, 18)\n    {\n        assets = _assets;\n        weights = _weights;\n\n        uint256 length = _weights.length;\n        uint256 _totalWeights;\n\n        if (length != _assets.length || length == 0) revert InvalidLength();\n\n        for (uint256 i = 0; i < length;) {\n            require(ERC20(_assets[i]).decimals() == 18);\n            require(_weights[i] > 0);\n\n            _totalWeights += _weights[i];\n            assetId[_assets[i]] = i + 1;\n\n            emit AssetAdded(_assets[i], _weights[i]);\n\n            unchecked {\n                i++;\n            }\n        }\n        totalWeights = _totalWeights;\n    }\n\n    function receiveAssets(uint256[] memory assetsAmounts) private {\n        uint256 length = assetsAmounts.length;\n        for (uint256 i = 0; i < length;) {\n            assets[i].safeTransferFrom(msg.sender, address(this), assetsAmounts[i]);\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    function sendAssets(uint256[] memory assetsAmounts, address receiver) private {\n        uint256 length = assetsAmounts.length;\n        for (uint256 i = 0; i < length;) {\n            assets[i].safeTransfer(receiver, assetsAmounts[i]);\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626MultiToken\n    function deposit(uint256[] calldata assetsAmounts, address receiver)\n        public\n        virtual\n        nonReentrant\n        returns (uint256 shares)\n    {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assetsAmounts)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        receiveAssets(assetsAmounts);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assetsAmounts, shares);\n\n        afterDeposit(assetsAmounts, shares);\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function mint(uint256 shares, address receiver)\n        public\n        virtual\n        nonReentrant\n        returns (uint256[] memory assetsAmounts)\n    {\n        assetsAmounts = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        receiveAssets(assetsAmounts);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assetsAmounts, shares);\n\n        afterDeposit(assetsAmounts, shares);\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function withdraw(uint256[] calldata assetsAmounts, address receiver, address owner)\n        public\n        virtual\n        nonReentrant\n        returns (uint256 shares)\n    {\n        shares = previewWithdraw(assetsAmounts); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(assetsAmounts, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assetsAmounts, shares);\n\n        sendAssets(assetsAmounts, receiver);\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function redeem(uint256 shares, address receiver, address owner)\n        public\n        virtual\n        nonReentrant\n        returns (uint256[] memory assetsAmounts)\n    {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        assetsAmounts = previewRedeem(shares);\n        uint256 length = assetsAmounts.length;\n        for (uint256 i = 0; i < length;) {\n            // Check for rounding error since we round down in previewRedeem.\n            if (assetsAmounts[i] == 0) revert ZeroAssets();\n            unchecked {\n                i++;\n            }\n        }\n\n        beforeWithdraw(assetsAmounts, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assetsAmounts, shares);\n\n        sendAssets(assetsAmounts, receiver);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    /// @inheritdoc IERC4626MultiToken\n    function convertToShares(uint256[] calldata assetsAmounts) public view virtual returns (uint256 shares) {\n        uint256 _totalWeights = totalWeights;\n        uint256 length = assetsAmounts.length;\n\n        if (length != assets.length) revert InvalidLength();\n\n        shares = type(uint256).max;\n        for (uint256 i = 0; i < length;) {\n            uint256 share = assetsAmounts[i].mulDiv(_totalWeights, weights[i]);\n            if (share < shares) shares = share;\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function convertToAssets(uint256 shares) public view virtual returns (uint256[] memory assetsAmounts) {\n        uint256 _totalWeights = totalWeights;\n        uint256 length = assets.length;\n\n        assetsAmounts = new uint256[](length);\n        for (uint256 i = 0; i < length;) {\n            assetsAmounts[i] = shares.mulDiv(weights[i], _totalWeights);\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function previewDeposit(uint256[] calldata assetsAmounts) public view virtual returns (uint256) {\n        return convertToShares(assetsAmounts);\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function previewMint(uint256 shares) public view virtual returns (uint256[] memory assetsAmounts) {\n        uint256 _totalWeights = totalWeights;\n        uint256 length = assets.length;\n\n        assetsAmounts = new uint256[](length);\n        for (uint256 i = 0; i < length;) {\n            assetsAmounts[i] = shares.mulDivUp(weights[i], _totalWeights);\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function previewWithdraw(uint256[] calldata assetsAmounts) public view virtual returns (uint256 shares) {\n        uint256 _totalWeights = totalWeights;\n        uint256 length = assetsAmounts.length;\n\n        if (length != assets.length) revert InvalidLength();\n\n        for (uint256 i = 0; i < length;) {\n            uint256 share = assetsAmounts[i].mulDivUp(_totalWeights, weights[i]);\n            if (share > shares) shares = share;\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function previewRedeem(uint256 shares) public view virtual returns (uint256[] memory) {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626MultiToken\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function maxWithdraw(address owner) public view virtual returns (uint256[] memory) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(uint256[] memory assetsAmounts, uint256 shares) internal virtual {}\n\n    function afterDeposit(uint256[] memory assetsAmounts, uint256 shares) internal virtual {}\n}"
    },
    {
      "filename": "src/ulysses-amm/UlyssesToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {ERC4626MultiToken, IERC4626MultiToken} from \"@ERC4626/ERC4626MultiToken.sol\";\n\nimport {IUlyssesToken} from \"./interfaces/IUlyssesToken.sol\";\n\n/// @title Ulysses Token - tokenized Vault multi asset implementation for Ulysses pools\ncontract UlyssesToken is ERC4626MultiToken, Ownable, IUlyssesToken {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n\n    uint256 public immutable id;\n\n    constructor(\n        uint256 _id,\n        address[] memory _assets,\n        uint256[] memory _weights,\n        string memory _name,\n        string memory _symbol,\n        address _owner\n    ) ERC4626MultiToken(_assets, _weights, _name, _symbol) {\n        _initializeOwner(_owner);\n        require(_id != 0);\n        id = _id;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626MultiToken\n    function totalAssets() public view override returns (uint256 _totalAssets) {\n        return totalSupply;\n    }\n\n    ///@inheritdoc IUlyssesToken\n    function addAsset(address asset, uint256 _weight) external nonReentrant onlyOwner {\n        if (assetId[asset] != 0) revert AssetAlreadyAdded();\n        require(ERC20(asset).decimals() == 18);\n        require(_weight > 0);\n\n        assetId[asset] = assets.length + 1;\n        assets.push(asset);\n        weights.push(_weight);\n        totalWeights += _weight;\n\n        emit AssetAdded(asset, _weight);\n\n        updateAssetBalances();\n    }\n\n    ///@inheritdoc IUlyssesToken\n    function removeAsset(address asset) external nonReentrant onlyOwner {\n        // No need to check if index is 0, it will underflow and revert if it is 0\n        uint256 assetIndex = assetId[asset] - 1;\n\n        uint256 newAssetsLength = assets.length - 1;\n\n        if (newAssetsLength == 0) revert CannotRemoveLastAsset();\n\n        totalWeights -= weights[assetIndex];\n\n        address lastAsset = assets[newAssetsLength];\n\n        assetId[lastAsset] = assetIndex;\n        assets[assetIndex] = lastAsset;\n        weights[assetIndex] = weights[newAssetsLength];\n\n        assets.pop();\n        weights.pop();\n        assetId[asset] = 0;\n\n        emit AssetRemoved(asset);\n\n        updateAssetBalances();\n\n        asset.safeTransfer(msg.sender, asset.balanceOf(address(this)));\n    }\n\n    ///@inheritdoc IUlyssesToken\n    function setWeights(uint256[] memory _weights) external nonReentrant onlyOwner {\n        if (_weights.length != assets.length) revert InvalidWeightsLength();\n\n        weights = _weights;\n\n        uint256 newTotalWeights;\n\n        for (uint256 i = 0; i < assets.length; i++) {\n            newTotalWeights += _weights[i];\n\n            emit AssetRemoved(assets[i]);\n            emit AssetAdded(assets[i], _weights[i]);\n        }\n\n        totalWeights = newTotalWeights;\n\n        updateAssetBalances();\n    }\n\n    /**\n     * @notice Update the balances of the underlying assets.\n     */\n    function updateAssetBalances() internal {\n        for (uint256 i = 0; i < assets.length; i++) {\n            uint256 assetBalance = assets[i].balanceOf(address(this));\n            uint256 newAssetBalance = totalSupply.mulDivUp(weights[i], totalWeights);\n\n            if (assetBalance > newAssetBalance) {\n                assets[i].safeTransfer(msg.sender, assetBalance - newAssetBalance);\n            } else {\n                assets[i].safeTransferFrom(msg.sender, address(this), newAssetBalance - assetBalance);\n            }\n        }\n    }\n}"
    }
  ]
}