{
  "Title": "Small unripe token withdrawals don't decrease BDV and Stalk",
  "Content": "**Description:** For any whitelisted token where `bdvCalc(amountDeposited) < amountDeposited`, a user can deposit that token and then withdraw in small amounts to avoid decreasing BDV and Stalk. This is achieved by exploiting a rounding down to zero precision loss in [`LibTokenSilo::removeDepositFromAccount`](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/libraries/Silo/LibTokenSilo.sol#L248):\n\n```solidity\n// @audit small unripe bean withdrawals don't decrease BDV and Stalk\n// due to rounding down to zero precision loss. Every token where\n// `bdvCalc(amountDeposited) < amountDeposited` is vulnerable\nuint256 removedBDV = amount.mul(crateBDV).div(crateAmount);\n```\n\n**Impact:** An attacker can withdraw deposited assets without decreasing BDV and Stalk. While the cost to perform this attack is likely more than the value an attacker would stand to gain, the potential impact should definitely be explored more closely especially considering the introduction of the Unripe Chop Convert in BIP-39 as this could have other unintended consequences in relation to this bug (given that the inflated BDV of an Unripe Token will persist once deposit is converted to its ripe counterpart, potentially allowing value to be extracted that way depending on how this BDV is used/manipulated elsewhere).\n\nThe other primary consideration for this bug is that it breaks the mechanism that Stalk is supposed to be lost when withdrawing deposited assets and keeps the `totalDepositedBdv` artificially high, violating the invariant that the `totalDepositedBdv` value for a token should be the sum of the BDV value of all the individual deposits.\n\n**Proof of Concept:** Add this PoC to `SiloToken.test.js` under the section `describe(\"1 deposit, some\", async function () {`:\n\n```javascript\nit('audit small unripe bean withdrawals dont decrease BDV and Stalks', async function () {\n    let initialUnripeBeanDeposited    = to6('10');\n    let initialUnripeBeanDepositedBdv = '2355646';\n    let initialTotalStalk = pruneToStalk(initialUnripeBeanDeposited).add(toStalk('0.5'));\n\n    // verify initial state\n    expect(await this.silo.getTotalDeposited(UNRIPE_BEAN)).to.eq(initialUnripeBeanDeposited);\n    expect(await this.silo.getTotalDepositedBdv(UNRIPE_BEAN)).to.eq(initialUnripeBeanDepositedBdv);\n    expect(await this.silo.totalStalk()).to.eq(initialTotalStalk);\n\n    // snapshot EVM state as we want to restore it after testing the normal\n    // case works as expected\n    let snapshotId = await network.provider.send('evm_snapshot');\n\n    // normal case: withdrawing total UNRIPE_BEAN correctly decreases BDV & removes stalks\n    const stem = await this.silo.seasonToStem(UNRIPE_BEAN, '10');\n    await this.silo.connect(user).withdrawDeposit(UNRIPE_BEAN, stem, initialUnripeBeanDeposited, EXTERNAL);\n\n    // verify UNRIPE_BEAN totalDeposited == 0\n    expect(await this.silo.getTotalDeposited(UNRIPE_BEAN)).to.eq('0');\n    // verify UNRIPE_BEAN totalDepositedBDV == 0\n    expect(await this.silo.getTotalDepositedBdv(UNRIPE_BEAN)).to.eq('0');\n    // verify silo.totalStalk() == 0\n    expect(await this.silo.totalStalk()).to.eq('0');\n\n    // restore EVM state to snapshot prior to testing normal case\n    await network.provider.send(\"evm_revert\", [snapshotId]);\n\n    // re-verify initial state\n    expect(await this.silo.getTotalDeposited(UNRIPE_BEAN)).to.eq(initialUnripeBeanDeposited);\n    expect(await this.silo.getTotalDepositedBdv(UNRIPE_BEAN)).to.eq(initialUnripeBeanDepositedBdv);\n    expect(await this.silo.totalStalk()).to.eq(initialTotalStalk);\n\n    // attacker case: withdrawing small amounts of UNRIPE_BEAN doesn't decrease\n    // BDV and doesn't remove stalks. This lets an attacker withdraw their deposits\n    // without losing Stalks & breaks the invariant that the totalDepositedBDV should\n    // equal the sum of the BDV of all individual deposits\n    let smallWithdrawAmount = '4';\n    await this.silo.connect(user).withdrawDeposit(UNRIPE_BEAN, stem, smallWithdrawAmount, EXTERNAL);\n\n    // verify UNRIPE_BEAN totalDeposited has been correctly decreased\n    expect(await this.silo.getTotalDeposited(UNRIPE_BEAN)).to.eq(initialUnripeBeanDeposited.sub(smallWithdrawAmount));\n    // verify UNRIPE_BEAN totalDepositedBDV remains unchanged!\n    expect(await this.silo.getTotalDepositedBdv(UNRIPE_BEAN)).to.eq(initialUnripeBeanDepositedBdv);\n    // verify silo.totalStalk() remains unchanged!\n    expect(await this.silo.totalStalk()).to.eq(initialTotalStalk);\n});\n```\nRun with: `npx hardhat test --grep \"audit small unripe bean withdrawals dont decrease BDV and Stalks\"`.\n\nAdditional Mainnet fork tests have been written to demonstrate the presence of this bug in the current and post-BIP-39 deployments of Beanstalk (see Appendix B).\n\n**Recommended Mitigation:** `LibTokenSilo::removeDepositFromAccount` should revert if `removedBDV == 0`. A similar check already exists in [`LibTokenSilo::depositWithBDV`](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/libraries/Silo/LibTokenSilo.sol#L141) but is missing in `removeDepositFromAccount()` when calculating `removedBDV` for partial withdrawals.\n\nThe breaking of protocol invariants could lead to other serious issues that have not yet been identified but may well exist if core properties do not hold. We would urge the team to consider fixing this bug as soon as possible, prior to or as part of the BIP-39 upgrade.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/libraries/Silo/LibTokenSilo.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"../LibAppStorage.sol\";\nimport \"../../C.sol\";\nimport \"contracts/libraries/LibSafeMath32.sol\";\nimport \"contracts/libraries/LibSafeMath128.sol\";\nimport \"contracts/libraries/LibSafeMathSigned128.sol\";\nimport \"contracts/libraries/LibSafeMathSigned96.sol\";\nimport \"contracts/libraries/LibBytes.sol\";\n\n\n/**\n * @title LibTokenSilo\n * @author Publius, Pizzaman1337\n * @notice Contains functions for depositing, withdrawing and claiming\n * whitelisted Silo tokens.\n *\n * For functionality related to Stalk, and Roots, see {LibSilo}.\n */\nlibrary LibTokenSilo {\n    using SafeMath for uint256;\n    using LibSafeMath128 for uint128;\n    using LibSafeMath32 for uint32;\n    using LibSafeMathSigned128 for int128;\n    using SafeCast for int128;\n    using SafeCast for uint256;\n    using LibSafeMathSigned96 for int96;\n\n\n    //////////////////////// ENUM ////////////////////////\n    /**\n     * @dev when a user deposits or withdraws a deposit, the\n     * {TrasferSingle} event is emitted. However, in the case\n     * of a transfer, this emission is ommited. This enum is\n     * used to determine if the event should be emitted.\n     */\n    enum Transfer {\n        emitTransferSingle,\n        noEmitTransferSingle\n    }\n\n    //////////////////////// EVENTS ////////////////////////\n\n    /**\n     * @dev IMPORTANT: copy of {TokenSilo-AddDeposit}, check there for details.\n     */\n    event AddDeposit(\n        address indexed account,\n        address indexed token,\n        int96 stem,\n        uint256 amount,\n        uint256 bdv\n    );\n\n    // added as the ERC1155 deposit upgrade\n    event TransferSingle(\n        address indexed operator, \n        address indexed sender, \n        address indexed recipient, \n        uint256 depositId, \n        uint256 amount\n    );\n\n\n    //////////////////////// ACCOUNTING: TOTALS ////////////////////////\n    \n    /**\n     * @dev Increment the total amount and bdv of `token` deposited in the Silo.\n     */\n    function incrementTotalDeposited(address token, uint256 amount, uint256 bdv) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.siloBalances[token].deposited = s.siloBalances[token].deposited.add(\n            amount.toUint128()\n        );\n        s.siloBalances[token].depositedBdv = s.siloBalances[token].depositedBdv.add(\n            bdv.toUint128()\n        );\n    }\n\n    /**\n     * @dev Decrement the total amount and bdv of `token` deposited in the Silo.\n     */\n    function decrementTotalDeposited(address token, uint256 amount, uint256 bdv) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.siloBalances[token].deposited = s.siloBalances[token].deposited.sub(\n            amount.toUint128()\n        );\n        s.siloBalances[token].depositedBdv = s.siloBalances[token].depositedBdv.sub(\n            bdv.toUint128()\n        );\n    }\n\n    /**\n     * @dev Increment the total bdv of `token` deposited in the Silo. Used in Enroot.\n     */\n    function incrementTotalDepositedBdv(address token, uint256 bdv) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.siloBalances[token].depositedBdv = s.siloBalances[token].depositedBdv.add(\n            bdv.toUint128()\n        );\n    }\n\n    //////////////////////// ADD DEPOSIT ////////////////////////\n\n    /**\n     * @return stalk The amount of Stalk received for this Deposit.\n     * \n     * @dev Calculate the current BDV for `amount` of `token`, then perform \n     * Deposit accounting.\n     */\n    function deposit(\n        address account,\n        address token,\n        int96 stem,\n        uint256 amount\n    ) internal returns (uint256) {\n        uint256 bdv = beanDenominatedValue(token, amount);\n        return depositWithBDV(account, token, stem, amount, bdv);\n    }\n\n    /**\n     * @dev Once the BDV received for Depositing `amount` of `token` is known, \n     * add a Deposit for `account` and update the total amount Deposited.\n     *\n     * `s.ss[token].stalkIssuedPerBdv` stores the number of Stalk per BDV for `token`.\n     */\n    function depositWithBDV(\n        address account,\n        address token,\n        int96 stem,\n        uint256 amount,\n        uint256 bdv\n    ) internal returns (uint256 stalk) {\n        require(bdv > 0, \"Silo: No Beans under Token.\");\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        \n        incrementTotalDeposited(token, amount, bdv);\n        addDepositToAccount(\n            account, \n            token, \n            stem, \n            amount, \n            bdv, \n            Transfer.emitTransferSingle  \n        ); \n        stalk = bdv.mul(s.ss[token].stalkIssuedPerBdv);\n    }\n\n    /**\n     * @dev Add `amount` of `token` to a user's Deposit in `stemTipForToken`. Requires a\n     * precalculated `bdv`.\n     *\n     * If a Deposit doesn't yet exist, one is created. Otherwise, the existing\n     * Deposit is updated.\n     * \n     * `amount` & `bdv` are downcasted uint256 -> uint128 to optimize storage cost,\n     * since both values can be packed into one slot.\n     * \n     * Unlike {removeDepositFromAccount}, this function DOES EMIT an \n     * {AddDeposit} event. See {removeDepositFromAccount} for more details.\n     */\n    function addDepositToAccount(\n        address account,\n        address token,\n        int96 stem,\n        uint256 amount,\n        uint256 bdv,\n        Transfer transferType\n    ) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 depositId = LibBytes.packAddressAndStem(\n            token,\n            stem\n        );\n\n        // add amount to the deposits, and update the deposit.\n        s.a[account].deposits[depositId].amount = \n            s.a[account].deposits[depositId].amount.add(amount.toUint128());\n        s.a[account].deposits[depositId].bdv = \n            s.a[account].deposits[depositId].bdv.add(bdv.toUint128());\n        \n        // update the mow status (note: mow status is per token, not per depositId)\n        // SafeMath not necessary as the bdv is already checked to be <= type(uint128).max\n        s.a[account].mowStatuses[token].bdv = uint128(s.a[account].mowStatuses[token].bdv.add(uint128(bdv)));\n\n        /** \n         *  {addDepositToAccount} is used for both depositing and transferring deposits.\n         *  In the case of a deposit, only the {TransferSingle} Event needs to be emitted.\n         *  In the case of a transfer, a different {TransferSingle}/{TransferBatch} \n         *  Event is emitted in {TokenSilo._transferDeposit(s)}, \n         *  and thus, this event is ommited.\n         */\n        if(transferType == Transfer.emitTransferSingle){\n            emit TransferSingle(\n                msg.sender, // operator\n                address(0), // from\n                account, // to\n                uint256(depositId), // depositID\n                amount // token amount\n            );\n        }\n        emit AddDeposit(account, token, stem, amount, bdv);\n    }\n\n    //////////////////////// REMOVE DEPOSIT ////////////////////////\n\n    /**\n     * @dev Remove `amount` of `token` from a user's Deposit in `stem`.\n     *\n     * A \"Crate\" refers to the existing Deposit in storage at:\n     *  `s.a[account].deposits[token][stem]`\n     *\n     * Partially removing a Deposit should scale its BDV proportionally. For ex.\n     * removing 80% of the tokens from a Deposit should reduce its BDV by 80%.\n     *\n     * During an update, `amount` & `bdv` are cast uint256 -> uint128 to\n     * optimize storage cost, since both values can be packed into one slot.\n     *\n     * This function DOES **NOT** EMIT a {RemoveDeposit} event. This\n     * asymmetry occurs because {removeDepositFromAccount} is called in a loop\n     * in places where multiple deposits are removed simultaneously, including\n     * {TokenSilo-removeDepositsFromAccount} and {TokenSilo-_transferDeposits}.\n     */\n\n    function removeDepositFromAccount(\n        address account,\n        address token,\n        int96 stem,\n        uint256 amount\n    ) internal returns (uint256 crateBDV) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 depositId = LibBytes.packAddressAndStem(token,stem);\n\n        uint256 crateAmount = s.a[account].deposits[depositId].amount;\n        crateBDV = s.a[account].deposits[depositId].bdv;\n\n        require(amount <= crateAmount, \"Silo: Crate balance too low.\");\n\n        // Partial remove\n        if (amount < crateAmount) {\n            uint256 removedBDV = amount.mul(crateBDV).div(crateAmount);\n            uint256 updatedBDV = crateBDV.sub(removedBDV);\n            uint256 updatedAmount = crateAmount.sub(amount);\n\n            // SafeCast unnecessary b/c updatedAmount <= crateAmount and updatedBDV <= crateBDV, which are both <= type(uint128).max\n            s.a[account].deposits[depositId].amount = uint128(updatedAmount);\n            s.a[account].deposits[depositId].bdv = uint128(updatedBDV);\n            //remove from the mow status bdv amount, which keeps track of total token deposited per farmer\n            s.a[account].mowStatuses[token].bdv = s.a[account].mowStatuses[token].bdv.sub(\n                removedBDV.toUint128()\n            );\n            return removedBDV;\n        }\n        // Full remove\n        if (crateAmount > 0) delete s.a[account].deposits[depositId];\n\n\n        // SafeMath unnecessary b/c crateBDV <= type(uint128).max\n        s.a[account].mowStatuses[token].bdv = s.a[account].mowStatuses[token].bdv.sub(\n            uint128(crateBDV)\n        );\n    }\n\n    //////////////////////// GETTERS ////////////////////////\n\n    /**\n     * @dev Calculate the BDV (\"Bean Denominated Value\") for `amount` of `token`.\n     * \n     * Makes a call to a BDV function defined in the SiloSettings for this \n     * `token`. See {AppStorage.sol:Storage-SiloSettings} for more information.\n     */\n    function beanDenominatedValue(address token, uint256 amount)\n        internal\n        view\n        returns (uint256 bdv)\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        require(s.ss[token].selector != bytes4(0), \"Silo: Token not whitelisted\");\n\n        (bool success, bytes memory data) = address(this).staticcall(\n            encodeBdvFunction(\n                token,\n                s.ss[token].encodeType,\n                s.ss[token].selector,\n                amount\n            )\n        );\n\n        if (!success) {\n            if (data.length == 0) revert();\n            assembly {\n                revert(add(32, data), mload(data))\n            }\n        }\n\n        assembly {\n            bdv := mload(add(data, add(0x20, 0)))\n        }\n    }\n\n    function encodeBdvFunction(\n        address token,\n        bytes1 encodeType,\n        bytes4 selector,\n        uint256 amount\n    )\n        internal\n        pure\n        returns (bytes memory callData)\n    {\n        if (encodeType == 0x00) {\n            callData = abi.encodeWithSelector(\n                selector,\n                amount\n            );\n        } else if (encodeType == 0x01) {\n            callData = abi.encodeWithSelector(\n                selector,\n                token,\n                amount\n            );\n        } else {\n            revert(\"Silo: Invalid encodeType\");\n        }\n    }\n\n    /**\n     * @dev Locate the `amount` and `bdv` for a user's Deposit in storage.\n     * \n     * Silo V3 Deposits are stored within each {Account} as a mapping of:\n     *  `uint256 DepositID => { uint128 amount, uint128 bdv }`\n     *  The DepositID is the concatination of the token address and the stem.\n     * \n     * Silo V2 deposits are only usable after a successful migration, see\n     * mowAndMigrate within the Migration facet.\n     *\n     */\n    function getDeposit(\n        address account,\n        address token,\n        int96 stem\n    ) internal view returns (uint256 amount, uint256 bdv) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 depositId = LibBytes.packAddressAndStem(\n            token,\n            stem\n        );\n        amount = s.a[account].deposits[depositId].amount;\n        bdv = s.a[account].deposits[depositId].bdv;\n    }\n    \n    /**\n     * @dev Get the number of Stalk per BDV per Season for a whitelisted token. Formerly just seeds.\n     * Note this is stored as 1e6, i.e. 1_000_000 units of this is equal to 1 old seed.\n     */\n    function stalkEarnedPerSeason(address token) internal view returns (uint256) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return uint256(s.ss[token].stalkEarnedPerSeason);\n    }\n\n    /**\n     * @dev Get the number of Stalk per BDV for a whitelisted token. Formerly just stalk.\n     */\n    function stalkIssuedPerBdv(address token) internal view returns (uint256) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return uint256(s.ss[token].stalkIssuedPerBdv);\n    }\n\n    /**\n     * @dev returns the cumulative stalk per BDV (stemTip) for a whitelisted token. \n     * Does not truncate the value, i.e. divide by 1e6\n     */\n    function stemTipForTokenUntruncated(address token)\n        internal\n        view\n        returns (int96 _stemTipForToken)\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        \n        // SafeCast unnecessary because all casted variables are types smaller that int96.\n        _stemTipForToken = s.ss[token].milestoneStem +\n        int96(s.ss[token].stalkEarnedPerSeason).mul(\n            int96(s.season.current).sub(int96(s.ss[token].milestoneSeason))\n        );\n    }\n\n    /**\n     * @dev returns the cumulative stalk per BDV (stemTip) for a whitelisted token.\n     */\n    function stemTipForToken(address token)\n        internal\n        view\n        returns (int96 _stemTipForToken)\n    {\n        return stemTipForTokenUntruncated(token).div(1e6);\n    }\n\n    /**\n     * @dev returns the amount of grown stalk a deposit has earned.\n     */\n    function grownStalkForDeposit(\n        address account,\n        address token,\n        int96 stem\n    )\n        internal\n        view\n        returns (uint grownStalk)\n    {\n        // stemTipForToken(token) > depositGrownStalkPerBdv for all valid Deposits\n        int96 _stemTip = stemTipForToken(token);\n        require(stem <= _stemTip, \"Silo: Invalid Deposit\");\n         // The check in the above line guarantees that subtraction result is positive\n         // and thus the cast to `uint256` is safe.\n        uint deltaStemTip = uint256(_stemTip.sub(stem));\n        (, uint bdv) = getDeposit(account, token, stem);\n\n        grownStalk = deltaStemTip.mul(bdv);\n    }\n\n    /**\n     * @dev returns the amount of grown stalk a deposit would have, based on the stem of the deposit.\n     */\n    function calculateStalkFromStemAndBdv(address token, int96 grownStalkIndexOfDeposit, uint256 bdv)\n        internal\n        view\n        returns (int96 grownStalk)\n    {\n        // current latest grown stalk index\n        int96 _stemTipForToken = stemTipForToken(address(token));\n\n        return _stemTipForToken.sub(grownStalkIndexOfDeposit).mul(toInt96(bdv));\n    }\n\n    /**\n     * @dev returns the stem of a deposit, based on the amount of grown stalk it has earned.\n     */\n    function calculateGrownStalkAndStem(address token, uint256 grownStalk, uint256 bdv)\n        internal\n        view \n        returns (uint256 _grownStalk, int96 stem)\n    {\n        int96 _stemTipForToken = stemTipForToken(token);\n        stem = _stemTipForToken.sub(toInt96(grownStalk.div(bdv)));\n        _grownStalk = uint256(_stemTipForToken.sub(stem).mul(toInt96(bdv)));\n    }\n\n\n    /**\n     * @dev returns the amount of grown stalk a deposit would have, based on the stem of the deposit.\n     * Similar to calculateStalkFromStemAndBdv, but has an additional check to prevent division by 0.\n     */\n    function grownStalkAndBdvToStem(address token, uint256 grownStalk, uint256 bdv)\n        internal\n        view\n        returns (int96 cumulativeGrownStalk)\n    {\n        // first get current latest grown stalk index\n        int96 _stemTipForToken = stemTipForToken(token);\n        // then calculate how much stalk each individual bdv has grown\n        // there's a > 0 check here, because if you have a small amount of unripe bean deposit, the bdv could\n        // end up rounding to zero, then you get a divide by zero error and can't migrate without losing that deposit\n\n        // prevent divide by zero error\n        int96 grownStalkPerBdv = bdv > 0 ? toInt96(grownStalk.div(bdv)) : 0;\n\n        // subtract from the current latest index, so we get the index the deposit should have happened at\n        return _stemTipForToken.sub(grownStalkPerBdv);\n    }\n\n    function toInt96(uint256 value) internal pure returns (int96) {\n        require(value <= uint256(type(int96).max), \"SafeCast: value doesn't fit in an int96\");\n        return int96(value);\n    }\n}"
    },
    {
      "filename": "protocol/contracts/libraries/Silo/LibTokenSilo.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"../LibAppStorage.sol\";\nimport \"../../C.sol\";\nimport \"contracts/libraries/LibSafeMath32.sol\";\nimport \"contracts/libraries/LibSafeMath128.sol\";\nimport \"contracts/libraries/LibSafeMathSigned128.sol\";\nimport \"contracts/libraries/LibSafeMathSigned96.sol\";\nimport \"contracts/libraries/LibBytes.sol\";\n\n\n/**\n * @title LibTokenSilo\n * @author Publius, Pizzaman1337\n * @notice Contains functions for depositing, withdrawing and claiming\n * whitelisted Silo tokens.\n *\n * For functionality related to Stalk, and Roots, see {LibSilo}.\n */\nlibrary LibTokenSilo {\n    using SafeMath for uint256;\n    using LibSafeMath128 for uint128;\n    using LibSafeMath32 for uint32;\n    using LibSafeMathSigned128 for int128;\n    using SafeCast for int128;\n    using SafeCast for uint256;\n    using LibSafeMathSigned96 for int96;\n\n\n    //////////////////////// ENUM ////////////////////////\n    /**\n     * @dev when a user deposits or withdraws a deposit, the\n     * {TrasferSingle} event is emitted. However, in the case\n     * of a transfer, this emission is ommited. This enum is\n     * used to determine if the event should be emitted.\n     */\n    enum Transfer {\n        emitTransferSingle,\n        noEmitTransferSingle\n    }\n\n    //////////////////////// EVENTS ////////////////////////\n\n    /**\n     * @dev IMPORTANT: copy of {TokenSilo-AddDeposit}, check there for details.\n     */\n    event AddDeposit(\n        address indexed account,\n        address indexed token,\n        int96 stem,\n        uint256 amount,\n        uint256 bdv\n    );\n\n    // added as the ERC1155 deposit upgrade\n    event TransferSingle(\n        address indexed operator, \n        address indexed sender, \n        address indexed recipient, \n        uint256 depositId, \n        uint256 amount\n    );\n\n\n    //////////////////////// ACCOUNTING: TOTALS ////////////////////////\n    \n    /**\n     * @dev Increment the total amount and bdv of `token` deposited in the Silo.\n     */\n    function incrementTotalDeposited(address token, uint256 amount, uint256 bdv) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.siloBalances[token].deposited = s.siloBalances[token].deposited.add(\n            amount.toUint128()\n        );\n        s.siloBalances[token].depositedBdv = s.siloBalances[token].depositedBdv.add(\n            bdv.toUint128()\n        );\n    }\n\n    /**\n     * @dev Decrement the total amount and bdv of `token` deposited in the Silo.\n     */\n    function decrementTotalDeposited(address token, uint256 amount, uint256 bdv) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.siloBalances[token].deposited = s.siloBalances[token].deposited.sub(\n            amount.toUint128()\n        );\n        s.siloBalances[token].depositedBdv = s.siloBalances[token].depositedBdv.sub(\n            bdv.toUint128()\n        );\n    }\n\n    /**\n     * @dev Increment the total bdv of `token` deposited in the Silo. Used in Enroot.\n     */\n    function incrementTotalDepositedBdv(address token, uint256 bdv) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.siloBalances[token].depositedBdv = s.siloBalances[token].depositedBdv.add(\n            bdv.toUint128()\n        );\n    }\n\n    //////////////////////// ADD DEPOSIT ////////////////////////\n\n    /**\n     * @return stalk The amount of Stalk received for this Deposit.\n     * \n     * @dev Calculate the current BDV for `amount` of `token`, then perform \n     * Deposit accounting.\n     */\n    function deposit(\n        address account,\n        address token,\n        int96 stem,\n        uint256 amount\n    ) internal returns (uint256) {\n        uint256 bdv = beanDenominatedValue(token, amount);\n        return depositWithBDV(account, token, stem, amount, bdv);\n    }\n\n    /**\n     * @dev Once the BDV received for Depositing `amount` of `token` is known, \n     * add a Deposit for `account` and update the total amount Deposited.\n     *\n     * `s.ss[token].stalkIssuedPerBdv` stores the number of Stalk per BDV for `token`.\n     */\n    function depositWithBDV(\n        address account,\n        address token,\n        int96 stem,\n        uint256 amount,\n        uint256 bdv\n    ) internal returns (uint256 stalk) {\n        require(bdv > 0, \"Silo: No Beans under Token.\");\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        \n        incrementTotalDeposited(token, amount, bdv);\n        addDepositToAccount(\n            account, \n            token, \n            stem, \n            amount, \n            bdv, \n            Transfer.emitTransferSingle  \n        ); \n        stalk = bdv.mul(s.ss[token].stalkIssuedPerBdv);\n    }\n\n    /**\n     * @dev Add `amount` of `token` to a user's Deposit in `stemTipForToken`. Requires a\n     * precalculated `bdv`.\n     *\n     * If a Deposit doesn't yet exist, one is created. Otherwise, the existing\n     * Deposit is updated.\n     * \n     * `amount` & `bdv` are downcasted uint256 -> uint128 to optimize storage cost,\n     * since both values can be packed into one slot.\n     * \n     * Unlike {removeDepositFromAccount}, this function DOES EMIT an \n     * {AddDeposit} event. See {removeDepositFromAccount} for more details.\n     */\n    function addDepositToAccount(\n        address account,\n        address token,\n        int96 stem,\n        uint256 amount,\n        uint256 bdv,\n        Transfer transferType\n    ) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 depositId = LibBytes.packAddressAndStem(\n            token,\n            stem\n        );\n\n        // add amount to the deposits, and update the deposit.\n        s.a[account].deposits[depositId].amount = \n            s.a[account].deposits[depositId].amount.add(amount.toUint128());\n        s.a[account].deposits[depositId].bdv = \n            s.a[account].deposits[depositId].bdv.add(bdv.toUint128());\n        \n        // update the mow status (note: mow status is per token, not per depositId)\n        // SafeMath not necessary as the bdv is already checked to be <= type(uint128).max\n        s.a[account].mowStatuses[token].bdv = uint128(s.a[account].mowStatuses[token].bdv.add(uint128(bdv)));\n\n        /** \n         *  {addDepositToAccount} is used for both depositing and transferring deposits.\n         *  In the case of a deposit, only the {TransferSingle} Event needs to be emitted.\n         *  In the case of a transfer, a different {TransferSingle}/{TransferBatch} \n         *  Event is emitted in {TokenSilo._transferDeposit(s)}, \n         *  and thus, this event is ommited.\n         */\n        if(transferType == Transfer.emitTransferSingle){\n            emit TransferSingle(\n                msg.sender, // operator\n                address(0), // from\n                account, // to\n                uint256(depositId), // depositID\n                amount // token amount\n            );\n        }\n        emit AddDeposit(account, token, stem, amount, bdv);\n    }\n\n    //////////////////////// REMOVE DEPOSIT ////////////////////////\n\n    /**\n     * @dev Remove `amount` of `token` from a user's Deposit in `stem`.\n     *\n     * A \"Crate\" refers to the existing Deposit in storage at:\n     *  `s.a[account].deposits[token][stem]`\n     *\n     * Partially removing a Deposit should scale its BDV proportionally. For ex.\n     * removing 80% of the tokens from a Deposit should reduce its BDV by 80%.\n     *\n     * During an update, `amount` & `bdv` are cast uint256 -> uint128 to\n     * optimize storage cost, since both values can be packed into one slot.\n     *\n     * This function DOES **NOT** EMIT a {RemoveDeposit} event. This\n     * asymmetry occurs because {removeDepositFromAccount} is called in a loop\n     * in places where multiple deposits are removed simultaneously, including\n     * {TokenSilo-removeDepositsFromAccount} and {TokenSilo-_transferDeposits}.\n     */\n\n    function removeDepositFromAccount(\n        address account,\n        address token,\n        int96 stem,\n        uint256 amount\n    ) internal returns (uint256 crateBDV) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 depositId = LibBytes.packAddressAndStem(token,stem);\n\n        uint256 crateAmount = s.a[account].deposits[depositId].amount;\n        crateBDV = s.a[account].deposits[depositId].bdv;\n\n        require(amount <= crateAmount, \"Silo: Crate balance too low.\");\n\n        // Partial remove\n        if (amount < crateAmount) {\n            uint256 removedBDV = amount.mul(crateBDV).div(crateAmount);\n            uint256 updatedBDV = crateBDV.sub(removedBDV);\n            uint256 updatedAmount = crateAmount.sub(amount);\n\n            // SafeCast unnecessary b/c updatedAmount <= crateAmount and updatedBDV <= crateBDV, which are both <= type(uint128).max\n            s.a[account].deposits[depositId].amount = uint128(updatedAmount);\n            s.a[account].deposits[depositId].bdv = uint128(updatedBDV);\n            //remove from the mow status bdv amount, which keeps track of total token deposited per farmer\n            s.a[account].mowStatuses[token].bdv = s.a[account].mowStatuses[token].bdv.sub(\n                removedBDV.toUint128()\n            );\n            return removedBDV;\n        }\n        // Full remove\n        if (crateAmount > 0) delete s.a[account].deposits[depositId];\n\n\n        // SafeMath unnecessary b/c crateBDV <= type(uint128).max\n        s.a[account].mowStatuses[token].bdv = s.a[account].mowStatuses[token].bdv.sub(\n            uint128(crateBDV)\n        );\n    }\n\n    //////////////////////// GETTERS ////////////////////////\n\n    /**\n     * @dev Calculate the BDV (\"Bean Denominated Value\") for `amount` of `token`.\n     * \n     * Makes a call to a BDV function defined in the SiloSettings for this \n     * `token`. See {AppStorage.sol:Storage-SiloSettings} for more information.\n     */\n    function beanDenominatedValue(address token, uint256 amount)\n        internal\n        view\n        returns (uint256 bdv)\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        require(s.ss[token].selector != bytes4(0), \"Silo: Token not whitelisted\");\n\n        (bool success, bytes memory data) = address(this).staticcall(\n            encodeBdvFunction(\n                token,\n                s.ss[token].encodeType,\n                s.ss[token].selector,\n                amount\n            )\n        );\n\n        if (!success) {\n            if (data.length == 0) revert();\n            assembly {\n                revert(add(32, data), mload(data))\n            }\n        }\n\n        assembly {\n            bdv := mload(add(data, add(0x20, 0)))\n        }\n    }\n\n    function encodeBdvFunction(\n        address token,\n        bytes1 encodeType,\n        bytes4 selector,\n        uint256 amount\n    )\n        internal\n        pure\n        returns (bytes memory callData)\n    {\n        if (encodeType == 0x00) {\n            callData = abi.encodeWithSelector(\n                selector,\n                amount\n            );\n        } else if (encodeType == 0x01) {\n            callData = abi.encodeWithSelector(\n                selector,\n                token,\n                amount\n            );\n        } else {\n            revert(\"Silo: Invalid encodeType\");\n        }\n    }\n\n    /**\n     * @dev Locate the `amount` and `bdv` for a user's Deposit in storage.\n     * \n     * Silo V3 Deposits are stored within each {Account} as a mapping of:\n     *  `uint256 DepositID => { uint128 amount, uint128 bdv }`\n     *  The DepositID is the concatination of the token address and the stem.\n     * \n     * Silo V2 deposits are only usable after a successful migration, see\n     * mowAndMigrate within the Migration facet.\n     *\n     */\n    function getDeposit(\n        address account,\n        address token,\n        int96 stem\n    ) internal view returns (uint256 amount, uint256 bdv) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 depositId = LibBytes.packAddressAndStem(\n            token,\n            stem\n        );\n        amount = s.a[account].deposits[depositId].amount;\n        bdv = s.a[account].deposits[depositId].bdv;\n    }\n    \n    /**\n     * @dev Get the number of Stalk per BDV per Season for a whitelisted token. Formerly just seeds.\n     * Note this is stored as 1e6, i.e. 1_000_000 units of this is equal to 1 old seed.\n     */\n    function stalkEarnedPerSeason(address token) internal view returns (uint256) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return uint256(s.ss[token].stalkEarnedPerSeason);\n    }\n\n    /**\n     * @dev Get the number of Stalk per BDV for a whitelisted token. Formerly just stalk.\n     */\n    function stalkIssuedPerBdv(address token) internal view returns (uint256) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return uint256(s.ss[token].stalkIssuedPerBdv);\n    }\n\n    /**\n     * @dev returns the cumulative stalk per BDV (stemTip) for a whitelisted token. \n     * Does not truncate the value, i.e. divide by 1e6\n     */\n    function stemTipForTokenUntruncated(address token)\n        internal\n        view\n        returns (int96 _stemTipForToken)\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        \n        // SafeCast unnecessary because all casted variables are types smaller that int96.\n        _stemTipForToken = s.ss[token].milestoneStem +\n        int96(s.ss[token].stalkEarnedPerSeason).mul(\n            int96(s.season.current).sub(int96(s.ss[token].milestoneSeason))\n        );\n    }\n\n    /**\n     * @dev returns the cumulative stalk per BDV (stemTip) for a whitelisted token.\n     */\n    function stemTipForToken(address token)\n        internal\n        view\n        returns (int96 _stemTipForToken)\n    {\n        return stemTipForTokenUntruncated(token).div(1e6);\n    }\n\n    /**\n     * @dev returns the amount of grown stalk a deposit has earned.\n     */\n    function grownStalkForDeposit(\n        address account,\n        address token,\n        int96 stem\n    )\n        internal\n        view\n        returns (uint grownStalk)\n    {\n        // stemTipForToken(token) > depositGrownStalkPerBdv for all valid Deposits\n        int96 _stemTip = stemTipForToken(token);\n        require(stem <= _stemTip, \"Silo: Invalid Deposit\");\n         // The check in the above line guarantees that subtraction result is positive\n         // and thus the cast to `uint256` is safe.\n        uint deltaStemTip = uint256(_stemTip.sub(stem));\n        (, uint bdv) = getDeposit(account, token, stem);\n\n        grownStalk = deltaStemTip.mul(bdv);\n    }\n\n    /**\n     * @dev returns the amount of grown stalk a deposit would have, based on the stem of the deposit.\n     */\n    function calculateStalkFromStemAndBdv(address token, int96 grownStalkIndexOfDeposit, uint256 bdv)\n        internal\n        view\n        returns (int96 grownStalk)\n    {\n        // current latest grown stalk index\n        int96 _stemTipForToken = stemTipForToken(address(token));\n\n        return _stemTipForToken.sub(grownStalkIndexOfDeposit).mul(toInt96(bdv));\n    }\n\n    /**\n     * @dev returns the stem of a deposit, based on the amount of grown stalk it has earned.\n     */\n    function calculateGrownStalkAndStem(address token, uint256 grownStalk, uint256 bdv)\n        internal\n        view \n        returns (uint256 _grownStalk, int96 stem)\n    {\n        int96 _stemTipForToken = stemTipForToken(token);\n        stem = _stemTipForToken.sub(to"
    }
  ]
}