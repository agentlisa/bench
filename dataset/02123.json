{
  "Title": "H-1: Adversary can sandwich oracle updates to exploit vault",
  "Content": "# Issue H-1: Adversary can sandwich oracle updates to exploit vault \n\nSource: https://github.com/sherlock-audit/2023-03-olympus-judging/issues/1 \n\n## Found by \n0x52\n\n## Summary\n\nBLVaultLido added a mechanism to siphon off all wstETH obtained from mismatched pool and oracle prices. This was implemented to fix the problem that the vault could be manipulated to the attackers gain. This mitigation however does not fully address the issue and the same issue is still exploitable by sandwiching oracle update.\n\n## Vulnerability Detail\n\n[BLVaultLido.sol#L232-L240](https://github.com/sherlock-audit/2023-03-olympus/blob/main/sherlock-olympus/src/policies/BoostedLiquidity/BLVaultLido.sol#L232-L240)\n\n        uint256 wstethOhmPrice = manager.getTknOhmPrice();\n        uint256 expectedWstethAmountOut = (ohmAmountOut * wstethOhmPrice) / _OHM_DECIMALS;\n\n        // Take any arbs relative to the oracle price for the Treasury and return the rest to the owner\n        uint256 wstethToReturn = wstethAmountOut > expectedWstethAmountOut\n            ? expectedWstethAmountOut\n            : wstethAmountOut;\n        if (wstethAmountOut > wstethToReturn)\n            wsteth.safeTransfer(TRSRY(), wstethAmountOut - wstethToReturn);\n\nIn the above lines we can see that the current oracle price is used to calculate the expected amount of wstETH to return to the user. In theory this should prevent the attack but an attacker can side step this sandwiching the oracle update.\n\nExample:\n\nThe POC is very similar to before except now it's composed of two transactions sandwiching the oracle update. Chainlink oracles have a tolerance threshold of 0.5% before updating so we will use that as our example value. The current price is assumed to be 0.995 wstETH/OHM. The oracle price (which is about to be updated) is currently 1:1\n\n    Transaction 1:\n    \n    Balances before attack (0.995:1)\n    Liquidity: 79.8 OHM 80.2 wstETH\n    Adversary: 20 wstETH\n    \n    Swap OHM so that pool price matches pre-update oracle price:\n    Liquidity: 80 OHM 80 wstETH\n    Adversary: -0.2 OHM 20.2 wstETH\n    \n    Balances after adversary has deposited to the pool:\n    Liquidity: 100 OHM 100 wstETH\n    Adversary: -0.2 OHM 0.2 wstETH\n    \n    Balances after adversary sells wstETH for OHM (0.5% movement in price):\n    Liquidity: 99.748 OHM 100.252 wstETH\n    Adversary: 0.052 OHM -0.052 wstETH\n    \n    Sandwiched Oracle Update:\n    \n    Oracle updates price of wstETH to 0.995 OHM. Since the attacker already sold wstETH to balance \n    the pool to the post-update price they will be able to withdraw the full amount of wstETH.\n    \n    Transaction 2:\n    \n    Balances after adversary removes their liquidity:\n    Liquidity: 79.798 OHM 80.202 wstETH\n    Adversary: 0.052 OHM 19.998 wstETH\n    \n    Balances after selling profited OHM:\n    Liquidity: 79.849 OHM 80.152 wstETH\n    Adversary: 20.05 wstETH\n\nAs shown above it's still profitable to exploit the vault by sandwiching the oracle updates. With each oracle update the pool can be repeatedly attacked causing large losses.\n\n## Impact\n\nVault will be attacked repeatedly for large losses\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-03-olympus/blob/main/sherlock-olympus/src/policies/BoostedLiquidity/BLVaultLido.sol#L203-L256\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nTo prevent this I would recommend locking the user into the vault for some minimum amount of time (i.e. 24 hours)\n\n## Discussion\n\n**0xLienid**\n\nThis is kind of similar to #029 in terms of underlying cause (knowledge of oracle update price)\n\n**0xLienid**\n\nFix Implementation: https://github.com/0xLienid/sherlock-olympus/pull/3/files\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/60",
  "Code": [
    {
      "filename": "sherlock-olympus/src/policies/BoostedLiquidity/BLVaultLido.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// Import system dependencies\nimport {IBLVaultLido, RewardsData} from \"policies/BoostedLiquidity/interfaces/IBLVaultLido.sol\";\nimport {IBLVaultManagerLido} from \"policies/BoostedLiquidity/interfaces/IBLVaultManagerLido.sol\";\nimport {BLVaultManagerLido} from \"policies/BoostedLiquidity/BLVaultManagerLido.sol\";\n\n// Import external dependencies\nimport {JoinPoolRequest, ExitPoolRequest, IVault, IBasePool} from \"policies/BoostedLiquidity/interfaces/IBalancer.sol\";\nimport {IAuraBooster, IAuraRewardPool, IAuraMiningLib} from \"policies/BoostedLiquidity/interfaces/IAura.sol\";\n\n// Import types\nimport {OlympusERC20Token} from \"src/external/OlympusERC20.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\n// Import libraries\nimport {Clone} from \"clones/Clone.sol\";\nimport {TransferHelper} from \"libraries/TransferHelper.sol\";\nimport {FullMath} from \"libraries/FullMath.sol\";\n\ncontract BLVaultLido is IBLVaultLido, Clone {\n    using TransferHelper for ERC20;\n    using FullMath for uint256;\n\n    // ========= ERRORS ========= //\n\n    error BLVaultLido_AlreadyInitialized();\n    error BLVaultLido_OnlyOwner();\n    error BLVaultLido_Inactive();\n    error BLVaultLido_Reentrancy();\n    error BLVaultLido_AuraDepositFailed();\n\n    // ========= EVENTS ========= //\n\n    event Deposit(uint256 ohmAmount, uint256 wstethAmount);\n    event Withdraw(uint256 ohmAmount, uint256 wstethAmount);\n    event RewardsClaimed(address indexed rewardsToken, uint256 amount);\n\n    // ========= STATE VARIABLES ========= //\n\n    uint256 private constant _OHM_DECIMALS = 1e9;\n    uint256 private constant _WSTETH_DECIMALS = 1e18;\n\n    uint256 private _reentrancyStatus;\n\n    // ========= CONSTRUCTOR ========= //\n\n    constructor() {}\n\n    // ========= INITIALIZER ========= //\n\n    function initializeClone() external {\n        if (_reentrancyStatus != 0) revert BLVaultLido_AlreadyInitialized();\n        _reentrancyStatus = 1;\n    }\n\n    // ========= IMMUTABLE CLONE ARGS ========= //\n\n    function owner() public pure returns (address) {\n        return _getArgAddress(0);\n    }\n\n    function manager() public pure returns (BLVaultManagerLido) {\n        return BLVaultManagerLido(_getArgAddress(20));\n    }\n\n    function TRSRY() public pure returns (address) {\n        return _getArgAddress(40);\n    }\n\n    function MINTR() public pure returns (address) {\n        return _getArgAddress(60);\n    }\n\n    function ohm() public pure returns (OlympusERC20Token) {\n        return OlympusERC20Token(_getArgAddress(80));\n    }\n\n    function wsteth() public pure returns (ERC20) {\n        return ERC20(_getArgAddress(100));\n    }\n\n    function aura() public pure returns (ERC20) {\n        return ERC20(_getArgAddress(120));\n    }\n\n    function bal() public pure returns (ERC20) {\n        return ERC20(_getArgAddress(140));\n    }\n\n    function vault() public pure returns (IVault) {\n        return IVault(_getArgAddress(160));\n    }\n\n    function liquidityPool() public pure returns (IBasePool) {\n        return IBasePool(_getArgAddress(180));\n    }\n\n    function pid() public pure returns (uint256) {\n        return _getArgUint256(200);\n    }\n\n    function auraBooster() public pure returns (IAuraBooster) {\n        return IAuraBooster(_getArgAddress(232));\n    }\n\n    function auraRewardPool() public pure returns (IAuraRewardPool) {\n        return IAuraRewardPool(_getArgAddress(252));\n    }\n\n    function fee() public pure returns (uint64) {\n        return _getArgUint64(272);\n    }\n\n    // ========= MODIFIERS ========= //\n\n    modifier onlyOwner() {\n        if (msg.sender != owner()) revert BLVaultLido_OnlyOwner();\n        _;\n    }\n\n    modifier onlyWhileActive() {\n        if (!manager().isLidoBLVaultActive()) revert BLVaultLido_Inactive();\n        _;\n    }\n\n    modifier nonReentrant() {\n        if (_reentrancyStatus != 1) revert BLVaultLido_Reentrancy();\n\n        _reentrancyStatus = 2;\n\n        _;\n\n        _reentrancyStatus = 1;\n    }\n\n    //============================================================================================//\n    //                                      LIQUIDITY FUNCTIONS                                   //\n    //============================================================================================//\n\n    /// @inheritdoc IBLVaultLido\n    function deposit(\n        uint256 amount_,\n        uint256 minLpAmount_\n    ) external override onlyWhileActive onlyOwner nonReentrant returns (uint256 lpAmountOut) {\n        // Cache variables into memory\n        IBLVaultManagerLido manager = manager();\n        OlympusERC20Token ohm = ohm();\n        ERC20 wsteth = wsteth();\n        IBasePool liquidityPool = liquidityPool();\n        IAuraBooster auraBooster = auraBooster();\n\n        // Calculate OHM amount to mint\n        // getOhmTknPrice returns the amount of OHM per 1 wstETH\n        uint256 ohmWstethPrice = manager.getOhmTknPrice();\n        uint256 ohmMintAmount = (amount_ * ohmWstethPrice) / _WSTETH_DECIMALS;\n\n        // Block scope to avoid stack too deep\n        {\n            // Cache OHM-wstETH BPT before\n            uint256 bptBefore = liquidityPool.balanceOf(address(this));\n\n            // Transfer in wstETH\n            wsteth.safeTransferFrom(msg.sender, address(this), amount_);\n\n            // Mint OHM\n            manager.mintOhmToVault(ohmMintAmount);\n\n            // Join Balancer pool\n            _joinBalancerPool(ohmMintAmount, amount_, minLpAmount_);\n\n            // OHM-PAIR BPT after\n            lpAmountOut = liquidityPool.balanceOf(address(this)) - bptBefore;\n            manager.increaseTotalLp(lpAmountOut);\n\n            // Stake into Aura\n            liquidityPool.approve(address(auraBooster), lpAmountOut);\n            bool depositSuccess = auraBooster.deposit(pid(), lpAmountOut, true);\n            if (!depositSuccess) revert BLVaultLido_AuraDepositFailed();\n        }\n\n        // Return unused tokens\n        uint256 unusedOhm = ohm.balanceOf(address(this));\n        uint256 unusedWsteth = wsteth.balanceOf(address(this));\n\n        if (unusedOhm > 0) {\n            ohm.increaseAllowance(MINTR(), unusedOhm);\n            manager.burnOhmFromVault(unusedOhm);\n        }\n\n        if (unusedWsteth > 0) {\n            wsteth.safeTransfer(msg.sender, unusedWsteth);\n        }\n\n        // Emit event\n        emit Deposit(ohmMintAmount - unusedOhm, amount_ - unusedWsteth);\n\n        return lpAmountOut;\n    }\n\n    /// @inheritdoc IBLVaultLido\n    function withdraw(\n        uint256 lpAmount_,\n        uint256[] calldata minTokenAmounts_,\n        bool claim_\n    ) external override onlyWhileActive onlyOwner nonReentrant returns (uint256, uint256) {\n        // Cache variables into memory\n        OlympusERC20Token ohm = ohm();\n        ERC20 wsteth = wsteth();\n        IBLVaultManagerLido manager = manager();\n\n        // Cache OHM and wstETH balances before\n        uint256 ohmBefore = ohm.balanceOf(address(this));\n        uint256 wstethBefore = wsteth.balanceOf(address(this));\n\n        // Decrease total LP\n        manager.decreaseTotalLp(lpAmount_);\n\n        // Unstake from Aura\n        auraRewardPool().withdrawAndUnwrap(lpAmount_, claim_);\n\n        // Exit Balancer pool\n        _exitBalancerPool(lpAmount_, minTokenAmounts_);\n\n        // Calculate OHM and wstETH amounts received\n        uint256 ohmAmountOut = ohm.balanceOf(address(this)) - ohmBefore;\n        uint256 wstethAmountOut = wsteth.balanceOf(address(this)) - wstethBefore;\n\n        // Calculate oracle expected wstETH received amount\n        // getTknOhmPrice returns the amount of wstETH per 1 OHM based on the oracle price\n        uint256 wstethOhmPrice = manager.getTknOhmPrice();\n        uint256 expectedWstethAmountOut = (ohmAmountOut * wstethOhmPrice) / _OHM_DECIMALS;\n\n        // Take any arbs relative to the oracle price for the Treasury and return the rest to the owner\n        uint256 wstethToReturn = wstethAmountOut > expectedWstethAmountOut\n            ? expectedWstethAmountOut\n            : wstethAmountOut;\n        if (wstethAmountOut > wstethToReturn)\n            wsteth.safeTransfer(TRSRY(), wstethAmountOut - wstethToReturn);\n\n        // Burn OHM\n        ohm.increaseAllowance(MINTR(), ohmAmountOut);\n        manager.burnOhmFromVault(ohmAmountOut);\n\n        // Return wstETH to owner\n        wsteth.safeTransfer(msg.sender, wstethToReturn);\n\n        // Return rewards to owner\n        if (claim_) _sendRewards();\n\n        // Emit event\n        emit Withdraw(ohmAmountOut, wstethToReturn);\n\n        return (ohmAmountOut, wstethToReturn);\n    }\n\n    //============================================================================================//\n    //                                       REWARDS FUNCTIONS                                    //\n    //============================================================================================//\n\n    /// @inheritdoc IBLVaultLido\n    function claimRewards() external override onlyWhileActive onlyOwner nonReentrant {\n        // Claim rewards from Aura\n        auraRewardPool().getReward(owner(), true);\n\n        // Send rewards to owner\n        _sendRewards();\n    }\n\n    //============================================================================================//\n    //                                        VIEW FUNCTIONS                                      //\n    //============================================================================================//\n\n    /// @inheritdoc IBLVaultLido\n    function getLpBalance() public view override returns (uint256) {\n        return auraRewardPool().balanceOf(address(this));\n    }\n\n    /// @inheritdoc IBLVaultLido\n    function getUserPairShare() public view override returns (uint256) {\n        // If total supply is 0 return 0\n        if (liquidityPool().totalSupply() == 0) return 0;\n\n        // Get user's LP balance\n        uint256 userLpBalance = getLpBalance();\n\n        // Get pool balances\n        (, uint256[] memory balances, ) = vault().getPoolTokens(liquidityPool().getPoolId());\n\n        // Get user's share of the wstETH\n        uint256 userWstethShare = (userLpBalance * balances[1]) / liquidityPool().totalSupply();\n\n        // Check pool against oracle price\n        // getTknOhmPrice returns the amount of wstETH per 1 OHM based on the oracle price\n        uint256 wstethOhmPrice = manager().getTknOhmPrice();\n        uint256 userOhmShare = (userLpBalance * balances[0]) / liquidityPool().totalSupply();\n        uint256 expectedWstethShare = (userOhmShare * wstethOhmPrice) / _OHM_DECIMALS;\n\n        return userWstethShare > expectedWstethShare ? expectedWstethShare : userWstethShare;\n    }\n\n    /// @inheritdoc IBLVaultLido\n    function getOutstandingRewards() public view override returns (RewardsData[] memory) {\n        uint256 numExtraRewards = auraRewardPool().extraRewardsLength();\n        RewardsData[] memory rewards = new RewardsData[](numExtraRewards + 2);\n\n        // Get Bal reward\n        uint256 balRewards = auraRewardPool().earned(address(this));\n        rewards[0] = RewardsData({rewardToken: address(bal()), outstandingRewards: balRewards});\n\n        // Get Aura rewards\n        uint256 auraRewards = manager().auraMiningLib().convertCrvToCvx(balRewards);\n        rewards[1] = RewardsData({rewardToken: address(aura()), outstandingRewards: auraRewards});\n\n        // Get extra rewards\n        for (uint256 i; i < numExtraRewards; ) {\n            IAuraRewardPool extraRewardPool = IAuraRewardPool(auraRewardPool().extraRewards(i));\n\n            address extraRewardToken = extraRewardPool.rewardToken();\n            uint256 extraRewardAmount = extraRewardPool.earned(address(this));\n\n            rewards[i + 2] = RewardsData({\n                rewardToken: extraRewardToken,\n                outstandingRewards: extraRewardAmount\n            });\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return rewards;\n    }\n\n    //============================================================================================//\n    //                                      INTERNAL FUNCTIONS                                    //\n    //============================================================================================//\n\n    function _joinBalancerPool(\n        uint256 ohmAmount_,\n        uint256 wstethAmount_,\n        uint256 minLpAmount_\n    ) internal {\n        // Cache variables to memory\n        OlympusERC20Token ohm = ohm();\n        ERC20 wsteth = wsteth();\n        IVault vault = vault();\n\n        // Build join pool request\n        address[] memory assets = new address[](2);\n        assets[0] = address(ohm);\n        assets[1] = address(wsteth);\n\n        uint256[] memory maxAmountsIn = new uint256[](2);\n        maxAmountsIn[0] = ohmAmount_;\n        maxAmountsIn[1] = wstethAmount_;\n\n        JoinPoolRequest memory joinPoolRequest = JoinPoolRequest({\n            assets: assets,\n            maxAmountsIn: maxAmountsIn,\n            userData: abi.encode(1, maxAmountsIn, minLpAmount_),\n            fromInternalBalance: false\n        });\n\n        // Join pool\n        ohm.increaseAllowance(address(vault), ohmAmount_);\n        wsteth.approve(address(vault), wstethAmount_);\n        vault.joinPool(liquidityPool().getPoolId(), address(this), address(this), joinPoolRequest);\n    }\n\n    function _exitBalancerPool(uint256 lpAmount_, uint256[] calldata minTokenAmounts_) internal {\n        // Cache variables to memory\n        OlympusERC20Token ohm = ohm();\n        ERC20 wsteth = wsteth();\n        IBasePool liquidityPool = liquidityPool();\n        IVault vault = vault();\n\n        // Build exit pool request\n        address[] memory assets = new address[](2);\n        assets[0] = address(ohm);\n        assets[1] = address(wsteth);\n\n        ExitPoolRequest memory exitPoolRequest = ExitPoolRequest({\n            assets: assets,\n            minAmountsOut: minTokenAmounts_,\n            userData: abi.encode(1, lpAmount_),\n            toInternalBalance: false\n        });\n\n        // Exit Balancer pool\n        liquidityPool.approve(address(vault), lpAmount_);\n        vault.exitPool(\n            liquidityPool.getPoolId(),\n            address(this),\n            payable(address(this)),\n            exitPoolRequest\n        );\n    }\n\n    function _sendRewards() internal {\n        // Send Bal rewards to owner\n        {\n            uint256 balRewards = bal().balanceOf(address(this));\n            uint256 balFee = (balRewards * fee()) / 10_000;\n            if (balRewards - balFee > 0) {\n                bal().safeTransfer(owner(), balRewards - balFee);\n                emit RewardsClaimed(address(bal()), balRewards - balFee);\n            }\n            if (balFee > 0) bal().safeTransfer(TRSRY(), balFee);\n        }\n\n        // Send Aura rewards to owner\n        {\n            uint256 auraRewards = aura().balanceOf(address(this));\n            uint256 auraFee = (auraRewards * fee()) / 10_000;\n            if (auraRewards - auraFee > 0) {\n                aura().safeTransfer(owner(), auraRewards - auraFee);\n                emit RewardsClaimed(address(aura()), auraRewards - auraFee);\n            }\n            if (auraFee > 0) aura().safeTransfer(TRSRY(), auraFee);\n        }\n\n        // Send extra rewards to owner\n        {\n            uint256 numExtraRewards = auraRewardPool().extraRewardsLength();\n            for (uint256 i; i < numExtraRewards; ) {\n                IAuraRewardPool extraRewardPool = IAuraRewardPool(auraRewardPool().extraRewards(i));\n                ERC20 extraRewardToken = ERC20(extraRewardPool.rewardToken());\n\n                uint256 extraRewardAmount = extraRewardToken.balanceOf(address(this));\n                uint256 extraRewardFee = (extraRewardAmount * fee()) / 10_000;\n                if (extraRewardAmount - extraRewardFee > 0) {\n                    extraRewardToken.safeTransfer(owner(), extraRewardAmount - extraRewardFee);\n                    emit RewardsClaimed(\n                        address(extraRewardToken),\n                        extraRewardAmount - extraRewardFee\n                    );\n                }\n                if (extraRewardFee > 0) extraRewardToken.safeTransfer(TRSRY(), extraRewardFee);\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n    }\n}"
    },
    {
      "filename": "sherlock-olympus/src/policies/BoostedLiquidity/BLVaultLido.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// Import system dependencies\nimport {IBLVaultLido, RewardsData} from \"policies/BoostedLiquidity/interfaces/IBLVaultLido.sol\";\nimport {IBLVaultManagerLido} from \"policies/BoostedLiquidity/interfaces/IBLVaultManagerLido.sol\";\nimport {BLVaultManagerLido} from \"policies/BoostedLiquidity/BLVaultManagerLido.sol\";\n\n// Import external dependencies\nimport {JoinPoolRequest, ExitPoolRequest, IVault, IBasePool} from \"policies/BoostedLiquidity/interfaces/IBalancer.sol\";\nimport {IAuraBooster, IAuraRewardPool, IAuraMiningLib} from \"policies/BoostedLiquidity/interfaces/IAura.sol\";\n\n// Import types\nimport {OlympusERC20Token} from \"src/external/OlympusERC20.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\n// Import libraries\nimport {Clone} from \"clones/Clone.sol\";\nimport {TransferHelper} from \"libraries/TransferHelper.sol\";\nimport {FullMath} from \"libraries/FullMath.sol\";\n\ncontract BLVaultLido is IBLVaultLido, Clone {\n    using TransferHelper for ERC20;\n    using FullMath for uint256;\n\n    // ========= ERRORS ========= //\n\n    error BLVaultLido_AlreadyInitialized();\n    error BLVaultLido_OnlyOwner();\n    error BLVaultLido_Inactive();\n    error BLVaultLido_Reentrancy();\n    error BLVaultLido_AuraDepositFailed();\n\n    // ========= EVENTS ========= //\n\n    event Deposit(uint256 ohmAmount, uint256 wstethAmount);\n    event Withdraw(uint256 ohmAmount, uint256 wstethAmount);\n    event RewardsClaimed(address indexed rewardsToken, uint256 amount);\n\n    // ========= STATE VARIABLES ========= //\n\n    uint256 private constant _OHM_DECIMALS = 1e9;\n    uint256 private constant _WSTETH_DECIMALS = 1e18;\n\n    uint256 private _reentrancyStatus;\n\n    // ========= CONSTRUCTOR ========= //\n\n    constructor() {}\n\n    // ========= INITIALIZER ========= //\n\n    function initializeClone() external {\n        if (_reentrancyStatus != 0) revert BLVaultLido_AlreadyInitialized();\n        _reentrancyStatus = 1;\n    }\n\n    // ========= IMMUTABLE CLONE ARGS ========= //\n\n    function owner() public pure returns (address) {\n        return _getArgAddress(0);\n    }\n\n    function manager() public pure returns (BLVaultManagerLido) {\n        return BLVaultManagerLido(_getArgAddress(20));\n    }\n\n    function TRSRY() public pure returns (address) {\n        return _getArgAddress(40);\n    }\n\n    function MINTR() public pure returns (address) {\n        return _getArgAddress(60);\n    }\n\n    function ohm() public pure returns (OlympusERC20Token) {\n        return OlympusERC20Token(_getArgAddress(80));\n    }\n\n    function wsteth() public pure returns (ERC20) {\n        return ERC20(_getArgAddress(100));\n    }\n\n    function aura() public pure returns (ERC20) {\n        return ERC20(_getArgAddress(120));\n    }\n\n    function bal() public pure returns (ERC20) {\n        return ERC20(_getArgAddress(140));\n    }\n\n    function vault() public pure returns (IVault) {\n        return IVault(_getArgAddress(160));\n    }\n\n    function liquidityPool() public pure returns (IBasePool) {\n        return IBasePool(_getArgAddress(180));\n    }\n\n    function pid() public pure returns (uint256) {\n        return _getArgUint256(200);\n    }\n\n    function auraBooster() public pure returns (IAuraBooster) {\n        return IAuraBooster(_getArgAddress(232));\n    }\n\n    function auraRewardPool() public pure returns (IAuraRewardPool) {\n        return IAuraRewardPool(_getArgAddress(252));\n    }\n\n    function fee() public pure returns (uint64) {\n        return _getArgUint64(272);\n    }\n\n    // ========= MODIFIERS ========= //\n\n    modifier onlyOwner() {\n        if (msg.sender != owner()) revert BLVaultLido_OnlyOwner();\n        _;\n    }\n\n    modifier onlyWhileActive() {\n        if (!manager().isLidoBLVaultActive()) revert BLVaultLido_Inactive();\n        _;\n    }\n\n    modifier nonReentrant() {\n        if (_reentrancyStatus != 1) revert BLVaultLido_Reentrancy();\n\n        _reentrancyStatus = 2;\n\n        _;\n\n        _reentrancyStatus = 1;\n    }\n\n    //============================================================================================//\n    //                                      LIQUIDITY FUNCTIONS                                   //\n    //============================================================================================//\n\n    /// @inheritdoc IBLVaultLido\n    function deposit(\n        uint256 amount_,\n        uint256 minLpAmount_\n    ) external override onlyWhileActive onlyOwner nonReentrant returns (uint256 lpAmountOut) {\n        // Cache variables into memory\n        IBLVaultManagerLido manager = manager();\n        OlympusERC20Token ohm = ohm();\n        ERC20 wsteth = wsteth();\n        IBasePool liquidityPool = liquidityPool();\n        IAuraBooster auraBooster = auraBooster();\n\n        // Calculate OHM amount to mint\n        // getOhmTknPrice returns the amount of OHM per 1 wstETH\n        uint256 ohmWstethPrice = manager.getOhmTknPrice();\n        uint256 ohmMintAmount = (amount_ * ohmWstethPrice) / _WSTETH_DECIMALS;\n\n        // Block scope to avoid stack too deep\n        {\n            // Cache OHM-wstETH BPT before\n            uint256 bptBefore = liquidityPool.balanceOf(address(this));\n\n            // Transfer in wstETH\n            wsteth.safeTransferFrom(msg.sender, address(this), amount_);\n\n            // Mint OHM\n            manager.mintOhmToVault(ohmMintAmount);\n\n            // Join Balancer pool\n            _joinBalancerPool(ohmMintAmount, amount_, minLpAmount_);\n\n            // OHM-PAIR BPT after\n            lpAmountOut = liquidityPool.balanceOf(address(this)) - bptBefore;\n            manager.increaseTotalLp(lpAmountOut);\n\n            // Stake into Aura\n            liquidityPool.approve(address(auraBooster), lpAmountOut);\n            bool depositSuccess = auraBooster.deposit(pid(), lpAmountOut, true);\n            if (!depositSuccess) revert BLVaultLido_AuraDepositFailed();\n        }\n\n        // Return unused tokens\n        uint256 unusedOhm = ohm.balanceOf(address(this));\n        uint256 unusedWsteth = wsteth.balanceOf(address(this));\n\n        if (unusedOhm > 0) {\n            ohm.increaseAllowance(MINTR(), unusedOhm);\n            manager.burnOhmFromVault(unusedOhm);\n        }\n\n        if (unusedWsteth > 0) {\n            wsteth.safeTransfer(msg.sender, unusedWsteth);\n        }\n\n        // Emit event\n        emit Deposit(ohmMintAmount - unusedOhm, amount_ - unusedWsteth);\n\n        return lpAmountOut;\n    }\n\n    /// @inheritdoc IBLVaultLido\n    function withdraw(\n        uint256 lpAmount_,\n        uint256[] calldata minTokenAmounts_,\n        bool claim_\n    ) external override onlyWhileActive onlyOwner nonReentrant returns (uint256, uint256) {\n        // Cache variables into memory\n        OlympusERC20Token ohm = ohm();\n        ERC20 wsteth = wsteth();\n        IBLVaultManagerLido manager = manager();\n\n        // Cache OHM and wstETH balances before\n        uint256 ohmBefore = ohm.balanceOf(address(this));\n        uint256 wstethBefore = wsteth.balanceOf(address(this));\n\n        // Decrease total LP\n        manager.decreaseTotalLp(lpAmount_);\n\n        // Unstake from Aura\n        auraRewardPool().withdrawAndUnwrap(lpAmount_, claim_);\n\n        // Exit Balancer pool\n        _exitBalancerPool(lpAmount_, minTokenAmounts_);\n\n        // Calculate OHM and wstETH amounts received\n        uint256 ohmAmountOut = ohm.balanceOf(address(this)) - ohmBefore;\n        uint256 wstethAmountOut = wsteth.balanceOf(address(this)) - wstethBefore;\n\n        // Calculate oracle expected wstETH received amount\n        // getTknOhmPrice returns the amount of wstETH per 1 OHM based on the oracle price\n        uint256 wstethOhmPrice = manager.getTknOhmPrice();\n        uint256 expectedWstethAmountOut = (ohmAmountOut * wstethOhmPrice) / _OHM_DECIMALS;\n\n        // Take any arbs relative to the oracle price for the Treasury and return the rest to the owner\n        uint256 wstethToReturn = wstethAmountOut > expectedWstethAmountOut\n            ? expectedWstethAmountOut\n            : wstethAmountOut;\n        if (wstethAmountOut > wstethToReturn)\n            wsteth.safeTransfer(TRSRY(), wstethAmountOut - wstethToReturn);\n\n        // Burn OHM\n        ohm.increaseAllowance(MINTR(), ohmAmountOut);\n        manager.burnOhmFromVault(ohmAmountOut);\n\n        // Return wstETH to owner\n        wsteth.safeTransfer(msg.sender, wstethToReturn);\n\n        // Return rewards to owner\n        if (claim_) _sendRewards();\n\n        // Emit event\n        emit Withdraw(ohmAmountOut, wstethToReturn);\n\n        return (ohmAmountOut, wstethToReturn);\n    }\n\n    //============================================================================================//\n    //                                       REWARDS FUNCTIONS                                    //\n    //============================================================================================//\n\n    /// @inheritdoc IBLVaultLido\n    function claimRewards() external override onlyWhileActive onlyOwner nonReentrant {\n        // Claim rewards from Aura\n        auraRewardPool().getReward(owner(), true);\n\n        // Send rewards to owner\n        _sendRewards();\n    }\n\n    //============================================================================================//\n    //                                        VIEW FUNCTIONS                                      //\n    //============================================================================================//\n\n    /// @inheritdoc IBLVaultLido\n    function getLpBalance() public view override returns (uint256) {\n        return auraRewardPool().balanceOf(address(this));\n    }\n\n    /// @inheritdoc IBLVaultLido\n    function getUserPairShare() public view override returns (uint256) {\n        // If total supply is 0 return 0\n        if (liquidityPool().totalSupply() == 0) return 0;\n\n        // Get user's LP balance\n        uint256 userLpBalance = getLpBalance();\n\n        // Get pool balances\n        (, uint256[] memory balances, ) = vault().getPoolTokens(liquidityPool().getPoolId());\n\n        // Get user's share of the wstETH\n        uint256 userWstethShare = (userLpBalance * balances[1]) / liquidityPool().totalSupply();\n\n        // Check pool against oracle price\n        // getTknOhmPrice returns the amount of wstETH per 1 OHM based on the oracle price\n        uint256 wstethOhmPrice = manager().getTknOhmPrice();\n        uint256 userOhmShare = (userLpBalance * balances[0]) / liquidityPool().totalSupply();\n        uint256 expectedWstethShare = (userOhmShare * wstethOhmPrice) / _OHM_DECIMALS;\n\n        return userWstethShare > expectedWstethShare ? expectedWstethShare : userWstethShare;\n    }\n\n    /// @inheritdoc IBLVaultLido\n    function getOutstandingRewards() public view override returns (RewardsData[] memory) {\n        uint256 numExtraRewards = auraRewardPool().extraRewardsLength();\n        RewardsData[] memory rewards = new RewardsData[](numExtraRewards + 2);\n\n        // Get Bal reward\n        uint256 balRewards = auraRewardPool().earned(address(this));\n        rewards[0] = RewardsData({rewardToken: address(bal()), outstandingRewards: balRewards});\n\n        // Get Aura rewards\n        uint256 auraRewards = manager().auraMiningLib().convertCrvToCvx(balRewards);\n        rewards[1] = RewardsData({rewardToken: address(aura()), outstandingRewards: auraRewards});\n\n        // Get extra rewards\n        for (uint256 i; i < numExtraRewards; ) {\n            IAuraRewardPool extraRewardPool = IAuraRewardPool(auraRewardPool().extraRewards(i));\n\n            address extraRewardToken = extraRewardPool.rewardToken();\n            uint256 extraRewardAmount = extraRewardPool.earned(address(this));\n\n            rewards[i + 2] = RewardsData({\n                rewardToken: extraRewardToken,\n                outstandingRewards: extraRewardAmount\n            });\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return rewards;\n    }\n\n    //============================================================================================//\n    //                                      INTERNAL FUNCTIONS                                    //\n    //============================================================================================//\n\n    function _joinBalancerPool(\n        uint256 ohmAmount_,\n        uint256 wstethAmount_,\n        uint256 minLpAmount_\n    ) internal {\n        // Cache variables to memory\n        OlympusERC20Token ohm = ohm();\n        ERC20 wsteth = wsteth();\n        IVault vault = vault();\n\n        // Build join pool request\n        address[] memory assets = new address[](2);\n        assets[0] = address(ohm);\n        assets[1] = address(wsteth);\n\n        uint256[] memory maxAmountsIn = new uint256[](2);\n        maxAmountsIn[0] = ohmAmount_;\n        maxAmountsIn[1] = wstethAmount_;\n\n        JoinPoolRequest memory joinPoolRequest = JoinPoolRequest({\n            assets: assets,\n            maxAmountsIn: maxAmountsIn,\n            userData: abi.encode(1, maxAmountsIn, minLpAmount_),\n            fromInternalBalance: false\n        });\n\n        // Join pool\n        ohm.increaseAllowance(address(vault), ohmAmount_);\n        wsteth.approve(address(vault), wstethAmount_);\n        vault.joinPool(liquidityPool().getPoolId(), address(this), address(this), joinPoolRequest);\n    }\n\n    function _exitBalancerPool(uint256 lpAmount_, uint256[] calldata minTokenAmounts_) internal {\n        // Cache variables to memory\n        OlympusERC20Token ohm = ohm();\n        ERC20 wsteth = wsteth();\n        IBasePool liquidityPool = liquidityPool();\n        IVault vault = vault();\n\n        // Build exit pool request\n        address[] memory assets = new address[](2);\n        assets[0] = address(ohm);\n        assets[1] = address(wsteth);\n\n        ExitPoolRequest memory exitPoolRequest = ExitPoolRequest({\n            assets: assets,\n            minAmountsOut: minTokenAmounts_,\n            userData: abi.encode(1, lpAmount_),\n            toInternalBalance: false\n        });\n\n        // Exit Balancer pool\n        liquidityPool.approve(address(vault), lpAmount_);\n        vault.exitPool(\n            liquidityPool.getPoolId(),\n            address(this),\n            payable(address(this)),\n            exitPoolRequest\n        );\n    }\n\n    function _sendRewards() internal {\n        // Send Bal rewards to owner\n        {\n            uint256 balRewards = bal().balanceOf(address(this));\n            uint256 balFee = (balRewards * fee()) / 10_000;\n            if (balRewards - balFee > 0) {\n                bal().safeTransfer(owner(), balRewards - balFee);\n                emit RewardsClaimed(address(bal()), balRewards - balFee);\n            }\n            if (balFee > 0) bal().safeTransfer(TRSRY(), balFee);\n        }\n\n        // Send Aura rewards to owner\n        {\n            uint256 auraRewards = aura().balanceOf(address(this));\n            uint256 auraFee = (auraRewards * fee()) / 10_000;\n            if (auraRewards - auraFee > 0) {\n                aura().safeTransfer(owner(), auraRewards - auraFee);\n                emit RewardsClaimed(address(aura()), auraRewards - auraFee);\n            }\n            if (auraFee > 0) aura().safeTransfer(TRSRY(), auraFee);\n        }\n\n        // Send extra rewards to owner\n        {\n            uint256 numExtraRewards = auraRewardPool().extraRewardsLength();\n            for (uint256 i; i < numExtraRewards; ) {\n                IAuraRewardPool extraRewardPool = IAuraRewardPool(auraRewardPool().extraRewards(i));\n                ERC20 extraRewardToken = ERC20(extraRewardPool.rewardToken());\n\n                uint256 extraRewardAmount = extraRewardToken.balanceOf(address(this));\n                uint256 extraRewardFee = (extraRewardAmount * fee()) / 10_000;\n                if (extraRewardAmount - extraRewardFee > 0) {\n                    extraRewardToken.safeTransfer(owner(), extraRewardAmount - extraRewardFee);\n                    emit RewardsClaimed(\n                        address(extraRewardToken),\n                        extraRewardAmount - extraRewardFee\n                    );\n                }\n                if (extraRewardFee > 0) extraRewardToken.safeTransfer(TRSRY(), extraRewardFee);\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n    }\n}"
    }
  ]
}