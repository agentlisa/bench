{
  "Title": "[G-05] Use `calldata` pointer. Saves more gas than `memory` pointer",
  "Content": "\nSaves `600 GAS` in `per Loop Iterations`.\n\nCalling `calldata` instead of `memory` in the loop you have shown will save gas. This is because `calldata` is a read-only data structure, which means that it does not have to be copied into memory each time it is accessed.\n\n### `InterchainProposalExecutor.sol`:\n\nUse `calldata` instead of `memory`: Saves `250-300 GAS` per iteration.\n\nhttps://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/interchain-governance-executor/InterchainProposalExecutor.sol#L75\n\n`call` value is not changed anywhere inside the loop. So `calldata` is more efficient than `memory` to save gas.\n\n```diff\nFILE: Breadcrumbs2023-07-axelar/contracts/interchain-governance-executor/InterchainProposalExecutor.sol\n\n74: for (uint256 i = 0; i < calls.length; i++) {\n- 75:            InterchainCalls.Call memory call = calls[i];\n+ 75:            InterchainCalls.Call calldata call = calls[i];\n76:            (bool success, bytes memory result) = call.target.call{ value: call.value }(call.callData);\n77:\n78:            if (!success) {\n79:                _onTargetExecutionFailed(call, result);\n80:            } else {\n81:                _onTargetExecuted(call, result);\n82:            }\n```\n\n### `AxelarGateway.sol`:\nUse `calldata` instead of `memory`: Saves `250-300 GAS` per iteration.\n\nhttps://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/cgp/AxelarGateway.sol#L270-L277\n\n`symbol` value is not changed anywhere inside the loop. So `calldata` is more efficient than `memory` to save gas.\n\n```diff\nFILE: 2023-07-axelar/contracts/cgp/AxelarGateway.sol\n\n270: for (uint256 i; i < length; ++i) {\n- 271:            string memory symbol = symbols[i];\n+ 271:            string calldata symbol = symbols[i];\n272:            uint256 limit = limits[i];\n273:\n274:            if (tokenAddresses(symbol) == address(0)) revert TokenDoesNotExist(symbol);\n275:\n276:            _setTokenMintLimit(symbol, limit);\n277:        }\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-07-axelar",
  "Code": [
    {
      "filename": "contracts/interchain-governance-executor/InterchainProposalExecutor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Ownable } from '@openzeppelin/contracts/access/Ownable.sol';\nimport { StringToAddress } from '../gmp-sdk/util/AddressString.sol';\nimport { AxelarExecutable } from '../gmp-sdk/executable/AxelarExecutable.sol';\nimport { IInterchainProposalExecutor } from './interfaces/IInterchainProposalExecutor.sol';\nimport { InterchainCalls } from './lib/InterchainCalls.sol';\n\n/**\n * @title InterchainProposalExecutor\n * @dev This contract is intended to be the destination contract for `InterchainProposalSender` contract.\n * The proposal will be finally executed from this contract on the destination chain.\n *\n * The contract maintains whitelists for proposal senders and proposal callers. Proposal senders\n * are InterchainProposalSender contracts at the source chain and proposal callers are contracts\n * that call the InterchainProposalSender at the source chain.\n * For most governance system, the proposal caller should be the Timelock contract.\n *\n * This contract is abstract and some of its functions need to be implemented in a derived contract.\n */\ncontract InterchainProposalExecutor is IInterchainProposalExecutor, AxelarExecutable, Ownable {\n    // Whitelisted proposal callers. The proposal caller is the contract that calls the `InterchainProposalSender` at the source chain.\n    mapping(string => mapping(address => bool)) public whitelistedCallers;\n\n    // Whitelisted proposal senders. The proposal sender is the `InterchainProposalSender` contract address at the source chain.\n    mapping(string => mapping(address => bool)) public whitelistedSenders;\n\n    constructor(address _gateway, address _owner) AxelarExecutable(_gateway) {\n        _transferOwnership(_owner);\n    }\n\n    /**\n     * @dev Executes the proposal. The source address must be a whitelisted sender.\n     * @param sourceAddress The source address\n     * @param payload The payload. It is ABI encoded of the caller and calls.\n     * Where:\n     * - `caller` is the address that calls the `InterchainProposalSender` at the source chain.\n     * - `calls` is the array of `InterchainCalls.Call` to execute. Each call contains the target, value, signature and data.\n     */\n    function _execute(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) internal override {\n        _beforeProposalExecuted(sourceChain, sourceAddress, payload);\n\n        // Check that the source address is whitelisted\n        if (!whitelistedSenders[sourceChain][StringToAddress.toAddress(sourceAddress)]) {\n            revert NotWhitelistedSourceAddress();\n        }\n\n        // Decode the payload\n        (address interchainProposalCaller, InterchainCalls.Call[] memory calls) = abi.decode(payload, (address, InterchainCalls.Call[]));\n\n        // Check that the caller is whitelisted\n        if (!whitelistedCallers[sourceChain][interchainProposalCaller]) {\n            revert NotWhitelistedCaller();\n        }\n\n        // Execute the proposal with the given arguments\n        _executeProposal(calls);\n\n        _onProposalExecuted(sourceChain, sourceAddress, interchainProposalCaller, payload);\n\n        emit ProposalExecuted(keccak256(abi.encode(sourceChain, sourceAddress, interchainProposalCaller, payload)));\n    }\n\n    /**\n     * @dev Executes the proposal. Calls each target with the respective value, signature, and data.\n     * @param calls The calls to execute.\n     */\n    function _executeProposal(InterchainCalls.Call[] memory calls) internal {\n        for (uint256 i = 0; i < calls.length; i++) {\n            InterchainCalls.Call memory call = calls[i];\n            (bool success, bytes memory result) = call.target.call{ value: call.value }(call.callData);\n\n            if (!success) {\n                _onTargetExecutionFailed(call, result);\n            } else {\n                _onTargetExecuted(call, result);\n            }\n        }\n    }\n\n    /**\n     * @dev Set the proposal caller whitelist status\n     * @param sourceChain The source chain\n     * @param sourceCaller The source caller\n     * @param whitelisted The whitelist status\n     */\n    function setWhitelistedProposalCaller(\n        string calldata sourceChain,\n        address sourceCaller,\n        bool whitelisted\n    ) external override onlyOwner {\n        whitelistedCallers[sourceChain][sourceCaller] = whitelisted;\n        emit WhitelistedProposalCallerSet(sourceChain, sourceCaller, whitelisted);\n    }\n\n    /**\n     * @dev Set the proposal sender whitelist status\n     * @param sourceChain The source chain\n     * @param sourceSender The source sender\n     * @param whitelisted The whitelist status\n     */\n    function setWhitelistedProposalSender(\n        string calldata sourceChain,\n        address sourceSender,\n        bool whitelisted\n    ) external override onlyOwner {\n        whitelistedSenders[sourceChain][sourceSender] = whitelisted;\n        emit WhitelistedProposalSenderSet(sourceChain, sourceSender, whitelisted);\n    }\n\n    /**\n     * @dev A callback function that is called before the proposal is executed.\n     * This function can be used to handle the payload before the proposal is executed.\n     * @param sourceChain The source chain from where the proposal was sent.\n     * @param sourceAddress The source address that sent the proposal. The source address should be the `InterchainProposalSender` contract address at the source chain.\n     * @param payload The payload. It is ABI encoded of the caller and calls.\n     * Where:\n     * - `caller` is the address that calls the `InterchainProposalSender` at the source chain.\n     * - `calls` is the array of `InterchainCalls.Call` to execute. Each call contains the target, value, calldata.\n     */\n    function _beforeProposalExecuted(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) internal virtual {\n        // You can add your own logic here to handle the payload before the proposal is executed.\n    }\n\n    /**\n     * @dev A callback function that is called after the proposal is executed.\n     * This function emits an event containing the hash of the payload to signify successful execution.\n     * @param payload The payload. It is ABI encoded of the caller and calls.\n     * Where:\n     * - `caller` is the address that calls the `InterchainProposalSender` at the source chain.\n     * - `calls` is the array of `InterchainCalls.Call` to execute. Each call contains the target, value, signature and data.\n     */\n    function _onProposalExecuted(\n        string calldata, /* sourceChain */\n        string calldata, /* sourceAddress */\n        address, /* caller */\n        bytes calldata payload\n    ) internal virtual {\n        // You can add your own logic here to handle the payload after the proposal is executed.\n    }\n\n    /**\n     * @dev A callback function that is called when the execution of a target contract within a proposal fails.\n     * This function will revert the transaction providing the failure reason if present in the failure data.\n     * @param result The return data from the failed call to the target contract.\n     */\n    function _onTargetExecutionFailed(\n        InterchainCalls.Call memory, /* call */\n        bytes memory result\n    ) internal virtual {\n        // You can add your own logic here to handle the failure of the target contract execution. The code below is just an example.\n        if (result.length > 0) {\n            // The failure data is a revert reason string.\n            assembly {\n                revert(add(32, result), mload(result))\n            }\n        } else {\n            // There is no failure data, just revert with no reason.\n            revert ProposalExecuteFailed();\n        }\n    }\n\n    /**\n     * @dev Called after a target is successfully executed. The derived contract should implement this function.\n     * This function should do some post-execution work, such as emitting events.\n     * @param call The call that has been executed.\n     * @param result The result of the call.\n     */\n    function _onTargetExecuted(InterchainCalls.Call memory call, bytes memory result) internal virtual {\n        // You can add your own logic here to handle the success of each target contract execution.\n    }\n}"
    },
    {
      "filename": "contracts/cgp/AxelarGateway.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport { SafeTokenCall, SafeTokenTransfer, SafeTokenTransferFrom } from '../gmp-sdk/util/SafeTransfer.sol';\nimport { IERC20 } from '../gmp-sdk/interfaces/IERC20.sol';\nimport { IAxelarGateway } from './interfaces/IAxelarGateway.sol';\nimport { IGovernable } from './interfaces/IGovernable.sol';\nimport { IAxelarAuth } from './interfaces/IAxelarAuth.sol';\nimport { IBurnableMintableCappedERC20 } from './interfaces/IBurnableMintableCappedERC20.sol';\nimport { ITokenDeployer } from './interfaces/ITokenDeployer.sol';\n\nimport { ECDSA } from './ECDSA.sol';\nimport { DepositHandler } from './DepositHandler.sol';\nimport { AdminMultisigBase } from './AdminMultisigBase.sol';\n\ncontract AxelarGateway is IAxelarGateway, IGovernable, AdminMultisigBase {\n    using SafeTokenCall for IERC20;\n    using SafeTokenTransfer for IERC20;\n    using SafeTokenTransferFrom for IERC20;\n\n    error InvalidImplementation();\n\n    enum TokenType {\n        InternalBurnable,\n        InternalBurnableFrom,\n        External\n    }\n\n    /// @dev Removed slots; Should avoid re-using\n    // bytes32 internal constant KEY_ALL_TOKENS_FROZEN = keccak256('all-tokens-frozen');\n    // bytes32 internal constant PREFIX_TOKEN_FROZEN = keccak256('token-frozen');\n\n    /// @dev Storage slot with the address of the current implementation. `keccak256('eip1967.proxy.implementation') - 1`.\n    bytes32 internal constant KEY_IMPLEMENTATION = bytes32(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc);\n\n    /// @dev Storage slot with the address of the current governance. `keccak256('governance') - 1`.\n    bytes32 internal constant KEY_GOVERNANCE = bytes32(0xabea6fd3db56a6e6d0242111b43ebb13d1c42709651c032c7894962023a1f909);\n\n    /// @dev Storage slot with the address of the current governance. `keccak256('mint-limiter') - 1`.\n    bytes32 internal constant KEY_MINT_LIMITER = bytes32(0x627f0c11732837b3240a2de89c0b6343512886dd50978b99c76a68c6416a4d92);\n\n    // AUDIT: slot names should be prefixed with some standard string\n    bytes32 internal constant PREFIX_COMMAND_EXECUTED = keccak256('command-executed');\n    bytes32 internal constant PREFIX_TOKEN_ADDRESS = keccak256('token-address');\n    bytes32 internal constant PREFIX_TOKEN_TYPE = keccak256('token-type');\n    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED = keccak256('contract-call-approved');\n    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT = keccak256('contract-call-approved-with-mint');\n    bytes32 internal constant PREFIX_TOKEN_MINT_LIMIT = keccak256('token-mint-limit');\n    bytes32 internal constant PREFIX_TOKEN_MINT_AMOUNT = keccak256('token-mint-amount');\n\n    bytes32 internal constant SELECTOR_BURN_TOKEN = keccak256('burnToken');\n    bytes32 internal constant SELECTOR_DEPLOY_TOKEN = keccak256('deployToken');\n    bytes32 internal constant SELECTOR_MINT_TOKEN = keccak256('mintToken');\n    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL = keccak256('approveContractCall');\n    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT = keccak256('approveContractCallWithMint');\n    bytes32 internal constant SELECTOR_TRANSFER_OPERATORSHIP = keccak256('transferOperatorship');\n\n    // solhint-disable-next-line var-name-mixedcase\n    address internal immutable AUTH_MODULE;\n    // solhint-disable-next-line var-name-mixedcase\n    address internal immutable TOKEN_DEPLOYER_IMPLEMENTATION;\n\n    constructor(address authModule_, address tokenDeployerImplementation_) {\n        if (authModule_.code.length == 0) revert InvalidAuthModule();\n        if (tokenDeployerImplementation_.code.length == 0) revert InvalidTokenDeployer();\n\n        AUTH_MODULE = authModule_;\n        TOKEN_DEPLOYER_IMPLEMENTATION = tokenDeployerImplementation_;\n    }\n\n    modifier onlySelf() {\n        if (msg.sender != address(this)) revert NotSelf();\n\n        _;\n    }\n\n    modifier onlyGovernance() {\n        if (msg.sender != getAddress(KEY_GOVERNANCE)) revert NotGovernance();\n\n        _;\n    }\n\n    /*\n     * @dev Reverts with an error if the sender is not the mint limiter or governance.\n     */\n    modifier onlyMintLimiter() {\n        if (msg.sender != getAddress(KEY_MINT_LIMITER) && msg.sender != getAddress(KEY_GOVERNANCE)) revert NotMintLimiter();\n\n        _;\n    }\n\n    /******************\\\n    |* Public Methods *|\n    \\******************/\n\n    function sendToken(\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        string calldata symbol,\n        uint256 amount\n    ) external {\n        _burnTokenFrom(msg.sender, symbol, amount);\n        emit TokenSent(msg.sender, destinationChain, destinationAddress, symbol, amount);\n    }\n\n    function callContract(\n        string calldata destinationChain,\n        string calldata destinationContractAddress,\n        bytes calldata payload\n    ) external {\n        emit ContractCall(msg.sender, destinationChain, destinationContractAddress, keccak256(payload), payload);\n    }\n\n    function callContractWithToken(\n        string calldata destinationChain,\n        string calldata destinationContractAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount\n    ) external {\n        _burnTokenFrom(msg.sender, symbol, amount);\n        emit ContractCallWithToken(msg.sender, destinationChain, destinationContractAddress, keccak256(payload), payload, symbol, amount);\n    }\n\n    function isContractCallApproved(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) external view override returns (bool) {\n        return getBool(_getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash));\n    }\n\n    function isContractCallAndMintApproved(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string calldata symbol,\n        uint256 amount\n    ) external view override returns (bool) {\n        return\n            getBool(\n                _getIsContractCallApprovedWithMintKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, symbol, amount)\n            );\n    }\n\n    function validateContractCall(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash\n    ) external override returns (bool valid) {\n        bytes32 key = _getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, msg.sender, payloadHash);\n        valid = getBool(key);\n        if (valid) _setBool(key, false);\n    }\n\n    function validateContractCallAndMint(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash,\n        string calldata symbol,\n        uint256 amount\n    ) external override returns (bool valid) {\n        bytes32 key = _getIsContractCallApprovedWithMintKey(commandId, sourceChain, sourceAddress, msg.sender, payloadHash, symbol, amount);\n        valid = getBool(key);\n        if (valid) {\n            // Prevent re-entrance\n            _setBool(key, false);\n            _mintToken(symbol, msg.sender, amount);\n        }\n    }\n\n    /***********\\\n    |* Getters *|\n    \\***********/\n\n    function authModule() public view override returns (address) {\n        return AUTH_MODULE;\n    }\n\n    function governance() public view override returns (address) {\n        return getAddress(KEY_GOVERNANCE);\n    }\n\n    function mintLimiter() public view override returns (address) {\n        return getAddress(KEY_MINT_LIMITER);\n    }\n\n    function tokenDeployer() public view returns (address) {\n        return TOKEN_DEPLOYER_IMPLEMENTATION;\n    }\n\n    function tokenMintLimit(string memory symbol) public view override returns (uint256) {\n        return getUint(_getTokenMintLimitKey(symbol));\n    }\n\n    function tokenMintAmount(string memory symbol) public view override returns (uint256) {\n        return getUint(_getTokenMintAmountKey(symbol, block.timestamp / 6 hours));\n    }\n\n    /// @dev This function is kept around to keep things working for internal\n    /// tokens that were deployed before the token freeze functionality was removed\n    function allTokensFrozen() external pure override returns (bool) {\n        return false;\n    }\n\n    /// @dev Deprecated.\n    function adminEpoch() external pure override returns (uint256) {\n        return 0;\n    }\n\n    /// @dev Deprecated.\n    function adminThreshold(uint256) external pure override returns (uint256) {\n        return 0;\n    }\n\n    /// @dev Deprecated.\n    function admins(uint256) external pure override returns (address[] memory) {\n        return new address[](0);\n    }\n\n    function implementation() public view override returns (address) {\n        return getAddress(KEY_IMPLEMENTATION);\n    }\n\n    function tokenAddresses(string memory symbol) public view override returns (address) {\n        return getAddress(_getTokenAddressKey(symbol));\n    }\n\n    /// @dev This function is kept around to keep things working for internal\n    /// tokens that were deployed before the token freeze functionality was removed\n    function tokenFrozen(string memory) external pure override returns (bool) {\n        return false;\n    }\n\n    function isCommandExecuted(bytes32 commandId) public view override returns (bool) {\n        return getBool(_getIsCommandExecutedKey(commandId));\n    }\n\n    function contractId() public pure returns (bytes32) {\n        return keccak256('axelar-gateway');\n    }\n\n    /************************\\\n    |* Governance Functions *|\n    \\************************/\n\n    function transferGovernance(address newGovernance) external override onlyGovernance {\n        if (newGovernance == address(0)) revert InvalidGovernance();\n\n        _transferGovernance(newGovernance);\n    }\n\n    function transferMintLimiter(address newMintLimiter) external override onlyMintLimiter {\n        if (newMintLimiter == address(0)) revert InvalidMintLimiter();\n\n        _transferMintLimiter(newMintLimiter);\n    }\n\n    function setTokenMintLimits(string[] calldata symbols, uint256[] calldata limits) external override onlyMintLimiter {\n        uint256 length = symbols.length;\n        if (length != limits.length) revert InvalidSetMintLimitsParams();\n\n        for (uint256 i; i < length; ++i) {\n            string memory symbol = symbols[i];\n            uint256 limit = limits[i];\n\n            if (tokenAddresses(symbol) == address(0)) revert TokenDoesNotExist(symbol);\n\n            _setTokenMintLimit(symbol, limit);\n        }\n    }\n\n    function upgrade(\n        address newImplementation,\n        bytes32 newImplementationCodeHash,\n        bytes calldata setupParams\n    ) external override onlyGovernance {\n        if (newImplementationCodeHash != newImplementation.codehash) revert InvalidCodeHash();\n\n        if (AxelarGateway(newImplementation).contractId() != contractId()) revert InvalidImplementation();\n\n        emit Upgraded(newImplementation);\n\n        // AUDIT: If `newImplementation.setup` performs `selfdestruct`, it will result in the loss of _this_ implementation (thereby losing the gateway)\n        //        if `upgrade` is entered within the context of _this_ implementation itself.\n        if (setupParams.length != 0) {\n            (bool success, ) = newImplementation.delegatecall(abi.encodeWithSelector(IAxelarGateway.setup.selector, setupParams));\n\n            if (!success) revert SetupFailed();\n        }\n\n        _setImplementation(newImplementation);\n    }\n\n    /**********************\\\n    |* External Functions *|\n    \\**********************/\n\n    /// @dev Not publicly accessible as overshadowed in the proxy\n    function setup(bytes calldata params) external override {\n        // Prevent setup from being called on a non-proxy (the implementation).\n        if (implementation() == address(0)) revert NotProxy();\n\n        (address governance_, address mintLimiter_, bytes memory newOperatorsData) = abi.decode(params, (address, address, bytes));\n\n        if (governance_ != address(0)) _transferGovernance(governance_);\n        if (mintLimiter_ != address(0)) _transferMintLimiter(mintLimiter_);\n\n        if (newOperatorsData.length != 0) {\n            IAxelarAuth(AUTH_MODULE).transferOperatorship(newOperatorsData);\n\n            emit OperatorshipTransferred(newOperatorsData);\n        }\n    }\n\n    function execute(bytes calldata input) external override {\n        (bytes memory data, bytes memory proof) = abi.decode(input, (bytes, bytes));\n\n        bytes32 messageHash = ECDSA.toEthSignedMessageHash(keccak256(data));\n\n        // returns true for current operators\n        bool allowOperatorshipTransfer = IAxelarAuth(AUTH_MODULE).validateProof(messageHash, proof);\n\n        uint256 chainId;\n        bytes32[] memory commandIds;\n        string[] memory commands;\n        bytes[] memory params;\n\n        (chainId, commandIds, commands, params) = abi.decode(data, (uint256, bytes32[], string[], bytes[]));\n\n        if (chainId != block.chainid) revert InvalidChainId();\n\n        uint256 commandsLength = commandIds.length;\n\n        if (commandsLength != commands.length || commandsLength != params.length) revert InvalidCommands();\n\n        for (uint256 i; i < commandsLength; ++i) {\n            bytes32 commandId = commandIds[i];\n\n            if (isCommandExecuted(commandId)) continue; /* Ignore if duplicate commandId received */\n\n            bytes4 commandSelector;\n            bytes32 commandHash = keccak256(abi.encodePacked(commands[i]));\n\n            if (commandHash == SELECTOR_DEPLOY_TOKEN) {\n                commandSelector = AxelarGateway.deployToken.selector;\n            } else if (commandHash == SELECTOR_MINT_TOKEN) {\n                commandSelector = AxelarGateway.mintToken.selector;\n            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL) {\n                commandSelector = AxelarGateway.approveContractCall.selector;\n            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT) {\n                commandSelector = AxelarGateway.approveContractCallWithMint.selector;\n            } else if (commandHash == SELECTOR_BURN_TOKEN) {\n                commandSelector = AxelarGateway.burnToken.selector;\n            } else if (commandHash == SELECTOR_TRANSFER_OPERATORSHIP) {\n                if (!allowOperatorshipTransfer) continue;\n\n                allowOperatorshipTransfer = false;\n                commandSelector = AxelarGateway.transferOperatorship.selector;\n            } else {\n                continue; /* Ignore if unknown command received */\n            }\n\n            // Prevent a re-entrancy from executing this command before it can be marked as successful.\n            _setCommandExecuted(commandId, true);\n\n            (bool success, ) = address(this).call(abi.encodeWithSelector(commandSelector, params[i], commandId));\n\n            if (success) emit Executed(commandId);\n            else _setCommandExecuted(commandId, false);\n        }\n    }\n\n    /******************\\\n    |* Self Functions *|\n    \\******************/\n\n    function deployToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory name, string memory symbol, uint8 decimals, uint256 cap, address tokenAddress, uint256 mintLimit) = abi.decode(\n            params,\n            (string, string, uint8, uint256, address, uint256)\n        );\n\n        // Ensure that this symbol has not been taken.\n        if (tokenAddresses(symbol) != address(0)) revert TokenAlreadyExists(symbol);\n\n        if (tokenAddress == address(0)) {\n            // If token address is no specified, it indicates a request to deploy one.\n            bytes32 salt = keccak256(abi.encodePacked(symbol));\n\n            (bool success, bytes memory data) = TOKEN_DEPLOYER_IMPLEMENTATION.delegatecall(\n                abi.encodeWithSelector(ITokenDeployer.deployToken.selector, name, symbol, decimals, cap, salt)\n            );\n\n            if (!success) revert TokenDeployFailed(symbol);\n\n            tokenAddress = abi.decode(data, (address));\n\n            _setTokenType(symbol, TokenType.InternalBurnableFrom);\n        } else {\n            // If token address is specified, ensure that there is a contact at the specified address.\n            if (tokenAddress.code.length == uint256(0)) revert TokenContractDoesNotExist(tokenAddress);\n\n            // Mark that this symbol is an external token, which is needed to differentiate between operations on mint and burn.\n            _setTokenType(symbol, TokenType.External);\n        }\n\n        _setTokenAddress(symbol, tokenAddress);\n        _setTokenMintLimit(symbol, mintLimit);\n\n        emit TokenDeployed(symbol, tokenAddress);\n    }\n\n    function mintToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory symbol, address account, uint256 amount) = abi.decode(params, (string, address, uint256));\n\n        _mintToken(symbol, account, amount);\n    }\n\n    function burnToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory symbol, bytes32 salt) = abi.decode(params, (string, bytes32));\n\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n\n        if (_getTokenType(symbol) == TokenType.External) {\n            address depositHandlerAddress = _getCreate2Address(salt, keccak256(abi.encodePacked(type(DepositHandler).creationCode)));\n\n            if (_hasCode(depositHandlerAddress)) return;\n\n            DepositHandler depositHandler = new DepositHandler{ salt: salt }();\n\n            (bool success, bytes memory returnData) = depositHandler.execute(\n                tokenAddress,\n                abi.encodeWithSelector(IERC20.transfer.selector, address(this), IERC20(tokenAddress).balanceOf(address(depositHandler)))\n            );\n\n            if (!success || (returnData.length != uint256(0) && !abi.decode(returnData, (bool)))) revert BurnFailed(symbol);\n\n            // NOTE: `depositHandler` must always be destroyed in the same runtime context that it is deployed.\n            depositHandler.destroy(address(this));\n        } else {\n            IBurnableMintableCappedERC20(tokenAddress).burn(salt);\n        }\n    }\n\n    function approveContractCall(bytes calldata params, bytes32 commandId) external onlySelf {\n        (\n            string memory sourceChain,\n            string memory sourceAddress,\n            address contractAddress,\n            bytes32 payloadHash,\n            bytes32 sourceTxHash,\n            uint256 sourceEventIndex\n        ) = abi.decode(params, (string, string, address, bytes32, bytes32, uint256));\n\n        _setContractCallApproved(commandId, sourceChain, sourceAddress, contractAddress, payloadHash);\n        emit ContractCallApproved(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, sourceTxHash, sourceEventIndex);\n    }\n\n    function approveContractCallWithMint(bytes calldata params, bytes32 commandId) external onlySelf {\n        (\n            string memory sourceChain,\n            string memory sourceAddress,\n            address contractAddress,\n            bytes32 payloadHash,\n            string memory symbol,\n            uint256 amount,\n            bytes32 sourceTxHash,\n            uint256 sourceEventIndex\n        ) = abi.decode(params, (string, string, address, bytes32, string, uint256, bytes32, uint256));\n\n        _setContractCallApprovedWithMint(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, symbol, amount);\n        emit ContractCallApprovedWithMint(\n            commandId,\n            sourceChain,\n            sourceAddress,\n            contractAddress,\n            payloadHash,\n            symbol,\n            amount,\n            sourceTxHash,\n            sourceEventIndex\n        );\n    }\n\n    function transferOperatorship(bytes calldata newOperatorsData, bytes32) external onlySelf {\n        IAxelarAuth(AUTH_MODULE).transferOperatorship(newOperatorsData);\n\n        emit OperatorshipTransferred(newOperatorsData);\n    }\n\n    /********************\\\n    |* Internal Methods *|\n    \\********************/\n\n    function _hasCode(address addr) internal view returns (bool) {\n        bytes32 codehash = addr.codehash;\n\n        // https://eips.ethereum.org/EIPS/eip-1052\n        return codehash != bytes32(0) && codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n    }\n\n    function _mintToken(\n        string memory symbol,\n        address account,\n        uint256 amount\n    ) internal {\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n\n        _setTokenMintAmount(symbol, tokenMintAmount(symbol) + amount);\n\n        if (_getTokenType(symbol) == TokenType.External) {\n            IERC20(tokenAddress).safeTransfer(account, amount);\n        } else {\n            IBurnableMintableCappedERC20(tokenAddress).mint(account, amount);\n        }\n    }\n\n    function _burnTokenFrom(\n        address sender,\n        string memory symbol,\n        uint256 amount\n    ) internal {\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n        if (amount == 0) revert InvalidAmount();\n\n        TokenType tokenType = _getTokenType(symbol);\n\n        if (tokenType == TokenType.External) {\n            IERC20(tokenAddress).safeTransferFrom(sender, address(this), amount);\n        } else if (tokenType == TokenType.InternalBurnableFrom) {\n            IERC20(tokenAddress).safeCall(abi.encodeWithSelector(IBurnableMintableCappedERC20.burnFrom.selector, sender, amount));\n        } else {\n            IERC20(tokenAddress).safeTransferFrom(sender, IBurnableMintableCappedERC20(tokenAddress).depositAddress(bytes32(0)), amount);\n            IBurnableMintableCappedERC20(tokenAddress).burn(bytes32(0));\n        }\n    }\n\n    /********************\\\n    |* Pure Key Getters *|\n    \\********************/\n\n    function _getTokenMintLimitKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_MINT_LIMIT, symbol));\n    }\n\n    function _getTokenMintAmountKey(string memory symbol, uint256 day) internal pure returns (bytes32) {\n        // abi.encode to securely hash dynamic-length symbol data followed by day\n        return keccak256(abi.encode(PREFIX_TOKEN_MINT_AMOUNT, symbol, day));\n    }\n\n    function _getTokenTypeKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_TYPE, symbol));\n    }\n\n    function _getTokenAddressKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_ADDRESS, symbol));\n    }\n\n    function _getIsCommandExecutedKey(bytes32 commandId) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_COMMAND_EXECUTED, commandId));\n    }\n\n    function _getIsContractCallApprovedKey(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encode(PREFIX_CONTRACT_CALL_APPROVED, commandId, sourceChain, sourceAddress, contractAddress, payloadHash));\n    }\n\n    function _getIsContractCallApprovedWithMintKey(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string memory symbol,\n        uint256 amount\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT,\n                    commandId,\n                    sourceChain,\n                    sourceAddress,\n                    contractAddress,\n                    payloadHash,\n                    symbol,\n                    amount\n                )\n            );\n    }\n\n    /********************\\\n    |* Internal Getters *|\n    \\********************/\n\n    function _getCreate2Address(bytes32 salt, bytes32 codeHash) internal view returns (address) {\n        return address(uint160(uint256(keccak256(abi.encodePacked(bytes1(0x"
    }
  ]
}