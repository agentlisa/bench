{
  "Title": "[03] `ExtraordinaryFundingProposal.votesReceived` IN `ExtraordinaryFunding` CONTRACT IS `uint120` INSTEAD OF `uint128`",
  "Content": "In the `StandardFunding` contract, `Proposal.votesReceived` is `uint128`.\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/interfaces/IStandardFunding.sol#L122-L129\n```solidity\n    struct Proposal {\n        ...\n        uint128 votesReceived;        // accumulator of screening votes received by a proposal\n        ...\n    }\n```\n\nYet, in the `ExtraordinaryFunding` contract, `ExtraordinaryFundingProposal.votesReceived` is `uint120`. Calling the `ExtraordinaryFunding.voteExtraordinary` function below by a user, who has the voting power being more than `type(uint120).max`, can revert, which causes such user to waste gas and fail to vote for the corresponding proposal. This degrades the user experience because such user, who is familiar with `Proposal.votesReceived` in the `StandardFunding` contract, could think that `ExtraordinaryFundingProposal.votesReceived` in the `ExtraordinaryFunding` contract would be `uint128` as well. To be more consistent and prevent disputes, please consider using `ExtraordinaryFundingProposal.votesReceived` as `uint128` instead of `uint120` in the `ExtraordinaryFunding` contract.\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/interfaces/IExtraordinaryFunding.sol#L32-L39\n```solidity\n    struct ExtraordinaryFundingProposal {\n        ...\n        uint120  votesReceived;   // Total votes received for this proposal.\n        ...\n    }\n```\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/ExtraordinaryFunding.sol#L131-L157\n```solidity\n    function voteExtraordinary(\n        uint256 proposalId_\n    ) external override returns (uint256 votesCast_) {\n        ...\n        // check voting power at snapshot block and update proposal votes\n        votesCast_ = _getVotesExtraordinary(msg.sender, proposalId_);\n        proposal.votesReceived += SafeCast.toUint120(votesCast_);\n        ...\n    }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-05-ajna",
  "Code": [
    {
      "filename": "ajna-grants/src/grants/interfaces/IStandardFunding.sol",
      "content": "// SPDX-License-Identifier: MIT\n\n//slither-disable-next-line solc-version\npragma solidity 0.8.16;\n\n/**\n * @title Ajna Grant Coordination Fund Standard Proposal flow.\n */\ninterface IStandardFunding {\n\n    /**************/\n    /*** Errors ***/\n    /**************/\n\n    /**\n     * @notice User attempted to execute a proposal before the distribution period ended.\n     */\n     error DistributionPeriodStillActive();\n\n    /**\n     * @notice User attempted to execute a proposal before the distribution period ended.\n     */\n     error ExecuteProposalInvalid();\n\n    /**\n     * @notice User attempted to change the direction of a subsequent funding vote on the same proposal.\n     */\n    error FundingVoteWrongDirection();\n\n    /**\n     * @notice User attempted to vote with more voting power than was available to them.\n     */\n    error InsufficientVotingPower();\n\n    /**\n     * @notice Delegatee attempted to claim delegate reward before the challenge period ended.\n     */\n    error ChallengePeriodNotEnded();\n\n    /**\n     * @notice User provided a slate of proposalIds that is invalid.\n     */\n    error InvalidProposalSlate();\n\n    /**\n     * @notice Delegatee attempted to claim delegate reward when not voted in screening.\n     */\n    error DelegateRewardInvalid();\n\n    /**\n     * @notice User attempted to vote on a proposal outside of the current distribution period.\n     */\n    error InvalidVote();\n\n    /**\n     * @notice User attempted to propose after screening period ended\n     */\n    error ScreeningPeriodEnded();\n\n    /**\n     * @notice User attempted to Claim delegate reward again\n     */\n    error RewardAlreadyClaimed();\n\n    /**************/\n    /*** Events ***/\n    /**************/\n\n    /**\n     *  @notice Emitted when a new top ten slate is submitted and set as the leading optimized slate.\n     *  @param  distributionId  Id of the distribution period.\n     *  @param  fundedSlateHash Hash of the proposals to be funded.\n     */\n    event FundedSlateUpdated(\n        uint256 indexed distributionId,\n        bytes32 indexed fundedSlateHash\n    );\n\n    /**\n     *  @notice Emitted at the beginning of a new quarterly distribution period.\n     *  @param  distributionId Id of the new distribution period.\n     *  @param  startBlock     Block number of the quarterly distrubtions start.\n     *  @param  endBlock       Block number of the quarterly distrubtions end.\n     */\n    event QuarterlyDistributionStarted(\n        uint256 indexed distributionId,\n        uint256 startBlock,\n        uint256 endBlock\n    );\n\n    /**\n     *  @notice Emitted when delegatee claims his rewards.\n     *  @param  delegateeAddress Address of delegatee.\n     *  @param  distributionId   Id of distribution period.\n     *  @param  rewardClaimed    Amount of Reward Claimed.\n     */\n    event DelegateRewardClaimed(\n        address indexed delegateeAddress,\n        uint256 indexed distributionId,\n        uint256 rewardClaimed\n    );\n\n    /***************/\n    /*** Structs ***/\n    /***************/\n\n    /**\n     * @notice Contains proposals that made it through the screening process to the funding stage.\n     */\n    struct QuarterlyDistribution {\n        uint24  id;                   // id of the current quarterly distribution\n        uint48  startBlock;           // block number of the quarterly distributions start\n        uint48  endBlock;             // block number of the quarterly distributions end\n        uint128 fundsAvailable;       // maximum fund (including delegate reward) that can be taken out that quarter\n        uint256 fundingVotePowerCast; // total number of voting power allocated in funding stage that quarter\n        bytes32 fundedSlateHash;      // hash of list of proposals to fund\n    }\n\n    /**\n     * @notice Contains information about proposals in a distribution period.\n     */\n    struct Proposal {\n        uint256 proposalId;           // OZ.Governor compliant proposalId. Hash of proposeStandard inputs\n        uint24  distributionId;       // Id of the distribution period in which the proposal was made\n        bool    executed;             // whether the proposal has been executed\n        uint128 votesReceived;        // accumulator of screening votes received by a proposal\n        uint128 tokensRequested;      // number of Ajna tokens requested in the proposal\n        int128  fundingVotesReceived; // accumulator of funding votes allocated to the proposal.\n    }\n\n    /**\n     * @notice Contains information about voters during a vote made by a QuadraticVoter in the Funding stage of a distribution period.\n     */\n    struct FundingVoteParams {\n        uint256 proposalId;\n        int256 votesUsed;\n    }\n\n    /**\n     * @notice Contains information about voters during a vote made during the Screening stage of a distribution period.\n     * @dev    Used in screeningVoteMulti().\n     */\n    struct ScreeningVoteParams {\n        uint256 proposalId; // the proposal being voted on\n        uint256 votes;      // the number of votes to allocate to the proposal\n    }\n\n    /**\n     * @notice Contains information about voters during a distribution period's funding stage.\n     */\n    struct QuadraticVoter {\n        uint128 votingPower;           // amount of votes originally available to the voter, equal to the sum of the square of their initial votes\n        uint128 remainingVotingPower;  // remaining voting power in the given period\n        FundingVoteParams[] votesCast; // array of votes cast by the voter\n    }\n\n    /*****************************************/\n    /*** Distribution Management Functions ***/\n    /*****************************************/\n\n    /**\n     * @notice Start a new Distribution Period and reset appropriate state.\n     * @dev    Can be kicked off by anyone assuming a distribution period isn't already active.\n     * @return newDistributionId_ The new distribution period Id.\n     */\n    function startNewDistributionPeriod() external returns (uint24 newDistributionId_);\n\n    /************************************/\n    /*** Delegation Rewards Functions ***/\n    /************************************/\n\n    /**\n     * @notice distributes delegate reward based on delegatee Vote share.\n     * @dev Can be called by anyone who has voted in both screening and funding period.\n     * @param  distributionId_ Id of distribution from whinch delegatee wants to claim his reward.\n     * @return rewardClaimed_  Amount of reward claimed by delegatee.\n     */\n    function claimDelegateReward(\n        uint24 distributionId_\n    ) external returns(uint256 rewardClaimed_);\n\n    /**************************/\n    /*** Proposal Functions ***/\n    /**************************/\n\n    /**\n     * @notice Execute a proposal that has been approved by the community.\n     * @dev    Calls out to Governor.execute().\n     * @dev    Check for proposal being succesfully funded or previously executed is handled by Governor.execute().\n     * @param  targets_         List of contracts the proposal calldata will interact with. Should be the Ajna token contract for all proposals.\n     * @param  values_          List of values to be sent with the proposal calldata. Should be 0 for all proposals.\n     * @param  calldatas_       List of calldata to be executed. Should be the transfer() method.\n     * @param  descriptionHash_ Hash of proposal's description string.\n     * @return proposalId_      The id of the executed proposal.\n     */\n     function executeStandard(\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        bytes32 descriptionHash_\n    ) external returns (uint256 proposalId_);\n\n    /**\n     * @notice Submit a new proposal to the Grant Coordination Fund Standard Funding mechanism.\n     * @dev    All proposals can be submitted by anyone. There can only be one value in each array. Interface inherits from OZ.propose().\n     * @param  targets_     List of contracts the proposal calldata will interact with. Should be the Ajna token contract for all proposals.\n     * @param  values_      List of values to be sent with the proposal calldata. Should be 0 for all proposals.\n     * @param  calldatas_   List of calldata to be executed. Should be the transfer() method.\n     * @param  description_ Proposal's description string.\n     * @return proposalId_  The id of the newly created proposal.\n     */\n    function proposeStandard(\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        string memory description_\n    ) external returns (uint256 proposalId_);\n\n    /**\n     * @notice Check if a slate of proposals meets requirements, and maximizes votes. If so, update QuarterlyDistribution.\n     * @param  proposalIds_    Array of proposal Ids to check.\n     * @param  distributionId_ Id of the current quarterly distribution.\n     * @return newTopSlate_    Boolean indicating whether the new proposal slate was set as the new top slate for distribution.\n     */\n    function updateSlate(\n        uint256[] calldata proposalIds_,\n        uint24 distributionId_\n    ) external returns (bool newTopSlate_);\n\n    /************************/\n    /*** Voting Functions ***/\n    /************************/\n\n    /**\n     * @notice Cast an array of funding votes in one transaction.\n     * @dev    Calls out to StandardFunding._fundingVote().\n     * @dev    Only iterates through a maximum of 10 proposals that made it through the screening round.\n     * @dev    Counters incremented in an unchecked block due to being bounded by array length.\n     * @param voteParams_ The array of votes on proposals to cast.\n     * @return votesCast_ The total number of votes cast across all of the proposals.\n     */\n    function fundingVote(\n        FundingVoteParams[] memory voteParams_\n    ) external returns (uint256 votesCast_);\n\n    /**\n     * @notice Cast an array of screening votes in one transaction.\n     * @dev    Calls out to StandardFunding._screeningVote().\n     * @dev    Counters incremented in an unchecked block due to being bounded by array length.\n     * @param  voteParams_ The array of votes on proposals to cast.\n     * @return votesCast_  The total number of votes cast across all of the proposals.\n     */\n    function screeningVote(\n        ScreeningVoteParams[] memory voteParams_\n    ) external returns (uint256 votesCast_);\n\n    /**********************/\n    /*** View Functions ***/\n    /**********************/\n\n    /**\n     * @notice Retrieve the delegate reward accrued to a voter in a given distribution period.\n     * @param  distributionId_ The  to calculate rewards for.\n     * @param  voter_          The address of the voter to calculate rewards for.\n     * @return rewards_        The rewards earned by the voter for voting in that distribution period.\n     */\n    function getDelegateReward(\n        uint24 distributionId_,\n        address voter_\n    ) external view returns (uint256 rewards_);\n\n    /**\n     * @notice Retrieve the current QuarterlyDistribution distributionId.\n     * @return The current distributionId.\n     */\n    function getDistributionId() external view returns (uint24);\n\n    /**\n     * @notice Mapping of distributionId to {QuarterlyDistribution} struct.\n     * @param  distributionId_      The distributionId to retrieve the QuarterlyDistribution struct for.\n     * @return distributionId       The retrieved struct's distributionId.\n     * @return startBlock           The block number of the distribution period's start.\n     * @return endBlock             The block number of the distribution period's end.\n     * @return fundsAvailable       The maximum amount of funds that can be taken out of the distribution period.\n     * @return fundingVotePowerCast The total number of votes cast in the distribution period's funding round.\n     * @return fundedSlateHash      The slate hash of the proposals that were funded.\n     */\n    function getDistributionPeriodInfo(\n        uint24 distributionId_\n    ) external view returns (uint24, uint48, uint48, uint128, uint256, bytes32);\n\n    /**\n     * @notice Get the funded proposal slate for a given distributionId, and slate hash\n     * @param  slateHash_      The slateHash to retrieve the funded proposals from.\n     * @return                 The array of proposalIds that are in the funded slate hash.\n     */\n    function getFundedProposalSlate(\n        bytes32 slateHash_\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @notice Get the number of discrete votes that can be cast on proposals given a specified voting power.\n     * @dev    This is calculated by taking the square root of the voting power, and adjusting for WAD decimals.\n     * @dev    This approach results in precision loss, and prospective users should be careful.\n     * @param  votingPower_ The provided voting power to calculate discrete votes for.\n     * @return The square root of the votingPower as a WAD.\n     */\n    function getFundingPowerVotes(\n        uint256 votingPower_\n    ) external pure returns (uint256);\n\n    /**\n     * @notice Get the list of funding votes cast by an account in a given distribution period.\n     * @param  distributionId_   The distributionId of the distribution period to check.\n     * @param  account_          The address of the voter to check.\n     * @return FundingVoteParams The list of FundingVoteParams structs that have been succesfully cast the voter.\n     */\n    function getFundingVotesCast(uint24 distributionId_, address account_) external view returns (FundingVoteParams[] memory);\n\n    /**\n     * @notice Mapping of proposalIds to {Proposal} structs.\n     * @param  proposalId_       The proposalId to retrieve the Proposal struct for.\n     * @return proposalId        The retrieved struct's proposalId.\n     * @return distributionId    The distributionId in which the proposal was submitted.\n     * @return votesReceived     The amount of votes the proposal has received in it's distribution period's screening round.\n     * @return tokensRequested   The amount of tokens requested by the proposal.\n     * @return qvBudgetAllocated The amount of quadratic vote budget allocated to the proposal in it's distribution period's funding round.\n     * @return executed          True if the proposal has been executed.\n     */\n    function getProposalInfo(\n        uint256 proposalId_\n    ) external view returns (uint256, uint24, uint128, uint128, int128, bool);\n\n    /**\n     * @notice Generate a unique hash of a list of proposal Ids for usage as a key for comparing proposal slates.\n     * @param  proposalIds_ Array of proposal Ids to hash.\n     * @return Bytes32      Hash of the list of proposals.\n     */\n    function getSlateHash(\n        uint256[] calldata proposalIds_\n    ) external pure returns (bytes32);\n\n    /**\n     * @notice Retrieve the top ten proposals that have received the most votes in a given distribution period's screening round.\n     * @dev    It may return less than 10 proposals if less than 10 have been submitted. \n     * @dev    Values are subject to change if the queried distribution period's screening round is ongoing.\n     * @param  distributionId_ The distributionId of the distribution period to query.\n     * @return topTenProposals Array of the top ten proposal's proposalIds.\n     */\n    function getTopTenProposals(\n        uint24 distributionId_\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @notice Get the current state of a given voter in the funding stage.\n     * @param  distributionId_ The distributionId of the distribution period to check.\n     * @param  account_        The address of the voter to check.\n     * @return votingPower          The voter's voting power in the funding round. Equal to the square of their tokens in the voting snapshot.\n     * @return remainingVotingPower The voter's remaining quadratic voting power in the given distribution period's funding round.\n     * @return votesCast            The voter's number of proposals voted on in the funding stage.\n     */\n    function getVoterInfo(\n        uint24 distributionId_,\n        address account_\n    ) external view returns (uint128, uint128, uint256);\n\n    /**\n     * @notice Get the remaining quadratic voting power available to the voter in the funding stage of a distribution period.\n     * @dev    This value will be the square of the voter's token balance at the snapshot blocks.\n     * @param  distributionId_ The distributionId of the distribution period to check.\n     * @param  account_        The address of the voter to check.\n     * @return votes_          The voter's remaining quadratic voting power.\n     */\n    function getVotesFunding(uint24 distributionId_, address account_) external view returns (uint256 votes_);\n\n    /**\n     * @notice Get the voter's voting power in the screening stage of a distribution period.\n     * @param  distributionId_ The distributionId of the distribution period to check.\n     * @param  account_        The address of the voter to check.\n     * @return votes_           The voter's voting power.\n     */\n    function getVotesScreening(uint24 distributionId_, address account_) external view returns (uint256 votes_);\n\n}"
    },
    {
      "filename": "ajna-grants/src/grants/interfaces/IExtraordinaryFunding.sol",
      "content": "// SPDX-License-Identifier: MIT\n\n//slither-disable-next-line solc-version\npragma solidity 0.8.16;\n\n/**\n * @title Ajna Grant Coordination Fund Extraordinary Proposal flow.\n */\ninterface IExtraordinaryFunding {\n\n    /**************/\n    /*** Errors ***/\n    /**************/\n\n    /**\n     * @notice The current block isn't in the specified range of active blocks.\n     */\n    error ExtraordinaryFundingProposalInactive();\n\n    /**\n     * @notice Proposal wasn't approved or has already been executed and isn't available for execution.\n     */\n    error ExecuteExtraordinaryProposalInvalid();\n\n    /***************/\n    /*** Structs ***/\n    /***************/\n\n    /**\n     * @notice Contains information about proposals made to the ExtraordinaryFunding mechanism.\n     */\n    struct ExtraordinaryFundingProposal {\n        uint256  proposalId;      // Unique ID of the proposal. Hashed from proposeExtraordinary inputs.\n        uint128  startBlock;      // Block number of the start of the extraordinary funding proposal voting period.\n        uint128  endBlock;        // Block number of the end of the extraordinary funding proposal voting period.\n        uint128  tokensRequested; // Number of AJNA tokens requested.\n        uint120  votesReceived;   // Total votes received for this proposal.\n        bool     executed;        // Whether the proposal has been executed or not.\n    }\n\n    /**************************/\n    /*** Proposal Functions ***/\n    /**************************/\n\n    /**\n     * @notice Execute an extraordinary funding proposal if it has passed its' requisite vote threshold.\n     * @param targets_         The addresses of the contracts to call.\n     * @param values_          The amounts of ETH to send to each target.\n     * @param calldatas_       The calldata to send to each target.\n     * @param descriptionHash_ The hash of the proposal's description string.\n     * @return proposalId_     The ID of the executed proposal.\n     */\n    function executeExtraordinary(\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        bytes32 descriptionHash_\n    ) external returns (uint256 proposalId_);\n\n    /**\n     * @notice Submit a proposal to the extraordinary funding flow.\n     * @param endBlock_            Block number of the end of the extraordinary funding proposal voting period.\n     * @param targets_             Array of addresses to send transactions to.\n     * @param values_              Array of values to send with transactions.\n     * @param calldatas_           Array of calldata to execute in transactions.\n     * @param description_         Description of the proposal.\n     * @return proposalId_         ID of the newly submitted proposal.\n     */\n    function proposeExtraordinary(\n        uint256 endBlock_,\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        string memory description_\n    ) external returns (uint256 proposalId_);\n\n    /************************/\n    /*** Voting Functions ***/\n    /************************/\n\n    /**\n     * @notice Vote on a proposal for extraordinary funding.\n     * @dev    Votes can only be cast affirmatively, or not cast at all.\n     * @dev    A proposal can only be voted upon once, with the entirety of a voter's voting power.\n     * @param  proposalId_ The ID of the proposal being voted upon.\n     * @return votesCast_  The amount of votes cast.\n     */\n    function voteExtraordinary(\n        uint256 proposalId_\n    ) external returns (uint256 votesCast_);\n\n    /**********************/\n    /*** View Functions ***/\n    /**********************/\n\n    /**\n     * @notice Get the number of ajna tokens equivalent to a given percentage.\n     * @param  percentage_ The percentage of the non-treasury to retrieve, in WAD.\n     * @return The number of tokens, in WAD.\n     */\n    function getSliceOfNonTreasury(\n        uint256 percentage_\n    ) external view returns (uint256);\n\n    /**\n     * @notice Get the number of ajna tokens equivalent to a given percentage.\n     * @param percentage_ The percentage of the treasury to retrieve, in WAD.\n     * @return The number of tokens, in WAD.\n     */\n    function getSliceOfTreasury(\n        uint256 percentage_\n    ) external view returns (uint256);\n\n    /**\n     *  @notice Mapping of proposalIds to {ExtraordinaryFundingProposal} structs.\n     *  @param  proposalId_     The proposalId to retrieve information about.\n     *  @return proposalId      The retrieved struct's proposalId.\n     *  @return startBlock      The block at which the proposal was submitted.\n     *  @return endBlock        The block by which the proposal must pass.\n     *  @return tokensRequested Amount of Ajna tokens requested by the proposal.\n     *  @return votesReceived   Number of votes the proposal has received. One Ajna token is one vote.\n     *  @return executed        Whether a succesful proposal has been executed.\n     */\n    function getExtraordinaryProposalInfo(\n        uint256 proposalId_\n    ) external view returns (uint256, uint128, uint128, uint128, uint120, bool);\n\n    /**\n     * @notice Check if an extraordinary funding proposal met the requirements for execution.\n     * @param  proposalId_ The ID of the proposal to check the status of.\n     * @return True if the proposal was successful, false if not.\n     */\n    function getExtraordinaryProposalSucceeded(uint256 proposalId_) external view returns (bool);\n\n    /**\n     * @notice Get the current minimum threshold percentage of Ajna tokens required for a proposal to exceed.\n     * @return The minimum threshold percentage, in WAD.\n     */\n    function getMinimumThresholdPercentage() external view returns (uint256);\n\n    /**\n     * @notice Get an accounts voting power available for casting on a given proposal.\n     * @dev    If the account has already voted on the proposal, the returned value will be 0.\n     * @param  account_    The address of the voter to check.\n     * @param  proposalId_ The ID of the proposal being voted on.\n     * @return             An accounts current voting power.\n     */\n    function getVotesExtraordinary(address account_, uint256 proposalId_) external view returns (uint256);\n\n}"
    },
    {
      "filename": "ajna-grants/src/grants/base/ExtraordinaryFunding.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport { IERC20 }   from \"@oz/token/ERC20/IERC20.sol\";\nimport { SafeCast } from \"@oz/utils/math/SafeCast.sol\";\n\nimport { Funding } from \"./Funding.sol\";\n\nimport { IExtraordinaryFunding } from \"../interfaces/IExtraordinaryFunding.sol\";\n\nimport { Maths } from \"../libraries/Maths.sol\";\n\nabstract contract ExtraordinaryFunding is Funding, IExtraordinaryFunding {\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    /**\n     * @notice The maximum length of a proposal's voting period, in blocks.\n     */\n    uint256 internal constant MAX_EFM_PROPOSAL_LENGTH = 216_000; // number of blocks in one month\n\n    /**\n     * @notice Keccak hash of a prefix string for extraordinary funding mechanism\n     */\n    bytes32 internal constant DESCRIPTION_PREFIX_HASH_EXTRAORDINARY = keccak256(bytes(\"Extraordinary Funding: \"));\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    /**\n     * @notice Mapping of extant extraordinary funding proposals.\n     * @dev proposalId => ExtraordinaryFundingProposal.\n     */\n    mapping (uint256 => ExtraordinaryFundingProposal) internal _extraordinaryFundingProposals;\n\n    /**\n     * @notice The list of extraordinary funding proposalIds that have been executed.\n     */\n    uint256[] internal _fundedExtraordinaryProposals;\n\n    /**\n     * @notice Mapping checking if a voter has voted on a given proposal.\n     * @dev proposalId => address => bool.\n     */\n    mapping(uint256 => mapping(address => bool)) public hasVotedExtraordinary;\n\n    /**************************/\n    /*** Proposal Functions ***/\n    /**************************/\n\n    /// @inheritdoc IExtraordinaryFunding\n    function executeExtraordinary(\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        bytes32 descriptionHash_\n    ) external nonReentrant override returns (uint256 proposalId_) {\n        proposalId_ = _hashProposal(targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_EXTRAORDINARY, descriptionHash_)));\n\n        ExtraordinaryFundingProposal storage proposal = _extraordinaryFundingProposals[proposalId_];\n\n        // since we are casting from uint128 to uint256, we can safely assume that the value will not overflow\n        uint256 tokensRequested = uint256(proposal.tokensRequested);\n\n        // check proposal is succesful and hasn't already been executed\n        if (proposal.executed || !_extraordinaryProposalSucceeded(proposalId_, tokensRequested)) revert ExecuteExtraordinaryProposalInvalid();\n\n        _fundedExtraordinaryProposals.push(proposalId_);\n\n        // update proposal state\n        proposal.executed = true;\n\n        // update treasury\n        treasury -= tokensRequested;\n\n        // execute proposal's calldata\n        _execute(proposalId_, targets_, values_, calldatas_);\n    }\n\n    /// @inheritdoc IExtraordinaryFunding\n    function proposeExtraordinary(\n        uint256 endBlock_,\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        string memory description_) external override returns (uint256 proposalId_) {\n\n        proposalId_ = _hashProposal(targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_EXTRAORDINARY, keccak256(bytes(description_)))));\n\n        ExtraordinaryFundingProposal storage newProposal = _extraordinaryFundingProposals[proposalId_];\n\n        // check if proposal already exists (proposal id not 0)\n        if (newProposal.proposalId != 0) revert ProposalAlreadyExists();\n\n        // check proposal length is within limits of 1 month maximum\n        if (block.number + MAX_EFM_PROPOSAL_LENGTH < endBlock_) revert InvalidProposal();\n\n        uint128 totalTokensRequested = _validateCallDatas(targets_, values_, calldatas_);\n\n        // check tokens requested are available for claiming from the treasury\n        if (uint256(totalTokensRequested) > _getSliceOfTreasury(Maths.WAD - _getMinimumThresholdPercentage())) revert InvalidProposal();\n\n        // store newly created proposal\n        newProposal.proposalId      = proposalId_;\n        newProposal.startBlock      = SafeCast.toUint128(block.number);\n        newProposal.endBlock        = SafeCast.toUint128(endBlock_);\n        newProposal.tokensRequested = totalTokensRequested;\n\n        emit ProposalCreated(\n            proposalId_,\n            msg.sender,\n            targets_,\n            values_,\n            new string[](targets_.length),\n            calldatas_,\n            block.number,\n            endBlock_,\n            description_\n        );\n    }\n\n    /************************/\n    /*** Voting Functions ***/\n    /************************/\n\n    /// @inheritdoc IExtraordinaryFunding\n    function voteExtraordinary(\n        uint256 proposalId_\n    ) external override returns (uint256 votesCast_) {\n        // revert if msg.sender already voted on proposal\n        if (hasVotedExtraordinary[proposalId_][msg.sender]) revert AlreadyVoted();\n\n        ExtraordinaryFundingProposal storage proposal = _extraordinaryFundingProposals[proposalId_];\n        // revert if proposal is inactive\n        if (proposal.startBlock > block.number || proposal.endBlock < block.number || proposal.executed) {\n            revert ExtraordinaryFundingProposalInactive();\n        }\n\n        // check voting power at snapshot block and update proposal votes\n        votesCast_ = _getVotesExtraordinary(msg.sender, proposalId_);\n        proposal.votesReceived += SafeCast.toUint120(votesCast_);\n\n        // record that voter has voted on this extraordinary funding proposal\n        hasVotedExtraordinary[proposalId_][msg.sender] = true;\n\n        emit VoteCast(\n            msg.sender,\n            proposalId_,\n            1,\n            votesCast_,\n            \"\"\n        );\n    }\n\n    /**\n     * @notice Check if a proposal for extraordinary funding has succeeded.\n     * @param  proposalId_ The ID of the proposal being checked.\n     * @return Boolean indicating whether the proposal has succeeded.\n     */\n    function _extraordinaryProposalSucceeded(\n        uint256 proposalId_,\n        uint256 tokensRequested_\n    ) internal view returns (bool) {\n        uint256 votesReceived          = uint256(_extraordinaryFundingProposals[proposalId_].votesReceived);\n        uint256 minThresholdPercentage = _getMinimumThresholdPercentage();\n\n        return\n            // succeeded if proposal's votes received doesn't exceed the minimum threshold required\n            (votesReceived >= tokensRequested_ + _getSliceOfNonTreasury(minThresholdPercentage))\n            &&\n            // succeeded if tokens requested are available for claiming from the treasury\n            (tokensRequested_ <= _getSliceOfTreasury(Maths.WAD - minThresholdPercentage))\n        ;\n    }\n\n    /********************************/\n    /*** Internal View Functions ****/\n    /********************************/\n\n    /**\n     * @notice Get the current ProposalState of a given proposal.\n     * @dev    Used by GrantFund.state() for analytics compatability purposes.\n     * @param  proposalId_ The ID of the proposal being checked.\n     * @return The proposals status in the ProposalState enum.\n     */\n    function _getExtraordinaryProposalState(uint256 proposalId_) internal view returns (ProposalState) {\n        ExtraordinaryFundingProposal memory proposal = _extraordinaryFundingProposals[proposalId_];\n\n        bool voteSucceeded = _extraordinaryProposalSucceeded(proposalId_, uint256(proposal.tokensRequested));\n\n        if (proposal.executed)                                        return ProposalState.Executed;\n        else if (proposal.endBlock >= block.number && !voteSucceeded) return ProposalState.Active;\n        else if (voteSucceeded)                                       return ProposalState.Succeeded;\n        else                                                          return ProposalState.Defeated;\n    }\n\n    /**\n     * @notice Get the minimum percentage of ajna tokens required for a proposal to pass.\n     * @dev    The minimum threshold increases according to the number of funded EFM proposals.\n     * @return The minimum threshold percentage, as a WAD.\n     */\n    function _getMinimumThresholdPercentage() internal view returns (uint256) {\n        // default minimum threshold is 50\n        if (_fundedExtraordinaryProposals.length == 0) {\n            return 0.5 * 1e18;\n        }\n        // minimum threshold increases according to the number of funded EFM proposals\n        else {\n            return 0.5 * 1e18 + (_fundedExtraordinaryProposals.length * (0.05 * 1e18));\n        }\n    }\n\n    /**\n     * @notice Get the number of ajna tokens equivalent to a given percentage.\n     * @param percentage_ The percentage of the Non treasury to retrieve, in WAD.\n     * @return The number of tokens, in WAD.\n     */\n    function _getSliceOfNonTreasury(\n        uint256 percentage_\n    ) internal view returns (uint256) {\n        uint256 totalAjnaSupply = IERC20(ajnaTokenAddress).totalSupply();\n        return Maths.wmul(totalAjnaSupply - treasury, percentage_);\n    }\n\n    /**\n     * @notice Get the number of ajna"
    }
  ]
}