{
  "Title": "[M-11] Maximum bid will always be used in Auction",
  "Content": "# Lines of code\n\nhttps://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/crowdfund/AuctionCrowdfund.sol#L149\n\n\n# Vulnerability details\n\n## Impact\nAuctionCrowdfund contract is designed in a way to allow bidding max upto maximumBid. But due to a flaw, anyone (including NFT seller) can make sure that CrowdFund bid always remain equal to maximumBid thus removing the purpose of maximumBid. This also causes loss to Party participating in this Auction as the auction will always end up with maximumBid even when it could have stopped with lower bid as shown in POC\n\n## Proof of Concept\n1. An auction is started for NFT N in the market\n2. Party Users P1 starts an AuctionCrowdfund with maximumBid as 100 for this auction.\n\n```\nfunction initialize(AuctionCrowdfundOptions memory opts)\n        external\n        payable\n        onlyConstructor\n    {\n...\nmaximumBid = opts.maximumBid;\n...\n}\n```\n\n3. P1 bids amount 10 for the NFT N using [bid function](https://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/crowdfund/AuctionCrowdfund.sol#L149)\n4. Some bad news arrives for the NFT collection including NFT N reducing its price\n5. P1 decides not to bid more than amount 10 due to this news\n6. NFT collection owner who is watching this AuctionCrowdfund observes that bidding is only 10 but Party users have maximumBid of 100\n7. NFT collection owner  asks his friend to bid on this NFT in the auction market (different from crowd fund)\n8. NFT collection owner now takes advantage of same and himself calls the bid function of AuctionCrowdfund via Proxy\n\n```\nfunction bid() external onlyDelegateCall {\n...\n}\n```\n\n9. Now since last bid belongs to collection owner friend, so AuctionCrowdfund contract simply extends its bid further \n\n```\nif (market.getCurrentHighestBidder(auctionId_) == address(this)) {\n            revert AlreadyHighestBidderError();\n        }\n        // Get the minimum necessary bid to be the highest bidder.\n        uint96 bidAmount = market.getMinimumBid(auctionId_).safeCastUint256ToUint96();\n        // Make sure the bid is less than the maximum bid.\n        if (bidAmount > maximumBid) {\n            revert ExceedsMaximumBidError(bidAmount, maximumBid);\n        }\n        lastBid = bidAmount;\n```\n\n10. NFT collection owner keeps repeating step 7-9 until AuctionCrowdfund reaches the final maximum bid of 100\n11. After auction completes, collection owner gets 100 amount instead of 10 even though crowd fund users never bidded for amount 100\n\n## Recommended Mitigation Steps\nmaximumbid concept can easily be bypassed as shown above and will not make sense. Either remove it completely\n   OR\nbid function should only be callable via crowdfund members then attacker would be afraid if new bid will come or not and there should be a consensus between crowdfund members before bidding which will protect this scenario",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-09-partydao-contest",
  "Code": [
    {
      "filename": "contracts/crowdfund/AuctionCrowdfund.sol",
      "content": "// SPDX-License-Identifier: Beta Software\npragma solidity ^0.8;\n\nimport \"../tokens/IERC721.sol\";\nimport \"../party/Party.sol\";\nimport \"../utils/Implementation.sol\";\nimport \"../utils/LibSafeERC721.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../gatekeepers/IGateKeeper.sol\";\n\nimport \"../market-wrapper/IMarketWrapper.sol\";\nimport \"./Crowdfund.sol\";\n\n/// @notice A crowdfund that can repeatedly bid on an auction for a specific NFT\n///         (i.e. with a known token ID) until it wins.\ncontract AuctionCrowdfund is Implementation, Crowdfund {\n    using LibSafeERC721 for IERC721;\n    using LibSafeCast for uint256;\n    using LibRawResult for bytes;\n\n    enum AuctionCrowdfundStatus {\n        // The crowdfund has been created and contributions can be made and\n        // acquisition functions may be called.\n        Active,\n        // An temporary state set by the contract during complex operations to\n        // act as a reentrancy guard.\n        Busy,\n        // The crowdfund is over and has either won or lost.\n        Finalized\n    }\n\n    struct AuctionCrowdfundOptions {\n        // The name of the crowdfund.\n        // This will also carry over to the governance party.\n        string name;\n        // The token symbol for both the crowdfund and the governance NFTs.\n        string symbol;\n        // The auction ID (specific to the IMarketWrapper).\n        uint256 auctionId;\n        // IMarketWrapper contract that handles interactions with auction markets.\n        IMarketWrapper market;\n        // The ERC721 contract of the NFT being bought.\n        IERC721 nftContract;\n        // ID of the NFT being bought.\n        uint256 nftTokenId;\n        // How long this crowdfund has to bid on the NFT, in seconds.\n        uint40 duration;\n        // Maximum bid allowed.\n        uint96 maximumBid;\n        // An address that receives a portion of the final voting power\n        // when the party transitions into governance.\n        address payable splitRecipient;\n        // What percentage (in bps) of the final total voting power `splitRecipient`\n        // receives.\n        uint16 splitBps;\n        // If ETH is attached during deployment, it will be interpreted\n        // as a contribution. This is who gets credit for that contribution.\n        address initialContributor;\n        // If there is an initial contribution, this is who they will delegate their\n        // voting power to when the crowdfund transitions to governance.\n        address initialDelegate;\n        // The gatekeeper contract to use (if non-null) to restrict who can\n        // contribute to this crowdfund.\n        IGateKeeper gateKeeper;\n        // The gate ID within the gateKeeper contract to use.\n        bytes12 gateKeeperId;\n        // Fixed governance options (i.e. cannot be changed) that the governance\n        // `Party` will be created with if the crowdfund succeeds.\n        FixedGovernanceOpts governanceOpts;\n    }\n\n    event Bid(uint256 bidAmount);\n    event Won(uint256 bid, Party party);\n    event Lost();\n\n    error InvalidAuctionIdError();\n    error AuctionFinalizedError(uint256 auctionId);\n    error AlreadyHighestBidderError();\n    error ExceedsMaximumBidError(uint256 bidAmount, uint256 maximumBid);\n    error NoContributionsError();\n    error AuctionNotExpiredError();\n\n    /// @notice The NFT contract to buy.\n    IERC721 public nftContract;\n    /// @notice The NFT token ID to buy.\n    uint256 public nftTokenId;\n    /// @notice An adapter for the auction market (Zora, OpenSea, etc).\n    /// @dev This will be delegatecalled into to execute bids.\n    IMarketWrapper public market;\n    /// @notice The auction ID to identify the auction on the `market`.\n    uint256 public auctionId;\n    /// @notice The maximum possible bid this crowdfund can make.\n    uint96 public maximumBid;\n    /// @notice The last successful bid() amount.\n    uint96 public lastBid;\n    /// @notice When this crowdfund expires. If the NFT has not been bought\n    ///         by this time, participants can withdraw their contributions.\n    uint40 public expiry;\n    // Track extra status of the crowdfund specific to bids.\n    AuctionCrowdfundStatus private _bidStatus;\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) Crowdfund(globals) {}\n\n    /// @notice Initializer to be delegatecalled by `Proxy` constructor. Will\n    ///         revert if called outside the constructor.\n    /// @param opts Options used to initialize the crowdfund. These are fixed\n    ///             and cannot be changed later.\n    function initialize(AuctionCrowdfundOptions memory opts)\n        external\n        payable\n        onlyConstructor\n    {\n        nftContract = opts.nftContract;\n        nftTokenId = opts.nftTokenId;\n        market = opts.market;\n        expiry = uint40(opts.duration + block.timestamp);\n        auctionId = opts.auctionId;\n        maximumBid = opts.maximumBid;\n        Crowdfund._initialize(CrowdfundOptions({\n            name: opts.name,\n            symbol: opts.symbol,\n            splitRecipient: opts.splitRecipient,\n            splitBps: opts.splitBps,\n            initialContributor: opts.initialContributor,\n            initialDelegate: opts.initialDelegate,\n            gateKeeper: opts.gateKeeper,\n            gateKeeperId: opts.gateKeeperId,\n            governanceOpts: opts.governanceOpts\n        }));\n\n        // Check that the auction can be bid on and is valid.\n        if (!market.auctionIdMatchesToken(\n            opts.auctionId,\n            address(opts.nftContract),\n            opts.nftTokenId))\n        {\n            revert InvalidAuctionIdError();\n        }\n    }\n\n    /// @notice Accept naked ETH, e.g., if an auction needs to return ETH to us.\n    receive() external payable {}\n\n    /// @notice Place a bid on the NFT using the funds in this crowdfund,\n    ///         placing the minimum possible bid to be the highest bidder, up to\n    ///         `maximumBid`.\n    function bid() external onlyDelegateCall {\n        // Check that the auction is still active.\n        {\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\n            if (lc != CrowdfundLifecycle.Active) {\n                revert WrongLifecycleError(lc);\n            }\n        }\n        // Mark as busy to prevent `burn()`, `bid()`, and `contribute()`\n        // getting called because this will result in a `CrowdfundLifecycle.Busy`.\n        _bidStatus = AuctionCrowdfundStatus.Busy;\n        // Make sure the auction is not finalized.\n        uint256 auctionId_ = auctionId;\n        if (market.isFinalized(auctionId_)) {\n            revert AuctionFinalizedError(auctionId_);\n        }\n        // Only bid if we are not already the highest bidder.\n        if (market.getCurrentHighestBidder(auctionId_) == address(this)) {\n            revert AlreadyHighestBidderError();\n        }\n        // Get the minimum necessary bid to be the highest bidder.\n        uint96 bidAmount = market.getMinimumBid(auctionId_).safeCastUint256ToUint96();\n        // Make sure the bid is less than the maximum bid.\n        if (bidAmount > maximumBid) {\n            revert ExceedsMaximumBidError(bidAmount, maximumBid);\n        }\n        lastBid = bidAmount;\n        // No need to check that we have `bidAmount` since this will attempt to\n        // transfer `bidAmount` ETH to the auction platform.\n        (bool s, bytes memory r) = address(market).delegatecall(abi.encodeCall(\n            IMarketWrapper.bid,\n            (auctionId_, bidAmount)\n        ));\n        if (!s) {\n            r.rawRevert();\n        }\n        emit Bid(bidAmount);\n\n        _bidStatus = AuctionCrowdfundStatus.Active;\n    }\n\n    /// @notice Calls finalize() on the market adapter, which will claim the NFT\n    ///         (if necessary) if we won, or recover our bid (if necessary)\n    ///         if we lost. If we won, a governance party will also be created.\n    /// @param governanceOpts The options used to initialize governance in the\n    ///                       `Party` instance created if the crowdfund wins.\n    /// @return party_ Address of the `Party` instance created if successful.\n    function finalize(FixedGovernanceOpts memory governanceOpts)\n        external\n        onlyDelegateCall\n        returns (Party party_)\n    {\n        // Check that the auction is still active and has not passed the `expiry` time.\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\n        if (lc != CrowdfundLifecycle.Active && lc != CrowdfundLifecycle.Expired) {\n            revert WrongLifecycleError(lc);\n        }\n        // Mark as busy to prevent burn(), bid(), and contribute()\n        // getting called because this will result in a `CrowdfundLifecycle.Busy`.\n        _bidStatus = AuctionCrowdfundStatus.Busy;\n\n        uint96 lastBid_ = lastBid;\n        // Only finalize on the market if we placed a bid.\n        if (lastBid_ != 0) {\n            uint256 auctionId_ = auctionId;\n            // Finalize the auction if it isn't finalized.\n            if (!market.isFinalized(auctionId_)) {\n                // Note that even if this crowdfund has expired but the auction is still\n                // ongoing, this call can fail and block finalization until the auction ends.\n                (bool s, bytes memory r) = address(market).call(abi.encodeCall(\n                    IMarketWrapper.finalize,\n                    auctionId_\n                ));\n                if (!s) {\n                    r.rawRevert();\n                }\n            }\n        } else {\n            // If we never placed a bid, the auction must have expired.\n            if (lc != CrowdfundLifecycle.Expired) {\n                revert AuctionNotExpiredError();\n            }\n        }\n        // Are we now in possession of the NFT?\n        if (nftContract.safeOwnerOf(nftTokenId) == address(this)) {\n            if (lastBid_ == 0) {\n                // The NFT was gifted to us. Everyone who contributed wins.\n                lastBid_ = totalContributions;\n                if (lastBid_ == 0) {\n                    // Nobody ever contributed. The NFT is effectively burned.\n                    revert NoContributionsError();\n                }\n                lastBid = lastBid_;\n            }\n            // Create a governance party around the NFT.\n            party_ = _createParty(\n                _getPartyFactory(),\n                governanceOpts,\n                nftContract,\n                nftTokenId\n            );\n            emit Won(lastBid_, party_);\n        } else {\n            // Clear `lastBid` so `_getFinalPrice()` is 0 and people can redeem their\n            // full contributions when they burn their participation NFTs.\n            lastBid = 0;\n            emit Lost();\n        }\n\n        _bidStatus = AuctionCrowdfundStatus.Finalized;\n    }\n\n    /// @inheritdoc Crowdfund\n    function getCrowdfundLifecycle() public override view returns (CrowdfundLifecycle) {\n        // Do not rely on `market.isFinalized()` in case `auctionId` gets reused.\n        AuctionCrowdfundStatus status = _bidStatus;\n        if (status == AuctionCrowdfundStatus.Busy) {\n            // In the midst of finalizing/bidding (trying to reenter).\n            return CrowdfundLifecycle.Busy;\n        }\n        if (status == AuctionCrowdfundStatus.Finalized) {\n            return address(party) != address(0)\n                // If we're fully finalized and we have a party instance then we won.\n                ? CrowdfundLifecycle.Won\n                // Otherwise we lost.\n                : CrowdfundLifecycle.Lost;\n        }\n        if (block.timestamp >= expiry) {\n            // Expired. `finalize()` needs to be called.\n            return CrowdfundLifecycle.Expired;\n        }\n        return CrowdfundLifecycle.Active;\n    }\n\n    function _getFinalPrice()\n        internal\n        override\n        view\n        returns (uint256 price)\n    {\n        return lastBid;\n    }\n}"
    }
  ]
}