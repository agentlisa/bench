{
  "Title": "M-17: WIchiFarm will break after second deposit of LP",
  "Content": "# Issue M-17: WIchiFarm will break after second deposit of LP \n\nSource: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/15 \n\n## Found by \n0x52\n\n## Summary\n\nWIchiFarm.sol makes the incorrect assumption that IchiVaultLP doesn't reduce allowance when using the transferFrom if allowance is set to type(uint256).max. Looking at a currently deployed [IchiVault](https://etherscan.io/token/0x683f081dbc729dbd34abac708fa0b390d49f1c39#code#L2281) this assumption is not true. On the second deposit for the LP token, the call will always revert at the safe approve call.\n\n## Vulnerability Detail\n\n[IchiVault](https://etherscan.io/token/0x683f081dbc729dbd34abac708fa0b390d49f1c39#code#L2281)\n\n      function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n          _transfer(sender, recipient, amount);\n          _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n          return true;\n      }\n\nThe above lines show the trasnferFrom call which reduces the allowance of the spender regardless of whether the spender is approved for type(uint256).max or not. \n\n        if (\n            IERC20Upgradeable(lpToken).allowance(\n                address(this),\n                address(ichiFarm)\n            ) != type(uint256).max\n        ) {\n            // We only need to do this once per pool, as LP token's allowance won't decrease if it's -1.\n            IERC20Upgradeable(lpToken).safeApprove(\n                address(ichiFarm),\n                type(uint256).max\n            );\n        }\n\nAs a result after the first deposit the allowance will be less than type(uint256).max. When there is a second deposit, the reduced allowance will trigger a safeApprove call.\n\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\nsafeApprove requires that either the input is zero or the current allowance is zero. Since neither is true the call will revert. The result of this is that WIchiFarm is effectively broken after the first deposit.\n\n## Impact\n\nWIchiFarm is broken and won't be able to process deposits after the first.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/wrapper/WIchiFarm.sol#L38\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nOnly approve is current allowance isn't enough for call. Optionally add zero approval before the approve. Realistically it's impossible to use the entire type(uint256).max, but to cover edge cases you may want to add it.\n\n        if (\n            IERC20Upgradeable(lpToken).allowance(\n                address(this),\n                address(ichiFarm)\n    -       ) != type(uint256).max\n    +       ) < amount\n        ) {\n\n    +       IERC20Upgradeable(lpToken).safeApprove(\n    +           address(ichiFarm),\n    +           0\n            );\n            // We only need to do this once per pool, as LP token's allowance won't decrease if it's -1.\n            IERC20Upgradeable(lpToken).safeApprove(\n                address(ichiFarm),\n                type(uint256).max\n            );\n        }\n\n## Discussion\n\n**SergeKireev**\n\nEscalate for 31 USDC\n\nThe impact stated is medium, since it only prevents additional deposits and no funds are at risk.\nThe high severity definition as stated per Sherlock docs:\n\n>This vulnerability would result in a material loss of funds and the cost of the attack is low (relative to the amount of funds lost). The attack path is possible with reasonable assumptions that mimic on-chain conditions. The vulnerability must be something that is not considered an acceptable risk by a reasonable protocol team.\n\n**sherlock-admin**\n\n > Escalate for 31 USDC\n> \n> The impact stated is medium, since it only prevents additional deposits and no funds are at risk.\n> The high severity definition as stated per Sherlock docs:\n> \n> >This vulnerability would result in a material loss of funds and the cost of the attack is low (relative to the amount of funds lost). The attack path is possible with reasonable assumptions that mimic on-chain conditions. The vulnerability must be something that is not considered an acceptable risk by a reasonable protocol team.\n\nYou've created a valid escalation for 31 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted \n\nAs the impact is only preventing further deposits rendering the farm contract useless, without causing a loss of funds. \n\n**sherlock-admin**\n\n> Escalation accepted \n> \n> As the impact is only preventing further deposits rendering the farm contract useless, without causing a loss of funds. \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/41",
  "Code": [
    {
      "filename": "contracts/wrapper/WIchiFarm.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"../utils/BlueBerryErrors.sol\";\nimport \"../libraries/BBMath.sol\";\nimport \"../interfaces/IWIchiFarm.sol\";\nimport \"../interfaces/IERC20Wrapper.sol\";\nimport \"../interfaces/ichi/IIchiV2.sol\";\nimport \"../interfaces/ichi/IIchiFarm.sol\";\n\ncontract WIchiFarm is\n    ERC1155Upgradeable,\n    ReentrancyGuardUpgradeable,\n    IERC20Wrapper,\n    IWIchiFarm\n{\n    using BBMath for uint256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeERC20Upgradeable for IIchiV2;\n\n    IERC20Upgradeable public ICHIv1;\n    IIchiV2 public ICHI;\n    IIchiFarm public ichiFarm;\n\n    function initialize(\n        address _ichi,\n        address _ichiv1,\n        address _ichiFarm\n    ) external initializer {\n        __ERC1155_init(\"WIchiFarm\");\n        ICHI = IIchiV2(_ichi);\n        ICHIv1 = IERC20Upgradeable(_ichiv1);\n        ichiFarm = IIchiFarm(_ichiFarm);\n    }\n\n    /// @dev Encode pid, ichiPerShare to ERC1155 token id\n    /// @param pid Pool id (16-bit)\n    /// @param ichiPerShare Ichi amount per share, multiplied by 1e18 (240-bit)\n    function encodeId(uint256 pid, uint256 ichiPerShare)\n        public\n        pure\n        returns (uint256 id)\n    {\n        if (pid >= (1 << 16)) revert BAD_PID(pid);\n        if (ichiPerShare >= (1 << 240))\n            revert BAD_REWARD_PER_SHARE(ichiPerShare);\n        return (pid << 240) | ichiPerShare;\n    }\n\n    /// @dev Decode ERC1155 token id to pid, ichiPerShare\n    /// @param id Token id\n    function decodeId(uint256 id)\n        public\n        pure\n        returns (uint256 pid, uint256 ichiPerShare)\n    {\n        pid = id >> 240; // First 16 bits\n        ichiPerShare = id & ((1 << 240) - 1); // Last 240 bits\n    }\n\n    /// @dev Return the underlying ERC-20 for the given ERC-1155 token id.\n    /// @param id Token id\n    function getUnderlyingToken(uint256 id)\n        external\n        view\n        override\n        returns (address)\n    {\n        (uint256 pid, ) = decodeId(id);\n        return ichiFarm.lpToken(pid);\n    }\n\n    /// @dev Mint ERC1155 token for the given pool id.\n    /// @param pid Pool id\n    /// @param amount Token amount to wrap\n    /// @return The token id that got minted.\n    function mint(uint256 pid, uint256 amount)\n        external\n        nonReentrant\n        returns (uint256)\n    {\n        address lpToken = ichiFarm.lpToken(pid);\n        IERC20Upgradeable(lpToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n        if (\n            IERC20Upgradeable(lpToken).allowance(\n                address(this),\n                address(ichiFarm)\n            ) != type(uint256).max\n        ) {\n            // We only need to do this once per pool, as LP token's allowance won't decrease if it's -1.\n            IERC20Upgradeable(lpToken).safeApprove(\n                address(ichiFarm),\n                type(uint256).max\n            );\n        }\n        ichiFarm.deposit(pid, amount, address(this));\n        (uint256 ichiPerShare, , ) = ichiFarm.poolInfo(pid);\n        uint256 id = encodeId(pid, ichiPerShare);\n        _mint(msg.sender, id, amount, \"\");\n        return id;\n    }\n\n    /// @dev Burn ERC1155 token to redeem LP ERC20 token back plus ICHI rewards.\n    /// @param id Token id\n    /// @param amount Token amount to burn\n    /// @return The pool id that that you will receive LP token back.\n    function burn(uint256 id, uint256 amount)\n        external\n        nonReentrant\n        returns (uint256)\n    {\n        if (amount == type(uint256).max) {\n            amount = balanceOf(msg.sender, id);\n        }\n        (uint256 pid, uint256 stIchiPerShare) = decodeId(id);\n        _burn(msg.sender, id, amount);\n\n        uint256 ichiRewards = ichiFarm.pendingIchi(pid, address(this));\n        ichiFarm.harvest(pid, address(this));\n        ichiFarm.withdraw(pid, amount, address(this));\n\n        // Convert Legacy ICHI to ICHI v2\n        if (ichiRewards > 0) {\n            ICHIv1.safeApprove(address(ICHI), ichiRewards);\n            ICHI.convertToV2(ichiRewards);\n        }\n\n        // Transfer LP Tokens\n        address lpToken = ichiFarm.lpToken(pid);\n        IERC20Upgradeable(lpToken).safeTransfer(msg.sender, amount);\n\n        // Transfer Reward Tokens\n        (uint256 enIchiPerShare, , ) = ichiFarm.poolInfo(pid);\n        uint256 stIchi = (stIchiPerShare * amount).divCeil(1e18);\n        uint256 enIchi = (enIchiPerShare * amount) / 1e18;\n\n        if (enIchi > stIchi) {\n            ICHI.safeTransfer(msg.sender, enIchi - stIchi);\n        }\n        return pid;\n    }\n}"
    }
  ]
}