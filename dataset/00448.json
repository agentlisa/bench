{
  "Title": "M-29: Secondary Big Bang market rates can be manipulated due to not triggering penrose.reAccrueBigBangMarkets(); when leveraging",
  "Content": "# Issue M-29: Secondary Big Bang market rates can be manipulated due to not triggering penrose.reAccrueBigBangMarkets(); when leveraging \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/128 \n\n## Found by \n0xadrii, hyh\n## Summary\n\nSecondary market rates can still be manipulated via leverage executors because `penrose.reAccrueBigBangMarkets()` is never called in the leverage module.\n\n## Vulnerability Detail\n\nThe attack described in [Tapioca’s C4 audit 1561 issue](https://github.com/code-423n4/2023-07-tapioca-findings/issues/1561) and also described in Spearbit’s audit 5.2.16 issue is still possible utilizing the leverage modules.\n\nAs a summary, these attacks described a way to manipulate interest rates. As stated in [Tapioca’s documentation](https://docs.tapioca.xyz/tapioca/core-technologies/big-bang#variable-interest-rate-collateral-debt-ratio), the interest rate for non-ETH markets is computed considering the current debt in ETH markets. Rate manipulation could be performed by an attacker following these steps:\n\n1. Borrow a huge amount in the ETH market. This step did not accrue the other markets.\n2. Accrue other non-ETH markets. It is important to be aware of the fact that non-ETH markets base their interest calculations considering the total debt in the ETH market. After step 1, the attacker triggers an accrual on non-ETH markets which will fetch the data from the greatly increased  borrow amount in the ETH market, making the non-ETH market see a huge amount of debt, thus affecting and manipulating the computation of its interest rate.\n\nThe fix introduced in the C4 and Spearbit audits incorporated a new function in the Penrose contract to mitigate this issue. If the caller is the `bigBangEthMarket`, then the internal `_reAccrueMarkets()` function will be called, and market’s interest rates will be accrued prior to performing any kind of borrow. Following this fix, an attacker can no longer perform step 2 of accruing the markets with a manipulated rate because accrual on secondary markets has already been triggered.\n\n```solidity\n// Penrose.sol\n\nfunction reAccrueBigBangMarkets() external notPaused {\n        if (msg.sender == bigBangEthMarket) {\n            _reAccrueMarkets(false);\n        } \n    }\n    \n  function _reAccrueMarkets(bool includeMainMarket) private {\n      uint256 len = allBigBangMarkets.length;\n      address[] memory markets = allBigBangMarkets;\n      for (uint256 i; i < len; i++) {\n          address market = markets[i];\n          if (isMarketRegistered[market]) {\n              if (includeMainMarket || market != bigBangEthMarket) {\n                  IBigBang(market).accrue();\n              }\n          }\n      }\n\n      emit ReaccruedMarkets(includeMainMarket);\n  }\n```\n\nAlthough this fix is effective, the attack is still possible via Big Bang’s leverage modules. Leveraging is a different way of borrowing that still affects a market’s total debt. As we can see, the `buyCollateral()` function still performs a `_borrow()`, thus incrementing a market’s debt:\n\n```solidity\n// BBLeverage.sol\n\nfunction buyCollateral(address from, uint256 borrowAmount, uint256 supplyAmount, bytes calldata data) \n        external\n        optionNotPaused(PauseType.LeverageBuy)\n        solvent(from, false)\n        notSelf(from)  \n        returns (uint256 amountOut) \n    { \n        ...\n\n        \n        {\n            (, uint256 borrowShare) = _borrow( \n                calldata_.from,    \n                address(this), \n                calldata_.borrowAmount,\n                _computeVariableOpeningFee(calldata_.borrowAmount)\n            );  \n            (memoryData.borrowShareToAmount,) =\n                yieldBox.withdraw(assetId, address(this), address(leverageExecutor), 0, borrowShare);\n        }\n        \n        ...\n       }\n```\n\nBecause Penrose’s `reAccrueBigBangMarkets()` function is not called when leveraging, the attack described in the C4 and Spearbit audits is still possible by utilizing leverage to increase the ETH market’s total debt, and then accruing non-ETH markets so that rates are manipulated.\n\n## Impact\n\nMedium. A previously found issue is still present in the codebase which allows secondary Big Bang markets interest rates to be manipulated, allowing the attacker to perform profitable strategies and potentially affecting users.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/bigBang/BBLeverage.sol#L53\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIt is recommended to trigger Penrose’s reAccrueBigBangMarkets() function when interacting with Big Bang’s leverage modules, so that the issue can be fully mitigated.\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Tapioca-DAO/Tapioca-bar/pull/365.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "Tapioca-bar/contracts/markets/bigBang/BBLeverage.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {BoringERC20} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport {IERC20} from \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\n\n// Tapioca\nimport {SafeApprove} from \"../../libraries/SafeApprove.sol\";\nimport {BBLendingCommon} from \"./BBLendingCommon.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract BBLeverage is BBLendingCommon {\n    using RebaseLibrary for Rebase;\n    using SafeApprove for address;\n    using BoringERC20 for IERC20;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error LeverageExecutorNotValid();\n    error CollateralShareNotValid();\n\n    struct _BuyCollateralCalldata {\n        address from;\n        uint256 borrowAmount;\n        uint256 supplyAmount;\n        bytes data;\n    }\n\n    struct _BuyCollateralMemoryData {\n        uint256 supplyShareToAmount;\n        uint256 borrowShareToAmount;\n    }\n\n    /// @notice Lever up: Borrow more and buy collateral with it.\n    /// @param from The user who buys\n    /// @param borrowAmount Amount of extra asset borrowed\n    /// @param supplyAmount Amount of asset supplied (down payment)\n    /// @param data LeverageExecutor data\n    /// @return amountOut Actual collateral amount purchased\n    function buyCollateral(address from, uint256 borrowAmount, uint256 supplyAmount, bytes calldata data)\n        external\n        optionNotPaused(PauseType.LeverageBuy)\n        solvent(from, false)\n        notSelf(from)\n        returns (uint256 amountOut)\n    {\n        if (address(leverageExecutor) == address(0)) {\n            revert LeverageExecutorNotValid();\n        }\n\n        // Stack too deep fix\n        _BuyCollateralCalldata memory calldata_;\n        _BuyCollateralMemoryData memory memoryData;\n        {\n            calldata_.from = from;\n            calldata_.borrowAmount = borrowAmount;\n            calldata_.supplyAmount = supplyAmount;\n            calldata_.data = data;\n        }\n\n        {\n            uint256 supplyShare = yieldBox.toShare(assetId, calldata_.supplyAmount, true);\n            if (supplyShare > 0) {\n                (memoryData.supplyShareToAmount,) =\n                    yieldBox.withdraw(assetId, calldata_.from, address(leverageExecutor), 0, supplyShare);\n            }\n        }\n\n        {\n            (, uint256 borrowShare) = _borrow(\n                calldata_.from,\n                address(this),\n                calldata_.borrowAmount,\n                _computeVariableOpeningFee(calldata_.borrowAmount)\n            );\n            (memoryData.borrowShareToAmount,) =\n                yieldBox.withdraw(assetId, address(this), address(leverageExecutor), 0, borrowShare);\n        }\n        {\n            amountOut = leverageExecutor.getCollateral(\n                collateralId,\n                address(asset),\n                address(collateral),\n                memoryData.supplyShareToAmount + memoryData.borrowShareToAmount,\n                calldata_.from,\n                calldata_.data\n            );\n        }\n        uint256 collateralShare = yieldBox.toShare(collateralId, amountOut, false);\n        address(asset).safeApprove(address(yieldBox), type(uint256).max);\n        yieldBox.depositAsset(collateralId, address(this), address(this), 0, collateralShare); // TODO Check for rounding attack?\n        address(asset).safeApprove(address(yieldBox), 0);\n\n        if (collateralShare == 0) revert CollateralShareNotValid();\n        _allowedBorrow(calldata_.from, collateralShare);\n        _addCollateral(calldata_.from, calldata_.from, false, 0, collateralShare);\n    }\n\n    struct _SellCollateralMemoryData {\n        uint256 obtainedShare;\n        uint256 leverageAmount;\n        uint256 shareOut;\n        uint256 partOwed;\n        uint256 amountOwed;\n        uint256 shareOwed;\n    }\n\n    /// @notice Lever down: Sell collateral to repay debt; excess goes to YB\n    /// @param from The user who sells\n    /// @param share Collateral YieldBox-shares to sell\n    /// @param data LeverageExecutor data\n    /// @return amountOut Actual asset amount received in the sale\n    function sellCollateral(address from, uint256 share, bytes calldata data)\n        external\n        optionNotPaused(PauseType.LeverageSell)\n        solvent(from, false)\n        notSelf(from)\n        returns (uint256 amountOut)\n    {\n        if (address(leverageExecutor) == address(0)) {\n            revert LeverageExecutorNotValid();\n        }\n        _allowedBorrow(from, share);\n        _removeCollateral(from, address(this), share);\n\n        _SellCollateralMemoryData memory memoryData;\n\n        (, memoryData.obtainedShare) =\n            yieldBox.withdraw(collateralId, address(this), address(leverageExecutor), 0, share);\n        memoryData.leverageAmount = yieldBox.toAmount(collateralId, memoryData.obtainedShare, false);\n        amountOut = leverageExecutor.getAsset(\n            assetId, address(collateral), address(asset), memoryData.leverageAmount, from, data\n        );\n        memoryData.shareOut = yieldBox.toShare(assetId, amountOut, false);\n        address(asset).safeApprove(address(yieldBox), type(uint256).max);\n        yieldBox.depositAsset(collateralId, address(this), address(this), 0, memoryData.shareOut); // TODO Check for rounding attack?\n        address(asset).safeApprove(address(yieldBox), 0);\n\n        memoryData.partOwed = userBorrowPart[from];\n        memoryData.amountOwed = totalBorrow.toElastic(memoryData.partOwed, true);\n        memoryData.shareOwed = yieldBox.toShare(assetId, memoryData.amountOwed, true);\n        if (memoryData.shareOwed <= memoryData.shareOut) {\n            _repay(from, from, memoryData.partOwed);\n        } else {\n            //repay as much as we can\n            uint256 partOut = totalBorrow.toBase(amountOut, false);\n            _repay(from, from, partOut);\n        }\n    }\n}"
    }
  ]
}