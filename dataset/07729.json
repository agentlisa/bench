{
  "Title": "[04] Sanity/Threshold/Limit Checks",
  "Content": "\nDevoid of sanity/threshold/limit checks, critical parameters can be configured to invalid values, causing a variety of issues and breaking expected interactions within/between contracts. Consider adding proper `uint256` validation as well as zero address checks in the constructor. A worst case scenario would render the contract needing to be re-deployed in the event of human/accidental errors that involve value assignments to immutable variables. If the validation procedure is unclear or too complex to implement on-chain, document the potential issues that could produce invalid values. \n\nConsider also adding an optional codehash check for immutable address at the constructor since the zero address check cannot guarantee a matching address has been inputted. \n\nThese checks are generally not implemented in the contracts. As an example, the following constructor may be refactored to:\n\nhttps://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/proxies/LooksRareProxy.sol#L37-L40\n\n```\n    constructor(address _marketplace, address _aggregator, bytes32 _marketplaceCodeHash, bytes32 _aggregatorCodeHash) {\n        if (_marketplace == address(0) || _aggregator == address(0) || \n            _marketplace.codehash != _marketplaceCodeHash || _aggregator.codehash != _aggregatorCodeHash) {\n            revert InvalidAddress();\n        }     \n        marketplace = ILooksRareExchange(_marketplace);\n        aggregator = _aggregator;\n    }\n```\nAll other instances entailed:\n\nhttps://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/proxies/SeaportProxy.sol#L45-L48\nhttps://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/ERC20EnabledLooksRareAggregator.sol#L21-L23\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-11-looksrare",
  "Code": [
    {
      "filename": "contracts/proxies/LooksRareProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {SignatureChecker} from \"../SignatureChecker.sol\";\nimport {IERC721} from \"../../contracts/interfaces/IERC721.sol\";\nimport {IERC1155} from \"../../contracts/interfaces/IERC1155.sol\";\nimport {ILooksRareExchange} from \"@looksrare/contracts-exchange-v1/contracts/interfaces/ILooksRareExchange.sol\";\nimport {OrderTypes} from \"@looksrare/contracts-exchange-v1/contracts/libraries/OrderTypes.sol\";\n\nimport {CollectionType} from \"../libraries/OrderEnums.sol\";\nimport {BasicOrder, FeeData} from \"../libraries/OrderStructs.sol\";\nimport {IProxy} from \"../interfaces/IProxy.sol\";\nimport {TokenRescuer} from \"../TokenRescuer.sol\";\nimport {TokenTransferrer} from \"../TokenTransferrer.sol\";\n\n/**\n * @title LooksRareProxy\n * @notice This contract allows NFT sweepers to batch buy NFTs from LooksRare\n *         by passing high-level structs + low-level bytes as calldata.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract LooksRareProxy is IProxy, TokenRescuer, TokenTransferrer, SignatureChecker {\n    struct OrderExtraData {\n        uint256 makerAskPrice; // Maker ask price, which is not necessarily equal to the taker bid price\n        uint256 minPercentageToAsk; // The maker's minimum % to receive from the sale\n        uint256 nonce; // The maker's nonce\n        address strategy; // LooksRare execution strategy\n    }\n\n    ILooksRareExchange public immutable marketplace;\n    address public immutable aggregator;\n\n    /**\n     * @param _marketplace LooksRareExchange's address\n     * @param _aggregator LooksRareAggregator's address\n     */\n    constructor(address _marketplace, address _aggregator) {\n        marketplace = ILooksRareExchange(_marketplace);\n        aggregator = _aggregator;\n    }\n\n    /**\n     * @notice Execute LooksRare NFT sweeps in a single transaction\n     * @dev extraData, feeBp and feeRecipient are not used\n     * @param orders Orders to be executed by LooksRare\n     * @param ordersExtraData Extra data for each order\n     * @param recipient The address to receive the purchased NFTs\n     * @param isAtomic Flag to enable atomic trades (all or nothing) or partial trades\n     */\n    function execute(\n        BasicOrder[] calldata orders,\n        bytes[] calldata ordersExtraData,\n        bytes memory,\n        address recipient,\n        bool isAtomic,\n        uint256,\n        address\n    ) external payable override {\n        if (address(this) != aggregator) revert InvalidCaller();\n\n        uint256 ordersLength = orders.length;\n        if (ordersLength == 0 || ordersLength != ordersExtraData.length) revert InvalidOrderLength();\n\n        for (uint256 i; i < ordersLength; ) {\n            BasicOrder memory order = orders[i];\n\n            OrderExtraData memory orderExtraData = abi.decode(ordersExtraData[i], (OrderExtraData));\n\n            OrderTypes.MakerOrder memory makerAsk;\n            {\n                makerAsk.isOrderAsk = true;\n                makerAsk.signer = order.signer;\n                makerAsk.collection = order.collection;\n                makerAsk.tokenId = order.tokenIds[0];\n                makerAsk.price = orderExtraData.makerAskPrice;\n                makerAsk.amount = order.amounts[0];\n                makerAsk.strategy = orderExtraData.strategy;\n                makerAsk.nonce = orderExtraData.nonce;\n                makerAsk.minPercentageToAsk = orderExtraData.minPercentageToAsk;\n                makerAsk.currency = order.currency;\n                makerAsk.startTime = order.startTime;\n                makerAsk.endTime = order.endTime;\n\n                (bytes32 r, bytes32 s, uint8 v) = _splitSignature(order.signature);\n                makerAsk.v = v;\n                makerAsk.r = r;\n                makerAsk.s = s;\n            }\n\n            OrderTypes.TakerOrder memory takerBid;\n            {\n                takerBid.isOrderAsk = false;\n                takerBid.taker = address(this);\n                takerBid.price = order.price;\n                takerBid.tokenId = makerAsk.tokenId;\n                takerBid.minPercentageToAsk = makerAsk.minPercentageToAsk;\n            }\n\n            _executeSingleOrder(takerBid, makerAsk, recipient, order.collectionType, isAtomic);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _executeSingleOrder(\n        OrderTypes.TakerOrder memory takerBid,\n        OrderTypes.MakerOrder memory makerAsk,\n        address recipient,\n        CollectionType collectionType,\n        bool isAtomic\n    ) private {\n        if (isAtomic) {\n            marketplace.matchAskWithTakerBidUsingETHAndWETH{value: takerBid.price}(takerBid, makerAsk);\n            _transferTokenToRecipient(\n                collectionType,\n                recipient,\n                makerAsk.collection,\n                makerAsk.tokenId,\n                makerAsk.amount\n            );\n        } else {\n            try marketplace.matchAskWithTakerBidUsingETHAndWETH{value: takerBid.price}(takerBid, makerAsk) {\n                _transferTokenToRecipient(\n                    collectionType,\n                    recipient,\n                    makerAsk.collection,\n                    makerAsk.tokenId,\n                    makerAsk.amount\n                );\n            } catch {}\n        }\n    }\n}"
    },
    {
      "filename": "contracts/proxies/SeaportProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport {CollectionType} from \"../libraries/OrderEnums.sol\";\nimport {BasicOrder, FeeData} from \"../libraries/OrderStructs.sol\";\nimport {ItemType, OrderType} from \"../libraries/seaport/ConsiderationEnums.sol\";\nimport {AdvancedOrder, CriteriaResolver, OrderParameters, OfferItem, ConsiderationItem, FulfillmentComponent, AdditionalRecipient} from \"../libraries/seaport/ConsiderationStructs.sol\";\nimport {IProxy} from \"../interfaces/IProxy.sol\";\nimport {SeaportInterface} from \"../interfaces/SeaportInterface.sol\";\nimport {TokenRescuer} from \"../TokenRescuer.sol\";\n\n/**\n * @title SeaportProxy\n * @notice This contract allows NFT sweepers to batch buy NFTs from Seaport\n *         by passing high-level structs + low-level bytes as calldata.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract SeaportProxy is IProxy, TokenRescuer {\n    SeaportInterface public immutable marketplace;\n    address public immutable aggregator;\n\n    error TradeExecutionFailed();\n\n    struct ExtraData {\n        FulfillmentComponent[][] offerFulfillments; // Contains the order and item index of each offer item\n        FulfillmentComponent[][] considerationFulfillments; // Contains the order and item index of each consideration item\n    }\n\n    struct OrderExtraData {\n        uint120 numerator; // A fraction to attempt to fill\n        uint120 denominator; // The total size of the order\n        OrderType orderType; // Seaport order type\n        address zone; // A zone can cancel the order or restrict who can fulfill the order depending on the type\n        bytes32 zoneHash; // An arbitrary 32-byte value that will be supplied to the zone when fulfilling restricted orders that the zone can utilize when making a determination on whether to authorize the order\n        uint256 salt; // An arbitrary source of entropy for the order\n        bytes32 conduitKey; // A bytes32 value that indicates what conduit, if any, should be utilized as a source for token approvals when performing transfers\n        AdditionalRecipient[] recipients; // Recipients of consideration items\n    }\n\n    /**\n     * @param _marketplace Seaport's address\n     * @param _aggregator LooksRareAggregator's address\n     */\n    constructor(address _marketplace, address _aggregator) {\n        marketplace = SeaportInterface(_marketplace);\n        aggregator = _aggregator;\n    }\n\n    /**\n     * @notice Execute Seaport NFT sweeps in a single transaction\n     * @param orders Orders to be executed by Seaport\n     * @param ordersExtraData Extra data for each order\n     * @param extraData Extra data for the whole transaction\n     * @param recipient The address to receive the purchased NFTs\n     * @param isAtomic Flag to enable atomic trades (all or nothing) or partial trades\n     * @param feeBp Fee basis point to pay for the trade, set by the aggregator\n     * @param feeRecipient Fee recipient for the trade, set by the aggregator\n     */\n    function execute(\n        BasicOrder[] calldata orders,\n        bytes[] calldata ordersExtraData,\n        bytes calldata extraData,\n        address recipient,\n        bool isAtomic,\n        uint256 feeBp,\n        address feeRecipient\n    ) external payable override {\n        if (address(this) != aggregator) revert InvalidCaller();\n\n        uint256 ordersLength = orders.length;\n        if (ordersLength == 0 || ordersLength != ordersExtraData.length) revert InvalidOrderLength();\n\n        if (isAtomic) {\n            _executeAtomicOrders(orders, ordersExtraData, extraData, recipient, feeBp, feeRecipient);\n        } else {\n            _executeNonAtomicOrders(orders, ordersExtraData, recipient, feeBp, feeRecipient);\n        }\n    }\n\n    /**\n     * @dev If fulfillAvailableAdvancedOrders fails, the ETH paid to Seaport\n     *      is refunded to the proxy contract. The proxy then has to refund\n     *      the ETH back to the user through _returnETHIfAny.\n     */\n    receive() external payable {}\n\n    function _executeAtomicOrders(\n        BasicOrder[] calldata orders,\n        bytes[] calldata ordersExtraData,\n        bytes calldata extraData,\n        address recipient,\n        uint256 feeBp,\n        address feeRecipient\n    ) private {\n        uint256 ordersLength = orders.length;\n        AdvancedOrder[] memory advancedOrders = new AdvancedOrder[](ordersLength);\n        ExtraData memory extraDataStruct = abi.decode(extraData, (ExtraData));\n\n        uint256 ethValue;\n\n        for (uint256 i; i < ordersLength; ) {\n            OrderExtraData memory orderExtraData = abi.decode(ordersExtraData[i], (OrderExtraData));\n            advancedOrders[i].parameters = _populateParameters(orders[i], orderExtraData);\n            advancedOrders[i].numerator = orderExtraData.numerator;\n            advancedOrders[i].denominator = orderExtraData.denominator;\n            advancedOrders[i].signature = orders[i].signature;\n\n            if (orders[i].currency == address(0)) ethValue += orders[i].price;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        (bool[] memory availableOrders, ) = marketplace.fulfillAvailableAdvancedOrders{value: ethValue}(\n            advancedOrders,\n            new CriteriaResolver[](0),\n            extraDataStruct.offerFulfillments,\n            extraDataStruct.considerationFulfillments,\n            bytes32(0),\n            recipient,\n            ordersLength\n        );\n\n        for (uint256 i; i < availableOrders.length; ) {\n            if (!availableOrders[i]) revert TradeExecutionFailed();\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (feeRecipient != address(0)) _handleFees(orders, feeBp, feeRecipient);\n    }\n\n    function _handleFees(\n        BasicOrder[] calldata orders,\n        uint256 feeBp,\n        address feeRecipient\n    ) private {\n        address lastOrderCurrency;\n        uint256 fee;\n        uint256 ordersLength = orders.length;\n\n        for (uint256 i; i < ordersLength; ) {\n            address currency = orders[i].currency;\n            uint256 orderFee = (orders[i].price * feeBp) / 10000;\n\n            if (currency == lastOrderCurrency) {\n                fee += orderFee;\n            } else {\n                if (fee > 0) _transferFee(fee, lastOrderCurrency, feeRecipient);\n\n                lastOrderCurrency = currency;\n                fee = orderFee;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (fee > 0) _transferFee(fee, lastOrderCurrency, feeRecipient);\n    }\n\n    function _transferFee(\n        uint256 fee,\n        address lastOrderCurrency,\n        address recipient\n    ) private {\n        if (lastOrderCurrency == address(0)) {\n            _transferETH(recipient, fee);\n        } else {\n            _executeERC20DirectTransfer(lastOrderCurrency, recipient, fee);\n        }\n    }\n\n    function _executeNonAtomicOrders(\n        BasicOrder[] calldata orders,\n        bytes[] calldata ordersExtraData,\n        address recipient,\n        uint256 feeBp,\n        address feeRecipient\n    ) private {\n        uint256 fee;\n        address lastOrderCurrency;\n        for (uint256 i; i < orders.length; ) {\n            OrderExtraData memory orderExtraData = abi.decode(ordersExtraData[i], (OrderExtraData));\n            AdvancedOrder memory advancedOrder;\n            advancedOrder.parameters = _populateParameters(orders[i], orderExtraData);\n            advancedOrder.numerator = orderExtraData.numerator;\n            advancedOrder.denominator = orderExtraData.denominator;\n            advancedOrder.signature = orders[i].signature;\n\n            address currency = orders[i].currency;\n            uint256 price = orders[i].price;\n\n            try\n                marketplace.fulfillAdvancedOrder{value: currency == address(0) ? price : 0}(\n                    advancedOrder,\n                    new CriteriaResolver[](0),\n                    bytes32(0),\n                    recipient\n                )\n            {\n                if (feeRecipient != address(0)) {\n                    uint256 orderFee = (price * feeBp) / 10000;\n                    if (currency == lastOrderCurrency) {\n                        fee += orderFee;\n                    } else {\n                        if (fee > 0) _transferFee(fee, lastOrderCurrency, feeRecipient);\n\n                        lastOrderCurrency = currency;\n                        fee = orderFee;\n                    }\n                }\n            } catch {}\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (fee > 0) _transferFee(fee, lastOrderCurrency, feeRecipient);\n    }\n\n    function _populateParameters(BasicOrder calldata order, OrderExtraData memory orderExtraData)\n        private\n        pure\n        returns (OrderParameters memory parameters)\n    {\n        uint256 recipientsLength = orderExtraData.recipients.length;\n\n        parameters.offerer = order.signer;\n        parameters.zone = orderExtraData.zone;\n        parameters.zoneHash = orderExtraData.zoneHash;\n        parameters.salt = orderExtraData.salt;\n        parameters.conduitKey = orderExtraData.conduitKey;\n        parameters.orderType = orderExtraData.orderType;\n        parameters.startTime = order.startTime;\n        parameters.endTime = order.endTime;\n        parameters.totalOriginalConsiderationItems = recipientsLength;\n\n        OfferItem[] memory offer = new OfferItem[](1);\n        // Seaport enums start with NATIVE and ERC20 so plus 2\n        offer[0].itemType = ItemType(uint8(order.collectionType) + 2);\n        offer[0].token = order.collection;\n        offer[0].identifierOrCriteria = order.tokenIds[0];\n        uint256 amount = order.amounts[0];\n        offer[0].startAmount = amount;\n        offer[0].endAmount = amount;\n        parameters.offer = offer;\n\n        ConsiderationItem[] memory consideration = new ConsiderationItem[](recipientsLength);\n        for (uint256 j; j < recipientsLength; ) {\n            // We don't need to assign value to identifierOrCriteria as it is always 0.\n            uint256 recipientAmount = orderExtraData.recipients[j].amount;\n            consideration[j].startAmount = recipientAmount;\n            consideration[j].endAmount = recipientAmount;\n            consideration[j].recipient = payable(orderExtraData.recipients[j].recipient);\n            consideration[j].itemType = order.currency == address(0) ? ItemType.NATIVE : ItemType.ERC20;\n            consideration[j].token = order.currency;\n\n            unchecked {\n                ++j;\n            }\n        }\n        parameters.consideration = consideration;\n    }\n}"
    },
    {
      "filename": "contracts/ERC20EnabledLooksRareAggregator.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {LowLevelERC20Transfer} from \"./lowLevelCallers/LowLevelERC20Transfer.sol\";\nimport {IERC20EnabledLooksRareAggregator} from \"./interfaces/IERC20EnabledLooksRareAggregator.sol\";\nimport {ILooksRareAggregator} from \"./interfaces/ILooksRareAggregator.sol\";\nimport {TokenTransfer} from \"./libraries/OrderStructs.sol\";\n\n/**\n * @title ERC20EnabledLooksRareAggregator\n * @notice This contract allows NFT sweepers to buy NFTs from different marketplaces using ERC20 tokens\n *         by passing high-level structs + low-level bytes as calldata.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract ERC20EnabledLooksRareAggregator is IERC20EnabledLooksRareAggregator, LowLevelERC20Transfer {\n    ILooksRareAggregator public immutable aggregator;\n\n    /**\n     * @param _aggregator LooksRareAggregator's address\n     */\n    constructor(address _aggregator) {\n        aggregator = ILooksRareAggregator(_aggregator);\n    }\n\n    /**\n     * @inheritdoc IERC20EnabledLooksRareAggregator\n     */\n    function execute(\n        TokenTransfer[] calldata tokenTransfers,\n        ILooksRareAggregator.TradeData[] calldata tradeData,\n        address recipient,\n        bool isAtomic\n    ) external payable {\n        if (tokenTransfers.length == 0) revert UseLooksRareAggregatorDirectly();\n        _pullERC20Tokens(tokenTransfers, msg.sender);\n        aggregator.execute{value: msg.value}(tokenTransfers, tradeData, msg.sender, recipient, isAtomic);\n    }\n\n    function _pullERC20Tokens(TokenTransfer[] calldata tokenTransfers, address source) private {\n        uint256 tokenTransfersLength = tokenTransfers.length;\n        for (uint256 i; i < tokenTransfersLength; ) {\n            _executeERC20TransferFrom(\n                tokenTransfers[i].currency,\n                source,\n                address(aggregator),\n                tokenTransfers[i].amount\n            );\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    }
  ]
}