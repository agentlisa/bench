{
  "Title": "Missing Docstrings",
  "Content": "Throughout the [codebase](https://github.com/scroll-tech/scroll/tree/ae2e010324506d52f30d1aa98b98cc3e44f8c501/), there are several parts that do not have docstrings. For instance:\n\n\n* [Line 10](https://github.com/scroll-tech/scroll/blob/ae2e010324506d52f30d1aa98b98cc3e44f8c501/contracts/src/misc/ScrollOwner.sol#L7-L10) in [`ScrollOwner.sol`](https://github.com/scroll-tech/scroll/blob/ae2e010324506d52f30d1aa98b98cc3e44f8c501/contracts/src/misc/ScrollOwner.sol)\n* [Line 13](https://github.com/scroll-tech/scroll/blob/ae2e010324506d52f30d1aa98b98cc3e44f8c501/contracts/src/rate-limiter/ETHRateLimiter.sol#L9-L13) in [`ETHRateLimiter.sol`](https://github.com/scroll-tech/scroll/blob/ae2e010324506d52f30d1aa98b98cc3e44f8c501/contracts/src/rate-limiter/ETHRateLimiter.sol)\n* [Line 5](https://github.com/scroll-tech/scroll/blob/ae2e010324506d52f30d1aa98b98cc3e44f8c501/contracts/src/rate-limiter/IETHRateLimiter.sol#L4-L5) in [`IETHRateLimiter.sol`](https://github.com/scroll-tech/scroll/blob/ae2e010324506d52f30d1aa98b98cc3e44f8c501/contracts/src/rate-limiter/IETHRateLimiter.sol)\n* [Line 5](https://github.com/scroll-tech/scroll/blob/ae2e010324506d52f30d1aa98b98cc3e44f8c501/contracts/src/rate-limiter/ITokenRateLimiter.sol#L4-L5) in [`ITokenRateLimiter.sol`](https://github.com/scroll-tech/scroll/blob/ae2e010324506d52f30d1aa98b98cc3e44f8c501/contracts/src/rate-limiter/ITokenRateLimiter.sol)\n* [Line 13](https://github.com/scroll-tech/scroll/blob/ae2e010324506d52f30d1aa98b98cc3e44f8c501/contracts/src/rate-limiter/TokenRateLimiter.sol#L9-L13) in [`TokenRateLimiter.sol`](https://github.com/scroll-tech/scroll/blob/ae2e010324506d52f30d1aa98b98cc3e44f8c501/contracts/src/rate-limiter/TokenRateLimiter.sol)\n* [Line 96](https://github.com/scroll-tech/scroll/blob/ae2e010324506d52f30d1aa98b98cc3e44f8c501/contracts/src/rate-limiter/TokenRateLimiter.sol#L96) in [`TokenRateLimiter.sol`](https://github.com/scroll-tech/scroll/blob/ae2e010324506d52f30d1aa98b98cc3e44f8c501/contracts/src/rate-limiter/TokenRateLimiter.sol)\n* [Line 13](https://github.com/scroll-tech/scroll/blob/ae2e010324506d52f30d1aa98b98cc3e44f8c501/contracts/src/rate-limiter/ITokenRateLimiter.sol#L13) in [`ITokenRateLimiter.sol`](https://github.com/scroll-tech/scroll/blob/ae2e010324506d52f30d1aa98b98cc3e44f8c501/contracts/src/rate-limiter/ITokenRateLimiter.sol)\n\n\nConsider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/develop/natspec-format.html) (NatSpec).\n\n\n***Update:** Acknowledged, will resolve. The Scroll team stated:*\n\n\n\n> *It will be fixed later on when we have more time.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/misc/ScrollOwner.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {AccessControlEnumerable} from \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n// solhint-disable no-empty-blocks\n\ncontract ScrollOwner is AccessControlEnumerable {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from target address to selector to the list of accessible roles.\n    mapping(address => mapping(bytes4 => EnumerableSet.Bytes32Set)) private targetAccess;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier hasAccess(\n        address _target,\n        bytes4 _selector,\n        bytes32 _role\n    ) {\n        // admin has access to all methods\n        require(_role == DEFAULT_ADMIN_ROLE || targetAccess[_target][_selector].contains(_role), \"no access\");\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor() {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Return a list of roles which has access to the function.\n    /// @param _target The address of target contract.\n    /// @param _selector The function selector to query.\n    /// @return _roles The list of roles.\n    function callableRoles(address _target, bytes4 _selector) external view returns (bytes32[] memory _roles) {\n        EnumerableSet.Bytes32Set storage _lists = targetAccess[_target][_selector];\n        _roles = new bytes32[](_lists.length());\n        for (uint256 i = 0; i < _roles.length; i++) {\n            _roles[i] = _lists.at(i);\n        }\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Perform a function call from arbitrary role.\n    /// @param _target The address of target contract.\n    /// @param _value The value passing to target contract.\n    /// @param _data The calldata passing to target contract.\n    /// @param _role The expected role of the caller.\n    function execute(\n        address _target,\n        uint256 _value,\n        bytes calldata _data,\n        bytes32 _role\n    ) public payable onlyRole(_role) hasAccess(_target, bytes4(_data[0:4]), _role) {\n        _execute(_target, _value, _data);\n    }\n\n    // allow others to send ether to this contract.\n    receive() external payable {}\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update the access to target contract.\n    /// @param _target The address of target contract.\n    /// @param _selectors The list of function selectors to update.\n    /// @param _role The role to change.\n    /// @param _status True if we are going to add the role, otherwise remove the role.\n    function updateAccess(\n        address _target,\n        bytes4[] memory _selectors,\n        bytes32 _role,\n        bool _status\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_status) {\n            for (uint256 i = 0; i < _selectors.length; i++) {\n                targetAccess[_target][_selectors[i]].add(_role);\n            }\n        } else {\n            for (uint256 i = 0; i < _selectors.length; i++) {\n                targetAccess[_target][_selectors[i]].remove(_role);\n            }\n        }\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to call contract. If the call reverted, the error will be popped up.\n    /// @param _target The address of target contract.\n    /// @param _value The value passing to target contract.\n    /// @param _data The calldata passing to target contract.\n    function _execute(\n        address _target,\n        uint256 _value,\n        bytes calldata _data\n    ) internal {\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = address(_target).call{value: _value}(_data);\n        if (!success) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                let ptr := mload(0x40)\n                let size := returndatasize()\n                returndatacopy(ptr, 0, size)\n                revert(ptr, size)\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/src/rate-limiter/ETHRateLimiter.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.16;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport {IETHRateLimiter} from \"./IETHRateLimiter.sol\";\n\n// solhint-disable func-name-mixedcase\n// solhint-disable not-rely-on-time\n\ncontract ETHRateLimiter is Ownable, IETHRateLimiter {\n    /***********\n     * Structs *\n     ***********/\n\n    struct TokenAmount {\n        // The timestamp when the amount is updated.\n        uint48 lastUpdateTs;\n        // The ETH limit in wei.\n        uint104 limit;\n        // The amount of ETH in current period.\n        uint104 amount;\n    }\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The period length in seconds.\n    /// @dev The time frame for the `k`-th period is `[periodDuration * k, periodDuration * (k + 1))`.\n    uint256 public immutable periodDuration;\n\n    /// @notice The address of ETH spender.\n    address public immutable spender;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The token amount used in current period.\n    TokenAmount public currentPeriod;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(\n        uint256 _periodDuration,\n        address _spender,\n        uint104 _totalLimit\n    ) {\n        if (_periodDuration == 0) {\n            revert PeriodIsZero();\n        }\n\n        if (_totalLimit == 0) {\n            revert TotalLimitIsZero();\n        }\n\n        periodDuration = _periodDuration;\n        spender = _spender;\n\n        currentPeriod.limit = _totalLimit;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IETHRateLimiter\n    function addUsedAmount(uint256 _amount) external override {\n        if (msg.sender != spender) {\n            revert CallerNotSpender();\n        }\n        if (_amount == 0) return;\n\n        uint256 _currentPeriodStart = (block.timestamp / periodDuration) * periodDuration;\n\n        // check total limit\n        uint256 _currentTotalAmount;\n        TokenAmount memory _currentPeriod = currentPeriod;\n\n        if (_currentPeriod.lastUpdateTs < _currentPeriodStart) {\n            _currentTotalAmount = _amount;\n        } else {\n            _currentTotalAmount = _currentPeriod.amount + _amount;\n        }\n        if (_currentTotalAmount > _currentPeriod.limit) {\n            revert ExceedTotalLimit();\n        }\n\n        _currentPeriod.lastUpdateTs = uint48(block.timestamp);\n        _currentPeriod.amount = SafeCast.toUint104(_currentTotalAmount);\n\n        currentPeriod = _currentPeriod;\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update the total token amount limit.\n    /// @param _newTotalLimit The new total limit.\n    function updateTotalLimit(uint104 _newTotalLimit) external onlyOwner {\n        if (_newTotalLimit == 0) {\n            revert TotalLimitIsZero();\n        }\n\n        uint256 _oldTotalLimit = currentPeriod.limit;\n        currentPeriod.limit = _newTotalLimit;\n\n        emit UpdateTotalLimit(_oldTotalLimit, _newTotalLimit);\n    }\n}"
    },
    {
      "filename": "contracts/src/rate-limiter/IETHRateLimiter.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\ninterface IETHRateLimiter {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when the total limit is updated.\n    /// @param oldTotalLimit The previous value of total limit before updating.\n    /// @param newTotalLimit The current value of total limit after updating.\n    event UpdateTotalLimit(uint256 oldTotalLimit, uint256 newTotalLimit);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the `periodDuration` is initialized to zero.\n    error PeriodIsZero();\n\n    /// @dev Thrown when the `totalAmount` is initialized to zero.\n    error TotalLimitIsZero();\n\n    /// @dev Thrown when an amount breaches the total limit in the period.\n    error ExceedTotalLimit();\n\n    /// @dev Thrown when the call is not spender.\n    error CallerNotSpender();\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Request some ETH usage for `sender`.\n    /// @param _amount The amount of ETH to use.\n    function addUsedAmount(uint256 _amount) external;\n}"
    },
    {
      "filename": "contracts/src/rate-limiter/ITokenRateLimiter.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\ninterface ITokenRateLimiter {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when the total limit is updated.\n    /// @param oldTotalLimit The previous value of total limit before updating.\n    /// @param newTotalLimit The current value of total limit after updating.\n    event UpdateTotalLimit(address indexed token, uint256 oldTotalLimit, uint256 newTotalLimit);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the `periodDuration` is initialized to zero.\n    error PeriodIsZero();\n\n    /// @dev Thrown when the `totalAmount` is initialized to zero.\n    /// @param token The address of the token.\n    error TotalLimitIsZero(address token);\n\n    /// @dev Thrown when an amount breaches the total limit in the period.\n    /// @param token The address of the token.\n    error ExceedTotalLimit(address token);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Request some token usage for `sender`.\n    /// @param token The address of the token.\n    /// @param amount The amount of token to use.\n    function addUsedAmount(address token, uint256 amount) external;\n}"
    },
    {
      "filename": "contracts/src/rate-limiter/TokenRateLimiter.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.16;\n\nimport {AccessControlEnumerable} from \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport {ITokenRateLimiter} from \"./ITokenRateLimiter.sol\";\n\n// solhint-disable func-name-mixedcase\n// solhint-disable not-rely-on-time\n\ncontract TokenRateLimiter is AccessControlEnumerable, ITokenRateLimiter {\n    /***********\n     * Structs *\n     ***********/\n\n    struct TokenAmount {\n        // The timestamp when the amount is updated.\n        uint48 lastUpdateTs;\n        // The token limit.\n        uint104 limit;\n        // The amount of token in current period.\n        uint104 amount;\n    }\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The role for token spender.\n    bytes32 public constant TOKEN_SPENDER_ROLE = keccak256(\"TOKEN_SPENDER_ROLE\");\n\n    /// @notice The period length in seconds.\n    /// @dev The time frame for the `k`-th period is `[periodDuration * k, periodDuration * (k + 1))`.\n    uint256 public immutable periodDuration;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from token address to the total amounts used in current period and total token amount limit.\n    mapping(address => TokenAmount) public currentPeriod;\n\n    /// @dev The storage slots for future usage.\n    uint256[49] private __gap;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(uint256 _periodDuration) {\n        if (_periodDuration == 0) {\n            revert PeriodIsZero();\n        }\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n\n        periodDuration = _periodDuration;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc ITokenRateLimiter\n    function addUsedAmount(address _token, uint256 _amount) external override onlyRole(TOKEN_SPENDER_ROLE) {\n        if (_amount == 0) return;\n\n        uint256 _currentPeriodStart = (block.timestamp / periodDuration) * periodDuration;\n\n        // check total limit, `0` means no limit at all.\n        uint256 _currentTotalAmount;\n        TokenAmount memory _currentPeriod = currentPeriod[_token];\n        if (_currentPeriod.lastUpdateTs < _currentPeriodStart) {\n            _currentTotalAmount = _amount;\n        } else {\n            _currentTotalAmount = _currentPeriod.amount + _amount;\n        }\n        if (_currentPeriod.limit != 0 && _currentTotalAmount > _currentPeriod.limit) {\n            revert ExceedTotalLimit(_token);\n        }\n\n        _currentPeriod.lastUpdateTs = uint48(block.timestamp);\n        _currentPeriod.amount = SafeCast.toUint104(_currentTotalAmount);\n\n        currentPeriod[_token] = _currentPeriod;\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update the total token amount limit.\n    /// @param _newTotalLimit The new total limit.\n    function updateTotalLimit(address _token, uint104 _newTotalLimit) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_newTotalLimit == 0) {\n            revert TotalLimitIsZero(_token);\n        }\n\n        uint256 _oldTotalLimit = currentPeriod[_token].limit;\n        currentPeriod[_token].limit = _newTotalLimit;\n\n        emit UpdateTotalLimit(_token, _oldTotalLimit, _newTotalLimit);\n    }\n}"
    },
    {
      "filename": "contracts/src/rate-limiter/TokenRateLimiter.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.16;\n\nimport {AccessControlEnumerable} from \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport {ITokenRateLimiter} from \"./ITokenRateLimiter.sol\";\n\n// solhint-disable func-name-mixedcase\n// solhint-disable not-rely-on-time\n\ncontract TokenRateLimiter is AccessControlEnumerable, ITokenRateLimiter {\n    /***********\n     * Structs *\n     ***********/\n\n    struct TokenAmount {\n        // The timestamp when the amount is updated.\n        uint48 lastUpdateTs;\n        // The token limit.\n        uint104 limit;\n        // The amount of token in current period.\n        uint104 amount;\n    }\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The role for token spender.\n    bytes32 public constant TOKEN_SPENDER_ROLE = keccak256(\"TOKEN_SPENDER_ROLE\");\n\n    /// @notice The period length in seconds.\n    /// @dev The time frame for the `k`-th period is `[periodDuration * k, periodDuration * (k + 1))`.\n    uint256 public immutable periodDuration;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from token address to the total amounts used in current period and total token amount limit.\n    mapping(address => TokenAmount) public currentPeriod;\n\n    /// @dev The storage slots for future usage.\n    uint256[49] private __gap;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(uint256 _periodDuration) {\n        if (_periodDuration == 0) {\n            revert PeriodIsZero();\n        }\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n\n        periodDuration = _periodDuration;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc ITokenRateLimiter\n    function addUsedAmount(address _token, uint256 _amount) external override onlyRole(TOKEN_SPENDER_ROLE) {\n        if (_amount == 0) return;\n\n        uint256 _currentPeriodStart = (block.timestamp / periodDuration) * periodDuration;\n\n        // check total limit, `0` means no limit at all.\n        uint256 _currentTotalAmount;\n        TokenAmount memory _currentPeriod = currentPeriod[_token];\n        if (_currentPeriod.lastUpdateTs < _currentPeriodStart) {\n            _currentTotalAmount = _amount;\n        } else {\n            _currentTotalAmount = _currentPeriod.amount + _amount;\n        }\n        if (_currentPeriod.limit != 0 && _currentTotalAmount > _currentPeriod.limit) {\n            revert ExceedTotalLimit(_token);\n        }\n\n        _currentPeriod.lastUpdateTs = uint48(block.timestamp);\n        _currentPeriod.amount = SafeCast.toUint104(_currentTotalAmount);\n\n        currentPeriod[_token] = _currentPeriod;\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update the total token amount limit.\n    /// @param _newTotalLimit The new total limit.\n    function updateTotalLimit(address _token, uint104 _newTotalLimit) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_newTotalLimit == 0) {\n            revert TotalLimitIsZero(_token);\n        }\n\n        uint256 _oldTotalLimit = currentPeriod[_token].limit;\n        currentPeriod[_token].limit = _newTotalLimit;\n\n        emit UpdateTotalLimit(_token, _oldTotalLimit, _newTotalLimit);\n    }\n}"
    },
    {
      "filename": "contracts/src/rate-limiter/ITokenRateLimiter.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\ninterface ITokenRateLimiter {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when the total limit is updated.\n    /// @param oldTotalLimit The previous value of total limit before updating.\n    /// @param newTotalLimit The current value of total limit after updating.\n    event UpdateTotalLimit(address indexed token, uint256 oldTotalLimit, uint256 newTotalLimit);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the `periodDuration` is initialized to zero.\n    error PeriodIsZero();\n\n    /// @dev Thrown when the `totalAmount` is initialized to zero.\n    /// @param token The address of the token.\n    error TotalLimitIsZero(address token);\n\n    /// @dev Thrown when an amount breaches the total limit in the period.\n    /// @param token The address of the token.\n    error ExceedTotalLimit(address token);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Request some token usage for `sender`.\n    /// @param token The address of the token.\n    /// @param amount The amount of token to use.\n    function addUsedAmount(address token, uint256 amount) external;\n}"
    }
  ]
}