{
  "Title": "[H-06] `Mul/div` relation should not be enforced when divisor is zero",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/era-zkevm_circuits/src/main_vm/opcodes/mul_div.rs#L286-L292><br>\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/era-zkevm_circuits/src/main_vm/opcodes/mul_div.rs#L358>\n\n### Impact\n\nWhen applying opcode `div`, if dividend is nonzero and divisor is zero, the resulted quotient and remainder are both zero. The enforced `mul/div` relation does not hold. An unprovable transaction will dos the priority queue.\n\n### Proof of Concept\n\n    quotient_is_zero.conditionally_enforce_true(cs, divisor_is_zero);\n    remainder_is_zero.conditionally_enforce_true(cs, divisor_is_zero);\n\nAccording to the EraVM spec, if divisor is zero, quotient and remainder should also be zero.\n\n    let uint256_zero = UInt256::zero(cs);\n\n    let rem_to_enforce = UInt32::parallel_select(\n        cs,\n        should_apply_mul,\n        &uint256_zero.inner,\n        &remainder_unchecked,\n    );\n    let a_to_enforce =\n        UInt32::parallel_select(cs, should_apply_mul, src0_view, &quotient_unchecked);\n    let b_to_enforce = src1_view.clone();\n    let mul_low_to_enforce =\n        UInt32::parallel_select(cs, should_apply_mul, &mul_low_unchecked, &src0_view);\n    let mul_high_to_enforce = UInt32::parallel_select(\n        cs,\n        should_apply_mul,\n        &mul_high_unchecked,\n        &uint256_zero.inner,\n    );\n\n    let mul_relation = MulDivRelation {\n        a: a_to_enforce,\n        b: b_to_enforce,\n        rem: rem_to_enforce,\n        mul_low: mul_low_to_enforce,\n        mul_high: mul_high_to_enforce,\n    };\n\nWhen dividing, the relation we need to enforce is `src0 = q * src1 + rem.` However, if `src0` (dividend) is nonzero and `src1` (divisor) is zero, both `q` and `rem` will be zero. The relation does not hold.\n\n    let apply_any = Boolean::multi_or(cs, &[should_apply_mul, should_apply_div]);\n    ......\n    diffs_accumulator\n        .mul_div_relations\n        .push((apply_any, mul_div_relations));\n\nIn fact, this relation will be enforced as long as we apply `div`, which will make the operation unprovable.\n\n### Recommended Mitigation Steps\n\nDon't enforce `mul/div` relation when divisor is zero.\n\n### Assessed type\n\nContext\n\n**[miladpiri (zkSync) confirmed and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/598#issuecomment-1794528268):**\n > Overconstrained.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/598#issuecomment-1826873108):**\n > The Warden has shown a case in which the `mul/div` relation doesn't require an additional constraint in the case of a zero divisor.\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-10-zksync",
  "Code": [
    {
      "filename": "code/era-zkevm_circuits/src/main_vm/opcodes/mul_div.rs",
      "content": "use self::ethereum_types::U256;\nuse super::*;\n\nuse crate::base_structures::register::VMRegister;\nuse crate::base_structures::vm_state::ArithmeticFlagsPort;\nuse arrayvec::ArrayVec;\nuse boojum::gadgets::u256::{decompose_u256_as_u32x8, UInt256};\n\nfn allocate_u256_from_limbs<F: SmallField>(limbs: &[F]) -> U256 {\n    debug_assert_eq!(limbs.len(), 8);\n\n    let mut byte_array = [0u8; 32];\n    for (dst, limb) in byte_array.array_chunks_mut::<4>().zip(limbs.iter()) {\n        *dst = (limb.as_u64_reduced() as u32).to_le_bytes();\n    }\n\n    U256::from_little_endian(&byte_array)\n}\n\npub fn allocate_mul_result_unchecked<F: SmallField, CS: ConstraintSystem<F>>(\n    cs: &mut CS,\n    a: &[UInt32<F>; 8],\n    b: &[UInt32<F>; 8],\n) -> ([UInt32<F>; 8], [UInt32<F>; 8]) {\n    let limbs_low = cs.alloc_multiple_variables_without_values::<8>();\n    let limbs_high = cs.alloc_multiple_variables_without_values::<8>();\n\n    if <CS::Config as CSConfig>::WitnessConfig::EVALUATE_WITNESS {\n        let value_fn = move |inputs: [F; 16]| {\n            let a = allocate_u256_from_limbs(&inputs[0..8]);\n            let b = allocate_u256_from_limbs(&inputs[8..16]);\n            let mut c_bytes = [0u8; 64];\n            a.full_mul(b).to_little_endian(&mut c_bytes[..]);\n\n            let mut outputs = [F::ZERO; 16];\n            let mut byte_array = [0u8; 4];\n            for (in_chunk, out_elem) in c_bytes.chunks(4).zip(outputs.iter_mut()) {\n                byte_array.copy_from_slice(in_chunk);\n                let as_u32 = u32::from_le_bytes(byte_array);\n                *out_elem = F::from_u64_unchecked(as_u32 as u64);\n            }\n\n            outputs\n        };\n\n        let dependencies = Place::from_variables([\n            a[0].get_variable(),\n            a[1].get_variable(),\n            a[2].get_variable(),\n            a[3].get_variable(),\n            a[4].get_variable(),\n            a[5].get_variable(),\n            a[6].get_variable(),\n            a[7].get_variable(),\n            b[0].get_variable(),\n            b[1].get_variable(),\n            b[2].get_variable(),\n            b[3].get_variable(),\n            b[4].get_variable(),\n            b[5].get_variable(),\n            b[6].get_variable(),\n            b[7].get_variable(),\n        ]);\n        let outputs = Place::from_variables([\n            limbs_low[0],\n            limbs_low[1],\n            limbs_low[2],\n            limbs_low[3],\n            limbs_low[4],\n            limbs_low[5],\n            limbs_low[6],\n            limbs_low[7],\n            limbs_high[0],\n            limbs_high[1],\n            limbs_high[2],\n            limbs_high[3],\n            limbs_high[4],\n            limbs_high[5],\n            limbs_high[6],\n            limbs_high[7],\n        ]);\n        cs.set_values_with_dependencies(&dependencies, &outputs, value_fn);\n    }\n\n    let limbs_low = limbs_low.map(|el| unsafe { UInt32::from_variable_unchecked(el) });\n    let limbs_high = limbs_high.map(|el| unsafe { UInt32::from_variable_unchecked(el) });\n\n    (limbs_low, limbs_high)\n}\n\npub fn allocate_div_result_unchecked<F: SmallField, CS: ConstraintSystem<F>>(\n    cs: &mut CS,\n    a: &[UInt32<F>; 8],\n    b: &[UInt32<F>; 8],\n) -> ([UInt32<F>; 8], [UInt32<F>; 8]) {\n    let quotient = cs.alloc_multiple_variables_without_values::<8>();\n    let remainder = cs.alloc_multiple_variables_without_values::<8>();\n\n    if <CS::Config as CSConfig>::WitnessConfig::EVALUATE_WITNESS {\n        let value_fn = move |inputs: [F; 16]| {\n            let a = allocate_u256_from_limbs(&inputs[0..8]);\n            let b = allocate_u256_from_limbs(&inputs[8..16]);\n\n            let (quotient, remainder) = if b.is_zero() {\n                (U256::zero(), U256::zero())\n            } else {\n                a.div_mod(b)\n            };\n\n            let mut outputs = [F::ZERO; 16];\n            for (dst, src) in outputs[..8]\n                .iter_mut()\n                .zip(decompose_u256_as_u32x8(quotient).into_iter())\n            {\n                *dst = F::from_u64_unchecked(src as u64);\n            }\n            for (dst, src) in outputs[8..]\n                .iter_mut()\n                .zip(decompose_u256_as_u32x8(remainder).into_iter())\n            {\n                *dst = F::from_u64_unchecked(src as u64);\n            }\n\n            outputs\n        };\n\n        let dependencies = Place::from_variables([\n            a[0].get_variable(),\n            a[1].get_variable(),\n            a[2].get_variable(),\n            a[3].get_variable(),\n            a[4].get_variable(),\n            a[5].get_variable(),\n            a[6].get_variable(),\n            a[7].get_variable(),\n            b[0].get_variable(),\n            b[1].get_variable(),\n            b[2].get_variable(),\n            b[3].get_variable(),\n            b[4].get_variable(),\n            b[5].get_variable(),\n            b[6].get_variable(),\n            b[7].get_variable(),\n        ]);\n        let outputs = Place::from_variables([\n            quotient[0],\n            quotient[1],\n            quotient[2],\n            quotient[3],\n            quotient[4],\n            quotient[5],\n            quotient[6],\n            quotient[7],\n            remainder[0],\n            remainder[1],\n            remainder[2],\n            remainder[3],\n            remainder[4],\n            remainder[5],\n            remainder[6],\n            remainder[7],\n        ]);\n        cs.set_values_with_dependencies(&dependencies, &outputs, value_fn);\n    }\n\n    let quotient = quotient.map(|el| unsafe { UInt32::from_variable_unchecked(el) });\n    let remainder = remainder.map(|el| unsafe { UInt32::from_variable_unchecked(el) });\n\n    (quotient, remainder)\n}\n\npub fn all_limbs_are_zero<F: SmallField, CS: ConstraintSystem<F>>(\n    cs: &mut CS,\n    limbs: &[UInt32<F>; 8],\n) -> Boolean<F> {\n    let limb_is_zero = limbs.map(|el| el.is_zero(cs));\n    let result_is_zero = Boolean::multi_and(cs, &limb_is_zero);\n\n    result_is_zero\n}\n\npub fn all_limbs_are_equal<F: SmallField, CS: ConstraintSystem<F>>(\n    cs: &mut CS,\n    lhs: &[UInt32<F>; 8],\n    rhs: &[UInt32<F>; 8],\n) -> Boolean<F> {\n    let boolean_false = Boolean::allocated_constant(cs, false);\n    let mut flags = [boolean_false; 8];\n    for ((lhs_limb, rhs_limb), out) in lhs.iter().zip(rhs.iter()).zip(flags.iter_mut()) {\n        *out = UInt32::equals(cs, lhs_limb, rhs_limb);\n    }\n    let result = Boolean::multi_and(cs, &flags);\n\n    result\n}\n\npub(crate) fn apply_mul_div<F: SmallField, CS: ConstraintSystem<F>>(\n    cs: &mut CS,\n    _draft_vm_state: &VmLocalState<F>,\n    common_opcode_state: &CommonOpcodeState<F>,\n    _opcode_carry_parts: &AfterDecodingCarryParts<F>,\n    diffs_accumulator: &mut StateDiffsAccumulator<F>,\n) {\n    const MUL_OPCODE: zkevm_opcode_defs::Opcode =\n        zkevm_opcode_defs::Opcode::Mul(zkevm_opcode_defs::MulOpcode);\n    const DIV_OPCODE: zkevm_opcode_defs::Opcode =\n        zkevm_opcode_defs::Opcode::Div(zkevm_opcode_defs::DivOpcode);\n\n    let should_apply_mul = common_opcode_state\n        .decoded_opcode\n        .properties_bits\n        .boolean_for_opcode(MUL_OPCODE);\n    let should_apply_div = common_opcode_state\n        .decoded_opcode\n        .properties_bits\n        .boolean_for_opcode(DIV_OPCODE);\n\n    if crate::config::CIRCUIT_VERSOBE {\n        if (should_apply_mul.witness_hook(&*cs))().unwrap_or(false) {\n            println!(\"Applying MUL\");\n        }\n        if (should_apply_div.witness_hook(&*cs))().unwrap_or(false) {\n            println!(\"Applying DIV\");\n        }\n    }\n\n    let should_set_flags = common_opcode_state\n        .decoded_opcode\n        .properties_bits\n        .flag_booleans[SET_FLAGS_FLAG_IDX];\n\n    let src0_view = &common_opcode_state.src0_view.u32x8_view;\n    let src1_view = &common_opcode_state.src1_view.u32x8_view;\n\n    let (mul_low_unchecked, mul_high_unchecked) =\n        allocate_mul_result_unchecked(cs, src0_view, src1_view);\n    let (quotient_unchecked, remainder_unchecked) =\n        allocate_div_result_unchecked(cs, src0_view, src1_view);\n\n    // if crate::config::CIRCUIT_VERSOBE {\n    //     if (should_apply_mul.witness_hook(&*cs))().unwrap_or(false) || (should_apply_div.witness_hook(&*cs))().unwrap_or(false) {\n    //         dbg!(mul_low_unchecked.witness_hook(&*cs)().unwrap());\n    //         dbg!(mul_high_unchecked.witness_hook(&*cs)().unwrap());\n    //         dbg!(quotient_unchecked.witness_hook(&*cs)().unwrap());\n    //         dbg!(remainder_unchecked.witness_hook(&*cs)().unwrap());\n    //     }\n    // }\n\n    let to_enforce_0 = UInt32::parallel_select(\n        cs,\n        should_apply_mul,\n        &mul_low_unchecked,\n        &quotient_unchecked,\n    );\n    let result_0 = to_enforce_0.map(|el| UInt32::from_variable_checked(cs, el.get_variable()));\n    let to_enforce_1 = UInt32::parallel_select(\n        cs,\n        should_apply_mul,\n        &mul_high_unchecked,\n        &remainder_unchecked,\n    );\n    let result_1 = to_enforce_1.map(|el| UInt32::from_variable_checked(cs, el.get_variable()));\n\n    // if we mull: src0 * src1 = mul_low + (mul_high << 256) => rem = 0, a = src0, b = src1, mul_low = mul_low, mul_high = mul_high\n    // if we divide: src0 = q * src1 + rem =>                   rem = rem, a = quotient, b = src1, mul_low = src0, mul_high = 0\n    let uint256_zero = UInt256::zero(cs);\n\n    let rem_to_enforce = UInt32::parallel_select(\n        cs,\n        should_apply_mul,\n        &uint256_zero.inner,\n        &remainder_unchecked,\n    );\n    let a_to_enforce =\n        UInt32::parallel_select(cs, should_apply_mul, src0_view, &quotient_unchecked);\n    let b_to_enforce = src1_view.clone();\n    let mul_low_to_enforce =\n        UInt32::parallel_select(cs, should_apply_mul, &mul_low_unchecked, &src0_view);\n    let mul_high_to_enforce = UInt32::parallel_select(\n        cs,\n        should_apply_mul,\n        &mul_high_unchecked,\n        &uint256_zero.inner,\n    );\n\n    let mul_relation = MulDivRelation {\n        a: a_to_enforce,\n        b: b_to_enforce,\n        rem: rem_to_enforce,\n        mul_low: mul_low_to_enforce,\n        mul_high: mul_high_to_enforce,\n    };\n\n    // flags which are set in case of executing mul\n    let high_is_zero = all_limbs_are_zero(cs, &mul_high_unchecked);\n    let low_is_zero = all_limbs_are_zero(cs, &mul_low_unchecked);\n    let of_mul = high_is_zero.negated(cs);\n    let eq_mul = low_is_zero;\n    let gt_mul = {\n        let x = of_mul.negated(cs);\n        let y = eq_mul.negated(cs);\n        Boolean::multi_and(cs, &[x, y])\n    };\n\n    // flags which are set in case of executing div\n    let divisor_is_zero = all_limbs_are_zero(cs, src1_view);\n    let divisor_is_non_zero = divisor_is_zero.negated(cs);\n    // check if quotient and remainder are 0\n    let quotient_is_zero = all_limbs_are_zero(cs, &quotient_unchecked);\n    let remainder_is_zero = all_limbs_are_zero(cs, &remainder_unchecked);\n\n    // check that remainder is smaller than divisor\n\n    // do remainder - divisor\n    let (subtraction_result_unchecked, remainder_is_less_than_divisor) =\n        allocate_subtraction_result_unchecked(cs, &remainder_unchecked, src1_view);\n\n    // relation is a + b == c + of * 2^N,\n    // but we compute d - e + 2^N * borrow = f\n\n    // so we need to shuffle\n    let addition_relation = AddSubRelation {\n        a: *src1_view,\n        b: subtraction_result_unchecked,\n        c: remainder_unchecked,\n        of: remainder_is_less_than_divisor,\n    };\n\n    // unless divisor is 0 (that we handle separately),\n    // we require that remainder is < divisor\n    remainder_is_less_than_divisor.conditionally_enforce_true(cs, divisor_is_non_zero);\n\n    // if divisor is 0, then we assume quotient and remainder to be 0\n\n    quotient_is_zero.conditionally_enforce_true(cs, divisor_is_zero);\n    remainder_is_zero.conditionally_enforce_true(cs, divisor_is_zero);\n\n    let of_div = divisor_is_zero;\n    let eq_div = {\n        let x = divisor_is_zero.negated(cs);\n        Boolean::multi_and(cs, &[x, quotient_is_zero])\n    };\n    let gt_div = {\n        let y = divisor_is_zero.negated(cs);\n        Boolean::multi_and(cs, &[y, remainder_is_zero])\n    };\n\n    let of = Boolean::conditionally_select(cs, should_apply_mul, &of_mul, &of_div);\n    let eq = Boolean::conditionally_select(cs, should_apply_mul, &eq_mul, &eq_div);\n    let gt = Boolean::conditionally_select(cs, should_apply_mul, &gt_mul, &gt_div);\n\n    let candidate_flags = ArithmeticFlagsPort {\n        overflow_or_less_than: of,\n        equal: eq,\n        greater_than: gt,\n    };\n\n    let apply_any = Boolean::multi_or(cs, &[should_apply_mul, should_apply_div]);\n    let dst0 = VMRegister {\n        is_pointer: Boolean::allocated_constant(cs, false),\n        value: UInt256 { inner: result_0 },\n    };\n    let dst1 = VMRegister {\n        is_pointer: Boolean::allocated_constant(cs, false),\n        value: UInt256 { inner: result_1 },\n    };\n\n    // if crate::config::CIRCUIT_VERSOBE {\n    //     if (should_apply_mul.witness_hook(&*cs))().unwrap_or(false) || (should_apply_div.witness_hook(&*cs))().unwrap_or(false) {\n    //         dbg!(result_0.witness_hook(&*cs)().unwrap());\n    //         dbg!(result_1.witness_hook(&*cs)().unwrap());\n    //     }\n    // }\n\n    let can_write_into_memory = MUL_OPCODE.can_write_dst0_into_memory(SUPPORTED_ISA_VERSION);\n    debug_assert_eq!(\n        can_write_into_memory,\n        DIV_OPCODE.can_write_dst0_into_memory(SUPPORTED_ISA_VERSION)\n    );\n\n    diffs_accumulator\n        .dst_0_values\n        .push((can_write_into_memory, apply_any, dst0));\n    diffs_accumulator.dst_1_values.push((apply_any, dst1));\n    let set_flags_and_execute = Boolean::multi_and(cs, &[apply_any, should_set_flags]);\n    diffs_accumulator\n        .flags\n        .push((set_flags_and_execute, candidate_flags));\n\n    let mut add_sub_relations = ArrayVec::new();\n    add_sub_relations.push(addition_relation);\n    diffs_accumulator\n        .add_sub_relations\n        .push((apply_any, add_sub_relations));\n\n    let mut mul_div_relations = ArrayVec::new();\n    mul_div_relations.push(mul_relation);\n    diffs_accumulator\n        .mul_div_relations\n        .push((apply_any, mul_div_relations));\n}"
    },
    {
      "filename": "code/era-zkevm_circuits/src/main_vm/opcodes/mul_div.rs",
      "content": "use self::ethereum_types::U256;\nuse super::*;\n\nuse crate::base_structures::register::VMRegister;\nuse crate::base_structures::vm_state::ArithmeticFlagsPort;\nuse arrayvec::ArrayVec;\nuse boojum::gadgets::u256::{decompose_u256_as_u32x8, UInt256};\n\nfn allocate_u256_from_limbs<F: SmallField>(limbs: &[F]) -> U256 {\n    debug_assert_eq!(limbs.len(), 8);\n\n    let mut byte_array = [0u8; 32];\n    for (dst, limb) in byte_array.array_chunks_mut::<4>().zip(limbs.iter()) {\n        *dst = (limb.as_u64_reduced() as u32).to_le_bytes();\n    }\n\n    U256::from_little_endian(&byte_array)\n}\n\npub fn allocate_mul_result_unchecked<F: SmallField, CS: ConstraintSystem<F>>(\n    cs: &mut CS,\n    a: &[UInt32<F>; 8],\n    b: &[UInt32<F>; 8],\n) -> ([UInt32<F>; 8], [UInt32<F>; 8]) {\n    let limbs_low = cs.alloc_multiple_variables_without_values::<8>();\n    let limbs_high = cs.alloc_multiple_variables_without_values::<8>();\n\n    if <CS::Config as CSConfig>::WitnessConfig::EVALUATE_WITNESS {\n        let value_fn = move |inputs: [F; 16]| {\n            let a = allocate_u256_from_limbs(&inputs[0..8]);\n            let b = allocate_u256_from_limbs(&inputs[8..16]);\n            let mut c_bytes = [0u8; 64];\n            a.full_mul(b).to_little_endian(&mut c_bytes[..]);\n\n            let mut outputs = [F::ZERO; 16];\n            let mut byte_array = [0u8; 4];\n            for (in_chunk, out_elem) in c_bytes.chunks(4).zip(outputs.iter_mut()) {\n                byte_array.copy_from_slice(in_chunk);\n                let as_u32 = u32::from_le_bytes(byte_array);\n                *out_elem = F::from_u64_unchecked(as_u32 as u64);\n            }\n\n            outputs\n        };\n\n        let dependencies = Place::from_variables([\n            a[0].get_variable(),\n            a[1].get_variable(),\n            a[2].get_variable(),\n            a[3].get_variable(),\n            a[4].get_variable(),\n            a[5].get_variable(),\n            a[6].get_variable(),\n            a[7].get_variable(),\n            b[0].get_variable(),\n            b[1].get_variable(),\n            b[2].get_variable(),\n            b[3].get_variable(),\n            b[4].get_variable(),\n            b[5].get_variable(),\n            b[6].get_variable(),\n            b[7].get_variable(),\n        ]);\n        let outputs = Place::from_variables([\n            limbs_low[0],\n            limbs_low[1],\n            limbs_low[2],\n            limbs_low[3],\n            limbs_low[4],\n            limbs_low[5],\n            limbs_low[6],\n            limbs_low[7],\n            limbs_high[0],\n            limbs_high[1],\n            limbs_high[2],\n            limbs_high[3],\n            limbs_high[4],\n            limbs_high[5],\n            limbs_high[6],\n            limbs_high[7],\n        ]);\n        cs.set_values_with_dependencies(&dependencies, &outputs, value_fn);\n    }\n\n    let limbs_low = limbs_low.map(|el| unsafe { UInt32::from_variable_unchecked(el) });\n    let limbs_high = limbs_high.map(|el| unsafe { UInt32::from_variable_unchecked(el) });\n\n    (limbs_low, limbs_high)\n}\n\npub fn allocate_div_result_unchecked<F: SmallField, CS: ConstraintSystem<F>>(\n    cs: &mut CS,\n    a: &[UInt32<F>; 8],\n    b: &[UInt32<F>; 8],\n) -> ([UInt32<F>; 8], [UInt32<F>; 8]) {\n    let quotient = cs.alloc_multiple_variables_without_values::<8>();\n    let remainder = cs.alloc_multiple_variables_without_values::<8>();\n\n    if <CS::Config as CSConfig>::WitnessConfig::EVALUATE_WITNESS {\n        let value_fn = move |inputs: [F; 16]| {\n            let a = allocate_u256_from_limbs(&inputs[0..8]);\n            let b = allocate_u256_from_limbs(&inputs[8..16]);\n\n            let (quotient, remainder) = if b.is_zero() {\n                (U256::zero(), U256::zero())\n            } else {\n                a.div_mod(b)\n            };\n\n            let mut outputs = [F::ZERO; 16];\n            for (dst, src) in outputs[..8]\n                .iter_mut()\n                .zip(decompose_u256_as_u32x8(quotient).into_iter())\n            {\n                *dst = F::from_u64_unchecked(src as u64);\n            }\n            for (dst, src) in outputs[8..]\n                .iter_mut()\n                .zip(decompose_u256_as_u32x8(remainder).into_iter())\n            {\n                *dst = F::from_u64_unchecked(src as u64);\n            }\n\n            outputs\n        };\n\n        let dependencies = Place::from_variables([\n            a[0].get_variable(),\n            a[1].get_variable(),\n            a[2].get_variable(),\n            a[3].get_variable(),\n            a[4].get_variable(),\n            a[5].get_variable(),\n            a[6].get_variable(),\n            a[7].get_variable(),\n            b[0].get_variable(),\n            b[1].get_variable(),\n            b[2].get_variable(),\n            b[3].get_variable(),\n            b[4].get_variable(),\n            b[5].get_variable(),\n            b[6].get_variable(),\n            b[7].get_variable(),\n        ]);\n        let outputs = Place::from_variables([\n            quotient[0],\n            quotient[1],\n            quotient[2],\n            quotient[3],\n            quotient[4],\n            quotient[5],\n            quotient[6],\n            quotient[7],\n            remainder[0],\n            remainder[1],\n            remainder[2],\n            remainder[3],\n            remainder[4],\n            remainder[5],\n            remainder[6],\n            remainder[7],\n        ]);\n        cs.set_values_with_dependencies(&dependencies, &outputs, value_fn);\n    }\n\n    let quotient = quotient.map(|el| unsafe { UInt32::from_variable_unchecked(el) });\n    let remainder = remainder.map(|el| unsafe { UInt32::from_variable_unchecked(el) });\n\n    (quotient, remainder)\n}\n\npub fn all_limbs_are_zero<F: SmallField, CS: ConstraintSystem<F>>(\n    cs: &mut CS,\n    limbs: &[UInt32<F>; 8],\n) -> Boolean<F> {\n    let limb_is_zero = limbs.map(|el| el.is_zero(cs));\n    let result_is_zero = Boolean::multi_and(cs, &limb_is_zero);\n\n    result_is_zero\n}\n\npub fn all_limbs_are_equal<F: SmallField, CS: ConstraintSystem<F>>(\n    cs: &mut CS,\n    lhs: &[UInt32<F>; 8],\n    rhs: &[UInt32<F>; 8],\n) -> Boolean<F> {\n    let boolean_false = Boolean::allocated_constant(cs, false);\n    let mut flags = [boolean_false; 8];\n    for ((lhs_limb, rhs_limb), out) in lhs.iter().zip(rhs.iter()).zip(flags.iter_mut()) {\n        *out = UInt32::equals(cs, lhs_limb, rhs_limb);\n    }\n    let result = Boolean::multi_and(cs, &flags);\n\n    result\n}\n\npub(crate) fn apply_mul_div<F: SmallField, CS: ConstraintSystem<F>>(\n    cs: &mut CS,\n    _draft_vm_state: &VmLocalState<F>,\n    common_opcode_state: &CommonOpcodeState<F>,\n    _opcode_carry_parts: &AfterDecodingCarryParts<F>,\n    diffs_accumulator: &mut StateDiffsAccumulator<F>,\n) {\n    const MUL_OPCODE: zkevm_opcode_defs::Opcode =\n        zkevm_opcode_defs::Opcode::Mul(zkevm_opcode_defs::MulOpcode);\n    const DIV_OPCODE: zkevm_opcode_defs::Opcode =\n        zkevm_opcode_defs::Opcode::Div(zkevm_opcode_defs::DivOpcode);\n\n    let should_apply_mul = common_opcode_state\n        .decoded_opcode\n        .properties_bits\n        .boolean_for_opcode(MUL_OPCODE);\n    let should_apply_div = common_opcode_state\n        .decoded_opcode\n        .properties_bits\n        .boolean_for_opcode(DIV_OPCODE);\n\n    if crate::config::CIRCUIT_VERSOBE {\n        if (should_apply_mul.witness_hook(&*cs))().unwrap_or(false) {\n            println!(\"Applying MUL\");\n        }\n        if (should_apply_div.witness_hook(&*cs))().unwrap_or(false) {\n            println!(\"Applying DIV\");\n        }\n    }\n\n    let should_set_flags = common_opcode_state\n        .decoded_opcode\n        .properties_bits\n        .flag_booleans[SET_FLAGS_FLAG_IDX];\n\n    let src0_view = &common_opcode_state.src0_view.u32x8_view;\n    let src1_view = &common_opcode_state.src1_view.u32x8_view;\n\n    let (mul_low_unchecked, mul_high_unchecked) =\n        allocate_mul_result_unchecked(cs, src0_view, src1_view);\n    let (quotient_unchecked, remainder_unchecked) =\n        allocate_div_result_unchecked(cs, src0_view, src1_view);\n\n    // if crate::config::CIRCUIT_VERSOBE {\n    //     if (should_apply_mul.witness_hook(&*cs))().unwrap_or(false) || (should_apply_div.witness_hook(&*cs))().unwrap_or(false) {\n    //         dbg!(mul_low_unchecked.witness_hook(&*cs)().unwrap());\n    //         dbg!(mul_high_unchecked.witness_hook(&*cs)().unwrap());\n    //         dbg!(quotient_unchecked.witness_hook(&*cs)().unwrap());\n    //         dbg!(remainder_unchecked.witness_hook(&*cs)().unwrap());\n    //     }\n    // }\n\n    let to_enforce_0 = UInt32::parallel_select(\n        cs,\n        should_apply_mul,\n        &mul_low_unchecked,\n        &quotient_unchecked,\n    );\n    let result_0 = to_enforce_0.map(|el| UInt32::from_variable_checked(cs, el.get_variable()));\n    let to_enforce_1 = UInt32::parallel_select(\n        cs,\n        should_apply_mul,\n        &mul_high_unchecked,\n        &remainder_unchecked,\n    );\n    let result_1 = to_enforce_1.map(|el| UInt32::from_variable_checked(cs, el.get_variable()));\n\n    // if we mull: src0 * src1 = mul_low + (mul_high << 256) => rem = 0, a = src0, b = src1, mul_low = mul_low, mul_high = mul_high\n    // if we divide: src0 = q * src1 + rem =>                   rem = rem, a = quotient, b = src1, mul_low = src0, mul_high = 0\n    let uint256_zero = UInt256::zero(cs);\n\n    let rem_to_enforce = UInt32::parallel_select(\n        cs,\n        should_apply_mul,\n        &uint256_zero.inner,\n        &remainder_unchecked,\n    );\n    let a_to_enforce =\n        UInt32::parallel_select(cs, should_apply_mul, src0_view, &quotient_unchecked);\n    let b_to_enforce = src1_view.clone();\n    let mul_low_to_enforce =\n        UInt32::parallel_select(cs, should_apply_mul, &mul_low_unchecked, &src0_view);\n    let mul_high_to_enforce = UInt32::parallel_select(\n        cs,\n        should_apply_mul,\n        &mul_high_unchecked,\n        &uint256_zero.inner,\n    );\n\n    let mul_relation = MulDivRelation {\n        a: a_to_enforce,\n        b: b_to_enforce,\n        rem: rem_to_enforce,\n        mul_low: mul_low_to_enforce,\n        mul_high: mul_high_to_enforce,\n    };\n\n    // flags which are set in case of executing mul\n    let high_is_zero = all_limbs_are_zero(cs, &mul_high_unchecked);\n    let low_is_zero = all_limbs_are_zero(cs, &mul_low_unchecked);\n    let of_mul = high_is_zero.negated(cs);\n    let eq_mul = low_is_zero;\n    let gt_mul = {\n        let x = of_mul.negated(cs);\n        let y = eq_mul.negated(cs);\n        Boolean::multi_and(cs, &[x, y])\n    };\n\n    // flags which are set in case of executing div\n    let divisor_is_zero = all_limbs_are_zero(cs, src1_view);\n    let divisor_is_non_zero = divisor_is_zero.negated(cs);\n    // check if quotient and remainder are 0\n    let quotient_is_zero = all_limbs_are_zero(cs, &quotient_unchecked);\n    let remainder_is_zero = all_limbs_are_zero(cs, &remainder_unchecked);\n\n    // check that remainder is smaller than divisor\n\n    // do remainder - divisor\n    let (subtraction_result_unchecked, remainder_is_less_than_divisor) =\n        allocate_subtraction_result_unchecked(cs, &remainder_unchecked, src1_view);\n\n    // relation is a + b == c + of * 2^N,\n    // but we compute d - e + 2^N * borrow = f\n\n    // so we need to shuffle\n    let addition_relation = AddSubRelation {\n        a: *src1_view,\n        b: subtraction_result_unchecked,\n        c: remainder_unchecked,\n        of: remainder_is_less_than_divisor,\n    };\n\n    // unless divisor is 0 (that we handle separately),\n    // we require that remainder is < divisor\n    remainder_is_less_than_divisor.conditionally_enforce_true(cs, divisor_is_non_zero);\n\n    // if divisor is 0, then we assume quotient and remainder to be 0\n\n    quotient_is_zero.conditionally_enforce_true(cs, divisor_is_zero);\n    remainder_is_zero.conditionally_enforce_true(cs, divisor_is_zero);\n\n    let of_div = divisor_is_zero;\n    let eq_div = {\n        let x = divisor_is_zero.negated(cs);\n        Boolean::multi_and(cs, &[x, quotient_is_zero])\n    };\n    let gt_div = {\n        let y = divisor_is_zero.negated(cs);\n        Boolean::multi_and(cs, &[y, remainder_is_zero])\n    };\n\n    let of = Boolean::conditionally_select(cs, should_apply_mul, &of_mul, &of_div);\n    let eq = Boolean::conditionally_select(cs, should_apply_mul, &eq_mul, &eq_div);\n    let gt = Boolean::conditionally_select(cs, should_apply_mul, &gt_mul, &gt_div);\n\n    let candidate_flags = ArithmeticFlagsPort {\n        overflow_or_less_than: of,\n        equal: eq,\n        greater_than: gt,\n    };\n\n    let apply_any = Boolean::multi_or(cs, &[should_apply_mul, should_apply_div]);\n    let dst0 = VMRegister {\n        is_pointer: Boolean::allocated_constant(cs, false),\n        value: UInt256 { inner: result_0 },\n    };\n    let dst1 = VMRegister {\n        is_pointer: Boolean::allocated_constant(cs, false),\n        value: UInt256 { inner: result_1 },\n    };\n\n    // if crate::config::CIRCUIT_VERSOBE {\n    //     if (should_apply_mul.witness_hook(&*cs))().unwrap_or(false) || (should_apply_div.witness_hook(&*cs))().unwrap_or(false) {\n    //         dbg!(result_0.witness_hook(&*cs)().unwrap());\n    //         dbg!(result_1.witness_hook(&*cs)().unwrap());\n    //     }\n    // }\n\n    let can_write_into_memory = MUL_OPCODE.can_write_dst0_into_memory(SUPPORTED_ISA_VERSION);\n    debug_assert_eq!(\n        can_write_into_memory,\n        DIV_OPCODE.can_write_dst0_into_memory(SUPPORTED_ISA_VERSION)\n    );\n\n    diffs_accumulator\n        .dst_0_values\n        .push((can_write_into_memory, apply_any, dst0));\n    diffs_accumulator.dst_1_values.push((apply_any, dst1));\n    let set_flags_and_execute = Boolean::multi_and(cs, &[apply_any, should_set_flags]);\n    diffs_accumulator\n        .flags\n        .push((set_flags_and_execute, candidate_flags));\n\n    let mut add_sub_relations = ArrayVec::new();\n    add_sub_relations.push(addition_relation);\n    diffs_accumulator\n        .add_sub_relations\n        .push((apply_any, add_sub_relations));\n\n    let mut mul_div_relations = ArrayVec::new();\n    mul_div_relations.push(mul_relation);\n    diffs_accumulator\n        .mul_div_relations\n        .push((apply_any, mul_div_relations));\n}"
    }
  ]
}