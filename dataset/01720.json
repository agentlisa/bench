{
  "Title": "FIXME and TODO comments",
  "Content": "There are several [FIXME](https://github.com/BeanstalkFarms/Wells/blob/e5441fc78f0fd4b77a898812d0fd22cb43a0af55/src/interfaces/IWell.sol#L351) and [TODO](https://github.com/BeanstalkFarms/Wells/blob/e5441fc78f0fd4b77a898812d0fd22cb43a0af55/src/libraries/LibMath.sol#L33) comments that should be addressed.\n\n**Beanstalk:** Fixed [here](https://github.com/BeanstalkFarms/Basin/pull/65).\n\n**Cyfrin:** Acknowledged.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/interfaces/IWell.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport {IERC20} from \"oz/token/ERC20/IERC20.sol\";\n\n/**\n * @title Call is the struct that contains the target address and extra calldata of a generic call.\n */\nstruct Call {\n    address target; // The address the call is executed on.\n    bytes data; // Extra calldata to be passed during the call\n}\n\n/**\n * @title IWell is the interface for the Well contract.\n */\ninterface IWell {\n    /**\n     * @notice Thrown when an operation would deliver fewer tokens than `minAmountOut`.\n     */\n    error SlippageOut(uint amountOut, uint minAmountOut);\n\n    /**\n     * @notice Thrown when an operation would require more tokens than `maxAmountIn`.\n     */\n    error SlippageIn(uint amountIn, uint maxAmountIn);\n\n    /**\n     * @notice Thrown if one or more tokens used in the operation are not supported by the Well.\n     */\n    error InvalidTokens();\n\n    /**\n     * @notice Thrown if this operation would cause an incorrect change in Well reserves.\n     */\n    error InvalidReserves();\n\n    /**\n     * @notice Thrown if an operation is executed after the provided `deadline` has passed.\n     */\n    error Expired();\n\n    /**\n     * @notice Emitted when a Swap occurs.\n     * @param fromToken The token swapped from\n     * @param toToken The token swapped to\n     * @param amountIn The amount of `fromToken` transferred into the Well\n     * @param amountOut The amount of `toToken` transferred out of the Well\n     * @param recipient The address to receive `toToken`\n     */\n    event Swap(IERC20 fromToken, IERC20 toToken, uint amountIn, uint amountOut, address recipient);\n\n    /**\n     * @notice Emitted when liquidity is added to the Well.\n     * @param tokenAmountsIn The amount of each token added to the Well\n     * @param lpAmountOut The amount of LP tokens minted\n     * @param recipient The address to receive the LP tokens\n     */\n    event AddLiquidity(uint[] tokenAmountsIn, uint lpAmountOut, address recipient);\n\n    /**\n     * @notice Emitted when liquidity is removed from the Well as multiple underlying tokens.\n     * @param lpAmountIn The amount of LP tokens burned\n     * @param tokenAmountsOut The amount of each underlying token removed\n     * @param recipient The address to receive the underlying tokens\n     * @dev Gas cost scales with `n` tokens.\n     */\n    event RemoveLiquidity(uint lpAmountIn, uint[] tokenAmountsOut, address recipient);\n\n    /**\n     * @notice Emitted when liquidity is removed from the Well as a single underlying token.\n     * @param lpAmountIn The amount of LP tokens burned\n     * @param tokenOut The underlying token removed\n     * @param tokenAmountOut The amount of `tokenOut` removed\n     * @param recipient The address to receive the underlying tokens\n     * @dev Emitting a separate event when removing liquidity as a single token\n     * saves gas, since `tokenAmountsOut` in {RemoveLiquidity} must emit a value\n     * for each token in the Well.\n     */\n    event RemoveLiquidityOneToken(uint lpAmountIn, IERC20 tokenOut, uint tokenAmountOut, address recipient);\n\n    /**\n     * @notice Emitted when a Shift occurs.\n     * @param reserves The ending reserves after a shift\n     * @param toToken The token swapped to\n     * @param minAmountOut The minimum amount of `toToken` transferred out of the Well\n     * @param recipient The address to receive `toToken`\n     */\n    event Shift(uint[] reserves, IERC20 toToken, uint minAmountOut, address recipient);\n\n    /**\n     * @notice Emitted when a Sync occurs.\n     * @param reserves The ending reserves after a sync\n     */\n    event Sync(uint[] reserves);\n\n    //////////////////// WELL DEFINITION ////////////////////\n\n    /**\n     * @notice Returns a list of ERC20 tokens supported by the Well.\n     */\n    function tokens() external view returns (IERC20[] memory);\n\n    /**\n     * @notice Returns the Well function as a Call struct.\n     * @dev Contains the address of the Well function contract and extra data to\n     * pass during calls.\n     *\n     * **Well functions** define a relationship between the reserves of the\n     * tokens in the Well and the number of LP tokens.\n     *\n     * A Well function MUST implement {IWellFunction}.\n     */\n    function wellFunction() external view returns (Call memory);\n\n    /**\n     * @notice Returns the Pumps attached to the Well as Call structs.\n     * @dev Contains the addresses of the Pumps contract and extra data to pass\n     * during calls.\n     *\n     * **Pumps** are on-chain oracles that are updated every time the Well is\n     * interacted with.\n     *\n     * A Pump is not required for Well operation. For Wells without a Pump:\n     * `pumps().length = 0`.\n     *\n     * An attached Pump MUST implement {IPump}.\n     */\n    function pumps() external view returns (Call[] memory);\n\n    /**\n     * @notice Returns the Well data that the Well was bored with.\n     * @dev The existence and signature of Well data is determined by each individual implementation.\n     */\n    function wellData() external view returns (bytes memory);\n\n    /**\n     * @notice Returns the Aquifer that created this Well.\n     * @dev Wells can be permissionlessly bored in an Aquifer.\n     *\n     * Aquifers stores the implementation that was used to bore the Well.\n     */\n    function aquifer() external view returns (address);\n\n    /**\n     * @notice Returns the tokens, Well function, Pump and Well Data associated with this Well.\n     */\n    function well()\n        external\n        view\n        returns (\n            IERC20[] memory _tokens,\n            Call memory _wellFunction,\n            Call[] memory _pumps,\n            bytes memory _wellData,\n            address aquifer\n        );\n\n    //////////////////// SWAP: FROM ////////////////////\n\n    /**\n     * @notice Swaps from an exact amount of `fromToken` to a minimum amount of `toToken`.\n     * @param fromToken The token to swap from\n     * @param toToken The token to swap to\n     * @param amountIn The amount of `fromToken` to spend\n     * @param minAmountOut The minimum amount of `toToken` to receive\n     * @param recipient The address to receive `toToken`\n     * @param deadline The timestamp after which this operation is invalid\n     * @return amountOut The amount of `toToken` received\n     */\n    function swapFrom(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint amountIn,\n        uint minAmountOut,\n        address recipient,\n        uint deadline\n    ) external returns (uint amountOut);\n\n    /**\n     * @notice Swaps from an exact amount of `fromToken` to a minimum amount of `toToken` and supports fee on transfer tokens.\n     * @param fromToken The token to swap from\n     * @param toToken The token to swap to\n     * @param amountIn The amount of `fromToken` to spend\n     * @param minAmountOut The minimum amount of `toToken` to take from the Well. Note that if `toToken` charges a fee on transfer, `recipient` will receive less than this amount.\n     * @param recipient The address to receive `toToken`\n     * @param deadline The timestamp after which this operation is invalid\n     * @return amountOut The amount of `toToken` transferred from the Well. Note that if `toToken` charges a fee on transfer, `recipient` may receive less than this amount.\n     * @dev Can also be used for tokens without a fee on transfer, but is less gas efficient.\n     */\n    function swapFromFeeOnTransfer(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint amountIn,\n        uint minAmountOut,\n        address recipient,\n        uint deadline\n    ) external returns (uint amountOut);\n\n    /**\n     * @notice Gets the amount of one token received for swapping an amount of another token.\n     * @param fromToken The token to swap from\n     * @param toToken The token to swap to\n     * @param amountIn The amount of `fromToken` to spend\n     * @return amountOut The amount of `toToken` to receive\n     */\n    function getSwapOut(IERC20 fromToken, IERC20 toToken, uint amountIn) external view returns (uint amountOut);\n\n    //////////////////// SWAP: TO ////////////////////\n\n    /**\n     * @notice Swaps from a maximum amount of `fromToken` to an exact amount of `toToken`.\n     * @param fromToken The token to swap from\n     * @param toToken The token to swap to\n     * @param maxAmountIn The maximum amount of `fromToken` to spend\n     * @param amountOut The amount of `toToken` to receive\n     * @param recipient The address to receive `toToken`\n     * @param deadline The timestamp after which this operation is invalid\n     * @return amountIn The amount of `toToken` received\n     */\n    function swapTo(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint maxAmountIn,\n        uint amountOut,\n        address recipient,\n        uint deadline\n    ) external returns (uint amountIn);\n\n    /**\n     * @notice Gets the amount of one token that must be spent to receive an amount of another token during a swap.\n     * @param fromToken The token to swap from\n     * @param toToken The token to swap to\n     * @param amountOut The amount of `toToken` desired\n     * @return amountIn The amount of `fromToken` that must be spent\n     */\n    function getSwapIn(IERC20 fromToken, IERC20 toToken, uint amountOut) external view returns (uint amountIn);\n\n    //////////////////// SHIFT ////////////////////\n\n    /**\n     * @notice Shifts excess tokens held by the Well into `tokenOut` and delivers to `recipient`.\n     * @param tokenOut The token to shift into\n     * @param minAmountOut The minimum amount of `tokenOut` to receive\n     * @param recipient The address to receive the token\n     * @return amountOut The amount of `tokenOut` received\n     * @dev Gas optimization: we leave the responsibility of checking a transaction\n     * deadline to a wrapper contract like {Pipeline} to prevent repeated deadline\n     * checks on each hop of a multi-step transaction.\n     */\n    function shift(IERC20 tokenOut, uint minAmountOut, address recipient) external returns (uint amountOut);\n\n    /**\n     * @notice Calculates the amount of the token out received from shifting excess tokens held by the Well.\n     * @param tokenOut The token to shift into\n     * @return amountOut The amount of `tokenOut` received\n     */\n    function getShiftOut(IERC20 tokenOut) external returns (uint amountOut);\n\n    //////////////////// ADD LIQUIDITY ////////////////////\n\n    /**\n     * @notice Adds liquidity to the Well as multiple tokens in any ratio.\n     * @param tokenAmountsIn The amount of each token to add; MUST match the indexing of {Well.tokens}\n     * @param minLpAmountOut The minimum amount of LP tokens to receive\n     * @param recipient The address to receive the LP tokens\n     * @param deadline The timestamp after which this operation is invalid\n     * @return lpAmountOut The amount of LP tokens received\n     */\n    function addLiquidity(\n        uint[] memory tokenAmountsIn,\n        uint minLpAmountOut,\n        address recipient,\n        uint deadline\n    ) external returns (uint lpAmountOut);\n\n    /**\n     * @notice Adds liquidity to the Well as multiple tokens in any ratio and supports\n     * fee on transfer tokens.\n     * @param tokenAmountsIn The amount of each token to add; MUST match the indexing of {Well.tokens}\n     * @param minLpAmountOut The minimum amount of LP tokens to receive\n     * @param recipient The address to receive the LP tokens\n     * @param deadline The timestamp after which this operation is invalid\n     * @return lpAmountOut The amount of LP tokens received\n     * @dev Can also be used for tokens without a fee on transfer, but is less gas efficient.\n     */\n    function addLiquidityFeeOnTransfer(\n        uint[] memory tokenAmountsIn,\n        uint minLpAmountOut,\n        address recipient,\n        uint deadline\n    ) external returns (uint lpAmountOut);\n\n    /**\n     * @notice Gets the amount of LP tokens received from adding liquidity as multiple tokens in any ratio.\n     * @param tokenAmountsIn The amount of each token to add; MUST match the indexing of {Well.tokens}\n     * @return lpAmountOut The amount of LP tokens to receive\n     */\n    function getAddLiquidityOut(uint[] memory tokenAmountsIn) external view returns (uint lpAmountOut);\n\n    //////////////////// REMOVE LIQUIDITY: BALANCED ////////////////////\n\n    /**\n     * @notice Removes liquidity from the Well as all underlying tokens in a balanced ratio.\n     * @param lpAmountIn The amount of LP tokens to burn\n     * @param minTokenAmountsOut The minimum amount of each underlying token to receive; MUST match the indexing of {Well.tokens}\n     * @param recipient The address to receive the underlying tokens\n     * @param deadline The timestamp after which this operation is invalid\n     * @return tokenAmountsOut The amount of each underlying token received\n     */\n    function removeLiquidity(\n        uint lpAmountIn,\n        uint[] calldata minTokenAmountsOut,\n        address recipient,\n        uint deadline\n    ) external returns (uint[] memory tokenAmountsOut);\n\n    /**\n     * @notice Gets the amount of each underlying token received from removing liquidity in a balanced ratio.\n     * @param lpAmountIn The amount of LP tokens to burn\n     * @return tokenAmountsOut The amount of each underlying token to receive\n     */\n    function getRemoveLiquidityOut(uint lpAmountIn) external view returns (uint[] memory tokenAmountsOut);\n\n    //////////////////// REMOVE LIQUIDITY: ONE TOKEN ////////////////////\n\n    /**\n     * @notice Removes liquidity from the Well as a single underlying token.\n     * @param lpAmountIn The amount of LP tokens to burn\n     * @param tokenOut The underlying token to receive\n     * @param minTokenAmountOut The minimum amount of `tokenOut` to receive\n     * @param recipient The address to receive the underlying tokens\n     * @param deadline The timestamp after which this operation is invalid\n     * @return tokenAmountOut The amount of `tokenOut` received\n     */\n    function removeLiquidityOneToken(\n        uint lpAmountIn,\n        IERC20 tokenOut,\n        uint minTokenAmountOut,\n        address recipient,\n        uint deadline\n    ) external returns (uint tokenAmountOut);\n\n    /**\n     * @notice Gets the amount received from removing liquidity from the Well as a single underlying token.\n     * @param lpAmountIn The amount of LP tokens to burn\n     * @param tokenOut The underlying token to receive\n     * @return tokenAmountOut The amount of `tokenOut` to receive\n     *\n     * FIXME: ordering\n     */\n    function getRemoveLiquidityOneTokenOut(\n        uint lpAmountIn,\n        IERC20 tokenOut\n    ) external view returns (uint tokenAmountOut);\n\n    //////////////////// REMOVE LIQUIDITY: IMBALANCED ////////////////////\n\n    /**\n     * @notice Removes liquidity from the Well as multiple underlying tokens in any ratio.\n     * @param maxLpAmountIn The maximum amount of LP tokens to burn\n     * @param tokenAmountsOut The amount of each underlying token to receive; MUST match the indexing of {Well.tokens}\n     * @param recipient The address to receive the underlying tokens\n     * @return lpAmountIn The amount of LP tokens burned\n     */\n    function removeLiquidityImbalanced(\n        uint maxLpAmountIn,\n        uint[] calldata tokenAmountsOut,\n        address recipient,\n        uint deadline\n    ) external returns (uint lpAmountIn);\n\n    /**\n     * @notice Gets the amount of LP tokens to burn from removing liquidity as multiple underlying tokens in any ratio.\n     * @param tokenAmountsOut The amount of each underlying token to receive; MUST match the indexing of {Well.tokens}\n     * @return lpAmountIn The amount of LP tokens to burn\n     */\n    function getRemoveLiquidityImbalancedIn(uint[] calldata tokenAmountsOut) external view returns (uint lpAmountIn);\n\n    //////////////////// RESERVES ////////////////////\n\n    /**\n     * @notice Syncs the reserves of the Well with the Well's balances of underlying tokens.\n     */\n    function sync() external;\n\n    /**\n     * @notice Sends excess tokens held by the Well to the `recipient`.\n     * @param recipient The address to send the tokens\n     * @return skimAmounts The amount of each token skimmed\n     */\n    function skim(address recipient) external returns (uint[] memory skimAmounts);\n\n    /**\n     * @notice Gets the reserves of each token held by the Well.\n     */\n    function getReserves() external view returns (uint[] memory reserves);\n}"
    }
  ]
}