{
  "Title": "Chainlink `min&max` price is not checked",
  "Content": "##### Description\n\n- https://github.com/ConicFinance/protocol/blob/7a66d26ef84f93059a811a189655e17c11d95f5c/contracts/oracles/ChainlinkOracle.sol#L68\n\nSome chainlink aggregators have min and max price. The price of an asset cannot go outside the range of min and max price. \n\n- https://docs.chain.link/data-feeds#check-the-latest-answer-against-reasonable-limits\n\n`When the reported answer is close to reaching reasonable minimum and maximum limits ... it can alert you to potential market events.`\n\n##### Recommendation\n\nAccording to Chainlink's recommendation:\n`Configure your application to detect and respond to extreme price volatility or prices that are outside of your acceptable limits.`\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/oracles/ChainlinkOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@chainlink/contracts/Denominations.sol\";\nimport \"@chainlink/contracts/interfaces/FeedRegistryInterface.sol\";\n\nimport \"../../interfaces/IOracle.sol\";\n\ninterface IAggregatorV3Interface {\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n\n    /// @notice `getRoundData` and `latestRoundData` should both raise \"No data present\"\n    /// if they do not have data to report, instead of returning unset values\n    /// which could be misinterpreted as actual reported values.\n    function getRoundData(\n        uint80 _roundId\n    )\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n\ncontract ChainlinkOracle is IOracle {\n    FeedRegistryInterface internal constant _feedRegistry =\n        FeedRegistryInterface(0x47Fb2585D2C56Fe188D0E6ec628a38b74fCeeeDf);\n    address internal constant _WETH = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    address internal constant _CURVE_ETH = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n    function isTokenSupported(address token) external view override returns (bool) {\n        if (_isEth(token)) return true;\n        try _feedRegistry.getFeed(token, Denominations.ETH) returns (AggregatorV2V3Interface) {\n            return true;\n        } catch Error(string memory) {\n            try _feedRegistry.getFeed(token, Denominations.USD) returns (AggregatorV2V3Interface) {\n                return true;\n            } catch Error(string memory) {\n                return false;\n            }\n        }\n    }\n\n    // Prices are always provided with 18 decimals pecision\n    function getUSDPrice(address token) external view returns (uint256) {\n        return _getPrice(token, Denominations.USD, false);\n    }\n\n    function _getPrice(\n        address token,\n        address denomination,\n        bool shouldRevert\n    ) internal view returns (uint256) {\n        if (_isEth(token)) token = Denominations.ETH;\n        try _feedRegistry.latestRoundData(token, denomination) returns (\n            uint80 roundID_,\n            int256 price_,\n            uint256,\n            uint256 timeStamp_,\n            uint80 answeredInRound_\n        ) {\n            require(timeStamp_ != 0, \"round not complete\");\n            require(price_ != 0, \"negative price\");\n            require(answeredInRound_ >= roundID_, \"stale price\");\n            return _scaleFrom(uint256(price_), _feedRegistry.decimals(token, denomination));\n        } catch Error(string memory reason) {\n            if (shouldRevert) revert(reason);\n\n            if (denomination == Denominations.USD) {\n                return\n                    (_getPrice(token, Denominations.ETH, true) *\n                        _getPrice(Denominations.ETH, Denominations.USD, true)) / 1e18;\n            }\n            return\n                (_getPrice(token, Denominations.USD, true) * 1e18) /\n                _getPrice(Denominations.ETH, Denominations.USD, true);\n        }\n    }\n\n    function _scaleFrom(uint256 value, uint8 decimals) internal pure returns (uint256) {\n        if (decimals == 18) return value;\n        if (decimals > 18) return value / 10 ** (decimals - 18);\n        else return value * 10 ** (18 - decimals);\n    }\n\n    function _isEth(address token) internal pure returns (bool) {\n        return token == address(0) || token == _WETH || token == _CURVE_ETH;\n    }\n}"
    }
  ]
}