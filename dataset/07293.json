{
  "Title": "[12] Compromised owner is capable of draining all user's fund after user gives token allowance to TransferProxy.sol",
  "Content": "\nThe TransferProxy.sol is important because it helps with moving the fund around in AuctionHouse, AstariaRouter and in LienToken.\n\nAs we can see, this function below is powerful. It is likely that user will give the max token allowance to the contract TransferProxy, otherwise, transaction would revert in AuctionHouse.sol, LienToken and in AuctionHouse.\n\n```solidity\n  function tokenTransferFrom(\n    address token,\n    address from,\n    address to,\n    uint256 amount\n  ) external requiresAuth {\n    ERC20(token).safeTransferFrom(from, to, amount);\n  }\n```\n\nWell, note that the requiresAuth modifier is used in the function tokenTransferFrom, this access control model means that only specific address set up by admin can call this function.\n\nIf the admin is compromised, the admin can authorize malicious contract that can drain all the token fund from user by calling the above tokenTransferFrom after user gives token allowance to TransferProxy.sol\n\nBecause the requiresAuth modifier calls:\n\n```solidity\nmodifier requiresAuth() virtual {\nrequire(isAuthorized(msg.sender, msg.sig), \"UNAUTHORIZED\");\n\n_;\n}\n```\n\nwhich calls:\n\n```solidity\n  function isAuthorized(address user, bytes4 functionSig)\n    internal\n    view\n    virtual\n    returns (bool)\n  {\n    AuthStorage storage s = _getAuthSlot();\n    Authority auth = s.authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\n\n    // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\n    // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\n    return\n      (address(auth) != address(0) &&\n        auth.canCall(user, address(this), functionSig)) || user == s.owner;\n  }\n```\n\nThe auth.canCall is called in MultiRolesAuthority.sol, as shown in the Deploy.sol script\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/scripts/deployments/Deploy.sol#L118\n\n```solidity\naddress auth = testModeDisabled ? msg.sender : address(this);\nMRA = new MultiRolesAuthority(auth, Authority(address(0)));\n```\n\nAnd the relevent authorization is granted by calling:\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/scripts/deployments/Deploy.sol#L377\n\n```solidity\nMRA.setRoleCapability(\n  uint8(UserRoles.ASTARIA_ROUTER),\n  TRANSFER_PROXY.tokenTransferFrom.selector,\n  true\n);\n```\n\nand\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/scripts/deployments/Deploy.sol#L410\n\n```solidity\nMRA.setUserRole(\n  address(ASTARIA_ROUTER),\n  uint8(UserRoles.ASTARIA_ROUTER),\n  true\n);\n```\n\nby calling:\n\n```solidity\nfunction setRoleCapability(\n\tuint8 role,\n\tbytes4 functionSig,\n\tbool enabled\n) public virtual requiresAuth {\n\tif (enabled) {\n\t\tgetRolesWithCapability[functionSig] |= bytes32(1 << role);\n\t} else {\n\t\tgetRolesWithCapability[functionSig] &= ~bytes32(1 << role);\n\t}\n\n\temit RoleCapabilityUpdated(role, functionSig, enabled);\n}\n```\n\nA compromised admin can call:\n\n```solidity\nMRA.setRoleCapability(\n  uint8(UserRoles.MALICIOUS),\n  TRANSFER_PROXY.tokenTransferFrom.selector,\n  true\n);\n```\n\nand\n\n```solidity\nMRA.setUserRole(\n  address(malicious_contract_or_account),\n  uint8(UserRoles.MALICIOUS),\n  true\n);\n```\n\nThen the malicious\\_contract\\_or\\_account address has permission to call tokenTransferFrom, which drains user token after user gives token allowance to TransferProxy.sol. All he needs to do is set the token to token that he wants to transfer and steal, the address from is victim's address, the address to is the recipient (hacker's address), the amount is how much he wants to transfer and drain.\n\n```solidity\nfunction tokenTransferFrom(\naddress token,\naddress from,\naddress to,\nuint256 amount\n) external requiresAuth {\n\tERC20(token).safeTransferFrom(from, to, amount);\n}\n```\n\nThe reference (relevant )code for MultiRolesAuthority in solmate:\n\nhttps://github.com/transmissions11/solmate/blob/main/src/test/MultiRolesAuthority.t.sol\n\n### Recommended Mitigation Steps\n\nOnly use safeIncreaseAllowance to give minimum approval to move the fund around, use multisig to safeguard to admin.\n\n**[SantiagoGregory (Astaria) disputed and commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/76#issuecomment-1412961381):**\n > **[02] New Protocol parameter setting should not be applied to old loan term and state, especially the fee setting**<br>\n> @androolloyd - Don't think this is worth the storage costs and can't be used maliciously (as far as I can tell).\n\n**[androolloyd (Astaria) disputed and commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/70#issuecomment-1413611159):**\n > **[03] Adversary can game the flashAuction feature to block further flashAuction after trading collateral token and make liquidatorNFTClaim function revert and block liquidation if the NFT is Moonbird**<br>\n> In the case of moonbirds, but also applying to all nfts that would be flash enabled, there is a security hooks mechanism that lets us query the state of the underlying asset, we would have to write and deploy a security hook for the moon bird contract that would check the nesting status, we would then prohibit the transaction because the state of the nft is changed.\n>\n> The security hook can fetch any data about an nft from calls and then compare them after the nft has been returned.\n\n**[SantiagoGregory (Astaria) disputed and commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/50#issuecomment-1412898631):**\n > **[04] If an auction has no bidder, the NFT ownership should go back to the loan lenders instead of liquidator**<br>\n> LPs implicitly take the risk of auctions resulting in very low or no bids. Auctions are a way to distribute liquidation results equitably to LPs, and if there are no bids, then there is no way to distribute that value.\n\n**[SantiagoGregory (Astaria) disagreed with severity and commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/101#issuecomment-1412958485):**\n > **[08] Transaction revert in division by zero error when handling protocol fee if the feeTo address is set but `s.protocolFeeDenominator` is not set**<br>\n> Low severity because this would be configured before the fee switch was turned on.\n\n**[androolloyd (Astaria) commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/83#issuecomment-1413615500):**\n > **[09] Should use _safeMint instead of mint in CollateralToken#onERC721Received**<br>\n> Acknowledged.\n\n**[SantiagoGregory (Astaria) commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/78#issuecomment-1412959654):**\n > **[10] Adversary can front-run admin's state update and parameter update**<br>\n> Acknowledged. Not really an issue IMO.\n\n**[androolloyd (Astaria) commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/52#issuecomment-1413618912):**\n > **[12] Compromised owner is capable of draining all user's fund after user gives token allowance to TransferProxy.sol**<br>\n> Acknowledged.\n\n**Picodes (judge) commented:**\n > **[[02] New Protocol parameter setting should not be applied to old loan term and state, especially the fee setting](https://github.com/code-423n4/2023-01-astaria-findings/issues/76#issuecomment-1436097227)**<br>\n> Downgrading to low as it's an interesting suggestion but isn't of medium severity\n> \n > **[[03] Adversary can game the flashAuction feature to block further flashAuction after trading collateral token and make liquidatorNFTClaim function revert and block liquidation if the NFT is Moonbird](https://github.com/code-423n4/2023-01-astaria-findings/issues/70#issuecomment-1441360783)**<br>\n> This is a remarkable and very creative finding. But considering this is specific to MoonBird's behavior and that Astaria has a `securityHook` for this kind of case, downgrading to low.\n> \n> **[[05] Security hook should not be set for a NFT that is not Uniswap V3 Position NFT](https://github.com/code-423n4/2023-01-astaria-findings/issues/109#issuecomment-1405562237)**<br>\n> Low severity as this is a configuration error, easily fixable by the admins.\n>\n > **[[08] Transaction revert in division by zero error when handling protocol fee if the feeTo address is set but `s.protocolFeeDenominator` is not set](https://github.com/code-423n4/2023-01-astaria-findings/issues/101#issuecomment-1441350707)**<br>\n> Downgrading to low as this is a configuration mistake by the admin.\n>\n > **[[09] Should use _safeMint instead of mint in CollateralToken#onERC721Received](https://github.com/code-423n4/2023-01-astaria-findings/issues/83#issuecomment-1436096534)**<br>\n> Downgrading to low as it's more a safety check than anything else here.\n>\n > **[[10] Adversary can front-run admin's state update and parameter update](https://github.com/code-423n4/2023-01-astaria-findings/issues/78#issuecomment-1436096842)**<br>\n> QA at best given that there is no real exploit scenario and it can be mitigated with private rpcs.\n>\n > **[[12] Compromised owner is capable of draining all user's fund after user gives token allowance to TransferProxy.sol](https://github.com/code-423n4/2023-01-astaria-findings/issues/52#issuecomment-1447965536)**<br>\n> After [this discussion](https://github.com/code-423n4/2023-01-astaria-findings/issues/617), I will downgrade this issue to Low severity, as I finally don't think we can consider this a case of \"privilege escalation\" versus changing the transfer proxy address for example. It boils down to Admin Privilege which is OOS per the automated report.\n\n\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-01-astaria",
  "Code": [
    {
      "filename": "src/scripts/deployments/Deploy.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**\n *  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗\n * ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n * ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n * ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n * ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n * ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n *\n * Astaria Labs, Inc\n */\n\npragma solidity =0.8.17;\n\nimport {Script} from \"forge-std/Script.sol\";\n\nimport {Authority} from \"solmate/auth/Auth.sol\";\nimport {\n  MultiRolesAuthority\n} from \"solmate/auth/authorities/MultiRolesAuthority.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {WETH} from \"solmate/tokens/WETH.sol\";\nimport {ERC721} from \"gpl/ERC721.sol\";\nimport {ITransferProxy} from \"core/interfaces/ITransferProxy.sol\";\nimport {IERC20} from \"core/interfaces/IERC20.sol\";\n\nimport {CollateralToken} from \"core/CollateralToken.sol\";\nimport {LienToken} from \"core/LienToken.sol\";\nimport {AstariaRouter} from \"core/AstariaRouter.sol\";\nimport {Vault} from \"core/Vault.sol\";\nimport {PublicVault} from \"core/PublicVault.sol\";\nimport {TransferProxy} from \"core/TransferProxy.sol\";\nimport {ICollateralToken} from \"core/interfaces/ICollateralToken.sol\";\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\nimport {WithdrawProxy} from \"core/WithdrawProxy.sol\";\nimport {BeaconProxy} from \"core/BeaconProxy.sol\";\nimport {ClearingHouse} from \"core/ClearingHouse.sol\";\nimport {\n  ConsiderationInterface\n} from \"seaport/interfaces/ConsiderationInterface.sol\";\nimport {\n  TransparentUpgradeableProxy\n} from \"lib/seaport/lib/openzeppelin-contracts/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport {\n  ProxyAdmin\n} from \"lib/seaport/lib/openzeppelin-contracts/contracts/proxy/transparent/ProxyAdmin.sol\";\nimport {\n  Initializable\n} from \"lib/seaport/lib/openzeppelin-contracts/contracts/proxy/utils/Initializable.sol\";\n\ncontract Deploy is Script {\n  enum UserRoles {\n    ADMIN,\n    ASTARIA_ROUTER,\n    WRAPPER,\n    TRANSFER_PROXY,\n    LIEN_TOKEN\n  }\n\n  event Deployed(address);\n\n  CollateralToken COLLATERAL_TOKEN;\n  LienToken LIEN_TOKEN;\n  AstariaRouter ASTARIA_ROUTER;\n  PublicVault PUBLIC_VAULT_IMPLEMENTATION;\n  WithdrawProxy WITHDRAW_PROXY;\n  Vault SOLO_IMPLEMENTATION;\n  TransferProxy TRANSFER_PROXY;\n  WETH WETH9;\n  MultiRolesAuthority MRA;\n  ConsiderationInterface SEAPORT;\n  ProxyAdmin PROXY_ADMIN;\n\n  bool testModeDisabled = true;\n\n  function run() public virtual {\n    deploy();\n  }\n\n  function deploy() public virtual {\n    if (testModeDisabled) {\n      vm.startBroadcast(msg.sender);\n    }\n\n    address weth;\n\n    try vm.envAddress(\"WETH9_ADDR\") {\n      weth = vm.envAddress(\"WETH9_ADDR\");\n    } catch {}\n    if (address(SEAPORT) == address(0)) {\n      try vm.envAddress(\"SEAPORT_ADDR\") {\n        SEAPORT = ConsiderationInterface(vm.envAddress(\"SEAPORT_ADDR\"));\n      } catch {\n        revert(\"SEAPORT_ADDR not found\");\n      }\n    }\n\n    if (weth == address(0)) {\n      WETH9 = new WETH();\n      if (testModeDisabled) {\n        vm.writeLine(\n          string(\".env\"),\n          string(abi.encodePacked(\"WETH9_ADDR=\", vm.toString(address(WETH9))))\n        );\n      }\n    } else {\n      WETH9 = WETH(payable(weth)); // mainnet weth\n      if (testModeDisabled) {\n        vm.writeLine(\n          string(\".env\"),\n          string(abi.encodePacked(\"WETH9_ADDR=\", vm.toString(address(WETH9))))\n        );\n      }\n    }\n    address auth = testModeDisabled ? msg.sender : address(this);\n    MRA = new MultiRolesAuthority(auth, Authority(address(0)));\n    if (testModeDisabled) {\n      vm.writeLine(\n        string(\".env\"),\n        string(abi.encodePacked(\"MRA_ADDR=\", vm.toString(address(MRA))))\n      );\n    }\n\n    TRANSFER_PROXY = new TransferProxy(MRA);\n    if (testModeDisabled) {\n      //      vm.setEnv(\"TRANSFER_PROXY_ADDR\", address(TRANSFER_PROXY));\n      vm.writeLine(\n        string(\".env\"),\n        string(\n          abi.encodePacked(\n            \"TRANSFER_PROXY_ADDR=\",\n            vm.toString(address(TRANSFER_PROXY))\n          )\n        )\n      );\n    }\n\n    PROXY_ADMIN = new ProxyAdmin();\n    if (testModeDisabled) {\n      vm.writeLine(\n        string(\".env\"),\n        string(\n          abi.encodePacked(\n            \"PROXY_ADMIN_ADDR=\",\n            vm.toString(address(PROXY_ADMIN))\n          )\n        )\n      );\n    }\n\n    LienToken LT_IMPL = new LienToken();\n\n    if (testModeDisabled) {\n      vm.writeLine(\n        string(\".env\"),\n        string(\n          abi.encodePacked(\n            \"LIEN_TOKEN_IMPL_ADDR=\",\n            vm.toString(address(LT_IMPL))\n          )\n        )\n      );\n    }\n    // LienToken proxy deployment/setup\n    TransparentUpgradeableProxy lienTokenProxy = new TransparentUpgradeableProxy(\n        address(LT_IMPL),\n        address(PROXY_ADMIN),\n        abi.encodeWithSelector(\n          LIEN_TOKEN.initialize.selector,\n          MRA,\n          TRANSFER_PROXY\n        )\n      );\n    LIEN_TOKEN = LienToken(address(lienTokenProxy));\n    if (testModeDisabled) {\n      //      vm.setEnv(\"TRANSPARENT_UPGRADEABLE_PROXY_ADDR\", address(transparentUpgradeableProxy));\n      vm.writeLine(\n        string(\".env\"),\n        string(\n          abi.encodePacked(\n            \"LIEN_TOKEN_PROXY_ADDR=\",\n            vm.toString(address(lienTokenProxy))\n          )\n        )\n      );\n    }\n    ClearingHouse CLEARING_HOUSE_IMPL = new ClearingHouse();\n\n    if (testModeDisabled) {\n      //      vm.setEnv(\"CLEARING_HOUSE_IMPL_ADDR\", address(CLEARING_HOUSE_IMPL));\n      vm.writeLine(\n        string(\".env\"),\n        string(\n          abi.encodePacked(\n            \"CLEARING_HOUSE_IMPL_ADDR=\",\n            vm.toString(address(CLEARING_HOUSE_IMPL))\n          )\n        )\n      );\n    }\n\n    CollateralToken CT_IMPL = new CollateralToken();\n\n    if (testModeDisabled) {\n      //      vm.setEnv(\"COLLATERAL_TOKEN_ADDR\", address(COLLATERAL_TOKEN));\n      vm.writeLine(\n        string(\".env\"),\n        string(\n          abi.encodePacked(\n            \"COLLATERAL_TOKEN_IMPL_ADDR=\",\n            vm.toString(address(CT_IMPL))\n          )\n        )\n      );\n    }\n    {\n      TransparentUpgradeableProxy collateralTokenProxy = new TransparentUpgradeableProxy(\n          address(CT_IMPL),\n          address(PROXY_ADMIN),\n          abi.encodeWithSelector(\n            COLLATERAL_TOKEN.initialize.selector,\n            MRA,\n            TRANSFER_PROXY,\n            ILienToken(address(LIEN_TOKEN)),\n            ConsiderationInterface(SEAPORT)\n          )\n        );\n      COLLATERAL_TOKEN = CollateralToken(address(collateralTokenProxy));\n      assert(COLLATERAL_TOKEN.owner() == auth);\n      if (testModeDisabled) {\n        //      vm.setEnv(\"TRANSPARENT_UPGRADEABLE_PROXY_ADDR\", address(transparentUpgradeableProxy));\n        vm.writeLine(\n          string(\".env\"),\n          string(\n            abi.encodePacked(\n              \"COLLATERAL_TOKEN_PROXY_ADDR=\",\n              vm.toString(address(collateralTokenProxy))\n            )\n          )\n        );\n      }\n    }\n\n    SOLO_IMPLEMENTATION = new Vault();\n    if (testModeDisabled) {\n      vm.writeLine(\n        string(\".env\"),\n        string(\n          abi.encodePacked(\n            \"SOLO_IMPLEMENTATION_ADDR=\",\n            vm.toString(address(SOLO_IMPLEMENTATION))\n          )\n        )\n      );\n    }\n    PUBLIC_VAULT_IMPLEMENTATION = new PublicVault();\n    if (testModeDisabled) {\n      vm.writeLine(\n        string(\".env\"),\n        string(\n          abi.encodePacked(\n            \"PUBLIC_VAULT_IMPLEMENTATION_ADDR=\",\n            vm.toString(address(PUBLIC_VAULT_IMPLEMENTATION))\n          )\n        )\n      );\n    }\n    WITHDRAW_PROXY = new WithdrawProxy();\n    if (testModeDisabled) {\n      vm.writeLine(\n        string(\".env\"),\n        string(\n          abi.encodePacked(\n            \"WITHDRAW_PROXY_ADDR=\",\n            vm.toString(address(WITHDRAW_PROXY))\n          )\n        )\n      );\n    }\n    BeaconProxy BEACON_PROXY = new BeaconProxy();\n    if (testModeDisabled) {\n      vm.writeLine(\n        string(\".env\"),\n        string(\n          abi.encodePacked(\n            \"BEACON_PROXY_ADDR=\",\n            vm.toString(address(BEACON_PROXY))\n          )\n        )\n      );\n    }\n\n    {\n      AstariaRouter AR_IMPL = new AstariaRouter();\n      if (testModeDisabled) {\n        vm.writeLine(\n          string(\".env\"),\n          string(\n            abi.encodePacked(\n              \"ASTARIA_ROUTER_IMPL_ADDR=\",\n              vm.toString(address(AR_IMPL))\n            )\n          )\n        );\n      }\n\n      TransparentUpgradeableProxy astariaRouterProxy = new TransparentUpgradeableProxy(\n          address(AR_IMPL),\n          address(PROXY_ADMIN),\n          abi.encodeWithSelector(\n            AstariaRouter.initialize.selector,\n            MRA,\n            ICollateralToken(address(COLLATERAL_TOKEN)),\n            ILienToken(address(LIEN_TOKEN)),\n            ITransferProxy(address(TRANSFER_PROXY)),\n            address(PUBLIC_VAULT_IMPLEMENTATION),\n            address(SOLO_IMPLEMENTATION),\n            address(WITHDRAW_PROXY),\n            address(BEACON_PROXY),\n            address(CLEARING_HOUSE_IMPL)\n          )\n        );\n      ASTARIA_ROUTER = AstariaRouter(address(astariaRouterProxy));\n\n      if (testModeDisabled) {\n        vm.writeLine(\n          string(\".env\"),\n          string(\n            abi.encodePacked(\n              \"ASTARIA_ROUTER_PROXY_ADDR=\",\n              vm.toString(address(astariaRouterProxy))\n            )\n          )\n        );\n      }\n    }\n    {\n      ICollateralToken.File[] memory ctfiles = new ICollateralToken.File[](1);\n\n      ctfiles[0] = ICollateralToken.File({\n        what: ICollateralToken.FileType.AstariaRouter,\n        data: abi.encode(address(ASTARIA_ROUTER))\n      });\n      COLLATERAL_TOKEN.fileBatch(ctfiles);\n    }\n    _setupRolesAndCapabilities();\n\n    LIEN_TOKEN.file(\n      ILienToken.File(\n        ILienToken.FileType.CollateralToken,\n        abi.encode(address(COLLATERAL_TOKEN))\n      )\n    );\n    LIEN_TOKEN.file(\n      ILienToken.File(\n        ILienToken.FileType.AstariaRouter,\n        abi.encode(address(ASTARIA_ROUTER))\n      )\n    );\n    if (testModeDisabled) {\n      vm.stopBroadcast();\n    } else {\n      //      _setOwner();\n    }\n  }\n\n  function _setupRolesAndCapabilities() internal {\n    // ROUTER CAPABILITIES\n\n    MRA.setRoleCapability(\n      uint8(UserRoles.ASTARIA_ROUTER),\n      LienToken.createLien.selector,\n      true\n    );\n    MRA.setRoleCapability(\n      uint8(UserRoles.ASTARIA_ROUTER),\n      TRANSFER_PROXY.tokenTransferFrom.selector,\n      true\n    );\n\n    MRA.setRoleCapability(\n      uint8(UserRoles.ASTARIA_ROUTER),\n      CollateralToken.auctionVault.selector,\n      true\n    );\n\n    // LIEN TOKEN CAPABILITIES\n    MRA.setRoleCapability(\n      uint8(UserRoles.ASTARIA_ROUTER),\n      LienToken.stopLiens.selector,\n      true\n    );\n\n    MRA.setRoleCapability(\n      uint8(UserRoles.LIEN_TOKEN),\n      CollateralToken.settleAuction.selector,\n      true\n    );\n\n    MRA.setRoleCapability(\n      uint8(UserRoles.LIEN_TOKEN),\n      TRANSFER_PROXY.tokenTransferFrom.selector,\n      true\n    );\n\n    // SEAPORT CAPABILITIES\n\n    MRA.setUserRole(\n      address(ASTARIA_ROUTER),\n      uint8(UserRoles.ASTARIA_ROUTER),\n      true\n    );\n    MRA.setUserRole(address(COLLATERAL_TOKEN), uint8(UserRoles.WRAPPER), true);\n    MRA.setUserRole(address(LIEN_TOKEN), uint8(UserRoles.LIEN_TOKEN), true);\n  }\n\n  function _setOwner() internal {\n    MRA.transferOwnership(msg.sender);\n    ASTARIA_ROUTER.transferOwnership(msg.sender);\n    LIEN_TOKEN.transferOwnership(msg.sender);\n    COLLATERAL_TOKEN.transferOwnership(msg.sender);\n  }\n}"
    },
    {
      "filename": "src/scripts/deployments/Deploy.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**\n *  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗\n * ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n * ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n * ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n * ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n * ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n *\n * Astaria Labs, Inc\n */\n\npragma solidity =0.8.17;\n\nimport {Script} from \"forge-std/Script.sol\";\n\nimport {Authority} from \"solmate/auth/Auth.sol\";\nimport {\n  MultiRolesAuthority\n} from \"solmate/auth/authorities/MultiRolesAuthority.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {WETH} from \"solmate/tokens/WETH.sol\";\nimport {ERC721} from \"gpl/ERC721.sol\";\nimport {ITransferProxy} from \"core/interfaces/ITransferProxy.sol\";\nimport {IERC20} from \"core/interfaces/IERC20.sol\";\n\nimport {CollateralToken} from \"core/CollateralToken.sol\";\nimport {LienToken} from \"core/LienToken.sol\";\nimport {AstariaRouter} from \"core/AstariaRouter.sol\";\nimport {Vault} from \"core/Vault.sol\";\nimport {PublicVault} from \"core/PublicVault.sol\";\nimport {TransferProxy} from \"core/TransferProxy.sol\";\nimport {ICollateralToken} from \"core/interfaces/ICollateralToken.sol\";\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\nimport {WithdrawProxy} from \"core/WithdrawProxy.sol\";\nimport {BeaconProxy} from \"core/BeaconProxy.sol\";\nimport {ClearingHouse} from \"core/ClearingHouse.sol\";\nimport {\n  ConsiderationInterface\n} from \"seaport/interfaces/ConsiderationInterface.sol\";\nimport {\n  TransparentUpgradeableProxy\n} from \"lib/seaport/lib/openzeppelin-contracts/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport {\n  ProxyAdmin\n} from \"lib/seaport/lib/openzeppelin-contracts/contracts/proxy/transparent/ProxyAdmin.sol\";\nimport {\n  Initializable\n} from \"lib/seaport/lib/openzeppelin-contracts/contracts/proxy/utils/Initializable.sol\";\n\ncontract Deploy is Script {\n  enum UserRoles {\n    ADMIN,\n    ASTARIA_ROUTER,\n    WRAPPER,\n    TRANSFER_PROXY,\n    LIEN_TOKEN\n  }\n\n  event Deployed(address);\n\n  CollateralToken COLLATERAL_TOKEN;\n  LienToken LIEN_TOKEN;\n  AstariaRouter ASTARIA_ROUTER;\n  PublicVault PUBLIC_VAULT_IMPLEMENTATION;\n  WithdrawProxy WITHDRAW_PROXY;\n  Vault SOLO_IMPLEMENTATION;\n  TransferProxy TRANSFER_PROXY;\n  WETH WETH9;\n  MultiRolesAuthority MRA;\n  ConsiderationInterface SEAPORT;\n  ProxyAdmin PROXY_ADMIN;\n\n  bool testModeDisabled = true;\n\n  function run() public virtual {\n    deploy();\n  }\n\n  function deploy() public virtual {\n    if (testModeDisabled) {\n      vm.startBroadcast(msg.sender);\n    }\n\n    address weth;\n\n    try vm.envAddress(\"WETH9_ADDR\") {\n      weth = vm.envAddress(\"WETH9_ADDR\");\n    } catch {}\n    if (address(SEAPORT) == address(0)) {\n      try vm.envAddress(\"SEAPORT_ADDR\") {\n        SEAPORT = ConsiderationInterface(vm.envAddress(\"SEAPORT_ADDR\"));\n      } catch {\n        revert(\"SEAPORT_ADDR not found\");\n      }\n    }\n\n    if (weth == address(0)) {\n      WETH9 = new WETH();\n      if (testModeDisabled) {\n        vm.writeLine(\n          string(\".env\"),\n          string(abi.encodePacked(\"WETH9_ADDR=\", vm.toString(address(WETH9))))\n        );\n      }\n    } else {\n      WETH9 = WETH(payable(weth)); // mainnet weth\n      if (testModeDisabled) {\n        vm.writeLine(\n          string(\".env\"),\n          string(abi.encodePacked(\"WETH9_ADDR=\", vm.toString(address(WETH9))))\n        );\n      }\n    }\n    address auth = testModeDisabled ? msg.sender : address(this);\n    MRA = new MultiRolesAuthority(auth, Authority(address(0)));\n    if (testModeDisabled) {\n      vm.writeLine(\n        string(\".env\"),\n        string(abi.encodePacked(\"MRA_ADDR=\", vm.toString(address(MRA))))\n      );\n    }\n\n    TRANSFER_PROXY = new TransferProxy(MRA);\n    if (testModeDisabled) {\n      //      vm.setEnv(\"TRANSFER_PROXY_ADDR\", address(TRANSFER_PROXY));\n      vm.writeLine(\n        string(\".env\"),\n        string(\n          abi.encodePacked(\n            \"TRANSFER_PROXY_ADDR=\",\n            vm.toString(address(TRANSFER_PROXY))\n          )\n        )\n      );\n    }\n\n    PROXY_ADMIN = new ProxyAdmin();\n    if (testModeDisabled) {\n      vm.writeLine(\n        string(\".env\"),\n        string(\n          abi.encodePacked(\n            \"PROXY_ADMIN_ADDR=\",\n            vm.toString(address(PROXY_ADMIN))\n          )\n        )\n      );\n    }\n\n    LienToken LT_IMPL = new LienToken();\n\n    if (testModeDisabled) {\n      vm.writeLine(\n        string(\".env\"),\n        string(\n          abi.encodePacked(\n            \"LIEN_TOKEN_IMPL_ADDR=\",\n            vm.toString(address(LT_IMPL))\n          )\n        )\n      );\n    }\n    // LienToken proxy deployment/setup\n    TransparentUpgradeableProxy lienTokenProxy = new TransparentUpgradeableProxy(\n        address(LT_IMPL),\n        address(PROXY_ADMIN),\n        abi.encodeWithSelector(\n          LIEN_TOKEN.initialize.selector,\n          MRA,\n          TRANSFER_PROXY\n        )\n      );\n    LIEN_TOKEN = LienToken(address(lienTokenProxy));\n    if (testModeDisabled) {\n      //      vm.setEnv(\"TRANSPARENT_UPGRADEABLE_PROXY_ADDR\", address(transparentUpgradeableProxy));\n      vm.writeLine(\n        string(\".env\"),\n        string(\n          abi.encodePacked(\n            \"LIEN_TOKEN_PROXY_ADDR=\",\n            vm.toString(address(lienTokenProxy))\n          )\n        )\n      );\n    }\n    ClearingHouse CLEARING_HOUSE_IMPL = new ClearingHouse();\n\n    if (testModeDisabled) {\n      //      vm.setEnv(\"CLEARING_HOUSE_IMPL_ADDR\", address(CLEARING_HOUSE_IMPL));\n      vm.writeLine(\n        string(\".env\"),\n        string(\n          abi.encodePacked(\n            \"CLEARING_HOUSE_IMPL_ADDR=\",\n            vm.toString(address(CLEARING_HOUSE_IMPL))\n          )\n        )\n      );\n    }\n\n    CollateralToken CT_IMPL = new CollateralToken();\n\n    if (testModeDisabled) {\n      //      vm.setEnv(\"COLLATERAL_TOKEN_ADDR\", address(COLLATERAL_TOKEN));\n      vm.writeLine(\n        string(\".env\"),\n        string(\n          abi.encodePacked(\n            \"COLLATERAL_TOKEN_IMPL_ADDR=\",\n            vm.toString(address(CT_IMPL))\n          )\n        )\n      );\n    }\n    {\n      TransparentUpgradeableProxy collateralTokenProxy = new TransparentUpgradeableProxy(\n          address(CT_IMPL),\n          address(PROXY_ADMIN),\n          abi.encodeWithSelector(\n            COLLATERAL_TOKEN.initialize.selector,\n            MRA,\n            TRANSFER_PROXY,\n            ILienToken(address(LIEN_TOKEN)),\n            ConsiderationInterface(SEAPORT)\n          )\n        );\n      COLLATERAL_TOKEN = CollateralToken(address(collateralTokenProxy));\n      assert(COLLATERAL_TOKEN.owner() == auth);\n      if (testModeDisabled) {\n        //      vm.setEnv(\"TRANSPARENT_UPGRADEABLE_PROXY_ADDR\", address(transparentUpgradeableProxy));\n        vm.writeLine(\n          string(\".env\"),\n          string(\n            abi.encodePacked(\n              \"COLLATERAL_TOKEN_PROXY_ADDR=\",\n              vm.toString(address(collateralTokenProxy))\n            )\n          )\n        );\n      }\n    }\n\n    SOLO_IMPLEMENTATION = new Vault();\n    if (testModeDisabled) {\n      vm.writeLine(\n        string(\".env\"),\n        string(\n          abi.encodePacked(\n            \"SOLO_IMPLEMENTATION_ADDR=\",\n            vm.toString(address(SOLO_IMPLEMENTATION))\n          )\n        )\n      );\n    }\n    PUBLIC_VAULT_IMPLEMENTATION = new PublicVault();\n    if (testModeDisabled) {\n      vm.writeLine(\n        string(\".env\"),\n        string(\n          abi.encodePacked(\n            \"PUBLIC_VAULT_IMPLEMENTATION_ADDR=\",\n            vm.toString(address(PUBLIC_VAULT_IMPLEMENTATION))\n          )\n        )\n      );\n    }\n    WITHDRAW_PROXY = new WithdrawProxy();\n    if (testModeDisabled) {\n      vm.writeLine(\n        string(\".env\"),\n        string(\n          abi.encodePacked(\n            \"WITHDRAW_PROXY_ADDR=\",\n            vm.toString(address(WITHDRAW_PROXY))\n          )\n        )\n      );\n    }\n    BeaconProxy BEACON_PROXY = new BeaconProxy();\n    if (testModeDisabled) {\n      vm.writeLine(\n        string(\".env\"),\n        string(\n          abi.encodePacked(\n            \"BEACON_PROXY_ADDR=\",\n            vm.toString(address(BEACON_PROXY))\n          )\n        )\n      );\n    }\n\n    {\n      AstariaRouter AR_IMPL = new AstariaRouter();\n      if (testModeDisabled) {\n        vm.writeLine(\n          string(\".env\"),\n          string(\n            abi.encodePacked(\n              \"ASTARIA_ROUTER_IMPL_ADDR=\",\n              vm.toString(address(AR_IMPL))\n            )\n          )\n        );\n      }\n\n      TransparentUpgradeableProxy astariaRouterProxy = new TransparentUpgradeableProxy(\n          address(AR_IMPL),\n          address(PROXY_ADMIN),\n          abi.encodeWithSelector(\n            AstariaRouter.initialize.selector,\n            MRA,\n            ICollateralToken(address(COLLATERAL_TOKEN)),\n            ILienToken(address(LIEN_TOKEN)),\n            ITransferProxy(address(TRANSFER_PROXY)),\n            address(PUBLIC_VAULT_IMPLEMENTATION),\n            address(SOLO_IMPLEMENTATION),\n            address(WITHDRAW_PROXY),\n            address(BEACON_PROXY),\n            address(CLEARING_HOUSE_IMPL)\n          )\n        );\n      ASTARIA_ROUTER = AstariaRouter(address(astariaRouterProxy));\n\n      if (testModeDisabled) {\n        vm.writeLine(\n          string(\".env\"),\n          string(\n            abi.encodePacked(\n              \"ASTARIA_ROUTER_PROXY_ADDR=\",\n              vm.toString(address(astariaRouterProxy))\n            )\n          )\n        );\n      }\n    }\n    {\n      ICollateralToken.File[] memory ctfiles = new ICollateralToken.File[](1);\n\n      ctfiles[0] = ICollateralToken.File({\n        what: ICollateralToken.FileType.AstariaRouter,\n        data: abi.encode(address(ASTARIA_ROUTER))\n      });\n      COLLATERAL_TOKEN.fileBatch(ctfiles);\n    }\n    _setupRolesAndCapabilities();\n\n    LIEN_TOKEN.file(\n      ILienToken.File(\n        ILienToken.FileType.CollateralToken,\n        abi.encode(address(COLLATERAL_TOKEN))\n      )\n    );\n    LIEN_TOKEN.file(\n      ILienToken.File(\n        ILienToken.FileType.AstariaRouter,\n        abi.encode(address(ASTARIA_ROUTER))\n      )\n    );\n    if (testModeDisabled) {\n      vm.stopBroadcast();\n    } else {\n      //      _setOwner();\n    }\n  }\n\n  function _setupRolesAndCapabilities() internal {\n    // ROUTER CAPABILITIES\n\n    MRA.setRoleCapability(\n      uint8(UserRoles.ASTARIA_ROUTER),\n      LienToken.createLien.selector,\n      true\n    );\n    MRA.setRoleCapability(\n      uint8(UserRoles.ASTARIA_ROUTER),\n      TRANSFER_PROXY.tokenTransferFrom.selector,\n      true\n    );\n\n    MRA.setRoleCapability(\n      uint8(UserRoles.ASTARIA_ROUTER),\n      CollateralToken.auctionVault.selector,\n      true\n    );\n\n    // LIEN TOKEN CAPABILITIES\n    MRA.setRoleCapability(\n      uint8(UserRoles.ASTARIA_ROUTER),\n      LienToken.stopLiens.selector,\n      true\n    );\n\n    MRA.setRoleCapability(\n      uint8(UserRoles.LIEN_TOKEN),\n      CollateralToken.settleAuction.selector,\n      true\n    );\n\n    MRA.setRoleCapability(\n      uint8(UserRoles.LIEN_TOKEN),\n      TRANSFER_PROXY.tokenTransferFrom.selector,\n      true\n    );\n\n    // SEAPORT CAPABILITIES\n\n    MRA.setUserRole(\n      address(ASTARIA_ROUTER),\n      uint8(UserRoles.ASTARIA_ROUTER),\n      true\n    );\n    MRA.setUserRole(address(COLLATERAL_TOKEN), uint8(UserRoles.WRAPPER), true);\n    MRA.setUserRole(address(LIEN_TOKEN), uint8(UserRoles.LIEN_TOKEN), true);\n  }\n\n  function _setOwner() internal {\n    MRA.transferOwnership(msg.sender);\n    ASTARIA_ROUTER.transferOwnership(msg.sender);\n    LIEN_TOKEN.transferOwnership(msg.sender);\n    COLLATERAL_TOKEN.transferOwnership(msg.sender);\n  }\n}"
    },
    {
      "filename": "src/scripts/deployments/Deploy.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**\n *  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗\n * ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n * ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n * ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n * ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n * ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n *\n * Astaria Labs, Inc\n */\n\npragma solidity =0.8.17;\n\nimport {Script} from \"forge-std/Script.sol\";\n\nimport {Authority} from \"solmate/auth/Auth.sol\";\nimport {\n  MultiRolesAuthority\n} from \"solmate/auth/authorities/MultiRolesAuthority.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {WETH} from \"solmate/tokens/WETH.sol\";\nimport {ERC721} from \"gpl/ERC721.sol\";\nimport {ITransferProxy} from \"core/interfaces/ITransferProxy.sol\";\nimport {IERC20} from \"core/interfaces/IERC20.sol\";\n\nimport {CollateralToken} from \"core/CollateralToken.sol\";\nimport {LienToken} from \"core/LienToken.sol\";\nimport {AstariaRouter} from \"core/AstariaRouter.sol\";\nimport {Vault} from \"core/Vault.sol\";\nimport {PublicVault} from \"core/PublicVault.sol\";\nimport {TransferProxy} from \"core/TransferProxy.sol\";\nimport {ICollateralToken} from \"core/interfaces/ICollateralToken.sol\";\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\nimport {WithdrawProxy} from \"core/WithdrawProxy.sol\";\nimport {BeaconProxy} from \"core/BeaconProxy.sol\";\nimport {ClearingHouse} from \"core/ClearingHouse.sol\";\nimport {\n  ConsiderationInterface\n} from \"seaport/interfaces/ConsiderationInterface.sol\";\nimport {\n  TransparentUpgradeableProxy\n} from \"lib/seaport/lib/openzeppelin-contracts/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport {\n  ProxyAdmin\n} from \"lib/seaport/lib/openzeppelin-contracts/contracts/proxy/transparent/ProxyAdmin.sol\";\nimport {\n  Initializable\n} from \"lib/seaport/lib/openzeppelin-contracts/contracts/proxy/utils/Initializable.sol\";\n\ncontract Deploy is Script {\n  enum UserRoles {\n    ADMIN,\n    ASTARIA_ROUTER,\n    WRAPPER,\n    TRANSFER_PROXY,\n    LIEN_TOKEN\n  }\n\n  event Deployed(address);\n\n  CollateralToken COLLATERAL_TOKEN;\n  LienToken LIEN_TOKEN;\n  AstariaRouter ASTARIA_ROUTER;\n  PublicVault PUBLIC_VAULT_IMPLEMENTATION;\n  WithdrawProxy WITHDRAW_PROXY;\n  Vault SOLO_IMPLEMENTATION;\n  TransferProxy TRANSFER_PROXY;\n  WETH WETH9;\n  MultiRolesAuthority MRA;\n  ConsiderationInterface SEAPORT;\n  ProxyAdmin PROXY_ADMIN;\n\n  bool testModeDisabled = true;\n\n  function run() public virtual {\n    deploy();\n  }\n\n  function deploy() public virtual {\n    if (testModeDisabled) {\n      vm.startBroadcast(msg.sender);\n    }\n\n    address weth;\n\n    try vm.envAddress(\"WETH9_ADDR\") {\n      weth = vm.envAddress(\"WETH9_ADDR\");\n    } catch {}\n    if (address(SEAPORT) == address(0)) {\n      try vm.envAddress(\"SEAPORT_ADDR\") {\n        SEAPORT = ConsiderationInterface(vm.envAddress(\"SEAPORT_ADDR\"));\n      } catch {\n        revert(\"SEAPORT_ADDR not found\");\n      }\n    }\n\n    if (weth == address(0)) {\n      WETH9 = new WETH();\n      if (testModeDisabled) {\n        vm.writeLine(\n          string(\".env\"),\n          string(abi.encodePacked(\"WETH9_ADDR=\", vm.toString(address(WETH9))))\n        );\n      }\n    } else {\n      WETH9 = WETH(payable(weth)); // mainnet weth\n      if (testModeDisabled) {\n        vm.writeLine(\n          string(\".env\"),\n          string(abi.encodePacked(\"WETH9_ADDR=\", vm.toString(address(WETH9))))\n        );\n      }\n    }\n    address auth = testModeDisabled ? msg.sender : address(this);\n    MRA = new MultiRolesAuthority(auth, Authority(address(0)));\n    if (testModeDisabled) {\n      vm.writeLine(\n        string(\".env\"),\n        string(abi.encodePacked(\"MRA_ADDR=\", vm.toString(address(MRA))))\n      );\n    }\n\n    TRANSFER_PROXY = new TransferProxy(MRA);\n    if (testModeDisabled) {\n      //      vm.setEnv(\"TRANSFER_PROXY_ADDR\", address(TRANSFER_PROXY));\n      vm.writeLine(\n        string(\".env\"),\n        string(\n          abi.encodePacked(\n            \"TRANSFER_PROXY_ADDR=\",\n            vm.toString(address(TRANSFER_PROXY))\n          )\n        )\n      );\n    }\n\n    PROXY_ADMIN = new ProxyAdmin();\n    if (testModeDisabled) {\n      vm.writeLine(\n        string(\".env\"),\n        string(\n          abi.encodePacked(\n            \"PROXY_ADMIN_ADDR=\",\n            vm.toString(address(PROXY_ADMIN))\n          )\n        )\n      );\n    }\n\n    LienToken LT_IMPL = new LienToken();\n\n    if (testModeDisabled) {\n      vm.writeLine(\n        string(\".env\"),\n        string(\n          abi.encodePacked(\n            \"LIEN_TOKEN_IMPL_ADDR=\",\n            vm.toString(address(LT_IMPL))\n          )\n        )\n      );\n    }\n    // LienToken proxy deployment/setup\n    TransparentUpgradeableProxy lienTokenProxy = new TransparentUpgradeableProxy(\n        address(LT_IMPL),\n        address(PROXY_ADMIN),\n        abi.encodeWithSelector(\n          LIEN_TOKEN.initialize.selector,\n          MRA,\n          TRANSFER_PROXY\n        )\n      );\n    LIEN_TOKEN = LienToken(address(lienTokenProxy));\n    if (testModeDisabled) {\n      //      vm.setEnv(\"TRANSPARENT_UPGRADEABLE_PROXY_ADDR\", address(transparentUpgradeableProxy));\n      vm.writeLine(\n        string(\".env\"),\n        string(\n          abi.encodePacked(\n            \"LIEN_TOKEN_PROXY_ADDR=\",\n            vm.toString(address(lienTokenProxy))\n          )\n        )\n      );\n    }\n    ClearingHouse CLEARING_HOUSE_IMPL = new ClearingHouse();\n\n    if (testModeDisabled) {\n      //      vm.setEnv(\"CLEARING_HOUSE_IMPL_ADDR\", address(CLEARING_HOUSE_IMPL));\n      vm.writeLine(\n        string(\".env\"),\n        string(\n          abi.encodePacked(\n            \"CLEARING_HOUSE_IMPL_ADDR=\",\n            vm.toString(address(CLEARING_HOUSE_IMPL))\n          )\n        )\n      );\n    }\n\n    CollateralToken CT_IMPL = new CollateralToken();\n\n    if (testModeDisabled) {\n      //      vm.setEnv(\"COLLATERAL_TOKEN_ADDR\", address(COLLATERAL_TOKEN));\n      vm.writeLine(\n        string(\".env\"),\n        string(\n          abi.encodePacked(\n            \"COLLATERAL_TOKEN_IMPL_ADDR=\",\n            vm.toString(address(CT_IMPL))\n          )\n        )\n      );\n    }\n    {\n      TransparentUpgradeableProxy collateralTokenProxy = new TransparentUpgradeableProxy(\n          address(CT_IMPL),\n          address(PROXY_ADMIN),\n          abi.encodeWithSelector(\n            COLLATERAL_TOKEN.initialize.selector,\n            MRA,\n            TRANSFER_PROXY,\n            ILienToken(address(LIEN_TOKEN)),\n            ConsiderationInterface(SEAPORT)\n          )\n        );\n      COLLATERAL_TOKEN = CollateralToken(address(collateralTokenProxy));\n      assert(COLLATERAL_TOKEN.owner() == auth);\n      if (testModeDisabled) {\n        //      vm.setEnv(\"TRANSPARENT_UPGRADEABLE_PROXY_ADDR\", address(transparentUpgradeableProxy));\n        vm.writeLine(\n          string(\".env\"),\n          string(\n            abi.encodePacked(\n              \"COLLATERAL_TOKEN_PROXY_ADDR=\",\n              vm.toString(address(collateralTokenProxy))\n            )\n          )\n        );\n      }\n    }\n\n    SOLO_IMPLEMENTATION = new Vault();\n    if (testModeDisabled) {\n      vm.writeLine(\n        string(\".env\"),\n        string(\n          abi.encodePacked(\n            \"SOLO_IMPLEMENTATION_ADDR=\",\n            vm.toString(address(SOLO_IMPLEMENTATION))\n          )\n        )\n      );\n    }\n    PUBLIC_VAULT_IMPLEMENTATION = new PublicVault();\n    if (testModeDisabled) {\n      vm.writeLine(\n        string(\".env\"),\n        string(\n          abi.encodePacked(\n            \"PUBLIC_VAULT_IMPLEMENTATION_ADDR=\",\n            vm.toString(address(PUBLIC_VAULT_IMPLEMENTATION))\n          )\n        )\n      );\n    }\n    WITHDRAW_PROXY = new WithdrawProxy();\n    if (testModeDisabled) {\n      vm.writeLine(\n        string(\".env\"),\n        string(\n          abi.encodePacked(\n            \"WITHDRAW_PROXY_ADDR=\",\n            vm.toString(address(WITHDRAW_PROXY))\n          )\n        )\n      );\n    }\n    BeaconProxy BEACON_PROXY = new BeaconProxy();\n    if (testModeDisabled) {\n      vm.writeLine(\n        string(\".env\"),\n        string(\n          abi.encodePacked(\n            \"BEACON_PROXY_ADDR=\",\n            vm.toString(address(BEACON_PROXY))\n          )\n        )\n      );\n    }\n\n    {\n      AstariaRouter AR_IMPL = new AstariaRouter();\n      if (testModeDisabled) {\n        vm.writeLine(\n          string(\".env\"),\n          string(\n            abi.encodePacked(\n              \"ASTARIA_ROUTER_IMPL_ADDR=\",\n              vm.toString(address(AR_IMPL))\n            )\n          )\n        );\n      }\n\n      TransparentUpgradeableProxy astariaRouterProxy = new TransparentUpgradeableProxy(\n          address(AR_IMPL),\n          address(PROXY_ADMIN),\n          abi.encodeWithSelector(\n            AstariaRouter.initialize.selector,\n            MRA,\n            ICollateralToken(address(COLLATERAL_TOKEN)),\n            ILienToken(address(LIEN_TOKEN)),\n            ITransferProxy(address(TRANSFER_PROXY)),\n            address(PUBLIC_VAULT_IMPLEMENTATION),\n            address(SOLO_IMPLEMENTATION),\n            address(WITHDRAW_PROXY),\n            address(BEACON_PROXY),\n            address(CLEARING_HOUSE_IMPL)\n          )\n        );\n      ASTARIA_ROUTER = AstariaRouter(address(astariaRouterProxy));\n\n      if (testModeDisabled) {\n        vm.writeLine(\n          string(\".env\"),\n          string("
    }
  ]
}