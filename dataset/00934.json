{
  "Title": "Static `GovUserKeeper::_nftInfo.totalPowerInTokens` used in quorum denominator can incorrectly make it impossible to reach quorum",
  "Content": "**Description:** Consider the following factors:\n\n1) `GovPoolVote::_quorumReached()` [uses](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/libs/gov/gov-pool/GovPoolVote.sol#L337) `GovUserKeeper::getTotalVoteWeight()` as the denominator for determining whether quorum has been reached.\n\n2) `GovUserKeeper::getTotalVoteWeight()` returns the current total supply of ERC20 tokens [plus](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/user-keeper/GovUserKeeper.sol#L573) `_nftInfo.totalPowerInTokens`\n\n3) `_nftInfo.totalPowerInTokens` which is [only set once at initialization](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/user-keeper/GovUserKeeper.sol#L690-L694) represents the total voting power of the nft contract in erc20 tokens.\n\nWhen voting using `ERC721Power` nfts where nft power can decrease to zero if nfts don't have the required collateral deposited, this can result in a state where `ERC721Power.totalPower() == 0` but `GovUserKeeper::_nftInfo.totalPowerInTokens > 0`.\n\nHence the voting power of the ERC20 voting tokens will be incorrectly diluted by the nft's initial voting power `GovUserKeeper::_nftInfo.totalPowerInTokens`, even though the nfts have lost all voting power.\n\nThis can result in a state where quorum is impossible to reach.\n\n**Impact:** Quorum can be impossible to reach.\n\n**Proof of Concept:** Firstly comment out GovUserKeeper [L677](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/user-keeper/GovUserKeeper.sol#L677) & [L690](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/user-keeper/GovUserKeeper.sol#L690) to allow quickly in-place changing of the voting & nft contracts.\n\nAdd PoC to `GovPool.test.js` under section `describe(\"getProposalState()\", () => {`:\n```javascript\n      it(\"audit static GovUserKeeper::_nftInfo.totalPowerInTokens in quorum denominator can incorrectly make it impossible to reach quorum\", async () => {\n        // time when nft power calculation starts\n        let powerNftCalcStartTime = (await getCurrentBlockTime()) + 200;\n\n        // required so we can call .toFixed() on BN returned outputs\n        ERC721Power.numberFormat = \"BigNumber\";\n\n        // ERC721Power.totalPower should be zero as no nfts yet created\n        assert.equal((await nftPower.totalPower()).toFixed(), \"0\");\n\n        // so proposal doesn't need to go to validators\n        await changeInternalSettings(false);\n\n        // set nftPower as the voting nft\n        // need to comment out check preventing updating existing\n        // nft address in GovUserKeeper::setERC721Address()\n        await impersonate(govPool.address);\n        await userKeeper.setERC721Address(nftPower.address, wei(\"190000000000000000000\"), 1, { from: govPool.address });\n\n        // create a new VOTER account and mint them the only power nft\n        let VOTER = await accounts(10);\n        await nftPower.safeMint(VOTER, 1);\n\n        // switch to using a new ERC20 token for voting; lets us\n        // control exactly who has what voting power without worrying about\n        // what previous setups have done\n        // requires commenting out require statement in GovUserKeeper::setERC20Address()\n        let newVotingToken = await ERC20Mock.new(\"NEWV\", \"NEWV\", 18);\n        await impersonate(govPool.address);\n        await userKeeper.setERC20Address(newVotingToken.address, { from: govPool.address });\n\n        // mint VOTER some tokens that when combined with their NFT are enough\n        // to reach quorum\n        let voterTokens = wei(\"190000000000000000000\");\n        await newVotingToken.mint(VOTER, voterTokens);\n        await newVotingToken.approve(userKeeper.address, voterTokens, { from: VOTER });\n        await nftPower.approve(userKeeper.address, \"1\", { from: VOTER });\n\n        // VOTER deposits their tokens & nft to have voting power\n        await govPool.deposit(VOTER, voterTokens, [1], { from: VOTER });\n\n        // advance to the approximate time when nft power calculation starts\n        await setTime(powerNftCalcStartTime);\n\n        // verify nft power after power calculation has started\n        let nftTotalPowerBefore = \"900000000000000000000000000\";\n        assert.equal((await nftPower.totalPower()).toFixed(), nftTotalPowerBefore);\n\n        // create a proposal which takes a snapshot of the current nft power\n        let proposal1Id = 2;\n\n        await govPool.createProposal(\n          \"example.com\",\n          [[govPool.address, 0, getBytesGovVote(3, wei(\"100\"), [], true)]],\n          [[govPool.address, 0, getBytesGovVote(3, wei(\"100\"), [], false)]]\n        );\n\n        // vote on first proposal\n        await govPool.vote(proposal1Id, true, voterTokens, [1], { from: VOTER });\n\n        // advance time to allow proposal state change\n        await setTime((await getCurrentBlockTime()) + 10);\n\n        // verify that proposal has reached quorum;\n        // VOTER's tokens & nft was enough to reach quorum\n        assert.equal(await govPool.getProposalState(proposal1Id), ProposalState.SucceededFor);\n\n        // advance time; since VOTER's nft doesn't have collateral deposited\n        // its power will decrement to zero\n        await setTime((await getCurrentBlockTime()) + 10000);\n\n        // call ERC721::recalculateNftPower() for the nft, this will update\n        // ERC721Power.totalPower with the actual current total power\n        await nftPower.recalculateNftPower(\"1\");\n\n        // verify that the true totalPower has decremented to zero as the nft\n        // lost all its power since it didn't have collateral deposited\n        assert.equal((await nftPower.totalPower()).toFixed(), \"0\");\n\n        // create 2nd proposal which takes a snapshot of the current nft power\n        let proposal2Id = 3;\n\n        await govPool.createProposal(\n          \"example.com\",\n          [[govPool.address, 0, getBytesGovVote(3, wei(\"100\"), [], true)]],\n          [[govPool.address, 0, getBytesGovVote(3, wei(\"100\"), [], false)]]\n        );\n\n        // vote on second proposal\n        await govPool.vote(proposal2Id, true, voterTokens, [1], { from: VOTER });\n\n        // advance time to allow proposal state change\n        await setTime((await getCurrentBlockTime()) + 10);\n\n        // verify that proposal has not reached quorum;\n        // even though VOTER owns 100% of the supply of the ERC20 voting token,\n        // it is now impossible to reach quorum since the power of VOTER's\n        // ERC20 tokens is being incorrectly diluted through the quorum calculation\n        // denominator assuming the nfts still have voting power.\n        //\n        // this is incorrect as the nft has lost all power. The root cause\n        // is GovUserKeeper::_nftInfo.totalPowerInTokens which is static\n        // but used in the denominator when calculating whether\n        // quorum is reached\n        assert.equal(await govPool.getProposalState(proposal2Id), ProposalState.Voting);\n      });\n```\n\nRun with: `npx hardhat test --grep \"audit static GovUserKeeper::_nftInfo.totalPowerInTokens in quorum denominator\"`\n\n**Recommended Mitigation:** Change `GovUserKeeper::getTotalVoteWeight` [L573](https://github.com/dexe-network/DeXe-Protocol/tree/f2fe12eeac0c4c63ac39670912640dc91d94bda5/contracts/gov/user-keeper/GovUserKeeper.sol#L573) to use 0 instead of `_nftInfo.totalPowerInTokens` if `IERC721Power(nftAddress).totalPower() == 0`.\n\nConsider whether this should be refactored such that the suggested `totalPower() == 0` check should not be done against the current `totalPower`, but against the `totalPower` saved when the proposal's nft snapshot was created which is stored in `GovUserKeeper::nftSnapshot[proposalSnapshotId]`.\n\n**Dexe:**\nFixed in [PR172](https://github.com/dexe-network/DeXe-Protocol/commit/b2b30da3204acd16da6fa61e79703ac0b6271815), [PR173](https://github.com/dexe-network/DeXe-Protocol/commit/15edac2ba207a915bd537684cd7644831ec2c887) & commit [7a0876b](https://github.com/dexe-network/DeXe-Protocol/commit/7a0876b3c6f832d03b2d45760a85b42d23a21ce7).\n\n**Cyrin:**\nDuring the mitigations Dexe has performed significant refactoring on the power nfts; what was previously 1 contract has become 3, and the interaction between the power nft voting contracts and `GovPool` & `GovUserKeeper` has been significantly changed.\n\nIn the new implementation:\n* when users use power nfts to [vote personally, this uses the current power](https://github.com/dexe-network/DeXe-Protocol/blob/440b8b3534d58d16df781b402503be5a64d5d576/contracts/libs/gov/gov-user-keeper/GovUserKeeperView.sol#L185) of the power nft\n* when users delegate power nfts and [have the delegatee vote, this caches the minimum power](https://github.com/dexe-network/DeXe-Protocol/blob/440b8b3534d58d16df781b402503be5a64d5d576/contracts/gov/user-keeper/GovUserKeeper.sol#L266) of the power nft\n* when the power nft [`totalRawPower` is calculated, this always uses the current power](https://github.com/dexe-network/DeXe-Protocol/blob/440b8b3534d58d16df781b402503be5a64d5d576/contracts/gov/ERC721/powers/AbstractERC721Power.sol#L212) of power nfts\n* the [quorum denominator always uses `totalRawPower`](https://github.com/dexe-network/DeXe-Protocol/blob/440b8b3534d58d16df781b402503be5a64d5d576/contracts/gov/user-keeper/GovUserKeeper.sol#L619) which is calculated from the current power\n\nThe effect of this is that:\n* users are highly penalized for delegating power nfts compared to using them to personally vote\n* the quorum denominator is always based on the current nft power so will be over-inflated if users are delegating their nfts and receiving only the minimum voting power\n\nHere is a PoC for `GovPool.test.js` that illustrates this scenario:\n```javascript\n       it(\"audit actual power nft voting power doesn't match total nft voting power\", async () => {\n          let powerNftCalcStartTime = (await getCurrentBlockTime()) + 200;\n\n          // required so we can call .toFixed() on BN returned outputs\n          ERC721RawPower.numberFormat = \"BigNumber\";\n\n          // ERC721RawPower::totalPower should be zero as no nfts yet created\n          assert.equal((await nftPower.totalPower()).toFixed(), \"0\");\n\n          // set nftPower as the voting nft\n          // need to comment out check preventing updating existing\n          // nft address in GovUserKeeper::setERC721Address()\n          await impersonate(govPool.address);\n          await userKeeper.setERC721Address(nftPower.address, wei(\"33000\"), 33, { from: govPool.address });\n\n          // create new MASTER & SLAVE accounts\n          let MASTER = await accounts(10);\n          let SLAVE  = await accounts(11);\n\n          // mint MASTER 1 power nft\n          let masterNftId = 1;\n          await nftPower.mint(MASTER, masterNftId, \"\");\n\n          // advance to the approximate time when nft power calculation starts\n          await setTime(powerNftCalcStartTime);\n\n          // verify MASTER's nft has current power > 0\n          let masterNftCurrentPowerStart = (await nftPower.getNftPower(masterNftId)).toFixed();\n          assert.equal(masterNftCurrentPowerStart, \"894960000000000000000000000\");\n          // verify MASTER's nft has minumum power = 0\n          let masterNftMinPowerStart = (await nftPower.getNftMinPower(masterNftId)).toFixed();\n          assert.equal(masterNftMinPowerStart, \"0\");\n\n          // MASTER deposits their nft then delegates it to SLAVE, another address they control\n          await nftPower.approve(userKeeper.address, masterNftId, { from: MASTER });\n          await govPool.deposit(\"0\", [masterNftId], { from: MASTER });\n          await govPool.delegate(SLAVE, \"0\", [masterNftId], { from: MASTER });\n\n          // delegation triggers power recalculation on master's nft. Delegation caches\n          // the minimum possible voting power of master's nft 0 and uses that for\n          // slaves delegated voting power. But recalculation uses the current power\n          // of Master's NFT > 0 to update the contract's total power, and this value\n          // is used in the denominator of the quorum calculation\n          assert.equal((await nftPower.totalPower()).toFixed(), \"894690000000000000000000000\");\n\n          // mint THIRD some voting tokens & deposit them\n          let thirdTokens = wei(\"1000\");\n          await token.mint(THIRD, thirdTokens);\n          await token.approve(userKeeper.address, thirdTokens, { from: THIRD });\n          await govPool.deposit(thirdTokens, [], { from: THIRD });\n\n          // create a proposal\n          let proposalId = 1;\n          await govPool.createProposal(\"\",\n            [[govPool.address, 0, getBytesDelegateTreasury(THIRD, wei(\"1\"), [])]], [], { from: THIRD });\n\n          // MASTER uses their SLAVE account to vote on the proposal; this reverts\n          // as delegation saved the minimum possible voting power of MASTER's nft 0\n          // and uses 0 as the voting power\n          await truffleAssert.reverts(\n            govPool.vote(proposalId, true, 0, [], { from: SLAVE }),\n            \"Gov: low voting power\"\n          );\n\n          // MASTER has the one & only power nft\n          // It has current power   = 894690000000000000000000000\n          // nft.Power.totalPower() = 894690000000000000000000000\n          // This value will be used in the denominator of the quorum calculation\n          // But in practice its actual voting power is 0 since the minumum\n          // possible voting power is used for voting power in delegation, causing\n          // the quorum denominator to be over-inflated\n        });\n```\n\nAlso due to the significant refactoring in this area, here is the updated PoC we used to verify the fix:\n\n```javascript\n        it(\"audit verified: nft totalPower > 0 when all nfts lost power incorrectly makes it impossible to reach quorum\", async () => {\n          // required so we can call .toFixed() on BN returned outputs\n          ERC721RawPower.numberFormat = \"BigNumber\";\n\n          // time when nft power calculation starts\n          let powerNftCalcStartTime = (await getCurrentBlockTime()) + 200;\n\n          // create a new nft power token with max power same as voting token's\n          // total supply; since we only mint 1 nft this keeps PoC simple\n          let voterTokens = wei(\"190000000000000000000\");\n\n          let newNftPower = await ERC721RawPower.new();\n          await newNftPower.__ERC721RawPower_init(\n            \"NFTPowerMock\",\n            \"NFTPM\",\n            powerNftCalcStartTime,\n            token.address,\n            toPercent(\"0.01\"),\n            voterTokens,\n            \"540\"\n          );\n\n          // ERC721Power.totalPower should be zero as no nfts yet created\n          assert.equal((await newNftPower.totalPower()).toFixed(), \"0\");\n\n          // so proposal doesn't need to go to validators\n          await changeInternalSettings(false);\n\n          // set newNftPower as the voting nft\n          // need to comment out check preventing updating existing\n          // nft address in GovUserKeeper::setERC721Address()\n          await impersonate(govPool.address);\n          // individualPower & supply params not used for power nfts\n          await userKeeper.setERC721Address(newNftPower.address, \"0\", 0, { from: govPool.address });\n\n          // create a new VOTER account and mint them the only power nft\n          let VOTER = await accounts(10);\n          let voterNftId = 1;\n          await newNftPower.mint(VOTER, voterNftId, \"\");\n\n          // switch to using a new ERC20 token for voting; lets us\n          // control exactly who has what voting power without worrying about\n          // what previous setups have done\n          // requires commenting out require statement in GovUserKeeper::setERC20Address()\n          let newVotingToken = await ERC20Mock.new(\"NEWV\", \"NEWV\", 18);\n          await impersonate(govPool.address);\n          await userKeeper.setERC20Address(newVotingToken.address, { from: govPool.address });\n\n          // mint VOTER some tokens that when combined with their NFT are enough\n          // to reach quorum\n          await newVotingToken.mint(VOTER, voterTokens);\n          await newVotingToken.approve(userKeeper.address, voterTokens, { from: VOTER });\n          await newNftPower.approve(userKeeper.address, voterNftId, { from: VOTER });\n\n          // VOTER deposits their tokens & nft to have voting power\n          await govPool.deposit(voterTokens, [voterNftId], { from: VOTER });\n\n          // advance to the approximate time when nft power calculation starts\n          await setTime(powerNftCalcStartTime);\n\n          // verify nft power after power calculation has started\n          assert.equal((await newNftPower.totalPower()).toFixed(), voterTokens);\n\n          // create a proposal\n          let proposal1Id = 2;\n\n          await govPool.createProposal(\n            \"example.com\",\n            [[govPool.address, 0, getBytesGovVote(3, wei(\"100\"), [], true)]],\n            [[govPool.address, 0, getBytesGovVote(3, wei(\"100\"), [], false)]]\n          ,{from : VOTER});\n\n          // vote on first proposal\n          await govPool.vote(proposal1Id, true, voterTokens, [voterNftId], { from: VOTER });\n\n          // advance time to allow proposal state change\n          await setTime((await getCurrentBlockTime()) + 10);\n\n          // verify that proposal has reached quorum;\n          // VOTER's tokens & nft was enough to reach quorum'\n          // since VOTER owns all the voting erc20s & power nfts\n          //\n          // fails here; proposal still in Voting state?\n          assert.equal(await govPool.getProposalState(proposal1Id), ProposalState.SucceededFor);\n\n          // advance time; since VOTER's nft doesn't have collateral deposited\n          // its power will decrement to zero\n          await setTime((await getCurrentBlockTime()) + 10000);\n\n          // create 2nd proposal\n          let proposal2Id = 3;\n\n          await govPool.createProposal(\n            \"example.com\",\n            [[govPool.address, 0, getBytesGovVote(3, wei(\"100\"), [], true)]],\n            [[govPool.address, 0, getBytesGovVote(3, wei(\"100\"), [], false)]]\n          ,{from : VOTER});\n\n          // vote on second proposal\n          await govPool.vote(proposal2Id, true, voterTokens, [voterNftId], { from: VOTER });\n\n          // advance time to allow proposal state change\n          await setTime((await getCurrentBlockTime()) + 10);\n\n          // this used to fail as the proposal would fail to reach quorum\n          // but now it works\n          assert.equal(await govPool.getProposalState(proposal2Id), ProposalState.SucceededFor);\n        });\n```\n\n**Dexe:**\nWe are aware of this inflation thing. Unfortunately, this is probably a sacrifice we have to make. Given the business logic of power NFT, we are caught between two stools. Either loops with \"current power\" (which doesn't work for delegatees as potentially the whole supply could be delegated to a single user) or with minimal power and quorum inflation.\n\nThe second option seems to be better and much more elegant. Also it incentivises users to add collateral to their NFTs.\n\n\\clearpage",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/libs/gov/gov-user-keeper/GovUserKeeperView.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"@solarity/solidity-lib/libs/data-structures/memory/Vector.sol\";\nimport \"@solarity/solidity-lib/libs/utils/TypeCaster.sol\";\n\nimport \"../../../interfaces/gov/user-keeper/IGovUserKeeper.sol\";\nimport \"../../../interfaces/gov/voting/IVotePower.sol\";\nimport \"../../../interfaces/gov/ERC721/powers/IERC721Power.sol\";\n\nimport \"../../math/MathHelper.sol\";\nimport \"../../utils/TypeHelper.sol\";\n\nimport \"../../../gov/user-keeper/GovUserKeeper.sol\";\n\nlibrary GovUserKeeperView {\n    using EnumerableSet for EnumerableSet.UintSet;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using Vector for Vector.UintVector;\n    using MathHelper for uint256;\n    using Math for uint256;\n    using TypeCaster for *;\n    using TypeHelper for *;\n\n    function transformedVotingPower(\n        mapping(address => IGovUserKeeper.UserInfo) storage usersInfo,\n        IGovUserKeeper.NFTInfo storage nftInfo,\n        address tokenAddress,\n        address voter,\n        uint256 amount,\n        uint256[] calldata nftIds\n    ) external view returns (uint256 personalPower, uint256 fullPower) {\n        IGovUserKeeper.VotingPowerView[] memory votingPowers = votingPower(\n            usersInfo,\n            nftInfo,\n            tokenAddress,\n            [voter, voter].asDynamic(),\n            [IGovPool.VoteType.MicropoolVote, IGovPool.VoteType.TreasuryVote].asDynamic(),\n            false\n        );\n\n        (uint256 nftPower, ) = getTotalNftsPower(\n            usersInfo,\n            nftInfo,\n            nftIds,\n            IGovPool.VoteType.PersonalVote,\n            voter,\n            false\n        );\n\n        (, , , , address votePower) = IGovPool(GovUserKeeper(address(this)).owner())\n            .getHelperContracts();\n\n        personalPower = amount + nftPower;\n        fullPower = personalPower + votingPowers[0].rawPower + votingPowers[1].rawPower;\n\n        personalPower = IVotePower(votePower).transformVotes(voter, personalPower);\n        fullPower = IVotePower(votePower).transformVotes(voter, fullPower);\n    }\n\n    function votingPower(\n        mapping(address => IGovUserKeeper.UserInfo) storage usersInfo,\n        IGovUserKeeper.NFTInfo storage nftInfo,\n        address tokenAddress,\n        address[] memory users,\n        IGovPool.VoteType[] memory voteTypes,\n        bool perNftPowerArray\n    ) public view returns (IGovUserKeeper.VotingPowerView[] memory votingPowers) {\n        GovUserKeeper userKeeper = GovUserKeeper(address(this));\n        votingPowers = new IGovUserKeeper.VotingPowerView[](users.length);\n\n        for (uint256 i = 0; i < users.length; i++) {\n            IGovUserKeeper.VotingPowerView memory power = votingPowers[i];\n\n            if (tokenAddress != address(0)) {\n                (power.power, power.ownedBalance) = userKeeper.tokenBalance(\n                    users[i],\n                    voteTypes[i]\n                );\n\n                power.rawPower = power.power - power.ownedBalance;\n            }\n\n            if (nftInfo.nftAddress != address(0)) {\n                uint256[] memory nftIds;\n                uint256 length;\n\n                if (!perNftPowerArray) {\n                    (, length) = userKeeper.nftBalance(users[i], voteTypes[i]);\n                } else {\n                    (nftIds, length) = userKeeper.nftExactBalance(users[i], voteTypes[i]);\n                }\n\n                (power.nftPower, power.perNftPower) = getTotalNftsPower(\n                    usersInfo,\n                    nftInfo,\n                    nftIds,\n                    voteTypes[i],\n                    users[i],\n                    perNftPowerArray\n                );\n\n                if (perNftPowerArray) {\n                    assembly {\n                        mstore(nftIds, sub(mload(nftIds), length))\n                    }\n                }\n\n                (power.rawNftPower, ) = getTotalNftsPower(\n                    usersInfo,\n                    nftInfo,\n                    nftIds,\n                    voteTypes[i],\n                    users[i],\n                    perNftPowerArray\n                );\n\n                if (perNftPowerArray) {\n                    assembly {\n                        mstore(nftIds, add(mload(nftIds), length))\n                    }\n                }\n\n                power.nftIds = nftIds;\n                power.ownedLength = length;\n\n                power.power += power.nftPower;\n                power.rawPower += power.rawNftPower;\n            }\n        }\n    }\n\n    function getTotalNftsPower(\n        mapping(address => IGovUserKeeper.UserInfo) storage usersInfo,\n        IGovUserKeeper.NFTInfo storage nftInfo,\n        uint256[] memory nftIds,\n        IGovPool.VoteType voteType,\n        address user,\n        bool perNftPowerArray\n    ) public view returns (uint256 nftPower, uint256[] memory perNftPower) {\n        if (nftInfo.nftAddress == address(0)) {\n            return (nftPower, perNftPower);\n        }\n\n        if (user != address(0)) {\n            if (\n                voteType == IGovPool.VoteType.MicropoolVote ||\n                voteType == IGovPool.VoteType.TreasuryVote\n            ) {\n                if (perNftPowerArray) {\n                    perNftPower = new uint256[](nftIds.length);\n\n                    if (!nftInfo.isSupportPower) {\n                        for (uint256 i = 0; i < perNftPower.length; i++) {\n                            perNftPower[i] = nftInfo.individualPower;\n                        }\n\n                        return (nftIds.length * nftInfo.individualPower, perNftPower);\n                    }\n\n                    for (uint256 i = 0; i < nftIds.length; ++i) {\n                        uint256 currentNftPower = nftInfo.nftMinPower[nftIds[i]];\n\n                        nftPower += currentNftPower;\n                        perNftPower[i] = currentNftPower;\n                    }\n\n                    return (nftPower, perNftPower);\n                } else {\n                    return\n                        nftInfo.isSupportPower\n                            ? (usersInfo[user].nftsPowers[voteType], perNftPower)\n                            : (\n                                usersInfo[user].balances[voteType].nfts.length() *\n                                    nftInfo.individualPower,\n                                perNftPower\n                            );\n                }\n            } else {\n                return\n                    _getActualNftPowers(\n                        IERC721Power(nftInfo.nftAddress).getNftPower,\n                        nftInfo,\n                        nftIds,\n                        perNftPowerArray\n                    );\n            }\n        } else {\n            return\n                _getActualNftPowers(\n                    IERC721Power(nftInfo.nftAddress).getNftMinPower,\n                    nftInfo,\n                    nftIds,\n                    perNftPowerArray\n                );\n        }\n    }\n\n    function delegations(\n        mapping(address => IGovUserKeeper.UserInfo) storage usersInfo,\n        IGovUserKeeper.NFTInfo storage nftInfo,\n        address user,\n        bool perNftPowerArray\n    )\n        external\n        view\n        returns (uint256 power, IGovUserKeeper.DelegationInfoView[] memory delegationsInfo)\n    {\n        IGovUserKeeper.UserInfo storage userInfo = usersInfo[user];\n\n        delegationsInfo = new IGovUserKeeper.DelegationInfoView[](userInfo.delegatees.length());\n\n        for (uint256 i; i < delegationsInfo.length; i++) {\n            IGovUserKeeper.DelegationInfoView memory delegation = delegationsInfo[i];\n            address delegatee = userInfo.delegatees.at(i);\n\n            IGovUserKeeper.BalanceInfo storage delegatedBalance = userInfo.delegatedBalances[\n                delegatee\n            ];\n\n            delegation.delegatee = delegatee;\n            delegation.delegatedTokens = delegatedBalance.tokens;\n            delegation.delegatedNfts = delegatedBalance.nfts.values();\n\n            (delegation.nftPower, delegation.perNftPower) = getTotalNftsPower(\n                usersInfo,\n                nftInfo,\n                delegation.delegatedNfts,\n                IGovPool.VoteType.MicropoolVote,\n                delegatee,\n                perNftPowerArray\n            );\n\n            power += delegation.delegatedTokens + delegation.nftPower;\n        }\n    }\n\n    function getWithdrawableAssets(\n        uint256[] calldata lockedProposals,\n        uint256[] calldata unlockedNfts,\n        IGovUserKeeper.UserInfo storage userInfo,\n        mapping(uint256 => uint256) storage nftLockedNums\n    ) external view returns (uint256 withdrawableTokens, uint256[] memory withdrawableNfts) {\n        IGovUserKeeper.BalanceInfo storage balanceInfo = userInfo.balances[\n            IGovPool.VoteType.PersonalVote\n        ];\n\n        uint256 newLockedAmount;\n\n        for (uint256 i; i < lockedProposals.length; i++) {\n            newLockedAmount = newLockedAmount.max(userInfo.lockedInProposals[lockedProposals[i]]);\n        }\n\n        withdrawableTokens = balanceInfo.tokens.max(newLockedAmount) - newLockedAmount;\n\n        Vector.UintVector memory nfts = Vector.newUint();\n        uint256 nftsLength = balanceInfo.nfts.length();\n\n        for (uint256 i; i < nftsLength; i++) {\n            uint256 nftId = balanceInfo.nfts.at(i);\n            uint256 nftLockAmount = nftLockedNums[nftId];\n\n            if (nftLockAmount != 0) {\n                for (uint256 j = 0; j < unlockedNfts.length; j++) {\n                    if (unlockedNfts[j] == nftId) {\n                        nftLockAmount--;\n                    }\n                }\n            }\n\n            if (nftLockAmount == 0) {\n                nfts.push(nftId);\n            }\n        }\n\n        withdrawableNfts = nfts.toArray();\n    }\n\n    function _getActualNftPowers(\n        function(uint256) external view returns (uint256) powerFunc,\n        IGovUserKeeper.NFTInfo storage nftInfo,\n        uint256[] memory nftIds,\n        bool perNftPowerArray\n    ) internal view returns (uint256 nftPower, uint256[] memory perNftPower) {\n        if (!nftInfo.isSupportPower) {\n            nftPower = nftIds.length * nftInfo.individualPower;\n        } else {\n            for (uint256 i = 0; i < nftIds.length; ++i) {\n                nftPower += powerFunc(nftIds[i]);\n            }\n        }\n\n        if (perNftPowerArray) {\n            perNftPower = new uint256[](nftIds.length);\n\n            if (!nftInfo.isSupportPower) {\n                for (uint256 i = 0; i < perNftPower.length; i++) {\n                    perNftPower[i] = nftInfo.individualPower;\n                }\n            } else {\n                for (uint256 i = 0; i < nftIds.length; ++i) {\n                    uint256 currentNftPower = powerFunc(nftIds[i]);\n\n                    perNftPower[i] = currentNftPower;\n                }\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/gov/user-keeper/GovUserKeeper.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"@solarity/solidity-lib/libs/utils/DecimalsConverter.sol\";\nimport \"@solarity/solidity-lib/libs/arrays/Paginator.sol\";\nimport \"@solarity/solidity-lib/libs/arrays/ArrayHelper.sol\";\nimport \"@solarity/solidity-lib/libs/data-structures/memory/Vector.sol\";\n\nimport \"../../interfaces/gov/user-keeper/IGovUserKeeper.sol\";\nimport \"../../interfaces/gov/IGovPool.sol\";\nimport \"../../interfaces/gov/ERC721/powers/IERC721Power.sol\";\n\nimport \"../../libs/math/MathHelper.sol\";\nimport \"../../libs/gov/gov-user-keeper/GovUserKeeperView.sol\";\n\ncontract GovUserKeeper is IGovUserKeeper, OwnableUpgradeable, ERC721HolderUpgradeable {\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n    using MathHelper for uint256;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using ArrayHelper for uint256[];\n    using Paginator for EnumerableSet.UintSet;\n    using DecimalsConverter for *;\n    using GovUserKeeperView for *;\n    using Vector for Vector.UintVector;\n\n    address public tokenAddress;\n    NFTInfo internal _nftInfo;\n\n    mapping(address => UserInfo) internal _usersInfo; // user => info\n\n    mapping(uint256 => uint256) internal _nftLockedNums; // tokenId => locked num\n\n    event SetERC20(address token);\n    event SetERC721(address token);\n\n    modifier withSupportedToken() {\n        _withSupportedToken();\n        _;\n    }\n\n    modifier withSupportedNft() {\n        _withSupportedNft();\n        _;\n    }\n\n    function __GovUserKeeper_init(\n        address _tokenAddress,\n        address _nftAddress,\n        uint256 individualPower,\n        uint256 nftsTotalSupply\n    ) external initializer {\n        __Ownable_init();\n        __ERC721Holder_init();\n\n        require(_tokenAddress != address(0) || _nftAddress != address(0), \"GovUK: zero addresses\");\n\n        if (_nftAddress != address(0)) {\n            _setERC721Address(_nftAddress, individualPower, nftsTotalSupply);\n        }\n\n        if (_tokenAddress != address(0)) {\n            _setERC20Address(_tokenAddress);\n        }\n    }\n\n    function depositTokens(\n        address payer,\n        address receiver,\n        uint256 amount\n    ) external override onlyOwner withSupportedToken {\n        address token = tokenAddress;\n\n        IERC20(token).safeTransferFrom(payer, address(this), amount.from18Safe(token));\n\n        _usersInfo[receiver].balances[IGovPool.VoteType.PersonalVote].tokens += amount;\n    }\n\n    function withdrawTokens(\n        address payer,\n        address receiver,\n        uint256 amount\n    ) external override onlyOwner withSupportedToken {\n        UserInfo storage payerInfo = _usersInfo[payer];\n        BalanceInfo storage payerBalanceInfo = payerInfo.balances[IGovPool.VoteType.PersonalVote];\n\n        address token = tokenAddress;\n        uint256 balance = payerBalanceInfo.tokens;\n        uint256 maxTokensLocked = payerInfo.maxTokensLocked;\n\n        require(\n            amount <= balance.max(maxTokensLocked) - maxTokensLocked,\n            \"GovUK: can't withdraw this\"\n        );\n\n        payerBalanceInfo.tokens = balance - amount;\n\n        IERC20(token).safeTransfer(receiver, amount.from18Safe(token));\n    }\n\n    function delegateTokens(\n        address delegator,\n        address delegatee,\n        uint256 amount\n    ) external override onlyOwner withSupportedToken {\n        UserInfo storage delegatorInfo = _usersInfo[delegator];\n        BalanceInfo storage delegatorBalanceInfo = delegatorInfo.balances[\n            IGovPool.VoteType.PersonalVote\n        ];\n\n        uint256 balance = delegatorBalanceInfo.tokens;\n        uint256 maxTokensLocked = delegatorInfo.maxTokensLocked;\n\n        require(amount <= balance.max(maxTokensLocked) - maxTokensLocked, \"GovUK: overdelegation\");\n\n        delegatorInfo.delegatedBalances[delegatee].tokens += amount;\n        delegatorInfo.allDelegatedBalance.tokens += amount;\n        delegatorBalanceInfo.tokens = balance - amount;\n\n        _usersInfo[delegatee].balances[IGovPool.VoteType.MicropoolVote].tokens += amount;\n\n        delegatorInfo.delegatees.add(delegatee);\n    }\n\n    function delegateTokensTreasury(\n        address delegatee,\n        uint256 amount\n    ) external override onlyOwner withSupportedToken {\n        _usersInfo[delegatee].balances[IGovPool.VoteType.TreasuryVote].tokens += amount;\n    }\n\n    function undelegateTokens(\n        address delegator,\n        address delegatee,\n        uint256 amount\n    ) external override onlyOwner withSupportedToken {\n        UserInfo storage delegatorInfo = _usersInfo[delegator];\n\n        require(\n            amount <= delegatorInfo.delegatedBalances[delegatee].tokens,\n            \"GovUK: amount exceeds delegation\"\n        );\n\n        _usersInfo[delegatee].balances[IGovPool.VoteType.MicropoolVote].tokens -= amount;\n\n        delegatorInfo.balances[IGovPool.VoteType.PersonalVote].tokens += amount;\n        delegatorInfo.delegatedBalances[delegatee].tokens -= amount;\n        delegatorInfo.allDelegatedBalance.tokens -= amount;\n\n        _cleanDelegatee(delegatorInfo, delegatee);\n    }\n\n    function undelegateTokensTreasury(\n        address delegatee,\n        uint256 amount\n    ) external override onlyOwner withSupportedToken {\n        BalanceInfo storage delegateeBalanceInfo = _usersInfo[delegatee].balances[\n            IGovPool.VoteType.TreasuryVote\n        ];\n\n        uint256 balance = delegateeBalanceInfo.tokens;\n\n        require(amount <= balance, \"GovUK: can't withdraw this\");\n\n        delegateeBalanceInfo.tokens = balance - amount;\n\n        address token = tokenAddress;\n\n        IERC20(token).safeTransfer(msg.sender, amount.from18Safe(token));\n    }\n\n    function depositNfts(\n        address payer,\n        address receiver,\n        uint256[] calldata nftIds\n    ) external override onlyOwner withSupportedNft {\n        EnumerableSet.UintSet storage receiverNftBalance = _usersInfo[receiver]\n            .balances[IGovPool.VoteType.PersonalVote]\n            .nfts;\n\n        IERC721Power nft = IERC721Power(_nftInfo.nftAddress);\n\n        for (uint256 i; i < nftIds.length; i++) {\n            uint256 nftId = nftIds[i];\n\n            nft.safeTransferFrom(payer, address(this), nftId);\n\n            receiverNftBalance.add(nftId);\n        }\n    }\n\n    function withdrawNfts(\n        address payer,\n        address receiver,\n        uint256[] calldata nftIds\n    ) external override onlyOwner withSupportedNft {\n        EnumerableSet.UintSet storage payerNftBalance = _usersInfo[payer]\n            .balances[IGovPool.VoteType.PersonalVote]\n            .nfts;\n\n        IERC721 nft = IERC721(_nftInfo.nftAddress);\n\n        for (uint256 i; i < nftIds.length; i++) {\n            uint256 nftId = nftIds[i];\n\n            require(\n                payerNftBalance.contains(nftId) && _nftLockedNums[nftId] == 0,\n                \"GovUK: NFT is not owned or locked\"\n            );\n\n            payerNftBalance.remove(nftId);\n\n            nft.safeTransferFrom(address(this), receiver, nftId);\n        }\n    }\n\n    function delegateNfts(\n        address delegator,\n        address delegatee,\n        uint256[] calldata nftIds\n    ) external override onlyOwner withSupportedNft {\n        UserInfo storage delegatorInfo = _usersInfo[delegator];\n        UserInfo storage delegateeInfo = _usersInfo[delegatee];\n\n        EnumerableSet.UintSet storage delegatorNftBalance = delegatorInfo\n            .balances[IGovPool.VoteType.PersonalVote]\n            .nfts;\n        EnumerableSet.UintSet storage delegatedNfts = delegatorInfo\n            .delegatedBalances[delegatee]\n            .nfts;\n        EnumerableSet.UintSet storage allDelegatedNfts = delegatorInfo.allDelegatedBalance.nfts;\n\n        EnumerableSet.UintSet storage delegateeNftBalance = delegateeInfo\n            .balances[IGovPool.VoteType.MicropoolVote]\n            .nfts;\n\n        IERC721Power nft = IERC721Power(_nftInfo.nftAddress);\n        bool isSupportPower = _nftInfo.isSupportPower;\n        uint256 nftPower;\n\n        for (uint256 i; i < nftIds.length; i++) {\n            uint256 nftId = nftIds[i];\n\n            require(\n                delegatorNftBalance.contains(nftId) && _nftLockedNums[nftId] == 0,\n                \"GovUK: NFT is not owned or locked\"\n            );\n\n            delegatorNftBalance.remove(nftId);\n\n            delegatedNfts.add(nftId);\n            allDelegatedNfts.add(nftId);\n\n            delegateeNftBalance.add(nftId);\n\n            if (isSupportPower) {\n                _nftInfo.nftMinPower[nftId] = nft.getNftMinPower(nftId);\n                nftPower += _nftInfo.nftMinPower[nftId];\n            }\n        }\n\n        delegatorInfo.delegatees.add(delegatee);\n\n        if (isSupportPower) {\n            delegatorInfo.delegatedNftPowers[delegatee] += nftPower;\n            delegateeInfo.nftsPowers[IGovPool.VoteType.MicropoolVote] += nftPower;\n        }\n    }\n\n    function delegateNftsTreasury(\n        address delegatee,\n        uint256[] calldata nftIds\n    ) external override onlyOwner withSupportedNft {\n        UserInfo storage delegateeInfo = _usersInfo[delegatee];\n        EnumerableSet.UintSet storage delegateeNftBalance = delegateeInfo\n            .balances[IGovPool.VoteType.TreasuryVote]\n            .nfts;\n\n        IERC721Power nft = IERC721Power(_nftInfo.nftAddress);\n        bool isSupportPower = _nftInfo.isSupportPower;\n        uint256 nftPower;\n\n        for (uint256 i; i < nftIds.length; i++) {\n            uint256 nftId = nftIds[i];\n\n            delegateeNftBalance.add(nftId);\n\n            if (isSupportPower) {\n                _nftInfo.nftMinPower[nftId] = nft.getNftMinPower(nftId);\n                nftPower += _nftInfo.nftMinPower[nftId];\n            }\n        }\n\n        if (isSupportPower) {\n            delegateeInfo.nftsPowers[IGovPool.VoteType.TreasuryVote] += nftPower;\n        }\n    }\n\n    function undelegateNfts(\n        address delegator,\n        address delegatee,\n        uint256[] calldata nftIds\n    ) external override onlyOwner withSupportedNft {\n        UserInfo storage delegatorInfo = _usersInfo[delegator];\n        UserInfo storage delegateeInfo = _usersInfo[delegatee];\n\n        EnumerableSet.UintSet storage delegatorNftBalance = delegatorInfo\n            .balances[IGovPool.VoteType.PersonalVote]\n            .nfts;\n        EnumerableSet.UintSet storage delegatedNfts = delegatorInfo\n            .delegatedBalances[delegatee]\n            .nfts;\n        EnumerableSet.UintSet storage allDelegatedNfts = delegatorInfo.allDelegatedBalance.nfts;\n\n        EnumerableSet.UintSet storage delegateeNftBalance = delegateeInfo\n            .balances[IGovPool.VoteType.MicropoolVote]\n            .nfts;\n\n        bool isSupportPower = _nftInfo.isSupportPower;\n        uint256 nftPower;\n\n        for (uint256 i; i < nftIds.length; i++) {\n            uint256 nftId = nftIds[i];\n\n            require(delegatedNfts.contains(nftId), \"GovUK: NFT is not delegated\");\n\n            delegateeNftBalance.remove(nftId);\n\n            delegatedNfts.remove(nftId);\n            allDelegatedNfts.remove(nftId);\n\n            delegatorNftBalance.add(nftId);\n\n            if (isSupportPower) {\n                nftPower += _nftInfo.nftMinPower[nftId];\n                delete _nftInfo.nftMinPower[nftId];\n            }\n        }\n\n        if (isSupportPower) {\n            delegatorInfo.delegatedNftPowers[delegatee] -= nftPower;\n            delegateeInfo.nftsPowers[IGovPool.VoteType.MicropoolVote] -= nftPower;\n        }\n\n        _cleanDelegatee(delegatorInfo, delegatee);\n    }\n\n    function undelegateNftsTreasury(\n        address delegatee,\n        uint256[] calldata nftIds\n    ) external override onlyOwner withSupportedNft {\n        UserInfo storage delegateeInfo = _usersInfo[delegatee];\n        EnumerableSet.UintSet storage delegateeNftBalance = delegateeInfo\n            .balances[IGovPool.VoteType.TreasuryVote]\n            .nfts;\n\n        IERC721 nft = IERC721(_nftInfo.nftAddress);\n        bool isSupportPower = _nftInfo.isSupportPower;\n        uint256 nftPower;\n\n        for (uint256 i; i < nftIds.length; i++) {\n            uint256 nftId = nftIds[i];\n\n            require(delegateeNftBalance.remove(nftId), \"GovUK: NFT is not owned\");\n\n            nft.safeTransferFrom(address(this), msg.sender, nftId);\n\n            if (isSupportPower) {\n                nftPower += _nftInfo.nftMinPower[nftId];\n                delete _nftInfo.nftMinPower[nftId];\n            }\n        }\n\n        if (isSupportPower) {\n            delegateeInfo.nftsPowers[IGovPool.VoteType.TreasuryVote] -= nftPower;\n        }\n    }\n\n    function updateMaxTokenLockedAmount(\n        uint256[] calldata lockedProposals,\n        address voter\n    ) external override onlyOwner {\n        UserInfo storage voterInfo = _usersInfo[voter];\n\n        uint256 lockedAmount = voterInfo.maxTokensLocked;\n        uint256 newLockedAmount;\n\n        for (uint256 i; i < lockedProposals.length; i++) {\n            newLockedAmount = newLockedAmount.max(voterInfo.lockedInProposals[lockedProposals[i]]);\n\n            if (newLockedAmount == lockedAmount) {\n                return;\n            }\n        }\n\n        voterInfo.maxTokensLocked = newLockedAmount;\n    }\n\n    function lockTokens(\n        uint256 proposalId,\n        address voter,\n        uint256 amount\n    ) external override onlyOwner {\n        UserInfo storage voterInfo = _usersInfo[voter];\n\n        voterInfo.lockedInProposals[proposalId] = amount;\n        voterInfo.maxTokensLocked = voterInfo.maxTokensLocked.max(\n            voterInfo.lockedInProposals[proposalId]\n        );\n    }\n\n    function unlockTokens(uint256 proposalId, address voter) external override onlyOwner {\n        delete _usersInfo[voter].lockedInProposals[proposalId];\n    }\n\n    function lockNfts(\n        address voter,\n        IGovPool.VoteType voteType,\n        uint256[] calldata nftIds\n    ) external override onlyOwner {\n        UserInfo storage voterInfo = _usersInfo[voter];\n        EnumerableSet.UintSet storage voteNftBalance = voterInfo\n            .balances[IGovPool.VoteType.PersonalVote]\n            .nfts;\n\n        for (uint256 i; i < nftIds.length; i++) {\n            uint256 nftId = nftIds[i];\n\n            bool hasNft = voteNftBalance.contains(nftId);\n\n            if (voteType == IGovPool.VoteType.DelegatedVote) {\n                hasNft = hasNft || voterInfo.allDelegatedBalance.nfts.contains(nftId);\n            }\n\n            require(hasNft, \"GovUK: NFT is not owned\");\n\n            _nftLockedNums[nftId]++;\n        }\n    }\n\n    function unlockNfts(uint256[] calldata nftIds) external override onlyOwner {\n        for (uint256 i; i < nftIds.length; i++) {\n            uint256 nftId = nftIds[i];\n\n            require(_nftLockedNums[nftId] > 0, \"GovUK: NFT is not locked\");\n\n            _nftLockedNums[nftId]--;\n        }\n    }\n\n    function updateNftPowers(uint256[] calldata nftIds) external override onlyOwner {\n        if (!_nftInfo.isSupportPower) {\n            return;\n        }\n\n        IERC721Power(_nftInfo.nftAddress).recalculateNftPowers(nftIds);\n    }\n\n    function setERC20Address(address _tokenAddress) external override onlyOwner {\n        _setERC20Address(_tokenAddress);\n    }\n\n    function setERC721Address(\n        address _nftAddress,\n        uint256 individualPower,\n        uint256 nftsTotalSupply\n    ) external override onlyOwner {\n        _setERC721Address(_nftAddress, individualPower, nftsTotalSupply);\n    }\n\n    function nftAddress() external view override returns (address) {\n        return _nftInfo.nftAddress;\n    }\n\n    function getNftInfo()\n        external\n        view\n        override\n        returns (bool isSupportPower, uint256 individualPower, uint256 totalSupply)\n    {\n        return (_nftInfo.isSupportPower, _nftInfo.individualPower, _nftInfo.totalSupply);\n    }\n\n    function maxLockedAmount(address voter) external view override returns (uint256) {\n        return _usersInfo[voter].maxTokensLocked;\n    }\n\n    function tokenBalance(\n        address voter,\n        IGovPool.VoteType voteType\n    ) public view override returns (uint256 totalBalance, uint256 ownedBalance) {\n        if (tokenAddress == address(0)) {\n            return (0, 0);\n        }\n\n        totalBalance = _getBalanceInfoStorage(voter, voteType).tokens;\n\n        if (\n            voteType != IGovPool.VoteType.PersonalVote &&\n            voteType != IGovPool.VoteType.DelegatedVote\n        ) {\n            return (totalBalance, 0);\n        }\n\n        if (voteType == IGovPool.VoteType.DelegatedVote) {\n            totalBalance += _usersInfo[voter].allDelegatedBalance.tokens;\n        }\n\n        ownedBalance = ERC20(tokenAddress).balanceOf(voter).to18(tokenAddress);\n        totalBalance += ownedBalance;\n    }\n\n    function nftBalance(\n        address voter,\n        IGovPool.VoteType voteType\n    ) external view override returns (uint256 totalBalance, uint256 ownedBalance) {\n        address nftAddress_ = _nftInfo.nftAddress;\n\n        if (nftAddress_ == address(0)) {\n            return (0, 0);\n        }\n\n        totalBalance = _getBalanceInfoStorage(voter, voteType).nfts.length();\n\n        if (\n            voteType != IGovPool.VoteType.PersonalVote &&\n            voteType != IGovPool.VoteType.DelegatedVote\n        ) {\n            return (totalBalance, 0);\n        }\n\n        if (voteType == IGovPool.VoteType.DelegatedVote) {\n            totalBalance += _usersInfo[voter].allDelegatedBalance.nfts.length();\n        }\n\n        ownedBalance = IERC721Upgradeable(nftAddress_).balanceOf(voter);\n        totalBalance += ownedBalance;\n    }\n\n    function nftExactBalance(\n        address voter,\n        IGovPool.VoteType voteType\n    ) public view override returns (uint256[] memory nfts, uint256 ownedLength) {\n        address nftAddress_ = _nftInfo.nftAddress;\n\n        if (nftAddress_ == address(0)) {\n            return (nfts, 0);\n        }\n\n        Vector.UintVector memory nftsVector = Vector.newUint(\n            _getBalanceInfoStorage(voter, voteType).nfts.values()\n        );\n\n        if (\n            voteType != IGovPool.VoteType.PersonalVote &&\n            voteType != IGovPool.VoteType.DelegatedVote\n        ) {\n            return (nftsVector.toArray(), 0);\n        }\n\n        if (voteType == IGovPool.VoteType.DelegatedVote) {\n            nftsVector.push(_usersInfo[voter].allDelegatedBalance.nfts.values());\n        }\n\n        ownedLength = IERC721Upgradeable(nftAddress_).balanceOf(voter);\n\n        if (_nftInfo.totalSupply != 0) {\n            nftsVector.push(new uint256[](ownedLength));\n\n            return (nftsVector.toArray(), ownedLength);\n        }\n\n        IERC721Power nftContract = IERC721Power(nftAddress_);\n\n        for (uint256 i; i < ownedLength; i++) {\n            nftsVector.push(nftContract.tokenOfOwnerByIndex(voter, i));\n        }\n\n        return (nftsVector.toArray(), ownedLength);\n    }\n\n    function getTotalNftsPower(\n        uint256[] memory nftIds,\n        IGovPool.VoteType voteType,\n        address voter,\n        bool perNftPowerArray\n    ) public view override returns (uint256 nftPower, uint256[] memory perNftPower) {\n        return _usersInfo.getTotalNftsPower(_nftInfo, nftIds, voteType, voter, perNftPowerArray);\n    }\n\n    function getTotalPower() external view override returns (uint256 power) {\n        address token = tokenAddress;\n\n        if (token != address(0)) {\n            power = IERC20(token).totalSupply().to18(token);\n        }\n\n        token = _nftInfo.nftAddress;\n\n        if (token != address(0)) {\n            if (!_nftInfo.isSupportPower) {\n                power +=\n                    _nftInfo.individualPower *\n                    (\n                        _nftInfo.totalSupply == 0\n                            ? IERC721Power(token).totalSupply()\n                            : _nftInfo.totalSupply\n                    );\n            } else {\n                power += IERC721Power(token).totalPower();\n            }\n        }\n    }\n\n    function canCreate(\n        address voter,\n        IGovPool.VoteType voteType,\n        uint256 requiredVotes\n    ) external view override returns (bool) {\n        (uint256 tokens, uint256 ownedBalance) = tokenBalance(voter, voteType);\n        (uint256 tokensMicropool, ) = tokenBalance(voter, IGovPool.VoteType.MicropoolVote);\n        (uint256 tokensTreasury, ) = tokenBalance(voter, IGovPool.VoteType.TreasuryVote);\n\n        tokens = tokens + tokensMicropool + tokensTreasury - ownedBalance;\n\n        if (tokens >= requiredVotes) {\n            return true;\n        }\n\n        (uint256[] memory nftIds, uint256 owned) = nftExactBalance(voter, voteType);\n\n        nftIds.crop(nftIds.length - owned);\n\n        (uint256 personalNftPower, ) = getTotalNftsPower(\n            nftIds,\n            IGovPool.VoteType.PersonalVote,\n            address(0),\n            false\n        );\n        (uint256 micropoolNftPower, ) = getTotalNftsPower(\n            new uint256[](0),\n            IGovPool.VoteType.MicropoolVote,\n            voter,\n            false\n        );\n        (uint256 treasuryNftPower, ) = getTotalNftsPower(\n            new uint256[](0),\n            IGovPool.VoteType.TreasuryVote,\n            voter,\n            false\n        );\n\n        return tokens + personalNftPower + micropoolNftPower + treasuryNftPower >= requiredVotes"
    }
  ]
}