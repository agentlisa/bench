{
  "Title": "[G-17] Revert strings length",
  "Content": "\nRevert strings cost more gas to deploy if the string is larger than 32 bytes. It costs an extra `9,500` gas per string exceeding that 32-byte size upon deployment.\n\n### Proof of Concept\n\nRevert strings exceeding 32 bytes include instances:\n\n##### src/utils/MerkleBase.sol\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L62>\n\n```cpp\n62:         require(_data.length > 1, \"wont generate root for single leaf\");\n```\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L78>\n\n```cpp\n78:         require(_data.length > 1, \"wont generate root for single leaf\");\n```\n\n### Recommended Mitigation Steps\n\nWrite the error strings so that they do not exceed 32 bytes. For further gas savings, consider also using [custom errors](#custom-errors).\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-07-fractional-v2-contest",
  "Code": [
    {
      "filename": "src/utils/MerkleBase.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n/// @title Merkle Base\n/// @author Modified from Murky (https://github.com/dmfxyz/murky/blob/main/src/common/MurkyBase.sol)\n/// @notice Utility contract for generating merkle roots and verifying proofs\nabstract contract MerkleBase {\n    constructor() {}\n\n    /// @notice Hashes two leaf pairs\n    /// @param _left Node on left side of tree level\n    /// @param _right Node on right side of tree level\n    /// @return data Result hash of node params\n    function hashLeafPairs(bytes32 _left, bytes32 _right)\n        public\n        pure\n        returns (bytes32 data)\n    {\n        // Return opposite node if checked node is of bytes zero value\n        if (_left == bytes32(0)) return _right;\n        if (_right == bytes32(0)) return _left;\n\n        assembly {\n            // TODO: This can be aesthetically simplified with a switch. Not sure it will\n            // save much gas but there are other optimizations to be had in here.\n            if or(lt(_left, _right), eq(_left, _right)) {\n                mstore(0x0, _left)\n                mstore(0x20, _right)\n            }\n            if gt(_left, _right) {\n                mstore(0x0, _right)\n                mstore(0x20, _left)\n            }\n            data := keccak256(0x0, 0x40)\n        }\n    }\n\n    /// @notice Verifies the merkle proof of a given value\n    /// @param _root Hash of merkle root\n    /// @param _proof Merkle proof\n    /// @param _valueToProve Leaf node being proven\n    /// @return Status of proof verification\n    function verifyProof(\n        bytes32 _root,\n        bytes32[] memory _proof,\n        bytes32 _valueToProve\n    ) public pure returns (bool) {\n        // proof length must be less than max array size\n        bytes32 rollingHash = _valueToProve;\n        unchecked {\n            for (uint256 i = 0; i < _proof.length; ++i) {\n                rollingHash = hashLeafPairs(rollingHash, _proof[i]);\n            }\n        }\n        return _root == rollingHash;\n    }\n\n    /// @notice Generates the merkle root of a tree\n    /// @param _data Leaf nodes of the merkle tree\n    /// @return Hash of merkle root\n    function getRoot(bytes32[] memory _data) public pure returns (bytes32) {\n        require(_data.length > 1, \"wont generate root for single leaf\");\n        while (_data.length > 1) {\n            _data = hashLevel(_data);\n        }\n        return _data[0];\n    }\n\n    /// @notice Generates the merkle proof for a leaf node in a given tree\n    /// @param _data Leaf nodes of the merkle tree\n    /// @param _node Index of the node in the tree\n    /// @return Merkle proof\n    function getProof(bytes32[] memory _data, uint256 _node)\n        public\n        pure\n        returns (bytes32[] memory)\n    {\n        require(_data.length > 1, \"wont generate proof for single leaf\");\n        // The size of the proof is equal to the ceiling of log2(numLeaves)\n        uint256 size = log2ceil_naive(_data.length);\n        bytes32[] memory result = new bytes32[](size);\n        uint256 pos;\n        uint256 counter;\n\n        // Two overflow risks: node, pos\n        // node: max array size is 2**256-1. Largest index in the array will be 1 less than that. Also,\n        // for dynamic arrays, size is limited to 2**64-1\n        // pos: pos is bounded by log2(data.length), which should be less than type(uint256).max\n        while (_data.length > 1) {\n            unchecked {\n                if (_node % 2 == 1) {\n                    result[pos] = _data[_node - 1];\n                } else if (_node + 1 == _data.length) {\n                    result[pos] = bytes32(0);\n                    ++counter;\n                } else {\n                    result[pos] = _data[_node + 1];\n                }\n                ++pos;\n                _node = _node / 2;\n            }\n            _data = hashLevel(_data);\n        }\n\n        // Dynamic array to filter out address(0) since proof size is rounded up\n        // This is done to return the actual proof size of the indexed node\n        bytes32[] memory arr = new bytes32[](size - counter);\n        unchecked {\n            uint256 offset;\n            for (uint256 i; i < result.length; ++i) {\n                if (result[i] != bytes32(0)) {\n                    arr[i - offset] = result[i];\n                } else {\n                    ++offset;\n                }\n            }\n        }\n\n        return arr;\n    }\n\n    /// @dev Hashes nodes at the given tree level\n    /// @param _data Nodes at the current level\n    /// @return result Hashes of nodes at the next level\n    function hashLevel(bytes32[] memory _data)\n        private\n        pure\n        returns (bytes32[] memory result)\n    {\n        // Function is private, and all internal callers check that data.length >=2.\n        // Underflow is not possible as lowest possible value for data/result index is 1\n        // overflow should be safe as length is / 2 always.\n        unchecked {\n            uint256 length = _data.length;\n            if (length & 0x1 == 1) {\n                result = new bytes32[](length / 2 + 1);\n                result[result.length - 1] = hashLeafPairs(\n                    _data[length - 1],\n                    bytes32(0)\n                );\n            } else {\n                result = new bytes32[](length / 2);\n            }\n\n            // pos is upper bounded by data.length / 2, so safe even if array is at max size\n            uint256 pos;\n            for (uint256 i; i < length - 1; i += 2) {\n                result[pos] = hashLeafPairs(_data[i], _data[i + 1]);\n                ++pos;\n            }\n        }\n    }\n\n    /// @notice Calculates proof size based on size of tree\n    /// @dev Note that x is assumed > 0 and proof size is not precise\n    /// @param x Size of the merkle tree\n    /// @return ceil Rounded value of proof size\n    function log2ceil_naive(uint256 x) public pure returns (uint256 ceil) {\n        uint256 pOf2;\n        // If x is a power of 2, then this function will return a ceiling\n        // that is 1 greater than the actual ceiling. So we need to check if\n        // x is a power of 2, and subtract one from ceil if so.\n        assembly {\n            // we check by seeing if x == (~x + 1) & x. This applies a mask\n            // to find the lowest set bit of x and then checks it for equality\n            // with x. If they are equal, then x is a power of 2.\n\n            /* Example\n                x has single bit set\n                x := 0000_1000\n                (~x + 1) = (1111_0111) + 1 = 1111_1000\n                (1111_1000 & 0000_1000) = 0000_1000 == x\n                x has multiple bits set\n                x := 1001_0010\n                (~x + 1) = (0110_1101 + 1) = 0110_1110\n                (0110_1110 & x) = 0000_0010 != x\n            */\n\n            // we do some assembly magic to treat the bool as an integer later on\n            pOf2 := eq(and(add(not(x), 1), x), x)\n        }\n\n        // if x == type(uint256).max, than ceil is capped at 256\n        // if x == 0, then pO2 == 0, so ceil won't underflow\n        unchecked {\n            while (x > 0) {\n                x >>= 1;\n                ceil++;\n            }\n            ceil -= pOf2; // see above\n        }\n    }\n}"
    },
    {
      "filename": "src/utils/MerkleBase.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n/// @title Merkle Base\n/// @author Modified from Murky (https://github.com/dmfxyz/murky/blob/main/src/common/MurkyBase.sol)\n/// @notice Utility contract for generating merkle roots and verifying proofs\nabstract contract MerkleBase {\n    constructor() {}\n\n    /// @notice Hashes two leaf pairs\n    /// @param _left Node on left side of tree level\n    /// @param _right Node on right side of tree level\n    /// @return data Result hash of node params\n    function hashLeafPairs(bytes32 _left, bytes32 _right)\n        public\n        pure\n        returns (bytes32 data)\n    {\n        // Return opposite node if checked node is of bytes zero value\n        if (_left == bytes32(0)) return _right;\n        if (_right == bytes32(0)) return _left;\n\n        assembly {\n            // TODO: This can be aesthetically simplified with a switch. Not sure it will\n            // save much gas but there are other optimizations to be had in here.\n            if or(lt(_left, _right), eq(_left, _right)) {\n                mstore(0x0, _left)\n                mstore(0x20, _right)\n            }\n            if gt(_left, _right) {\n                mstore(0x0, _right)\n                mstore(0x20, _left)\n            }\n            data := keccak256(0x0, 0x40)\n        }\n    }\n\n    /// @notice Verifies the merkle proof of a given value\n    /// @param _root Hash of merkle root\n    /// @param _proof Merkle proof\n    /// @param _valueToProve Leaf node being proven\n    /// @return Status of proof verification\n    function verifyProof(\n        bytes32 _root,\n        bytes32[] memory _proof,\n        bytes32 _valueToProve\n    ) public pure returns (bool) {\n        // proof length must be less than max array size\n        bytes32 rollingHash = _valueToProve;\n        unchecked {\n            for (uint256 i = 0; i < _proof.length; ++i) {\n                rollingHash = hashLeafPairs(rollingHash, _proof[i]);\n            }\n        }\n        return _root == rollingHash;\n    }\n\n    /// @notice Generates the merkle root of a tree\n    /// @param _data Leaf nodes of the merkle tree\n    /// @return Hash of merkle root\n    function getRoot(bytes32[] memory _data) public pure returns (bytes32) {\n        require(_data.length > 1, \"wont generate root for single leaf\");\n        while (_data.length > 1) {\n            _data = hashLevel(_data);\n        }\n        return _data[0];\n    }\n\n    /// @notice Generates the merkle proof for a leaf node in a given tree\n    /// @param _data Leaf nodes of the merkle tree\n    /// @param _node Index of the node in the tree\n    /// @return Merkle proof\n    function getProof(bytes32[] memory _data, uint256 _node)\n        public\n        pure\n        returns (bytes32[] memory)\n    {\n        require(_data.length > 1, \"wont generate proof for single leaf\");\n        // The size of the proof is equal to the ceiling of log2(numLeaves)\n        uint256 size = log2ceil_naive(_data.length);\n        bytes32[] memory result = new bytes32[](size);\n        uint256 pos;\n        uint256 counter;\n\n        // Two overflow risks: node, pos\n        // node: max array size is 2**256-1. Largest index in the array will be 1 less than that. Also,\n        // for dynamic arrays, size is limited to 2**64-1\n        // pos: pos is bounded by log2(data.length), which should be less than type(uint256).max\n        while (_data.length > 1) {\n            unchecked {\n                if (_node % 2 == 1) {\n                    result[pos] = _data[_node - 1];\n                } else if (_node + 1 == _data.length) {\n                    result[pos] = bytes32(0);\n                    ++counter;\n                } else {\n                    result[pos] = _data[_node + 1];\n                }\n                ++pos;\n                _node = _node / 2;\n            }\n            _data = hashLevel(_data);\n        }\n\n        // Dynamic array to filter out address(0) since proof size is rounded up\n        // This is done to return the actual proof size of the indexed node\n        bytes32[] memory arr = new bytes32[](size - counter);\n        unchecked {\n            uint256 offset;\n            for (uint256 i; i < result.length; ++i) {\n                if (result[i] != bytes32(0)) {\n                    arr[i - offset] = result[i];\n                } else {\n                    ++offset;\n                }\n            }\n        }\n\n        return arr;\n    }\n\n    /// @dev Hashes nodes at the given tree level\n    /// @param _data Nodes at the current level\n    /// @return result Hashes of nodes at the next level\n    function hashLevel(bytes32[] memory _data)\n        private\n        pure\n        returns (bytes32[] memory result)\n    {\n        // Function is private, and all internal callers check that data.length >=2.\n        // Underflow is not possible as lowest possible value for data/result index is 1\n        // overflow should be safe as length is / 2 always.\n        unchecked {\n            uint256 length = _data.length;\n            if (length & 0x1 == 1) {\n                result = new bytes32[](length / 2 + 1);\n                result[result.length - 1] = hashLeafPairs(\n                    _data[length - 1],\n                    bytes32(0)\n                );\n            } else {\n                result = new bytes32[](length / 2);\n            }\n\n            // pos is upper bounded by data.length / 2, so safe even if array is at max size\n            uint256 pos;\n            for (uint256 i; i < length - 1; i += 2) {\n                result[pos] = hashLeafPairs(_data[i], _data[i + 1]);\n                ++pos;\n            }\n        }\n    }\n\n    /// @notice Calculates proof size based on size of tree\n    /// @dev Note that x is assumed > 0 and proof size is not precise\n    /// @param x Size of the merkle tree\n    /// @return ceil Rounded value of proof size\n    function log2ceil_naive(uint256 x) public pure returns (uint256 ceil) {\n        uint256 pOf2;\n        // If x is a power of 2, then this function will return a ceiling\n        // that is 1 greater than the actual ceiling. So we need to check if\n        // x is a power of 2, and subtract one from ceil if so.\n        assembly {\n            // we check by seeing if x == (~x + 1) & x. This applies a mask\n            // to find the lowest set bit of x and then checks it for equality\n            // with x. If they are equal, then x is a power of 2.\n\n            /* Example\n                x has single bit set\n                x := 0000_1000\n                (~x + 1) = (1111_0111) + 1 = 1111_1000\n                (1111_1000 & 0000_1000) = 0000_1000 == x\n                x has multiple bits set\n                x := 1001_0010\n                (~x + 1) = (0110_1101 + 1) = 0110_1110\n                (0110_1110 & x) = 0000_0010 != x\n            */\n\n            // we do some assembly magic to treat the bool as an integer later on\n            pOf2 := eq(and(add(not(x), 1), x), x)\n        }\n\n        // if x == type(uint256).max, than ceil is capped at 256\n        // if x == 0, then pO2 == 0, so ceil won't underflow\n        unchecked {\n            while (x > 0) {\n                x >>= 1;\n                ceil++;\n            }\n            ceil -= pOf2; // see above\n        }\n    }\n}"
    }
  ]
}