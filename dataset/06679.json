{
  "Title": "[M-06] `validateSignature(...)` in `EllipticCurve` mixes up Jacobian and projective coordinates",
  "Content": "\nCurrently not exploitable because this bug is cancelled out by another issue (see my Gas report). If the other issue is fixed `validateSignature` will return completely incorrect values.\n\n### Details\n\nIn <https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/algorithms/EllipticCurve.sol#L415> `validateSignature` converts to affine coordinates from Jacobian coordinates, i.e. $X_a = X_j \\cdot (Z_j^{-1})^2$.\n\nHowever, the inputs from the previous computation <https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/algorithms/EllipticCurve.sol#L408> are actually projective coordinates and the correct conversion formula is $X_a = X_p \\cdot Z_p^{-1}$.\n\nThis has been working so far only because the `EllipticCurve` performs a redundant chain of immediate conversions projective->affine->projective->affine and so during that last conversion $Z = 1$. Should the chain of redundant conversions be fixed, `validateSignature` will no longer work correctly.\n\n### Recommended Mitigation Steps\n\nTo just fix this bug:\n\n```diff\ndiff --git a/contracts/dnssec-oracle/algorithms/EllipticCurve.sol b/contracts/dnssec-oracle/algorithms/EllipticCurve.sol\nindex 6861264..ea7e865 100644\n--- a/contracts/dnssec-oracle/algorithms/EllipticCurve.sol\n+++ b/contracts/dnssec-oracle/algorithms/EllipticCurve.sol\n@@ -412,7 +412,7 @@ contract EllipticCurve {\n         }\n \n         uint256 Px = inverseMod(P[2], p);\n-        Px = mulmod(P[0], mulmod(Px, Px, p), p);\n+        Px = mulmod(P[0], Px, p);\n \n         return Px % n == rs[0];\n     }\n\n```\n\nOr to fix this bug and optimize out the redundant conversions chain:\n\n```diff\ndiff --git a/contracts/dnssec-oracle/algorithms/EllipticCurve.sol b/contracts/dnssec-oracle/algorithms/EllipticCurve.sol\nindex 6861264..8568be2 100644\n--- a/contracts/dnssec-oracle/algorithms/EllipticCurve.sol\n+++ b/contracts/dnssec-oracle/algorithms/EllipticCurve.sol\n@@ -405,14 +405,13 @@ contract EllipticCurve {\n         uint256 sInv = inverseMod(rs[1], n);\n         (x1, y1) = multiplyScalar(gx, gy, mulmod(uint256(message), sInv, n));\n         (x2, y2) = multiplyScalar(Q[0], Q[1], mulmod(rs[0], sInv, n));\n-        uint256[3] memory P = addAndReturnProjectivePoint(x1, y1, x2, y2);\n+        (uint256 Px,, uint256 Pz) = addProj(x1, y1, 1, x2, y2, 1);\n \n-        if (P[2] == 0) {\n+        if (Pz == 0) {\n             return false;\n         }\n \n-        uint256 Px = inverseMod(P[2], p);\n-        Px = mulmod(P[0], mulmod(Px, Px, p), p);\n+        Px = mulmod(Px, inverseMod(Pz, p), p);\n \n         return Px % n == rs[0];\n     }\n```\n\n**[Arachnid (ENS) confirmed](https://github.com/code-423n4/2023-04-ens-findings/issues/180#issuecomment-1536298235)**\n\n**[d3e4 (warden) commented](https://github.com/code-423n4/2023-04-ens-findings/issues/180#issuecomment-1544801992):**\n > I agree that EllipticCurve.sol is somewhat of a bodge. It's correct what the warden says in that \"`EllipticCurve` mixes up\" something. But actually it adds affine points and then trivially converts them to jacobian/projective coordinates. Since they are trivial they are the same in jacobian as in projective, so one could say that it's as much a misnamed function as a confused computation.\n> \n> But it's also correct what the warden himself said that it is \"currently not exploitable\". In fact, I'm quite sure it's not exploitable even if \"the other issue is fixed\". Then it will just invalidate every signature.\n> \n> Both recommendations here are therefore just gas savings and refactoring. `mulmod(Px, Px, p)` is indeed a redundant computation, because `Px == 1` always here. But so is `inverseMod(P[2], p)` redundant. The first recommendation can be simplified even further to just\n> ```diff\n> - uint256 Px = inverseMod(P[2], p);\n> - Px = mulmod(P[0], mulmod(Px, Px, p), p);\n>  \n> - return Px % n == rs[0];\n> + return P[0] % n == rs[0];\n> ```\n> instead, since `P[2] == 1`.\n> \n> The second recommendation is a better optimisation but still does redundant conversions in `multiplyScalar`, which also should be corrected then. The whole point of using projective coordinates is to do the modular inverse (i.e. convert to affine) only at the end.\n> \n> In any case, there is nothing exploitable here, no funds or functionality are at risk. The code does what it's supposed to do as it is, just not in the prettiest way. And the way in which the hypothetical issue is proposed to arise is by fixing the very same thing that the hypothetical issue is itself based on, i.e. it is said that fixing the needless conversion between coordinate representations causes an error due to coordinate conversions. One should assume that reworking the coordinate handling would fix all coordinate issues. And if the bug described here were to arise in the suggested manner, it would be immediately noticed in testing.\n> \n> _This is a bug that is not yet a bug but could be a bug that is impossible to miss if someone were to create this bug so it's never going to actually be a bug._\n> \n> I think this is a good catch, but the severity is only QA/Gas.\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2023-04-ens-findings/issues/180#issuecomment-1545670843):**\n > I agree with @d3e4 that the bug is highly unlikely to make it to production without being caught. In this case, however, if it were to make it into production, the \"function of the protocol or availability could be impacted\". That makes this a valid medium in my view. I agree with the warden and sponsor.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-04-ens",
  "Code": [
    {
      "filename": "contracts/dnssec-oracle/algorithms/EllipticCurve.sol",
      "content": "pragma solidity ^0.8.4;\n\n/**\n * @title   EllipticCurve\n *\n * @author  Tilman Drerup;\n *\n * @notice  Implements elliptic curve math; Parametrized for SECP256R1.\n *\n *          Includes components of code by Andreas Olofsson, Alexander Vlasov\n *          (https://github.com/BANKEX/CurveArithmetics), and Avi Asayag\n *          (https://github.com/orbs-network/elliptic-curve-solidity)\n *\n *          Source: https://github.com/tdrerup/elliptic-curve-solidity\n *\n * @dev     NOTE: To disambiguate public keys when verifying signatures, activate\n *          condition 'rs[1] > lowSmax' in validateSignature().\n */\ncontract EllipticCurve {\n    // Set parameters for curve.\n    uint256 constant a =\n        0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC;\n    uint256 constant b =\n        0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B;\n    uint256 constant gx =\n        0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296;\n    uint256 constant gy =\n        0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5;\n    uint256 constant p =\n        0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF;\n    uint256 constant n =\n        0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551;\n\n    uint256 constant lowSmax =\n        0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0;\n\n    /**\n     * @dev Inverse of u in the field of modulo m.\n     */\n    function inverseMod(uint256 u, uint256 m) internal pure returns (uint256) {\n        unchecked {\n            if (u == 0 || u == m || m == 0) return 0;\n            if (u > m) u = u % m;\n\n            int256 t1;\n            int256 t2 = 1;\n            uint256 r1 = m;\n            uint256 r2 = u;\n            uint256 q;\n\n            while (r2 != 0) {\n                q = r1 / r2;\n                (t1, t2, r1, r2) = (t2, t1 - int256(q) * t2, r2, r1 - q * r2);\n            }\n\n            if (t1 < 0) return (m - uint256(-t1));\n\n            return uint256(t1);\n        }\n    }\n\n    /**\n     * @dev Transform affine coordinates into projective coordinates.\n     */\n    function toProjectivePoint(\n        uint256 x0,\n        uint256 y0\n    ) internal pure returns (uint256[3] memory P) {\n        P[2] = addmod(0, 1, p);\n        P[0] = mulmod(x0, P[2], p);\n        P[1] = mulmod(y0, P[2], p);\n    }\n\n    /**\n     * @dev Add two points in affine coordinates and return projective point.\n     */\n    function addAndReturnProjectivePoint(\n        uint256 x1,\n        uint256 y1,\n        uint256 x2,\n        uint256 y2\n    ) internal pure returns (uint256[3] memory P) {\n        uint256 x;\n        uint256 y;\n        (x, y) = add(x1, y1, x2, y2);\n        P = toProjectivePoint(x, y);\n    }\n\n    /**\n     * @dev Transform from projective to affine coordinates.\n     */\n    function toAffinePoint(\n        uint256 x0,\n        uint256 y0,\n        uint256 z0\n    ) internal pure returns (uint256 x1, uint256 y1) {\n        uint256 z0Inv;\n        z0Inv = inverseMod(z0, p);\n        x1 = mulmod(x0, z0Inv, p);\n        y1 = mulmod(y0, z0Inv, p);\n    }\n\n    /**\n     * @dev Return the zero curve in projective coordinates.\n     */\n    function zeroProj()\n        internal\n        pure\n        returns (uint256 x, uint256 y, uint256 z)\n    {\n        return (0, 1, 0);\n    }\n\n    /**\n     * @dev Return the zero curve in affine coordinates.\n     */\n    function zeroAffine() internal pure returns (uint256 x, uint256 y) {\n        return (0, 0);\n    }\n\n    /**\n     * @dev Check if the curve is the zero curve.\n     */\n    function isZeroCurve(\n        uint256 x0,\n        uint256 y0\n    ) internal pure returns (bool isZero) {\n        if (x0 == 0 && y0 == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @dev Check if a point in affine coordinates is on the curve.\n     */\n    function isOnCurve(uint256 x, uint256 y) internal pure returns (bool) {\n        if (0 == x || x == p || 0 == y || y == p) {\n            return false;\n        }\n\n        uint256 LHS = mulmod(y, y, p); // y^2\n        uint256 RHS = mulmod(mulmod(x, x, p), x, p); // x^3\n\n        if (a != 0) {\n            RHS = addmod(RHS, mulmod(x, a, p), p); // x^3 + a*x\n        }\n        if (b != 0) {\n            RHS = addmod(RHS, b, p); // x^3 + a*x + b\n        }\n\n        return LHS == RHS;\n    }\n\n    /**\n     * @dev Double an elliptic curve point in projective coordinates. See\n     * https://www.nayuki.io/page/elliptic-curve-point-addition-in-projective-coordinates\n     */\n    function twiceProj(\n        uint256 x0,\n        uint256 y0,\n        uint256 z0\n    ) internal pure returns (uint256 x1, uint256 y1, uint256 z1) {\n        uint256 t;\n        uint256 u;\n        uint256 v;\n        uint256 w;\n\n        if (isZeroCurve(x0, y0)) {\n            return zeroProj();\n        }\n\n        u = mulmod(y0, z0, p);\n        u = mulmod(u, 2, p);\n\n        v = mulmod(u, x0, p);\n        v = mulmod(v, y0, p);\n        v = mulmod(v, 2, p);\n\n        x0 = mulmod(x0, x0, p);\n        t = mulmod(x0, 3, p);\n\n        z0 = mulmod(z0, z0, p);\n        z0 = mulmod(z0, a, p);\n        t = addmod(t, z0, p);\n\n        w = mulmod(t, t, p);\n        x0 = mulmod(2, v, p);\n        w = addmod(w, p - x0, p);\n\n        x0 = addmod(v, p - w, p);\n        x0 = mulmod(t, x0, p);\n        y0 = mulmod(y0, u, p);\n        y0 = mulmod(y0, y0, p);\n        y0 = mulmod(2, y0, p);\n        y1 = addmod(x0, p - y0, p);\n\n        x1 = mulmod(u, w, p);\n\n        z1 = mulmod(u, u, p);\n        z1 = mulmod(z1, u, p);\n    }\n\n    /**\n     * @dev Add two elliptic curve points in projective coordinates. See\n     * https://www.nayuki.io/page/elliptic-curve-point-addition-in-projective-coordinates\n     */\n    function addProj(\n        uint256 x0,\n        uint256 y0,\n        uint256 z0,\n        uint256 x1,\n        uint256 y1,\n        uint256 z1\n    ) internal pure returns (uint256 x2, uint256 y2, uint256 z2) {\n        uint256 t0;\n        uint256 t1;\n        uint256 u0;\n        uint256 u1;\n\n        if (isZeroCurve(x0, y0)) {\n            return (x1, y1, z1);\n        } else if (isZeroCurve(x1, y1)) {\n            return (x0, y0, z0);\n        }\n\n        t0 = mulmod(y0, z1, p);\n        t1 = mulmod(y1, z0, p);\n\n        u0 = mulmod(x0, z1, p);\n        u1 = mulmod(x1, z0, p);\n\n        if (u0 == u1) {\n            if (t0 == t1) {\n                return twiceProj(x0, y0, z0);\n            } else {\n                return zeroProj();\n            }\n        }\n\n        (x2, y2, z2) = addProj2(mulmod(z0, z1, p), u0, u1, t1, t0);\n    }\n\n    /**\n     * @dev Helper function that splits addProj to avoid too many local variables.\n     */\n    function addProj2(\n        uint256 v,\n        uint256 u0,\n        uint256 u1,\n        uint256 t1,\n        uint256 t0\n    ) private pure returns (uint256 x2, uint256 y2, uint256 z2) {\n        uint256 u;\n        uint256 u2;\n        uint256 u3;\n        uint256 w;\n        uint256 t;\n\n        t = addmod(t0, p - t1, p);\n        u = addmod(u0, p - u1, p);\n        u2 = mulmod(u, u, p);\n\n        w = mulmod(t, t, p);\n        w = mulmod(w, v, p);\n        u1 = addmod(u1, u0, p);\n        u1 = mulmod(u1, u2, p);\n        w = addmod(w, p - u1, p);\n\n        x2 = mulmod(u, w, p);\n\n        u3 = mulmod(u2, u, p);\n        u0 = mulmod(u0, u2, p);\n        u0 = addmod(u0, p - w, p);\n        t = mulmod(t, u0, p);\n        t0 = mulmod(t0, u3, p);\n\n        y2 = addmod(t, p - t0, p);\n\n        z2 = mulmod(u3, v, p);\n    }\n\n    /**\n     * @dev Add two elliptic curve points in affine coordinates.\n     */\n    function add(\n        uint256 x0,\n        uint256 y0,\n        uint256 x1,\n        uint256 y1\n    ) internal pure returns (uint256, uint256) {\n        uint256 z0;\n\n        (x0, y0, z0) = addProj(x0, y0, 1, x1, y1, 1);\n\n        return toAffinePoint(x0, y0, z0);\n    }\n\n    /**\n     * @dev Double an elliptic curve point in affine coordinates.\n     */\n    function twice(\n        uint256 x0,\n        uint256 y0\n    ) internal pure returns (uint256, uint256) {\n        uint256 z0;\n\n        (x0, y0, z0) = twiceProj(x0, y0, 1);\n\n        return toAffinePoint(x0, y0, z0);\n    }\n\n    /**\n     * @dev Multiply an elliptic curve point by a 2 power base (i.e., (2^exp)*P)).\n     */\n    function multiplyPowerBase2(\n        uint256 x0,\n        uint256 y0,\n        uint256 exp\n    ) internal pure returns (uint256, uint256) {\n        uint256 base2X = x0;\n        uint256 base2Y = y0;\n        uint256 base2Z = 1;\n\n        for (uint256 i = 0; i < exp; i++) {\n            (base2X, base2Y, base2Z) = twiceProj(base2X, base2Y, base2Z);\n        }\n\n        return toAffinePoint(base2X, base2Y, base2Z);\n    }\n\n    /**\n     * @dev Multiply an elliptic curve point by a scalar.\n     */\n    function multiplyScalar(\n        uint256 x0,\n        uint256 y0,\n        uint256 scalar\n    ) internal pure returns (uint256 x1, uint256 y1) {\n        if (scalar == 0) {\n            return zeroAffine();\n        } else if (scalar == 1) {\n            return (x0, y0);\n        } else if (scalar == 2) {\n            return twice(x0, y0);\n        }\n\n        uint256 base2X = x0;\n        uint256 base2Y = y0;\n        uint256 base2Z = 1;\n        uint256 z1 = 1;\n        x1 = x0;\n        y1 = y0;\n\n        if (scalar % 2 == 0) {\n            x1 = y1 = 0;\n        }\n\n        scalar = scalar >> 1;\n\n        while (scalar > 0) {\n            (base2X, base2Y, base2Z) = twiceProj(base2X, base2Y, base2Z);\n\n            if (scalar % 2 == 1) {\n                (x1, y1, z1) = addProj(base2X, base2Y, base2Z, x1, y1, z1);\n            }\n\n            scalar = scalar >> 1;\n        }\n\n        return toAffinePoint(x1, y1, z1);\n    }\n\n    /**\n     * @dev Multiply the curve's generator point by a scalar.\n     */\n    function multipleGeneratorByScalar(\n        uint256 scalar\n    ) internal pure returns (uint256, uint256) {\n        return multiplyScalar(gx, gy, scalar);\n    }\n\n    /**\n     * @dev Validate combination of message, signature, and public key.\n     */\n    function validateSignature(\n        bytes32 message,\n        uint256[2] memory rs,\n        uint256[2] memory Q\n    ) internal pure returns (bool) {\n        // To disambiguate between public key solutions, include comment below.\n        if (rs[0] == 0 || rs[0] >= n || rs[1] == 0) {\n            // || rs[1] > lowSmax)\n            return false;\n        }\n        if (!isOnCurve(Q[0], Q[1])) {\n            return false;\n        }\n\n        uint256 x1;\n        uint256 x2;\n        uint256 y1;\n        uint256 y2;\n\n        uint256 sInv = inverseMod(rs[1], n);\n        (x1, y1) = multiplyScalar(gx, gy, mulmod(uint256(message), sInv, n));\n        (x2, y2) = multiplyScalar(Q[0], Q[1], mulmod(rs[0], sInv, n));\n        uint256[3] memory P = addAndReturnProjectivePoint(x1, y1, x2, y2);\n\n        if (P[2] == 0) {\n            return false;\n        }\n\n        uint256 Px = inverseMod(P[2], p);\n        Px = mulmod(P[0], mulmod(Px, Px, p), p);\n\n        return Px % n == rs[0];\n    }\n}"
    },
    {
      "filename": "contracts/dnssec-oracle/algorithms/EllipticCurve.sol",
      "content": "pragma solidity ^0.8.4;\n\n/**\n * @title   EllipticCurve\n *\n * @author  Tilman Drerup;\n *\n * @notice  Implements elliptic curve math; Parametrized for SECP256R1.\n *\n *          Includes components of code by Andreas Olofsson, Alexander Vlasov\n *          (https://github.com/BANKEX/CurveArithmetics), and Avi Asayag\n *          (https://github.com/orbs-network/elliptic-curve-solidity)\n *\n *          Source: https://github.com/tdrerup/elliptic-curve-solidity\n *\n * @dev     NOTE: To disambiguate public keys when verifying signatures, activate\n *          condition 'rs[1] > lowSmax' in validateSignature().\n */\ncontract EllipticCurve {\n    // Set parameters for curve.\n    uint256 constant a =\n        0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC;\n    uint256 constant b =\n        0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B;\n    uint256 constant gx =\n        0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296;\n    uint256 constant gy =\n        0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5;\n    uint256 constant p =\n        0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF;\n    uint256 constant n =\n        0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551;\n\n    uint256 constant lowSmax =\n        0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0;\n\n    /**\n     * @dev Inverse of u in the field of modulo m.\n     */\n    function inverseMod(uint256 u, uint256 m) internal pure returns (uint256) {\n        unchecked {\n            if (u == 0 || u == m || m == 0) return 0;\n            if (u > m) u = u % m;\n\n            int256 t1;\n            int256 t2 = 1;\n            uint256 r1 = m;\n            uint256 r2 = u;\n            uint256 q;\n\n            while (r2 != 0) {\n                q = r1 / r2;\n                (t1, t2, r1, r2) = (t2, t1 - int256(q) * t2, r2, r1 - q * r2);\n            }\n\n            if (t1 < 0) return (m - uint256(-t1));\n\n            return uint256(t1);\n        }\n    }\n\n    /**\n     * @dev Transform affine coordinates into projective coordinates.\n     */\n    function toProjectivePoint(\n        uint256 x0,\n        uint256 y0\n    ) internal pure returns (uint256[3] memory P) {\n        P[2] = addmod(0, 1, p);\n        P[0] = mulmod(x0, P[2], p);\n        P[1] = mulmod(y0, P[2], p);\n    }\n\n    /**\n     * @dev Add two points in affine coordinates and return projective point.\n     */\n    function addAndReturnProjectivePoint(\n        uint256 x1,\n        uint256 y1,\n        uint256 x2,\n        uint256 y2\n    ) internal pure returns (uint256[3] memory P) {\n        uint256 x;\n        uint256 y;\n        (x, y) = add(x1, y1, x2, y2);\n        P = toProjectivePoint(x, y);\n    }\n\n    /**\n     * @dev Transform from projective to affine coordinates.\n     */\n    function toAffinePoint(\n        uint256 x0,\n        uint256 y0,\n        uint256 z0\n    ) internal pure returns (uint256 x1, uint256 y1) {\n        uint256 z0Inv;\n        z0Inv = inverseMod(z0, p);\n        x1 = mulmod(x0, z0Inv, p);\n        y1 = mulmod(y0, z0Inv, p);\n    }\n\n    /**\n     * @dev Return the zero curve in projective coordinates.\n     */\n    function zeroProj()\n        internal\n        pure\n        returns (uint256 x, uint256 y, uint256 z)\n    {\n        return (0, 1, 0);\n    }\n\n    /**\n     * @dev Return the zero curve in affine coordinates.\n     */\n    function zeroAffine() internal pure returns (uint256 x, uint256 y) {\n        return (0, 0);\n    }\n\n    /**\n     * @dev Check if the curve is the zero curve.\n     */\n    function isZeroCurve(\n        uint256 x0,\n        uint256 y0\n    ) internal pure returns (bool isZero) {\n        if (x0 == 0 && y0 == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @dev Check if a point in affine coordinates is on the curve.\n     */\n    function isOnCurve(uint256 x, uint256 y) internal pure returns (bool) {\n        if (0 == x || x == p || 0 == y || y == p) {\n            return false;\n        }\n\n        uint256 LHS = mulmod(y, y, p); // y^2\n        uint256 RHS = mulmod(mulmod(x, x, p), x, p); // x^3\n\n        if (a != 0) {\n            RHS = addmod(RHS, mulmod(x, a, p), p); // x^3 + a*x\n        }\n        if (b != 0) {\n            RHS = addmod(RHS, b, p); // x^3 + a*x + b\n        }\n\n        return LHS == RHS;\n    }\n\n    /**\n     * @dev Double an elliptic curve point in projective coordinates. See\n     * https://www.nayuki.io/page/elliptic-curve-point-addition-in-projective-coordinates\n     */\n    function twiceProj(\n        uint256 x0,\n        uint256 y0,\n        uint256 z0\n    ) internal pure returns (uint256 x1, uint256 y1, uint256 z1) {\n        uint256 t;\n        uint256 u;\n        uint256 v;\n        uint256 w;\n\n        if (isZeroCurve(x0, y0)) {\n            return zeroProj();\n        }\n\n        u = mulmod(y0, z0, p);\n        u = mulmod(u, 2, p);\n\n        v = mulmod(u, x0, p);\n        v = mulmod(v, y0, p);\n        v = mulmod(v, 2, p);\n\n        x0 = mulmod(x0, x0, p);\n        t = mulmod(x0, 3, p);\n\n        z0 = mulmod(z0, z0, p);\n        z0 = mulmod(z0, a, p);\n        t = addmod(t, z0, p);\n\n        w = mulmod(t, t, p);\n        x0 = mulmod(2, v, p);\n        w = addmod(w, p - x0, p);\n\n        x0 = addmod(v, p - w, p);\n        x0 = mulmod(t, x0, p);\n        y0 = mulmod(y0, u, p);\n        y0 = mulmod(y0, y0, p);\n        y0 = mulmod(2, y0, p);\n        y1 = addmod(x0, p - y0, p);\n\n        x1 = mulmod(u, w, p);\n\n        z1 = mulmod(u, u, p);\n        z1 = mulmod(z1, u, p);\n    }\n\n    /**\n     * @dev Add two elliptic curve points in projective coordinates. See\n     * https://www.nayuki.io/page/elliptic-curve-point-addition-in-projective-coordinates\n     */\n    function addProj(\n        uint256 x0,\n        uint256 y0,\n        uint256 z0,\n        uint256 x1,\n        uint256 y1,\n        uint256 z1\n    ) internal pure returns (uint256 x2, uint256 y2, uint256 z2) {\n        uint256 t0;\n        uint256 t1;\n        uint256 u0;\n        uint256 u1;\n\n        if (isZeroCurve(x0, y0)) {\n            return (x1, y1, z1);\n        } else if (isZeroCurve(x1, y1)) {\n            return (x0, y0, z0);\n        }\n\n        t0 = mulmod(y0, z1, p);\n        t1 = mulmod(y1, z0, p);\n\n        u0 = mulmod(x0, z1, p);\n        u1 = mulmod(x1, z0, p);\n\n        if (u0 == u1) {\n            if (t0 == t1) {\n                return twiceProj(x0, y0, z0);\n            } else {\n                return zeroProj();\n            }\n        }\n\n        (x2, y2, z2) = addProj2(mulmod(z0, z1, p), u0, u1, t1, t0);\n    }\n\n    /**\n     * @dev Helper function that splits addProj to avoid too many local variables.\n     */\n    function addProj2(\n        uint256 v,\n        uint256 u0,\n        uint256 u1,\n        uint256 t1,\n        uint256 t0\n    ) private pure returns (uint256 x2, uint256 y2, uint256 z2) {\n        uint256 u;\n        uint256 u2;\n        uint256 u3;\n        uint256 w;\n        uint256 t;\n\n        t = addmod(t0, p - t1, p);\n        u = addmod(u0, p - u1, p);\n        u2 = mulmod(u, u, p);\n\n        w = mulmod(t, t, p);\n        w = mulmod(w, v, p);\n        u1 = addmod(u1, u0, p);\n        u1 = mulmod(u1, u2, p);\n        w = addmod(w, p - u1, p);\n\n        x2 = mulmod(u, w, p);\n\n        u3 = mulmod(u2, u, p);\n        u0 = mulmod(u0, u2, p);\n        u0 = addmod(u0, p - w, p);\n        t = mulmod(t, u0, p);\n        t0 = mulmod(t0, u3, p);\n\n        y2 = addmod(t, p - t0, p);\n\n        z2 = mulmod(u3, v, p);\n    }\n\n    /**\n     * @dev Add two elliptic curve points in affine coordinates.\n     */\n    function add(\n        uint256 x0,\n        uint256 y0,\n        uint256 x1,\n        uint256 y1\n    ) internal pure returns (uint256, uint256) {\n        uint256 z0;\n\n        (x0, y0, z0) = addProj(x0, y0, 1, x1, y1, 1);\n\n        return toAffinePoint(x0, y0, z0);\n    }\n\n    /**\n     * @dev Double an elliptic curve point in affine coordinates.\n     */\n    function twice(\n        uint256 x0,\n        uint256 y0\n    ) internal pure returns (uint256, uint256) {\n        uint256 z0;\n\n        (x0, y0, z0) = twiceProj(x0, y0, 1);\n\n        return toAffinePoint(x0, y0, z0);\n    }\n\n    /**\n     * @dev Multiply an elliptic curve point by a 2 power base (i.e., (2^exp)*P)).\n     */\n    function multiplyPowerBase2(\n        uint256 x0,\n        uint256 y0,\n        uint256 exp\n    ) internal pure returns (uint256, uint256) {\n        uint256 base2X = x0;\n        uint256 base2Y = y0;\n        uint256 base2Z = 1;\n\n        for (uint256 i = 0; i < exp; i++) {\n            (base2X, base2Y, base2Z) = twiceProj(base2X, base2Y, base2Z);\n        }\n\n        return toAffinePoint(base2X, base2Y, base2Z);\n    }\n\n    /**\n     * @dev Multiply an elliptic curve point by a scalar.\n     */\n    function multiplyScalar(\n        uint256 x0,\n        uint256 y0,\n        uint256 scalar\n    ) internal pure returns (uint256 x1, uint256 y1) {\n        if (scalar == 0) {\n            return zeroAffine();\n        } else if (scalar == 1) {\n            return (x0, y0);\n        } else if (scalar == 2) {\n            return twice(x0, y0);\n        }\n\n        uint256 base2X = x0;\n        uint256 base2Y = y0;\n        uint256 base2Z = 1;\n        uint256 z1 = 1;\n        x1 = x0;\n        y1 = y0;\n\n        if (scalar % 2 == 0) {\n            x1 = y1 = 0;\n        }\n\n        scalar = scalar >> 1;\n\n        while (scalar > 0) {\n            (base2X, base2Y, base2Z) = twiceProj(base2X, base2Y, base2Z);\n\n            if (scalar % 2 == 1) {\n                (x1, y1, z1) = addProj(base2X, base2Y, base2Z, x1, y1, z1);\n            }\n\n            scalar = scalar >> 1;\n        }\n\n        return toAffinePoint(x1, y1, z1);\n    }\n\n    /**\n     * @dev Multiply the curve's generator point by a scalar.\n     */\n    function multipleGeneratorByScalar(\n        uint256 scalar\n    ) internal pure returns (uint256, uint256) {\n        return multiplyScalar(gx, gy, scalar);\n    }\n\n    /**\n     * @dev Validate combination of message, signature, and public key.\n     */\n    function validateSignature(\n        bytes32 message,\n        uint256[2] memory rs,\n        uint256[2] memory Q\n    ) internal pure returns (bool) {\n        // To disambiguate between public key solutions, include comment below.\n        if (rs[0] == 0 || rs[0] >= n || rs[1] == 0) {\n            // || rs[1] > lowSmax)\n            return false;\n        }\n        if (!isOnCurve(Q[0], Q[1])) {\n            return false;\n        }\n\n        uint256 x1;\n        uint256 x2;\n        uint256 y1;\n        uint256 y2;\n\n        uint256 sInv = inverseMod(rs[1], n);\n        (x1, y1) = multiplyScalar(gx, gy, mulmod(uint256(message), sInv, n));\n        (x2, y2) = multiplyScalar(Q[0], Q[1], mulmod(rs[0], sInv, n));\n        uint256[3] memory P = addAndReturnProjectivePoint(x1, y1, x2, y2);\n\n        if (P[2] == 0) {\n            return false;\n        }\n\n        uint256 Px = inverseMod(P[2], p);\n        Px = mulmod(P[0], mulmod(Px, Px, p), p);\n\n        return Px % n == rs[0];\n    }\n}"
    }
  ]
}