{
  "Title": "H-3: Vault max redeem calculations limit redeem amount to the smallest position size in underlying markets which can lead to very small max redeem amount even with huge TVL vault",
  "Content": "# Issue H-3: Vault max redeem calculations limit redeem amount to the smallest position size in underlying markets which can lead to very small max redeem amount even with huge TVL vault \n\nSource: https://github.com/sherlock-audit/2023-10-perennial-judging/issues/29 \n\n## Found by \npanprog\n## Summary\n\nWhen redeeming from the vault, maximum amount allowed to be redeemed is limited by current opened position in each underlying market (the smallest opened position adjusted for weight). However, if any one market has its maker close to maker limit, the vault will open very small position, limited by maker limit. But now all redeems will be limited by this very small position for no reason: when almost any amount is redeemed, the vault will attempt to **increase** (not decrease) position in such market, so there is no sense in limiting redeem amount to the smallest position.\n\nThis issue can create huge problems for users with large deposits. For example, if the user has deposited $10M to the vault, but due to one of the underlying markets the max redeem amount is only $1, user will need to do 10M transactions to redeem his full amount (which will not make sense due to gas).\n\n## Vulnerability Detail\n\nVault's `maxRedeem` is calculated for each market as:\n\n```solidity\nUFixed6 collateral = marketContext.currentPosition.maker\n    .sub(marketContext.currentPosition.net().min(marketContext.currentPosition.maker))  // available maker\n    .min(marketContext.closable.mul(StrategyLib.LEVERAGE_BUFFER))                       // available closable\n    .muldiv(marketContext.latestPrice.abs(), registration.leverage)                     // available collateral\n    .muldiv(totalWeight, registration.weight);                                          // collateral in market\n\nredemptionAssets = redemptionAssets.min(collateral);\n```\n\n`closable` is limited by the vault's settled and current positions in the market. As can be seen from the calculation, redeem amount is limited by vault's position in the market. However, if the position is far from target due to different market limitations, this doesn't make much sense. For example, if vault has $2M deposts and there are 2 underlying markets, each with weight 1, and:\n\n1. In Market1 vault position is worth $1 (target position = $1M)\n2. In Market2 vault position is worth $1M (target position = $1M)\n\nThe `maxRedeem` will be limited to $1, even though redeeming any amount up to $999999 will only make the vault attempt to increase position in Market1 rather than decrease.\n\nThere is also an opposite situation possible, when current position is higher than target position (due to LEVERAGE_BUFFER). This will make maxredeem too high. For example, similar example to previous, but:\n\n1. In Market1 vault position is worth $1.2M (target position = $1M)\n2. In Market2 vault position is worth $1.2M (target position = $1M)\n\nThe `maxRedeem` will be limited to $1.44M (due to LEVERAGE_BUFFER), without even comparing the current collateral (which is just $1M per market), based only on position size.\n\n## Impact\n\nWhen vault's position is small in any underlying market due to maker limit, the max redeem amount in the vault will be very small, which will force users with large deposits to use a lot of transactions to redeem it (they'll lose funds to gas) or it might even be next to impossible to do at all (if, for example, user has a deposit of $10M and max redeem = $1), in such case the redeems are basically broken and not possible to do.\n\n## Code Snippet\n\n`maxRedeem` calculation:\nhttps://github.com/sherlock-audit/2023-10-perennial/blob/main/perennial-v2/packages/perennial-vault/contracts/lib/StrategyLib.sol#L94-L98\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider calculating max redeem by comparing target position vs current position and then target collateral vs current collateral instead of using only current position for calculations. This might be somewhat complex, because it will require to re-calculate allocation amounts to compare target vs current position. Possibly max redeem should not be limited as a separate check, but rather as part of the `allocate()` calculations (reverting if the actual leverage is too high in the end)\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/123",
  "Code": [
    {
      "filename": "perennial-v2/packages/perennial-vault/contracts/lib/StrategyLib.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../types/Registration.sol\";\n\n/// @dev The context of an underlying market\nstruct MarketStrategyContext {\n    /// @dev The market parameter set\n    MarketParameter marketParameter;\n\n    /// @dev The risk parameter set\n    RiskParameter riskParameter;\n\n    /// @dev The local state of the vault\n    Local local;\n\n    /// @dev The vault's current account position\n    Position currentAccountPosition;\n\n    /// @dev The vault's latest account position\n    Position latestAccountPosition;\n\n    /// @dev The current global position\n    Position currentPosition;\n\n    /// @dev The latest valid price\n    Fixed6 latestPrice;\n\n    /// @dev The margin requirement of the vault\n    UFixed6 margin;\n\n    /// @dev The current closable amount of the vault\n    UFixed6 closable;\n}\n\nstruct Strategy {\n    MarketStrategyContext[] marketContexts;\n}\nusing StrategyLib for Strategy global;\n\n/// @title Strategy\n/// @notice Logic for vault capital allocation\n/// @dev - Deploys collateral first to satisfy the margin of each market, then deploys the rest by weight.\n///      - Positions are then targeted based on the amount of collateral that ends up deployed to each market.\nlibrary StrategyLib {\n    /// @dev The maximum multiplier that is allowed for leverage\n    UFixed6 public constant LEVERAGE_BUFFER = UFixed6.wrap(1.2e6);\n\n    /// @dev The target allocation for a market\n    struct MarketTarget {\n        /// @dev The amount of change in collateral\n        Fixed6 collateral;\n\n        /// @dev The new position\n        UFixed6 position;\n    }\n\n    /// @dev Internal struct to avoid stack to deep error\n    struct _AllocateLocals {\n        UFixed6 marketCollateral;\n        UFixed6 marketAssets;\n        UFixed6 minPosition;\n        UFixed6 maxPosition;\n        UFixed6 minAssets;\n        uint256 totalWeight;\n        UFixed6 totalMargin;\n    }\n\n    function load(Registration[] memory registrations) internal view returns (Strategy memory strategy) {\n        strategy.marketContexts = new MarketStrategyContext[](registrations.length);\n        for (uint256 marketId; marketId < registrations.length; marketId++)\n            strategy.marketContexts[marketId] = _loadContext(registrations[marketId]);\n    }\n\n    function maxRedeem(\n        Strategy memory strategy,\n        Registration[] memory registrations,\n        uint256 totalWeight\n    ) internal pure returns (UFixed6 redemptionAssets) {\n        redemptionAssets = UFixed6Lib.MAX;\n        for (uint256 marketId; marketId < strategy.marketContexts.length; marketId++) {\n            MarketStrategyContext memory marketContext = strategy.marketContexts[marketId];\n            Registration memory registration = registrations[marketId];\n\n            // If market has 0 weight, leverage, or position, skip\n            if (\n                registration.weight == 0 ||\n                registration.leverage.isZero() || (\n                    marketContext.latestAccountPosition.maker.isZero() &&\n                    marketContext.currentAccountPosition.maker.isZero()\n                )\n            ) continue;\n\n            UFixed6 collateral = marketContext.currentPosition.maker\n                .sub(marketContext.currentPosition.net().min(marketContext.currentPosition.maker))  // available maker\n                .min(marketContext.closable.mul(StrategyLib.LEVERAGE_BUFFER))                       // available closable\n                .muldiv(marketContext.latestPrice.abs(), registration.leverage)                     // available collateral\n                .muldiv(totalWeight, registration.weight);                                          // collateral in market\n\n            redemptionAssets = redemptionAssets.min(collateral);\n        }\n    }\n\n    /// @notice Compute the target allocation for each market\n    /// @param strategy The strategy of the vault\n    /// @param registrations The registrations of the markets\n    /// @param collateral The amount of collateral to allocate\n    /// @param assets The amount of collateral that is eligible for positions\n    function allocate(\n        Strategy memory strategy,\n        Registration[] memory registrations,\n        UFixed6 collateral,\n        UFixed6 assets\n    ) internal pure returns (MarketTarget[] memory targets) {\n        _AllocateLocals memory _locals;\n        (_locals.totalWeight, _locals.totalMargin) = _aggregate(registrations, strategy.marketContexts);\n\n        targets = new MarketTarget[](registrations.length);\n        for (uint256 marketId; marketId < registrations.length; marketId++) {\n\n            _locals.marketCollateral = strategy.marketContexts[marketId].margin\n                .add(collateral.sub(_locals.totalMargin).muldiv(registrations[marketId].weight, _locals.totalWeight));\n\n            _locals.marketAssets = assets\n                .muldiv(registrations[marketId].weight, _locals.totalWeight)\n                .min(_locals.marketCollateral.mul(LEVERAGE_BUFFER));\n\n            _locals.minAssets = strategy.marketContexts[marketId].riskParameter.minMargin\n                .unsafeDiv(registrations[marketId].leverage.mul(strategy.marketContexts[marketId].riskParameter.maintenance));\n            if (strategy.marketContexts[marketId].marketParameter.closed || _locals.marketAssets.lt(_locals.minAssets))\n                _locals.marketAssets = UFixed6Lib.ZERO;\n\n            (_locals.minPosition, _locals.maxPosition) = _positionLimit(strategy.marketContexts[marketId]);\n\n            (targets[marketId].collateral, targets[marketId].position) = (\n                Fixed6Lib.from(_locals.marketCollateral).sub(strategy.marketContexts[marketId].local.collateral),\n                _locals.marketAssets\n                    .muldiv(registrations[marketId].leverage, strategy.marketContexts[marketId].latestPrice.abs())\n                    .min(_locals.maxPosition)\n                    .max(_locals.minPosition)\n            );\n        }\n    }\n\n    /// @notice Load the context of a market\n    /// @param registration The registration of the market\n    /// @return marketContext The context of the market\n    function _loadContext(Registration memory registration) private view returns (MarketStrategyContext memory marketContext) {\n        marketContext.marketParameter = registration.market.parameter();\n        marketContext.riskParameter = registration.market.riskParameter();\n        marketContext.local = registration.market.locals(address(this));\n        Global memory global = registration.market.global();\n        marketContext.latestPrice = global.latestPrice;\n\n        // latest position\n        UFixed6 previousClosable;\n        previousClosable = _loadPosition(\n            marketContext,\n            marketContext.latestAccountPosition = registration.market.positions(address(this)),\n            previousClosable\n        );\n        marketContext.closable = marketContext.latestAccountPosition.maker;\n\n        // pending positions\n        for (uint256 id = marketContext.local.latestId + 1; id <= marketContext.local.currentId; id++)\n            previousClosable = _loadPosition(\n                marketContext,\n                marketContext.currentAccountPosition = registration.market.pendingPositions(address(this), id),\n                previousClosable\n            );\n\n        // current position\n        Position memory latestPosition = registration.market.position();\n        marketContext.currentPosition = registration.market.pendingPosition(global.currentId);\n        marketContext.currentPosition.adjust(latestPosition);\n    }\n\n    /// @notice Loads one position for the context calculation\n    /// @param marketContext The context of the market\n    /// @param position The position to load\n    /// @param previousMaker The previous maker position\n    /// @return nextMaker The next maker position\n    function _loadPosition(\n        MarketStrategyContext memory marketContext,\n        Position memory position,\n        UFixed6 previousMaker\n    ) private pure returns (UFixed6 nextMaker) {\n        position.adjust(marketContext.latestAccountPosition);\n\n        marketContext.margin = position\n            .margin(OracleVersion(0, marketContext.latestPrice, true), marketContext.riskParameter)\n            .max(marketContext.margin);\n        marketContext.closable = marketContext.closable.sub(previousMaker.sub(position.maker.min(previousMaker)));\n        nextMaker = position.maker;\n    }\n\n    /// @notice Aggregate the context of all markets\n    /// @param registrations The registrations of the markets\n    /// @param marketContexts The contexts of the markets\n    /// @return totalWeight The total weight of all markets\n    /// @return totalMargin The total margin of all markets\n    function _aggregate(\n        Registration[] memory registrations,\n        MarketStrategyContext[] memory marketContexts\n    ) private pure returns (uint256 totalWeight, UFixed6 totalMargin) {\n        for (uint256 marketId; marketId < registrations.length; marketId++) {\n            totalWeight += registrations[marketId].weight;\n            totalMargin = totalMargin.add(marketContexts[marketId].margin);\n        }\n    }\n\n    /// @notice Compute the position limit of a market\n    /// @param marketContext The context of the market\n    /// @return The minimum position size before crossing the net position\n    /// @return The maximum position size before crossing the maker limit\n    function _positionLimit(MarketStrategyContext memory marketContext) private pure returns (UFixed6, UFixed6) {\n        return (\n            // minimum position size before crossing the net position\n            marketContext.currentAccountPosition.maker.sub(\n            marketContext.currentPosition.maker\n                    .sub(marketContext.currentPosition.net().min(marketContext.currentPosition.maker))\n                    .min(marketContext.currentAccountPosition.maker)\n                    .min(marketContext.closable)\n            ),\n            // maximum position size before crossing the maker limit\n            marketContext.currentAccountPosition.maker.add(\n            marketContext.riskParameter.makerLimit\n                    .sub(marketContext.currentPosition.maker.min(marketContext.riskParameter.makerLimit))\n            )\n        );\n    }\n}"
    }
  ]
}