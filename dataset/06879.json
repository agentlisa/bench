{
  "Title": "[M-03] `characterModifier` is `uint8` but encodes `1.38e24` different Zalgo distortions",
  "Content": "\n<https://github.com/code-423n4/2023-03-canto-identity/blob/077372297fc419ea7688ab62cc3fd4e8f4e24e66/canto-namespace-protocol/src/Tray.sol#L163><br>\n<https://github.com/code-423n4/2023-03-canto-identity/blob/077372297fc419ea7688ab62cc3fd4e8f4e24e66/canto-namespace-protocol/src/Tray.sol#L264-L268><br>\n<https://github.com/code-423n4/2023-03-canto-identity/blob/077372297fc419ea7688ab62cc3fd4e8f4e24e66/canto-namespace-protocol/src/Utils.sol#L136-L174>\n\nOnly 256 Zalgo distortions are possible, which is a miniscule fraction of the actual combinations possible.\n\n### Proof of Concept\n\nA Zalgo tile is defined by a letter and a modification consisting of a combination of characters above, over and below the letter. The modification consists of a selection of 1 up to 7 characters from a set of 46 characters above the letter, 0 or 1 from 5 over the letter, and 1 to 7 from 47 below the letter. Thus there is a total of $(46^1 + 46^2 + ... + 46^7)*(5^0 + 5^1)*(47^1 + 47^2 + ... + 47^7) = 1.38e24$ different Zalgo modifications possible per letter.\n\nHowever, the distortions are uniquely determined by `characterModifier` which is a `uint8`. So only 256 different distortions per letter are possible.\n\nWhen a tray is bought, [`_drawing` sets the tile](https://github.com/code-423n4/2023-03-canto-identity/blob/077372297fc419ea7688ab62cc3fd4e8f4e24e66/canto-namespace-protocol/src/Tray.sol#L163),\n\n```solidity\nfunction buy(uint256 _amount) external {\n// ...\n            trayTiledata[j] = _drawing(uint256(lastHash));\n// ...\n}\n```\n\nand, if luck would have it that it is a Zalgo tile, [`characterModifier` is set to a pseudo-random `uint8`](https://github.com/code-423n4/2023-03-canto-identity/blob/077372297fc419ea7688ab62cc3fd4e8f4e24e66/canto-namespace-protocol/src/Tray.sol#L264-L268), i.e. in the range 0..255.\n\n```solidity\nfunction _drawing(uint256 _seed) private pure returns (TileData memory tileData) {\n// ...\n            if (tileData.fontClass == 7) {\n                // Set seed for Zalgo to ensure same characters will be always generated for this tile\n                uint256 zalgoSeed = Utils.iteratePRNG(_seed);\n                tileData.characterModifier = uint8(zalgoSeed % 256);\n// ...\n}\n```\n\nThis `characterModifier` uniquely determines the distortion in `characterToUnicodeBytes` at [L136-L174](https://github.com/code-423n4/2023-03-canto-identity/blob/077372297fc419ea7688ab62cc3fd4e8f4e24e66/canto-namespace-protocol/src/Utils.sol#L136-L174):\n\n```solidity\n} else if (_fontClass == 7) {\n    // Zalgo\n    uint8 asciiStartingIndex = 97;\n    uint256 numAbove = (_characterModifier % 7) + 1;\n    // We do not reuse the same seed for the following generations to avoid any symmetries, e.g. that 2 chars above would also always result in 2 chars below\n    _characterModifier = iteratePRNG(_characterModifier);\n    uint256 numMiddle = _characterModifier % 2;\n    _characterModifier = iteratePRNG(_characterModifier);\n    uint256 numBelow = (_characterModifier % 7) + 1;\n    bytes memory character = abi.encodePacked(bytes1(asciiStartingIndex + uint8(_characterIndex)));\n    for (uint256 i; i < numAbove; ++i) {\n        _characterModifier = iteratePRNG(_characterModifier);\n        uint256 characterIndex = (_characterModifier % ZALGO_NUM_ABOVE) * 2;\n        character = abi.encodePacked(\n            character,\n            ZALGO_ABOVE_LETTER[characterIndex],\n            ZALGO_ABOVE_LETTER[characterIndex + 1]\n        );\n    }\n    for (uint256 i; i < numMiddle; ++i) {\n        _characterModifier = iteratePRNG(_characterModifier);\n        uint256 characterIndex = (_characterModifier % ZALGO_NUM_OVER) * 2;\n        character = abi.encodePacked(\n            character,\n            ZALGO_OVER_LETTER[characterIndex],\n            ZALGO_OVER_LETTER[characterIndex + 1]\n        );\n    }\n    for (uint256 i; i < numBelow; ++i) {\n        _characterModifier = iteratePRNG(_characterModifier);\n        uint256 characterIndex = (_characterModifier % ZALGO_NUM_BELOW) * 2;\n        character = abi.encodePacked(\n            character,\n            ZALGO_BELOW_LETTER[characterIndex],\n            ZALGO_BELOW_LETTER[characterIndex + 1]\n        );\n    }\n    return character;\n} else {\n```\n\nNote that there is also a similar bottleneck issue with `iteratePRNG`, which is reported as a separate issue.\n\n### Recommended Mitigation Steps\n\nLet `characterModifier` have a range of at least `0..1.38e24`. Since it therefore cannot be a `uint8`, simply let it be a `uint256` (or at least a `uint88`).\n\n**[OpenCoreCH (Canto Identity) acknowledged and commented](https://github.com/code-423n4/2023-03-canto-identity-findings/issues/277#issuecomment-1489232861):**\n > Addressing [M-02 (issue 282)](https://github.com/code-423n4/2023-03-canto-identity-findings/issues/282) and [M-03 (issue 277)](https://github.com/code-423n4/2023-03-canto-identity-findings/issues/277) here because they are very similar: Both issues are technically true and well written, but 256 different distortions are more than enough in my opinion and there is no need to have `1.38e24`.\n\n**[d3e4 (warden) commented](https://github.com/code-423n4/2023-03-canto-identity-findings/issues/277#issuecomment-1515985208):**\n > @OpenCoreCH - It’s of course up to you what you eventually implement, but I would just like to offer my perspective on why you might actually want to make the corrections suggested in `#277` and `#282`.\n> \n> 256 distortions may seem plenty, but there are already 98 combinations just in terms of the number of diacritics above, in the middle, and below (7*2*7). Currently five such combinations are not even generated at all, viz. (2,1,7), (3,0,6), (3,1,1), (5,0,6), (6,1,5), where the combinations are represented as (numAbove, numMiddle, numBelow).\n> \n> Even if all possible distortions were reachable, a user couldn’t feasibly obtain a specific distortion of his choosing, but he might desire some class of distortions. If this class is any of the above missing combinations of numbers of diacritics he evidently cannot obtain it. But even if 14266523201 distortions are available (`#282`) the chances that these overlap with his own desired class is minuscule, as these are only 0.000000000001% of all possible Zalgo distortions promised by the parameters.\n> \n> And with only 256 distortions they will have to be reused. Different users will share identical distortions, and there may even be duplicates in the same tray. This would be exceedingly unlikely if the full range of distortions were available.\n> \n> If the goal is simply to offer only 256 different distortions, then the protocol currently achieves this. (But in this case I wonder if it wouldn’t be more gas efficient to simply hardcode these and pick one randomly instead of generating them in the current complicated manner.)\n> But the protocol gives the impression (if not promise?) of offering a distortion synthesised from a range of diacritics, which might leave the user feeling cheated. For example, none of the Zalgos in the docs are available.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-03-canto-identity-subprotocols-contest",
  "Code": [
    {
      "filename": "canto-namespace-protocol/src/Tray.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC721A} from \"erc721a/ERC721A.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {LibString} from \"solmate/utils/LibString.sol\";\nimport {Base64} from \"solady/utils/Base64.sol\";\nimport \"./Utils.sol\";\nimport \"../interface/Turnstile.sol\";\n\ncontract Tray is ERC721A, Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Number of tiles that are in one tray\n    uint256 private constant TILES_PER_TRAY = 7;\n\n    /// @notice Sum of the odds for all fonts\n    uint256 private constant SUM_ODDS = 109;\n\n    /// @notice Number of characters for emojis\n    uint256 private constant NUM_CHARS_EMOJIS = 420;\n\n    /// @notice Number of characters for letters\n    uint256 private constant NUM_CHARS_LETTERS = 26;\n\n    /// @notice Number of characters for letters and numbers\n    uint256 private constant NUM_CHARS_LETTERS_NUMBERS = 36;\n\n    /// @notice Maximum number of trays that can be minted pre-launch (by the owner)\n    uint256 private constant PRE_LAUNCH_MINT_CAP = 1_000;\n\n    /// @notice Price of one tray in $NOTE\n    uint256 public immutable trayPrice;\n\n    /*//////////////////////////////////////////////////////////////\n                                 ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Wallet that receives the revenue\n    address private revenueAddress;\n\n    /// @notice Reference to the $NOTE TOKEN\n    ERC20 public note;\n\n    /// @notice Reference to the Namespace NFT contract\n    address public immutable namespaceNFT;\n\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Font and character index of a tile\n    struct TileData {\n        /// @notice Allowed values between 0 (emoji) and 9 (font5 rare)\n        uint8 fontClass;\n        /// @notice For Emojis (font class 0) between 0..NUM_CHARS_EMOJIS - 1, otherwise between 0..NUM_CHARS_LETTERS - 1\n        uint16 characterIndex;\n        /// @notice For generative fonts with randomness (Zalgo), we generate and fix this on minting. For some emojis, it can be set by the user to influence the skin color\n        uint8 characterModifier;\n    }\n\n    /// @notice Stores the content of a tray, i.e. all tiles\n    mapping(uint256 => TileData[TILES_PER_TRAY]) private tiles;\n\n    /// @notice Last hash that was used to generate a tray\n    bytes32 public lastHash;\n\n    /// @notice Set to the number of minted NFTs after the prelaunch has ended\n    uint256 private prelaunchMinted = type(uint256).max;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event RevenueAddressUpdated(address indexed oldRevenueAddress, address indexed newRevenueAddress);\n    event NoteAddressUpdate(address indexed oldNoteAddress, address indexed newNoteAddress);\n    event PrelaunchEnded();\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error CallerNotAllowedToBurn();\n    error TrayNotMinted(uint256 tokenID);\n    error OnlyOwnerCanMintPreLaunch();\n    error MintExceedsPreLaunchAmount();\n    error PrelaunchTrayCannotBeUsedAfterPrelaunch(uint256 startTokenId);\n    error PrelaunchAlreadyEnded();\n\n    /// @notice Sets the initial hash, tray price, and the revenue address\n    /// @param _initHash Hash to initialize the system with. Will determine the generation sequence of the trays\n    /// @param _trayPrice Price of one tray in $NOTE\n    /// @param _revenueAddress Adress to send the revenue to\n    /// @param _note Address of the $NOTE token\n    /// @param _namespaceNFT Address of the Namespace NFT\n    constructor(\n        bytes32 _initHash,\n        uint256 _trayPrice,\n        address _revenueAddress,\n        address _note,\n        address _namespaceNFT\n    ) ERC721A(\"Namespace Tray\", \"NSTRAY\") Owned(msg.sender) {\n        lastHash = _initHash;\n        trayPrice = _trayPrice;\n        revenueAddress = _revenueAddress;\n        note = ERC20(_note);\n        namespaceNFT = _namespaceNFT;\n        if (block.chainid == 7700) {\n            // Register CSR on Canto mainnnet\n            Turnstile turnstile = Turnstile(0xEcf044C5B4b867CFda001101c617eCd347095B44);\n            turnstile.register(tx.origin);\n        }\n    }\n\n    /// @notice Get the token URI for the specified _id\n    /// @param _id ID to query for\n    function tokenURI(uint256 _id) public view override returns (string memory) {\n        if (!_exists(_id)) revert TrayNotMinted(_id);\n        uint256 numPrelaunchMinted = prelaunchMinted;\n        if (numPrelaunchMinted != type(uint256).max) {\n            // Prelaunch trays become invalid after the phase has ended\n            if (_id <= numPrelaunchMinted) revert PrelaunchTrayCannotBeUsedAfterPrelaunch(_id);\n        }\n        // Need to do an explicit copy here, implicit one not supported\n        TileData[TILES_PER_TRAY] storage storedNftTiles = tiles[_id];\n        TileData[] memory nftTiles = new TileData[](TILES_PER_TRAY);\n        for (uint256 i; i < TILES_PER_TRAY; ++i) {\n            nftTiles[i] = storedNftTiles[i];\n        }\n        string memory json = Base64.encode(\n            bytes(\n                string(\n                    abi.encodePacked(\n                        '{\"name\": \"Tray #',\n                        LibString.toString(_id),\n                        '\", \"image\": \"data:image/svg+xml;base64,',\n                        Base64.encode(bytes(Utils.generateSVG(nftTiles, true))),\n                        '\"}'\n                    )\n                )\n            )\n        );\n        return string(abi.encodePacked(\"data:application/json;base64,\", json));\n    }\n\n    /// @notice Buy a specifiable amount of trays\n    /// @param _amount Amount of trays to buy\n    function buy(uint256 _amount) external {\n        uint256 startingTrayId = _nextTokenId();\n        if (prelaunchMinted == type(uint256).max) {\n            // Still in prelaunch phase\n            if (msg.sender != owner) revert OnlyOwnerCanMintPreLaunch();\n            if (startingTrayId + _amount - 1 > PRE_LAUNCH_MINT_CAP) revert MintExceedsPreLaunchAmount();\n        } else {\n            SafeTransferLib.safeTransferFrom(note, msg.sender, revenueAddress, _amount * trayPrice);\n        }\n        for (uint256 i; i < _amount; ++i) {\n            TileData[TILES_PER_TRAY] memory trayTiledata;\n            for (uint256 j; j < TILES_PER_TRAY; ++j) {\n                lastHash = keccak256(abi.encode(lastHash));\n                trayTiledata[j] = _drawing(uint256(lastHash));\n            }\n            tiles[startingTrayId + i] = trayTiledata;\n        }\n        _mint(msg.sender, _amount); // We do not use _safeMint on purpose here to disallow callbacks and save gas\n    }\n\n    /// @notice Burn a specified tray\n    /// @dev Callable by the owner, an authorized address, or the Namespace NFT (when fusing)\n    /// @param _id Tray ID\n    function burn(uint256 _id) external {\n        address trayOwner = ownerOf(_id);\n        if (\n            namespaceNFT != msg.sender &&\n            trayOwner != msg.sender &&\n            getApproved(_id) != msg.sender &&\n            !isApprovedForAll(trayOwner, msg.sender)\n        ) revert CallerNotAllowedToBurn();\n        if (msg.sender == namespaceNFT) {\n            // Disallow fusing for prelaunch trays after phase has ended\n            uint256 numPrelaunchMinted = prelaunchMinted;\n            if (numPrelaunchMinted != type(uint256).max && _id <= numPrelaunchMinted)\n                revert PrelaunchTrayCannotBeUsedAfterPrelaunch(_id);\n        }\n        delete tiles[_id];\n        _burn(_id);\n    }\n\n    /// @notice Get the information about one tile\n    /// @dev Reverts for non-existing tray ID\n    /// @param _trayId Tray to query\n    /// @param _tileOffset Offset of the tile within the query, needs to be between 0 .. TILES_PER_TRAY - 1\n    function getTile(uint256 _trayId, uint8 _tileOffset) external view returns (TileData memory tileData) {\n        if (!_exists(_trayId)) revert TrayNotMinted(_trayId);\n        tileData = tiles[_trayId][_tileOffset];\n    }\n\n    /// @notice Query all tiles of a tray\n    /// @dev Reverts for non-existing tray ID\n    /// @param _trayId Tray to query\n    function getTiles(uint256 _trayId) external view returns (TileData[TILES_PER_TRAY] memory tileData) {\n        if (!_exists(_trayId)) revert TrayNotMinted(_trayId);\n        tileData = tiles[_trayId];\n    }\n\n    /// @notice Change the address of the $NOTE token\n    /// @param _newNoteAddress New address to use\n    function changeNoteAddress(address _newNoteAddress) external onlyOwner {\n        address currentNoteAddress = address(note);\n        note = ERC20(_newNoteAddress);\n        emit NoteAddressUpdate(currentNoteAddress, _newNoteAddress);\n    }\n\n    /// @notice Change the revenue address\n    /// @param _newRevenueAddress New address to use\n    function changeRevenueAddress(address _newRevenueAddress) external onlyOwner {\n        address currentRevenueAddress = revenueAddress;\n        revenueAddress = _newRevenueAddress;\n        emit RevenueAddressUpdated(currentRevenueAddress, _newRevenueAddress);\n    }\n\n    /// @notice End the prelaunch phase and start the public mint\n    function endPrelaunchPhase() external onlyOwner {\n        if (prelaunchMinted != type(uint256).max) revert PrelaunchAlreadyEnded();\n        prelaunchMinted = _nextTokenId() - 1;\n        emit PrelaunchEnded();\n    }\n\n    function _beforeTokenTransfers(\n        address, /* from*/\n        address to,\n        uint256 startTokenId,\n        uint256 /* quantity*/\n    ) internal view override {\n        uint256 numPrelaunchMinted = prelaunchMinted;\n        if (numPrelaunchMinted != type(uint256).max) {\n            // We do not allow any transfers of the prelaunch trays after the phase has ended\n            if (startTokenId <= numPrelaunchMinted && to != address(0))\n                revert PrelaunchTrayCannotBeUsedAfterPrelaunch(startTokenId);\n        }\n    }\n\n    function _drawing(uint256 _seed) private pure returns (TileData memory tileData) {\n        uint256 res = _seed % SUM_ODDS;\n        uint256 charRandValue = Utils.iteratePRNG(_seed); // Iterate PRNG to not have any biasedness / correlation between random numbers\n        if (res < 32) {\n            // Class is 0 in that case\n            tileData.characterIndex = uint16(charRandValue % NUM_CHARS_EMOJIS);\n        } else {\n            tileData.characterIndex = uint16(charRandValue % NUM_CHARS_LETTERS);\n            if (res < 64) {\n                tileData.fontClass = 1;\n                tileData.characterIndex = uint16(charRandValue % NUM_CHARS_LETTERS_NUMBERS);\n            } else if (res < 80) {\n                tileData.fontClass = 2;\n            } else if (res < 96) {\n                tileData.fontClass = 3 + uint8((res - 80) / 8);\n            } else if (res < 104) {\n                tileData.fontClass = 5 + uint8((res - 96) / 4);\n            } else if (res < 108) {\n                tileData.fontClass = 7 + uint8((res - 104) / 2);\n                if (tileData.fontClass == 7) {\n                    // Set seed for Zalgo to ensure same characters will be always generated for this tile\n                    uint256 zalgoSeed = Utils.iteratePRNG(_seed);\n                    tileData.characterModifier = uint8(zalgoSeed % 256);\n                }\n            } else {\n                tileData.fontClass = 9;\n            }\n        }\n    }\n\n    /// @dev Overridden function of ERC721A to start minting at 1\n    function _startTokenId() internal pure override returns (uint256) {\n        return 1;\n    }\n}"
    },
    {
      "filename": "canto-namespace-protocol/src/Tray.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC721A} from \"erc721a/ERC721A.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {LibString} from \"solmate/utils/LibString.sol\";\nimport {Base64} from \"solady/utils/Base64.sol\";\nimport \"./Utils.sol\";\nimport \"../interface/Turnstile.sol\";\n\ncontract Tray is ERC721A, Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Number of tiles that are in one tray\n    uint256 private constant TILES_PER_TRAY = 7;\n\n    /// @notice Sum of the odds for all fonts\n    uint256 private constant SUM_ODDS = 109;\n\n    /// @notice Number of characters for emojis\n    uint256 private constant NUM_CHARS_EMOJIS = 420;\n\n    /// @notice Number of characters for letters\n    uint256 private constant NUM_CHARS_LETTERS = 26;\n\n    /// @notice Number of characters for letters and numbers\n    uint256 private constant NUM_CHARS_LETTERS_NUMBERS = 36;\n\n    /// @notice Maximum number of trays that can be minted pre-launch (by the owner)\n    uint256 private constant PRE_LAUNCH_MINT_CAP = 1_000;\n\n    /// @notice Price of one tray in $NOTE\n    uint256 public immutable trayPrice;\n\n    /*//////////////////////////////////////////////////////////////\n                                 ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Wallet that receives the revenue\n    address private revenueAddress;\n\n    /// @notice Reference to the $NOTE TOKEN\n    ERC20 public note;\n\n    /// @notice Reference to the Namespace NFT contract\n    address public immutable namespaceNFT;\n\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Font and character index of a tile\n    struct TileData {\n        /// @notice Allowed values between 0 (emoji) and 9 (font5 rare)\n        uint8 fontClass;\n        /// @notice For Emojis (font class 0) between 0..NUM_CHARS_EMOJIS - 1, otherwise between 0..NUM_CHARS_LETTERS - 1\n        uint16 characterIndex;\n        /// @notice For generative fonts with randomness (Zalgo), we generate and fix this on minting. For some emojis, it can be set by the user to influence the skin color\n        uint8 characterModifier;\n    }\n\n    /// @notice Stores the content of a tray, i.e. all tiles\n    mapping(uint256 => TileData[TILES_PER_TRAY]) private tiles;\n\n    /// @notice Last hash that was used to generate a tray\n    bytes32 public lastHash;\n\n    /// @notice Set to the number of minted NFTs after the prelaunch has ended\n    uint256 private prelaunchMinted = type(uint256).max;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event RevenueAddressUpdated(address indexed oldRevenueAddress, address indexed newRevenueAddress);\n    event NoteAddressUpdate(address indexed oldNoteAddress, address indexed newNoteAddress);\n    event PrelaunchEnded();\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error CallerNotAllowedToBurn();\n    error TrayNotMinted(uint256 tokenID);\n    error OnlyOwnerCanMintPreLaunch();\n    error MintExceedsPreLaunchAmount();\n    error PrelaunchTrayCannotBeUsedAfterPrelaunch(uint256 startTokenId);\n    error PrelaunchAlreadyEnded();\n\n    /// @notice Sets the initial hash, tray price, and the revenue address\n    /// @param _initHash Hash to initialize the system with. Will determine the generation sequence of the trays\n    /// @param _trayPrice Price of one tray in $NOTE\n    /// @param _revenueAddress Adress to send the revenue to\n    /// @param _note Address of the $NOTE token\n    /// @param _namespaceNFT Address of the Namespace NFT\n    constructor(\n        bytes32 _initHash,\n        uint256 _trayPrice,\n        address _revenueAddress,\n        address _note,\n        address _namespaceNFT\n    ) ERC721A(\"Namespace Tray\", \"NSTRAY\") Owned(msg.sender) {\n        lastHash = _initHash;\n        trayPrice = _trayPrice;\n        revenueAddress = _revenueAddress;\n        note = ERC20(_note);\n        namespaceNFT = _namespaceNFT;\n        if (block.chainid == 7700) {\n            // Register CSR on Canto mainnnet\n            Turnstile turnstile = Turnstile(0xEcf044C5B4b867CFda001101c617eCd347095B44);\n            turnstile.register(tx.origin);\n        }\n    }\n\n    /// @notice Get the token URI for the specified _id\n    /// @param _id ID to query for\n    function tokenURI(uint256 _id) public view override returns (string memory) {\n        if (!_exists(_id)) revert TrayNotMinted(_id);\n        uint256 numPrelaunchMinted = prelaunchMinted;\n        if (numPrelaunchMinted != type(uint256).max) {\n            // Prelaunch trays become invalid after the phase has ended\n            if (_id <= numPrelaunchMinted) revert PrelaunchTrayCannotBeUsedAfterPrelaunch(_id);\n        }\n        // Need to do an explicit copy here, implicit one not supported\n        TileData[TILES_PER_TRAY] storage storedNftTiles = tiles[_id];\n        TileData[] memory nftTiles = new TileData[](TILES_PER_TRAY);\n        for (uint256 i; i < TILES_PER_TRAY; ++i) {\n            nftTiles[i] = storedNftTiles[i];\n        }\n        string memory json = Base64.encode(\n            bytes(\n                string(\n                    abi.encodePacked(\n                        '{\"name\": \"Tray #',\n                        LibString.toString(_id),\n                        '\", \"image\": \"data:image/svg+xml;base64,',\n                        Base64.encode(bytes(Utils.generateSVG(nftTiles, true))),\n                        '\"}'\n                    )\n                )\n            )\n        );\n        return string(abi.encodePacked(\"data:application/json;base64,\", json));\n    }\n\n    /// @notice Buy a specifiable amount of trays\n    /// @param _amount Amount of trays to buy\n    function buy(uint256 _amount) external {\n        uint256 startingTrayId = _nextTokenId();\n        if (prelaunchMinted == type(uint256).max) {\n            // Still in prelaunch phase\n            if (msg.sender != owner) revert OnlyOwnerCanMintPreLaunch();\n            if (startingTrayId + _amount - 1 > PRE_LAUNCH_MINT_CAP) revert MintExceedsPreLaunchAmount();\n        } else {\n            SafeTransferLib.safeTransferFrom(note, msg.sender, revenueAddress, _amount * trayPrice);\n        }\n        for (uint256 i; i < _amount; ++i) {\n            TileData[TILES_PER_TRAY] memory trayTiledata;\n            for (uint256 j; j < TILES_PER_TRAY; ++j) {\n                lastHash = keccak256(abi.encode(lastHash));\n                trayTiledata[j] = _drawing(uint256(lastHash));\n            }\n            tiles[startingTrayId + i] = trayTiledata;\n        }\n        _mint(msg.sender, _amount); // We do not use _safeMint on purpose here to disallow callbacks and save gas\n    }\n\n    /// @notice Burn a specified tray\n    /// @dev Callable by the owner, an authorized address, or the Namespace NFT (when fusing)\n    /// @param _id Tray ID\n    function burn(uint256 _id) external {\n        address trayOwner = ownerOf(_id);\n        if (\n            namespaceNFT != msg.sender &&\n            trayOwner != msg.sender &&\n            getApproved(_id) != msg.sender &&\n            !isApprovedForAll(trayOwner, msg.sender)\n        ) revert CallerNotAllowedToBurn();\n        if (msg.sender == namespaceNFT) {\n            // Disallow fusing for prelaunch trays after phase has ended\n            uint256 numPrelaunchMinted = prelaunchMinted;\n            if (numPrelaunchMinted != type(uint256).max && _id <= numPrelaunchMinted)\n                revert PrelaunchTrayCannotBeUsedAfterPrelaunch(_id);\n        }\n        delete tiles[_id];\n        _burn(_id);\n    }\n\n    /// @notice Get the information about one tile\n    /// @dev Reverts for non-existing tray ID\n    /// @param _trayId Tray to query\n    /// @param _tileOffset Offset of the tile within the query, needs to be between 0 .. TILES_PER_TRAY - 1\n    function getTile(uint256 _trayId, uint8 _tileOffset) external view returns (TileData memory tileData) {\n        if (!_exists(_trayId)) revert TrayNotMinted(_trayId);\n        tileData = tiles[_trayId][_tileOffset];\n    }\n\n    /// @notice Query all tiles of a tray\n    /// @dev Reverts for non-existing tray ID\n    /// @param _trayId Tray to query\n    function getTiles(uint256 _trayId) external view returns (TileData[TILES_PER_TRAY] memory tileData) {\n        if (!_exists(_trayId)) revert TrayNotMinted(_trayId);\n        tileData = tiles[_trayId];\n    }\n\n    /// @notice Change the address of the $NOTE token\n    /// @param _newNoteAddress New address to use\n    function changeNoteAddress(address _newNoteAddress) external onlyOwner {\n        address currentNoteAddress = address(note);\n        note = ERC20(_newNoteAddress);\n        emit NoteAddressUpdate(currentNoteAddress, _newNoteAddress);\n    }\n\n    /// @notice Change the revenue address\n    /// @param _newRevenueAddress New address to use\n    function changeRevenueAddress(address _newRevenueAddress) external onlyOwner {\n        address currentRevenueAddress = revenueAddress;\n        revenueAddress = _newRevenueAddress;\n        emit RevenueAddressUpdated(currentRevenueAddress, _newRevenueAddress);\n    }\n\n    /// @notice End the prelaunch phase and start the public mint\n    function endPrelaunchPhase() external onlyOwner {\n        if (prelaunchMinted != type(uint256).max) revert PrelaunchAlreadyEnded();\n        prelaunchMinted = _nextTokenId() - 1;\n        emit PrelaunchEnded();\n    }\n\n    function _beforeTokenTransfers(\n        address, /* from*/\n        address to,\n        uint256 startTokenId,\n        uint256 /* quantity*/\n    ) internal view override {\n        uint256 numPrelaunchMinted = prelaunchMinted;\n        if (numPrelaunchMinted != type(uint256).max) {\n            // We do not allow any transfers of the prelaunch trays after the phase has ended\n            if (startTokenId <= numPrelaunchMinted && to != address(0))\n                revert PrelaunchTrayCannotBeUsedAfterPrelaunch(startTokenId);\n        }\n    }\n\n    function _drawing(uint256 _seed) private pure returns (TileData memory tileData) {\n        uint256 res = _seed % SUM_ODDS;\n        uint256 charRandValue = Utils.iteratePRNG(_seed); // Iterate PRNG to not have any biasedness / correlation between random numbers\n        if (res < 32) {\n            // Class is 0 in that case\n            tileData.characterIndex = uint16(charRandValue % NUM_CHARS_EMOJIS);\n        } else {\n            tileData.characterIndex = uint16(charRandValue % NUM_CHARS_LETTERS);\n            if (res < 64) {\n                tileData.fontClass = 1;\n                tileData.characterIndex = uint16(charRandValue % NUM_CHARS_LETTERS_NUMBERS);\n            } else if (res < 80) {\n                tileData.fontClass = 2;\n            } else if (res < 96) {\n                tileData.fontClass = 3 + uint8((res - 80) / 8);\n            } else if (res < 104) {\n                tileData.fontClass = 5 + uint8((res - 96) / 4);\n            } else if (res < 108) {\n                tileData.fontClass = 7 + uint8((res - 104) / 2);\n                if (tileData.fontClass == 7) {\n                    // Set seed for Zalgo to ensure same characters will be always generated for this tile\n                    uint256 zalgoSeed = Utils.iteratePRNG(_seed);\n                    tileData.characterModifier = uint8(zalgoSeed % 256);\n                }\n            } else {\n                tileData.fontClass = 9;\n            }\n        }\n    }\n\n    /// @dev Overridden function of ERC721A to start minting at 1\n    function _startTokenId() internal pure override returns (uint256) {\n        return 1;\n    }\n}"
    },
    {
      "filename": "canto-namespace-protocol/src/Utils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport \"./Tray.sol\";\nimport {LibString} from \"solmate/utils/LibString.sol\";\n\n/// @notice Utiltities for the on-chain SVG generation of the text data and pseudo randomness\nlibrary Utils {\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error EmojiDoesNotSupportSkinToneModifier(uint16 emojiIndex);\n    error InvalidSkinToneModifierProvided(uint256 characterModifier);\n\n    /// @notice UTF-8 encoding of the squiggle characters. The characters have a different length (1 to 3 bytes)\n    bytes private constant FONT_SQUIGGLE =\n        hex\"CEB1E182A6C688D483D2BDCF9DC9A0D48BCEB9CA9DC699CA85C9B1C9B3CF83CF81CF99C9BECA82C69ACF85CA8BC9AF78E183A7C8A5\";\n\n    /// @notice UTF-8 encoding of possible characters that can be above a letter for Zalgo. All characters have a length of 2 bytes\n    bytes private constant ZALGO_ABOVE_LETTER =\n        hex\"CC80CC81CC82CC83CC84CC85CC86CC87CC88CC89CC8ACC8BCC8CCC8DCC8ECC8FCC90CC91CC92CC93CC94CC95CC9ACC9BCCBDCCBECCBFCD80CD81CD82CD83CD84CD86CD8ACD8BCD8CCD90CD91CD92CD97CD98CD9BCD9DCD9ECDA0CDA1\";\n\n    /// @notice Number of characters that can be above a letter for Zalgo\n    uint256 private constant ZALGO_NUM_ABOVE = 46;\n\n    /// @notice UTF-8 encoding of possible characters that can be below a letter for Zalgo. All characters have a length of 2 bytes\n    bytes private constant ZALGO_BELOW_LETTER =\n        hex\"CC96CC97CC98CC99CC9CCC9DCC9ECC9FCCA0CCA1CCA2CCA3CCA4CCA5CCA6CCA7CCA8CCA9CCAACCABCCACCCADCCAECCAFCCB0CCB1CCB2CCB3CCB9CCBACCBBCCBCCD85CD87CD88CD89CD8DCD8ECD93CD94CD95CD96CD99CD9ACD9CCD9FCDA2\";\n\n    /// @notice Number of characters that can be below a letter for Zalgo\n    uint256 private constant ZALGO_NUM_BELOW = 47;\n\n    /// @notice UTF-8 encoding of possible characters that can be over a letter (i.e., in the middle) for Zalgo. All characters have a length of 2 bytes\n    bytes private constant ZALGO_OVER_LETTER = hex\"CCB4CCB5CCB6CCB7CCB8\";\n\n    /// @notice Number of characters that can be over a letter for Zalgo\n    uint256 private constant ZALGO_NUM_OVER = 5;\n\n    /// @notice UTF-8 encoding of all supported emojis. They are sorted by their length in bytes (all with 3 bytes first, then all with four bytes, ...)\n    /// For emojis with the same length, the emojis that do not support skin tone modifier come first.\n    /// @dev This string is generated by the script utils/gen_emoji_string.py\n    bytes private constant EMOJIS =\n        hex\"E29CA8E29C85E29D97E29AA1E29895E2AD90E29D8CE29ABDE29D93E28FB0E2AD95E29AABE29ABEE29894E29AAAE29C8BE29C8AF09F9882F09FA4A3F09F98ADF09F9898F09FA5B0F09F988DF09F988AF09F8E89F09F9881F09F9295F09FA5BAF09F9885F09F94A5F09F9984F09F9886F09FA497F09F9889F09F8E82F09FA494F09F9982F09F98B3F09FA5B3F09F988EF09F929CF09F9894F09F9296F09F9180F09F988BF09F988FF09F98A2F09F9297F09F98A9F09F92AFF09F8CB9F09F929EF09F8E88F09F9299F09F9883F09F98A1F09F9290F09F989CF09F9988F09F9884F09FA4A4F09FA4AAF09F9880F09F928BF09F9280F09F9294F09F988CF09F9293F09FA4A9F09F9983F09F98ACF09F98B1F09F98B4F09FA4ADF09F9890F09F8C9EF09F9892F09F9887F09F8CB8F09F9888F09F8EB6F09F8E8AF09FA5B5F09F989EF09F929AF09F96A4F09F92B0F09F989AF09F9191F09F8E81F09F92A5F09F9891F09FA5B4F09F92A9F09FA4AEF09F98A4F09FA4A2F09F8C9FF09F98A5F09F8C88F09F929BF09F989DF09F98ABF09F98B2F09F94B4F09F8CBBF09FA4AFF09FA4ACF09F9895F09F8D80F09F92A6F09FA68BF09FA4A8F09F8CBAF09F98B9F09F8CB7F09F929DF09F92A4F09F90B0F09F9893F09F9298F09F8DBBF09F989FF09F98A3F09FA790F09F98A0F09FA4A0F09F98BBF09F8C99F09F989BF09F998AF09FA7A1F09FA4A1F09FA4ABF09F8CBCF09FA582F09F98B7F09FA493F09FA5B6F09F98B6F09F9896F09F8EB5F09F9899F09F8D86F09FA491F09F9897F09F90B6F09F8D93F09F9185F09F9184F09F8CBFF09F9AA8F09F93A3F09F8D91F09F8D83F09F98AEF09F928EF09F93A2F09F8CB1F09F9981F09F8DB7F09F98AAF09F8C9AF09F8F86F09F8D92F09F9289F09F92A2F09F9B92F09F98B8F09F90BEF09F9A80F09F8EAFF09F8DBAF09F938CF09F93B7F09F92A8F09F8D95F09F8FA0F09F93B8F09F9087F09F9AA9F09F98B0F09F8C8AF09F9095F09F92ABF09F98B5F09F8EA4F09F8FA1F09FA580F09FA4A7F09F8DBEF09F8DB0F09F8D81F09F98AFF09F928CF09F92B8F09FA781F09F98BAF09F92A7F09F92A3F09FA490F09F8D8EF09F90B7F09F90A5F09F938DF09F8E80F09FA587F09F8C9DF09F94ABF09F90B1F09F90A3F09F8EA7F09F929FF09F91B9F09F928DF09F8DBCF09F92A1F09F98BDF09F8D8AF09F98A8F09F8DABF09FA7A2F09FA495F09F9AABF09F8EBCF09F90BBF09F93B2F09F91BBF09F91BFF09F8CAEF09F8DADF09F909FF09F90B8F09F909DF09F9088F09F94B5F09F94AAF09F98A7F09F8C84F09F98BEF09F93B1F09F8D87F09F8CB4F09F90A2F09F8C83F09F91BDF09F8D8CF09F93BAF09F9494F09F8C85F09FA684F09F8EA5F09F8D8BF09FA59AF09F92B2F09F939AF09F9094F09F8EB8F09FA583F09F98BFF09F9A97F09F8C8EF09F948AF09FA685F09F9ABFF09FA686F09F8D89F09F8DACF09FA7B8F09F8DA8F09F939DF09F93A9F09F92B5F09F92ADF09F8C8DF09F8DBFF09FA7BFF09F8F80F09F8D8FF09F8CB3F09F9989F09F98A6F09F8DB9F09F8DA6F09F9B91F09F8D94F09F8D82F09F9092F09F8DAAF09F9980F09F8D97F09F8CA0F09F8EACF09F8CB5F09F8D84F09F9090F09F8DA9F09FA681F09F939EF09F8D85F09F908DF09F92ACF09FA5A4F09F98BCF09F8CBEF09FA780F09F8EAEF09FA7A0F09F8C8FF09F949DF09F8C89F09FA492F09F9197F09F8CB2F09F8D9CF09F90A6F09F8DAFF09F8F85F09F90BCF09F9284F09F91BAF09F949EF09F8E86F09F8EA8F09F8D9EF09F8E87F09FA69CF09F9091F09F9099F09FA68DF09F9497F09F9396F09F94B9F09FA593F09FA592F09F8DB8F09F918DF09F998FF09FA4A6F09FA4B7F09F918FF09F918CF09F92AAF09F9189F09FA49EF09F998CF09F9187F09F998BF09F9188F09F918BF09F9695F09F9283F09F918AF09F8F83F09FA498F09FA49DF09FA499F09F9AB6F09F9285F09FA49FF09F918EF09F9987F09F91B6F09FA4B2F09F9186F09F95BAF09F9281F09F9985F09FA79AF09FA4B8F09F9190F09FA49AF09F91BCF09F91A7F09FA49CF09FA4B0F09FA798F09F9986F09F91B8F09F91A6F09F9B8CF09FA49BF09F91AEE29DA4EFB88FE298BAEFB88FE299A5EFB88FE29DA3EFB88FE29C8CEFB88FE29880EFB88FE298B9EFB88FE280BCEFB88FE298A0EFB88FE29EA1EFB88FE29AA0EFB88FE29C94EFB88FE2989DEFB88FE2AC87EFB88FE29D84EFB88FE28189EFB88FE2988EEFB88FE29C9DEFB88FE29898EFB88FE29C88EFB88FE296B6EFB88FE29C8DEFB88FE2AC85EFB88FE29881EFB88FE29891EFB88FE299BBEFB88FF09F9181EFB88FF09F9690EFB88FF09F97A3EFB88FF09F8CA7EFB88FF09F958AEFB88FF09F8FB5EFB88FF09F8F96EFB88FF09F87BAF09F87B8F09F87A7F09F87B7F09F87BAF09F87B2F09F8FB3EFB88FE2808DF09F8C88\";\n\n    /// @notice These constants are used to efficiently parse the UTF-8 encoding of the emojis. They enable constant time lookup of any character.\n    /// This is done by storing the byte offset where each group (with the same length) starts and by storing the amount per group.\n    /// Furthermore, we store the number of emojis where the skin tone can be modified such that we can revert when this is not supported (and would result in wrong characters).\n\n    /// @notice LE refers to \"less or equal than\", i.e. we store the amount of emojis that are less or equal than 3, 4, 6, 7, 8 bytes\n    uint256 private constant EMOJIS_LE_THREE_BYTES = 17;\n    uint256 private constant EMOJIS_LE_FOUR_BYTES = 383;\n    uint256 private constant EMOJIS_LE_SIX_BYTES = 409;\n    uint256 private constant EMOJIS_LE_SEVEN_BYTES = 416;\n    uint256 private constant EMOJIS_LE_EIGHT_BYTES = 419;\n    // uint256 constant EMOJIS_LE_FOURTEEN_BYTES = 420;\n\n    /// @notice Number of emojis where the skin tone can be modified for three and four bytes\n    uint256 private constant EMOJIS_MOD_SKIN_TONE_THREE_BYTES = 2;\n    uint256 private constant EMOJIS_MOD_SKIN_TONE_FOUR_BYTES = 47;\n    // 0 for 7, 8, 14 bytes\n\n    /// @notice Byte offset where the groups start\n    uint256 private constant EMOJIS_BYTE_OFFSET_FOUR_BYTES = 51; // 17 * 3\n    uint256 private constant EMOJIS_BYTE_OFFSET_SIX_BYTES = 1515; // 17 * 3 + 366 * 4\n    uint256 private constant EMOJIS_BYTE_OFFSET_SEVEN_BYTES = 1671; // 17 * 3 + 366 * 4 + 26 * 6\n    uint256 private constant EMOJIS_BYTE_OFFSET_EIGHT_BYTES = 1720; // 17 * 3 + 366 * 4 + 26 * 6 + 7 * 7\n    uint256 private constant EMOJIS_BYTE_OFFSET_FOURTEEN_BYTES = 1744; // 17 * 3 + 366 * 4 + 26 * 6 + 7 * 7 + 3 * 8\n\n    /// @notice Convert a given font class, character index, and a seed (for font classes with randomness) to their Unicode representation as bytes\n    /// @param _fontClass The class to convert\n    /// @param _characterIndex Index within the class\n    /// @param _characterModifier Some characters have numeric modifiers (skin tone modifier for emojis, seed generated at minting for zalgo)\n    function characterToUnicodeBytes(\n        uint8 _fontClass,\n        uint16 _characterIndex,\n        uint256 _characterModifier\n    ) internal pure returns (bytes memory) {\n        if (_fontClass == 0) {\n            // Emojis\n            uint256 byteOffset;\n            uint256 numB"
    }
  ]
}