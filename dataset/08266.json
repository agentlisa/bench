{
  "Title": "[M-03] Malicious manipulation of gas reserve can deny access to MIMOProxy",
  "Content": "_Submitted by horsefacts, also found by giovannidisiena and Lambda_\n\n<https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/proxy/MIMOProxy.sol#L18-L19>\n\n<https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/proxy/MIMOProxy.sol#L74-L79>\n\n### Vulnerability Details\n\nThe `MIMOProxy` contract defines a `minGasReserve` value as a storage variable:\n\n[`MIMOProxy.sol#L18`](https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/proxy/MIMOProxy.sol#L18-L19):\n\n```solidity\n  /// @inheritdoc IMIMOProxy\n  uint256 public override minGasReserve;\n```\n\nThe `execute` function uses this `minGasReserve` value to calculate a gas stipend to provide to the target contract when executing a `delegatecall`:\n\n[`MIMOProxy.sol#L74`](https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/proxy/MIMOProxy.sol#L74-L79):\n\n```solidity\n    // Reserve some gas to ensure that the function has enough to finish the execution.\n    uint256 stipend = gasleft() - minGasReserve;\n\n    // Delegate call to the target contract.\n    bool success;\n    (success, response) = target.delegatecall{ gas: stipend }(data);\n```\n\nAlthough `minGasReserve` is a public storage variable, it has no corresponding setter function. There used to be one in the upstream `PRBProxy`, but it was [removed](https://github.com/paulrberg/prb-proxy/blob/main/CHANGELOG.md#removed) in version 2.0. The intent of this change was to simplify the proxy contract, while allowing users to `delegatecall` to their own target contract to [set this value](https://github.com/paulrberg/prb-proxy/issues/21) if necessary.\n\nHowever, a malicious target contract can permanently block access to a `MIMOProxy` by setting `minGasReserve` to a very high value and forcing an underflow in the gas stipend calculation:\n\n[`MIMOProxy.sol#L75`](https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/proxy/MIMOProxy.sol#L74-L75)\n\n```solidity\n    // Reserve some gas to ensure that the function has enough to finish the execution.\n    uint256 stipend = gasleft() - minGasReserve;\n```\n\nIf a target contract intentionally or accidentally sets `minGasReserve` to a value higher than the block gas limit, the `execute` function will always underflow and revert. In this scenario, it is impossible to set `minGasReserve` back to a reasonable value, since the change must be made through the `execute` function.\n\n**Impact:** If a user intentionally or accidentally sets a high `minGasReserve`, they may permanently lose access to their `MIMOProxy`. Malicious target contracts may attempt to trick users into bricking their proxy contracts using this method.\n\n### Recommended Mitigation Steps\n\nRestore the `setMinGasReserve` function removed in `PRBProxy` v2.0, which will allow the proxy owner to directly set this value:\n\n```solidity\n    function setMinGasReserve(uint256 newMinGasReserve) external override {\n        if (owner != msg.sender) {\n            revert CustomErrors.NOT_OWNER(owner, msg.sender);\n        }\n        minGasReserve = newMinGasReserve;\n    }\n```\n\n#### Test cases\n\nWe'll use this `ProxyAttacks` helper contract to manipulate proxy storage. Note that it has the same storage layout as `MIMOProxy`.\n\n```solidity\ncontract ProxyAttacks {\n\n   address public owner;\n   uint256 public minGasReserve;\n   mapping(address => mapping(address => mapping(bytes4 => bool))) internal _permissions;\n\n   // Selector 0xf613a687\n   function returnTrue() external pure returns (bool) {\n     return true;\n   }\n\n   // Selector 0x5f9981ae\n   function setGasReserve() external {\n     minGasReserve = type(uint256).max;\n   }\n}\n```\n\nThen deploy the `ProxyAttacks` helper in a test environment and use `MIMOProxy` to `delegatecall` into it:\n\n```typescript\nimport chai, { expect } from 'chai';\nimport { solidity } from 'ethereum-waffle';\nimport { deployments, ethers } from 'hardhat';\n\nimport { MIMOProxy, MIMOProxyFactory, MIMOProxyRegistry, ProxyAttacks } from '../../typechain';\n\nchai.use(solidity);\n\nconst setup = deployments.createFixture(async () => {\n  const { deploy } = deployments;\n  const [owner, attacker] = await ethers.getSigners();\n\n  await deploy(\"MIMOProxy\", {\n    from: owner.address,\n    args: [],\n  });\n  const mimoProxyBase: MIMOProxy = await ethers.getContract(\"MIMOProxy\");\n\n  await deploy(\"MIMOProxyFactory\", {\n    from: owner.address,\n    args: [mimoProxyBase.address],\n  });\n  const mimoProxyFactory: MIMOProxyFactory = await ethers.getContract(\"MIMOProxyFactory\");\n\n  await deploy(\"MIMOProxyRegistry\", {\n    from: owner.address,\n    args: [mimoProxyFactory.address],\n  });\n  const mimoProxyRegistry: MIMOProxyRegistry = await ethers.getContract(\"MIMOProxyRegistry\");\n\n  await deploy(\"ProxyAttacks\", {\n    from: owner.address,\n    args: [],\n  });\n  const proxyAttacks: ProxyAttacks = await ethers.getContract(\"ProxyAttacks\");\n\n  return {\n    owner,\n    attacker,\n    mimoProxyBase,\n    mimoProxyFactory,\n    mimoProxyRegistry,\n    proxyAttacks,\n  };\n});\n\ndescribe(\"Proxy attack tests\", () => {\n  it(\"DoS by manipulating gas reserve\", async () => {\n    const { owner, mimoProxyRegistry, proxyAttacks } = await setup();\n    await mimoProxyRegistry.deploy();\n    const currentProxy = await mimoProxyRegistry.getCurrentProxy(owner.address);\n\n    const proxy = await ethers.getContractAt(\"MIMOProxy\", currentProxy);\n\n    // Call setGasReserve on ProxyAttacks contract\n    await proxy.execute(proxyAttacks.address, \"0x5f9981ae\");\n\n    // Proxy's minGasReserve is now type(uint256).max\n    expect(await proxy.minGasReserve()).to.equal(ethers.constants.MaxUint256);\n\n    // All calls revert due to underflow calculating gas stipend\n    await expect(proxy.execute(proxyAttacks.address, \"0xf613a687\")).to.be.revertedWith(\n      \"Arithmetic operation underflowed or overflowed outside of an unchecked block\",\n    );\n  });\n});\n```\n\n**[RnkSngh (Mimo) marked as duplicate](https://github.com/code-423n4/2022-08-mimo-findings/issues/158#issuecomment-1210483560):**\n > Duplicate of [#161](https://github.com/code-423n4/2022-08-mimo-findings/issues/161). \n\n**[gzeoneth (judge) commented](https://github.com/code-423n4/2022-08-mimo-findings/issues/158#issuecomment-1221557802):**\n > Not a duplicate due to griefing by minGasReserve.\n\n**horsefacts (warden) reviewed mitigation:**\n> **Status:** âœ… Resolved\n\n> **Finding:** Wardens identified that users could lose access to their `MIMOProxy` by setting a high minimum gas reserve using `delegatecall`.\n\n> **What changed:** The minimum gas reserve by proxy address is now stored in the `_proxyStates` mapping in `MIMOProxyFactory`. The proxy owner may update the minimum gas reserve value for their proxy by calling the `setMinGas` function. This behavior is demonstrated by a unit test [here](https://github.com/mimo-capital/2022-08-mimo/blob/4e579420ecbe3fc3e770996610e6ab66b0c8d15b/test/01_unit/proxy/MIMOProxyFactory.test.ts#L204).\n>Only the owner may call `setMinGas`. Authorization behavior is demonstrated by a unit test [here](https://github.com/mimo-capital/2022-08-mimo/blob/4e579420ecbe3fc3e770996610e6ab66b0c8d15b/test/01_unit/proxy/MIMOProxyFactory.test.ts#L215).\n\n> **Why it works:** Since `minGasReserve` is no longer stored in `MIMOProxy` storage, it cannot be manipulated as described in the original finding.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-08-mimo-august-2022-contest",
  "Code": [
    {
      "filename": "contracts/proxy/MIMOProxy.sol",
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport \"../libraries/BoringBatchable.sol\";\nimport \"./interfaces/IMIMOProxy.sol\";\nimport { CustomErrors } from \"../libraries/CustomErrors.sol\";\n\n/// @title MIMOProxy\n/// @notice Used as a proxy to access VaultsCore from a user or a rebalancer\ncontract MIMOProxy is IMIMOProxy, Initializable, BoringBatchable {\n  /// PUBLIC STORAGE ///\n\n  /// @inheritdoc IMIMOProxy\n  address public override owner;\n\n  /// @inheritdoc IMIMOProxy\n  uint256 public override minGasReserve;\n\n  /// INTERNAL STORAGE ///\n\n  /// @notice Maps envoys to target contracts to function selectors to boolean flags.\n  mapping(address => mapping(address => mapping(bytes4 => bool))) internal _permissions;\n\n  /// CONSTRUCTOR ///\n\n  /// @inheritdoc IMIMOProxy\n  function initialize() external initializer {\n    minGasReserve = 5_000;\n    owner = msg.sender;\n    emit TransferOwnership(address(0), msg.sender);\n  }\n\n  /// FALLBACK FUNCTION ///\n\n  /// @dev Called when Ether is sent and the call data is empty.\n  receive() external payable {}\n\n  /// PUBLIC CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxy\n  function getPermission(\n    address envoy,\n    address target,\n    bytes4 selector\n  ) external view override returns (bool) {\n    return _permissions[envoy][target][selector];\n  }\n\n  /// PUBLIC NON-CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxy\n  function execute(address target, bytes calldata data) public payable override returns (bytes memory response) {\n    // Check that the caller is either the owner or an envoy.\n    if (owner != msg.sender) {\n      bytes4 selector;\n      assembly {\n        selector := calldataload(data.offset)\n      }\n      if (!_permissions[msg.sender][target][selector]) {\n        revert CustomErrors.EXECUTION_NOT_AUTHORIZED(owner, msg.sender, target, selector);\n      }\n    }\n\n    // Check that the target is a valid contract.\n    if (target.code.length == 0) {\n      revert CustomErrors.TARGET_INVALID(target);\n    }\n\n    // Save the owner address in memory. This local variable cannot be modified during the DELEGATECALL.\n    address owner_ = owner;\n\n    // Reserve some gas to ensure that the function has enough to finish the execution.\n    uint256 stipend = gasleft() - minGasReserve;\n\n    // Delegate call to the target contract.\n    bool success;\n    (success, response) = target.delegatecall{ gas: stipend }(data);\n\n    // Check that the owner has not been changed.\n    if (owner_ != owner) {\n      revert CustomErrors.OWNER_CHANGED(owner_, owner);\n    }\n\n    // Log the execution.\n    emit Execute(target, data, response);\n\n    // Check if the call was successful or not.\n    if (!success) {\n      // If there is return data, the call reverted with a reason or a custom error.\n      if (response.length > 0) {\n        assembly {\n          let returndata_size := mload(response)\n          revert(add(32, response), returndata_size)\n        }\n      } else {\n        revert CustomErrors.EXECUTION_REVERTED();\n      }\n    }\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function setPermission(\n    address envoy,\n    address target,\n    bytes4 selector,\n    bool permission\n  ) public override {\n    if (owner != msg.sender) {\n      revert CustomErrors.NOT_OWNER(owner, msg.sender);\n    }\n    _permissions[envoy][target][selector] = permission;\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function transferOwnership(address newOwner) external override {\n    address oldOwner = owner;\n    if (oldOwner != msg.sender) {\n      revert CustomErrors.NOT_OWNER(oldOwner, msg.sender);\n    }\n    owner = newOwner;\n    emit TransferOwnership(oldOwner, newOwner);\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function multicall(address[] calldata targets, bytes[] calldata data) external override returns (bytes[] memory) {\n    if (msg.sender != owner) {\n      revert CustomErrors.NOT_OWNER(owner, msg.sender);\n    }\n    bytes[] memory results = new bytes[](data.length);\n    for (uint256 i = 0; i < targets.length; i++) {\n      (bool success, bytes memory response) = targets[i].call(data[i]);\n      if (!success) {\n        if (response.length > 0) {\n          assembly {\n            let returndata_size := mload(response)\n            revert(add(32, response), returndata_size)\n          }\n        } else {\n          revert CustomErrors.LOW_LEVEL_CALL_FAILED();\n        }\n      }\n      results[i] = response;\n    }\n    return results;\n  }\n}"
    },
    {
      "filename": "contracts/proxy/MIMOProxy.sol",
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport \"../libraries/BoringBatchable.sol\";\nimport \"./interfaces/IMIMOProxy.sol\";\nimport { CustomErrors } from \"../libraries/CustomErrors.sol\";\n\n/// @title MIMOProxy\n/// @notice Used as a proxy to access VaultsCore from a user or a rebalancer\ncontract MIMOProxy is IMIMOProxy, Initializable, BoringBatchable {\n  /// PUBLIC STORAGE ///\n\n  /// @inheritdoc IMIMOProxy\n  address public override owner;\n\n  /// @inheritdoc IMIMOProxy\n  uint256 public override minGasReserve;\n\n  /// INTERNAL STORAGE ///\n\n  /// @notice Maps envoys to target contracts to function selectors to boolean flags.\n  mapping(address => mapping(address => mapping(bytes4 => bool))) internal _permissions;\n\n  /// CONSTRUCTOR ///\n\n  /// @inheritdoc IMIMOProxy\n  function initialize() external initializer {\n    minGasReserve = 5_000;\n    owner = msg.sender;\n    emit TransferOwnership(address(0), msg.sender);\n  }\n\n  /// FALLBACK FUNCTION ///\n\n  /// @dev Called when Ether is sent and the call data is empty.\n  receive() external payable {}\n\n  /// PUBLIC CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxy\n  function getPermission(\n    address envoy,\n    address target,\n    bytes4 selector\n  ) external view override returns (bool) {\n    return _permissions[envoy][target][selector];\n  }\n\n  /// PUBLIC NON-CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxy\n  function execute(address target, bytes calldata data) public payable override returns (bytes memory response) {\n    // Check that the caller is either the owner or an envoy.\n    if (owner != msg.sender) {\n      bytes4 selector;\n      assembly {\n        selector := calldataload(data.offset)\n      }\n      if (!_permissions[msg.sender][target][selector]) {\n        revert CustomErrors.EXECUTION_NOT_AUTHORIZED(owner, msg.sender, target, selector);\n      }\n    }\n\n    // Check that the target is a valid contract.\n    if (target.code.length == 0) {\n      revert CustomErrors.TARGET_INVALID(target);\n    }\n\n    // Save the owner address in memory. This local variable cannot be modified during the DELEGATECALL.\n    address owner_ = owner;\n\n    // Reserve some gas to ensure that the function has enough to finish the execution.\n    uint256 stipend = gasleft() - minGasReserve;\n\n    // Delegate call to the target contract.\n    bool success;\n    (success, response) = target.delegatecall{ gas: stipend }(data);\n\n    // Check that the owner has not been changed.\n    if (owner_ != owner) {\n      revert CustomErrors.OWNER_CHANGED(owner_, owner);\n    }\n\n    // Log the execution.\n    emit Execute(target, data, response);\n\n    // Check if the call was successful or not.\n    if (!success) {\n      // If there is return data, the call reverted with a reason or a custom error.\n      if (response.length > 0) {\n        assembly {\n          let returndata_size := mload(response)\n          revert(add(32, response), returndata_size)\n        }\n      } else {\n        revert CustomErrors.EXECUTION_REVERTED();\n      }\n    }\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function setPermission(\n    address envoy,\n    address target,\n    bytes4 selector,\n    bool permission\n  ) public override {\n    if (owner != msg.sender) {\n      revert CustomErrors.NOT_OWNER(owner, msg.sender);\n    }\n    _permissions[envoy][target][selector] = permission;\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function transferOwnership(address newOwner) external override {\n    address oldOwner = owner;\n    if (oldOwner != msg.sender) {\n      revert CustomErrors.NOT_OWNER(oldOwner, msg.sender);\n    }\n    owner = newOwner;\n    emit TransferOwnership(oldOwner, newOwner);\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function multicall(address[] calldata targets, bytes[] calldata data) external override returns (bytes[] memory) {\n    if (msg.sender != owner) {\n      revert CustomErrors.NOT_OWNER(owner, msg.sender);\n    }\n    bytes[] memory results = new bytes[](data.length);\n    for (uint256 i = 0; i < targets.length; i++) {\n      (bool success, bytes memory response) = targets[i].call(data[i]);\n      if (!success) {\n        if (response.length > 0) {\n          assembly {\n            let returndata_size := mload(response)\n            revert(add(32, response), returndata_size)\n          }\n        } else {\n          revert CustomErrors.LOW_LEVEL_CALL_FAILED();\n        }\n      }\n      results[i] = response;\n    }\n    return results;\n  }\n}"
    },
    {
      "filename": "contracts/proxy/MIMOProxy.sol",
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport \"../libraries/BoringBatchable.sol\";\nimport \"./interfaces/IMIMOProxy.sol\";\nimport { CustomErrors } from \"../libraries/CustomErrors.sol\";\n\n/// @title MIMOProxy\n/// @notice Used as a proxy to access VaultsCore from a user or a rebalancer\ncontract MIMOProxy is IMIMOProxy, Initializable, BoringBatchable {\n  /// PUBLIC STORAGE ///\n\n  /// @inheritdoc IMIMOProxy\n  address public override owner;\n\n  /// @inheritdoc IMIMOProxy\n  uint256 public override minGasReserve;\n\n  /// INTERNAL STORAGE ///\n\n  /// @notice Maps envoys to target contracts to function selectors to boolean flags.\n  mapping(address => mapping(address => mapping(bytes4 => bool))) internal _permissions;\n\n  /// CONSTRUCTOR ///\n\n  /// @inheritdoc IMIMOProxy\n  function initialize() external initializer {\n    minGasReserve = 5_000;\n    owner = msg.sender;\n    emit TransferOwnership(address(0), msg.sender);\n  }\n\n  /// FALLBACK FUNCTION ///\n\n  /// @dev Called when Ether is sent and the call data is empty.\n  receive() external payable {}\n\n  /// PUBLIC CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxy\n  function getPermission(\n    address envoy,\n    address target,\n    bytes4 selector\n  ) external view override returns (bool) {\n    return _permissions[envoy][target][selector];\n  }\n\n  /// PUBLIC NON-CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxy\n  function execute(address target, bytes calldata data) public payable override returns (bytes memory response) {\n    // Check that the caller is either the owner or an envoy.\n    if (owner != msg.sender) {\n      bytes4 selector;\n      assembly {\n        selector := calldataload(data.offset)\n      }\n      if (!_permissions[msg.sender][target][selector]) {\n        revert CustomErrors.EXECUTION_NOT_AUTHORIZED(owner, msg.sender, target, selector);\n      }\n    }\n\n    // Check that the target is a valid contract.\n    if (target.code.length == 0) {\n      revert CustomErrors.TARGET_INVALID(target);\n    }\n\n    // Save the owner address in memory. This local variable cannot be modified during the DELEGATECALL.\n    address owner_ = owner;\n\n    // Reserve some gas to ensure that the function has enough to finish the execution.\n    uint256 stipend = gasleft() - minGasReserve;\n\n    // Delegate call to the target contract.\n    bool success;\n    (success, response) = target.delegatecall{ gas: stipend }(data);\n\n    // Check that the owner has not been changed.\n    if (owner_ != owner) {\n      revert CustomErrors.OWNER_CHANGED(owner_, owner);\n    }\n\n    // Log the execution.\n    emit Execute(target, data, response);\n\n    // Check if the call was successful or not.\n    if (!success) {\n      // If there is return data, the call reverted with a reason or a custom error.\n      if (response.length > 0) {\n        assembly {\n          let returndata_size := mload(response)\n          revert(add(32, response), returndata_size)\n        }\n      } else {\n        revert CustomErrors.EXECUTION_REVERTED();\n      }\n    }\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function setPermission(\n    address envoy,\n    address target,\n    bytes4 selector,\n    bool permission\n  ) public override {\n    if (owner != msg.sender) {\n      revert CustomErrors.NOT_OWNER(owner, msg.sender);\n    }\n    _permissions[envoy][target][selector] = permission;\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function transferOwnership(address newOwner) external override {\n    address oldOwner = owner;\n    if (oldOwner != msg.sender) {\n      revert CustomErrors.NOT_OWNER(oldOwner, msg.sender);\n    }\n    owner = newOwner;\n    emit TransferOwnership(oldOwner, newOwner);\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function multicall(address[] calldata targets, bytes[] calldata data) external override returns (bytes[] memory) {\n    if (msg.sender != owner) {\n      revert CustomErrors.NOT_OWNER(owner, msg.sender);\n    }\n    bytes[] memory results = new bytes[](data.length);\n    for (uint256 i = 0; i < targets.length; i++) {\n      (bool success, bytes memory response) = targets[i].call(data[i]);\n      if (!success) {\n        if (response.length > 0) {\n          assembly {\n            let returndata_size := mload(response)\n            revert(add(32, response), returndata_size)\n          }\n        } else {\n          revert CustomErrors.LOW_LEVEL_CALL_FAILED();\n        }\n      }\n      results[i] = response;\n    }\n    return results;\n  }\n}"
    },
    {
      "filename": "contracts/proxy/MIMOProxy.sol",
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport \"../libraries/BoringBatchable.sol\";\nimport \"./interfaces/IMIMOProxy.sol\";\nimport { CustomErrors } from \"../libraries/CustomErrors.sol\";\n\n/// @title MIMOProxy\n/// @notice Used as a proxy to access VaultsCore from a user or a rebalancer\ncontract MIMOProxy is IMIMOProxy, Initializable, BoringBatchable {\n  /// PUBLIC STORAGE ///\n\n  /// @inheritdoc IMIMOProxy\n  address public override owner;\n\n  /// @inheritdoc IMIMOProxy\n  uint256 public override minGasReserve;\n\n  /// INTERNAL STORAGE ///\n\n  /// @notice Maps envoys to target contracts to function selectors to boolean flags.\n  mapping(address => mapping(address => mapping(bytes4 => bool))) internal _permissions;\n\n  /// CONSTRUCTOR ///\n\n  /// @inheritdoc IMIMOProxy\n  function initialize() external initializer {\n    minGasReserve = 5_000;\n    owner = msg.sender;\n    emit TransferOwnership(address(0), msg.sender);\n  }\n\n  /// FALLBACK FUNCTION ///\n\n  /// @dev Called when Ether is sent and the call data is empty.\n  receive() external payable {}\n\n  /// PUBLIC CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxy\n  function getPermission(\n    address envoy,\n    address target,\n    bytes4 selector\n  ) external view override returns (bool) {\n    return _permissions[envoy][target][selector];\n  }\n\n  /// PUBLIC NON-CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxy\n  function execute(address target, bytes calldata data) public payable override returns (bytes memory response) {\n    // Check that the caller is either the owner or an envoy.\n    if (owner != msg.sender) {\n      bytes4 selector;\n      assembly {\n        selector := calldataload(data.offset)\n      }\n      if (!_permissions[msg.sender][target][selector]) {\n        revert CustomErrors.EXECUTION_NOT_AUTHORIZED(owner, msg.sender, target, selector);\n      }\n    }\n\n    // Check that the target is a valid contract.\n    if (target.code.length == 0) {\n      revert CustomErrors.TARGET_INVALID(target);\n    }\n\n    // Save the owner address in memory. This local variable cannot be modified during the DELEGATECALL.\n    address owner_ = owner;\n\n    // Reserve some gas to ensure that the function has enough to finish the execution.\n    uint256 stipend = gasleft() - minGasReserve;\n\n    // Delegate call to the target contract.\n    bool success;\n    (success, response) = target.delegatecall{ gas: stipend }(data);\n\n    // Check that the owner has not been changed.\n    if (owner_ != owner) {\n      revert CustomErrors.OWNER_CHANGED(owner_, owner);\n    }\n\n    // Log the execution.\n    emit Execute(target, data, response);\n\n    // Check if the call was successful or not.\n    if (!success) {\n      // If there is return data, the call reverted with a reason or a custom error.\n      if (response.length > 0) {\n        assembly {\n          let returndata_size := mload(response)\n          revert(add(32, response), returndata_size)\n        }\n      } else {\n        revert CustomErrors.EXECUTION_REVERTED();\n      }\n    }\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function setPermission(\n    address envoy,\n    address target,\n    bytes4 selector,\n    bool permission\n  ) public override {\n    if (owner != msg.sender) {\n      revert CustomErrors.NOT_OWNER(owner, msg.sender);\n    }\n    _permissions[envoy][target][selector] = permission;\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function transferOwnership(address newOwner) external override {\n    address oldOwner = owner;\n    if (oldOwner != msg.sender) {\n      revert CustomErrors.NOT_OWNER(oldOwner, msg.sender);\n    }\n    owner = newOwner;\n    emit TransferOwnership(oldOwner, newOwner);\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function multicall(address[] calldata targets, bytes[] calldata data) external override returns (bytes[] memory) {\n    if (msg.sender != owner) {\n      revert CustomErrors.NOT_OWNER(owner, msg.sender);\n    }\n    bytes[] memory results = new bytes[](data.length);\n    for (uint256 i = 0; i < targets.length; i++) {\n      (bool success, bytes memory response) = targets[i].call(data[i]);\n      if (!success) {\n        if (response.length > 0) {\n          assembly {\n            let returndata_size := mload(response)\n            revert(add(32, response), returndata_size)\n          }\n        } else {\n          revert CustomErrors.LOW_LEVEL_CALL_FAILED();\n        }\n      }\n      results[i] = response;\n    }\n    return results;\n  }\n}"
    },
    {
      "filename": "CHANGELOG.md",
      "content": "# Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Common Changelog](https://common-changelog.org/), and this project adheres to\n[Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n[4.0.2]: https://github.com/PaulRBerg/prb-proxy/compare/v4.0.1...v4.0.2\n[4.0.1]: https://github.com/PaulRBerg/prb-proxy/compare/v4.0.0...v4.0.1\n[4.0.0]: https://github.com/PaulRBerg/prb-proxy/compare/v2.0.0...v4.0.0\n[2.0.0]: https://github.com/PaulRBerg/prb-proxy/compare/v1.0.1...v2.0.0\n[1.0.1]: https://github.com/PaulRBerg/prb-proxy/compare/v1.0.0...v1.0.1\n[1.0.0]: https://github.com/PaulRBerg/prb-proxy/releases/tag/v1.0.0\n\n## [4.0.2] - 2023-12-28\n\n### Changed\n\n- Install `prb-test` and `forge-std` as Node.js packages ([#179](https://github.com/PaulRBerg/prb-proxy/pull/179)) (@andreivladbrg, @PaulRBerg)\n- Make Node.js the default installation option (@PaulRBerg)\n- Update import paths to include `src` ([#179](https://github.com/PaulRBerg/prb-proxy/pull/179)) (@PaulRBerg)\n- Use Solidity v0.8.23 ([#182](https://github.com/PaulRBerg/prb-proxy/pull/182)) (@PaulRBerg)\n\n### Added\n\n- Include `test/utils` in Node.js package ([#179](https://github.com/PaulRBerg/prb-proxy/pull/179)) (@andreivladbrg, @PaulRBerg)\n\n### Removed\n\n- Remove git submodules ([#179](https://github.com/PaulRBerg/prb-proxy/pull/179)) (@andreivladbrg, @PaulRBerg)\n\n## [4.0.1] - 2023-07-10\n\n### Changed\n\n- Improve documentation ([#163](https://github.com/PaulRBerg/prb-proxy/pull/163)) (@PaulRBerg, @IaroslavMazur)\n- Rename `noProxy` to `onlyNonProxyOwner` ([#165](https://github.com/PaulRBerg/prb-proxy/pull/165)) (@PaulRBerg, @IaroslavMazur)\n- Rename `owner` parameter to `user` ([#165](https://github.com/PaulRBerg/prb-proxy/pull/165)) (@PaulRBerg, @IaroslavMazur)\n\n### Removed\n\n- Remove unused errors ([#164](https://github.com/PaulRBerg/prb-proxy/pull/164)) (@PaulRBerg, @IaroslavMazur)\n\n## [4.0.0] - 2023-07-07\n\n_Version 3 has been skipped to keep the package version in sync with the contract version_\n\n### Changed\n\n- **Breaking**: Merge the registry and the factory ([#81](https://github.com/PaulRBerg/prb-proxy/pull/81)) (@PaulRBerg)\n- **Breaking**: Rename `getCurrentProxy` to `getProxy` (@PaulRBerg)\n- **Breaking**: Simplify the envoy permission system ([#72](https://github.com/PaulRBerg/prb-proxy/issues/73)) (@PaulRBerg)\n- **Breaking**: Use `owner` instead of `tx.origin` as CREATE2 salt ([#130](https://github.com/PaulRBerg/prb-proxy/pull/130)) (@PaulRBerg)\n- Bump Solidity pragmas (@PaulRBerg)\n- Change license to MIT ([#49](https://github.com/PaulRBerg/prb-proxy/issues/49)) (@PaulRBerg)\n- Rename custom errors to use single underscore ([b954b5](https://github.com/PaulRBerg/prb-proxy/commit/b954b5)) (@PaulRBerg)\n- Improve formatting and documentation (@PaulRBerg)\n- Lower pragma to `>=0.8.4` in interface files ([46a34c](https://github.com/PaulRBerg/prb-proxy/commit/46a34c)) (@PaulRBerg)\n- Make the `owner` an immutable variable ([#120](https://github.com/PaulRBerg/prb-proxy/pull/120)) (@PaulRBerg)\n- Make `VERSION` a string ([699f76](https://github.com/PaulRBerg/prb-proxy/commit/699f76)) (@PaulRBerg)\n- Reduce deployment size by setting optimizer runs to 200 ([c2f955](https://github.com/PaulRBerg/prb-proxy/commit/c2f955)) (@PaulRBerg)\n\n### Added\n\n- Add ability to deploy a proxy and execute a delegate call to a target in a single transaction (@PaulRBerg)\n- Add ASCII art (@PaulRBerg)\n- Add plugin system ([#53](https://github.com/PaulRBerg/prb-proxy/pull/53)) (@cleanunicorn, @PaulRBerg)\n- Emit event in `setPermission` ([b277fd](https://github.com/PaulRBerg/prb-proxy/commit/b277fd)) (@PaulRBerg)\n- Provide testing utilities for deploying precompiled bytecodes (@PaulRBerg)\n- Store the registry address as an immutable variable in the proxy (@PaulRBerg)\n\n### Removed\n\n- **Breaking**: Remove `PRBProxyFactory` contract ([#81](https://github.com/PaulRBerg/prb-proxy/pull/81)) (@PaulRBerg)\n- **Breaking**: Remove proxy storage ([#120](https://github.com/PaulRBerg/prb-proxy/pull/120)) (@PaulRBerg)\n- **Breaking**: Remove `transferOwnership` functionality ([#119](https://github.com/PaulRBerg/prb-proxy/pull/119)) (@PaulRBerg)\n\n### Fixed\n\n- Fix bug that permitted unintentional calls to fallback functions ([#50](https://github.com/PaulRBerg/prb-proxy/issues/50)) (@PaulRBerg)\n\n## [2.0.0] - 2022-03-10\n\n### Changed\n\n- Change the package name from `prb-proxy` to `@prb/proxy` (@PaulRBerg)\n- Change the extension for types from `.d.ts` to `.ts` (@PaulRBerg)\n- Upgrade to latest versions of `ethers` (@PaulRBerg)\n- Upgrade to Solidity v0.8.12 (@PaulRBerg)\n- Use modern Solidity `create2` instead of inline assembly ([#20](https://github.com/PaulRBerg/prb-proxy/pull/20)) (@transmissions11)\n- Use modern Solidity `target.code.length` instead of inline assembly (@PaulRBerg) ([#19](https://github.com/PaulRBerg/prb-proxy/pull/19))\n  (@transmissions11)\n\n### Added\n\n- Add support for Avalanche (@PaulRBerg)\n\n### Fixed\n\n- Fix old owner address in `TransferOwnership` ([#29](https://github.com/PaulRBerg/prb-proxy/pull/29) (@PaulRBerg)\n\n### Removed\n\n- Remove the `setMinGasReserve` function (@PaulRBerg)\n\n## [1.0.1] - 2021-10-18\n\n### Added\n\n- Include contracts in npm package (@PaulRBerg)\n\n### Fixed\n\n- Add `override` modifiers so that contacts can be imported in Solidity v0.8.7 and lower (@PaulRBerg)\n\n## [1.0.0] - 2021-10-18\n\n### Added\n\n- First release (@PaulRBerg)"
    },
    {
      "filename": "contracts/proxy/MIMOProxy.sol",
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport \"../libraries/BoringBatchable.sol\";\nimport \"./interfaces/IMIMOProxy.sol\";\nimport { CustomErrors } from \"../libraries/CustomErrors.sol\";\n\n/// @title MIMOProxy\n/// @notice Used as a proxy to access VaultsCore from a user or a rebalancer\ncontract MIMOProxy is IMIMOProxy, Initializable, BoringBatchable {\n  /// PUBLIC STORAGE ///\n\n  /// @inheritdoc IMIMOProxy\n  address public override owner;\n\n  /// @inheritdoc IMIMOProxy\n  uint256 public override minGasReserve;\n\n  /// INTERNAL STORAGE ///\n\n  /// @notice Maps envoys to target contracts to function selectors to boolean flags.\n  mapping(address => mapping(address => mapping(bytes4 => bool))) internal _permissions;\n\n  /// CONSTRUCTOR ///\n\n  /// @inheritdoc IMIMOProxy\n  function initialize() external initializer {\n    minGasReserve = 5_000;\n    owner = msg.sender;\n    emit TransferOwnership(address(0), msg.sender);\n  }\n\n  /// FALLBACK FUNCTION ///\n\n  /// @dev Called when Ether is sent and the call data is empty.\n  receive() external payable {}\n\n  /// PUBLIC CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxy\n  function getPermission(\n    address envoy,\n    address target,\n    bytes4 selector\n  ) external view override returns (bool) {\n    return _permissions[envoy][target][selector];\n  }\n\n  /// PUBLIC NON-CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxy\n  function execute(address target, bytes calldata data) public payable override returns (bytes memory response) {\n    // Check that the caller is either the owner or an envoy.\n    if (owner != msg.sender) {\n      bytes4 selector;\n      assembly {\n        selector := calldataload(data.offset)\n      }\n      if (!_permissions[msg.sender][target][selector]) {\n        revert CustomErrors.EXECUTION_NOT_AUTHORIZED(owner, msg.sender, target, selector);\n      }\n    }\n\n    // Check that the target is a valid contract.\n    if (target.code.length == 0) {\n      revert CustomErrors.TARGET_INVALID(target);\n    }\n\n    // Save the owner address in memory. This local variable cannot be modified during the DELEGATECALL.\n    address owner_ = owner;\n\n    // Reserve some gas to ensure that the function has enough to finish the execution.\n    uint256 stipend = gasleft() - minGasReserve;\n\n    // Delegate call to the target contract.\n    bool success;\n    (success, response) = target.delegatecall{ gas: stipend }(data);\n\n    // Check that the owner has not been changed.\n    if (owner_ != owner) {\n      revert CustomErrors.OWNER_CHANGED(owner_, owner);\n    }\n\n    // Log the execution.\n    emit Execute(target, data, response);\n\n    // Check if the call was successful or not.\n    if (!success) {\n      // If there is return data, the call reverted with a reason or a custom error.\n      if (response.length > 0) {\n        assembly {\n          let returndata_size := mload(response)\n          revert(add(32, response), returndata_size)\n        }\n      } else {\n        revert CustomErrors.EXECUTION_REVERTED();\n      }\n    }\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function setPermission(\n    address envoy,\n    address target,\n    bytes4 selector,\n    bool permission\n  ) public override {\n    if (owner != msg.sender) {\n      revert CustomErrors.NOT_OWNER(owner, msg.sender);\n    }\n    _permissions[envoy][target][selector] = permission;\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function transferOwnership(address newOwner) external override {\n    address oldOwner = owner;\n    if (oldOwner != msg.sender) {\n      revert CustomErrors.NOT_OWNER(oldOwner, msg.sender);\n    }\n    owner = newOwner;\n    emit TransferOwnership(oldOwner, newOwner);\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function multicall(address[] calldata targets, bytes[] calldata data) external override returns (bytes[] memory) {\n    if (msg.sender != owner) {\n      revert CustomErrors.NOT_OWNER(owner, msg.sender);\n    }\n    bytes[] memory results = new bytes[](data.length);\n    for (uint256 i = 0; i < targets.length; i++) {\n      (bool success, bytes memory response) = targets[i].call(data[i]);\n      if (!success) {\n        if (response.length > 0) {\n          assembly {\n            let returndata_size := mload(response)\n            revert(add(32, response), returndata_size)\n          }\n        } else {\n          revert CustomErrors.LOW_LEVEL_CALL_FAILED();\n        }\n      }\n      results[i] = response;\n    }\n    return results;\n  }\n}"
    },
    {
      "filename": "test/01_unit/proxy/MIMOProxyFactory.test.ts",
      "content": "import chai, { expect } from \"chai\";\nimport { deployMockContract, solidity } from \"ethereum-waffle\";\nimport { artifacts, deployments, ethers } from \"hardhat\";\nimport { MIMOLeverage, MIMOProxy, MIMOProxyFactory, MIMOProxyGuard, MockLendingPool } from \"../../../typechain\";\nimport { getSelector } from \"../../utils\";\n\nchai.use(solidity);\n\nconst setup = deployments.createFixture(async () => {\n  await deployments.fixture([\"Proxy\"]);\n  const { deploy } = deployments;\n  const [owner, alice, bob] = await ethers.getSigners();\n  const mimoProxyFactory: MIMOProxyFactory = await ethers.getContract(\"MIMOProxyFactory\");\n  const mimoProxyGuardBase: MIMOProxyGuard = await ethers.getContract(\"MIMOProxyGuard\");\n\n  const [addressProviderArtifact, dexAddressProviderArtifact] = await Promise.all([\n    artifacts.readArtifact(\"IAddressProvider\"),\n    artifacts.readArtifact(\"IDexAddressProvider\"),\n  ]);\n\n  const [addressProvider, dexAddressProvider] = await Promise.all([\n    deployMockContract(owner, addressProviderArtifact.abi),\n    deployMockContract(owner, dexAddressProviderArtifact.abi),\n  ]);\n\n  await deploy(\"MockLendingPool\", {\n    from: owner.address,\n    args: [],\n  });\n\n  const lendingPool: MockLendingPool = await ethers.getContract(\"MockLendingPool\");\n  await deploy(\"MIMOLeverage\", {\n    from: owner.address,\n    args: [addressProvider.address, dexAddressProvider.address, lendingPool.address, mimoProxyFactory.address],\n  });\n  const leverage: MIMOLeverage = await ethers.getContract(\"MIMOLeverage\");\n\n  return {\n    deploy,\n    owner,\n    alice,\n    bob,\n    mimoProxyFactory,\n    mimoProxyGuardBase,\n    leverage,\n  };\n});\n\ndescribe(\"--- MIMOProxyFactory Unit Tests ---\", () => {\n  it(\"should be able to deploy MIMOProxyFactory correctly\", async () => {\n    const { mimoProxyFactory, mimoProxyGuardBase } = await setup();\n    const _proxyGuardBase = await mimoProxyFactory.mimoProxyGuardBase();\n    expect(_proxyGuardBase).to.be.equal(mimoProxyGuardBase.address);\n  });\n  it(\"should revert if trying to set mimoProxyGuardBase to address 0\", async () => {\n    const { deploy, owner } = await setup();\n    await expect(\n      deploy(\"MIMOProxyFactory\", {\n        from: owner.address,\n        args: [ethers.constants.AddressZero],\n        skipIfAlreadyDeployed: false,\n      }),\n    ).to.be.revertedWith(\"CANNOT_SET_TO_ADDRESS_ZERO()\");\n  });\n  it(\"should be able to deploy proxy correctly\", async () => {\n    const { mimoProxyFactory, owner } = await setup();\n    const tx = await mimoProxyFactory.deploy();\n    const mimoProxyAddress = await mimoProxyFactory.getCurrentProxy(owner.address);\n    const mimoProxy: MIMOProxy = await ethers.getContractAt(\"MIMOProxy\", mimoProxyAddress);\n    const proxyState = await mimoProxyFactory.getProxyState(mimoProxy.address);\n    const _proxyFactory = await mimoProxy.proxyFactory();\n    const isProxy = await mimoProxyFactory.isProxy(mimoProxyAddress);\n    expect(mimoProxyAddress).to.not.be.equal(ethers.constants.AddressZero);\n    expect(_proxyFactory).to.be.equal(mimoProxyFactory.address);\n    expect(proxyState.owner).to.be.equal(owner.address);\n    expect(proxyState.proxyGuard).to.not.be.equal(ethers.constants.AddressZero);\n    expect(proxyState.minGas).to.be.equal(ethers.BigNumber.from(5000));\n    expect(isProxy).to.be.true;\n    await expect(tx).to.emit(mimoProxyFactory, \"ProxyDeployed\").withArgs(owner.address, mimoProxy.address, proxyState);\n  });\n  it(\"should revert if deployer already owns a proxy\", async () => {\n    const { mimoProxyFactory, owner } = await setup();\n    await mimoProxyFactory.deploy();\n    const mimoProxyAddress = await mimoProxyFactory.getCurrentProxy(owner.address);\n    await expect(mimoProxyFactory.deploy()).to.be.revertedWith(\n      `ALREADY_OWNER(\"${owner.address}\", \"${mimoProxyAddress}\")`,\n    );\n  });\n  it(\"should be able to transfer ownership correctly\", async () => {\n    const { mimoProxyFactory, owner, alice } = await setup();\n    await mimoProxyFactory.deploy();\n    const mimoProxyAddress = await mimoProxyFactory.getCurrentProxy(owner.address);\n    const tx_0 = await mimoProxyFactory.transferOwnership(mimoProxyAddress, alice.address);\n    const pendingOwnerBeforeClaim = await mimoProxyFactory.getPendingOwner(mimoProxyAddress);\n    const mimoProxyStateBeforeClaim = await mimoProxyFactory.getProxyState(mimoProxyAddress);\n    const tx_1 = await mimoProxyFactory.connect(alice).claimOwnership(mimoProxyAddress, false);\n    const aliceProxy = await mimoProxyFactory.getCurrentProxy(alice.address);\n    const pendingOwnerAfterClaim = await mimoProxyFactory.getPendingOwner(mimoProxyAddress);\n    const mimoProxyStateAfterClaim = await mimoProxyFactory.getProxyState(mimoProxyAddress);\n    expect(pendingOwnerBeforeClaim).to.be.equal(alice.address);\n    expect(mimoProxyStateBeforeClaim.owner).to.be.equal(owner.address);\n    expect"
    }
  ]
}