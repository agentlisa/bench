{
  "Title": "H-1: Tax refund is calculated based on the wrong amount",
  "Content": "# Issue H-1: Tax refund is calculated based on the wrong amount \n\nSource: https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/57 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nKrace, bughuntoor, s1ce, ydlee\n## Summary\nTax refund is calculated based on the wrong amount\n\n## Vulnerability Detail\nAfter the private period has finished, users can claim a tax refund, based on their max tax free allocation.\n```solidity\n        (s.share, left) = _claim(s);\n        require(left > 0, \"TokenSale: Nothing to claim\");\n        uint256 refundTaxAmount;\n        if (s.taxAmount > 0) {\n            uint256 tax = userTaxRate(s.amount, msg.sender);\n            uint256 taxFreeAllc = _maxTaxfreeAllocation(msg.sender) * PCT_BASE;\n            if (taxFreeAllc >= s.share) {\n                refundTaxAmount = s.taxAmount;\n            } else {\n                refundTaxAmount = (left * tax) / POINT_BASE;\n            }\n            usdc.safeTransferFrom(marketingWallet, msg.sender, refundTaxAmount);\n        }\n```\nThe problem is that in case `s.share > taxFreeAllc`, the tax refund is calculated wrongfully. Not only it should refund the tax on the unused USDC amount, but it should also refund the tax for the tax-free allocation the user has. \n\nImagine the following. \n1. User deposits 1000 USDC.\n2. Private period finishes, token oversells. Only half of the user's money actually go towards the sell (s.share = 500 USDC, s.left = 500 USDC)\n3. The user has 400 USDC tax-free allocation\n4. The user must be refunded the tax for the 500 unused USDC, as well as their 400 USDC tax-free allocation. In stead, they're only refunded for the 500 unused USDC. (note, if the user had 500 tax-free allocation, they would've been refunded all tax)\n\n\n## Impact\nUsers are not refunded enough tax \n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-03-zap-protocol/blob/main/zap-contracts-labs/contracts/TokenSale.sol#L385\n\n## Tool used\n\nManual Review\n\n## Recommendation\nchange the code to the following: \n```solidity\n                refundTaxAmount = ((left + taxFreeAllc) * tax) / POINT_BASE;\n```\n\n\n\n## Discussion\n\n**ZdravkoHr**\n\nEscalate \n\nUsers are not supposed to be refunded for the tax free allocation, same reasoning as in [58](https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/58#issuecomment-2025286194).\n\n**sherlock-admin2**\n\n> Escalate \n> \n> Users are not supposed to be refunded for the tax free allocation, same reasoning as in [58](https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/58#issuecomment-2025286194).\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**koreanspicygarlic1**\n\nescalation by watson is plain wrong. Users have taxfree allocation for which their tax should be refunded. The total refund should be for the taxfree allocation + tax on unused funds (s.left)\n\n**ZdravkoHr**\n\n@koreanspicygarlic1, users are not paying tax for the tax free allocation when depositing. What should they be refunded for then?\n\n**merc1995**\n\n@ZdravkoHr , users pay tax for the tax-free allocation when depositing because the `taxFreeAllcOfUser` is zero, as I mentioned in #7 .\n\n**vsharma4394**\n\n@merc1995 initially there is no tax free allocation so why should tax free amount be taken into consideration when claim function is called. The tax amount refunded to the user should be calculated for the left amount only i.e not taking into consideration the tax free amount. Otherwise every user would purposely make totalPrivateSold > totalSupplyValue so that they can avoid the tax.\n\n\n**merc1995**\n\n@vsharma4394 because the code says it should consider the tax free.\n\n```\n    function claim() external {\n        checkingEpoch();\n        require(\n            uint8(epoch) > 1 && !admin.blockClaim(address(this)),\n            \"TokenSale: Not time or not allowed\"\n        );\n\n        Staked storage s = stakes[msg.sender];\n        require(s.amount != 0, \"TokenSale: No Deposit\");\n        require(!s.claimed, \"TokenSale: Already Claimed\");\n\n        uint256 left;\n        (s.share, left) = _claim(s);\n        require(left > 0, \"TokenSale: Nothing to claim\");\n        uint256 refundTaxAmount;\n        if (s.taxAmount > 0) {\n            uint256 tax = userTaxRate(s.amount, msg.sender);\n            uint256 taxFreeAllc = _maxTaxfreeAllocation(msg.sender) * PCT_BASE; //==> tax free \n            if (taxFreeAllc >= s.share) {\n                refundTaxAmount = s.taxAmount;\n            } else {\n                refundTaxAmount = (left * tax) / POINT_BASE;\n            }\n            usdc.safeTransferFrom(marketingWallet, msg.sender, refundTaxAmount);\n        }\n        s.claimed = true;\n        usdc.safeTransfer(msg.sender, left);\n        emit Claim(msg.sender, left);\n    }\n```\n\n**ZdravkoHr**\n\n@merc1995, that's because if the taxFree was set to 500 for example amd I deposit 600, the claim function should consider this and let me claim tax for only 100 (assumung I can claim 100%, which of course is not true, but makes the example more simple)\n\n**merc1995**\n\nThe code use `left` rather than `s.shrare - taxFree` to calculate the `refundAmount`. According to your comment, this issue is valid because of the wrong implementation.\n\n**merc1995**\n\n> The tax amount refunded to the user should be calculated for the left amount only i.e not taking into consideration the tax free amount\n@vsharma4394 \nCould you please provide the doc which said that the tax free amount should not be taken into consideration?\n\n**vsharma4394**\n\n@merc1995 It is clear from the deposit function (which calls the _processPrivate function) that currently they don't allow tax free allocation. \n\n**merc1995**\n\nSo there should be no tax-free releated code in the `claim`, and this issue should be valid?\n\n**vsharma4394**\n\nI agree that there should not be tax free related code and refundTaxAmount should only be equal to (left * tax) / POINT_BASE.\n\n**vsharma4394**\n\nI don't agree with the following lines as stated in the vulnerability detail that \nThe problem is that in case s.share > taxFreeAllc, the tax refund is calculated wrongfully. Not only it should refund the tax on the unused USDC amount, but it should also refund the tax for the tax-free allocation the user has.\nThey should never refund tax for the tax Free allocation because while calling deposit taxFreeAllocation was set to zero.\n\n**vsharma4394**\n\nAccording to me there is a logic error in the code where they first don't take into account taxFreeAllocation but they do so in claim function due to which there has been lot of miss interpretation of the code.\n\n**Hash01011122**\n\nI missed the part where user is not supposed to be refunded for tax free allocation, it would be better if someone with deeper knowledge of protocol can shed some light on taxFreeAllocation concept. Requesting insight from someone with deeper knowledge of the protocol is a prudent step. @ZdravkoHr  @deadrosesxyz ??\n\n**ZdravkoHr**\n\n@Hash01011122, if you look at TokenSale.processPrivate and assume the tax free amount is set to an extremely large number, the if statement where the actual tax transfer happens will never be entered. \n\nSo the tax free allocation is tax-free because users don't pay for it from the very beginning. That's why a refund is not needed.\n\n**spacegliderrrr**\n\n@Hash01011122 When users deposit, they always have to pay tax. The users then have a tax-free allocation. Meaning, that for this amount, they don't have to pay tax and they'll be refunded for it. \n\nTax refund must always be for the tax on their tax-free allocation.+ the tax on their unused funds (s.left)\n\n**niketansainiantier**\n\nwe are taking the tax on the whole invested amount including all allocations, including the whitelist. So will refund the only tax on left amount(extra Amount). \n\n**deadrosesxyz**\n\n@niketansainiantier if this was the case, then what is the purpose of `_maxTaxfreeAllocation` and the following lines of code? Why would they refund the whole tax amount if it was always intended to refund only based on the left/extra amount. What you've said simply contradicts the code.\n\n```solidity\n            uint256 taxFreeAllc = _maxTaxfreeAllocation(msg.sender) * PCT_BASE;\n            if (taxFreeAllc >= s.share) {\n                refundTaxAmount = s.taxAmount;\n```\n\n**Hash01011122**\n\nHighlighting the specific [code line](https://github.com/sherlock-audit/2024-03-zap-protocol/blob/c2ad35aa844899fa24f6ed0cbfcf6c7e611b061a/zap-contracts-labs/contracts/TokenSale.sol#L227C1-L228C1) where `taxFreeAllocOfUser` is hardcoded to zero implies that users are indeed intended to be processed for a tax refund according to the protocol's logic. Let me know if I am getting anything wrong here @ZdravkoHr \n\n**vsharma4394**\n\n@Hash01011122  the following is said by @niketansainiantier\n``` we are taking the tax on the whole invested amount including all allocations, including the whitelist. So will refund the only tax on left amount(extra Amount).```\n Due to this users are only refunded on the left amount i.e not considering the tax free allocation. While depositing also taxFreeAllocation was not considered as taxFreeAllocOfUser is equal to zero so it should also not be considered while calling claim function.\n\nI think you have misunderstood the code ,```taxfreeAllocOfUser``` is hardcoded to zero implies that users are processed tax on whole amount neglecting the tax free amount.So as now tax free amount is not taken into consideration , it should not be taken into account while calling claim function. \n\n**vsharma4394**\n\nI think sponsers have also added the won't fix tag because it is intended behaviour to refund tax only on left amount. As initially also taxFreeAlloc was taken as zero. Thus making this finding as invalid.\n\n**ZdravkoHr**\n\n@vsharma4394 is right imo. There is a comment next to taxAlloc = 0 that says that all pools have tax\n\n**vsharma4394**\n\n> @vsharma4394 is right imo. There is a comment next to taxAlloc = 0 that says that all pools have tax\n\nYes,there has been a lot of misunderstanding because people have not understood wwhat taxAlloc = 0 means.\n\n**vsharma4394**\n\n> @niketansainiantier if this was the case, then what is the purpose of `_maxTaxfreeAllocation` and the following lines of code? Why would they refund the whole tax amount if it was always intended to refund only based on the left/extra amount. What you've said simply contradicts the code.\n> \n> ```solidity\n>             uint256 taxFreeAllc = _maxTaxfreeAllocation(msg.sender) * PCT_BASE;\n>             if (taxFreeAllc >= s.share) {\n>                 refundTaxAmount = s.taxAmount;\n> ```\n\nAgain this is because they have taken taxFreeAlloc = 0. Hence this issue is invalid.\n\n**niketansainiantier**\n\nYes, that's why I changed the logic here. \n\n` uint256 left;\n        (s.share, left) = _claim(s);\n        require(left > 0, \"TokenSale: Nothing to claim\");\n        uint256 refundTaxAmount;\n        if (s.taxAmount > 0) {\n            uint256 tax = userTaxRate(s.amount, msg.sender);\n            refundTaxAmount = (left * tax) / POINT_BASE;\n            usdc.safeTransferFrom(marketingWallet, msg.sender, refundTaxAmount);\n        }`\n       You guys can check this on 2nd PR\n\n**vsharma4394**\n\n> Yes, that's why I changed the logic here.\n> \n> ` uint256 left; (s.share, left) = _claim(s); require(left > 0, \"TokenSale: Nothing to claim\"); uint256 refundTaxAmount; if (s.taxAmount > 0) { uint256 tax = userTaxRate(s.amount, msg.sender); refundTaxAmount = (left * tax) / POINT_BASE; usdc.safeTransferFrom(marketingWallet, msg.sender, refundTaxAmount); }` You guys can check this on 2nd PR\n\n@Hash01011122 now things should be very clear. This issue should be invalid and #159 should be a valid unique finding.Also #58 should also be invalid.\n\n**ZdravkoHr**\n\n[131](https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/131) is also a dup of 159\n\n**Hash01011122**\n\nSeems logical enough, @vsharma4394 thanks for clearing the misunderstanding regarding `taxfreeAllocOfUser` I am inclined towards invalidating this issue. @deadrosesxyz Your input would be appreciated.\n\n**deadrosesxyz**\n\n@Hash01011122 The other watson simply assumes that `_maxTaxFreeAllocation` is always going to return 0. They assume the logic here, including the call to the staking contract, the tokensale tiers will all return 0 for whatever reason. There's contract logic based on the calculated `taxFreeAllc` and logic to calculate its value. `taxFreeAllc ` always having a value of 0 is not enforced anywhere, hence cannot be expected this would be the case (in fact it's just the opposite considering the function designed to calculate it). I'd politely ask other watsons to refrain from making any more comments. I believe everyone has made their point clear and it's simply time to wait for judge's decision.\n```solidity\n            uint256 taxFreeAllc = _maxTaxfreeAllocation(msg.sender) * PCT_BASE;\n            if (taxFreeAllc >= s.share) {\n                refundTaxAmount = s.taxAmount;\n```\n```solidity\n    function _maxTaxfreeAllocation(address _sender) internal returns (uint256) {\n        uint256 userTierAllc = stakingContract.getAllocationOf(_sender);\n        uint256 giftedTierAllc = tokensaleTiers[_sender];\n\n        if (userTierAllc > giftedTierAllc) {\n            return userTierAllc;\n        } else {\n            return giftedTierAllc;\n        }\n    }\n```\n\n\n**Hash01011122**\n\nEven I thought the same when I first looked at `taxFreeAllc` in codebase, but after @niketansainiantier cleared that this is not the case. Just want to know whether this was mentioned in by the sponsors at the time of contest. If nothing was mentioned this should remain a valid issue.\n\n**Evert0x**\n\nPlanning to reject escalation and keep issue as is. \n\n\n**vsharma4394**\n\n> Yes, that's why I changed the logic here.\n> \n> ` uint256 left; (s.share, left) = _claim(s); require(left > 0, \"TokenSale: Nothing to claim\"); uint256 refundTaxAmount; if (s.taxAmount > 0) { uint256 tax = userTaxRate(s.amount, msg.sender); refundTaxAmount = (left * tax) / POINT_BASE; usdc.safeTransferFrom(marketingWallet, msg.sender, refundTaxAmount); }` You guys can check this on 2nd PR\n\n@Evert0x see here the changed code by sponsers now tax amount which is returned is only calculated on the left amount excluding tax free allocation because which is contradiction to this finding, so doesn't that make this finding invalid. \n\n**vsharma4394**\n\n@Evert0x In the following loc \nhttps://github.com/sherlock-audit/2024-03-zap-protocol/blob/c2ad35aa844899fa24f6ed0cbfcf6c7e611b061a/zap-contracts-labs/contracts/TokenSale.sol#L227\nIt is clearly commented that tax is charged for every pool, i.e the tax free calculation is not done so it doesn't makes sense that they would refund the tax on tax free allocation and similarly the protocol doesn't wishes to take into account tax free allocation while calling claim function that is why they changed the code in latest pr.Now its best you ask the sponsers and take your decision.\nSponsers have made that change by looking at #159 so asking sponsers would definitely resolve that issue too.\n\n**Evert0x**\n\nResult:\nHigh\nHas Duplicates\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [ZdravkoHr](https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/57/#issuecomment-2025488727): rejected\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/243",
  "Code": [
    {
      "filename": "zap-contracts-labs/contracts/TokenSale.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./interfaces/ITokenSale.sol\";\nimport \"./interfaces/IAdmin.sol\";\nimport \"./interfaces/IAirdrops.sol\";\nimport \"./interfaces/IERC20D.sol\";\nimport \"./interfaces/IStaking.sol\";\nimport \"hardhat/console.sol\";\n\n/*\nA tokensale includes 3 stages: \n1. Private round. Only ion token holders can participate in this round. \n The Matic/USDC price is fixed in the beginning of the tokensale.\n All tokens available in the pre-sale will be made available through the private sale round. \n A single investor can purchase up to their maximum allowed investment defined by the tier.\n Investors can claim their tokens only when the private round is finished. \n If the total supply is higher than the total demand for this tokensale, investors purchase tokens up to their max allocation. \n If the the demand is higher than supply, the number of tokens investors will receive is adjusted, and then the native token used to invest are partially refunded.\n\n*/\n\n//TODO Change USDC address\n//TODO Change Marketing wallet address\n\ncontract TokenSale is Initializable, ITokenSale {\n    using SafeERC20 for IERC20D;\n\n    uint256 constant PCT_BASE = 10 ** 18;\n    uint256 constant POINT_BASE = 1000;\n    bytes32 constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    address public marketingWallet;\n\n    uint256 public maxAllocation; // in dollar with decimals\n    uint256 public globalTaxRate; // base 1000\n    uint256 public whitelistTxRate; // base 1000\n    bool public isKYCEnabled;\n\n    IStaking stakingContract;\n    Params params;\n    IERC20D public usdc;\n    IAdmin admin;\n    /**\n     * @dev current tokensale stage (epoch)\n     */\n    Epoch public override epoch;\n    bool isRaiseClaimed;\n    bool only;\n    bytes32 public constant OPERATOR = keccak256(\"OPERATOR\");\n    address[] public usersOnDeposit;\n\n    mapping(address => Staked) public override stakes;\n    mapping(address => uint256) public tokensaleTiers;\n    /** @dev Decrease result by 1 to access correct position */\n    mapping(address => uint256) public userDepositIndex;\n    mapping(address => bool) public isWhitelisted;\n\n    State state;\n\n    receive() external payable {}\n\n    function getState() external view returns (uint128, uint128) {\n        return (state.totalPrivateSold, state.totalSupplyInValue);\n    }\n\n    function initialize(\n        Params calldata _params,\n        address _stakingContract,\n        address _admin,\n        uint256 _maxAllocation,\n        uint256 _globalTaxRate,\n        bool _isKYC,\n        uint256 _whitelistTxRate\n    ) external initializer {\n        params = _params;\n        stakingContract = IStaking(_stakingContract);\n        admin = IAdmin(_admin);\n        state.totalSupplyInValue = uint128(\n            (uint256(_params.totalSupply) *\n                uint256(_params.privateTokenPrice)) / 10 ** 18\n            // removes USDB hardcode of six, awful\n        );\n        usdc = IERC20D(0xA9F81589Cc48Ff000166Bf03B3804A0d8Cec8114); //TODO change for mainnet\n        marketingWallet = 0x6507fFd283c32386B6065EA89744Ade21515e91E; //TODO change for mainnet\n        maxAllocation = _maxAllocation;\n        globalTaxRate = _globalTaxRate;\n        isKYCEnabled = _isKYC;\n        whitelistTxRate = _whitelistTxRate;\n    }\n\n    // allocation is amount in dollar without decimals\n    function userWhitelistAllocation(\n        address[] calldata users,\n        uint256[] calldata allocations\n    ) public {\n        require(admin.hasRole(OPERATOR, msg.sender), \"TokenSale: OnlyOperator\");\n        require(\n            users.length == allocations.length,\n            \"TokenSale: Invalid length\"\n        );\n        for (uint256 i = 0; i < users.length; i++) {\n            tokensaleTiers[users[i]] = allocations[i];\n        }\n    }\n\n    function whitelistUser(address[] calldata users) public {\n        require(admin.hasRole(OPERATOR, msg.sender), \"TokenSale: OnlyOperator\");\n        for (uint256 i = 0; i < users.length; i++) {\n            isWhitelisted[users[i]] = true;\n        }\n    }\n\n    function setAllocationAndTax(uint256[3] calldata _allocations) external {\n        require(block.timestamp <= params.privateStart, \"Time lapsed\");\n        require(admin.hasRole(OPERATOR, msg.sender), \"TokenSale: OnlyOperator\");\n        maxAllocation = _allocations[0];\n        globalTaxRate = _allocations[1];\n        whitelistTxRate = _allocations[2];\n    }\n\n    function setMarketingWallet(address _wallet) external {\n        _onlyAdmin();\n        marketingWallet = _wallet;\n    }\n\n    /**\n     * @dev setup the current tokensale stage (epoch)\n     */\n    function checkingEpoch() public {\n        uint256 time = block.timestamp;\n        if (\n            epoch != Epoch.Private &&\n            time >= params.privateStart &&\n            time <= params.privateEnd\n        ) {\n            epoch = Epoch.Private;\n            return;\n        }\n        if ((epoch != Epoch.Finished && (time > params.privateEnd))) {\n            epoch = Epoch.Finished;\n            return;\n        }\n    }\n\n    // to save size\n    function _onlyAdmin() internal view {\n        require(\n            admin.hasRole(DEFAULT_ADMIN_ROLE, msg.sender) ||\n                msg.sender == address(admin),\n            \"TokenSale: Onlyadmin\"\n        );\n    }\n\n    /**\n     * @dev invest usdc to the tokensale\n     */\n    function deposit(uint256 _amount) external {\n        console.log(\"kyc enabled\", isKYCEnabled);\n        if (isKYCEnabled) {\n            require(admin.isKYCDone(msg.sender) == true, \"KYC not done\");\n        }\n        address sender = msg.sender;\n        require(\n            !admin.blacklist(address(this), sender),\n            \"TokenSale: Blacklisted\"\n        );\n        checkingEpoch();\n\n        require(epoch == Epoch.Private, \"TokenSale: Incorrect time\");\n        require(_amount > 0, \"TokenSale: 0 deposit\");\n\n        if (userDepositIndex[sender] == 0) {\n            usersOnDeposit.push(sender);\n            userDepositIndex[sender] = usersOnDeposit.length;\n        }\n        if (epoch == Epoch.Private) {\n            _processPrivate(sender, _amount);\n        }\n    }\n\n    function destroy() external override {\n        _onlyAdmin();\n        uint256 amountUSDC = usdc.balanceOf(address(this));\n        if (amountUSDC > 0) {\n            usdc.safeTransfer(admin.wallet(), amountUSDC);\n        }\n        address payable wallet = payable(admin.wallet());\n        selfdestruct(wallet);\n    }\n\n    /**\n     * @notice withdraw accidently sent ERC20 tokens\n     * @param _tokenAddress address of token to withdraw\n     */\n    function removeOtherERC20Tokens(address _tokenAddress) external {\n        _onlyAdmin();\n        require(\n            _tokenAddress != address(usdc),\n            \"TokenSale: Can't withdraw usdc\"\n        );\n        uint256 balance = IERC20D(_tokenAddress).balanceOf(address(this));\n        IERC20D(_tokenAddress).safeTransfer(admin.wallet(), balance);\n\n        emit ERC20TokensRemoved(_tokenAddress, msg.sender, balance);\n    }\n\n    /**\n     * @dev processing usdc investment to the private round\n     * @param _sender - transaction sender\n     * @param _amount - investment amount in usdc\n     */\n    function _processPrivate(address _sender, uint256 _amount) internal {\n        require(_amount > 0, \"TokenSale: Too small\");\n\n        Staked storage s = stakes[_sender];\n        uint256 amount = _amount * PCT_BASE;\n        uint256 sum = s.amount + amount;\n\n        uint256 maxAllocationOfUser = (calculateMaxAllocation(_sender)) *\n            PCT_BASE;\n        require(sum <= maxAllocationOfUser, \"upto max allocation\");\n        uint256 taxFreeAllcOfUser = 0; // hardcode zero - all pools have ax\n\n        uint256 userTaxAmount;\n\n        if (sum > taxFreeAllcOfUser) {\n            uint256 userTxRate = userTaxRate(sum, _sender);\n            if (s.amount < taxFreeAllcOfUser) {\n                userTaxAmount =\n                    ((sum - taxFreeAllcOfUser) * userTxRate) /\n                    POINT_BASE;\n            } else {\n                userTaxAmount = (amount * userTxRate) / POINT_BASE;\n            }\n        }\n\n        if (userTaxAmount > 0) {\n            s.taxAmount += userTaxAmount;\n            usdc.safeTransferFrom(_sender, marketingWallet, userTaxAmount);\n        }\n        s.amount += uint128(amount);\n        state.totalPrivateSold += uint128(amount);\n        usdc.safeTransferFrom(_sender, address(this), amount);\n\n        /**@notice Forbid unstaking*/\n        // stakingContract.setPoolsEndTime(_sender, uint256(params.privateEnd)); // TODO: uncomment\n        emit DepositPrivate(_sender, _amount, address(this));\n    }\n\n    /**\n     * @dev sends the usdc raise to admin's wallet\n     */\n\n    function calculateMaxAllocation(address _sender) public returns (uint256) {\n        uint256 userMaxAllc = _maxTierAllc(_sender);\n\n        if (userMaxAllc > maxAllocation) {\n            return userMaxAllc;\n        } else {\n            return maxAllocation;\n        }\n    }\n\n    function _maxTaxfreeAllocation(address _sender) internal returns (uint256) {\n        uint256 userTierAllc = stakingContract.getAllocationOf(_sender);\n        uint256 giftedTierAllc = tokensaleTiers[_sender];\n\n        if (userTierAllc > giftedTierAllc) {\n            return userTierAllc;\n        } else {\n            return giftedTierAllc;\n        }\n    }\n\n    function _maxTierAllc(address _sender) internal returns (uint256) {\n        (uint256 userTier, uint256 userLockLvl, , ) = stakingContract\n            .getUserState(_sender);\n\n        uint256 giftedTierAllc = tokensaleTiers[_sender];\n\n        if (userTier == 0 && giftedTierAllc == 0) {\n            return 0;\n        }\n\n        uint256 userTierAllc = stakingContract.getAllocationOf(_sender);\n        uint256 nextTierAllc;\n        if (userLockLvl > 0 && userLockLvl < 4) {\n            nextTierAllc = stakingContract.getAllocations(\n                userLockLvl + 1,\n                userTier\n            );\n        } else {\n            nextTierAllc = stakingContract.getAllocations(\n                userLockLvl,\n                userTier + 1\n            );\n        }\n\n        if (nextTierAllc > userTierAllc) {\n            if (nextTierAllc > giftedTierAllc) {\n                return nextTierAllc;\n            } else {\n                return giftedTierAllc;\n            }\n        } else {\n            if (userTierAllc > giftedTierAllc) {\n                return userTierAllc;\n            } else {\n                return giftedTierAllc;\n            }\n        }\n    }\n\n    // _amount should be in dollar without decimals\n    function userTaxRate(\n        uint256 _amount,\n        address _sender\n    ) public returns (uint256) {\n        uint256 userTaxFreeAllc = 0;\n\n        if (_amount > userTaxFreeAllc) {\n            if (isWhitelisted[_sender]) {\n                return whitelistTxRate;\n            } else {\n                return globalTaxRate;\n            }\n        } else {\n            return 0;\n        }\n    }\n\n    function takeUSDCRaised() external override {\n        checkingEpoch();\n        require(epoch == Epoch.Finished, \"TokenSale: Not time yet\");\n        require(!isRaiseClaimed, \"TokenSale: Already paid\");\n\n        uint256 earned;\n\n        if (state.totalPrivateSold > state.totalSupplyInValue) {\n            earned = uint256(state.totalSupplyInValue);\n        } else {\n            earned = uint256(state.totalPrivateSold);\n        }\n\n        isRaiseClaimed = true;\n\n        if (earned > 0) {\n            uint256 bal = usdc.balanceOf(address(this));\n            uint256 returnValue = earned <= bal ? earned : bal;\n            usdc.safeTransfer(admin.wallet(), returnValue);\n        }\n\n        emit RaiseClaimed(admin.wallet(), earned);\n    }\n\n    /**\n     * @dev allows the participants of the private round to claim usdc left\n     */\n    function claim() external {\n        checkingEpoch();\n        require(\n            uint8(epoch) > 1 && !admin.blockClaim(address(this)),\n            \"TokenSale: Not time or not allowed\"\n        );\n\n        Staked storage s = stakes[msg.sender];\n        require(s.amount != 0, \"TokenSale: No Deposit\");\n        require(!s.claimed, \"TokenSale: Already Claimed\");\n\n        uint256 left;\n        (s.share, left) = _claim(s);\n        require(left > 0, \"TokenSale: Nothing to claim\");\n        uint256 refundTaxAmount;\n        if (s.taxAmount > 0) {\n            uint256 tax = userTaxRate(s.amount, msg.sender);\n            uint256 taxFreeAllc = _maxTaxfreeAllocation(msg.sender) * PCT_BASE;\n            if (taxFreeAllc >= s.share) {\n                refundTaxAmount = s.taxAmount;\n            } else {\n                refundTaxAmount = (left * tax) / POINT_BASE;\n            }\n            usdc.safeTransferFrom(marketingWallet, msg.sender, refundTaxAmount);\n        }\n        s.claimed = true;\n        usdc.safeTransfer(msg.sender, left);\n        emit Claim(msg.sender, left);\n    }\n\n    function _claim(Staked memory _s) internal view returns (uint120, uint256) {\n        uint256 left;\n        if (state.totalPrivateSold > (state.totalSupplyInValue)) {\n            uint256 rate = (state.totalSupplyInValue * PCT_BASE) /\n                state.totalPrivateSold;\n            _s.share = uint120((uint256(_s.amount) * rate) / PCT_BASE);\n            left = uint256(_s.amount) - uint256(_s.share);\n        } else {\n            _s.share = uint120(_s.amount);\n        }\n\n        return (_s.share, left);\n    }\n\n    function canClaim(address _user) external view returns (uint120, uint256) {\n        return _claim(stakes[_user]);\n    }\n\n    /**\n     * @dev sends Locked usdc to admin wallet\n     */\n\n    function takeLocked() external override {\n        _onlyAdmin();\n        require(\n            block.timestamp >= (params.privateEnd + 2592e3),\n            \"TokenSale: Not ended\"\n        );\n        uint256 amountUSDC = usdc.balanceOf(address(this));\n        if (amountUSDC > 0) {\n            usdc.safeTransfer(admin.wallet(), amountUSDC);\n        }\n    }\n\n    /**\n    @dev Total Tokens (in $) sold in IDO\n     */\n    function totalTokenSold() external view returns (uint128) {\n        return state.totalPrivateSold;\n    }\n}"
    },
    {
      "filename": "zap-contracts-labs/contracts/TokenSale.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./interfaces/ITokenSale.sol\";\nimport \"./interfaces/IAdmin.sol\";\nimport \"./interfaces/IAirdrops.sol\";\nimport \"./interfaces/IERC20D.sol\";\nimport \"./interfaces/IStaking.sol\";\nimport \"hardhat/console.sol\";\n\n/*\nA tokensale includes 3 stages: \n1. Private round. Only ion token holders can participate in this round. \n The Matic/USDC price is fixed in the beginning of the tokensale.\n All tokens available in the pre-sale will be made available through the private sale round. \n A single investor can purchase up to their maximum allowed investment defined by the tier.\n Investors can claim their tokens only when the private round is finished. \n If the total supply is higher than the total demand for this tokensale, investors purchase tokens up to their max allocation. \n If the the demand is higher than supply, the number of tokens investors will receive is adjusted, and then the native token used to invest are partially refunded.\n\n*/\n\n//TODO Change USDC address\n//TODO Change Marketing wallet address\n\ncontract TokenSale is Initializable, ITokenSale {\n    using SafeERC20 for IERC20D;\n\n    uint256 constant PCT_BASE = 10 ** 18;\n    uint256 constant POINT_BASE = 1000;\n    bytes32 constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    address public marketingWallet;\n\n    uint256 public maxAllocation; // in dollar with decimals\n    uint256 public globalTaxRate; // base 1000\n    uint256 public whitelistTxRate; // base 1000\n    bool public isKYCEnabled;\n\n    IStaking stakingContract;\n    Params params;\n    IERC20D public usdc;\n    IAdmin admin;\n    /**\n     * @dev current tokensale stage (epoch)\n     */\n    Epoch public override epoch;\n    bool isRaiseClaimed;\n    bool only;\n    bytes32 public constant OPERATOR = keccak256(\"OPERATOR\");\n    address[] public usersOnDeposit;\n\n    mapping(address => Staked) public override stakes;\n    mapping(address => uint256) public tokensaleTiers;\n    /** @dev Decrease result by 1 to access correct position */\n    mapping(address => uint256) public userDepositIndex;\n    mapping(address => bool) public isWhitelisted;\n\n    State state;\n\n    receive() external payable {}\n\n    function getState() external view returns (uint128, uint128) {\n        return (state.totalPrivateSold, state.totalSupplyInValue);\n    }\n\n    function initialize(\n        Params calldata _params,\n        address _stakingContract,\n        address _admin,\n        uint256 _maxAllocation,\n        uint256 _globalTaxRate,\n        bool _isKYC,\n        uint256 _whitelistTxRate\n    ) external initializer {\n        params = _params;\n        stakingContract = IStaking(_stakingContract);\n        admin = IAdmin(_admin);\n        state.totalSupplyInValue = uint128(\n            (uint256(_params.totalSupply) *\n                uint256(_params.privateTokenPrice)) / 10 ** 18\n            // removes USDB hardcode of six, awful\n        );\n        usdc = IERC20D(0xA9F81589Cc48Ff000166Bf03B3804A0d8Cec8114); //TODO change for mainnet\n        marketingWallet = 0x6507fFd283c32386B6065EA89744Ade21515e91E; //TODO change for mainnet\n        maxAllocation = _maxAllocation;\n        globalTaxRate = _globalTaxRate;\n        isKYCEnabled = _isKYC;\n        whitelistTxRate = _whitelistTxRate;\n    }\n\n    // allocation is amount in dollar without decimals\n    function userWhitelistAllocation(\n        address[] calldata users,\n        uint256[] calldata allocations\n    ) public {\n        require(admin.hasRole(OPERATOR, msg.sender), \"TokenSale: OnlyOperator\");\n        require(\n            users.length == allocations.length,\n            \"TokenSale: Invalid length\"\n        );\n        for (uint256 i = 0; i < users.length; i++) {\n            tokensaleTiers[users[i]] = allocations[i];\n        }\n    }\n\n    function whitelistUser(address[] calldata users) public {\n        require(admin.hasRole(OPERATOR, msg.sender), \"TokenSale: OnlyOperator\");\n        for (uint256 i = 0; i < users.length; i++) {\n            isWhitelisted[users[i]] = true;\n        }\n    }\n\n    function setAllocationAndTax(uint256[3] calldata _allocations) external {\n        require(block.timestamp <= params.privateStart, \"Time lapsed\");\n        require(admin.hasRole(OPERATOR, msg.sender), \"TokenSale: OnlyOperator\");\n        maxAllocation = _allocations[0];\n        globalTaxRate = _allocations[1];\n        whitelistTxRate = _allocations[2];\n    }\n\n    function setMarketingWallet(address _wallet) external {\n        _onlyAdmin();\n        marketingWallet = _wallet;\n    }\n\n    /**\n     * @dev setup the current tokensale stage (epoch)\n     */\n    function checkingEpoch() public {\n        uint256 time = block.timestamp;\n        if (\n            epoch != Epoch.Private &&\n            time >= params.privateStart &&\n            time <= params.privateEnd\n        ) {\n            epoch = Epoch.Private;\n            return;\n        }\n        if ((epoch != Epoch.Finished && (time > params.privateEnd))) {\n            epoch = Epoch.Finished;\n            return;\n        }\n    }\n\n    // to save size\n    function _onlyAdmin() internal view {\n        require(\n            admin.hasRole(DEFAULT_ADMIN_ROLE, msg.sender) ||\n                msg.sender == address(admin),\n            \"TokenSale: Onlyadmin\"\n        );\n    }\n\n    /**\n     * @dev invest usdc to the tokensale\n     */\n    function deposit(uint256 _amount) external {\n        console.log(\"kyc enabled\", isKYCEnabled);\n        if (isKYCEnabled) {\n            require(admin.isKYCDone(msg.sender) == true, \"KYC not done\");\n        }\n        address sender = msg.sender;\n        require(\n            !admin.blacklist(address(this), sender),\n            \"TokenSale: Blacklisted\"\n        );\n        checkingEpoch();\n\n        require(epoch == Epoch.Private, \"TokenSale: Incorrect time\");\n        require(_amount > 0, \"TokenSale: 0 deposit\");\n\n        if (userDepositIndex[sender] == 0) {\n            usersOnDeposit.push(sender);\n            userDepositIndex[sender] = usersOnDeposit.length;\n        }\n        if (epoch == Epoch.Private) {\n            _processPrivate(sender, _amount);\n        }\n    }\n\n    function destroy() external override {\n        _onlyAdmin();\n        uint256 amountUSDC = usdc.balanceOf(address(this));\n        if (amountUSDC > 0) {\n            usdc.safeTransfer(admin.wallet(), amountUSDC);\n        }\n        address payable wallet = payable(admin.wallet());\n        selfdestruct(wallet);\n    }\n\n    /**\n     * @notice withdraw accidently sent ERC20 tokens\n     * @param _tokenAddress address of token to withdraw\n     */\n    function removeOtherERC20Tokens(address _tokenAddress) external {\n        _onlyAdmin();\n        require(\n            _tokenAddress != address(usdc),\n            \"TokenSale: Can't withdraw usdc\"\n        );\n        uint256 balance = IERC20D(_tokenAddress).balanceOf(address(this));\n        IERC20D(_tokenAddress).safeTransfer(admin.wallet(), balance);\n\n        emit ERC20TokensRemoved(_tokenAddress, msg.sender, balance);\n    }\n\n    /**\n     * @dev processing usdc investment to the private round\n     * @param _sender - transaction sender\n     * @param _amount - investment amount in usdc\n     */\n    function _processPrivate(address _sender, uint256 _amount) internal {\n        require(_amount > 0, \"TokenSale: Too small\");\n\n        Staked storage s = stakes[_sender];\n        uint256 amount = _amount * PCT_BASE;\n        uint256 sum = s.amount + amount;\n\n        uint256 maxAllocationOfUser = (calculateMaxAllocation(_sender)) *\n            PCT_BASE;\n        require(sum <= maxAllocationOfUser, \"upto max allocation\");\n        uint256 taxFreeAllcOfUser = 0; // hardcode zero - all pools have ax\n\n        uint256 userTaxAmount;\n\n        if (sum > taxFreeAllcOfUser) {\n            uint256 userTxRate = userTaxRate(sum, _sender);\n            if (s.amount < taxFreeAllcOfUser) {\n                userTaxAmount =\n                    ((sum - taxFreeAllcOfUser) * userTxRate) /\n                    POINT_BASE;\n            } else {\n                userTaxAmount = (amount * userTxRate) / POINT_BASE;\n            }\n        }\n\n        if (userTaxAmount > 0) {\n            s.taxAmount += userTaxAmount;\n            usdc.safeTransferFrom(_sender, marketingWallet, userTaxAmount);\n        }\n        s.amount += uint128(amount);\n        state.totalPrivateSold += uint128(amount);\n        usdc.safeTransferFrom(_sender, address(this), amount);\n\n        /**@notice Forbid unstaking*/\n        // stakingContract.setPoolsEndTime(_sender, uint256(params.privateEnd)); // TODO: uncomment\n        emit DepositPrivate(_sender, _amount, address(this));\n    }\n\n    /**\n     * @dev sends the usdc raise to admin's wallet\n     */\n\n    function calculateMaxAllocation(address _sender) public returns (uint256) {\n        uint256 userMaxAllc = _maxTierAllc(_sender);\n\n        if (userMaxAllc > maxAllocation) {\n            return userMaxAllc;\n        } else {\n            return maxAllocation;\n        }\n    }\n\n    function _maxTaxfreeAllocation(address _sender) internal returns (uint256) {\n        uint256 userTierAllc = stakingContract.getAllocationOf(_sender);\n        uint256 giftedTierAllc = tokensaleTiers[_sender];\n\n        if (userTierAllc > giftedTierAllc) {\n            return userTierAllc;\n        } else {\n            return giftedTierAllc;\n        }\n    }\n\n    function _maxTierAllc(address _sender) internal returns (uint256) {\n        (uint256 userTier, uint256 userLockLvl, , ) = stakingContract\n            .getUserState(_sender);\n\n        uint256 giftedTierAllc = tokensaleTiers[_sender];\n\n        if (userTier == 0 && giftedTierAllc == 0) {\n            return 0;\n        }\n\n        uint256 userTierAllc = stakingContract.getAllocationOf(_sender);\n        uint256 nextTierAllc;\n        if (userLockLvl > 0 && userLockLvl < 4) {\n            nextTierAllc = stakingContract.getAllocations(\n                userLockLvl + 1,\n                userTier\n            );\n        } else {\n            nextTierAllc = stakingContract.getAllocations(\n                userLockLvl,\n                userTier + 1\n            );\n        }\n\n        if (nextTierAllc > userTierAllc) {\n            if (nextTierAllc > giftedTierAllc) {\n                return nextTierAllc;\n            } else {\n                return giftedTierAllc;\n            }\n        } else {\n            if (userTierAllc > giftedTierAllc) {\n                return userTierAllc;\n            } else {\n                return giftedTierAllc;\n            }\n        }\n    }\n\n    // _amount should be in dollar without decimals\n    function userTaxRate(\n        uint256 _amount,\n        address _sender\n    ) public returns (uint256) {\n        uint256 userTaxFreeAllc = 0;\n\n        if (_amount > userTaxFreeAllc) {\n            if (isWhitelisted[_sender]) {\n                return whitelistTxRate;\n            } else {\n                return globalTaxRate;\n            }\n        } else {\n            return 0;\n        }\n    }\n\n    function takeUSDCRaised() external override {\n        checkingEpoch();\n        require(epoch == Epoch.Finished, \"TokenSale: Not time yet\");\n        require(!isRaiseClaimed, \"TokenSale: Already paid\");\n\n        uint256 earned;\n\n        if (state.totalPrivateSold > state.totalSupplyInValue) {\n            earned = uint256(state.totalSupplyInValue);\n        } else {\n            earned = uint256(state.totalPrivateSold);\n        }\n\n        isRaiseClaimed = true;\n\n        if (earned > 0) {\n            uint256 bal = usdc.balanceOf(address(this));\n            uint256 returnValue = earned <= bal ? earned : bal;\n            usdc.safeTransfer(admin.wallet(), returnValue);\n        }\n\n        emit RaiseClaimed(admin.wallet(), earned);\n    }\n\n    /**\n     * @dev allows the participants of the private round to claim usdc left\n     */\n    function claim() external {\n        checkingEpoch();\n        require(\n            uint8(epoch) > 1 && !admin.blockClaim(address(this)),\n            \"TokenSale: Not time or not allowed\"\n        );\n\n        Staked storage s = stakes[msg.sender];\n        require(s.amount != 0, \"TokenSale: No Deposit\");\n        require(!s.claimed, \"TokenSale: Already Claimed\");\n\n        uint256 left;\n        (s.share, left) = _claim(s);\n        require(left > 0, \"TokenSale: Nothing to claim\");\n        uint256 refundTaxAmount;\n        if (s.taxAmount > 0) {\n            uint256 tax = userTaxRate(s.amount, msg.sender);\n            uint256 taxFreeAllc = _maxTaxfreeAllocation(msg.sender) * PCT_BASE;\n            if (taxFreeAllc >= s.share) {\n                refundTaxAmount = s.taxAmount;\n            } else {\n                refundTaxAmount = (left * tax) / POINT_BASE;\n            }\n            usdc.safeTransferFrom(marketingWallet, msg.sender, refundTaxAmount);\n        }\n        s.claimed = true;\n        usdc.safeTransfer(msg.sender, left);\n        emit Claim(msg.sender, left);\n    }\n\n    function _claim(Staked memory _s) internal view returns (uint120, uint256) {\n        uint256 left;\n        if (state.totalPrivateSold > (state.totalSupplyInValue)) {\n            uint256 rate = (state.totalSupplyInValue * PCT_BASE) /\n                state.totalPrivateSold;\n            _s.share = uint120((uint256(_s.amount) * rate) / PCT_BASE);\n            left = uint256(_s.amount) - uint256(_s.share);\n        } else {\n            _s.share = uint120(_s.amount);\n        }\n\n        return (_s.share, left);\n    }\n\n    function canClaim(address _user) external view returns (uint120, uint256) {\n        return _claim(stakes[_user]);\n    }\n\n    /**\n     * @dev sends Locked usdc to admin wallet\n     */\n\n    function takeLocked() external override {\n        _onlyAdmin();\n        require(\n            block.timestamp >= (params.privateEnd + 2592e3),\n            \"TokenSale: Not ended\"\n        );\n        uint256 amountUSDC = usdc.balanceOf(address(this));\n        if (amountUSDC > 0) {\n            usdc.safeTransfer(admin.wallet(), amountUSDC);\n        }\n    }\n\n    /**\n    @dev Total Tokens (in $) sold in IDO\n     */\n    function totalTokenSold() external view returns (uint128) {\n        return state.totalPrivateSold;\n    }\n}"
    },
    {
      "filename": "zap-contracts-labs/contracts/TokenSale.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./interfaces/ITokenSale.sol\";\nimport \"./interfaces/IAdmin.sol\";\nimport \"./interfaces/IAirdrops.sol\";\nimport \"./interfaces/IERC20D.sol\";\nimport \"./interfaces/IStaking.sol\";\nimport \"hardhat/console.sol\";\n\n/*\nA tokensale includes 3 stages: \n1. Private round. Only ion token holders can participate in this round. \n The Matic/USDC price is fixed in the beginning of the tokensale.\n All tokens available in the pre-sale will be made available through the private sale round. \n A single investor can purchase up to their maximum allowed investment defined by the tier.\n Investors can claim their tokens only when the private round is finished. \n If the total supply is higher than the total demand for this tokensale, investors purchase tokens up to their max allocation. \n If the the demand is higher than supply, the number of tokens investors will receive is adjusted, and then the native token used to invest are partially refunded.\n\n*/\n\n//TODO Change USDC address\n//TODO Change Marketing wallet address\n\ncontract TokenSale is Initializable, ITokenSale {\n    using SafeERC20 for IERC20D;\n\n    uint256 constant PCT_BASE = 10 ** 18;\n    uint256 constant POINT_BASE = 1000;\n    bytes32 constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    address public marketingWallet;\n\n    uint256 public maxAllocation; // in dollar with decimals\n    uint256 public globalTaxRate; // base 1000\n    uint256 public whitelistTxRate; // base 1000\n    bool public isKYCEnabled;\n\n    IStaking stakingContract;\n    Params params;\n    IERC20D public usdc;\n    IAdmin admin;\n    /**\n     * @dev current tokensale stage (epoch)\n     */\n    Epoch public override epoch;\n    bool isRaiseClaimed;\n    bool only;\n    bytes32 public constant OPERATOR = keccak256(\"OPERATOR\");\n    address[] public usersOnDeposit;\n\n    mapping(address => Staked) public override stakes;\n    mapping(address => uint256) public tokensaleTiers;\n    /** @dev Decrease result by 1 to access correct position */\n    mapping(address => uint256) public userDepositIndex;\n    mapping(address => bool) public isWhitelisted;\n\n    State state;\n\n    receive() external payable {}\n\n    function getState() external view returns (uint128, uint128) {\n        return (state.totalPrivateSold, state.totalSupplyInValue);\n    }\n\n    function initialize(\n        Params calldata _params,\n        address _stakingContract,\n        address _admin,\n        uint256 _maxAllocation,\n        uint256 _globalTaxRate,\n        bool _isKYC,\n        uint256 _whitelistTxRate\n    ) external initializer {\n        params = _params;\n        stakingContract = IStaking(_stakingContract);\n        admin = IAdmin(_admin);\n        state.totalSupplyInValue = uint128(\n            (uint256(_params.totalSupply) *\n                uint256(_params.privateTokenPrice)) / 10 ** 18\n            // removes USDB hardcode of six, awful\n        );\n        usdc = IERC20D(0xA9F81589Cc48Ff000166Bf03B3804A0d8Cec8114); //TODO change for mainnet\n        marketingWallet = 0x6507fFd283c32386B6065EA89744Ade21515e91E; //TODO change for mainnet\n        maxAllocation = _maxAllocation;\n        globalTaxRate = _globalTaxRate;\n        isKYCEnabled = _isKYC;\n        whitelistTxRate = _whitelistTxRate;\n    }\n\n    // allocation is amount in dollar without decimals\n    function userWhitelistAllocation(\n        address[] calldata users,\n        uint256[] calldata allocations\n    ) public {\n        require(admin.hasRole(OPERATOR, msg.sender), \"TokenSale: OnlyOperator\");\n        require(\n            users.length == allocations.length,\n            \"TokenSale: Invalid length\"\n        );\n        for (uint256 i = 0; i < users.length; i++) {\n            tokensaleTiers[users[i]] = allocations[i];\n        }\n    }\n\n    function whitelistUser(address[] calldata users) public {\n        require(admin.hasRole(OPERATOR, msg.sender), \"TokenSale: OnlyOperator\");\n        for (uint256 i ="
    }
  ]
}