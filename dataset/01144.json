{
  "Title": "Missing Docstrings",
  "Content": "Throughout the [codebase](https://github.com/scroll-tech/scroll/tree/f6894bb82f78228b349267ed814375cae2fc1483/contracts/) there are several parts that do not have docstrings. For instance:\n\n\n* [Line 17](https://github.com/scroll-tech/scroll/blob/f6894bb82f78228b349267ed814375cae2fc1483/contracts/src/L1/gateways/L1ERC20Gateway.sol#L16-L17) in [`L1ERC20Gateway.sol`](https://github.com/scroll-tech/scroll/blob/f6894bb82f78228b349267ed814375cae2fc1483/contracts/src/L1/gateways/L1ERC20Gateway.sol)\n* [Line 64](https://github.com/scroll-tech/scroll/blob/f6894bb82f78228b349267ed814375cae2fc1483/contracts/src/L2/gateways/usdc/L2USDCGateway.sol#L59-L64) in [`L2USDCGateway.sol`](https://github.com/scroll-tech/scroll/blob/f6894bb82f78228b349267ed814375cae2fc1483/contracts/src/L2/gateways/usdc/L2USDCGateway.sol)\n* [Line 5](https://github.com/scroll-tech/scroll/blob/f6894bb82f78228b349267ed814375cae2fc1483/contracts/src/interfaces/IMessageTransmitter.sol#L4-L5) in [`IMessageTransmitter.sol`](https://github.com/scroll-tech/scroll/blob/f6894bb82f78228b349267ed814375cae2fc1483/contracts/src/interfaces/IMessageTransmitter.sol)\n* [Line 6](https://github.com/scroll-tech/scroll/blob/f6894bb82f78228b349267ed814375cae2fc1483/contracts/src/interfaces/IMessageTransmitter.sol#L6) in [`IMessageTransmitter.sol`](https://github.com/scroll-tech/scroll/blob/f6894bb82f78228b349267ed814375cae2fc1483/contracts/src/interfaces/IMessageTransmitter.sol)\n* [Line 5](https://github.com/scroll-tech/scroll/blob/f6894bb82f78228b349267ed814375cae2fc1483/contracts/src/interfaces/ITokenMessenger.sol#L4-L5) in [`ITokenMessenger.sol`](https://github.com/scroll-tech/scroll/blob/f6894bb82f78228b349267ed814375cae2fc1483/contracts/src/interfaces/ITokenMessenger.sol)\n* [Line 6](https://github.com/scroll-tech/scroll/blob/f6894bb82f78228b349267ed814375cae2fc1483/contracts/src/interfaces/IUSDCBurnableSourceBridge.sol#L4-L6) in [`IUSDCBurnableSourceBridge.sol`](https://github.com/scroll-tech/scroll/blob/f6894bb82f78228b349267ed814375cae2fc1483/contracts/src/interfaces/IUSDCBurnableSourceBridge.sol)\n* [Line 6](https://github.com/scroll-tech/scroll/blob/f6894bb82f78228b349267ed814375cae2fc1483/contracts/src/interfaces/IUSDCDestinationBridge.sol#L4-L6) in [`IUSDCDestinationBridge.sol`](https://github.com/scroll-tech/scroll/blob/f6894bb82f78228b349267ed814375cae2fc1483/contracts/src/interfaces/IUSDCDestinationBridge.sol)\n* [Line 9](https://github.com/scroll-tech/scroll/blob/f6894bb82f78228b349267ed814375cae2fc1483/contracts/src/libraries/gateway/CCTPGatewayBase.sol#L8-L9) in [`CCTPGatewayBase.sol`](https://github.com/scroll-tech/scroll/blob/f6894bb82f78228b349267ed814375cae2fc1483/contracts/src/libraries/gateway/CCTPGatewayBase.sol)\n\n\nConsider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/develop/natspec-format.html) (NatSpec).\n\n\n***Update:** Resolved in [pull request #940](https://github.com/scroll-tech/scroll/pull/940) at commit [30fa5e6](https://github.com/scroll-tech/scroll/pull/940/commits/30fa5e65ef577acbde630baa982e1752b2095a60).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/L1/gateways/L1ERC20Gateway.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {IL1ERC20Gateway} from \"./IL1ERC20Gateway.sol\";\nimport {IL1GatewayRouter} from \"./IL1GatewayRouter.sol\";\n\nimport {IL2ERC20Gateway} from \"../../L2/gateways/IL2ERC20Gateway.sol\";\nimport {IScrollMessenger} from \"../../libraries/IScrollMessenger.sol\";\nimport {ScrollConstants} from \"../../libraries/constants/ScrollConstants.sol\";\nimport {ScrollGatewayBase} from \"../../libraries/gateway/ScrollGatewayBase.sol\";\nimport {IMessageDropCallback} from \"../../libraries/callbacks/IMessageDropCallback.sol\";\n\nabstract contract L1ERC20Gateway is IL1ERC20Gateway, IMessageDropCallback, ScrollGatewayBase {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @dev The storage slots for future usage.\n    uint256[50] private __gap;\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        _deposit(_token, msg.sender, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        _deposit(_token, _to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20AndCall(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) external payable override {\n        _deposit(_token, _to, _amount, _data, _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function finalizeWithdrawERC20(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable virtual override onlyCallByCounterpart nonReentrant {\n        _beforeFinalizeWithdrawERC20(_l1Token, _l2Token, _from, _to, _amount, _data);\n\n        // @note can possible trigger reentrant call to this contract or messenger,\n        // but it seems not a big problem.\n        IERC20Upgradeable(_l1Token).safeTransfer(_to, _amount);\n\n        _doCallback(_to, _data);\n\n        emit FinalizeWithdrawERC20(_l1Token, _l2Token, _from, _to, _amount, _data);\n    }\n\n    /// @inheritdoc IMessageDropCallback\n    function onDropMessage(bytes calldata _message) external payable virtual onlyInDropContext nonReentrant {\n        // _message should start with 0x8431f5c1  =>  finalizeDepositERC20(address,address,address,address,uint256,bytes)\n        require(bytes4(_message[0:4]) == IL2ERC20Gateway.finalizeDepositERC20.selector, \"invalid selector\");\n\n        // decode (token, receiver, amount)\n        (address _token, , address _receiver, , uint256 _amount, ) = abi.decode(\n            _message[4:],\n            (address, address, address, address, uint256, bytes)\n        );\n\n        // do dome check for each custom gateway\n        _beforeDropMessage(_token, _receiver, _amount);\n\n        IERC20Upgradeable(_token).safeTransfer(_receiver, _amount);\n\n        emit RefundERC20(_token, _receiver, _amount);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function hook to perform checks and actions before finalizing the withdrawal.\n    /// @param _l1Token The address of corresponding L1 token in L1.\n    /// @param _l2Token The address of corresponding L2 token in L2.\n    /// @param _from The address of account who withdraw the token in L2.\n    /// @param _to The address of recipient in L1 to receive the token.\n    /// @param _amount The amount of the token to withdraw.\n    /// @param _data Optional data to forward to recipient's account.\n    function _beforeFinalizeWithdrawERC20(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) internal virtual;\n\n    /// @dev Internal function hook to perform checks and actions before dropping the message.\n    /// @param _token The L1 token address.\n    /// @param _receiver The recipient address on L1.\n    /// @param _amount The amount of token to refund.\n    function _beforeDropMessage(\n        address _token,\n        address _receiver,\n        uint256 _amount\n    ) internal virtual;\n\n    /// @dev Internal function to transfer ERC20 token to this contract.\n    /// @param _token The address of token to transfer.\n    /// @param _amount The amount of token to transfer.\n    /// @param _data The data passed by caller.\n    function _transferERC20In(\n        address _token,\n        uint256 _amount,\n        bytes memory _data\n    )\n        internal\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        address _from = msg.sender;\n        if (router == msg.sender) {\n            // Extract real sender if this call is from L1GatewayRouter.\n            (_from, _data) = abi.decode(_data, (address, bytes));\n            _amount = IL1GatewayRouter(msg.sender).requestERC20(_from, _token, _amount);\n        } else {\n            // common practice to handle fee on transfer token.\n            uint256 _before = IERC20Upgradeable(_token).balanceOf(address(this));\n            IERC20Upgradeable(_token).safeTransferFrom(_from, address(this), _amount);\n            uint256 _after = IERC20Upgradeable(_token).balanceOf(address(this));\n            // no unchecked here, since some weird token may return arbitrary balance.\n            _amount = _after - _before;\n        }\n        // ignore weird fee on transfer token\n        require(_amount > 0, \"deposit zero amount\");\n\n        // rate limit\n        _addUsedAmount(_token, _amount);\n\n        return (_from, _amount, _data);\n    }\n\n    /// @dev Internal function to do all the deposit operations.\n    ///\n    /// @param _token The token to deposit.\n    /// @param _to The recipient address to recieve the token in L2.\n    /// @param _amount The amount of token to deposit.\n    /// @param _data Optional data to forward to recipient's account.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function _deposit(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) internal virtual;\n}"
    },
    {
      "filename": "contracts/src/L2/gateways/usdc/L2USDCGateway.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.16;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {IFiatToken} from \"../../../interfaces/IFiatToken.sol\";\nimport {IUSDCDestinationBridge} from \"../../../interfaces/IUSDCDestinationBridge.sol\";\nimport {IL1ERC20Gateway} from \"../../../L1/gateways/IL1ERC20Gateway.sol\";\nimport {IL2ScrollMessenger} from \"../../IL2ScrollMessenger.sol\";\nimport {IL2ERC20Gateway} from \"../IL2ERC20Gateway.sol\";\n\nimport {ScrollGatewayBase, IScrollGateway} from \"../../../libraries/gateway/ScrollGatewayBase.sol\";\nimport {L2ERC20Gateway} from \"../L2ERC20Gateway.sol\";\n\n/// @title L2USDCGateway\n/// @notice The `L2USDCGateway` contract is used to withdraw `USDC` token on layer 2 and\n/// finalize deposit `USDC` from layer 1.\ncontract L2USDCGateway is L2ERC20Gateway, IUSDCDestinationBridge {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The address of L1 USDC address.\n    address public immutable l1USDC;\n\n    /// @notice The address of L2 USDC address.\n    address public immutable l2USDC;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The address of caller from Circle.\n    address public circleCaller;\n\n    /// @notice The flag indicates whether USDC deposit is paused.\n    /// @dev This is not necessary to be set `true` since we will set `L1USDCGateway.depositPaused` first.\n    ///      This is kept just in case and will be set after all pending messages are relayed.\n    bool public depositPaused;\n\n    /// @notice The flag indicates whether USDC withdrawal is paused.\n    bool public withdrawPaused;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(address _l1USDC, address _l2USDC) {\n        _disableInitializers();\n\n        l1USDC = _l1USDC;\n        l2USDC = _l2USDC;\n    }\n\n    function initialize(\n        address _counterpart,\n        address _router,\n        address _messenger\n    ) external initializer {\n        require(_router != address(0), \"zero router address\");\n        ScrollGatewayBase._initialize(_counterpart, _router, _messenger);\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IL2ERC20Gateway\n    function getL1ERC20Address(address) external view override returns (address) {\n        return l1USDC;\n    }\n\n    /// @inheritdoc IL2ERC20Gateway\n    function getL2ERC20Address(address) public view override returns (address) {\n        return l2USDC;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL2ERC20Gateway\n    function finalizeDepositERC20(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable override onlyCallByCounterpart nonReentrant {\n        require(msg.value == 0, \"nonzero msg.value\");\n        require(_l1Token == l1USDC, \"l1 token not USDC\");\n        require(_l2Token == l2USDC, \"l2 token not USDC\");\n        require(!depositPaused, \"deposit paused\");\n\n        require(IFiatToken(_l2Token).mint(_to, _amount), \"mint USDC failed\");\n\n        // disable call for USDC\n        // _doCallback(_to, _data);\n\n        emit FinalizeDepositERC20(_l1Token, _l2Token, _from, _to, _amount, _data);\n    }\n\n    /*******************************\n     * Public Restricted Functions *\n     *******************************/\n\n    /// @inheritdoc IUSDCDestinationBridge\n    function transferUSDCRoles(address _owner) external {\n        require(msg.sender == circleCaller, \"only circle caller\");\n\n        OwnableUpgradeable(l2USDC).transferOwnership(_owner);\n    }\n\n    /// @notice Update the Circle EOA address.\n    /// @param _caller The address to update.\n    function updateCircleCaller(address _caller) external onlyOwner {\n        circleCaller = _caller;\n    }\n\n    /// @notice Change the deposit pause status of this contract.\n    /// @param _paused The new status, `true` means paused and `false` means not paused.\n    function pauseDeposit(bool _paused) external onlyOwner {\n        depositPaused = _paused;\n    }\n\n    /// @notice Change the withdraw pause status of this contract.\n    /// @param _paused The new status, `true` means paused and `false` means not paused.\n    function pauseWithdraw(bool _paused) external onlyOwner {\n        withdrawPaused = _paused;\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @inheritdoc L2ERC20Gateway\n    function _withdraw(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) internal virtual override nonReentrant {\n        require(_amount > 0, \"withdraw zero amount\");\n        require(_token == l2USDC, \"only USDC is allowed\");\n        require(!withdrawPaused, \"withdraw paused\");\n\n        // 1. Extract real sender if this call is from L2GatewayRouter.\n        address _from = msg.sender;\n        if (router == msg.sender) {\n            (_from, _data) = abi.decode(_data, (address, bytes));\n        }\n        require(_data.length == 0, \"call is not allowed\");\n\n        // 2. Transfer token into this contract.\n        IERC20Upgradeable(_token).safeTransferFrom(_from, address(this), _amount);\n        IFiatToken(_token).burn(_amount);\n\n        // 3. Generate message passed to L1USDCGateway.\n        address _l1USDC = l1USDC;\n        bytes memory _message = abi.encodeCall(\n            IL1ERC20Gateway.finalizeWithdrawERC20,\n            (_l1USDC, _token, _from, _to, _amount, _data)\n        );\n\n        // 4. Send message to L1ScrollMessenger.\n        IL2ScrollMessenger(messenger).sendMessage{value: msg.value}(counterpart, 0, _message, _gasLimit);\n\n        emit WithdrawERC20(_l1USDC, _token, _from, _to, _amount, _data);\n    }\n}"
    },
    {
      "filename": "contracts/src/interfaces/IMessageTransmitter.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\ninterface IMessageTransmitter {\n    function usedNonces(bytes32 _sourceAndNonce) external view returns (uint256);\n\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success);\n}"
    },
    {
      "filename": "contracts/src/interfaces/IMessageTransmitter.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\ninterface IMessageTransmitter {\n    function usedNonces(bytes32 _sourceAndNonce) external view returns (uint256);\n\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success);\n}"
    },
    {
      "filename": "contracts/src/interfaces/ITokenMessenger.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\n     * on the destination domain must be called by `destinationCaller`.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given destinationCaller is zero address\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function depositForBurnWithCaller(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller\n    ) external returns (uint64 nonce);\n\n    /**\n     * @notice Replace a BurnMessage to change the mint recipient and/or\n     * destination caller. Allows the sender of a previous BurnMessage\n     * (created by depositForBurn or depositForBurnWithCaller)\n     * to send a new BurnMessage to replace the original.\n     * The new BurnMessage will reuse the amount and burn token of the original,\n     * without requiring a new deposit.\n     * @dev The new message will reuse the original message's nonce. For a\n     * given nonce, all replacement message(s) and the original message are\n     * valid to broadcast on the destination domain, until the first message\n     * at the nonce confirms, at which point all others are invalidated.\n     * Note: The msg.sender of the replaced message must be the same as the\n     * msg.sender of the original message.\n     * @param originalMessage original message bytes (to replace)\n     * @param originalAttestation original attestation bytes\n     * @param newDestinationCaller the new destination caller, which may be the\n     * same as the original destination caller, a new destination caller, or an empty\n     * destination caller (bytes32(0), indicating that any destination caller is valid.)\n     * @param newMintRecipient the new mint recipient, which may be the same as the\n     * original mint recipient, or different.\n     */\n    function replaceDepositForBurn(\n        bytes calldata originalMessage,\n        bytes calldata originalAttestation,\n        bytes32 newDestinationCaller,\n        bytes32 newMintRecipient\n    ) external;\n}"
    },
    {
      "filename": "contracts/src/interfaces/IUSDCBurnableSourceBridge.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\n// Implement this on the source chain (Ethereum).\ninterface IUSDCBurnableSourceBridge {\n    /**\n     * @notice Called by Circle, this executes a burn on the source\n     * chain.\n     */\n    function burnAllLockedUSDC() external;\n}"
    },
    {
      "filename": "contracts/src/interfaces/IUSDCDestinationBridge.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\n// Implement this on the destination chain (Scroll).\ninterface IUSDCDestinationBridge {\n    /**\n     * @notice Called by Circle, this transfers FiatToken roles to the designated owner.\n     */\n    function transferUSDCRoles(address owner) external;\n}"
    },
    {
      "filename": "contracts/src/libraries/gateway/CCTPGatewayBase.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {IMessageTransmitter} from \"../../interfaces/IMessageTransmitter.sol\";\n\nimport {ScrollGatewayBase} from \"./ScrollGatewayBase.sol\";\n\nabstract contract CCTPGatewayBase is ScrollGatewayBase {\n    /*********\n     * Enums *\n     *********/\n\n    enum CCTPMessageStatus {\n        None,\n        Pending,\n        Relayed\n    }\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The address of L1 USDC address.\n    address public immutable l1USDC;\n\n    /// @notice The address of L2 USDC address.\n    address public immutable l2USDC;\n\n    /// @notice The destination domain for layer2.\n    uint32 public immutable destinationDomain;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The address of TokenMessenger in local domain.\n    address public cctpMessenger;\n\n    /// @notice The address of MessageTransmitter in local domain.\n    address public cctpTransmitter;\n\n    /// @notice Mapping from destination domain CCTP nonce to status.\n    mapping(uint256 => CCTPMessageStatus) public status;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(\n        address _l1USDC,\n        address _l2USDC,\n        uint32 _destinationDomain\n    ) {\n        l1USDC = _l1USDC;\n        l2USDC = _l2USDC;\n        destinationDomain = _destinationDomain;\n    }\n\n    function _initialize(address _cctpMessenger, address _cctpTransmitter) internal {\n        cctpMessenger = _cctpMessenger;\n        cctpTransmitter = _cctpTransmitter;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Claim USDC that has been cross chained.\n    /// @param _nonce The nonce of the message from CCTP.\n    /// @param _cctpMessage The message passed to MessageTransmitter contract in CCTP.\n    /// @param _cctpSignature The message passed to MessageTransmitter contract in CCTP.\n    function claimUSDC(\n        uint256 _nonce,\n        bytes calldata _cctpMessage,\n        bytes calldata _cctpSignature\n    ) public {\n        // Check `_nonce` match with `_cctpMessage`.\n        // According to the encoding of `_cctpMessage`, the nonce is in bytes 12 to 16.\n        // See here: https://github.com/circlefin/evm-cctp-contracts/blob/master/src/messages/Message.sol#L29\n        uint256 _expectedMessageNonce;\n        assembly {\n            _expectedMessageNonce := and(shr(96, calldataload(_cctpMessage.offset)), 0xffffffffffffffff)\n        }\n        require(_expectedMessageNonce == _nonce, \"nonce mismatch\");\n\n        require(status[_nonce] == CCTPMessageStatus.Pending, \"message not relayed\");\n\n        // call transmitter to mint USDC\n        bool _success = IMessageTransmitter(cctpTransmitter).receiveMessage(_cctpMessage, _cctpSignature);\n        require(_success, \"call transmitter failed\");\n\n        status[_nonce] = CCTPMessageStatus.Relayed;\n    }\n}"
    }
  ]
}