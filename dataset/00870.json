{
  "Title": "M-6: Division difference can result in a revert when claiming treasury yield and excess rewards to some users",
  "Content": "# Issue M-6: Division difference can result in a revert when claiming treasury yield and excess rewards to some users \n\nSource: https://github.com/sherlock-audit/2023-11-convergence-judging/issues/190 \n\n## Found by \ncergyk, hash, vvv\n## Summary\nDifferent ordering of calculations are used to compute `ysTotal` in different situations. This causes the totalShares tracked to be less than the claimable amount of shares  \n\n## Vulnerability Detail\n`ysTotal` is calculated differently when adding to `totalSuppliesTracking` and when computing `balanceOfYsCvgAt`.\nWhen adding to `totalSuppliesTracking`, the calculation of `ysTotal` is as follows:\n\n```solidity\n        uint256 cvgLockAmount = (amount * ysPercentage) / MAX_PERCENTAGE;\n        uint256 ysTotal = (lockDuration * cvgLockAmount) / MAX_LOCK;\n```\n\nIn `balanceOfYsCvgAt`, `ysTotal` is calculated as follows\n\n```solidity\n        uint256 ysTotal = (((endCycle - startCycle) * amount * ysPercentage) / MAX_PERCENTAGE) / MAX_LOCK;\n```\n\nThis difference allows the `balanceOfYsCvgAt` to be greater than what is added to `totalSuppliesTracking`\n\n### POC\n```solidity\n  startCycle 357\n  endCycle 420\n  lockDuration 63\n  amount 2\n  ysPercentage 80\n```\n\nCalculation in `totalSuppliesTracking` gives:\n```solidity\n        uint256 cvgLockAmount = (2 * 80) / 100; == 1\n        uint256 ysTotal = (63 * 1) / 96; == 0\n```\nCalculation in `balanceOfYsCvgAt` gives:\n```solidity\n        uint256 ysTotal = ((63 * 2 * 80) / 100) / 96; == 10080 / 100 / 96 == 1\n```\n\n### Example Scenario\nAlice, Bob and Jake locks cvg for 1 TDE and obtains rounded up `balanceOfYsCvgAt`. A user who is aware of this issue can exploit this issue further by using `increaseLockAmount` with small amount values by which the total difference difference b/w the user's calculated `balanceOfYsCvgAt` and the accounted amount in `totalSuppliesTracking` can be increased. Bob and Jake claims the reward at the end of reward cycle. When Alice attempts to claim rewards, it reverts since there is not enough reward to be sent.\n\n## Impact\nThis breaks the shares accounting of the treasury rewards. Some user's will get more than the actual intended rewards while the last withdrawals will result in a revert\n\n## Code Snippet\n`totalSuppliesTracking` calculation\n\nIn `mintPosition`\nhttps://github.com/sherlock-audit/2023-11-convergence/blob/main/sherlock-cvg/contracts/Locking/LockingPositionService.sol#L261-L263\n\nIn `increaseLockAmount`\nhttps://github.com/sherlock-audit/2023-11-convergence/blob/e894be3e36614a385cf409dc7e278d5b8f16d6f2/sherlock-cvg/contracts/Locking/LockingPositionService.sol#L339-L345\n\nIn `increaseLockTimeAndAmount`\nhttps://github.com/sherlock-audit/2023-11-convergence/blob/main/sherlock-cvg/contracts/Locking/LockingPositionService.sol#L465-L470\n\n`_ysCvgCheckpoint`\nhttps://github.com/sherlock-audit/2023-11-convergence/blob/main/sherlock-cvg/contracts/Locking/LockingPositionService.sol#L577-L584\n\n`balanceOfYsCvgAt` calculation\nhttps://github.com/sherlock-audit/2023-11-convergence/blob/main/sherlock-cvg/contracts/Locking/LockingPositionService.sol#L673-L675\n\n## Tool used\n\nManual Review\n\n## Recommendation\nPerform the same calculation in both places\n\n```diff\n+++                     uint256 _ysTotal = (_extension.endCycle - _extension.cycleId)* ((_extension.cvgLocked * _lockingPosition.ysPercentage) / MAX_PERCENTAGE) / MAX_LOCK;\n---     uint256 ysTotal = (((endCycle - startCycle) * amount * ysPercentage) / MAX_PERCENTAGE) / MAX_LOCK;\n```\n\n\n\n## Discussion\n\n**walk-on-me**\n\nHello\n\nIndeed this is a real problem due the way that the invariant : \n*Sum of all balanceOfYsCvg > totalSupply*\n\nAnd so some positions will become not claimable on the `YsDistributor`.\n\nWe'll correct this by computing the same way the ysTotal & ysPartial on the balanceYs & ysCheckpoint\n\nVery nice finding, it'd break the claim for the last users to claim.\n\n**deadrosesxyz**\n\nEscalate\nThe amounts are scaled up by 1e18. The rounding down problem comes when dividing by `MAX_PERCENTAGE` which equals 100. Worst case scenario (which will only happen if a user deposits an amount which is not divisible by 100), there will be rounding down of up to 99 wei. Not only it is insignificant, it is unlikely to happen as it requires a deposit of an amount not divisible by 1e2.\nBelieve issue should be marked as low.\n\n**sherlock-admin2**\n\n > Escalate\n> The amounts are scaled up by 1e18. The rounding down problem comes when dividing by `MAX_PERCENTAGE` which equals 100. Worst case scenario (which will only happen if a user deposits an amount which is not divisible by 100), there will be rounding down of up to 99 wei. Not only it is insignificant, it is unlikely to happen as it requires a deposit of an amount not divisible by 1e2.\n> Believe issue should be marked as low.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**10xhash**\n\n1. The rounding down is significant because it disallows the last claimers of a TDE cycle from obtaining their reward.\n2. An attacker can perform the attack which requires no expectations from the other users.\n3. The reasoning to classify non 1e2 amounts as unlikely would be the neatness part and the UI interacting users. There is a functionality provided by the CvgUtilities contract itself to lock Cvg using swap and bond tokens which shouldn't be discriminating non 1e2 amounts.\n\n**deadrosesxyz**\n\nWorst case scenario, only the last user will be unable to claim their rewards (even though I described above why it is highly unlikely). In the rare situation it happens, it can be fixed by simply sending a few wei to the contract. \n\n**nevillehuang**\n\nImo, just off point 1 alone, this warrants medium severity at the least. The fact that a donation is required to fix this means there is a bug, and is not intended functionality of the function.\n\n**Czar102**\n\nI agree that this is a borderline low/med.\nI don't see a reason to discriminate nonzero deposits mod 100. That said, I am siding with the escalation â€“ the loss here is insufficient to consider it a material loss of funds (at no point in the lifetime of the codebase will it surpass $1), and a loss of protocol functionality isn't serious enough if simply sending some dust to the contract will resolve the issue.\n\nPlanning to accept the escalation and consider this a low severity issue.\n\n**CergyK**\n\n@Czar102 please consider report #132 which I submitted which allows to steal an arbitrary amount from the rewards under some conditions, which is a higher impact.\n\nMy issue shares the same root cause as this one, so I did not escalate for deduplication. However if you think that this issue should be low, maybe it would be more fair to make my issue unique since the impact is sufficient.\n\n**nevillehuang**\n\n#132 and this #190 shares the same impact, if this is invalid, #132 should be invalid as well. Namely the following two impact:\n\n1. Last user withdrawals can revert\n2. Some users will gain more rewards at the expense of others.\n\nBoth examples present used involve relatively low amounts, so I'm unsure what is the exact impact\n\nComparing this issue attack path\n\n> by using increaseLockAmount with small amount values by which the total difference difference b/w the user's calculated balanceOfYsCvgAt and the accounted amount in totalSuppliesTracking can be increased\n\nand #132\n\n> -> Alice locks some small amount for lockDuration = 64 so that it increases totalSupply by exactly 1\n> -> Alice proceeds to lock X times using the values:\n\nComparing this issue impact\n\n> This breaks the shares accounting of the treasury rewards. Some user's will get more than the actual intended rewards while the last withdrawals will result in a revert\n\nand #132\n\n> Under specific circumstances (if the attacker is the only one to have allocated to YS during a TDE), an attacker is able to claim arbitrarily more rewards than is due to him, stealing rewards from other participants in the protocol\n\nMy opinion is both issues should remain valid medium severity issue based on impact highlighted in both issues.\n\n**CergyK**\n\nAfter some discussion with @nevillehuang, agree that issues should stay duplicated and valid `high/medium` given following reasons:\n- Highest impact is: loss of arbitrary amount of present/future rewards (see #132 for explanation)\n- Necessary condition of very low YS allocation is unlikely but not impossible since YS is not central in Convergence (YS allocation could be empty and the system would be working as expected)\n\n**deadrosesxyz**\n\nTo summarize: \n - Almost certainly in regular conditions, there will be no issue for any user whatsover.\n - In some rare case, (see original escalation) there could be a small overdistribution of rewards (matter of a few wei). In the rarer case all users claim their rewards, the last unstaker will be unable to do so due to lack of funds. This is even more unlikely considering any time a user claims rewards, the amount they claim is rounded down, (due to built-in round down in solidity) leading to making the overdistribution smaller/inexistent. But even if all the conditions are met, the issue can be fixed by simply sending a few wei to the contract. \n - The highest impact described in #132 requires for the total balance to not simply be _very low_ but in fact to be just a few wei. Not only it has to be a few wei, but it has to be a few wei for at least 12 weeks (until TDE payout). It is absolutely unrealistic to have a few wei total balance for 12 weeks. \n \n Issue should remain Low severity\n\n**10xhash**\n\nI agree that the fix of sending minor amounts of all reward tokens won't cost the team any considerable loss financially. But apart from the fix, the impact under reasonable conditions of user not being able to withdraw their rewards is certainly a major one. \nIf issues existing on the contract are judged based on the ease of fixing/preventing, I think a lot more issues would exist under this category. Wouldn't it make almost all functionality breaks in up-gradable contracts low severity due to the fix being an upgrade?     \n\n**Czar102**\n\nDue to the additional impact noted (thank you @CergyK) I think the loss can be sufficient to warrant a medium severity for this issue (loss of funds, but improbable assumptions are made).\n\n**Czar102**\n\nResult:\nMedium\nHas duplicates\n\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [deadrosesxyz](https://github.com/sherlock-audit/2023-11-convergence-judging/issues/190/#issuecomment-1868546666): accepted\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/126",
  "Code": [
    {
      "filename": "sherlock-cvg/contracts/Locking/LockingPositionService.sol",
      "content": "// SPDX-License-Identifier: MIT\n/**\n _____\n/  __ \\\n| /  \\/ ___  _ ____   _____ _ __ __ _  ___ _ __   ___ ___\n| |    / _ \\| '_ \\ \\ / / _ \\ '__/ _` |/ _ \\ '_ \\ / __/ _ \\\n| \\__/\\ (_) | | | \\ V /  __/ | | (_| |  __/ | | | (_|  __/\n \\____/\\___/|_| |_|\\_/ \\___|_|  \\__, |\\___|_| |_|\\___\\___|\n                                 __/ |\n                                |___/\n */\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/ICvgControlTower.sol\";\n\n/**\n * @title Cvg-Finance - LockingPositionService\n * @notice Allows to lock CVG, gives yield and governance power.\n * @dev  When a position is minted, the amount can be split  between 2 different type of CVG :\n *       veCVG : used for voting power ( associated  with MgCVG meta-governance voting power )\n *       | ysCVG : used for treasury shares( allow the user to claim a part of the treasury at each TDE ( treasury distribution event ) )\n *       | the amount  of ys/Ve the user will receive for each CVG locked  is proportional with the duration of the lock.\n */\ncontract LockingPositionService is Ownable2StepUpgradeable {\n    struct LockingPosition {\n        uint96 startCycle;\n        uint96 lastEndCycle;\n        /** @dev  Percentage of the NFT dedicated to ysCvg. */\n        uint64 ysPercentage;\n        /** @dev  Number of CVG Locked. */\n        uint256 totalCvgLocked;\n        /** @dev  Meta Governance CVG amount. */\n        uint256 mgCvgAmount;\n    }\n\n    struct TokenView {\n        uint256 tokenId;\n        uint128 startCycle;\n        uint128 endCycle;\n        uint256 cvgLocked;\n        uint256 ysActual;\n        uint256 ysTotal;\n        uint256 veCvgActual;\n        uint256 mgCvg;\n        uint256 ysPercentage;\n    }\n\n    struct TrackingBalance {\n        uint256 ysToAdd;\n        uint256 ysToSub;\n    }\n\n    struct LockingExtension {\n        uint128 cycleId;\n        uint128 endCycle;\n        uint256 cvgLocked;\n        uint256 mgCvgAdded;\n    }\n\n    event MintLockingPosition(uint256 tokenId, LockingPosition lockingPosition, LockingExtension lockingExtension);\n    event IncreaseLockAmount(uint256 tokenId, LockingPosition lockingPosition, LockingExtension lockingExtension);\n    event IncreaseLockTime(uint256 tokenId, LockingPosition lockingPosition, uint256 oldEndCycle);\n    event IncreaseLockTimeAndAmount(\n        uint256 tokenId,\n        LockingPosition lockingPosition,\n        LockingExtension lockingExtension,\n        uint256 oldEndCycle\n    );\n    event UpdateTotalSupplies(uint256 newYsSupply, uint256 veCvgSupply, uint256 cycle);\n    event LockingPositionBurn(uint256 tokenId);\n\n    /** @dev Maximum locking time in cycle(weeks)  */\n    uint256 public constant MAX_LOCK = 96;\n    /** @dev TDE duration in weeks  */\n    uint256 public constant TDE_DURATION = 12;\n    uint256 public constant MAX_PERCENTAGE = 100;\n    /** @dev pourcentage can only used as multiple of this value */\n    uint256 public constant RANGE_PERCENTAGE = 10;\n\n    /** @dev Convergence ControlTower. */\n    ICvgControlTower public cvgControlTower;\n    /** @dev Convergence CVG. */\n    ICvg public cvg;\n\n    /** @dev Total supply of ysCvg. */\n    uint256 public totalSupplyYsCvg;\n\n    /** @dev  Keeps global data of a LockingPosition. */\n    mapping(uint256 => LockingPosition) public lockingPositions;\n\n    /** @dev Keep track of the ySCvg supply changes for each cycle, so we can compute the totalSupply of ysCvg at each cycle. */\n    mapping(uint256 => TrackingBalance) public totalSuppliesTracking;\n\n    /** @dev Keep track of the ysCvg supply at each cycle. */\n    mapping(uint256 => uint256) public totalSupplyYsCvgHistories;\n\n    /** @dev Keep track of the update of locking positions. */\n    mapping(uint256 => LockingExtension[]) public lockExtensions;\n\n    /** @dev Address => contract is whitelisted to perform locks. */\n    mapping(address => bool) public isContractLocker;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initialize the contract with the ConvergenceControlTower address, set the cvgToken address, transfer ownership to the initializer.\n     * @param _cvgControlTower ConvergenceControlTower address.\n     */\n    function initialize(ICvgControlTower _cvgControlTower) external initializer {\n        cvgControlTower = _cvgControlTower;\n        _transferOwnership(msg.sender);\n        ICvg _cvg = _cvgControlTower.cvgToken();\n        require(address(_cvg) != address(0), \"CVG_ZERO\");\n        cvg = _cvg;\n    }\n\n    /**\n     * @dev  Some methods that are called by wallet ,\n     * can also be called by cvgUtilities meta functionalities\n     * this modifier allow to check both case.\n     * it also check that the token is not time locked.\n     */\n    modifier checkCompliance(uint256 tokenId, address operator) {\n        _checkCompliance(tokenId, operator);\n        _;\n    }\n\n    /**\n     * @dev Some methods that are called by wallet ,\n     * can also be called by cvgUtilities meta functionalities\n     * this modifier allow to check both case.\n     */\n    modifier onlyWalletOrWhiteListedContract() {\n        _onlyWalletOrWhiteListedContract();\n        _;\n    }\n\n    /**\n     * @notice Check the owner of the token  taking into consideration the operator and the msg.sender.\n     * @dev  For the swap and bond function, the caller is the cvgUtilities contract, in which case the token property is checked with the operator, otherwise the sender msg.sender is used.\n     * @param _tokenId ID of the token.\n     * @param _operator address of the operator.\n     */\n    function _checkTokenOwnerShip(uint256 _tokenId, address _operator) internal view {\n        address tokenOwner = cvgControlTower.lockingPositionManager().ownerOf(_tokenId);\n        if (msg.sender == cvgControlTower.cvgUtilities()) {\n            require(_operator == tokenOwner, \"TOKEN_NOT_OWNED\");\n        } else {\n            require(msg.sender == tokenOwner, \"TOKEN_NOT_OWNED\");\n        }\n    }\n\n    /**\n     *  @notice Check if the token is compliant to be manipulated\n     *   this function is used on  methods that can be called by the wallet or the cvgUtilities contract\n     *   the check of ownership is done in both case , it also check that the token is not time locked\n     *   Time lock is a feature that protects a potential buyer of a token from a malicious front run from the seller.\n     *  @param tokenId ID of the token.\n     *  @param operator address of the operator.\n     */\n    function _checkCompliance(uint256 tokenId, address operator) internal view {\n        (address ownerOf, uint256 unlockTimestamp) = cvgControlTower.lockingPositionManager().getComplianceInfo(\n            tokenId\n        );\n        if (msg.sender == cvgControlTower.cvgUtilities()) {\n            require(operator == ownerOf, \"TOKEN_NOT_OWNED\");\n        } else {\n            require(msg.sender == ownerOf, \"TOKEN_NOT_OWNED\");\n        }\n        require(unlockTimestamp < block.timestamp, \"TOKEN_TIMELOCKED\");\n    }\n\n    /**\n     * @notice Check if the caller is a wallet or a whitelisted contract.\n     */\n    function _onlyWalletOrWhiteListedContract() internal view {\n        require(\n            // solhint-disable-next-line avoid-tx-origin\n            msg.sender == tx.origin || isContractLocker[msg.sender],\n            \"NOT_CONTRACT_OR_WL\"\n        );\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                            INFO\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n    struct LockingInfo {\n        uint256 tokenId;\n        uint256 cvgLocked;\n        uint256 lockEnd;\n        uint256 ysPercentage;\n        uint256 mgCvg;\n    }\n\n    /**\n     *   @notice Get position information for a given tokenId, used by the CVG display of the token.\n     *   @param tokenId is the token ID of the position.\n     */\n    function lockingInfo(uint256 tokenId) external view returns (LockingInfo memory) {\n        uint256 _cvgCycle = cvgControlTower.cvgCycle();\n        uint256 tokenLastEndCycle = lockingPositions[tokenId].lastEndCycle;\n\n        return\n            LockingInfo({\n                tokenId: tokenId,\n                cvgLocked: lockingPositions[tokenId].totalCvgLocked,\n                lockEnd: tokenLastEndCycle,\n                ysPercentage: lockingPositions[tokenId].ysPercentage,\n                mgCvg: _cvgCycle > tokenLastEndCycle ? 0 : lockingPositions[tokenId].mgCvgAmount\n            });\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                        PUBLIC FUNCTIONS\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n\n    /**\n     * @notice Mint a locking position (ERC721) for the user.\n     * @dev Lock can't be greater than the Maximum locking time / The end of the lock must finish on a TDE event cycle |  The percentage of ys determines the repartition in veCVG,mgCVG/YsCVG.\n     * @param lockDuration is the duration in cycle(week) of the lock.\n     * @param amount is the amount of cvg to lock in the position.\n     * @param ysPercentage percentage of lock dedicated to treasury shares (ysCVG).\n     * @param receiver address of the receiver of the locking position.\n     * @param isAddToManagedTokens add the created token in managed tokens(voting power)  directly.\n     */\n    function mintPosition(\n        uint96 lockDuration,\n        uint256 amount,\n        uint64 ysPercentage,\n        address receiver,\n        bool isAddToManagedTokens\n    ) external onlyWalletOrWhiteListedContract {\n        require(amount > 0, \"LTE\");\n        /** @dev Percentage cannot be over 100%. */\n        require(ysPercentage <= MAX_PERCENTAGE, \"YS_%_OVER_100\");\n        /** @dev Only percentage with multiple of 10 are possible to use. */\n        require(ysPercentage % RANGE_PERCENTAGE == 0, \"YS_%_10_MULTIPLE\");\n        /** @dev Lock cannot be longer than MAX_LOCK. */\n        require(lockDuration <= MAX_LOCK, \"MAX_LOCK_96_CYCLES\");\n\n        ICvgControlTower _cvgControlTower = cvgControlTower;\n\n        /** @dev Retrieve actual staking cycle. */\n        uint96 actualCycle = uint96(_cvgControlTower.cvgCycle());\n        uint96 endLockCycle = actualCycle + lockDuration;\n        /** @dev End of lock must finish on TDE. */\n        require(endLockCycle % TDE_DURATION == 0, \"END_MUST_BE_TDE_MULTIPLE\");\n\n        ILockingPositionManager _lockingPositionManager = _cvgControlTower.lockingPositionManager();\n\n        /// @dev get the nextId on the LockingPosition manager\n        uint256 tokenId = _lockingPositionManager.nextId();\n\n        uint256 _mgCvgCreated;\n        /** @dev Update checkpoints for YsCvg TotalSupply and Supply by NFT. */\n        if (ysPercentage != 0) {\n            _ysCvgCheckpoint(lockDuration, (amount * ysPercentage) / MAX_PERCENTAGE, actualCycle, endLockCycle);\n        }\n\n        /** @dev Create voting power through Curve contract, link voting power to the  token (NFT). */\n        if (ysPercentage != MAX_PERCENTAGE) {\n            uint256 amountVote = amount * (MAX_PERCENTAGE - ysPercentage);\n\n            /** @dev Timestamp of the end of locking. */\n            _cvgControlTower.votingPowerEscrow().create_lock(\n                tokenId,\n                amountVote / MAX_PERCENTAGE,\n                block.timestamp + (lockDuration + 1) * 7 days\n            );\n            /// @dev compute the amount of mgCvg\n            _mgCvgCreated = (amountVote * lockDuration) / (MAX_LOCK * MAX_PERCENTAGE);\n\n            /// @dev Automatically add the veCVG and mgCVG in the balance taken from Snapshot.\n            if (isAddToManagedTokens) {\n                _cvgControlTower.lockingPositionDelegate().addTokenAtMint(tokenId, receiver);\n            }\n        }\n\n        LockingPosition memory lockingPosition = LockingPosition({\n            startCycle: actualCycle,\n            lastEndCycle: endLockCycle,\n            totalCvgLocked: amount,\n            mgCvgAmount: _mgCvgCreated,\n            ysPercentage: ysPercentage\n        });\n\n        /** @dev Associate this Locking position on the tokenId. */\n        lockingPositions[tokenId] = lockingPosition;\n\n        LockingExtension memory lockingExtension = LockingExtension({\n            cycleId: actualCycle,\n            endCycle: endLockCycle,\n            cvgLocked: amount,\n            mgCvgAdded: _mgCvgCreated\n        });\n\n        /** @dev Add a lock extension with the initial params of the token minted. */\n        lockExtensions[tokenId].push(lockingExtension);\n\n        /** @dev Transfer CVG from user wallet to here. */\n        cvg.transferFrom(msg.sender, address(this), amount);\n\n        /** @dev Mint the ERC721 representing the user position. */\n        _lockingPositionManager.mint(receiver);\n\n        emit MintLockingPosition(tokenId, lockingPosition, lockingExtension);\n    }\n\n    /**\n     * @notice Increase the amount of CVG token in the locking position proportionally from the actual cycle to the end of lock.\n     * @dev CheckCompliance is not used in this function, as an increase in the amount cannot be detrimental to a potential buyer.\n     * @param tokenId is the token ID of the position to extend\n     * @param amount  of cvg to add to the position\n     * @param operator address of token owner (used when call from cvgUtilities)\n     */\n    function increaseLockAmount(\n        uint256 tokenId,\n        uint256 amount,\n        address operator\n    ) external onlyWalletOrWhiteListedContract {\n        require(amount > 0, \"LTE\");\n        _checkTokenOwnerShip(tokenId, operator);\n\n        ICvgControlTower _cvgControlTower = cvgControlTower;\n        LockingPosition memory lockingPosition = lockingPositions[tokenId];\n\n        /** @dev Retrieve actual staking cycle. */\n        uint128 actualCycle = _cvgControlTower.cvgCycle();\n\n        /** @dev Impossible to increase the lock in amount after the end of the lock. */\n        require(lockingPosition.lastEndCycle > actualCycle, \"LOCK_OVER\");\n\n        /** @dev YsCvg TotalSupply Part, access only if some % has been given to ys on the NFT. */\n        if (lockingPosition.ysPercentage != 0) {\n            _ysCvgCheckpoint(\n                lockingPosition.lastEndCycle - actualCycle,\n                (amount * lockingPosition.ysPercentage) / MAX_PERCENTAGE,\n                actualCycle,\n                lockingPosition.lastEndCycle\n            );\n        }\n\n        uint256 _newVotingPower;\n        /** @dev Update voting power through Curve contract, link voting power to the nft tokenId. */\n        if (lockingPosition.ysPercentage != MAX_PERCENTAGE) {\n            uint256 amountVote = amount * (MAX_PERCENTAGE - lockingPosition.ysPercentage);\n            _cvgControlTower.votingPowerEscrow().increase_amount(tokenId, amountVote / MAX_PERCENTAGE);\n            _newVotingPower = (amountVote * (lockingPosition.lastEndCycle - actualCycle)) / (MAX_LOCK * MAX_PERCENTAGE);\n            lockingPositions[tokenId].mgCvgAmount += _newVotingPower;\n        }\n\n        /** @dev Update cvgLocked balance. */\n        lockingPositions[tokenId].totalCvgLocked += amount;\n\n        LockingExtension memory lockingExtension = LockingExtension({\n            cycleId: actualCycle,\n            endCycle: lockingPosition.lastEndCycle,\n            cvgLocked: amount,\n            mgCvgAdded: _newVotingPower\n        });\n\n        /** @dev Add a lock extension linked to the Amount Extension. */\n        lockExtensions[tokenId].push(lockingExtension);\n\n        /** @dev Transfer CVG from user wallet to here. */\n        cvg.transferFrom(msg.sender, address(this), amount);\n\n        emit IncreaseLockAmount(tokenId, lockingPosition, lockingExtension);\n    }\n\n    /**\n     * @notice Increase the time of the lock\n     *         Increasing the locking time will not increase the amount of ysCvg & mgCvg\n     *         The amounts will be just extended on the new duration.\n     * @dev The token must not be time locked  , as an increase in time can be detrimental to a potential buyer.\n     * @param tokenId is the token ID of the position\n     * @param durationAdd is the number of cycle to add to the position lockingTime\n     */\n    function increaseLockTime(\n        uint256 tokenId,\n        uint256 durationAdd\n    ) external checkCompliance(tokenId, address(0)) onlyWalletOrWhiteListedContract {\n        ICvgControlTower _cvgControlTower = cvgControlTower;\n        /** @dev Retrieve actual staking cycle. */\n        uint128 actualCycle = _cvgControlTower.cvgCycle();\n\n        LockingPosition storage lockingPosition = lockingPositions[tokenId];\n        uint256 oldEndCycle = lockingPosition.lastEndCycle + 1;\n        uint256 newEndCycle = oldEndCycle + durationAdd;\n\n        /** @dev Not possible extend a lock in duration after it's expiration. */\n        require(oldEndCycle > actualCycle, \"LOCK_TIME_OVER\");\n\n        /** @dev Not possible to have an active lock longer than the MAX_LOCK. */\n        require(newEndCycle - actualCycle - 1 <= MAX_LOCK, \"MAX_LOCK_96_CYCLES\");\n\n        /** @dev As the oldEnd cycle is a xTDE_DURATION. */\n        /** @dev We just need to verify that the time we add is a xTDE_DURATION to ensure new lock is ending on a xTDE_DURATION. */\n        require(durationAdd % TDE_DURATION == 0, \"NEW_END_MUST_BE_TDE_MULTIPLE\");\n\n        /** @dev YsCvg TotalSupply Part, access only if some % has been given to ys on the NFT. */\n        if (lockingPosition.ysPercentage != 0) {\n            /** @dev Retrieve the balance registered at the cycle where the ysBalance is supposed to drop. */\n            uint256 _ysToReport = balanceOfYsCvgAt(tokenId, oldEndCycle - 1);\n            /** @dev Add this value to the tracking on the oldEndCycle. */\n            totalSuppliesTracking[oldEndCycle].ysToAdd += _ysToReport;\n            /** @dev Report this value in the newEndCycle in the Sub part. */\n            totalSuppliesTracking[newEndCycle].ysToSub += _ysToReport;\n        }\n\n        /** @dev Vote part, access here only if some % has been given to ve/mg on the NFT. */\n        if (lockingPosition.ysPercentage != MAX_PERCENTAGE) {\n            /** @dev Increase Locking time to a new timestamp, computed with the cycle. */\n            _cvgControlTower.votingPowerEscrow().increase_unlock_time(\n                tokenId,\n                block.timestamp + ((newEndCycle - actualCycle) * 7 days)\n            );\n        }\n\n        /** @dev Update the new end cycle on the locking position. */\n        lockingPosition.lastEndCycle = uint96(newEndCycle - 1);\n\n        emit IncreaseLockTime(tokenId, lockingPosition, oldEndCycle - 1);\n    }\n\n    /**\n     * @notice Increase first the time THEN the amount in the position proportionally from the actual cycle to the end of lock.\n     * @dev The token must not be time locked, as an increase in the time can be detrimental to a potential buyer.\n     * @param tokenId is the token ID of the position\n     * @param durationAdd is the number of cycle to add to the position lockingTime\n     * @param amount  of cvg to add to the position\n     * @param operator address of token owner (used when call from cvgUtilities)\n     */\n    function increaseLockTimeAndAmount(\n        uint256 tokenId,\n        uint256 durationAdd,\n        uint256 amount,\n        address operator\n    ) external checkCompliance(tokenId, operator) onlyWalletOrWhiteListedContract {\n        require(amount > 0, \"LTE\");\n        ICvgControlTower _cvgControlTower = cvgControlTower;\n        /** @dev Retrieve actual staking cycle. */\n        uint128 actualCycle = _cvgControlTower.cvgCycle();\n\n        LockingPosition storage lockingPosition = lockingPositions[tokenId];\n        uint256 oldEndCycle = lockingPosition.lastEndCycle + 1;\n        /** @dev Calculating the new end cycle. */\n        uint256 newEndCycle = oldEndCycle + durationAdd;\n        /** @dev Check  the new end cycle. */\n        require(oldEndCycle > actualCycle, \"LOCK_OVER\");\n        require(newEndCycle - actualCycle - 1 <= MAX_LOCK, \"MAX_LOCK_96_CYCLES\");\n        require(durationAdd % TDE_DURATION == 0, \"END_MUST_BE_TDE_MULTIPLE\");\n\n        if (lockingPosition.ysPercentage != 0) {\n            /** @dev Taking in account the change of YsCvg TotalSupply update. */\n            uint256 _ysToReport = balanceOfYsCvgAt(tokenId, oldEndCycle - 1);\n            totalSuppliesTracking[oldEndCycle].ysToAdd += _ysToReport;\n            totalSuppliesTracking[newEndCycle].ysToSub += _ysToReport;\n\n            _ysCvgCheckpoint(\n                newEndCycle - actualCycle - 1,\n                (amount * lockingPosition.ysPercentage) / MAX_PERCENTAGE,\n                actualCycle,\n                newEndCycle - 1\n            );\n        }\n\n        uint256 _newVotingPower;\n\n        if (lockingPosition.ysPercentage != MAX_PERCENTAGE) {\n            /** @dev Update voting power through veCVG contract, link voting power to the nft tokenId. */\n            uint256 amountVote = amount * (MAX_PERCENTAGE - lockingPosition.ysPercentage);\n            _newVotingPower = (amountVote * (newEndCycle - actualCycle - 1)) / (MAX_LOCK * MAX_PERCENTAGE);\n            lockingPosition.mgCvgAmount += _newVotingPower;\n\n            _cvgControlTower.votingPowerEscrow().increase_unlock_time_and_amount(\n                tokenId,\n                block.timestamp + ((newEndCycle - actualCycle) * 7 days),\n                amountVote / MAX_PERCENTAGE\n            );\n        }\n\n        /** @dev Update the new end cycle on the locking position. */\n        lockingPosition.lastEndCycle = uint96(newEndCycle - 1);\n        lockingPosition.totalCvgLocked += amount;\n\n        LockingExtension memory _lockingExtension = LockingExtension({\n            cycleId: actualCycle,\n            endCycle: uint128(newEndCycle - 1),\n            cvgLocked: amount,\n            mgCvgAdded: _newVotingPower\n        });\n        /** @dev Keep track of the update on the lock , including mgCvg part. */\n        lockExtensions[tokenId].push(_lockingExtension);\n\n        /** @dev Transfer CVG */\n        cvg.transferFrom(msg.sender, address(this), amount);\n\n        emit IncreaseLockTimeAndAmount(tokenId, lockingPosition, _lockingExtension, oldEndCycle - 1);\n    }\n\n    /**\n     * @notice Unlock CVG tokens under the NFT Locking Position : Burn the NFT, Transfer back the CVG to the user.  Rewards from YsDistributor must be claimed before or they will be lost.    * @dev The locking time must be over\n     * @param tokenId to burn\n     */\n    function burnPosition(uint256 tokenId) external {\n        _checkTokenOwnerShip(tokenId, address(0));\n        ICvgControlTower _cvgControlTower = cvgControlTower;\n        uint256 lastEndCycle = lockingPositions[tokenId].lastEndCycle;\n        uint256 ysPercentage = lockingPositions[tokenId].ysPercentage;\n        uint256 totalCvgLocked = lockingPositions[tokenId].totalCvgLocked;\n\n        require(_cvgControlTower.cvgCycle() > lastEndCycle, \"LOCKED\");\n\n        /** @dev  if the position contains veCvg , we must remove it from the voting escrow */\n        if (ysPercentage != MAX_PERCENTAGE) {\n            _cvgControlTower.votingPowerEscrow().withdraw(tokenId);\n        }\n\n        /** @dev Burn the NFT representing the position. */\n        _cvgControlTower.lockingPositionManager().burn(tokenId);\n\n        /** @dev Transfer CVG back to the user. */\n        cvg.transfer(msg.sender, totalCvgLocked);\n\n        emit LockingPositionBurn(tokenId);\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                    ONLY CONTROL TOWER\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n    /**\n     * @notice Compute the new Ys total supply  by adding and subtracting checkpoints formerly created on mint & increaseLock by the _YsCvgCheckpoint().\n     * @dev  Only callable by ControlTower ( DAO ).\n     */\n    function updateYsTotalSupply() external {\n        ICvgControlTower _cvgControlTower = cvgControlTower;\n\n        require(msg.sender == address(_cvgControlTower), \"NOT_CONTROL_TOWER\");\n        uint256 actualCycle = _cvgControlTower.cvgCycle();\n\n        uint256 totalSupplyYsCvgBeforeUpdate = totalSupplyYsCvg;\n\n        /** @dev Register the last totalSupply for the past cycle. */\n        totalSupplyYsCvgHistories[actualCycle - 1] = totalSupplyYsCvgBeforeUpdate;\n\n        /** @dev Update ysCVG  total supply with checkpoints for the actual cycle */\n        totalSupplyYsCvg =\n            totalSupplyYsCvgBeforeUpdate +\n            totalSuppliesTracking[actualCycle].ysToAdd -\n            totalSuppliesTracking[actualCycle].ysToSub;\n\n        emit UpdateTotalSupplies(\n            totalSupplyYsCvgBeforeUpdate,\n            _cvgControlTower.votingPowerEscrow().total_supply(),\n            actualCycle - 1\n        );\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                    INTERNAL FUNCTIONS\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n    /**\n     *  @notice Compute the new Ys by adding and subtracting\n     *   checkpoints formerly created on mint & increaseLock by the _YsCvgCheckpoint().\n     *  @dev  Only callable by ControlTower ( DAO ).\n     *  @param lockDuration is the duration in cycle(week) of the lock\n     *  @param cvgLockAmount is the amount of cvg to lock in the position\n     *  @param actualCycle is the actual cycle of the cvg\n     *  @param endLockCycle is the end cycle of the lock\n     */\n    function _ysCvgCheckpoint(\n        uint256 lockDuration,\n        uint256 cvgLockAmount,\n        uint256 actualCycle,\n        uint256 endLockCycle\n    ) internal {\n        /** @dev Compute the amount of ysCVG on this Locking Position proportionally with the ratio of lockDuration and MAX LOCK duration. */\n        uint256 ysTotalAmount = (lockDuration * cvgLockAmount) / MAX_LOCK;\n        uint256 realStartCycle = actualCycle + 1;\n        uint256 realEndCycle = endLockCycle + 1;\n        /** @dev If the lock is not made on a TDE cycle,   we need to compute the ratio of ysCVG  for the current partial TDE */\n        if (actualCycle % TDE_DURATION != 0) {\n            /** @dev Get the cycle id of next TDE to be taken into account for this LockingPosition. */\n            uint256 nextTdeCycle = (actualCycle / TDE_DURATION + 1) * TDE_DURATION + 1;\n            /** @dev Represent the amount of ysCvg to be taken into account on the next TDE of this LockingPosition. */\n            uint256 ysNextTdeAmount = ((nextTdeCycle - realStartCycle) * ysTotalAmount) / TDE_DURATION;\n\n            totalSuppliesTracking[realStartCycle].ysToAdd += ysNextTdeAmount;\n\n            /** @dev When a lock is greater than a TDE_DURATION */\n            if (lockDuration >= TDE_DURATION) {\n                /** @dev we add the calculations for the next full TDE */\n                totalSuppliesTracking[nextTdeCycle].ysToAdd += ysTotalAmount - ysNextTdeAmount;\n                totalSuppliesTracking[realEndCycle].ysToSub += ysTotalAmount;\n            }\n            /** @dev If the lock less than TDE_DURATION. */\n            else {\n                /** @dev We simply remove the amount from the supply calculation at the end of the TDE */\n                totalSuppliesTracking[realEndCycle].ysToSub += ysNextTdeAmount;\n            }\n        }\n        /** @dev If the lock is performed on a TDE cycle  */\n        else {\n            totalSuppliesTracking[realStartCycle].ysToAdd += ysTotalAmount;\n            totalSuppliesTracking[realEndCycle].ysToSub += ysTotalAmount;\n        }\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                        VIEW FUNCTIONS\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n\n    /**\n     *   @notice Returns the information needed to display the lock position display svg.\n     *   @param _tokenId id of the token\n     */\n    function tokenInfos(uint256 _tokenId) external view returns (TokenView memory) {\n        LockingPosition memory _lockingPosition = lockingPositions[_tokenId];\n        ICvgControlTower _cvgControlTower = cvgControlTower;\n\n        uint256 _cvgCycle = _cvgControlTower.cvgCycle();\n\n        return\n            TokenView({\n                tokenId: _tokenId,\n                cvgLocked: _lockingPosition.totalCvgLocked,\n                startCycle: _lockingPosition.startCycle,\n                endCycle: _lockingPosition.lastEndCycle,\n                veCvgActual: _cvgControlTower.votingPowerEscrow().balanceOf(_tokenId),\n                ysTotal: balanceOfYsCvgAt(_tokenId, _lockingPosition.lastEndCycle),\n                ysActual: balanceOfYsCvgAt(_tokenId, _cvgCycle),\n                mgCvg: _cvgCycle > _lockingPosition.lastEndCycle ? 0 : _lockingPosition.mgCvgAmount,\n                ysPercentage: _lockingPosition.ysPercentage\n            });\n    }\n\n    /**\n     * @notice Fetch the balance of veCVG (gauge voting power)  for a specified tokenId.\n     * @param _tokenId id of the token\n     */\n    function balanceOfVeCvg(uint256 _tokenId) public view returns (uint256) {\n        return cvgControlTower.votingPowerEscrow().balanceOf(_tokenId);\n    }\n\n    /**\n     * @notice Fetch the balance of ysCVG (treasury share)  for a specified tokenId and at a specified cycle, can be in the future.\n     * @param _tokenId id of the token\n     * @param _cycleId id of the cycle\n     */\n    function balanceOfYsCvgAt(uint256 _tokenId, uint256 _cycleId) public view returns (uint256) {\n        require(_cycleId != 0, \"NOT_EXISTING_CYCLE\");\n\n        LockingPosition memory _lockingPosition = lockingPositions[_tokenId];\n        LockingExtension[] memory _extensions = lockExtensions[_tokenId];\n        uint256 _ysCvgBalance;\n\n        /** @dev If the requested cycle is before or after the lock , there is no balance. */\n        if (_lockingPosition.startCycle >= _cycleId || _cycleId > _lockingPosition.lastEndCycle) {\n            return 0;\n        }\n        /** @dev We go through the extensions to compute the balance of ysCvg at the cycleId */\n        for (uint256 i; i < _extensions.length; ) {\n            /** @dev Don't take into account the extensions if in the future. */\n            if (_extensions[i].cycleId < _cycleId) {\n                LockingExtension memory _extension = _extensions[i];\n                uint256 _firstTdeCycle = TDE_DURATION * (_extension.cycleId / TDE_DURATION + 1);\n                uint256 _ysTotal = (((_extension.endCycle - _extension.cycleId) *\n                    _extension.cvgLocked *\n                    _lockingPosition.ysPercentage) / MAX_PERCENTAGE) / MAX_LOCK;\n                uint256 _ysPartial = ((_firstTdeCycle - _extension.cycleId) * _ysTotal) / TDE_DURATION;\n                /** @dev For locks that last less than 1 TDE. */\n                if (_extension.endCycle - _extension.cycleId <= TDE_DURATION) {\n                    _ysCvgBalance += _ysPartial;\n                } else {\n                    _ysCvgBalance += _cycleId <= _firstTdeCycle ? _ysPartial : _ysTotal;\n                }\n            }\n            ++i;\n        }\n        return _ysCvgBalance;\n    }\n\n    /**\n     * @notice  Fetch the balance of mgCVG (meta-governance voting power ) for a specified tokenId and at a specified cycle, this can be in the future.\n     */\n    function balanceOfMgCvgAt(uint256 _tokenId, uint256 _cycleId) public view returns (uint256) {\n        require(_cycleId != 0, \"NOT_EXISTING_CYCLE\");\n\n        LockingPosition memory _lockingPosition = lockingPositions[_tokenId];\n        LockingExtension[] memory _extensions = lockExtensions[_tokenId];\n        uint256 _mgCvgBalance;\n\n        /** @dev If the requested cycle is before or after the lock , there is no balance. */\n        if (_lockingPosition.startCycle > _cycleId || _cycleId > _lockingPosition.lastEndCycle) {\n            return 0;\n        }\n        /** @dev We go through the extensions to compute the balance of mgCvg at the cycleId */\n        for (uint256 i; i < _extensions.length; ) {\n            LockingExtension memory _extension = _extensions[i];\n            if (_extension.cycleId <= _cycleId) {\n                _mgCvgBalance += _extension.mgCvgAdded;\n            }\n            ++i;\n        }\n\n        return _mgCvgBalance;\n    }\n\n    /**\n     * @notice Fetch the balance of mgCVG (meta-governance voting power ) for a specified tokenId.\n     * @param _tokenId id of the token\n     */\n    function balanceOfMgCvg(uint256 _tokenId) public view returns (uint256) {\n        return balanceOfMgCvgAt(_tokenId, cvgControlTower.cvgCycle());\n    }\n\n    /**\n     *   @notice Fetch the voting power (in veCvg) for a specified address, used in the Cvg Governance proposal strategy.\n     *   @param _user is the address that we want to fetch voting power from\n     */\n    function veCvgVotingPowerPerAddress(address _user) external view returns (uint256) {\n        uint256 _totalVotingPower;\n\n        ILockingPositionDelegate _lockingPositionDelegate = cvgControlTower.lockingPositionDelega"
    }
  ]
}