{
  "Title": "H-3: Tier winner can steal excess funds from tiered percentage bounty if any deposits are expired",
  "Content": "# Issue H-3: Tier winner can steal excess funds from tiered percentage bounty if any deposits are expired \n\nSource: https://github.com/sherlock-audit/2023-02-openq-judging/issues/275 \n\n## Found by \nRobert, 0x52, bin2chen, ast3ros, unforgiven, jkoppel\n\n## Summary\n\nTotal funds used to calculate the percentage payment is set when the bounty is closed. If the main deposit is refundable by the time when the bounty is closed, a tier winner could exploit the bounty to steal all the funds in the contract.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-02-openq/blob/main/contracts/Bounty/Implementations/TieredPercentageBountyV1.sol#L123-L136\n\nWhen a tiered bounty is closed, the balances of each payout token is snapshot.\n\nhttps://github.com/sherlock-audit/2023-02-openq/blob/main/contracts/Bounty/Implementations/TieredPercentageBountyV1.sol#L104-L120\n\nThese balance snapshots are used to calculate the amount to pay of each payout token. The balances are only snapshot once and don't change when deposits are refunded. A tier winner can abuse this structure to steal excess funds from the contract if there are any expired deposits. This would be accomplished by using a very short-lived deposit to artificially inflate the prize pool before claiming and refunding to drain all available funds.\n\nExample:\nUser A creates a competition with 10,000 USDC in prizes. The contest goes longer than expected and their deposit becomes available for refund. User B wins 3rd place which entitles them to 10% of the pool. User A makes a call adding User B as the winner of tier 2 (3rd place). User B calls DepositManagerV1#fundBountyToken to fund the bounty with 90,000 USDC and a _expiration of 1 (second). They then call ClaimManagerV1#permissionedClaimTieredBounty which snapshots the total bounty at 100,000 USDC and entitles User B to 10,000 USDC (10%) of winnings. The next block User B calls DepositManagerV1#refundDeposit and refunds their deposit. Since the initial 10,000 USDC deposit has expired, User B withdraws the other 90,000 USDC in the contract. This leaves the bounty with no funds.\n\n## Impact\n\nTier winner can steal all funds in the percentage bounty during claim if initial deposit is expired\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-openq/blob/main/contracts/Bounty/Implementations/TieredPercentageBountyV1.sol#L104-L120\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAll deposits should be locked for some minimum amount of time after a tiered bounty has been closed\n\n## Discussion\n\n**FlacoJones**\n\nhttps://github.com/OpenQDev/OpenQ-Contracts/pull/112 and https://github.com/OpenQDev/OpenQ-Contracts/pull/117\n\n**sherlock-admin**\n\n> N/A\n\nYou've deleted an escalation for this issue.\n\n**ctf-sec**\n\nEscalate for 50 USDC. I would love to make a few arguments: this exploits path is feasible because first of all, user can claim the refund after the competition is closed and the snapshot of the tierPercentageContract balance is taken. secondly, the expiration time can be gamed. then the exploit path is formulated:\n\n> These balance snapshots are used to calculate the amount to pay of each payout token. The balances are only snapshot once and don't change when deposits are refunded. A tier winner can abuse this structure to steal excess funds from the contract if there are any expired deposits. This would be accomplished by using a very short-lived deposit to artificially inflate the prize pool before claiming and refunding to drain all available funds.\n\nHowever, the issue \"user can claim the refund after the competition is closed\" is already rewarded, then either 266 should be considered as a duplicate of this issue or this issue can be considered as a duplicate of the 266\n\nhttps://github.com/sherlock-audit/2023-02-openq-judging/issues/266\n\nthe issue \" This would be accomplished by using a very short-lived deposit to artificially inflate the prize pool before claiming\" because the expiration can be gamed, adversary can set short expiration time.\n\nwhich is the issue: https://github.com/sherlock-audit/2023-02-openq-judging/issues/229, but is it not rewarded.\n\nmy issue https://github.com/sherlock-audit/2023-02-openq-judging/issues/187 also mentioned that the expiration time can be gamed as well and I did articulate the impact:\n\n> Developer B failed to claim the entitled bounty because User A set expiration time too short and claim the refund.\n\nI think https://github.com/sherlock-audit/2023-02-openq-judging/issues/229 can be considered as the duplicate of this issue as well because the short expiration is crucial to this attack. this leads to my next point.\n\nI think this bug report should be a medium instead of high, according to the judging guide given the risk of the attacker is taking.\n\nhttps://docs.sherlock.xyz/audits/watsons/judging\n\n> Criteria for Issues:\nMedium: There is a viable scenario (even if unlikely) that could cause the protocol to enter a state where a material amount of funds can be lost. The attack path is possible with assumptions that either mimic on-chain conditions or reflect conditions that have a reasonable chance of becoming true in the future. The more expensive the attack is for an attacker, the less likely it will be included as a Medium (holding all other factors constant). The vulnerability must be something that is not considered an acceptable risk by a reasonable protocol team.\n\n> High: This vulnerability would result in a material loss of funds and the cost of the attack is low (relative to the amount of funds lost). The attack path is possible with reasonable assumptions that mimic on-chain conditions. The vulnerability must be something that is not considered an acceptable risk by a reasonable protocol team.\n\nI argue that the attack cost is not low at all, and the attack is risky and the attack can lose money.\n\nJust using the POC provided in this bug report:\n\n> User A creates a competition with 10,000 USDC in prizes. The contest goes longer than expected and their deposit becomes available for refund. User B wins 3rd place which entitles them to 10% of the pool. User A makes a call adding User B as the winner of tier 2 (3rd place). User B calls DepositManagerV1#fundBountyToken to fund the bounty with 90,000 USDC and a _expiration of 1 (second). They then call ClaimManagerV1#permissionedClaimTieredBounty which snapshots the total bounty at 100,000 USDC and entitles User B to 10,000 USDC (10%) of winnings. \n\n> The next block User B calls DepositManagerV1#refundDeposit and refunds their deposit. Since the initial 10,000 USDC deposit has expired, User B withdraws the other 90,000 USDC in the contract. This leaves the bounty with no funds.\n\nEven though the expiration time is set to 1 second, before the malicious user B call refundDeposit to claim the 90000 USDC, it is very possible that user C, another tier winner (for example, user C is the tier 1 winner and is eligible for winning 50% of the reward), user C call permissionedClaimTieredBounty to claim 50% of the 100,000 (10000 USDC provided by User A and the rest provided by User B), user C unexpectedly getting 5,0000 but the malicious user B is losing a lot of money.\n\nThe lower tier the malicious winner, the more difficult the attack is and the attack is not profitable at all if the attacker lose a lot of money nd athe other tier winner claims the tiered rewards before the attacker refund the token, thus I think the cost of the attack is high and the issue is a medium issue instead of a HIGH issue.\n\nTo summarize my point:\n\n1. the root cause: the deposit expiration time is gamed and should be marked as a duplicate of this issue.\n2. the issue should be a medium issue given the cost of the attack and the potential heavy loss of the attacker.\n\n\n\n**sherlock-admin**\n\n > Escalate for 50 USDC. I would love to make a few arguments: this exploits path is feasible because first of all, user can claim the refund after the competition is closed and the snapshot of the tierPercentageContract balance is taken. secondly, the expiration time can be gamed. then the exploit path is formulated:\n> \n> > These balance snapshots are used to calculate the amount to pay of each payout token. The balances are only snapshot once and don't change when deposits are refunded. A tier winner can abuse this structure to steal excess funds from the contract if there are any expired deposits. This would be accomplished by using a very short-lived deposit to artificially inflate the prize pool before claiming and refunding to drain all available funds.\n> \n> However, the issue \"user can claim the refund after the competition is closed\" is already rewarded, then either 266 should be considered as a duplicate of this issue or this issue can be considered as a duplicate of the 266\n> \n> https://github.com/sherlock-audit/2023-02-openq-judging/issues/266\n> \n> the issue \" This would be accomplished by using a very short-lived deposit to artificially inflate the prize pool before claiming\" because the expiration can be gamed, adversary can set short expiration time.\n> \n> which is the issue: https://github.com/sherlock-audit/2023-02-openq-judging/issues/229, but is it not rewarded.\n> \n> my issue https://github.com/sherlock-audit/2023-02-openq-judging/issues/187 also mentioned that the expiration time can be gamed as well and I did articulate the impact:\n> \n> > Developer B failed to claim the entitled bounty because User A set expiration time too short and claim the refund.\n> \n> I think https://github.com/sherlock-audit/2023-02-openq-judging/issues/229 can be considered as the duplicate of this issue as well because the short expiration is crucial to this attack. this leads to my next point.\n> \n> I think this bug report should be a medium instead of high, according to the judging guide given the risk of the attacker is taking.\n> \n> https://docs.sherlock.xyz/audits/watsons/judging\n> \n> > Criteria for Issues:\n> Medium: There is a viable scenario (even if unlikely) that could cause the protocol to enter a state where a material amount of funds can be lost. The attack path is possible with assumptions that either mimic on-chain conditions or reflect conditions that have a reasonable chance of becoming true in the future. The more expensive the attack is for an attacker, the less likely it will be included as a Medium (holding all other factors constant). The vulnerability must be something that is not considered an acceptable risk by a reasonable protocol team.\n> \n> > High: This vulnerability would result in a material loss of funds and the cost of the attack is low (relative to the amount of funds lost). The attack path is possible with reasonable assumptions that mimic on-chain conditions. The vulnerability must be something that is not considered an acceptable risk by a reasonable protocol team.\n> \n> I argue that the attack cost is not low at all, and the attack is risky and the attack can lose money.\n> \n> Just using the POC provided in this bug report:\n> \n> > User A creates a competition with 10,000 USDC in prizes. The contest goes longer than expected and their deposit becomes available for refund. User B wins 3rd place which entitles them to 10% of the pool. User A makes a call adding User B as the winner of tier 2 (3rd place). User B calls DepositManagerV1#fundBountyToken to fund the bounty with 90,000 USDC and a _expiration of 1 (second). They then call ClaimManagerV1#permissionedClaimTieredBounty which snapshots the total bounty at 100,000 USDC and entitles User B to 10,000 USDC (10%) of winnings. \n> \n> > The next block User B calls DepositManagerV1#refundDeposit and refunds their deposit. Since the initial 10,000 USDC deposit has expired, User B withdraws the other 90,000 USDC in the contract. This leaves the bounty with no funds.\n> \n> Even though the expiration time is set to 1 second, before the malicious user B call refundDeposit to claim the 90000 USDC, it is very possible that user C, another tier winner (for example, user C is the tier 1 winner and is eligible for winning 50% of the reward), user C call permissionedClaimTieredBounty to claim 50% of the 100,000 (10000 USDC provided by User A and the rest provided by User B), user C unexpectedly getting 5,0000 but the malicious user B is losing a lot of money.\n> \n> The lower tier the malicious winner, the more difficult the attack is and the attack is not profitable at all if the attacker lose a lot of money nd athe other tier winner claims the tiered rewards before the attacker refund the token, thus I think the cost of the attack is high and the issue is a medium issue instead of a HIGH issue.\n> \n> To summarize my point:\n> \n> 1. the root cause: the deposit expiration time is gamed and should be marked as a duplicate of this issue.\n> 2. the issue should be a medium issue given the cost of the attack and the potential heavy loss of the attacker.\n> \n> \n\nYou've created a valid escalation for 50 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation rejected\n\nIssue #275 and #266 are different as 275 is about a malicious user inflating the prize pool to steal extra funds using refund deposit and short expiration time. While 266 is user breaking the payouts by first depositing, setting fundingTotals & using refund. \n\nBoth issues #229 and #187 do not talk of the above attacks. and mentions only the part of the short expiration time that the Sponsor has addressed in the respective issue. \n\n\n\n**sherlock-admin**\n\n> Escalation rejected\n> \n> Issue #275 and #266 are different as 275 is about a malicious user inflating the prize pool to steal extra funds using refund deposit and short expiration time. While 266 is user breaking the payouts by first depositing, setting fundingTotals & using refund. \n> \n> Both issues #229 and #187 do not talk of the above attacks. and mentions only the part of the short expiration time that the Sponsor has addressed in the respective issue. \n> \n> \n\nThis issue's escalations have been rejected!\n\nWatsons who escalated this issue will have their escalation amount deducted from their next payout.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/39",
  "Code": [
    {
      "filename": "contracts/Bounty/Implementations/TieredPercentageBountyV1.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport '../Storage/TieredPercentageBountyStorage.sol';\n\n/// @title TieredPercentageBountyV1\n/// @notice TieredPercentageBountyV1 is a bounty implementation contract for single contributor, single payout circumstances\n/// @dev TieredPercentageBountyV1 -> TieredPercentageBountyStorageV1 -> TieredBountyCore -> TieredBountyStorageCore -> (BountyCore -> BountyStorageCore) -> (Third Party Deps + Custom )\n/// @dev Do not add any new storage variables here. Put them in a TieredPercentageBountyStorageV# and release new implementation\ncontract TieredPercentageBountyV1 is TieredPercentageBountyStorageV1 {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address payable;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    constructor() {}\n\n    /// @notice Initializes a bounty proxy with initial state\n    /// @param _bountyId The unique bounty identifier\n    /// @param _issuer The sender of the mint bounty transaction\n    /// @param _organization The organization associated with the bounty\n    /// @param _openQ The OpenQProxy address\n    /// @param _claimManager The Claim Manager proxy address\n    /// @param _depositManager The Deposit Manager proxy address\n    /// @param _operation The ABI encoded data determining the type of bounty being initialized and associated data\n    /// @dev see IBountyCore.initialize.(_operation) for _operation ABI encoding schema for TIERED PERCENTAGE\n    function initialize(\n        string memory _bountyId,\n        address _issuer,\n        string memory _organization,\n        address _openQ,\n        address _claimManager,\n        address _depositManager,\n        OpenQDefinitions.InitOperation memory _operation\n    ) external initializer {\n        require(bytes(_bountyId).length != 0, Errors.NO_EMPTY_BOUNTY_ID);\n        require(bytes(_organization).length != 0, Errors.NO_EMPTY_ORGANIZATION);\n\n        __ReentrancyGuard_init();\n\n        __OnlyOpenQ_init(_openQ);\n        __ClaimManagerOwnable_init(_claimManager);\n        __DepositManagerOwnable_init(_depositManager);\n\n        bountyId = _bountyId;\n        issuer = _issuer;\n        organization = _organization;\n        bountyCreatedTime = block.timestamp;\n        nftDepositLimit = 5;\n\n        (\n            uint256[] memory _payoutSchedule,\n            bool _hasFundingGoal,\n            address _fundingToken,\n            uint256 _fundingGoal,\n            bool _invoiceRequired,\n            bool _kycRequired,\n            bool _supportingDocumentsRequired,\n            string memory _issuerExternalUserId,\n            ,\n\n        ) = abi.decode(\n                _operation.data,\n                (\n                    uint256[],\n                    bool,\n                    address,\n                    uint256,\n                    bool,\n                    bool,\n                    bool,\n                    string,\n                    string,\n                    string\n                )\n            );\n\n        uint256 sum;\n        for (uint256 i = 0; i < _payoutSchedule.length; i++) {\n            sum += _payoutSchedule[i];\n        }\n        require(sum == 100, Errors.PAYOUT_SCHEDULE_MUST_ADD_TO_100);\n        payoutSchedule = _payoutSchedule;\n\n        bountyType = OpenQDefinitions.TIERED_PERCENTAGE;\n        hasFundingGoal = _hasFundingGoal;\n        fundingToken = _fundingToken;\n        fundingGoal = _fundingGoal;\n        invoiceRequired = _invoiceRequired;\n        kycRequired = _kycRequired;\n        supportingDocumentsRequired = _supportingDocumentsRequired;\n        issuerExternalUserId = _issuerExternalUserId;\n\n        // Initialize metadata arrays to same number of tiers\n        tierWinners = new string[](_payoutSchedule.length);\n        invoiceComplete = new bool[](_payoutSchedule.length);\n        supportingDocumentsComplete = new bool[](_payoutSchedule.length);\n    }\n\n    /// @notice Transfers the tiered percentage of the token balance of _tokenAddress from bounty to _payoutAddress\n    /// @param _payoutAddress The destination address for the fund\n    /// @param _tier The ordinal of the claimant (e.g. 1st place, 2nd place)\n    /// @param _tokenAddress The token address being claimed\n    /// @return Volume of claimed token payout\n    function claimTiered(\n        address _payoutAddress,\n        uint256 _tier,\n        address _tokenAddress\n    ) external onlyClaimManager nonReentrant returns (uint256) {\n        require(\n            bountyType == OpenQDefinitions.TIERED_PERCENTAGE,\n            Errors.NOT_A_TIERED_BOUNTY\n        );\n        require(!tierClaimed[_tier], Errors.TIER_ALREADY_CLAIMED);\n\n        uint256 claimedBalance = (payoutSchedule[_tier] *\n            fundingTotals[_tokenAddress]) / 100;\n\n        _transferToken(_tokenAddress, claimedBalance, _payoutAddress);\n        return claimedBalance;\n    }\n\n    /// @notice Similar to close() for single priced bounties. closeCompetition() freezes the current funds for the competition.\n    function closeCompetition() external onlyClaimManager {\n        require(\n            status == OpenQDefinitions.OPEN,\n            Errors.CONTRACT_ALREADY_CLOSED\n        );\n\n        status = OpenQDefinitions.CLOSED;\n        bountyClosedTime = block.timestamp;\n\n        for (uint256 i = 0; i < getTokenAddresses().length; i++) {\n            address _tokenAddress = getTokenAddresses()[i];\n            fundingTotals[_tokenAddress] = getTokenBalance(_tokenAddress);\n        }\n    }\n\n    /// @notice Sets the payout schedule\n    /// @notice There is no tokenAddress needed here - payouts on percentage tiered bounties is a percentage of whatever is deposited on the contract\n    /// @param _payoutSchedule An array of payout volumes for each tier\n    function setPayoutSchedule(uint256[] calldata _payoutSchedule)\n        external\n        onlyOpenQ\n    {\n        require(\n            bountyType == OpenQDefinitions.TIERED_PERCENTAGE,\n            Errors.NOT_A_TIERED_BOUNTY\n        );\n        uint256 sum;\n        for (uint256 i = 0; i < _payoutSchedule.length; i++) {\n            sum += _payoutSchedule[i];\n        }\n        require(sum == 100, Errors.PAYOUT_SCHEDULE_MUST_ADD_TO_100);\n\n        payoutSchedule = _payoutSchedule;\n\n        // Resize metadata arrays and copy current members to new array\n        // NOTE: If resizing to fewer tiers than previously, the final indexes will be removed\n        string[] memory newTierWinners = new string[](payoutSchedule.length);\n        bool[] memory newInvoiceComplete = new bool[](payoutSchedule.length);\n        bool[] memory newSupportingDocumentsCompleted = new bool[](\n            payoutSchedule.length\n        );\n\n        for (uint256 i = 0; i < tierWinners.length; i++) {\n            newTierWinners[i] = tierWinners[i];\n        }\n        tierWinners = newTierWinners;\n\n        for (uint256 i = 0; i < invoiceComplete.length; i++) {\n            newInvoiceComplete[i] = invoiceComplete[i];\n        }\n        invoiceComplete = newInvoiceComplete;\n\n        for (uint256 i = 0; i < supportingDocumentsComplete.length; i++) {\n            newSupportingDocumentsCompleted[i] = supportingDocumentsComplete[i];\n        }\n        supportingDocumentsComplete = newSupportingDocumentsCompleted;\n    }\n\n    /// @notice receive() method to accept protocol tokens\n    receive() external payable {\n        revert(\n            'Cannot send Ether directly to boutny contract. Please use the BountyV1.receiveFunds() method.'\n        );\n    }\n}"
    },
    {
      "filename": "contracts/Bounty/Implementations/TieredPercentageBountyV1.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport '../Storage/TieredPercentageBountyStorage.sol';\n\n/// @title TieredPercentageBountyV1\n/// @notice TieredPercentageBountyV1 is a bounty implementation contract for single contributor, single payout circumstances\n/// @dev TieredPercentageBountyV1 -> TieredPercentageBountyStorageV1 -> TieredBountyCore -> TieredBountyStorageCore -> (BountyCore -> BountyStorageCore) -> (Third Party Deps + Custom )\n/// @dev Do not add any new storage variables here. Put them in a TieredPercentageBountyStorageV# and release new implementation\ncontract TieredPercentageBountyV1 is TieredPercentageBountyStorageV1 {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address payable;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    constructor() {}\n\n    /// @notice Initializes a bounty proxy with initial state\n    /// @param _bountyId The unique bounty identifier\n    /// @param _issuer The sender of the mint bounty transaction\n    /// @param _organization The organization associated with the bounty\n    /// @param _openQ The OpenQProxy address\n    /// @param _claimManager The Claim Manager proxy address\n    /// @param _depositManager The Deposit Manager proxy address\n    /// @param _operation The ABI encoded data determining the type of bounty being initialized and associated data\n    /// @dev see IBountyCore.initialize.(_operation) for _operation ABI encoding schema for TIERED PERCENTAGE\n    function initialize(\n        string memory _bountyId,\n        address _issuer,\n        string memory _organization,\n        address _openQ,\n        address _claimManager,\n        address _depositManager,\n        OpenQDefinitions.InitOperation memory _operation\n    ) external initializer {\n        require(bytes(_bountyId).length != 0, Errors.NO_EMPTY_BOUNTY_ID);\n        require(bytes(_organization).length != 0, Errors.NO_EMPTY_ORGANIZATION);\n\n        __ReentrancyGuard_init();\n\n        __OnlyOpenQ_init(_openQ);\n        __ClaimManagerOwnable_init(_claimManager);\n        __DepositManagerOwnable_init(_depositManager);\n\n        bountyId = _bountyId;\n        issuer = _issuer;\n        organization = _organization;\n        bountyCreatedTime = block.timestamp;\n        nftDepositLimit = 5;\n\n        (\n            uint256[] memory _payoutSchedule,\n            bool _hasFundingGoal,\n            address _fundingToken,\n            uint256 _fundingGoal,\n            bool _invoiceRequired,\n            bool _kycRequired,\n            bool _supportingDocumentsRequired,\n            string memory _issuerExternalUserId,\n            ,\n\n        ) = abi.decode(\n                _operation.data,\n                (\n                    uint256[],\n                    bool,\n                    address,\n                    uint256,\n                    bool,\n                    bool,\n                    bool,\n                    string,\n                    string,\n                    string\n                )\n            );\n\n        uint256 sum;\n        for (uint256 i = 0; i < _payoutSchedule.length; i++) {\n            sum += _payoutSchedule[i];\n        }\n        require(sum == 100, Errors.PAYOUT_SCHEDULE_MUST_ADD_TO_100);\n        payoutSchedule = _payoutSchedule;\n\n        bountyType = OpenQDefinitions.TIERED_PERCENTAGE;\n        hasFundingGoal = _hasFundingGoal;\n        fundingToken = _fundingToken;\n        fundingGoal = _fundingGoal;\n        invoiceRequired = _invoiceRequired;\n        kycRequired = _kycRequired;\n        supportingDocumentsRequired = _supportingDocumentsRequired;\n        issuerExternalUserId = _issuerExternalUserId;\n\n        // Initialize metadata arrays to same number of tiers\n        tierWinners = new string[](_payoutSchedule.length);\n        invoiceComplete = new bool[](_payoutSchedule.length);\n        supportingDocumentsComplete = new bool[](_payoutSchedule.length);\n    }\n\n    /// @notice Transfers the tiered percentage of the token balance of _tokenAddress from bounty to _payoutAddress\n    /// @param _payoutAddress The destination address for the fund\n    /// @param _tier The ordinal of the claimant (e.g. 1st place, 2nd place)\n    /// @param _tokenAddress The token address being claimed\n    /// @return Volume of claimed token payout\n    function claimTiered(\n        address _payoutAddress,\n        uint256 _tier,\n        address _tokenAddress\n    ) external onlyClaimManager nonReentrant returns (uint256) {\n        require(\n            bountyType == OpenQDefinitions.TIERED_PERCENTAGE,\n            Errors.NOT_A_TIERED_BOUNTY\n        );\n        require(!tierClaimed[_tier], Errors.TIER_ALREADY_CLAIMED);\n\n        uint256 claimedBalance = (payoutSchedule[_tier] *\n            fundingTotals[_tokenAddress]) / 100;\n\n        _transferToken(_tokenAddress, claimedBalance, _payoutAddress);\n        return claimedBalance;\n    }\n\n    /// @notice Similar to close() for single priced bounties. closeCompetition() freezes the current funds for the competition.\n    function closeCompetition() external onlyClaimManager {\n        require(\n            status == OpenQDefinitions.OPEN,\n            Errors.CONTRACT_ALREADY_CLOSED\n        );\n\n        status = OpenQDefinitions.CLOSED;\n        bountyClosedTime = block.timestamp;\n\n        for (uint256 i = 0; i < getTokenAddresses().length; i++) {\n            address _tokenAddress = getTokenAddresses()[i];\n            fundingTotals[_tokenAddress] = getTokenBalance(_tokenAddress);\n        }\n    }\n\n    /// @notice Sets the payout schedule\n    /// @notice There is no tokenAddress needed here - payouts on percentage tiered bounties is a percentage of whatever is deposited on the contract\n    /// @param _payoutSchedule An array of payout volumes for each tier\n    function setPayoutSchedule(uint256[] calldata _payoutSchedule)\n        external\n        onlyOpenQ\n    {\n        require(\n            bountyType == OpenQDefinitions.TIERED_PERCENTAGE,\n            Errors.NOT_A_TIERED_BOUNTY\n        );\n        uint256 sum;\n        for (uint256 i = 0; i < _payoutSchedule.length; i++) {\n            sum += _payoutSchedule[i];\n        }\n        require(sum == 100, Errors.PAYOUT_SCHEDULE_MUST_ADD_TO_100);\n\n        payoutSchedule = _payoutSchedule;\n\n        // Resize metadata arrays and copy current members to new array\n        // NOTE: If resizing to fewer tiers than previously, the final indexes will be removed\n        string[] memory newTierWinners = new string[](payoutSchedule.length);\n        bool[] memory newInvoiceComplete = new bool[](payoutSchedule.length);\n        bool[] memory newSupportingDocumentsCompleted = new bool[](\n            payoutSchedule.length\n        );\n\n        for (uint256 i = 0; i < tierWinners.length; i++) {\n            newTierWinners[i] = tierWinners[i];\n        }\n        tierWinners = newTierWinners;\n\n        for (uint256 i = 0; i < invoiceComplete.length; i++) {\n            newInvoiceComplete[i] = invoiceComplete[i];\n        }\n        invoiceComplete = newInvoiceComplete;\n\n        for (uint256 i = 0; i < supportingDocumentsComplete.length; i++) {\n            newSupportingDocumentsCompleted[i] = supportingDocumentsComplete[i];\n        }\n        supportingDocumentsComplete = newSupportingDocumentsCompleted;\n    }\n\n    /// @notice receive() method to accept protocol tokens\n    receive() external payable {\n        revert(\n            'Cannot send Ether directly to boutny contract. Please use the BountyV1.receiveFunds() method.'\n        );\n    }\n}"
    },
    {
      "filename": "contracts/Bounty/Implementations/TieredPercentageBountyV1.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport '../Storage/TieredPercentageBountyStorage.sol';\n\n/// @title TieredPercentageBountyV1\n/// @notice TieredPercentageBountyV1 is a bounty implementation contract for single contributor, single payout circumstances\n/// @dev TieredPercentageBountyV1 -> TieredPercentageBountyStorageV1 -> TieredBountyCore -> TieredBountyStorageCore -> (BountyCore -> BountyStorageCore) -> (Third Party Deps + Custom )\n/// @dev Do not add any new storage variables here. Put them in a TieredPercentageBountyStorageV# and release new implementation\ncontract TieredPercentageBountyV1 is TieredPercentageBountyStorageV1 {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address payable;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    constructor() {}\n\n    /// @notice Initializes a bounty proxy with initial state\n    /// @param _bountyId The unique bounty identifier\n    /// @param _issuer The sender of the mint bounty transaction\n    /// @param _organization The organization associated with the bounty\n    /// @param _openQ The OpenQProxy address\n    /// @param _claimManager The Claim Manager proxy address\n    /// @param _depositManager The Deposit Manager proxy address\n    /// @param _operation The ABI encoded data determining the type of bounty being initialized and associated data\n    /// @dev see IBountyCore.initialize.(_operation) for _operation ABI encoding schema for TIERED PERCENTAGE\n    function initialize(\n        string memory _bountyId,\n        address _issuer,\n        string memory _organization,\n        address _openQ,\n        address _claimManager,\n        address _depositManager,\n        OpenQDefinitions.InitOperation memory _operation\n    ) external initializer {\n        require(bytes(_bountyId).length != 0, Errors.NO_EMPTY_BOUNTY_ID);\n        require(bytes(_organization).length != 0, Errors.NO_EMPTY_ORGANIZATION);\n\n        __ReentrancyGuard_init();\n\n        __OnlyOpenQ_init(_openQ);\n        __ClaimManagerOwnable_init(_claimManager);\n        __DepositManagerOwnable_init(_depositManager);\n\n        bountyId = _bountyId;\n        issuer = _issuer;\n        organization = _organization;\n        bountyCreatedTime = block.timestamp;\n        nftDepositLimit = 5;\n\n        (\n            uint256[] memory _payoutSchedule,\n            bool _hasFundingGoal,\n            address _fundingToken,\n            uint256 _fundingGoal,\n            bool _invoiceRequired,\n            bool _kycRequired,\n            bool _supportingDocumentsRequired,\n            string memory _issuerExternalUserId,\n            ,\n\n        ) = abi.decode(\n                _operation.data,\n                (\n                    uint256[],\n                    bool,\n                    address,\n                    uint256,\n                    bool,\n                    bool,\n                    bool,\n                    string,\n                    string,\n                    string\n                )\n            );\n\n        uint256 sum;\n        for (uint256 i = 0; i < _payoutSchedule.length; i++) {\n            sum += _payoutSchedule[i];\n        }\n        require(sum == 100, Errors.PAYOUT_SCHEDULE_MUST_ADD_TO_100);\n        payoutSchedule = _payoutSchedule;\n\n        bountyType = OpenQDefinitions.TIERED_PERCENTAGE;\n        hasFundingGoal = _hasFundingGoal;\n        fundingToken = _fundingToken;\n        fundingGoal = _fundingGoal;\n        invoiceRequired = _invoiceRequired;\n        kycRequired = _kycRequired;\n        supportingDocumentsRequired = _supportingDocumentsRequired;\n        issuerExternalUserId = _issuerExternalUserId;\n\n        // Initialize metadata arrays to same number of tiers\n        tierWinners = new string[](_payoutSchedule.length);\n        invoiceComplete = new bool[](_payoutSchedule.length);\n        supportingDocumentsComplete = new bool[](_payoutSchedule.length);\n    }\n\n    /// @notice Transfers the tiered percentage of the token balance of _tokenAddress from bounty to _payoutAddress\n    /// @param _payoutAddress The destination address for the fund\n    /// @param _tier The ordinal of the claimant (e.g. 1st place, 2nd place)\n    /// @param _tokenAddress The token address being claimed\n    /// @return Volume of claimed token payout\n    function claimTiered(\n        address _payoutAddress,\n        uint256 _tier,\n        address _tokenAddress\n    ) external onlyClaimManager nonReentrant returns (uint256) {\n        require(\n            bountyType == OpenQDefinitions.TIERED_PERCENTAGE,\n            Errors.NOT_A_TIERED_BOUNTY\n        );\n        require(!tierClaimed[_tier], Errors.TIER_ALREADY_CLAIMED);\n\n        uint256 claimedBalance = (payoutSchedule[_tier] *\n            fundingTotals[_tokenAddress]) / 100;\n\n        _transferToken(_tokenAddress, claimedBalance, _payoutAddress);\n        return claimedBalance;\n    }\n\n    /// @notice Similar to close() for single priced bounties. closeCompetition() freezes the current funds for the competition.\n    function closeCompetition() external onlyClaimManager {\n        require(\n            status == OpenQDefinitions.OPEN,\n            Errors.CONTRACT_ALREADY_CLOSED\n        );\n\n        status = OpenQDefinitions.CLOSED;\n        bountyClosedTime = block.timestamp;\n\n        for (uint256 i = 0; i < getTokenAddresses().length; i++) {\n            address _tokenAddress = getTokenAddresses()[i];\n            fundingTotals[_tokenAddress] = getTokenBalance(_tokenAddress);\n        }\n    }\n\n    /// @notice Sets the payout schedule\n    /// @notice There is no tokenAddress needed here - payouts on percentage tiered bounties is a percentage of whatever is deposited on the contract\n    /// @param _payoutSchedule An array of payout volumes for each tier\n    function setPayoutSchedule(uint256[] calldata _payoutSchedule)\n        external\n        onlyOpenQ\n    {\n        require(\n            bountyType == OpenQDefinitions.TIERED_PERCENTAGE,\n            Errors.NOT_A_TIERED_BOUNTY\n        );\n        uint256 sum;\n        for (uint256 i = 0; i < _payoutSchedule.length; i++) {\n            sum += _payoutSchedule[i];\n        }\n        require(sum == 100, Errors.PAYOUT_SCHEDULE_MUST_ADD_TO_100);\n\n        payoutSchedule = _payoutSchedule;\n\n        // Resize metadata arrays and copy current members to new array\n        // NOTE: If resizing to fewer tiers than previously, the final indexes will be removed\n        string[] memory newTierWinners = new string[](payoutSchedule.length);\n        bool[] memory newInvoiceComplete = new bool[](payoutSchedule.length);\n        bool[] memory newSupportingDocumentsCompleted = new bool[](\n            payoutSchedule.length\n        );\n\n        for (uint256 i = 0; i < tierWinners.length; i++) {\n            newTierWinners[i] = tierWinners[i];\n        }\n        tierWinners = newTierWinners;\n\n        for (uint256 i = 0; i < invoiceComplete.length; i++) {\n            newInvoiceComplete[i] = invoiceComplete[i];\n        }\n        invoiceComplete = newInvoiceComplete;\n\n        for (uint256 i = 0; i < supportingDocumentsComplete.length; i++) {\n            newSupportingDocumentsCompleted[i] = supportingDocumentsComplete[i];\n        }\n        supportingDocumentsComplete = newSupportingDocumentsCompleted;\n    }\n\n    /// @notice receive() method to accept protocol tokens\n    receive() external payable {\n        revert(\n            'Cannot send Ether directly to boutny contract. Please use the BountyV1.receiveFunds() method.'\n        );\n    }\n}"
    }
  ]
}