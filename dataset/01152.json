{
  "Title": "Enforced Transactions Signed Off-Chain Are Likely to Fail",
  "Content": "The `EnforcedTxGateway` contract allows users to sign a transaction hash that authorizes an L1 to L2 transaction. During the verification of the signature, the [signed hash is computed](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/gateways/EnforcedTxGateway.sol#L86) given the `sendTransaction` function parameters, except for the `_queueIndex` value, which is fetched as the supposedly following index from the message queue.\n\n\nTiming this queue index during signing becomes challenging considering the following scenario:\n\n\n1. User A signs the transaction off-chain for index `i`.\n2. User B queues a transaction unrelated to A, thereby incrementing the queue index to `i+1`.\n3. User C tries to submit user A's transaction, which reverts due to the mismatching queue indices.\n\n\nDepending on the activity of the messenger contract and the delay between users A and C, it is likely that this call reverts.\n\n\nConsider repurposing the queue index to a `nonce` that is signed as part of the transaction hash by taking it as an additional function parameter. The replayability must therefore be prevented by keeping track of used transaction hashes in a mapping. Also, consider adding an expiration timestamp and chain id to the message such that signed messages are not indefinitely valid and are chain dependent. Otherwise, a signature can be reused for a rollup that follows the same message format and is signed by the same user. It's important to note that the transaction hash should not be constructed over the signature when an OpenZeppelin library version lower than 4.7.3 is used, due to a [signature malleability issue](https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-4h98-2769-gh6h).\n\n\n***Update:** Resolved in [pull request #620](https://github.com/scroll-tech/scroll/pull/620) at commit [af8a4c9](https://github.com/scroll-tech/scroll/pull/620/commits/af8a4c9ac808bf70e27c4d3ef4ede18ede565075). The data is now signed using the EIP-712 standard. Expiration and replayability were addressed by adding a deadline and nonce.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/L1/gateways/EnforcedTxGateway.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {ECDSAUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport {IL1MessageQueue} from \"../rollup/IL1MessageQueue.sol\";\n\ncontract EnforcedTxGateway is OwnableUpgradeable, ReentrancyGuardUpgradeable, PausableUpgradeable {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when owner updates fee vault contract.\n    /// @param _oldFeeVault The address of old fee vault contract.\n    /// @param _newFeeVault The address of new fee vault contract.\n    event UpdateFeeVault(address _oldFeeVault, address _newFeeVault);\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The address of L1MessageQueue contract.\n    address public messageQueue;\n\n    /// @notice The address of fee vault contract.\n    address public feeVault;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    function initialize(address _queue, address _feeVault) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        PausableUpgradeable.__Pausable_init();\n\n        messageQueue = _queue;\n        feeVault = _feeVault;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Add an enforced transaction to L2.\n    /// @dev The caller should be EOA only.\n    /// @param _target The address of target contract to call in L2.\n    /// @param _value The value passed\n    /// @param _gasLimit The maximum gas should be used for this transaction in L2.\n    /// @param _data The calldata passed to target contract.\n    function sendTransaction(\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes calldata _data\n    ) external payable whenNotPaused {\n        require(msg.sender == tx.origin, \"Only EOA senders are allowed to send enforced transaction\");\n\n        _sendTransaction(msg.sender, _target, _value, _gasLimit, _data, msg.sender);\n    }\n\n    /// @notice Add an enforced transaction to L2.\n    /// @dev The `_sender` should be EOA and match with the signature.\n    /// @param _sender The address of sender who will initiate this transaction in L2.\n    /// @param _target The address of target contract to call in L2.\n    /// @param _value The value passed\n    /// @param _gasLimit The maximum gas should be used for this transaction in L2.\n    /// @param _data The calldata passed to target contract.\n    /// @param _signature The signature for the transaction.\n    /// @param _refundAddress The address to refund exceeded fee.\n    function sendTransaction(\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes calldata _data,\n        bytes memory _signature,\n        address _refundAddress\n    ) external payable whenNotPaused {\n        address _messageQueue = messageQueue;\n        uint256 _queueIndex = IL1MessageQueue(messageQueue).nextCrossDomainMessageIndex();\n        bytes32 _txHash = IL1MessageQueue(_messageQueue).computeTransactionHash(\n            _sender,\n            _queueIndex,\n            _value,\n            _target,\n            _gasLimit,\n            _data\n        );\n\n        bytes32 _signHash = ECDSAUpgradeable.toEthSignedMessageHash(_txHash);\n        address _signer = ECDSAUpgradeable.recover(_signHash, _signature);\n\n        // no need to check `_signer != address(0)`, since it is checked in `recover`.\n        require(_signer == _sender, \"Incorrect signature\");\n\n        _sendTransaction(_sender, _target, _value, _gasLimit, _data, _refundAddress);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update the address of fee vault.\n    /// @param _newFeeVault The address to update.\n    function updateFeeVault(address _newFeeVault) external onlyOwner {\n        address _oldFeeVault = feeVault;\n        feeVault = _newFeeVault;\n\n        emit UpdateFeeVault(_oldFeeVault, _newFeeVault);\n    }\n\n    /// @notice Pause or unpause this contract.\n    /// @param _status Pause this contract if it is true, otherwise unpause this contract.\n    function setPaused(bool _status) external onlyOwner {\n        if (_status) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to charge fee and add enforced transaction.\n    /// @param _sender The address of sender who will initiate this transaction in L2.\n    /// @param _target The address of target contract to call in L2.\n    /// @param _value The value passed\n    /// @param _gasLimit The maximum gas should be used for this transaction in L2.\n    /// @param _data The calldata passed to target contract.\n    /// @param _refundAddress The address to refund exceeded fee.\n    function _sendTransaction(\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes calldata _data,\n        address _refundAddress\n    ) internal nonReentrant {\n        address _messageQueue = messageQueue;\n\n        // charge fee\n        uint256 _fee = IL1MessageQueue(_messageQueue).estimateCrossDomainMessageFee(_gasLimit);\n        require(msg.value >= _fee, \"Insufficient value for fee\");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}(\"\");\n            require(_success, \"Failed to deduct the fee\");\n        }\n\n        // append transaction\n        IL1MessageQueue(messageQueue).appendEnforcedTransaction(_sender, _target, _value, _gasLimit, _data);\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}(\"\");\n                require(_success, \"Failed to refund the fee\");\n            }\n        }\n    }\n}"
    }
  ]
}