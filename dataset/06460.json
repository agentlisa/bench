{
  "Title": "[M-03] `RootBridgeAgent.redeemSettlement` can be front-run using `RootBridgeAgent.retrySettlement`, causing redeem to DoS",
  "Content": "\nSince [RootBridgeAgent.retrySettlement(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L243-L252) can be called by **anyone** for **any** settlement, a malicious actor can front-run a user trying to redeem their failed settlement via [RootBridgeAgent.redeemSettlement(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L254-L268) by calling [RootBridgeAgent.retrySettlement(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L243-L252) with `_remoteExecutionGas = 0`, in order to make sure that this settlement will also fail in the future.\n\nAs a consequence, the user's subsequent call to [RootBridgeAgent.redeemSettlement(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L254-L268) [will revert](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L260-L261) (DoS) because the settlement was [already marked](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L577) with `SettlementStatus.Success` during the malicious actor's call to [RootBridgeAgent.retrySettlement(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L243-L252). Therefore, the user is unable to redeem their assets.\n\n### Proof of Concept\n\nThe following PoC modifies an existing test case to confirm the above claims resulting in:\n\n- The settlement is being marked with `SettlementStatus.Success`.\n- DoS of [RootBridgeAgent.redeemSettlement(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L254-L268) is the method for this settlement.\n- The user is not able to redeem their assets.\n\nJust apply the *diff* below and run the test with `forge test --match-test testRedeemSettlement`:\n\n```diff\ndiff --git a/test/ulysses-omnichain/RootTest.t.sol b/test/ulysses-omnichain/RootTest.t.sol\nindex ea88453..ccd7ad2 100644\n--- a/test/ulysses-omnichain/RootTest.t.sol\n+++ b/test/ulysses-omnichain/RootTest.t.sol\n@@ -1299,14 +1299,13 @@ contract RootTest is DSTestPlus {\n         hevm.deal(_user, 1 ether);\n \n         //Retry Settlement\n-        multicallBridgeAgent.retrySettlement{value: 1 ether}(settlementNonce, 0.5 ether);\n \n         settlement = multicallBridgeAgent.getSettlementEntry(settlementNonce);\n \n         require(settlement.status == SettlementStatus.Success, \"Settlement status should be success.\");\n     }\n \n-    function testRedeemSettlement() public {\n+    function testRedeemSettlementFrontRunDoS() public {\n         //Set up\n         testAddLocalTokenArbitrum();\n \n@@ -1389,15 +1388,25 @@ contract RootTest is DSTestPlus {\n \n         require(settlement.status == SettlementStatus.Failed, \"Settlement status should be failed.\");\n \n-        //Retry Settlement\n-        multicallBridgeAgent.redeemSettlement(settlementNonce);\n+        //Front-run redeem settlement with '_remoteExecutionGas = 0'\n+        address _malice = address(0x1234);\n+        hevm.deal(_malice, 1 ether);\n+        hevm.prank(_malice);\n+        multicallBridgeAgent.retrySettlement{value: 1 ether}(settlementNonce, 0 ether);\n \n         settlement = multicallBridgeAgent.getSettlementEntry(settlementNonce);\n+        require(settlement.status == SettlementStatus.Success, \"Settlement status should be success.\");\n \n-        require(settlement.owner == address(0), \"Settlement should cease to exist.\");\n+        //Redeem settlement DoS cause settlement is marked as success\n+        hevm.expectRevert(abi.encodeWithSignature(\"SettlementRedeemUnavailable()\"));\n+        multicallBridgeAgent.redeemSettlement(settlementNonce);\n+\n+        settlement = multicallBridgeAgent.getSettlementEntry(settlementNonce);\n+        require(settlement.owner != address(0), \"Settlement should still exist.\");\n \n+        //User couldn't redeem funds\n         require(\n-            MockERC20(newAvaxAssetGlobalAddress).balanceOf(_user) == 150 ether, \"Settlement should have been redeemed\"\n+            MockERC20(newAvaxAssetGlobalAddress).balanceOf(_user) == 0 ether, \"Settlement should not have been redeemed\"\n         );\n     }\n \n```\n\n### Tools Used\n\nVS Code, Foundry\n\n### Recommended Mitigation Steps\n\nI suggest to only allow calls to [RootBridgeAgent.retrySettlement(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L243-L252) by the settlement owner:\n\n```diff\ndiff --git a/src/ulysses-omnichain/RootBridgeAgent.sol b/src/ulysses-omnichain/RootBridgeAgent.sol\nindex 34f4286..4acef39 100644\n--- a/src/ulysses-omnichain/RootBridgeAgent.sol\n+++ b/src/ulysses-omnichain/RootBridgeAgent.sol\n@@ -242,6 +242,14 @@ contract RootBridgeAgent is IRootBridgeAgent {\n \n     /// @inheritdoc IRootBridgeAgent\n     function retrySettlement(uint32 _settlementNonce, uint128 _remoteExecutionGas) external payable {\n+        //Get deposit owner.\n+        address depositOwner = getSettlement[_settlementNonce].owner;\n+        if (\n+            msg.sender != depositOwner && msg.sender != address(IPort(localPortAddress).getUserAccount(depositOwner))\n+        ) {\n+            revert NotSettlementOwner();\n+        }\n+\n         //Update User Gas available.\n         if (initialGas == 0) {\n             userFeeInfo.depositedGas = uint128(msg.value);\n\n```\n\n### Assessed type\n\nDoS\n\n**[0xBugsy (Maia) confirmed and commented](https://github.com/code-423n4/2023-05-maia-findings/issues/869#issuecomment-1632814004):**\n > Despite the user being still entitled to their assets and able to call retry with gas and redeem, this would allow anyone to grieve a user's failed settlement, causing the user to spend unnecessary time/gas. If the economic incentives exist, this could be done repeatedly. As this is completely undesired, we will add a settlement owner verification to `retrySettlement` function.\n\n**[peakbolt (warden) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/869#issuecomment-1654501484):**\n > Front-running is not possible on the root chain (Arbitrum), as there is no `mempool` and the Arbitrum Sequencer orders transactions on a first come, first served basis. Refer to Arbitrum docs at https://developer.arbitrum.io/learn-more/faq#will-transactions-with-a-higher-gas-price-bid-be-confirmed-first\n\n**[0xTheC0der (warden) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/869#issuecomment-1654591091):**\n > I partially agree; however, the affected contract is part of the Ulysses Omnichain system and therefore, not limited to Arbitrum.  \n >\n> Furthermore, due to the lack of access control of `retrySettlement`, this can also accidentally happen when a user calls it with the wrong settlement nonce and therefore, doesn't necessarily need a `mempool`. Irrespective of a malicious or good intention, a user should not be able to cause DoS for another user.\n\n**[peakbolt (warden) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/869#issuecomment-1657131274):**\n > Thanks for the clarification. Agree with the point that it extends beyond Arbitrum. \n\n**[0xLightt (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/869#issuecomment-1708800159):**\n > Addressed [here](https://github.com/Maia-DAO/eco-c4-contest/tree/183-492-688-869).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/ulysses-omnichain/RootBridgeAgent.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {WETH9} from \"./interfaces/IWETH9.sol\";\nimport {IUniswapV3Pool} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\n\nimport {AnycallFlags} from \"./lib/AnycallFlags.sol\";\n\nimport {IAnycallProxy} from \"./interfaces/IAnycallProxy.sol\";\nimport {IAnycallConfig} from \"./interfaces/IAnycallConfig.sol\";\nimport {IAnycallExecutor} from \"./interfaces/IAnycallExecutor.sol\";\n\nimport {IApp, IRootBridgeAgent} from \"./interfaces/IRootBridgeAgent.sol\";\nimport {IBranchBridgeAgent} from \"./interfaces/IBranchBridgeAgent.sol\";\nimport {IERC20hTokenRoot} from \"./interfaces/IERC20hTokenRoot.sol\";\nimport {IRootPort as IPort} from \"./interfaces/IRootPort.sol\";\nimport {IRootRouter as IRouter} from \"./interfaces/IRootRouter.sol\";\n\nimport {VirtualAccount} from \"./VirtualAccount.sol\";\nimport {\n    IRootBridgeAgent,\n    DepositParams,\n    DepositMultipleParams,\n    Settlement,\n    SettlementStatus,\n    SettlementParams,\n    SettlementMultipleParams,\n    UserFeeInfo,\n    SwapCallbackData\n} from \"./interfaces/IRootBridgeAgent.sol\";\n\nimport {DeployRootBridgeAgentExecutor, RootBridgeAgentExecutor} from \"./RootBridgeAgentExecutor.sol\";\n\n/// @title Library for Cross Chain Deposit Parameters Validation.\nlibrary CheckParamsLib {\n    /**\n     * @notice Function to check cross-chain deposit parameters and verify deposits made on branch chain are valid.\n     * @param _localPortAddress Address of local Port.\n     * @param _dParams Cross Chain swap parameters.\n     * @param _fromChain Chain ID of the chain where the deposit was made.\n     * @dev Local hToken must be recognized and address must match underlying if exists otherwise only local hToken is checked.\n     *\n     */\n    function checkParams(address _localPortAddress, DepositParams memory _dParams, uint24 _fromChain)\n        internal\n        view\n        returns (bool)\n    {\n        if (\n            (_dParams.amount < _dParams.deposit) //Deposit can't be greater than amount.\n                || (_dParams.amount > 0 && !IPort(_localPortAddress).isLocalToken(_dParams.hToken, _fromChain)) //Check local exists.\n                || (_dParams.deposit > 0 && !IPort(_localPortAddress).isUnderlyingToken(_dParams.token, _fromChain)) //Check underlying exists.\n        ) {\n            return false;\n        }\n        return true;\n    }\n}\n\n/// @title Library for Root Bridge Agent Deployment.\nlibrary DeployRootBridgeAgent {\n    function deploy(\n        WETH9 _wrappedNativeToken,\n        uint24 _localChainId,\n        address _daoAddress,\n        address _localAnyCallAddress,\n        address _localAnyCallExecutorAddress,\n        address _localPortAddress,\n        address _localRouterAddress\n    ) external returns (RootBridgeAgent) {\n        return new RootBridgeAgent(\n            _wrappedNativeToken,\n            _localChainId,\n            _daoAddress,\n            _localAnyCallAddress,\n            _localAnyCallExecutorAddress,\n            _localPortAddress,\n            _localRouterAddress\n        );\n    }\n}\n\n/// @title  Root Bridge Agent Contract\ncontract RootBridgeAgent is IRootBridgeAgent {\n    using SafeTransferLib for address;\n    using SafeCastLib for uint256;\n\n    /*///////////////////////////////////////////////////////////////\n                            ENCODING CONSTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// AnyExec Consts\n\n    uint8 internal constant PARAMS_START = 1;\n\n    uint8 internal constant PARAMS_START_SIGNED = 21;\n\n    uint8 internal constant PARAMS_ADDRESS_SIZE = 20;\n\n    uint8 internal constant PARAMS_GAS_IN = 32;\n\n    uint8 internal constant PARAMS_GAS_OUT = 16;\n\n    /// BridgeIn Consts\n\n    uint8 internal constant PARAMS_TKN_START = 5;\n\n    uint8 internal constant PARAMS_AMT_OFFSET = 64;\n\n    uint8 internal constant PARAMS_DEPOSIT_OFFSET = 96;\n\n    /*///////////////////////////////////////////////////////////////\n                        ROOT BRIDGE AGENT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Local Chain Id\n    uint24 public immutable localChainId;\n\n    /// @notice Local Wrapped Native Token\n    WETH9 public immutable wrappedNativeToken;\n\n    /// @notice Bridge Agent Factory Address.\n    address public immutable factoryAddress;\n\n    /// @notice Address of DAO.\n    address public immutable daoAddress;\n\n    /// @notice Local Core Root Router Address\n    address public immutable localRouterAddress;\n\n    /// @notice Address for Local Port Address where funds deposited from this chain are stored.\n    address public immutable localPortAddress;\n\n    /// @notice Local Anycall Address\n    address public immutable localAnyCallAddress;\n\n    /// @notice Local Anyexec Address\n    address public immutable localAnyCallExecutorAddress;\n\n    /// @notice Address of Root Bridge Agent Executor.\n    address public immutable bridgeAgentExecutorAddress;\n\n    /*///////////////////////////////////////////////////////////////\n                    BRANCH BRIDGE AGENTS STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Chain -> Branch Bridge Agent Address. For N chains, each Root Bridge Agent Address has M =< N Branch Bridge Agent Address.\n    mapping(uint256 => address) public getBranchBridgeAgent;\n\n    /// @notice If true, bridge agent manager has allowed for a new given branch bridge agent to be synced/added.\n    mapping(uint256 => bool) public isBranchBridgeAgentAllowed;\n\n    /*///////////////////////////////////////////////////////////////\n                        SETTLEMENTS STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Deposit nonce used for identifying transaction.\n    uint32 public settlementNonce;\n\n    /// @notice Mapping from Settlement nonce to Deposit Struct.\n    mapping(uint32 => Settlement) public getSettlement;\n\n    /*///////////////////////////////////////////////////////////////\n                            EXECUTOR STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice If true, bridge agent has already served a request with this nonce from  a given chain. Chain -> Nonce -> Bool\n    mapping(uint256 => mapping(uint32 => bool)) public executionHistory;\n\n    /*///////////////////////////////////////////////////////////////\n                        GAS MANAGEMENT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant MIN_FALLBACK_RESERVE = 155_000; // 100_000 for anycall + 55_000 for fallback\n    uint256 internal constant MIN_EXECUTION_OVERHEAD = 155_000; // 100_000 for anycall + 30_000 Pre 1st Gas Checkpoint Execution + 25_000 Post last Gas Checkpoint Execution\n\n    uint256 public initialGas;\n    UserFeeInfo public userFeeInfo;\n\n    /*///////////////////////////////////////////////////////////////\n                        DAO STATE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public accumulatedFees;\n\n    /**\n     * @notice Constructor for Bridge Agent.\n     *     @param _wrappedNativeToken Local Wrapped Native Token.\n     *     @param _daoAddress Address of DAO.\n     *     @param _localChainId Local Chain Id.\n     *     @param _localAnyCallAddress Local Anycall Address.\n     *     @param _localPortAddress Local Port Address.\n     *     @param _localRouterAddress Local Port Address.\n     */\n    constructor(\n        WETH9 _wrappedNativeToken,\n        uint24 _localChainId,\n        address _daoAddress,\n        address _localAnyCallAddress,\n        address _localAnyCallExecutorAddress,\n        address _localPortAddress,\n        address _localRouterAddress\n    ) {\n        require(address(_wrappedNativeToken) != address(0), \"Wrapped native token cannot be zero address\");\n        require(_daoAddress != address(0), \"DAO cannot be zero address\");\n        require(_localAnyCallAddress != address(0), \"Anycall Address cannot be zero address\");\n        require(_localAnyCallExecutorAddress != address(0), \"Anycall Executor Address cannot be zero address\");\n        require(_localPortAddress != address(0), \"Port Address cannot be zero address\");\n        require(_localRouterAddress != address(0), \"Router Address cannot be zero address\");\n\n        wrappedNativeToken = _wrappedNativeToken;\n        factoryAddress = msg.sender;\n        daoAddress = _daoAddress;\n        localChainId = _localChainId;\n        localAnyCallAddress = _localAnyCallAddress;\n        localPortAddress = _localPortAddress;\n        localRouterAddress = _localRouterAddress;\n        bridgeAgentExecutorAddress = DeployRootBridgeAgentExecutor.deploy(address(this));\n        localAnyCallExecutorAddress = _localAnyCallExecutorAddress;\n        settlementNonce = 1;\n        accumulatedFees = 1; //Avoid paying 20k gas in first `payExecutionGas` making MIN_EXECUTION_OVERHEAD constant.\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        VIEW EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootBridgeAgent\n    function getSettlementEntry(uint32 _settlementNonce) external view returns (Settlement memory) {\n        return getSettlement[_settlementNonce];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        USER EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootBridgeAgent\n    function retrySettlement(uint32 _settlementNonce, uint128 _remoteExecutionGas) external payable {\n        //Update User Gas available.\n        if (initialGas == 0) {\n            userFeeInfo.depositedGas = uint128(msg.value);\n            userFeeInfo.gasToBridgeOut = _remoteExecutionGas;\n        }\n        //Clear Settlement with updated gas.\n        _retrySettlement(_settlementNonce);\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function redeemSettlement(uint32 _depositNonce) external lock {\n        //Get deposit owner.\n        address depositOwner = getSettlement[_depositNonce].owner;\n\n        //Update Deposit\n        if (getSettlement[_depositNonce].status != SettlementStatus.Failed || depositOwner == address(0)) {\n            revert SettlementRedeemUnavailable();\n        } else if (\n            msg.sender != depositOwner && msg.sender != address(IPort(localPortAddress).getUserAccount(depositOwner))\n        ) {\n            revert NotSettlementOwner();\n        }\n        _redeemSettlement(_depositNonce);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    ROOT ROUTER EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootBridgeAgent\n    function callOut(address _recipient, bytes memory _data, uint24 _toChain) external payable lock requiresRouter {\n        //Encode Data for call.\n        bytes memory data =\n            abi.encodePacked(bytes1(0x00), _recipient, settlementNonce++, _data, _manageGasOut(_toChain));\n\n        //Perform Call to clear hToken balance on destination branch chain.\n        _performCall(data, _toChain);\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function callOutAndBridge(\n        address _owner,\n        address _recipient,\n        bytes memory _data,\n        address _globalAddress,\n        uint256 _amount,\n        uint256 _deposit,\n        uint24 _toChain\n    ) external payable lock requiresRouter {\n        //Get destination Local Address from Global Address.\n        address localAddress = IPort(localPortAddress).getLocalTokenFromGlobal(_globalAddress, _toChain);\n\n        //Get destination Underlying Address from Local Address.\n        address underlyingAddress = IPort(localPortAddress).getUnderlyingTokenFromLocal(localAddress, _toChain);\n\n        //Check if valid assets\n        if (localAddress == address(0) || (underlyingAddress == address(0) && _deposit > 0)) {\n            revert InvalidInputParams();\n        }\n\n        //Prepare data for call\n        bytes memory data = abi.encodePacked(\n            bytes1(0x01),\n            _recipient,\n            settlementNonce,\n            localAddress,\n            underlyingAddress,\n            _amount,\n            _deposit,\n            _data,\n            _manageGasOut(_toChain)\n        );\n\n        //Update State to reflect bridgeOut\n        _updateStateOnBridgeOut(\n            msg.sender, _globalAddress, localAddress, underlyingAddress, _amount, _deposit, _toChain\n        );\n\n        //Create Settlement\n        _createSettlement(_owner, _recipient, localAddress, underlyingAddress, _amount, _deposit, data, _toChain);\n\n        //Perform Call to clear hToken balance on destination branch chain and perform call.\n        _performCall(data, _toChain);\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function callOutAndBridgeMultiple(\n        address _owner,\n        address _recipient,\n        bytes memory _data,\n        address[] memory _globalAddresses,\n        uint256[] memory _amounts,\n        uint256[] memory _deposits,\n        uint24 _toChain\n    ) external payable lock requiresRouter {\n        address[] memory hTokens = new address[](_globalAddresses.length);\n        address[] memory tokens = new address[](_globalAddresses.length);\n        for (uint256 i = 0; i < _globalAddresses.length;) {\n            //Populate Addresses for Settlement\n            hTokens[i] = IPort(localPortAddress).getLocalTokenFromGlobal(_globalAddresses[i], _toChain);\n            tokens[i] = IPort(localPortAddress).getUnderlyingTokenFromLocal(hTokens[i], _toChain);\n\n            if (hTokens[i] == address(0) || (tokens[i] == address(0) && _deposits[i] > 0)) revert InvalidInputParams();\n\n            _updateStateOnBridgeOut(\n                msg.sender, _globalAddresses[i], hTokens[i], tokens[i], _amounts[i], _deposits[i], _toChain\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        //Prepare data for call with settlement of multiple assets\n        bytes memory data = abi.encodePacked(\n            bytes1(0x02),\n            _recipient,\n            uint8(hTokens.length),\n            settlementNonce,\n            hTokens,\n            tokens,\n            _amounts,\n            _deposits,\n            _data,\n            _manageGasOut(_toChain)\n        );\n\n        //Create Settlement Balance\n        _createMultipleSettlement(_owner, _recipient, hTokens, tokens, _amounts, _deposits, data, _toChain);\n\n        //Perform Call to destination Branch Chain.\n        _performCall(data, _toChain);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    TOKEN MANAGEMENT EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootBridgeAgent\n    function bridgeIn(address _recipient, DepositParams memory _dParams, uint24 _fromChain)\n        public\n        requiresAgentExecutor\n    {\n        //Check Deposit info from Cross Chain Parameters.\n        if (!CheckParamsLib.checkParams(localPortAddress, _dParams, _fromChain)) {\n            revert InvalidInputParams();\n        }\n\n        //Get global address\n        address globalAddress = IPort(localPortAddress).getGlobalTokenFromLocal(_dParams.hToken, _fromChain);\n\n        //Check if valid asset\n        if (globalAddress == address(0)) revert InvalidInputParams();\n\n        //Move hTokens from Branch to Root + Mint Sufficient hTokens to match new port deposit\n        IPort(localPortAddress).bridgeToRoot(_recipient, globalAddress, _dParams.amount, _dParams.deposit, _fromChain);\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function bridgeInMultiple(address _recipient, DepositMultipleParams memory _dParams, uint24 _fromChain)\n        external\n        requiresAgentExecutor\n    {\n        for (uint256 i = 0; i < _dParams.hTokens.length;) {\n            bridgeIn(\n                _recipient,\n                DepositParams({\n                    hToken: _dParams.hTokens[i],\n                    token: _dParams.tokens[i],\n                    amount: _dParams.amounts[i],\n                    deposit: _dParams.deposits[i],\n                    toChain: _dParams.toChain,\n                    depositNonce: 0\n                }),\n                _fromChain\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    TOKEN MANAGEMENT INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Updates the token balance state by moving assets from root omnichain environment to branch chain, when a user wants to bridge out tokens from the root bridge agent chain.\n     *     @param _sender address of the sender.\n     *     @param _globalAddress address of the global token.\n     *     @param _localAddress address of the local token.\n     *     @param _underlyingAddress address of the underlying token.\n     *     @param _amount amount of hTokens to be bridged out.\n     *     @param _deposit amount of underlying tokens to be bridged out.\n     *     @param _toChain chain to bridge to.\n     */\n    function _updateStateOnBridgeOut(\n        address _sender,\n        address _globalAddress,\n        address _localAddress,\n        address _underlyingAddress,\n        uint256 _amount,\n        uint256 _deposit,\n        uint24 _toChain\n    ) internal {\n        if (_amount - _deposit > 0) {\n            //Move output hTokens from Root to Branch\n            if (_localAddress == address(0)) revert UnrecognizedLocalAddress();\n            _globalAddress.safeTransferFrom(_sender, localPortAddress, _amount - _deposit);\n        }\n\n        if (_deposit > 0) {\n            //Verify there is enough balance to clear native tokens if needed\n            if (_underlyingAddress == address(0)) revert UnrecognizedUnderlyingAddress();\n            if (IERC20hTokenRoot(_globalAddress).getTokenBalance(_toChain) < _deposit) {\n                revert InsufficientBalanceForSettlement();\n            }\n            IPort(localPortAddress).burn(_sender, _globalAddress, _deposit, _toChain);\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                SETTLEMENT INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function to store a Settlement instance. Settlement should be reopened if fallback occurs.\n     *    @param _owner settlement owner address.\n     *    @param _recipient destination chain reciever address.\n     *    @param _hToken deposited global token address.\n     *    @param _token deposited global token address.\n     *    @param _amount amounts of total hTokens + Tokens output.\n     *    @param _deposit amount of underlying / native token to output.\n     *    @param _callData calldata to execute on destination Router.\n     *    @param _toChain Destination chain identificator.\n     *\n     */\n    function _createSettlement(\n        address _owner,\n        address _recipient,\n        address _hToken,\n        address _token,\n        uint256 _amount,\n        uint256 _deposit,\n        bytes memory _callData,\n        uint24 _toChain\n    ) internal {\n        //Cast to Dynamic\n        address[] memory hTokens = new address[](1);\n        hTokens[0] = _hToken;\n        address[] memory tokens = new address[](1);\n        tokens[0] = _token;\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = _amount;\n        uint256[] memory deposits = new uint256[](1);\n        deposits[0] = _deposit;\n\n        //Call createSettlement\n        _createMultipleSettlement(_owner, _recipient, hTokens, tokens, amounts, deposits, _callData, _toChain);\n    }\n\n    /**\n     * @notice Function to create a settlemment. Settlement should be reopened if fallback occurs.\n     *    @param _owner settlement owner address.\n     *    @param _recipient destination chain reciever address.\n     *    @param _hTokens deposited global token addresses.\n     *    @param _tokens deposited global token addresses.\n     *    @param _amounts amounts of total hTokens + Tokens output.\n     *    @param _deposits amount of underlying / native tokens to output.\n     *    @param _callData calldata to execute on destination Router.\n     *    @param _toChain Destination chain identificator.\n     *\n     *\n     */\n    function _createMultipleSettlement(\n        address _owner,\n        address _recipient,\n        address[] memory _hTokens,\n        address[] memory _tokens,\n        uint256[] memory _amounts,\n        uint256[] memory _deposits,\n        bytes memory _callData,\n        uint24 _toChain\n    ) internal {\n        // Update State\n        getSettlement[_getAndIncrementSettlementNonce()] = Settlement({\n            owner: _owner,\n            recipient: _recipient,\n            hTokens: _hTokens,\n            tokens: _tokens,\n            amounts: _amounts,\n            deposits: _deposits,\n            callData: _callData,\n            toChain: _toChain,\n            status: SettlementStatus.Success,\n            gasToBridgeOut: userFeeInfo.gasToBridgeOut\n        });\n    }\n\n    /**\n     * @notice Function to retry a user's Settlement balance with a new amount of gas to bridge out of Root Bridge Agent's Omnichain Environment.\n     *    @param _settlementNonce Identifier for token settlement.\n     *\n     */\n    function _retrySettlement(uint32 _settlementNonce) internal returns (bool) {\n        //Get Settlement\n        Settlement memory settlement = getSettlement[_settlementNonce];\n\n        //Check if Settlement hasn't been redeemed.\n        if (settlement.owner == address(0)) return false;\n\n        //abi encodePacked\n        bytes memory newGas = abi.encodePacked(_manageGasOut(settlement.toChain));\n\n        //overwrite last 16bytes of callData\n        for (uint256 i = 0; i < newGas.length;) {\n            settlement.callData[settlement.callData.length - 16 + i] = newGas[i];\n            unchecked {\n                ++i;\n            }\n        }\n\n        Settlement storage settlementReference = getSettlement[_settlementNonce];\n\n        //Update Gas To Bridge Out\n        settlementReference.gasToBridgeOut = userFeeInfo.gasToBridgeOut;\n\n        //Set Settlement Calldata to send to Branch Chain\n        settlementReference.callData = settlement.callData;\n\n        //Update Settlement Staus\n        settlementReference.status = SettlementStatus.Success;\n\n        //Retry call with additional gas\n        _performCall(settlement.callData, settlement.toChain);\n\n        //Retry Success\n        return true;\n    }\n\n    /**\n     * @notice Function to retry a user's Settlement balance.\n     *     @param _settlementNonce Identifier for token settlement.\n     *\n     */\n    function _redeemSettlement(uint32 _settlementNonce) internal {\n        // Get storage reference\n        Settlement storage settlement = getSettlement[_settlementNonce];\n\n        //Clear Global hTokens To Recipient on Root Chain cancelling Settlement to Branch\n        for (uint256 i = 0; i < settlement.hTokens.length;) {\n            //Check if asset\n            if (settlement.hTokens[i] != address(0)) {\n                //Move hTokens from Branch to Root + Mint Sufficient hTokens to match new port deposit\n                IPort(localPortAddress).bridgeToRoot(\n                    msg.sender,\n                    IPort(localPortAddress).getGlobalTokenFromLocal(settlement.hTokens[i], settlement.toChain),\n                    settlement.amounts[i],\n                    settlement.deposits[i],\n                    settlement.toChain\n                );\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Delete Settlement\n        delete getSettlement[_settlementNonce];\n    }\n\n    /**\n     * @notice Function to reopen a user's Settlement balance as pending and thus retryable by users. Called upon anyFallback of triggered by Branch Bridge Agent.\n     *     @param _settlementNonce Identifier for token settlement.\n     *\n     */\n    function _reopenSettlemment(uint32 _settlementNonce) internal {\n        //Update Deposit\n        getSettlement[_settlementNonce].status = SettlementStatus.Failed;\n    }\n\n    /**\n     * @notice Function that returns Deposit nonce and increments nonce counter.\n     *\n     */\n    function _getAndIncrementSettlementNonce() internal returns (uint32) {\n        return settlementNonce++;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    GAS SWAP INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint24 private constant GLOBAL_DIVISIONER = 1e6; // for basis point (0.0001%)\n\n    //Local mapping of valid gas pools\n    mapping(address => bool) private approvedGasPool;\n\n    /// @inheritdoc IRootBridgeAgent\n    function uniswapV3SwapCallback(int256 amount0, int256 amount1, bytes calldata _data) external {\n        if (!approvedGasPool[msg.sender]) revert CallerIsNotPool();\n        if (amount0 == 0 && amount1 == 0) revert AmountsAreZero();\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n\n        address(data.tokenIn).safeTransfer(msg.sender, uint256(amount0 > 0 ? amount0 : amount1));\n    }\n\n    /**\n     * @notice Swaps gas tokens from the given branch chain to the root chain\n     * @param _amount amount of gas token to swap\n     * @param _fromChain chain to swap from\n     */\n    function _gasSwapIn(uint256 _amount, uint24 _fromChain) internal returns (uint256) {\n        //Get fromChain's Gas Pool Info\n        (bool zeroForOneOnInflow, uint24 priceImpactPercentage, address gasTokenGlobalAddress, address poolAddress) =\n            IPort(localPortAddress).getGasPoolInfo(_fromChain);\n\n        //Check if valid addresses\n        if (gasTokenGlobalAddress == address(0) || poolAddress == address(0)) revert InvalidGasPool();\n\n        //Move Gas hTokens from Branch to Root / Mint Sufficient hTokens to match new port deposit\n        IPort(localPortAddress).bridgeToRoot(address(this), gasTokenGlobalAddress, _amount, _amount, _fromChain);\n\n        //Save Gas Pool for future use\n        if (!approvedGasPool[poolAddress]) approvedGasPool[poolAddress] = true;\n\n        //Get sqrtPriceX96\n        (uint160 sqrtPriceX96,,,,,,) = IUniswapV3Pool(poolAddress).slot0();\n\n        // Calculate Price limit depending on pre-set price impact\n        uint160 exactSqrtPriceImpact = (sqrtPriceX96 * (priceImpactPercentage / 2)) / GLOBAL_DIVISIONER;\n\n        //Get limit\n        uint160 sqrtPriceLimitX96 =\n            zeroForOneOnInflow ? sqrtPriceX96 - exactSqrtPriceImpact : sqrtPriceX96 + exactSqrtPriceImpact;\n\n        //Swap imbalanced token as long as we haven't used the entire amountSpecified and haven't reached the price limit\n        try IUniswapV3Pool(poolAddress).swap(\n            address(this),\n            zeroForOneOnInflow,\n            int256(_amount),\n            sqrtPriceLimitX96,\n            abi.encode(SwapCallbackData({tokenIn: gasTokenGlobalAddress}))\n        ) returns (int256 amount0, int256 amount1) {\n            return uint256(zeroForOneOnInflow ? amount1 : amount0);\n        } catch (bytes memory) {\n            _forceRevert();\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Swaps gas tokens from the given root chain to the branch chain\n     * @param _amount amount of gas token to swap\n     * @param _toChain chain to swap to\n     */\n    function _gasSwapOut(uint256 _amount, uint24 _toChain) internal returns (uint256, address) {\n        //Get fromChain's Gas Pool Info\n        (bool zeroForOneOnInflow, uint24 priceImpactPercentage, address gasTokenGlobalAddress, address poolAddress) =\n            IPort(localPortAddress).getGasPoolInfo(_toChain);\n\n        //Check if valid addresses\n        if (gasTokenGlobalAddress == address(0) || poolAddress == address(0)) revert InvalidGasPool();\n\n        //Save Gas Pool for future use\n        if (!approvedGasPool[poolAddress]) approvedGasPool[poolAddress] = true;\n\n        uint160 sqrtPriceLimitX96;\n        {\n            //Get sqrtPriceX96\n            (uint160 sqrtPriceX96,,,,,,) = IUniswapV3Pool(poolAddress).slot0();\n\n            // Calculate Price limit depending on pre-set price impact\n            uint160 exactSqrtPriceImpact = (sqrtPriceX96 * (priceImpactPercentage / 2)) / GLOBAL_DIVISIONER;\n\n            //Get limit\n            sqrtPriceLimitX96 =\n                zeroForOneOnInflow ? sqrtPriceX96 + exactSqrtPriceImpact : sqrtPriceX96 - exactSqrtPriceImpact;\n        }\n\n        //Swap imbalanced token as long as we haven't used the entire amountSpecified and haven't reached the price limit\n        (int256 amount0, int256 amount1) = IUniswapV3Pool(poolAddress).swap(\n            address(this),\n            !zeroForOneOnInflow,\n            int256(_amount),\n            sqrtPriceLimitX96,\n            abi.encode(SwapCallbackData({tokenIn: address(wrappedNativeToken)}))\n        );\n\n        return (uint256(!zeroForOneOnInflow ? amount1 : amount0), gasTokenGlobalAddress);\n    }\n\n    /**\n     * @notice Manages gas costs of bridging from Root to a given Branch.\n     * @param _toChain destination chain.\n     */\n    function _manageGasOut(uint24 _toChain) internal returns (uint128) {\n        uint256 amountOut;\n        address gasToken;\n        uint256 _initialGas = initialGas;\n\n        if (_toChain == localChainId) {\n            //Transfer gasToBridgeOut Local Branch Bridge Agent if remote initiated call.\n            if (_initialGas > 0) {\n                address(wrappedNativeToken).safeTransfer(getBranchBridgeAgent[localChainId], userFeeInfo.gasToBridgeOut);\n            }\n\n            return uint128(userFeeInfo.gasToBridgeOut);\n        }\n\n        if (_initialGas > 0) {\n            if (userFeeInfo.gasToBridgeOut <= MIN_FALLBACK_RESERVE * tx.gasprice) revert InsufficientGasForFees();\n            (amountOut, gasToken) = _gasSwapOut(userFeeInfo.gasToBridgeOut, _toChain);\n        } else {\n            if (msg.value <= MIN_FALLBACK_RESERVE * tx.gasprice) revert InsufficientGasForFees();\n            wrappedNativeToken.deposit{value: msg.value}();\n            (amountOut, gasToken) = _gasSwapOut(msg.value, _toChain);\n        }\n\n        IPort(localPortAddress).burn(address(this), gasToken, amountOut, _toChain);\n        return amountOut.toUint128();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    ANYCALL INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Internal function performs call to AnycallProxy Contract for cross-chain messaging.\n    function _performCall(bytes memory _calldata, uint256 _toChain) internal {\n        address callee = getBranchBridgeAgent[_toChain];\n\n        if (callee == address(0)) revert UnrecognizedBridgeAgent();\n\n        if (_toChain != localChainId) {\n            //Sends message to AnycallProxy\n            IAnycallProxy(localAnyCallAddress).anyCall(\n                callee, _calldata, _toChain, AnycallFlags.FLAG_ALLOW_FALLBACK_DST, \"\"\n            );\n        } else {\n            //Execute locally\n            IBranchBridgeAgent(callee).anyExecute(_calldata);\n        }\n    }\n\n    /**\n     * @notice Pays for the remote call execution gas. Demands that the user has enough gas to replenish gas for the anycall config contract or forces reversion.\n     * @param _depositedGas available user gas to pay for execution.\n     * @param _gasToBridgeOut amount of gas needed to bridge out.\n     * @param _initialGas initial gas used by the transaction.\n     * @param _fromChain chain remote action initiated from.\n     */\n    function _payExecutionGas(uint128 _depositedGas, uint128 _gasToBridgeOut, uint256 _initialGas, uint24 _fromChain)\n        internal\n    {\n        //reset initial remote execution gas and remote execution fee information\n        delete(initialGas);\n        delete(userFeeInfo);\n\n        if (_fromChain == localChainId) return;\n\n        //Get Available Gas\n        uint256 availableGas = _depositedGas - _gasToBridgeOut;\n\n        //Get Root Environment Execution Cost\n        uint256 minExecCost = tx.gasprice * (MIN_EXECUTION_OVERHEAD + _initialGas - gasleft());\n\n        //Check if sufficient balance\n        if (minExecCost > availableGas) {\n            _forceRevert();\n            return;\n        }\n\n        //Replenish Gas\n        _replenishGas(minExecCost);\n\n        //Account for excess gas\n        accumulatedFees += availableGas - minExecCost;\n    }\n\n    /**\n     * @notice Updates the user de"
    }
  ]
}