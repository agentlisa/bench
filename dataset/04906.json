{
  "Title": "[M-11] Proposers would choose to avoid higher tier by exploiting non-randomness of parameter used in getMinTier()",
  "Content": "\nThe issue exists for both `MainnetTierProvider.sol` and `TestnetTierProvider.sol`. For this report, we shall concentrate only on describing it via `MainnetTierProvider.sol`.\n\nThe proving tier is chosen by the [getMinTier()](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L66-L70) function which accepts a `_rand` param.\n\n```js\n  File: contracts/L1/tiers/MainnetTierProvider.sol\n\n  66:               function getMinTier(uint256 _rand) public pure override returns (uint16) {\n  67:                   // 0.1% require SGX + ZKVM; all others require SGX\n  68: @--->             if (_rand % 1000 == 0) return LibTiers.TIER_SGX_ZKVM;\n  69:                   else return LibTiers.TIER_SGX;\n  70:               }\n```\n\nIf `_rand % 1000 == 0`, a costlier tier `TIER_SGX_ZKVM` is used instead of the cheaper `TIER_SGX`. The `_rand` param is passed in the form of `meta_.difficulty` [which is calculated inside](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L199-L209) `proposeBlock()`:\n\n```js\n  File: contracts/L1/libs/LibProposing.sol\n\n  199:                  // Following the Merge, the L1 mixHash incorporates the\n  200:                  // prevrandao value from the beacon chain. Given the possibility\n  201:                  // of multiple Taiko blocks being proposed within a single\n  202:                  // Ethereum block, we choose to introduce a salt to this random\n  203:                  // number as the L2 mixHash.\n  204: @--->            meta_.difficulty = keccak256(abi.encodePacked(block.prevrandao, b.numBlocks, block.number));\n  205:          \n  206:                  // Use the difficulty as a random number\n  207:                  meta_.minTier = ITierProvider(_resolver.resolve(\"tier_provider\", false)).getMinTier(\n  208: @--->                uint256(meta_.difficulty)\n  209:                  );\n```\n\nAs can be seen, all the parameters used in L204 to calculate `meta_.difficulty` can be known in advance and hence a proposer can choose not to propose when `meta_.difficulty` modulus 1000 equals zero, because in such cases it will cost him more to afford the proof (sgx + zk proof in this case).\n\n### Impact\n\nSince the proposer will now wait for the next or any future block to call `proposeBlock()` instead of the current costlier one, **transactions will now take longer to finalilze**.\n\nIf `_rand` were truly random, it would have been an even playing field in all situations as the proposer wouldn't be able to pick & choose since he won't know in advance which tier he might get. We would then truly have:\n\n```js\n  67:                   // 0.1% require SGX + ZKVM; all others require SGX\n```\n\n### Recommended Mitigation Steps\n\nConsider using VRF like solutions to make `_rand` truly random.\n\n**[dantaik (Taiko) acknowledged and commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/172#issuecomment-2032346577):**\n > This is a very well known issue.\n> \n> Using VRF creates a third party dependency which may be a bigger risk for a Based rollup. We'll monitor how this plays out and mitigate the issue later.\n\n**[adaki2004 (Taiko) commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/172#issuecomment-2034096641):**\n > Eventually we will have only 1 (1 \"aggregated ZK multiproof\") proof tier, which will be the default/min too. (Maybe keeping guardian for a while to be as a failsafe, but that one also cannot be \"picked\" with thispseudoe random calculation).\n> Also Taiko foundation will run a proposer node, so in case noone is willing to propose to avoid fees, we will, regardless of cost - at least until we reach the 1 tier maturity.\n\n**[genesiscrew (Warden) commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/172#issuecomment-2048545898):**\n > Considering this report and the responses from the sponsors, I am unable to see how this would impact the function of the protocol in such a way that would deem it a medium risk. I personally think this is informational. The report states proving will take longer because it assumes all proposers will want to avoid paying fees because they can predict the block difficulty. I find that a bit of a stretch.\n\n**[adaki2004 (Taiko) commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/172#issuecomment-2049215839):**\n> Not the proving but the liveness (proposing) would take longer as provers would deny to grant signatures to prove blocks - which's evaluation i happening during `proposeBlock`. \n> \n> But at least +2 years post mainnet taiko foundation is commited to `proposeBlock` every X time intervals (even if not breaking even) to keep the liveness and get over this.\n> \n> And as stated, by the time hopefully this minTier() will vanish in that time - hopefully even in months after launch (not years) when ZK is cheap enough. So for now we would say it is a known issue, we are aware of.\n\n**[t0x1c (Warden) commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/172#issuecomment-2051225141):**\n > Thank you for the inputs. From what I see, this is being acknowledged by the sponsor as a valid issue which is known to the team.\n> Also important to note that it wasn't mentioned in the list of C4 \"known issues\" section on the audit page, so should qualify as a Medium. \n\n**[adaki2004 (Taiko) commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/172#issuecomment-2051231358):**\n> Can accept medium.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-03-taiko",
  "Code": [
    {
      "filename": "packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"../../common/EssentialContract.sol\";\nimport \"./ITierProvider.sol\";\n\n/// @title MainnetTierProvider\n/// @dev Labeled in AddressResolver as \"tier_provider\"\n/// @custom:security-contact security@taiko.xyz\ncontract MainnetTierProvider is EssentialContract, ITierProvider {\n    uint256[50] private __gap;\n\n    /// @notice Initializes the contract.\n    /// @param _owner The owner of this contract. msg.sender will be used if this value is zero.\n    function init(address _owner) external initializer {\n        __Essential_init(_owner);\n    }\n\n    /// @inheritdoc ITierProvider\n    function getTier(uint16 _tierId) public pure override returns (ITierProvider.Tier memory) {\n        if (_tierId == LibTiers.TIER_SGX) {\n            return ITierProvider.Tier({\n                verifierName: \"tier_sgx\",\n                validityBond: 250 ether, // TKO\n                contestBond: 500 ether, // TKO\n                cooldownWindow: 1440, //24 hours\n                provingWindow: 60, // 1 hours\n                maxBlocksToVerifyPerProof: 8\n            });\n        }\n\n        if (_tierId == LibTiers.TIER_SGX_ZKVM) {\n            return ITierProvider.Tier({\n                verifierName: \"tier_sgx_zkvm\",\n                validityBond: 500 ether, // TKO\n                contestBond: 1000 ether, // TKO\n                cooldownWindow: 1440, //24 hours\n                provingWindow: 240, // 4 hours\n                maxBlocksToVerifyPerProof: 4\n            });\n        }\n\n        if (_tierId == LibTiers.TIER_GUARDIAN) {\n            return ITierProvider.Tier({\n                verifierName: \"tier_guardian\",\n                validityBond: 0, // must be 0 for top tier\n                contestBond: 0, // must be 0 for top tier\n                cooldownWindow: 60, //1 hours\n                provingWindow: 2880, // 48 hours\n                maxBlocksToVerifyPerProof: 16\n            });\n        }\n\n        revert TIER_NOT_FOUND();\n    }\n\n    /// @inheritdoc ITierProvider\n    function getTierIds() public pure override returns (uint16[] memory tiers_) {\n        tiers_ = new uint16[](3);\n        tiers_[0] = LibTiers.TIER_SGX;\n        tiers_[1] = LibTiers.TIER_SGX_ZKVM;\n        tiers_[2] = LibTiers.TIER_GUARDIAN;\n    }\n\n    /// @inheritdoc ITierProvider\n    function getMinTier(uint256 _rand) public pure override returns (uint16) {\n        // 0.1% require SGX + ZKVM; all others require SGX\n        if (_rand % 1000 == 0) return LibTiers.TIER_SGX_ZKVM;\n        else return LibTiers.TIER_SGX;\n    }\n}"
    },
    {
      "filename": "packages/protocol/contracts/L1/libs/LibProposing.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../common/IAddressResolver.sol\";\nimport \"../../libs/LibAddress.sol\";\nimport \"../hooks/IHook.sol\";\nimport \"../tiers/ITierProvider.sol\";\nimport \"../TaikoData.sol\";\nimport \"./LibDepositing.sol\";\n\n/// @title LibProposing\n/// @notice A library for handling block proposals in the Taiko protocol.\n/// @custom:security-contact security@taiko.xyz\nlibrary LibProposing {\n    using LibAddress for address;\n\n    /// @notice The maximum number of bytes allowed per blob.\n    /// @dev According to EIP4844, each blob has up to 4096 field elements, and each\n    /// field element has 32 bytes.\n    uint256 public constant MAX_BYTES_PER_BLOB = 4096 * 32;\n\n    // Warning: Any events defined here must also be defined in TaikoEvents.sol.\n    /// @notice Emitted when a block is proposed.\n    /// @param blockId The ID of the proposed block.\n    /// @param assignedProver The address of the assigned prover.\n    /// @param livenessBond The liveness bond of the proposed block.\n    /// @param meta The metadata of the proposed block.\n    /// @param depositsProcessed The EthDeposit array about processed deposits in this proposed\n    /// block.\n    event BlockProposed(\n        uint256 indexed blockId,\n        address indexed assignedProver,\n        uint96 livenessBond,\n        TaikoData.BlockMetadata meta,\n        TaikoData.EthDeposit[] depositsProcessed\n    );\n\n    /// @notice Emitted when a blob is cached.\n    /// @param blobHash The hash of the cached blob.\n    event BlobCached(bytes32 blobHash);\n\n    // Warning: Any errors defined here must also be defined in TaikoErrors.sol.\n    error L1_BLOB_FOR_DA_DISABLED();\n    error L1_BLOB_NOT_FOUND();\n    error L1_BLOB_NOT_REUSABLE();\n    error L1_BLOB_REUSE_DISABLED();\n    error L1_INVALID_HOOK();\n    error L1_INVALID_PARAM();\n    error L1_INVALID_PROVER();\n    error L1_LIVENESS_BOND_NOT_RECEIVED();\n    error L1_PROPOSER_NOT_EOA();\n    error L1_TOO_MANY_BLOCKS();\n    error L1_TXLIST_OFFSET();\n    error L1_TXLIST_SIZE();\n    error L1_UNAUTHORIZED();\n    error L1_UNEXPECTED_PARENT();\n\n    /// @dev Proposes a Taiko L2 block.\n    /// @param _state Current TaikoData.State.\n    /// @param _config Actual TaikoData.Config.\n    /// @param _resolver Address resolver interface.\n    /// @param _data Encoded data bytes containing the block params.\n    /// @param _txList Transaction list bytes (if not blob).\n    /// @return meta_ The constructed block's metadata.\n    /// @return deposits_ The EthDeposit array about processed deposits in this proposed\n    /// block.\n    function proposeBlock(\n        TaikoData.State storage _state,\n        TaikoData.Config memory _config,\n        IAddressResolver _resolver,\n        bytes calldata _data,\n        bytes calldata _txList\n    )\n        internal\n        returns (TaikoData.BlockMetadata memory meta_, TaikoData.EthDeposit[] memory deposits_)\n    {\n        TaikoData.BlockParams memory params = abi.decode(_data, (TaikoData.BlockParams));\n\n        // We need a prover that will submit proofs after the block has been submitted\n        if (params.assignedProver == address(0)) {\n            revert L1_INVALID_PROVER();\n        }\n\n        if (params.coinbase == address(0)) {\n            params.coinbase = msg.sender;\n        }\n\n        // Taiko, as a Based Rollup, enables permissionless block proposals.\n        // However, if the \"proposer\" address is set to a non-zero value, we\n        // ensure that only that specific address has the authority to propose\n        // blocks.\n        TaikoData.SlotB memory b = _state.slotB;\n        if (!_isProposerPermitted(b, _resolver)) revert L1_UNAUTHORIZED();\n\n        // It's essential to ensure that the ring buffer for proposed blocks\n        // still has space for at least one more block.\n        if (b.numBlocks >= b.lastVerifiedBlockId + _config.blockMaxProposals + 1) {\n            revert L1_TOO_MANY_BLOCKS();\n        }\n\n        bytes32 parentMetaHash =\n            _state.blocks[(b.numBlocks - 1) % _config.blockRingBufferSize].metaHash;\n\n        // Check if parent block has the right meta hash\n        // This is to allow the proposer to make sure the block builds on the expected latest chain\n        // state\n        if (params.parentMetaHash != 0 && parentMetaHash != params.parentMetaHash) {\n            revert L1_UNEXPECTED_PARENT();\n        }\n\n        // Each transaction must handle a specific quantity of L1-to-L2\n        // Ether deposits.\n        deposits_ = LibDepositing.processDeposits(_state, _config, params.coinbase);\n\n        // Initialize metadata to compute a metaHash, which forms a part of\n        // the block data to be stored on-chain for future integrity checks.\n        // If we choose to persist all data fields in the metadata, it will\n        // require additional storage slots.\n        unchecked {\n            meta_ = TaikoData.BlockMetadata({\n                l1Hash: blockhash(block.number - 1),\n                difficulty: 0, // to be initialized below\n                blobHash: 0, // to be initialized below\n                extraData: params.extraData,\n                depositsHash: keccak256(abi.encode(deposits_)),\n                coinbase: params.coinbase,\n                id: b.numBlocks,\n                gasLimit: _config.blockMaxGasLimit,\n                timestamp: uint64(block.timestamp),\n                l1Height: uint64(block.number - 1),\n                txListByteOffset: 0, // to be initialized below\n                txListByteSize: 0, // to be initialized below\n                minTier: 0, // to be initialized below\n                blobUsed: _txList.length == 0,\n                parentMetaHash: parentMetaHash\n            });\n        }\n\n        // Update certain meta fields\n        if (meta_.blobUsed) {\n            if (!_config.blobAllowedForDA) revert L1_BLOB_FOR_DA_DISABLED();\n\n            if (params.blobHash != 0) {\n                if (!_config.blobReuseEnabled) revert L1_BLOB_REUSE_DISABLED();\n\n                // We try to reuse an old blob\n                if (!isBlobReusable(_state, _config, params.blobHash)) {\n                    revert L1_BLOB_NOT_REUSABLE();\n                }\n                meta_.blobHash = params.blobHash;\n            } else {\n                // Always use the first blob in this transaction. If the\n                // proposeBlock functions are called more than once in the same\n                // L1 transaction, these multiple L2 blocks will share the same\n                // blob.\n                meta_.blobHash = blobhash(0);\n\n                if (meta_.blobHash == 0) revert L1_BLOB_NOT_FOUND();\n\n                // Depends on the blob data price, it may not make sense to\n                // cache the blob which costs 20,000 (sstore) + 631 (event)\n                // extra gas.\n                if (_config.blobReuseEnabled && params.cacheBlobForReuse) {\n                    _state.reusableBlobs[meta_.blobHash] = block.timestamp;\n                    emit BlobCached(meta_.blobHash);\n                }\n            }\n\n            // Check that the txList data range is within the max size of a blob\n            if (uint256(params.txListByteOffset) + params.txListByteSize > MAX_BYTES_PER_BLOB) {\n                revert L1_TXLIST_OFFSET();\n            }\n\n            meta_.txListByteOffset = params.txListByteOffset;\n            meta_.txListByteSize = params.txListByteSize;\n        } else {\n            // The proposer must be an Externally Owned Account (EOA) for\n            // calldata usage. This ensures that the transaction is not an\n            // internal one, making calldata retrieval more straightforward for\n            // Taiko node software.\n            if (!LibAddress.isSenderEOA()) revert L1_PROPOSER_NOT_EOA();\n\n            // The txList is the full byte array without any offset\n            if (params.txListByteOffset != 0) {\n                revert L1_INVALID_PARAM();\n            }\n\n            meta_.blobHash = keccak256(_txList);\n            meta_.txListByteOffset = 0;\n            meta_.txListByteSize = uint24(_txList.length);\n        }\n\n        // Check that the tx length is non-zero and within the supported range\n        if (meta_.txListByteSize == 0 || meta_.txListByteSize > _config.blockMaxTxListBytes) {\n            revert L1_TXLIST_SIZE();\n        }\n\n        // Following the Merge, the L1 mixHash incorporates the\n        // prevrandao value from the beacon chain. Given the possibility\n        // of multiple Taiko blocks being proposed within a single\n        // Ethereum block, we choose to introduce a salt to this random\n        // number as the L2 mixHash.\n        meta_.difficulty = keccak256(abi.encodePacked(block.prevrandao, b.numBlocks, block.number));\n\n        // Use the difficulty as a random number\n        meta_.minTier = ITierProvider(_resolver.resolve(\"tier_provider\", false)).getMinTier(\n            uint256(meta_.difficulty)\n        );\n\n        // Create the block that will be stored onchain\n        TaikoData.Block memory blk = TaikoData.Block({\n            metaHash: keccak256(abi.encode(meta_)),\n            // Safeguard the liveness bond to ensure its preservation,\n            // particularly in scenarios where it might be altered after the\n            // block's proposal but before it has been proven or verified.\n            livenessBond: _config.livenessBond,\n            blockId: b.numBlocks,\n            proposedAt: meta_.timestamp,\n            proposedIn: uint64(block.number),\n            // For a new block, the next transition ID is always 1, not 0.\n            nextTransitionId: 1,\n            // For unverified block, its verifiedTransitionId is always 0.\n            verifiedTransitionId: 0,\n            assignedProver: params.assignedProver\n        });\n\n        // Store the block in the ring buffer\n        _state.blocks[b.numBlocks % _config.blockRingBufferSize] = blk;\n\n        // Increment the counter (cursor) by 1.\n        unchecked {\n            ++_state.slotB.numBlocks;\n        }\n\n        {\n            IERC20 tko = IERC20(_resolver.resolve(\"taiko_token\", false));\n            uint256 tkoBalance = tko.balanceOf(address(this));\n\n            // Run all hooks.\n            // Note that address(this).balance has been updated with msg.value,\n            // prior to any code in this function has been executed.\n            address prevHook;\n            for (uint256 i; i < params.hookCalls.length; ++i) {\n                if (uint160(prevHook) >= uint160(params.hookCalls[i].hook)) {\n                    revert L1_INVALID_HOOK();\n                }\n\n                // When a hook is called, all ether in this contract will be send to the hook.\n                // If the ether sent to the hook is not used entirely, the hook shall send the Ether\n                // back to this contract for the next hook to use.\n                // Proposers shall choose use extra hooks wisely.\n                IHook(params.hookCalls[i].hook).onBlockProposed{ value: address(this).balance }(\n                    blk, meta_, params.hookCalls[i].data\n                );\n\n                prevHook = params.hookCalls[i].hook;\n            }\n            // Refund Ether\n            if (address(this).balance != 0) {\n                msg.sender.sendEther(address(this).balance);\n            }\n\n            // Check that after hooks, the Taiko Token balance of this contract\n            // have increased by the same amount as _config.livenessBond (to prevent)\n            // multiple draining payments by a malicious proposer nesting the same\n            // hook.\n            if (tko.balanceOf(address(this)) != tkoBalance + _config.livenessBond) {\n                revert L1_LIVENESS_BOND_NOT_RECEIVED();\n            }\n        }\n\n        emit BlockProposed({\n            blockId: blk.blockId,\n            assignedProver: blk.assignedProver,\n            livenessBond: _config.livenessBond,\n            meta: meta_,\n            depositsProcessed: deposits_\n        });\n    }\n\n    /// @notice Checks if a blob is reusable.\n    /// @param _state Current TaikoData.State.\n    /// @param _config The TaikoData.Config.\n    /// @param _blobHash The blob hash\n    /// @return true if the blob is reusable, false otherwise.\n    function isBlobReusable(\n        TaikoData.State storage _state,\n        TaikoData.Config memory _config,\n        bytes32 _blobHash\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return _state.reusableBlobs[_blobHash] + _config.blobExpiry > block.timestamp;\n    }\n\n    function _isProposerPermitted(\n        TaikoData.SlotB memory _slotB,\n        IAddressResolver _resolver\n    )\n        private\n        view\n        returns (bool)\n    {\n        if (_slotB.numBlocks == 1) {\n            // Only proposer_one can propose the first block after genesis\n            address proposerOne = _resolver.resolve(\"proposer_one\", true);\n            if (proposerOne != address(0) && msg.sender != proposerOne) {\n                return false;\n            }\n        }\n\n        address proposer = _resolver.resolve(\"proposer\", true);\n        return proposer == address(0) || msg.sender == proposer;\n    }\n}"
    }
  ]
}