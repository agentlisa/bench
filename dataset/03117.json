{
  "Title": "Staked funds might get soft-stuck",
  "Content": "The [`FortaStaking` contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L45) implements the functionality to allow holders to stake their funds (vested or not) into a subject and collect rewards by doing so. The contract uses 2 different accounting systems to handle the assets: a [`Distribution` type based for the asset in stake units](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L53-L56) and the inner [ERC1155 accounting system](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L45) for the associated shares. When a user [stakes](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L201), the contract [mints new active shares](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L213). When a user [wants to withdraw](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L224), the contract [burns those active shares](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L241) and [mints inactive ones](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L242).\n\n\nWhen minting these ERC1155, the [`_doSafeTransferAcceptanceCheck` hook](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.4.2/contracts/token/ERC1155/ERC1155Upgradeable.sol#L421) will get triggered and it would check if the destinatary is a `ERC1155Receiver` implementer or not when it detects that the address has code in it.\n\n\nHowever, if the minting process happens during the constructor of a non-fully compatible ERC1155 wallet, the `FortaStaking` contract would treat the destinatary as a regular EOA during the minting process. Then, once it is deployed, the wallet will not be able to mint new shares due to the same `_doSafeTransferAcceptanceCheck` hook as it will get triggered, failing at the same validation that was skipped on the first deposit.\n\n\nThis means that when the wallet [starts the process to withdraw the assets](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L224), the transaction will fail during the [minting of inactive shares](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L242). Nevertheless, the user may transfer those active shares to a fully compatible wallet to then initiate the withdrawal process once again.\n\n\nIn favor of improving the usability of the protocol, consider documenting the requirements that 3rd party wallets would need to be able to fully interact with it either during the deployment stage or once it has been deployed.\n\n\n***Update:** Fixed on [commit `d13be24e8b84ffc59eb04ded2d03841a69996434` in pull request 54](https://github.com/forta-protocol/forta-token/pull/54/commits/d13be24e8b84ffc59eb04ded2d03841a69996434).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/components/staking/FortaStaking.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/interfaces/draft-IERC2612.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/utils/Timers.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155SupplyUpgradeable.sol\";\n\nimport \"./FortaStakingUtils.sol\";\nimport \"./FortaStakingSubjectTypes.sol\";\nimport \"./IStakeController.sol\";\nimport \"../BaseComponentUpgradeable.sol\";\nimport \"../../tools/Distributions.sol\";\nimport \"../../tools/FullMath.sol\";\n\ninterface IRewardReceiver {\n    function onRewardReceived(uint8 subjectType, uint256 subject, uint256 amount) external;\n}\n\n/**\n * @dev This is a generic staking contract for the Forta platform. It allows any account to deposit ERC20 tokens to\n * delegate their \"power\" by staking on behalf of a particular subject. The subject can be scanner, or any other actor\n * in the Forta ecosystem, who need to lock assets in order to contribute to the system.\n *\n * Stakers take risks with their funds, as bad action from a subject can lead to slashing of the funds. In the\n * meantime, stakers are elligible for rewards. Rewards distributed to a particular subject's stakers are distributed\n * following to each staker's share in the subject.\n *\n * Stakers can withdraw their funds, following a withdrawal delay. During the withdrawal delay, funds are no longer\n * counting toward the active stake of a subject, but are still slashable.\n *\n * The SLASHER_ROLE should be given to a future smart contract that will be in charge of resolving disputes.\n *\n * Stakers receive ERC1155 shares in exchange for their stake, making the active stake transferable. When a withdrawal\n * is initiated, similarly the ERC1155 tokens representing the (transferable) active shares are burned in exchange for\n * non-transferable ERC1155 tokens representing the inactive shares.\n *\n * ERC1155 shares representing active stake are transferable, and can be used in an AMM. Their value is however subject\n * to quick devaluation in case of slashing event for the corresponding subject. Thus, trading of such shares should be\n * be done very carefully.\n */\ncontract FortaStaking is BaseComponentUpgradeable, ERC1155SupplyUpgradeable, IStakeController {\n    using Distributions for Distributions.Balances;\n    using Distributions for Distributions.SignedBalances;\n    using Timers        for Timers.Timestamp;\n    using ERC165Checker for address;\n\n    IERC20 public stakedToken;\n\n    // subject => active stake\n    Distributions.Balances private _activeStake;\n    // subject => inactive stake\n    Distributions.Balances private _inactiveStake;\n    \n\n    // subject => staker => inactive stake timer\n    mapping(uint256 => mapping(address => Timers.Timestamp)) private _lockingDelay;\n\n    // subject => reward\n    Distributions.Balances private _rewards;\n    // subject => staker => released reward\n    mapping(uint256 => Distributions.SignedBalances) private _released;\n\n    // frozen tokens\n    mapping(uint256 => bool) private _frozen;\n\n    // withdrawal delay\n    uint64 private _withdrawalDelay;\n\n    // treasury for slashing\n    address private _treasury;\n\n    // minimum stake per subject type\n    mapping(uint8 => uint256) private _minStakes;\n\n    event StakeDeposited(uint8 indexed subjectType, uint256 indexed subject, address indexed account, uint256 amount);\n    event WithdrawalInitiated(uint8 indexed subjectType, uint256 indexed subject, address indexed account, uint64 deadline);\n    event WithdrawalExecuted(uint8 indexed subjectType, uint256 indexed subject, address indexed account);\n    event Froze(uint8 indexed subjectType, uint256 indexed subject, address indexed by, bool isFrozen);\n    event Slashed(uint8 indexed subjectType, uint256 indexed subject, address indexed by, uint256 value);\n    event Rewarded(uint8 indexed subjectType, uint256 indexed subject, address indexed from, uint256 value);\n    event Released(uint8 indexed subjectType, uint256 indexed subject, address indexed to, uint256 value);\n    event DelaySet(uint256 newWithdrawalDelay);\n    event TreasurySet(address newTreasury);\n\n    modifier onlyValidSubjectType(uint8 subjectType) {\n        require(\n            subjectType == SCANNER_SUBJECT ||\n            subjectType == AGENT_SUBJECT,\n            \"FortaStaking: invalid subjectType\"\n        );\n        _;\n    }\n\n    string public constant version = \"0.1.0\";\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address forwarder) initializer ForwardedContext(forwarder) {}\n\n    function initialize(\n        address __manager,\n        address __router,\n        IERC20 __stakedToken,\n        uint64 __withdrawalDelay,\n        address __treasury\n    ) public initializer {\n        __AccessManaged_init(__manager);\n        __Routed_init(__router);\n        __UUPSUpgradeable_init();\n        __ERC1155_init(\"\");\n\n        stakedToken = __stakedToken;\n        _withdrawalDelay = __withdrawalDelay;\n        _treasury = __treasury;\n        emit DelaySet(__withdrawalDelay);\n        emit TreasurySet(__treasury);\n    }\n\n    /**\n     * @dev Get stake of a subject\n     */\n    function activeStakeFor(uint8 subjectType, uint256 subject) public view returns (uint256) {\n        return _activeStake.balanceOf(FortaStakingUtils.subjectToActive(subjectType, subject));\n    }\n\n    /**\n     * @dev Get total stake of all subjects\n     */\n    function totalActiveStake() public view returns (uint256) {\n        return _activeStake.totalSupply();\n    }\n\n    /**\n     * @dev Get stake inactive for withdrawal of a subject\n     */\n    function inactiveStakeFor(uint8 subjectType, uint256 subject) external view returns (uint256) {\n        return _inactiveStake.balanceOf(FortaStakingUtils.subjectToInactive(subjectType, subject));\n    }\n\n    /**\n     * @dev Get total stake inactive for withdrawal of all subjects\n     */\n    function totalInactiveStake() public view returns (uint256) {\n        return _inactiveStake.totalSupply();\n    }\n\n    /**\n     * @dev Get (active) shares of an account on a subject, corresponding to a fraction of the subject stake.\n     * NOTE: This is equivalent to getting the ERC1155 balanceOf for keccak256(abi.encodePacked(subjectType, subject)),\n     * shifted 9 bits, with the 9th bit set and uint8(subjectType) masked in\n     */\n    function sharesOf(uint8 subjectType, uint256 subject, address account) public view returns (uint256) {\n        return balanceOf(account, FortaStakingUtils.subjectToActive(subjectType, subject));\n    }\n\n    /**\n     * @dev Get the total (active) shares on a subject.\n     *\n     * NOTE: This is equivalent to getting the ERC1155 totalSupply for keccak256(abi.encodePacked(subjectType, subject)),\n     * shifted 9 bits, with the 9th bit set and uint8(subjectType) masked in\n     */\n    function totalShares(uint8 subjectType, uint256 subject) external view returns (uint256) {\n        return totalSupply(FortaStakingUtils.subjectToActive(subjectType, subject));\n    }\n\n    /**\n     * @dev Get inactive shares of an account on a subject, corresponding to a fraction of the subject inactive stake.\n     *\n     * NOTE: This is equivalent to getting the ERC1155 balanceOf for keccak256(abi.encodePacked(subjectType, subject)),\n     * shifted 9 bits, with the 9th bit unset and uint8(subjectType) masked in\n     */\n    function inactiveSharesOf(uint8 subjectType, uint256 subject, address account) external view returns (uint256) {\n        return balanceOf(account, FortaStakingUtils.subjectToInactive(subjectType, subject));\n    }\n\n    /**\n     * @dev Get the total inactive shares on a subject.\n     *\n     * NOTE: This is equivalent to getting the ERC1155 totalSupply for keccak256(abi.encodePacked(subjectType, subject)),\n     * shifted 9 bits, with the 9th bit unset and uint8(subjectType) masked in\n     */\n    function totalInactiveShares(uint8 subjectType, uint256 subject) external view returns (uint256) {\n        return totalSupply(FortaStakingUtils.subjectToInactive(subjectType, subject));\n    }\n\n    /**\n     * @dev Is a subject frozen (stake of frozen subject cannot be withdrawn).\n     */\n    function isFrozen(uint8 subjectType, uint256 subject) public view returns (bool) {\n        return _frozen[FortaStakingUtils.subjectToActive(subjectType, subject)];\n    }\n\n    /**\n     * @dev Deposit `stakeValue` tokens for a given `subject`, and mint the corresponding shares.\n     * NOTE: Subject type is necessary because we can't infer subject ID uniqueness between scanners, agents, etc\n     * Emits a ERC1155.TransferSingle event and StakeDeposited (to allow accounting per subject type)\n     */\n    function deposit(uint8 subjectType, uint256 subject, uint256 stakeValue)\n        public\n        onlyValidSubjectType(subjectType)\n        returns (uint256)\n    {\n        address staker = _msgSender();\n        uint256 activeSharesId = FortaStakingUtils.subjectToActive(subjectType, subject);\n\n        uint256 sharesValue = _stakeToActiveShares(activeSharesId, stakeValue);\n        SafeERC20.safeTransferFrom(stakedToken, staker, address(this), stakeValue);\n\n        _activeStake.mint(activeSharesId, stakeValue);\n        _mint(staker, activeSharesId, sharesValue, new bytes(0));\n        emit StakeDeposited(subjectType, subject, staker, stakeValue);\n        _emitHook(abi.encodeWithSignature(\"hook_afterStakeChanged(uint8, uint256)\", subjectType, subject));\n        return sharesValue;\n    }\n\n    /**\n     * @dev Schedule the withdrawal of shares.\n     *\n     * Emits a WithdrawalInitiated event.\n     */\n    function initiateWithdrawal(uint8 subjectType, uint256 subject, uint256 sharesValue)\n        public\n        onlyValidSubjectType(subjectType)\n        returns (uint64)\n    {\n        address staker = _msgSender();\n        uint256 activeSharesId = FortaStakingUtils.subjectToActive(subjectType, subject);\n        uint64 deadline = SafeCast.toUint64(block.timestamp) + _withdrawalDelay;\n\n        _lockingDelay[activeSharesId][staker].setDeadline(deadline);\n\n        uint256 activeShares   = Math.min(sharesValue, balanceOf(staker, activeSharesId));\n        uint256 stakeValue     = _activeSharesToStake(activeSharesId, activeShares);\n        uint256 inactiveShares = _stakeToInactiveShares(FortaStakingUtils.activeToInactive(activeSharesId), stakeValue);\n\n        _activeStake.burn(activeSharesId, stakeValue);\n        _inactiveStake.mint(FortaStakingUtils.activeToInactive(activeSharesId), stakeValue);\n        _burn(staker, activeSharesId, activeShares);\n        _mint(staker, FortaStakingUtils.activeToInactive(activeSharesId), inactiveShares, new bytes(0));\n\n        emit WithdrawalInitiated(subjectType, subject, staker, deadline);\n\n        _emitHook(abi.encodeWithSignature(\"hook_afterStakeChanged(uint8, uint256)\", subjectType, subject));\n        return deadline;\n    }\n\n    /**\n     * @dev Burn `sharesValue` shares for a given `subject`, and withdraw the corresponding tokens.\n     *\n     * Emits events WithdrawalExecuted and ERC1155.TransferSingle.\n     */\n    function withdraw(uint8 subjectType, uint256 subject)\n        public\n        onlyValidSubjectType(subjectType)\n        returns (uint256)\n    {\n        address staker = _msgSender();\n        uint256 inactiveSharesId = FortaStakingUtils.subjectToInactive(subjectType, subject);\n        require(!_frozen[FortaStakingUtils.inactiveToActive(inactiveSharesId)], \"Subject unstaking is currently frozen\");\n\n        Timers.Timestamp storage timer = _lockingDelay[FortaStakingUtils.inactiveToActive(inactiveSharesId)][staker];\n        require(timer.isExpired(), 'Withdrawal is not ready');\n        timer.reset();\n        emit WithdrawalExecuted(subjectType, subject, staker);\n\n        uint256 inactiveShares = balanceOf(staker, inactiveSharesId);\n        uint256 stakeValue     = _inactiveSharesToStake(inactiveSharesId, inactiveShares);\n\n        _inactiveStake.burn(inactiveSharesId, stakeValue);\n        _burn(staker, inactiveSharesId, inactiveShares);\n        SafeERC20.safeTransfer(stakedToken, staker, stakeValue);\n\n        _emitHook(abi.encodeWithSignature(\"hook_afterStakeChanged(uint8, uint256)\", subjectType, subject));\n\n        return stakeValue;\n    }\n\n    /**\n     * @dev Slash a fraction of a subject stake, and transfer it to the treasury. Restricted to the `SLASHER_ROLE`.\n     *\n     * Emits a Slashed event.\n     */\n    function slash(uint8 subjectType, uint256 subject, uint256 stakeValue)\n        public\n        onlyRole(SLASHER_ROLE)\n        onlyValidSubjectType(subjectType)\n        returns (uint256)\n    {\n        uint256 activeSharesId = FortaStakingUtils.subjectToActive(subjectType, subject);\n        uint256 activeStake       = _activeStake.balanceOf(activeSharesId);\n        uint256 inactiveStake     = _inactiveStake.balanceOf(FortaStakingUtils.activeToInactive(activeSharesId));\n\n        uint256 maxSlashableStake = FullMath.mulDiv(9, 10, activeStake + inactiveStake);\n        require(stakeValue <= maxSlashableStake, \"Stake to be slashed is over 90%\");\n\n        uint256 slashFromActive   = FullMath.mulDiv(activeStake, activeStake + inactiveStake, stakeValue);\n        uint256 slashFromInactive = stakeValue - slashFromActive;\n        stakeValue                = slashFromActive + slashFromInactive;\n\n        _activeStake.burn(activeSharesId, slashFromActive);\n        _inactiveStake.burn(FortaStakingUtils.activeToInactive(activeSharesId), slashFromInactive);\n        SafeERC20.safeTransfer(stakedToken, _treasury, stakeValue);\n\n        emit Slashed(subjectType, subject, _msgSender(), stakeValue);\n\n        _emitHook(abi.encodeWithSignature(\"hook_afterStakeChanged(uint8, uint256)\", subjectType, subject));\n\n        return stakeValue;\n    }\n\n    /**\n     * @dev Freeze/unfreeze a subject stake. Restricted to the `SLASHER_ROLE`.\n     *\n     * Emits a Freeze event.\n     */\n    function freeze(uint8 subjectType, uint256 subject, bool frozen)\n        public\n        onlyRole(SLASHER_ROLE)\n        onlyValidSubjectType(subjectType)\n    {\n        _frozen[FortaStakingUtils.subjectToActive(subjectType, subject)] = frozen;\n        emit Froze(subjectType, subject, _msgSender(), frozen);\n    }\n\n    /**\n    * @dev Deposit reward value for a given `subject`. The corresponding tokens will be shared amongst the shareholders\n    * of this subject.\n    *\n    * Emits a Reward event.\n    */\n    function reward(uint8 subjectType, uint256 subject, uint256 value)\n        public\n        onlyValidSubjectType(subjectType)\n    {\n        SafeERC20.safeTransferFrom(stakedToken, _msgSender(), address(this), value);\n        _rewards.mint(FortaStakingUtils.subjectToActive(subjectType, subject), value);\n\n        emit Rewarded(subjectType, subject, _msgSender(), value);\n    }\n\n    /**\n     * @dev Sweep all token that might be mistakenly sent to the contract. This covers both unrelated tokens and staked\n     * tokens that would be sent through a direct transfer.\n     */\n    function sweep(IERC20 token, address recipient) public onlyRole(SWEEPER_ROLE) returns (uint256) {\n        uint256 amount = token.balanceOf(address(this));\n\n        if (token == stakedToken) {\n            amount -= totalActiveStake();\n            amount -= totalInactiveStake();\n            amount -= _rewards.totalSupply();\n        }\n\n        SafeERC20.safeTransfer(token, recipient, amount);\n\n        return amount;\n    }\n\n    /**\n     * @dev Release reward owed by given `account` for its current or past share for a given `subject`.\n     * If staking from a contract, said contract may optionally implement ERC165 for IRewardReceiver\n     * Emits a Release event.\n     */\n    function releaseReward(uint8 subjectType, uint256 subject, address account)\n        public\n        onlyValidSubjectType(subjectType)\n        returns (uint256)\n    {\n        uint256 value = availableReward(subjectType, subject, account);\n        uint256 activeSharesId = FortaStakingUtils.subjectToActive(subjectType, subject);\n        _rewards.burn(activeSharesId, value);\n        _released[activeSharesId].mint(account, SafeCast.toInt256(value));\n\n        SafeERC20.safeTransfer(stakedToken, account, value);\n\n        emit Released(subjectType, subject, account, value);\n\n        if (Address.isContract(account) && account.supportsInterface(type(IRewardReceiver).interfaceId)) {\n            IRewardReceiver(account).onRewardReceived(subjectType, subject, value);\n        }\n\n        return value;\n    }\n\n    /**\n     * @dev Amount of reward tokens owed by given `account` for its current or past share for a given `subject`.\n     */\n    function availableReward(uint8 subjectType, uint256 subject, address account) public view returns (uint256) {\n        uint256 activeSharesId = FortaStakingUtils.subjectToActive(subjectType, subject);\n        return SafeCast.toUint256(\n            SafeCast.toInt256(_historicalRewardFraction(activeSharesId, balanceOf(account, activeSharesId)))\n            -\n            _released[activeSharesId].balanceOf(account)\n        );\n    }\n\n    /**\n     * @dev Relay a ERC2612 permit signature to the staked token. This cal be bundled with a {deposit} or a {reward}\n     * operation using Multicall.\n     */\n    function relayPermit(\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        IERC2612(address(stakedToken)).permit(_msgSender(), address(this), value, deadline, v, r, s);\n    }\n\n    // Internal helpers\n    function _totalHistoricalReward(uint256 activeSharesId) internal view returns (uint256) {\n        return SafeCast.toUint256(\n            SafeCast.toInt256(_rewards.balanceOf(activeSharesId))\n            +\n            _released[activeSharesId].totalSupply()\n        );\n    }\n\n    function _historicalRewardFraction(uint256 activeSharesId, uint256 amount) internal view returns (uint256) {\n        uint256 supply = totalSupply(activeSharesId);\n        return amount > 0 && supply > 0 ? FullMath.mulDiv(amount, supply, _totalHistoricalReward(activeSharesId)) : 0;\n    }\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n\n        // Order is important here, we must do the virtual release, which uses totalSupply(activeSharesId) in\n        // _historicalRewardFraction, BEFORE the super call updates the totalSupply()\n        for (uint256 i = 0; i < ids.length; ++i) {\n            if (FortaStakingUtils.isActive(ids[i])) {\n                // Mint, burn, or transfer of subject shares would by default affect the distribution of the\n                // currently available reward for the subject. We create a \"virtual release\" that should preserve\n                // reward distribution as it was prior to the transfer.\n                int256 virtualRelease = SafeCast.toInt256(\n                    _historicalRewardFraction(\n                        ids[i],\n                        amounts[i]\n                    )\n                );\n                if (from == address(0)) {\n                    _released[ids[i]].mint(to, virtualRelease);\n                } else if (to == address(0)) {\n                    _released[ids[i]].burn(from, virtualRelease);\n                } else {\n                    _released[ids[i]].transfer(from, to, virtualRelease);\n                }\n            } else {\n                require(from == address(0) || to == address(0), \"Withdrawal shares are not transferable\");\n            }\n        }\n\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n    }\n\n    // Conversions\n    function _stakeToActiveShares(uint256 activeSharesId, uint256 amount) internal view returns (uint256) {\n        uint256 activeStake = _activeStake.balanceOf(activeSharesId);\n        return activeStake == 0 ? amount : FullMath.mulDiv(amount, activeStake, totalSupply(activeSharesId));\n    }\n\n    function _stakeToInactiveShares(uint256 inactiveSharesId, uint256 amount) internal view returns (uint256) {\n        uint256 inactiveStake = _inactiveStake.balanceOf(inactiveSharesId);\n        return inactiveStake == 0 ? amount : FullMath.mulDiv(amount, inactiveStake, totalSupply(inactiveSharesId));\n    }\n\n    function _activeSharesToStake(uint256 activeSharesId, uint256 amount) internal view returns (uint256) {\n        uint256 activeSupply = totalSupply(activeSharesId);\n        return activeSupply == 0 ? 0 : FullMath.mulDiv(amount, activeSupply, _activeStake.balanceOf(activeSharesId));\n    }\n    function _inactiveSharesToStake(uint256 inactiveSharesId, uint256 amount) internal view returns (uint256) {\n        uint256 inactiveSupply = totalSupply(inactiveSharesId);\n        return inactiveSupply == 0 ? 0 : FullMath.mulDiv(amount, inactiveSupply, _inactiveStake.balanceOf(inactiveSharesId));\n    }\n\n    // Admin: change withdrawal delay\n    function setDelay(uint64 newDelay) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _withdrawalDelay = newDelay;\n        emit DelaySet(newDelay);\n    }\n\n    // Admin: change recipient of slashed funds\n    function setTreasury(address newTreasury) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _treasury = newTreasury;\n        emit TreasurySet(newTreasury);\n    }\n\n    // Mininimum Stake\n\n    /**\n    * Sets minimum stake for subject type. To be controlled by governance\n    */\n    function setMinStake(uint8 subjectType, uint256 amount) external onlyRole(DEFAULT_ADMIN_ROLE) onlyValidSubjectType(subjectType) {\n        emit MinStakeChanged(amount, _minStakes[subjectType]);\n        _minStakes[subjectType] = amount;\n    }\n\n    function getMinStake(uint8 subjectType) external view returns (uint256) {\n        return _minStakes[subjectType];\n    }\n    function isStakedOverMin(uint8 subjectType, uint256 subject) external view returns (bool) {\n        return activeStakeFor(subjectType, subject) >= _minStakes[subjectType];\n    }\n\n    function setURI(string memory newUri) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setURI(newUri);\n    }\n\n    function _msgSender() internal view virtual override(ContextUpgradeable, BaseComponentUpgradeable) returns (address sender) {\n        return super._msgSender();\n    }\n\n    function _msgData() internal view virtual override(ContextUpgradeable, BaseComponentUpgradeable) returns (bytes calldata) {\n        return super._msgData();\n    }\n\n    uint256[40] private __gap;\n}"
    },
    {
      "filename": "contracts/token/ERC1155/ERC1155Upgradeable.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155Upgradeable.sol\";\nimport \"./IERC1155ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC1155MetadataURIUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC1155Upgradeable, IERC1155MetadataURIUpgradeable {\n    using AddressUpgradeable for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    function __ERC1155_init(string memory uri_) internal onlyInitializing {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __ERC1155_init_unchained(uri_);\n    }\n\n    function __ERC1155_init_unchained(string memory uri_) internal onlyInitializing {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC1155Upgradeable).interfaceId ||\n            interfaceId == type(IERC1155MetadataURIUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operat"
    }
  ]
}