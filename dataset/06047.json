{
  "Title": "[L-05] Wrong comment",
  "Content": "- https://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/Asset.sol#L146\n\n```solidity\n// oracleTimeout <= delta <= oracleTimeout + priceTimeout ==========> oracleTimeout < delta < oracleTimeout + priceTimeout\n```\n\n- https://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/compoundv3/WrappedERC20.sol#L298\n\n```solidity\n     * - when `from` is zero, `amount` tokens will be minted for `to`. //@audit should remove, no hook if `from` or `to` is zero\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-07-reserve",
  "Code": [
    {
      "filename": "contracts/plugins/assets/Asset.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.19;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../../interfaces/IAsset.sol\";\nimport \"./OracleLib.sol\";\nimport \"./VersionedAsset.sol\";\n\ncontract Asset is IAsset, VersionedAsset {\n    using FixLib for uint192;\n    using OracleLib for AggregatorV3Interface;\n\n    AggregatorV3Interface public immutable chainlinkFeed; // {UoA/tok}\n\n    IERC20Metadata public immutable erc20;\n\n    uint8 public immutable erc20Decimals;\n\n    uint192 public immutable override maxTradeVolume; // {UoA}\n\n    uint48 public immutable oracleTimeout; // {s}\n\n    uint192 public immutable oracleError; // {1}\n\n    // === Lot price ===\n\n    uint48 public immutable priceTimeout; // {s} The period over which `savedHighPrice` decays to 0\n\n    uint192 public savedLowPrice; // {UoA/tok} The low price of the token during the last update\n\n    uint192 public savedHighPrice; // {UoA/tok} The high price of the token during the last update\n\n    uint48 public lastSave; // {s} The timestamp when prices were last saved\n\n    /// @param priceTimeout_ {s} The number of seconds over which savedHighPrice decays to 0\n    /// @param chainlinkFeed_ Feed units: {UoA/tok}\n    /// @param oracleError_ {1} The % the oracle feed can be off by\n    /// @param maxTradeVolume_ {UoA} The max trade volume, in UoA\n    /// @param oracleTimeout_ {s} The number of seconds until a oracle value becomes invalid\n    constructor(\n        uint48 priceTimeout_,\n        AggregatorV3Interface chainlinkFeed_,\n        uint192 oracleError_,\n        IERC20Metadata erc20_,\n        uint192 maxTradeVolume_,\n        uint48 oracleTimeout_\n    ) {\n        require(priceTimeout_ > 0, \"price timeout zero\");\n        require(address(chainlinkFeed_) != address(0), \"missing chainlink feed\");\n        require(oracleError_ > 0 && oracleError_ < FIX_ONE, \"oracle error out of range\");\n        require(address(erc20_) != address(0), \"missing erc20\");\n        require(maxTradeVolume_ > 0, \"invalid max trade volume\");\n        require(oracleTimeout_ > 0, \"oracleTimeout zero\");\n        priceTimeout = priceTimeout_;\n        chainlinkFeed = chainlinkFeed_;\n        oracleError = oracleError_;\n        erc20 = erc20_;\n        erc20Decimals = erc20.decimals();\n        maxTradeVolume = maxTradeVolume_;\n        oracleTimeout = oracleTimeout_;\n    }\n\n    /// Can revert, used by other contract functions in order to catch errors\n    /// Should not return FIX_MAX for low\n    /// Should only return FIX_MAX for high if low is 0\n    /// @dev The third (unused) variable is only here for compatibility with Collateral\n    /// @return low {UoA/tok} The low price estimate\n    /// @return high {UoA/tok} The high price estimate\n    function tryPrice()\n        external\n        view\n        virtual\n        returns (\n            uint192 low,\n            uint192 high,\n            uint192\n        )\n    {\n        uint192 p = chainlinkFeed.price(oracleTimeout); // {UoA/tok}\n        uint192 err = p.mul(oracleError, CEIL);\n        // assert(low <= high); obviously true just by inspection\n        return (p - err, p + err, 0);\n    }\n\n    /// Should not revert\n    /// Refresh saved prices\n    function refresh() public virtual override {\n        try this.tryPrice() returns (uint192 low, uint192 high, uint192) {\n            // {UoA/tok}, {UoA/tok}\n            // (0, 0) is a valid price; (0, FIX_MAX) is unpriced\n\n            // Save prices if priced\n            if (high < FIX_MAX) {\n                savedLowPrice = low;\n                savedHighPrice = high;\n                lastSave = uint48(block.timestamp);\n            } else {\n                // must be unpriced\n                assert(low == 0);\n            }\n        } catch (bytes memory errData) {\n            // see: docs/solidity-style.md#Catching-Empty-Data\n            if (errData.length == 0) revert(); // solhint-disable-line reason-string\n        }\n    }\n\n    /// Should not revert\n    /// @dev Should be general enough to not need to be overridden\n    /// @return {UoA/tok} The lower end of the price estimate\n    /// @return {UoA/tok} The upper end of the price estimate\n    function price() public view virtual returns (uint192, uint192) {\n        try this.tryPrice() returns (uint192 low, uint192 high, uint192) {\n            assert(low <= high);\n            return (low, high);\n        } catch (bytes memory errData) {\n            // see: docs/solidity-style.md#Catching-Empty-Data\n            if (errData.length == 0) revert(); // solhint-disable-line reason-string\n            return (0, FIX_MAX);\n        }\n    }\n\n    /// Should not revert\n    /// lotLow should be nonzero when the asset might be worth selling\n    /// @dev Should be general enough to not need to be overridden\n    /// @return lotLow {UoA/tok} The lower end of the lot price estimate\n    /// @return lotHigh {UoA/tok} The upper end of the lot price estimate\n    function lotPrice() external view virtual returns (uint192 lotLow, uint192 lotHigh) {\n        try this.tryPrice() returns (uint192 low, uint192 high, uint192) {\n            // if the price feed is still functioning, use that\n            lotLow = low;\n            lotHigh = high;\n        } catch (bytes memory errData) {\n            // see: docs/solidity-style.md#Catching-Empty-Data\n            if (errData.length == 0) revert(); // solhint-disable-line reason-string\n\n            // if the price feed is broken, use a decayed historical value\n\n            uint48 delta = uint48(block.timestamp) - lastSave; // {s}\n            if (delta <= oracleTimeout) {\n                lotLow = savedLowPrice;\n                lotHigh = savedHighPrice;\n            } else if (delta >= oracleTimeout + priceTimeout) {\n                return (0, 0); // no price after full timeout\n            } else {\n                // oracleTimeout <= delta <= oracleTimeout + priceTimeout\n\n                // {1} = {s} / {s}\n                uint192 lotMultiplier = divuu(oracleTimeout + priceTimeout - delta, priceTimeout);\n\n                // {UoA/tok} = {UoA/tok} * {1}\n                lotLow = savedLowPrice.mul(lotMultiplier);\n                lotHigh = savedHighPrice.mul(lotMultiplier);\n            }\n        }\n        assert(lotLow <= lotHigh);\n    }\n\n    /// @return {tok} The balance of the ERC20 in whole tokens\n    function bal(address account) external view virtual returns (uint192) {\n        return shiftl_toFix(erc20.balanceOf(account), -int8(erc20Decimals));\n    }\n\n    /// @return If the asset is an instance of ICollateral or not\n    function isCollateral() external pure virtual returns (bool) {\n        return false;\n    }\n\n    // solhint-disable no-empty-blocks\n\n    /// Claim rewards earned by holding a balance of the ERC20 token\n    /// DEPRECATED: claimRewards() will be removed from all assets and collateral plugins\n    function claimRewards() external virtual {}\n\n    // solhint-enable no-empty-blocks\n}"
    },
    {
      "filename": "contracts/plugins/assets/compoundv3/WrappedERC20.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.19;\n\nimport \"./IWrappedERC20.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This is a \"soft-fork\" of Open Zeppelin's ERC20 contract but with some notable\n * changes including:\n *\n *   - The allowance system is changed so that users are either allowed or not.\n *   There are no approved/allowed amounts. `approve` function still exists to\n *   adhere to the ERC-20 interface.\n *\n *   - Adds `allow` for easier authorization and is an easier-to-use alternative\n *   to `approve`.\n *\n *   - All hooks are removed except for `_beforeTokenTransfer` in `_transfer`.\n *   This is done to save on gas.\n *\n *   - All reverts use custom errors instead of strings. Another gas-optimization.\n *\n *   - Adds `hasPermission` which works the same as `allowance` and checks whether\n *   a user is authorized to make balance transfers.\n *\n *   - Some state variables are removed in anticipation of this contract\n *   being inherited by the cUSDCv3 wrapper\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract WrappedERC20 is IWrappedERC20 {\n    error BadAmount();\n    error Unauthorized();\n    error ZeroAddress();\n    error ExceedsBalance(uint256 amount);\n\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => bool)) public isAllowed;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return hasPermission(owner, spender) ? type(uint256).max : 0;\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        if (spender == address(0)) revert ZeroAddress();\n        if (amount == type(uint256).max) {\n            _allow(msg.sender, spender, true);\n        } else if (amount == 0) {\n            _allow(msg.sender, spender, false);\n        } else {\n            revert BadAmount();\n        }\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must be authorized to transfer ``from``'s tokens\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        if (!hasPermission(from, msg.sender)) revert Unauthorized();\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        if (from == address(0)) revert ZeroAddress();\n        if (to == address(0)) revert ZeroAddress();\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        if (amount > fromBalance) revert ExceedsBalance(amount);\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        if (account == address(0)) revert ZeroAddress();\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        // untestable:\n        //      previously validated, account will not be address(0)\n        if (account == address(0)) revert ZeroAddress();\n\n        uint256 accountBalance = _balances[account];\n        // untestable:\n        //      ammount previously capped to the account balance\n        if (amount > accountBalance) revert ExceedsBalance(amount);\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Allow or disallow another address to withdraw, or transfer from the sender.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `manager` cannot be the zero address.\n     */\n    function allow(address account, bool isAllowed_) external {\n        _allow(msg.sender, account, isAllowed_);\n    }\n\n    /**\n     * @dev Gives `manager` control over the  `owner` s tokens.\n     *\n     * This internal function is equivalent to `allow`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `manager` cannot be the zero address.\n     */\n    function _allow(\n        address owner,\n        address manager,\n        bool isAllowed_\n    ) internal {\n        if (owner == address(0)) revert ZeroAddress();\n        if (manager == address(0)) revert ZeroAddress();\n\n        isAllowed[owner][manager] = isAllowed_;\n        emit Approval(owner, manager, isAllowed_ ? type(uint256).max : 0);\n    }\n\n    /**\n     * @dev Determine if the `manager` has permission to act on behalf of the `owner`.\n     */\n    function hasPermission(address owner, address manager) public view returns (bool) {\n        return owner == manager || isAllowed[owner][manager];\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This does not include\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     */\n    // solhint-disable no-empty-blocks\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}"
    }
  ]
}