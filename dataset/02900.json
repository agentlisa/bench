{
  "Title": "M-26: ERC4626 does not work with fee-on-transfer tokens",
  "Content": "# Issue M-26: ERC4626 does not work with fee-on-transfer tokens \n\nSource: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/3 \n\n## Found by \npashov, w42d3n, Bnke0x0\n\n## Summary\n\n## Vulnerability Detail\n\n## Impact\nThe ERC4626-Cloned.deposit/mint functions do not work well with fee-on-transfer tokens as the `assets` variable is the pre-fee amount, including the fee, whereas the totalAssets do not include the fee anymore.\n\n## Code Snippet\nThis can be abused to mint more shares than desired.\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/lib/astaria-gpl/src/ERC4626-Cloned.sol#L305-L322\n\n             '  function deposit(uint256 assets, address receiver)\n                 public\n                 virtual\n                 override(IVault)\n                 returns (uint256 shares)\n               {\n                 // Check for rounding error since we round down in previewDeposit.\n                 require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n                 // Need to transfer before minting or ERC777s could reenter.\n                 ERC20(underlying()).safeTransferFrom(msg.sender, address(this), assets);\n\n                 _mint(receiver, shares);\n\n                 emit Deposit(msg.sender, receiver, assets, shares);\n\n                 afterDeposit(assets, shares);\n               }'\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/lib/astaria-gpl/src/ERC4626-Cloned.sol#L315\n\n     `ERC20(underlying()).safeTransferFrom(msg.sender, address(this), assets);`\n\nA `deposit(1000)` should result in the same shares as two deposits of `deposit(500)` but it does not because `assets` is the pre-fee amount.\nAssume a fee-on-transfer of `20%`. Assume current `totalAmount = 1000`, `totalShares = 1000` for simplicity.\n\n`deposit(1000) = 1000 / totalAmount * totalShares = 1000 shares`.\n`deposit(500) = 500 / totalAmount * totalShares = 500 shares`. Now the `totalShares` increased by 500 but the `totalAssets` only increased by `(100% - 20%) * 500 = 400`. Therefore, the second `deposit(500) = 500 / (totalAmount + 400) * (newTotalShares) = 500 / (1400) * 1500 = 535.714285714 shares`.\n\nIn total, the two deposits lead to `35` more shares than a single deposit of the sum of the deposits.\n\n## Tool used\n\nManual Review\n\n## Recommendation\n`assets` should be the amount excluding the fee, i.e., the amount the contract actually received.\nThis can be done by subtracting the pre-contract balance from the post-contract balance.\nHowever, this would create another issue with ERC777 tokens.\n\nMaybe `previewDeposit` should be overwritten by vaults supporting fee-on-transfer tokens to predict the post-fee amount. And do the shares computation on that, but then the `afterDeposit` is still called with the original `assets`and implementers need to be aware of this.\n\n## Discussion\n\n**androolloyd**\n\nwe will not be supporting fee on transfer tokens at the time\n\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/8",
  "Code": [
    {
      "filename": "lib/astaria-gpl/src/ERC4626-Cloned.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.16;\n\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {Clone} from \"clones-with-immutable-args/Clone.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\n// owner (20) -> underlying (ERC20 address) ,\n\ninterface ITokenBase {\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n}\n\ninterface IERC4646Base is ITokenBase {\n  function underlying() external view returns (address);\n}\n\ninterface IAstariaVaultBase is IERC4646Base {\n  function owner() external view returns (address);\n\n  function COLLATERAL_TOKEN() external view returns (address);\n\n  function ROUTER() external view returns (address);\n\n  function AUCTION_HOUSE() external view returns (address);\n\n  function START() external view returns (uint256);\n\n  function EPOCH_LENGTH() external view returns (uint256);\n\n  function VAULT_TYPE() external view returns (uint8);\n\n  function VAULT_FEE() external view returns (uint256);\n}\n\nabstract contract ERC4626Base is Clone, IERC4646Base {\n  function underlying() public view virtual returns (address);\n}\n\n//abstract contract TokenBase is Clone, ITokenCloneBase {\n//    function name() external virtual view returns (string memory);\n//\n//    function symbol() external virtual view returns (string memory);\n//}\nabstract contract WithdrawVaultBase is ERC4626Base {\n  function name() public view virtual returns (string memory);\n\n  function symbol() public view virtual returns (string memory);\n\n  function owner() public pure returns (address) {\n    return _getArgAddress(0);\n  }\n\n  function underlying()\n    public\n    view\n    virtual\n    override(ERC4626Base)\n    returns (address)\n  {\n    return _getArgAddress(20);\n  }\n}\n\nabstract contract AstariaVaultBase is ERC4626Base, IAstariaVaultBase {\n  function name() public view virtual returns (string memory);\n\n  function symbol() public view virtual returns (string memory);\n\n  function owner() public pure returns (address) {\n    return _getArgAddress(0);\n  }\n\n  function underlying()\n    public\n    view\n    virtual\n    override(IERC4646Base, ERC4626Base)\n    returns (address)\n  {\n    return _getArgAddress(20);\n  }\n\n  function COLLATERAL_TOKEN() public view returns (address) {\n    return _getArgAddress(40);\n  }\n\n  function ROUTER() public view returns (address) {\n    return _getArgAddress(60);\n  }\n\n  function AUCTION_HOUSE() public view returns (address) {\n    return _getArgAddress(80);\n  }\n\n  function START() public view returns (uint256) {\n    return _getArgUint256(100);\n  }\n\n  function EPOCH_LENGTH() public view returns (uint256) {\n    return _getArgUint256(132);\n  }\n\n  function VAULT_TYPE() public view returns (uint8) {\n    return _getArgUint8(164);\n  }\n\n  function VAULT_FEE() public view returns (uint256) {\n    return _getArgUint256(172);\n  }\n}\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\n\nabstract contract ERC20Cloned is ITokenBase {\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 amount\n  );\n\n  uint256 _totalSupply;\n\n  mapping(address => uint256) public balanceOf;\n\n  mapping(address => mapping(address => uint256)) public allowance;\n\n  mapping(address => uint256) public nonces;\n\n  function approve(address spender, uint256 amount)\n    public\n    virtual\n    returns (bool)\n  {\n    allowance[msg.sender][spender] = amount;\n\n    emit Approval(msg.sender, spender, amount);\n\n    return true;\n  }\n\n  function transfer(address to, uint256 amount) public virtual returns (bool) {\n    balanceOf[msg.sender] -= amount;\n\n    // Cannot overflow because the sum of all user\n    // balances can't exceed the max uint256 value.\n    unchecked {\n      balanceOf[to] += amount;\n    }\n\n    emit Transfer(msg.sender, to, amount);\n\n    return true;\n  }\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public virtual returns (bool) {\n    uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n    if (allowed != type(uint256).max) {\n      allowance[from][msg.sender] = allowed - amount;\n    }\n\n    balanceOf[from] -= amount;\n\n    // Cannot overflow because the sum of all user\n    // balances can't exceed the max uint256 value.\n    unchecked {\n      balanceOf[to] += amount;\n    }\n\n    emit Transfer(from, to, amount);\n\n    return true;\n  }\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public virtual {\n    require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n    // Unchecked because the only math done is incrementing\n    // the owner's nonce which cannot realistically overflow.\n    unchecked {\n      address recoveredAddress = ecrecover(\n        keccak256(\n          abi.encodePacked(\n            \"\\x19\\x01\",\n            DOMAIN_SEPARATOR(),\n            keccak256(\n              abi.encode(\n                keccak256(\n                  \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                ),\n                owner,\n                spender,\n                value,\n                nonces[owner]++,\n                deadline\n              )\n            )\n          )\n        ),\n        v,\n        r,\n        s\n      );\n\n      require(\n        recoveredAddress != address(0) && recoveredAddress == owner,\n        \"INVALID_SIGNER\"\n      );\n\n      allowance[recoveredAddress][spender] = value;\n    }\n\n    emit Approval(owner, spender, value);\n  }\n\n  function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n    return computeDomainSeparator();\n  }\n\n  function computeDomainSeparator() internal view virtual returns (bytes32) {\n    return\n      keccak256(\n        abi.encode(\n          keccak256(\n            \"EIP712Domain(string version,uint256 chainId,address verifyingContract)\"\n          ),\n          keccak256(\"1\"),\n          block.chainid,\n          address(this)\n        )\n      );\n  }\n\n  function _mint(address to, uint256 amount) internal virtual {\n    _totalSupply += amount;\n\n    // Cannot overflow because the sum of all user\n    // balances can't exceed the max uint256 value.\n    unchecked {\n      balanceOf[to] += amount;\n    }\n\n    emit Transfer(address(0), to, amount);\n  }\n\n  function _burn(address from, uint256 amount) internal virtual {\n    balanceOf[from] -= amount;\n\n    // Cannot underflow because a user's balance\n    // will never be larger than the total supply.\n    unchecked {\n      _totalSupply -= amount;\n    }\n\n    emit Transfer(from, address(0), amount);\n  }\n}\n\ninterface IVault {\n  function deposit(uint256, address) external returns (uint256);\n}\n\nabstract contract ERC4626Cloned is ERC20Cloned, ERC4626Base, IVault {\n  using SafeTransferLib for ERC20;\n  using FixedPointMathLib for uint256;\n\n  event Deposit(\n    address indexed caller,\n    address indexed owner,\n    uint256 assets,\n    uint256 shares\n  );\n\n  event Withdraw(\n    address indexed caller,\n    address indexed receiver,\n    address indexed owner,\n    uint256 assets,\n    uint256 shares\n  );\n\n  function deposit(uint256 assets, address receiver)\n    public\n    virtual\n    override(IVault)\n    returns (uint256 shares)\n  {\n    // Check for rounding error since we round down in previewDeposit.\n    require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n    // Need to transfer before minting or ERC777s could reenter.\n    ERC20(underlying()).safeTransferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n\n    afterDeposit(assets, shares);\n  }\n\n  function mint(uint256 shares, address receiver)\n    public\n    virtual\n    returns (uint256 assets)\n  {\n    assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n    // Need to transfer before minting or ERC777s could reenter.\n    ERC20(underlying()).safeTransferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n\n    afterDeposit(assets, shares);\n  }\n\n  function withdraw(\n    uint256 assets,\n    address receiver,\n    address owner\n  ) public virtual returns (uint256 shares) {\n    shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n    if (msg.sender != owner) {\n      uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n      if (allowed != type(uint256).max) {\n        allowance[owner][msg.sender] = allowed - shares;\n      }\n    }\n\n    beforeWithdraw(assets, shares);\n\n    _burn(owner, shares);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n    ERC20(underlying()).safeTransfer(receiver, assets);\n  }\n\n  function redeem(\n    uint256 shares,\n    address receiver,\n    address owner\n  ) public virtual returns (uint256 assets) {\n    if (msg.sender != owner) {\n      uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n      if (allowed != type(uint256).max) {\n        allowance[owner][msg.sender] = allowed - shares;\n      }\n    }\n\n    // Check for rounding error since we round down in previewRedeem.\n    require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n    beforeWithdraw(assets, shares);\n\n    _burn(owner, shares);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n    ERC20(underlying()).safeTransfer(receiver, assets);\n  }\n\n  function totalAssets() public view virtual returns (uint256);\n\n  function convertToShares(uint256 assets)\n    public\n    view\n    virtual\n    returns (uint256)\n  {\n    uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\n    return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n  }\n\n  function convertToAssets(uint256 shares)\n    public\n    view\n    virtual\n    returns (uint256)\n  {\n    uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\n    return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n  }\n\n  function previewDeposit(uint256 assets)\n    public\n    view\n    virtual\n    returns (uint256)\n  {\n    return convertToShares(assets);\n  }\n\n  function previewMint(uint256 shares) public view virtual returns (uint256) {\n    uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\n    return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n  }\n\n  function previewWithdraw(uint256 assets)\n    public\n    view\n    virtual\n    returns (uint256)\n  {\n    uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\n    return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n  }\n\n  function totalSupply() public view virtual returns (uint256) {\n    return _totalSupply;\n  }\n\n  function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n    return convertToAssets(shares);\n  }\n\n  function maxDeposit(address) public view virtual returns (uint256) {\n    return type(uint256).max;\n  }\n\n  function maxMint(address) public view virtual returns (uint256) {\n    return type(uint256).max;\n  }\n\n  function maxWithdraw(address owner) public view virtual returns (uint256) {\n    return convertToAssets(balanceOf[owner]);\n  }\n\n  function maxRedeem(address owner) public view virtual returns (uint256) {\n    return balanceOf[owner];\n  }\n\n  function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\n\n  function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\n}"
    },
    {
      "filename": "lib/astaria-gpl/src/ERC4626-Cloned.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.16;\n\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {Clone} from \"clones-with-immutable-args/Clone.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\n// owner (20) -> underlying (ERC20 address) ,\n\ninterface ITokenBase {\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n}\n\ninterface IERC4646Base is ITokenBase {\n  function underlying() external view returns (address);\n}\n\ninterface IAstariaVaultBase is IERC4646Base {\n  function owner() external view returns (address);\n\n  function COLLATERAL_TOKEN() external view returns (address);\n\n  function ROUTER() external view returns (address);\n\n  function AUCTION_HOUSE() external view returns (address);\n\n  function START() external view returns (uint256);\n\n  function EPOCH_LENGTH() external view returns (uint256);\n\n  function VAULT_TYPE() external view returns (uint8);\n\n  function VAULT_FEE() external view returns (uint256);\n}\n\nabstract contract ERC4626Base is Clone, IERC4646Base {\n  function underlying() public view virtual returns (address);\n}\n\n//abstract contract TokenBase is Clone, ITokenCloneBase {\n//    function name() external virtual view returns (string memory);\n//\n//    function symbol() external virtual view returns (string memory);\n//}\nabstract contract WithdrawVaultBase is ERC4626Base {\n  function name() public view virtual returns (string memory);\n\n  function symbol() public view virtual returns (string memory);\n\n  function owner() public pure returns (address) {\n    return _getArgAddress(0);\n  }\n\n  function underlying()\n    public\n    view\n    virtual\n    override(ERC4626Base)\n    returns (address)\n  {\n    return _getArgAddress(20);\n  }\n}\n\nabstract contract AstariaVaultBase is ERC4626Base, IAstariaVaultBase {\n  function name() public view virtual returns (string memory);\n\n  function symbol() public view virtual returns (string memory);\n\n  function owner() public pure returns (address) {\n    return _getArgAddress(0);\n  }\n\n  function underlying()\n    public\n    view\n    virtual\n    override(IERC4646Base, ERC4626Base)\n    returns (address)\n  {\n    return _getArgAddress(20);\n  }\n\n  function COLLATERAL_TOKEN() public view returns (address) {\n    return _getArgAddress(40);\n  }\n\n  function ROUTER() public view returns (address) {\n    return _getArgAddress(60);\n  }\n\n  function AUCTION_HOUSE() public view returns (address) {\n    return _getArgAddress(80);\n  }\n\n  function START() public view returns (uint256) {\n    return _getArgUint256(100);\n  }\n\n  function EPOCH_LENGTH() public view returns (uint256) {\n    return _getArgUint256(132);\n  }\n\n  function VAULT_TYPE() public view returns (uint8) {\n    return _getArgUint8(164);\n  }\n\n  function VAULT_FEE() public view returns (uint256) {\n    return _getArgUint256(172);\n  }\n}\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\n\nabstract contract ERC20Cloned is ITokenBase {\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 amount\n  );\n\n  uint256 _totalSupply;\n\n  mapping(address => uint256) public balanceOf;\n\n  mapping(address => mapping(address => uint256)) public allowance;\n\n  mapping(address => uint256) public nonces;\n\n  function approve(address spender, uint256 amount)\n    public\n    virtual\n    returns (bool)\n  {\n    allowance[msg.sender][spender] = amount;\n\n    emit Approval(msg.sender, spender, amount);\n\n    return true;\n  }\n\n  function transfer(address to, uint256 amount) public virtual returns (bool) {\n    balanceOf[msg.sender] -= amount;\n\n    // Cannot overflow because the sum of all user\n    // balances can't exceed the max uint256 value.\n    unchecked {\n      balanceOf[to] += amount;\n    }\n\n    emit Transfer(msg.sender, to, amount);\n\n    return true;\n  }\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public virtual returns (bool) {\n    uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n    if (allowed != type(uint256).max) {\n      allowance[from][msg.sender] = allowed - amount;\n    }\n\n    balanceOf[from] -= amount;\n\n    // Cannot overflow because the sum of all user\n    // balances can't exceed the max uint256 value.\n    unchecked {\n      balanceOf[to] += amount;\n    }\n\n    emit Transfer(from, to, amount);\n\n    return true;\n  }\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public virtual {\n    require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n    // Unchecked because the only math done is incrementing\n    // the owner's nonce which cannot realistically overflow.\n    unchecked {\n      address recoveredAddress = ecrecover(\n        keccak256(\n          abi.encodePacked(\n            \"\\x19\\x01\",\n            DOMAIN_SEPARATOR(),\n            keccak256(\n              abi.encode(\n                keccak256(\n                  \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                ),\n                owner,\n                spender,\n                value,\n                nonces[owner]++,\n                deadline\n              )\n            )\n          )\n        ),\n        v,\n        r,\n        s\n      );\n\n      require(\n        recoveredAddress != address(0) && recoveredAddress == owner,\n        \"INVALID_SIGNER\"\n      );\n\n      allowance[recoveredAddress][spender] = value;\n    }\n\n    emit Approval(owner, spender, value);\n  }\n\n  function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n    return computeDomainSeparator();\n  }\n\n  function computeDomainSeparator() internal view virtual returns (bytes32) {\n    return\n      keccak256(\n        abi.encode(\n          keccak256(\n            \"EIP712Domain(string version,uint256 chainId,address verifyingContract)\"\n          ),\n          keccak256(\"1\"),\n          block.chainid,\n          address(this)\n        )\n      );\n  }\n\n  function _mint(address to, uint256 amount) internal virtual {\n    _totalSupply += amount;\n\n    // Cannot overflow because the sum of all user\n    // balances can't exceed the max uint256 value.\n    unchecked {\n      balanceOf[to] += amount;\n    }\n\n    emit Transfer(address(0), to, amount);\n  }\n\n  function _burn(address from, uint256 amount) internal virtual {\n    balanceOf[from] -= amount;\n\n    // Cannot underflow because a user's balance\n    // will never be larger than the total supply.\n    unchecked {\n      _totalSupply -= amount;\n    }\n\n    emit Transfer(from, address(0), amount);\n  }\n}\n\ninterface IVault {\n  function deposit(uint256, address) external returns (uint256);\n}\n\nabstract contract ERC4626Cloned is ERC20Cloned, ERC4626Base, IVault {\n  using SafeTransferLib for ERC20;\n  using FixedPointMathLib for uint256;\n\n  event Deposit(\n    address indexed caller,\n    address indexed owner,\n    uint256 assets,\n    uint256 shares\n  );\n\n  event Withdraw(\n    address indexed caller,\n    address indexed receiver,\n    address indexed owner,\n    uint256 assets,\n    uint256 shares\n  );\n\n  function deposit(uint256 assets, address receiver)\n    public\n    virtual\n    override(IVault)\n    returns (uint256 shares)\n  {\n    // Check for rounding error since we round down in previewDeposit.\n    require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n    // Need to transfer before minting or ERC777s could reenter.\n    ERC20(underlying()).safeTransferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n\n    afterDeposit(assets, shares);\n  }\n\n  function mint(uint256 shares, address receiver)\n    public\n    virtual\n    returns (uint256 assets)\n  {\n    assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n    // Need to transfer before minting or ERC777s could reenter.\n    ERC20(underlying()).safeTransferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n\n    afterDeposit(assets, shares);\n  }\n\n  function withdraw(\n    uint256 assets,\n    address receiver,\n    address owner\n  ) public virtual returns (uint256 shares) {\n    shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n    if (msg.sender != owner) {\n      uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n      if (allowed != type(uint256).max) {\n        allowance[owner][msg.sender] = allowed - shares;\n      }\n    }\n\n    beforeWithdraw(assets, shares);\n\n    _burn(owner, shares);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n    ERC20(underlying()).safeTransfer(receiver, assets);\n  }\n\n  function redeem(\n    uint256 shares,\n    address receiver,\n    address owner\n  ) public virtual returns (uint256 assets) {\n    if (msg.sender != owner) {\n      uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n      if (allowed != type(uint256).max) {\n        allowance[owner][msg.sender] = allowed - shares;\n      }\n    }\n\n    // Check for rounding error since we round down in previewRedeem.\n    require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n    beforeWithdraw(assets, shares);\n\n    _burn(owner, shares);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n    ERC20(underlying()).safeTransfer(receiver, assets);\n  }\n\n  function totalAssets() public view virtual returns (uint256);\n\n  function convertToShares(uint256 assets)\n    public\n    view\n    virtual\n    returns (uint256)\n  {\n    uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\n    return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n  }\n\n  function convertToAssets(uint256 shares)\n    public\n    view\n    virtual\n    returns (uint256)\n  {\n    uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\n    return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n  }\n\n  function previewDeposit(uint256 assets)\n    public\n    view\n    virtual\n    returns (uint256)\n  {\n    return convertToShares(assets);\n  }\n\n  function previewMint(uint256 shares) public view virtual returns (uint256) {\n    uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\n    return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n  }\n\n  function previewWithdraw(uint256 assets)\n    public\n    view\n    virtual\n    returns (uint256)\n  {\n    uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\n    return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n  }\n\n  function totalSupply() public view virtual returns (uint256) {\n    return _totalSupply;\n  }\n\n  function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n    return convertToAssets(shares);\n  }\n\n  function maxDeposit(address) public view virtual returns (uint256) {\n    return type(uint256).max;\n  }\n\n  function maxMint(address) public view virtual returns (uint256) {\n    return type(uint256).max;\n  }\n\n  function maxWithdraw(address owner) public view virtual returns (uint256) {\n    return convertToAssets(balanceOf[owner]);\n  }\n\n  function maxRedeem(address owner) public view virtual returns (uint256) {\n    return balanceOf[owner];\n  }\n\n  function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\n\n  function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\n}"
    }
  ]
}