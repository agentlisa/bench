{
  "Title": "[N-07] Numeric values having to do with time should use time units for readability",
  "Content": "\nThere are [units](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#time-units) for seconds, minutes, hours, days, and weeks\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts-full/libraries/Limiters.sol   #1\n\n12:       uint256 constant public MAX_COOLDOWN_BLOCKS = 7200;\n```\n\n<https://github.com/code-423n4/2022-05-alchemix/blob/71abbe683dfd5c0686b7e594fb4f78a14b668d8b/contracts-full/libraries/Limiters.sol#L12>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-05-alchemix",
  "Code": [
    {
      "filename": "contracts-full/libraries/Limiters.sol",
      "content": "pragma solidity ^0.8.11;\n\nimport {IllegalArgument} from \"../base/Errors.sol\";\n\n/// @title  Functions\n/// @author Alchemix Finance\nlibrary Limiters {\n    using Limiters for LinearGrowthLimiter;\n\n    /// @dev A maximum cooldown to avoid malicious governance bricking the contract.\n    /// @dev 1 day @ 12 sec / block\n    uint256 constant public MAX_COOLDOWN_BLOCKS = 7200;\n\n    /// @dev The scalar used to convert integral types to fixed point numbers.\n    uint256 constant public FIXED_POINT_SCALAR = 1e18;\n\n    /// @dev The configuration and state of a linear growth function (LGF).\n    struct LinearGrowthLimiter {\n        uint256 maximum;        /// The maximum limit of the function.\n        uint256 rate;           /// The rate at which the function increases back to its maximum.\n        uint256 lastValue;      /// The most recently saved value of the function.\n        uint256 lastBlock;      /// The block that `lastValue` was recorded.\n        uint256 minLimit;       /// A minimum limit to avoid malicious governance bricking the contract\n    }\n\n    /// @dev Instantiates a new linear growth function.\n    ///\n    /// @param maximum The maximum value for the LGF.\n    /// @param blocks  The number of blocks that determins the rate of the LGF.\n    ///\n    /// @return The LGF struct.\n    function createLinearGrowthLimiter(uint256 maximum, uint256 blocks, uint256 _minLimit) internal view returns (LinearGrowthLimiter memory) {\n        if (blocks > MAX_COOLDOWN_BLOCKS) {\n            revert IllegalArgument();\n        }\n\n        if (maximum < _minLimit) {\n            revert IllegalArgument();\n        }\n\n        return LinearGrowthLimiter({\n            maximum: maximum,\n            rate: maximum * FIXED_POINT_SCALAR / blocks,\n            lastValue: maximum,\n            lastBlock: block.number,\n            minLimit: _minLimit\n        });\n    }\n\n    /// @dev Configure an LGF.\n    ///\n    /// @param self    The LGF to configure.\n    /// @param maximum The maximum value of the LFG.\n    /// @param blocks  The number of recovery blocks of the LGF.\n    function configure(LinearGrowthLimiter storage self, uint256 maximum, uint256 blocks) internal {\n        if (blocks > MAX_COOLDOWN_BLOCKS) {\n            revert IllegalArgument();\n        }\n\n        if (maximum < self.minLimit) {\n            revert IllegalArgument();\n        }\n\n        if (self.lastValue > maximum) {\n            self.lastValue = maximum;\n        }\n\n        self.maximum = maximum;\n        self.rate = maximum * FIXED_POINT_SCALAR / blocks;\n    }\n\n    /// @dev Updates the state of an LGF by updating `lastValue` and `lastBlock`.\n    ///\n    /// @param self the LGF to update.\n    function update(LinearGrowthLimiter storage self) internal {\n        self.lastValue = self.get();\n        self.lastBlock = block.number;\n    }\n\n    /// @dev Decrease the value of the linear growth limiter.\n    ///\n    /// @param self   The linear growth limiter.\n    /// @param amount The amount to decrease `lastValue`.\n    function decrease(LinearGrowthLimiter storage self, uint256 amount) internal {\n        uint256 value = self.get();\n        self.lastValue = value - amount;\n        self.lastBlock = block.number;\n    }\n\n    /// @dev Get the current value of the linear growth limiter.\n    ///\n    /// @return The current value.\n    function get(LinearGrowthLimiter storage self) internal view returns (uint256) {\n        uint256 elapsed = block.number - self.lastBlock;\n        if (elapsed == 0) {\n            return self.lastValue;\n        }\n        uint256 delta = elapsed * self.rate / FIXED_POINT_SCALAR;\n        uint256 value = self.lastValue + delta;\n        return value > self.maximum ? self.maximum : value;\n    }\n}"
    }
  ]
}