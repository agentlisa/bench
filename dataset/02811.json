{
  "Title": "M-4: Wrong Illuminate PT allowance checks lead to loss of principal",
  "Content": "# Issue M-4: Wrong Illuminate PT allowance checks lead to loss of principal \n\nSource: https://github.com/sherlock-audit/2022-10-illuminate-judging/issues/118 \n\n## Found by \nIllIllI\n\n## Summary\n\nWrong Illuminate PT allowance checks lead to loss of principal\n\n## Vulnerability Detail\n\nThe `ERC5095.withdraw()` function, when called after maturity by a user with an allowance, incorrectly uses the amount of underlying rather than the number of shares the underlying is worth, when adjusting the allowance.\n\n\n## Impact\n\n_Direct theft of any user funds, whether at-rest or in-motion, other than unclaimed yield_\n\nIf each underlying is worth less than a share (e.g. if there were losses due to Lido slashing, or the external PT's protocol is paused), then a user will be allowed to take out more shares than they have been given allowance for. If the user granting the approval had minted the Illuminate PT by providing a external PT, in order to become an LP in a pool, the loss of shares is a principal loss.\n\n\n## Code Snippet\n\nThe amount of _underlying_ is being subtracted from the allowance, rather than the number of _shares required to retrieve that amount of underlying_:\n```solidity\n// File: src/tokens/ERC5095.sol : ERC5095.withdraw()   #1\n\n262                    uint256 allowance = _allowance[o][msg.sender];\n263 @>                 if (allowance < a) {\n264                        revert Exception(20, allowance, a, address(0), address(0));\n265                    }\n266 @>                 _allowance[o][msg.sender] = allowance - a;\n267                    return\n268                        IRedeemer(redeemer).authRedeem(\n269                            underlying,\n270                            maturity,\n271                            o,\n272                            r,\n273                            a\n274:                       );\n```\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/tokens/ERC5095.sol#L262-L274\n\nRedemptions of Illuminate PTs for underlyings is based on shares of each Illuminate PT's `totalSupply()` of the _available_ underlying, not the expect underlying total, and there is no way for an admin to pause this withdrawal since the `authRedeem()` function does not use the `unpaused` modifier:\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Redeemer.sol#L464\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\nCalculate how many shares the the amount of underlying is worth (e.g. call `previewWithdraw()`) and use that amount when adjusting the allowance\n\n## Discussion\n\n**sourabhmarathe**\n\nThis report will be addressed. The documentation should be updated to reflect what `withdraw` will do for the user after maturity. Given the nature of the redemption process post-maturity, we'll instead have the user specify how many PTs they will burn post-maturity.\n\n**JTraversa**\n\nThis is intended given post maturity previewWithdraw returns a 1:1 amount.\n\nYou can utilize the two interchangably, and the suggested remediation actually returns the same thing as the current code.\n\n**JTraversa**\n\nAfter discussing very briefly with the watson, he does have a rare edge case pointed out, where the heuristic of 1:1 redemptions may not be correct and will lead to slightly incorrect calculation of approvals. \n\nThat said.... this is definitely minimally impactful (especially given the design of PTs / lack of approval usage post maturity), so likely a low-med?\n\nTo be honest we could/should? have used a binary yes/no approval process for auto redemption but wanted to utilize storage slots already available\n\n**0x00052**\n\nEscalate for 1 USDC\n\nReminder @Evert0x \n\n**sherlock-admin**\n\n > Escalate for 1 USDC\n> \n> Reminder @Evert0x \n\nYou've created a valid escalation for 1 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**KenzoAgada**\n\nEscalate for 50 USDC\nSee sponsor's comments.\nTo my understanding, as mentioned, first of all the issue necessitates unusual external conditions.\nFurthermore, as the sponsor wrote, the protocol is working on the assumption that shares and underlying are 1:1 ([see `previewWithdraw`](https://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/tokens/ERC5095.sol#L138)). Because of that, the issue's fix practically makes no difference, as `previewWithdraw` anyway returns a 1:1 rate for shares-underlying. Therefore it seems to me that if the issue is valid (which I'm not sure), it should be not higher than a medium.\n\n**sherlock-admin**\n\n > Escalate for 50 USDC\n> See sponsor's comments.\n> To my understanding, as mentioned, first of all the issue necessitates unusual external conditions.\n> Furthermore, as the sponsor wrote, the protocol is working on the assumption that shares and underlying are 1:1 ([see `previewWithdraw`](https://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/tokens/ERC5095.sol#L138)). Because of that, the issue's fix practically makes no difference, as `previewWithdraw` anyway returns a 1:1 rate for shares-underlying. Therefore it seems to me that if the issue is valid (which I'm not sure), it should be not higher than a medium.\n\nYou've created a valid escalation for 50 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation accepted\n\n**sherlock-admin**\n\n> Escalation accepted\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/12",
  "Code": [
    {
      "filename": "src/tokens/ERC5095.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport 'src/tokens/ERC20Permit.sol';\nimport 'src/interfaces/IERC5095.sol';\nimport 'src/interfaces/IRedeemer.sol';\nimport 'src/interfaces/IMarketPlace.sol';\nimport 'src/interfaces/IYield.sol';\nimport 'src/errors/Exception.sol';\nimport 'src/lib/Cast.sol';\nimport 'src/lib/Safe.sol';\n\ncontract ERC5095 is ERC20Permit, IERC5095 {\n    /// @dev unix timestamp when the ERC5095 token can be redeemed\n    uint256 public immutable override maturity;\n    /// @dev address of the ERC20 token that is returned on ERC5095 redemption\n    address public immutable override underlying;\n    /// @dev address of the minting authority\n    address public immutable lender;\n    /// @dev address of the \"marketplace\" YieldSpace AMM router\n    address public immutable marketplace;\n    ///@dev Interface to interact with the pool\n    address public immutable pool;\n\n    /// @dev address and interface for an external custody contract (necessary for some project's backwards compatability)\n    address public immutable redeemer;\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Exception(0, 0, 0, msg.sender, a);\n        }\n        _;\n    }\n\n    constructor(\n        address _underlying,\n        uint256 _maturity,\n        address _redeemer,\n        address _lender,\n        address _marketplace,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) ERC20Permit(name_, symbol_, decimals_) {\n        underlying = _underlying;\n        maturity = _maturity;\n        redeemer = _redeemer;\n        lender = _lender;\n        marketplace = _marketplace;\n        pool = IMarketPlace(marketplace).pools(underlying, maturity);\n    }\n\n    /// @notice Post or at maturity converts an amount of principal tokens to an amount of underlying that would be returned.\n    /// @param s The amount of principal tokens to convert\n    /// @return uint256 The amount of underlying tokens returned by the conversion\n    function convertToUnderlying(uint256 s)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (block.timestamp < maturity) {\n            return previewRedeem(s);\n        }\n        return s;\n    }\n\n    /// @notice Post or at maturity converts a desired amount of underlying tokens returned to principal tokens needed.\n    /// @param a The amount of underlying tokens to convert\n    /// @return uint256 The amount of principal tokens returned by the conversion\n    function convertToShares(uint256 a)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (block.timestamp < maturity) {\n            return previewWithdraw(a);\n        }\n        return a;\n    }\n\n    /// @notice Post or at maturity returns user's PT balance. Pre maturity, returns a previewRedeem for owner's PT balance.\n    /// @param o The address of the owner for which redemption is calculated\n    /// @return uint256 The maximum amount of principal tokens that `owner` can redeem.\n    function maxRedeem(address o) external view override returns (uint256) {\n        if (block.timestamp < maturity) {\n            return previewRedeem(_balanceOf[o]);\n        }\n        return _balanceOf[o];\n    }\n\n    /// @notice Post or at maturity returns user's PT balance. Pre maturity, returns a previewWithdraw for owner's PT balance.\n    /// @param  o The address of the owner for which withdrawal is calculated\n    /// @return uint256 maximum amount of underlying tokens that `owner` can withdraw.\n    function maxWithdraw(address o) external view override returns (uint256) {\n        if (block.timestamp < maturity) {\n            return previewWithdraw(_balanceOf[address(this)]);\n        }\n        return _balanceOf[o];\n    }\n\n    /// @notice Post or at maturity returns 0. Pre maturity returns the amount of `shares` when spending `assets` in underlying on a YieldSpace AMM.\n    /// @param a The amount of underlying spent\n    /// @return uint256 The amount of PT purchased by spending `assets` of underlying\n    function previewDeposit(uint256 a) public view returns (uint256) {\n        if (block.timestamp < maturity) {\n            return IYield(pool).sellBasePreview(Cast.u128(a));\n        }\n        return 0;\n    }\n\n    /// @notice Post or at maturity returns 0. Pre maturity returns the amount of `assets` in underlying spent on a purchase of `shares` in PT on a YieldSpace AMM.\n    /// @param s the amount of principal tokens bought in the simulation\n    /// @return uint256 The amount of underlying spent to purchase `shares` of PT\n    function previewMint(uint256 s) public view returns (uint256) {\n        if (block.timestamp < maturity) {\n            return IYield(pool).buyFYTokenPreview(Cast.u128(s));\n        }\n        return 0;\n    }\n\n    /// @notice Post or at maturity simulates the effects of redeemption at the current block. Pre maturity returns the amount of `assets from a sale of `shares` in PT from a sale of PT on a YieldSpace AMM.\n    /// @param s the amount of principal tokens redeemed in the simulation\n    /// @return uint256 The amount of underlying returned by `shares` of PT redemption\n    function previewRedeem(uint256 s) public view override returns (uint256) {\n        if (block.timestamp > maturity) {\n            return s;\n        }\n        return IYield(pool).sellFYTokenPreview(Cast.u128(s));\n    }\n\n    /// @notice Post or at maturity simulates the effects of withdrawal at the current block. Pre maturity simulates the amount of `shares` in PT necessary to receive `assets` in underlying from a sale of PT on a YieldSpace AMM.\n    /// @param a the amount of underlying tokens withdrawn in the simulation\n    /// @return uint256 The amount of principal tokens required for the withdrawal of `assets`\n    function previewWithdraw(uint256 a) public view override returns (uint256) {\n        if (block.timestamp > maturity) {\n            return a;\n        }\n        return IYield(pool).buyBasePreview(Cast.u128(a));\n    }\n\n    /// @notice Before maturity spends `assets` of underlying, and sends `shares` of PTs to `receiver`. Post or at maturity, reverts.\n    /// @param r The receiver of the underlying tokens being withdrawn\n    /// @param a The amount of underlying tokens withdrawn\n    /// @return uint256 The amount of principal tokens burnt by the withdrawal\n    function deposit(address r, uint256 a) external override returns (uint256) {\n        if (block.timestamp > maturity) {\n            revert Exception(\n                21,\n                block.timestamp,\n                maturity,\n                address(0),\n                address(0)\n            );\n        }\n        uint128 shares = Cast.u128(previewDeposit(a));\n        Safe.transferFrom(IERC20(underlying), msg.sender, address(this), a);\n        // consider the hardcoded slippage limit, 4626 compliance requires no minimum param.\n        uint128 returned = IMarketPlace(marketplace).sellUnderlying(\n            underlying,\n            maturity,\n            Cast.u128(a),\n            shares - (shares / 100)\n        );\n        _transfer(address(this), r, returned);\n        return returned;\n    }\n\n    /// @notice Before maturity mints `shares` of PTs to `receiver` and spending `assets` of underlying. Post or at maturity, reverts.\n    /// @param r The receiver of the underlying tokens being withdrawn\n    /// @param s The amount of underlying tokens withdrawn\n    /// @return uint256 The amount of principal tokens burnt by the withdrawal\n    function mint(address r, uint256 s) external override returns (uint256) {\n        if (block.timestamp > maturity) {\n            revert Exception(\n                21,\n                block.timestamp,\n                maturity,\n                address(0),\n                address(0)\n            );\n        }\n        uint128 assets = Cast.u128(previewMint(s));\n        Safe.transferFrom(\n            IERC20(underlying),\n            msg.sender,\n            address(this),\n            assets\n        );\n        // consider the hardcoded slippage limit, 4626 compliance requires no minimum param.\n        uint128 returned = IMarketPlace(marketplace).sellUnderlying(\n            underlying,\n            maturity,\n            assets,\n            assets - (assets / 100)\n        );\n        _transfer(address(this), r, returned);\n        return returned;\n    }\n\n    /// @notice At or after maturity, Burns `shares` from `owner` and sends exactly `assets` of underlying tokens to `receiver`. Before maturity, sends `assets` by selling shares of PT on a YieldSpace AMM.\n    /// @param a The amount of underlying tokens withdrawn\n    /// @param r The receiver of the underlying tokens being withdrawn\n    /// @param o The owner of the underlying tokens\n    /// @return uint256 The amount of principal tokens burnt by the withdrawal\n    function withdraw(\n        uint256 a,\n        address r,\n        address o\n    ) external override returns (uint256) {\n        // Pre maturity\n        if (block.timestamp < maturity) {\n            uint128 shares = Cast.u128(previewWithdraw(a));\n            // If owner is the sender, sell PT without allowance check\n            if (o == msg.sender) {\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n                    underlying,\n                    maturity,\n                    shares,\n                    Cast.u128(a - (a / 100))\n                );\n                Safe.transfer(IERC20(underlying), r, returned);\n                return returned;\n                // Else, sell PT with allowance check\n            } else {\n                uint256 allowance = _allowance[o][msg.sender];\n                if (allowance < shares) {\n                    revert Exception(\n                        20,\n                        allowance,\n                        shares,\n                        address(0),\n                        address(0)\n                    );\n                }\n                _allowance[o][msg.sender] = allowance - shares;\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n                    underlying,\n                    maturity,\n                    Cast.u128(shares),\n                    Cast.u128(a - (a / 100))\n                );\n                Safe.transfer(IERC20(underlying), r, returned);\n                return returned;\n            }\n        }\n        // Post maturity\n        else {\n            if (o == msg.sender) {\n                return\n                    IRedeemer(redeemer).authRedeem(\n                        underlying,\n                        maturity,\n                        msg.sender,\n                        r,\n                        a\n                    );\n            } else {\n                uint256 allowance = _allowance[o][msg.sender];\n                if (allowance < a) {\n                    revert Exception(20, allowance, a, address(0), address(0));\n                }\n                _allowance[o][msg.sender] = allowance - a;\n                return\n                    IRedeemer(redeemer).authRedeem(\n                        underlying,\n                        maturity,\n                        o,\n                        r,\n                        a\n                    );\n            }\n        }\n    }\n\n    /// @notice At or after maturity, burns exactly `shares` of Principal Tokens from `owner` and sends `assets` of underlying tokens to `receiver`. Before maturity, sends `assets` by selling `shares` of PT on a YieldSpace AMM.\n    /// @param s The number of shares to be burned in exchange for the underlying asset\n    /// @param r The receiver of the underlying tokens being withdrawn\n    /// @param o Address of the owner of the shares being burned\n    /// @return uint256 The amount of underlying tokens distributed by the redemption\n    function redeem(\n        uint256 s,\n        address r,\n        address o\n    ) external override returns (uint256) {\n        // Pre-maturity\n        if (block.timestamp < maturity) {\n            uint128 assets = Cast.u128(previewRedeem(s));\n            // If owner is the sender, sell PT without allowance check\n            if (o == msg.sender) {\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n                    underlying,\n                    maturity,\n                    Cast.u128(s),\n                    assets - (assets / 100)\n                );\n                Safe.transfer(IERC20(underlying), r, returned);\n                return returned;\n                // Else, sell PT with allowance check\n            } else {\n                uint256 allowance = _allowance[o][msg.sender];\n                if (allowance < s) {\n                    revert Exception(20, allowance, s, address(0), address(0));\n                }\n                _allowance[o][msg.sender] = allowance - s;\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n                    underlying,\n                    maturity,\n                    Cast.u128(s),\n                    assets - (assets / 100)\n                );\n                Safe.transfer(IERC20(underlying), r, returned);\n                return returned;\n            }\n            // Post-maturity\n        } else {\n            if (o == msg.sender) {\n                return\n                    IRedeemer(redeemer).authRedeem(\n                        underlying,\n                        maturity,\n                        msg.sender,\n                        r,\n                        s\n                    );\n            } else {\n                uint256 allowance = _allowance[o][msg.sender];\n                if (allowance < s) {\n                    revert Exception(20, allowance, s, address(0), address(0));\n                }\n                _allowance[o][msg.sender] = allowance - s;\n                return\n                    IRedeemer(redeemer).authRedeem(\n                        underlying,\n                        maturity,\n                        o,\n                        r,\n                        s\n                    );\n            }\n        }\n    }\n\n    /// @param f Address to burn from\n    /// @param a Amount to burn\n    /// @return bool true if successful\n    function authBurn(address f, uint256 a)\n        external\n        authorized(redeemer)\n        returns (bool)\n    {\n        _burn(f, a);\n        return true;\n    }\n\n    /// @param t Address recieving the minted amount\n    /// @param a The amount to mint\n    /// @return bool true if successful\n    function authMint(address t, uint256 a)\n        external\n        authorized(lender)\n        returns (bool)\n    {\n        _mint(t, a);\n        return true;\n    }\n}"
    },
    {
      "filename": "src/Redeemer.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.16;\n\nimport 'src/MarketPlace.sol';\n\nimport 'src/lib/Safe.sol';\nimport 'src/errors/Exception.sol';\n\nimport 'src/interfaces/IERC5095.sol';\nimport 'src/interfaces/IERC20.sol';\nimport 'src/interfaces/ITempus.sol';\nimport 'src/interfaces/ITempusPool.sol';\nimport 'src/interfaces/ITempusToken.sol';\nimport 'src/interfaces/IAPWine.sol';\nimport 'src/interfaces/IAPWineController.sol';\nimport 'src/interfaces/IAPWineFutureVault.sol';\nimport 'src/interfaces/IAPWineToken.sol';\nimport 'src/interfaces/IAPWineAMMPool.sol';\nimport 'src/interfaces/ISwivel.sol';\nimport 'src/interfaces/ISwivelToken.sol';\nimport 'src/interfaces/IElementToken.sol';\nimport 'src/interfaces/IYieldToken.sol';\nimport 'src/interfaces/INotional.sol';\nimport 'src/interfaces/IPendle.sol';\nimport 'src/interfaces/IPendleForge.sol';\nimport 'src/interfaces/IPendleToken.sol';\nimport 'src/interfaces/ISenseDivider.sol';\nimport 'src/interfaces/ISenseAdapter.sol';\nimport 'src/interfaces/IYield.sol';\nimport 'src/interfaces/IConverter.sol';\n\nimport 'forge-std/Test.sol';\n\n/// @title Redeemer\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice The Redeemer contract is used to redeem the underlying lent capital of a loan.\n/// @notice Users may redeem their ERC-5095 tokens for the underlying asset represented by that token after maturity.\ncontract Redeemer {\n    /// @notice address that is allowed to set fees and contracts, etc. It is commonly used in the authorized modifier.\n    address public admin;\n    /// @notice address of the MarketPlace contract, used to access the markets mapping\n    address public marketPlace;\n    /// @notice address that custodies principal tokens for all markets\n    address public lender;\n    /// @notice address that converts compounding tokens to their underlying\n    address public converter;\n\n    /// @notice third party contract needed to redeem Swivel PTs\n    address public immutable swivelAddr;\n    /// @notice third party contract needed to redeem Pendle PTs\n    address public immutable pendleAddr;\n    /// @notice third party contract needed to redeem Tempus PTs\n    address public immutable tempusAddr;\n\n    /// @notice this value determines the amount of fees paid on auto redemptions\n    uint256 public feenominator;\n    /// @notice represents a point in time where the feenominator may change\n    uint256 public feeChange;\n    /// @notice represents a minimum that the feenominator must exceed\n    uint256 public MIN_FEENOMINATOR = 500;\n\n    /// @notice mapping that indicates how much underlying has been redeemed by a market\n    mapping(address => mapping(uint256 => uint256)) public holdings;\n    /// @notice mapping that determines if a market's iPT can be redeemed\n    mapping(address => mapping(uint256 => bool)) public paused;\n\n    /// @notice emitted upon redemption of a loan\n    event Redeem(\n        uint8 principal,\n        address indexed underlying,\n        uint256 indexed maturity,\n        uint256 amount,\n        address sender\n    );\n    /// @notice emitted upon changing the admin\n    event SetAdmin(address indexed admin);\n    /// @notice emitted upon changing the converter\n    event SetConverter(address indexed converter);\n    /// @notice emitted upon setting the fee rate\n    event SetFee(uint256 indexed fee);\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Exception(0, 0, 0, msg.sender, a);\n        }\n        _;\n    }\n\n    /// @notice reverts on all markets where the paused mapping returns true\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    modifier unpaused(address u, uint256 m) {\n        if (paused[u][m]) {\n            revert Exception(17, m, 0, u, address(0));\n        }\n        _;\n    }\n\n    /// @notice Initializes the Redeemer contract\n    /// @param l the lender contract\n    /// @param s the Swivel contract\n    /// @param p the Pendle contract\n    /// @param t the Tempus contract\n    constructor(\n        address l,\n        address s,\n        address p,\n        address t\n    ) {\n        admin = msg.sender;\n        lender = l;\n        swivelAddr = s;\n        pendleAddr = p;\n        tempusAddr = t;\n        feenominator = 4000;\n    }\n\n    /// @notice sets the admin address\n    /// @param a Address of a new admin\n    /// @return bool true if successful\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        emit SetAdmin(a);\n        return true;\n    }\n\n    /// @notice sets the address of the marketplace contract which contains the addresses of all the fixed rate markets\n    /// @param m the address of the marketplace contract\n    /// @return bool true if the address was set\n    function setMarketPlace(address m)\n        external\n        authorized(admin)\n        returns (bool)\n    {\n        if (marketPlace != address(0)) {\n            revert Exception(5, 0, 0, marketPlace, address(0));\n        }\n        marketPlace = m;\n        return true;\n    }\n\n    /// @notice sets the converter address\n    /// @param c address of the new converter\n    /// @return bool true if successful\n    function setConverter(address c) external authorized(admin) returns (bool) {\n        converter = c;\n        emit SetConverter(c);\n        return true;\n    }\n\n    /// @notice sets the address of the lender contract which contains the addresses of all the fixed rate markets\n    /// @param l the address of the lender contract\n    /// @return bool true if the address was set\n    function setLender(address l) external authorized(admin) returns (bool) {\n        if (lender != address(0)) {\n            revert Exception(8, 0, 0, address(lender), address(0));\n        }\n        lender = l;\n        return true;\n    }\n\n    /// @notice sets the feenominator to the given value\n    /// @param f the new value of the feenominator, fees are not collected when the feenominator is 0\n    /// @return bool true if successful\n    function setFee(uint256 f) external authorized(admin) returns (bool) {\n        uint256 feeTime = feeChange;\n        if (feeTime == 0) {\n            revert Exception(23, 0, 0, address(0), address(0));\n        } else if (feeTime < block.timestamp) {\n            revert Exception(\n                24,\n                block.timestamp,\n                feeTime,\n                address(0),\n                address(0)\n            );\n        } else if (f < MIN_FEENOMINATOR) {\n            revert Exception(25, 0, 0, address(0), address(0));\n        }\n        feenominator = f;\n        delete feeChange;\n        emit SetFee(f);\n        return true;\n    }\n\n    /// @notice allows admin to stop redemptions of Illuminate PTs for a given market\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param b true to pause, false to unpause\n    function pauseRedemptions(\n        address u,\n        uint256 m,\n        bool b\n    ) external authorized(admin) {\n        paused[u][m] = b;\n    }\n\n    /// @notice approves the converter to spend the compounding asset\n    /// @param i an interest bearing token that must be approved for conversion\n    function approve(address i) external authorized(marketPlace) {\n        if (i != address(0)) {\n            Safe.approve(IERC20(i), address(converter), type(uint256).max);\n        }\n    }\n\n    /// @notice redeem method for Swivel, Yield, Element, Pendle, APWine, Tempus and Notional protocols\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @return bool true if the redemption was successful\n    function redeem(\n        uint8 p,\n        address u,\n        uint256 m\n    ) external returns (bool) {\n        // Get the principal token that is being redeemed by the user\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Get the maturity for the given principal token\n        uint256 maturity;\n        if (p == uint8(MarketPlace.Principals.Swivel)) {\n            maturity = ISwivelToken(principal).maturity();\n        } else if (p == uint8(MarketPlace.Principals.Yield)) {\n            maturity = IYieldToken(principal).maturity();\n        } else if (p == uint8(MarketPlace.Principals.Element)) {\n            maturity = IElementToken(principal).unlockTimestamp();\n        } else if (p == uint8(MarketPlace.Principals.Pendle)) {\n            maturity = IPendleToken(principal).expiry();\n        } else if (p == uint8(MarketPlace.Principals.Tempus)) {\n            maturity = ITempusPool(ITempusToken(principal).pool())\n                .maturityTime();\n        } else if (p == uint8(MarketPlace.Principals.Apwine)) {\n            // APWine's maturity is retrieved indirectly via the PT's\n            // futureVault and Controller\n            address futureVault = IAPWineToken(principal).futureVault();\n\n            address controller = IAPWineFutureVault(futureVault)\n                .getControllerAddress();\n\n            uint256 duration = IAPWineFutureVault(futureVault)\n                .PERIOD_DURATION();\n\n            maturity = IAPWineController(controller).getNextPeriodStart(\n                duration\n            );\n        } else if (p == uint8(MarketPlace.Principals.Notional)) {\n            maturity = INotional(principal).getMaturity();\n        } else {\n            revert Exception(6, p, 0, address(0), address(0));\n        }\n\n        // Verify that the token has matured\n        if (maturity > block.timestamp) {\n            revert Exception(7, maturity, 0, address(0), address(0));\n        }\n\n        // Cache the lender to save gas on sload\n        address cachedLender = lender;\n\n        // Get the amount to be redeemed\n        uint256 amount = IERC20(principal).balanceOf(cachedLender);\n\n        // Receive the principal token from the lender contract\n        Safe.transferFrom(\n            IERC20(principal),\n            cachedLender,\n            address(this),\n            amount\n        );\n\n        // Get the starting balance of the underlying held by the redeemer\n        uint256 starting = IERC20(u).balanceOf(address(this));\n\n        if (p == uint8(MarketPlace.Principals.Swivel)) {\n            // Redeems principal tokens from Swivel\n            if (!ISwivel(swivelAddr).redeemZcToken(u, maturity, amount)) {\n                revert Exception(15, 0, 0, address(0), address(0));\n            }\n        } else if (p == uint8(MarketPlace.Principals.Yield)) {\n            // Redeems principal tokens from Yield\n            IYieldToken(principal).redeem(address(this), amount);\n        } else if (p == uint8(MarketPlace.Principals.Element)) {\n            // Redeems principal tokens from Element\n            IElementToken(principal).withdrawPrincipal(amount, address(this));\n        } else if (p == uint8(MarketPlace.Principals.Pendle)) {\n            // Get the forge contract for the principal token\n            address forge = IPendleToken(principal).forge();\n\n            // Get the forge ID of the principal token\n            bytes32 forgeId = IPendleForge(forge).forgeId();\n\n            // Redeem the tokens from the Pendle contract\n            IPendle(pendleAddr).redeemAfterExpiry(forgeId, u, maturity);\n\n            // Get the compounding asset for this market\n            address compounding = IPendleToken(principal)\n                .underlyingYieldToken();\n\n            // Redeem the compounding to token to the underlying\n            IConverter(converter).convert(\n                compounding,\n                u,\n                IERC20(compounding).balanceOf(address(this))\n            );\n        } else if (p == uint8(MarketPlace.Principals.Tempus)) {\n            // Retrieve the pool for the principal token\n            address pool = ITempusToken(principal).pool();\n\n            // Redeems principal tokens from Tempus\n            ITempus(tempusAddr).redeemToBacking(pool, amount, 0, address(this));\n        } else if (p == uint8(MarketPlace.Principals.Apwine)) {\n            apwineWithdraw(principal, u, amount);\n        } else if (p == uint8(MarketPlace.Principals.Notional)) {\n            // Redeems principal tokens from Notional\n            INotional(principal).redeem(\n                INotional(principal).maxRedeem(address(this)),\n                address(this),\n                address(this)\n            );\n        }\n\n        // Calculate how much underlying was redeemed\n        uint256 redeemed = IERC20(u).balanceOf(address(this)) - starting;\n\n        // Update the holding for this market\n        holdings[u][m] = holdings[u][m] + redeemed;\n\n        emit Redeem(p, u, m, redeemed, msg.sender);\n        return true;\n    }\n\n    /// @notice redeem method signature for Sense\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param s Sense's maturity is needed to extract the pt address\n    /// @param a Sense's adapter for this market\n    /// @return bool true if the redemption was successful\n    function redeem(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 s,\n        address a\n    ) external returns (bool) {\n        // Check the principal is Sense\n        if (p != uint8(MarketPlace.Principals.Sense)) {\n            revert Exception(6, p, 0, address(0), address(0));\n        }\n\n        // Get Sense's principal token for this market\n        IERC20 token = IERC20(IMarketPlace(marketPlace).token(u, m, p));\n\n        // Cache the lender to save on SLOAD operations\n        address cachedLender = lender;\n\n        // Get the balance of tokens to be redeemed by the user\n        uint256 amount = token.balanceOf(cachedLender);\n\n        // Transfer the user's tokens to the redeem contract\n        Safe.transferFrom(token, cachedLender, address(this), amount);\n\n        // Get the starting balance to verify the amount received afterwards\n        uint256 starting = IERC20(u).balanceOf(address(this));\n\n        // Get the divider from the adapter\n        ISenseDivider divider = ISenseDivider(ISenseAdapter(a).divider());\n\n        // Redeem the tokens from the Sense contract\n        ISenseDivider(divider).redeem(a, s, amount);\n\n        // Get the compounding token that is redeemed by Sense\n        address compounding = ISenseAdapter(a).target();\n\n        // Redeem the compounding token back to the underlying\n        IConverter(converter).convert(\n            compounding,\n            u,\n            IERC20(compounding).balanceOf(address(this))\n        );\n\n        // Get the amount received\n        uint256 redeemed = IERC20(u).balanceOf(address(this)) - starting;\n\n        // Verify that underlying are received 1:1 - cannot trust the adapter\n        if (redeemed < amount) {\n            revert Exception(13, 0, 0, address(0), address(0));\n        }\n\n        // Update the holdings for this market\n        holdings[u][m] = holdings[u][m] + redeemed;\n\n        emit Redeem(p, u, m, redeemed, msg.sender);\n        return true;\n    }\n\n    /// @notice burns Illuminate principal tokens and sends underlying to user\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    function redeem(address u, uint256 m) external unpaused(u, m) {\n        // Get Illuminate's principal token for this market\n        IERC5095 token = IERC5095(\n            IMarketPlace(marketPlace).token(\n                u,\n                m,\n                uint8(MarketPlace.Principals.Illuminate)\n            )\n        );\n\n        // Verify the token has matured\n        if (block.timestamp < token.maturity()) {\n            revert Exception(7, block.timestamp, m, address(0), address(0));\n        }\n\n        // Get the amount of tokens to be redeemed from the sender\n        uint256 amount = token.balanceOf(msg.sender);\n\n        // Calculate how many tokens the user should receive\n        uint256 redeemed = (amount * holdings[u][m]) / token.totalSupply();\n\n        // Update holdings of underlying\n        holdings[u][m] = holdings[u][m] - redeemed;\n\n        // Burn the user's principal tokens\n        token.authBurn(msg.sender, amount);\n\n        // Transfer the original underlying token back to the user\n        Safe.transfer(IERC20(u), msg.sender, redeemed);\n\n        emit Redeem(0, u, m, redeemed, msg.sender);\n    }\n\n    /// @notice implements the redeem method for the contract to fulfill the ERC-5095 interface\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param f address from where the underlying asset will be burned\n    /// @param t address to where the underlying asset will be transferred\n    /// @param a amount of the Illuminate PT to be burned and redeemed\n    /// @return uint256 amount of the underlying asset that was burned\n    function authRedeem(\n        address u,\n        uint256 m,\n        address f,\n        address t,\n        uint256 a\n    )\n        external\n        authorized(IMarketPlace(marketPlace).token(u, m, 0))\n        returns (uint256)\n    {\n        // Get the principal token for the given market\n        IERC5095 pt = IERC5095(IMarketPlace(marketPlace).token(u, m, 0));\n\n        // Make sure the market has matured\n        uint256 maturity = pt.maturity();\n        if (block.timestamp < maturity) {\n            revert Exception(7, maturity, 0, address(0), address(0));\n        }\n\n        // Calculate the amount redeemed\n        uint256 redeemed = (a * holdings[u][m]) / pt.totalSupply();\n\n        // Update holdings of underlying\n        holdings[u][m] = holdings[u][m] - redeemed;\n\n        // Burn the user's principal tokens\n        pt.authBurn(f, a);\n\n        // Transfer the original underlying token back to the user\n        Safe.tran"
    }
  ]
}