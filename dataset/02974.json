{
  "Title": "M-2: Chainlink's `latestRoundData` might return stale or incorrect results",
  "Content": "# Issue M-2: Chainlink's `latestRoundData` might return stale or incorrect results \n\nSource: https://github.com/sherlock-audit/2022-09-knox-judging/issues/137 \n\n## Found by \nJeiwan, csanuragjain, berndartmueller, jayphbee, joestakey, Olivierdem, Ruhum, GalloDaSballo, \\_\\_141345\\_\\_, Trumpero, ArbitraryExecution, hansfriese, ali\\_shehab, cccz, 0xNazgul, ak1, ctf\\_sec, minhquanym\n\n## Summary\n\nChainlink's `latestRoundData()` is used but there is no check if the return value indicates stale data. This could lead to stale prices according to the Chainlink documentation:\n\n- https://docs.chain.link/docs/historical-price-data/#historical-rounds\n\n## Vulnerability Detail\n\nThe `PricerInternal._latestAnswer64x64` function uses Chainlink's `latestRoundData()` to get the latest price. However, there is no check if the return value indicates stale data.\n\n## Impact\n\nThe `PricerInternal` could return stale price data for the underlying asset.\n\n## Code Snippet\n\n[PricerInternal.\\_latestAnswer64x64](https://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/pricer/PricerInternal.sol#L50-L52)\n\n```solidity\n/**\n  * @notice gets the latest price of the underlying denominated in the base\n  * @return price of underlying asset as 64x64 fixed point number\n  */\nfunction _latestAnswer64x64() internal view returns (int128) {\n    (, int256 basePrice, , , ) = BaseSpotOracle.latestRoundData();\n    (, int256 underlyingPrice, , , ) =\n        UnderlyingSpotOracle.latestRoundData();\n\n    return ABDKMath64x64.divi(underlyingPrice, basePrice);\n}\n```\n\n## Tool Used\n\nManual review\n\n## Recommendation\n\nConsider adding checks for stale data. e.g\n\n```solidity\n(uint80 roundId, int256 basePrice, , uint256 updatedAt, uint80 answeredInRound) = BaseSpotOracle.latestRoundData();\n\nrequire(answeredInRound >= roundId, \"Price stale\");\nrequire(block.timestamp - updatedAt < PRICE_ORACLE_STALE_THRESHOLD, \"Price round incomplete\");\n```\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/4",
  "Code": [
    {
      "filename": "knox-contracts/contracts/pricer/PricerInternal.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../libraries/OptionMath.sol\";\n\nimport \"../vendor/IPremiaPool.sol\";\nimport \"../vendor/IVolatilitySurfaceOracle.sol\";\nimport \"../vendor/CumulativeNormalDistribution.sol\";\n\nimport \"./IPricer.sol\";\n\n/**\n * @title Knox Pricer Internal Contract\n */\n\ncontract PricerInternal {\n    using ABDKMath64x64 for uint256;\n\n    address public immutable Base;\n    address public immutable Underlying;\n    IVolatilitySurfaceOracle public immutable IVolOracle;\n    AggregatorV3Interface public immutable BaseSpotOracle;\n    AggregatorV3Interface public immutable UnderlyingSpotOracle;\n\n    constructor(address pool, address volatilityOracle) {\n        IVolOracle = IVolatilitySurfaceOracle(volatilityOracle);\n\n        IPremiaPool.PoolSettings memory settings =\n            IPremiaPool(pool).getPoolSettings();\n\n        Base = settings.base;\n        Underlying = settings.underlying;\n\n        BaseSpotOracle = AggregatorV3Interface(settings.baseOracle);\n        UnderlyingSpotOracle = AggregatorV3Interface(settings.underlyingOracle);\n\n        uint8 decimals = UnderlyingSpotOracle.decimals();\n\n        require(\n            BaseSpotOracle.decimals() == decimals,\n            \"oracle decimals must match\"\n        );\n    }\n\n    /**\n     * @notice gets the latest price of the underlying denominated in the base\n     * @return price of underlying asset as 64x64 fixed point number\n     */\n    function _latestAnswer64x64() internal view returns (int128) {\n        (, int256 basePrice, , , ) = BaseSpotOracle.latestRoundData();\n        (, int256 underlyingPrice, , , ) =\n            UnderlyingSpotOracle.latestRoundData();\n\n        return ABDKMath64x64.divi(underlyingPrice, basePrice);\n    }\n\n    /**\n     * @notice calculates the time remaining until maturity\n     * @param expiry the expiry date as UNIX timestamp\n     * @return time remaining until maturity\n     */\n    function _getTimeToMaturity64x64(uint64 expiry)\n        internal\n        view\n        returns (int128)\n    {\n        return ABDKMath64x64.divu(expiry - block.timestamp, 365 days);\n    }\n\n    /**\n     * @notice gets the annualized volatility of the pool pair\n     * @param spot64x64 spot price of the underlying as 64x64 fixed point number\n     * @param strike64x64 strike price of the option as 64x64 fixed point number\n     * @param timeToMaturity64x64 time remaining until maturity as a 64x64 fixed point number\n     * @return annualized volatility as 64x64 fixed point number\n     */\n    function _getAnnualizedVolatility64x64(\n        int128 spot64x64,\n        int128 strike64x64,\n        int128 timeToMaturity64x64\n    ) internal view returns (int128) {\n        return\n            IVolOracle.getAnnualizedVolatility64x64(\n                Base,\n                Underlying,\n                spot64x64,\n                strike64x64,\n                timeToMaturity64x64\n            );\n    }\n}"
    }
  ]
}