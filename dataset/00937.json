{
  "Title": "incorrect handling of compound cancelation lead vault to stuck at `compound_failed` status",
  "Content": "# incorrect handling of compound cancelation lead vault to stuck at `compound_failed` status\n\n### Severity\nHigh Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/strategy/gmx/GMXCompound.sol\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/strategy/gmx/GMXCompound.sol</a>\n\n\n## Summary\n\nthe [compound](https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/strategy/gmx/GMXCompound.sol#L35) function allows the keeper to swap a token for **TokenA** or **TokenB** and add it as liquidity to `GMX`. However, if the deposit get _cancelled_, the contract enters a `compound_failed` status. leading to a deadlock and preventing further protocol interactions.\n\n## Vulnerability Details\n\n-The [compound](https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/strategy/gmx/GMXCompound.sol#L35) function is invoked by the keeper to swap a token held by the contract (e.g., from an airdrop as sponsor said) for **TokenA** or **TokenB**. Initially, it exchanges this token for either **tokenA** or **tokenB** and sets the status to `compound`. Then, it adds the swapped token as liquidity to `GMX` by creating a deposit:\n\n```solidity\n  function compound(GMXTypes.Store storage self, GMXTypes.CompoundParams memory cp) external {lt\n      if (self.tokenA.balanceOf(address(self.trove)) > 0) {\n          self.tokenA.safeTransferFrom(address(self.trove), address(this), self.tokenA.balanceOf(address(self.trove)));\n      }\n      if (self.tokenB.balanceOf(address(self.trove)) > 0) {\n          self.tokenB.safeTransferFrom(address(self.trove), address(this), self.tokenB.balanceOf(address(self.trove)));\n      }\n\n>>      uint256 _tokenInAmt = IERC20(cp.tokenIn).balanceOf(address(this));\n\n      // Only compound if tokenIn amount is more than 0\n      if (_tokenInAmt > 0) {\n          self.refundee = payable(msg.sender); // the msg.sender is the keeper.\n\n          self.compoundCache.compoundParams = cp; // storage update.\n\n          ISwap.SwapParams memory _sp;\n\n          _sp.tokenIn = cp.tokenIn;\n          _sp.tokenOut = cp.tokenOut;\n          _sp.amountIn = _tokenInAmt;\n          _sp.amountOut = 0; // amount out minimum calculated in Swap\n          _sp.slippage = self.minSlippage; // minSlipage may result to a revert an cause the tokens stays in this contract.\n          _sp.deadline = cp.deadline;\n\n          GMXManager.swapExactTokensForTokens(self, _sp); // return value not checked.\n\n          GMXTypes.AddLiquidityParams memory _alp;\n\n          _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n          _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n          /// what this return in case zero balance?? zero\n          self.compoundCache.depositValue = GMXReader.convertToUsdValue(\n              self, address(self.tokenA), self.tokenA.balanceOf(address(this))\n          ) + GMXReader.convertToUsdValue(self, address(self.tokenB), self.tokenB.balanceOf(address(this)));\n          // revert if zero value, status not open or compound_failed , executionFee < minExecutionFee.\n          GMXChecks.beforeCompoundChecks(self);\n\n>>          self.status = GMXTypes.Status.Compound;\n\n          _alp.minMarketTokenAmt =\n              GMXManager.calcMinMarketSlippageAmt(self, self.compoundCache.depositValue, cp.slippage);\n\n          _alp.executionFee = cp.executionFee;\n>>          self.compoundCache.depositKey = GMXManager.addLiquidity(self, _alp);\n      }\n```\n\n- In the event of a successful deposit, the contract will set the status to `open` again. _However_, if the deposit is _cancelled_, the callback will call `processCompoundCancellation()` function and the status will be set to `compound_failed` as shown in the following code:\n\n```solidity\n  function processCompoundCancellation(GMXTypes.Store storage self) external {\n        GMXChecks.beforeProcessCompoundCancellationChecks(self);\n        self.status = GMXTypes.Status.Compound_Failed;\n\n        emit CompoundCancelled();\n    }\n```\n\n- The issue arises when the deposit is cancelled, and the status becomes `compound_failed`. In this scenario, only the [compound](https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/strategy/gmx/GMXCompound.sol#L35) function can be called again and only by the keeper, but the tokens have already been swapped for **TokenA** or **TokenB** (Because we successfully create a deposit in `GMX` that means the swap was successfull). Consequently, the `amountIn` will be zero, and in this case the compound logic will be skipped.\n\n```solidity\n>>     uint256 _tokenInAmt = IERC20(cp.tokenIn).balanceOf(address(this));\n\n        // Only compound if tokenIn amount is more than 0\n>>      if (_tokenInAmt > 0) {\n            //compound logic\n            //....\n        }\n```\n\n- As a result, the status will remain `compound_failed`, leading to a deadlock. If keeper continue to call this function, no progress will be made, only gas will be wasted. Furthermore, all interactions with the protocol are impossible since the status is `compound_failed`.\n\n## Impact\n\n- strategy vault stuck at `compond_failed` status. prevent any interaction with the protocol\n- keeper may waste a lot of gas trying to handle this situation .\n\n## Tools Used\n\nmanual review\n\n## Recommendations\n\n- in the event of a deposit get cancelled when trying to compound. just add liquidity again without the swapping logic.",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clo38mm260001la08daw5cbuf",
  "Code": [
    {
      "filename": "contracts/strategy/gmx/GMXCompound.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\n\n/**\n  * @title GMXCompound\n  * @author Steadefi\n  * @notice Re-usable library functions for compound operations for Steadefi leveraged vaults\n*/\nlibrary GMXCompound {\n  using SafeERC20 for IERC20;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ======================== EVENTS ========================= */\n\n  event CompoundCompleted();\n  event CompoundCancelled();\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function compound(\n    GMXTypes.Store storage self,\n    GMXTypes.CompoundParams memory cp\n  ) external {\n    // Transfer any tokenA/B from trove to vault\n    if (self.tokenA.balanceOf(address(self.trove)) > 0) {\n      self.tokenA.safeTransferFrom(\n        address(self.trove),\n        address(this),\n        self.tokenA.balanceOf(address(self.trove))\n      );\n    }\n    if (self.tokenB.balanceOf(address(self.trove)) > 0) {\n      self.tokenB.safeTransferFrom(\n        address(self.trove),\n        address(this),\n        self.tokenB.balanceOf(address(self.trove))\n      );\n    }\n\n    uint256 _tokenInAmt = IERC20(cp.tokenIn).balanceOf(address(this));\n\n    // Only compound if tokenIn amount is more than 0\n    if (_tokenInAmt > 0) {\n      self.refundee = payable(msg.sender);\n\n      self.compoundCache.compoundParams = cp;\n\n      ISwap.SwapParams memory _sp;\n\n      _sp.tokenIn = cp.tokenIn;\n      _sp.tokenOut = cp.tokenOut;\n      _sp.amountIn = _tokenInAmt;\n      _sp.amountOut = 0; // amount out minimum calculated in Swap\n      _sp.slippage = self.minSlippage;\n      _sp.deadline = cp.deadline;\n\n      GMXManager.swapExactTokensForTokens(self, _sp);\n\n      GMXTypes.AddLiquidityParams memory _alp;\n\n      _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n      _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n\n      self.compoundCache.depositValue = GMXReader.convertToUsdValue(\n        self,\n        address(self.tokenA),\n        self.tokenA.balanceOf(address(this))\n      )\n      + GMXReader.convertToUsdValue(\n        self,\n        address(self.tokenB),\n        self.tokenB.balanceOf(address(this))\n      );\n\n      GMXChecks.beforeCompoundChecks(self);\n\n      self.status = GMXTypes.Status.Compound;\n\n      _alp.minMarketTokenAmt = GMXManager.calcMinMarketSlippageAmt(\n        self,\n        self.compoundCache.depositValue,\n        cp.slippage\n      );\n\n      _alp.executionFee = cp.executionFee;\n\n      self.compoundCache.depositKey = GMXManager.addLiquidity(\n        self,\n        _alp\n      );\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processCompound(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessCompoundChecks(self);\n\n    self.status = GMXTypes.Status.Open;\n\n    emit CompoundCompleted();\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processCompoundCancellation(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessCompoundCancellationChecks(self);\n\n    self.status = GMXTypes.Status.Compound_Failed;\n\n    emit CompoundCancelled();\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXCompound.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\n\n/**\n  * @title GMXCompound\n  * @author Steadefi\n  * @notice Re-usable library functions for compound operations for Steadefi leveraged vaults\n*/\nlibrary GMXCompound {\n  using SafeERC20 for IERC20;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ======================== EVENTS ========================= */\n\n  event CompoundCompleted();\n  event CompoundCancelled();\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function compound(\n    GMXTypes.Store storage self,\n    GMXTypes.CompoundParams memory cp\n  ) external {\n    // Transfer any tokenA/B from trove to vault\n    if (self.tokenA.balanceOf(address(self.trove)) > 0) {\n      self.tokenA.safeTransferFrom(\n        address(self.trove),\n        address(this),\n        self.tokenA.balanceOf(address(self.trove))\n      );\n    }\n    if (self.tokenB.balanceOf(address(self.trove)) > 0) {\n      self.tokenB.safeTransferFrom(\n        address(self.trove),\n        address(this),\n        self.tokenB.balanceOf(address(self.trove))\n      );\n    }\n\n    uint256 _tokenInAmt = IERC20(cp.tokenIn).balanceOf(address(this));\n\n    // Only compound if tokenIn amount is more than 0\n    if (_tokenInAmt > 0) {\n      self.refundee = payable(msg.sender);\n\n      self.compoundCache.compoundParams = cp;\n\n      ISwap.SwapParams memory _sp;\n\n      _sp.tokenIn = cp.tokenIn;\n      _sp.tokenOut = cp.tokenOut;\n      _sp.amountIn = _tokenInAmt;\n      _sp.amountOut = 0; // amount out minimum calculated in Swap\n      _sp.slippage = self.minSlippage;\n      _sp.deadline = cp.deadline;\n\n      GMXManager.swapExactTokensForTokens(self, _sp);\n\n      GMXTypes.AddLiquidityParams memory _alp;\n\n      _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n      _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n\n      self.compoundCache.depositValue = GMXReader.convertToUsdValue(\n        self,\n        address(self.tokenA),\n        self.tokenA.balanceOf(address(this))\n      )\n      + GMXReader.convertToUsdValue(\n        self,\n        address(self.tokenB),\n        self.tokenB.balanceOf(address(this))\n      );\n\n      GMXChecks.beforeCompoundChecks(self);\n\n      self.status = GMXTypes.Status.Compound;\n\n      _alp.minMarketTokenAmt = GMXManager.calcMinMarketSlippageAmt(\n        self,\n        self.compoundCache.depositValue,\n        cp.slippage\n      );\n\n      _alp.executionFee = cp.executionFee;\n\n      self.compoundCache.depositKey = GMXManager.addLiquidity(\n        self,\n        _alp\n      );\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processCompound(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessCompoundChecks(self);\n\n    self.status = GMXTypes.Status.Open;\n\n    emit CompoundCompleted();\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processCompoundCancellation(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessCompoundCancellationChecks(self);\n\n    self.status = GMXTypes.Status.Compound_Failed;\n\n    emit CompoundCancelled();\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXCompound.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\n\n/**\n  * @title GMXCompound\n  * @author Steadefi\n  * @notice Re-usable library functions for compound operations for Steadefi leveraged vaults\n*/\nlibrary GMXCompound {\n  using SafeERC20 for IERC20;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ======================== EVENTS ========================= */\n\n  event CompoundCompleted();\n  event CompoundCancelled();\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function compound(\n    GMXTypes.Store storage self,\n    GMXTypes.CompoundParams memory cp\n  ) external {\n    // Transfer any tokenA/B from trove to vault\n    if (self.tokenA.balanceOf(address(self.trove)) > 0) {\n      self.tokenA.safeTransferFrom(\n        address(self.trove),\n        address(this),\n        self.tokenA.balanceOf(address(self.trove))\n      );\n    }\n    if (self.tokenB.balanceOf(address(self.trove)) > 0) {\n      self.tokenB.safeTransferFrom(\n        address(self.trove),\n        address(this),\n        self.tokenB.balanceOf(address(self.trove))\n      );\n    }\n\n    uint256 _tokenInAmt = IERC20(cp.tokenIn).balanceOf(address(this));\n\n    // Only compound if tokenIn amount is more than 0\n    if (_tokenInAmt > 0) {\n      self.refundee = payable(msg.sender);\n\n      self.compoundCache.compoundParams = cp;\n\n      ISwap.SwapParams memory _sp;\n\n      _sp.tokenIn = cp.tokenIn;\n      _sp.tokenOut = cp.tokenOut;\n      _sp.amountIn = _tokenInAmt;\n      _sp.amountOut = 0; // amount out minimum calculated in Swap\n      _sp.slippage = self.minSlippage;\n      _sp.deadline = cp.deadline;\n\n      GMXManager.swapExactTokensForTokens(self, _sp);\n\n      GMXTypes.AddLiquidityParams memory _alp;\n\n      _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n      _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n\n      self.compoundCache.depositValue = GMXReader.convertToUsdValue(\n        self,\n        address(self.tokenA),\n        self.tokenA.balanceOf(address(this))\n      )\n      + GMXReader.convertToUsdValue(\n        self,\n        address(self.tokenB),\n        self.tokenB.balanceOf(address(this))\n      );\n\n      GMXChecks.beforeCompoundChecks(self);\n\n      self.status = GMXTypes.Status.Compound;\n\n      _alp.minMarketTokenAmt = GMXManager.calcMinMarketSlippageAmt(\n        self,\n        self.compoundCache.depositValue,\n        cp.slippage\n      );\n\n      _alp.executionFee = cp.executionFee;\n\n      self.compoundCache.depositKey = GMXManager.addLiquidity(\n        self,\n        _alp\n      );\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processCompound(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessCompoundChecks(self);\n\n    self.status = GMXTypes.Status.Open;\n\n    emit CompoundCompleted();\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processCompoundCancellation(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessCompoundCancellationChecks(self);\n\n    self.status = GMXTypes.Status.Compound_Failed;\n\n    emit CompoundCancelled();\n  }\n}"
    }
  ]
}