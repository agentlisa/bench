{
  "Title": "[M02] Inputs are not checked in setReserveFraction",
  "Content": "The [`setReserveFraction` function](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/stability/Exchange.sol#L237) of the `Exchange` contract has no checks on its input, which means [it can set `reserveFraction` to values corresponding to a `Fraction` of greater than or less than `1.0`](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/stability/Exchange.sol#L238).\n\n\nIn the function [`getUpdatedGoldBucket`](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/stability/Exchange.sol#L290), the `updatedGoldBucket` is set to [`reserveFraction` multiplied by the unfrozen reserve gold balance](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/stability/Exchange.sol#L292).\n\n\nAccording to the [documentation](https://docs.celo.org/celo-codebase/protocol/stability/doto), “`the Celo Gold bucket must remain smaller than the total reserve gold balance`“. So, it follows that the `reserveFraction` should never be equal to or greater than `1.0`.\n\n\nConsider adding a `require` such that `reserveFraction`‘s value is restricted to being strictly less than `1.0` when being set.\n\n\n***Update:** Fixed in [pull request #3275](https://github.com/celo-org/celo-monorepo/pull/3275).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/stability/Exchange.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"./interfaces/IExchange.sol\";\nimport \"./interfaces/ISortedOracles.sol\";\nimport \"./interfaces/IReserve.sol\";\nimport \"./interfaces/IStableToken.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/FixidityLib.sol\";\nimport \"../common/Freezable.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/libraries/ReentrancyGuard.sol\";\n\n/**\n * @title Contract that allows to exchange StableToken for GoldToken and vice versa\n * using a Constant Product Market Maker Model\n */\ncontract Exchange is IExchange, Initializable, Ownable, UsingRegistry, ReentrancyGuard, Freezable {\n  using SafeMath for uint256;\n  using FixidityLib for FixidityLib.Fraction;\n\n  event Exchanged(address indexed exchanger, uint256 sellAmount, uint256 buyAmount, bool soldGold);\n  event UpdateFrequencySet(uint256 updateFrequency);\n  event MinimumReportsSet(uint256 minimumReports);\n  event StableTokenSet(address stable);\n  event SpreadSet(uint256 spread);\n  event ReserveFractionSet(uint256 reserveFraction);\n\n  FixidityLib.Fraction public spread;\n\n  // Fraction of the Reserve that is committed to the gold bucket when updating\n  // buckets.\n  FixidityLib.Fraction public reserveFraction;\n\n  address public stable;\n\n  // Size of the Uniswap gold bucket\n  uint256 public goldBucket;\n  // Size of the Uniswap stable token bucket\n  uint256 public stableBucket;\n\n  uint256 public lastBucketUpdate = 0;\n  uint256 public updateFrequency;\n  uint256 public minimumReports;\n\n  modifier updateBucketsIfNecessary() {\n    _updateBucketsIfNecessary();\n    _;\n  }\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param registryAddress The address of the registry core smart contract.\n   * @param stableToken Address of the stable token\n   * @param _spread Spread charged on exchanges\n   * @param _reserveFraction Fraction to commit to the gold bucket\n   * @param _updateFrequency The time period that needs to elapse between bucket\n   * updates\n   * @param _minimumReports The minimum number of fresh reports that need to be\n   * present in the oracle to update buckets\n   * commit to the gold bucket\n   */\n  function initialize(\n    address registryAddress,\n    address stableToken,\n    uint256 _spread,\n    uint256 _reserveFraction,\n    uint256 _updateFrequency,\n    uint256 _minimumReports\n  ) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setStableToken(stableToken);\n    setSpread(_spread);\n    setReserveFraction(_reserveFraction);\n    setUpdateFrequency(_updateFrequency);\n    setMinimumReports(_minimumReports);\n    _updateBucketsIfNecessary();\n  }\n\n  /**\n   * @dev Exchanges sellAmount of sellToken in exchange for at least minBuyAmount of buyToken\n   * Requires the sellAmount to have been approved to the exchange\n   * @param sellAmount The amount of sellToken the user is selling to the exchange\n   * @param minBuyAmount The minimum amount of buyToken the user has to receive for this\n   * transaction to succeed\n   * @param sellGold `true` if gold is the sell token\n   * @return The amount of buyToken that was transfered\n   * @dev This function can be frozen using the Freezable interface.\n   */\n  function exchange(uint256 sellAmount, uint256 minBuyAmount, bool sellGold)\n    external\n    onlyWhenNotFrozen\n    updateBucketsIfNecessary\n    nonReentrant\n    returns (uint256)\n  {\n    uint256 buyAmount = _getBuyTokenAmount(sellAmount, sellGold);\n\n    require(buyAmount >= minBuyAmount, \"Calculated buyAmount was less than specified minBuyAmount\");\n\n    IReserve reserve = IReserve(registry.getAddressForOrDie(RESERVE_REGISTRY_ID));\n\n    if (sellGold) {\n      goldBucket = goldBucket.add(sellAmount);\n      stableBucket = stableBucket.sub(buyAmount);\n      require(\n        getGoldToken().transferFrom(msg.sender, address(reserve), sellAmount),\n        \"Transfer of sell token failed\"\n      );\n      require(IStableToken(stable).mint(msg.sender, buyAmount), \"Mint of stable token failed\");\n    } else {\n      stableBucket = stableBucket.add(sellAmount);\n      goldBucket = goldBucket.sub(buyAmount);\n      require(\n        IERC20(stable).transferFrom(msg.sender, address(this), sellAmount),\n        \"Transfer of sell token failed\"\n      );\n      IStableToken(stable).burn(sellAmount);\n\n      require(reserve.transferExchangeGold(msg.sender, buyAmount), \"Transfer of buyToken failed\");\n    }\n\n    emit Exchanged(msg.sender, sellAmount, buyAmount, sellGold);\n    return buyAmount;\n  }\n\n  /**\n   * @dev Returns the amount of buyToken a user would get for sellAmount of sellToken\n   * @param sellAmount The amount of sellToken the user is selling to the exchange\n   * @param sellGold `true` if gold is the sell token\n   * @return The corresponding buyToken amount.\n   */\n  function getBuyTokenAmount(uint256 sellAmount, bool sellGold) external view returns (uint256) {\n    uint256 sellTokenBucket;\n    uint256 buyTokenBucket;\n    (buyTokenBucket, sellTokenBucket) = getBuyAndSellBuckets(sellGold);\n\n    FixidityLib.Fraction memory reducedSellAmount = getReducedSellAmount(sellAmount);\n    FixidityLib.Fraction memory numerator = reducedSellAmount.multiply(\n      FixidityLib.newFixed(buyTokenBucket)\n    );\n    FixidityLib.Fraction memory denominator = FixidityLib.newFixed(sellTokenBucket).add(\n      reducedSellAmount\n    );\n\n    // Can't use FixidityLib.divide because denominator can easily be greater\n    // than maxFixedDivisor.\n    // Fortunately, we expect an integer result, so integer division gives us as\n    // much precision as we could hope for.\n    return numerator.unwrap().div(denominator.unwrap());\n  }\n\n  /**\n   * @dev Returns the amount of sellToken a user would need to exchange to receive buyAmount of\n   * buyToken.\n   * @param buyAmount The amount of buyToken the user would like to purchase.\n   * @param sellGold `true` if gold is the sell token\n   * @return The corresponding sellToken amount.\n   */\n  function getSellTokenAmount(uint256 buyAmount, bool sellGold) external view returns (uint256) {\n    uint256 sellTokenBucket;\n    uint256 buyTokenBucket;\n    (buyTokenBucket, sellTokenBucket) = getBuyAndSellBuckets(sellGold);\n\n    FixidityLib.Fraction memory numerator = FixidityLib.newFixed(buyAmount.mul(sellTokenBucket));\n    FixidityLib.Fraction memory denominator = FixidityLib\n      .newFixed(buyTokenBucket.sub(buyAmount))\n      .multiply(FixidityLib.fixed1().subtract(spread));\n\n    // See comment in getBuyTokenAmount\n    return numerator.unwrap().div(denominator.unwrap());\n  }\n\n  /**\n   * @notice Returns the buy token and sell token bucket sizes, in order. The ratio of\n   * the two also represents the exchange rate between the two.\n   * @param sellGold `true` if gold is the sell token\n   * @return (buyTokenBucket, sellTokenBucket)\n   */\n  function getBuyAndSellBuckets(bool sellGold) public view returns (uint256, uint256) {\n    uint256 currentGoldBucket = goldBucket;\n    uint256 currentStableBucket = stableBucket;\n\n    if (shouldUpdateBuckets()) {\n      (currentGoldBucket, currentStableBucket) = getUpdatedBuckets();\n    }\n\n    if (sellGold) {\n      return (currentStableBucket, currentGoldBucket);\n    } else {\n      return (currentGoldBucket, currentStableBucket);\n    }\n  }\n\n  /**\n    * @notice Allows owner to set the update frequency\n    * @param newUpdateFrequency The new update frequency\n    */\n  function setUpdateFrequency(uint256 newUpdateFrequency) public onlyOwner {\n    updateFrequency = newUpdateFrequency;\n    emit UpdateFrequencySet(newUpdateFrequency);\n  }\n\n  /**\n    * @notice Allows owner to set the minimum number of reports required\n    * @param newMininumReports The new update minimum number of reports required\n    */\n  function setMinimumReports(uint256 newMininumReports) public onlyOwner {\n    minimumReports = newMininumReports;\n    emit MinimumReportsSet(newMininumReports);\n  }\n\n  /**\n    * @notice Allows owner to set the Stable Token address\n    * @param newStableToken The new address for Stable Token\n    */\n  function setStableToken(address newStableToken) public onlyOwner {\n    stable = newStableToken;\n    emit StableTokenSet(newStableToken);\n  }\n\n  /**\n    * @notice Allows owner to set the spread\n    * @param newSpread The new value for the spread\n    */\n  function setSpread(uint256 newSpread) public onlyOwner {\n    spread = FixidityLib.wrap(newSpread);\n    emit SpreadSet(newSpread);\n  }\n\n  /**\n    * @notice Allows owner to set the Reserve Fraction\n    * @param newReserveFraction The new value for the reserve fraction\n    */\n  function setReserveFraction(uint256 newReserveFraction) public onlyOwner {\n    reserveFraction = FixidityLib.wrap(newReserveFraction);\n    emit ReserveFractionSet(newReserveFraction);\n  }\n\n  /**\n   * @notice Returns the sell token and buy token bucket sizes, in order. The ratio of\n   * the two also represents the exchange rate between the two.\n   * @param sellGold `true` if gold is the sell token\n   * @return (sellTokenBucket, buyTokenBucket)\n   */\n  function _getBuyAndSellBuckets(bool sellGold) private view returns (uint256, uint256) {\n    if (sellGold) {\n      return (stableBucket, goldBucket);\n    } else {\n      return (goldBucket, stableBucket);\n    }\n  }\n\n  /**\n   * @dev Returns the amount of buyToken a user would get for sellAmount of sellToken\n   * @param sellAmount The amount of sellToken the user is selling to the exchange\n   * @param sellGold `true` if gold is the sell token\n   * @return The corresponding buyToken amount.\n   */\n  function _getBuyTokenAmount(uint256 sellAmount, bool sellGold) private view returns (uint256) {\n    uint256 sellTokenBucket;\n    uint256 buyTokenBucket;\n    (buyTokenBucket, sellTokenBucket) = _getBuyAndSellBuckets(sellGold);\n\n    FixidityLib.Fraction memory reducedSellAmount = getReducedSellAmount(sellAmount);\n    FixidityLib.Fraction memory numerator = reducedSellAmount.multiply(\n      FixidityLib.newFixed(buyTokenBucket)\n    );\n    FixidityLib.Fraction memory denominator = FixidityLib.newFixed(sellTokenBucket).add(\n      reducedSellAmount\n    );\n\n    // See comment in getBuyTokenAmount\n    return numerator.unwrap().div(denominator.unwrap());\n  }\n\n  function getUpdatedBuckets() private view returns (uint256, uint256) {\n    uint256 updatedGoldBucket = getUpdatedGoldBucket();\n    uint256 exchangeRateNumerator;\n    uint256 exchangeRateDenominator;\n    (exchangeRateNumerator, exchangeRateDenominator) = getOracleExchangeRate();\n    uint256 updatedStableBucket = exchangeRateNumerator.mul(updatedGoldBucket).div(\n      exchangeRateDenominator\n    );\n    return (updatedGoldBucket, updatedStableBucket);\n  }\n\n  function getUpdatedGoldBucket() private view returns (uint256) {\n    uint256 reserveGoldBalance = getReserve().getUnfrozenReserveGoldBalance();\n    return reserveFraction.multiply(FixidityLib.newFixed(reserveGoldBalance)).fromFixed();\n  }\n\n  /**\n   * @notice If conditions are met, updates the Uniswap bucket sizes to track\n   * the price reported by the Oracle.\n   */\n  function _updateBucketsIfNecessary() private {\n    if (shouldUpdateBuckets()) {\n      // solhint-disable-next-line not-rely-on-time\n      lastBucketUpdate = now;\n\n      (goldBucket, stableBucket) = getUpdatedBuckets();\n    }\n  }\n\n  /**\n   * @dev Calculates the sell amount reduced by the spread.\n   * @param sellAmount The original sell amount.\n   * @return The reduced sell amount, computed as (1 - spread) * sellAmount\n   */\n  function getReducedSellAmount(uint256 sellAmount)\n    private\n    view\n    returns (FixidityLib.Fraction memory)\n  {\n    return FixidityLib.fixed1().subtract(spread).multiply(FixidityLib.newFixed(sellAmount));\n  }\n\n  /*\n   * Checks conditions required for bucket updates.\n   * @return Whether or not buckets should be updated.\n   */\n  function shouldUpdateBuckets() private view returns (bool) {\n    ISortedOracles sortedOracles = ISortedOracles(\n      registry.getAddressForOrDie(SORTED_ORACLES_REGISTRY_ID)\n    );\n    (bool isReportExpired, ) = sortedOracles.isOldestReportExpired(stable);\n    // solhint-disable-next-line not-rely-on-time\n    bool timePassed = now >= lastBucketUpdate.add(updateFrequency);\n    bool enoughReports = sortedOracles.numRates(stable) >= minimumReports;\n    // solhint-disable-next-line not-rely-on-time\n    bool medianReportRecent = sortedOracles.medianTimestamp(stable) > now.sub(updateFrequency);\n    return timePassed && enoughReports && medianReportRecent && !isReportExpired;\n  }\n\n  function getOracleExchangeRate() private view returns (uint256, uint256) {\n    uint256 rateNumerator;\n    uint256 rateDenominator;\n    (rateNumerator, rateDenominator) = ISortedOracles(\n      registry.getAddressForOrDie(SORTED_ORACLES_REGISTRY_ID)\n    )\n      .medianRate(stable);\n    return (rateNumerator, rateDenominator);\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/stability/Exchange.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"./interfaces/IExchange.sol\";\nimport \"./interfaces/ISortedOracles.sol\";\nimport \"./interfaces/IReserve.sol\";\nimport \"./interfaces/IStableToken.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/FixidityLib.sol\";\nimport \"../common/Freezable.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/libraries/ReentrancyGuard.sol\";\n\n/**\n * @title Contract that allows to exchange StableToken for GoldToken and vice versa\n * using a Constant Product Market Maker Model\n */\ncontract Exchange is IExchange, Initializable, Ownable, UsingRegistry, ReentrancyGuard, Freezable {\n  using SafeMath for uint256;\n  using FixidityLib for FixidityLib.Fraction;\n\n  event Exchanged(address indexed exchanger, uint256 sellAmount, uint256 buyAmount, bool soldGold);\n  event UpdateFrequencySet(uint256 updateFrequency);\n  event MinimumReportsSet(uint256 minimumReports);\n  event StableTokenSet(address stable);\n  event SpreadSet(uint256 spread);\n  event ReserveFractionSet(uint256 reserveFraction);\n\n  FixidityLib.Fraction public spread;\n\n  // Fraction of the Reserve that is committed to the gold bucket when updating\n  // buckets.\n  FixidityLib.Fraction public reserveFraction;\n\n  address public stable;\n\n  // Size of the Uniswap gold bucket\n  uint256 public goldBucket;\n  // Size of the Uniswap stable token bucket\n  uint256 public stableBucket;\n\n  uint256 public lastBucketUpdate = 0;\n  uint256 public updateFrequency;\n  uint256 public minimumReports;\n\n  modifier updateBucketsIfNecessary() {\n    _updateBucketsIfNecessary();\n    _;\n  }\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param registryAddress The address of the registry core smart contract.\n   * @param stableToken Address of the stable token\n   * @param _spread Spread charged on exchanges\n   * @param _reserveFraction Fraction to commit to the gold bucket\n   * @param _updateFrequency The time period that needs to elapse between bucket\n   * updates\n   * @param _minimumReports The minimum number of fresh reports that need to be\n   * present in the oracle to update buckets\n   * commit to the gold bucket\n   */\n  function initialize(\n    address registryAddress,\n    address stableToken,\n    uint256 _spread,\n    uint256 _reserveFraction,\n    uint256 _updateFrequency,\n    uint256 _minimumReports\n  ) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setStableToken(stableToken);\n    setSpread(_spread);\n    setReserveFraction(_reserveFraction);\n    setUpdateFrequency(_updateFrequency);\n    setMinimumReports(_minimumReports);\n    _updateBucketsIfNecessary();\n  }\n\n  /**\n   * @dev Exchanges sellAmount of sellToken in exchange for at least minBuyAmount of buyToken\n   * Requires the sellAmount to have been approved to the exchange\n   * @param sellAmount The amount of sellToken the user is selling to the exchange\n   * @param minBuyAmount The minimum amount of buyToken the user has to receive for this\n   * transaction to succeed\n   * @param sellGold `true` if gold is the sell token\n   * @return The amount of buyToken that was transfered\n   * @dev This function can be frozen using the Freezable interface.\n   */\n  function exchange(uint256 sellAmount, uint256 minBuyAmount, bool sellGold)\n    external\n    onlyWhenNotFrozen\n    updateBucketsIfNecessary\n    nonReentrant\n    returns (uint256)\n  {\n    uint256 buyAmount = _getBuyTokenAmount(sellAmount, sellGold);\n\n    require(buyAmount >= minBuyAmount, \"Calculated buyAmount was less than specified minBuyAmount\");\n\n    IReserve reserve = IReserve(registry.getAddressForOrDie(RESERVE_REGISTRY_ID));\n\n    if (sellGold) {\n      goldBucket = goldBucket.add(sellAmount);\n      stableBucket = stableBucket.sub(buyAmount);\n      require(\n        getGoldToken().transferFrom(msg.sender, address(reserve), sellAmount),\n        \"Transfer of sell token failed\"\n      );\n      require(IStableToken(stable).mint(msg.sender, buyAmount), \"Mint of stable token failed\");\n    } else {\n      stableBucket = stableBucket.add(sellAmount);\n      goldBucket = goldBucket.sub(buyAmount);\n      require(\n        IERC20(stable).transferFrom(msg.sender, address(this), sellAmount),\n        \"Transfer of sell token failed\"\n      );\n      IStableToken(stable).burn(sellAmount);\n\n      require(reserve.transferExchangeGold(msg.sender, buyAmount), \"Transfer of buyToken failed\");\n    }\n\n    emit Exchanged(msg.sender, sellAmount, buyAmount, sellGold);\n    return buyAmount;\n  }\n\n  /**\n   * @dev Returns the amount of buyToken a user would get for sellAmount of sellToken\n   * @param sellAmount The amount of sellToken the user is selling to the exchange\n   * @param sellGold `true` if gold is the sell token\n   * @return The corresponding buyToken amount.\n   */\n  function getBuyTokenAmount(uint256 sellAmount, bool sellGold) external view returns (uint256) {\n    uint256 sellTokenBucket;\n    uint256 buyTokenBucket;\n    (buyTokenBucket, sellTokenBucket) = getBuyAndSellBuckets(sellGold);\n\n    FixidityLib.Fraction memory reducedSellAmount = getReducedSellAmount(sellAmount);\n    FixidityLib.Fraction memory numerator = reducedSellAmount.multiply(\n      FixidityLib.newFixed(buyTokenBucket)\n    );\n    FixidityLib.Fraction memory denominator = FixidityLib.newFixed(sellTokenBucket).add(\n      reducedSellAmount\n    );\n\n    // Can't use FixidityLib.divide because denominator can easily be greater\n    // than maxFixedDivisor.\n    // Fortunately, we expect an integer result, so integer division gives us as\n    // much precision as we could hope for.\n    return numerator.unwrap().div(denominator.unwrap());\n  }\n\n  /**\n   * @dev Returns the amount of sellToken a user would need to exchange to receive buyAmount of\n   * buyToken.\n   * @param buyAmount The amount of buyToken the user would like to purchase.\n   * @param sellGold `true` if gold is the sell token\n   * @return The corresponding sellToken amount.\n   */\n  function getSellTokenAmount(uint256 buyAmount, bool sellGold) external view returns (uint256) {\n    uint256 sellTokenBucket;\n    uint256 buyTokenBucket;\n    (buyTokenBucket, sellTokenBucket) = getBuyAndSellBuckets(sellGold);\n\n    FixidityLib.Fraction memory numerator = FixidityLib.newFixed(buyAmount.mul(sellTokenBucket));\n    FixidityLib.Fraction memory denominator = FixidityLib\n      .newFixed(buyTokenBucket.sub(buyAmount))\n      .multiply(FixidityLib.fixed1().subtract(spread));\n\n    // See comment in getBuyTokenAmount\n    return numerator.unwrap().div(denominator.unwrap());\n  }\n\n  /**\n   * @notice Returns the buy token and sell token bucket sizes, in order. The ratio of\n   * the two also represents the exchange rate between the two.\n   * @param sellGold `true` if gold is the sell token\n   * @return (buyTokenBucket, sellTokenBucket)\n   */\n  function getBuyAndSellBuckets(bool sellGold) public view returns (uint256, uint256) {\n    uint256 currentGoldBucket = goldBucket;\n    uint256 currentStableBucket = stableBucket;\n\n    if (shouldUpdateBuckets()) {\n      (currentGoldBucket, currentStableBucket) = getUpdatedBuckets();\n    }\n\n    if (sellGold) {\n      return (currentStableBucket, currentGoldBucket);\n    } else {\n      return (currentGoldBucket, currentStableBucket);\n    }\n  }\n\n  /**\n    * @notice Allows owner to set the update frequency\n    * @param newUpdateFrequency The new update frequency\n    */\n  function setUpdateFrequency(uint256 newUpdateFrequency) public onlyOwner {\n    updateFrequency = newUpdateFrequency;\n    emit UpdateFrequencySet(newUpdateFrequency);\n  }\n\n  /**\n    * @notice Allows owner to set the minimum number of reports required\n    * @param newMininumReports The new update minimum number of reports required\n    */\n  function setMinimumReports(uint256 newMininumReports) public onlyOwner {\n    minimumReports = newMininumReports;\n    emit MinimumReportsSet(newMininumReports);\n  }\n\n  /**\n    * @notice Allows owner to set the Stable Token address\n    * @param newStableToken The new address for Stable Token\n    */\n  function setStableToken(address newStableToken) public onlyOwner {\n    stable = newStableToken;\n    emit StableTokenSet(newStableToken);\n  }\n\n  /**\n    * @notice Allows owner to set the spread\n    * @param newSpread The new value for the spread\n    */\n  function setSpread(uint256 newSpread) public onlyOwner {\n    spread = FixidityLib.wrap(newSpread);\n    emit SpreadSet(newSpread);\n  }\n\n  /**\n    * @notice Allows owner to set the Reserve Fraction\n    * @param newReserveFraction The new value for the reserve fraction\n    */\n  function setReserveFraction(uint256 newReserveFraction) public onlyOwner {\n    reserveFraction = FixidityLib.wrap(newReserveFraction);\n    emit ReserveFractionSet(newReserveFraction);\n  }\n\n  /**\n   * @notice Returns the sell token and buy token bucket sizes, in order. The ratio of\n   * the two also represents the exchange rate between the two.\n   * @param sellGold `true` if gold is the sell token\n   * @return (sellTokenBucket, buyTokenBucket)\n   */\n  function _getBuyAndSellBuckets(bool sellGold) private view returns (uint256, uint256) {\n    if (sellGold) {\n      return (stableBucket, goldBucket);\n    } else {\n      return (goldBucket, stableBucket);\n    }\n  }\n\n  /**\n   * @dev Returns the amount of buyToken a user would get for sellAmount of sellToken\n   * @param sellAmount The amount of sellToken the user is selling to the exchange\n   * @param sellGold `true` if gold is the sell token\n   * @return The corresponding buyToken amount.\n   */\n  function _getBuyTokenAmount(uint256 sellAmount, bool sellGold) private view returns (uint256) {\n    uint256 sellTokenBucket;\n    uint256 buyTokenBucket;\n    (buyTokenBucket, sellTokenBucket) = _getBuyAndSellBuckets(sellGold);\n\n    FixidityLib.Fraction memory reducedSellAmount = getReducedSellAmount(sellAmount);\n    FixidityLib.Fraction memory numerator = reducedSellAmount.multiply(\n      FixidityLib.newFixed(buyTokenBucket)\n    );\n    FixidityLib.Fraction memory denominator = FixidityLib.newFixed(sellTokenBucket).add(\n      reducedSellAmount\n    );\n\n    // See comment in getBuyTokenAmount\n    return numerator.unwrap().div(denominator.unwrap());\n  }\n\n  function getUpdatedBuckets() private view returns (uint256, uint256) {\n    uint256 updatedGoldBucket = getUpdatedGoldBucket();\n    uint256 exchangeRateNumerator;\n    uint256 exchangeRateDenominator;\n    (exchangeRateNumerator, exchangeRateDenominator) = getOracleExchangeRate();\n    uint256 updatedStableBucket = exchangeRateNumerator.mul(updatedGoldBucket).div(\n      exchangeRateDenominator\n    );\n    return (updatedGoldBucket, updatedStableBucket);\n  }\n\n  function getUpdatedGoldBucket() private view returns (uint256) {\n    uint256 reserveGoldBalance = getReserve().getUnfrozenReserveGoldBalance();\n    return reserveFraction.multiply(FixidityLib.newFixed(reserveGoldBalance)).fromFixed();\n  }\n\n  /**\n   * @notice If conditions are met, updates the Uniswap bucket sizes to track\n   * the price reported by the Oracle.\n   */\n  function _updateBucketsIfNecessary() private {\n    if (shouldUpdateBuckets()) {\n      // solhint-disable-next-line not-rely-on-time\n      lastBucketUpdate = now;\n\n      (goldBucket, stableBucket) = getUpdatedBuckets();\n    }\n  }\n\n  /**\n   * @dev Calculates the sell amount reduced by the spread.\n   * @param sellAmount The original sell amount.\n   * @return The reduced sell amount, computed as (1 - spread) * sellAmount\n   */\n  function getReducedSellAmount(uint256 sellAmount)\n    private\n    view\n    returns (FixidityLib.Fraction memory)\n  {\n    return FixidityLib.fixed1().subtract(spread).multiply(FixidityLib.newFixed(sellAmount));\n  }\n\n  /*\n   * Checks conditions required for bucket updates.\n   * @return Whether or not buckets should be updated.\n   */\n  function shouldUpdateBuckets() private view returns (bool) {\n    ISortedOracles sortedOracles = ISortedOracles(\n      registry.getAddressForOrDie(SORTED_ORACLES_REGISTRY_ID)\n    );\n    (bool isReportExpired, ) = sortedOracles.isOldestReportExpired(stable);\n    // solhint-disable-next-line not-rely-on-time\n    bool timePassed = now >= lastBucketUpdate.add(updateFrequency);\n    bool enoughReports = sortedOracles.numRates(stable) >= minimumReports;\n    // solhint-disable-next-line not-rely-on-time\n    bool medianReportRecent = sortedOracles.medianTimestamp(stable) > now.sub(updateFrequency);\n    return timePassed && enoughReports && medianReportRecent && !isReportExpired;\n  }\n\n  function getOracleExchangeRate() private view returns (uint256, uint256) {\n    uint256 rateNumerator;\n    uint256 rateDenominator;\n    (rateNumerator, rateDenominator) = ISortedOracles(\n      registry.getAddressForOrDie(SORTED_ORACLES_REGISTRY_ID)\n    )\n      .medianRate(stable);\n    return (rateNumerator, rateDenominator);\n  }\n}"
    }
  ]
}