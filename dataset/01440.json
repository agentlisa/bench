{
  "Title": "Missing Events ",
  "Content": "# Missing Events \n\n### Severity\nLow Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-08-sparkn/blob/47c22b818818af4ea7388118dd83fa308ad67b83/src/Distributor.sol#L163\">https://github.com/Cyfrin/2023-08-sparkn/blob/47c22b818818af4ea7388118dd83fa308ad67b83/src/Distributor.sol#L163</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-08-sparkn/blob/47c22b818818af4ea7388118dd83fa308ad67b83/src/ProxyFactory.sol#L58\">https://github.com/Cyfrin/2023-08-sparkn/blob/47c22b818818af4ea7388118dd83fa308ad67b83/src/ProxyFactory.sol#L58</a>\n\n\n## Summary\nThere are some critical functionalities that are missing events \n\n## Vulnerability Details\n1. [Distributor.sol line 163 function _commissionTransfer(IERC20 token)](https://github.com/Cyfrin/2023-08-sparkn/blob/0f139b2dc53905700dd29a01451b330f829653e9/src/Distributor.sol#L163)  should emit its own event, especially given that commissions transfers occur after distribution to winners. Its a critical function that can report to offchain tooling the commissions going to STADIUM at every moment \n\n2. ProxyFactory.sol all deploy and distribute functions in the contract emit Distributed event. This is not truly reflective of happenings as they are different and events should reflect differences. The functions should emit specific events related to them e.g \n- deployProxyAndDistributeByOwner //should differentiate that organizer not around so owner called this by having event with owner and organizer details emitted \n- distributeByOwner // should differentiate that organizer called it , important information like above \n- deployProxyAndDistribute \nare all functions with different intricacies and dynamics that can be captured by adding additional event or updating Distributed event to capture these differences \n\n## Impact\nThis shortchanges various offchain tooling, monitoring, reporting, frontend services that may rely on events to adequately capture real time activities of the contracts. It may even be critical for security monitoring so project can respond adequately if events sufficiently detailed and informative. Any emissions suspicious can allow protocol to react quickly \n\n## Tools Used\nManual Analysis \n\n## Recommendations\nRecommended to add events for the cases detailed above e.g \nDistributeByOrganizer, DistributedSignature, DistributedOwner or keep Distributed and add other specific events in function e.g BySignatureEvent in function deployProxyAndDistributeBySignature() etc \n",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/cllcnja1h0001lc08z7w0orxx",
  "Code": [
    {
      "filename": "src/Distributor.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n// Layout of Contract:\n// version\n// imports\n// errors\n// interfaces, libraries, contracts\n// Type declarations\n// State variables\n// Events\n// Modifiers\n// Functions\n\n// Layout of Functions:\n// constructor\n// receive function (if exists)\n// fallback function (if exists)\n// external\n// public\n// internal\n// private\n// view & pure functions\n\npragma solidity 0.8.18;\n\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport {ProxyFactory} from \"./ProxyFactory.sol\";\n\n/**\n * @title Distributor contract\n * @notice General ERC20 stable coin tokens, e.g. JPYC, USDC, USDT, DAI, etc, are suppsoed to be used in SPARKN.\n * @notice This contract is used as the implementation of proxy contracts to distribute ERC20 token(e.g. JPYC) to winners\n * @dev The main logic of prize token distribution sits in this contract waiting to be called by factory contract\n * @dev Although the contract is immutable after deployment, If we want to upgrade the implementation contract\n * we can deploy a new one and change the implementation address of proxy contract.\n */\ncontract Distributor {\n    using SafeERC20 for IERC20;\n    //////////////////////\n    /////// Error ////////\n    //////////////////////\n\n    error Distributor__InvalidCommissionFee();\n    error Distributor__NoZeroAddress();\n    error Distributor__OnlyFactoryAddressIsAllowed();\n    error Distributor__InvalidTokenAddress();\n    error Distributor__MismatchedArrays();\n    error Distributor__MismatchedPercentages();\n    error Distributor__NoTokenToDistribute();\n\n    //////////////////////////////////////\n    /////// Immutable Variables //////////\n    //////////////////////////////////////\n    /* solhint-disable */\n    uint8 private constant VERSION = 1; // version is 1 for now\n    address private immutable FACTORY_ADDRESS;\n    address private immutable STADIUM_ADDRESS;\n    uint256 private constant COMMISSION_FEE = 500; // this can be changed in the future\n    // a constant value of 10,000 (basis points) = 100%\n    uint256 private constant BASIS_POINTS = 10000;\n\n    // prize distribution event. data is for logging purpose\n    event Distributed(address token, address[] winners, uint256[] percentages, bytes data);\n\n    ////////////////////////////\n    /////// Constructor ////////\n    ////////////////////////////\n    /// @dev initiate the contract with factory address and other key addresses, fee rate\n    constructor(\n        // uint256 version, // for future use\n        address factoryAddress,\n        address stadiumAddress\n    ) \n    /* solhint-enable */\n    {\n        if (factoryAddress == address(0) || stadiumAddress == address(0)) revert Distributor__NoZeroAddress();\n        FACTORY_ADDRESS = factoryAddress; // initialize with deployed factory address beforehand\n        STADIUM_ADDRESS = stadiumAddress; // official address to receive commission fee\n    }\n\n    ////////////////////////////////////////////\n    /////// External & Public functions ////////\n    ////////////////////////////////////////////\n    /**\n     * @notice Distribute token to winners according to the percentages\n     * @dev Only factory contract can call this function\n     * @param token The token address to distribute\n     * @param winners The addresses array of winners\n     * @param percentages The percentages array of winners\n     */\n    function distribute(address token, address[] memory winners, uint256[] memory percentages, bytes memory data)\n        external\n    {\n        if (msg.sender != FACTORY_ADDRESS) {\n            revert Distributor__OnlyFactoryAddressIsAllowed();\n        }\n        _distribute(token, winners, percentages, data);\n    }\n\n    ////////////////////////////////////////////\n    /////// Internal & Private functions ///////\n    ////////////////////////////////////////////\n    /**\n     * @notice An internal function to distribute JPYC to winners\n     * @dev Main logic of distribution is implemented here. The length of winners and percentages must be the same\n     * The token address must be one of the whitelisted tokens\n     * The winners and percentages array are supposed not to be so long, so the loop can stay unbounded\n     * The total percentage must be correct. It must be (100 - COMMITION_FEE).\n     * Finally send the remained token(fee) to STADIUM_ADDRESS with no dust in the contract\n     * @param token The token address\n     * @param winners The addresses of winners\n     * @param percentages The percentages of winners\n     * @param data The data to be logged. It is supposed to be used for showing the realation bbetween winners and proposals.\n     */\n    function _distribute(address token, address[] memory winners, uint256[] memory percentages, bytes memory data)\n        internal\n    {\n        // token address input check\n        if (token == address(0)) revert Distributor__NoZeroAddress();\n        if (!_isWhiteListed(token)) {\n            revert Distributor__InvalidTokenAddress();\n        }\n        // winners and percentages input check\n        if (winners.length == 0 || winners.length != percentages.length) revert Distributor__MismatchedArrays();\n        uint256 percentagesLength = percentages.length;\n        uint256 totalPercentage;\n        for (uint256 i; i < percentagesLength;) {\n            totalPercentage += percentages[i];\n            unchecked {\n                ++i;\n            }\n        }\n        // check if totalPercentage is correct\n        if (totalPercentage != (10000 - COMMISSION_FEE)) {\n            revert Distributor__MismatchedPercentages();\n        }\n        IERC20 erc20 = IERC20(token);\n        uint256 totalAmount = erc20.balanceOf(address(this));\n\n        // if there is no token to distribute, then revert\n        if (totalAmount == 0) revert Distributor__NoTokenToDistribute();\n\n        uint256 winnersLength = winners.length; // cache length\n        for (uint256 i; i < winnersLength;) {\n            uint256 amount = totalAmount * percentages[i] / BASIS_POINTS;\n            erc20.safeTransfer(winners[i], amount);\n            unchecked {\n                ++i;\n            }\n        }\n\n        // send commission fee as well as all the remaining tokens to STADIUM_ADDRESS to avoid dust remaining\n        _commissionTransfer(erc20);\n        emit Distributed(token, winners, percentages, data);\n    }\n\n    /**\n     * @notice Transfer commission fee to STADIUM_ADDRESS\n     * @dev This internal function is called after distribution in `_distribute` function\n     * @param token The token address\n     */\n    function _commissionTransfer(IERC20 token) internal {\n        token.safeTransfer(STADIUM_ADDRESS, token.balanceOf(address(this)));\n    }\n\n    /**\n     * @dev Check if the token is whitelisted. calling FACTORY_ADDRESS\n     * @param token The token address\n     * @return true if the token is whitelisted, vice versa\n     */\n    function _isWhiteListed(address token) internal view returns (bool) {\n        return ProxyFactory(FACTORY_ADDRESS).whitelistedTokens(token);\n    }\n\n    ///////////////////////////////////////////\n    /////// Getter pure/view functions ////////\n    ///////////////////////////////////////////\n    /**\n     * @notice returns all the immutable and constant addresses and values\n     * @dev This function is for convenience to check the addresses and values\n     */\n    function getConstants()\n        external\n        view\n        returns (address _FACTORY_ADDRESS, address _STADIUM_ADDRESS, uint256 _COMMISSION_FEE, uint8 _VERSION)\n    {\n        /* solhint-disable */\n        _FACTORY_ADDRESS = FACTORY_ADDRESS;\n        _STADIUM_ADDRESS = STADIUM_ADDRESS;\n        _COMMISSION_FEE = COMMISSION_FEE;\n        _VERSION = VERSION;\n        /* solhint-enable */\n    }\n}"
    },
    {
      "filename": "src/ProxyFactory.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n// Layout of Contract:\n// version\n// imports\n// errors\n// interfaces, libraries, contracts\n// Type declarations\n// State variables\n// Events\n// Modifiers\n// Functions\n\n// Layout of Functions:\n// constructor\n// receive function (if exists)\n// fallback function (if exists)\n// external\n// public\n// internal\n// private\n// view & pure functions\n\npragma solidity 0.8.18;\n\nimport {Ownable} from \"openzeppelin/access/Ownable.sol\";\nimport {ECDSA} from \"openzeppelin/utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"openzeppelin/utils/cryptography/EIP712.sol\";\nimport {Proxy} from \"./Proxy.sol\";\n\n/**\n * @title ProxyFactory contract\n * @notice This contract is the main entry point for users to use SPARKN's contracts.\n * @notice It will be used to deploy proxy contracts for every contest in SPARKN.\n * @dev This contract is the factory contract which will be used to deploy proxy contracts.\n */\ncontract ProxyFactory is Ownable, EIP712 {\n    //////////////////////\n    /////// Error ////////\n    //////////////////////\n    error ProxyFactory__NoEmptyArray();\n    error ProxyFactory__NoZeroAddress();\n    error ProxyFactory__CloseTimeNotInRange();\n    error ProxyFactory__InvalidSignature();\n    error ProxyFactory__ContestIsAlreadyRegistered();\n    error ProxyFactory__ContestIsNotClosed();\n    error ProxyFactory__ContestIsNotRegistered();\n    error ProxyFactory__ContestIsNotExpired();\n    error ProxyFactory__DelegateCallFailed();\n    error ProxyFactory__ProxyAddressCannotBeZero();\n\n    /////////////////////\n    /////// Event ///////\n    /////////////////////\n    event SetContest(\n        address indexed organizer, bytes32 indexed contestId, uint256 closeTime, address indexed implementation\n    );\n    event Distributed(address indexed proxy, bytes data);\n\n    ////////////////////////////////\n    /////// State Variables ////////\n    ////////////////////////////////\n    // contest distribution expiration\n    uint256 public constant EXPIRATION_TIME = 7 days;\n    uint256 public constant MAX_CONTEST_PERIOD = 28 days;\n\n    /// @notice record contest close time by salt\n    /// @dev The contest doesn't exist when value is 0\n    mapping(bytes32 => uint256) public saltToCloseTime;\n    /// @dev record whitelisted tokens\n    mapping(address => bool) public whitelistedTokens;\n\n    ////////////////////////////\n    /////// Constructor ////////\n    ////////////////////////////\n    /**\n     * @notice The constructor will set the whitelist tokens. e.g. USDC, JPYCv1, JPYCv2, USDT, DAI\n     * @notice the array is not supposed to be so long because only major tokens will get listed\n     * @param _whitelistedTokens The tokens array to get whitelisted\n     */\n    constructor(address[] memory _whitelistedTokens) EIP712(\"ProxyFactory\", \"1\") Ownable() {\n        if (_whitelistedTokens.length == 0) revert ProxyFactory__NoEmptyArray();\n        for (uint256 i; i < _whitelistedTokens.length;) {\n            if (_whitelistedTokens[i] == address(0)) revert ProxyFactory__NoZeroAddress();\n            whitelistedTokens[_whitelistedTokens[i]] = true;\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    ////////////////////////////////////////////\n    /////// External & Public functions ////////\n    ////////////////////////////////////////////\n    /**\n     * @notice Only owner can set contest's properties\n     * @notice close time must be less than 28 days from now\n     * @dev Set contest close time, implementation address, organizer, contest id\n     * @dev only owner can call this function\n     * @param organizer The owner of the contest\n     * @param contestId The contest id\n     * @param closeTime The contest close time\n     * @param implementation The implementation address\n     */\n    function setContest(address organizer, bytes32 contestId, uint256 closeTime, address implementation)\n        public\n        onlyOwner\n    {\n        if (organizer == address(0) || implementation == address(0)) revert ProxyFactory__NoZeroAddress();\n        if (closeTime > block.timestamp + MAX_CONTEST_PERIOD || closeTime < block.timestamp) {\n            revert ProxyFactory__CloseTimeNotInRange();\n        }\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] != 0) revert ProxyFactory__ContestIsAlreadyRegistered();\n        saltToCloseTime[salt] = closeTime;\n        emit SetContest(organizer, contestId, closeTime, implementation);\n    }\n\n    /**\n     * @notice deploy proxy contract and distribute winner's prize\n     * @dev the caller can only control his own contest\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param data The prize distribution data\n     * @return The proxy address\n     */\n    function deployProxyAndDistribute(bytes32 contestId, address implementation, bytes calldata data)\n        public\n        returns (address)\n    {\n        bytes32 salt = _calculateSalt(msg.sender, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        // can set close time to current time and end it immediately if organizer wish\n        if (saltToCloseTime[salt] > block.timestamp) revert ProxyFactory__ContestIsNotClosed();\n        address proxy = _deployProxy(msg.sender, contestId, implementation);\n        _distribute(proxy, data);\n        return proxy;\n    }\n\n    /**\n     * @notice deploy proxy contract and distribute prize on behalf of organizer\n     * @dev the caller can only control his own contest\n     * @dev It uess EIP712 to verify the signature to avoid replay attacks\n     * @dev front run is allowed because it will only help the tx sender\n     * @param organizer The organizer of the contest\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param signature The signature from organizer\n     * @param data The prize distribution data\n     * @return proxy The proxy address\n     */\n    function deployProxyAndDistributeBySignature(\n        address organizer,\n        bytes32 contestId,\n        address implementation,\n        bytes calldata signature,\n        bytes calldata data\n    ) public returns (address) {\n        bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(contestId, data)));\n        if (ECDSA.recover(digest, signature) != organizer) revert ProxyFactory__InvalidSignature();\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        if (saltToCloseTime[salt] > block.timestamp) revert ProxyFactory__ContestIsNotClosed();\n        address proxy = _deployProxy(organizer, contestId, implementation);\n        _distribute(proxy, data);\n        return proxy;\n    }\n\n    /**\n     * @notice deploy proxy contract and distribute prize on behalf of organizer by owner\n     * @notice This can only be called after contest is expired\n     * @dev the caller must be owner\n     * @param organizer The organizer of the contest\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param data The prize distribution data\n     * @return proxy The proxy address\n     */\n    function deployProxyAndDistributeByOwner(\n        address organizer,\n        bytes32 contestId,\n        address implementation,\n        bytes calldata data\n    ) public onlyOwner returns (address) {\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        if (saltToCloseTime[salt] + EXPIRATION_TIME > block.timestamp) revert ProxyFactory__ContestIsNotExpired();\n        // require(saltToCloseTime[salt] == 0, \"Contest is not registered\");\n        // require(saltToCloseTime[salt] < block.timestamp + EXPIRATION_TIME, \"Contest is not expired\");\n        address proxy = _deployProxy(organizer, contestId, implementation);\n        _distribute(proxy, data);\n        return proxy;\n    }\n\n    /**\n     * @notice Owner can rescue funds if token is stuck after the deployment and contest is over for a while\n     * @dev only owner can call this function and it is supposed not to be called often\n     * @dev fee sent to stadium address is included in the logic contract\n     * @param proxy The proxy address\n     * @param organizer The contest organizer\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param data The prize distribution calling data\n     */\n    function distributeByOwner(\n        address proxy,\n        address organizer,\n        bytes32 contestId,\n        address implementation,\n        bytes calldata data\n    ) public onlyOwner {\n        if (proxy == address(0)) revert ProxyFactory__ProxyAddressCannotBeZero();\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        // distribute only when it exists and expired\n        if (saltToCloseTime[salt] + EXPIRATION_TIME > block.timestamp) revert ProxyFactory__ContestIsNotExpired();\n        _distribute(proxy, data);\n    }\n\n    /// @notice This address can be used to send ERC20 tokens before deployment of proxy\n    /// @dev Calculate the proxy address using salt and implementation address\n    /// @param salt The salt\n    /// @param implementation The implementation address\n    /// @return proxy The calculated proxy address\n    function getProxyAddress(bytes32 salt, address implementation) public view returns (address proxy) {\n        bytes memory code = abi.encodePacked(type(Proxy).creationCode, uint256(uint160(implementation)));\n        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, keccak256(code)));\n        proxy = address(uint160(uint256(hash)));\n    }\n\n    ///////////////////////////////////\n    /////// Internal functions ////////\n    ///////////////////////////////////\n    /// @dev Deploy proxy and return the proxy address\n    /// @dev This is an internal function\n    /// @param organizer The contest organizer\n    /// @param contestId The contest id\n    /// @param implementation The implementation address\n    function _deployProxy(address organizer, bytes32 contestId, address implementation) internal returns (address) {\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        address proxy = address(new Proxy{salt: salt}(implementation));\n        return proxy;\n    }\n\n    /// @dev The internal function to be used to call proxy to distribute prizes to the winners\n    /// @dev the data passed in should be the calling data of the distributing logic\n    /// @param proxy The proxy address\n    /// @param data The prize distribution data\n    function _distribute(address proxy, bytes calldata data) internal {\n        (bool success,) = proxy.call(data);\n        if (!success) revert ProxyFactory__DelegateCallFailed();\n        emit Distributed(proxy, data);\n    }\n\n    /// @dev Calculate salt using contest organizer address and contestId, implementation address\n    /// @dev This is an internal function\n    /// @param organizer The contest organizer\n    /// @param contestId The contest id\n    /// @param implementation The implementation address\n    function _calculateSalt(address organizer, bytes32 contestId, address implementation)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encode(organizer, contestId, implementation));\n    }\n}"
    },
    {
      "filename": "src/Distributor.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n// Layout of Contract:\n// version\n// imports\n// errors\n// interfaces, libraries, contracts\n// Type declarations\n// State variables\n// Events\n// Modifiers\n// Functions\n\n// Layout of Functions:\n// constructor\n// receive function (if exists)\n// fallback function (if exists)\n// external\n// public\n// internal\n// private\n// view & pure functions\n\npragma solidity 0.8.18;\n\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport {ProxyFactory} from \"./ProxyFactory.sol\";\n\n/**\n * @title Distributor contract\n * @notice General ERC20 stable coin tokens, e.g. JPYC, USDC, USDT, DAI, etc, are suppsoed to be used in SPARKN.\n * @notice This contract is used as the implementation of proxy contracts to distribute ERC20 token(e.g. JPYC) to winners\n * @dev The main logic of prize token distribution sits in this contract waiting to be called by factory contract\n * @dev Although the contract is immutable after deployment, If we want to upgrade the implementation contract\n * we can deploy a new one and change the implementation address of proxy contract.\n */\ncontract Distributor {\n    using SafeERC20 for IERC20;\n    //////////////////////\n    /////// Error ////////\n    //////////////////////\n\n    error Distributor__InvalidCommissionFee();\n    error Distributor__NoZeroAddress();\n    error Distributor__OnlyFactoryAddressIsAllowed();\n    error Distributor__InvalidTokenAddress();\n    error Distributor__MismatchedArrays();\n    error Distributor__MismatchedPercentages();\n    error Distributor__NoTokenToDistribute();\n\n    //////////////////////////////////////\n    /////// Immutable Variables //////////\n    //////////////////////////////////////\n    /* solhint-disable */\n    uint8 private constant VERSION = 1; // version is 1 for now\n    address private immutable FACTORY_ADDRESS;\n    address private immutable STADIUM_ADDRESS;\n    uint256 private constant COMMISSION_FEE = 500; // this can be changed in the future\n    // a constant value of 10,000 (basis points) = 100%\n    uint256 private constant BASIS_POINTS = 10000;\n\n    // prize distribution event. data is for logging purpose\n    event Distributed(address token, address[] winners, uint256[] percentages, bytes data);\n\n    ////////////////////////////\n    /////// Constructor ////////\n    ////////////////////////////\n    /// @dev initiate the contract with factory address and other key addresses, fee rate\n    constructor(\n        // uint256 version, // for future use\n        address factoryAddress,\n        address stadiumAddress\n    ) \n    /* solhint-enable */\n    {\n        if (factoryAddress == address(0) || stadiumAddress == address(0)) revert Distributor__NoZeroAddress();\n        FACTORY_ADDRESS = factoryAddress; // initialize with deployed factory address beforehand\n        STADIUM_ADDRESS = stadiumAddress; // official address to receive commission fee\n    }\n\n    ////////////////////////////////////////////\n    /////// External & Public functions ////////\n    ////////////////////////////////////////////\n    /**\n     * @notice Distribute token to winners according to the percentages\n     * @dev Only factory contract can call this function\n     * @param token The token address to distribute\n     * @param winners The addresses array of winners\n     * @param percentages The percentages array of winners\n     */\n    function distribute(address token, address[] memory winners, uint256[] memory percentages, bytes memory data)\n        external\n    {\n        if (msg.sender != FACTORY_ADDRESS) {\n            revert Distributor__OnlyFactoryAddressIsAllowed();\n        }\n        _distribute(token, winners, percentages, data);\n    }\n\n    ////////////////////////////////////////////\n    /////// Internal & Private functions ///////\n    ////////////////////////////////////////////\n    /**\n     * @notice An internal function to distribute JPYC to winners\n     * @dev Main logic of distribution is implemented here. The length of winners and percentages must be the same\n     * The token address must be one of the whitelisted tokens\n     * The winners and percentages array are supposed not to be so long, so the loop can stay unbounded\n     * The total percentage must be correct. It must be (100 - COMMITION_FEE).\n     * Finally send the remained token(fee) to STADIUM_ADDRESS with no dust in the contract\n     * @param token The token address\n     * @param winners The addresses of winners\n     * @param percentages The percentages of winners\n     * @param data The data to be logged. It is supposed to be used for showing the realation bbetween winners and proposals.\n     */\n    function _distribute(address token, address[] memory winners, uint256[] memory percentages, bytes memory data)\n        internal\n    {\n        // token address input check\n        if (token == address(0)) revert Distributor__NoZeroAddress();\n        if (!_isWhiteListed(token)) {\n            revert Distributor__InvalidTokenAddress();\n        }\n        // winners and percentages input check\n        if (winners.length == 0 || winners.length != percentages.length) revert Distributor__MismatchedArrays();\n        uint256 percentagesLength = percentages.length;\n        uint256 totalPercentage;\n        for (uint256 i; i < percentagesLength;) {\n            totalPercentage += percentages[i];\n            unchecked {\n                ++i;\n            }\n        }\n        // check if totalPercentage is correct\n        if (totalPercentage != (10000 - COMMISSION_FEE)) {\n            revert Distributor__MismatchedPercentages();\n        }\n        IERC20 erc20 = IERC20(token);\n        uint256 totalAmount = erc20.balanceOf(address(this));\n\n        // if there is no token to distribute, then revert\n        if (totalAmount == 0) revert Distributor__NoTokenToDistribute();\n\n        uint256 winnersLength = winners.length; // cache length\n        for (uint256 i; i < winnersLength;) {\n            uint256 amount = totalAmount * percentages[i] / BASIS_POINTS;\n            erc20.safeTransfer(winners[i], amount);\n            unchecked {\n                ++i;\n            }\n        }\n\n        // send commission fee as well as all the remaining tokens to STADIUM_ADDRESS to avoid dust remaining\n        _commissionTransfer(erc20);\n        emit Distributed(token, winners, percentages, data);\n    }\n\n    /**\n     * @notice Transfer commission fee to STADIUM_ADDRESS\n     * @dev This internal function is called after distribution in `_distribute` function\n     * @param token The token address\n     */\n    function _commissionTransfer(IERC20 token) internal {\n        token.safeTransfer(STADIUM_ADDRESS, token.balanceOf(address(this)));\n    }\n\n    /**\n     * @dev Check if the token is whitelisted. calling FACTORY_ADDRESS\n     * @param token The token address\n     * @return true if the token is whitelisted, vice versa\n     */\n    function _isWhiteListed(address token) internal view returns (bool) {\n        return ProxyFactory(FACTORY_ADDRESS).whitelistedTokens(token);\n    }\n\n    ///////////////////////////////////////////\n    /////// Getter pure/view functions ////////\n    ///////////////////////////////////////////\n    /**\n     * @notice returns all the immutable and constant addresses and values\n     * @dev This function is for convenience to check the addresses and values\n     */\n    function getConstants()\n        external\n        view\n        returns (address _FACTORY_ADDRESS, address _STADIUM_ADDRESS, uint256 _COMMISSION_FEE, uint8 _VERSION)\n    {\n        /* solhint-disable */\n        _FACTORY_ADDRESS = FACTORY_ADDRESS;\n        _STADIUM_ADDRESS = STADIUM_ADDRESS;\n        _COMMISSION_FEE = COMMISSION_FEE;\n        _VERSION = VERSION;\n        /* solhint-enable */\n    }\n}"
    }
  ]
}