{
  "Title": "Missed depositary check",
  "Content": "##### Description\nIn function `buy` defined at https://github.com/bondappetit/bondappetit-protocol/blob/88680691fe8d872c5fc26e9500d19cf7caaa9861/contracts/CollateralMarket.sol#L120 contract exchanges collateral tokens to stable tokens. But in case of wrong `depositary` that code will lead to collateralization disbalance, that is bad even you have manual `depositary` changing mechanism because `issuer` requires exact list of depositaries and transaction wont fail because `rebalance` call is fault tolerance.\n\n##### Recommendation\nWe recommend check depositary\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/CollateralMarket.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"./utils/OwnablePausable.sol\";\nimport \"./Issuer.sol\";\nimport \"./Treasury.sol\";\n\ncontract CollateralMarket is OwnablePausable {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice Address of issuer contract.\n    Issuer public issuer;\n\n    /// @notice Address of treasury contract.\n    Treasury public treasury;\n\n    /// @notice Address of depositary contract.\n    address public depositary;\n\n    /// @dev Allowed tokens list.\n    EnumerableSet.AddressSet private _allowedTokens;\n\n    /// @notice An event emitted when token allowed.\n    event TokenAllowed(address token);\n\n    /// @notice An event emitted when token denied.\n    event TokenDenied(address token);\n\n    /// @notice An event thats emitted when an Issuer contract address changed.\n    event IssuerChanged(address newIssuer);\n\n    /// @notice An event thats emitted when an Treasury contract address changed.\n    event TreasuryChanged(address newTreasury);\n\n    /// @notice An event thats emitted when an Depositary contract address changed.\n    event DepositaryChanged(address newDepositary);\n\n    /// @notice An event thats emitted when an account buyed token.\n    event Buy(address customer, address token, uint256 amount, uint256 buy);\n\n    constructor(\n        address _issuer,\n        address payable _treasury,\n        address _depositary\n    ) public {\n        issuer = Issuer(_issuer);\n        treasury = Treasury(_treasury);\n        depositary = _depositary;\n    }\n\n    /**\n     * @notice Allow token.\n     * @param token Allowable token.\n     */\n    function allowToken(address token) external onlyOwner {\n        _allowedTokens.add(token);\n        emit TokenAllowed(token);\n    }\n\n    /**\n     * @notice Deny token.\n     * @param token Denied token.\n     */\n    function denyToken(address token) external onlyOwner {\n        _allowedTokens.remove(token);\n        emit TokenDenied(token);\n    }\n\n    /**\n     * @return Allowed tokens list.\n     */\n    function allowedTokens() external view returns (address[] memory) {\n        address[] memory result = new address[](_allowedTokens.length());\n\n        for (uint256 i = 0; i < _allowedTokens.length(); i++) {\n            result[i] = _allowedTokens.at(i);\n        }\n\n        return result;\n    }\n\n    /**\n     * @notice Change Issuer contract address.\n     * @param _issuer New address Issuer contract.\n     */\n    function changeIssuer(address _issuer) external onlyOwner {\n        issuer = Issuer(_issuer);\n        emit IssuerChanged(_issuer);\n    }\n\n    /**\n     * @notice Change Treasury contract address.\n     * @param _treasury New address Treasury contract.\n     */\n    function changeTreasury(address payable _treasury) external onlyOwner {\n        treasury = Treasury(_treasury);\n        emit TreasuryChanged(_treasury);\n    }\n\n    /**\n     * @notice Change Depositary contract address.\n     * @param _depositary New address Depositary contract.\n     */\n    function changeDepositary(address _depositary) external onlyOwner {\n        depositary = _depositary;\n        emit DepositaryChanged(depositary);\n    }\n\n    /**\n     * @notice Buy stable token with ERC20 payment token amount.\n     * @param token Payment token.\n     * @param amount Amount of payment token.\n     */\n    function buy(ERC20 token, uint256 amount) external whenNotPaused {\n        require(_allowedTokens.contains(address(token)), \"CollateralMarket::buy: token is not allowed\");\n\n        token.safeTransferFrom(_msgSender(), address(this), amount);\n        token.transfer(depositary, amount);\n\n        ERC20 stableToken = ERC20(issuer.stableToken());\n        uint256 stableTokenDecimals = stableToken.decimals();\n        uint256 tokenDecimals = token.decimals();\n        uint256 reward = amount.mul(10**(stableTokenDecimals.sub(tokenDecimals)));\n        issuer.rebalance();\n        treasury.transfer(address(stableToken), _msgSender(), reward);\n\n        emit Buy(_msgSender(), address(token), amount, reward);\n    }\n}"
    }
  ]
}