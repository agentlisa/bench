{
  "Title": "Wrong reward calculation of balance < 100",
  "Content": "##### Description\nAt the line https://github.com/bondappetit/bondappetit-protocol/blob/355180f0aca0b29d60d808f761052956b7a3a159/contracts/VestingSplitter.sol#L126 contract calculate `reward` for account, however that calculation always return zero if `balance < 100`\n\n##### Recommendation\nWe suggest to perform division after multiplication\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/VestingSplitter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./Vesting.sol\";\n\ncontract VestingSplitter is Ownable {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n\n    /**\n     * @notice Distributed tokens.\n     */\n    mapping(address => uint256) public totalSupply;\n\n    /**\n     * @dev Accounts balances.\n     */\n    mapping(address => mapping(address => uint256)) internal _balances;\n\n    /**\n     * @dev Accounts list.\n     */\n    address[] internal _accounts;\n\n    /**\n     * @dev Shares of account in split.\n     */\n    mapping(address => uint256) internal _share;\n\n    /// @notice An event emitted when shares changed.\n    event SharesChanged();\n\n    /// @notice An event emitted when vesting period withdrawal.\n    event VestingWithdraw(address vesting, uint256 periodId);\n\n    /// @notice An event emitted when split a balance.\n    event Split(address token);\n\n    /// @notice An event emitted when withdrawal a token.\n    event Withdraw(address token, address account, uint256 reward);\n\n    /**\n     * @notice Get accounts limit for split.\n     * @return Max accounts for split.\n     */\n    function getMaxAccounts() public pure returns (uint256) {\n        return 100;\n    }\n\n    /**\n     * @notice Get accounts with share list.\n     * @return Addresses of all accounts with share.\n     */\n    function getAccounts() public view returns (address[] memory) {\n        return _accounts;\n    }\n\n    /**\n     * @notice Get balance of account.\n     * @param token Target token.\n     * @param account Target account.\n     * @return Balance of account.\n     */\n    function balanceOf(address token, address account) public view returns (uint256) {\n        return _balances[token][account];\n    }\n\n    /**\n     * @notice Get share of account in split.\n     * @param account Target account.\n     * @return Share in split.\n     */\n    function shareOf(address account) public view returns (uint256) {\n        return _share[account];\n    }\n\n    /**\n     * @notice Change shares of accounts in split.\n     * @param accounts Accounts list.\n     * @param shares Shares in split.\n     */\n    function changeShares(address[] memory accounts, uint256[] memory shares) external onlyOwner {\n        require(accounts.length <= getMaxAccounts(), \"VestingSplitter::changeShares: too many accounts\");\n        require(accounts.length == shares.length, \"VestingSplitter::changeShares: shares function information arity mismatch\");\n\n        uint256 sharesSum;\n        for (uint256 i = 0; i < accounts.length; i++) {\n            address account = accounts[i];\n            uint256 share = shares[i];\n            require(share <= 100 && share > 0, \"VestingSplitter::changeShares: invalid value of share\");\n\n            _share[account] = share;\n            sharesSum = sharesSum.add(share);\n        }\n        require(sharesSum == 100, \"VestingSplitter::changeShares: invalid sum of shares\");\n        _accounts = accounts;\n        emit SharesChanged();\n    }\n\n    /**\n     * @notice Withdraw reward from vesting contract.\n     * @param vesting Address of vesting contract.\n     * @param periodId Target vesting period.\n     */\n    function vestingWithdraw(Vesting vesting, uint256 periodId) external {\n        vesting.withdraw(periodId);\n        emit VestingWithdraw(address(vesting), periodId);\n    }\n\n    /**\n     * @notice Split token to all accounts.\n     * @param token Target token.\n     */\n    function split(address token) external {\n        uint256 balance = ERC20(token).balanceOf(address(this)).sub(totalSupply[token]);\n        require(balance > 0, \"VestingSplitter::split: empty balance\");\n\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            address account = _accounts[i];\n            uint256 share = _share[account];\n            uint256 reward = balance.div(100).mul(share);\n\n            _balances[token][account] = _balances[token][account].add(reward);\n            totalSupply[token] = totalSupply[token].add(reward);\n        }\n        emit Split(token);\n    }\n\n    /**\n     * @notice Withdraw token balance to sender.\n     * @param token Target token.\n     */\n    function withdraw(address token) external {\n        uint256 reward = _balances[token][_msgSender()];\n        _balances[token][_msgSender()] = 0;\n        totalSupply[token] = totalSupply[token].sub(reward);\n        ERC20(token).safeTransfer(_msgSender(), reward);\n        emit Withdraw(token, _msgSender(), reward);\n    }\n}"
    }
  ]
}