{
  "Title": "[H-03] Manipulation of `livePrice` to receive `defaultIncentive` in 2 consecutive blocks",
  "Content": "\nIn StabilizerNode, the default behaviour when twap is below the lower peg threshold, all transfers to the amm pool are blocked. However when `usePrimedWindow = true`, it will only block transfers for `primedWindow = 10` blocks. After 10 blocks, the block automatically stops and allows free market trading.\n\nThe first call to start this priming will receive `defaultIncentive` Malt and set `primedBlock` to start the priming. However, function `_validateSwingTraderTrigger()` which is used to validate and start the priming using `livePrice` is easy to be manipulated. Attacker can manipulate it to receive `defaultIncentive` in 2 consecutive blocks.\n\n### Proof of Concept\n\nConsider the scenario:\n\n1.  Block i, twap is below the value returned from `maltDataLab.getSwingTraderEntryPrice()`, attacker call `stabilize()` and receive `defaultIncentive`. `primedBlock = block.number`.\n2.  Block i+1, call to `_validateSwingTraderTrigger()` return `true` and trigger swing trader to bring the price back to peg. It's also reset `primedBlock = 0` (stop blocking transfer to AMM pool)\n3.  Since only 1 block pass, let's assume twap is still below the value returned from `maltDataLab.getSwingTraderEntryPrice()` (because twap moves slowly and will not change immediately to current price)\n4.  Now attacker can use flash loan to manipulate the `livePrice` to be larger than `entryPrice` (tranfer to AMM is not blocked) and call `stabilize()` to receive incentive again then repay the flash loan.\n\nAttacker cost is only flash loan fee, since his call will start an auction but not trigger swing trader so the state of AMM pool when he repays the flash loan is still the same (only added flash loan fee).\n\n<https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L312-L334>\n\n```solidity\nfunction _validateSwingTraderTrigger(uint256 livePrice, uint256 entryPrice)\n    internal\n    returns (bool)\n  {\n    if (usePrimedWindow) {\n      if (livePrice > entryPrice) {\n        return false;\n      }\n\n      if (block.number > primedBlock + primedWindow) {\n        primedBlock = block.number;\n        malt.mint(msg.sender, defaultIncentive * (10**malt.decimals()));\n        emit MintMalt(defaultIncentive * (10**malt.decimals()));\n        return false;\n      }\n\n      if (primedBlock == block.number) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n```\n\n### Recommended Mitigation Steps\n\nConsider not giving incentives for caller or reset the `primedBlock` at least after `primedWindow` blocks.\n\n**[0xScotch (Malt) commented](https://github.com/code-423n4/2023-02-malt-findings/issues/14#issuecomment-1447044279):**\n > Iâ€™m kinda skeptical of this but I think its possible in theory.\n> \n> However:\n> - `stabilize` can only be called via EOA due to `msg.sender == tx.origin` check (in `onlyEOA` modifier)\n> - Size of flashloan required is proportional to the size of the pool (as you have to manipulate price of that pool) while the incentive is fixed. So it seems like this would quickly become unprofitable\n> \n> I would be very curious to see a real PoC of this rather than just a theoretical threat.\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-02-malt-findings/issues/14#issuecomment-1455212754):**\n > Regarding the previous comment:\n>  - The `onlyEOA` check can be bypassed using a sandwich attack instead of a flashloan so the possibility of a MEV attack still exists\n>  - We should consider that the cost of capital within a block is 0. For example, Euler already proposes feeless flashloans of up to their TVL. See https://twitter.com/euler_mab/status/1595725665868910595. However there would still be the cost of using the AMM to manipulate the price.\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-02-malt-findings/issues/14#issuecomment-1455215172):**\n > Although the possibility of this being implemented depends on the size of the incentives and the cost of manipulating the AMM, it does not seem so unlikely. It could lead to a significant loss for the protocol, so I agree that high severity is appropriate.\n\n**[0xScotch (Malt) acknowledged](https://github.com/code-423n4/2023-02-malt-findings/issues/14)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2023-02-malt-protocol-versus-contest",
  "Code": [
    {
      "filename": "contracts/StabilityPod/StabilizerNode.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport \"openzeppelin/token/ERC20/ERC20.sol\";\nimport \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin/security/Pausable.sol\";\n\nimport \"../StabilizedPoolExtensions/StabilizedPoolUnit.sol\";\nimport \"../StabilizedPoolExtensions/AuctionExtension.sol\";\nimport \"../StabilizedPoolExtensions/DexHandlerExtension.sol\";\nimport \"../StabilizedPoolExtensions/DataLabExtension.sol\";\nimport \"../StabilizedPoolExtensions/ProfitDistributorExtension.sol\";\nimport \"../StabilizedPoolExtensions/SwingTraderManagerExtension.sol\";\nimport \"../StabilizedPoolExtensions/ImpliedCollateralServiceExtension.sol\";\nimport \"../interfaces/IAuction.sol\";\nimport \"../interfaces/IMaltDataLab.sol\";\nimport \"../interfaces/ITimekeeper.sol\";\nimport \"../interfaces/IRewardThrottle.sol\";\nimport \"../interfaces/IImpliedCollateralService.sol\";\nimport \"../interfaces/IDexHandler.sol\";\nimport \"../interfaces/ISwingTrader.sol\";\nimport \"../interfaces/IBurnMintableERC20.sol\";\nimport \"../interfaces/ISupplyDistributionController.sol\";\nimport \"../interfaces/IAuctionStartController.sol\";\nimport \"../interfaces/IProfitDistributor.sol\";\nimport \"../interfaces/IGlobalImpliedCollateralService.sol\";\n\n/// @title Stabilizer Node\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The backbone of the Malt stability system. In charge of triggering actions to stabilize price\ncontract StabilizerNode is\n  StabilizedPoolUnit,\n  AuctionExtension,\n  DexHandlerExtension,\n  DataLabExtension,\n  ProfitDistributorExtension,\n  SwingTraderManagerExtension,\n  ImpliedCollateralServiceExtension,\n  Pausable\n{\n  using SafeERC20 for ERC20;\n\n  uint256 internal stabilizeWindowEnd;\n  uint256 public stabilizeBackoffPeriod = 5 * 60; // 5 minutes\n  uint256 public upperStabilityThresholdBps = 100; // 1%\n  uint256 public lowerStabilityThresholdBps = 100;\n  uint256 public priceAveragePeriod = 5 minutes;\n  uint256 public fastAveragePeriod = 30; // 30 seconds\n  uint256 public overrideDistanceBps = 200; // 2%\n  uint256 public callerRewardCutBps = 30; // 0.3%\n\n  uint256 public expansionDampingFactor = 1;\n\n  uint256 public defaultIncentive = 100; // in Malt\n  uint256 public trackingIncentive = 20; // in 100ths of a Malt\n\n  uint256 public upperBandLimitBps = 100000; // 1000%\n  uint256 public lowerBandLimitBps = 1000; // 10%\n  uint256 public sampleSlippageBps = 2000; // 20%\n  uint256 public skipAuctionThreshold;\n  uint256 public preferAuctionThreshold;\n\n  uint256 public lastStabilize;\n  uint256 public lastTracking;\n  uint256 public trackingBackoff = 30; // 30 seconds\n  uint256 public primedBlock;\n  uint256 public primedWindow = 10; // blocks\n\n  bool internal trackAfterStabilize = true;\n  bool public onlyStabilizeToPeg = false;\n  bool public usePrimedWindow;\n\n  address public supplyDistributionController;\n  address public auctionStartController;\n\n  event MintMalt(uint256 amount);\n  event Stabilize(uint256 timestamp, uint256 exchangeRate);\n  event SetStabilizeBackoff(uint256 period);\n  event SetDefaultIncentive(uint256 incentive);\n  event SetTrackingIncentive(uint256 incentive);\n  event SetExpansionDamping(uint256 amount);\n  event SetPriceAveragePeriod(uint256 period);\n  event SetOverrideDistance(uint256 distance);\n  event SetFastAveragePeriod(uint256 period);\n  event SetStabilityThresholds(uint256 upper, uint256 lower);\n  event SetSupplyDistributionController(address _controller);\n  event SetAuctionStartController(address _controller);\n  event SetBandLimits(uint256 _upper, uint256 _lower);\n  event SetSlippageBps(uint256 _slippageBps);\n  event SetSkipAuctionThreshold(uint256 _skipAuctionThreshold);\n  event SetEmergencyMintThresholdBps(uint256 thresholdBps);\n  event Tracking();\n  event SetTrackingBackoff(uint256 backoff);\n  event SetCallerCut(uint256 callerCutBps);\n  event SetPreferAuctionThreshold(uint256 preferAuctionThreshold);\n  event SetTrackAfterStabilize(bool track);\n  event SetOnlyStabilizeToPeg(bool stabilize);\n  event SetPrimedWindow(uint256 primedWindow);\n  event SetUsePrimedWindow(bool usePrimedWindow);\n\n  constructor(\n    address timelock,\n    address repository,\n    address poolFactory,\n    uint256 _skipAuctionThreshold,\n    uint256 _preferAuctionThreshold\n  ) StabilizedPoolUnit(timelock, repository, poolFactory) {\n    skipAuctionThreshold = _skipAuctionThreshold;\n    preferAuctionThreshold = _preferAuctionThreshold;\n\n    lastStabilize = block.timestamp;\n  }\n\n  function setupContracts(\n    address _malt,\n    address _collateralToken,\n    address _dexHandler,\n    address _maltDataLab,\n    address _impliedCollateralService,\n    address _auction,\n    address _swingTraderManager,\n    address _profitDistributor,\n    address pool\n  ) external onlyRoleMalt(POOL_FACTORY_ROLE, \"Must have pool factory role\") {\n    require(!contractActive, \"StabilizerNode: Already setup\");\n    require(_malt != address(0), \"StabilizerNode: Malt addr(0)\");\n    require(_collateralToken != address(0), \"StabilizerNode: Col addr(0)\");\n    require(_dexHandler != address(0), \"StabilizerNode: DexHandler addr(0)\");\n    require(_maltDataLab != address(0), \"StabilizerNode: DataLab addr(0)\");\n    require(\n      _swingTraderManager != address(0),\n      \"StabilizerNode: Swing Manager addr(0)\"\n    );\n    require(\n      _impliedCollateralService != address(0),\n      \"StabilizerNode: ImpCol addr(0)\"\n    );\n    require(_auction != address(0), \"StabilizerNode: Auction addr(0)\");\n    require(\n      _profitDistributor != address(0),\n      \"StabilizerNode: ProfitDistributor addr(0)\"\n    );\n\n    contractActive = true;\n\n    collateralToken = ERC20(_collateralToken);\n    malt = IBurnMintableERC20(_malt);\n    dexHandler = IDexHandler(_dexHandler);\n    maltDataLab = IMaltDataLab(_maltDataLab);\n    swingTraderManager = ISwingTrader(_swingTraderManager);\n    impliedCollateralService = IImpliedCollateralService(\n      _impliedCollateralService\n    );\n    auction = IAuction(_auction);\n    profitDistributor = IProfitDistributor(_profitDistributor);\n\n    (, address updater, ) = poolFactory.getPool(pool);\n    _setPoolUpdater(updater);\n  }\n\n  function stabilize() external nonReentrant onlyEOA onlyActive whenNotPaused {\n    // Ensure data consistency\n    maltDataLab.trackPool();\n\n    // Finalize auction if possible before potentially starting a new one\n    auction.checkAuctionFinalization();\n\n    require(\n      block.timestamp >= stabilizeWindowEnd || _stabilityWindowOverride(),\n      \"Can't call stabilize\"\n    );\n    stabilizeWindowEnd = block.timestamp + stabilizeBackoffPeriod;\n\n    // used in 3 location.\n    uint256 exchangeRate = maltDataLab.maltPriceAverage(priceAveragePeriod);\n    bool stabilizeToPeg = onlyStabilizeToPeg; // gas\n\n    if (!_shouldAdjustSupply(exchangeRate, stabilizeToPeg)) {\n      lastStabilize = block.timestamp;\n      impliedCollateralService.syncGlobalCollateral();\n      return;\n    }\n\n    emit Stabilize(block.timestamp, exchangeRate);\n\n    (uint256 livePrice, ) = dexHandler.maltMarketPrice();\n\n    uint256 priceTarget = maltDataLab.getActualPriceTarget();\n    // The upper and lower bands here avoid any issues with price\n    // descrepency between the TWAP and live market price.\n    // This avoids starting auctions too quickly into a big selloff\n    // and also reduces risk of flashloan vectors\n    address sender = _msgSender();\n    if (exchangeRate > priceTarget) {\n      if (\n        !hasRole(ADMIN_ROLE, sender) &&\n        !hasRole(INTERNAL_WHITELIST_ROLE, sender)\n      ) {\n        uint256 upperBand = exchangeRate +\n          ((exchangeRate * upperBandLimitBps) / 10000);\n        uint256 latestSample = maltDataLab.maltPriceAverage(0);\n        uint256 minThreshold = latestSample -\n          (((latestSample - priceTarget) * sampleSlippageBps) / 10000);\n\n        require(livePrice < upperBand, \"Stabilize: Beyond upper bound\");\n        require(livePrice > minThreshold, \"Stabilize: Slippage threshold\");\n      }\n\n      _distributeSupply(livePrice, priceTarget, stabilizeToPeg);\n    } else {\n      if (\n        !hasRole(ADMIN_ROLE, sender) &&\n        !hasRole(INTERNAL_WHITELIST_ROLE, sender)\n      ) {\n        uint256 lowerBand = exchangeRate -\n          ((exchangeRate * lowerBandLimitBps) / 10000);\n        require(livePrice > lowerBand, \"Stabilize: Beyond lower bound\");\n      }\n\n      uint256 stEntryPrice = maltDataLab.getSwingTraderEntryPrice();\n      if (exchangeRate <= stEntryPrice) {\n        if (_validateSwingTraderTrigger(livePrice, stEntryPrice)) {\n          // Reset primedBlock\n          primedBlock = 0;\n          _triggerSwingTrader(priceTarget, livePrice);\n        }\n      } else {\n        _startAuction(priceTarget);\n      }\n    }\n\n    if (trackAfterStabilize) {\n      maltDataLab.trackPool();\n    }\n    impliedCollateralService.syncGlobalCollateral();\n    lastStabilize = block.timestamp;\n  }\n\n  function endAuctionEarly() external onlyActive whenNotPaused {\n    // This call reverts if the auction isn't ended\n    auction.endAuctionEarly();\n\n    // It hasn't reverted so the auction was ended. Pay the incentive\n    malt.mint(msg.sender, defaultIncentive * (10**malt.decimals()));\n    emit MintMalt(defaultIncentive * (10**malt.decimals()));\n  }\n\n  function trackPool() external onlyActive {\n    require(block.timestamp >= lastTracking + trackingBackoff, \"Too early\");\n    bool success = maltDataLab.trackPool();\n    require(success, \"Too early\");\n    malt.mint(msg.sender, (trackingIncentive * (10**malt.decimals())) / 100); // div 100 because units are cents\n    lastTracking = block.timestamp;\n    emit Tracking();\n  }\n\n  function primedWindowData() public view returns (bool, uint256) {\n    return (usePrimedWindow, primedBlock + primedWindow);\n  }\n\n  /*\n   * INTERNAL VIEW FUNCTIONS\n   */\n  function _stabilityWindowOverride() internal view returns (bool) {\n    address sender = _msgSender();\n    if (\n      hasRole(ADMIN_ROLE, sender) || hasRole(INTERNAL_WHITELIST_ROLE, sender)\n    ) {\n      // Admin can always stabilize\n      return true;\n    }\n    // Must have elapsed at least one period of the moving average before we stabilize again\n    if (block.timestamp < lastStabilize + fastAveragePeriod) {\n      return false;\n    }\n\n    uint256 priceTarget = maltDataLab.getActualPriceTarget();\n    uint256 exchangeRate = maltDataLab.maltPriceAverage(fastAveragePeriod);\n\n    uint256 upperThreshold = (priceTarget * (10000 + overrideDistanceBps)) /\n      10000;\n\n    return exchangeRate >= upperThreshold;\n  }\n\n  function _shouldAdjustSupply(uint256 exchangeRate, bool stabilizeToPeg)\n    internal\n    view\n    returns (bool)\n  {\n    uint256 decimals = collateralToken.decimals();\n    uint256 priceTarget;\n\n    if (stabilizeToPeg) {\n      priceTarget = maltDataLab.priceTarget();\n    } else {\n      priceTarget = maltDataLab.getActualPriceTarget();\n    }\n\n    uint256 upperThreshold = (priceTarget * upperStabilityThresholdBps) / 10000;\n    uint256 lowerThreshold = (priceTarget * lowerStabilityThresholdBps) / 10000;\n\n    return\n      (exchangeRate <= (priceTarget - lowerThreshold) &&\n        !auction.auctionExists(auction.currentAuctionId())) ||\n      exchangeRate >= (priceTarget + upperThreshold);\n  }\n\n  /*\n   * INTERNAL FUNCTIONS\n   */\n  function _validateSwingTraderTrigger(uint256 livePrice, uint256 entryPrice)\n    internal\n    returns (bool)\n  {\n    if (usePrimedWindow) {\n      if (livePrice > entryPrice) {\n        return false;\n      }\n\n      if (block.number > primedBlock + primedWindow) {\n        primedBlock = block.number;\n        malt.mint(msg.sender, defaultIncentive * (10**malt.decimals()));\n        emit MintMalt(defaultIncentive * (10**malt.decimals()));\n        return false;\n      }\n\n      if (primedBlock == block.number) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function _triggerSwingTrader(uint256 priceTarget, uint256 exchangeRate)\n    internal\n  {\n    uint256 decimals = collateralToken.decimals();\n    uint256 unity = 10**decimals;\n    IGlobalImpliedCollateralService globalIC = maltDataLab.globalIC();\n    uint256 icTotal = maltDataLab.maltToRewardDecimals(\n      globalIC.collateralRatio()\n    );\n\n    if (icTotal >= unity) {\n      icTotal = unity;\n    }\n\n    uint256 originalPriceTarget = priceTarget;\n\n    // TODO StabilizerNode.sol these checks won't work when working with pools not pegged to 1 Wed 26 Oct 2022 16:40:25 BST\n    if (exchangeRate < icTotal) {\n      priceTarget = icTotal;\n    }\n\n    uint256 purchaseAmount = dexHandler.calculateBurningTradeSize(priceTarget);\n\n    if (purchaseAmount > preferAuctionThreshold) {\n      uint256 capitalUsed = swingTraderManager.buyMalt(purchaseAmount);\n\n      uint256 callerCut = (capitalUsed * callerRewardCutBps) / 10000;\n\n      if (callerCut != 0) {\n        malt.mint(msg.sender, callerCut);\n        emit MintMalt(callerCut);\n      }\n    } else {\n      _startAuction(originalPriceTarget);\n    }\n  }\n\n  function _distributeSupply(\n    uint256 livePrice,\n    uint256 priceTarget,\n    bool stabilizeToPeg\n  ) internal {\n    if (supplyDistributionController != address(0)) {\n      bool success = ISupplyDistributionController(supplyDistributionController)\n        .check();\n      if (!success) {\n        return;\n      }\n    }\n\n    uint256 pegPrice = maltDataLab.priceTarget();\n\n    uint256 lowerThreshold = (pegPrice * lowerStabilityThresholdBps) / 10000;\n    if (stabilizeToPeg || livePrice >= pegPrice - lowerThreshold) {\n      priceTarget = pegPrice;\n    }\n\n    uint256 tradeSize = dexHandler.calculateMintingTradeSize(priceTarget) /\n      expansionDampingFactor;\n\n    if (tradeSize == 0) {\n      return;\n    }\n\n    uint256 swingAmount = swingTraderManager.sellMalt(tradeSize);\n\n    if (swingAmount >= tradeSize) {\n      return;\n    }\n\n    tradeSize = tradeSize - swingAmount;\n\n    malt.mint(address(dexHandler), tradeSize);\n    emit MintMalt(tradeSize);\n    // Transfer verification ensure any attempt to\n    // sandwhich will trigger stabilize first\n    uint256 rewards = dexHandler.sellMalt(tradeSize, 10000);\n\n    uint256 callerCut = (rewards * callerRewardCutBps) / 10000;\n\n    if (callerCut != 0) {\n      rewards -= callerCut;\n      collateralToken.safeTransfer(msg.sender, callerCut);\n    }\n\n    collateralToken.safeTransfer(address(profitDistributor), rewards);\n\n    profitDistributor.handleProfit(rewards);\n  }\n\n  function _startAuction(uint256 priceTarget) internal {\n    if (auctionStartController != address(0)) {\n      bool success = IAuctionStartController(auctionStartController)\n        .checkForStart();\n      if (!success) {\n        return;\n      }\n    }\n\n    uint256 purchaseAmount = dexHandler.calculateBurningTradeSize(priceTarget);\n\n    if (purchaseAmount < skipAuctionThreshold) {\n      return;\n    }\n\n    // TODO StabilizerNode.sol invert priceTarget? Fri 21 Oct 2022 11:02:43 BST\n    bool success = auction.triggerAuction(priceTarget, purchaseAmount);\n\n    if (success) {\n      malt.mint(msg.sender, defaultIncentive * (10**malt.decimals()));\n      emit MintMalt(defaultIncentive * (10**malt.decimals()));\n    }\n  }\n\n  /*\n   * PRIVILEDGED FUNCTIONS\n   */\n\n  function setStabilizeBackoff(uint256 _period)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_period > 0, \"Must be greater than 0\");\n    stabilizeBackoffPeriod = _period;\n    emit SetStabilizeBackoff(_period);\n  }\n\n  function setDefaultIncentive(uint256 _incentive)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_incentive != 0 && _incentive <= 1000, \"Incentive out of range\");\n\n    defaultIncentive = _incentive;\n\n    emit SetDefaultIncentive(_incentive);\n  }\n\n  function setTrackingIncentive(uint256 _incentive)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    // Priced in cents. Must be less than 1000 Malt\n    require(_incentive != 0 && _incentive <= 100000, \"Incentive out of range\");\n\n    trackingIncentive = _incentive;\n\n    emit SetTrackingIncentive(_incentive);\n  }\n\n  /// @notice Only callable by Admin address.\n  /// @dev Sets the Expansion Damping units.\n  /// @param amount: Amount to set Expansion Damping units to.\n  function setExpansionDamping(uint256 amount)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(amount > 0, \"No negative damping\");\n\n    expansionDampingFactor = amount;\n    emit SetExpansionDamping(amount);\n  }\n\n  function setStabilityThresholds(uint256 _upper, uint256 _lower)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_upper != 0 && _lower != 0, \"Must be above 0\");\n    require(_lower < 10000, \"Lower to large\");\n\n    upperStabilityThresholdBps = _upper;\n    lowerStabilityThresholdBps = _lower;\n    emit SetStabilityThresholds(_upper, _lower);\n  }\n\n  function setSupplyDistributionController(address _controller)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    // This is allowed to be set to address(0) as its checked before calling methods on it\n    supplyDistributionController = _controller;\n    emit SetSupplyDistributionController(_controller);\n  }\n\n  function setAuctionStartController(address _controller)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    // This is allowed to be set to address(0) as its checked before calling methods on it\n    auctionStartController = _controller;\n    emit SetAuctionStartController(_controller);\n  }\n\n  function setPriceAveragePeriod(uint256 _period)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_period > 0, \"Cannot have 0 period\");\n    priceAveragePeriod = _period;\n    emit SetPriceAveragePeriod(_period);\n  }\n\n  function setOverrideDistance(uint256 _distance)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(\n      _distance != 0 && _distance < 10000,\n      \"Override must be between 0-100%\"\n    );\n    overrideDistanceBps = _distance;\n    emit SetOverrideDistance(_distance);\n  }\n\n  function setFastAveragePeriod(uint256 _period)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_period > 0, \"Cannot have 0 period\");\n    fastAveragePeriod = _period;\n    emit SetFastAveragePeriod(_period);\n  }\n\n  function setBandLimits(uint256 _upper, uint256 _lower)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_upper != 0 && _lower != 0, \"Cannot have 0 band limit\");\n    upperBandLimitBps = _upper;\n    lowerBandLimitBps = _lower;\n    emit SetBandLimits(_upper, _lower);\n  }\n\n  function setSlippageBps(uint256 _slippageBps)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_slippageBps <= 10000, \"slippage: Must be <= 100%\");\n    sampleSlippageBps = _slippageBps;\n    emit SetSlippageBps(_slippageBps);\n  }\n\n  function setSkipAuctionThreshold(uint256 _skipAuctionThreshold)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    skipAuctionThreshold = _skipAuctionThreshold;\n    emit SetSkipAuctionThreshold(_skipAuctionThreshold);\n  }\n\n  function setPreferAuctionThreshold(uint256 _preferAuctionThreshold)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    preferAuctionThreshold = _preferAuctionThreshold;\n    emit SetPreferAuctionThreshold(_preferAuctionThreshold);\n  }\n\n  function setTrackingBackoff(uint256 _backoff)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_backoff != 0, \"Cannot be 0\");\n    trackingBackoff = _backoff;\n    emit SetTrackingBackoff(_backoff);\n  }\n\n  function setTrackAfterStabilize(bool _track)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    trackAfterStabilize = _track;\n    emit SetTrackAfterStabilize(_track);\n  }\n\n  function setOnlyStabilizeToPeg(bool _stabilize)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    onlyStabilizeToPeg = _stabilize;\n    emit SetOnlyStabilizeToPeg(_stabilize);\n  }\n\n  function setCallerCut(uint256 _callerCut)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_callerCut <= 1000, \"Must be less than 10%\");\n    callerRewardCutBps = _callerCut;\n    emit SetCallerCut(_callerCut);\n  }\n\n  function togglePause()\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    if (paused()) {\n      _unpause();\n    } else {\n      _pause();\n    }\n  }\n\n  function setPrimedWindow(uint256 _primedWindow)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_primedWindow != 0, \"Cannot be 0\");\n    primedWindow = _primedWindow;\n    emit SetPrimedWindow(_primedWindow);\n  }\n\n  function setUsePrimedWindow(bool _usePrimedWindow)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin role\")\n  {\n    usePrimedWindow = _usePrimedWindow;\n    emit SetUsePrimedWindow(_usePrimedWindow);\n  }\n\n  function _accessControl()\n    internal\n    override(\n      AuctionExtension,\n      DexHandlerExtension,\n      DataLabExtension,\n      ProfitDistributorExtension,\n      SwingTraderManagerExtension,\n      ImpliedCollateralServiceExtension\n    )\n  {\n    _onlyRoleMalt(POOL_UPDATER_ROLE, \"Must have pool updater role\");\n  }\n}"
    }
  ]
}