{
  "Title": "[H-06] Attacker can use `MagnetarAction.OFT` action of the Magnet to perform operations as any user including directly stealing user tokens",
  "Content": "\n<https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/Magnetar/Magnetar.sol#L153-L156> \n\n<https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/Magnetar/Magnetar.sol#L325-L333> \n\n<https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/Magnetar/MagnetarStorage.sol#L93-L97>\n\nThis issue requires the combination of two vulnerabilities to achieve the impact described in the title. The first vulnerability is that the `Magnetar._processOFTOperation` function doesn't check the function sigs in the action calldata with the the target addresses. It only ensures the calling target addresses are in the Whitelist of the Cluster. So an attacker can use this vuln to call any whitelist target address from the Magnetar.\n\nThe second vulnerability is that the Magnetar contract address itself will also be added to the Cluster whitelist. It can be found in the following integration test [here](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/test_hardhat/magnetar.test.ts#L389). If the attacker can let the Magnetar call itself, the `msg.sender` in the sub-call will be in the whitelist. It will bypass the `_checkSender` check:\n\n```solidity\n    function _checkSender(address _from) internal view {\n        if (_from != msg.sender && !cluster.isWhitelisted(0, msg.sender)) {\n            revert Magnetar_NotAuthorized(msg.sender, _from);\n        }\n    }\n```\n\n### Impact\n\nCombining the two issues mentioned above, we can carry out the following exploitation.\n\n1. Call `Magnetar.burst` function with `_action.id == MagnetarAction.OFT`, which will call `_processOFTOperation` function. The `_target` is the Magnetar contract itself, and the `_actionCalldata` is still an encoded calldata to call the `Magnetar.burst` function with `_action.id == MagnetarAction.OFT` again.\n2. In the second call, the `msg.sender` will be the Magnetar itself, so the from address check in the `_checkSender` function will be skipped directly because the `msg.sender` is in the whitelist.\n3. Now the attacker can pretend to be anyone and call any contract through the Magnetar. Please note that users approved their tokens to Magnetar if they used it.\n\n### Proof of Concept\n\nTaking `MagnetarAssetModule` as an example, it demonstrates how an attacker could steal users' collateral in the market.\n\nFirstly the `_checkSender(data.user);` can be bypassed directly.\n\nAnd make `data.withdrawCollateralParams.withdraw = true`, so the `collateralWithdrawReceiver` will be the Magnetar contract itself:\n\n    address collateralWithdrawReceiver = data.withdrawCollateralParams.withdraw ? address(this) : data.user;\n\nThen if `collateralShare > 0`, the function will call `_withdrawToChain(data.withdrawCollateralParams);` to withdraw the collateral to the another chain by sending LZ message.\n\nThere is no check for `withdrawCollateralParams` in the `_withdrawToChain` function. The attacker can set the receiver address to his address and finally receive the tokens on the target chain.\n\n### Recommendation\n\nCheck the target function sig in the `_processOFTOperation` function.\n\n**[cryptotechmaker (Tapioca) confirmed, but disagreed with severity and commented via duplicate Issue #170](https://github.com/code-423n4/2024-02-tapioca-findings/issues/170#issuecomment-2009731108):**\n>Medium, the same happens if you approve the attacker for an ERC20. However, this is worth fixing in my opinion. I think we can add specific selectors instead of allowing any call to be executed.\n>\n>Fixed [here](https://github.com/Tapioca-DAO/tapioca-periph/commit/d4bb69d70f57d570a9608b797f1effc35cfa8490).\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2024-02-tapioca",
  "Code": [
    {
      "filename": "contracts/Magnetar/Magnetar.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External \nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// Tapioca\nimport {ITapiocaOptionBroker} from \"tapioca-periph/interfaces/tap-token/ITapiocaOptionBroker.sol\";\nimport {ITapiocaOptionLiquidityProvision} from\n    \"tapioca-periph/interfaces/tap-token/ITapiocaOptionLiquidityProvision.sol\";\nimport {MagnetarAction, MagnetarModule, MagnetarCall} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {IMagnetarModuleExtender} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {ISingularity} from \"tapioca-periph/interfaces/bar/ISingularity.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IPermitAll} from \"tapioca-periph/interfaces/common/IPermitAll.sol\";\nimport {ICluster} from \"tapioca-periph/interfaces/periph/ICluster.sol\";\nimport {IPearlmit} from \"tapioca-periph/pearlmit/PearlmitHandler.sol\";\nimport {IPermit} from \"tapioca-periph/interfaces/common/IPermit.sol\";\nimport {IMarket} from \"tapioca-periph/interfaces/bar/IMarket.sol\";\nimport {ITOFT} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\nimport {BaseMagnetar} from \"./BaseMagnetar.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title Magnetar\n * @author TapiocaDAO\n * @notice Magnetar helper contract\n */\ncontract Magnetar is BaseMagnetar {\n    error Magnetar_ValueMismatch(uint256 expected, uint256 received); // Value mismatch in the total value asked and the msg.value in burst\n    error Magnetar_ActionNotValid(MagnetarAction action, bytes actionCalldata); // Burst did not find what to execute\n\n    constructor(\n        ICluster _cluster,\n        address _owner,\n        address payable _assetModule,\n        address payable _assetXChainModule,\n        address payable _collateralModule,\n        address payable _mintModule,\n        address payable _mintXChainModule,\n        address payable _optionModule,\n        address payable _yieldBoxModule,\n        IPearlmit _pearlmit\n    ) BaseMagnetar(_cluster, _pearlmit, _owner) {\n        modules[MagnetarModule.AssetModule] = _assetModule;\n        modules[MagnetarModule.AssetXChainModule] = _assetXChainModule;\n        modules[MagnetarModule.CollateralModule] = _collateralModule;\n        modules[MagnetarModule.MintModule] = _mintModule;\n        modules[MagnetarModule.MintXChainModule] = _mintXChainModule;\n        modules[MagnetarModule.OptionModule] = _optionModule;\n        modules[MagnetarModule.YieldBoxModule] = _yieldBoxModule;\n    }\n\n    /// =====================\n    /// Public\n    /// =====================\n    /**\n     * @notice Batch multiple calls together\n     * @param calls The list of actions to perform\n     */\n    function burst(MagnetarCall[] calldata calls) external payable {\n        uint256 valAccumulator;\n\n        uint256 length = calls.length;\n\n        for (uint256 i; i < length; i++) {\n            MagnetarCall calldata _action = calls[i];\n            if (!_action.allowFailure) {\n                require(\n                    _action.call.length > 0,\n                    string.concat(\"Magnetar: Missing call for action with index\", string(abi.encode(i)))\n                );\n            }\n            valAccumulator += _action.value;\n\n            /// @dev Permit on YB, or an SGL/BB market\n            if (_action.id == MagnetarAction.Permit) {\n                _processPermitOperation(_action.target, _action.call, _action.allowFailure);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Wrap/unwrap singular operations\n            if (_action.id == MagnetarAction.Wrap) {\n                _processWrapOperation(_action.target, _action.call, _action.value, _action.allowFailure);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Market singular operations\n            if (_action.id == MagnetarAction.Market) {\n                _processMarketOperation(_action.target, _action.call, _action.value, _action.allowFailure);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Tap singular operations\n            if (_action.id == MagnetarAction.TapToken) {\n                _processTapTokenOperation(_action.target, _action.call, _action.value, _action.allowFailure);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.AssetModule) {\n                _executeModule(MagnetarModule.AssetModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.AssetXChainModule) {\n                _executeModule(MagnetarModule.AssetXChainModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.CollateralModule) {\n                _executeModule(MagnetarModule.CollateralModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.MintModule) {\n                _executeModule(MagnetarModule.MintModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.MintXChainModule) {\n                _executeModule(MagnetarModule.MintXChainModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.OptionModule) {\n                _executeModule(MagnetarModule.OptionModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.YieldBoxModule) {\n                _executeModule(MagnetarModule.YieldBoxModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            if (_action.id == MagnetarAction.OFT) {\n                _processOFTOperation(_action.target, _action.call, _action.value, _action.allowFailure);\n                continue; // skip the rest of the loop\n            }\n\n            // If no valid action was found, use the Magnetar module extender. Only if the action is valid.\n            if (\n                address(magnetarModuleExtender) != address(0)\n                    && magnetarModuleExtender.isValidActionId(uint8(_action.id))\n            ) {\n                bytes memory callData = abi.encodeWithSelector(IMagnetarModuleExtender.handleAction.selector, _action);\n                (bool success, bytes memory returnData) = address(magnetarModuleExtender).delegatecall(callData);\n                if (!success) {\n                    _getRevertMsg(returnData);\n                }\n            } else {\n                // If no valid action was found, revert\n                revert Magnetar_ActionNotValid(_action.id, _action.call);\n            }\n        }\n\n        if (msg.value != valAccumulator) revert Magnetar_ValueMismatch(msg.value, valAccumulator);\n    }\n\n    /// =====================\n    /// Private\n    /// =====================\n    /**\n     * @dev Process a permit operation, will only execute if the selector is allowed.\n     * @dev !!! WARNING !!! Make sure to check the Owner param and check that function definition didn't change.\n     *\n     * @param _target The contract address to call.\n     * @param _actionCalldata The calldata to send to the target.\n     * @param _allowFailure Whether to allow the call to fail.\n     */\n    function _processPermitOperation(address _target, bytes calldata _actionCalldata, bool _allowFailure) private {\n        if (!cluster.isWhitelisted(0, _target)) revert Magnetar_NotAuthorized(_target, _target);\n\n        /// @dev owner address should always be first param.\n        // permitAction(bytes,uint16)\n        // permit(address owner...)\n        // revoke(address owner...)\n        // permitAll(address from,..)\n        // permit(address from,...)\n        // setApprovalForAll(address from,...)\n        // setApprovalForAsset(address from,...)\n        bytes4 funcSig = bytes4(_actionCalldata[:4]);\n        if (\n            funcSig == IPermitAll.permitAll.selector || funcSig == IPermitAll.revokeAll.selector\n                || funcSig == IPermit.permit.selector || funcSig == IPermit.revoke.selector\n                || funcSig == IYieldBox.setApprovalForAll.selector || funcSig == IYieldBox.setApprovalForAsset.selector \n                || funcSig == IERC20.approve.selector || funcSig == IPearlmit.approve.selector\n                || funcSig == IERC721.approve.selector \n        ) {\n            /// @dev Owner param check. See Warning above.\n            _checkSender(abi.decode(_actionCalldata[4:36], (address)));\n            // No need to send value on permit\n            _executeCall(_target, _actionCalldata, 0, _allowFailure);\n            return;\n        }\n        revert Magnetar_ActionNotValid(MagnetarAction.Permit, _actionCalldata);\n    }\n\n    //TODO: decide\n    /**\n     * @dev Process a TOFT operation, will only execute if the selector is allowed.\n     * @dev !!! WARNING !!! Make sure to check the Owner param and check that function definition didn't change.\n     *\n     * @param _target The contract address to call.\n     * @param _actionCalldata The calldata to send to the target.\n     * @param _actionValue The value to send with the call.\n     * @param _allowFailure Whether to allow the call to fail.\n     */\n    function _processWrapOperation(\n        address _target,\n        bytes calldata _actionCalldata,\n        uint256 _actionValue,\n        bool _allowFailure\n    ) private {\n        if (!cluster.isWhitelisted(0, _target)) revert Magnetar_NotAuthorized(_target, _target);\n\n        /// @dev owner address should always be first param.\n        // wrap(address from,...)\n        // unwrap(address from,...)\n        bytes4 funcSig = bytes4(_actionCalldata[:4]);\n\n        if (funcSig == ITOFT.wrap.selector || funcSig == ITOFT.unwrap.selector) {\n            /// @dev Owner param check. See Warning above.\n            _checkSender(abi.decode(_actionCalldata[4:36], (address)));\n            _executeCall(_target, _actionCalldata, _actionValue, _allowFailure);\n            return;\n        }\n        revert Magnetar_ActionNotValid(MagnetarAction.Wrap, _actionCalldata);\n    }\n\n    /**\n     * @dev Process a market operation, will only execute if the selector is allowed.\n     * @dev !!! WARNING !!! Make sure to check the Owner param and check that function definition didn't change.\n     *\n     * @param _target The contract address to call.\n     * @param _actionCalldata The calldata to send to the target.\n     * @param _actionValue The value to send with the call.\n     * @param _allowFailure Whether to allow the call to fail.\n     */\n    function _processMarketOperation(\n        address _target,\n        bytes calldata _actionCalldata,\n        uint256 _actionValue,\n        bool _allowFailure\n    ) private {\n        if (!cluster.isWhitelisted(0, _target)) revert Magnetar_NotAuthorized(_target, _target);\n\n        /// @dev owner address should always be first param.\n        // addCollateral(address from,...)\n        // borrow(address from,...)\n        // addAsset(address from,...)\n        // repay(address _from,...)\n        // buyCollateral(address from,...)\n        // sellCollateral(address from,...)\n        bytes4 funcSig = bytes4(_actionCalldata[:4]);\n        if (\n            funcSig == IMarket.execute.selector || funcSig == ISingularity.addAsset.selector\n                || funcSig == ISingularity.removeAsset.selector\n        ) {\n            /// @dev Owner param check. See Warning above.\n            _checkSender(abi.decode(_actionCalldata[4:36], (address)));\n            _executeCall(_target, _actionCalldata, _actionValue, _allowFailure);\n            return;\n        }\n        revert Magnetar_ActionNotValid(MagnetarAction.Market, _actionCalldata);\n    }\n\n    /**\n     * @dev Process a TapToken operation, will only execute if the selector is allowed.\n     * @dev Different from the others. No need to check for sender.\n     *\n     * @param _target The contract address to call.\n     * @param _actionCalldata The calldata to send to the target.\n     * @param _actionValue The value to send with the call.\n     * @param _allowFailure Whether to allow the call to fail.\n     */\n    function _processTapTokenOperation(\n        address _target,\n        bytes calldata _actionCalldata,\n        uint256 _actionValue,\n        bool _allowFailure\n    ) private {\n        if (!cluster.isWhitelisted(0, _target)) revert Magnetar_NotAuthorized(_target, _target);\n\n        bytes4 funcSig = bytes4(_actionCalldata[:4]);\n        if (\n            funcSig == ITapiocaOptionBroker.exerciseOption.selector\n                || funcSig == ITapiocaOptionBroker.participate.selector\n                || funcSig == ITapiocaOptionBroker.exitPosition.selector\n                || funcSig == ITapiocaOptionLiquidityProvision.lock.selector\n                || funcSig == ITapiocaOptionLiquidityProvision.unlock.selector\n        ) {\n            _executeCall(_target, _actionCalldata, _actionValue, _allowFailure);\n            return;\n        }\n        revert Magnetar_ActionNotValid(MagnetarAction.TapToken, _actionCalldata);\n    }\n\n    /**\n     * @dev Process an OFT operation, will only execute if the selector is allowed.\n     * @dev Different from the others. No need to check for sender. MsgType is sanitized by the OFT\n     *\n     * @param _target The contract address to call.\n     * @param _actionCalldata The calldata to send to the target.\n     * @param _actionValue The value to send with the call.\n     * @param _allowFailure Whether to allow the call to fail.\n     */\n    function _processOFTOperation(\n        address _target,\n        bytes calldata _actionCalldata,\n        uint256 _actionValue,\n        bool _allowFailure\n    ) private {\n        if (!cluster.isWhitelisted(0, _target)) revert Magnetar_NotAuthorized(_target, _target);\n        _executeCall(_target, _actionCalldata, _actionValue, _allowFailure);\n    }\n\n    /**\n     * @dev Executes a call to an address, optionally reverting on failure. Make sure to sanitize prior to calling.\n     */\n    function _executeCall(address _target, bytes calldata _actionCalldata, uint256 _actionValue, bool _allowFailure)\n        private\n    {\n        bool success;\n        bytes memory returnData;\n\n        if (_actionValue > 0) {\n            (success, returnData) = _target.call{value: _actionValue}(_actionCalldata);\n        } else {\n            (success, returnData) = _target.call(_actionCalldata);\n        }\n\n        if (!success && !_allowFailure) {\n            _getRevertMsg(returnData);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/Magnetar/Magnetar.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External \nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// Tapioca\nimport {ITapiocaOptionBroker} from \"tapioca-periph/interfaces/tap-token/ITapiocaOptionBroker.sol\";\nimport {ITapiocaOptionLiquidityProvision} from\n    \"tapioca-periph/interfaces/tap-token/ITapiocaOptionLiquidityProvision.sol\";\nimport {MagnetarAction, MagnetarModule, MagnetarCall} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {IMagnetarModuleExtender} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {ISingularity} from \"tapioca-periph/interfaces/bar/ISingularity.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IPermitAll} from \"tapioca-periph/interfaces/common/IPermitAll.sol\";\nimport {ICluster} from \"tapioca-periph/interfaces/periph/ICluster.sol\";\nimport {IPearlmit} from \"tapioca-periph/pearlmit/PearlmitHandler.sol\";\nimport {IPermit} from \"tapioca-periph/interfaces/common/IPermit.sol\";\nimport {IMarket} from \"tapioca-periph/interfaces/bar/IMarket.sol\";\nimport {ITOFT} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\nimport {BaseMagnetar} from \"./BaseMagnetar.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title Magnetar\n * @author TapiocaDAO\n * @notice Magnetar helper contract\n */\ncontract Magnetar is BaseMagnetar {\n    error Magnetar_ValueMismatch(uint256 expected, uint256 received); // Value mismatch in the total value asked and the msg.value in burst\n    error Magnetar_ActionNotValid(MagnetarAction action, bytes actionCalldata); // Burst did not find what to execute\n\n    constructor(\n        ICluster _cluster,\n        address _owner,\n        address payable _assetModule,\n        address payable _assetXChainModule,\n        address payable _collateralModule,\n        address payable _mintModule,\n        address payable _mintXChainModule,\n        address payable _optionModule,\n        address payable _yieldBoxModule,\n        IPearlmit _pearlmit\n    ) BaseMagnetar(_cluster, _pearlmit, _owner) {\n        modules[MagnetarModule.AssetModule] = _assetModule;\n        modules[MagnetarModule.AssetXChainModule] = _assetXChainModule;\n        modules[MagnetarModule.CollateralModule] = _collateralModule;\n        modules[MagnetarModule.MintModule] = _mintModule;\n        modules[MagnetarModule.MintXChainModule] = _mintXChainModule;\n        modules[MagnetarModule.OptionModule] = _optionModule;\n        modules[MagnetarModule.YieldBoxModule] = _yieldBoxModule;\n    }\n\n    /// =====================\n    /// Public\n    /// =====================\n    /**\n     * @notice Batch multiple calls together\n     * @param calls The list of actions to perform\n     */\n    function burst(MagnetarCall[] calldata calls) external payable {\n        uint256 valAccumulator;\n\n        uint256 length = calls.length;\n\n        for (uint256 i; i < length; i++) {\n            MagnetarCall calldata _action = calls[i];\n            if (!_action.allowFailure) {\n                require(\n                    _action.call.length > 0,\n                    string.concat(\"Magnetar: Missing call for action with index\", string(abi.encode(i)))\n                );\n            }\n            valAccumulator += _action.value;\n\n            /// @dev Permit on YB, or an SGL/BB market\n            if (_action.id == MagnetarAction.Permit) {\n                _processPermitOperation(_action.target, _action.call, _action.allowFailure);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Wrap/unwrap singular operations\n            if (_action.id == MagnetarAction.Wrap) {\n                _processWrapOperation(_action.target, _action.call, _action.value, _action.allowFailure);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Market singular operations\n            if (_action.id == MagnetarAction.Market) {\n                _processMarketOperation(_action.target, _action.call, _action.value, _action.allowFailure);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Tap singular operations\n            if (_action.id == MagnetarAction.TapToken) {\n                _processTapTokenOperation(_action.target, _action.call, _action.value, _action.allowFailure);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.AssetModule) {\n                _executeModule(MagnetarModule.AssetModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.AssetXChainModule) {\n                _executeModule(MagnetarModule.AssetXChainModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.CollateralModule) {\n                _executeModule(MagnetarModule.CollateralModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.MintModule) {\n                _executeModule(MagnetarModule.MintModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.MintXChainModule) {\n                _executeModule(MagnetarModule.MintXChainModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.OptionModule) {\n                _executeModule(MagnetarModule.OptionModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            /// @dev Modules will not return result data.\n            if (_action.id == MagnetarAction.YieldBoxModule) {\n                _executeModule(MagnetarModule.YieldBoxModule, _action.call);\n                continue; // skip the rest of the loop\n            }\n\n            if (_action.id == MagnetarAction.OFT) {\n                _processOFTOperation(_action.target, _action.call, _action.value, _action.allowFailure);\n                continue; // skip the rest of the loop\n            }\n\n            // If no valid action was found, use the Magnetar module extender. Only if the action is valid.\n            if (\n                address(magnetarModuleExtender) != address(0)\n                    && magnetarModuleExtender.isValidActionId(uint8(_action.id))\n            ) {\n                bytes memory callData = abi.encodeWithSelector(IMagnetarModuleExtender.handleAction.selector, _action);\n                (bool success, bytes memory returnData) = address(magnetarModuleExtender).delegatecall(callData);\n                if (!success) {\n                    _getRevertMsg(returnData);\n                }\n            } else {\n                // If no valid action was found, revert\n                revert Magnetar_ActionNotValid(_action.id, _action.call);\n            }\n        }\n\n        if (msg.value != valAccumulator) revert Magnetar_ValueMismatch(msg.value, valAccumulator);\n    }\n\n    /// =====================\n    /// Private\n    /// =====================\n    /**\n     * @dev Process a permit operation, will only execute if the selector is allowed.\n     * @dev !!! WARNING !!! Make sure to check the Owner param and check that function definition didn't change.\n     *\n     * @param _target The contract address to call.\n     * @param _actionCalldata The calldata to send to the target.\n     * @param _allowFailure Whether to allow the call to fail.\n     */\n    function _processPermitOperation(address _target, bytes calldata _actionCalldata, bool _allowFailure) private {\n        if (!cluster.isWhitelisted(0, _target)) revert Magnetar_NotAuthorized(_target, _target);\n\n        /// @dev owner address should always be first param.\n        // permitAction(bytes,uint16)\n        // permit(address owner...)\n        // revoke(address owner...)\n        // permitAll(address from,..)\n        // permit(address from,...)\n        // setApprovalForAll(address from,...)\n        // setApprovalForAsset(address from,...)\n        bytes4 funcSig = bytes4(_actionCalldata[:4]);\n        if (\n            funcSig == IPermitAll.permitAll.selector || funcSig == IPermitAll.revokeAll.selector\n                || funcSig == IPermit.permit.selector || funcSig == IPermit.revoke.selector\n                || funcSig == IYieldBox.setApprovalForAll.selector || funcSig == IYieldBox.setApprovalForAsset.selector \n                || funcSig == IERC20.approve.selector || funcSig == IPearlmit.approve.selector\n                || funcSig == IERC721.approve.selector \n        ) {\n            /// @dev Owner param check. See Warning above.\n            _checkSender(abi.decode(_actionCalldata[4:36], (address)));\n            // No need to send value on permit\n            _executeCall(_target, _actionCalldata, 0, _allowFailure);\n            return;\n        }\n        revert Magnetar_ActionNotValid(MagnetarAction.Permit, _actionCalldata);\n    }\n\n    //TODO: decide\n    /**\n     * @dev Process a TOFT operation, will only execute if the selector is allowed.\n     * @dev !!! WARNING !!! Make sure to check the Owner param and check that function definition didn't change.\n     *\n     * @param _target The contract address to call.\n     * @param _actionCalldata The calldata to send to the target.\n     * @param _actionValue The value to send with the call.\n     * @param _allowFailure Whether to allow the call to fail.\n     */\n    function _processWrapOperation(\n        address _target,\n        bytes calldata _actionCalldata,\n        uint256 _actionValue,\n        bool _allowFailure\n    ) private {\n        if (!cluster.isWhitelisted(0, _target)) revert Magnetar_NotAuthorized(_target, _target);\n\n        /// @dev owner address should always be first param.\n        // wrap(address from,...)\n        // unwrap(address from,...)\n        bytes4 funcSig = bytes4(_actionCalldata[:4]);\n\n        if (funcSig == ITOFT.wrap.selector || funcSig == ITOFT.unwrap.selector) {\n            /// @dev Owner param check. See Warning above.\n            _checkSender(abi.decode(_actionCalldata[4:36], (address)));\n            _executeCall(_target, _actionCalldata, _actionValue, _allowFailure);\n            return;\n        }\n        revert Magnetar_ActionNotValid(MagnetarAction.Wrap, _actionCalldata);\n    }\n\n    /**\n     * @dev Process a market operation, will only execute if the selector is allowed.\n     * @dev !!! WARNING !!! Make sure to check the Owner param and check that function definition didn't change.\n     *\n     * @param _target The contract address to call.\n     * @param _actionCalldata The calldata to send to the target.\n     * @param _actionValue The value to send with the call.\n     * @param _allowFailure Whether to allow the call to fail.\n     */\n    function _processMarketOperation(\n        address _target,\n        bytes calldata _actionCalldata,\n        uint256 _actionValue,\n        bool _allowFailure\n    ) private {\n        if (!cluster.isWhitelisted(0, _target)) revert Magnetar_NotAuthorized(_target, _target);\n\n        /// @dev owner address should always be first param.\n        // addCollateral(address from,...)\n        // borrow(address from,...)\n        // addAsset(address from,...)\n        // repay(address _from,...)\n        // buyCollateral(address from,...)\n        // sellCollateral(address from,...)\n        bytes4 funcSig = bytes4(_actionCalldata[:4]);\n        if (\n            funcSig == IMarket.execute.selector || funcSig == ISingularity.addAsset.selector\n                || funcSig == ISingularity.removeAsset.selector\n        ) {\n            /// @dev Owner param check. See Warning above.\n            _checkSender(abi.decode(_actionCalldata[4:36], (address)));\n            _executeCall(_target, _actionCalldata, _actionValue, _allowFailure);\n            return;\n        }\n        revert Magnetar_ActionNotValid(MagnetarAction.Market, _actionCalldata);\n    }\n\n    /**\n     * @dev Process a TapToken operation, will only execute if the selector is allowed.\n     * @dev Different from the others. No need to check for sender.\n     *\n     * @param _target The contract address to call.\n     * @param _actionCalldata The calldata to send to the target.\n     * @param _actionValue The value to send with the call.\n     * @param _allowFailure Whether to allow the call to fail.\n     */\n    function _processTapTokenOperation(\n        address _target,\n        bytes calldata _actionCalldata,\n        uint256 _actionValue,\n        bool _allowFailure\n    ) private {\n        if (!cluster.isWhitelisted(0, _target)) revert Magnetar_NotAuthorized(_target, _target);\n\n        bytes4 funcSig = bytes4(_actionCalldata[:4]);\n        if (\n            funcSig == ITapiocaOptionBroker.exerciseOption.selector\n                || funcSig == ITapiocaOptionBroker.participate.selector\n                || funcSig == ITapiocaOptionBroker.exitPosition.selector\n                || funcSig == ITapiocaOptionLiquidityProvision.lock.selector\n                || funcSig == ITapiocaOptionLiquidityProvision.unlock.selector\n        ) {\n            _executeCall(_target, _actionCalldata, _actionValue, _allowFailure);\n            return;\n        }\n        revert Magnetar_ActionNotValid(MagnetarAction.TapToken, _actionCalldata);\n    }\n\n    /**\n     * @dev Process an OFT operation, will only execute if the selector is allowed.\n     * @dev Different from the others. No need to check for sender. MsgType is sanitized by the OFT\n     *\n     * @param _target The contract address to call.\n     * @param _actionCalldata The calldata to send to the target.\n     * @param _actionValue The value to send with the call.\n     * @param _allowFailure Whether to allow the call to fail.\n     */\n    function _processOFTOperation(\n        address _target,\n        bytes calldata _actionCalldata,\n        uint256 _actionValue,\n        bool _allowFailure\n    ) private {\n        if (!cluster.isWhitelisted(0, _target)) revert Magnetar_NotAuthorized(_target, _target);\n        _executeCall(_target, _actionCalldata, _actionValue, _allowFailure);\n    }\n\n    /**\n     * @dev Executes a call to an address, optionally reverting on failure. Make sure to sanitize prior to calling.\n     */\n    function _executeCall(address _target, bytes calldata _actionCalldata, uint256 _actionValue, bool _allowFailure)\n        private\n    {\n        bool success;\n        bytes memory returnData;\n\n        if (_actionValue > 0) {\n            (success, returnData) = _target.call{value: _actionValue}(_actionCalldata);\n        } else {\n            (success, returnData) = _target.call(_actionCalldata);\n        }\n\n        if (!success && !_allowFailure) {\n            _getRevertMsg(returnData);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/Magnetar/MagnetarStorage.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\n// Tapioca\nimport {ITapiocaOptionLiquidityProvision} from\n    \"tapioca-periph/interfaces/tap-token/ITapiocaOptionLiquidityProvision.sol\";\nimport {ITapiocaOptionBroker} from \"tapioca-periph/interfaces/tap-token/ITapiocaOptionBroker.sol\";\nimport {MagnetarAction, MagnetarModule} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {PearlmitHandler, IPearlmit} from \"tapioca-periph/pearlmit/PearlmitHandler.sol\";\nimport {IYieldBoxTokenType} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {ITapiocaOracle} from \"tapioca-periph/interfaces/periph/ITapiocaOracle.sol\";\nimport {ICommonData} from \"tapioca-periph/interfaces/common/ICommonData.sol\";\nimport {ISingularity} from \"tapioca-periph/interfaces/bar/ISingularity.sol\";\nimport {ICluster} from \"tapioca-periph/interfaces/periph/ICluster.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title MagnetarStorage\n * @author TapiocaDAO\n * @notice Storage contract for Magnetar & modules\n */\ncontract MagnetarStorage is IERC721Receiver, PearlmitHandler {\n    ICluster internal cluster;\n    mapping(MagnetarModule moduleId => address moduleAddress) internal modules;\n\n    // Helpers for external usage. Not used in the contract.\n    uint8 public constant MAGNETAR_ACTION_PERMIT = 0;\n    uint8 public con"
    }
  ]
}