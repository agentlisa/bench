{
  "Title": "M-5: DAI/gOHM exchange rate may be stale",
  "Content": "# Issue M-5: DAI/gOHM exchange rate may be stale \n\nSource: https://github.com/sherlock-audit/2023-01-cooler-judging/issues/217 \n\n## Found by \nIllIllI\n\n## Summary\n\nThe `maxLTC` variable is a constant which implies a specific DAI/gOHM echange rate. The exchange rate has already changed so the current value in use will be wrong, and any value chosen now will eventually be out of date.\n\n\n## Vulnerability Detail\n\nThe `ClearingHouse` allows any loan to go through (assuming the `operator` approves it, and the `operator` is likely some sort of keeper program), and decides whether the terms are fair based on the hard-coded `maxLTC`, which will be (and is already - gOHM is currently worth $2,600) out of date. \n\nIf the code had been using a Chainlink oracle, this issue would be equivalent to not checking whether the price used to determine the loan-to-collateral ratio was stale, which is a Medium-severity issue.\n\nIt's not clear who or what exactly will be in control of the `operator` address which will make the `clear()` calls, but it will likely be a keeper which, unless programmed otherwise, would blindly approve such loans. Even if the `operator` is an actual person, the fact that there are coded checks for the `maxLTC`, means that the person/keeper can't be fully trusted, or that the code is attempting to protect against mistakes, so this category of mistake should also be added.\n\n\n## Impact\n\nUnder-collateralized loans will be given, and borrowers will purposely take loans default, since they can use the loan amount to buy more collateral than they would lose during default.\n\n\n## Code Snippet\n\nThe maximum loan-to-collateral is hard-coded, rather than being based on an oracle price:\n```solidity\n// File: src/aux/ClearingHouse.sol : ClearingHouse.maxLTC   #1\n\n34:@>     uint256 public constant maxLTC = 2_500 * 1e18; // 2,500\n```\nhttps://github.com/sherlock-audit/2023-01-cooler/blob/main/src/aux/ClearingHouse.sol#L34\n\nIf the gOHM price drops below $2500 to say $2000, a loan for 2500 DAI will only require 1 gOHM of collateral, even though it should require at least 1.2 gOHM in order to be fully-collateralized:\n```solidity\n// File: src/Cooler.sol : Cooler.collateralFor()   #2\n\n236        function collateralFor(uint256 amount, uint256 loanToCollateral) public pure returns (uint256) {\n237 @>         return amount * decimals / loanToCollateral;\n238:       }\n```\nhttps://github.com/sherlock-audit/2023-01-cooler/blob/main/src/Cooler.sol#L236-L238\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nUse a chainlink oracle to determine the right prices to use when coming up with the maximum loan-to-collateral, for _each_ loan\n\n\n## Discussion\n\n**hrishibhat**\n\nSponsor comment:\n> Not intended to be updated in real time. Set via gov; computed relative to backing (far less volatile than pricing).\n\n**IllIllI000**\n\nThe values are stored in `constant` variables, so once they're set they cannot change\n\n**hrishibhat**\n\nConsidering this issue as a valid medium, as a request placed with an ltc based on the exchange rate would result in incorrect maxltc calculated. Could render the contract useless since the maxLTC is fixed. \n\n> If the gOHM price drops below $2500 to say $2000, a loan for 2500 DAI will only require 1 gOHM of collateral, even though it should require at least 1.2 gOHM in order to be fully-collateralized:\n\n**0x00052**\n\nEscalate for 11 USDC\n\n`If the gOHM price drops below $2500 to say $2000, a loan for 2500 DAI will only require 1 gOHM of collateral, even though it should require at least 1.2 gOHM in order to be fully-collateralized:`\n\nI disagree with this statement. It doesn't use the maxLTC when creating the loan, it uses the value specified by the loan request. maxLTC is just the max value it can't exceed. There's nothing forcing the operator to accept every loan at/under the maxLTC. The operator would have discretion and wouldn't clear bad loans that are undercollateralized from the start. The only thing it's doing it providing a hard stop for the ltc.\n\n        (\n            uint256 amount, \n            uint256 interest, \n            uint256 ltc, \n            uint256 duration,\n        ) = cooler.requests(id);\n\n\n        // Validate terms\n        if (interest < minimumInterest) \n            revert InterestMinimum();\n        if (ltc > maxLTC) \n            revert LTCMaximum();\n\nWe see in the above lines that it pulls the requested LTC from the cooler and compares it to maxLTC to confirm it isn't too high. It doesn't use the maxLTC value, it simply functions as a guardrail to make sure it doesn't accidentally clear a bad loan to gives way too much DAI. Technically if the price of gOHM was to increase dramatically the contract would become useless, but it wouldn't lead to any lost/stuck funds and it would be easy enough to just deploy a new contract with different bounds.\n\nThis should be low severity.\n\n**sherlock-admin**\n\n > Escalate for 11 USDC\n> \n> `If the gOHM price drops below $2500 to say $2000, a loan for 2500 DAI will only require 1 gOHM of collateral, even though it should require at least 1.2 gOHM in order to be fully-collateralized:`\n> \n> I disagree with this statement. It doesn't use the maxLTC when creating the loan, it uses the value specified by the loan request. maxLTC is just the max value it can't exceed. There's nothing forcing the operator to accept every loan at/under the maxLTC. The operator would have discretion and wouldn't clear bad loans that are undercollateralized from the start. The only thing it's doing it providing a hard stop for the ltc.\n> \n>         (\n>             uint256 amount, \n>             uint256 interest, \n>             uint256 ltc, \n>             uint256 duration,\n>         ) = cooler.requests(id);\n> \n> \n>         // Validate terms\n>         if (interest < minimumInterest) \n>             revert InterestMinimum();\n>         if (ltc > maxLTC) \n>             revert LTCMaximum();\n> \n> We see in the above lines that it pulls the requested LTC from the cooler and compares it to maxLTC to confirm it isn't too high. It doesn't use the maxLTC value, it simply functions as a guardrail to make sure it doesn't accidentally clear a bad loan to gives way too much DAI. Technically if the price of gOHM was to increase dramatically the contract would become useless, but it wouldn't lead to any lost/stuck funds and it would be easy enough to just deploy a new contract with different bounds.\n> \n> This should be low severity.\n\nYou've created a valid escalation for 11 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation rejected\n\nAfter careful consideration & internal discussion. Sherlock did not have full context on the intent of the contract. Based on certain assumptions, & as pointed out by the escalation,\nin case of price change, the contract does not seem to serve its purpose and is rendered useless with the same bounds, making this issue a valid medium. \n\n**sherlock-admin**\n\n> Escalation rejected\n> \n> After careful consideration & internal discussion. Sherlock did not have full context on the intent of the contract. Based on certain assumptions, & as pointed out by the escalation,\n> in case of price change, the contract does not seem to serve its purpose and is rendered useless with the same bounds, making this issue a valid medium. \n\nThis issue's escalations have been rejected!\n\nWatsons who escalated this issue will have their escalation amount deducted from their next payout.\n\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/36",
  "Code": [
    {
      "filename": "src/aux/ClearingHouse.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../Factory.sol\";\nimport \"../lib/mininterfaces.sol\";\n\ncontract ClearingHouse {\n    // Errors\n\n    error OnlyApproved();\n    error OnlyFromFactory();\n    error BadEscrow();\n    error InterestMinimum();\n    error LTCMaximum();\n    error DurationMaximum();\n\n    // Roles\n\n    address public operator;\n    address public overseer;\n    address public pendingOperator;\n    address public pendingOverseer;\n\n    // Relevant Contracts\n\n    ERC20 public immutable dai;\n    ERC20 public immutable gOHM;\n    address public immutable treasury;\n    CoolerFactory public immutable factory;\n\n    // Parameter Bounds\n\n    uint256 public constant minimumInterest = 2e16; // 2%\n    uint256 public constant maxLTC = 2_500 * 1e18; // 2,500\n    uint256 public constant maxDuration = 365 days; // 1 year\n\n    constructor (\n        address oper, \n        address over, \n        ERC20 g, \n        ERC20 d, \n        CoolerFactory f, \n        address t\n    ) {\n        operator = oper;\n        overseer = over;\n        gOHM = g;\n        dai = d;\n        factory = f;\n        treasury = t;\n    }\n\n    // Operation\n\n    /// @notice clear a requested loan\n    /// @param cooler contract requesting loan\n    /// @param id of loan in escrow contract\n    function clear (Cooler cooler, uint256 id) external returns (uint256) {\n        if (msg.sender != operator) \n            revert OnlyApproved();\n\n        // Validate escrow\n        if (!factory.created(address(cooler))) \n            revert OnlyFromFactory();\n        if (cooler.collateral() != gOHM || cooler.debt() != dai)\n            revert BadEscrow();\n\n        (\n            uint256 amount, \n            uint256 interest, \n            uint256 ltc, \n            uint256 duration,\n        ) = cooler.requests(id);\n\n        // Validate terms\n        if (interest < minimumInterest) \n            revert InterestMinimum();\n        if (ltc > maxLTC) \n            revert LTCMaximum();\n        if (duration > maxDuration) \n            revert DurationMaximum();\n\n        // Clear loan\n        dai.approve(address(cooler), amount);\n        return cooler.clear(id);\n    }\n\n    /// @notice toggle 'rollable' status of a loan\n    function toggleRoll(Cooler cooler, uint256 loanID) external {\n        if (msg.sender != operator) \n            revert OnlyApproved();\n\n        cooler.toggleRoll(loanID);\n    }\n\n    // Oversight\n\n    /// @notice pull funding from treasury\n    function fund (uint256 amount) external {\n        if (msg.sender != overseer) \n            revert OnlyApproved();\n        ITreasury(treasury).manage(address(dai), amount);\n    }\n\n    /// @notice return funds to treasury\n    /// @param token to transfer\n    /// @param amount to transfer\n    function defund (ERC20 token, uint256 amount) external {\n        if (msg.sender != operator && msg.sender != overseer) \n            revert OnlyApproved();\n        token.transfer(treasury, amount);\n    }\n\n    // Management\n\n    /// @notice operator or overseer can set a new address\n    /// @dev using a push/pull model for safety\n    function push (address newAddress) external {\n        if (msg.sender == overseer) \n            pendingOverseer = newAddress;\n        else if (msg.sender == operator) \n            pendingOperator = newAddress;\n        else revert OnlyApproved();\n    }\n\n    /// @notice new operator or overseer can pull role once pushed\n    function pull () external {\n        if (msg.sender == pendingOverseer) {\n            overseer = pendingOverseer;\n            pendingOverseer = address(0);\n        } else if (msg.sender == pendingOperator) {\n            operator = pendingOperator;\n            pendingOperator = address(0);\n        } else revert OnlyApproved();\n    }\n}"
    },
    {
      "filename": "src/Cooler.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./lib/mininterfaces.sol\";\nimport \"./Factory.sol\";\n\n/// @notice A Cooler is a smart contract escrow that facilitates fixed-duration loans\n///         for a specific user and debt-collateral pair.\ncontract Cooler {\n    // Errors\n\n    error OnlyApproved();\n    error Deactivated();\n    error Default();\n    error NoDefault();\n    error NotRollable();\n\n    // Data Structures\n\n    Request[] public requests;\n    struct Request { // A loan begins with a borrow request. It specifies:\n        uint256 amount; // the amount they want to borrow,\n        uint256 interest; // the annualized percentage they will pay as interest,\n        uint256 loanToCollateral; // the loan-to-collateral ratio they want,\n        uint256 duration; // and the length of time until the loan defaults.\n        bool active; // Any lender can clear an active loan request.\n    } \n\n    Loan[] public loans;\n    struct Loan { // A request is converted to a loan when a lender clears it.\n        Request request; // The terms of the loan are saved, along with:\n        uint256 amount; // the amount of debt owed,\n        uint256 collateral; // the amount of collateral pledged,\n        uint256 expiry; // the time when the loan defaults,\n        bool rollable; // whether the loan can be rolled over,\n        address lender; // and the lender's address.\n    }\n\n    // Facilitates transfer of lender ownership to new address\n    mapping(uint256 => address) public approvals;\n\n    // Immutables\n\n    // This address owns the collateral in escrow.\n    address private immutable owner;\n    // This token is borrowed against.\n    ERC20 public immutable collateral;\n    // This token is lent.\n    ERC20 public immutable debt;\n    // This contract created the Cooler\n    CoolerFactory public immutable factory;\n\n    // This makes the code look prettier.\n    uint256 private constant decimals = 1e18;\n\n    // Initialization\n\n    constructor (address o, ERC20 c, ERC20 d) {\n        owner = o;\n        collateral = c;\n        debt = d;\n        factory = CoolerFactory(msg.sender);\n    }\n\n    // Borrower\n\n    /// @notice request a loan with given parameters\n    /// @notice collateral is taken at time of request\n    /// @param amount of debt tokens to borrow\n    /// @param interest to pay (annualized % of 'amount')\n    /// @param loanToCollateral debt tokens per collateral token pledged\n    /// @param duration of loan tenure in seconds\n    /// @param reqID index of request in requests[]\n    function request (\n        uint256 amount,\n        uint256 interest,\n        uint256 loanToCollateral,\n        uint256 duration\n    ) external returns (uint256 reqID) {\n        reqID = requests.length;\n        factory.newEvent(reqID, CoolerFactory.Events.Request);\n        requests.push(\n            Request(amount, interest, loanToCollateral, duration, true)\n        );\n        collateral.transferFrom(msg.sender, address(this), collateralFor(amount, loanToCollateral));\n    }\n\n    /// @notice cancel a loan request and return collateral\n    /// @param reqID index of request in requests[]\n    function rescind (uint256 reqID) external {\n        if (msg.sender != owner) \n            revert OnlyApproved();\n\n        factory.newEvent(reqID, CoolerFactory.Events.Rescind);\n\n        Request storage req = requests[reqID];\n\n        if (!req.active)\n            revert Deactivated();\n        \n        req.active = false;\n        collateral.transfer(owner, collateralFor(req.amount, req.loanToCollateral));\n    }\n\n    /// @notice repay a loan to recoup collateral\n    /// @param loanID index of loan in loans[]\n    /// @param repaid debt tokens to repay\n    function repay (uint256 loanID, uint256 repaid) external {\n        Loan storage loan = loans[loanID];\n\n        if (block.timestamp > loan.expiry) \n            revert Default();\n        \n        uint256 decollateralized = loan.collateral * repaid / loan.amount;\n\n        if (repaid == loan.amount) delete loans[loanID];\n        else {\n            loan.amount -= repaid;\n            loan.collateral -= decollateralized;\n        }\n\n        debt.transferFrom(msg.sender, loan.lender, repaid);\n        collateral.transfer(owner, decollateralized);\n    }\n\n    /// @notice roll a loan over\n    /// @notice uses terms from request\n    /// @param loanID index of loan in loans[]\n    function roll (uint256 loanID) external {\n        Loan storage loan = loans[loanID];\n        Request memory req = loan.request;\n\n        if (block.timestamp > loan.expiry) \n            revert Default();\n\n        if (!loan.rollable)\n            revert NotRollable();\n\n        uint256 newCollateral = collateralFor(loan.amount, req.loanToCollateral) - loan.collateral;\n        uint256 newDebt = interestFor(loan.amount, req.interest, req.duration);\n\n        loan.amount += newDebt;\n        loan.expiry += req.duration;\n        loan.collateral += newCollateral;\n        \n        collateral.transferFrom(msg.sender, address(this), newCollateral);\n    }\n\n    /// @notice delegate voting power on collateral\n    /// @param to address to delegate\n    function delegate (address to) external {\n        if (msg.sender != owner) \n            revert OnlyApproved();\n        IDelegateERC20(address(collateral)).delegate(to);\n    }\n\n    // Lender\n\n    /// @notice fill a requested loan as a lender\n    /// @param reqID index of request in requests[]\n    /// @param loanID index of loan in loans[]\n    function clear (uint256 reqID) external returns (uint256 loanID) {\n        Request storage req = requests[reqID];\n\n        factory.newEvent(reqID, CoolerFactory.Events.Clear);\n\n        if (!req.active) \n            revert Deactivated();\n        else req.active = false;\n\n        uint256 interest = interestFor(req.amount, req.interest, req.duration);\n        uint256 collat = collateralFor(req.amount, req.loanToCollateral);\n        uint256 expiration = block.timestamp + req.duration;\n\n        loanID = loans.length;\n        loans.push(\n            Loan(req, req.amount + interest, collat, expiration, true, msg.sender)\n        );\n        debt.transferFrom(msg.sender, owner, req.amount);\n    }\n\n    /// @notice change 'rollable' status of loan\n    /// @param loanID index of loan in loans[]\n    /// @return bool new 'rollable' status\n    function toggleRoll(uint256 loanID) external returns (bool) {\n        Loan storage loan = loans[loanID];\n\n        if (msg.sender != loan.lender)\n            revert OnlyApproved();\n\n        loan.rollable = !loan.rollable;\n        return loan.rollable;\n    }\n\n    /// @notice send collateral to lender upon default\n    /// @param loanID index of loan in loans[]\n    /// @return uint256 collateral amount\n    function defaulted (uint256 loanID) external returns (uint256) {\n        Loan memory loan = loans[loanID];\n        delete loans[loanID];\n\n        if (block.timestamp <= loan.expiry) \n            revert NoDefault();\n\n        collateral.transfer(loan.lender, loan.collateral);\n        return loan.collateral;\n    }\n\n    /// @notice approve transfer of loan ownership to new address\n    /// @param to address to approve\n    /// @param loanID index of loan in loans[]\n    function approve (address to, uint256 loanID) external {\n        Loan memory loan = loans[loanID];\n\n        if (msg.sender != loan.lender)\n            revert OnlyApproved();\n\n        approvals[loanID] = to;\n    }\n\n    /// @notice execute approved transfer of loan ownership\n    /// @param loanID index of loan in loans[]\n    function transfer (uint256 loanID) external {\n        if (msg.sender != approvals[loanID])\n            revert OnlyApproved();\n\n        approvals[loanID] = address(0);\n        loans[loanID].lender = msg.sender;\n    }\n\n    // Views\n\n    /// @notice compute collateral needed for loan amount at given loan to collateral ratio\n    /// @param amount of collateral tokens\n    /// @param loanToCollateral ratio for loan\n    function collateralFor(uint256 amount, uint256 loanToCollateral) public pure returns (uint256) {\n        return amount * decimals / loanToCollateral;\n    }\n\n    /// @notice compute interest cost on amount for duration at given annualized rate\n    /// @param amount of debt tokens\n    /// @param rate of interest (annualized)\n    /// @param duration of loan in seconds\n    /// @return interest as a number of debt tokens\n    function interestFor(uint256 amount, uint256 rate, uint256 duration) public pure returns (uint256) {\n        uint256 interest = rate * duration / 365 days;\n        return amount * interest / decimals;\n    }\n\n    /// @notice check if given loan is in default\n    /// @param loanID index of loan in loans[]\n    /// @return defaulted status\n    function isDefaulted(uint256 loanID) external view returns (bool) {\n        return block.timestamp > loans[loanID].expiry;\n    }\n\n    /// @notice check if given request is active\n    /// @param reqID index of request in requests[]\n    /// @return active status\n    function isActive(uint256 reqID) external view returns (bool) {\n        return requests[reqID].active;\n    }\n}"
    }
  ]
}