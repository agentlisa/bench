{
  "Title": "Upgrade Validation and Execution Is Not Strict",
  "Content": "The [`BaseZkSyncUpgrade` contract](https://github.com/matter-labs/era-contracts/blob/2e0734b1ff9cbf3a88aadba6a19c4c4bc8645d33/ethereum/contracts/upgrades/BaseZkSyncUpgrade.sol) is an abstract contract used to perform standardized upgrades on the rollup. To ensure stricter execution and validation in this process, consider the following suggestions.\n\n\nThe `DefaultUpgrade` contract extends the `BaseZkSyncUpgrade` contract to invoke its functions from the overridden [`upgrade` function](https://github.com/matter-labs/era-contracts/blob/2e0734b1ff9cbf3a88aadba6a19c4c4bc8645d33/ethereum/contracts/upgrades/DefaultUpgrade.sol#L25) using the values passed in through the `ProposedUpgrade` struct. In order to enforce that the new values will be set through this struct, and given that the `BaseZkSyncUpgrade` functions will only execute on non-zero inputs (otherwise it will be a no-op), consider moving the invoked functions from `DefaultUpgrade.upgrade` to `BaseZkSyncUpgrade.upgrade` to provide a stricter execution through the parent contract.\n\n\nIn addition, the [`_setVerifier` function](https://github.com/matter-labs/era-contracts/blob/2e0734b1ff9cbf3a88aadba6a19c4c4bc8645d33/ethereum/contracts/upgrades/BaseZkSyncUpgrade.sol#L106) is used to set the verifier contract that will be used on L1 to verify the ZK proofs of the L2 rollup. As the documentation explains, batches that have been committed but not verified with the old verifier cannot be verified afterwards.\n\n\nTo prevent this mistake on a smart contract level, consider checking that the number of batches verified matches the number of the batches committed [in the storage](https://github.com/matter-labs/era-contracts/blob/2e0734b1ff9cbf3a88aadba6a19c4c4bc8645d33/ethereum/contracts/zksync/Storage.sol#L117-L121).\n\n\n***Update:** Resolved in [pull request #158](https://github.com/matter-labs/era-contracts/pull/158/commits/b34ca08fc6a38a25223f0e19ebe0ff11622e07b6) at commit [b34ca08](https://github.com/matter-labs/era-contracts/pull/158/commits/b34ca08fc6a38a25223f0e19ebe0ff11622e07b6). The Matter Labs team stated:*\n\n\n\n> *We decided to not check that all the batches are verified, due to the following reasons:*\n> \n> \n> 1. *Firstly, it is not the only thing that needs to be checked. For instance, we need to ensure that all the batches with the old version have been committed prior to executing the upgrade. This cannot be done on-chain.*\n> 2. *The following scenario is possible:*\n> \t* *We may start an upgrade (that fixes some theoretical issue with the verifier, i.e., the system does not change its logic but there is an edge case whereby a batch may become unprovable and we are trying to fix it).*\n> \t* *Let's assume that we introduced a delay in upgrades (i.e., they are not instant). During the waiting period, the issue has been triggered. Meaning, we cannot achieve the \"all committed blocks must be verified\" requirement without the upgrade itself.*\n> \t* *Now, in order to turn off the \"all committed blocks must be verified\" requirement, we will have to restart the waiting period (or do an emergency upgrade) to use the upgrade implementation that does not enforce it.*\n> \n> \n> *While the benefits are clear, it introduces edge cases that are rather easier to avoid by just always double-checking the requirements off-chain before triggering the upgrade.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "ethereum/contracts/upgrades/DefaultUpgrade.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport \"../zksync/libraries/Diamond.sol\";\nimport \"./BaseZkSyncUpgrade.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ncontract DefaultUpgrade is BaseZkSyncUpgrade {\n    /// @notice Placeholder function for custom logic for upgrading L1 contract.\n    /// Typically this function will never be used.\n    /// @param _customCallDataForUpgrade Custom data for an upgrade, which may be interpreted differently for each\n    /// upgrade.\n    function _upgradeL1Contract(bytes calldata _customCallDataForUpgrade) internal virtual {}\n\n    /// @notice placeholder function for custom logic for post-upgrade logic.\n    /// Typically this function will never be used.\n    /// @param _customCallDataForUpgrade Custom data for an upgrade, which may be interpreted differently for each\n    /// upgrade.\n    function _postUpgrade(bytes calldata _customCallDataForUpgrade) internal virtual {}\n\n    /// @notice The main function that will be called by the upgrade proxy.\n    /// @param _proposedUpgrade The upgrade to be executed.\n    function upgrade(ProposedUpgrade calldata _proposedUpgrade) public override returns (bytes32) {\n        super.upgrade(_proposedUpgrade);\n\n        _setNewProtocolVersion(_proposedUpgrade.newProtocolVersion);\n        _upgradeL1Contract(_proposedUpgrade.l1ContractsUpgradeCalldata);\n        _upgradeVerifier(_proposedUpgrade.verifier, _proposedUpgrade.verifierParams);\n        _setBaseSystemContracts(_proposedUpgrade.bootloaderHash, _proposedUpgrade.defaultAccountHash);\n\n        bytes32 txHash;\n        txHash = _setL2SystemContractUpgrade(\n            _proposedUpgrade.l2ProtocolUpgradeTx,\n            _proposedUpgrade.factoryDeps,\n            _proposedUpgrade.newProtocolVersion\n        );\n\n        _postUpgrade(_proposedUpgrade.postUpgradeCalldata);\n\n        emit UpgradeComplete(_proposedUpgrade.newProtocolVersion, txHash, _proposedUpgrade);\n\n        return Diamond.DIAMOND_INIT_SUCCESS_RETURN_VALUE;\n    }\n}"
    },
    {
      "filename": "ethereum/contracts/upgrades/BaseZkSyncUpgrade.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport \"../zksync/facets/Base.sol\";\nimport \"../zksync/interfaces/IMailbox.sol\";\nimport \"../zksync/interfaces/IVerifier.sol\";\nimport \"../common/libraries/L2ContractHelper.sol\";\nimport \"../zksync/libraries/TransactionValidator.sol\";\nimport {SYSTEM_UPGRADE_L2_TX_TYPE, MAX_NEW_FACTORY_DEPS, MAX_ALLOWED_PROTOCOL_VERSION_DELTA} from \"../zksync/Config.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice Interface to which all the upgrade implementations should adhere\nabstract contract BaseZkSyncUpgrade is Base {\n    /// @notice The struct that represents the upgrade proposal.\n    /// @param l2ProtocolUpgradeTx The system upgrade transaction.\n    /// @param factoryDeps The list of factory deps for the l2ProtocolUpgradeTx.\n    /// @param bootloaderHash The hash of the new bootloader bytecode. If zero, it will not be updated.\n    /// @param defaultAccountHash The hash of the new default account bytecode. If zero, it will not be updated.\n    /// @param verifier The address of the new verifier. If zero, the verifier will not be updated.\n    /// @param verifierParams The new verifier params. If either of its fields is 0, the params will not be updated.\n    /// @param l1ContractsUpgradeCalldata Custom calldata for L1 contracts upgrade, it may be interpreted differently\n    /// in each upgrade. Usually empty.\n    /// @param postUpgradeCalldata Custom calldata for post upgrade hook, it may be interpreted differently in each\n    /// upgrade. Usually empty.\n    /// @param upgradeTimestamp The timestamp after which the upgrade can be executed.\n    /// @param newProtocolVersion The new version number for the protocol after this upgrade. Should be greater than\n    /// the previous protocol version.\n    struct ProposedUpgrade {\n        IMailbox.L2CanonicalTransaction l2ProtocolUpgradeTx;\n        bytes[] factoryDeps;\n        bytes32 bootloaderHash;\n        bytes32 defaultAccountHash;\n        address verifier;\n        VerifierParams verifierParams;\n        bytes l1ContractsUpgradeCalldata;\n        bytes postUpgradeCalldata;\n        uint256 upgradeTimestamp;\n        uint256 newProtocolVersion;\n    }\n\n    /// @notice Changes the protocol version\n    event NewProtocolVersion(uint256 indexed previousProtocolVersion, uint256 indexed newProtocolVersion);\n\n    /// @notice Сhanges to the bytecode that is used in L2 as a bootloader (start program)\n    event NewL2BootloaderBytecodeHash(bytes32 indexed previousBytecodeHash, bytes32 indexed newBytecodeHash);\n\n    /// @notice Сhanges to the bytecode that is used in L2 as a default account\n    event NewL2DefaultAccountBytecodeHash(bytes32 indexed previousBytecodeHash, bytes32 indexed newBytecodeHash);\n\n    /// @notice Verifier address changed\n    event NewVerifier(address indexed oldVerifier, address indexed newVerifier);\n\n    /// @notice Verifier parameters changed\n    event NewVerifierParams(VerifierParams oldVerifierParams, VerifierParams newVerifierParams);\n\n    /// @notice Notifies about complete upgrade\n    event UpgradeComplete(uint256 indexed newProtocolVersion, bytes32 indexed l2UpgradeTxHash, ProposedUpgrade upgrade);\n\n    /// @notice The main function that will be provided by the upgrade proxy\n    function upgrade(ProposedUpgrade calldata _proposedUpgrade) public virtual returns (bytes32) {\n        // Note that due to commitment delay, the timestamp of the L2 upgrade batch may be earlier than the timestamp\n        // of the L1 block at which the upgrade occured. This means that using timestamp as a signifier of \"upgraded\"\n        // on the L2 side would be inaccurate. The effects of this \"back-dating\" of L2 upgrade batches will be reduced\n        // as the permitted delay window is reduced in the future.\n        require(block.timestamp >= _proposedUpgrade.upgradeTimestamp, \"Upgrade is not ready yet\");\n    }\n\n    /// @notice Change default account bytecode hash, that is used on L2\n    /// @param _l2DefaultAccountBytecodeHash The hash of default account L2 bytecode\n    function _setL2DefaultAccountBytecodeHash(bytes32 _l2DefaultAccountBytecodeHash) private {\n        if (_l2DefaultAccountBytecodeHash == bytes32(0)) {\n            return;\n        }\n\n        L2ContractHelper.validateBytecodeHash(_l2DefaultAccountBytecodeHash);\n\n        // Save previous value into the stack to put it into the event later\n        bytes32 previousDefaultAccountBytecodeHash = s.l2DefaultAccountBytecodeHash;\n\n        // Change the default account bytecode hash\n        s.l2DefaultAccountBytecodeHash = _l2DefaultAccountBytecodeHash;\n        emit NewL2DefaultAccountBytecodeHash(previousDefaultAccountBytecodeHash, _l2DefaultAccountBytecodeHash);\n    }\n\n    /// @notice Change bootloader bytecode hash, that is used on L2\n    /// @param _l2BootloaderBytecodeHash The hash of bootloader L2 bytecode\n    function _setL2BootloaderBytecodeHash(bytes32 _l2BootloaderBytecodeHash) private {\n        if (_l2BootloaderBytecodeHash == bytes32(0)) {\n            return;\n        }\n\n        L2ContractHelper.validateBytecodeHash(_l2BootloaderBytecodeHash);\n\n        // Save previous value into the stack to put it into the event later\n        bytes32 previousBootloaderBytecodeHash = s.l2BootloaderBytecodeHash;\n\n        // Change the bootloader bytecode hash\n        s.l2BootloaderBytecodeHash = _l2BootloaderBytecodeHash;\n        emit NewL2BootloaderBytecodeHash(previousBootloaderBytecodeHash, _l2BootloaderBytecodeHash);\n    }\n\n    /// @notice Change the address of the verifier smart contract\n    /// @param _newVerifier Verifier smart contract address\n    function _setVerifier(IVerifier _newVerifier) private {\n        // An upgrade to the verifier must be done carefully to ensure there aren't batches in the committed state\n        // during the transition. If verifier is upgraded, it will immediately be used to prove all committed batches.\n        // Batches committed expecting the old verifier will fail. Ensure all commited batches are finalized before the\n        // verifier is upgraded.\n        if (_newVerifier == IVerifier(address(0))) {\n            return;\n        }\n\n        IVerifier oldVerifier = s.verifier;\n        s.verifier = _newVerifier;\n        emit NewVerifier(address(oldVerifier), address(_newVerifier));\n    }\n\n    /// @notice Change the verifier parameters\n    /// @param _newVerifierParams New parameters for the verifier\n    function _setVerifierParams(VerifierParams calldata _newVerifierParams) private {\n        if (\n            _newVerifierParams.recursionNodeLevelVkHash == bytes32(0) &&\n            _newVerifierParams.recursionLeafLevelVkHash == bytes32(0) &&\n            _newVerifierParams.recursionCircuitsSetVksHash == bytes32(0)\n        ) {\n            return;\n        }\n\n        VerifierParams memory oldVerifierParams = s.verifierParams;\n        s.verifierParams = _newVerifierParams;\n        emit NewVerifierParams(oldVerifierParams, _newVerifierParams);\n    }\n\n    /// @notice Updates the verifier and the verifier params\n    /// @param _newVerifier The address of the new verifier. If 0, the verifier will not be updated.\n    /// @param _verifierParams The new verifier params. If either of the fields is 0, the params will not be updated.\n    function _upgradeVerifier(address _newVerifier, VerifierParams calldata _verifierParams) internal {\n        _setVerifier(IVerifier(_newVerifier));\n        _setVerifierParams(_verifierParams);\n    }\n\n    /// @notice Updates the bootloader hash and the hash of the default account\n    /// @param _bootloaderHash The hash of the new bootloader bytecode. If zero, it will not be updated.\n    /// @param _defaultAccountHash The hash of the new default account bytecode. If zero, it will not be updated.\n    function _setBaseSystemContracts(bytes32 _bootloaderHash, bytes32 _defaultAccountHash) internal {\n        _setL2BootloaderBytecodeHash(_bootloaderHash);\n        _setL2DefaultAccountBytecodeHash(_defaultAccountHash);\n    }\n\n    /// @notice Sets the hash of the L2 system contract upgrade transaction for the next batch to be committed\n    /// @dev If the transaction is noop (i.e. its type is 0) it does nothing and returns 0.\n    /// @param _l2ProtocolUpgradeTx The L2 system contract upgrade transaction.\n    /// @return System contracts upgrade transaction hash. Zero if no upgrade transaction is set.\n    function _setL2SystemContractUpgrade(\n        IMailbox.L2CanonicalTransaction calldata _l2ProtocolUpgradeTx,\n        bytes[] calldata _factoryDeps,\n        uint256 _newProtocolVersion\n    ) internal returns (bytes32) {\n        // If the type is 0, it is considered as noop and so will not be required to be executed.\n        if (_l2ProtocolUpgradeTx.txType == 0) {\n            return bytes32(0);\n        }\n\n        require(_l2ProtocolUpgradeTx.txType == SYSTEM_UPGRADE_L2_TX_TYPE, \"L2 system upgrade tx type is wrong\");\n\n        bytes memory encodedTransaction = abi.encode(_l2ProtocolUpgradeTx);\n\n        TransactionValidator.validateL1ToL2Transaction(\n            _l2ProtocolUpgradeTx,\n            encodedTransaction,\n            s.priorityTxMaxGasLimit,\n            s.feeParams.priorityTxMaxPubdata\n        );\n\n        TransactionValidator.validateUpgradeTransaction(_l2ProtocolUpgradeTx);\n\n        // We want the hashes of l2 system upgrade transactions to be unique.\n        // This is why we require that the `nonce` field is unique to each upgrade.\n        require(\n            _l2ProtocolUpgradeTx.nonce == _newProtocolVersion,\n            \"The new protocol version should be included in the L2 system upgrade tx\"\n        );\n\n        _verifyFactoryDeps(_factoryDeps, _l2ProtocolUpgradeTx.factoryDeps);\n\n        bytes32 l2ProtocolUpgradeTxHash = keccak256(encodedTransaction);\n        s.l2SystemContractsUpgradeTxHash = l2ProtocolUpgradeTxHash;\n        return l2ProtocolUpgradeTxHash;\n    }\n\n    /// @notice Verifies that the factory deps correspond to the proper hashes\n    /// @param _factoryDeps The list of factory deps\n    /// @param _expectedHashes The list of expected bytecode hashes\n    function _verifyFactoryDeps(bytes[] calldata _factoryDeps, uint256[] calldata _expectedHashes) private pure {\n        require(_factoryDeps.length == _expectedHashes.length, \"Wrong number of factory deps\");\n        require(_factoryDeps.length <= MAX_NEW_FACTORY_DEPS, \"Factory deps can be at most 32\");\n\n        for (uint256 i = 0; i < _factoryDeps.length; ++i) {\n            require(\n                L2ContractHelper.hashL2Bytecode(_factoryDeps[i]) == bytes32(_expectedHashes[i]),\n                \"Wrong factory dep hash\"\n            );\n        }\n    }\n\n    /// @notice Changes the protocol version\n    /// @param _newProtocolVersion The new protocol version\n    function _setNewProtocolVersion(uint256 _newProtocolVersion) internal {\n        uint256 previousProtocolVersion = s.protocolVersion;\n        require(\n            _newProtocolVersion > previousProtocolVersion,\n            \"New protocol version is not greater than the current one\"\n        );\n        require(\n            _newProtocolVersion - previousProtocolVersion <= MAX_ALLOWED_PROTOCOL_VERSION_DELTA,\n            \"Too big protocol version difference\"\n        );\n\n        // If the previous upgrade had an L2 system upgrade transaction, we require that it is finalized.\n        require(s.l2SystemContractsUpgradeTxHash == bytes32(0), \"Previous upgrade has not been finalized\");\n        require(\n            s.l2SystemContractsUpgradeBatchNumber == 0,\n            \"The batch number of the previous upgrade has not been cleaned\"\n        );\n\n        s.protocolVersion = _newProtocolVersion;\n        emit NewProtocolVersion(previousProtocolVersion, _newProtocolVersion);\n    }\n}"
    },
    {
      "filename": "ethereum/contracts/zksync/Storage.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport \"./../zksync/interfaces/IVerifier.sol\";\nimport \"./libraries/PriorityQueue.sol\";\n\n/// @notice Indicates whether an upgrade is initiated and if yes what type\n/// @param None Upgrade is NOT initiated\n/// @param Transparent Fully transparent upgrade is initiated, upgrade data is publicly known\n/// @param Shadow Shadow upgrade is initiated, upgrade data is hidden\nenum UpgradeState {\n    None,\n    Transparent,\n    Shadow\n}\n\n/// @dev Logically separated part of the storage structure, which is responsible for everything related to proxy\n/// upgrades and diamond cuts\n/// @param proposedUpgradeHash The hash of the current upgrade proposal, zero if there is no active proposal\n/// @param state Indicates whether an upgrade is initiated and if yes what type\n/// @param securityCouncil Address which has the permission to approve instant upgrades (expected to be a Gnosis\n/// multisig)\n/// @param approvedBySecurityCouncil Indicates whether the security council has approved the upgrade\n/// @param proposedUpgradeTimestamp The timestamp when the upgrade was proposed, zero if there are no active proposals\n/// @param currentProposalId The serial number of proposed upgrades, increments when proposing a new one\nstruct UpgradeStorage {\n    bytes32 proposedUpgradeHash;\n    UpgradeState state;\n    address securityCouncil;\n    bool approvedBySecurityCouncil;\n    uint40 proposedUpgradeTimestamp;\n    uint40 currentProposalId;\n}\n\n/// @dev The log passed from L2\n/// @param l2ShardId The shard identifier, 0 - rollup, 1 - porter. All other values are not used but are reserved for\n/// the future\n/// @param isService A boolean flag that is part of the log along with `key`, `value`, and `sender` address.\n/// This field is required formally but does not have any special meaning.\n/// @param txNumberInBatch The L2 transaction number in the batch, in which the log was sent\n/// @param sender The L2 address which sent the log\n/// @param key The 32 bytes of information that was sent in the log\n/// @param value The 32 bytes of information that was sent in the log\n// Both `key` and `value` are arbitrary 32-bytes selected by the log sender\nstruct L2Log {\n    uint8 l2ShardId;\n    bool isService;\n    uint16 txNumberInBatch;\n    address sender;\n    bytes32 key;\n    bytes32 value;\n}\n\n/// @dev An arbitrary length message passed from L2\n/// @notice Under the hood it is `L2Log` sent from the special system L2 contract\n/// @param txNumberInBatch The L2 transaction number in the batch, in which the message was sent\n/// @param sender The address of the L2 account from which the message was passed\n/// @param data An arbitrary length message\nstruct L2Message {\n    uint16 txNumberInBatch;\n    address sender;\n    bytes data;\n}\n\n/// @notice Part of the configuration parameters of ZKP circuits\nstruct VerifierParams {\n    bytes32 recursionNodeLevelVkHash;\n    bytes32 recursionLeafLevelVkHash;\n    bytes32 recursionCircuitsSetVksHash;\n}\n\n/// @notice The struct that describes for the users will be charged for pubdata for L1->L2 transactions.\n/// @param Rollup The users are charged for pubdata & it is priced based on the gas price on Ethereum.\n/// @param Validium The pubdata is considered free with regard to the L1 gas price.\nenum PubdataPricingMode {\n    Rollup,\n    Validium\n}\n\n/// @notice The fee params for L1->L2 transactions for the network.\n/// @param pubdataPricingMode How the users will charged for pubdata in L1->L2 transactions.\n/// @param batchOverheadL1Gas The amount of L1 gas required to process the batch (except for the calldata).\n/// @param maxPubdataPerBatch The maximal number of pubdata that can be emitted per batch.\n/// @param priorityTxMaxPubdata The maximal amount of pubdata a priority transaction is allowed to publish.\n/// It can be slightly less than maxPubdataPerBatch in order to have some margin for the bootloader execution.\n/// @param minimalL2GasPrice The minimal L2 gas price to be used by L1->L2 transactions. It should represent\n/// the price that a single unit of compute costs.\nstruct FeeParams {\n    PubdataPricingMode pubdataPricingMode;\n    uint32 batchOverheadL1Gas;\n    uint32 maxPubdataPerBatch;\n    uint32 maxL2GasPerBatch;\n    uint32 priorityTxMaxPubdata;\n    uint64 minimalL2GasPrice;\n}\n\n/// @dev storing all storage variables for zkSync facets\n/// NOTE: It is used in a proxy, so it is possible to add new variables to the end\n/// but NOT to modify already existing variables or change their order.\n/// NOTE: variables prefixed with '__DEPRECATED_' are deprecated and shouldn't be used.\n/// Their presence is maintained for compatibility and to prevent storage collision.\nstruct AppStorage {\n    /// @dev Storage of variables needed for deprecated diamond cut facet\n    uint256[7] __DEPRECATED_diamondCutStorage;\n    /// @notice Address which will exercise critical changes to the Diamond Proxy (upgrades, freezing & unfreezing)\n    address governor;\n    /// @notice Address that the governor proposed as one that will replace it\n    address pendingGovernor;\n    /// @notice List of permitted validators\n    mapping(address => bool) validators;\n    /// @dev Verifier contract. Used to verify aggregated proof for batches\n    IVerifier verifier;\n    /// @notice Total number of executed batches i.e. batches[totalBatchesExecuted] points at the latest executed batch\n    /// (batch 0 is genesis)\n    uint256 totalBatchesExecuted;\n    /// @notice Total number of proved batches i.e. batches[totalBatchesProved] points at the latest proved batch\n    uint256 totalBatchesVerified;\n    /// @notice Total number of committed batches i.e. batches[totalBatchesCommitted] points at the latest committed\n    /// batch\n    uint256 totalBatchesCommitted;\n    /// @dev Stored hashed StoredBatch for batch number\n    mapping(uint256 => bytes32) storedBatchHashes;\n    /// @dev Stored root hashes of L2 -> L1 logs\n    mapping(uint256 => bytes32) l2LogsRootHashes;\n    /// @dev Container that stores transactions requested from L1\n    PriorityQueue.Queue priorityQueue;\n    /// @dev The smart contract that manages the list with permission to call contract functions\n    address __DEPRECATED_allowList;\n    /// @notice Part of the configuration parameters of ZKP circuits. Used as an input for the verifier smart contract\n    VerifierParams verifierParams;\n    /// @notice Bytecode hash of bootloader program.\n    /// @dev Used as an input to zkp-circuit.\n    bytes32 l2BootloaderBytecodeHash;\n    /// @notice Bytecode hash of default account (bytecode for EOA).\n    /// @dev Used as an input to zkp-circuit.\n    bytes32 l2DefaultAccountBytecodeHash;\n    /// @dev Indicates that the porter may be touched on L2 transactions.\n    /// @dev Used as an input to zkp-circuit.\n    bool zkPorterIsAvailable;\n    /// @dev The maximum number of the L2 gas that a user can request for L1 -> L2 transactions\n    /// @dev This is the maximum number of L2 gas that is available for the \"body\" of the transaction, i.e.\n    /// without overhead for proving the batch.\n    uint256 priorityTxMaxGasLimit;\n    /// @dev Storage of variables needed for upgrade facet\n    UpgradeStorage __DEPRECATED_upgrades;\n    /// @dev A mapping L2 batch number => message number => flag.\n    /// @dev The L2 -> L1 log is sent for every withdrawal, so this mapping is serving as\n    /// a flag to indicate that the message was already processed.\n    /// @dev Used to indicate that eth withdrawal was already processed\n    mapping(uint256 => mapping(uint256 => bool)) isEthWithdrawalFinalized;\n    /// @dev The most recent withdrawal time and amount reset\n    uint256 __DEPRECATED_lastWithdrawalLimitReset;\n    /// @dev The accumulated withdrawn amount during the withdrawal limit window\n    uint256 __DEPRECATED_withdrawnAmountInWindow;\n    /// @dev A mapping user address => the total deposited amount by the user\n    mapping(address => uint256) totalDepositedAmountPerUser;\n    /// @dev Stores the protocol version. Note, that the protocol version may not only encompass changes to the\n    /// smart contracts, but also to the node behavior.\n    uint256 protocolVersion;\n    /// @dev Hash of the system contract upgrade transaction. If 0, then no upgrade transaction needs to be done.\n    bytes32 l2SystemContractsUpgradeTxHash;\n    /// @dev Batch number where the upgrade transaction has happened. If 0, then no upgrade transaction has happened\n    /// yet.\n    uint256 l2SystemContractsUpgradeBatchNumber;\n    /// @dev Address which will exercise non-critical changes to the Diamond Proxy (changing validator set & unfreezing)\n    address admin;\n    /// @notice Address that the governor or admin proposed as one that will replace admin role\n    address pendingAdmin;\n    /// @dev Fee params used to derive gasPrice for the L1->L2 transactions. For L2 transactions,\n    /// the bootloader gives enough freedom to the operator.\n    FeeParams feeParams;\n}"
    }
  ]
}