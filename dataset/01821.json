{
  "Title": "M-7: Stop-loss orders do not become marketable orders",
  "Content": "# Issue M-7: Stop-loss orders do not become marketable orders \n\nSource: https://github.com/sherlock-audit/2023-04-gmx-judging/issues/233 \n\n## Found by \nCh\\_301, IllIllI, ShadowForce, lemonmon\n## Summary\n\nStop-loss orders do not execute if the market has moved since the order was submitted.\n\n\n## Vulnerability Detail\n\nThis is the normal behavior for a stop-loss order in financial markets: \"A stop-loss order becomes a market order as soon as the stop-loss price is reached. Since the stop loss becomes a market order, execution of the order is guaranteed, but not the price.\" - https://www.wikihow.com/Set-Up-a-Stop%E2%80%90loss-Order . In the GMX system, stop-loss orders will be unexecutable if the price has moved since the order was submitted to the mempool, because the primary and secondary prices are required to straddle the trigger price.\n\nAnother way this could happen is if there's an oracle outage, and the oracles come back after the trigger price has been passed.\n\n## Impact\n\nSince the stop-loss will revert if a keeper tries to execute it, essentially the order becomes wedged and there will be no stoploss protection.\n\nConsider a scenario where the price of token X is $100, and a user who is long is in a profit above $99, but will have a loss at $98, so they set a stoploss with a trigger price of $99 and submit the order to the mempool. By the time the block gets mined 12 seconds later, the primary and secondary prices are $97/$96, and the order becomes unexecutable.\n\n\n## Code Snippet\n\nStop-loss orders revert if the primary price and secondary price don't straddle the trigger price\n```solidity\n// File: gmx-synthetics/contracts/order/BaseOrderUtils.sol : BaseOrderUtils.ok   #1\n\n270    \n271            if (orderType == Order.OrderType.StopLossDecrease) {\n272                uint256 primaryPrice = oracle.getPrimaryPrice(indexToken).pickPrice(shouldUseMaxPrice);\n273                uint256 secondaryPrice = oracle.getSecondaryPrice(indexToken).pickPrice(shouldUseMaxPrice);\n274    \n275                // for stop-loss decrease orders:\n276                //     - long: validate descending price\n277                //     - short: validate ascending price\n278                bool shouldValidateAscendingPrice = !isLong;\n279    \n280 @>             bool ok = shouldValidateAscendingPrice ?\n281                    (primaryPrice <= triggerPrice && triggerPrice <= secondaryPrice) :\n282                    (primaryPrice >= triggerPrice && triggerPrice >= secondaryPrice);\n283    \n284                if (!ok) {\n285                    revert Errors.InvalidStopLossOrderPrices(primaryPrice, secondaryPrice, triggerPrice, shouldValidateAscendingPrice);\n286:               }\n```\nhttps://github.com/sherlock-audit/2023-04-gmx/blob/main/gmx-synthetics/contracts/order/BaseOrderUtils.sol#L270-L286\n\nThe revert is allowed to cause the order to fail:\n```solidity\n// File: gmx-synthetics/contracts/exchange/OrderHandler.sol : OrderHandler._handleOrderError()   #2\n\n263                // the transaction is reverted for InvalidLimitOrderPrices and\n264                // InvalidStopLossOrderPrices errors since since the oracle prices\n265                // do not fulfill the specified trigger price\n266                errorSelector == Errors.InvalidLimitOrderPrices.selector ||\n267 @>             errorSelector == Errors.InvalidStopLossOrderPrices.selector\n268            ) {\n269                ErrorUtils.revertWithCustomError(reasonBytes);\n270:           }\n```\nhttps://github.com/sherlock-audit/2023-04-gmx/blob/main/gmx-synthetics/contracts/exchange/OrderHandler.sol#L263-L270\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nDon't revert if both the primary and secondary prices are worse than the trigger price.\n\n\n\n\n\n## Discussion\n\n**xvi10**\n\nwould classify this as a medium, the oracle should sign a price in the block in which the order was submitted, the likelihood that the price was out of range by then should be small, it is somewhat similar to the chance of submitting a market order and price moves past the acceptable price\n\n**Jiaren-tang**\n\nEscalate for 10 USDC. \n\nthe severity should be high.\n\nthe impact:\n\n> Since the stop-loss will revert if a keeper tries to execute it, essentially the order becomes wedged and there will be no stoploss protection\n\nbasically this is equal to lack of slippage protection!\n\n**sherlock-admin**\n\n > Escalate for 10 USDC. \n> \n> the severity should be high.\n> \n> the impact:\n> \n> > Since the stop-loss will revert if a keeper tries to execute it, essentially the order becomes wedged and there will be no stoploss protection\n> \n> basically this is equal to lack of slippage protection!\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**IllIllI000**\n\nWill leave this up to Sherlock\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\nIn addition to the Sponsor comment, This requires the market to change before the order gets mined or an oracle outage. \nThis is a valid medium. \n\n**sherlock-admin**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [ShadowForce](https://github.com/sherlock-audit/2023-04-gmx-judging/issues/233/#issuecomment-1598701349): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/74",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/order/BaseOrderUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./Order.sol\";\nimport \"../market/Market.sol\";\n\nimport \"../data/DataStore.sol\";\nimport \"../event/EventEmitter.sol\";\n\nimport \"../order/OrderVault.sol\";\n\nimport \"../oracle/Oracle.sol\";\nimport \"../swap/SwapHandler.sol\";\n\n// @title Order\n// @dev Library for common order functions used in OrderUtils, IncreaseOrderUtils\n// DecreaseOrderUtils, SwapOrderUtils\nlibrary BaseOrderUtils {\n    using SafeCast for int256;\n    using SafeCast for uint256;\n\n    using Order for Order.Props;\n    using Price for Price.Props;\n\n    // @dev CreateOrderParams struct used in createOrder to avoid stack\n    // too deep errors\n    //\n    // @param addresses address values\n    // @param numbers number values\n    // @param orderType for order.orderType\n    // @param decreasePositionSwapType for order.decreasePositionSwapType\n    // @param isLong for order.isLong\n    // @param shouldUnwrapNativeToken for order.shouldUnwrapNativeToken\n    struct CreateOrderParams {\n        CreateOrderParamsAddresses addresses;\n        CreateOrderParamsNumbers numbers;\n        Order.OrderType orderType;\n        Order.DecreasePositionSwapType decreasePositionSwapType;\n        bool isLong;\n        bool shouldUnwrapNativeToken;\n        bytes32 referralCode;\n    }\n\n    // @param receiver for order.receiver\n    // @param callbackContract for order.callbackContract\n    // @param market for order.market\n    // @param initialCollateralToken for order.initialCollateralToken\n    // @param swapPath for order.swapPath\n    struct CreateOrderParamsAddresses {\n        address receiver;\n        address callbackContract;\n        address uiFeeReceiver;\n        address market;\n        address initialCollateralToken;\n        address[] swapPath;\n    }\n\n    // @param sizeDeltaUsd for order.sizeDeltaUsd\n    // @param triggerPrice for order.triggerPrice\n    // @param acceptablePrice for order.acceptablePrice\n    // @param executionFee for order.executionFee\n    // @param callbackGasLimit for order.callbackGasLimit\n    // @param minOutputAmount for order.minOutputAmount\n    struct CreateOrderParamsNumbers {\n        uint256 sizeDeltaUsd;\n        uint256 initialCollateralDeltaAmount;\n        uint256 triggerPrice;\n        uint256 acceptablePrice;\n        uint256 executionFee;\n        uint256 callbackGasLimit;\n        uint256 minOutputAmount;\n    }\n\n    // @dev ExecuteOrderParams struct used in executeOrder to avoid stack\n    // too deep errors\n    //\n    // @param contracts ExecuteOrderParamsContracts\n    // @param key the key of the order to execute\n    // @param order the order to execute\n    // @param swapPathMarkets the market values of the markets in the swapPath\n    // @param minOracleBlockNumbers the min oracle block numbers\n    // @param maxOracleBlockNumbers the max oracle block numbers\n    // @param market market values of the trading market\n    // @param keeper the keeper sending the transaction\n    // @param startingGas the starting gas\n    // @param positionKey the key of the order's position\n    struct ExecuteOrderParams {\n        ExecuteOrderParamsContracts contracts;\n        bytes32 key;\n        Order.Props order;\n        Market.Props[] swapPathMarkets;\n        uint256[] minOracleBlockNumbers;\n        uint256[] maxOracleBlockNumbers;\n        Market.Props market;\n        address keeper;\n        uint256 startingGas;\n        bytes32 positionKey;\n    }\n\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param orderVault OrderVault\n    // @param oracle Oracle\n    // @param swapHandler SwapHandler\n    // @param referralStorage IReferralStorage\n    struct ExecuteOrderParamsContracts {\n        DataStore dataStore;\n        EventEmitter eventEmitter;\n        OrderVault orderVault;\n        Oracle oracle;\n        SwapHandler swapHandler;\n        IReferralStorage referralStorage;\n    }\n\n    // @dev check if an orderType is a market order\n    // @param orderType the order type\n    // @return whether an orderType is a market order\n    function isMarketOrder(Order.OrderType orderType) internal pure returns (bool) {\n        return orderType == Order.OrderType.MarketSwap ||\n               orderType == Order.OrderType.MarketIncrease ||\n               orderType == Order.OrderType.MarketDecrease ||\n               orderType == Order.OrderType.Liquidation;\n    }\n\n    // @dev check if an orderType is a limit order\n    // @param orderType the order type\n    // @return whether an orderType is a limit order\n    function isLimitOrder(Order.OrderType orderType) internal pure returns (bool) {\n        return orderType == Order.OrderType.LimitSwap ||\n               orderType == Order.OrderType.LimitIncrease ||\n               orderType == Order.OrderType.LimitDecrease;\n    }\n\n    // @dev check if an orderType is a swap order\n    // @param orderType the order type\n    // @return whether an orderType is a swap order\n    function isSwapOrder(Order.OrderType orderType) internal pure returns (bool) {\n        return orderType == Order.OrderType.MarketSwap ||\n               orderType == Order.OrderType.LimitSwap;\n    }\n\n    // @dev check if an orderType is a position order\n    // @param orderType the order type\n    // @return whether an orderType is a position order\n    function isPositionOrder(Order.OrderType orderType) internal pure returns (bool) {\n        return isIncreaseOrder(orderType) || isDecreaseOrder(orderType);\n    }\n\n    // @dev check if an orderType is an increase order\n    // @param orderType the order type\n    // @return whether an orderType is an increase order\n    function isIncreaseOrder(Order.OrderType orderType) internal pure returns (bool) {\n        return orderType == Order.OrderType.MarketIncrease ||\n               orderType == Order.OrderType.LimitIncrease;\n    }\n\n    // @dev check if an orderType is a decrease order\n    // @param orderType the order type\n    // @return whether an orderType is a decrease order\n    function isDecreaseOrder(Order.OrderType orderType) internal pure returns (bool) {\n        return orderType == Order.OrderType.MarketDecrease ||\n               orderType == Order.OrderType.LimitDecrease ||\n               orderType == Order.OrderType.StopLossDecrease ||\n               orderType == Order.OrderType.Liquidation;\n    }\n\n    // @dev check if an orderType is a liquidation order\n    // @param orderType the order type\n    // @return whether an orderType is a liquidation order\n    function isLiquidationOrder(Order.OrderType orderType) internal pure returns (bool) {\n        return orderType == Order.OrderType.Liquidation;\n    }\n\n    // @dev set the price for increase / decrease position orders\n    //\n    // for market orders, set the min and max values of the customPrice for the indexToken\n    // to either primaryPrice.min or primaryPrice.max depending on whether the order\n    // is an increase or decrease and whether it is for a long or short\n    //\n    // customPrice.min and customPrice.max will be equal in this case\n    // this is because in getExecutionPrice the function will try to use the closest price which can fulfill\n    // the order, if customPrice.min is set to primaryPrice.min and customPrice.max is set to primaryPrice.max\n    // getExecutionPrice will pick a better price than what should be possible\n    //\n    // for limit orders, the the min and max value will be set to the triggerPrice\n    // and primaryPrice value, this represents the price that the user desired the order\n    // to be fulfilled at and the best oracle price that the order can be fulfilled at\n    //\n    // for stop-loss orders, the min and max value will be set to the triggerPrice value\n    // the primaryPrice and secondaryPrice are not used because the primaryPrice is a stale\n    // value and cannot be used as it would result in executing at a better price than what\n    // should be possible, the secondaryPrice is a worse price than the triggerPrice, so\n    // it should not need to be considered\n    //\n    // getExecutionPrice handles the logic for selecting the execution price to use\n    //\n    // @param oracle Oracle\n    // @param indexToken the index token\n    // @param orderType the order type\n    // @param triggerPrice the order's triggerPrice\n    // @param isLong whether the order is for a long or short\n    function setExactOrderPrice(\n        Oracle oracle,\n        address indexToken,\n        Order.OrderType orderType,\n        uint256 triggerPrice,\n        bool isLong\n    ) internal {\n        if (isSwapOrder(orderType)) {\n            return;\n        }\n\n        bool isIncrease = isIncreaseOrder(orderType);\n        // increase order:\n        //     - long: use the larger price\n        //     - short: use the smaller price\n        // decrease order:\n        //     - long: use the smaller price\n        //     - short: use the larger price\n        bool shouldUseMaxPrice = isIncrease ? isLong : !isLong;\n\n        if (orderType == Order.OrderType.MarketIncrease ||\n            orderType == Order.OrderType.MarketDecrease ||\n            orderType == Order.OrderType.Liquidation) {\n\n            Price.Props memory price = oracle.getPrimaryPrice(indexToken);\n\n            oracle.setCustomPrice(indexToken, Price.Props(\n                price.pickPrice(shouldUseMaxPrice),\n                price.pickPrice(shouldUseMaxPrice)\n            ));\n\n            return;\n        }\n\n        if (orderType == Order.OrderType.LimitIncrease ||\n            orderType == Order.OrderType.LimitDecrease\n        ) {\n            uint256 primaryPrice = oracle.getPrimaryPrice(indexToken).pickPrice(shouldUseMaxPrice);\n\n            // for limit increase orders:\n            //      - long: validate primaryPrice < triggerPrice\n            //      - short: validate primaryPrice > triggerPrice\n            // for limit decrease orders:\n            //      - long: validate primaryPrice > triggerPrice\n            //      - short: validate primaryPrice < triggerPrice\n            bool shouldValidateSmallerPrimaryPrice = shouldUseMaxPrice;\n\n            bool ok = shouldValidateSmallerPrimaryPrice ? primaryPrice <= triggerPrice : primaryPrice >= triggerPrice;\n\n            if (!ok) {\n                revert Errors.InvalidLimitOrderPrices(primaryPrice, triggerPrice, shouldValidateSmallerPrimaryPrice);\n            }\n\n            if (shouldValidateSmallerPrimaryPrice) {\n                oracle.setCustomPrice(indexToken, Price.Props(\n                    primaryPrice, // min price that order can be executed with\n                    triggerPrice // max price that order can be executed with\n                ));\n            } else {\n                oracle.setCustomPrice(indexToken, Price.Props(\n                    triggerPrice, // min price that order can be executed with\n                    primaryPrice // max price that order can be executed with\n                ));\n            }\n\n            return;\n        }\n\n        if (orderType == Order.OrderType.StopLossDecrease) {\n            uint256 primaryPrice = oracle.getPrimaryPrice(indexToken).pickPrice(shouldUseMaxPrice);\n            uint256 secondaryPrice = oracle.getSecondaryPrice(indexToken).pickPrice(shouldUseMaxPrice);\n\n            // for stop-loss decrease orders:\n            //     - long: validate descending price\n            //     - short: validate ascending price\n            bool shouldValidateAscendingPrice = !isLong;\n\n            bool ok = shouldValidateAscendingPrice ?\n                (primaryPrice <= triggerPrice && triggerPrice <= secondaryPrice) :\n                (primaryPrice >= triggerPrice && triggerPrice >= secondaryPrice);\n\n            if (!ok) {\n                revert Errors.InvalidStopLossOrderPrices(primaryPrice, secondaryPrice, triggerPrice, shouldValidateAscendingPrice);\n            }\n\n            if (shouldValidateAscendingPrice) {\n                oracle.setCustomPrice(indexToken, Price.Props(\n                    triggerPrice, // min price that order can be executed with\n                    triggerPrice // max price that order can be executed with\n                ));\n            } else {\n                oracle.setCustomPrice(indexToken, Price.Props(\n                    triggerPrice, // min price that order can be executed with\n                    triggerPrice // max price that order can be executed with\n                ));\n            }\n\n            return;\n        }\n\n        revert Errors.UnsupportedOrderType();\n    }\n\n    // @dev get the execution price for an order\n    //\n    // see setExactOrderPrice for information on the customPrice values\n    //\n    // for limit / stop-loss orders, the triggerPrice is returned here if it can\n    // fulfill the acceptablePrice after factoring in price impact\n    //\n    // if the triggerPrice cannot fulfill the acceptablePrice, check if the acceptablePrice\n    // can be fulfilled using the best oracle price after factoring in price impact\n    // if it can be fulfilled, fulfill the order at the acceptablePrice\n    //\n    // @param customIndexTokenPrice the custom price of the index token\n    // @param sizeDeltaUsd the order.sizeDeltaUsd\n    // @param priceImpactUsd the price impact of the order\n    // @param acceptablePrice the order.acceptablePrice\n    // @param isLong whether this is for a long or short order\n    // @param isIncrease whether this is for an increase or decrease order\n    // @return the execution price\n    function getExecutionPrice(\n        Price.Props memory customIndexTokenPrice,\n        uint256 sizeDeltaUsd,\n        int256 priceImpactUsd,\n        uint256 acceptablePrice,\n        bool isLong,\n        bool isIncrease\n    ) internal pure returns (uint256) {\n        // increase order:\n        //     - long: use the larger price\n        //     - short: use the smaller price\n        // decrease order:\n        //     - long: use the smaller price\n        //     - short: use the larger price\n        bool shouldUseMaxPrice = isIncrease ? isLong : !isLong;\n\n        // should price be smaller than acceptablePrice\n        // increase order:\n        //     - long: price should be smaller than acceptablePrice\n        //     - short: price should be larger than acceptablePrice\n        // decrease order:\n        //     - long: price should be larger than acceptablePrice\n        //     - short: price should be smaller than acceptablePrice\n        bool shouldPriceBeSmaller = isIncrease ? isLong : !isLong;\n\n        // for market orders, customIndexTokenPrice.min and customIndexTokenPrice.max should\n        // be equal, see setExactOrderPrice for more info\n        // for limit orders, customIndexTokenPrice contains the triggerPrice and the best oracle\n        // price, we first attempt to fulfill the order using the triggerPrice\n        uint256 price = customIndexTokenPrice.pickPrice(shouldUseMaxPrice);\n\n        // increase order:\n        //     - long: lower price for positive impact, higher price for negative impact\n        //     - short: higher price for positive impact, lower price for negative impact\n        // decrease order:\n        //     - long: higher price for positive impact, lower price for negative impact\n        //     - short: lower price for positive impact, higher price for negative impact\n        bool shouldFlipPriceImpactUsd = isIncrease ? isLong : !isLong;\n        int256 priceImpactUsdForPriceAdjustment = shouldFlipPriceImpactUsd ? -priceImpactUsd : priceImpactUsd;\n\n        if (priceImpactUsdForPriceAdjustment < 0 && (-priceImpactUsdForPriceAdjustment).toUint256() > sizeDeltaUsd) {\n            revert Errors.PriceImpactLargerThanOrderSize(priceImpactUsdForPriceAdjustment, sizeDeltaUsd);\n        }\n\n        // adjust price by price impact\n        if (sizeDeltaUsd > 0) {\n            price = price * Calc.sumReturnUint256(sizeDeltaUsd, priceImpactUsdForPriceAdjustment) / sizeDeltaUsd;\n        }\n\n        if (shouldPriceBeSmaller && price <= acceptablePrice) {\n            return price;\n        }\n\n        if (!shouldPriceBeSmaller && price >= acceptablePrice) {\n            return price;\n        }\n\n        // if the order could not be fulfilled using the triggerPrice\n        // check if the best oracle price can fulfill the order\n        price = customIndexTokenPrice.pickPrice(!shouldUseMaxPrice);\n\n        // adjust price by price impact\n        if (sizeDeltaUsd > 0) {\n            price = price * Calc.sumReturnUint256(sizeDeltaUsd, priceImpactUsdForPriceAdjustment) / sizeDeltaUsd;\n        }\n\n        if (shouldPriceBeSmaller && price <= acceptablePrice) {\n            return acceptablePrice;\n        }\n\n        if (!shouldPriceBeSmaller && price >= acceptablePrice) {\n            return acceptablePrice;\n        }\n\n        // the setExactOrderPrice function should have validated if the price fulfills\n        // the order's trigger price\n        //\n        // for decrease orders, the price impact should already be capped, so if the user\n        // had set an acceptable price within the range of the capped price impact, then\n        // the order should be fulfillable at the acceptable price\n        //\n        // for increase orders, the negative price impact is not capped\n        //\n        // for both increase and decrease orders, if it is due to price impact that the\n        // order cannot be fulfilled then the order should be frozen\n        //\n        // this is to prevent gaming by manipulation of the price impact value\n        //\n        // usually it should be costly to game the price impact value\n        // however, for certain cases, e.g. a user already has a large position opened\n        // the user may create limit orders that would only trigger after they close\n        // their position, this gives the user the option to cancel the pending order if\n        // prices do not move in their favour or to close their position and let the order\n        // execute if prices move in their favour\n        revert Errors.OrderNotFulfillableDueToPriceImpact(price, acceptablePrice);\n    }\n\n    // @dev validate that an order exists\n    // @param order the order to check\n    function validateNonEmptyOrder(Order.Props memory order) internal pure {\n        if (order.account() == address(0)) {\n            revert Errors.EmptyOrder();\n        }\n\n        if (order.sizeDeltaUsd() == 0 && order.initialCollateralDeltaAmount() == 0) {\n            revert Errors.EmptyOrder();\n        }\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/exchange/OrderHandler.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./BaseOrderHandler.sol\";\nimport \"../error/ErrorUtils.sol\";\n\n// @title OrderHandler\n// @dev Contract to handle creation, execution and cancellation of orders\ncontract OrderHandler is BaseOrderHandler {\n    using SafeCast for uint256;\n    using Order for Order.Props;\n    using Array for uint256[];\n\n    constructor(\n        RoleStore _roleStore,\n        DataStore _dataStore,\n        EventEmitter _eventEmitter,\n        OrderVault _orderVault,\n        Oracle _oracle,\n        SwapHandler _swapHandler,\n        IReferralStorage _referralStorage\n    ) BaseOrderHandler(\n        _roleStore,\n        _dataStore,\n        _eventEmitter,\n        _orderVault,\n        _oracle,\n        _swapHandler,\n        _referralStorage\n    ) {}\n\n    // @dev creates an order in the order store\n    // @param account the order's account\n    // @param params BaseOrderUtils.CreateOrderParams\n    function createOrder(\n        address account,\n        BaseOrderUtils.CreateOrderParams calldata params\n    ) external globalNonReentrant onlyController returns (bytes32) {\n        FeatureUtils.validateFeature(dataStore, Keys.createOrderFeatureDisabledKey(address(this), uint256(params.orderType)));\n\n        return OrderUtils.createOrder(\n            dataStore,\n            eventEmitter,\n            orderVault,\n            referralStorage,\n            account,\n            params\n        );\n    }\n\n    /**\n     * @dev Updates the given order with the specified size delta, acceptable price, and trigger price.\n     * The `updateOrder()` feature must be enabled for the given order type. The caller must be the owner\n     * of the order, and the order must not be a market order. The size delta, trigger price, and\n     * acceptable price are updated on the order, and the order is unfrozen. Any additional WNT that is\n     * transferred to the contract is added to the order's execution fee. The updated order is then saved\n     * in the order store, and an `OrderUpdated` event is emitted.\n     *\n     * A user may be able to observe exchange prices and prevent order execution by updating the order's\n     * trigger price or acceptable price\n     *\n     * The main front-running concern is if a user knows whether the price is going to move up or down\n     * then positions accordingly, e.g. if price is going to move up then the user opens a long position\n     *\n     * With updating of orders, a user may know that price could be lower and delays the execution of an\n     * order by updating it, this should not be a significant front-running concern since it is similar\n     * to observing prices then creating a market order as price is decreasing\n     *\n     * @param key The unique ID of the order to be updated\n     * @param sizeDeltaUsd The new size delta for the order\n     * @param acceptablePrice The new acceptable price for the order\n     * @param triggerPrice The new trigger price for the order\n     */\n    function updateOrder(\n        bytes32 key,\n        uint256 sizeDeltaUsd,\n        uint256 acceptablePrice,\n        uint256 triggerPrice,\n        uint256 minOutputAmount,\n        Order.Props memory order\n    ) external payable globalNonReentrant onlyController {\n        FeatureUtils.validateFeature(dataStore, Keys.updateOrderFeatureDisabledKey(address(this), uint256(order.orderType())));\n\n        if (BaseOrderUtils.isMarketOrder(order.orderType())) {\n            revert Errors.OrderNotUpdatable(uint256(order.orderType()));\n        }\n\n        order.setSizeDeltaUsd(sizeDeltaUsd);\n        order.setTriggerPrice(triggerPrice);\n        order.setAcceptablePrice(acceptablePrice);\n        order.setMinOutputAmount(minOutputAmount);\n        order.setIsFrozen(false);\n\n        // allow topping up of executionFee as frozen orders\n        // will have their executionFee reduced\n        address wnt = TokenUtils.wnt(dataStore);\n        uint256 receivedWnt = orderVault.recordTransferIn(wnt);\n        order.setExecutionFee(order.executionFee() + receivedWnt);\n\n        uint256 estimatedGasLimit = GasUtils.estimateExecuteOrderGasLimit(dataStore, order);\n        GasUtils.validateExecutionFee(dataStore, estimatedGasLimit, order.executionFee());\n\n        order.touch();\n\n        BaseOrderUtils.validateNonEmptyOrder(order);\n\n        OrderStoreUtils.set(dataStore, key, order);\n\n        OrderEventUtils.emitOrderUpdated(eventEmitter, key, sizeDeltaUsd, acceptablePrice, triggerPrice, minOutputAmount);\n    }\n\n    /**\n     * @dev Cancels the given order. The `cancelOrder()` feature must be enabled for the given order\n     * type. The caller must be the owner of the order, and the order must not be a market order. The\n     * order is cancelled by calling the `cancelOrder()` function in the `OrderUtils` contract. This\n     * function also records the starting gas amount and the reason for cancellation, which is passed to\n     * the `cancelOrder()` function.\n     *\n     * @param key The unique ID of the order to be cancelled\n     */\n    function cancelOrder(bytes32 key) external globalNonReentrant onlyController {\n        uint256 startingGas = gasleft();\n\n        DataStore _dataStore = dataStore;\n        Order.Props memory order = OrderStoreUtils.get(_dataStore, key);\n\n        FeatureUtils.validateFeature(_dataStore, Keys.cancelOrderFeatureDisabledKey(address(this), uint256(order.orderType())));\n\n        if (BaseOrderUtils.isMarketOrder(order.orderType())) {\n            ExchangeUtils.validateRequestCancellation(\n                _dataStore,\n                order.updatedAtBlock(),\n                \"Order\"\n            );\n        }\n\n        OrderUtils.cancelOrder(\n            dataStore,\n            eventEmitter,\n            orderVault,\n            key,\n            order.account(),\n            startingGas,\n            Keys.USER_INITIATED_CANCEL,\n            \"\"\n        );\n    }\n\n    // @dev simulate execution of an order to check for any errors\n    // @param key the order key\n    // @param params OracleUtils.SimulatePricesParams\n    function simulateExecuteOrder(\n        bytes32 key,\n        OracleUtils.SimulatePricesParams memory params\n    ) external\n        onlyController\n        withSimulatedOraclePrices(oracle, params)\n        globalNonReentrant\n    {\n        OracleUtils.SetPricesParams memory oracleParams;\n\n        this._executeOrder(\n            key,\n            oracleParams,\n            msg.sender\n        );\n    }\n\n    // @dev executes an order\n    // @param key the key of the order to execute\n    // @param oracleParams OracleUtils.SetPricesParams\n    function executeOrder(\n        bytes32 key,\n        OracleUtils.SetPricesParams calldata oracleParams\n    ) external\n        globalNonReentrant\n        onlyOrderKeeper\n        withOraclePrices(oracle, dataStore, eventEmitter, oracleParams)\n    {\n        uint256 startingGas = gasleft();\n\n        try this._executeOrder(\n            key,\n            oracleParams,\n            msg.sender\n        ) {\n        } catch (bytes memory reasonBytes) {\n            _handleOrderError(key, startingGas, reasonBytes);\n        }\n    }\n\n    // @dev executes an order\n    // @param key the key of the order to execute\n    // @param oracleParams OracleUtils.SetPricesParams\n    // @param keeper the keeper executing the order\n    // @param startingGas the starting gas\n    function _executeOrder(\n        bytes32 key,\n        OracleUtils.SetPricesParams memory oracleParams,\n        address keeper\n    ) external onlySelf {\n        uint256 startingGas = gasleft();\n\n        BaseOrderUtils.ExecuteOrderParams memory params = _getExecuteOrderParams(key, oracleParams, keeper, startingGas);\n        // limit swaps require frozen order keeper for execution since on creation it can fail due to output amount\n        // which would automatically cause the order to be frozen\n        // limit increase and limit / trigger decrease orders may fail due to output amount as well and become frozen\n        // but only if their acceptablePrice is reached\n        if (params.order.isFrozen() || params.order.orderType() == Order.OrderType.LimitSwap) {\n            _validateFrozenOrderKeeper(keeper);\n        }\n\n        FeatureUtils.validateFeature(params.contracts.dataStore, Keys.executeOrderFeatureDisabledKey(address(this), uint256(params.order.orderType())));\n\n        OrderUtils.executeOrder(params);\n    }\n\n    // @dev handle a caught order error\n    // @param key the order's key\n    // @param startingGas the starting gas\n    // @param reason the error reason\n    // @param reasonKey the hash or the error reason\n    function _handleOrderError(\n        bytes32 key,\n        uint256 startingGas,\n        bytes memory reasonBytes\n    ) internal {\n        (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n\n        bytes4 errorSelector = ErrorUtils.getErrorSelectorFromData(reasonBytes);\n\n        Order.Props memory order = OrderStoreUtils.get(dataStore, key);\n        bool isMarketOrder = BaseOrderUtils.isMarketOrder(order.orderType());\n\n        if (\n            OracleUtils.isOracleError(errorSelector) ||\n            // if the order is already frozen, revert with the custom error to provide more information\n            // on why the order cannot be executed\n            order.isFrozen() ||\n            // for market orders, the EmptyPosition error should still lead to the\n            // order being cancelled\n            // for limit, trigger orders, the EmptyPosition error should lead to the transaction\n            // being reverted instead\n            // if the position is created or increased later, the oracle prices used to fulfill the order\n            // must be after the position was last increased, this is validated in DecreaseOrderUtils\n            (!isMarketOrder && errorSelector == Errors.EmptyPosition.selector) ||\n            errorSelector == Errors.EmptyOrder.selector ||\n            // if the order execution feature is disabled, it may be possible\n            // for a user to cancel their orders after the feature is re-enabled\n            // or they may be able to execute the order at an outdated price\n            // depending on the order keeper\n            // disabling of features should be a rare occurrence, it may be\n            // preferrable to still execute the orders when the feature is re-enabled\n            // instead of cancelling / freezing the orders\n            // if features are not frequently disabled, the amount of front-running\n            // from this should not be significant\n            // based on this it may also be advisable to disable the cancelling of orders\n            // if the execution of orders is disabled\n            errorSelector == Errors.DisabledFeature.selector ||\n            errorSelector == Errors.InvalidKeeperForFrozenOrder.selector ||\n            errorSelector == Errors.UnsupportedOrderType.selector ||\n            // the transaction is reverted for InvalidLimitOrderPrices and\n            // InvalidStopLossOrderPrices errors since since the oracle prices\n            // do not fulfill the specified trigger price\n            errorSelector == Errors.InvalidLimitOrderPrices.selector ||\n            errorSelector == Errors.InvalidStopLossOrderPrices.selector\n        ) {\n            ErrorUtils.revertWithCustomError(reasonBytes);\n        }\n\n        if (\n            isMarketOrder ||\n            errorSelector == Errors.InvalidPositionMarket.selector ||\n            errorSelector == Errors.InvalidCollateralTokenForMarket.selector ||\n            errorSelector == Errors.InvalidPositionSizeValues.selector\n        ) {\n            OrderUtils.cancelOrder(\n                dataStore,\n                eventEmitter,\n                orderVault,\n                key,\n                msg.sender,\n                startingGas,\n                reason,\n                reasonBytes\n            );\n\n            return;\n        }\n\n        // freeze unfulfillable orders to prevent the order system from being gamed\n        // an example of gaming would be if a user creates a limit order\n        // with size greater than the available amount in the pool\n        // the user waits for their limit price to be hit, and if price\n        // moves in their favour after, they can deposit into the pool\n        // to allow the order to be executed then close the order for a profit\n        //\n        // frozen order keepers are expected to execute orders only if the\n        // latest prices match the trigger price\n        //\n        // a user can also call updateOrder to unfreeze an order\n        OrderUtils.freezeOrder(\n            dataStore,\n            eventEmitter,\n            orderVault,\n            key,\n            msg.sender,\n            startingGas,\n            reason,\n            reasonBytes\n        );\n    }\n\n    // @dev validate that the keeper is a frozen order keeper\n    // @param keeper address of the keeper\n    function _validateFrozenOrderKeeper(address keeper) internal view {\n        if (!roleStore.hasRole(keeper, Role.FROZEN_ORDER_KEEPER)) {\n            revert Errors.InvalidKeeperForFrozenOrder(keeper);\n        }\n    }\n}"
    }
  ]
}