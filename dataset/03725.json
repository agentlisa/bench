{
  "Title": "zBanc - DynamicLiquidTokenConverter avoid potential converter type overlap with bancor Â Acknowledged",
  "Content": "\n\n#### Resolution\n\n\n\nAcknowledged by providing the following statement:\n\n\n\n> \n> 5.24 the converterType relates to an array selector in the test helpers, so would be inconvenient to make a higher value. we will have to maintain the value when rebasing in DynamicLiquidTokenConverter & Factory, ConverterUpgrader, and the ConverterUpgrader.js test file and Converter.js test helper file.\n> \n> \n> \n\n\n\n\n#### Description\n\n\nThe system is forked from[bancorprotocol/contracts-solidity](https://github.com/bancorprotocol/contracts-solidity). As such, it is very likely that security vulnerabilities reported to bancorprotocol upstream need to be merged into the zer0/zBanc fork if they also affect this codebase. There is also a chance that security fixes will only be available with feature releases or that the zer0 development team wants to merge upstream features into the zBanc codebase.\n\n\nzBanc introduced `converterType=3` for the `DynamicLiquidTokenConverter` as `converterType=1` and `converterType=2` already exist in the bancorprotocol codebase. Now, since it is unclear if `DynamicLiquidTokenConverter` will be merged into bancorprotocol there is a chance that bancor introduces new types that overlap with the `DynamicLiquidTokenConverter` converter type (`3`). It is therefore suggested to map the `DynamicLiquidTokenConverter` to a converterType that is unlikely to create an overlap with the system it was forked from. E.g. use converter type id `1001` instead of `3` (Note: converterType is an uint16).\n\n\nNote that the current master of the bancorprotocol already appears to defined converterType 3 and 4: <https://github.com/bancorprotocol/contracts-solidity/blob/5f4c53ebda784751c3a90b06aa2c85e9fdb36295/solidity/test/helpers/Converter.js#L51-L54>\n\n\n#### Examples\n\n\n* The new custom converter\n\n\n**zBanc/solidity/contracts/converter/types/liquid-token/DynamicLiquidTokenConverter.sol:L50-L52**\n\n\n\n```\nfunction converterType() public pure override returns (uint16) {\n    return 3;\n}\n\n```\n* ConverterTypes from the bancor base system\n\n\n**zBanc/solidity/contracts/converter/types/liquidity-pool-v1/LiquidityPoolV1Converter.sol:L71-L73**\n\n\n\n```\nfunction converterType() public pure override returns (uint16) {\n    return 1;\n}\n\n```\n**zBanc/solidity/contracts/converter/types/liquidity-pool-v2/LiquidityPoolV2Converter.sol:L73-L76**\n\n\n\n```\n\\*/\nfunction converterType() public pure override returns (uint16) {\n    return 2;\n}\n\n```\n#### Recommendation\n\n\nChoose a converterType id for this custom implementation that does not overlap with the codebase the system was forked from. e.g. `uint16(-1)` or `1001` instead of `3` which might already be used upstream.\n\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "solidity/test/helpers/Converter.js",
      "content": "const fs = require('fs');\nconst path = require('path');\n\nconst { contract, web3 } = require('@openzeppelin/test-environment');\nconst { constants } = require('@openzeppelin/test-helpers');\n\nconst truffleContract = require('@truffle/contract');\n\nconst { ZERO_ADDRESS } = constants;\n\nconst Converter = contract.fromArtifact('ConverterBase');\nconst LiquidityPoolV1Converter = contract.fromArtifact('LiquidityPoolV1Converter');\nconst StandardPoolConverter = contract.fromArtifact('StandardPoolConverter');\nconst FixedRatePoolConverter = contract.fromArtifact('FixedRatePoolConverter');\n\nmodule.exports.new = async (\n    type,\n    tokenAddress,\n    registryAddress,\n    maxConversionFee,\n    reserveTokenAddress,\n    weight,\n    version\n) => {\n    if (version) {\n        let contractName = `../bin/converter_v${version}`;\n        if (version >= 43) {\n            contractName += `_t${type}`;\n        }\n\n        const abi = fs.readFileSync(path.resolve(__dirname, `${contractName}.abi`));\n        const bin = fs.readFileSync(path.resolve(__dirname, `${contractName}.bin`));\n\n        const Converter = truffleContract({ abi: JSON.parse(abi), unlinked_binary: `0x${bin}` });\n        const block = await web3.eth.getBlock('latest');\n        Converter.setProvider(web3.currentProvider);\n        Converter.defaults({ from: (await web3.eth.getAccounts())[0], gas: block.gasLimit });\n\n        if (version > 28) {\n            const converter = await Converter.new(tokenAddress, registryAddress, maxConversionFee);\n            if (reserveTokenAddress !== ZERO_ADDRESS) {\n                await converter.addReserve(reserveTokenAddress, weight);\n            }\n\n            return converter;\n        }\n\n        return Converter.new(tokenAddress, registryAddress, maxConversionFee, reserveTokenAddress, weight);\n    }\n\n    const converterType = {\n        1: LiquidityPoolV1Converter,\n        3: StandardPoolConverter,\n        4: FixedRatePoolConverter\n    }[type];\n    const converter = await converterType.new(tokenAddress, registryAddress, maxConversionFee);\n    if (reserveTokenAddress !== ZERO_ADDRESS) {\n        await converter.addReserve(reserveTokenAddress, weight);\n    }\n\n    return converter;\n};\n\nmodule.exports.at = async (address, version) => {\n    if (version) {\n        const abi = fs.readFileSync(path.resolve(__dirname, `../bin/converter_v${version}.abi`));\n        const converter = truffleContract({ abi: JSON.parse(abi) });\n        return converter.at(address);\n    }\n\n    return Converter.at(address);\n};"
    }
  ]
}