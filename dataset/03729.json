{
  "Title": "[L04] Unclear lack of input validation",
  "Content": "The [`initialize`](https://github.com/graphprotocol/contracts/blob/b61a9b27eb18eab5ec6bb612244d58c33f2321f2/contracts/disputes/DisputeManager.sol#L155) and [`setSlashingPercentage`](https://github.com/graphprotocol/contracts/blob/b61a9b27eb18eab5ec6bb612244d58c33f2321f2/contracts/disputes/DisputeManager.sol#L250) functions of the `DisputeManager` contract are lacking of any input validation for the `_qrySlashingPercentage` and `_idxSlashingPercentage` variables.\n\n\nAt the same time, the comment [in line 264](https://github.com/graphprotocol/contracts/blob/b61a9b27eb18eab5ec6bb612244d58c33f2321f2/contracts/disputes/DisputeManager.sol#L264) suggests that those slashing percentages are allowed to be zero.\n\n\nIf this is true and thereâ€™s a dispute that has been created, any call to [`acceptDispute`](https://github.com/graphprotocol/contracts/blob/b61a9b27eb18eab5ec6bb612244d58c33f2321f2/contracts/disputes/DisputeManager.sol#L542) will internally call the [`_slashIndexer`](https://github.com/graphprotocol/contracts/blob/b61a9b27eb18eab5ec6bb612244d58c33f2321f2/contracts/disputes/DisputeManager.sol#L547) and the call [will ultimately fail and revert here](https://github.com/graphprotocol/contracts/blob/b61a9b27eb18eab5ec6bb612244d58c33f2321f2/contracts/disputes/DisputeManager.sol#L699-L702) because of the zero values of the slashing percentages.\n\n\nThis is not a security issue as in this case, to finalize the dispute, the [`drawDispute`](https://github.com/graphprotocol/contracts/blob/b61a9b27eb18eab5ec6bb612244d58c33f2321f2/contracts/disputes/DisputeManager.sol#L590) function should be called instead. However, unexpected failures may confuse the users.\n\n\nConsider adding a check in the `acceptDispute` function that will revert early and loudly whenever a dispute is trying to be accepted with zero slashing percentages. Moreover, make sure to set these parameters to positive values if disputes are intended to be accepted.\n\n\n**Update:** *Fixed in commit [`3b38f9e6d82b7cf7169cad111d9c9cf4cdea3326`](https://github.com/graphprotocol/contracts/pull/458/commits/3b38f9e6d82b7cf7169cad111d9c9cf4cdea3326) where documentation was included to clarify that `acceptDispute` will fail under certain conditions and that best course of action is to resolve using `drawDispute` or `rejectDispute`.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/disputes/DisputeManager.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.3;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/cryptography/ECDSA.sol\";\n\nimport \"../governance/Managed.sol\";\nimport \"../upgrades/GraphUpgradeable.sol\";\n\nimport \"./DisputeManagerStorage.sol\";\nimport \"./IDisputeManager.sol\";\n\n/*\n * @title DisputeManager\n * @notice Provides a way to align the incentives of participants by having slashing as deterrent\n * for incorrect behaviour.\n *\n * There are two types of disputes that can be created: Query disputes and Indexing disputes.\n *\n * Query Disputes:\n * Graph nodes receive queries and return responses with signed receipts called attestations.\n * An attestation can be disputed if the consumer thinks the query response was invalid.\n * Indexers use the derived private key for an allocation to sign attestations.\n *\n * Indexing Disputes:\n * Indexers present a Proof of Indexing (POI) when they close allocations to prove\n * they were indexing a subgraph. The Staking contract emits that proof with the format\n * keccak256(indexer.address, POI).\n * Any challenger can dispute the validity of a POI by submitting a dispute to this contract\n * along with a deposit.\n *\n * Arbitration:\n * Disputes can only be accepted, rejected or drawn by the arbitrator role that can be delegated\n * to a EOA or DAO.\n */\ncontract DisputeManager is DisputeManagerV1Storage, GraphUpgradeable, IDisputeManager {\n    using SafeMath for uint256;\n\n    // -- EIP-712  --\n\n    bytes32 private constant DOMAIN_TYPE_HASH =\n        keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)\"\n        );\n    bytes32 private constant DOMAIN_NAME_HASH = keccak256(\"Graph Protocol\");\n    bytes32 private constant DOMAIN_VERSION_HASH = keccak256(\"0\");\n    bytes32 private constant DOMAIN_SALT =\n        0xa070ffb1cd7409649bf77822cce74495468e06dbfaef09556838bf188679b9c2;\n    bytes32 private constant RECEIPT_TYPE_HASH =\n        keccak256(\"Receipt(bytes32 requestCID,bytes32 responseCID,bytes32 subgraphDeploymentID)\");\n\n    // -- Constants --\n\n    uint256 private constant ATTESTATION_SIZE_BYTES = 161;\n    uint256 private constant RECEIPT_SIZE_BYTES = 96;\n\n    uint256 private constant SIG_R_LENGTH = 32;\n    uint256 private constant SIG_S_LENGTH = 32;\n    uint256 private constant SIG_R_OFFSET = RECEIPT_SIZE_BYTES;\n    uint256 private constant SIG_S_OFFSET = RECEIPT_SIZE_BYTES + SIG_R_LENGTH;\n    uint256 private constant SIG_V_OFFSET = RECEIPT_SIZE_BYTES + SIG_R_LENGTH + SIG_S_LENGTH;\n\n    uint256 private constant UINT8_BYTE_LENGTH = 1;\n    uint256 private constant BYTES32_BYTE_LENGTH = 32;\n\n    uint256 private constant MAX_PPM = 1000000; // 100% in parts per million\n\n    // -- Events --\n\n    /**\n     * @dev Emitted when a query dispute is created for `subgraphDeploymentID` and `indexer`\n     * by `fisherman`.\n     * The event emits the amount of `tokens` deposited by the fisherman and `attestation` submitted.\n     */\n    event QueryDisputeCreated(\n        bytes32 indexed disputeID,\n        address indexed indexer,\n        address indexed fisherman,\n        uint256 tokens,\n        bytes32 subgraphDeploymentID,\n        bytes attestation\n    );\n\n    /**\n     * @dev Emitted when an indexing dispute is created for `allocationID` and `indexer`\n     * by `fisherman`.\n     * The event emits the amount of `tokens` deposited by the fisherman.\n     */\n    event IndexingDisputeCreated(\n        bytes32 indexed disputeID,\n        address indexed indexer,\n        address indexed fisherman,\n        uint256 tokens,\n        address allocationID\n    );\n\n    /**\n     * @dev Emitted when arbitrator accepts a `disputeID` to `indexer` created by `fisherman`.\n     * The event emits the amount `tokens` transferred to the fisherman, the deposit plus reward.\n     */\n    event DisputeAccepted(\n        bytes32 indexed disputeID,\n        address indexed indexer,\n        address indexed fisherman,\n        uint256 tokens\n    );\n\n    /**\n     * @dev Emitted when arbitrator rejects a `disputeID` for `indexer` created by `fisherman`.\n     * The event emits the amount `tokens` burned from the fisherman deposit.\n     */\n    event DisputeRejected(\n        bytes32 indexed disputeID,\n        address indexed indexer,\n        address indexed fisherman,\n        uint256 tokens\n    );\n\n    /**\n     * @dev Emitted when arbitrator draw a `disputeID` for `indexer` created by `fisherman`.\n     * The event emits the amount `tokens` used as deposit and returned to the fisherman.\n     */\n    event DisputeDrawn(\n        bytes32 indexed disputeID,\n        address indexed indexer,\n        address indexed fisherman,\n        uint256 tokens\n    );\n\n    /**\n     * @dev Emitted when two disputes are in conflict to link them.\n     * This event will be emitted after each DisputeCreated event is emitted\n     * for each of the individual disputes.\n     */\n    event DisputeLinked(bytes32 indexed disputeID1, bytes32 indexed disputeID2);\n\n    /**\n     * @dev Check if the caller is the arbitrator.\n     */\n    modifier onlyArbitrator {\n        require(msg.sender == arbitrator, \"Caller is not the Arbitrator\");\n        _;\n    }\n\n    /**\n     * @dev Initialize this contract.\n     * @param _arbitrator Arbitrator role\n     * @param _minimumDeposit Minimum deposit required to create a Dispute\n     * @param _fishermanRewardPercentage Percent of slashed funds for fisherman (ppm)\n     * @param _qrySlashingPercentage Percentage of indexer stake slashed for query disputes (ppm)\n     * @param _idxSlashingPercentage Percentage of indexer stake slashed for indexing disputes (ppm)\n     */\n    function initialize(\n        address _controller,\n        address _arbitrator,\n        uint256 _minimumDeposit,\n        uint32 _fishermanRewardPercentage,\n        uint32 _qrySlashingPercentage,\n        uint32 _idxSlashingPercentage\n    ) external onlyImpl {\n        Managed._initialize(_controller);\n\n        // Settings\n        _setArbitrator(_arbitrator);\n        _setMinimumDeposit(_minimumDeposit);\n        _setFishermanRewardPercentage(_fishermanRewardPercentage);\n        _setSlashingPercentage(_qrySlashingPercentage, _idxSlashingPercentage);\n\n        // EIP-712 domain separator\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                DOMAIN_TYPE_HASH,\n                DOMAIN_NAME_HASH,\n                DOMAIN_VERSION_HASH,\n                _getChainID(),\n                address(this),\n                DOMAIN_SALT\n            )\n        );\n    }\n\n    /**\n     * @dev Set the arbitrator address.\n     * @notice Update the arbitrator to `_arbitrator`\n     * @param _arbitrator The address of the arbitration contract or party\n     */\n    function setArbitrator(address _arbitrator) external override onlyGovernor {\n        _setArbitrator(_arbitrator);\n    }\n\n    /**\n     * @dev Internal: Set the arbitrator address.\n     * @notice Update the arbitrator to `_arbitrator`\n     * @param _arbitrator The address of the arbitration contract or party\n     */\n    function _setArbitrator(address _arbitrator) private {\n        require(_arbitrator != address(0), \"Arbitrator must be set\");\n        arbitrator = _arbitrator;\n        emit ParameterUpdated(\"arbitrator\");\n    }\n\n    /**\n     * @dev Set the minimum deposit required to create a dispute.\n     * @notice Update the minimum deposit to `_minimumDeposit` Graph Tokens\n     * @param _minimumDeposit The minimum deposit in Graph Tokens\n     */\n    function setMinimumDeposit(uint256 _minimumDeposit) external override onlyGovernor {\n        _setMinimumDeposit(_minimumDeposit);\n    }\n\n    /**\n     * @dev Internal: Set the minimum deposit required to create a dispute.\n     * @notice Update the minimum deposit to `_minimumDeposit` Graph Tokens\n     * @param _minimumDeposit The minimum deposit in Graph Tokens\n     */\n    function _setMinimumDeposit(uint256 _minimumDeposit) private {\n        require(_minimumDeposit > 0, \"Minimum deposit must be set\");\n        minimumDeposit = _minimumDeposit;\n        emit ParameterUpdated(\"minimumDeposit\");\n    }\n\n    /**\n     * @dev Set the percent reward that the fisherman gets when slashing occurs.\n     * @notice Update the reward percentage to `_percentage`\n     * @param _percentage Reward as a percentage of indexer stake\n     */\n    function setFishermanRewardPercentage(uint32 _percentage) external override onlyGovernor {\n        _setFishermanRewardPercentage(_percentage);\n    }\n\n    /**\n     * @dev Internal: Set the percent reward that the fisherman gets when slashing occurs.\n     * @notice Update the reward percentage to `_percentage`\n     * @param _percentage Reward as a percentage of indexer stake\n     */\n    function _setFishermanRewardPercentage(uint32 _percentage) private {\n        // Must be within 0% to 100% (inclusive)\n        require(_percentage <= MAX_PPM, \"Reward percentage must be below or equal to MAX_PPM\");\n        fishermanRewardPercentage = _percentage;\n        emit ParameterUpdated(\"fishermanRewardPercentage\");\n    }\n\n    /**\n     * @dev Set the percentage used for slashing indexers.\n     * @param _qryPercentage Percentage slashing for query disputes\n     * @param _idxPercentage Percentage slashing for indexing disputes\n     */\n    function setSlashingPercentage(uint32 _qryPercentage, uint32 _idxPercentage)\n        external\n        override\n        onlyGovernor\n    {\n        _setSlashingPercentage(_qryPercentage, _idxPercentage);\n    }\n\n    /**\n     * @dev Internal: Set the percentage used for slashing indexers.\n     * @param _qryPercentage Percentage slashing for query disputes\n     * @param _idxPercentage Percentage slashing for indexing disputes\n     */\n    function _setSlashingPercentage(uint32 _qryPercentage, uint32 _idxPercentage) private {\n        // Must be within 0% to 100% (inclusive)\n        require(\n            _qryPercentage <= MAX_PPM && _idxPercentage <= MAX_PPM,\n            \"Slashing percentage must be below or equal to MAX_PPM\"\n        );\n        qrySlashingPercentage = _qryPercentage;\n        idxSlashingPercentage = _idxPercentage;\n        emit ParameterUpdated(\"slashingPercentage\");\n    }\n\n    /**\n     * @dev Return whether a dispute exists or not.\n     * @notice Return if dispute with ID `_disputeID` exists\n     * @param _disputeID True if dispute already exists\n     */\n    function isDisputeCreated(bytes32 _disputeID) public view override returns (bool) {\n        return disputes[_disputeID].fisherman != address(0);\n    }\n\n    /**\n     * @dev Get the message hash that an indexer used to sign the receipt.\n     * Encodes a receipt using a domain separator, as described on\n     * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#specification.\n     * @notice Return the message hash used to sign the receipt\n     * @param _receipt Receipt returned by indexer and submitted by fisherman\n     * @return Message hash used to sign the receipt\n     */\n    function encodeHashReceipt(Receipt memory _receipt) public view override returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\", // EIP-191 encoding pad, EIP-712 version 1\n                    DOMAIN_SEPARATOR,\n                    keccak256(\n                        abi.encode(\n                            RECEIPT_TYPE_HASH,\n                            _receipt.requestCID,\n                            _receipt.responseCID,\n                            _receipt.subgraphDeploymentID\n                        ) // EIP 712-encoded message hash\n                    )\n                )\n            );\n    }\n\n    /**\n     * @dev Returns if two attestations are conflicting.\n     * Everything must match except for the responseID.\n     * @param _attestation1 Attestation\n     * @param _attestation2 Attestation\n     * @return True if the two attestations are conflicting\n     */\n    function areConflictingAttestations(\n        Attestation memory _attestation1,\n        Attestation memory _attestation2\n    ) public pure override returns (bool) {\n        return (_attestation1.requestCID == _attestation2.requestCID &&\n            _attestation1.subgraphDeploymentID == _attestation2.subgraphDeploymentID &&\n            _attestation1.responseCID != _attestation2.responseCID);\n    }\n\n    /**\n     * @dev Returns the indexer that signed an attestation.\n     * @param _attestation Attestation\n     * @return Indexer address\n     */\n    function getAttestationIndexer(Attestation memory _attestation)\n        public\n        view\n        override\n        returns (address)\n    {\n        // Get attestation signer. Indexers signs with the allocationID\n        address allocationID = _recoverAttestationSigner(_attestation);\n\n        IStaking.Allocation memory alloc = staking().getAllocation(allocationID);\n        require(alloc.indexer != address(0), \"Indexer cannot be found for the attestation\");\n        require(\n            alloc.subgraphDeploymentID == _attestation.subgraphDeploymentID,\n            \"Allocation and attestation subgraphDeploymentID must match\"\n        );\n        return alloc.indexer;\n    }\n\n    /**\n     * @dev Create a query dispute for the arbitrator to resolve.\n     * This function is called by a fisherman that will need to `_deposit` at\n     * least `minimumDeposit` GRT tokens.\n     * @param _attestationData Attestation bytes submitted by the fisherman\n     * @param _deposit Amount of tokens staked as deposit\n     */\n    function createQueryDispute(bytes calldata _attestationData, uint256 _deposit)\n        external\n        override\n        returns (bytes32)\n    {\n        // Get funds from submitter\n        _pullSubmitterDeposit(_deposit);\n\n        // Create a dispute\n        return\n            _createQueryDisputeWithAttestation(\n                msg.sender,\n                _deposit,\n                _parseAttestation(_attestationData),\n                _attestationData\n            );\n    }\n\n    /**\n     * @dev Create query disputes for two conflicting attestations.\n     * A conflicting attestation is a proof presented by two different indexers\n     * where for the same request on a subgraph the response is different.\n     * For this type of dispute the submitter is not required to present a deposit\n     * as one of the attestation is considered to be right.\n     * Two linked disputes will be created and if the arbitrator resolve one, the other\n     * one will be automatically resolved.\n     * @param _attestationData1 First attestation data submitted\n     * @param _attestationData2 Second attestation data submitted\n     * @return DisputeID1, DisputeID2\n     */\n    function createQueryDisputeConflict(\n        bytes calldata _attestationData1,\n        bytes calldata _attestationData2\n    ) external override returns (bytes32, bytes32) {\n        address fisherman = msg.sender;\n\n        // Parse each attestation\n        Attestation memory attestation1 = _parseAttestation(_attestationData1);\n        Attestation memory attestation2 = _parseAttestation(_attestationData2);\n\n        // Test that attestations are conflicting\n        require(\n            areConflictingAttestations(attestation1, attestation2),\n            \"Attestations must be in conflict\"\n        );\n\n        // Create the disputes\n        // The deposit is zero for conflicting attestations\n        bytes32 dID1 =\n            _createQueryDisputeWithAttestation(fisherman, 0, attestation1, _attestationData1);\n        bytes32 dID2 =\n            _createQueryDisputeWithAttestation(fisherman, 0, attestation2, _attestationData2);\n\n        // Store the linked disputes to be resolved\n        disputes[dID1].relatedDisputeID = dID2;\n        disputes[dID2].relatedDisputeID = dID1;\n\n        // Emit event that links the two created disputes\n        emit DisputeLinked(dID1, dID2);\n\n        return (dID1, dID2);\n    }\n\n    /**\n     * @dev Create a query dispute passing the parsed attestation.\n     * To be used in createQueryDispute() and createQueryDisputeConflict()\n     * to avoid calling parseAttestation() multiple times\n     * `_attestationData` is only passed to be emitted\n     * @param _fisherman Creator of dispute\n     * @param _deposit Amount of tokens staked as deposit\n     * @param _attestation Attestation struct parsed from bytes\n     * @param _attestationData Attestation bytes submitted by the fisherman\n     * @return DisputeID\n     */\n    function _createQueryDisputeWithAttestation(\n        address _fisherman,\n        uint256 _deposit,\n        Attestation memory _attestation,\n        bytes memory _attestationData\n    ) private returns (bytes32) {\n        // Get the indexer that signed the attestation\n        address indexer = getAttestationIndexer(_attestation);\n\n        // The indexer is disputable\n        require(staking().getIndexerStakedTokens(indexer) > 0, \"Dispute indexer has no stake\");\n\n        // Create a disputeID\n        bytes32 disputeID =\n            keccak256(\n                abi.encodePacked(\n                    _attestation.requestCID,\n                    _attestation.responseCID,\n                    _attestation.subgraphDeploymentID,\n                    indexer,\n                    _fisherman\n                )\n            );\n\n        // Only one dispute for a (indexer, subgraphDeploymentID) at a time\n        require(!isDisputeCreated(disputeID), \"Dispute already created\");\n\n        // Store dispute\n        disputes[disputeID] = Dispute(\n            indexer,\n            _fisherman,\n            _deposit,\n            0, // no related dispute,\n            DisputeType.QueryDispute\n        );\n\n        emit QueryDisputeCreated(\n            disputeID,\n            indexer,\n            _fisherman,\n            _deposit,\n            _attestation.subgraphDeploymentID,\n            _attestationData\n        );\n\n        return disputeID;\n    }\n\n    /**\n     * @dev Create an indexing dispute for the arbitrator to resolve.\n     * The disputes are created in reference to an allocationID\n     * This function is called by a challenger that will need to `_deposit` at\n     * least `minimumDeposit` GRT tokens.\n     * @param _allocationID The allocation to dispute\n     * @param _deposit Amount of tokens staked as deposit\n     */\n    function createIndexingDispute(address _allocationID, uint256 _deposit)\n        external\n        override\n        returns (bytes32)\n    {\n        // Get funds from submitter\n        _pullSubmitterDeposit(_deposit);\n\n        // Create a dispute\n        return _createIndexingDisputeWithAllocation(msg.sender, _deposit, _allocationID);\n    }\n\n    /**\n     * @dev Create indexing dispute internal function.\n     * @param _fisherman The challenger creating the dispute\n     * @param _deposit Amount of tokens staked as deposit\n     * @param _allocationID Allocation disputed\n     */\n\n    function _createIndexingDisputeWithAllocation(\n        address _fisherman,\n        uint256 _deposit,\n        address _allocationID\n    ) private returns (bytes32) {\n        // Create a disputeID\n        bytes32 disputeID = keccak256(abi.encodePacked(_allocationID));\n\n        // Only one dispute for an allocationID at a time\n        require(!isDisputeCreated(disputeID), \"Dispute already created\");\n\n        // Allocation must exist\n        IStaking staking = staking();\n        IStaking.Allocation memory alloc = staking.getAllocation(_allocationID);\n        require(alloc.indexer != address(0), \"Dispute allocation must exist\");\n\n        // The indexer must be disputable\n        require(staking.getIndexerStakedTokens(alloc.indexer) > 0, \"Dispute indexer has no stake\");\n\n        // Store dispute\n        disputes[disputeID] = Dispute(\n            alloc.indexer,\n            _fisherman,\n            _deposit,\n            0,\n            DisputeType.IndexingDispute\n        );\n\n        emit IndexingDisputeCreated(disputeID, alloc.indexer, _fisherman, _deposit, _allocationID);\n\n        return disputeID;\n    }\n\n    /**\n     * @dev The arbitrator accepts a dispute as being valid.\n     * @notice Accept a dispute with ID `_disputeID`\n     * @param _disputeID ID of the dispute to be accepted\n     */\n    function acceptDispute(bytes32 _disputeID) external override onlyArbitrator {\n        Dispute memory dispute = _resolveDispute(_disputeID);\n\n        // Slash\n        (, uint256 tokensToReward) =\n            _slashIndexer(dispute.indexer, dispute.fisherman, dispute.disputeType);\n\n        // Give the fisherman their deposit back\n        _pushTokens(dispute.fisherman, dispute.deposit);\n\n        // Resolve the conflicting dispute if any\n        _resolveDisputeInConflict(dispute);\n\n        emit DisputeAccepted(\n            _disputeID,\n            dispute.indexer,\n            dispute.fisherman,\n            dispute.deposit.add(tokensToReward)\n        );\n    }\n\n    /**\n     * @dev The arbitrator rejects a dispute as being invalid.\n     * @notice Reject a dispute with ID `_disputeID`\n     * @param _disputeID ID of the dispute to be rejected\n     */\n    function rejectDispute(bytes32 _disputeID) external override onlyArbitrator {\n        Dispute memory dispute = _resolveDispute(_disputeID);\n\n        // Handle conflicting dispute if any\n        require(\n            !_isDisputeInConflict(dispute),\n            \"Dispute for conflicting attestation, must accept the related ID to reject\"\n        );\n\n        // Burn the fisherman's deposit\n        if (dispute.deposit > 0) {\n            graphToken().burn(dispute.deposit);\n        }\n\n        emit DisputeRejected(_disputeID, dispute.indexer, dispute.fisherman, dispute.deposit);\n    }\n\n    /**\n     * @dev The arbitrator draws dispute.\n     * @notice Ignore a dispute with ID `_disputeID`\n     * @param _disputeID ID of the dispute to be disregarded\n     */\n    function drawDispute(bytes32 _disputeID) external override onlyArbitrator {\n        Dispute memory dispute = _resolveDispute(_disputeID);\n\n        // Return deposit to the fisherman\n        _pushTokens(dispute.fisherman, dispute.deposit);\n\n        // Resolve the conflicting dispute if any\n        _resolveDisputeInConflict(dispute);\n\n        emit DisputeDrawn(_disputeID, dispute.indexer, dispute.fisherman, dispute.deposit);\n    }\n\n    /**\n     * @dev Resolve a dispute by removing it from storage and returning a memory copy.\n     * @param _disputeID ID of the dispute to resolve\n     * @return Dispute\n     */\n    function _resolveDispute(bytes32 _disputeID) private returns (Dispute memory) {\n        require(isDisputeCreated(_disputeID), \"Dispute does not exist\");\n\n        Dispute memory dispute = disputes[_disputeID];\n\n        // Resolve dispute\n        delete disputes[_disputeID]; // Re-entrancy\n\n        return dispute;\n    }\n\n    /**\n     * @dev Returns whether the dispute is for a conflicting attestation or not.\n     * @param _dispute Dispute\n     * @return True conflicting attestation dispute\n     */\n    function _isDisputeInConflict(Dispute memory _dispute) private pure returns (bool) {\n        return _dispute.relatedDisputeID != 0;\n    }\n\n    /**\n     * @dev Resolve the conflicting dispute if there is any for the one passed to this function.\n     * @param _dispute Dispute\n     * @return True if resolved\n     */\n    function _resolveDisputeInConflict(Dispute memory _dispute) private returns (bool) {\n        if (_isDisputeInConflict(_dispute)) {\n            bytes32 relatedDisputeID = _dispute.relatedDisputeID;\n            delete disputes[relatedDisputeID];\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @dev Pull deposit from submitter account.\n     * @param _deposit Amount of tokens to deposit\n     */\n    function _pullSubmitterDeposit(uint256 _deposit) private {\n        // Ensure that fisherman has staked at least the minimum amount\n        require(_deposit >= minimumDeposit, \"Dispute deposit is under minimum required\");\n\n        // Transfer tokens to deposit from fisherman to this contract\n        _pullTokens(msg.sender, _deposit);\n    }\n\n    /**\n     * @dev Pull tokens from an address to this contract.\n     * @param _from Address sending the tokens\n     * @param _amount Amount of tokens to transfer\n     */\n    function _pullTokens(address _from, uint256 _amount) private {\n        if (_amount > 0) {\n            // Transfer tokens to deposit from fisherman to this contract\n            require(\n                graphToken().transferFrom(_from, address(this), _amount),\n                \"Cannot transfer tokens\"\n            );\n        }\n    }\n\n    /**\n     * @dev Push tokens from this contract to a receiving address.\n     * @param _to Address receiving the tokens\n     * @param _amount Amount of tokens to transfer\n     */\n    function _pushTokens(address _to, uint256 _amount) private {\n        if (_amount > 0) {\n            require(graphToken().transfer(_to, _amount), \"Cannot transfer tokens\");\n        }\n    }\n\n    /**\n     * @dev Make the staking contract slash the indexer and reward the challenger.\n     * Give the challenger a reward equal to the fishermanRewardPercentage of slashed amount\n     * @param _indexer Address of the indexer\n     * @param _challenger Address of the challenger\n     * @param _disputeType Type of dispute\n     * @return slashAmount Dispute slash amount\n     * @return rewardsAmount Dispute rewards amount\n     */\n    function _slashIndexer(\n        address _indexer,\n        address _challenger,\n        DisputeType _disputeType\n    ) private returns (uint256 slashAmount, uint256 rewardsAmount) {\n        IStaking staking = staking();\n\n        // Get slashable amount for indexer\n        uint256 slashableAmount = staking.getIndexerStakedTokens(_indexer); // slashable tokens\n\n        // Get slash amount\n        slashAmount = _getSlashingPercentageForDisputeType(_disputeType).mul(slashableAmount).div(\n            MAX_PPM\n        );\n        require(slashAmount > 0, \"Dispute has zero tokens to slash\");\n\n        // Get rewards amount\n        rewardsAmount = uint256(fishermanRewardPercentage).mul(slashAmount).div(MAX_PPM);\n\n        // Have staking contract slash the indexer and reward the fisherman\n        // Give the fisherman a reward equal to the fishermanRewardPercentage of slashed amount\n        staking.slash(_indexer, slashAmount, rewardsAmount, _challenger);\n    }\n\n    /**\n     * @dev Recover the signer address of the `_attestation`.\n     * @param _disputeType Dispute type\n     * @return Slashing percentage to use for the dispute type\n     */\n    function _getSlashingPercentageForDisputeType(DisputeType _disputeType)\n        private\n        view\n        returns (uint256)\n    {\n        if (_disputeType == DisputeType.QueryDispute) return uint256(qrySlashingPercentage);\n        if (_disputeType == DisputeType.IndexingDispute) return uint256(idxSlashingPercentage);\n        return 0;\n    }\n\n    /**\n     * @dev Recover the signer address of the `_attestation`.\n     * @param _attestation The attestation struct\n     * @return Signer address\n     */\n    function _recoverAttestationSigner(Attestation memory _attestation)\n        private\n        view\n        returns (address)\n    {\n        // Obtain the hash of the fully-encoded message, per EIP-712 encoding\n        Receipt memory receipt =\n            Receipt(\n                _attestation.requestCID,\n                _attestation.responseCID,\n                _attestation.subgraphDeploymentID\n            );\n        bytes32 messageHash = encodeHashReceipt(receipt);\n\n        // Obtain the signer of the fully-encoded EIP-712 message hash\n        // NOTE: The signer of the attestation is the indexer that served the request\n        return\n            ECDSA.recover(\n                messageHash,\n                abi.encodePacked(_attestation.r, _attestation.s, _attestation.v)\n            );\n    }\n\n    /**\n     * @dev Get the running network chain ID\n     * @return The chain ID\n     */\n    function _getChainID() private pure returns (uint256) {\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n\n    /**\n     * @dev Parse the bytes attestation into a struct from `_data`.\n     * @return Attestation struct\n     */\n    function _parseAttestation(bytes memory _data) private pure returns (Attestation memory) {\n        // Check attestation data length\n        require(_data.length == ATTESTATION_SIZE_BYTES, \"Attestation must be 161 bytes long\");\n\n        // Decode receipt\n        (bytes32 requestCID, bytes32 responseCID, bytes32 subgraphDeploymentID) =\n            abi.decode(_data, (bytes32, bytes32, bytes32));\n\n        // Decode signature\n        // Signature is expected to be in the order defined in the Attestation struct\n        bytes32 r = _toBytes32(_data, SIG_R_OFFSET);\n        bytes32 s = _toBytes32(_data, SIG_S_OFFSET);\n        uint8 v = _toUint8(_data, SIG_V_OFFSET);\n\n        return Attestation(requestCID, responseCID, subgraphDeploymentID, r, s, v);\n    }\n\n    /**\n     * @dev Parse a uint8 from `_bytes` starting at offset `_start`.\n     * @return uint8 value\n     */\n    function _toUint8(bytes memory _bytes, uint256 _start) private pure returns (uint8) {\n        require(_bytes.length >= (_start + UINT8_BYTE_LENGTH), \"Bytes: out of bounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    /**\n     * @dev Parse a bytes32 from `_bytes` starting at offset `_start`.\n     * @return bytes32 value\n     */\n    function _toBytes32(bytes memory _bytes, uint256 _start) private pure returns (bytes32) {\n        require(_bytes.length >= (_start + BYTES32_BYTE_LENGTH), \"Bytes: out of bounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n}"
    },
    {
      "filename": "contracts/disputes/DisputeManager.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.3;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/cryptography/ECDSA.sol\";\n\nimport \"../governance/Managed.sol\";\nimport \"../upgrades/GraphUpgradeable.sol\";\n\nimport \"./DisputeManagerStorage.sol\";\nimport \"./IDisputeManager.sol\";\n\n/*\n * @title DisputeManager\n * @notice Provides a way to align the incentives of participants by having slashing as deterrent\n * for incorrect behaviour.\n *\n * There are two types of disputes that can be created: Query disputes and Indexing disputes.\n *\n * Query Disputes:\n * Graph nodes receive queries and return responses with signed receipts called attestations.\n * An attestation can be disputed if the consumer thinks the query response was invalid.\n * Indexers use the derived private key for an allocation to sign attestations.\n *\n * Indexing Disputes:\n * Indexers present a Proof of Indexing (POI) when they close allocations to prove\n * they were indexing a subgraph. The Staking contract emits that proof with the format\n * keccak256(indexer.address, POI).\n * Any challenger can dispute the validity of a POI by submitting a dispute to this contract\n * along with a deposit.\n *\n * Arbitration:\n * Disputes can only be accepted, rejected or drawn by the arbitrator role that can be delegated\n * to a EOA or DAO.\n */\ncontract DisputeManager is DisputeManagerV1Storage, GraphUpgradeable, IDisputeManager {\n    using SafeMath for uint256;\n\n    // -- EIP-712  --\n\n    bytes32 private constant DOMAIN_TYPE_HASH =\n        keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)\"\n        );\n    bytes32 private constant DOMAIN_NAME_HASH = keccak256(\"Graph Protocol\");\n    bytes32 private constant DOMAIN_VERSION_HASH = keccak256(\"0\");\n    bytes32 private constant DOMAIN_SALT =\n        0xa070ffb1cd7409649bf77822cce74495468e06dbfaef09556838bf188679b9c2;\n    bytes32 private constant RECEIPT_TYPE_HASH =\n        keccak256(\"Receipt(bytes32 requestCID,bytes32 responseCID,bytes32 subgraphDeploymentID)\");\n\n    // -- Constants --\n\n    uint256 private constant ATTESTATION_SIZE_BYTES = 161;\n    uint256 private constant RECEIPT_SIZE_BYTES = 96;\n\n    uint256 private constant SIG_R_LENGTH = 32;\n    uint256 private constant SIG_S_LENGTH = 32;\n    uint256 private constant SIG_R_OFFSET = RECEIPT_SIZE_BYTES;\n    uint256 private constant SIG_S_OFFSET = RECEIPT_SIZE_BYTES + SIG_R_LENGTH;\n    uint256 private constant SIG_V_OFFSET = RECEIPT_SIZE_BYTES + SIG_R_LENGTH + SIG_S_LENGTH;\n\n    uint256 private constant UINT8_BYTE_LENGTH = 1;\n    uint256 private constant BYTES32_BYTE_LENGTH = 32;\n\n    uint256 private constant MAX_PPM = 1000000; // 100% in parts per million\n\n    // -- Events --\n\n    /**\n     * @dev Emitted when a query dispute is created for `subgraphDeploymentID` and `indexer`\n     * by `fisherman`.\n     * The event emits the a"
    }
  ]
}