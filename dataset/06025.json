{
  "Title": "[G-13] Use assembly to validate msg.sender",
  "Content": "\nWe can use assembly to efficiently validate msg.sender for the didPay and uniswapV3SwapCallback functions with the least amount of opcodes necessary. Additionally, we can use xor() instead of iszero(eq()), saving 3 gas. We can also potentially save gas on the unhappy path by using scratch space to store the error selector, potentially avoiding memory expansion costs.\n\n\n```solidity\nfile:  contracts/PositionManager/OptionsPositionManager.sol\n\n281    if (user != msg.sender ) {\n\n327    if (user == msg.sender) swapTokens(poolId, collateralAsset == token0 ? token1 : token0, 0);\n\n```\nhttps://github.com/code-423n4/2023-08-goodentry/blob/main/contracts/PositionManager/OptionsPositionManager.sol#L281\n\n```solidity\nfile:  contracts/TokenisableRange.sol\n\n136    require(msg.sender == creator, \"Unallowed call\");\n\n```\nhttps://github.com/code-423n4/2023-08-goodentry/blob/main/contracts/TokenisableRange.sol#L136\n\n```solidity\nfile:  contracts/helper/FixedOracle.sol\n\n11   require(msg.sender == owner, \"Only the owner can call this function.\");\n\n```\nhttps://github.com/code-423n4/2023-08-goodentry/blob/main/contracts/helper/FixedOracle.sol#L11\n\n```solidity\nfile:  contracts/PositionManager/OptionsPositionManager.sol\n\n91    require( address(lendingPool) == msg.sender, \"OPM: Call Unallowed\");\n\n```\nhttps://github.com/code-423n4/2023-08-goodentry/blob/main/contracts/PositionManager/OptionsPositionManager.sol#L91\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-08-goodentry",
  "Code": [
    {
      "filename": "contracts/PositionManager/OptionsPositionManager.sol",
      "content": "// SPDX-License-Identifier: none\npragma solidity 0.8.19;\n\nimport \"./PositionManager.sol\";\nimport \"../TokenisableRange.sol\";\n\ninterface  AmountsRouter {\n  function getAmountsOut(uint256 amountIn, address[] calldata path) external returns (uint256[] memory amounts);\n  function getAmountsIn(uint256 amountOut, address[] calldata path) external returns (uint256[] memory amounts);\n}\n\ncontract OptionsPositionManager is PositionManager {\n  using SafeERC20 for IERC20;\n\n  ////////////////////// EVENTS\n  event BuyOptions(address indexed user, address indexed asset, uint amount, uint amount0, uint amount1);\n  event SellOptions(address indexed user, address indexed asset, uint amount, uint amount0, uint amount1);\n  event ClosePosition(address indexed user, address indexed asset, uint amount, uint amount0, uint amount1);\n  event LiquidatePosition(address indexed user, address indexed asset, uint amount, uint amount0, uint amount1);\n  event ReducedPosition(address indexed user, address indexed asset, uint amount);\n  event Swap(address indexed user, address sourceAsset, uint sourceAmount, address targetAsset, uint targetAmount);\n\n\n  /// @param roerouter Address of Roe whitelist router\n  constructor (address roerouter) PositionManager(roerouter) {}\n\n\n  ////////////////////// DISPATCHER\n  /**\n   * @notice Aave-compatible flashloan receiver dispatch: open a leverage position or liquidate a position\n   * @param assets The address of the flash-borrowed asset\n   * @param amounts The amount of the flash-borrowed asset\n   * @param premiums The fee of the flash-borrowed asset\n   * @param initiator The address of the flashloan initiator\n   * @param params The byte-encoded params passed when initiating the flashloan\n   * @return result True if the execution of the operation succeeds, false otherwise\n   */\n  function executeOperation(\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address initiator,\n    bytes calldata params\n  ) override external returns (bool result) {\n    uint8 mode = abi.decode(params, (uint8) );\n    // Buy options\n    if ( mode == 0 ){\n      (, uint poolId, address user, address[] memory sourceSwap) = abi.decode(params, (uint8, uint, address, address[]));\n      executeBuyOptions(poolId, assets, amounts, user, sourceSwap);\n    }\n    // Liquidate\n    else {\n      (, uint poolId, address user, address collateral) = abi.decode(params, (uint8, uint, address, address));\n      executeLiquidation(poolId, assets, amounts, user, collateral);\n    }\n    result = true;\n  }\n  \n  \n  /// @notice Buy each flashloaned option\n  function executeBuyOptions(\n    uint poolId,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    address user,\n    address[] memory sourceSwap\n  ) internal {\n    (ILendingPool lendingPool,,, address token0, address token1 ) = getPoolAddresses(poolId);\n    require( address(lendingPool) == msg.sender, \"OPM: Call Unallowed\");\n    \n    for ( uint8 k = 0; k<assets.length; k++){\n      address asset = assets[k];\n      uint amount = amounts[k];\n      withdrawOptionAssets(poolId, asset, amount, sourceSwap[k], user);\n    }\n    // send all tokens to lendingPool\n    cleanup(lendingPool, user, token0);\n    cleanup(lendingPool, user, token1);\n  }\n  \n  \n  /// @notice Execute operation liquidation\n  function executeLiquidation(\n    uint poolId,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    address user,\n    address collateral\n  ) internal {\n    (ILendingPool lendingPool,,, address token0, address token1) = getPoolAddresses(poolId);\n    require( address(lendingPool) == msg.sender, \"OPM: Call Unallowed\");\n    uint[2] memory amts = [ERC20(token0).balanceOf(address(this)), ERC20(token1).balanceOf(address(this))];\n    for ( uint8 k =0; k<assets.length; k++){\n      address debtAsset = assets[k];\n      \n      // simple liquidation: debt is transferred from user to liquidator and collateral deposited to roe\n      uint amount = amounts[k];\n      \n      // liquidate and send assets here\n      checkSetAllowance(debtAsset, address(lendingPool), amount);\n      lendingPool.liquidationCall(collateral, debtAsset, user, amount, false);\n      // repay tokens\n      uint debt = closeDebt(poolId, address(this), debtAsset, amount, collateral);\n      uint amt0 = ERC20(token0).balanceOf(address(this));\n      uint amt1 = ERC20(token1).balanceOf(address(this));\n      emit LiquidatePosition(user, debtAsset, debt, amt0 - amts[0], amt1 - amts[1]);\n      amts[0] = amt0;\n      amts[1] = amt1;\n      \n    }\n  }\n\n\n  ////////////////////// BUY OPTIONS\n  \n  /// @notice Withdraw underlying option assets and swap if necessary\n  /// @param poolId ID of the ROE lending pool\n  /// @param flashAsset Option asset to borrow\n  /// @param flashAmount Amount to borrow\n  /// @param sourceSwap Asset to swap (put-call parity)\n  /// @param user Address of option buyer\n  /// @dev Only withdraws the tokens and swap, doesnt deposit, as this is done afterwards to avoid doing multiple times\n  function withdrawOptionAssets(\n    uint poolId,\n    address flashAsset,\n    uint256 flashAmount,\n    address sourceSwap,\n    address user\n  ) \n    private returns (bool result)\n  {\n    (, IPriceOracle oracle, IUniswapV2Router01 router, address token0, address token1) = getPoolAddresses(poolId);\n    sanityCheckUnderlying(flashAsset, token0, token1);\n    // Remove Liquidity and get underlying tokens\n    (uint256 amount0, uint256 amount1) = TokenisableRange(flashAsset).withdraw(flashAmount, 0, 0);\n    if (sourceSwap != address(0) ){\n      require(sourceSwap == token0 || sourceSwap == token1, \"OPM: Invalid Swap Token\");\n      address[] memory path = new address[](2);\n      path[0] = sourceSwap ;\n      path[1] = sourceSwap == token0 ? token1 : token0;\n      uint amount = sourceSwap == token0 ? amount0 : amount1;\n\n      uint received = swapExactTokensForTokens(router, oracle, amount, path);\n      // if swap underlying, then sourceSwap amount is 0 and the other amount is amount withdrawn + amount received from swap\n      amount0 = sourceSwap == token0 ? 0 : amount0 + received;\n      amount1 = sourceSwap == token1 ? 0 : amount1 + received;\n    }\n    emit BuyOptions(user, flashAsset, flashAmount, amount0, amount1);\n    result = true;\n  }\n\n  \n  /// @notice Buy a list of option. An option is a triplet [TRAddress, amount, putOrCall]\n  /// @param poolId ID of the ROE lending pool\n  /// @param options Option addresses list\n  /// @param amounts Option amounts list\n  /// @param sourceSwap Source swap address for call-put parity\n  /// @dev Because tickers are one coin or the other depending on the price, one can only buy OTM options. You can get ITM put by buying OTM call and swapping, or get ITM call by buying OTM put and swapping. If you wanna swap, set sourceSwap to the asset you *dont* want, otherwise must be address(0x0)\n  function buyOptions(\n    uint poolId, \n    address[] memory options, \n    uint[] memory amounts, \n    address[] memory sourceSwap\n  )\n    external\n  {\n    require(options.length == amounts.length && sourceSwap.length == options.length, \"OPM: Array Length Mismatch\");\n    bytes memory params = abi.encode(0, poolId, msg.sender, sourceSwap);\n    (ILendingPool LP,,,, ) = getPoolAddresses(poolId);\n\n    uint[] memory flashtype = new uint[](options.length);\n    for (uint8 i = 0; i< options.length; ){\n      flashtype[i] = 2;\n      unchecked { i+=1; }\n    }\n    LP.flashLoan( address(this), options, amounts, flashtype, msg.sender, params, 0);\n  }\n\n  \n  ////////////////////// LIQUIDATIONS\n  \n  /// @notice Liquidate up to 50% of an unhealthy position\n  /// @param poolId ID of the ROE lending pool\n  /// @param user The owner of the loan to liquidate\n  /// @param options Array of borrowed Ticker assets to repay\n  /// @param amounts Array of borrowed Ticker assets amounts to repay\n  /// @param collateralAsset Asset used for liquidation fee\n  /// @dev Flashloan the debt tokens to liquidate, then use liquidation assets to repay the flashloan\n  function liquidate (\n    uint poolId, \n    address user,\n    address[] memory options, \n    uint[] memory amounts,\n    address collateralAsset\n  )\n    external\n  {\n    require(options.length == amounts.length, \"ARRAY_LEN_MISMATCH\");\n    bytes memory params = abi.encode(1, poolId, user, collateralAsset); // mode = 1 -> liquidation\n    (ILendingPool LP,,, address token0, address token1) = getPoolAddresses(poolId);\n    \n    uint[] memory flashtype = new uint[](options.length);\n    for (uint8 i = 0; i< options.length; ){\n      flashtype[i] = 0; // dont open debt for liquidations, need to repay\n      unchecked { i+=1; }\n    }\n    LP.flashLoan( address(this), options, amounts, flashtype, msg.sender, params, 0);\n\n    // send all tokens to liquidator\n    cleanup(LP, msg.sender, token0);\n    cleanup(LP, msg.sender, token1);\n  }\n\n\n  ////////////////////// REDUCING POSITION\n  \n  /// @notice Repays a TR debt and send tokens back to user\n  /// @param poolId ID of the ROE lending pool\n  /// @param user Owner of the debt\n  /// @param debtAsset the borrowed LP token address\n  /// @param repayAmount amount of borrowed tokens to repay; 0 or higher than current debt will repay all\n  /// @param collateralAsset Asset used for liquidation fee\n  function close(\n    uint poolId, \n    address user,\n    address debtAsset, \n    uint repayAmount,\n    address collateralAsset\n  ) \n    external\n  {\n    (ILendingPool LP,,, address token0, address token1) = getPoolAddresses(poolId);\n    uint debt = ERC20(LP.getReserveData(debtAsset).variableDebtTokenAddress).balanceOf(user);\n    if ( repayAmount > 0 && repayAmount < debt ) debt = repayAmount;\n    require(debt > 0, \"OPM: No Debt\");\n    debt = closeDebt(poolId, user, debtAsset, debt, collateralAsset);\n\n    cleanup(LP, user, token0);\n    cleanup(LP, user, token1);\n    emit ReducedPosition(user, debtAsset, debt);\n  }\n\n\n  /// @notice Repays a TR debt\n  /// @param poolId ID of the ROE lending pool\n  /// @param user Owner of the debt to close. If user is address(this), we dont repay but just recreate tokens, flashloan will take care of getting them back\n  /// @param debtAsset the borrowed LP token address\n  /// @param repayAmount amount of borrowed tokens to repay; 0 or higher than current debt will repay all\n  /// @param collateralAsset Asset used for liquidation fee\n  function closeDebt(\n    uint poolId, \n    address user,\n    address debtAsset, \n    uint repayAmount,\n    address collateralAsset\n  ) \n    internal returns (uint debt)\n  {\n    (ILendingPool LP,,IUniswapV2Router01 ammRouter, address token0, address token1) = getPoolAddresses(poolId);\n    sanityCheckUnderlying(debtAsset, token0, token1);\n    require(collateralAsset == token0 || collateralAsset == token1, \"OPM: Invalid Collateral Asset\");\n    uint amtA;\n    uint amtB;\n    // Add dust to be sure debt reformed >= debt outstanding\n    debt = repayAmount + addDust(debtAsset, token0, token1);\n    \n    // Claim fees first so that deposit will match exactly\n    TokenisableRange(debtAsset).claimFee();\n    { //localize vars\n      (uint token0Amount, uint token1Amount) = TokenisableRange(debtAsset).getTokenAmounts(debt);\n      checkExpectedBalances(debtAsset, debt, token0Amount, token1Amount);\n      checkSetAllowance(token0, debtAsset, token0Amount);\n      checkSetAllowance(token1, debtAsset, token1Amount);\n      // If called by this contract himself this is a liquidation, skip that step\n      if (user != address(this) ){\n        amtA = IERC20(LP.getReserveData(token0).aTokenAddress ).balanceOf(user);\n        amtB = IERC20(LP.getReserveData(token1).aTokenAddress ).balanceOf(user);\n        PMWithdraw(LP, user, token0, amtA );\n        PMWithdraw(LP, user, token1, amtB );\n        // If another user softLiquidates a share of the liquidation goes to the treasury\n        if (user != msg.sender ) {\n          uint feeAmount = calculateAndSendFee(poolId, token0Amount, token1Amount, collateralAsset);\n          if (collateralAsset == token0) amtA -= feeAmount;\n          else amtB -= feeAmount;\n        }\n      }\n      else {\n        // Assets are already present from liquidation\n        amtA = ERC20(token0).balanceOf(user);\n        amtB = ERC20(token1).balanceOf(user);\n      }\n\n      // swap if one token is missing - consider that there is enough \n      address[] memory path = new address[](2);\n      if ( amtA < token0Amount ){\n        path[0] = token1;\n        path[1] = token0;\n        swapTokensForExactTokens(ammRouter, token0Amount - amtA, amtB, path); \n      }\n      else if ( amtB < token1Amount ){\n        path[0] = token0;\n        path[1] = token1;\n        swapTokensForExactTokens(ammRouter, token1Amount - amtB, amtA, path); \n      }\n      debt = TokenisableRange(debtAsset).deposit(token0Amount, token1Amount);\n    }\n    checkSetAllowance(debtAsset, address(LP), debt);\n    \n    // If user closes, repay debt, else tokens will be taken back by the flashloan\n    if (user != address(this) ) LP.repay( debtAsset, debt, 2, user);\n    {\n      uint amt0 = ERC20(token0).balanceOf(address(this));\n      uint amt1 = ERC20(token1).balanceOf(address(this));\n      // edge case where after swapping exactly the tokens and repaying debt, dust causes remaining asset balance to be slightly higher than before repaying\n      if (amtA > amt0) \n        amt0 = amtA - amt0;\n      else \n        amt0 = 0;\n      if (amtB > amt1) \n        amt1 = amtB - amt1;\n      else \n        amt1 = 0;\n      emit ClosePosition(user, debtAsset, debt, amt0, amt1);\n    }\n    \n    // Swap other token back to collateral: this allows to control exposure\n    if (user == msg.sender) swapTokens(poolId, collateralAsset == token0 ? token1 : token0, 0);\n  }\n  \n  \n  /// @notice Check that amounts to deposit in TR are matching expected balance based on oracle, to avoid sandwich attacks\n  /// @param debtAsset the borrowed LP token address\n  /// @param debtAmount the amount of debt\n  /// @param token0Amount Amount of token0 used to liquidate the debt\n  /// @param token1Amount Amount of token1 used to liquidate the debt\n  function checkExpectedBalances(address debtAsset, uint debtAmount, uint token0Amount, uint token1Amount) internal view\n  {\n    IAaveOracle oracle = TokenisableRange(debtAsset).ORACLE();\n    (ERC20 token0, uint8 decimals0) = TokenisableRange(debtAsset).TOKEN0();\n    (ERC20 token1, uint8 decimals1) = TokenisableRange(debtAsset).TOKEN1();\n    uint debtValue = TokenisableRange(debtAsset).latestAnswer() * debtAmount / 1e18;\n    uint tokensValue = token0Amount * oracle.getAssetPrice(address(token0)) / 10**decimals0 + token1Amount * oracle.getAssetPrice(address(token1)) / 10**decimals1;\n    // check that value of underlying tokens > 98% theoretical value  of TR asset, or that this is dust \n    require( \n      (debtValue < 1e8 && tokensValue < 1e8 )\n      || (tokensValue > debtValue * 98 / 100 && tokensValue < debtValue * 102 / 100), \n      \"OPM: Slippage Error\"\n    );\n  }\n\n  \n  /// @notice Calculates the liquidation fee and sends it to the treasury\n  /// @param poolId ROE pool Id\n  /// @param token0Amount Amount of token0 used to liquidate the debt\n  /// @param token1Amount Amount of token1 used to liquidate the debt\n  /// @param collateralAsset Asset used for liquidation fee\n  function calculateAndSendFee(\n    uint poolId, \n    uint token0Amount, \n    uint token1Amount, \n    address collateralAsset\n  ) internal returns (uint feeAmount) {\n    (, IPriceOracle oracle,, address token0, address token1) = getPoolAddresses(poolId);\n    \n    uint feeValueE8 = token0Amount * oracle.getAssetPrice(token0) / 10**ERC20(token0).decimals()\n                    + token1Amount * oracle.getAssetPrice(token1) / 10**ERC20(token1).decimals() ;\n    feeAmount = feeValueE8 * 10**ERC20(collateralAsset).decimals() / 100 / oracle.getAssetPrice(collateralAsset);\n    \n    require(feeAmount <= IERC20(collateralAsset).balanceOf(address(this)), \"OPM: Insufficient Collateral\");\n    IERC20(collateralAsset).safeTransfer(ROEROUTER.treasury(), feeAmount);\n  }\n\n  \n  ////////////////////// SELL OPTIONS\n  \n  \n  /// @notice Sell options\n  /// @param poolId ID of the ROE lending pool\n  /// @param optionAddress The TokenisableRange representing the option\n  /// @param amount0 The amount of underlying token0 to add\n  /// @param amount1 The amount of underlying token1 to add\n  /// @dev Amounts aren't checked and will revert if wrong. In 99.9% cases one of the amounts should be 0\n  /// @dev Collateral needs to be in Lending Pool already\n  function sellOptions(\n    uint poolId,\n    address optionAddress,\n    uint amount0,\n    uint amount1\n  )\n    external\n  {\n    (ILendingPool LP, IPriceOracle oracle,, address token0, address token1 ) = getPoolAddresses(poolId);\n    require( LP.getReserveData(optionAddress).aTokenAddress != address(0x0), \"OPM: Invalid Address\" );\n    \n    PMWithdraw(LP, msg.sender, token0, amount0);\n    PMWithdraw(LP, msg.sender, token1, amount1);\n    checkSetAllowance(token0, optionAddress, amount0);\n    checkSetAllowance(token1, optionAddress, amount1);\n    uint deposited = TokenisableRange(optionAddress).deposit(amount0, amount1);\n    \n    emit SellOptions(msg.sender, optionAddress, deposited, amount0, amount1 );\n    cleanup(LP, msg.sender, optionAddress);\n    cleanup(LP, msg.sender, token0);\n    cleanup(LP, msg.sender, token1);\n  }\n  \n  \n  /// @notice Stop selling = remove liquidity from a TR\n  /// @param poolId Id of the pool\n  /// @param optionAddress Address of the TR asset\n  /// @param amount Amount of TR asset redeemed\n  function withdrawOptions(\n    uint poolId,\n    address optionAddress,\n    uint amount\n  )\n    external\n  {\n    (ILendingPool LP,,, address token0, address token1 ) = getPoolAddresses(poolId);\n    require( LP.getReserveData(optionAddress).aTokenAddress != address(0x0), \"OPM: Invalid Address\" );\n    PMWithdraw(LP, msg.sender, optionAddress, amount);\n\n    // Get output amounts from oracle to avoid sandwich\n    (uint amount0, uint amount1) = TokenisableRange(optionAddress).withdraw(amount, 0, 0);\n    checkExpectedBalances(optionAddress, amount, amount0, amount1);\n    cleanup(LP, msg.sender, optionAddress);\n    cleanup(LP, msg.sender, token0);\n    cleanup(LP, msg.sender, token1);\n  }\n  \n  \n  ////////////////////// SWAP\n  \n  /// @notice Swap user assets; useful to change user risk profile\n  /// @param poolId Id of the pool\n  /// @param sourceAsset Asset to be swapped\n  /// @param amount of asset to swap - if 0, swap all\n  /// @return received Amount of target token received\n  function swapTokens(uint poolId, address sourceAsset, uint amount) public returns (uint received) {\n    (ILendingPool LP, IPriceOracle oracle,IUniswapV2Router01 router, address token0, address token1) = getPoolAddresses(poolId);\n    require(sourceAsset == token0 || sourceAsset == token1, \"OPM: Invalid Swap Asset\");\n    if (amount == 0) {\n      amount = ERC20(LP.getReserveData(sourceAsset).aTokenAddress).balanceOf(msg.sender);\n      if (amount == 0) return 0;\n    }\n    PMWithdraw(LP, msg.sender, sourceAsset, amount);\n\n    address[] memory path = new address[](2);\n    path[0] = sourceAsset ;\n    path[1] = sourceAsset == token0 ? token1 : token0;\n    received = swapExactTokensForTokens(router, oracle, amount, path);\n    \n    cleanup(LP, msg.sender, token0);\n    cleanup(LP, msg.sender, token1);\n    emit Swap(msg.sender, path[0], amount, path[1], received);\n  }\n  \n  \n  \n  \n  ////////////////////// HELPERS\n\n  \n  /// @notice Swaps assets for exact assets\n  /// @param ammRouter AMM router\n  /// @param oracle Price oracle\n  /// @param amount Amount of target token received\n  /// @param path The path [source, target] of the swap\n  /// @return received Amount of target tokens received\n  function swapExactTokensForTokens(IUniswapV2Router01 ammRouter, IPriceOracle oracle, uint amount, address[] memory path) \n    internal returns (uint256 received)\n  {\n    if (amount > 0 && AmountsRouter(address(ammRouter)).getAmountsOut(amount, path)[1] > 0){\n      checkSetAllowance(path[0], address(ammRouter), amount);\n      uint[] memory amounts = ammRouter.swapExactTokensForTokens(\n        amount, \n        getTargetAmountFromOracle(oracle, path[0], amount, path[1]) * 99 / 100, // allow 1% slippage \n        path, \n        address(this), \n        block.timestamp\n      );\n      received = amounts[1];\n    }\n  }\n  \n  /// @notice Swaps assets for exact assets\n  /// @param ammRouter AMM router\n  /// @param recvAmount Amount of target token received\n  /// @param maxAmount Amount of source token allowed to be spent minus margin\n  /// @param path The path [source, target] of the swap\n  function swapTokensForExactTokens(IUniswapV2Router01 ammRouter, uint recvAmount, uint maxAmount, address[] memory path) internal {\n    checkSetAllowance(path[0], address(ammRouter), maxAmount);\n    uint [] memory amountsIn = AmountsRouter(address(ammRouter)).getAmountsIn(recvAmount, path);\n        \n    require( amountsIn[0] <= maxAmount && amountsIn[0] > 0, \"OPM: Invalid Swap Amounts\" );\n    require( amountsIn[0] <= ERC20(path[0]).balanceOf(address(this)), \"OPM: Insufficient Token Amount\" );\n    amountsIn = ammRouter.swapTokensForExactTokens(\n      recvAmount,\n      maxAmount,\n      path,\n      address(this),\n      block.timestamp\n    );\n  }\n  \n\n  /// @notice Calculate a target swap amount based on oracle-provided token prices\n  /// @param oracle Price oracle\n  /// @param assetA address of token A\n  /// @param amountA Amount of toke A\n  /// @param assetB address of token B\n  /// @return amountB Amount of target token\n  function getTargetAmountFromOracle(IPriceOracle oracle, address assetA, uint amountA, address assetB) \n    internal view returns (uint amountB) \n  {\n    /**\n      uint valueA = amountA * oracle.getAssetPrice(assetA) / 10**ERC20(assetA).decimals();\n      uint valueB = amountB * oracle.getAssetPrice(assetB) / 10**ERC20(assetB).decimals();\n      We expect valueA == valueB\n    */\n    uint priceAssetA = oracle.getAssetPrice(assetA);\n    uint priceAssetB = oracle.getAssetPrice(assetB);\n    require ( priceAssetA > 0 && priceAssetB > 0, \"OPM: Invalid Oracle Price\");\n    amountB = amountA * priceAssetA * 10**ERC20(assetB).decimals() / 10**ERC20(assetA).decimals() / priceAssetB;\n    require( amountB > 0, \"OPM: Target Amount Too Low\");\n  }\n  \n  \n  /// @notice Check that tr is a Tokenisable Range matching given tokens or revert\n  /// @param tr Tokenisable range\n  /// @param token0 Underlying token 0\n  /// @param token1 Underlying token 1\n  function sanityCheckUnderlying(address tr, address token0, address token1) internal {\n    (ERC20 t0, ) = TokenisableRange(tr).TOKEN0();\n    (ERC20 t1, ) = TokenisableRange(tr).TOKEN1();\n    require(token0 == address(t0) && token1 == address(t1), \"OPM: Invalid Debt Asset\");\n  }\n  \n  \n  /// @notice Calculate a dust amount such that any underlying token amount would be larger than 100 units\n  /// @param debtAsset The debt TR asset\n  /// @param token0 Underlying token\n  /// @param token1 Underlying token\n  function addDust(address debtAsset, address token0, address token1) internal returns (uint amount){\n    IAaveOracle oracle = TokenisableRange(debtAsset).ORACLE();\n    uint scale0 = 10**(20 - ERC20(token0).decimals()) * oracle.getAssetPrice(token0) / 1e8;\n    uint scale1 = 10**(20 - ERC20(token1).decimals()) * oracle.getAssetPrice(token1) / 1e8;\n    \n    if (scale0 > scale1) amount = scale0;\n    else amount = scale1;\n  }\n}"
    },
    {
      "filename": "contracts/TokenisableRange.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nimport \"../interfaces/INonfungiblePositionManager.sol\";\nimport \"../interfaces/IUniswapV3Factory.sol\";\nimport \"../interfaces/IUniswapV3Pool.sol\";\nimport \"./openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\nimport \"./openzeppelin-solidity/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./openzeppelin-solidity/contracts/utils/Strings.sol\";\nimport \"./openzeppelin-solidity/contracts/security/ReentrancyGuard.sol\";\nimport \"./lib/LiquidityAmounts.sol\";\nimport \"./lib/TickMath.sol\";\nimport \"../interfaces/IAaveOracle.sol\";\nimport \"../interfaces/IAaveOracle.sol\";\n\n\n/// @notice Tokenize a Uniswap V3 NFT position\ncontract TokenisableRange is ERC20(\"\", \"\"), ReentrancyGuard {\n  using SafeERC20 for ERC20;\n  /// EVENTS\n  event InitTR(address asset0, address asset1, uint128 startX10, uint128 endX10);\n  event Deposit(address sender, uint trAmount);\n  event Withdraw(address sender, uint trAmount);\n  event ClaimFees(uint fee0, uint fee1);\n  \n  /// VARIABLES\n\n  int24 public lowerTick;\n  int24 public upperTick;\n  uint24 public feeTier;\n  \n  uint256 public tokenId;\n  uint256 public fee0;\n  uint256 public fee1;\n  \n  struct ASSET {\n    ERC20 token;\n    uint8 decimals;\n  }\n  \n  ASSET public TOKEN0;\n  ASSET public TOKEN1;\n  IAaveOracle public ORACLE;\n  \n  string _name;\n  string _symbol;\n  \n  enum ProxyState { INIT_PROXY, INIT_LP, READY }\n  ProxyState public status;\n  address private creator;\n  \n  uint128 public liquidity;\n  // @notice deprecated, keep to avoid beacon storage slot overwriting errors\n  address public TREASURY_DEPRECATED = 0x22Cc3f665ba4C898226353B672c5123c58751692;\n  uint public treasuryFee_deprecated = 20;\n  \n  // These are constant across chains - https://docs.uniswap.org/protocol/reference/deployments\n  INonfungiblePositionManager constant public POS_MGR = INonfungiblePositionManager(0xC36442b4a4522E871399CD717aBDD847Ab11FE88); \n  IUniswapV3Factory constant public V3_FACTORY = IUniswapV3Factory(0x1F98431c8aD98523631AE4a59f267346ea31F984); \n  address constant public treasury = 0x22Cc3f665ba4C898226353B672c5123c58751692;\n  uint constant public treasuryFee = 20;\n\n  /// @notice Babylonian method for sqrt\n  /// @param x sqrt parameter\n  /// @return y Square root\n  function sqrt(uint x) internal pure returns (uint y) {\n      uint z = (x + 1) / 2;\n      y = x;\n      while (z < y) {\n          y = z;\n          z = (x / z + z) / 2;\n      }\n  }\n\n\n  /// @notice Store range parameters\n  /// @param _oracle Address of the IAaveOracle interface of the ROE lending pool\n  /// @param asset0 Quote token address\n  /// @param asset1 Base token address \n  /// @param startX10 Range lower price scaled by 1e10\n  /// @param endX10 Range high price scaled by 1e10\n  /// @param startName Name of the range lower bound \n  /// @param endName Name of the range higher bound\n  /// @param isTicker Range is single tick liquidity around upperTick/startX10/startName\n  function initProxy(IAaveOracle _oracle, ERC20 asset0, ERC20 asset1, uint128 startX10, uint128 endX10, string memory startName, string memory endName, bool isTicker) external {\n    require(address(_oracle) != address(0x0), \"Invalid oracle\");\n    require(status == ProxyState.INIT_PROXY, \"!InitProxy\");\n    creator = msg.sender;\n    status = ProxyState.INIT_LP;\n    ORACLE = _oracle;\n    \n    TOKEN0.token    = asset0;\n    TOKEN0.decimals = asset0.decimals();\n    TOKEN1.token     = asset1;\n    TOKEN1.decimals  = asset1.decimals();\n    string memory quoteSymbol = asset0.symbol();\n    string memory baseSymbol  = asset1.symbol();\n        \n    int24 _upperTick = TickMath.getTickAtSqrtRatio( uint160( 2**48 * sqrt( (2 ** 96 * (10 ** TOKEN1.decimals)) * 1e10 / (uint256(startX10) * 10 ** TOKEN0.decimals) ) ) );\n    int24 _lowerTick = TickMath.getTickAtSqrtRatio( uint160( 2**48 * sqrt( (2 ** 96 * (10 ** TOKEN1.decimals)) * 1e10 / (uint256(endX10  ) * 10 ** TOKEN0.decimals) ) ) );\n    \n    if (isTicker) { \n      feeTier   = 5;\n      int24 midleTick;\n      midleTick = (_upperTick + _lowerTick) / 2;\n      _upperTick = (midleTick + int24(feeTier)) - (midleTick + int24(feeTier)) % int24(feeTier * 2);\n      _lowerTick = _upperTick - int24(feeTier) - int24(feeTier);\n      _name     = string(abi.encodePacked(\"Ticker \", baseSymbol, \" \", quoteSymbol, \" \", startName, \"-\", endName));\n     _symbol    = string(abi.encodePacked(\"T-\",startName,\"_\",endName,\"-\",baseSymbol,\"-\",quoteSymbol));\n    } else {\n      feeTier   = 5;\n      _lowerTick = (_lowerTick + int24(feeTier)) - (_lowerTick + int24(feeTier)) % int24(feeTier * 2);\n      _upperTick = (_upperTick + int24(feeTier)) - (_upperTick + int24(feeTier)) % int24(feeTier * 2);\n      _name     = string(abi.encodePacked(\"Ranger \", baseSymbol, \" \", quoteSymbol, \" \", startName, \"-\", endName));\n      _symbol   = string(abi.encodePacked(\"R-\",startName,\"_\",endName,\"-\",baseSymbol,\"-\",quoteSymbol));\n    }\n    lowerTick = _lowerTick;\n    upperTick = _upperTick;\n    emit InitTR(address(asset0), address(asset1), startX10, endX10);\n  }\n  \n\n  /// @notice Get the name of this contract token\n  /// @dev Override name, symbol and decimals from ERC20 inheritance\n  function name()     public view virtual override returns (string memory) { return _name; }\n  /// @notice Get the symbol of this contract token\n  function symbol()   public view virtual override returns (string memory) { return _symbol; }\n\n\n  /// @notice Initialize a TokenizableRange by adding assets in the underlying Uniswap V3 position\n  /// @param n0 Amount of quote token added\n  /// @param n1 Amount of base token added\n  /// @notice The token amounts must be 95% correct or this will fail the Uniswap slippage check\n  function init(uint n0, uint n1) external {\n    require(status == ProxyState.INIT_LP, \"!InitLP\");\n    require(msg.sender == creator, \"Unallowed call\");\n    status = ProxyState.READY;\n    TOKEN0.token.safeTransferFrom(msg.sender, address(this), n0);\n    TOKEN1.token.safeTransferFrom(msg.sender, address(this), n1);\n    TOKEN0.token.safeIncreaseAllowance(address(POS_MGR), n0);\n    TOKEN1.token.safeIncreaseAllowance(address(POS_MGR), n1);\n    (tokenId, liquidity, , ) = POS_MGR.mint( \n      INonfungiblePositionManager.MintParams({\n         token0: address(TOKEN0.token),\n         token1: address(TOKEN1.token),\n         fee: feeTier * 100,\n         tickLower: lowerTick,\n         tickUpper: upperTick,\n         amount0Desired: n0,\n         amount1Desired: n1,\n         amount0Min: n0 * 95 / 100,\n         amount1Min: n1 * 95 / 100,\n         recipient: address(this),\n         deadline: block.timestamp\n      })\n    );\n    \n    // Transfer remaining assets back to user\n    TOKEN0.token.safeTransfer( msg.sender,  TOKEN0.token.balanceOf(address(this)));\n    TOKEN1.token.safeTransfer(msg.sender, TOKEN1.token.balanceOf(address(this)));\n    _mint(msg.sender, 1e18);\n    emit Deposit(msg.sender, 1e18);\n  }\n  \n  \n  /// @notice Claim the accumulated Uniswap V3 trading fees\n  function claimFee() public {\n    (uint256 newFee0, uint256 newFee1) = POS_MGR.collect( \n      INonfungiblePositionManager.CollectParams({\n        tokenId: tokenId,\n        recipient: address(this),\n        amount0Max: type(uint128).max,\n        amount1Max: type(uint128).max\n      })\n    );\n    // If there's no new fees generated, skip compounding logic;\n    if ((newFee0 == 0) && (newFee1 == 0)) return;  \n    uint tf0 = newFee0 * treasuryFee / 100;\n    uint tf1 = newFee1 * treasuryFee / 100;\n    if (tf0 > 0) TOKEN0.token.safeTransfer(treasury, tf0);\n    if (tf1 > 0) TOKEN1.token.safeTransfer(treasury, tf1);\n    \n    fee0 = fee0 + newFee0 - tf0;\n    fee1 = fee1 + newFee1 - tf1;\n    \n    // Calculate expected balance,  \n    (uint256 bal0, uint256 bal1) = returnExpectedBalanceWithoutFees(0, 0);\n    \n    // If accumulated more than 1% worth of fees, compound by adding fees to Uniswap position\n    if ((fee0 * 100 > bal0 ) && (fee1 * 100 > bal1)) { \n      TOKEN0.token.safeIncreaseAllowance(address(POS_MGR), fee0);\n      TOKEN1.token.safeIncreaseAllowance(address(POS_MGR), fee1);\n      (uint128 newLiquidity, uint256 added0, uint256 added1) = POS_MGR.increaseLiquidity(\n        INonfungiblePositionManager.IncreaseLiquidityParams({\n          tokenId: tokenId,\n          amount0Desired: fee0,\n          amount1Desired: fee1,\n          amount0Min: 0,\n          amount1Min: 0,\n          deadline: block.timestamp\n        })\n      );\n      // check slippage: validate against value since token amounts can move widely\n      uint token0Price = ORACLE.getAssetPrice(address(TOKEN0.token));\n      uint token1Price = ORACLE.getAssetPrice(address(TOKEN1.token));\n      uint addedValue = added0 * token0Price / 10**TOKEN0.decimals + added1 * token1Price / 10**TOKEN1.decimals;\n      uint totalValue =   bal0 * token0Price / 10**TOKEN0.decimals +   bal1 * token1Price / 10**TOKEN1.decimals;\n      uint liquidityValue = totalValue * newLiquidity / liquidity;\n      require(addedValue > liquidityValue * 95 / 100 && liquidityValue > addedValue * 95 / 100, \"TR: Claim Fee Slippage\");\n      fee0 -= added0;\n      fee1 -= added1;\n      liquidity = liquidity + newLiquidity;\n    }\n    emit ClaimFees(newFee0, newFee1);\n  }\n  \n  \n  /// @notice Deposit assets into the range\n  /// @param n0 Amount of quote asset\n  /// @param n1 Amount of base asset\n  /// @return lpAmt Amount of"
    }
  ]
}