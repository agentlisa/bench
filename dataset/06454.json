{
  "Title": "[H-30] Incorrect flow of adding liquidity in `UlyssesRouter.sol`",
  "Content": "\nUsually the router in `AMM` is stateless, i.e. it isn't supposed to contain any tokens, it is just a wrapper of low-level pool functions to perform user-friendly interactions. The current implementation of `addLiquidity()` assumes that a user firstly transfers tokens to the router and then the router performs the deposit to the pool. However, it is not atomic and requires two transactions. Another user can break in after the first transaction and deposit someone else's tokens.\n\n### Proof of Concept\n\nThe router calls the deposit with `msg.sender` as a receiver of shares:\n\n<https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-amm/UlyssesRouter.sol#L49-L56>\n\n```solidity\n    function addLiquidity(uint256 amount, uint256 minOutput, uint256 poolId) external returns (uint256) {\n        UlyssesPool ulysses = getUlyssesLP(poolId);\n\n        amount = ulysses.deposit(amount, msg.sender);\n\n        if (amount < minOutput) revert OutputTooLow();\n        return amount;\n    }\n```\n\nAnd in deposit pool transfer tokens from `msg.sender`, which is the router:\n\n<https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/erc-4626/UlyssesERC4626.sol#L34-L45>\n\n```solidity\n    function deposit(uint256 assets, address receiver) public virtual nonReentrant returns (uint256 shares) {\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        shares = beforeDeposit(assets);\n\n        require(shares != 0, \"ZERO_SHARES\");\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n```\n\nFirst, a user will lose tokens sent to the router, if a malicious user calls `addLiquidity()` after it.\n\n### Recommended Mitigation Steps\n\nTransfer tokens to the router via `safeTransferFrom()`:\n\n```solidity\n    function addLiquidity(uint256 amount, uint256 minOutput, uint256 poolId) external returns (uint256) {\n        UlyssesPool ulysses = getUlyssesLP(poolId);\n        address(ulysses.asset()).safeTransferFrom(msg.sender, address(this), amount);\n\n        amount = ulysses.deposit(amount, msg.sender);\n\n        if (amount < minOutput) revert OutputTooLow();\n        return amount;\n    }\n```\n\n### Assessed type\n\nAccess Control\n\n**[0xLightt (Maia) confirmed](https://github.com/code-423n4/2023-05-maia-findings/issues/201#issuecomment-1631643366)**\n\n**[0xLightt (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/201#issuecomment-1655655112):**\n > We recognize the audit's findings on Ulysses AMM. These will not be rectified due to the upcoming migration of this section to Balancer Stable Pools.\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/ulysses-amm/UlyssesRouter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {UlyssesPool} from \"./UlyssesPool.sol\";\n\nimport {IUlyssesRouter, UlyssesFactory} from \"./interfaces/IUlyssesRouter.sol\";\n\n/// @title Ulysses Router - Handles routing of transactions in the Ulysses AMM\ncontract UlyssesRouter is IUlyssesRouter {\n    using SafeTransferLib for address;\n\n    /// @notice Mapping from pool id to Ulysses pool.\n    mapping(uint256 => UlyssesPool) private pools;\n\n    /// @inheritdoc IUlyssesRouter\n    UlyssesFactory public ulyssesFactory;\n\n    constructor(UlyssesFactory _ulyssesFactory) {\n        ulyssesFactory = _ulyssesFactory;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        Internal LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Returns the Ulysses pool for the given id.\n     * @param id The id of the Ulysses pool.\n     */\n    function getUlyssesLP(uint256 id) private returns (UlyssesPool ulysses) {\n        ulysses = pools[id];\n        if (address(ulysses) == address(0)) {\n            ulysses = ulyssesFactory.pools(id);\n\n            if (address(ulysses) == address(0)) revert UnrecognizedUlyssesLP();\n\n            pools[id] = ulysses;\n\n            address(ulysses.asset()).safeApprove(address(ulysses), type(uint256).max);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         LIQUIDITY LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IUlyssesRouter\n    function addLiquidity(uint256 amount, uint256 minOutput, uint256 poolId) external returns (uint256) {\n        UlyssesPool ulysses = getUlyssesLP(poolId);\n\n        amount = ulysses.deposit(amount, msg.sender);\n\n        if (amount < minOutput) revert OutputTooLow();\n        return amount;\n    }\n\n    /// @inheritdoc IUlyssesRouter\n    function removeLiquidity(uint256 amount, uint256 minOutput, uint256 poolId) external returns (uint256) {\n        UlyssesPool ulysses = getUlyssesLP(poolId);\n\n        amount = ulysses.redeem(amount, msg.sender, msg.sender);\n\n        if (amount < minOutput) revert OutputTooLow();\n        return amount;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            SWAP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IUlyssesRouter\n    function swap(uint256 amount, uint256 minOutput, Route[] calldata routes) external returns (uint256) {\n        address(getUlyssesLP(routes[0].from).asset()).safeTransferFrom(msg.sender, address(this), amount);\n\n        uint256 length = routes.length;\n\n        for (uint256 i = 0; i < length;) {\n            amount = getUlyssesLP(routes[i].from).swapIn(amount, routes[i].to);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (amount < minOutput) revert OutputTooLow();\n\n        unchecked {\n            --length;\n        }\n\n        address(getUlyssesLP(routes[length].to).asset()).safeTransfer(msg.sender, amount);\n\n        return amount;\n    }\n}"
    },
    {
      "filename": "src/erc-4626/UlyssesERC4626.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\n\nimport {IUlyssesERC4626} from \"./interfaces/IUlyssesERC4626.sol\";\n\n/// @title Minimal ERC4626 tokenized 1:1 Vault implementation\n/// @author Maia DAO (https://github.com/Maia-DAO)\nabstract contract UlyssesERC4626 is ERC20, ReentrancyGuard, IUlyssesERC4626 {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    address public immutable asset;\n\n    constructor(address _asset, string memory _name, string memory _symbol) ERC20(_name, _symbol, 18) {\n        asset = _asset;\n\n        if (ERC20(_asset).decimals() != 18) revert InvalidAssetDecimals();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function deposit(uint256 assets, address receiver) public virtual nonReentrant returns (uint256 shares) {\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        shares = beforeDeposit(assets);\n\n        require(shares != 0, \"ZERO_SHARES\");\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n\n    function mint(uint256 shares, address receiver) public virtual nonReentrant returns (uint256 assets) {\n        assets = beforeMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        require(assets != 0, \"ZERO_ASSETS\");\n\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n\n    function redeem(uint256 shares, address receiver, address owner)\n        public\n        virtual\n        nonReentrant\n        returns (uint256 assets)\n    {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        _burn(owner, shares);\n\n        assets = afterRedeem(shares);\n\n        require(assets != 0, \"ZERO_ASSETS\");\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        return assets;\n    }\n\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        return shares;\n    }\n\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return assets;\n    }\n\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        return shares;\n    }\n\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return shares;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Should not do any external calls to prevent reentrancy.\n    function beforeDeposit(uint256 assets) internal virtual returns (uint256 shares);\n\n    /// @dev Should not do any external calls to prevent reentrancy.\n    function beforeMint(uint256 shares) internal virtual returns (uint256 assets);\n\n    /// @dev Should not do any external calls to prevent reentrancy.\n    function afterRedeem(uint256 shares) internal virtual returns (uint256 assets);\n}"
    }
  ]
}