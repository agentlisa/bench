{
  "Title": "[M-05] `anchor_basset_reward` pending yields can be stolen",
  "Content": "\nFor yield farming aggregators, if the pending yield on an underlying strategy can be harvested and cause a surge of rewards to all existing investors, especially if the harvest can be triggered permissionlessly. Then the attacker can amplify the attack using a flash loan.\n\nThis is a well-known attack vector on Ethereum.\n\nThe root cause for this attack vector is that the pending yield is not settled to the existing users before issuing shares to new deposits.\n\nIn the current implementation of anchor\\_basset\\_reward/src/user.rs#execute\\_increase\\_balance() before L105, the `state.global_index` is not being upadted first.\n\n*   Expected: the pending rewards (current\\_global\\_index - state.global\\_index) belongs to old user balance,\n*   Current implementation: the pending rewards (current\\_global\\_index - state.global\\_index) will be multiplied by the new user balance after `increase_balance` when calculate rewards.\n\nBecause new user balance > old user balance, the user will take a part of the rewards belonging to other existing users.\n\n<https://github.com/code-423n4/2022-02-anchor/blob/7af353e3234837979a19ddc8093dc9ad3c63ab6b/contracts/anchor-bAsset-contracts/contracts/anchor_basset_reward/src/user.rs#L80-L123>\n\n```rust\npub fn execute_increase_balance(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    address: String,\n    amount: Uint128,\n) -> StdResult<Response<TerraMsgWrapper>> {\n    let config = read_config(deps.storage)?;\n    let owner_human = deps.api.addr_humanize(&config.hub_contract)?;\n    let address_raw = deps.api.addr_canonicalize(&address)?;\n    let sender = info.sender;\n\n    let token_address = deps\n        .api\n        .addr_humanize(&query_token_contract(deps.as_ref(), owner_human)?)?;\n\n    // Check sender is token contract\n    if sender != token_address {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    let mut state: State = read_state(deps.storage)?;\n    let mut holder: Holder = read_holder(deps.storage, &address_raw)?;\n\n    // get decimals\n    let rewards = calculate_decimal_rewards(state.global_index, holder.index, holder.balance)?;\n\n    holder.index = state.global_index;\n    holder.pending_rewards = decimal_summation_in_256(rewards, holder.pending_rewards);\n    holder.balance += amount;\n    state.total_balance += amount;\n\n    store_holder(deps.storage, &address_raw, &holder)?;\n    store_state(deps.storage, &state)?;\n\n    let attributes = vec![\n        attr(\"action\", \"increase_balance\"),\n        attr(\"holder_address\", address),\n        attr(\"amount\", amount),\n    ];\n\n    let res = Response::new().add_attributes(attributes);\n    Ok(res)\n}\n```\n\n### Proof of Concept\n\nGiven:\n\n*   the reward balance of `anchor_basset_reward` increased\n\nThe attacker can:\n\n1.  `bond` a large amount of asset tokens\n\n<!---->\n\n    -   [anchor_basset_hub](https://github.com/code-423n4/2022-02-anchor/blob/7af353e3234837979a19ddc8093dc9ad3c63ab6b/contracts/anchor-bAsset-contracts/contracts/anchor_basset_hub/src/bond.rs#L88-L107) will trigger `anchor_basset_token` to mint basset tokens to the attacker\n    -   [anchor_basset_token](https://github.com/code-423n4/2022-02-anchor/blob/7af353e3234837979a19ddc8093dc9ad3c63ab6b/contracts/anchor-bAsset-contracts/contracts/anchor_basset_token/src/handler.rs#L90-L98) will trigger `anchor_basset_reward` to IncreaseBalance for the attacker\n    -   [anchor_basset_reward](https://github.com/code-423n4/2022-02-anchor/blob/7af353e3234837979a19ddc8093dc9ad3c63ab6b/contracts/anchor-bAsset-contracts/contracts/anchor_basset_reward/src/user.rs#L107) will use the old `state.global_index` to update the attacker's `holder.index`\n\n2.  `UpdateGlobalIndex` on anchor\\_basset\\_hub\n    *   [`anchor_basset_hub`](https://github.com/code-423n4/2022-02-anchor/blob/7af353e3234837979a19ddc8093dc9ad3c63ab6b/contracts/anchor-bAsset-contracts/contracts/anchor_basset_hub/src/contract.rs#L258-L262) will trigger anchor\\_basset\\_reward's  `execute_update_global_index()` and increase `global_index` for all users\n\nAs of now, the attacker can get a large share of the pending yield. The attacker can claim the rewards and exit.\n\nThis process can be done in one transaction by using a smart contract, and the impact can be amplified by using a flash loan.\n\n### Recommended Mitigation Steps\n\nConsider changing to a similar approach like [`anchor_beth_reward/src/user.rs#L114`](https://github.com/code-423n4/2022-02-anchor/blob/7af353e3234837979a19ddc8093dc9ad3c63ab6b/contracts/anchor-bEth-contracts/contracts/anchor_beth_reward/src/user.rs#L114), update `state.global_index` before changing the user's balance.\n\nAnd/or, transfer rewards and update `global_index` in one transaction.\n\n**[Alex the Entreprenerd (triage) commented](https://github.com/code-423n4/2022-02-anchor-findings/issues/48#issuecomment-1205896976):**\n > Seems like loss of yield due to frontrun.\n\n**[Albert Chon (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-02-anchor-findings/issues/48#issuecomment-1251627358):**\n > Indeed a bug, although this bug can be mitigated in practice by continuously executing `UpdateGlobalIndex`, doing so shouldn't necessarily be a requirement for the functioning of the system.  \n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-anchor-contest",
  "Code": [
    {
      "filename": "contracts/anchor-bAsset-contracts/contracts/anchor_basset_reward/src/user.rs",
      "content": "use crate::querier::query_token_contract;\nuse crate::state::{\n    read_config, read_holder, read_holders, read_state, store_holder, store_state, Config, Holder,\n    State,\n};\nuse basset::reward::{AccruedRewardsResponse, HolderResponse, HoldersResponse};\n\nuse cosmwasm_std::{\n    attr, BankMsg, Coin, CosmosMsg, Decimal, Deps, DepsMut, Env, MessageInfo, Response, StdError,\n    StdResult, Uint128,\n};\n\nuse crate::math::{\n    decimal_multiplication_in_256, decimal_subtraction_in_256, decimal_summation_in_256,\n};\nuse basset::deduct_tax;\nuse std::str::FromStr;\nuse terra_cosmwasm::TerraMsgWrapper;\n\npub fn execute_claim_rewards(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    recipient: Option<String>,\n) -> StdResult<Response<TerraMsgWrapper>> {\n    let holder_addr = info.sender;\n    let holder_addr_raw = deps.api.addr_canonicalize(holder_addr.as_str())?;\n    let recipient = match recipient {\n        Some(value) => deps.api.addr_validate(value.as_str()).unwrap(),\n        None => holder_addr.clone(),\n    };\n\n    let mut holder: Holder = read_holder(deps.storage, &holder_addr_raw)?;\n    let mut state: State = read_state(deps.storage)?;\n    let config: Config = read_config(deps.storage)?;\n\n    let reward_with_decimals =\n        calculate_decimal_rewards(state.global_index, holder.index, holder.balance)?;\n\n    let all_reward_with_decimals =\n        decimal_summation_in_256(reward_with_decimals, holder.pending_rewards);\n    let decimals = get_decimals(all_reward_with_decimals)?;\n\n    let rewards = all_reward_with_decimals * Uint128::new(1);\n\n    if rewards.is_zero() {\n        return Err(StdError::generic_err(\"No rewards have accrued yet\"));\n    }\n\n    let new_balance = (state.prev_reward_balance.checked_sub(rewards))?;\n    state.prev_reward_balance = new_balance;\n    store_state(deps.storage, &state)?;\n\n    holder.pending_rewards = decimals;\n    holder.index = state.global_index;\n    store_holder(deps.storage, &holder_addr_raw, &holder)?;\n\n    let bank_msg: CosmosMsg<TerraMsgWrapper> = CosmosMsg::Bank(BankMsg::Send {\n        to_address: recipient.to_string(),\n        amount: vec![deduct_tax(\n            &deps.querier,\n            Coin {\n                denom: config.reward_denom,\n                amount: rewards,\n            },\n        )?],\n    });\n\n    let res = Response::new()\n        .add_attributes(vec![\n            attr(\"action\", \"claim_reward\"),\n            attr(\"holder_address\", holder_addr),\n            attr(\"rewards\", rewards),\n        ])\n        .add_message(bank_msg);\n\n    Ok(res)\n}\n\npub fn execute_increase_balance(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    address: String,\n    amount: Uint128,\n) -> StdResult<Response<TerraMsgWrapper>> {\n    let config = read_config(deps.storage)?;\n    let owner_human = deps.api.addr_humanize(&config.hub_contract)?;\n    let address_raw = deps.api.addr_canonicalize(&address)?;\n    let sender = info.sender;\n\n    let token_address = deps\n        .api\n        .addr_humanize(&query_token_contract(deps.as_ref(), owner_human)?)?;\n\n    // Check sender is token contract\n    if sender != token_address {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    let mut state: State = read_state(deps.storage)?;\n    let mut holder: Holder = read_holder(deps.storage, &address_raw)?;\n\n    // get decimals\n    let rewards = calculate_decimal_rewards(state.global_index, holder.index, holder.balance)?;\n\n    holder.index = state.global_index;\n    holder.pending_rewards = decimal_summation_in_256(rewards, holder.pending_rewards);\n    holder.balance += amount;\n    state.total_balance += amount;\n\n    store_holder(deps.storage, &address_raw, &holder)?;\n    store_state(deps.storage, &state)?;\n\n    let attributes = vec![\n        attr(\"action\", \"increase_balance\"),\n        attr(\"holder_address\", address),\n        attr(\"amount\", amount),\n    ];\n\n    let res = Response::new().add_attributes(attributes);\n    Ok(res)\n}\n\npub fn execute_decrease_balance(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    address: String,\n    amount: Uint128,\n) -> StdResult<Response<TerraMsgWrapper>> {\n    let config = read_config(deps.storage)?;\n    let hub_contract = deps.api.addr_humanize(&config.hub_contract)?;\n    let address_raw = deps.api.addr_canonicalize(&address)?;\n\n    // Check sender is token contract\n    if query_token_contract(deps.as_ref(), hub_contract)?\n        != deps.api.addr_canonicalize(info.sender.as_str())?\n    {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    let mut state: State = read_state(deps.storage)?;\n    let mut holder: Holder = read_holder(deps.storage, &address_raw)?;\n    if holder.balance < amount {\n        return Err(StdError::generic_err(format!(\n            \"Decrease amount cannot exceed user balance: {}\",\n            holder.balance\n        )));\n    }\n\n    let rewards = calculate_decimal_rewards(state.global_index, holder.index, holder.balance)?;\n\n    holder.index = state.global_index;\n    holder.pending_rewards = decimal_summation_in_256(rewards, holder.pending_rewards);\n    holder.balance = (holder.balance.checked_sub(amount))?;\n    state.total_balance = (state.total_balance.checked_sub(amount))?;\n\n    store_holder(deps.storage, &address_raw, &holder)?;\n    store_state(deps.storage, &state)?;\n\n    let attributes = vec![\n        attr(\"action\", \"decrease_balance\"),\n        attr(\"holder_address\", address),\n        attr(\"amount\", amount),\n    ];\n\n    let res = Response::new().add_attributes(attributes);\n\n    Ok(res)\n}\n\npub fn query_accrued_rewards(deps: Deps, address: String) -> StdResult<AccruedRewardsResponse> {\n    let global_index = read_state(deps.storage)?.global_index;\n\n    let holder: Holder = read_holder(deps.storage, &deps.api.addr_canonicalize(&address)?)?;\n    let reward_with_decimals =\n        calculate_decimal_rewards(global_index, holder.index, holder.balance)?;\n    let all_reward_with_decimals =\n        decimal_summation_in_256(reward_with_decimals, holder.pending_rewards);\n\n    let rewards = all_reward_with_decimals * Uint128::new(1);\n\n    Ok(AccruedRewardsResponse { rewards })\n}\n\npub fn query_holder(deps: Deps, address: String) -> StdResult<HolderResponse> {\n    let holder: Holder = read_holder(deps.storage, &deps.api.addr_canonicalize(&address)?)?;\n    Ok(HolderResponse {\n        address,\n        balance: holder.balance,\n        index: holder.index,\n        pending_rewards: holder.pending_rewards,\n    })\n}\n\npub fn query_holders(\n    deps: Deps,\n    start_after: Option<String>,\n    limit: Option<u32>,\n) -> StdResult<HoldersResponse> {\n    let start_after = if let Some(start_after) = start_after {\n        Some(deps.api.addr_validate(&start_after)?)\n    } else {\n        None\n    };\n\n    let holders: Vec<HolderResponse> = read_holders(deps, start_after, limit)?;\n\n    Ok(HoldersResponse { holders })\n}\n\n// calculate the reward based on the sender's index and the global index.\nfn calculate_decimal_rewards(\n    global_index: Decimal,\n    user_index: Decimal,\n    user_balance: Uint128,\n) -> StdResult<Decimal> {\n    let decimal_balance = Decimal::from_ratio(user_balance, Uint128::new(1));\n    Ok(decimal_multiplication_in_256(\n        decimal_subtraction_in_256(global_index, user_index),\n        decimal_balance,\n    ))\n}\n\n// calculate the reward with decimal\nfn get_decimals(value: Decimal) -> StdResult<Decimal> {\n    let stringed: &str = &*value.to_string();\n    let parts: &[&str] = &*stringed.split('.').collect::<Vec<&str>>();\n    match parts.len() {\n        1 => Ok(Decimal::zero()),\n        2 => {\n            let decimals = Decimal::from_str(&*(\"0.\".to_owned() + parts[1]))?;\n            Ok(decimals)\n        }\n        _ => Err(StdError::generic_err(\"Unexpected number of dots\")),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    pub fn proper_calculate_rewards() {\n        let global_index = Decimal::from_ratio(Uint128::new(9), Uint128::new(100));\n        let user_index = Decimal::zero();\n        let user_balance = Uint128::new(1000);\n        let reward = calculate_decimal_rewards(global_index, user_index, user_balance).unwrap();\n        assert_eq!(reward.to_string(), \"90\");\n    }\n\n    #[test]\n    pub fn proper_get_decimals() {\n        let global_index = Decimal::from_ratio(Uint128::new(9999999), Uint128::new(100000000));\n        let user_index = Decimal::zero();\n        let user_balance = Uint128::new(10);\n        let reward = get_decimals(\n            calculate_decimal_rewards(global_index, user_index, user_balance).unwrap(),\n        )\n        .unwrap();\n        assert_eq!(reward.to_string(), \"0.9999999\");\n    }\n}"
    },
    {
      "filename": "contracts/anchor-bAsset-contracts/contracts/anchor_basset_hub/src/bond.rs",
      "content": "use crate::contract::{query_total_issued, slashing};\nuse crate::math::decimal_division;\nuse crate::state::{is_valid_validator, CONFIG, CURRENT_BATCH, PARAMETERS, STATE};\nuse basset::hub::State;\nuse cosmwasm_std::{\n    attr, to_binary, CosmosMsg, DepsMut, Env, MessageInfo, Response, StakingMsg, StdError,\n    StdResult, Uint128, WasmMsg,\n};\nuse cw20::Cw20ExecuteMsg;\n\npub fn execute_bond(\n    mut deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    validator: String,\n) -> StdResult<Response> {\n    // validator must be whitelisted\n    let is_valid = is_valid_validator(deps.storage, validator.clone())?;\n    if !is_valid {\n        return Err(StdError::generic_err(\n            \"The chosen validator is currently not supported\",\n        ));\n    }\n\n    let params = PARAMETERS.load(deps.storage)?;\n    let coin_denom = params.underlying_coin_denom;\n    let threshold = params.er_threshold;\n    let recovery_fee = params.peg_recovery_fee;\n\n    // current batch requested fee is need for accurate exchange rate computation.\n    let current_batch = CURRENT_BATCH.load(deps.storage)?;\n    let requested_with_fee = current_batch.requested_with_fee;\n\n    // coin must have be sent along with transaction and it should be in underlying coin denom\n    if info.funds.len() > 1usize {\n        return Err(StdError::generic_err(\n            \"More than one coin is sent; only one asset is supported\",\n        ));\n    }\n\n    let payment = info\n        .funds\n        .iter()\n        .find(|x| x.denom == coin_denom && x.amount > Uint128::zero())\n        .ok_or_else(|| {\n            StdError::generic_err(format!(\"No {} assets are provided to bond\", coin_denom))\n        })?;\n\n    // check slashing\n    slashing(&mut deps, env)?;\n\n    let state = STATE.load(deps.storage)?;\n    let sender = info.sender;\n\n    // get the total supply\n    let mut total_supply = query_total_issued(deps.as_ref()).unwrap_or_default();\n\n    // peg recovery fee should be considered\n    let mint_amount = decimal_division(payment.amount, state.exchange_rate);\n    let mut mint_amount_with_fee = mint_amount;\n    if state.exchange_rate < threshold {\n        let max_peg_fee = mint_amount * recovery_fee;\n        let required_peg_fee = ((total_supply + mint_amount + current_batch.requested_with_fee)\n            .checked_sub(state.total_bond_amount + payment.amount))?;\n        let peg_fee = Uint128::min(max_peg_fee, required_peg_fee);\n        mint_amount_with_fee = (mint_amount.checked_sub(peg_fee))?;\n    }\n\n    // total supply should be updated for exchange rate calculation.\n    total_supply += mint_amount_with_fee;\n\n    // exchange rate should be updated for future\n    STATE.update(deps.storage, |mut prev_state| -> StdResult<State> {\n        prev_state.total_bond_amount += payment.amount;\n        prev_state.update_exchange_rate(total_supply, requested_with_fee);\n        Ok(prev_state)\n    })?;\n\n    let mut messages: Vec<CosmosMsg> = vec![\n        // send the delegate message\n        CosmosMsg::Staking(StakingMsg::Delegate {\n            validator,\n            amount: payment.clone(),\n        }),\n    ];\n\n    // issue the basset token for sender\n    let mint_msg = Cw20ExecuteMsg::Mint {\n        recipient: sender.to_string(),\n        amount: mint_amount_with_fee,\n    };\n\n    let config = CONFIG.load(deps.storage)?;\n    let token_address = deps\n        .api\n        .addr_humanize(\n            &config\n                .token_contract\n                .expect(\"the token contract must have been registered\"),\n        )?\n        .to_string();\n\n    messages.push(CosmosMsg::Wasm(WasmMsg::Execute {\n        contract_addr: token_address,\n        msg: to_binary(&mint_msg)?,\n        funds: vec![],\n    }));\n\n    Ok(Response::new().add_messages(messages).add_attributes(vec![\n        attr(\"action\", \"mint\"),\n        attr(\"from\", sender),\n        attr(\"bonded\", payment.amount),\n        attr(\"minted\", mint_amount_with_fee),\n    ]))\n}"
    },
    {
      "filename": "contracts/anchor-bAsset-contracts/contracts/anchor_basset_token/src/handler.rs",
      "content": "use cosmwasm_std::{\n    to_binary, Binary, CosmosMsg, DepsMut, Env, MessageInfo, Response, SubMsg, Uint128, WasmMsg,\n};\n\nuse crate::querier::query_reward_contract;\nuse basset::reward::ExecuteMsg::{DecreaseBalance, IncreaseBalance};\nuse cw20_legacy::allowances::{\n    execute_burn_from as cw20_burn_from, execute_send_from as cw20_send_from,\n    execute_transfer_from as cw20_transfer_from,\n};\nuse cw20_legacy::contract::{\n    execute_burn as cw20_burn, execute_mint as cw20_mint, execute_send as cw20_send,\n    execute_transfer as cw20_transfer,\n};\nuse cw20_legacy::ContractError;\n\npub fn execute_transfer(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    recipient: String,\n    amount: Uint128,\n) -> Result<Response, ContractError> {\n    let sender = info.sender.clone();\n    let reward_contract = query_reward_contract(&deps)?;\n\n    let rcpt_addr = deps.api.addr_validate(&recipient)?;\n\n    let res: Response = cw20_transfer(deps, env, info, recipient, amount)?;\n    let messages = vec![\n        CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: reward_contract.to_string(),\n            msg: to_binary(&DecreaseBalance {\n                address: sender.to_string(),\n                amount,\n            })\n            .unwrap(),\n            funds: vec![],\n        }),\n        CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: reward_contract.to_string(),\n            msg: to_binary(&IncreaseBalance {\n                address: rcpt_addr.to_string(),\n                amount,\n            })\n            .unwrap(),\n            funds: vec![],\n        }),\n    ];\n    Ok(Response::new()\n        .add_messages(messages)\n        .add_attributes(res.attributes))\n}\n\npub fn execute_burn(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    amount: Uint128,\n) -> Result<Response, ContractError> {\n    let sender = info.sender.clone();\n    let reward_contract = query_reward_contract(&deps)?;\n\n    let res: Response = cw20_burn(deps, env, info, amount)?;\n    let messages = vec![CosmosMsg::Wasm(WasmMsg::Execute {\n        contract_addr: reward_contract.to_string(),\n        msg: to_binary(&DecreaseBalance {\n            address: sender.to_string(),\n            amount,\n        })\n        .unwrap(),\n        funds: vec![],\n    })];\n    Ok(Response::new()\n        .add_messages(messages)\n        .add_attributes(res.attributes))\n}\n\npub fn execute_mint(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    recipient: String,\n    amount: Uint128,\n) -> Result<Response, ContractError> {\n    let reward_contract = query_reward_contract(&deps)?;\n\n    let res: Response = cw20_mint(deps, env, info, recipient.clone(), amount)?;\n    Ok(Response::new()\n        .add_messages(vec![CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: reward_contract.to_string(),\n            msg: to_binary(&IncreaseBalance {\n                address: recipient,\n                amount,\n            })\n            .unwrap(),\n            funds: vec![],\n        })])\n        .add_attributes(res.attributes))\n}\n\npub fn execute_send(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    contract: String,\n    amount: Uint128,\n    msg: Binary,\n) -> Result<Response, ContractError> {\n    let sender = info.sender.clone();\n    let reward_contract = query_reward_contract(&deps)?;\n\n    let res: Response = cw20_send(deps, env, info, contract.clone(), amount, msg)?;\n    let messages = vec![\n        vec![\n            SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: reward_contract.to_string(),\n                msg: to_binary(&DecreaseBalance {\n                    address: sender.to_string(),\n                    amount,\n                })\n                .unwrap(),\n                funds: vec![],\n            })),\n            SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: reward_contract.to_string(),\n                msg: to_binary(&IncreaseBalance {\n                    address: contract,\n                    amount,\n                })\n                .unwrap(),\n                funds: vec![],\n            })),\n        ],\n        res.messages,\n    ]\n    .concat();\n\n    Ok(Response::new()\n        .add_submessages(messages)\n        .add_attributes(res.attributes))\n}\n\npub fn execute_transfer_from(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    owner: String,\n    recipient: String,\n    amount: Uint128,\n) -> Result<Response, ContractError> {\n    let reward_contract = query_reward_contract(&deps)?;\n\n    let valid_owner = deps.api.addr_validate(owner.as_str())?;\n\n    let res: Response = cw20_transfer_from(deps, env, info, owner, recipient.clone(), amount)?;\n    let messages = vec![\n        CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: reward_contract.to_string(),\n            msg: to_binary(&DecreaseBalance {\n                address: valid_owner.to_string(),\n                amount,\n            })\n            .unwrap(),\n            funds: vec![],\n        }),\n        CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: reward_contract.to_string(),\n            msg: to_binary(&IncreaseBalance {\n                address: recipient,\n                amount,\n            })\n            .unwrap(),\n            funds: vec![],\n        }),\n    ];\n    Ok(Response::new()\n        .add_messages(messages)\n        .add_attributes(res.attributes))\n}\n\npub fn execute_burn_from(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    owner: String,\n    amount: Uint128,\n) -> Result<Response, ContractError> {\n    let reward_contract = query_reward_contract(&deps)?;\n\n    let valid_owner = deps.api.addr_validate(owner.as_str())?;\n\n    let res: Response = cw20_burn_from(deps, env, info, owner, amount)?;\n    let messages = vec![CosmosMsg::Wasm(WasmMsg::Execute {\n        contract_addr: reward_contract.to_string(),\n        msg: to_binary(&DecreaseBalance {\n            address: valid_owner.to_string(),\n            amount,\n        })\n        .unwrap(),\n        funds: vec![],\n    })];\n    Ok(Response::new()\n        .add_messages(messages)\n        .add_attributes(res.attributes))\n}\n\npub fn execute_send_from(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    owner: String,\n    contract: String,\n    amount: Uint128,\n    msg: Binary,\n) -> Result<Response, ContractError> {\n    let reward_contract = query_reward_contract(&deps)?;\n\n    let valid_owner = deps.api.addr_validate(owner.as_str())?;\n\n    let res: Response = cw20_send_from(deps, env, info, owner, contract.clone(), amount, msg)?;\n    let messages = vec![\n        vec![\n            SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: reward_contract.to_string(),\n                msg: to_binary(&DecreaseBalance {\n                    address: valid_owner.to_string(),\n                    amount,\n                })\n                .unwrap(),\n                funds: vec![],\n            })),\n            SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: reward_contract.to_string(),\n                msg: to_binary(&IncreaseBalance {\n                    address: contract,\n                    amount,\n                })\n                .unwrap(),\n                funds: vec![],\n            })),\n        ],\n        res.messages,\n    ]\n    .concat();\n\n    Ok(Response::new()\n        .add_submessages(messages)\n        .add_attributes(res.attributes))\n}"
    },
    {
      "filename": "contracts/anchor-bAsset-contracts/contracts/anchor_basset_reward/src/user.rs",
      "content": "use crate::querier::query_token_contract;\nuse crate::state::{\n    read_config, read_holder, read_holders, read_state, store_holder, store_state, Config, Holder,\n    State,\n};\nuse basset::reward::{AccruedRewardsResponse, HolderResponse, HoldersResponse};\n\nuse cosmwasm_std::{\n    attr, BankMsg, Coin, CosmosMsg, Decimal, Deps, DepsMut, Env, MessageInfo, Response, StdError,\n    StdResult, Uint128,\n};\n\nuse crate::math::{\n    decimal_multiplication_in_256, decimal_subtraction_in_256, decimal_summation_in_256,\n};\nuse basset::deduct_tax;\nuse std::str::FromStr;\nuse terra_cosmwasm::TerraMsgWrapper;\n\npub fn execute_claim_rewards(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    recipient: Option<String>,\n) -> StdResult<Response<TerraMsgWrapper>> {\n    let holder_addr = info.sender;\n    let holder_addr_raw = deps.api.addr_canonicalize(holder_addr.as_str())?;\n    let recipient = match recipient {\n        Some(value) => deps.api.addr_validate(value.as_str()).unwrap(),\n        None => holder_addr.clone(),\n    };\n\n    let mut holder: Holder = read_holder(deps.storage, &holder_addr_raw)?;\n    let mut state: State = read_state(deps.storage)?;\n    let config: Config = read_config(deps.storage)?;\n\n    let reward_with_decimals =\n        calculate_decimal_rewards(state.global_index, holder.index, holder.balance)?;\n\n    let all_reward_with_decimals =\n        decimal_summation_in_256(reward_with_decimals, holder.pending_rewards);\n    let decimals = get_decimals(all_reward_with_decimals)?;\n\n    let rewards = all_reward_with_decimals * Uint128::new(1);\n\n    if rewards.is_zero() {\n        return Err(StdError::generic_err(\"No rewards have accrued yet\"));\n    }\n\n    let new_balance = (state.prev_reward_balance.checked_sub(rewards))?;\n    state.prev_reward_balance = new_balance;\n    store_state(deps.storage, &state)?;\n\n    holder.pending_rewards = decimals;\n    holder.index = state.global_index;\n    store_holder(deps.storage, &holder_addr_raw, &holder)?;\n\n    let bank_msg: CosmosMsg<TerraMsgWrapper> = CosmosMsg::Bank(BankMsg::Send {\n        to_address: recipient.to_string(),\n        amount: vec![deduct_tax(\n            &deps.querier,\n            Coin {\n                denom: config.reward_denom,\n                amount: rewards,\n            },\n        )?],\n    });\n\n    let res = Response::new()\n        .add_attributes(vec![\n            attr(\"action\", \"claim_reward\"),\n            attr(\"holder_address\", holder_addr),\n            attr(\"rewards\", rewards),\n        ])\n        .add_message(bank_msg);\n\n    Ok(res)\n}\n\npub fn execute_increase_balance(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    address: String,\n    amount: Uint128,\n) -> StdResult<Response<TerraMsgWrapper>> {\n    let config = read_config(deps.storage)?;\n    let owner_human = deps.api.addr_humanize(&config.hub_contract)?;\n    let address_raw = deps.api.addr_canonicalize(&address)?;\n    let sender = info.sender;\n\n    let token_address = deps\n        .api\n        .addr_humanize(&query_token_contract(deps.as_ref(), owner_human)?)?;\n\n    // Check sender is token contract\n    if sender != token_address {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    let mut state: State = read_state(deps.storage)?;\n    let mut holder: Holder = read_holder(deps.storage, &address_raw)?;\n\n    // get decimals\n    let rewards = calculate_decimal_rewards(state.global_index, holder.index, holder.balance)?;\n\n    holder.index = state.global_index;\n    holder.pending_rewards = decimal_summation_in_256(rewards, holder.pending_rewards);\n    holder.balance += amount;\n    state.total_balance += amount;\n\n    store_holder(deps.storage, &address_raw, &holder)?;\n    store_state(deps.storage, &state)?;\n\n    let attributes = vec![\n        attr(\"action\", \"increase_balance\"),\n        attr(\"holder_address\", address),\n        attr(\"amount\", amount),\n    ];\n\n    let res = Response::new().add_attributes(attributes);\n    Ok(res)\n}\n\npub fn execute_decrease_balance(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    address: String,\n    amount: Uint128,\n) -> StdResult<Response<TerraMsgWrapper>> {\n    let config = read_config(deps.storage)?;\n    let hub_contract = deps.api.addr_humanize(&config.hub_contract)?;\n    let address_raw = deps.api.addr_canonicalize(&address)?;\n\n    // Check sender is token contract\n    if query_token_contract(deps.as_ref(), hub_contract)?\n        != deps.api.addr_canonicalize(info.sender.as_str())?\n    {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    let mut state: State = read_state(deps.storage)?;\n    let mut holder: Holder = read_holder(deps.storage, &address_raw)?;\n    if holder.balance < amount {\n        return Err(StdError::generic_err(format!(\n            \"Decrease amount cannot exceed user balance: {}\",\n            holder.balance\n        )));\n    }\n\n    let rewards = calculate_decimal_rewards(state.global_index, holder.index, holder.balance)?;\n\n    holder.index = state.global_index;\n    holder.pending_rewards = decimal_summation_in_256(rewards, holder.pending_rewards);\n    holder.balance = (holder.balance.checked_sub(amount))?;\n    state.total_balance = (state.total_balance.checked_sub(amount))?;\n\n    store_holder(deps.storage, &address_raw, &holder)?;\n    store_state(deps.storage, &state)?;\n\n    let attributes = vec![\n        attr(\"action\", \"decrease_balance\"),\n        attr(\"holder_address\", address),\n        attr(\"amount\", amount),\n    ];\n\n    let res = Response::new().add_attributes(attributes);\n\n    Ok(res)\n}\n\npub fn query_accrued_rewards(deps: Deps, address: String) -> StdResult<AccruedRewardsResponse> {\n    let global_index = read_state(deps.storage)?.global_index;\n\n    let holder: Holder = read_holder(deps.storage, &deps.api.addr_canonicalize(&address)?)?;\n    let reward_with_decimals =\n        calculate_decimal_rewards(global_index, holder.index, holder.balance)?;\n    let all_reward_with_decimals =\n        decimal_summation_in_256(reward_with_decimals, holder.pending_rewards);\n\n    let rewards = all_reward_with_decimals * Uint128::new(1);\n\n    Ok(AccruedRewardsResponse { rewards })\n}\n\npub fn query_holder(deps: Deps, address: String) -> StdResult<HolderResponse> {\n    let holder: Holder = read_holder(deps.storage, &deps.api.addr_canonicalize(&address)?)?;\n    Ok(HolderResponse {\n        address,\n        balance: holder.balance,\n        index: holder.index,\n        pending_rewards: holder.pending_rewards,\n    })\n}\n\npub fn query_holders(\n    deps: Deps,\n    start_after: Option<String>,\n    limit: Option<u32>,\n) -> StdResult<HoldersResponse> {\n    let start_after = if let Some(start_after) = start_after {\n        Some(deps.api.addr_validate(&start_after)?)\n    } else {\n        None\n    };\n\n    let holders: Vec<HolderResponse> = read_holders(deps, start_after, limit)?;\n\n    Ok(HoldersResponse { holders })\n}\n\n// calculate the reward based on the sender's index and the global index.\nfn calculate_decimal_rewards(\n    global_index: Decimal,\n    user_index: Decimal,\n    user_balance: Uint128,\n) -> StdResult<Decimal> {\n    let decimal_balance = Decimal::from_ratio(user_balance, Uint128::new(1));\n    Ok(decimal_multiplication_in_256(\n        decimal_subtraction_in_256(global_index, user_index),\n        decimal_balance,\n    ))\n}\n\n// calculate the reward with decimal\nfn get_decimals(value: Decimal) -> StdResult<Decimal> {\n    let stringed: &str = &*value.to_string();\n    let parts: &[&str] = &*stringed.split('.').collect::<Vec<&str>>();\n    match parts.len() {\n        1 => Ok(Decimal::zero()),\n        2 => {\n            let decimals = Decimal::from_str(&*(\"0.\".to_owned() + parts[1]))?;\n            Ok(decimals)\n        }\n        _ => Err(StdError::generic_err(\"Unexpected number of dots\")),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    pub fn proper_calculate_rewards() {\n        let global_index = Decimal::from_ratio(Uint128::new(9), Uint128::new(100));\n        let user_index = Decimal::zero();\n        let user_balance = Uint128::new(1000);\n        let reward = calculate_decimal_rewards(global_index, user_index, user_balance).unwrap();\n        assert_eq!(reward.to_string(), \"90\");\n    }\n\n    #[test]\n    pub fn proper_get_decimals() {\n        let global_index = Decimal::from_ratio(Uint128::new(9999999), Uint128::new(100000000));\n        let user_index = Decimal::zero();\n        let user_balance = Uint128::new(10);\n        let reward = get_decimals(\n            calculate_decimal_rewards(global_index, user_index, user_balance).unwrap(),\n        )\n        .unwrap();\n        assert_eq!(reward.to_string(), \"0.9999999\");\n    }\n}"
    },
    {
      "filename": "contracts/anchor-bAsset-contracts/contracts/anchor_basset_hub/src/contract.rs",
      "content": "#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\nuse cosmwasm_std::{\n    attr, from_binary, to_binary, Addr, Binary, CosmosMsg, Decimal, Deps, DepsMut, DistributionMsg,\n    Env, MessageInfo, QueryRequest, Response, StakingMsg, StdError, StdResult, SubMsg, Uint128,\n    WasmMsg, WasmQuery,\n};\n\nuse crate::config::{\n    execute_deregister_validator, execute_register_validator, execute_update_config,\n    execute_update_params,\n};\n\nuse crate::state::{\n    all_unbond_history, get_unbond_requests, query_get_finished_amount, read_valid_validators,\n    CurrentBatch, Parameters, CONFIG, CURRENT_BATCH, PARAMETERS, STATE,\n};\nuse crate::unbond::{execute_unbond, execute_withdraw_unbonded};\n\nuse crate::bond::execute_bond;\nuse basset::hub::ExecuteMsg::SwapHook;\nuse basset::hub::{\n    AllHistoryResponse, Config, ConfigResponse, CurrentBatchResponse, Cw20HookMsg, ExecuteMsg,\n    InstantiateMsg, QueryMsg, State, StateResponse, UnbondRequestsResponse,\n    WhitelistedValidatorsResponse, WithdrawableUnbondedResponse,\n};\nuse basset::reward::ExecuteMsg::{SwapToRewardDenom, UpdateGlobalIndex};\nuse cw20::{BalanceResponse, Cw20ExecuteMsg, Cw20QueryMsg, Cw20ReceiveMsg, TokenInfoResponse};\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: InstantiateMsg,\n) -> StdResult<Response> {\n    let sender = info.sender.clone();\n    let _sndr_raw = deps.api.addr_canonicalize(sender.as_str())?;\n\n    let payment = info\n        .funds\n        .iter()\n        .find(|x| x.denom == msg.underlying_coin_denom && x.amount > Uint128::zero())\n        .ok_or_else(|| {\n            StdError::generic_err(format!(\"No {} assets are provided to bond\", \"uluna\"))\n        })?;\n\n    // store config\n    let data = Config {\n        creator: deps.api.addr_canonicalize(info.sender.as_str())?,\n        reward_contract: None,\n        token_contract: None,\n        airdrop_registry_contract: None,\n    };\n    CONFIG.save(deps.storage, &data)?;\n\n    // store state\n    let state = State {\n        exchange_rate: Decimal::one(),\n        last_index_modification: env.block.time.seconds(),\n        last_unbonded_time: env.block.time.seconds(),\n        last_processed_batch: 0u64,\n        total_bond_amount: payment.amount,\n        ..Default::default()\n    };\n\n    STATE.save(deps.storage, &state)?;\n\n    // instantiate parameters\n    let params = Parameters {\n        epoch_period: msg.epoch_period,\n        underlying_coin_denom: msg.underlying_coin_denom,\n        unbonding_period: msg.unbonding_period,\n        peg_recovery_fee: msg.peg_recovery_fee,\n        er_threshold: msg.er_threshold,\n        reward_denom: msg.reward_denom,\n    };\n\n    PARAMETERS.save(deps.storage, &params)?;\n\n    let batch = CurrentBatch {\n        id: 1,\n        requested_with_fee: Default::default(),\n    };\n    CURRENT_BATCH.save(deps.storage, &batch)?;\n\n    let mut messages = vec![];\n\n    // register the given validator\n    let register_validator = ExecuteMsg::RegisterValidator {\n        validator: msg.validator.clone(),\n    };\n    messages.push(SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n        contract_addr: env.contract.address.to_string(),\n        msg: to_binary(&register_validator).unwrap(),\n        funds: vec![],\n    })));\n\n    // send the delegate message\n    messages.push(SubMsg::new(CosmosMsg::Staking(StakingMsg::Delegate {\n        validator: msg.validator.to_string(),\n        amount: payment.clone(),\n    })));\n\n    Ok(Response::new()\n        .add_submessages(messages)\n        .add_attributes(vec![\n            attr(\"register-validator\", msg.validator),\n            attr(\"bond\", payment.amount),\n        ]))\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg) -> StdResult<Response> {\n    match msg {"
    }
  ]
}