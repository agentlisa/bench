{
  "Title": "[M-17] The tokenURI method does not check if the NFT has been minted and returns data for the contract that may be a fake NFT",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/Factory.sol#L161\nhttps://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/PrivatePoolMetadata.sol#L17\n\n\n# Vulnerability details\n\n## Impact\n\n- By invoking the [Factory.tokenURI](https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/Factory.sol#L161) method for a maliciously provided NFT id, the returned data may deceive potential users, as the method will return data for a non-existent NFT id that appears to be a genuine PrivatePool. This can lead to a poor user experience or financial loss for users.\n- Violation of the [ERC721-Metadata part](https://eips.ethereum.org/EIPS/eip-721) standard\n\n## Proof of Concept\n\n- The [Factory.tokenURI](https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/Factory.sol#L161) and [PrivatePoolMetadata.tokenURI](https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/PrivatePoolMetadata.sol#L17) methods lack any requirements stating that the provided NFT id must be created. We can also see that in the standard implementation by [OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cf86fd9962701396457e50ab0d6cc78aa29a5ebc/contracts/token/ERC721/ERC721.sol#L94), this check is present:\n- [Throws if `_tokenId` is not a valid NFT](https://eips.ethereum.org/EIPS/eip-721)\n\n### Example\n\n1. User creates a fake contract\n   A simple example so that the `tokenURI` method does not revert:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ncontract NFT {\n    function balanceOf(address) external pure returns (uint256) {\n        1;\n    }\n}\n\ncontract NonNFT {\n    address public immutable nft;\n\n    address public constant baseToken = address(0);\n    uint256 public constant virtualBaseTokenReserves = 1 ether;\n    uint256 public constant virtualNftReserves = 1 ether;\n    uint256 public constant feeRate = 500;\n\n    constructor() {\n        nft = address(new NFT());\n    }\n}\n```\n\n2. User deploy the contract\n3. Now, by using `tokenURI()` for the deployed user's address, one can fetch information about a non-existent NFT.\n\n## Tools Used\n\n- Manual review\n- Foundry\n\n## Recommended Mitigation Steps\n\n- Throw an error if the NFT id is invalid.\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-04-caviar-private-pools",
  "Code": [
    {
      "filename": "src/Factory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/*\n *\n *       __________...----..____..-'``-..___\n *     ,'.                                  ```--.._\n *    :                                             ``._\n *    |                           --                    ``.\n *    |                 -0-           -.     -   -.        `.\n *    :                     __           --            .     \\\n *     `._____________     (  `.   -.-      --  -   .   `     \\\n *        `-----------------\\   \\_.--------..__..--.._ `. `.   :\n *                           `--'                     `-._ .   |\n *                                                        `.`  |\n *                                                          \\` |\n *                                                           \\ |\n *                                                           / \\`.\n *                                                          /  _\\-'\n *                                                         /_,'\n */\n\nimport {LibClone} from \"solady/utils/LibClone.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n\nimport {PrivatePool} from \"./PrivatePool.sol\";\nimport {PrivatePoolMetadata} from \"./PrivatePoolMetadata.sol\";\n\n/// @title Caviar Private Pool Factory\n/// @author out.eth (@outdoteth)\n/// @notice This contract is used to create and initialize new private pools. Each time a private pool is created, a new\n/// NFT representing that private pool is minted to the creator. All protocol fees also accrue to this contract and can\n/// be withdrawn by the admin.\ncontract Factory is ERC721, Owned {\n    using LibClone for address;\n    using SafeTransferLib for address;\n\n    event Create(address indexed privatePool, uint256[] tokenIds, uint256 baseTokenAmount);\n    event Withdraw(address indexed token, uint256 indexed amount);\n\n    /// @notice The address of the private pool implementation that proxies point to.\n    address public privatePoolImplementation;\n\n    /// @notice Helper contract that constructs the private pool metadata svg and json for each pool NFT.\n    address public privatePoolMetadata;\n\n    /// @notice The protocol fee that is taken on each buy/sell/change. It's in basis points: 350 = 3.5%.\n    uint16 public protocolFeeRate;\n\n    constructor() ERC721(\"Caviar Private Pools\", \"POOL\") Owned(msg.sender) {}\n\n    receive() external payable {}\n\n    /// @notice Creates a new private pool using the minimal proxy pattern that points to the private pool\n    /// implementation. The caller must approve the factory to transfer the NFTs that will be deposited to the pool.\n    /// @param _baseToken The address of the base token.\n    /// @param _nft The address of the NFT.\n    /// @param _virtualBaseTokenReserves The virtual base token reserves.\n    /// @param _virtualNftReserves The virtual NFT reserves.\n    /// @param _changeFee The change fee.\n    /// @param _feeRate The fee rate.\n    /// @param _merkleRoot The merkle root.\n    /// @param _useStolenNftOracle Whether to use the stolen NFT oracle.\n    /// @param _salt The salt that will used on deployment.\n    /// @param tokenIds The token ids to deposit to the pool.\n    /// @param baseTokenAmount The amount of base tokens to deposit to the pool.\n    /// @return privatePool The address of the private pool.\n    function create(\n        address _baseToken,\n        address _nft,\n        uint128 _virtualBaseTokenReserves,\n        uint128 _virtualNftReserves,\n        uint56 _changeFee,\n        uint16 _feeRate,\n        bytes32 _merkleRoot,\n        bool _useStolenNftOracle,\n        bool _payRoyalties,\n        bytes32 _salt,\n        uint256[] memory tokenIds, // put in memory to avoid stack too deep error\n        uint256 baseTokenAmount\n    ) public payable returns (PrivatePool privatePool) {\n        // check that the msg.value is equal to the base token amount if the base token is ETH or the msg.value is equal\n        // to zero if the base token is not ETH\n        if ((_baseToken == address(0) && msg.value != baseTokenAmount) || (_baseToken != address(0) && msg.value > 0)) {\n            revert PrivatePool.InvalidEthAmount();\n        }\n\n        // deploy a minimal proxy clone of the private pool implementation\n        privatePool = PrivatePool(payable(privatePoolImplementation.cloneDeterministic(_salt)));\n\n        // mint the nft to the caller\n        _safeMint(msg.sender, uint256(uint160(address(privatePool))));\n\n        // initialize the pool\n        privatePool.initialize(\n            _baseToken,\n            _nft,\n            _virtualBaseTokenReserves,\n            _virtualNftReserves,\n            _changeFee,\n            _feeRate,\n            _merkleRoot,\n            _useStolenNftOracle,\n            _payRoyalties\n        );\n\n        if (_baseToken == address(0)) {\n            // transfer eth into the pool if base token is ETH\n            address(privatePool).safeTransferETH(baseTokenAmount);\n        } else {\n            // deposit the base tokens from the caller into the pool\n            ERC20(_baseToken).transferFrom(msg.sender, address(privatePool), baseTokenAmount);\n        }\n\n        // deposit the nfts from the caller into the pool\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ERC721(_nft).safeTransferFrom(msg.sender, address(privatePool), tokenIds[i]);\n        }\n\n        // emit create event\n        emit Create(address(privatePool), tokenIds, baseTokenAmount);\n    }\n\n    /// @notice Sets private pool metadata contract.\n    /// @param _privatePoolMetadata The private pool metadata contract.\n    function setPrivatePoolMetadata(address _privatePoolMetadata) public onlyOwner {\n        privatePoolMetadata = _privatePoolMetadata;\n    }\n\n    /// @notice Sets the private pool implementation contract that newly deployed proxies point to.\n    /// @param _privatePoolImplementation The private pool implementation contract.\n    function setPrivatePoolImplementation(address _privatePoolImplementation) public onlyOwner {\n        privatePoolImplementation = _privatePoolImplementation;\n    }\n\n    /// @notice Sets the protocol fee that is taken on each buy/sell/change. It's in basis points: 350 = 3.5%.\n    /// @param _protocolFeeRate The protocol fee.\n    function setProtocolFeeRate(uint16 _protocolFeeRate) public onlyOwner {\n        protocolFeeRate = _protocolFeeRate;\n    }\n\n    /// @notice Withdraws the earned protocol fees.\n    /// @param token The token to withdraw.\n    /// @param amount The amount to withdraw.\n    function withdraw(address token, uint256 amount) public onlyOwner {\n        if (token == address(0)) {\n            msg.sender.safeTransferETH(amount);\n        } else {\n            ERC20(token).transfer(msg.sender, amount);\n        }\n\n        emit Withdraw(token, amount);\n    }\n\n    /// @notice Returns the token URI for a given token id.\n    /// @param id The token id.\n    /// @return uri The token URI.\n    function tokenURI(uint256 id) public view override returns (string memory) {\n        return PrivatePoolMetadata(privatePoolMetadata).tokenURI(id);\n    }\n\n    /// @notice Predicts the deployment address of a new private pool.\n    /// @param salt The salt that will used on deployment.\n    /// @return predictedAddress The predicted deployment address of the private pool.\n    function predictPoolDeploymentAddress(bytes32 salt) public view returns (address predictedAddress) {\n        predictedAddress = privatePoolImplementation.predictDeterministicAddress(salt, address(this));\n    }\n}"
    },
    {
      "filename": "src/PrivatePoolMetadata.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {Strings} from \"openzeppelin/utils/Strings.sol\";\nimport {Base64} from \"openzeppelin/utils/Base64.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\n\nimport {PrivatePool} from \"./PrivatePool.sol\";\n\n/// @title Private Pool Metadata\n/// @author out.eth (@outdoteth)\n/// @notice This contract is used to generate NFT metadata for private pools.\ncontract PrivatePoolMetadata {\n    /// @notice Returns the tokenURI for a pool with it's metadata.\n    /// @param tokenId The private pool's token ID.\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\n        // forgefmt: disable-next-item\n        bytes memory metadata = abi.encodePacked(\n            \"{\",\n                '\"name\": \"Private Pool ',Strings.toString(tokenId),'\",',\n                '\"description\": \"Caviar private pool AMM position.\",',\n                '\"image\": ','\"data:image/svg+xml;base64,', Base64.encode(svg(tokenId)),'\",',\n                '\"attributes\": [',\n                    attributes(tokenId),\n                \"]\",\n            \"}\"\n        );\n\n        return string(abi.encodePacked(\"data:application/json;base64,\", Base64.encode(metadata)));\n    }\n\n    /// @notice Returns the attributes for a pool encoded as json.\n    /// @param tokenId The private pool's token ID.\n    function attributes(uint256 tokenId) public view returns (string memory) {\n        PrivatePool privatePool = PrivatePool(payable(address(uint160(tokenId))));\n\n        // forgefmt: disable-next-item\n        bytes memory _attributes = abi.encodePacked(\n            trait(\"Pool address\", Strings.toHexString(address(privatePool))), ',',\n            trait(\"Base token\", Strings.toHexString(privatePool.baseToken())), ',',\n            trait(\"NFT\", Strings.toHexString(privatePool.nft())), ',',\n            trait(\"Virtual base token reserves\",Strings.toString(privatePool.virtualBaseTokenReserves())), ',',\n            trait(\"Virtual NFT reserves\", Strings.toString(privatePool.virtualNftReserves())), ',',\n            trait(\"Fee rate (bps): \", Strings.toString(privatePool.feeRate())), ',',\n            trait(\"NFT balance\", Strings.toString(ERC721(privatePool.nft()).balanceOf(address(privatePool)))), ',',\n            trait(\"Base token balance\",  Strings.toString(privatePool.baseToken() == address(0) ? address(privatePool).balance : ERC20(privatePool.baseToken()).balanceOf(address(privatePool))))\n        );\n\n        return string(_attributes);\n    }\n\n    /// @notice Returns an svg image for a pool.\n    /// @param tokenId The private pool's token ID.\n    function svg(uint256 tokenId) public view returns (bytes memory) {\n        PrivatePool privatePool = PrivatePool(payable(address(uint160(tokenId))));\n\n        // break up svg building into multiple scopes to avoid stack too deep errors\n        bytes memory _svg;\n        {\n            // forgefmt: disable-next-item\n            _svg = abi.encodePacked(\n                '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 400 400\" style=\"width:100%;background:black;fill:white;font-family:serif;\">',\n                    '<text x=\"24px\" y=\"24px\" font-size=\"12\">',\n                        \"Caviar AMM private pool position\",\n                    \"</text>\",\n                    '<text x=\"24px\" y=\"48px\" font-size=\"12\">',\n                        \"Private pool: \", Strings.toHexString(address(privatePool)),\n                    \"</text>\",\n                    '<text x=\"24px\" y=\"72px\" font-size=\"12\">',\n                        \"Base token: \", Strings.toHexString(privatePool.baseToken()),\n                    \"</text>\",\n                    '<text x=\"24px\" y=\"96px\" font-size=\"12\">',\n                        \"NFT: \", Strings.toHexString(privatePool.nft()),\n                    \"</text>\"\n            );\n        }\n\n        {\n            // forgefmt: disable-next-item\n            _svg = abi.encodePacked(\n                _svg,\n                '<text x=\"24px\" y=\"120px\" font-size=\"12\">',\n                    \"Virtual base token reserves: \", Strings.toString(privatePool.virtualBaseTokenReserves()),\n                \"</text>\",\n                '<text x=\"24px\" y=\"144px\" font-size=\"12\">',\n                    \"Virtual NFT reserves: \", Strings.toString(privatePool.virtualNftReserves()),\n                \"</text>\",\n                '<text x=\"24px\" y=\"168px\" font-size=\"12\">',\n                    \"Fee rate (bps): \", Strings.toString(privatePool.feeRate()),\n                \"</text>\"\n            );\n        }\n\n        {\n            // forgefmt: disable-next-item\n            _svg = abi.encodePacked(\n                _svg, \n                    '<text x=\"24px\" y=\"192px\" font-size=\"12\">',\n                        \"NFT balance: \", Strings.toString(ERC721(privatePool.nft()).balanceOf(address(privatePool))),\n                    \"</text>\",\n                    '<text x=\"24px\" y=\"216px\" font-size=\"12\">',\n                        \"Base token balance: \", Strings.toString(privatePool.baseToken() == address(0) ? address(privatePool).balance : ERC20(privatePool.baseToken()).balanceOf(address(privatePool))),\n                    \"</text>\",\n                \"</svg>\"\n            );\n        }\n\n        return _svg;\n    }\n\n    function trait(string memory traitType, string memory value) internal pure returns (string memory) {\n        // forgefmt: disable-next-item\n        return string(\n            abi.encodePacked(\n                '{ \"trait_type\": \"', traitType, '\",', '\"value\": \"', value, '\" }'\n            )\n        );\n    }\n}"
    }
  ]
}