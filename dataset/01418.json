{
  "Title": "M-6: `previewRedeem` and `redeem` functions deviate from the ERC4626 specification",
  "Content": "# Issue M-6: `previewRedeem` and `redeem` functions deviate from the ERC4626 specification \n\nSource: https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/577 \n\n## Found by \n0x73696d616f, 0xSurena, BPZ, BTK, Flora, Kalyan-Singh, Nadin, bin2chen, enfrasico, shaka, talfao, xiaoming90\n\nThe `previewRedeem` and `redeem` functions deviate from the ERC4626 specification. As a result, the caller (internal or external) of the `previewRedeem` function might receive incorrect information, leading to the wrong decision being executed.\n\n## Vulnerability Detail\n\n> **Important**\n> The [contest page](https://github.com/sherlock-audit/2023-06-tokemak-xiaoming9090/tree/main#q-is-the-codecontract-expected-to-comply-with-any-eips-are-there-specific-assumptions-around-adhering-to-those-eips-that-watsons-should-be-aware-of) explicitly mentioned that the `LMPVault` must conform with the ERC4626. Thus, issues related to EIP compliance should be considered valid in the context of this audit.\n>\n> **Q: Is the code/contract expected to comply with any EIPs? Are there specific assumptions around adhering to those EIPs that Watsons should be aware of?**\n>\n> src/vault/LMPVault.sol should be 4626 compatible\n\nLet the value returned by `previewRedeem` function be $asset_{preview}$ and the actual number of assets obtained from calling the `redeem` function be $asset_{actual}$. \n\nThe following specification of `previewRedeem` function is taken from [ERC4626 specification](https://eips.ethereum.org/EIPS/eip-4626):\n\n> Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block, given current on-chain conditions.\n>\n> MUST return as close to and no more than the exact amount of assets that would be withdrawn in a `redeem` call in the same transaction. I.e. `redeem` should return the same or more `assets` as `previewRedeem` if called in the same transaction.\n\nIt mentioned that the `redeem` should return the same or more `assets` as `previewRedeem` if called in the same transaction, which means that it must always be $asset_{preview} \\le asset_{actual}$.\n\nHowever, it is possible that the `redeem` function might return fewer assets than the number of assets previewed by the `previewRedeem` ($asset_{preview} > asset_{actual}$), thus it does not conform to the specification.\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/vault/LMPVault.sol#L422\n\n```solidity\nFile: LMPVault.sol\n422:     function redeem(\n423:         uint256 shares,\n424:         address receiver,\n425:         address owner\n426:     ) public virtual override nonReentrant noNavDecrease ensureNoNavOps returns (uint256 assets) {\n427:         uint256 maxShares = maxRedeem(owner);\n428:         if (shares > maxShares) {\n429:             revert ERC4626ExceededMaxRedeem(owner, shares, maxShares);\n430:         }\n431:         uint256 possibleAssets = previewRedeem(shares); // @audit-info  round down, which is correct because user won't get too many\n432: \n433:         assets = _withdraw(possibleAssets, shares, receiver, owner);\n434:     }\n```\n\nNote that the `previewRedeem` function performs its computation based on the cached `totalDebt` and `totalIdle`, which might not have been updated to reflect the actual on-chain market condition. Thus, these cached values might be higher than expected.\n\nAssume that `totalIdle` is zero and all WETH has been invested in the destination vaults. Thus, `totalAssetsToPull` will be set to $asset_{preview}$.\n\nIf a DV is making a loss, users could only burn an amount proportional to their ownership of this vault. The code will go through all the DVs in the withdrawal queue (`withdrawalQueueLength`) in an attempt to withdraw as many assets as possible. However, it is possible that the `totalAssetsPulled` to be less than  $asset_{preview}$.\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/vault/LMPVault.sol#L448\n\n```solidity\nFile: LMPVault.sol\n448:     function _withdraw(\n449:         uint256 assets,\n450:         uint256 shares,\n451:         address receiver,\n452:         address owner\n453:     ) internal virtual returns (uint256) {\n454:         uint256 idle = totalIdle;\n455:         WithdrawInfo memory info = WithdrawInfo({\n456:             currentIdle: idle,\n457:             assetsFromIdle: assets >= idle ? idle : assets,\n458:             totalAssetsToPull: assets - (assets >= idle ? idle : assets),\n459:             totalAssetsPulled: 0,\n460:             idleIncrease: 0,\n461:             debtDecrease: 0\n462:         });\n463: \n464:         // If not enough funds in idle, then pull what we need from destinations\n465:         if (info.totalAssetsToPull > 0) {\n466:             uint256 totalVaultShares = totalSupply();\n467: \n468:             // Using pre-set withdrawalQueue for withdrawal order to help minimize user gas\n469:             uint256 withdrawalQueueLength = withdrawalQueue.length;\n470:             for (uint256 i = 0; i < withdrawalQueueLength; ++i) {\n471:                 IDestinationVault destVault = IDestinationVault(withdrawalQueue[i]);\n472:                 (uint256 sharesToBurn, uint256 totalDebtBurn) = _calcUserWithdrawSharesToBurn(\n473:                     destVault,\n474:                     shares,\n475:                     info.totalAssetsToPull - Math.max(info.debtDecrease, info.totalAssetsPulled),\n476:                     totalVaultShares\n477:                 );\n..SNIP..\n508:         // At this point should have all the funds we need sitting in in the vault\n509:         uint256 returnedAssets = info.assetsFromIdle + info.totalAssetsPulled;\n```\n\n## Impact\n\nIt was understood from the protocol team that they anticipate external parties to integrate directly with the LMPVault (e.g., vault shares as collateral). Thus, the LMPVault must be ERC4626 compliance. Otherwise, the caller (internal or external) of the `previewRedeem` function might receive incorrect information, leading to the wrong action being executed.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/vault/LMPVault.sol#L422\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nEnsure that  $asset_{preview} \\le asset_{actual}$. \n\nAlternatively, document that the `previewRedeem` and `redeem` functions deviate from the ERC4626 specification in the comments and/or documentation.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**Trumpero** commented:\n> low, not following ERC4626 won't incur risk for the users and protocol \n> To make sure the assetPreview <= assetActual, users (integrated protocol) should use router to redeem \n\n\n\n**xiaoming9090**\n\nEscalate\n\nI have confirmed with the protocol team that they anticipate external parties integrating directly with the LMPVault (e.g., vault shares as collateral), as shown below. The router is not applicable in the context of this issue, as ERC4626 is strictly applied to the LMPVault only.\n\n![image](https://github.com/sherlock-audit/2023-06-tokemak-judging/assets/102820284/5af2dcc3-cbe2-4ed0-8600-1e8e90d8d691)\n\nPer the judging docs, the issue will be considered as valid if there is external integrations.\n\n> **EIP compliance with no integrations**: If the protocol does not have external integrations then issues related to code not fully complying with the EIP it is implementing and there are no adverse effects of this, is considered informational\n\nAlso, the [contest page](https://github.com/sherlock-audit/2023-06-tokemak-xiaoming9090/tree/main#q-is-the-codecontract-expected-to-comply-with-any-eips-are-there-specific-assumptions-around-adhering-to-those-eips-that-watsons-should-be-aware-of) explicitly mentioned that the `LMPVault` must conform with the ERC4626. Thus, issues related to EIP compliance is considered valid in the context of this audit.\n\n> **Q: Is the code/contract expected to comply with any EIPs? Are there specific assumptions around adhering to those EIPs that Watsons should be aware of?**\n>\n> src/vault/LMPVault.sol should be 4626 compatible\n\nIn this case, non-conforming to ERC4626 is a valid Medium.\n\n\n**sherlock-admin2**\n\n > Escalate\n> \n> I have confirmed with the protocol team that they anticipate external parties integrating directly with the LMPVault (e.g., vault shares as collateral), as shown below. The router is not applicable in the context of this issue, as ERC4626 is strictly applied to the LMPVault only.\n> \n> ![image](https://github.com/sherlock-audit/2023-06-tokemak-judging/assets/102820284/5af2dcc3-cbe2-4ed0-8600-1e8e90d8d691)\n> \n> Per the judging docs, the issue will be considered as valid if there is external integrations.\n> \n> > **EIP compliance with no integrations**: If the protocol does not have external integrations then issues related to code not fully complying with the EIP it is implementing and there are no adverse effects of this, is considered informational\n> \n> Also, the [contest page](https://github.com/sherlock-audit/2023-06-tokemak-xiaoming9090/tree/main#q-is-the-codecontract-expected-to-comply-with-any-eips-are-there-specific-assumptions-around-adhering-to-those-eips-that-watsons-should-be-aware-of) explicitly mentioned that the `LMPVault` must conform with the ERC4626. Thus, issues related to EIP compliance is considered valid in the context of this audit.\n> \n> > **Q: Is the code/contract expected to comply with any EIPs? Are there specific assumptions around adhering to those EIPs that Watsons should be aware of?**\n> >\n> > src/vault/LMPVault.sol should be 4626 compatible\n> \n> In this case, non-conforming to ERC4626 is a valid Medium.\n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**midori-fuse**\n\nEscalate\n\nIf this issue ends up being valid post-escalation, then #452 #441 #319 #288 #202 should be dupes of this. \n\n**sherlock-admin2**\n\n > Escalate\n> \n> If this issue ends up being valid post-escalation, then #452 #441 #319 #288 #202 should be dupes of this. \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**JeffCX**\n\nI thought the EIP complicance issue is valid low in sherlock\n\n**JeffCX**\n\nhttps://docs.sherlock.xyz/audits/judging/judging\n\n> EIP compliance with no integrations: If the protocol does not have external integrations then issues related to code not fully complying with the EIP it is implementing and there are no adverse effects of this, are considered informational\n\n**0xbtk**\n\nIf #577 is considered a medium, then #412 should be a medium too, because as per of the EIP-4626: \n\n> **It is considered most secure to favor the Vault itself during calculations over its users**.\n\n**Kalyan-Singh**\n\n #656 shows how deposit function  reverts under certain conditions due to maxDeposit not being eip compliant, I think that will be a genuine problem for external integrators. I think this escalations result should also be reflected there.\n\n**xiaoming9090**\n\n> I thought the EIP complicance issue is valid low in sherlock\n\nFor this contest, it was explicitly mentioned in the [contest page](https://github.com/sherlock-audit/2023-06-tokemak-xiaoming9090/tree/main#q-is-the-codecontract-expected-to-comply-with-any-eips-are-there-specific-assumptions-around-adhering-to-those-eips-that-watsons-should-be-aware-of)  that the `LMPVault` must conform with the ERC4626. Thus, issues related to EIP compliance is considered valid Medium in the context of this audit.\n\n> **Q: Is the code/contract expected to comply with any EIPs? Are there specific assumptions around adhering to those EIPs that Watsons should be aware of?**\n>\n> src/vault/LMPVault.sol should be 4626 compatible\n\n**xiaoming9090**\n\n> https://docs.sherlock.xyz/audits/judging/judging\n> \n> > EIP compliance with no integrations: If the protocol does not have external integrations then issues related to code not fully complying with the EIP it is implementing and there are no adverse effects of this, are considered informational\n\nI have confirmed with the protocol team that they anticipate external parties integrating directly with the LMPVault (e.g., vault shares as collateral), as shown below. Thus, there are external integrations.\n\n![image](https://github.com/sherlock-audit/2023-06-tokemak-judging/assets/102820284/5af2dcc3-cbe2-4ed0-8600-1e8e90d8d691)\n\n**0xSurena**\n\n> > I thought the EIP complicance issue is valid low in sherlock\n> \n> For this contest, it was explicitly mentioned in the [contest page](https://github.com/sherlock-audit/2023-06-tokemak-xiaoming9090/tree/main#q-is-the-codecontract-expected-to-comply-with-any-eips-are-there-specific-assumptions-around-adhering-to-those-eips-that-watsons-should-be-aware-of) that the `LMPVault` must conform with the ERC4626. Thus, issues related to EIP compliance is considered valid Medium in the context of this audit.\n> \n> > **Q: Is the code/contract expected to comply with any EIPs? Are there specific assumptions around adhering to those EIPs that Watsons should be aware of?**\n> > src/vault/LMPVault.sol should be 4626 compatible\n\nExactly, it was explicitly mentioned in the [contest page](https://github.com/sherlock-audit/2023-06-tokemak-xiaoming9090/tree/main#q-is-the-codecontract-expected-to-comply-with-any-eips-are-there-specific-assumptions-around-adhering-to-those-eips-that-watsons-should-be-aware-of) that code/contract **expected / should** to comply with 4626. \n\n\n@JeffCX\n> https://docs.sherlock.xyz/audits/judging/judging\n> \n> > EIP compliance with no integrations: If the protocol does not have external integrations then issues related to code not fully complying with the EIP it is implementing and there are no adverse effects of this, are considered informational\n\nIn case of conflict between information in the Contest README vs Sherlock rules, **the README overrides Sherlock rules.** \n\n**Trumpero**\n\nI believe this issue is a low/info issue evidently. Judging docs of Sherlock clearly stated that: \n> EIP compliance with no integrations: If the protocol does not have external integrations, then issues related to the code not fully complying with the EIP it is implementing, and there are no adverse effects of this, it is considered informational. \n\nTherefore, it should be an informational issue. \n\nThe issue must cause a loss of funds (even if unlikely) to be considered as medium\n> Medium: There is a viable scenario (even if unlikely) that could cause the protocol to enter a state where a material amount of funds can be lost.\n\nFurthermore, according to Sherlock's judging docs, the external integrations in the future are not considered valid issues:\n> Future issues: Issues that result out of a future integration/implementation that was not intended (mentioned in the docs/README) or because of a future change in the code (as a fix to another issue) are not valid issues.\n\n**Evert0x**\n\nCurrent opinion is to accept escalation and make issue medium because of the following judging rule.\n\n> In case of conflict between information in the README vs Sherlock rules, the README overrides Sherlock rules.\nhttps://docs.sherlock.xyz/audits/judging/judging#iii.-some-standards-observed\n\n\n**Trumpero**\n\nI believe this issue doesn't meet the requirements of a medium issue since it doesn't cause any loss, which is an important requirement to be a valid issue in Sherlock. Even without considering the Sherlock docs about EIP compliance, it only has a low impact, so I don't think it is a valid medium. Historically, the potential risk from a view function has never been accepted as a medium in Sherlock. Additionally, there is no potential loss since users should use the router to redeem, which protects users from any loss by using the minimum redeem amount.\n\n**midori-fuse**\n\n> Historically, the potential risk from a view function has never been accepted as a medium in Sherlock\n\nDisputing this point. [Evidence](https://github.com/sherlock-audit/2022-12-notional-judging/issues/11)\n\n\n\n**xiaoming9090**\n\nThe README explicitly stated that `LMPVault.sol` should be 4626 compatible. README overwrites the Sherlock rules. Thus, any 4626 incompatible in this contest would be classified as Medium.\n\n**Evert0x**\n\nThe core question is, does the README also override the severity classifications? It states that \"Sherlock rules for valid issues\" are overwritten. But it's unclear if the severity definitions are included in this, especially because the medium/high definitions are stated above this rule. \n\nThe intention of this sentence is that the protocol can thrive in the context defined by the protocol team. \n\nIn this case, it's clear that the team states that the `LMPVault.sol` should exist in the context of complete ERC4626 compatibility. Making this issue valid. \n\nPlanning to make some changes to the Medium definition and `Hierarchy of truth` language so it will be clear for future contests. \n\n\n\n\n**Evert0x**\n\nPlanning to accept escalation and duplicate with https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/452 https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/441 https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/319 https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/288 https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/202\n\n\n**Evert0x**\n\nUpdate: planning to add #412 #577 #656 #487 and categorize as a general \"Failing to comply with ERC4626\" issue family.\n\n**Evert0x**\n\nResult:\nMedium \nHas Duplicates\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [xiaoming9090](https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/577/#issuecomment-1748037264): accepted\n- [midori-fuse](https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/577/#issuecomment-1748212019): accepted\n\n**Evert0x**\n\nWill add #665 https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/465, https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/503 and https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/731 as duplicates as they point out an issue that will make the contract fail to comply with ERC4626.\n\nBecause `_maxMint()` has the possibility to return `uint256.max` it can break the ERC4626 specification of `maxDeposit` of \"MUST NOT REVERT\"\n\nSee https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/665#issuecomment-1780762436\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/101",
  "Code": [
    {
      "filename": "v2-core-audit-2023-07-14/src/vault/LMPVault.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\npragma solidity 0.8.17;\n\n// solhint-disable max-states-count\n\nimport { Roles } from \"src/libs/Roles.sol\";\nimport { Errors } from \"src/utils/Errors.sol\";\nimport { LMPDebt } from \"src/vault/libs/LMPDebt.sol\";\nimport { Pausable } from \"src/security/Pausable.sol\";\nimport { VaultTypes } from \"src/vault/VaultTypes.sol\";\nimport { NonReentrant } from \"src/utils/NonReentrant.sol\";\nimport { SystemComponent } from \"src/SystemComponent.sol\";\nimport { LMPStrategy } from \"src/strategy/LMPStrategy.sol\";\nimport { SecurityBase } from \"src/security/SecurityBase.sol\";\nimport { ILMPVault } from \"src/interfaces/vault/ILMPVault.sol\";\nimport { IStrategy } from \"src/interfaces/strategy/IStrategy.sol\";\nimport { Math } from \"openzeppelin-contracts/utils/math/Math.sol\";\nimport { LMPDestinations } from \"src/vault/libs/LMPDestinations.sol\";\nimport { ERC20 } from \"openzeppelin-contracts/token/ERC20/ERC20.sol\";\nimport { IERC4626 } from \"openzeppelin-contracts/interfaces/IERC4626.sol\";\nimport { IMainRewarder } from \"src/interfaces/rewarders/IMainRewarder.sol\";\nimport { IDestinationVault } from \"src/interfaces/vault/IDestinationVault.sol\";\nimport { SafeERC20 } from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Initializable } from \"openzeppelin-contracts/proxy/utils/Initializable.sol\";\nimport { EnumerableSet } from \"openzeppelin-contracts/utils/structs/EnumerableSet.sol\";\nimport { ISystemRegistry, IDestinationVaultRegistry } from \"src/interfaces/ISystemRegistry.sol\";\nimport { ERC20Permit } from \"openzeppelin-contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport { IERC3156FlashBorrower } from \"openzeppelin-contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport { IERC20Metadata as IERC20 } from \"openzeppelin-contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n// Cross functional reentrancy was identified between updateDebtReporting and the\n// destinationInfo. Have nonReentrant and read-only nonReentrant modifier on them both\n// but slither was still complaining\n//slither-disable-start reentrancy-no-eth,reentrancy-benign\n\ncontract LMPVault is\n    SystemComponent,\n    Initializable,\n    ILMPVault,\n    IStrategy,\n    ERC20Permit,\n    SecurityBase,\n    Pausable,\n    NonReentrant\n{\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using Math for uint256;\n    using SafeERC20 for ERC20;\n    using SafeERC20 for IERC20;\n\n    /// @dev In memory struct only for managing vars in _withdraw\n    struct WithdrawInfo {\n        uint256 currentIdle;\n        uint256 assetsFromIdle;\n        uint256 totalAssetsToPull;\n        uint256 totalAssetsPulled;\n        uint256 idleIncrease;\n        uint256 debtDecrease;\n    }\n\n    /// @notice Max fee. 100% == 10000\n    uint256 public constant MAX_FEE_BPS = 10_000;\n\n    uint256 public constant NAV_CHANGE_ROUNDING_BUFFER = 100;\n\n    /// @notice Factory contract that created this vault\n    address public factory;\n\n    /// @notice Overarching baseAsset type\n    bytes32 public immutable vaultType = VaultTypes.LST;\n\n    /// @dev The asset that is deposited into the vault\n    IERC20 internal immutable _baseAsset;\n\n    /// @notice Decimals of the base asset. Used as the decimals for the vault itself\n    uint8 internal immutable _baseAssetDecimals;\n\n    /// @dev Full list of possible destinations that could be deployed to\n    EnumerableSet.AddressSet internal destinations;\n\n    /// @dev Destinations that queued for removal\n    EnumerableSet.AddressSet internal removalQueue;\n\n    /// @dev destinationVaultAddress -> Info .. Debt reporting snapshot info\n    mapping(address => LMPDebt.DestinationInfo) internal destinationInfo;\n\n    /// @dev whether or not the vault has been shutdown\n    bool internal _shutdown;\n\n    /// @notice The amount of baseAsset deposited into the contract pending deployment\n    uint256 public totalIdle = 0;\n\n    /// @notice The current (though cached) value of assets we've deployed\n    uint256 public totalDebt = 0;\n\n    /// @notice The destinations, in order, in which withdrawals will be attempted from\n    IDestinationVault[] public withdrawalQueue;\n\n    /// @notice Main rewarder for this contract\n    IMainRewarder public rewarder;\n\n    /// @notice Current performance fee taken on profit. 100% == 10000\n    uint256 public performanceFeeBps;\n\n    /// @notice Where claimed fees are sent\n    address public feeSink;\n\n    /// @notice The last nav/share height we took fees at\n    uint256 public navPerShareHighMark = MAX_FEE_BPS;\n\n    /// @notice The last timestamp we took fees at\n    uint256 public navPerShareHighMarkTimestamp;\n\n    /// @notice The max total supply of shares we'll allow to be minted\n    uint256 public totalSupplyLimit;\n\n    /// @notice The max shares a single wallet is allowed to hold\n    uint256 public perWalletLimit;\n\n    string private _desc;\n    string private _symbol;\n\n    error TooFewAssets(uint256 requested, uint256 actual);\n    error WithdrawShareCalcInvalid(uint256 currentShares, uint256 cachedShares);\n    error InvalidFee(uint256 newFee);\n    error RewarderAlreadySet();\n    error RebalanceDestinationsMatch(address destinationVault);\n    error InvalidDestination(address destination);\n    error NavChanged(uint256 oldNav, uint256 newNav);\n    error NavOpsInProgress();\n    error OverWalletLimit(address to);\n    error VaultShutdown();\n\n    event PerformanceFeeSet(uint256 newFee);\n    event FeeSinkSet(address newFeeSink);\n    event NewNavHighWatermark(uint256 navPerShare, uint256 timestamp);\n    event TotalSupplyLimitSet(uint256 limit);\n    event PerWalletLimitSet(uint256 limit);\n\n    modifier noNavChange() {\n        (uint256 oldNav, uint256 startingTotalSupply) = _snapStartNav();\n        _;\n        _ensureNoNavChange(oldNav, startingTotalSupply);\n    }\n\n    modifier noNavDecrease() {\n        (uint256 oldNav, uint256 startingTotalSupply) = _snapStartNav();\n        _;\n        _ensureNoNavDecrease(oldNav, startingTotalSupply);\n    }\n\n    modifier ensureNoNavOps() {\n        if (systemRegistry.systemSecurity().navOpsInProgress() > 0) {\n            revert NavOpsInProgress();\n        }\n        _;\n    }\n\n    modifier trackNavOps() {\n        systemRegistry.systemSecurity().enterNavOperation();\n        _;\n        systemRegistry.systemSecurity().exitNavOperation();\n    }\n\n    constructor(\n        ISystemRegistry _systemRegistry,\n        address _vaultAsset\n    )\n        SystemComponent(_systemRegistry)\n        ERC20(\n            string(abi.encodePacked(ERC20(_vaultAsset).name(), \" Pool Token\")),\n            string(abi.encodePacked(\"lmp\", ERC20(_vaultAsset).symbol()))\n        )\n        ERC20Permit(string(abi.encodePacked(\"lmp\", ERC20(_vaultAsset).symbol())))\n        SecurityBase(address(_systemRegistry.accessController()))\n        Pausable(_systemRegistry)\n    {\n        _baseAsset = IERC20(_vaultAsset);\n        _baseAssetDecimals = IERC20(_vaultAsset).decimals();\n\n        _symbol = ERC20(_vaultAsset).symbol();\n        _desc = ERC20(_vaultAsset).name();\n\n        _disableInitializers();\n    }\n\n    function initialize(\n        uint256 supplyLimit,\n        uint256 walletLimit,\n        string memory symbolSuffix,\n        string memory descPrefix,\n        bytes memory\n    ) public virtual initializer {\n        Errors.verifyNotEmpty(symbolSuffix, \"symbolSuffix\");\n        Errors.verifyNotEmpty(descPrefix, \"descPrefix\");\n\n        // init withdrawal queue to empty (slither issue)\n        withdrawalQueue = new IDestinationVault[](0);\n\n        navPerShareHighMarkTimestamp = block.timestamp;\n\n        _setTotalSupplyLimit(supplyLimit);\n        _setPerWalletLimit(walletLimit);\n\n        factory = msg.sender;\n\n        _symbol = symbolSuffix;\n        _desc = descPrefix;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override(ERC20, IERC20) returns (string memory) {\n        return string(abi.encodePacked(_desc, \" Pool Token\"));\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override(ERC20, IERC20) returns (string memory) {\n        return string(abi.encodePacked(\"lmp\", _symbol));\n    }\n\n    /// @inheritdoc IERC20\n    function decimals() public view virtual override(ERC20, IERC20) returns (uint8) {\n        return _baseAssetDecimals;\n    }\n\n    /// @notice Set the global share limit\n    /// @dev Zero is allowed here and used as a way to stop deposits but allow withdrawals\n    /// @param newSupplyLimit new total amount of shares allowed to be minted\n    function setTotalSupplyLimit(uint256 newSupplyLimit) external onlyOwner {\n        _setTotalSupplyLimit(newSupplyLimit);\n    }\n\n    /// @notice Set the per-wallet share limit\n    /// @param newWalletLimit new total shares a wallet is allowed to hold\n    function setPerWalletLimit(uint256 newWalletLimit) external onlyOwner {\n        _setPerWalletLimit(newWalletLimit);\n    }\n\n    /// @notice Set the fee that will be taken when profit is realized\n    /// @dev Resets the high water to current value\n    /// @param fee Percent. 100% == 10000\n    function setPerformanceFeeBps(uint256 fee) external nonReentrant hasRole(Roles.LMP_FEE_SETTER_ROLE) {\n        if (fee >= MAX_FEE_BPS) {\n            revert InvalidFee(fee);\n        }\n\n        performanceFeeBps = fee;\n\n        // Set the high mark when we change the fee so we aren't able to go farther back in\n        // time than one debt reporting and claim fee's against past profits\n        uint256 supply = totalSupply();\n        if (supply > 0) {\n            navPerShareHighMark = (totalAssets() * MAX_FEE_BPS) / supply;\n        } else {\n            // The default high mark is 1:1. We don't want to be able to take\n            // fee's before the first debt reporting\n            // Before a rebalance, everything will be in idle and we don't want to take\n            // fee's on pure idle\n            navPerShareHighMark = MAX_FEE_BPS;\n        }\n\n        emit PerformanceFeeSet(fee);\n    }\n\n    /// @notice Set the address that will receive fees\n    /// @param newFeeSink Address that will receive fees\n    function setFeeSink(address newFeeSink) external onlyOwner {\n        emit FeeSinkSet(newFeeSink);\n\n        // Zero is valid. One way to disable taking fees\n        // slither-disable-next-line missing-zero-check\n        feeSink = newFeeSink;\n    }\n\n    /// @notice Set the rewarder contract used by the vault\n    /// @dev Must be set immediately on initialization/creation and only once\n    function setRewarder(address _rewarder) external {\n        if (msg.sender != factory) {\n            revert Errors.AccessDenied();\n        }\n\n        Errors.verifyNotZero(_rewarder, \"rewarder\");\n\n        if (address(rewarder) != address(0)) {\n            revert RewarderAlreadySet();\n        }\n\n        rewarder = IMainRewarder(_rewarder);\n\n        emit RewarderSet(_rewarder);\n    }\n\n    /// @dev See {IERC4626-asset}.\n    function asset() public view virtual override returns (address) {\n        return address(_baseAsset);\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        return totalIdle + totalDebt;\n    }\n\n    /// @dev See {IERC4626-convertToShares}.\n    function convertToShares(uint256 assets) public view virtual returns (uint256 shares) {\n        shares = _convertToShares(assets, Math.Rounding.Down);\n    }\n\n    /// @dev See {IERC4626-convertToAssets}.\n    function convertToAssets(uint256 shares) public view virtual returns (uint256 assets) {\n        assets = _convertToAssets(shares, Math.Rounding.Down);\n    }\n\n    //////////////////////////////////////////////////////////////////////\n    //\t\t\t\t\t\t\t\tDeposit\t\t\t\t\t\t\t\t//\n    //////////////////////////////////////////////////////////////////////\n\n    /// @dev See {IERC4626-maxDeposit}.\n    function maxDeposit(address wallet) public view virtual override returns (uint256 maxAssets) {\n        maxAssets = convertToAssets(_maxMint(wallet));\n    }\n\n    /// @dev See {IERC4626-previewDeposit}.\n    function previewDeposit(uint256 assets) public view virtual returns (uint256 shares) {\n        shares = _convertToShares(assets, Math.Rounding.Down);\n    }\n\n    function deposit(\n        uint256 assets,\n        address receiver\n    ) public virtual override nonReentrant noNavChange ensureNoNavOps returns (uint256 shares) {\n        Errors.verifyNotZero(assets, \"assets\");\n        if (assets > maxDeposit(receiver)) {\n            revert ERC4626DepositExceedsMax(assets, maxDeposit(receiver));\n        }\n\n        shares = previewDeposit(assets);\n\n        _transferAndMint(assets, shares, receiver);\n    }\n\n    /// @dev See {IERC4626-maxMint}.\n    function maxMint(address wallet) public view virtual override returns (uint256 maxShares) {\n        maxShares = _maxMint(wallet);\n    }\n\n    /// @dev See {IERC4626-maxWithdraw}.\n    function maxWithdraw(address owner) public view virtual returns (uint256 maxAssets) {\n        maxAssets = paused() ? 0 : previewRedeem(balanceOf(owner));\n    }\n\n    /// @dev See {IERC4626-maxRedeem}.\n    function maxRedeem(address owner) public view virtual returns (uint256 maxShares) {\n        maxShares = _maxRedeem(owner);\n    }\n\n    /// @dev See {IERC4626-previewMint}.\n    function previewMint(uint256 shares) public view virtual returns (uint256 assets) {\n        assets = _convertToAssets(shares, Math.Rounding.Up);\n    }\n\n    /// @dev See {IERC4626-previewWithdraw}.\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256 shares) {\n        shares = _convertToShares(assets, Math.Rounding.Up);\n    }\n\n    /// @dev See {IERC4626-previewRedeem}.\n    function previewRedeem(uint256 shares) public view virtual override returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Down);\n    }\n\n    /**\n     * @dev See {IERC4626-mint}.\n     *\n     * As opposed to {deposit}, minting is allowed even if the vault is in a state where the price of a share is zero.\n     * In this case, the shares will be minted without requiring any assets to be deposited.\n     */\n    function mint(\n        uint256 shares,\n        address receiver\n    ) public virtual override nonReentrant noNavChange ensureNoNavOps returns (uint256 assets) {\n        if (shares > maxMint(receiver)) {\n            revert ERC4626MintExceedsMax(shares, maxMint(receiver));\n        }\n\n        assets = previewMint(shares);\n\n        _transferAndMint(assets, shares, receiver);\n    }\n\n    //////////////////////////////////////////////////////////////////////\n    //\t\t\t\t\t\t\t\tWithdraw\t\t\t\t\t\t\t//\n    //////////////////////////////////////////////////////////////////////\n\n    /// @dev See {IERC4626-withdraw}.\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual override nonReentrant noNavDecrease ensureNoNavOps returns (uint256 shares) {\n        Errors.verifyNotZero(assets, \"assets\");\n        uint256 maxAssets = maxWithdraw(owner);\n        if (assets > maxAssets) {\n            revert ERC4626ExceededMaxWithdraw(owner, assets, maxAssets);\n        }\n\n        // query number of shares these assets match\n        shares = previewWithdraw(assets);\n\n        uint256 actualAssets = _withdraw(assets, shares, receiver, owner);\n\n        if (actualAssets < assets) {\n            revert TooFewAssets(assets, actualAssets);\n        }\n    }\n\n    /// @dev See {IERC4626-redeem}.\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual override nonReentrant noNavDecrease ensureNoNavOps returns (uint256 assets) {\n        uint256 maxShares = maxRedeem(owner);\n        if (shares > maxShares) {\n            revert ERC4626ExceededMaxRedeem(owner, shares, maxShares);\n        }\n        uint256 possibleAssets = previewRedeem(shares);\n\n        assets = _withdraw(possibleAssets, shares, receiver, owner);\n    }\n\n    function _calcUserWithdrawSharesToBurn(\n        IDestinationVault destVault,\n        uint256 userShares,\n        uint256 maxAssetsToPull,\n        uint256 totalVaultShares\n    ) internal returns (uint256 sharesToBurn, uint256 totalDebtBurn) {\n        (sharesToBurn, totalDebtBurn) = LMPDebt._calcUserWithdrawSharesToBurn(\n            destinationInfo[address(destVault)], destVault, userShares, maxAssetsToPull, totalVaultShares\n        );\n    }\n\n    // slither-disable-next-line cyclomatic-complexity\n    function _withdraw(\n        uint256 assets,\n        uint256 shares,\n        address receiver,\n        address owner\n    ) internal virtual returns (uint256) {\n        uint256 idle = totalIdle;\n        WithdrawInfo memory info = WithdrawInfo({\n            currentIdle: idle,\n            assetsFromIdle: assets >= idle ? idle : assets,\n            totalAssetsToPull: assets - (assets >= idle ? idle : assets),\n            totalAssetsPulled: 0,\n            idleIncrease: 0,\n            debtDecrease: 0\n        });\n\n        // If not enough funds in idle, then pull what we need from destinations\n        if (info.totalAssetsToPull > 0) {\n            uint256 totalVaultShares = totalSupply();\n\n            // Using pre-set withdrawalQueue for withdrawal order to help minimize user gas\n            uint256 withdrawalQueueLength = withdrawalQueue.length;\n            for (uint256 i = 0; i < withdrawalQueueLength; ++i) {\n                IDestinationVault destVault = IDestinationVault(withdrawalQueue[i]);\n                (uint256 sharesToBurn, uint256 totalDebtBurn) = _calcUserWithdrawSharesToBurn(\n                    destVault,\n                    shares,\n                    info.totalAssetsToPull - Math.max(info.debtDecrease, info.totalAssetsPulled),\n                    totalVaultShares\n                );\n                if (sharesToBurn == 0) {\n                    continue;\n                }\n\n                uint256 assetPreBal = _baseAsset.balanceOf(address(this));\n                uint256 assetPulled = destVault.withdrawBaseAsset(sharesToBurn, address(this));\n\n                // Destination Vault rewards will be transferred to us as part of burning out shares\n                // Back into what that amount is and make sure it gets into idle\n                info.idleIncrease += _baseAsset.balanceOf(address(this)) - assetPreBal - assetPulled;\n                info.totalAssetsPulled += assetPulled;\n                info.debtDecrease += totalDebtBurn;\n\n                // It's possible we'll get back more assets than we anticipate from a swap\n                // so if we do, throw it in idle and stop processing. You don't get more than we've calculated\n                if (info.totalAssetsPulled > info.totalAssetsToPull) {\n                    info.idleIncrease = info.totalAssetsPulled - info.totalAssetsToPull;\n                    info.totalAssetsPulled = info.totalAssetsToPull;\n                    break;\n                }\n\n                // No need to keep going if we have the amount we're looking for\n                // Any overage is accounted for above. Anything lower and we need to keep going\n                // slither-disable-next-line incorrect-equality\n                if (info.totalAssetsPulled == info.totalAssetsToPull) {\n                    break;\n                }\n            }\n        }\n\n        // At this point should have all the funds we need sitting in in the vault\n        uint256 returnedAssets = info.assetsFromIdle + info.totalAssetsPulled;\n\n        // subtract what's taken out of idle from totalIdle\n        // slither-disable-next-line events-maths\n        totalIdle = info.currentIdle + info.idleIncrease - info.assetsFromIdle;\n\n        if (info.debtDecrease > totalDebt) {\n            totalDebt = 0;\n        } else {\n            totalDebt -= info.debtDecrease;\n        }\n\n        // do the actual withdrawal (going off of total # requested)\n        uint256 allowed = allowance(owner, msg.sender);\n        if (msg.sender != owner && allowed != type(uint256).max) {\n            if (shares > allowed) revert AmountExceedsAllowance(shares, allowed);\n\n            unchecked {\n                _approve(owner, msg.sender, allowed - shares);\n            }\n        }\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, returnedAssets, shares);\n\n        _baseAsset.safeTransfer(receiver, returnedAssets);\n\n        return returnedAssets;\n    }\n\n    function claimRewards() public whenNotPaused {\n        rewarder.getReward(msg.sender, true);\n    }\n\n    /// @notice Transfer out non-tracked tokens\n    function recover(\n        address[] calldata tokens,\n        uint256[] calldata amounts,\n        address[] calldata _destinations\n    ) external virtual override hasRole(Roles.TOKEN_RECOVERY_ROLE) {\n        // Makes sure our params are valid\n        uint256 len = tokens.length;\n        if (len == 0) {\n            revert Errors.InvalidParams();\n        }\n        Errors.verifyArrayLengths(len, amounts.length, \"tokens+amounts\");\n        Errors.verifyArrayLengths(len, _destinations.length, \"tokens+_destinations\");\n\n        emit TokensRecovered(tokens, amounts, _destinations);\n\n        for (uint256 i = 0; i < len; ++i) {\n            (address tokenAddress, uint256 amount, address destination) = (tokens[i], amounts[i], _destinations[i]);\n\n            // Ensure this isn't an asset we care about\n            if (_isTrackedAsset(tokenAddress)) {\n                revert Errors.AssetNotAllowed(tokenAddress);\n            }\n\n            IERC20(tokenAddress).safeTransfer(destination, amount);\n        }\n    }\n\n    /// @inheritdoc ILMPVault\n    function shutdown() external onlyOwner {\n        _shutdown = true;\n\n        emit Shutdown();\n    }\n\n    /// @inheritdoc ILMPVault\n    function isShutdown() external view returns (bool) {\n        return _shutdown;\n    }\n\n    /**\n     * @dev Internal conversion function (from assets to shares) with support for rounding direction.\n     */\n    function _convertToShares(uint256 assets, Math.Rounding rounding) internal view virtual returns (uint256 shares) {\n        uint256 supply = totalSupply();\n\n        // slither-disable-next-line incorrect-equality\n        shares = (assets == 0 || supply == 0) ? assets : assets.mulDiv(supply, totalAssets(), rounding);\n    }\n\n    /// @dev Internal conversion function (from shares to assets) with support for rounding direction.\n    function _convertToAssets(uint256 shares, Math.Rounding rounding) internal view virtual returns (uint256 assets) {\n        uint256 supply = totalSupply();\n        assets = (supply == 0) ? shares : shares.mulDiv(totalAssets(), supply, rounding);\n    }\n\n    function _maxRedeem(address owner) internal view virtual returns (uint256 maxShares) {\n        maxShares = paused() ? 0 : balanceOf(owner);\n    }\n\n    function _transferAndMint(uint256 assets, uint256 shares, address receiver) internal virtual {\n        // From OZ documentation:\n        // ----------------------\n        // If _asset is ERC777, `transferFrom` can trigger a reentrancy BEFORE the transfer happens through the\n        // `tokensToSend` hook. On the other hand, the `tokenReceived` hook, that is triggered after the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer before we mint so that any reentrancy would happen before the\n        // assets are transferred and before the shares are minted, which is a valid state.\n        // slither-disable-next-line reentrancy-no-eth\n        _baseAsset.safeTransferFrom(msg.sender, address(this), assets);\n\n        totalIdle += assets;\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n\n    ///@dev Checks if vault is \"healthy\" in the sense of having assets backing the circulating shares.\n    function _isVaultCollateralized() internal view returns (bool) {\n        return totalAssets() > 0 || totalSupply() == 0;\n    }\n\n    function updateDebtReporting(address[] calldata _destinations) external nonReentrant trackNavOps {\n        _updateDebtReporting(_destinations);\n    }\n\n    //////////////////////////////////////////////////////////////////////////\n    //\t\t\t\t\t\t\t  Destinations     \t\t\t\t\t\t\t//\n    //////////////////////////////////////////////////////////////////////////\n\n    function getDestinations() public view override returns (address[] memory) {\n        return destinations.values();\n    }\n\n    function isDestinationRegistered(address destination) external view returns (bool) {\n        return destinations.contains(destination);\n    }\n\n    function addDestinations(address[] calldata _destinations) public hasRole(Roles.DESTINATION_VAULTS_UPDATER) {\n        LMPDestinations.addDestinations(removalQueue, destinations, _destinations, systemRegistry);\n    }\n\n    function removeDestinations(address[] calldata _destinations) public hasRole(Roles.DESTINATION_VAULTS_UPDATER) {\n        LMPDestinations.removeDestinations(removalQueue, destinations, _destinations);\n    }\n\n    function getRemovalQueue() public view override returns (address[] memory) {\n        return removalQueue.values();\n    }\n\n    function removeFromRemovalQueue(address vaultToRemove) public override hasRole(Roles.REBALANCER_ROLE) {\n        LMPDestinations.removeFromRemovalQueue(removalQueue, vaultToRemove);\n    }\n\n    /// @dev Order is set as list of interfaces to minimize gas for our users\n    function setWithdrawalQueue(address[] calldata _destinations)\n        public\n        override\n        hasRole(Roles.SET_WITHDRAWAL_QUEUE_ROLE)\n    {\n        LMPDestinations.setWithdrawalQueue(withdrawalQueue, _destinations, systemRegistry);\n    }\n\n    /// @notice Get the current withdrawal queue\n    function getWithdrawalQueue() public view override returns (IDestinationVault[] memory withdrawalDestinations) {\n        return withdrawalQueue;\n    }\n\n    /// @notice Get the current snapshot debt info for a destination\n    function getDestinationInfo(address destVault)\n        external\n        view\n        nonReentrantReadOnly\n        returns (LMPDebt.DestinationInfo memory)\n    {\n        return destinationInfo[destVault];\n    }\n\n    //////////////////////////////////////////////////////////////////////////\n    //                                                                      //\n    //\t\t\t\t\t\t\tStrategy Related   \t\t\t\t\t\t\t//\n    //                                                                      //\n    //////////////////////////////////////////////////////////////////////////\n\n    /// @inheritdoc IStrategy\n    function rebalance(RebalanceParams memory params) public nonReentrant hasRole(Roles.SOLVER_ROLE) trackNavOps {\n        (uint256 idle, uint256 debt) = LMPDebt.rebalance(\n            destinationInfo[params.destinationOut],\n            destinationInfo[params.destinationIn],\n            params,\n            _baseAsset,\n            _shutdown,\n            totalIdle,\n            totalDebt\n        );\n        totalIdle = idle;\n        totalDebt = debt;\n        _collectFees(idle, debt, totalSupply());\n    }\n\n    /// @inheritdoc IStrategy\n    function flashRebalance(\n        IERC3156FlashBorrower receiver,\n        RebalanceParams memory rebalanceParams,\n        bytes calldata data\n    ) public nonReentrant hasRole(Roles.SOLVER_ROLE) trackNavOps {\n        (uint256 idle, uint256 debt) = LMPDebt.flashRebalance(\n            destinationInfo[rebalanceParams.destinationOut],\n            destinationInfo[rebalanceParams.destinationIn],\n            receiver,\n            rebalanceParams,\n            LMPDebt.FlashRebalanceParams({\n                totalIdle: totalIdle,\n                totalDebt: totalDebt,\n                baseAsset: _baseAsset,\n                shutdown: _shutdown\n            }),\n            data\n        );\n        totalIdle = idle;\n        totalDebt = debt;\n        _collectFees(idle, debt, totalSupply());\n    }\n\n    /// @inheritdoc IStrategy\n    function verifyRebalance(\n        address destinationIn,\n        address tokenIn,\n        uint256 amountIn,\n        address destinationOut,\n        address tokenOut,\n        uint256 amountOut\n    ) public view virtual returns (bool success, string memory message) {\n        (success, message) = LMPStrategy.verifyRebalance(\n            IStrategy.RebalanceParams({\n                destinationIn: destinationIn,\n                tokenIn: tokenIn,\n                amountIn: amountIn,\n                destinationOut: destinationOut,\n                tokenOut: tokenOut,\n                amountOut: amountOut\n            })\n        );\n    }\n\n    /// @notice Process the destinations calculating current value and snapshotting for safe deposit/mint'ing\n    function _updateDebtReporting(address[] memory _destinations) private {\n        uint256 nDest = _destinations.length;\n\n        uint256 idleIncrease = 0;\n        uint256 prevNTotalDebt = 0;\n        uint256 afterNTotalDebt = 0;\n\n        for (uint256 i = 0; i < nDest; ++i) {\n            IDestinationVault destVault = IDestinationVault(_destinations[i]);\n\n            if (!destinations.contains(address(destVault))) {\n                revert InvalidDestination(address(destVault));\n            }\n\n            // Get the reward value we've earned. DV rewards are always in terms of base asset\n            // We track the gas used purely for off-chain stats purposes\n            // Main rewarder on DV's store the earned and liquidated rewards\n            // Extra rewarders are disabled at the DV level\n            uint256 claimGasUsed = gasleft();\n            uint256 beforeBaseAsset = _baseAsset.balanceOf(address(this));\n            // We don't want any extras, those would likely not be baseAsset\n            IMainRewarder(destVault.rewarder()).getReward(address(this), false);\n            uint256 claimedRewardValue = _baseAsset.balanceOf(address(this)) - beforeBaseAsset;\n            claimGasUsed -= gasleft();\n            idleIncrease += claimedRewardValue;\n\n            // Recalculate the debt info figuring out the change in\n            // total debt value we can roll up later\n            uint256 currentShareBalance = destVault.balanceOf(address(this));\n            (uint256 totalDebtDecrease, uint256 totalDebtIncrease) = LMPDebt.recalculateDestInfo(\n                destinationInfo[address(destVault)], destVault, currentShareBalance, currentShareBalance, false\n            );\n            prevNTotalDebt += totalDebtDecrease;\n            afterNTotalDebt += totalDebtIncrease;\n\n            emit DestinationDebtReporting(address(destVault), totalDebtIncrease, claimedRewardValue, claimGasUsed);\n        }\n\n        // Persist our change in idle and debt\n        uint256 idle = totalIdle + idleIncrease;\n        uint256 debt = totalDebt - prevNTotalDebt + afterNTotalDebt;\n\n        totalIdle = idle;\n        totalDebt = debt;\n\n        _collectFees(idle, debt, totalSupply());\n    }\n\n    function _collectFees(uint256 idle, uint256 debt, uint256 totalSupply) internal {\n        address sink = feeSink;\n        uint256 fees = 0;\n        uint256 shares = 0;\n        uint256 profit = 0;\n\n        // If there's no supply then there should be no assets and so nothing\n        // to actually take fees on\n        if (totalSupply == 0) {\n            return;\n        }\n\n        uint256 currentNavPerShare = ((idle + debt) * MAX_FEE_BPS) / totalSupply;\n        uint256 effectiveNavPerShareHighMark = navPerShareHighMark;\n\n        if (currentNavPerShare > effectiveNavPerShareHighMark) {\n            // Even if we aren't going to take the fee (haven't set a sink)\n            // We still want to calculate so we can emit for off-chain analysis\n            profit = (currentNavPerShare - effectiveNavPerShareHighMark) * totalSupply;\n            fees = profit.mulDiv(performanceFeeBps, (MAX_FEE_BPS ** 2), Math.Rounding.Up);\n            if (fees > 0 && sink != address(0)) {\n                // Calculated separate from other mints as normal share mint is round down\n                shares = _convertToShares(fees, Math.Rounding.Up);\n                _mint(sink, shares);\n                emit Deposit(address(this), sink, fees, shares);\n            }\n            // Set our new high water mark, the last nav/share height we took fees\n            navPerShareHighMark = currentNavPerShare;\n            navPerShareHighMarkTimestamp = block.timestamp;\n            emit NewNavHighWatermark(currentNavPerShare, block.timestamp);\n        }\n        emit FeeCollected(fees, sink, shares, profit, idle, debt);\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override whenNotPaused {\n        // Nothing to do really do here\n        if (from == to) {\n            return;\n        }\n\n        // If this isn't a mint of new tokens, then they are being transferred\n        // from someone who is \"staked\" in the rewarder. Make sure the"
    }
  ]
}