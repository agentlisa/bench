{
  "Title": "Inaccurate Attribution in LibMap.sol",
  "Content": "In the `LibMap.sol` contract, specifically at [line 5](https://github.com/matter-labs/era-contracts/blob/2e0734b1ff9cbf3a88aadba6a19c4c4bc8645d33/ethereum/contracts/zksync/libraries/LibMap.sol#L5), the authorship is attributed to Solady. However, upon examination, it is clear that the code is not directly sourced from Solady but rather draws inspiration from their work. This misattribution could lead to confusion regarding the origins and the licensing of the code.\n\n\nTo maintain clarity and proper intellectual property acknowledgment, consider revising the comment to accurately reflect the nature of Solady's influence, perhaps indicating that the implementation is inspired by Solady's work rather than directly copied from there.\n\n\n***Update:** Resolved in [pull request #141](https://github.com/matter-labs/era-contracts/pull/141) at commit [9712419](https://github.com/matter-labs/era-contracts/pull/141/commits/97124192ecfa6d234c281d1f1d3d99e51830c773).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "ethereum/contracts/zksync/libraries/LibMap.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\n/// @notice Library for storage of packed unsigned integers.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibMap.sol)\nlibrary LibMap {\n    /// @dev A uint32 map in storage.\n    struct Uint32Map {\n        mapping(uint256 => uint256) map;\n    }\n\n    /// @dev Retrieves the uint32 value at a specific index from the Uint32Map.\n    /// @param _map The Uint32Map instance containing the packed uint32 values.\n    /// @param _index The index of the uint32 value to retrieve.\n    /// @return result The uint32 value at the specified index.\n    function get(Uint32Map storage _map, uint256 _index) internal view returns (uint32 result) {\n        unchecked {\n            // Each storage slot can store 256 bits of data.\n            // As uint32 is 32 bits long, 8 uint32s can be packed into one storage slot.\n            // Hence, `_index / 8` is done to find the storage slot that contains the required uint32.\n            uint256 mapValue = _map.map[_index / 8];\n\n            // First three bits of the original `_index` denotes the position of the uint32 in that slot.\n            // So, '(_index & 7) * 32' is done to find the bit position of the uint32 in that storage slot.\n            uint256 bitOffset = (_index & 7) * 32;\n\n            // Shift the bits to the right and retrieve the uint32 value.\n            result = uint32(mapValue >> bitOffset);\n        }\n    }\n\n    /// @dev Updates the uint32 value at `_index` in `map`.\n    /// @param _map The Uint32Map instance containing the packed uint32 values.\n    /// @param _index The index of the uint32 value to retrieve.\n    /// @param _value The new value at the specified index.\n    function set(Uint32Map storage _map, uint256 _index, uint32 _value) internal {\n        unchecked {\n            // Each storage slot can store 256 bits of data.\n            // As uint32 is 32 bits long, 8 uint32s can be packed into one storage slot.\n            // Hence, `_index / 8` is done to find the storage slot that contains the required uint32.\n            uint256 mapIndex = _index / 8;\n            uint256 mapValue = _map.map[mapIndex];\n\n            // First three bits of the original `_index` denotes the position of the uint32 in that slot.\n            // So, '(_index & 7) * 32' is done to find the bit position of the uint32 in that storage slot.\n            uint256 bitOffset = (_index & 7) * 32;\n\n            // XORing a value A with B, and then with A again, gives the original value B.\n            // We will use this property to update the uint32 value in the slot.\n\n            // Shift the bits to the right and retrieve the uint32 value.\n            uint32 oldValue = uint32(mapValue >> bitOffset);\n\n            // Calculate the XOR of the new value and the existing value.\n            uint256 newValueXorOldValue = uint256(oldValue ^ _value);\n\n            // Finally, we XOR the slot with the XOR of the new value and the existing value,\n            // shifted to its proper position. The XOR operation will effectively replace the old value with the new value.\n            _map.map[mapIndex] = (newValueXorOldValue << bitOffset) ^ mapValue;\n        }\n    }\n}"
    }
  ]
}