{
  "Title": "M-8: Unexpected behavior when calling certain ERC4626 functions",
  "Content": "# Issue M-8: Unexpected behavior when calling certain ERC4626 functions \n\nSource: https://github.com/sherlock-audit/2023-12-notional-update-5-judging/issues/43 \n\n## Found by \nCL001, xiaoming90\n## Summary\n\nUnexpected behavior could occur when certain ERC4626 functions are called during the time windows when the fCash has matured but is not yet settled.\n\n## Vulnerability Detail\n\nWhen the fCash has matured, the global settlement does not automatically get executed. The global settlement will only be executed when the first account attempts to settle its own account. The code expects the `pr.supplyFactor` to return zero if the global settlement has not been executed yet after maturity.\n\nPer the comment at Line 215, the design of the `_getMaturedCashValue` function is that it expects that if fCash has matured AND the fCash has not yet been settled, the `pr.supplyFactor` will be zero. In this case, the cash value will be zero.\n\nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/wrapped-fcash/contracts/wfCashBase.sol#L215\n\n```solidity\nFile: wfCashBase.sol\n209:     function _getMaturedCashValue(uint256 fCashAmount) internal view returns (uint256) { \n210:         if (!hasMatured()) return 0; \n211:         // If the fCash has matured we use the cash balance instead.\n212:         (uint16 currencyId, uint40 maturity) = getDecodedID(); \n213:         PrimeRate memory pr = NotionalV2.getSettlementRate(currencyId, maturity); \n214: \n215:         // fCash has not yet been settled\n216:         if (pr.supplyFactor == 0) return 0; \n..SNIP..\n```\n\nDuring the time window where the fCash has matured, and none of the accounts triggered an account settlement, the `_getMaturedCashValue` function at Line 33 below will return zero, which will result in the `totalAssets()` function returning zero.\n\nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/wrapped-fcash/contracts/wfCashERC4626.sol#L33\n\n```solidity\nFile: wfCashERC4626.sol\n29:     function totalAssets() public view override returns (uint256) {\n30:         if (hasMatured()) {\n31:             // We calculate the matured cash value of the total supply of fCash. This is\n32:             // not always equal to the cash balance held by the wrapper contract.\n33:             uint256 primeCashValue = _getMaturedCashValue(totalSupply());\n34:             require(primeCashValue < uint256(type(int256).max));\n35:             int256 externalValue = NotionalV2.convertCashBalanceToExternal(\n36:                 getCurrencyId(), int256(primeCashValue), true\n37:             );\n38:             return externalValue >= 0 ? uint256(externalValue) : 0;\n..SNIP..\n```\n\n## Impact\n\nThe `totalAssets()` function is utilized by key ERC4626 functions within the wrapper, such as the following functions. The side effects of this issue are documented below:\n\n- `convertToAssets` (Impact = returned value is always zero assets regardless of the inputs)\n- `convertToAssets` > `previewRedeem` (Impact = returned value is always zero assets regardless of the inputs)\n- `convertToAssets` > `previewRedeem` > `maxWithdraw` (Impact = max withdrawal is always zero)\n- `convertToShares` (Impact = Division by zero error, Revert)\n- `convertToShares` > `previewWithdraw` (Impact = Revert)\n\nIn addition, any external protocol integrating with wfCash will be vulnerable within this time window as an invalid result (zero) is returned, or a revert might occur. For instance, any external protocol that relies on any of the above-affected functions for computing the withdrawal/minting amount or collateral value will be greatly impacted as the value before the maturity might be 10000, but it will temporarily reset to zero during this time window. Attackers could take advantage of this time window to perform malicious actions.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/wrapped-fcash/contracts/wfCashBase.sol#L215\n\nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/wrapped-fcash/contracts/wfCashERC4626.sol#L33\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nDocument the unexpected behavior of the affected functions that could occur during the time windows when the fCash has matured but is not yet settled so that anyone who calls these functions is aware of them.\n\n\n\n## Discussion\n\n**jeffywu**\n\nValid issue and I would consider increasing the severity to high. While this is not a risk for the leveraged vault framework (transactions revert inside the time window between fCash maturity and settlement rate initialization), this may cause severe issues for another protocol which relies on the `convertToAssets` method as a valuation method.\n\nI believe the proper solution here is to `revert` while the settlement rate is not set.\n\n**nevillehuang**\n\n@jeffywu Since it is impossible to know how it will impact other protocols for wrong integrations, I will maintain is medium severity.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/142",
  "Code": [
    {
      "filename": "wrapped-fcash/contracts/wfCashBase.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"./lib/Constants.sol\";\nimport \"./lib/DateTime.sol\";\nimport \"./lib/EncodeDecode.sol\";\nimport \"../interfaces/notional/INotionalV2.sol\";\nimport \"../interfaces/notional/IWrappedfCash.sol\";\nimport \"../interfaces/WETH9.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\nabstract contract wfCashBase is ERC20Upgradeable, IWrappedfCash {\n    using SafeERC20 for IERC20;\n\n    // This is the empirically measured maximum amount of fCash that can be lent. Lending\n    // the fCashAmount down to zero is not possible due to rounding errors and fees inside\n    // the liquidity curve.\n    uint256 internal constant MAX_LEND_LIMIT = 1e9 - 50;\n    // Below this absolute number we consider the max fcash to be zero\n    uint256 internal constant MIN_FCASH_FLOOR = 50_000;\n\n    /// @notice address to the NotionalV2 system\n    INotionalV2 public immutable NotionalV2;\n    WETH9 public immutable WETH;\n\n    /// @dev Storage slot for fCash id. Read only and set on initialization\n    uint64 private _fCashId;\n\n    /// @notice Constructor is called only on deployment to set the Notional address, rest of state\n    /// is initialized on the proxy.\n    /// @dev Ensure initializer modifier is on the constructor to prevent an attack on UUPSUpgradeable contracts\n    constructor(INotionalV2 _notional, WETH9 _weth) initializer {\n        NotionalV2 = _notional;\n        WETH = _weth;\n    }\n\n    /// @notice Initializes a proxy for a specific fCash asset\n    function initialize(uint16 currencyId, uint40 maturity) external override initializer {\n        CashGroupSettings memory cashGroup = NotionalV2.getCashGroup(currencyId);\n        require(cashGroup.maxMarketIndex > 0, \"Invalid currency\");\n        require(maturity > block.timestamp, \"Invalid maturity\");\n        // Ensure that the maturity is not past the max market index, also ensure that the maturity\n        // is not in the past. This statement will allow idiosyncratic (non-tradable) fCash assets.\n        require(\n            DateTime.isValidMaturity(cashGroup.maxMarketIndex, maturity, block.timestamp),\n            \"Invalid maturity\"\n        );\n\n        // Get the corresponding fCash ID\n        uint256 fCashId = EncodeDecode.encodeERC1155Id(currencyId, maturity, Constants.FCASH_ASSET_TYPE);\n        require(fCashId <= uint256(type(uint64).max));\n        _fCashId = uint64(fCashId);\n\n        (IERC20 underlyingToken, /* */) = getUnderlyingToken();\n\n        string memory _symbol = address(underlyingToken) == Constants.ETH_ADDRESS\n            ? \"ETH\"\n            : IERC20Metadata(address(underlyingToken)).symbol();\n\n        string memory _maturity = Strings.toString(maturity);\n\n        __ERC20_init(\n            // name\n            string(abi.encodePacked(\"Wrapped f\", _symbol, \" @ \", _maturity)),\n            // symbol\n            string(abi.encodePacked(\"wf\", _symbol, \":\", _maturity))\n        );\n\n        if (address(underlyingToken) != Constants.ETH_ADDRESS) {\n            underlyingToken.safeApprove(address(NotionalV2), type(uint256).max);\n        }\n    }\n\n    /// @notice Returns the underlying fCash ID of the token\n    function getfCashId() public view override returns (uint256) {\n        return _fCashId;\n    }\n\n    /// @notice Returns the underlying fCash maturity of the token\n    function getMaturity() public view override returns (uint40 maturity) {\n        (/* */, maturity, /* */) = EncodeDecode.decodeERC1155Id(_fCashId);\n    }\n\n    /// @notice True if the fCash has matured, assets mature exactly on the block time\n    function hasMatured() public view override returns (bool) {\n        return getMaturity() <= block.timestamp;\n    }\n\n    /// @notice Returns the underlying fCash currency\n    function getCurrencyId() public view override returns (uint16 currencyId) {\n        (currencyId, /* */, /* */) = EncodeDecode.decodeERC1155Id(_fCashId);\n    }\n\n    /// @notice Returns the components of the fCash idd\n    function getDecodedID() public view override returns (uint16 currencyId, uint40 maturity) {\n        (currencyId, maturity, /* */) = EncodeDecode.decodeERC1155Id(_fCashId);\n    }\n\n    /// @notice fCash is always denominated in 8 decimal places\n    function decimals() public pure override returns (uint8) {\n        return Constants.INTERNAL_TOKEN_DECIMALS;\n    }\n\n    /// @notice Returns the current market index for this fCash asset. If this returns\n    /// zero that means it is idiosyncratic and cannot be traded.\n    function getMarketIndex() public view override returns (uint8) {\n        (uint256 marketIndex, bool isIdiosyncratic) = DateTime.getMarketIndex(\n            Constants.MAX_TRADED_MARKET_INDEX,\n            getMaturity(),\n            block.timestamp\n        );\n\n        if (isIdiosyncratic) return 0;\n        // Market index as defined does not overflow this conversion\n        return uint8(marketIndex);\n    }\n\n    /// @notice Returns the token and precision of the token that this token settles\n    /// to. For example, fUSDC will return the USDC token address and 1e6. The zero\n    /// address will represent ETH.\n    function getUnderlyingToken() public view override returns (IERC20 underlyingToken, int256 underlyingPrecision) {\n        (Token memory asset, Token memory underlying) = NotionalV2.getCurrency(getCurrencyId());\n\n        if (asset.tokenType == TokenType.NonMintable) {\n            // In this case the asset token is the underlying\n            return (IERC20(asset.tokenAddress), asset.decimals);\n        } else {\n            return (IERC20(underlying.tokenAddress), underlying.decimals);\n        }\n    }\n\n    /// @notice [Deprecated] is no longer used internal to the contract but left here to maintain\n    /// compatibility with previous interface\n    function getAssetToken() public view override returns (\n        IERC20 assetToken,\n        int256 underlyingPrecision,\n        TokenType tokenType\n    ) {\n        (Token memory asset, /* Token memory underlying */) = NotionalV2.getCurrency(getCurrencyId());\n        return (IERC20(asset.tokenAddress), asset.decimals, asset.tokenType);\n    }\n\n    function getToken(bool useUnderlying) public view returns (IERC20 token, bool isETH) {\n        if (useUnderlying) {\n            (token, /* */) = getUnderlyingToken();\n        } else {\n            (token, /* */, /* */) = getAssetToken();\n        }\n        isETH = address(token) == Constants.ETH_ADDRESS;\n    }\n\n    function getTotalFCashAvailable() public view returns (uint256, uint256) {\n        uint8 marketIndex = getMarketIndex();\n        if (marketIndex == 0) return (0, 0);\n        MarketParameters[] memory markets = NotionalV2.getActiveMarkets(getCurrencyId());\n        require(marketIndex <= markets.length);\n\n        int256 totalfCash = markets[marketIndex - 1].totalfCash;\n        require(totalfCash > 0);\n\n        uint256 maxFCash = uint256(totalfCash) * MAX_LEND_LIMIT / 1e9;\n        if (maxFCash < MIN_FCASH_FLOOR) maxFCash = 0;\n\n        return (uint256(totalfCash), maxFCash);\n    }\n\n    /// @notice Returns the cash balance held by the account, if any.\n    function getCashBalance() public view returns (uint256) {\n        (int256 cash, /* */, /* */) = NotionalV2.getAccountBalance(getCurrencyId(), address(this));\n        require(cash >= 0);\n        return uint256(cash);\n    }\n\n    /// @notice Returns the cash balance and fCash balance held by the account\n    function getBalances() public view returns (uint256 cashBalance, uint256 fCashBalance) {\n        cashBalance = getCashBalance();\n        fCashBalance = NotionalV2.balanceOf(address(this), _fCashId);\n    }\n\n    function _getPresentCashValue(uint256 fCashAmount) internal view returns (\n        uint256 primeCashValue,\n        uint256 pvExternalUnderlying\n    ) {\n        if (hasMatured()) return (0, 0);\n        (/* */, int256 precision) = getUnderlyingToken();\n\n        // Get the present value of the fCash held by the contract, this is returned in 8 decimal precision\n        (uint16 currencyId, uint40 maturity) = getDecodedID();\n        int256 pvInternal = NotionalV2.getPresentfCashValue(\n            currencyId,\n            maturity,\n            int256(fCashAmount),\n            block.timestamp,\n            false\n        );\n        int256 pvExternal = pvInternal * precision / Constants.INTERNAL_TOKEN_PRECISION;\n        require(pvExternal >= 0);\n        int256 cashValue = NotionalV2.convertUnderlyingToPrimeCash(currencyId, pvExternal);\n        require(cashValue >= 0);\n\n        primeCashValue = uint256(cashValue);\n        pvExternalUnderlying = uint256(pvExternal);\n    }\n\n    function _getMaturedCashValue(uint256 fCashAmount) internal view returns (uint256) {\n        if (!hasMatured()) return 0;\n        // If the fCash has matured we use the cash balance instead.\n        (uint16 currencyId, uint40 maturity) = getDecodedID();\n        PrimeRate memory pr = NotionalV2.getSettlementRate(currencyId, maturity);\n\n        // fCash has not yet been settled\n        if (pr.supplyFactor == 0) return 0;\n        require(pr.supplyFactor > 0);\n\n        return fCashAmount * Constants.DOUBLE_SCALAR_PRECISION / uint256(pr.supplyFactor);\n    }\n\n    /// @dev Internal method with more flags required for use inside mint internal\n    function _getTokenForMintInternal() internal view returns (\n        IERC20 token, bool isETH, bool hasTransferFee, uint256 precision\n    ) {\n        (/* */, Token memory underlying) = NotionalV2.getCurrency(getCurrencyId());\n        token = IERC20(underlying.tokenAddress);\n        hasTransferFee = underlying.hasTransferFee;\n        isETH = address(token) == Constants.ETH_ADDRESS;\n\n        require(underlying.decimals > 0);\n        precision = uint256(underlying.decimals);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}"
    },
    {
      "filename": "wrapped-fcash/contracts/wfCashERC4626.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"./wfCashLogic.sol\";\nimport \"../interfaces/IERC4626.sol\";\n\ncontract wfCashERC4626 is IERC4626, wfCashLogic {\n    constructor(INotionalV2 _notional, WETH9 _weth) wfCashLogic(_notional, _weth) {}\n\n    /** @dev See {IERC4626-asset} */\n    function asset() public view override returns (address) {\n        (IERC20 underlyingToken, bool isETH) = getToken(true);\n        return isETH ? address(WETH) : address(underlyingToken);\n    }\n\n    /** \n     * @notice Although not explicitly required by ERC4626 standards, this totalAssets method\n     * is expected to be manipulation resistant because it queries an internal Notional V2 TWAP\n     * of the fCash interest rate. This means that the value here along with `convertToAssets`\n     * and `convertToShares` can be used as an on-chain price oracle.\n     *\n     * If the wrapper is holding a cash balance prior to maturity, the total value of assets held\n     * by the contract will exceed what is returned by this function. The value of the excess value\n     * should never be accessible by Wrapped fCash holders due to the redemption mechanism, therefore\n     * the lower reported value is correct.\n     *\n     * @dev See {IERC4626-totalAssets}\n     */\n    function totalAssets() public view override returns (uint256) {\n        if (hasMatured()) {\n            // We calculate the matured cash value of the total supply of fCash. This is\n            // not always equal to the cash balance held by the wrapper contract.\n            uint256 primeCashValue = _getMaturedCashValue(totalSupply());\n            require(primeCashValue < uint256(type(int256).max));\n            int256 externalValue = NotionalV2.convertCashBalanceToExternal(\n                getCurrencyId(), int256(primeCashValue), true\n            );\n            return externalValue >= 0 ? uint256(externalValue) : 0;\n        } else {\n            (/* */, uint256 pvExternal) = _getPresentCashValue(totalSupply());\n            return pvExternal;\n        }\n    }\n\n    /** @dev See {IERC4626-convertToShares} */\n    function convertToShares(uint256 assets) public view override returns (uint256 shares) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            // Scales assets by the value of a single unit of fCash\n            (/* */, uint256 unitfCashValue) = _getPresentCashValue(uint256(Constants.INTERNAL_TOKEN_PRECISION));\n            return (assets * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / unitfCashValue;\n        }\n\n        return (assets * supply) / totalAssets();\n    }\n\n    /** @dev See {IERC4626-convertToAssets} */\n    function convertToAssets(uint256 shares) public view override returns (uint256 assets) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            // Catch the edge case where totalSupply causes a divide by zero error\n            (/* */, assets) = _getPresentCashValue(shares);\n        } else {\n            assets = (shares * totalAssets()) / supply;\n        }\n    }\n\n    /** @dev See {IERC4626-maxDeposit} */\n    function maxDeposit(address) external view override returns (uint256) {\n        return hasMatured() ? 0 : type(uint256).max;\n    }\n\n    /** @dev See {IERC4626-maxMint} */\n    function maxMint(address) external view override returns (uint256) {\n        return hasMatured() ? 0 : type(uint88).max;\n    }\n\n    /** @dev See {IERC4626-maxWithdraw} */\n    function maxWithdraw(address owner) external view override returns (uint256) {\n        return previewRedeem(balanceOf(owner));\n    }\n\n    /** @dev See {IERC4626-maxRedeem} */\n    function maxRedeem(address owner) external view override returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /** @dev See {IERC4626-previewDeposit} */\n    function _previewDeposit(uint256 assets) internal view returns (uint256 shares, uint256 maxFCash) {\n        if (hasMatured()) return (0, 0);\n        // This is how much fCash received from depositing assets\n        (uint16 currencyId, uint40 maturity) = getDecodedID();\n        (/* */, maxFCash) = getTotalFCashAvailable();\n\n        try NotionalV2.getfCashLendFromDeposit(\n            currencyId,\n            assets,\n            maturity,\n            0,\n            block.timestamp,\n            true\n        ) returns (uint88 s, uint8, bytes32) {\n            shares = s;\n        } catch {\n            shares = maxFCash;\n        }\n    }\n\n    function previewDeposit(uint256 assets) public view override returns (uint256 shares) {\n        (shares, /* */) = _previewDeposit(assets);\n    }\n\n    /** @dev See {IERC4626-previewMint} */\n    function _previewMint(uint256 shares) internal view returns (uint256 assets, uint256 maxFCash) {\n        if (hasMatured()) return (0, 0);\n\n        // This is how much fCash received from depositing assets\n        (uint16 currencyId, uint40 maturity) = getDecodedID();\n        (/* */, maxFCash) = getTotalFCashAvailable();\n        if (maxFCash < shares) {\n            (/* */, int256 precision) = getUnderlyingToken();\n            require(precision > 0);\n            // Lending at zero interest means that 1 fCash unit is equivalent to 1 asset unit\n            assets = shares * uint256(precision) / uint256(Constants.INTERNAL_TOKEN_PRECISION);\n        } else {\n            // This method will round up when calculating the depositAmountUnderlying (happens inside\n            // CalculationViews._convertToAmountExternal).\n            (assets, /* */, /* */, /* */) = NotionalV2.getDepositFromfCashLend(\n                currencyId,\n                shares,\n                maturity,\n                0,\n                block.timestamp\n            );\n        }\n    }\n\n    function previewMint(uint256 shares) public view override returns (uint256 assets) {\n        (assets, /* */) = _previewMint(shares);\n    }\n\n    /** @dev See {IERC4626-previewWithdraw} */\n    function previewWithdraw(uint256 assets) public view override returns (uint256 shares) {\n        if (assets == 0) return 0;\n\n        // Although the ERC4626 standard suggests that shares is rounded up in this calculation,\n        // it would not have much of an effect for wrapped fCash in practice. The actual amount\n        // of assets returned to the user is not dictated by the `assets` parameter supplied here\n        // but is actually calculated inside _burnInternal (rounding against the user) when fCash\n        // has matured or inside the NotionalV2 AMM when withdrawing fCash early. In either case,\n        // the number of shares returned here will be burned exactly and the user will receive close\n        // to the assets input, but not exactly.\n        if (hasMatured()) {\n            shares = convertToShares(assets);\n        } else {\n            // If withdrawing non-matured assets, we sell them on the market (i.e. borrow)\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (shares, /* */, /* */) = NotionalV2.getfCashBorrowFromPrincipal(\n                currencyId,\n                assets,\n                maturity,\n                0,\n                block.timestamp,\n                true\n            );\n        }\n    }\n\n    /** @dev See {IERC4626-previewRedeem} */\n    function previewRedeem(uint256 shares) public view override returns (uint256 assets) {\n        if (shares == 0) return 0;\n\n        if (hasMatured()) {\n            assets = convertToAssets(shares);\n        } else {\n            // If withdrawing non-matured assets, we sell them on the market (i.e. borrow)\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (assets, /* */, /* */, /* */) = NotionalV2.getPrincipalFromfCashBorrow(\n                currencyId,\n                shares,\n                maturity,\n                0,\n                block.timestamp\n            );\n        }\n    }\n\n    /** @dev See {IERC4626-deposit} */\n    function deposit(uint256 assets, address receiver) external override returns (uint256) {\n        (uint256 shares, uint256 maxFCash) = _previewDeposit(assets);\n        // Will revert if matured\n        _mintInternal(assets, _safeUint88(shares), receiver, 0, maxFCash);\n        emit Deposit(msg.sender, receiver, assets, shares);\n        return shares;\n    }\n\n    /** @dev See {IERC4626-mint} */\n    function mint(uint256 shares, address receiver) external override returns (uint256) {\n        (uint256 assets, uint256 maxFCash) = _previewMint(shares);\n        // Will revert if matured\n        _mintInternal(assets, _safeUint88(shares), receiver, 0, maxFCash);\n        emit Deposit(msg.sender, receiver, assets, shares);\n        return assets;\n    }\n\n    /** @dev See {IERC4626-withdraw} */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external override returns (uint256) {\n        // This is a noop if the account has already been settled, cheaper to call this than cache\n        // it locally in storage.\n        NotionalV2.settleAccount(address(this));\n\n        uint256 shares = previewWithdraw(assets);\n\n        if (msg.sender != owner) {\n            _spendAllowance(owner, msg.sender, shares);\n        }\n        _redeemInternal(shares, receiver, owner);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4626-redeem} */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external override returns (uint256) {\n        // It is more accurate and gas efficient to check the balance of the\n        // receiver here than rely on the previewRedeem method.\n        IERC20 token = IERC20(asset());\n        uint256 balanceBefore = token.balanceOf(receiver);\n\n        if (msg.sender != owner) {\n            _spendAllowance(owner, msg.sender, shares);\n        }\n        _redeemInternal(shares, receiver, owner);\n\n        uint256 balanceAfter = token.balanceOf(receiver);\n        uint256 assets = balanceAfter - balanceBefore;\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n        return assets;\n    }\n\n    function _redeemInternal(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) private {\n        _burnInternal(\n            owner,\n            shares,\n            RedeemOpts({\n                redeemToUnderlying: true,\n                transferfCash: false,\n                receiver: receiver,\n                maxImpliedRate: 0\n            })\n        );\n    }\n}"
    },
    {
      "filename": "wrapped-fcash/contracts/wfCashBase.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"./lib/Constants.sol\";\nimport \"./lib/DateTime.sol\";\nimport \"./lib/EncodeDecode.sol\";\nimport \"../interfaces/notional/INotionalV2.sol\";\nimport \"../interfaces/notional/IWrappedfCash.sol\";\nimport \"../interfaces/WETH9.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\nabstract contract wfCashBase is ERC20Upgradeable, IWrappedfCash {\n    using SafeERC20 for IERC20;\n\n    // This is the empirically measured maximum amount of fCash that can be lent. Lending\n    // the fCashAmount down to zero is not possible due to rounding errors and fees inside\n    // the liquidity curve.\n    uint256 internal constant MAX_LEND_LIMIT = 1e9 - 50;\n    // Below this absolute number we consider the max fcash to be zero\n    uint256 internal constant MIN_FCASH_FLOOR = 50_000;\n\n    /// @notice address to the NotionalV2 system\n    INotionalV2 public immutable NotionalV2;\n    WETH9 public immutable WETH;\n\n    /// @dev Storage slot for fCash id. Read only and set on initialization\n    uint64 private _fCashId;\n\n    /// @notice Constructor is called only on deployment to set the Notional address, rest of state\n    /// is initialized on the proxy.\n    /// @dev Ensure initializer modifier is on the constructor to prevent an attack on UUPSUpgradeable contracts\n    constructor(INotionalV2 _notional, WETH9 _weth) initializer {\n        NotionalV2 = _notional;\n        WETH = _weth;\n    }\n\n    /// @notice Initializes a proxy for a specific fCash asset\n    function initialize(uint16 currencyId, uint40 maturity) external override initializer {\n        CashGroupSettings memory cashGroup = NotionalV2.getCashGroup(currencyId);\n        require(cashGroup.maxMarketIndex > 0, \"Invalid currency\");\n        require(maturity > block.timestamp, \"Invalid maturity\");\n        // Ensure that the maturity is not past the max market index, also ensure that the maturity\n        // is not in the past. This statement will allow idiosyncratic (non-tradable) fCash assets.\n        require(\n            DateTime.isValidMaturity(cashGroup.maxMarketIndex, maturity, block.timestamp),\n            \"Invalid maturity\"\n        );\n\n        // Get the corresponding fCash ID\n        uint256 fCashId = EncodeDecode.encodeERC1155Id(currencyId, maturity, Constants.FCASH_ASSET_TYPE);\n        require(fCashId <= uint256(type(uint64).max));\n        _fCashId = uint64(fCashId);\n\n        (IERC20 underlyingToken, /* */) = getUnderlyingToken();\n\n        string memory _symbol = address(underlyingToken) == Constants.ETH_ADDRESS\n            ? \"ETH\"\n            : IERC20Metadata(address(underlyingToken)).symbol();\n\n        string memory _maturity = Strings.toString(maturity);\n\n        __ERC20_init(\n            // name\n            string(abi.encodePacked(\"Wrapped f\", _symbol, \" @ \", _maturity)),\n            // symbol\n            string(abi.encodePacked(\"wf\", _symbol, \":\", _maturity))\n        );\n\n        if (address(underlyingToken) != Constants.ETH_ADDRESS) {\n            underlyingToken.safeApprove(address(NotionalV2), type(uint256).max);\n        }\n    }\n\n    /// @notice Returns the underlying fCash ID of the token\n    function getfCashId() public view override returns (uint256) {\n        return _fCashId;\n    }\n\n    /// @notice Returns the underlying fCash maturity of the token\n    function getMaturity() public view override returns (uint40 maturity) {\n        (/* */, maturity, /* */) = EncodeDecode.decodeERC1155Id(_fCashId);\n    }\n\n    /// @notice True if the fCash has matured, assets mature exactly on the block time\n    function hasMatured() public view override returns (bool) {\n        return getMaturity() <= block.timestamp;\n    }\n\n    /// @notice Returns the underlying fCash currency\n    function getCurrencyId() public view override returns (uint16 currencyId) {\n        (currencyId, /* */, /* */) = EncodeDecode.decodeERC1155Id(_fCashId);\n    }\n\n    /// @notice Returns the components of the fCash idd\n    function getDecodedID() public view override returns (uint16 currencyId, uint40 maturity) {\n        (currencyId, maturity, /* */) = EncodeDecode.decodeERC1155Id(_fCashId);\n    }\n\n    /// @notice fCash is always denominated in 8 decimal places\n    function decimals() public pure override returns (uint8) {\n        return Constants.INTERNAL_TOKEN_DECIMALS;\n    }\n\n    /// @notice Returns the current market index for this fCash asset. If this returns\n    /// zero that means it is idiosyncratic and cannot be traded.\n    function getMarketIndex() public view override returns (uint8) {\n        (uint256 marketIndex, bool isIdiosyncratic) = DateTime.getMarketIndex(\n            Constants.MAX_TRADED_MARKET_INDEX,\n            getMaturity(),\n            block.timestamp\n        );\n\n        if (isIdiosyncratic) return 0;\n        // Market index as defined does not overflow this conversion\n        return uint8(marketIndex);\n    }\n\n    /// @notice Returns the token and precision of the token that this token settles\n    /// to. For example, fUSDC will return the USDC token address and 1e6. The zero\n    /// address will represent ETH.\n    function getUnderlyingToken() public view override returns (IERC20 underlyingToken, int256 underlyingPrecision) {\n        (Token memory asset, Token memory underlying) = NotionalV2.getCurrency(getCurrencyId());\n\n        if (asset.tokenType == TokenType.NonMintable) {\n            // In this case the asset token is the underlying\n            return (IERC20(asset.tokenAddress), asset.decimals);\n        } else {\n            return (IERC20(underlying.tokenAddress), underlying.decimals);\n        }\n    }\n\n    /// @notice [Deprecated] is no longer used internal to the contract but left here to maintain\n    /// compatibility with previous interface\n    function getAssetToken() public view override returns (\n        IERC20 assetToken,\n        int256 underlyingPrecision,\n        TokenType tokenType\n    ) {\n        (Token memory asset, /* Token memory underlying */) = NotionalV2.getCurrency(getCurrencyId());\n        return (IERC20(asset.tokenAddress), asset.decimals, asset.tokenType);\n    }\n\n    function getToken(bool useUnderlying) public view returns (IERC20 token, bool isETH) {\n        if (useUnderlying) {\n            (token, /* */) = getUnderlyingToken();\n        } else {\n            (token, /* */, /* */) = getAssetToken();\n        }\n        isETH = address(token) == Constants.ETH_ADDRESS;\n    }\n\n    function getTotalFCashAvailable() public view returns (uint256, uint256) {\n        uint8 marketIndex = getMarketIndex();\n        if (marketIndex == 0) return (0, 0);\n        MarketParameters[] memory markets = NotionalV2.getActiveMarkets(getCurrencyId());\n        require(marketIndex <= markets.length);\n\n        int256 totalfCash = markets[marketIndex - 1].totalfCash;\n        require(totalfCash > 0);\n\n        uint256 maxFCash = uint256(totalfCash) * MAX_LEND_LIMIT / 1e9;\n        if (maxFCash < MIN_FCASH_FLOOR) maxFCash = 0;\n\n        return (uint256(totalfCash), maxFCash);\n    }\n\n    /// @notice Returns the cash balance held by the account, if any.\n    function getCashBalance() public view returns (uint256) {\n        (int256 cash, /* */, /* */) = NotionalV2.getAccountBalance(getCurrencyId(), address(this));\n        require(cash >= 0);\n        return uint256(cash);\n    }\n\n    /// @notice Returns the cash balance and fCash balance held by the account\n    function getBalances() public view returns (uint256 cashBalance, uint256 fCashBalance) {\n        cashBalance = getCashBalance();\n        fCashBalance = NotionalV2.balanceOf(address(this), _fCashId);\n    }\n\n    function _getPresentCashValue(uint256 fCashAmount) internal view returns (\n        uint256 primeCashValue,\n        uint256 pvExternalUnderlying\n    ) {\n        if (hasMatured()) return (0, 0);\n        (/* */, int256 precision) = getUnderlyingToken();\n\n        // Get the present value of the fCash held by the contract, this is returned in 8 decimal precision\n        (uint16 currencyId, uint40 maturity) = getDecodedID();\n        int256 pvInternal = NotionalV2.getPresentfCashValue(\n            currencyId,\n            maturity,\n            int256(fCashAmount),\n            block.timestamp,\n            false\n        );\n        int256 pvExternal = pvInternal * precision / Constants.INTERNAL_TOKEN_PRECISION;\n        require(pvExternal >= 0);\n        int256 cashValue = NotionalV2.convertUnderlyingToPrimeCash(currencyId, pvExternal);\n        require(cashValue >= 0);\n\n        primeCashValue = uint256(cashValue);\n        pvExternalUnderlying = uint256(pvExternal);\n    }\n\n    function _getMaturedCashValue(uint256 fCashAmount) internal view returns (uint256) {\n        if (!hasMatured()) return 0;\n        // If the fCash has matured we use the cash balance instead.\n        (uint16 currencyId, uint40 maturity) = getDecodedID();\n        PrimeRate memory pr = NotionalV2.getSettlementRate(currencyId, maturity);\n\n        // fCash has not yet been settled\n        if (pr.supplyFactor == 0) return 0;\n        require(pr.supplyFactor > 0);\n\n        return fCashAmount * Constants.DOUBLE_SCALAR_PRECISION / uint256(pr.supplyFactor);\n    }\n\n    /// @dev Internal method with more flags required for use inside mint internal\n    function _getTokenForMintInternal() internal view returns (\n        IERC20 token, bool isETH, bool hasTransferFee, uint256 precision\n    ) {\n        (/* */, Token memory underlying) = NotionalV2.getCurrency(getCurrencyId());\n        token = IERC20(underlying.tokenAddress);\n        hasTransferFee = underlying.hasTransferFee;\n        isETH = address(token) == Constants.ETH_ADDRESS;\n\n        require(underlying.decimals > 0);\n        precision = uint256(underlying.decimals);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}"
    },
    {
      "filename": "wrapped-fcash/contracts/wfCashERC4626.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"./wfCashLogic.sol\";\nimport \"../interfaces/IERC4626.sol\";\n\ncontract wfCashERC4626 is IERC4626, wfCashLogic {\n    constructor(INotionalV2 _notional, WETH9 _weth) wfCashLogic(_notional, _weth) {}\n\n    /** @dev See {IERC4626-asset} */\n    function asset() public view override returns (address) {\n        (IERC20 underlyingToken, bool isETH) = getToken(true);\n        return isETH ? address(WETH) : address(underlyingToken);\n    }\n\n    /** \n     * @notice Although not explicitly required by ERC4626 standards, this totalAssets method\n     * is expected to be manipulation resistant because it queries an internal Notional V2 TWAP\n     * of the fCash interest rate. This means that the value here along with `convertToAssets`\n     * and `convertToShares` can be used as an on-chain price oracle.\n     *\n     * If the wrapper is holding a cash balance prior to maturity, the total value of assets held\n     * by the contract will exceed what is returned by this function. The value of the excess value\n     * should never be accessible by Wrapped fCash holders due to the redemption mechanism, therefore\n     * the lower reported value is correct.\n     *\n     * @dev See {IERC4626-totalAssets}\n     */\n    function totalAssets() public view override returns (uint256) {\n        if (hasMatured()) {\n            // We calculate the matured cash value of the total supply of fCash. This is\n            // not always equal to the cash balance held by the wrapper contract.\n            uint256 primeCashValue = _getMaturedCashValue(totalSupply());\n            require(primeCashValue < uint256("
    }
  ]
}