{
  "Title": "M-5: Function `_indexOf` will cause a settlement to revert if `auctionPrice > MAX_PRICE`",
  "Content": "# Issue M-5: Function `_indexOf` will cause a settlement to revert if `auctionPrice > MAX_PRICE` \n\nSource: https://github.com/sherlock-audit/2023-09-ajna-judging/issues/30 \n\n## Found by \nsantipu\\_\n\nIn ERC721 pools, when an auction is settled while `auctionPrice > MAX_PRICE` and borrower has some fraction of collateral (e.g. `0.5e18`) the settlement will always revert until enough time has passed so `auctionPrice` lowers below `MAX_PRICE`, thus causing a temporary DoS. \n\n## Vulnerability Detail\n\nIn ERC721 pools, when a settlement occurs and the borrower still have some fraction of collateral, that fraction is allocated in the bucket with a price closest to `auctionPrice` and the borrower is proportionally compensated with LPB in that bucket.\n\nIn order to calculate the index of the bucket closest in price to `auctionPrice`, the `_indexOf` function is called. The first line of that function is outlined below:\n\nhttps://github.com/sherlock-audit/2023-09-ajna/blob/main/ajna-core/src/libraries/helpers/PoolHelper.sol#L78\n```solidity\nif (price_ < MIN_PRICE || price_ > MAX_PRICE) revert BucketPriceOutOfBounds();\n```\n\nThe `_indexOf` function will revert if `price_` (provided as an argument) is below `MIN_PRICE` or above `MAX_PRICE`. This function is called from `_settleAuction`, here is a snippet of that:\n\nhttps://github.com/sherlock-audit/2023-09-ajna/blob/main/ajna-core/src/libraries/external/SettlerActions.sol#L234\n\n```solidity\nfunction _settleAuction(\n    AuctionsState storage auctions_,\n    mapping(uint256 => Bucket) storage buckets_,\n    DepositsState storage deposits_,\n    address borrowerAddress_,\n    uint256 borrowerCollateral_,\n    uint256 poolType_\n) internal returns (uint256 remainingCollateral_, uint256 compensatedCollateral_) {\n\n    // ...\n\n            uint256 auctionPrice = _auctionPrice(\n                auctions_.liquidations[borrowerAddress_].referencePrice,\n                auctions_.liquidations[borrowerAddress_].kickTime\n            );\n\n            // determine the bucket index to compensate fractional collateral\n>>>         bucketIndex = auctionPrice > MIN_PRICE ? _indexOf(auctionPrice) : MAX_FENWICK_INDEX;\n\n    // ...\n}\n```\n\nThe `_settleAuction` function first calculates the `auctionPrice` and then it gets the index of the bucket with a price closest to `bucketPrice`. If `auctionPrice` results to be bigger than `MAX_PRICE`, then the `_indexOf` function will revert and the entire settlement will fail. \n\nIn certain types of pools where one asset has an extremely low market price and the other is valued really high, the resulting prices at an auction can be so high that is not rare to see an `auctionPrice > MAX_PRICE`.\n\nThe `auctionPrice` variable is computed from `referencePrice` and it goes lower through time until 72 hours have passed. Also, `referencePrice` can be much higher than `MAX_PRICE`, as outline in `_kick`:\n\n```solidity\nvars.referencePrice = Maths.min(Maths.max(vars.htp, vars.neutralPrice), MAX_INFLATED_PRICE);\n```\n\nThe value of `MAX_INFLATED_PRICE` is exactly `50 * MAX_PRICE` so a `referencePrice` bigger than `MAX_PRICE` is totally possible. \n\nIn auctions where `referencePrice` is bigger than `MAX_PRICE` and the auction is settled in a low time frame, `auctionPrice` will be also bigger than `MAX_PRICE` and that will cause the entire transaction to revert. \n\n## Impact\n\nWhen the above conditions are met, the auction won't be able to settle until `auctionPrice` lowers below `MAX_PRICE`.\n\nIn ERC721 pools with a high difference in assets valuation, there is no low-probability prerequisites and the impact will be a violation of the system design, as well as the potential losses for the kicker of that auction, so setting severity to be high\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-09-ajna/blob/main/ajna-core/src/libraries/external/SettlerActions.sol#L234\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIt's recommended to change the affected line of `_settleAuction` in the following way:\n\n```diff\n-   bucketIndex = auctionPrice > MIN_PRICE ? _indexOf(auctionPrice) : MAX_FENWICK_INDEX;\n+   if(auctionPrice < MIN_PRICE){\n+       bucketIndex = MAX_FENWICK_INDEX;\n+   } else if (auctionPrice > MAX_PRICE) {\n+       bucketIndex = 1;\n+   } else {\n+       bucketIndex = _indexOf(auctionPrice);\n+   }\n```\n\n\n\n## Discussion\n\n**neeksec**\n\nValid finding.\nSet to `Medium` because I don't see `the potential losses for the kicker of that auction`. This revert happens under extreme market condition and the it could recovery as time elapses.\n\n**dmitriia**\n\nEscalate\n\nSince for `_settleAuction()` called outside of taking the exact time of settlement does not matter, the only remaining case is calling it in the taking workflow, and there the impact is that taker has to wait for the auction price to go under the limit. This is actually beneficial for the kicker since lower execution price means higher kicker's reward. Also, it is beneficial for the taker as they pay less, and the losing party is the borrower.\n\nGiven that `MAX_PRICE` is by definition set at a very high level that will not be achieved practically in the vast majority of the pools, the probability of the scenario is very low. Basically the only practical case I can see at the moment is that quote token defaults/breaks and its valuation goes to zero. In this case it will not matter for the borrower at what exactly price the auction was settled. This way based on the very low probability and not straightforward materiality of the impact, that can be estimated as low/medium, I would categorize the overall severity to be low.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> Since for `_settleAuction()` called outside of taking the exact time of settlement does not matter, the only remaining case is calling it in the taking workflow, and there the impact is that taker has to wait for the auction price to go under the limit. This is actually beneficial for the kicker since lower execution price means higher kicker's reward. Also, it is beneficial for the taker as they pay less, and the losing party is the borrower.\n> \n> Given that `MAX_PRICE` is by definition set at a very high level that will not be achieved practically in the vast majority of the pools, the probability of the scenario is very low. Basically the only practical case I can see at the moment is that quote token defaults/breaks and its valuation goes to zero. In this case it will not matter for the borrower at what exactly price the auction was settled. This way based on the very low probability and not straightforward materiality of the impact, that can be estimated as low/medium, I would categorize the overall severity to be low.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**kadenzipfel**\n\nFrom the [judging docs](https://docs.sherlock.xyz/audits/judging/judging#iii.-some-standards-observed): \"**Could Denial-of-Service (DOS), griefing, or locking of contracts count as a Medium (or High) issue?** It would not count if the DOS, etc. lasts a known, finite amount of time <1 year.\"\n\n**santipu03**\n\n@dmitriia \nAgree that this issue will actually benefit the kicker and taker, making the borrower the losing party. \nAlso agree that the impact is that takers will have to wait for `auctionPrice` to go lower than `MAX_PRICE`.\nAnd this can create the following scenario where a kicker unfairly profits from a borrower:\n - Market price in a pool is higher than `MAX_PRICE` (only feasible on a few pools)\n - Bob is a borrower that's collateralized enough so kicking him would cause a loss on kicker.\n - A malicious lender can kick Bob knowing that the auction won't settle until `auctionPrice` is below `MAX_PRICE`, then the kicker will be receiving more profits from the bond, thus profiting off the borrower. \n - Therefore, Bob will be receiving less tokens from the auction as expected, and the kicker will be pocketing a profit taking advantage of this bug. \n\nOn the other hand, the only pools affected by this issue would be pools with a high difference in valuation (e.g. `BTC/SHIBA`,  `ETH/SHIBA`, etc). Because the difference of valuation of a unit of token on these pools is huge, it'd be pretty easy to achieve `MAX_PRICE`. \nFor example:\n - Market Price BTC/SHIBA: `4_295_487_804 * 1e18`\n - Market Price ETH/SHIBA: `229_958_536 * 1e18`\n - MAX_PRICE in Ajna = `1_004_968_987 * 1e18`\n\nAchieving `MAX_PRICE` is not unfeasible in these sort of pools. \n\n@kadenzipfel \nA DoS by itself doesn't qualify for a medium/high but in the case of this issue it also implies the loss of borrower funds.\n\nGiven that Ajna will be an immutable protocol that aims to support this kind of pools, the impact of this issue is high. And because these sort of pools only represents a minority, the probability of this happening is medium/low. Therefore, I think the fair severity for this issue is medium. \n\n**kadenzipfel**\n\n> A malicious lender can kick Bob knowing that the auction won't settle until auctionPrice is below MAX_PRICE, then the kicker will be receiving more profits from the bond, thus profiting off the borrower.\n\nIt seems what you're trying to argue here is that you can't `take` the full amount auctioned because it will attempt to settle the auction if the remaining `borrower_.t0Debt == 0`, see `TakerActions:L524-539` below:\n\n```solidity \n// if debt is fully repaid, settle the auction\nif (borrower_.t0Debt == 0) {\n    settledAuction_ = true;\n\n    // settle auction and update borrower's collateral with value after settlement\n    (remainingCollateral_, compensatedCollateral_) = SettlerActions._settleAuction(\n        auctions_,\n        buckets_,\n        deposits_,\n        borrowerAddress_,\n        borrower_.collateral,\n        poolState_.poolType\n    );\n\n    borrower_.collateral = remainingCollateral_;\n}\n```\n\nThe flaw with your argument is that you can still `take` at whatever the current auction price is as long as you leave some `borrower_.t0Debt` so that we don't get the unexpected revert in `_settleAuction`. So the borrower could easily `take` most of the auctioned debt at a favourable price, resulting in a loss for the kicker, maintaining intended system incentives.\n\n**santipu03**\n\n> The flaw with your argument is that you can still take at whatever the current auction price is as long as you leave some borrower_.t0Debt so that we don't get the unexpected revert in _settleAuction. So the borrower could easily take most of the auctioned debt at a favourable price, resulting in a loss for the kicker, maintaining intended system incentives.\n\nThis isn't true in ERC721 pools because is required to take a minimum of one unit of collateral (`1e18`) for every `take` action. \n\nBefore calculating the amounts in `take`, collateral to take is rounded to only get a minimum of 1 unit:\nhttps://github.com/sherlock-audit/2023-09-ajna/blob/main/ajna-core/src/libraries/external/TakerActions.sol#L358-L361\n```solidity\n// for NFT take make sure the take flow and bond change calculation happens for the rounded collateral that can be taken\nif (params_.poolType == uint8(PoolType.ERC721)) {\n    takeableCollateral = (takeableCollateral / 1e18) * 1e18;\n}\n```\n\nAlso, after calculating the collateral to take, `collateralAmount` is rounded up in order to get full units of collateral (min: `1e18`):\nhttps://github.com/sherlock-audit/2023-09-ajna/blob/main/ajna-core/src/libraries/external/TakerActions.sol#L383-L402\n```solidity\nif (params_.poolType == uint8(PoolType.ERC721)) {\n    // slither-disable-next-line divide-before-multiply\n    uint256 collateralTaken = (vars_.collateralAmount / 1e18) * 1e18; // solidity rounds down, so if 2.5 it will be 2.5 / 1 = 2\n\n    // collateral taken not a round number\n    if (collateralTaken != vars_.collateralAmount) {\n        if (Maths.min(borrower_.collateral, params_.takeCollateral) >= collateralTaken + 1e18) {\n            // round up collateral to take\n            collateralTaken += 1e18;\n\n            // taker should send additional quote tokens to cover difference between collateral needed to be taken and rounded collateral, at auction price\n            // borrower will get quote tokens for the difference between rounded collateral and collateral taken to cover debt\n            vars_.excessQuoteToken = Maths.wmul(collateralTaken - vars_.collateralAmount, vars_.auctionPrice);\n            vars_.collateralAmount = collateralTaken;\n        } else {\n            // shouldn't get here, but just in case revert\n            revert CollateralRoundingNeededButNotPossible();\n        }\n    }\n}\n```\n\nTherefore, in ERC721 pools, the minimum amount of collateral to take is `1e18`, and this will prevent takers to take most of the collateral at a favourable price when collateral auctioned is low (e.g. 1 NFT).\n\n**dmitriia**\n\n> @dmitriia Agree that this issue will actually benefit the kicker and taker, making the borrower the losing party. Also agree that the impact is that takers will have to wait for `auctionPrice` to go lower than `MAX_PRICE`. And this can create the following scenario where a kicker unfairly profits from a borrower:\n> ...\n> On the other hand, the only pools affected by this issue would be pools with a high difference in valuation (e.g. `BTC/SHIBA`, `ETH/SHIBA`, etc). Because the difference of valuation of a unit of token on these pools is huge, it'd be pretty easy to achieve `MAX_PRICE`. For example:\n> \n> * Market Price BTC/SHIBA: `4_295_487_804 * 1e18`\n> * Market Price ETH/SHIBA: `229_958_536 * 1e18`\n> * MAX_PRICE in Ajna = `1_004_968_987 * 1e18`\n> \n> Achieving `MAX_PRICE` is not unfeasible in these sort of pools.\n\nThis means that until `MAX_PRICE` is increased `BTC/SHIBA` and alike pools will malfunction in Ajna, which needs to be communicated as pool creation is permissionless.\n\nRe ERC721 it looks like the attack is for `1e18` amount only as before that takes can avoid `_settleAuction()` by leaving this `1` NFT intact.\n\n**santipu03**\n\n> Re ERC721 it looks like the attack is for 1e18 amount only as before that takes can avoid _settleAuction() by leaving this 1 NFT intact.\n\nThe attack is most effective for auctions of `1e18` collateral, but it's still efective (though less impactful) with auctions for more amount of collateral. \n\nFor example, in case of an auction of `2.1e18` collateral the borrower will receive the fair price for 1 NFT but a lower price for the other NFT. This unfair price for the last NFT of an auction can be the difference between a kicker winning over a bond or losing part or it.\n\nAs said, the probability is kind of low but the impact is high so I think the fair severity is medium. \n\n**Evert0x**\n\n@kadenzipfel @dmitriia do you have any follow up arguments? If not I will keep the issue state as is. \n\n**dmitriia**\n\n> @kadenzipfel @dmitriia do you have any follow up arguments? If not I will keep the issue state as is.\n\nI'm fine with medium as issue highlights the important enough limitations (first of all, `MAX_PRICE` looks to be too low) for extreme pairs of tokens, which are relevant due to permissionless nature of Ajna pools.\n\n**Czar102**\n\nTo me it looks like a limitation introduced by `MAX_PRICE`, which seems to be a design choice, hence should be out of scope. @santipu03 please let me know if that's accurate. If yes, I will be accepting the escalation and closing the issue.\n\n**santipu03**\n\nI don't think this issue is because of a design choice. In ERC20 pools, taking collateral from auctions with `auctionPrice > MAX_PRICE` is always possible. This is also true in ERC721 pools when dealing with integer collateral (e.g., `1e18`). However, the problem arises specifically in ERC721 pools with fractioned collateral (e.g., `1.5e18`). This inconsistency points to the issue being a bug, not an intended feature.\n\nIf it were a design choice, the issue would appear in all pool types under any scenario. Instead, it only happens in ERC721 pools with fractioned collateral, further indicating it's an unintentional bug.\n\nThe protocol allows for takers to take collateral in an auction with a price above `MAX_PRICE`, therefore this issue is not a design choice but a bug. The fix proposed in the report addresses and corrects this issue, reinforcing the idea that it's a bug and not a designed aspect of the protocol.\n\n**Czar102**\n\nSorry for my misunderstanding. Thank you for the explanation.\nI plan on rejecting the escalation and leaving the issue as is.\n\n**Czar102**\n\nResult:\nMedium\nUnique\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [dmitriia](https://github.com/sherlock-audit/2023-09-ajna-judging/issues/30/#issuecomment-1800454290): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/114",
  "Code": [
    {
      "filename": "ajna-core/src/libraries/helpers/PoolHelper.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.18;\n\nimport { PRBMathSD59x18 } from \"@prb-math/contracts/PRBMathSD59x18.sol\";\nimport { Math }           from '@openzeppelin/contracts/utils/math/Math.sol';\n\nimport { PoolType } from '../../interfaces/pool/IPool.sol';\n\nimport { Buckets } from '../internal/Buckets.sol';\nimport { Maths }   from '../internal/Maths.sol';\n\n    error BucketIndexOutOfBounds();\n    error BucketPriceOutOfBounds();\n\n    /*************************/\n    /*** Price Conversions ***/\n    /*************************/\n\n    /// @dev constant price indices defining the min and max of the potential price range\n    int256  constant MAX_BUCKET_INDEX  =  4_156;\n    int256  constant MIN_BUCKET_INDEX  = -3_232;\n    uint256 constant MAX_FENWICK_INDEX =  7_388;\n\n    uint256 constant MIN_PRICE = 99_836_282_890;\n    uint256 constant MAX_PRICE = 1_004_968_987.606512354182109771 * 1e18;\n\n    uint256 constant MAX_INFLATED_PRICE = 50_248_449_380.325617709105488550 * 1e18; // 50 * MAX_PRICE\n\n    /// @dev deposit buffer (extra margin) used for calculating reserves\n    uint256 constant DEPOSIT_BUFFER = 1.000000001 * 1e18;\n\n    /// @dev step amounts in basis points. This is a constant across pools at `0.005`, achieved by dividing `WAD` by `10,000`\n    int256 constant FLOAT_STEP_INT = 1.005 * 1e18;\n\n    /**\n     *  @notice Calculates the price (`WAD` precision) for a given `Fenwick` index.\n     *  @dev    Reverts with `BucketIndexOutOfBounds` if index exceeds maximum constant.\n     *  @dev    Uses fixed-point math to get around lack of floating point numbers in `EVM`.\n     *  @dev    Fenwick index is converted to bucket index.\n     *  @dev    Fenwick index to bucket index conversion:\n     *  @dev      `1.00`      : bucket index `0`,     fenwick index `4156`: `7388-4156-3232=0`.\n     *  @dev      `MAX_PRICE` : bucket index `4156`,  fenwick index `0`:    `7388-0-3232=4156`.\n     *  @dev      `MIN_PRICE` : bucket index - `3232`, fenwick index `7388`: `7388-7388-3232=-3232`.\n     *  @dev    `V1`: `price = MIN_PRICE + (FLOAT_STEP * index)`\n     *  @dev    `V2`: `price = MAX_PRICE * (FLOAT_STEP ** (abs(int256(index - MAX_PRICE_INDEX))));`\n     *  @dev    `V3 (final)`: `x^y = 2^(y*log_2(x))`\n     */\n    function _priceAt(\n        uint256 index_\n    ) pure returns (uint256) {\n        // Lowest Fenwick index is highest price, so invert the index and offset by highest bucket index.\n        int256 bucketIndex = MAX_BUCKET_INDEX - int256(index_);\n        if (bucketIndex < MIN_BUCKET_INDEX || bucketIndex > MAX_BUCKET_INDEX) revert BucketIndexOutOfBounds();\n\n        return uint256(\n            PRBMathSD59x18.exp2(\n                PRBMathSD59x18.mul(\n                    PRBMathSD59x18.fromInt(bucketIndex),\n                    PRBMathSD59x18.log2(FLOAT_STEP_INT)\n                )\n            )\n        );\n    }\n\n    /**\n     *  @notice Calculates the  Fenwick  index for a given price.\n     *  @dev    Reverts with `BucketPriceOutOfBounds` if price exceeds maximum constant.\n     *  @dev    Price expected to be inputted as a `WAD` (`18` decimal).\n     *  @dev    `V1`: `bucket index = (price - MIN_PRICE) / FLOAT_STEP`\n     *  @dev    `V2`: `bucket index = (log(FLOAT_STEP) * price) /  MAX_PRICE`\n     *  @dev    `V3 (final)`: `bucket index =  log_2(price) / log_2(FLOAT_STEP)`\n     *  @dev    `Fenwick index = 7388 - bucket index + 3232`\n     */\n    function _indexOf(\n        uint256 price_\n    ) pure returns (uint256) {\n        if (price_ < MIN_PRICE || price_ > MAX_PRICE) revert BucketPriceOutOfBounds();\n\n        int256 index = PRBMathSD59x18.div(\n            PRBMathSD59x18.log2(int256(price_)),\n            PRBMathSD59x18.log2(FLOAT_STEP_INT)\n        );\n\n        int256 ceilIndex = PRBMathSD59x18.ceil(index);\n        if (index < 0 && ceilIndex - index > 0.5 * 1e18) {\n            return uint256(4157 - PRBMathSD59x18.toInt(ceilIndex));\n        }\n        return uint256(4156 - PRBMathSD59x18.toInt(ceilIndex));\n    }\n\n    /**********************/\n    /*** Pool Utilities ***/\n    /**********************/\n\n    /**\n     *  @notice Calculates the minimum debt amount that can be borrowed or can remain in a loan in pool.\n     *  @param  debt_          The debt amount to calculate minimum debt amount for.\n     *  @param  loansCount_    The number of loans in pool.\n     *  @return minDebtAmount_ Minimum debt amount value of the pool.\n     */\n    function _minDebtAmount(\n        uint256 debt_,\n        uint256 loansCount_\n    ) pure returns (uint256 minDebtAmount_) {\n        if (loansCount_ != 0) {\n            minDebtAmount_ = Maths.wdiv(Maths.wdiv(debt_, Maths.wad(loansCount_)), 10**19);\n        }\n    }\n\n    /**\n     *  @notice Calculates origination fee for a given interest rate.\n     *  @notice Calculated as greater of the current annualized interest rate divided by `52` (one week of interest) or `5` bps.\n     *  @param  interestRate_ The current interest rate.\n     *  @return Fee rate based upon the given interest rate.\n     */\n    function _borrowFeeRate(\n        uint256 interestRate_\n    ) pure returns (uint256) {\n        // greater of the current annualized interest rate divided by 52 (one week of interest) or 5 bps\n        return Maths.max(Maths.wdiv(interestRate_, 52 * 1e18), 0.0005 * 1e18);\n    }\n\n    /**\n     * @notice Calculates the unutilized deposit fee, charged to lenders who deposit below the `LUP`.\n     * @param  interestRate_ The current interest rate.\n     * @return Fee rate based upon the given interest rate, capped at 10%.\n     */\n    function _depositFeeRate(\n        uint256 interestRate_\n    ) pure returns (uint256) {\n        // current annualized rate divided by 365 (24 hours of interest), capped at 10%\n        return Maths.min(Maths.wdiv(interestRate_, 365 * 1e18), 0.1 * 1e18);\n    }\n\n    /**\n     *  @notice Calculates debt-weighted average threshold price.\n     *  @param  t0Debt_              Pool debt owed by borrowers in `t0` terms.\n     *  @param  inflator_            Pool's borrower inflator.\n     *  @param  t0Debt2ToCollateral_ `t0-debt-squared-to-collateral` accumulator. \n     */\n    function _dwatp(\n        uint256 t0Debt_,\n        uint256 inflator_,\n        uint256 t0Debt2ToCollateral_\n    ) pure returns (uint256) {\n        return t0Debt_ == 0 ? 0 : Maths.wdiv(Maths.wmul(inflator_, t0Debt2ToCollateral_), t0Debt_);\n    }\n\n    /**\n     *  @notice Collateralization calculation.\n     *  @param debt_       Debt to calculate collateralization for.\n     *  @param collateral_ Collateral to calculate collateralization for.\n     *  @param price_      Price to calculate collateralization for.\n     *  @param type_       Type of the pool.\n     *  @return `True` if collateralization calculated is equal or greater than `1`.\n     */\n    function _isCollateralized(\n        uint256 debt_,\n        uint256 collateral_,\n        uint256 price_,\n        uint8 type_\n    ) pure returns (bool) {\n        if (type_ == uint8(PoolType.ERC20)) return Maths.wmul(collateral_, price_) >= debt_;\n        else {\n            //slither-disable-next-line divide-before-multiply\n            collateral_ = (collateral_ / Maths.WAD) * Maths.WAD; // use collateral floor\n            return Maths.wmul(collateral_, price_) >= debt_;\n        }\n    }\n\n    /**\n     *  @notice Price precision adjustment used in calculating collateral dust for a bucket.\n     *          To ensure the accuracy of the exchange rate calculation, buckets with smaller prices require\n     *          larger minimum amounts of collateral.  This formula imposes a lower bound independent of token scale.\n     *  @param  bucketIndex_              Index of the bucket, or `0` for encumbered collateral with no bucket affinity.\n     *  @return pricePrecisionAdjustment_ Unscaled integer of the minimum number of decimal places the dust limit requires.\n     */\n    function _getCollateralDustPricePrecisionAdjustment(\n        uint256 bucketIndex_\n    ) pure returns (uint256 pricePrecisionAdjustment_) {\n        // conditional is a gas optimization\n        if (bucketIndex_ > 3900) {\n            int256 bucketOffset = int256(bucketIndex_ - 3900);\n            int256 result = PRBMathSD59x18.sqrt(PRBMathSD59x18.div(bucketOffset * 1e18, int256(36 * 1e18)));\n            pricePrecisionAdjustment_ = uint256(result / 1e18);\n        }\n    }\n\n    /**\n     *  @notice Returns the amount of collateral calculated for the given amount of `LP`.\n     *  @dev    The value returned is capped at collateral amount available in bucket.\n     *  @param  bucketCollateral_ Amount of collateral in bucket.\n     *  @param  bucketLP_         Amount of `LP` in bucket.\n     *  @param  deposit_          Current bucket deposit (quote tokens). Used to calculate bucket's exchange rate / `LP`.\n     *  @param  lenderLPBalance_  The amount of `LP` to calculate collateral for.\n     *  @param  bucketPrice_      Bucket's price.\n     *  @return collateralAmount_ Amount of collateral calculated for the given `LP `amount.\n     */\n    function _lpToCollateral(\n        uint256 bucketCollateral_,\n        uint256 bucketLP_,\n        uint256 deposit_,\n        uint256 lenderLPBalance_,\n        uint256 bucketPrice_\n    ) pure returns (uint256 collateralAmount_) {\n        collateralAmount_ = Buckets.lpToCollateral(\n            bucketCollateral_,\n            bucketLP_,\n            deposit_,\n            lenderLPBalance_,\n            bucketPrice_,\n            Math.Rounding.Down\n        );\n\n        if (collateralAmount_ > bucketCollateral_) {\n            // user is owed more collateral than is available in the bucket\n            collateralAmount_ = bucketCollateral_;\n        }\n    }\n\n    /**\n     *  @notice Returns the amount of quote tokens calculated for the given amount of `LP`.\n     *  @dev    The value returned is capped at available bucket deposit.\n     *  @param  bucketLP_         Amount of `LP` in bucket.\n     *  @param  bucketCollateral_ Amount of collateral in bucket.\n     *  @param  deposit_          Current bucket deposit (quote tokens). Used to calculate bucket's exchange rate / `LP`.\n     *  @param  lenderLPBalance_  The amount of `LP` to calculate quote token amount for.\n     *  @param  maxQuoteToken_    The max quote token amount to calculate `LP` for.\n     *  @param  bucketPrice_      Bucket's price.\n     *  @return quoteTokenAmount_ Amount of quote tokens calculated for the given `LP` amount, capped at available bucket deposit.\n     */\n    function _lpToQuoteToken(\n        uint256 bucketLP_,\n        uint256 bucketCollateral_,\n        uint256 deposit_,\n        uint256 lenderLPBalance_,\n        uint256 maxQuoteToken_,\n        uint256 bucketPrice_\n    ) pure returns (uint256 quoteTokenAmount_) {\n        quoteTokenAmount_ = Buckets.lpToQuoteTokens(\n            bucketCollateral_,\n            bucketLP_,\n            deposit_,\n            lenderLPBalance_,\n            bucketPrice_,\n            Math.Rounding.Down\n        );\n\n        if (quoteTokenAmount_ > deposit_)       quoteTokenAmount_ = deposit_;\n        if (quoteTokenAmount_ > maxQuoteToken_) quoteTokenAmount_ = maxQuoteToken_;\n    }\n\n    /**\n     *  @notice Rounds a token amount down to the minimum amount permissible by the token scale.\n     *  @param  amount_       Value to be rounded.\n     *  @param  tokenScale_   Scale of the token, presented as a power of `10`.\n     *  @return scaledAmount_ Rounded value.\n     */\n    function _roundToScale(\n        uint256 amount_,\n        uint256 tokenScale_\n    ) pure returns (uint256 scaledAmount_) {\n        scaledAmount_ = (amount_ / tokenScale_) * tokenScale_;\n    }\n\n    /**\n     *  @notice Rounds a token amount up to the next amount permissible by the token scale.\n     *  @param  amount_       Value to be rounded.\n     *  @param  tokenScale_   Scale of the token, presented as a power of `10`.\n     *  @return scaledAmount_ Rounded value.\n     */\n    function _roundUpToScale(\n        uint256 amount_,\n        uint256 tokenScale_\n    ) pure returns (uint256 scaledAmount_) {\n        if (amount_ % tokenScale_ == 0)\n            scaledAmount_ = amount_;\n        else\n            scaledAmount_ = _roundToScale(amount_, tokenScale_) + tokenScale_;\n    }\n\n    /*********************************/\n    /*** Reserve Auction Utilities ***/\n    /*********************************/\n\n    uint256 constant MINUTE_HALF_LIFE    = 0.988514020352896135_356867505 * 1e27;  // 0.5^(1/60)\n\n    /**\n     *  @notice Calculates claimable reserves within the pool.\n     *  @dev    Claimable reserve auctions and escrowed auction bonds are guaranteed by the pool.\n     *  @param  debt_                    Pool's debt.\n     *  @param  poolSize_                Pool's deposit size.\n     *  @param  totalBondEscrowed_       Total bond escrowed.\n     *  @param  reserveAuctionUnclaimed_ Pool's unclaimed reserve auction.\n     *  @param  quoteTokenBalance_       Pool's quote token balance.\n     *  @return claimable_               Calculated pool reserves.\n     */  \n    function _claimableReserves(\n        uint256 debt_,\n        uint256 poolSize_,\n        uint256 totalBondEscrowed_,\n        uint256 reserveAuctionUnclaimed_,\n        uint256 quoteTokenBalance_\n    ) pure returns (uint256 claimable_) {\n        uint256 guaranteedFunds = totalBondEscrowed_ + reserveAuctionUnclaimed_;\n\n        // calculate claimable reserves if there's quote token excess\n        if (quoteTokenBalance_ > guaranteedFunds) {\n            claimable_ = Maths.wmul(0.995 * 1e18, debt_) + quoteTokenBalance_;\n\n            claimable_ -= Maths.min(\n                claimable_,\n                // require 1.0 + 1e-9 deposit buffer (extra margin) for deposits\n                Maths.wmul(DEPOSIT_BUFFER, poolSize_) + guaranteedFunds\n            );\n\n            // incremental claimable reserve should not exceed excess quote in pool\n            claimable_ = Maths.min(\n                claimable_,\n                quoteTokenBalance_ - guaranteedFunds\n            );\n        }\n    }\n\n    /**\n     *  @notice Calculates reserves auction price.\n     *  @param  reserveAuctionKicked_ Time when reserve auction was started (kicked).\n     *  @return price_                Calculated auction price.\n     */     \n    function _reserveAuctionPrice(\n        uint256 reserveAuctionKicked_\n    ) view returns (uint256 price_) {\n        if (reserveAuctionKicked_ != 0) {\n            uint256 secondsElapsed   = block.timestamp - reserveAuctionKicked_;\n            uint256 hoursComponent   = 1e27 >> secondsElapsed / 3600;\n            uint256 minutesComponent = Maths.rpow(MINUTE_HALF_LIFE, secondsElapsed % 3600 / 60);\n\n            price_ = Maths.rayToWad(1_000_000_000 * Maths.rmul(hoursComponent, minutesComponent));\n        }\n    }\n\n    /*************************/\n    /*** Auction Utilities ***/\n    /*************************/\n\n    /**\n     *  @notice Calculates auction price.\n     *  @param  referencePrice_ Recorded at kick, used to calculate start price.\n     *  @param  kickTime_       Time when auction was kicked.\n     *  @return price_          Calculated auction price.\n     */\n    function _auctionPrice(\n        uint256 referencePrice_,\n        uint256 kickTime_\n    ) view returns (uint256 price_) {\n        uint256 elapsedMinutes = Maths.wdiv((block.timestamp - kickTime_) * 1e18, 1 minutes * 1e18);\n\n        int256 timeAdjustment;\n        if (elapsedMinutes < 120 * 1e18) {\n            timeAdjustment = PRBMathSD59x18.mul(-1 * 1e18, int256(elapsedMinutes / 20));\n            price_ = 256 * Maths.wmul(referencePrice_, uint256(PRBMathSD59x18.exp2(timeAdjustment)));\n        } else if (elapsedMinutes < 840 * 1e18) {\n            timeAdjustment = PRBMathSD59x18.mul(-1 * 1e18, int256((elapsedMinutes - 120 * 1e18) / 120));\n            price_ = 4 * Maths.wmul(referencePrice_, uint256(PRBMathSD59x18.exp2(timeAdjustment)));\n        } else {\n            timeAdjustment = PRBMathSD59x18.mul(-1 * 1e18, int256((elapsedMinutes - 840 * 1e18) / 60));\n            price_ = Maths.wmul(referencePrice_, uint256(PRBMathSD59x18.exp2(timeAdjustment))) / 16;\n        }\n    }\n\n    /**\n     *  @notice Calculates bond penalty factor.\n     *  @dev    Called in kick and take.\n     *  @param debt_         Borrower debt.\n     *  @param collateral_   Borrower collateral.\n     *  @param neutralPrice_ `NP` of auction.\n     *  @param bondFactor_   Factor used to determine bondSize.\n     *  @param auctionPrice_ Auction price at the time of call.\n     *  @return bpf_         Factor used in determining bond `reward` (positive) or `penalty` (negative).\n     */\n    function _bpf(\n        uint256 debt_,\n        uint256 collateral_,\n        uint256 neutralPrice_,\n        uint256 bondFactor_,\n        uint256 auctionPrice_\n    ) pure returns (int256) {\n        int256 thresholdPrice = int256(Maths.wdiv(debt_, collateral_));\n\n        int256 sign;\n        if (thresholdPrice < int256(neutralPrice_)) {\n            // BPF = BondFactor * min(1, max(-1, (neutralPrice - price) / (neutralPrice - thresholdPrice)))\n            sign = Maths.minInt(\n                1e18,\n                Maths.maxInt(\n                    -1 * 1e18,\n                    PRBMathSD59x18.div(\n                        int256(neutralPrice_) - int256(auctionPrice_),\n                        int256(neutralPrice_) - thresholdPrice\n                    )\n                )\n            );\n        } else {\n            int256 val = int256(neutralPrice_) - int256(auctionPrice_);\n            if (val < 0 )      sign = -1e18;\n            else if (val != 0) sign = 1e18;\n        }\n\n        return PRBMathSD59x18.mul(int256(bondFactor_), sign);\n    }\n\n    /**\n     *  @notice Calculates bond parameters of an auction.\n     *  @param  borrowerDebt_   Borrower's debt before entering in liquidation.\n     *  @param  npTpRatio_      Borrower's Np to Tp ratio\n     */\n    function _bondParams(\n        uint256 borrowerDebt_,\n        uint256 npTpRatio_\n    ) pure returns (uint256 bondFactor_, uint256 bondSize_) {\n        // bondFactor = min((NP-to-TP-ratio - 1)/10, 0.03)\n        bondFactor_ = Maths.min(\n            0.03 * 1e18,\n            (npTpRatio_ - 1e18) / 10\n        );\n\n        bondSize_ = Maths.wmul(bondFactor_,  borrowerDebt_);\n    }"
    },
    {
      "filename": "ajna-core/src/libraries/external/SettlerActions.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.18;\n\nimport { PoolType } from '../../interfaces/pool/IPool.sol';\n\nimport {\n    AuctionsState,\n    Borrower,\n    Bucket,\n    DepositsState,\n    Kicker,\n    Liquidation,\n    LoansState,\n    PoolState,\n    ReserveAuctionState\n}                       from '../../interfaces/pool/commons/IPoolState.sol';\nimport {\n    SettleParams,\n    SettleResult\n}                       from '../../interfaces/pool/commons/IPoolInternals.sol';\n\nimport {\n    _auctionPrice,\n    _indexOf,\n    _priceAt,\n    MAX_FENWICK_INDEX,\n    MIN_PRICE,\n    DEPOSIT_BUFFER   \n}  from '../helpers/PoolHelper.sol';\n\nimport { Buckets }  from '../internal/Buckets.sol';\nimport { Deposits } from '../internal/Deposits.sol';\nimport { Loans }    from '../internal/Loans.sol';\nimport { Maths }    from '../internal/Maths.sol';\n\n/**\n    @title  Auction settler library\n    @notice External library containing actions involving auctions within pool:\n            - `settle` auctions\n */\nlibrary SettlerActions {\n\n    /*************************/\n    /*** Local Var Structs ***/\n    /*************************/\n\n    /// @dev Struct used for `_settlePoolDebtWithDeposit` function local vars.\n    struct SettleLocalVars {\n        uint256 collateralUsed;     // [WAD] collateral used to settle debt\n        uint256 debt;               // [WAD] debt to settle\n        uint256 hpbCollateral;      // [WAD] amount of collateral in HPB bucket\n        uint256 hpbUnscaledDeposit; // [WAD] unscaled amount of of quote tokens in HPB bucket before settle\n        uint256 hpbLP;              // [WAD] amount of LP in HPB bucket\n        uint256 index;              // index of settling bucket\n        uint256 maxSettleableDebt;  // [WAD] max amount that can be settled with existing collateral\n        uint256 price;              // [WAD] price of settling bucket\n        uint256 scaledDeposit;      // [WAD] scaled amount of quote tokens in bucket\n        uint256 scale;              // [WAD] scale of settling bucket\n        uint256 unscaledDeposit;    // [WAD] unscaled amount of quote tokens in bucket\n    }\n\n    /**************/\n    /*** Events ***/\n    /**************/\n\n    // See `IPoolEvents` for descriptions\n    event AuctionSettle(address indexed borrower, uint256 collateral);\n    event AuctionNFTSettle(address indexed borrower, uint256 collateral, uint256 lp, uint256 index);\n    event BucketBankruptcy(uint256 indexed index, uint256 lpForfeited);\n    event Settle(address indexed borrower, uint256 settledDebt);\n\n    /**************/\n    /*** Errors ***/\n    /**************/\n\n    // See `IPoolErrors` for descriptions\n    error AuctionNotClearable();\n    error NoAuction();\n\n    /***************************/\n    /***  External Functions ***/\n    /***************************/\n\n    /**\n     *  @notice See `IPoolSettlerActions` for descriptions.\n     *  @notice Settles the debt of the given loan / borrower by performing following steps:\n     *          1. settle debt with `HPB`s deposit, up to specified buckets depth.\n     *          2. settle debt with pool reserves (if there's still debt and no collateral left after step 1).\n     *          3. forgive bad debt from next `HPB`, up to remaining buckets depth (and if there's still debt after step 2).\n     *  @dev    === Write state ===\n     *  @dev    update borrower state\n     *  @dev    === Reverts on ===\n     *  @dev    loan is not in auction `NoAuction()`\n     *  @dev    `72` hours didn't pass and auction still has collateral `AuctionNotClearable()`\n     *  @dev    === Emit events ===\n     *  @dev    - `Settle`\n     *  @return result_ The `SettleResult` struct result of settle action.\n     */\n    function settlePoolDebt(\n        AuctionsState storage auctions_,\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        LoansState storage loans_,\n        ReserveAuctionState storage reserveAuction_,\n        PoolState calldata poolState_,\n        SettleParams memory params_\n    ) external returns (SettleResult memory result_) {\n        uint256 kickTime = auctions_.liquidations[params_.borrower].kickTime;\n        if (kickTime == 0) revert NoAuction();\n\n        Borrower memory borrower = loans_.borrowers[params_.borrower];\n        if ((block.timestamp - kickTime <= 72 hours) && (borrower.collateral != 0)) revert AuctionNotClearable();\n\n        result_.debtPreAction       = borrower.t0Debt;\n        result_.collateralPreAction = borrower.collateral;\n        result_.t0DebtSettled       = borrower.t0Debt;\n        result_.collateralSettled   = borrower.collateral;\n\n        // 1. settle debt with HPB deposit\n        (\n            borrower.t0Debt,\n            borrower.collateral,\n            params_.bucketDepth\n        ) = _settlePoolDebtWithDeposit(\n            buckets_,\n            deposits_,\n            params_,\n            borrower,\n            poolState_.inflator\n        );\n\n        if (borrower.t0Debt != 0 && borrower.collateral == 0) {\n            // 2. settle debt with pool reserves\n            uint256 assets = Maths.floorWmul(poolState_.t0Debt - result_.t0DebtSettled + borrower.t0Debt, poolState_.inflator) + params_.poolBalance;\n\n            uint256 liabilities =\n                // require 1.0 + 1e-9 deposit buffer (extra margin) for deposits\n                Maths.wmul(DEPOSIT_BUFFER, Deposits.treeSum(deposits_)) +\n                auctions_.totalBondEscrowed +\n                reserveAuction_.unclaimed;\n\n            // settle debt from reserves (assets - liabilities) if reserves positive, round reserves down however\n            if (assets > liabilities) {\n                borrower.t0Debt -= Maths.min(borrower.t0Debt, Maths.floorWdiv(assets - liabilities, poolState_.inflator));\n            }\n\n            // 3. forgive bad debt from next HPB\n            if (borrower.t0Debt != 0) {\n                borrower.t0Debt = _forgiveBadDebt(\n                    buckets_,\n                    deposits_,\n                    params_,\n                    borrower,\n                    poolState_.inflator\n                );\n            }\n        }\n\n        // complete result struct with debt settled\n        result_.t0DebtSettled -= borrower.t0Debt;\n\n        emit Settle(\n            params_.borrower,\n            result_.t0DebtSettled\n        );\n\n        // if entire debt was settled then settle auction\n        if (borrower.t0Debt == 0) {\n            (borrower.collateral, ) = _settleAuction(\n                auctions_,\n                buckets_,\n                deposits_,\n                params_.borrower,\n                borrower.collateral,\n                poolState_.poolType\n            );\n        }\n\n        // complete result struct with debt and collateral post action and collateral settled\n        result_.debtPostAction      = borrower.t0Debt;\n        result_.collateralRemaining = borrower.collateral;\n        result_.collateralSettled   -= result_.collateralRemaining;\n\n        // update borrower state\n        loans_.borrowers[params_.borrower] = borrower;\n    }\n\n    /***************************/\n    /***  Internal Functions ***/\n    /***************************/\n\n    /**\n     *  @notice Performs auction settle based on pool type, emits settle event and removes auction from auctions queue.\n     *  @dev    === Emit events ===\n     *  @dev    - `AuctionNFTSettle` or `AuctionSettle`\n     *  @param  auctions_              Struct for pool auctions state.\n     *  @param  buckets_               Struct for pool buckets state.\n     *  @param  deposits_              Struct for pool deposits state.\n     *  @param  borrowerAddress_       Address of the borrower that exits auction.\n     *  @param  borrowerCollateral_    Borrower collateral amount before auction exit (in `NFT` could be fragmented as result of partial takes).\n     *  @param  poolType_              Type of the pool (can be `ERC20` or `ERC721`).\n     *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for `ERC20` pool, rounded collateral for `ERC721` pool).\n     *  @return compensatedCollateral_ Amount of collateral compensated (`ERC721` settle only), to be deducted from pool pledged collateral accumulator. Always `0` for `ERC20` pools.\n     */\n    function _settleAuction(\n        AuctionsState storage auctions_,\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        address borrowerAddress_,\n        uint256 borrowerCollateral_,\n        uint256 poolType_\n    ) internal returns (uint256 remainingCollateral_, uint256 compensatedCollateral_) {\n\n        if (poolType_ == uint8(PoolType.ERC721)) {\n            uint256 lp;\n            uint256 bucketIndex;\n\n            // floor collateral of borrower\n            remainingCollateral_ = (borrowerCollateral_ / Maths.WAD) * Maths.WAD;\n\n            // if there's fraction of NFTs remaining then reward difference to borrower as LP in auction price bucket\n            if (remainingCollateral_ != borrowerCollateral_) {\n\n                // calculate the amount of collateral that should be compensated with LP\n                compensatedCollateral_ = borrowerCollateral_ - remainingCollateral_;\n\n                uint256 auctionPrice = _auctionPrice(\n                    auctions_.liquidations[borrowerAddress_].referencePrice,\n                    auctions_.liquidations[borrowerAddress_].kickTime\n                );\n\n                // determine the bucket index to compensate fractional collateral\n                bucketIndex = auctionPrice > MIN_PRICE ? _indexOf(auctionPrice) : MAX_FENWICK_INDEX;\n\n                // deposit collateral in bucket and reward LP to compensate fractional collateral\n                lp = Buckets.addCollateral(\n                    buckets_[bucketIndex],\n                    borrowerAddress_,\n                    Deposits.valueAt(deposits_, bucketIndex),\n                    compensatedCollateral_,\n                    _priceAt(bucketIndex)\n                );\n            }\n\n            emit AuctionNFTSettle(\n                borrowerAddress_,\n                remainingCollateral_,\n                lp,\n                bucketIndex\n            );\n\n        } else {\n            remainingCollateral_ = borrowerCollateral_;\n\n            emit AuctionSettle(\n                borrowerAddress_,\n                remainingCollateral_\n            );\n        }\n\n        _removeAuction(auctions_, borrowerAddress_);\n    }\n\n    /**\n     *  @notice Removes auction and repairs the queue order.\n     *  @notice Updates kicker's claimable balance with bond size awarded and subtracts bond size awarded from `liquidationBondEscrowed`.\n     *  @dev    === Write state ===\n     *  @dev    decrement kicker locked accumulator, increment kicker claimable accumumlator\n     *  @dev    decrement auctions count accumulator\n     *  @dev    update auction queue state\n     *  @param  auctions_ Struct for pool auctions state.\n     *  @param  borrower_ Auctioned borrower address.\n     */\n    function _removeAuction(\n        AuctionsState storage auctions_,\n        address borrower_\n    ) internal {\n        Liquidation memory liquidation = auctions_.liquidations[borrower_];\n        // update kicker balances\n        Kicker storage kicker = auctions_.kickers[liquidation.kicker];\n\n        kicker.locked    -= liquidation.bondSize;\n        kicker.claimable += liquidation.bondSize;\n\n        // decrement number of active auctions\n        -- auctions_.noOfAuctions;\n\n        // update auctions queue\n        if (auctions_.head == borrower_ && auctions_.tail == borrower_) {\n            // liquidation is the head and tail\n            auctions_.head = address(0);\n            auctions_.tail = address(0);\n        }\n        else if(auctions_.head == borrower_) {\n            // liquidation is the head\n            auctions_.liquidations[liquidation.next].prev = address(0);\n            auctions_.head = liquidation.next;\n        }\n        else if(auctions_.tail == borrower_) {\n            // liquidation is the tail\n            auctions_.liquidations[liquidation.prev].next = address(0);\n            auctions_.tail = liquidation.prev;\n        }\n        else {\n            // liquidation is in the middle\n            auctions_.liquidations[liquidation.prev].next = liquidation.next;\n            auctions_.liquidations[liquidation.next].prev = liquidation.prev;\n        }\n        // delete liquidation\n        delete auctions_.liquidations[borrower_];\n    }\n\n    /**\n     *  @notice Called to settle debt using `HPB` deposits, up to the number of specified buckets depth.\n     *  @dev    === Write state ===\n     *  @dev    - `Deposits.unscaledRemove()` (remove amount in `Fenwick` tree, from index):\n     *  @dev      update `values` array state\n     *  @dev    - `Buckets.addCollateral`:\n     *  @dev      increment `bucket.collateral` and `bucket.lps` accumulator\n     *  @dev      increment `lender.lps` accumulator and `lender.depositTime` state\n     *  @dev    === Emit events ===\n     *  @dev    - `BucketBankruptcy`\n     *  @param  buckets_             Struct for pool buckets state.\n     *  @param  deposits_            Struct for pool deposits state.\n     *  @param  params_              Struct containing params for settle action.\n     *  @param  borrower_            Struct containing borrower details.\n     *  @param  inflator_            Current pool inflator.\n     *  @return remainingt0Debt_     Remaining borrower `t0` debt after settle with `HPB`.\n     *  @return remainingCollateral_ Remaining borrower collateral after settle with `HPB`.\n     *  @return bucketDepth_         Number of buckets to use for forgiving debt in case there's more remaining.\n     */\n    function _settlePoolDebtWithDeposit(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        SettleParams memory params_,\n        Borrower memory borrower_,\n        uint256 inflator_\n    ) internal returns (uint256 remainingt0Debt_, uint256 remainingCollateral_, uint256 bucketDepth_) {\n        remainingt0Debt_     = borrower_.t0Debt;\n        remainingCollateral_ = borrower_.collateral;\n        bucketDepth_         = params_.bucketDepth;\n\n        while (bucketDepth_ != 0 && remainingt0Debt_ != 0 && remainingCollateral_ != 0) {\n            SettleLocalVars memory vars;\n\n            (vars.index, , vars.scale) = Deposits.findIndexAndSumOfSum(deposits_, 1);\n            vars.hpbUnscaledDeposit    = Deposits.unscaledValueAt(deposits_, vars.index);\n            vars.unscaledDeposit       = vars.hpbUnscaledDeposit;\n            vars.price"
    }
  ]
}