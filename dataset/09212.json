{
  "Title": "[M-03] DoS in wrap and unwrap",
  "Content": "_Submitted by CertoraInc_\n\n[FuseTokenAdapterV1.sol#L76](https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/adapters/fuse/FuseTokenAdapterV1.sol#L76)<br>\n[FuseTokenAdapterV1.sol#L98](https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/adapters/fuse/FuseTokenAdapterV1.sol#L98)<br>\n\nThe code is doing wrong check, so when things will work it will revert.\n\n### Proof of Concept\n\nIn the function `wrap()` there is this lines:\n\n       if ((error = ICERC20(token).mint(amount)) != NO_ERROR) {\n                revert FuseError(error);\n            }\n\nbut `mint` returns the amount that minted, so when `error = amount` the check will fail even though it worked good.\n\nSame in `unwrap`:\n\n    if ((error = ICERC20(token).redeem(amount)) != NO_ERROR) {\n                revert FuseError(error);\n            }\n\nthe redeem returns the amount.\n\n### Recommended Mitigation Steps\n\nI recommend to change the lines like this:\nin wrap:\n`      if ((error = ICERC20(token).mint(amount)) != amount) {\n            revert FuseError(error);\n        }\n    `\nand in unwrap:\n`     if ((error = ICERC20(token).redeem(amount)) != amount) {\n            revert FuseError(error);\n        }\n    `\n\n**[0xfoobar (Alchemix) confirmed, disagreed with severity and commented](https://github.com/code-423n4/2022-05-alchemix-findings/issues/159#issuecomment-1133987052):**\n > This would not cause any loss of user funds because the deposit function would revert, but it is a needed fix in the Fuse Adapter. So recommend a lower severity.\n\n**[0xleastwood (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-05-alchemix-findings/issues/159#issuecomment-1146198103):**\n > As no assets are at risk, medium risk seems correct because only the availability of the protocol is impacted.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-alchemix-contest",
  "Code": [
    {
      "filename": "contracts-full/adapters/fuse/FuseTokenAdapterV1.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\n\nimport {\n    IllegalArgument,\n    IllegalState,\n    Unauthorized,\n    UnsupportedOperation\n} from \"../../base/Errors.sol\";\n\nimport {Mutex} from \"../../base/Mutex.sol\";\n\nimport {LibFuse} from \"../../libraries/LibFuse.sol\";\nimport {SafeERC20} from \"../../libraries/SafeERC20.sol\";\n\nimport {ICERC20} from \"../../interfaces/external/compound/ICERC20.sol\";\nimport {ITokenAdapter} from \"../../interfaces/ITokenAdapter.sol\";\nimport {IWETH9} from \"../../interfaces/external/IWETH9.sol\";\n\nstruct InitializationParams {\n    address alchemist;\n    address token;\n    address underlyingToken;\n}\n\ncontract FuseTokenAdapterV1 is ITokenAdapter, Mutex {\n    string public override version = \"1.0.0\";\n\n    address public immutable alchemist;\n    address public immutable override token;\n    address public immutable override underlyingToken;\n\n    /// @dev Fuse error code for a noop.\n    uint256 private constant NO_ERROR = 0;\n\n    /// @dev Scalar for all fixed point numbers returned by Fuse.\n    uint256 private constant FIXED_POINT_SCALAR = 1e18;\n\n    /// @notice An error used when a call to Fuse fails.\n    ///\n    /// @param code The error code.\n    error FuseError(uint256 code);\n\n    constructor(InitializationParams memory params) {\n        alchemist       = params.alchemist;\n        token           = params.token;\n        underlyingToken = params.underlyingToken;\n    }\n\n    /// @dev Checks that the message sender is the alchemist that the adapter is bound to.\n    modifier onlyAlchemist() {\n        if (msg.sender != alchemist) {\n            revert Unauthorized(\"Not alchemist\");\n        }\n        _;\n    }\n\n    /// @inheritdoc ITokenAdapter\n    function price() external view returns (uint256) {\n        return LibFuse.viewExchangeRate(ICERC20(token));\n    }\n\n    /// @inheritdoc ITokenAdapter\n    function wrap(\n        uint256 amount,\n        address recipient\n    ) external onlyAlchemist returns (uint256) {\n        SafeERC20.safeTransferFrom(underlyingToken, msg.sender, address(this), amount);\n        SafeERC20.safeApprove(underlyingToken, token, amount);\n\n        uint256 startingBalance = IERC20(token).balanceOf(address(this));\n\n        uint256 error;\n        if ((error = ICERC20(token).mint(amount)) != NO_ERROR) {\n            revert FuseError(error);\n        }\n\n        uint256 endingBalance = IERC20(token).balanceOf(address(this));\n        uint256 mintedAmount = endingBalance - startingBalance;\n\n        SafeERC20.safeTransfer(token, recipient, mintedAmount);\n\n        return mintedAmount;\n    }\n\n    // @inheritdoc ITokenAdapter\n    function unwrap(\n        uint256 amount,\n        address recipient\n    ) external lock onlyAlchemist returns (uint256) {\n        SafeERC20.safeTransferFrom(token, msg.sender, address(this), amount);\n\n        uint256 startingBalance = IERC20(underlyingToken).balanceOf(address(this));\n\n        uint256 error;\n        if ((error = ICERC20(token).redeem(amount)) != NO_ERROR) {\n            revert FuseError(error);\n        }\n\n        uint256 endingBalance = IERC20(underlyingToken).balanceOf(address(this));\n        uint256 redeemedAmount = endingBalance - startingBalance;\n\n        SafeERC20.safeTransfer(underlyingToken, recipient, redeemedAmount);\n\n        return redeemedAmount;\n    }\n}"
    },
    {
      "filename": "contracts-full/adapters/fuse/FuseTokenAdapterV1.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\n\nimport {\n    IllegalArgument,\n    IllegalState,\n    Unauthorized,\n    UnsupportedOperation\n} from \"../../base/Errors.sol\";\n\nimport {Mutex} from \"../../base/Mutex.sol\";\n\nimport {LibFuse} from \"../../libraries/LibFuse.sol\";\nimport {SafeERC20} from \"../../libraries/SafeERC20.sol\";\n\nimport {ICERC20} from \"../../interfaces/external/compound/ICERC20.sol\";\nimport {ITokenAdapter} from \"../../interfaces/ITokenAdapter.sol\";\nimport {IWETH9} from \"../../interfaces/external/IWETH9.sol\";\n\nstruct InitializationParams {\n    address alchemist;\n    address token;\n    address underlyingToken;\n}\n\ncontract FuseTokenAdapterV1 is ITokenAdapter, Mutex {\n    string public override version = \"1.0.0\";\n\n    address public immutable alchemist;\n    address public immutable override token;\n    address public immutable override underlyingToken;\n\n    /// @dev Fuse error code for a noop.\n    uint256 private constant NO_ERROR = 0;\n\n    /// @dev Scalar for all fixed point numbers returned by Fuse.\n    uint256 private constant FIXED_POINT_SCALAR = 1e18;\n\n    /// @notice An error used when a call to Fuse fails.\n    ///\n    /// @param code The error code.\n    error FuseError(uint256 code);\n\n    constructor(InitializationParams memory params) {\n        alchemist       = params.alchemist;\n        token           = params.token;\n        underlyingToken = params.underlyingToken;\n    }\n\n    /// @dev Checks that the message sender is the alchemist that the adapter is bound to.\n    modifier onlyAlchemist() {\n        if (msg.sender != alchemist) {\n            revert Unauthorized(\"Not alchemist\");\n        }\n        _;\n    }\n\n    /// @inheritdoc ITokenAdapter\n    function price() external view returns (uint256) {\n        return LibFuse.viewExchangeRate(ICERC20(token));\n    }\n\n    /// @inheritdoc ITokenAdapter\n    function wrap(\n        uint256 amount,\n        address recipient\n    ) external onlyAlchemist returns (uint256) {\n        SafeERC20.safeTransferFrom(underlyingToken, msg.sender, address(this), amount);\n        SafeERC20.safeApprove(underlyingToken, token, amount);\n\n        uint256 startingBalance = IERC20(token).balanceOf(address(this));\n\n        uint256 error;\n        if ((error = ICERC20(token).mint(amount)) != NO_ERROR) {\n            revert FuseError(error);\n        }\n\n        uint256 endingBalance = IERC20(token).balanceOf(address(this));\n        uint256 mintedAmount = endingBalance - startingBalance;\n\n        SafeERC20.safeTransfer(token, recipient, mintedAmount);\n\n        return mintedAmount;\n    }\n\n    // @inheritdoc ITokenAdapter\n    function unwrap(\n        uint256 amount,\n        address recipient\n    ) external lock onlyAlchemist returns (uint256) {\n        SafeERC20.safeTransferFrom(token, msg.sender, address(this), amount);\n\n        uint256 startingBalance = IERC20(underlyingToken).balanceOf(address(this));\n\n        uint256 error;\n        if ((error = ICERC20(token).redeem(amount)) != NO_ERROR) {\n            revert FuseError(error);\n        }\n\n        uint256 endingBalance = IERC20(underlyingToken).balanceOf(address(this));\n        uint256 redeemedAmount = endingBalance - startingBalance;\n\n        SafeERC20.safeTransfer(underlyingToken, recipient, redeemedAmount);\n\n        return redeemedAmount;\n    }\n}"
    }
  ]
}