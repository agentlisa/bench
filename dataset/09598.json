{
  "Title": "[M-05] Updating rate limit for addresses restores their entire buffer amount",
  "Content": "_Submitted by cmichel_\n\n[MultiRateLimited.sol#L280](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/utils/MultiRateLimited.sol#L280)<br>\n\nWhen the `bufferCap` is updated for an address in `_updateAddress`, the address's allowed buffer (`bufferStored`) is replenished to the entire `bufferCap`.\n\nThe address could frontrun the `updateAddress` call and spend their entire buffer, then the buffer is replenished and they can spend their entire buffer a second time.\n\n### Recommended Mitigation Steps\n\nKeep the old buffer value, capped by the new `bufferCap`:\n\n```diff\n+ uint256 newBuffer = individualBuffer(rateLimitedAddress);\n\n  rateLimitData.lastBufferUsedTime = block.timestamp.toUint32();\n  rateLimitData.bufferCap = _bufferCap;\n  rateLimitData.rateLimitPerSecond = _rateLimitPerSecond;\n- rateLimitData.bufferStored = _bufferCap;\n+ rateLimitData.bufferStored = min(_bufferCap, newBuffer);\n```\n\n**[ElliotFriedman (Volt) confirmed and commented](https://github.com/code-423n4/2022-03-volt-findings/issues/27#issuecomment-1092202200):**\n > Good catch!\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-03-volt-protocol-contest",
  "Code": [
    {
      "filename": "contracts/utils/MultiRateLimited.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport {CoreRef} from \"../refs/CoreRef.sol\";\nimport {TribeRoles} from \"./../core/TribeRoles.sol\";\nimport {RateLimited} from \"./RateLimited.sol\";\nimport {IMultiRateLimited} from \"./IMultiRateLimited.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n/// @title abstract contract for putting a rate limit on how fast an address can perform an action e.g. Minting\n/// there are two buffers, one buffer which is each individual addresses's current buffer,\n/// and then there is a global buffer which is the buffer that each individual address must respect as well\n/// @author Elliot Friedman, Fei Protocol\n/// this contract was made abstract so that other contracts that already construct an instance of CoreRef\n/// do not collide with this one\nabstract contract MultiRateLimited is RateLimited, IMultiRateLimited {\n    using SafeCast for *;\n\n    /// @notice the struct containing all information per rate limited address\n    struct RateLimitData {\n        uint32 lastBufferUsedTime;\n        uint112 bufferCap;\n        uint112 bufferStored;\n        uint112 rateLimitPerSecond;\n    }\n\n    /// @notice rate limited address information\n    mapping(address => RateLimitData) public rateLimitPerAddress;\n\n    /// @notice max rate limit per second allowable by non governor per contract\n    uint256 public individualMaxRateLimitPerSecond;\n\n    /// @notice max buffer cap allowable by non governor per contract\n    uint256 public individualMaxBufferCap;\n\n    /// @param _maxRateLimitPerSecond maximum amount of fei that can replenish per second ever, this amount cannot be changed by governance\n    /// @param _rateLimitPerSecond maximum rate limit per second per address\n    /// @param _individualMaxRateLimitPerSecond maximum rate limit per second per address in multi rate limited\n    /// @param _individualMaxBufferCap maximum buffer cap in multi rate limited\n    /// @param _globalBufferCap maximum global buffer cap\n    constructor(\n        uint256 _maxRateLimitPerSecond,\n        uint256 _rateLimitPerSecond,\n        uint256 _individualMaxRateLimitPerSecond,\n        uint256 _individualMaxBufferCap,\n        uint256 _globalBufferCap\n    )\n        RateLimited(\n            _maxRateLimitPerSecond,\n            _rateLimitPerSecond,\n            _globalBufferCap,\n            false\n        )\n    {\n        require(\n            _individualMaxBufferCap < _globalBufferCap,\n            \"MultiRateLimited: max buffer cap invalid\"\n        );\n\n        individualMaxRateLimitPerSecond = _individualMaxRateLimitPerSecond;\n        individualMaxBufferCap = _individualMaxBufferCap;\n    }\n\n    modifier addressIsRegistered(address rateLimitedAddress) {\n        require(\n            rateLimitPerAddress[rateLimitedAddress].lastBufferUsedTime != 0,\n            \"MultiRateLimited: rate limit address does not exist\"\n        );\n        _;\n    }\n\n    // ----------- Governor and Admin only state changing api -----------\n\n    /// @notice update the ADD_MINTER_ROLE rate limit per second\n    /// @param newRateLimitPerSecond new maximum rate limit per second for add minter role\n    function updateMaxRateLimitPerSecond(uint256 newRateLimitPerSecond)\n        external\n        virtual\n        override\n        onlyGovernor\n    {\n        require(\n            newRateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,\n            \"MultiRateLimited: exceeds global max rate limit per second\"\n        );\n\n        uint256 oldMaxRateLimitPerSecond = individualMaxRateLimitPerSecond;\n        individualMaxRateLimitPerSecond = newRateLimitPerSecond;\n\n        emit MultiMaxRateLimitPerSecondUpdate(\n            oldMaxRateLimitPerSecond,\n            newRateLimitPerSecond\n        );\n    }\n\n    /// @notice update the ADD_MINTER_ROLE max buffer cap\n    /// @param newBufferCap new buffer cap for ADD_MINTER_ROLE added addresses\n    function updateMaxBufferCap(uint256 newBufferCap)\n        external\n        virtual\n        override\n        onlyGovernor\n    {\n        require(\n            newBufferCap <= bufferCap,\n            \"MultiRateLimited: exceeds global buffer cap\"\n        );\n\n        uint256 oldBufferCap = individualMaxBufferCap;\n        individualMaxBufferCap = newBufferCap;\n\n        emit MultiBufferCapUpdate(oldBufferCap, newBufferCap);\n    }\n\n    /// @notice add an authorized rateLimitedAddress contract\n    /// @param rateLimitedAddress the new address to add as a rateLimitedAddress\n    /// @param _rateLimitPerSecond the rate limit per second for this rateLimitedAddress\n    /// @param _bufferCap  the buffer cap for this rateLimitedAddress\n    function addAddress(\n        address rateLimitedAddress,\n        uint112 _rateLimitPerSecond,\n        uint112 _bufferCap\n    ) external virtual override onlyGovernor {\n        _addAddress(rateLimitedAddress, _rateLimitPerSecond, _bufferCap);\n    }\n\n    /// @notice add an authorized rateLimitedAddress contract\n    /// @param rateLimitedAddress the address whose buffer and rate limit per second will be set\n    /// @param _rateLimitPerSecond the new rate limit per second for this rateLimitedAddress\n    /// @param _bufferCap  the new buffer cap for this rateLimitedAddress\n    function updateAddress(\n        address rateLimitedAddress,\n        uint112 _rateLimitPerSecond,\n        uint112 _bufferCap\n    )\n        external\n        virtual\n        override\n        addressIsRegistered(rateLimitedAddress)\n        hasAnyOfTwoRoles(TribeRoles.ADD_MINTER_ROLE, TribeRoles.GOVERNOR)\n    {\n        if (core().hasRole(TribeRoles.ADD_MINTER_ROLE, msg.sender)) {\n            require(\n                _rateLimitPerSecond <= individualMaxRateLimitPerSecond,\n                \"MultiRateLimited: rate limit per second exceeds non governor allowable amount\"\n            );\n            require(\n                _bufferCap <= individualMaxBufferCap,\n                \"MultiRateLimited: max buffer cap exceeds non governor allowable amount\"\n            );\n        }\n        require(\n            _bufferCap <= bufferCap,\n            \"MultiRateLimited: buffercap too high\"\n        );\n\n        _updateAddress(rateLimitedAddress, _rateLimitPerSecond, _bufferCap);\n    }\n\n    /// @notice add an authorized rateLimitedAddress contract\n    /// @param rateLimitedAddress the new address to add as a rateLimitedAddress\n    /// gives the newly added contract the maximum allowable rate limit per second and buffer cap\n    function addAddressWithCaps(address rateLimitedAddress)\n        external\n        virtual\n        override\n        onlyTribeRole(TribeRoles.ADD_MINTER_ROLE)\n    {\n        _addAddress(\n            rateLimitedAddress,\n            uint112(individualMaxRateLimitPerSecond),\n            uint112(individualMaxBufferCap)\n        );\n    }\n\n    /// @notice remove an authorized rateLimitedAddress contract\n    /// @param rateLimitedAddress the address to remove from the whitelist of addresses\n    function removeAddress(address rateLimitedAddress)\n        external\n        virtual\n        override\n        addressIsRegistered(rateLimitedAddress)\n        onlyGuardianOrGovernor\n    {\n        uint256 oldRateLimitPerSecond = rateLimitPerAddress[rateLimitedAddress]\n            .rateLimitPerSecond;\n\n        delete rateLimitPerAddress[rateLimitedAddress];\n\n        emit IndividualRateLimitPerSecondUpdate(\n            rateLimitedAddress,\n            oldRateLimitPerSecond,\n            0\n        );\n    }\n\n    // ----------- Getters -----------\n\n    /// @notice the amount of action used before hitting limit\n    /// @dev replenishes at rateLimitPerSecond per second up to bufferCap\n    /// @param rateLimitedAddress the address whose buffer will be returned\n    /// @return the buffer of the specified rate limited address\n    function individualBuffer(address rateLimitedAddress)\n        public\n        view\n        override\n        returns (uint112)\n    {\n        RateLimitData memory rateLimitData = rateLimitPerAddress[\n            rateLimitedAddress\n        ];\n\n        uint256 elapsed = block.timestamp - rateLimitData.lastBufferUsedTime;\n        return\n            uint112(\n                Math.min(\n                    rateLimitData.bufferStored +\n                        (rateLimitData.rateLimitPerSecond * elapsed),\n                    rateLimitData.bufferCap\n                )\n            );\n    }\n\n    /// @notice the rate per second for each address\n    function getRateLimitPerSecond(address limiter)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return rateLimitPerAddress[limiter].rateLimitPerSecond;\n    }\n\n    /// @notice the last time the buffer was used by each address\n    function getLastBufferUsedTime(address limiter)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return rateLimitPerAddress[limiter].lastBufferUsedTime;\n    }\n\n    /// @notice the cap of the buffer that can be used at once\n    function getBufferCap(address limiter)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return rateLimitPerAddress[limiter].bufferCap;\n    }\n\n    // ----------- Helper Methods -----------\n\n    function _updateAddress(\n        address rateLimitedAddress,\n        uint112 _rateLimitPerSecond,\n        uint112 _bufferCap\n    ) internal {\n        RateLimitData storage rateLimitData = rateLimitPerAddress[\n            rateLimitedAddress\n        ];\n\n        require(\n            rateLimitData.lastBufferUsedTime != 0,\n            \"MultiRateLimited: rate limit address does not exist\"\n        );\n        require(\n            _rateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,\n            \"MultiRateLimited: rateLimitPerSecond too high\"\n        );\n\n        uint112 oldRateLimitPerSecond = rateLimitData.rateLimitPerSecond;\n\n        rateLimitData.lastBufferUsedTime = block.timestamp.toUint32();\n        rateLimitData.bufferCap = _bufferCap;\n        rateLimitData.rateLimitPerSecond = _rateLimitPerSecond;\n        rateLimitData.bufferStored = _bufferCap;\n\n        emit IndividualRateLimitPerSecondUpdate(\n            rateLimitedAddress,\n            oldRateLimitPerSecond,\n            _rateLimitPerSecond\n        );\n    }\n\n    /// @param rateLimitedAddress the new address to add as a rateLimitedAddress\n    /// @param _rateLimitPerSecond the rate limit per second for this rateLimitedAddress\n    /// @param _bufferCap  the buffer cap for this rateLimitedAddress\n    function _addAddress(\n        address rateLimitedAddress,\n        uint112 _rateLimitPerSecond,\n        uint112 _bufferCap\n    ) internal {\n        require(\n            _bufferCap <= bufferCap,\n            \"MultiRateLimited: new buffercap too high\"\n        );\n        require(\n            rateLimitPerAddress[rateLimitedAddress].lastBufferUsedTime == 0,\n            \"MultiRateLimited: address already added\"\n        );\n        require(\n            _rateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,\n            \"MultiRateLimited: rateLimitPerSecond too high\"\n        );\n\n        RateLimitData memory rateLimitData = RateLimitData({\n            lastBufferUsedTime: block.timestamp.toUint32(),\n            bufferCap: _bufferCap,\n            rateLimitPerSecond: _rateLimitPerSecond,\n            bufferStored: _bufferCap\n        });\n\n        rateLimitPerAddress[rateLimitedAddress] = rateLimitData;\n\n        emit IndividualRateLimitPerSecondUpdate(\n            rateLimitedAddress,\n            0,\n            _rateLimitPerSecond\n        );\n    }\n\n    /// @notice the method that enforces the rate limit. Decreases buffer by \"amount\".\n    /// @param rateLimitedAddress the address whose buffer will be depleted\n    /// @param amount the amount to remove from the rateLimitedAddress's buffer\n    function _depleteIndividualBuffer(\n        address rateLimitedAddress,\n        uint256 amount\n    ) internal returns (uint256) {\n        _depleteBuffer(amount);\n\n        uint256 newBuffer = individualBuffer(rateLimitedAddress);\n\n        require(newBuffer != 0, \"MultiRateLimited: no rate limit buffer\");\n        require(amount <= newBuffer, \"MultiRateLimited: rate limit hit\");\n\n        rateLimitPerAddress[rateLimitedAddress].bufferStored = uint112(\n            newBuffer - amount\n        );\n\n        rateLimitPerAddress[rateLimitedAddress].lastBufferUsedTime = block\n            .timestamp\n            .toUint32();\n\n        emit IndividualBufferUsed(\n            rateLimitedAddress,\n            amount,\n            newBuffer - amount\n        );\n\n        return amount;\n    }\n}"
    }
  ]
}