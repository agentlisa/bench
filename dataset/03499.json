{
  "Title": "[L11] Incorrect state transitioner index",
  "Content": "When [deploying a new `OVM_StateTransitioner` contract](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/OVM_FraudVerifier.sol#L138), the `OVM_FraudVerifier` contract incorrectly passes the index of the state root in its corresponding batch, confusing it with the state rootâ€™s index in the State Commitment chain. The same mistake is made when emitting the [`FraudProofInitialized`](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/OVM_FraudVerifier.sol#L142) and [`FraudProofFinalized`](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/verification/OVM_FraudVerifier.sol#L215) events.\n\n\nConsider replacing these values with the index of the state root in the State Commitment chain.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/optimistic-ethereum/OVM/verification/OVM_FraudVerifier.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\n/* Library Imports */\nimport { Lib_OVMCodec } from \"../../libraries/codec/Lib_OVMCodec.sol\";\nimport { Lib_AddressResolver } from \"../../libraries/resolver/Lib_AddressResolver.sol\";\n\n/* Interface Imports */\nimport { iOVM_FraudVerifier } from \"../../iOVM/verification/iOVM_FraudVerifier.sol\";\nimport { iOVM_StateTransitioner } from \"../../iOVM/verification/iOVM_StateTransitioner.sol\";\nimport { iOVM_StateTransitionerFactory } from \"../../iOVM/verification/iOVM_StateTransitionerFactory.sol\";\nimport { iOVM_BondManager } from \"../../iOVM/verification/iOVM_BondManager.sol\";\nimport { iOVM_StateCommitmentChain } from \"../../iOVM/chain/iOVM_StateCommitmentChain.sol\";\nimport { iOVM_CanonicalTransactionChain } from \"../../iOVM/chain/iOVM_CanonicalTransactionChain.sol\";\n\n/* Contract Imports */\nimport { Abs_FraudContributor } from \"./Abs_FraudContributor.sol\";\n\n\n\n/**\n * @title OVM_FraudVerifier\n * @dev The Fraud Verifier contract coordinates the entire fraud proof verification process. \n * If the fraud proof was successful it prunes any state batches from State Commitment Chain\n * which were published after the fraudulent state root.\n * \n * Compiler used: solc\n * Runtime target: EVM\n */\ncontract OVM_FraudVerifier is Lib_AddressResolver, Abs_FraudContributor, iOVM_FraudVerifier {\n\n    /*******************************************\n     * Contract Variables: Internal Accounting *\n     *******************************************/\n\n    mapping (bytes32 => iOVM_StateTransitioner) internal transitioners;\n\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _libAddressManager Address of the Address Manager.\n     */\n    constructor(\n        address _libAddressManager\n    )\n        Lib_AddressResolver(_libAddressManager)\n    {}\n\n\n    /***************************************\n     * Public Functions: Transition Status *\n     ***************************************/\n\n    /**\n     * Retrieves the state transitioner for a given root.\n     * @param _preStateRoot State root to query a transitioner for.\n     * @return _transitioner Corresponding state transitioner contract.\n     */\n    function getStateTransitioner(\n        bytes32 _preStateRoot,\n        bytes32 _txHash\n    )\n        override\n        public\n        view\n        returns (\n            iOVM_StateTransitioner _transitioner\n        )\n    {\n        return transitioners[keccak256(abi.encodePacked(_preStateRoot, _txHash))];\n    }\n\n\n    /****************************************\n     * Public Functions: Fraud Verification *\n     ****************************************/\n\n    /**\n     * Begins the fraud verification process.\n     * @param _preStateRoot State root before the fraudulent transaction.\n     * @param _preStateRootBatchHeader Batch header for the provided pre-state root.\n     * @param _preStateRootProof Inclusion proof for the provided pre-state root.\n     * @param _transaction OVM transaction claimed to be fraudulent.\n     * @param _txChainElement OVM transaction chain element.\n     * @param _transactionBatchHeader Batch header for the provided transaction.\n     * @param _transactionProof Inclusion proof for the provided transaction.\n     */\n    function initializeFraudVerification(\n        bytes32 _preStateRoot,\n        Lib_OVMCodec.ChainBatchHeader memory _preStateRootBatchHeader,\n        Lib_OVMCodec.ChainInclusionProof memory _preStateRootProof,\n        Lib_OVMCodec.Transaction memory _transaction,\n        Lib_OVMCodec.TransactionChainElement memory _txChainElement,\n        Lib_OVMCodec.ChainBatchHeader memory _transactionBatchHeader,\n        Lib_OVMCodec.ChainInclusionProof memory _transactionProof\n    )\n        override\n        public\n        contributesToFraudProof(_preStateRoot, Lib_OVMCodec.hashTransaction(_transaction))\n    {\n        bytes32 _txHash = Lib_OVMCodec.hashTransaction(_transaction);\n\n        if (_hasStateTransitioner(_preStateRoot, _txHash)) {\n            return;\n        }\n\n        iOVM_StateCommitmentChain ovmStateCommitmentChain = iOVM_StateCommitmentChain(resolve(\"OVM_StateCommitmentChain\"));\n        iOVM_CanonicalTransactionChain ovmCanonicalTransactionChain = iOVM_CanonicalTransactionChain(resolve(\"OVM_CanonicalTransactionChain\"));\n\n        require(\n            ovmStateCommitmentChain.verifyStateCommitment(\n                _preStateRoot,\n                _preStateRootBatchHeader,\n                _preStateRootProof\n            ),\n            \"Invalid pre-state root inclusion proof.\"\n        );\n\n        require(\n            ovmCanonicalTransactionChain.verifyTransaction(\n                _transaction,\n                _txChainElement,\n                _transactionBatchHeader,\n                _transactionProof\n            ),\n            \"Invalid transaction inclusion proof.\"\n        );\n\n        require (\n            _preStateRootBatchHeader.prevTotalElements + _preStateRootProof.index + 1 == _transactionBatchHeader.prevTotalElements + _transactionProof.index,\n            \"Pre-state root global index must equal to the transaction root global index.\"\n        );\n\n        _deployTransitioner(_preStateRoot, _txHash, _preStateRootProof.index);\n\n        emit FraudProofInitialized(\n            _preStateRoot,\n            _preStateRootProof.index,\n            _txHash,\n            msg.sender\n        );\n    }\n\n    /**\n     * Finalizes the fraud verification process.\n     * @param _preStateRoot State root before the fraudulent transaction.\n     * @param _preStateRootBatchHeader Batch header for the provided pre-state root.\n     * @param _preStateRootProof Inclusion proof for the provided pre-state root.\n     * @param _txHash The transaction for the state root\n     * @param _postStateRoot State root after the fraudulent transaction.\n     * @param _postStateRootBatchHeader Batch header for the provided post-state root.\n     * @param _postStateRootProof Inclusion proof for the provided post-state root.\n     */\n    function finalizeFraudVerification(\n        bytes32 _preStateRoot,\n        Lib_OVMCodec.ChainBatchHeader memory _preStateRootBatchHeader,\n        Lib_OVMCodec.ChainInclusionProof memory _preStateRootProof,\n        bytes32 _txHash,\n        bytes32 _postStateRoot,\n        Lib_OVMCodec.ChainBatchHeader memory _postStateRootBatchHeader,\n        Lib_OVMCodec.ChainInclusionProof memory _postStateRootProof\n    )\n        override\n        public\n        contributesToFraudProof(_preStateRoot, _txHash)\n    {\n        iOVM_StateTransitioner transitioner = getStateTransitioner(_preStateRoot, _txHash);\n        iOVM_StateCommitmentChain ovmStateCommitmentChain = iOVM_StateCommitmentChain(resolve(\"OVM_StateCommitmentChain\"));\n\n        require(\n            transitioner.isComplete() == true,\n            \"State transition process must be completed prior to finalization.\"\n        );\n\n        require (\n            _postStateRootBatchHeader.prevTotalElements + _postStateRootProof.index == _preStateRootBatchHeader.prevTotalElements + _preStateRootProof.index + 1,\n            \"Post-state root global index must equal to the pre state root global index plus one.\"\n        );\n\n        require(\n            ovmStateCommitmentChain.verifyStateCommitment(\n                _preStateRoot,\n                _preStateRootBatchHeader,\n                _preStateRootProof\n            ),\n            \"Invalid pre-state root inclusion proof.\"\n        );\n\n        require(\n            ovmStateCommitmentChain.verifyStateCommitment(\n                _postStateRoot,\n                _postStateRootBatchHeader,\n                _postStateRootProof\n            ),\n            \"Invalid post-state root inclusion proof.\"\n        );\n\n        // If the post state root did not match, then there was fraud and we should delete the batch\n        require(\n            _postStateRoot != transitioner.getPostStateRoot(),\n            \"State transition has not been proven fraudulent.\"\n        );\n        \n        _cancelStateTransition(_postStateRootBatchHeader, _preStateRoot);\n\n        // TEMPORARY: Remove the transitioner; for minnet.\n        transitioners[keccak256(abi.encodePacked(_preStateRoot, _txHash))] = iOVM_StateTransitioner(0x0000000000000000000000000000000000000000);\n\n        emit FraudProofFinalized(\n            _preStateRoot,\n            _preStateRootProof.index,\n            _txHash,\n            msg.sender\n        );\n    }\n\n\n    /************************************\n     * Internal Functions: Verification *\n     ************************************/\n\n    /**\n     * Checks whether a transitioner already exists for a given pre-state root.\n     * @param _preStateRoot Pre-state root to check.\n     * @return _exists Whether or not we already have a transitioner for the root.\n     */\n    function _hasStateTransitioner(\n        bytes32 _preStateRoot,\n        bytes32 _txHash\n    )\n        internal\n        view\n        returns (\n            bool _exists\n        )\n    {\n        return address(getStateTransitioner(_preStateRoot, _txHash)) != address(0);\n    }\n\n    /**\n     * Deploys a new state transitioner.\n     * @param _preStateRoot Pre-state root to initialize the transitioner with.\n     * @param _txHash Hash of the transaction this transitioner will execute.\n     * @param _stateTransitionIndex Index of the transaction in the chain.\n     */\n    function _deployTransitioner(\n        bytes32 _preStateRoot,\n        bytes32 _txHash,\n        uint256 _stateTransitionIndex\n    )\n        internal\n    {\n        transitioners[keccak256(abi.encodePacked(_preStateRoot, _txHash))] = iOVM_StateTransitionerFactory(\n            resolve(\"OVM_StateTransitionerFactory\")\n        ).create(\n            address(libAddressManager),\n            _stateTransitionIndex,\n            _preStateRoot,\n            _txHash\n        );\n    }\n\n    /**\n     * Removes a state transition from the state commitment chain.\n     * @param _postStateRootBatchHeader Header for the post-state root.\n     * @param _preStateRoot Pre-state root hash.\n     */\n    function _cancelStateTransition(\n        Lib_OVMCodec.ChainBatchHeader memory _postStateRootBatchHeader,\n        bytes32 _preStateRoot\n    )\n        internal\n    {\n        iOVM_StateCommitmentChain ovmStateCommitmentChain = iOVM_StateCommitmentChain(resolve(\"OVM_StateCommitmentChain\"));\n        iOVM_BondManager ovmBondManager = iOVM_BondManager(resolve(\"OVM_BondManager\"));\n\n        // Delete the state batch.\n        ovmStateCommitmentChain.deleteStateBatch(\n            _postStateRootBatchHeader\n        );\n\n        // Get the timestamp and publisher for that block.\n        (uint256 timestamp, address publisher) = abi.decode(_postStateRootBatchHeader.extraData, (uint256, address));\n\n        // Slash the bonds at the bond manager.\n        ovmBondManager.finalize(\n            _preStateRoot,\n            publisher,\n            timestamp\n        );\n    }\n}"
    }
  ]
}