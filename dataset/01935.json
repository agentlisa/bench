{
  "Title": "M-3: It's possible to reset primaryCredit and secondaryCredit for insurance account",
  "Content": "# Issue M-3: It's possible to reset primaryCredit and secondaryCredit for insurance account \n\nSource: https://github.com/sherlock-audit/2023-04-jojo-judging/issues/159 \n\n## Found by \nGalloDaSballo, p0wd3r, rvierdiiev\n## Summary\nWhen because of negative credit after liquidations of another accounts, insurance address doesn't pass `isSafe` check, then malicious user can call JOJOExternal.handleBadDebt and reset both primaryCredit and secondaryCredit for insurance account.\n## Vulnerability Detail\n`insurance` account is handled by JOJO team. Team is responsible to top up this account in order to cover losses. When [bad debt is handled](https://github.com/sherlock-audit/2023-04-jojo/blob/main/smart-contract-EVM/contracts/impl/Perpetual.sol#L165), then its negative credit value is added to the insurance account. Because of that it's possible that primaryCredit of insurance account is negative and `Liquidation._isSafe(state, insurance) == false`.\n\nAnyone can call [`JOJOExternal.handleBadDebt` function](https://github.com/sherlock-audit/2023-04-jojo/blob/main/smart-contract-EVM/contracts/impl/JOJOExternal.sol#L56-L58).\nhttps://github.com/sherlock-audit/2023-04-jojo/blob/main/smart-contract-EVM/contracts/lib/Liquidation.sol#L399-L418\n```solidity\n    function handleBadDebt(Types.State storage state, address liquidatedTrader)\n        external\n    {\n        if (\n            state.openPositions[liquidatedTrader].length == 0 &&\n            !Liquidation._isSafe(state, liquidatedTrader)\n        ) {\n            int256 primaryCredit = state.primaryCredit[liquidatedTrader];\n            uint256 secondaryCredit = state.secondaryCredit[liquidatedTrader];\n            state.primaryCredit[state.insurance] += primaryCredit;\n            state.secondaryCredit[state.insurance] += secondaryCredit;\n            state.primaryCredit[liquidatedTrader] = 0;\n            state.secondaryCredit[liquidatedTrader] = 0;\n            emit HandleBadDebt(\n                liquidatedTrader,\n                primaryCredit,\n                secondaryCredit\n            );\n        }\n    }\n```\nSo it's possible for anyone to call `handleBadDebt` for `insurance` address, once its primaryCredit is negative and `Liquidation._isSafe(state, insurance) == false`. This will reset both primaryCredit and secondaryCredit variables to 0 and break insurance calculations.\n## Impact\nInsurance primaryCredit and secondaryCredit variables are reset.\n## Code Snippet\nProvided above\n## Tool used\n\nManual Review\n\n## Recommendation\nDo not allow `handleBadDebt` call with insurance address.\n\n\n\n## Discussion\n\n**JoscelynFarr**\n\nfix link: \nhttps://github.com/JOJOexchange/smart-contract-EVM/commit/78c53b4721ae7bb97fb922f78342d0ee4a1825dd\n\n**IAm0x52**\n\nFix looks good. Since the order has been changed, clearing bad debt on the insurance account will result it in still having the same debt before and after the call\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/70",
  "Code": [
    {
      "filename": "smart-contract-EVM/contracts/impl/Perpetual.sol",
      "content": "/*\n    Copyright 2022 JOJO Exchange\n     SPDX-License-Identifier: BUSL-1.1\n*/\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"../intf/IDealer.sol\";\nimport \"../intf/IPerpetual.sol\";\nimport \"../utils/SignedDecimalMath.sol\";\n\ncontract Perpetual is Ownable, IPerpetual {\n    using SignedDecimalMath for int256;\n\n    // ========== storage ==========\n\n    /*\n        We use int128 to store paper and reduced credit, \n        so that we could store balance in a single slot.\n        This trick can help us saving gas.\n\n        int128 can support size of 1.7E38, which is enough \n        for most transactions. But other than storing paper \n        and reduced credit values, we use int256 to achieve \n        higher accuracy of calculation.\n\n        Normally, paper amount will be a 1e18 based decimal.\n    */\n    struct balance {\n        int128 paper;\n        int128 reducedCredit;\n    }\n    mapping(address => balance) balanceMap;\n    int256 fundingRate;\n\n    // ========== events ==========\n\n    event BalanceChange(\n        address indexed trader,\n        int256 paperChange,\n        int256 creditChange\n    );\n\n    event UpdateFundingRate(int256 oldFundingRate, int256 newFundingRate);\n\n    // ========== constructor ==========\n\n    constructor(address _owner) Ownable() {\n        transferOwnership(_owner);\n    }\n\n    // ========== balance related ==========\n\n    /*\n        We store \"reducedCredit\" instead of credit itself.\n        So that after funding rate is updated, the credit values will be\n        updated without any extra storage write.\n        \n        credit = (paper * fundingRate) + reducedCredit\n\n        FundingRate here is a little different from what it means at CEX.\n        FundingRate is a cumulative value. Its absolute value doesn't mean \n        anything and only the changes (due to funding updates) matter.\n\n        e.g. If the fundingRate increases by 5 at a certain update, \n        then you will receive 5 credit for every paper you long.\n        And you will be charged 5 credit for every paper you short.\n    */\n\n    /// @inheritdoc IPerpetual\n    function balanceOf(\n        address trader\n    ) external view returns (int256 paper, int256 credit) {\n        paper = int256(balanceMap[trader].paper);\n        credit =\n            paper.decimalMul(fundingRate) +\n            int256(balanceMap[trader].reducedCredit);\n    }\n\n    function updateFundingRate(int256 newFundingRate) external onlyOwner {\n        int256 oldFundingRate = fundingRate;\n        fundingRate = newFundingRate;\n        emit UpdateFundingRate(oldFundingRate, newFundingRate);\n    }\n\n    function getFundingRate() external view returns (int256) {\n        return fundingRate;\n    }\n\n    // ========== trade ==========\n\n    /// @inheritdoc IPerpetual\n    function trade(bytes calldata tradeData) external {\n        (\n            address[] memory traderList,\n            int256[] memory paperChangeList,\n            int256[] memory creditChangeList\n        ) = IDealer(owner()).approveTrade(msg.sender, tradeData);\n\n        for (uint256 i = 0; i < traderList.length; ) {\n            _settle(traderList[i], paperChangeList[i], creditChangeList[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        require(IDealer(owner()).isAllSafe(traderList), \"TRADER_NOT_SAFE\");\n    }\n\n    // ========== liquidation ==========\n\n    /// @inheritdoc IPerpetual\n    function liquidate(\n        address liquidator,\n        address liquidatedTrader,\n        int256 requestPaper,\n        int256 expectCredit\n    ) external returns (int256 liqtorPaperChange, int256 liqtorCreditChange) {\n        // liqed => liquidated trader, who faces the risk of liquidation.\n        // liqtor => liquidator, who takes over the trader's position.\n        int256 liqedPaperChange;\n        int256 liqedCreditChange;\n        (\n            liqtorPaperChange,\n            liqtorCreditChange,\n            liqedPaperChange,\n            liqedCreditChange\n        ) = IDealer(owner()).requestLiquidation(\n            msg.sender,\n            liquidator,\n            liquidatedTrader,\n            requestPaper\n        );\n\n        // expected price = expectCredit/requestPaper * -1\n        // execute price = liqtorCreditChange/liqtorPaperChange * -1\n        if (liqtorPaperChange < 0) {\n            // open short, execute price >= expected price\n            // liqtorCreditChange/liqtorPaperChange * -1 >= expectCredit/requestPaper * -1\n            // liqtorCreditChange/liqtorPaperChange <= expectCredit/requestPaper\n            // liqtorCreditChange*requestPaper <= expectCredit*liqtorPaperChange\n            require(\n                liqtorCreditChange * requestPaper <=\n                    expectCredit * liqtorPaperChange,\n                \"LIQUIDATION_PRICE_PROTECTION\"\n            );\n        } else {\n            // open long, execute price <= expected price\n            // liqtorCreditChange/liqtorPaperChange * -1 <= expectCredit/requestPaper * -1\n            // liqtorCreditChange/liqtorPaperChange >= expectCredit/requestPaper\n            // liqtorCreditChange*requestPaper >= expectCredit*liqtorPaperChange\n            require(\n                liqtorCreditChange * requestPaper >=\n                    expectCredit * liqtorPaperChange,\n                \"LIQUIDATION_PRICE_PROTECTION\"\n            );\n        }\n\n        _settle(liquidatedTrader, liqedPaperChange, liqedCreditChange);\n        _settle(liquidator, liqtorPaperChange, liqtorCreditChange);\n        require(IDealer(owner()).isSafe(liquidator), \"LIQUIDATOR_NOT_SAFE\");\n        if (balanceMap[liquidatedTrader].paper == 0) {\n            IDealer(owner()).handleBadDebt(liquidatedTrader);\n        }\n    }\n\n    // ========== settlement ==========\n\n    /*\n        Remember the fomula?\n        credit = (paper * fundingRate) + reducedCredit\n\n        So we have...\n        reducedCredit = credit - (paper * fundingRate)\n\n        When you update the balance, you need to first calculate the credit, \n        and then calculate and store the reducedCredit.\n    */\n\n    function _settle(\n        address trader,\n        int256 paperChange,\n        int256 creditChange\n    ) internal {\n        bool isNewPosition = balanceMap[trader].paper == 0;\n        int256 rate = fundingRate; // gas saving\n        int256 credit = int256(balanceMap[trader].paper).decimalMul(rate) +\n            int256(balanceMap[trader].reducedCredit) +\n            creditChange;\n        int128 newPaper = balanceMap[trader].paper +\n            SafeCast.toInt128(paperChange);\n        int128 newReducedCredit = SafeCast.toInt128(\n            credit - int256(newPaper).decimalMul(rate)\n        );\n        balanceMap[trader].paper = newPaper;\n        balanceMap[trader].reducedCredit = newReducedCredit;\n        emit BalanceChange(trader, paperChange, creditChange);\n        if (isNewPosition) {\n            IDealer(owner()).openPosition(trader);\n        }\n        if (newPaper == 0) {\n            // realize PNL\n            IDealer(owner()).realizePnl(\n                trader,\n                balanceMap[trader].reducedCredit\n            );\n            balanceMap[trader].reducedCredit = 0;\n        }\n    }\n}"
    },
    {
      "filename": "smart-contract-EVM/contracts/impl/JOJOExternal.sol",
      "content": "/*\n    Copyright 2022 JOJO Exchange\n    SPDX-License-Identifier: BUSL-1.1\n*/\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./JOJOStorage.sol\";\nimport \"../utils/Errors.sol\";\nimport \"../utils/SignedDecimalMath.sol\";\nimport \"../intf/IDealer.sol\";\nimport \"../lib/Liquidation.sol\";\nimport \"../lib/Funding.sol\";\nimport \"../lib/Trading.sol\";\nimport \"../lib/Position.sol\";\nimport \"../lib/Operation.sol\";\n\nabstract contract JOJOExternal is JOJOStorage, IDealer {\n    using SignedDecimalMath for int256;\n    using SafeERC20 for IERC20;\n\n    // ========== fund related ==========\n\n    /// @inheritdoc IDealer\n    function deposit(\n        uint256 primaryAmount,\n        uint256 secondaryAmount,\n        address to\n    ) external nonReentrant {\n        Funding.deposit(state, primaryAmount, secondaryAmount, to);\n    }\n\n    /// @inheritdoc IDealer\n    function requestWithdraw(uint256 primaryAmount, uint256 secondaryAmount)\n        external\n        nonReentrant\n    {\n        Funding.requestWithdraw(state, primaryAmount, secondaryAmount);\n    }\n\n    /// @inheritdoc IDealer\n    function executeWithdraw(address to, bool isInternal)\n        external\n        nonReentrant\n    {\n        Funding.executeWithdraw(state, to, isInternal);\n    }\n\n    /// @inheritdoc IDealer\n    function setOperator(address operator, bool isValid) external {\n        Operation.setOperator(state, msg.sender, operator, isValid);\n    }\n\n    /// @inheritdoc IDealer\n    function handleBadDebt(address liquidatedTrader) external {\n        Liquidation.handleBadDebt(state, liquidatedTrader);\n    }\n\n    // ========== registered perpetual only ==========\n\n    /// @inheritdoc IDealer\n    function requestLiquidation(\n        address executor,\n        address liquidator,\n        address liquidatedTrader,\n        int256 requestPaperAmount\n    )\n        external\n        onlyRegisteredPerp\n        returns (\n            int256 liqtorPaperChange,\n            int256 liqtorCreditChange,\n            int256 liqedPaperChange,\n            int256 liqedCreditChange\n        )\n    {\n        return\n            Liquidation.requestLiquidation(\n                state,\n                msg.sender,\n                executor,\n                liquidator,\n                liquidatedTrader,\n                requestPaperAmount\n            );\n    }\n\n    /// @inheritdoc IDealer\n    function openPosition(address trader) external onlyRegisteredPerp {\n        Position._openPosition(state, trader);\n    }\n\n    /// @inheritdoc IDealer\n    function realizePnl(address trader, int256 pnl)\n        external\n        onlyRegisteredPerp\n    {\n        Position._realizePnl(state, trader, pnl);\n    }\n\n    /// @inheritdoc IDealer\n    function approveTrade(address orderSender, bytes calldata tradeData)\n        external\n        onlyRegisteredPerp\n        returns (\n            address[] memory, // traderList\n            int256[] memory, // paperChangeList\n            int256[] memory // creditChangeList\n        )\n    {\n        require(\n            state.validOrderSender[orderSender],\n            Errors.INVALID_ORDER_SENDER\n        );\n\n        /*\n            parse tradeData\n            Pass in all orders and their signatures that need to be matched.\n            Also, pass in the amount you want to fill each order.\n        */\n        (\n            Types.Order[] memory orderList,\n            bytes[] memory signatureList,\n            uint256[] memory matchPaperAmount\n        ) = abi.decode(tradeData, (Types.Order[], bytes[], uint256[]));\n        bytes32[] memory orderHashList = new bytes32[](orderList.length);\n\n        // validate all orders\n        for (uint256 i = 0; i < orderList.length; ) {\n            Types.Order memory order = orderList[i];\n            bytes32 orderHash = EIP712._hashTypedDataV4(\n                domainSeparator,\n                Trading._structHash(order)\n            );\n            orderHashList[i] = orderHash;\n            address recoverSigner = ECDSA.recover(orderHash, signatureList[i]);\n            // requirements\n            require(\n                recoverSigner == order.signer ||\n                    state.operatorRegistry[order.signer][recoverSigner],\n                Errors.INVALID_ORDER_SIGNATURE\n            );\n            require(\n                Trading._info2Expiration(order.info) >= block.timestamp,\n                Errors.ORDER_EXPIRED\n            );\n            require(\n                (order.paperAmount < 0 && order.creditAmount > 0) ||\n                    (order.paperAmount > 0 && order.creditAmount < 0),\n                Errors.ORDER_PRICE_NEGATIVE\n            );\n            require(order.perp == msg.sender, Errors.PERP_MISMATCH);\n            require(\n                i == 0 || order.signer != orderList[0].signer,\n                Errors.ORDER_SELF_MATCH\n            );\n            state.orderFilledPaperAmount[orderHash] += matchPaperAmount[i];\n            require(\n                state.orderFilledPaperAmount[orderHash] <=\n                    int256(orderList[i].paperAmount).abs(),\n                Errors.ORDER_FILLED_OVERFLOW\n            );\n            unchecked {\n                ++i;\n            }\n        }\n\n        Types.MatchResult memory result = Trading._matchOrders(\n            state,\n            orderHashList,\n            orderList,\n            matchPaperAmount\n        );\n\n        // charge fee\n        state.primaryCredit[orderSender] += result.orderSenderFee;\n        // if orderSender pay fees to traders, check if orderSender is safe\n        if (result.orderSenderFee < 0) {\n            require(\n                Liquidation._isSolidSafe(state, orderSender),\n                Errors.ORDER_SENDER_NOT_SAFE\n            );\n        }\n\n        return (\n            result.traderList,\n            result.paperChangeList,\n            result.creditChangeList\n        );\n    }\n}"
    },
    {
      "filename": "smart-contract-EVM/contracts/lib/Liquidation.sol",
      "content": "/*\n    Copyright 2022 JOJO Exchange\n    SPDX-License-Identifier: BUSL-1.1\n*/\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"../intf/IPerpetual.sol\";\nimport \"../intf/IMarkPriceSource.sol\";\nimport \"../utils/SignedDecimalMath.sol\";\nimport \"../utils/Errors.sol\";\nimport \"./Types.sol\";\nimport \"./Position.sol\";\n\nlibrary Liquidation {\n    using SignedDecimalMath for int256;\n\n    // ========== events ==========\n\n    event BeingLiquidated(\n        address indexed perp,\n        address indexed liquidatedTrader,\n        int256 paperChange,\n        int256 creditChange,\n        uint256 positionSerialNum\n    );\n\n    event JoinLiquidation(\n        address indexed perp,\n        address indexed liquidator,\n        address indexed liquidatedTrader,\n        int256 paperChange,\n        int256 creditChange,\n        uint256 positionSerialNum\n    );\n\n    // emit when charge insurance fee from liquidated trader\n    event ChargeInsurance(\n        address indexed perp,\n        address indexed liquidatedTrader,\n        uint256 fee\n    );\n\n    event HandleBadDebt(\n        address indexed liquidatedTrader,\n        int256 primaryCredit,\n        uint256 secondaryCredit\n    );\n\n    // ========== trader safety check ==========\n\n    function getTotalExposure(Types.State storage state, address trader)\n        public\n        view\n        returns (\n            int256 netPositionValue,\n            uint256 exposure,\n            uint256 maintenanceMargin\n        )\n    {\n        // sum net value and exposure among all markets\n        for (uint256 i = 0; i < state.openPositions[trader].length; ) {\n            (int256 paperAmount, int256 creditAmount) = IPerpetual(\n                state.openPositions[trader][i]\n            ).balanceOf(trader);\n            Types.RiskParams storage params = state.perpRiskParams[\n                state.openPositions[trader][i]\n            ];\n            int256 price = SafeCast.toInt256(\n                IMarkPriceSource(params.markPriceSource).getMarkPrice()\n            );\n\n            netPositionValue += paperAmount.decimalMul(price) + creditAmount;\n            uint256 exposureIncrement = paperAmount.decimalMul(price).abs();\n            exposure += exposureIncrement;\n            maintenanceMargin +=\n                (exposureIncrement * params.liquidationThreshold) /\n                Types.ONE;\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _isSafe(Types.State storage state, address trader)\n        internal\n        view\n        returns (bool)\n    {\n        (\n            int256 netPositionValue,\n            ,\n            uint256 maintenanceMargin\n        ) = getTotalExposure(state, trader);\n\n        // net value >= maintenanceMargin\n        return\n            netPositionValue +\n                state.primaryCredit[trader] +\n                SafeCast.toInt256(state.secondaryCredit[trader]) >=\n            SafeCast.toInt256(maintenanceMargin);\n    }\n\n    /// @notice More strict than _isSafe.\n    /// Additional requirement: netPositionValue + primaryCredit >= 0\n    /// used when traders transfer out primary credit.\n    function _isSolidSafe(Types.State storage state, address trader)\n        internal\n        view\n        returns (bool)\n    {\n        (\n            int256 netPositionValue,\n            ,\n            uint256 maintenanceMargin\n        ) = getTotalExposure(state, trader);\n        return\n            netPositionValue + state.primaryCredit[trader] >= 0 &&\n            netPositionValue +\n                state.primaryCredit[trader] +\n                SafeCast.toInt256(state.secondaryCredit[trader]) >=\n            SafeCast.toInt256(maintenanceMargin);\n    }\n\n    /// @dev A gas saving way to check multi traders' safety status\n    /// by caching mark prices\n    function _isAllSafe(\n        Types.State storage state,\n        address[] calldata traderList\n    ) internal view returns (bool) {\n        // cache mark price\n        uint256 totalPerpNum = state.registeredPerp.length;\n        address[] memory perpList = new address[](totalPerpNum);\n        int256[] memory markPriceCache = new int256[](totalPerpNum);\n\n        // check each trader's maintenance margin and net value\n        for (uint256 i = 0; i < traderList.length; ) {\n            address trader = traderList[i];\n            uint256 maintenanceMargin;\n            int256 netValue = state.primaryCredit[trader] +\n                SafeCast.toInt256(state.secondaryCredit[trader]);\n\n            // go through all open positions\n            for (uint256 j = 0; j < state.openPositions[trader].length; ) {\n                address perp = state.openPositions[trader][j];\n                Types.RiskParams storage params = state.perpRiskParams[perp];\n                int256 markPrice;\n                // use cached price OR cache it\n                for (uint256 k = 0; k < totalPerpNum; ) {\n                    if (perpList[k] == perp) {\n                        markPrice = markPriceCache[k];\n                        break;\n                    }\n                    // if not, query mark price and cache it\n                    if (perpList[k] == address(0)) {\n                        markPrice = SafeCast.toInt256(\n                            IMarkPriceSource(params.markPriceSource)\n                                .getMarkPrice()\n                        );\n                        perpList[k] = perp;\n                        markPriceCache[k] = markPrice;\n                        break;\n                    }\n                    unchecked {\n                        ++k;\n                    }\n                }\n                (int256 paperAmount, int256 credit) = IPerpetual(perp)\n                    .balanceOf(trader);\n                maintenanceMargin +=\n                    (paperAmount.decimalMul(markPrice).abs() *\n                        params.liquidationThreshold) /\n                    Types.ONE;\n                netValue += paperAmount.decimalMul(markPrice) + credit;\n                unchecked {\n                    ++j;\n                }\n            }\n\n            // return false if any one of traders is lack of collateral\n            if (netValue < SafeCast.toInt256(maintenanceMargin)) {\n                return false;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n        return true;\n    }\n\n    /// @return liquidationPrice It should be considered as the position can never be\n    /// liquidated (absolutely safe) or being liquidated at the present if return 0.\n    function getLiquidationPrice(\n        Types.State storage state,\n        address trader,\n        address perp\n    ) external view returns (uint256 liquidationPrice) {\n        /*\n            To avoid liquidation, we need:\n            netValue >= maintenanceMargin\n\n            We first calculate the maintenanceMargin for all other markets' positions.\n            Let's call it maintenanceMargin'\n\n            Then we have netValue of the account.\n            Let's call it netValue'\n\n            So we have:\n                netValue' + paperAmount * price + creditAmount >= maintenanceMargin' + abs(paperAmount) * price * liquidationThreshold\n            \n            if paperAmount > 0\n                paperAmount * price * (1-liquidationThreshold) >= maintenanceMargin' - netValue' - creditAmount \n                price >= (maintenanceMargin' - netValue' - creditAmount)/paperAmount/(1-liquidationThreshold)\n                liqPrice = (maintenanceMargin' - netValue' - creditAmount)/paperAmount/(1-liquidationThreshold)\n\n            if paperAmount < 0\n                paperAmount * price * (1+liquidationThreshold) >= maintenanceMargin' - netValue' - creditAmount \n                price <= (maintenanceMargin' - netValue' - creditAmount)/paperAmount/(1+liquidationThreshold)\n                liqPrice = (maintenanceMargin' - netValue' - creditAmount)/paperAmount/(1+liquidationThreshold)\n            \n            Let's call 1Â±liquidationThreshold \"multiplier\"\n            Then:\n                liqPrice = (maintenanceMargin' - netValue' - creditAmount)/paperAmount/multiplier\n            \n            If liqPrice<0, it should be considered as the position can never be\n            liquidated (absolutely safe) or being liquidated at the present if return 0.\n        */\n        int256 maintenanceMarginPrime;\n        int256 netValuePrime = state.primaryCredit[trader] +\n            SafeCast.toInt256(state.secondaryCredit[trader]);\n        for (uint256 i = 0; i < state.openPositions[trader].length; ) {\n            address p = state.openPositions[trader][i];\n            if (perp != p) {\n                (\n                    int256 paperAmountPrime,\n                    int256 creditAmountPrime\n                ) = IPerpetual(p).balanceOf(trader);\n                Types.RiskParams storage params = state.perpRiskParams[p];\n                int256 price = SafeCast.toInt256(\n                    IMarkPriceSource(params.markPriceSource).getMarkPrice()\n                );\n                netValuePrime +=\n                    paperAmountPrime.decimalMul(price) +\n                    creditAmountPrime;\n                maintenanceMarginPrime += SafeCast.toInt256(\n                    (paperAmountPrime.decimalMul(price).abs() *\n                        params.liquidationThreshold) / Types.ONE\n                );\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        (int256 paperAmount, int256 creditAmount) = IPerpetual(perp).balanceOf(\n            trader\n        );\n        if (paperAmount == 0) {\n            return 0;\n        }\n        int256 multiplier = paperAmount > 0\n            ? SafeCast.toInt256(\n                Types.ONE - state.perpRiskParams[perp].liquidationThreshold\n            )\n            : SafeCast.toInt256(\n                Types.ONE + state.perpRiskParams[perp].liquidationThreshold\n            );\n        int256 liqPrice = (maintenanceMarginPrime -\n            netValuePrime -\n            creditAmount).decimalDiv(paperAmount).decimalDiv(multiplier);\n        return liqPrice < 0 ? 0 : uint256(liqPrice);\n    }\n\n    /// @notice Using a fixed discount price model.\n    /// Charge fee from liquidated trader.\n    /// Will limit you liquidation request to the position size.\n    function getLiquidateCreditAmount(\n        Types.State storage state,\n        address perp,\n        address liquidatedTrader,\n        int256 requestPaperAmount\n    )\n        public\n        view\n        returns (\n            int256 liqtorPaperChange,\n            int256 liqtorCreditChange,\n            uint256 insuranceFee\n        )\n    {\n        // can not liquidate a safe trader\n        require(!_isSafe(state, liquidatedTrader), Errors.ACCOUNT_IS_SAFE);\n\n        // calculate and limit the paper change to the position size\n        (int256 brokenPaperAmount, ) = IPerpetual(perp).balanceOf(\n            liquidatedTrader\n        );\n        require(brokenPaperAmount != 0, Errors.TRADER_HAS_NO_POSITION);\n        require(\n            requestPaperAmount * brokenPaperAmount > 0,\n            Errors.LIQUIDATION_REQUEST_AMOUNT_WRONG\n        );\n        liqtorPaperChange = requestPaperAmount.abs() > brokenPaperAmount.abs()\n            ? brokenPaperAmount\n            : requestPaperAmount;\n\n        // get price\n        Types.RiskParams storage params = state.perpRiskParams[perp];\n        uint256 price = IMarkPriceSource(params.markPriceSource).getMarkPrice();\n        uint256 priceOffset = (price * params.liquidationPriceOff) / Types.ONE;\n        price = liqtorPaperChange > 0\n            ? price - priceOffset\n            : price + priceOffset;\n\n        // calculate credit change\n        liqtorCreditChange =\n            -1 *\n            liqtorPaperChange.decimalMul(SafeCast.toInt256(price));\n        insuranceFee =\n            (liqtorCreditChange.abs() * params.insuranceFeeRate) /\n            Types.ONE;\n    }\n\n    /// @notice execute a liquidation request\n    function requestLiquidation(\n        Types.State storage state,\n        address perp,\n        address executor,\n        address liquidator,\n        address liquidatedTrader,\n        int256 requestPaperAmount\n    )\n        external\n        returns (\n            int256 liqtorPaperChange,\n            int256 liqtorCreditChange,\n            int256 liqedPaperChange,\n            int256 liqedCreditChange\n        )\n    {\n        require(\n            executor == liquidator ||\n                state.operatorRegistry[liquidator][executor],\n            Errors.INVALID_LIQUIDATION_EXECUTOR\n        );\n        require(\n            liquidatedTrader != liquidator,\n            Errors.SELF_LIQUIDATION_NOT_ALLOWED\n        );\n        uint256 insuranceFee;\n        (\n            liqtorPaperChange,\n            liqtorCreditChange,\n            insuranceFee\n        ) = getLiquidateCreditAmount(\n            state,\n            perp,\n            liquidatedTrader,\n            requestPaperAmount\n        );\n        state.primaryCredit[state.insurance] += SafeCast.toInt256(insuranceFee);\n\n        // liquidated trader balance change\n        liqedCreditChange = liqtorCreditChange * -1 - SafeCast.toInt256(insuranceFee);\n        liqedPaperChange = liqtorPaperChange * -1;\n\n        // events\n        uint256 ltSN = state.positionSerialNum[liquidatedTrader][perp];\n        uint256 liquidatorSN = state.positionSerialNum[liquidator][perp];\n        emit BeingLiquidated(\n            perp,\n            liquidatedTrader,\n            liqedPaperChange,\n            liqedCreditChange,\n            ltSN\n        );\n        emit JoinLiquidation(\n            perp,\n            liquidator,\n            liquidatedTrader,\n            liqtorPaperChange,\n            liqtorCreditChange,\n            liquidatorSN\n        );\n        emit ChargeInsurance(perp, liquidatedTrader, insuranceFee);\n    }\n\n    function getMarkPrice(Types.State storage state, address perp)\n        external\n        view\n        returns (uint256 price)\n    {\n        price = IMarkPriceSource(state.perpRiskParams[perp].markPriceSource)\n            .getMarkPrice();\n    }\n\n    function handleBadDebt(Types.State storage state, address liquidatedTrader)\n        external\n    {\n        if (\n            state.openPositions[liquidatedTrader].length == 0 &&\n            !Liquidation._isSafe(state, liquidatedTrader)\n        ) {\n            int256 primaryCredit = state.primaryCredit[liquidatedTrader];\n            uint256 secondaryCredit = state.secondaryCredit[liquidatedTrader];\n            state.primaryCredit[state.insurance] += primaryCredit;\n            state.secondaryCredit[state.insurance] += secondaryCredit;\n            state.primaryCredit[liquidatedTrader] = 0;\n            state.secondaryCredit[liquidatedTrader] = 0;\n            emit HandleBadDebt(\n                liquidatedTrader,\n                primaryCredit,\n                secondaryCredit\n            );\n        }\n    }\n}"
    }
  ]
}