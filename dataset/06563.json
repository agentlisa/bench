{
  "Title": "[G-03] Use assembly to perform efficient back-to-back calls",
  "Content": "If similar external calls are performed back-to-back, we can use assembly to reuse any function signatures and function parameters that stay the same. In addition, we can also reuse the same memory space for each function call (`scratch space` + `free memory pointer`), which can potentially allow us to avoid memory expansion costs. In this case we are also able to efficiently store both function signatures together in memory as one word, saving one MLOAD in the process.\n\n**Note: In order to do this optimization safely we will cache and restore the free memory pointer after we are done with our function calls**.\n\nhttps://github.com/code-423n4/2023-05-juicebox/blob/main/juice-buyback/contracts/JBXBuybackDelegate.sol#L231-L232\n\n*Gas Savings for `JBXBuybackDelegate.didPay`, obtained via protocol's tests: Avg 392 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  148266  |  242106  |  161126 |    7     |\n| After  |  147874  |  241714  |  160902 |    7     |\n\n*Gas Savings for `JBXBuybackDelegate.uniswapV3SwapCallback`, obtained via protocol's tests: Avg 262 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  28794   |  30714   |  20125  |    6     |\n| After  |  28402   |  30322   |  19863  |    6     |\n\n```solidity\nFile: juice-buyback/contracts/JBXBuybackDelegate.sol\n231:        weth.deposit{value: _amountToSend}();\n232:        weth.transfer(address(pool), _amountToSend);\n```\n```diff\ndiff --git a/contracts/JBXBuybackDelegate.sol b/contracts/JBXBuybackDelegate.sol\nindex 0ee751b..9c252d5 100644\n--- a/contracts/JBXBuybackDelegate.sol\n+++ b/contracts/JBXBuybackDelegate.sol\n@@ -228,8 +228,20 @@ contract JBXBuybackDelegate is IJBFundingCycleDataSource, IJBPayDelegate, IUnisw\n         if (_amountReceived < _minimumAmountReceived) revert JuiceBuyback_MaximumSlippage();\n\n         // Wrap and transfer the weth to the pool\n-        weth.deposit{value: _amountToSend}();\n-        weth.transfer(address(pool), _amountToSend);\n+        IWETH9 _weth = weth;\n+        IUniswapV3Pool _pool = pool;\n+        assembly {\n+            // function selectors for `deposit()` & `transfer(address,uint256)`\n+            mstore(0x00, 0xd0e30db0a9059cbb)\n+            if iszero(call(gas(), _weth, _amountToSend, 0x18, 0x04, 0x00, 0x00)) {revert(0, 0)}\n+            // store memory pointer\n+            let memptr := mload(0x40)\n+            mstore(0x20, _pool)\n+            mstore(0x40, _amountToSend)\n+            if iszero(call(gas(), _weth, 0x00, 0x1c, 0x44, 0x00, 0x00)) {revert(0, 0)}\n+            // restore memory pointer\n+            mstore(0x40, memptr)\n+        }\n     }\n\n     function redeemParams(JBRedeemParamsData calldata _data)\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-05-juicebox",
  "Code": [
    {
      "filename": "juice-buyback/contracts/JBXBuybackDelegate.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"@jbx-protocol/juice-contracts-v3/contracts/interfaces/IJBController3_1.sol\";\nimport \"@jbx-protocol/juice-contracts-v3/contracts/interfaces/IJBFundingCycleDataSource.sol\";\nimport \"@jbx-protocol/juice-contracts-v3/contracts/interfaces/IJBPayDelegate.sol\";\nimport \"@jbx-protocol/juice-contracts-v3/contracts/interfaces/IJBPayoutRedemptionPaymentTerminal3_1.sol\";\nimport \"@jbx-protocol/juice-contracts-v3/contracts/interfaces/IJBFundingCycleBallot.sol\";\nimport \"@jbx-protocol/juice-contracts-v3/contracts/libraries/JBConstants.sol\";\nimport \"@jbx-protocol/juice-contracts-v3/contracts/libraries/JBFundingCycleMetadataResolver.sol\";\nimport \"@jbx-protocol/juice-contracts-v3/contracts/libraries/JBTokens.sol\";\nimport \"@jbx-protocol/juice-contracts-v3/contracts/structs/JBDidPayData.sol\";\nimport \"@jbx-protocol/juice-contracts-v3/contracts/structs/JBPayParamsData.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\n\nimport \"@paulrberg/contracts/math/PRBMath.sol\";\n\nimport \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\";\nimport \"@uniswap/v3-core/contracts/libraries/TickMath.sol\";\n\nimport \"./interfaces/external/IWETH9.sol\";\n\n/**\n * @custom:benediction DEVS BENEDICAT ET PROTEGAT CONTRACTVS MEAM\n *\n * @title  Buyback Delegate\n *\n * @notice Datasource and delegate allowing pay beneficiary to get the highest amount\n *         of project tokens between minting using the project weigh and swapping in a\n *         given Uniswap V3 pool\n *\n * @dev    This only supports ETH terminal. The pool is fixed, if a new pool offers deeper\n *         liquidity, this delegate needs to be redeployed.\n */\n\ncontract JBXBuybackDelegate is IJBFundingCycleDataSource, IJBPayDelegate, IUniswapV3SwapCallback, Ownable {\n    using JBFundingCycleMetadataResolver for JBFundingCycle;\n\n    //*********************************************************************//\n    // --------------------------- custom errors ------------------------- //\n    //*********************************************************************//\n\n    error JuiceBuyback_Unauthorized();\n    error JuiceBuyback_MaximumSlippage();\n\n    //*********************************************************************//\n    // -----------------------------  events ----------------------------- //\n    //*********************************************************************//\n\n    event JBXBuybackDelegate_Swap(uint256 projectId, uint256 amountEth, uint256 amountOut);\n    event JBXBuybackDelegate_Mint(uint256 projectId);\n\n    //*********************************************************************//\n    // --------------------- private constant properties ----------------- //\n    //*********************************************************************//\n\n    /**\n     * @notice Address project token < address terminal token ?\n     */\n    bool private immutable _projectTokenIsZero;\n\n    /**\n     * @notice The unit of the max slippage (expressed in 1/10000th)\n     */\n    uint256 private constant SLIPPAGE_DENOMINATOR = 10000;\n\n    //*********************************************************************//\n    // --------------------- public constant properties ------------------ //\n    //*********************************************************************//\n\n    /**\n     * @notice The project token address\n     * \n     * @dev In this context, this is the tokenOut\n     */\n    IERC20 public immutable projectToken;\n\n    /**\n     * @notice The uniswap pool corresponding to the project token-other token market\n     *         (this should be carefully chosen liquidity wise)\n     */\n    IUniswapV3Pool public immutable pool;\n\n    /**\n     * @notice The project terminal using this extension\n     */\n    IJBPayoutRedemptionPaymentTerminal3_1 public immutable jbxTerminal;\n\n    /**\n     * @notice The WETH contract\n     */\n    IWETH9 public immutable weth;\n\n    //*********************************************************************//\n    // --------------------- private stored properties ------------------- //\n    //*********************************************************************//\n\n    /**\n     * @notice The amount of token created if minted is prefered\n     * \n     * @dev    This is a mutex 1-x-1\n     */\n    uint256 private mintedAmount = 1;\n\n    /**\n     * @notice The current reserved rate\n     * \n     * @dev    This is a mutex 1-x-1\n     */\n    uint256 private reservedRate = 1;\n\n    /**\n     * @dev No other logic besides initializing the immutables\n     */\n    constructor(\n        IERC20 _projectToken,\n        IWETH9 _weth,\n        IUniswapV3Pool _pool,\n        IJBPayoutRedemptionPaymentTerminal3_1 _jbxTerminal\n    ) {\n        projectToken = _projectToken;\n        pool = _pool;\n        jbxTerminal = _jbxTerminal;\n        _projectTokenIsZero = address(_projectToken) < address(_weth);\n        weth = _weth;\n    }\n\n    //*********************************************************************//\n    // ---------------------- external functions ------------------------- //\n    //*********************************************************************//\n\n    /**\n     * @notice The datasource implementation\n     *\n     * @param  _data the data passed to the data source in terminal.pay(..). _data.metadata need to have the Uniswap quote\n     * @return weight the weight to use (the one passed if not max reserved rate, 0 if swapping or the one corresponding\n     *         to the reserved token to mint if minting)\n     * @return memo the original memo passed\n     * @return delegateAllocations The amount to send to delegates instead of adding to the local balance.\n     */\n    function payParams(JBPayParamsData calldata _data)\n        external\n        override\n        returns (uint256 weight, string memory memo, JBPayDelegateAllocation[] memory delegateAllocations)\n    {\n        // Find the total number of tokens to mint, as a fixed point number with 18 decimals\n        uint256 _tokenCount = PRBMath.mulDiv(_data.amount.value, _data.weight, 10 ** 18);\n\n        // Unpack the quote from the pool, given by the frontend\n        (,, uint256 _quote, uint256 _slippage) = abi.decode(_data.metadata, (bytes32, bytes32, uint256, uint256));\n\n        // If the amount swapped is bigger than the lowest received when minting, use the swap pathway\n        if (_tokenCount < _quote - (_quote * _slippage / SLIPPAGE_DENOMINATOR)) {\n            // Pass the quote and reserve rate via a mutex\n            mintedAmount = _tokenCount;\n            reservedRate = _data.reservedRate;\n\n            // Return this delegate as the one to use, and do not mint from the terminal\n            delegateAllocations = new JBPayDelegateAllocation[](1);\n            delegateAllocations[0] =\n                JBPayDelegateAllocation({delegate: IJBPayDelegate(this), amount: _data.amount.value});\n\n            return (0, _data.memo, delegateAllocations);\n        }\n\n        // If minting, do not use this as delegate\n        return (_data.weight, _data.memo, new JBPayDelegateAllocation[](0));\n    }\n\n    /**\n     * @notice Delegate to either swap to the beneficiary or mint to the beneficiary\n     *\n     * @dev    This delegate is called only if the quote for the swap is bigger than the lowest received when minting.\n     *         If the swap reverts (slippage, liquidity, etc), the delegate will then mint the same amount of token as\n     *         if the delegate was not used.\n     *         If the beneficiary requests non claimed token, the swap is not used (as it is, per definition, claimed token)\n     *\n     * @param _data the delegate data passed by the terminal\n     */\n    function didPay(JBDidPayData calldata _data) external payable override {\n        // Access control as minting is authorized to this delegate\n        if (msg.sender != address(jbxTerminal)) revert JuiceBuyback_Unauthorized();\n\n        // Retrieve the number of token created if minting and reset the mutex (not exposed in JBDidPayData)\n        uint256 _tokenCount = mintedAmount;\n        mintedAmount = 1;\n\n        // Retrieve the fc reserved rate and reset the mutex\n        uint256 _reservedRate = reservedRate;\n        reservedRate = 1;\n\n        // The minimum amount of token received if swapping\n        (,, uint256 _quote, uint256 _slippage) = abi.decode(_data.metadata, (bytes32, bytes32, uint256, uint256));\n        uint256 _minimumReceivedFromSwap = _quote - (_quote * _slippage / SLIPPAGE_DENOMINATOR);\n\n        // Pick the appropriate pathway (swap vs mint), use mint if non-claimed prefered\n        if (_data.preferClaimedTokens) {\n            // Try swapping\n            uint256 _amountReceived = _swap(_data, _minimumReceivedFromSwap, _reservedRate);\n\n            // If swap failed, mint instead, with the original weight + add to balance the token in\n            if (_amountReceived == 0) _mint(_data, _tokenCount);\n        } else {\n            _mint(_data, _tokenCount);\n        }\n    }\n\n    /**\n     * @notice The Uniswap V3 pool callback (where token transfer should happens)\n     *\n     * @dev    Slippage controle is achieved here\n     */\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external override {\n        // Check if this is really a callback\n        if (msg.sender != address(pool)) revert JuiceBuyback_Unauthorized();\n\n        // Unpack the data\n        (uint256 _minimumAmountReceived) = abi.decode(data, (uint256));\n\n        // Assign 0 and 1 accordingly\n        uint256 _amountReceived = uint256(-(_projectTokenIsZero ? amount0Delta : amount1Delta));\n        uint256 _amountToSend = uint256(_projectTokenIsZero ? amount1Delta : amount0Delta);\n\n        // Revert if slippage is too high\n        if (_amountReceived < _minimumAmountReceived) revert JuiceBuyback_MaximumSlippage();\n\n        // Wrap and transfer the weth to the pool\n        weth.deposit{value: _amountToSend}();\n        weth.transfer(address(pool), _amountToSend);\n    }\n\n    function redeemParams(JBRedeemParamsData calldata _data)\n        external\n        override\n        returns (uint256 reclaimAmount, string memory memo, JBRedemptionDelegateAllocation[] memory delegateAllocations)\n    {}\n\n    //*********************************************************************//\n    // ---------------------- internal functions ------------------------- //\n    //*********************************************************************//\n\n    /**\n     * @notice Swap the terminal token to receive the project toke_beforeTransferTon\n     *\n     * @dev    This delegate first receive the whole amount of project token,\n     *         then send the non-reserved token to the beneficiary,\n     *         then burn the rest of this delegate balance (ie the amount of reserved token),\n     *         then mint the same amount as received (this will add the reserved token, following the fc rate)\n     *         then burn the difference (ie this delegate balance)\n     *         -> End result is having the correct balances (beneficiary and reserve), according to the reserve rate\n     *\n     * @param  _data the didPayData passed by the terminal\n     * @param  _minimumReceivedFromSwap the minimum amount received, to prevent slippage\n     */\n    function _swap(JBDidPayData calldata _data, uint256 _minimumReceivedFromSwap, uint256 _reservedRate)\n        internal\n        returns (uint256 _amountReceived)\n    {\n        // Pass the token and min amount to receive as extra data\n        try pool.swap({\n            recipient: address(this),\n            zeroForOne: !_projectTokenIsZero,\n            amountSpecified: int256(_data.amount.value),\n            sqrtPriceLimitX96: _projectTokenIsZero ? TickMath.MAX_SQRT_RATIO - 1 : TickMath.MIN_SQRT_RATIO + 1,\n            data: abi.encode(_minimumReceivedFromSwap)\n        }) returns (int256 amount0, int256 amount1) {\n            // Swap succeded, take note of the amount of projectToken received (negative as it is an exact input)\n            _amountReceived = uint256(-(_projectTokenIsZero ? amount0 : amount1));\n        } catch {\n            // implies _amountReceived = 0 -> will later mint when back in didPay\n            return _amountReceived;\n        }\n\n        // The amount to send to the beneficiary\n        uint256 _nonReservedToken = PRBMath.mulDiv(\n            _amountReceived, JBConstants.MAX_RESERVED_RATE - _reservedRate, JBConstants.MAX_RESERVED_RATE\n        );\n\n        // The amount to add to the reserved token\n        uint256 _reservedToken = _amountReceived - _nonReservedToken;\n\n        // Send the non-reserved token to the beneficiary (if any / reserved rate is not max)\n        if (_nonReservedToken != 0) projectToken.transfer(_data.beneficiary, _nonReservedToken);\n\n        // If there are reserved token, add them to the reserve\n        if (_reservedToken != 0) {\n            IJBController controller = IJBController(jbxTerminal.directory().controllerOf(_data.projectId));\n\n            // 1) Burn all the reserved token, which are in this address -> result: 0 here, 0 in reserve\n            controller.burnTokensOf({\n                _holder: address(this),\n                _projectId: _data.projectId,\n                _tokenCount: _reservedToken,\n                _memo: \"\",\n                _preferClaimedTokens: true\n            });\n\n            // 2) Mint the reserved token with this address as beneficiary -> result: _amountReceived-reserved here, reservedToken in reserve\n            controller.mintTokensOf({\n                _projectId: _data.projectId,\n                _tokenCount: _amountReceived,\n                _beneficiary: address(this),\n                _memo: _data.memo,\n                _preferClaimedTokens: false,\n                _useReservedRate: true\n            });\n\n            // 3) Burn the non-reserve token which are now left in this address (can be 0) -> result: 0 here, reservedToken in reserve\n            uint256 _nonReservedTokenInContract = _amountReceived - _reservedToken;\n\n            if (_nonReservedTokenInContract != 0) {\n                controller.burnTokensOf({\n                    _holder: address(this),\n                    _projectId: _data.projectId,\n                    _tokenCount: _nonReservedTokenInContract,\n                    _memo: \"\",\n                    _preferClaimedTokens: false\n                });\n            }\n        }\n\n        emit JBXBuybackDelegate_Swap(_data.projectId, _data.amount.value, _amountReceived);\n    }\n\n    /**\n     * @notice Mint the token out, sending back the token in in the terminal\n     *\n     * @param  _data the didPayData passed by the terminal\n     * @param  _amount the amount of token out to mint\n     */\n    function _mint(JBDidPayData calldata _data, uint256 _amount) internal {\n        IJBController controller = IJBController(jbxTerminal.directory().controllerOf(_data.projectId));\n\n        // Mint to the beneficiary with the fc reserve rate\n        controller.mintTokensOf({\n            _projectId: _data.projectId,\n            _tokenCount: _amount,\n            _beneficiary: _data.beneficiary,\n            _memo: _data.memo,\n            _preferClaimedTokens: _data.preferClaimedTokens,\n            _useReservedRate: true\n        });\n\n        // Send the eth back to the terminal balance\n        jbxTerminal.addToBalanceOf{value: _data.amount.value}(\n            _data.projectId, _data.amount.value, JBTokens.ETH, \"\", new bytes(0)\n        );\n\n        emit JBXBuybackDelegate_Mint(_data.projectId);\n    }\n\n    //*********************************************************************//\n    // ---------------------- peripheral functions ----------------------- //\n    //*********************************************************************//\n\n    function supportsInterface(bytes4 _interfaceId) external pure override returns (bool) {\n        return _interfaceId == type(IJBFundingCycleDataSource).interfaceId\n            || _interfaceId == type(IJBPayDelegate).interfaceId;\n    }\n}"
    }
  ]
}