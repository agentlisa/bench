{
  "Title": "[L04] Lack of input validation",
  "Content": "There are several instances of `external` functions failing to validate the input parameters they are provided. For example:\n\n\n* In the `setParameters` function on [line 94 of `CashMarket.sol`](https://github.com/notional-finance/contracts/blob/b6fc6be4622422d0e34c90e77f2ec9da18596b8c/contracts/CashMarket.sol#L94) and the `createCashGroup` function on [line 140 of `Portfolios.sol`](https://github.com/notional-finance/contracts/blob/b6fc6be4622422d0e34c90e77f2ec9da18596b8c/contracts/Portfolios.sol#L140), `maturityLength` can be set arbitrarily. In practice, a market with an extremely large maturity length would likely not have many participants. Even so, if `maturityLength` were too large, it would lead to erroneous cash ladders. If `maturityLength` were set to zero, it would lead to reversions caused by division by zero.\n* In the `setFee` function on [line 150 of `CashMarket.sol`](https://github.com/notional-finance/contracts/blob/b6fc6be4622422d0e34c90e77f2ec9da18596b8c/contracts/CashMarket.sol#L150), neither `liquidityFee` nor `transactionFee` are given upper bounds. Values that are too large will lead to reversions in several critical functions.\n* In the `setParameters` function on [line 94 of `CashMarket.sol`](https://github.com/notional-finance/contracts/blob/b6fc6be4622422d0e34c90e77f2ec9da18596b8c/contracts/CashMarket.sol#L94), `numMaturities` can be set to `0` which would cause reversions in several critical functions.\n* In the `settleCashBalanceBatch` function on [line 682 of `Escrow.sol`](https://github.com/notional-finance/contracts/blob/b6fc6be4622422d0e34c90e77f2ec9da18596b8c/contracts/Escrow.sol#L682), the length of `values` and `payers` is not required to be equal. Unequal lengths will lead to a reversion after potentially burning non-negligible amounts of gas.\n* In the `setHaircuts` function on [line 100 of `Portfolios.sol`](https://github.com/notional-finance/contracts/blob/b6fc6be4622422d0e34c90e77f2ec9da18596b8c/contracts/Portfolios.sol#L100), the values passed in for the various “haircuts” can be arbitrarily large. This is in contradiction with the intention of the codebase and the comment provided in the [NatSpec `@notice` tag of this same function](https://github.com/notional-finance/contracts/blob/b6fc6be4622422d0e34c90e77f2ec9da18596b8c/contracts/Portfolios.sol#L93).\n* In the `updateCashGroup` function [on line 182 of `Portfolios.sol`](https://github.com/notional-finance/contracts/blob/b6fc6be4622422d0e34c90e77f2ec9da18596b8c/contracts/Portfolios.sol#L182), the NatSpec comments list several guidelines for each input, but none of those guidelines are enforced in the code.\n\n\nTo avoid errors and unexpected system behavior, consider explicitly restricting the range of inputs that can be accepted for all externally-provided inputs via `require` clauses where appropriate.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/CashMarket.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./lib/SafeUInt128.sol\";\nimport \"./lib/SafeInt256.sol\";\nimport \"./lib/ABDKMath64x64.sol\";\nimport \"./lib/SafeMath.sol\";\n\nimport \"./utils/Governed.sol\";\nimport \"./utils/Common.sol\";\n\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\n\n/**\n * @title CashMarket\n * @notice Marketplace for trading cash to fCash tokens. Implements a specialized AMM for trading such assets.\n */\ncontract CashMarket is Governed {\n    using SafeUInt128 for uint128;\n    using SafeMath for uint256;\n    using SafeInt256 for int256;\n\n    // This is used in _tradeCalculation to shift the ln calculation\n    int128 internal constant PRECISION_64x64 = 0x3b9aca000000000000000000;\n    uint256 internal constant MAX64 = 0x7FFFFFFFFFFFFFFF;\n    int64 internal constant LN_1E18 = 0x09a667e259;\n    bool internal constant CHECK_FC = true;\n    bool internal constant DEFER_CHECK = false;\n\n    /**\n     * @dev skip\n     */\n    function initializeDependencies() external {\n        // Setting dependencies can only be done once here. With proxy contracts the addresses shouldn't\n        // change as we upgrade the logic.\n        Governed.CoreContracts[] memory dependencies = new Governed.CoreContracts[](3);\n        dependencies[0] = CoreContracts.Escrow;\n        dependencies[1] = CoreContracts.Portfolios;\n        dependencies[2] = CoreContracts.ERC1155Trade;\n        _setDependencies(dependencies);\n    }\n\n    // Defines the fields for each market in each maturity.\n    struct Market {\n        // Total amount of fCash available for purchase in the market.\n        uint128 totalfCash;\n        // Total amount of liquidity tokens (representing a claim on liquidity) in the market.\n        uint128 totalLiquidity;\n        // Total amount of cash available for purchase in the market.\n        uint128 totalCurrentCash;\n        // These factors are set when the market is instantiated by a liquidity provider via the global\n        // settings and then held constant for the duration of the maturity. We cannot change them without\n        // really messing up the market rates.\n        uint16 rateScalar;\n        uint32 rateAnchor;\n        // This is the implied rate that we use to smooth the anchor rate between trades.\n        uint32 lastImpliedRate;\n    }\n\n    // This is a mapping between a maturity and its corresponding market.\n    mapping(uint32 => Market) public markets;\n\n    /********** Governance Parameters *********************/\n\n    // These next parameters are set by the Portfolios contract and are immutable, except for G_NUM_MATURITIES\n    uint8 public CASH_GROUP;\n    uint32 internal constant INSTRUMENT_PRECISION = 1e9;\n    uint32 public G_MATURITY_LENGTH;\n    uint32 public G_NUM_MATURITIES;\n\n    // These are governance parameters for the market itself and can be set by the owner.\n\n    // The maximum trade size denominated in local currency\n    uint128 public G_MAX_TRADE_SIZE;\n\n    // The y-axis shift of the rate curve\n    uint32 public G_RATE_ANCHOR;\n    // The slope of the rate curve\n    uint16 public G_RATE_SCALAR;\n    // The fee in basis points given to liquidity providers\n    uint32 public G_LIQUIDITY_FEE;\n    // The fee as a percentage of the cash traded given to the protocol\n    uint128 public G_TRANSACTION_FEE;\n\n    /**\n     * @notice Sets governance parameters on the rate oracle.\n     * @dev skip\n     * @param cashGroupId this cannot change once set\n     * @param precision will only take effect on a new maturity\n     * @param maturityLength will take effect immediately, must be careful\n     * @param numMaturities will take effect immediately, makers can create new markets\n     */\n    function setParameters(\n        uint8 cashGroupId,\n        uint16 /* instrumentId */,\n        uint32 precision,\n        uint32 maturityLength,\n        uint32 numMaturities,\n        uint32 /* maxRate */\n    ) external {\n        require(calledByPortfolios(), $$(ErrorCode(UNAUTHORIZED_CALLER)));\n\n        // These values cannot be reset once set.\n        if (CASH_GROUP == 0) {\n            CASH_GROUP = cashGroupId;\n        }\n\n        require(precision == 1e9, $$(ErrorCode(INVALID_INSTRUMENT_PRECISION)));\n        G_MATURITY_LENGTH = maturityLength;\n        G_NUM_MATURITIES = numMaturities;\n    }\n\n    /**\n     * @notice Sets rate factors that will determine the liquidity curve. Rate Anchor is set as the target annualized exchange\n     * rate so 1.10 * INSTRUMENT_PRECISION represents a target annualized rate of 10%. Rate anchor will be scaled accordingly\n     * when a fCash market is initialized. As a general default, INSTRUMENT_PRECISION will be set to 1e9.\n     * @dev governance\n     * @param rateAnchor the offset of the liquidity curve\n     * @param rateScalar the sensitivity of the liquidity curve to changes\n     */\n    function setRateFactors(uint32 rateAnchor, uint16 rateScalar) external onlyOwner {\n        require(rateScalar > 0 && rateAnchor > 0, $$(ErrorCode(INVALID_RATE_FACTORS)));\n        G_RATE_SCALAR = rateScalar;\n        G_RATE_ANCHOR = rateAnchor;\n\n        emit UpdateRateFactors(rateAnchor, rateScalar);\n    }\n\n    /**\n     * @notice Sets the maximum amount that can be traded in a single trade.\n     * @dev governance\n     * @param amount the max trade size\n     */\n    function setMaxTradeSize(uint128 amount) external onlyOwner {\n        G_MAX_TRADE_SIZE = amount;\n\n        emit UpdateMaxTradeSize(amount);\n    }\n\n    /**\n     * @notice Sets fee parameters for the market. Liquidity Fees are set as basis points and shift the traded\n     * exchange rate. A basis point is the equivalent of 1e5 if INSTRUMENT_PRECISION is set to 1e9.\n     * Transaction fees are set as a percentage shifted by 1e18. For example a 1% transaction fee will be set\n     * as 1.01e18.\n     * @dev governance\n     * @param liquidityFee a change in the traded exchange rate paid to liquidity providers\n     * @param transactionFee percentage of a transaction that accrues to the reserve account\n     */\n    function setFee(uint32 liquidityFee, uint128 transactionFee) external onlyOwner {\n        G_LIQUIDITY_FEE = liquidityFee;\n        G_TRANSACTION_FEE = transactionFee;\n\n        emit UpdateFees(liquidityFee, transactionFee);\n    }\n\n    /********** Governance Parameters *********************/\n\n    /********** Events ************************************/\n    /**\n     * @notice Emitted when rate factors are updated, will take effect at the next maturity\n     * @param rateAnchor the new rate anchor\n     * @param rateScalar the new rate scalar\n     */\n    event UpdateRateFactors(uint32 rateAnchor, uint16 rateScalar);\n\n    /**\n     * @notice Emitted when max trade size is updated, takes effect immediately\n     * @param maxTradeSize the new max trade size\n     */\n    event UpdateMaxTradeSize(uint128 maxTradeSize);\n\n    /**\n     * @notice Emitted when fees are updated, takes effect immediately\n     * @param liquidityFee the new liquidity fee\n     * @param transactionFee the new transaction fee\n     */\n    event UpdateFees(uint32 liquidityFee, uint128 transactionFee);\n\n    /**\n     * @notice Emitted when liquidity is added to a maturity\n     * @param account the account that performed the trade\n     * @param maturity the maturity that this trade affects\n     * @param tokens amount of liquidity tokens issued\n     * @param fCash amount of fCash tokens added\n     * @param cash amount of cash tokens added\n     */\n    event AddLiquidity(\n        address indexed account,\n        uint32 maturity,\n        uint128 tokens,\n        uint128 fCash,\n        uint128 cash\n    );\n\n    /**\n     * @notice Emitted when liquidity is removed from a maturity\n     * @param account the account that performed the trade\n     * @param maturity the maturity that this trade affects\n     * @param tokens amount of liquidity tokens burned\n     * @param fCash amount of fCash tokens removed\n     * @param cash amount of cash tokens removed\n     */\n    event RemoveLiquidity(\n        address indexed account,\n        uint32 maturity,\n        uint128 tokens,\n        uint128 fCash,\n        uint128 cash\n    );\n\n    /**\n     * @notice Emitted when cash is taken from a maturity\n     * @param account the account that performed the trade\n     * @param maturity the maturity that this trade affects\n     * @param fCash amount of fCash tokens added\n     * @param cash amount of cash tokens removed\n     * @param fee amount of transaction fee charged\n     */\n    event TakeCurrentCash(address indexed account, uint32 maturity, uint128 fCash, uint128 cash, uint128 fee);\n\n    /**\n     * @notice Emitted when fCash is taken from a maturity\n     * @param account the account that performed the trade\n     * @param maturity the maturity that this trade affects\n     * @param fCash amount of fCash tokens removed\n     * @param cash amount of cash tokens added\n     * @param fee amount of transaction fee charged\n     */\n    event TakefCash(address indexed account, uint32 maturity, uint128 fCash, uint128 cash, uint128 fee);\n\n    /********** Events ************************************/\n\n    /********** Liquidity Tokens **************************/\n\n    /**\n     * @notice Adds some amount of cash to the liquidity pool up to the corresponding amount defined by\n     * `maxfCash`. Mints liquidity tokens back to the sender.\n     * @dev - TRADE_FAILED_MAX_TIME: maturity specified is not yet active\n     * - MARKET_INACTIVE: maturity is not a valid one\n     * - OVER_MAX_FCASH: fCash amount required exceeds supplied maxfCash\n     * - OUT_OF_IMPLIED_RATE_BOUNDS: depositing cash would require more fCash than specified\n     * - INSUFFICIENT_BALANCE: insufficient cash to deposit into market\n     * @param maturity the maturity to add liquidity to\n     * @param cash the amount of cash to add to the pool\n     * @param maxfCash the max amount of fCash to add to the pool. When initializing a pool this is the\n     * amount of fCash that will be added.\n     * @param minImpliedRate the minimum implied rate that we will add liquidity at\n     * @param maxImpliedRate the maximum implied rate that we will add liquidity at\n     * @param maxTime after this time the trade will fail\n     */\n    function addLiquidity(\n        uint32 maturity,\n        uint128 cash,\n        uint128 maxfCash,\n        uint32 minImpliedRate,\n        uint32 maxImpliedRate,\n        uint32 maxTime\n    ) external {\n        Common.Asset[] memory assets = _addLiquidity(\n            msg.sender,\n            maturity,\n            cash,\n            maxfCash,\n            minImpliedRate,\n            maxImpliedRate,\n            maxTime\n        );\n\n        // This will do a free collateral check before it adds to the portfolio.\n        Portfolios().upsertAccountAssetBatch(msg.sender, assets, CHECK_FC);\n    }\n\n    /**\n     * @notice Used by ERC1155 contract to add liquidity\n     * @dev skip\n     */\n    function addLiquidityOnBehalf(\n        address account,\n        uint32 maturity,\n        uint128 cash,\n        uint128 maxfCash,\n        uint32 minImpliedRate,\n        uint32 maxImpliedRate\n    ) external {\n        require(calledByERC1155Trade(), $$(ErrorCode(UNAUTHORIZED_CALLER)));\n\n        Common.Asset[] memory assets = _addLiquidity(\n            account,\n            maturity,\n            cash,\n            maxfCash,\n            minImpliedRate,\n            maxImpliedRate,\n            uint32(block.timestamp)\n        );\n\n        Portfolios().upsertAccountAssetBatch(account, assets, DEFER_CHECK);\n    }\n\n    function _addLiquidity(\n        address account,\n        uint32 maturity,\n        uint128 cash,\n        uint128 maxfCash,\n        uint32 minImpliedRate,\n        uint32 maxImpliedRate,\n        uint32 maxTime\n    ) internal returns (Common.Asset[] memory) {\n        _isValidBlock(maturity, maxTime);\n        uint32 timeToMaturity = maturity - uint32(block.timestamp);\n        Market memory market = markets[maturity];\n        // We call settle here instead of at the end of the function because if we have matured liquidity\n        // tokens this will put cash back into our portfolio so that we can add it back into the markets.\n        Portfolios().settleMaturedAssets(account);\n\n        uint128 fCash;\n        uint128 liquidityTokenAmount;\n        if (market.totalLiquidity == 0) {\n            // We check the rateScalar to determine if the market exists or not. The reason for this is that once we\n            // initialize a market we will set the rateScalar and rateAnchor based on global values for the duration\n            // of the market. The proportion of fCash to cash that the first liquidity provider sets here will\n            // determine the initial exchange rate of the market (taking into account rateScalar and rateAnchor, of course).\n            // Governance will never allow rateScalar to be set to 0.\n            if (market.rateScalar == 0) {\n                market.rateScalar = G_RATE_SCALAR;\n            }\n\n            // G_RATE_ANCHOR is stored as the annualized rate. Here we normalize it to the rate that is required given the\n            // time to maturity. (RATE_ANCHOR - 1) * timeToMaturity / SECONDS_IN_YEAR + 1\n            market.rateAnchor = SafeCast.toUint32(\n                uint256(G_RATE_ANCHOR)\n                    .sub(INSTRUMENT_PRECISION)\n                    .mul(timeToMaturity)\n                    .div(Common.SECONDS_IN_YEAR)\n                    .add(INSTRUMENT_PRECISION)\n            );\n\n            market.totalfCash = maxfCash;\n            market.totalCurrentCash = cash;\n            market.totalLiquidity = cash;\n            // We have to initialize this to the exchange rate implied by the proportion of cash to fCash.\n            uint32 impliedRate = _getImpliedRateRequire(market, timeToMaturity);\n            require(minImpliedRate <= maxImpliedRate \n                && minImpliedRate <= impliedRate && impliedRate <= maxImpliedRate,\n                $$(ErrorCode(OUT_OF_IMPLIED_RATE_BOUNDS))\n            );\n            market.lastImpliedRate = impliedRate;\n\n            liquidityTokenAmount = cash;\n            fCash = maxfCash;\n        } else {\n            // We calculate the amount of liquidity tokens to mint based on the share of the fCash\n            // that the liquidity provider is depositing.\n            liquidityTokenAmount = SafeCast.toUint128(\n                uint256(market.totalLiquidity).mul(cash).div(market.totalCurrentCash)\n            );\n\n            // We use the prevailing proportion to calculate the required amount of current cash to deposit.\n            fCash = SafeCast.toUint128(uint256(market.totalfCash).mul(cash).div(market.totalCurrentCash));\n            require(fCash <= maxfCash, $$(ErrorCode(OVER_MAX_FCASH)));\n\n            // Add the fCash and cash to the pool.\n            market.totalfCash = market.totalfCash.add(fCash);\n            market.totalCurrentCash = market.totalCurrentCash.add(cash);\n            market.totalLiquidity = market.totalLiquidity.add(liquidityTokenAmount);\n\n            // If this proportion has moved beyond what the liquidity provider is willing to pay then we\n            // will revert here. The implied rate will not change when liquidity is added.\n            require(minImpliedRate <= maxImpliedRate \n                && minImpliedRate <= market.lastImpliedRate && market.lastImpliedRate <= maxImpliedRate,\n                $$(ErrorCode(OUT_OF_IMPLIED_RATE_BOUNDS))\n            );\n\n        }\n\n        markets[maturity] = market;\n\n        // Move the cash into the contract's cash balances account. This must happen before the trade\n        // is placed so that the free collateral check is correct.\n        Escrow().depositIntoMarket(account, CASH_GROUP, cash, 0);\n\n        // Providing liquidity results in two tokens generated, a liquidity token and a CASH_PAYER which\n        // represents the obligation that offsets the fCash in the market.\n        Common.Asset[] memory assets = new Common.Asset[](2);\n        // This is the liquidity token\n        assets[0] = Common.Asset(\n            CASH_GROUP,\n            0,\n            maturity,\n            Common.getLiquidityToken(),\n            0,\n            liquidityTokenAmount\n        );\n\n        // This is the CASH_PAYER\n        assets[1] = Common.Asset(\n            CASH_GROUP,\n            0,\n            maturity,\n            Common.getCashPayer(),\n            0,\n            fCash\n        );\n\n        emit AddLiquidity(account, maturity, liquidityTokenAmount, fCash, cash);\n\n        return assets;\n    }\n\n    /**\n     * @notice Removes liquidity from the fCash market. The sender's liquidity tokens are burned and they\n     * are credited back with fCash and cash at the prevailing exchange rate. This function\n     * only works when removing liquidity from an active market. For markets that are matured, the sender\n     * must settle their liquidity token via `Portfolios.settleMaturedAssets`.\n     * @dev - TRADE_FAILED_MAX_TIME: maturity specified is not yet active\n     * - MARKET_INACTIVE: maturity is not a valid one\n     * - INSUFFICIENT_BALANCE: account does not have sufficient tokens to remove\n     * @param maturity the maturity to remove liquidity from\n     * @param amount the amount of liquidity tokens to burn\n     * @param maxTime after this block the trade will fail\n     * @return the amount of cash claim the removed liquidity tokens have\n     */\n    function removeLiquidity(\n        uint32 maturity,\n        uint128 amount,\n        uint32 maxTime\n    ) external returns (uint128) {\n        (Common.Asset[] memory assets, uint128 cash) = _removeLiquidity(\n            msg.sender,\n            maturity,\n            amount,\n            maxTime\n        );\n\n        // This function call will check if the account in question actually has\n        // enough liquidity tokens to remove.\n        Portfolios().upsertAccountAssetBatch(msg.sender, assets, CHECK_FC);\n\n        return cash;\n    }\n\n    /**\n     * @notice Used by ERC1155 contract to remove liquidity\n     * @dev skip\n     */\n    function removeLiquidityOnBehalf(\n        address account,\n        uint32 maturity,\n        uint128 amount\n    ) external returns (uint128) {\n        require(calledByERC1155Trade(), $$(ErrorCode(UNAUTHORIZED_CALLER)));\n\n        (Common.Asset[] memory assets, uint128 cash) = _removeLiquidity(\n            account,\n            maturity,\n            amount,\n            uint32(block.timestamp)\n        );\n\n        Portfolios().upsertAccountAssetBatch(account, assets, DEFER_CHECK);\n\n        return cash;\n    }\n\n    function _removeLiquidity(\n        address account,\n        uint32 maturity,\n        uint128 amount,\n        uint32 maxTime\n    ) internal returns (Common.Asset[] memory, uint128) {\n        // This method only works when the market is active.\n        uint32 blockTime = uint32(block.timestamp);\n        require(blockTime <= maxTime, $$(ErrorCode(TRADE_FAILED_MAX_TIME)));\n        require(blockTime < maturity, $$(ErrorCode(MARKET_INACTIVE)));\n\n        Market memory market = markets[maturity];\n\n        // Here we calculate the amount of current cash that the liquidity token represents.\n        uint128 cash = SafeCast.toUint128(uint256(market.totalCurrentCash).mul(amount).div(market.totalLiquidity));\n        market.totalCurrentCash = market.totalCurrentCash.sub(cash);\n\n        // This is the amount of fCash that the liquidity token has a claim to.\n        uint128 fCashAmount = SafeCast.toUint128(uint256(market.totalfCash).mul(amount).div(market.totalLiquidity));\n        market.totalfCash = market.totalfCash.sub(fCashAmount);\n\n        // We do this calculation after the previous two so that we do not mess with the totalLiquidity\n        // figure when calculating fCash and cash.\n        market.totalLiquidity = market.totalLiquidity.sub(amount);\n\n        markets[maturity] = market;\n\n        // Move the cash from the contract's cash balances account back to the sender. This must happen\n        // before the free collateral check in the Portfolio call below.\n        Escrow().withdrawFromMarket(account, CASH_GROUP, cash, 0);\n\n        Common.Asset[] memory assets = new Common.Asset[](2);\n        // This will remove the liquidity tokens\n        assets[0] = Common.Asset(\n            CASH_GROUP,\n            0,\n            maturity,\n            // We mark this as a \"PAYER\" liquidity token so the portfolio reduces the balance\n            Common.makeCounterparty(Common.getLiquidityToken()),\n            0,\n            amount\n        );\n\n        // This is the CASH_RECEIVER\n        assets[1] = Common.Asset(\n            CASH_GROUP,\n            0,\n            maturity,\n            Common.getCashReceiver(),\n            0,\n            fCashAmount\n        );\n\n        emit RemoveLiquidity(account, maturity, amount, fCashAmount, cash);\n        return (assets, cash);\n    }\n\n    /**\n     * @notice Settles a liquidity token into fCash and cash. Can only be called by the Portfolios contract.\n     * @dev skip\n     * @param account the account that is holding the token\n     * @param tokenAmount the amount of token to settle\n     * @param maturity when the token matures\n     * @return the amount of cash to settle to the account\n     */\n    function settleLiquidityToken(\n        address account,\n        uint128 tokenAmount,\n        uint32 maturity\n    ) external returns (uint128) {\n        require(calledByPortfolios(), $$(ErrorCode(UNAUTHORIZED_CALLER)));\n\n        (uint128 cash, uint128 fCash) = _settleLiquidityToken(tokenAmount, maturity);\n\n        // Move the cash from the contract's cash balances account back to the sender\n        Escrow().withdrawFromMarket(account, CASH_GROUP, cash, 0);\n\n        // No need to remove the liquidity token from the portfolio, the calling function will take care of this.\n\n        // The liquidity token carries with it an obligation to pay a certain amount of fCash and we credit that\n        // amount plus any appreciation here. This amount will be added to the cashBalances for the account to offset\n        // the CASH_PAYER token that was created when the liquidity token was minted.\n        return fCash;\n    }\n\n    /**\n     * @notice Internal method for settling liquidity tokens, calculates the values for cash and fCash\n     *\n     * @param tokenAmount the amount of token to settle\n     * @param maturity when the token matures\n     * @return the amount of cash and fCash\n     */\n    function _settleLiquidityToken(uint128 tokenAmount, uint32 maturity) internal returns (uint128, uint128) {\n        Market memory market = markets[maturity];\n\n        // Here we calculate the amount of cash that the liquidity token represents.\n        uint128 cash = SafeCast.toUint128(uint256(market.totalCurrentCash).mul(tokenAmount).div(market.totalLiquidity));\n        market.totalCurrentCash = market.totalCurrentCash.sub(cash);\n\n        // This is the amount of fCash that the liquidity token has a claim to.\n        uint128 fCash = SafeCast.toUint128(uint256(market.totalfCash).mul(tokenAmount).div(market.totalLiquidity));\n        market.totalfCash = market.totalfCash.sub(fCash);\n\n        // We do this calculation after the previous two so that we do not mess with the totalLiquidity\n        // figure when calculating fCash and cash.\n        market.totalLiquidity = market.totalLiquidity.sub(tokenAmount);\n\n        markets[maturity] = market;\n\n        return (cash, fCash);\n    }\n\n    /********** Liquidity Tokens **************************/\n\n    /********** Trading Cash ******************************/\n\n    /**\n     * @notice Given the amount of fCash put into a market, how much cash this would\n     * purchase at the current block.\n     * @param maturity the maturity of the fCash\n     * @param fCashAmount the amount of fCash to input\n     * @return the amount of cash this would purchase, returns 0 if the trade will fail\n     */\n    function getfCashToCurrentCash(uint32 maturity, uint128 fCashAmount) public view returns (uint128) {\n        return getfCashToCurrentCashAtTime(maturity, fCashAmount, uint32(block.timestamp));\n    }\n\n    /**\n     * @notice Given the amount of fCash put into a market, how much cash this would\n     * purchase at the given time. fCash exchange rates change as we go towards maturity.\n     * @dev - CANNOT_GET_PRICE_FOR_MATURITY: can only get prices before the maturity\n     * @param maturity the maturity of the fCash\n     * @param fCashAmount the amount of fCash to input\n     * @param blockTime the specified block time\n     * @return the amount of cash this would purchase, returns 0 if the trade will fail\n     */\n    function getfCashToCurrentCashAtTime(\n        uint32 maturity,\n        uint128 fCashAmount,\n        uint32 blockTime\n    ) public view returns (uint128) {\n        Market memory interimMarket = markets[maturity];\n        require(blockTime < maturity, $$(ErrorCode(CANNOT_GET_PRICE_FOR_MATURITY)));\n\n        uint32 timeToMaturity = maturity - blockTime;\n\n        ( /* market */, uint128 cash) = _tradeCalculation(interimMarket, int256(fCashAmount), timeToMaturity);\n        // On trade failure, we will simply return 0\n        uint128 fee = _calculateTransactionFee(cash, timeToMaturity);\n        return cash.sub(fee);\n    }\n\n    /**\n     * @notice Receive cash in exchange for a fCash obligation. Equivalent to borrowing\n     * cash at a fixed rate.\n     * @dev - TRADE_FAILED_MAX_TIME: maturity specified is not yet active\n     * - MARKET_INACTIVE: maturity is not a valid one\n     * - TRADE_FAILED_TOO_LARGE: trade is larger than allowed by the governance settings\n     * - TRADE_FAILED_LACK_OF_LIQUIDITY: there is insufficient liquidity in this maturity to handle the trade\n     * - TRADE_FAILED_SLIPPAGE: trade is greater than the max implied rate set\n     * - INSUFFICIENT_FREE_COLLATERAL: insufficient free collateral to take on the debt\n     * @param maturity the maturity of the fCash being exchanged for current cash\n     * @param fCashAmount the amount of fCash to sell, will convert this amount to current cash\n     *  at the prevailing exchange rate.\n     * @param maxTime after this time the trade will not settle\n     * @param maxImpliedRate the maximum implied maturity rate that the borrower will accept\n     * @return the amount of cash purchased, `fCashAmount - cash` determines the fixed interested owed.\n     */\n    function takeCurrentCash(\n        uint32 maturity,\n        uint128 fCashAmount,\n        uint32 maxTime,\n        uint32 maxImpliedRate\n    ) external returns (uint128) {\n        (Common.Asset memory asset, uint128 cash) = _takeCurrentCash(\n            msg.sender,\n            maturity,\n            fCashAmount,\n            maxTime,\n            maxImpliedRate\n        );\n\n        // This will do a free collateral check before it adds to the portfolio.\n        Portfolios().upsertAccountAsset(msg.sender, asset, CHECK_FC);\n\n        return cash;\n    }\n\n    /**\n     * @notice Used by ERC1155 contract to take cash\n     * @dev skip\n     */\n    function takeCurrentCashOnBehalf(\n        address account,\n        uint32 maturity,\n        uint128 fCashAmount,\n        uint32 maxImpliedRate\n    ) external returns (uint128) {\n        require(calledByERC1155Trade(), $$(ErrorCode(UNAUTHORIZED_CALLER)));\n\n        (Common.Asset memory asset, uint128 cash) = _takeCurrentCash(\n            account,\n            maturity,\n            fCashAmount,\n            uint32(block.timestamp),\n            maxImpliedRate\n        );\n\n        Portfolios().upsertAccountAsset(account, asset, DEFER_CHECK);\n\n        return cash;\n    }\n\n    function _takeCurrentCash(\n        address account,\n        uint32 maturity,\n        uint128 fCashAmount,\n        uint32 maxTime,\n        uint32 maxImpliedRate\n    ) internal returns (Common.Asset memory, uint128) {\n        _isValidBlock(maturity, maxTime);\n        require(fCashAmount <= G_MAX_TRADE_SIZE, $$(ErrorCode(TRADE_FAILED_TOO_LARGE)));\n\n        uint128 cash = _updateMarket(maturity, int256(fCashAmount));\n        require(cash > 0, $$(ErrorCode(TRADE_FAILED_LACK_OF_LIQUIDITY)));\n\n        uint32 timeToMaturity = maturity - uint32(block.timestamp);\n        uint128 fee = _calculateTransactionFee(cash, timeToMaturity);\n        uint32 impliedRate = _calculateImpliedRate(cash.sub(fee), fCashAmount, timeToMaturity);\n        require(impliedRate <= maxImpliedRate, $$(ErrorCode(TRADE_FAILED_SLIPPAGE)));\n\n        // Move the cash from the contract's cash balances account to the sender. This must happen before\n        // the call to insert the trade below in order for the free collateral check to work properly.\n        Escrow().withdrawFromMarket(account, CASH_GROUP, cash, fee);\n\n        // The sender now has an obligation to pay cash at maturity.\n        Common.Asset memory asset = Common.Asset(\n            CASH_GROUP,\n            0,\n            maturity,\n            Common.getCashPayer(),\n            0,\n            fCashAmount\n        );\n\n        emit TakeCurrentCash(account, maturity, fCashAmount, cash, fee);\n\n        return (asset, cash);\n    }\n\n    /**\n     * @notice Given the amount of fCash to purchase, returns the amount of cash this would cost at the current\n     * block.\n     * @param maturity the maturity of the fCash\n     * @param fCashAmount the amount of fCash to purchase\n     * @return the amount of cash this would cost, returns 0 on trade failure\n     */\n    function getCurrentCashTofCash(uint32 maturity, uint128 fCashAmount) public view returns (uint128) {\n        return getCurrentCashTofCashAtTime(maturity, fCashAmount, uint32(block.timestamp));\n    }\n\n    /**\n     * @notice Given the amount of fCash to purchase, returns the amount of cash this would cost.\n     * @dev - CANNOT_GET_PRICE_FOR_MATURITY: can only get prices before the maturity\n     * @param maturity the maturity of the fCash\n     * @param fCashAmount the amount of fCash to purchase\n     * @param blockTime the time to calculate the price at\n     * @return the amount of cash this would cost, returns 0 on trade failure\n     */\n    function getCurrentCashTofCashAtTime(\n        uint32 maturity,\n        uint128 fCashAmount,\n        uint32 blockTime\n    ) public view returns (uint128) {\n        Market memory interimMarket = markets[maturity];\n        require(blockTime < maturity, $$(ErrorCode(CANNOT_GET_PRICE_FOR_MATURITY)));\n\n        uint32 timeToMaturity = maturity - blockTime;\n\n        ( /* market */, uint128 cash) = _tradeCalculation(interimMarket, int256(fCashAmount).neg(), timeToMaturity);\n        uint128 fee = _calculateTransactionFee(cash, timeToMaturity);\n        // On trade failure, we will simply return 0\n        return cash.add(fee);\n    }\n\n    /**\n     * @notice Deposit cash in return for the right to receive cash at the specified maturity. Equivalent to lending\n     * cash at a fixed rate.\n     * @dev - TRADE_FAILED_MAX_TIME: maturity specified is not yet active\n     * - MARKET_INACTIVE: maturity is not a valid one\n     * - TRADE_FAILED_TOO_LARGE: trade is larger than allowed by the governance settings\n     * - TRADE_FAILED_LACK_OF_LIQUIDITY: there is insufficient liquidity in this maturity to handle the trade\n     * - TRADE_FAILED_SLIPPAGE: trade is lower than the min implied rate set\n     * - INSUFFICIENT_BALANCE: not enough cash to complete this trade\n     * @param maturity the maturity to receive fCash in\n     * @param fCashAmount the amount of fCash to purchase\n     * @param maxTime after this time the trade will not settle\n     * @param minImpliedRate the minimum implied rate that the lender will accept\n     * @return the amount of cash deposited to the market, `fCashAmount - cash` is the interest to be received\n     */\n    function takefCash(\n        uint32 maturity,\n        uint128 fCashAmount,\n        uint32 maxTime,\n        uint128 minImpliedRate\n    ) external returns (uint128) {\n        (Common.Asset memory asset, uint128 cash) = _takefCash(\n            msg.sender,\n            maturity,\n            fCashAmount,\n            maxTime,\n            minImpliedRate\n        );\n\n        // This will do a free collateral check before it adds to the portfolio.\n        Portfolios().upsertAccountAsset(msg.sender, asset, CHECK_FC);\n\n        return cash;\n    }\n\n    /**\n     * @notice Used by ERC1155 contract to take fCash\n     * @dev skip\n     */\n    function takefCashOnBehalf(\n        address account,\n        uint32 maturity,\n        uint128 fCashAmount,\n        uint32 minImpliedRate\n    ) external returns (uint128) {\n        require(calledByERC1155Trade(), $$(ErrorCode(UNAUTHORIZED_CALLER)));\n\n        (Common.Asset memory asset, uint128 cash) = _takefCash(\n            account,\n            maturity,\n            fCashAmount,\n            uint32(block.timestamp),\n            minImpliedRate\n        );\n\n        Portfolios().upsertAccountAsset(account, asset, DEFER_CHECK);\n\n        return cash;\n    }\n\n    function _"
    }
  ]
}