{
  "Title": "H-1: Non terminal tokens received via Balancer batchSwap are not accounted for",
  "Content": "# Issue H-1: Non terminal tokens received via Balancer batchSwap are not accounted for \n\nSource: https://github.com/sherlock-audit/2022-11-sentiment-judging/issues/6 \n\n## Found by \nBahurum, obront\n\n## Summary\n\nBalancer's `batchSwap()` function is able to return multiple tokens along the execution path, but BalancerController.sol only accounts for receipt of the final token in the swap. The result is that other tokens received from a user's trade will not be registered with the protocol or included in their account.\n\n## Vulnerability Detail\n\nBalancer's `batchSwap()` functionality takes in an array of `BatchSwapSteps`, each of which dictates a pool to use for the swap, assets to swap to and from, an amount, and some additional user data (which is currently unused by Balancer).\n\nFor users who would like all their funds to move from step to step (swapping all of their input token from their first step, for the maximum amount of the output token from the final step), Balancer provides the helpful option to set `amount = 0` for all steps after the first, and it will automatically use the maximum amount.\n\nAlternatively, users are able to provide their own `amounts` in each step. Any amount returned from a step that is not used for the next step is sent to the user. \n\nHere is a simple example:\n- Step 1: Trade 400 BAL for max WETH (returns ~1.7)\n- Step 2: Trade 1 WETH for max USDC (returns ~1575)\n- Result: 400 BAL is inputted, and both 0.7 WETH and 1575 USDC are returned\n\n[Here is a gist with a standalone Foundry test that can be run to show this behavior.](https://gist.github.com/zobront/e56c53d80765e0092a5f94788da2c245)\n\nAs the `canBatchSwap()` function is currently implemented, only the final asset (in this case, USDC) would be returned in the `tokensIn[]` array. While the user's WETH would be transferred to their account, it would not be registered with the protocol to count towards their account balance or interact with.\n\n## Impact\n\nIf a user uses Balancer's `batchSwap()` functionality with returned intermediate tokens that are not in the account's asset list already, the user may get liquidated sooner than expected as `RiskEngine.sol:_getBalance()` only counts in the assets in the assets list.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-sentiment/blob/main/controller-merged/src/balancer/BalancerController.sol#L193-L197\n\nhttps://github.com/sherlock-audit/2022-11-sentiment/blob/main/controller-merged/src/balancer/BalancerController.sol#L219-L228\n\n## Tool used\n\nManual Review, Foundry\n\n## Recommendation\n\nBalancer's `batchSwap()` function returns `int256[] memory assetDeltas`, which provide details on the final amounts of each asset that are inputted and outputted from the function.\n\nRather than try to manually calculate these values, the best option is likely the following:\n- Use an in-line assembly block to `STATICCALL` Balancer's `canBatchSwap()` to return the asset deltas\n- Any positive number in `assetDeltas` means the token belongs in `tokensOut`\n- Any negative number in `assetDeltas` means the token belongs in `tokensIn`\n\n## Discussion\n\n**r0ohafza**\n\nPR: https://github.com/sentimentxyz/controller/pull/49\n\n**zobront**\n\nConfirmed. Didn't follow recommendation above, but blocked all trades with intermediate amounts > 0, so problem is solved.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/17",
  "Code": [
    {
      "filename": "controller-merged/src/balancer/BalancerController.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {IController} from \"../core/IController.sol\";\nimport {IVault, IAsset} from \"./IVault.sol\";\n\n/**\n    @title Balancer V2 Controller\n    @notice Balance v2 controller for join/exit/swap/batchSwap (multiHop)\n*/\ncontract BalancerController is IController {\n\n    /* -------------------------------------------------------------------------- */\n    /*                             CONSTANT VARIABLES                             */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice joinPool(bytes32,address,address,(address[],uint256[],bytes,bool))\n    bytes4 constant JOIN = 0xb95cac28;\n\n    /// @notice exitPool(bytes32,address,address,(address[],uint256[],bytes,bool))\n    bytes4 constant EXIT = 0x8bdb3913;\n\n    /// @notice swap((bytes32,uint8,address,address,uint256,bytes),(address,bool,address,bool),uint256,uint256)\n    bytes4 constant SWAP = 0x52bbbe29;\n    bytes4 constant BATCH_SWAP = 0x945bcec9;\n\n    /* -------------------------------------------------------------------------- */\n    /*                              EXTERNAL FUNCTIONS                            */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IController\n    function canCall(address target, bool useEth, bytes calldata data)\n        external\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        bytes4 sig = bytes4(data);\n\n        if (sig == JOIN)\n            return canJoin(target, useEth, data[4:]);\n        if (sig == EXIT)\n            return canExit(target, useEth, data[4:]);\n        if (sig == SWAP)\n            return canSwap(target, useEth, data[4:]);\n        if (sig == BATCH_SWAP)\n            return canBatchSwap(target, useEth, data[4:]);\n        return (false, new address[](0), new address[](0));\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             INTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    function canJoin(address target, bool, bytes calldata data)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        (\n            bytes32 poolId,\n            ,\n            ,\n            IVault.JoinPoolRequest memory request\n        ) = abi.decode(data, (\n                bytes32, address, address, IVault.JoinPoolRequest\n            )\n        );\n        address[] memory tokensIn = new address[](1);\n        address[] memory tokensOut = new address[](request.assets.length);\n\n        uint i; uint j;\n        while(i < request.assets.length) {\n            if (\n                request.maxAmountsIn[i] > 0 &&\n                address(request.assets[i]) != address(0)\n            )\n                tokensOut[j++] = address(request.assets[i]);\n            unchecked { ++i; }\n        }\n        assembly { mstore(tokensOut, j) }\n\n        (tokensIn[0],) = IVault(target).getPool(poolId);\n\n        return (\n            true,\n            tokensIn,\n            tokensOut\n        );\n    }\n\n    function canExit(address target, bool, bytes calldata data)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        (\n            bytes32 poolId,\n            ,\n            ,\n            IVault.ExitPoolRequest memory request\n        ) = abi.decode(data, (\n                bytes32, address, address, IVault.ExitPoolRequest\n            )\n        );\n        address[] memory tokensOut = new address[](1);\n        address[] memory tokensIn = new address[](request.assets.length);\n\n        uint i; uint j;\n        while(i < request.assets.length) {\n            if (address(request.assets[i]) != address(0))\n                tokensIn[j++] = address(request.assets[i]);\n            unchecked { ++i; }\n        }\n        assembly { mstore(tokensIn, j) }\n\n        (tokensOut[0],) = IVault(target).getPool(poolId);\n\n        return (\n            true,\n            tokensIn,\n            tokensOut\n        );\n    }\n\n    function canSwap(address, bool, bytes calldata data)\n        internal\n        pure\n        returns (bool, address[] memory, address[] memory)\n    {\n        (\n            IVault.SingleSwap memory swap,\n            ,\n            ,\n        ) = abi.decode(data, (\n                IVault.SingleSwap, IVault.FundManagement, uint256, uint256\n            )\n        );\n\n        address[] memory tokensIn;\n        address[] memory tokensOut;\n\n        if (address(swap.assetIn) == address(0)) {\n            tokensIn = new address[](1);\n            tokensIn[0] = address(swap.assetOut);\n            return (\n                true,\n                tokensIn,\n                new address[](0)\n            );\n        }\n\n        if (address(swap.assetOut) == address(0)) {\n            tokensOut = new address[](1);\n            tokensOut[0] = address(swap.assetIn);\n            return (\n                true,\n                new address[](0),\n                tokensOut\n            );\n        }\n\n        tokensIn = new address[](1);\n        tokensOut = new address[](1);\n        tokensOut[0] = address(swap.assetIn);\n        tokensIn[0] = address(swap.assetOut);\n\n        return (\n            true,\n            tokensIn,\n            tokensOut\n        );\n    }\n\n    function canBatchSwap(address, bool, bytes calldata data)\n        internal\n        pure\n        returns (bool, address[] memory, address[] memory)\n    {\n        (\n            ,\n            IVault.BatchSwapStep[] memory swaps,\n            IAsset[] memory assets,\n            ,\n            ,\n        ) = abi.decode(data, (\n                uint8, IVault.BatchSwapStep[], IAsset[], IVault.FundManagement, uint256[], uint256\n            )\n        );\n\n        if (!isMultiHopSwap(swaps))\n            return (false, new address[](0), new address[](0));\n\n        uint tokenInIndex = swaps[swaps.length - 1].assetOutIndex;\n        uint tokenOutIndex = swaps[0].assetInIndex;\n\n        address[] memory tokensIn;\n        address[] memory tokensOut;\n\n        if (address(assets[tokenOutIndex]) == address(0)) {\n            tokensIn = new address[](1);\n            tokensIn[0] = address(assets[tokenInIndex]);\n            return (\n                true,\n                tokensIn,\n                new address[](0)\n            );\n        }\n\n        if (address(assets[tokenInIndex]) == address(0)) {\n            tokensOut = new address[](1);\n            tokensOut[0] = address(assets[tokenOutIndex]);\n            return (\n                true,\n                new address[](0),\n                tokensOut\n            );\n        }\n\n        tokensIn = new address[](1);\n        tokensOut = new address[](1);\n        tokensOut[0] = address(assets[tokenOutIndex]);\n        tokensIn[0] = address(assets[tokenInIndex]);\n\n        return (\n            true,\n            tokensIn,\n            tokensOut\n        );\n    }\n\n    function isMultiHopSwap(IVault.BatchSwapStep[] memory swaps)\n        internal\n        pure\n        returns (bool)\n    {\n        uint steps = swaps.length;\n        for (uint i; i < steps - 1; i++) {\n            if (swaps[i].assetOutIndex != swaps[i+1].assetInIndex)\n                return false;\n        }\n        return true;\n    }\n}"
    },
    {
      "filename": "controller-merged/src/balancer/BalancerController.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {IController} from \"../core/IController.sol\";\nimport {IVault, IAsset} from \"./IVault.sol\";\n\n/**\n    @title Balancer V2 Controller\n    @notice Balance v2 controller for join/exit/swap/batchSwap (multiHop)\n*/\ncontract BalancerController is IController {\n\n    /* -------------------------------------------------------------------------- */\n    /*                             CONSTANT VARIABLES                             */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice joinPool(bytes32,address,address,(address[],uint256[],bytes,bool))\n    bytes4 constant JOIN = 0xb95cac28;\n\n    /// @notice exitPool(bytes32,address,address,(address[],uint256[],bytes,bool))\n    bytes4 constant EXIT = 0x8bdb3913;\n\n    /// @notice swap((bytes32,uint8,address,address,uint256,bytes),(address,bool,address,bool),uint256,uint256)\n    bytes4 constant SWAP = 0x52bbbe29;\n    bytes4 constant BATCH_SWAP = 0x945bcec9;\n\n    /* -------------------------------------------------------------------------- */\n    /*                              EXTERNAL FUNCTIONS                            */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IController\n    function canCall(address target, bool useEth, bytes calldata data)\n        external\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        bytes4 sig = bytes4(data);\n\n        if (sig == JOIN)\n            return canJoin(target, useEth, data[4:]);\n        if (sig == EXIT)\n            return canExit(target, useEth, data[4:]);\n        if (sig == SWAP)\n            return canSwap(target, useEth, data[4:]);\n        if (sig == BATCH_SWAP)\n            return canBatchSwap(target, useEth, data[4:]);\n        return (false, new address[](0), new address[](0));\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             INTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    function canJoin(address target, bool, bytes calldata data)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        (\n            bytes32 poolId,\n            ,\n            ,\n            IVault.JoinPoolRequest memory request\n        ) = abi.decode(data, (\n                bytes32, address, address, IVault.JoinPoolRequest\n            )\n        );\n        address[] memory tokensIn = new address[](1);\n        address[] memory tokensOut = new address[](request.assets.length);\n\n        uint i; uint j;\n        while(i < request.assets.length) {\n            if (\n                request.maxAmountsIn[i] > 0 &&\n                address(request.assets[i]) != address(0)\n            )\n                tokensOut[j++] = address(request.assets[i]);\n            unchecked { ++i; }\n        }\n        assembly { mstore(tokensOut, j) }\n\n        (tokensIn[0],) = IVault(target).getPool(poolId);\n\n        return (\n            true,\n            tokensIn,\n            tokensOut\n        );\n    }\n\n    function canExit(address target, bool, bytes calldata data)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        (\n            bytes32 poolId,\n            ,\n            ,\n            IVault.ExitPoolRequest memory request\n        ) = abi.decode(data, (\n                bytes32, address, address, IVault.ExitPoolRequest\n            )\n        );\n        address[] memory tokensOut = new address[](1);\n        address[] memory tokensIn = new address[](request.assets.length);\n\n        uint i; uint j;\n        while(i < request.assets.length) {\n            if (address(request.assets[i]) != address(0))\n                tokensIn[j++] = address(request.assets[i]);\n            unchecked { ++i; }\n        }\n        assembly { mstore(tokensIn, j) }\n\n        (tokensOut[0],) = IVault(target).getPool(poolId);\n\n        return (\n            true,\n            tokensIn,\n            tokensOut\n        );\n    }\n\n    function canSwap(address, bool, bytes calldata data)\n        internal\n        pure\n        returns (bool, address[] memory, address[] memory)\n    {\n        (\n            IVault.SingleSwap memory swap,\n            ,\n            ,\n        ) = abi.decode(data, (\n                IVault.SingleSwap, IVault.FundManagement, uint256, uint256\n            )\n        );\n\n        address[] memory tokensIn;\n        address[] memory tokensOut;\n\n        if (address(swap.assetIn) == address(0)) {\n            tokensIn = new address[](1);\n            tokensIn[0] = address(swap.assetOut);\n            return (\n                true,\n                tokensIn,\n                new address[](0)\n            );\n        }\n\n        if (address(swap.assetOut) == address(0)) {\n            tokensOut = new address[](1);\n            tokensOut[0] = address(swap.assetIn);\n            return (\n                true,\n                new address[](0),\n                tokensOut\n            );\n        }\n\n        tokensIn = new address[](1);\n        tokensOut = new address[](1);\n        tokensOut[0] = address(swap.assetIn);\n        tokensIn[0] = address(swap.assetOut);\n\n        return (\n            true,\n            tokensIn,\n            tokensOut\n        );\n    }\n\n    function canBatchSwap(address, bool, bytes calldata data)\n        internal\n        pure\n        returns (bool, address[] memory, address[] memory)\n    {\n        (\n            ,\n            IVault.BatchSwapStep[] memory swaps,\n            IAsset[] memory assets,\n            ,\n            ,\n        ) = abi.decode(data, (\n                uint8, IVault.BatchSwapStep[], IAsset[], IVault.FundManagement, uint256[], uint256\n            )\n        );\n\n        if (!isMultiHopSwap(swaps))\n            return (false, new address[](0), new address[](0));\n\n        uint tokenInIndex = swaps[swaps.length - 1].assetOutIndex;\n        uint tokenOutIndex = swaps[0].assetInIndex;\n\n        address[] memory tokensIn;\n        address[] memory tokensOut;\n\n        if (address(assets[tokenOutIndex]) == address(0)) {\n            tokensIn = new address[](1);\n            tokensIn[0] = address(assets[tokenInIndex]);\n            return (\n                true,\n                tokensIn,\n                new address[](0)\n            );\n        }\n\n        if (address(assets[tokenInIndex]) == address(0)) {\n            tokensOut = new address[](1);\n            tokensOut[0] = address(assets[tokenOutIndex]);\n            return (\n                true,\n                new address[](0),\n                tokensOut\n            );\n        }\n\n        tokensIn = new address[](1);\n        tokensOut = new address[](1);\n        tokensOut[0] = address(assets[tokenOutIndex]);\n        tokensIn[0] = address(assets[tokenInIndex]);\n\n        return (\n            true,\n            tokensIn,\n            tokensOut\n        );\n    }\n\n    function isMultiHopSwap(IVault.BatchSwapStep[] memory swaps)\n        internal\n        pure\n        returns (bool)\n    {\n        uint steps = swaps.length;\n        for (uint i; i < steps - 1; i++) {\n            if (swaps[i].assetOutIndex != swaps[i+1].assetInIndex)\n                return false;\n        }\n        return true;\n    }\n}"
    }
  ]
}