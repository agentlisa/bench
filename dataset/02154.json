{
  "Title": "M-1: `swap()` will be reverted if `path` has more tokens.",
  "Content": "# Issue M-1: `swap()` will be reverted if `path` has more tokens. \n\nSource: https://github.com/sherlock-audit/2023-03-taurus-judging/issues/160 \n\n## Found by \nGimelSec, shaka\n\n## Summary\n\n`swap()` will be reverted if `path` has more tokens, the keepers will not be able to successfully call `swapForTau()`.\n\n## Vulnerability Detail\n\nIn `test/SwapAdapters/00_UniswapSwapAdapter.ts`:\n\n```javascript\n    // Get generic swap parameters\n    const basicSwapParams = buildUniswapSwapAdapterData(\n      [\"0xyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\", \"0xzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"],\n      [3000],\n      testDepositAmount,\n      expectedReturnAmount,\n      0,\n    ).swapData;\n```\n\nWe will get:\n\n```text\n000000000000000000000000000000000000000000000000000000024f49cbca\n0000000000000000000000000000000000000000000000056bc75e2d63100000\n0000000000000000000000000000000000000000000000055de6a779bbac0000\n0000000000000000000000000000000000000000000000000000000000000080\n000000000000000000000000000000000000000000000000000000000000002b\nyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy000bb8zzzzzzzzzzzzzzzzzz\nzzzzzzzzzzzzzzzzzzzzzz000000000000000000000000000000000000000000\n```\n\nThen the `swapOutputToken` is `_swapData[length - 41:length - 21]`.\n\nBut if we have more tokens in path:\n```javascript\n    const basicSwapParams = buildUniswapSwapAdapterData(\n      [\"0xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\", \"0xyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\", \"0xzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"],\n      [3000, 3000],\n      testDepositAmount,\n      expectedReturnAmount,\n      0,\n    ).swapData;\n```\n\n```text\n000000000000000000000000000000000000000000000000000000024f49cbca\n0000000000000000000000000000000000000000000000056bc75e2d63100000\n0000000000000000000000000000000000000000000000055de6a779bbac0000\n0000000000000000000000000000000000000000000000000000000000000080\n0000000000000000000000000000000000000000000000000000000000000042\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx000bb8yyyyyyyyyyyyyyyyyy\nyyyyyyyyyyyyyyyyyyyyyy000bb8zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\nzzzz000000000000000000000000000000000000000000000000000000000000\n```\n\n`swapOutputToken` is `_swapData[length - 50:length - 30]`, the `swap()` function will be reverted.\n\n\n## Impact\n\nThe keepers will not be able to successfully call `SwapHandler.swapForTau()`. Someone will get a reverted transaction if they misuse `UniswapSwapAdapter`.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-03-taurus/blob/main/taurus-contracts/contracts/SwapAdapters/UniswapSwapAdapter.sol#L30\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nLimit the swap pools, or check if the balance of `_outputToken` should exceed `_amountOutMinimum`.\n\n## Discussion\n\n**Sierraescape**\n\nhttps://github.com/protokol/taurus-contracts/pull/82\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/45",
  "Code": [
    {
      "filename": "taurus-contracts/contracts/SwapAdapters/UniswapSwapAdapter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ISwapRouter02 } from \"./ISwapRouter02.sol\";\n\nerror incorrectOutputToken();\n\n/**\n * @dev this contract exposes necessary logic to swap between tokens using Uniswap.\n * note that it should only hold tokens mid-transaction. Any tokens transferred in outside of a swap can be stolen.\n */\ncontract UniswapSwapAdapter {\n    address public immutable swapRouter;\n\n    constructor(address _swapRouter) {\n        swapRouter = _swapRouter;\n    }\n\n    // exactInput\n    function swap(address _outputToken, bytes calldata _swapData) external returns (uint256) {\n        // Decode swap data\n        (uint256 deadline, uint256 _amountIn, uint256 _amountOutMinimum, bytes memory _path) = abi.decode(\n            _swapData,\n            (uint256, uint256, uint256, bytes)\n        );\n\n        // Check that the outputToken is the final token in the path\n        uint256 length = _swapData.length;\n        address swapOutputToken = address(bytes20(_swapData[length - 41:length - 21]));\n\n        if (swapOutputToken != _outputToken) {\n            // The keeper-inputted Output Token differs from what the contract says it must be.\n            revert incorrectOutputToken();\n        }\n\n        // Perform swap (this will fail if tokens haven't been transferred in, or haven't been approved)\n        ISwapRouter02.ExactInputParams memory params = ISwapRouter02.ExactInputParams({\n            path: _path,\n            recipient: msg.sender,\n            deadline: deadline,\n            amountIn: _amountIn,\n            amountOutMinimum: _amountOutMinimum\n        });\n\n        return ISwapRouter02(swapRouter).exactInput(params);\n    }\n\n    /**\n     * @dev approve any token to the swapRouter.\n     * note this is calleable by anyone.\n     */\n    function approveTokens(address _tokenIn) external {\n        IERC20(_tokenIn).approve(swapRouter, type(uint256).max);\n    }\n}"
    }
  ]
}