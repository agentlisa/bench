{
  "Title": "A swap with permit can be blocked if a frontrunner swaps using copied permit",
  "Content": "##### Description\n\nFacade does not check that msg.sender is the owner of a permit.\nSo, a frontrunner can use permits of other users available from mempool, so that their transactions would revert (as permit are used by the frontrunner).\n\n- https://github.com/BarterLab/argon/blob/22239aaccdbb78d4aa7ac5c4d0859a9b31c0fc00/contracts/SwapFacade.sol#L58-L64\n\nA user will receive revert and will have to build new calldata, without permit.\n\n##### Recommendation\n\nWe recommend decoding permits to extract their owner, then check that msg.sender is this owner. Some example used by 1inch:\n- https://github.com/1inch/solidity-utils/blob/60fa6eba06f50f2acac5286dea5fb54f206e2434/contracts/libraries/SafeERC20.sol#L158-L245\n\n***",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/libraries/SafeERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\nimport \"../interfaces/IDaiLikePermit.sol\";\nimport \"../interfaces/IPermit2.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"../libraries/RevertReasonForwarder.sol\";\n\n/// @title Implements efficient safe methods for ERC20 interface.\nlibrary SafeERC20 {\n    error SafeTransferFailed();\n    error SafeTransferFromFailed();\n    error ForceApproveFailed();\n    error SafeIncreaseAllowanceFailed();\n    error SafeDecreaseAllowanceFailed();\n    error SafePermitBadLength();\n\n    address private constant _PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n    bytes4 private constant _PERMIT_LENGHT_ERROR = 0x68275857;  // SafePermitBadLength.selector\n\n    /// @dev Ensures method do not revert or return boolean `true`, admits call to non-smart-contract.\n    function safeTransferFromUniversal(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        bool permit2\n    ) internal {\n        if (permit2) {\n            safeTransferFromPermit2(token, from, to, uint160(amount));\n        } else {\n            safeTransferFrom(token, from, to, amount);\n        }\n    }\n\n    /// @dev Ensures method do not revert or return boolean `true`, admits call to non-smart-contract.\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bytes4 selector = token.transferFrom.selector;\n        bool success;\n        /// @solidity memory-safe-assembly\n        assembly { // solhint-disable-line no-inline-assembly\n            let data := mload(0x40)\n\n            mstore(data, selector)\n            mstore(add(data, 0x04), from)\n            mstore(add(data, 0x24), to)\n            mstore(add(data, 0x44), amount)\n            success := call(gas(), token, 0, data, 100, 0x0, 0x20)\n            if success {\n                switch returndatasize()\n                case 0 {\n                    success := gt(extcodesize(token), 0)\n                }\n                default {\n                    success := and(gt(returndatasize(), 31), eq(mload(0), 1))\n                }\n            }\n        }\n        if (!success) revert SafeTransferFromFailed();\n    }\n\n    /// @dev Permit2 version of safeTransferFrom above.\n    function safeTransferFromPermit2(\n        IERC20 token,\n        address from,\n        address to,\n        uint160 amount\n    ) internal {\n        bytes4 selector = IPermit2.transferFrom.selector;\n        bool success;\n        /// @solidity memory-safe-assembly\n        assembly { // solhint-disable-line no-inline-assembly\n            let data := mload(0x40)\n\n            mstore(data, selector)\n            mstore(add(data, 0x04), from)\n            mstore(add(data, 0x24), to)\n            mstore(add(data, 0x44), amount)\n            mstore(add(data, 0x64), token)\n            success := call(gas(), _PERMIT2, 0, data, 0x84, 0x0, 0x0)\n            if success {\n                success := gt(extcodesize(_PERMIT2), 0)\n            }\n        }\n        if (!success) revert SafeTransferFromFailed();\n    }\n\n    /// @dev Ensures method do not revert or return boolean `true`, admits call to non-smart-contract.\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        if (!_makeCall(token, token.transfer.selector, to, value)) {\n            revert SafeTransferFailed();\n        }\n    }\n\n    /// @dev If `approve(from, to, amount)` fails, try to `approve(from, to, 0)` before retry.\n    function forceApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        if (!_makeCall(token, token.approve.selector, spender, value)) {\n            if (\n                !_makeCall(token, token.approve.selector, spender, 0) ||\n                !_makeCall(token, token.approve.selector, spender, value)\n            ) {\n                revert ForceApproveFailed();\n            }\n        }\n    }\n\n    /// @dev Allowance increase with safe math check.\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 allowance = token.allowance(address(this), spender);\n        if (value > type(uint256).max - allowance) revert SafeIncreaseAllowanceFailed();\n        forceApprove(token, spender, allowance + value);\n    }\n\n    /// @dev Allowance decrease with safe math check.\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 allowance = token.allowance(address(this), spender);\n        if (value > allowance) revert SafeDecreaseAllowanceFailed();\n        forceApprove(token, spender, allowance - value);\n    }\n\n    function safePermit(IERC20 token, bytes calldata permit) internal {\n        if (!tryPermit(token, msg.sender, address(this), permit)) RevertReasonForwarder.reRevert();\n    }\n\n    function safePermit(IERC20 token, address owner, address spender, bytes calldata permit) internal {\n        if (!tryPermit(token, owner, spender, permit)) RevertReasonForwarder.reRevert();\n    }\n\n    function tryPermit(IERC20 token, bytes calldata permit) internal returns(bool success) {\n        return tryPermit(token, msg.sender, address(this), permit);\n    }\n\n    function tryPermit(IERC20 token, address owner, address spender, bytes calldata permit) internal returns(bool success) {\n        bytes4 permitSelector = IERC20Permit.permit.selector;\n        bytes4 daiPermitSelector = IDaiLikePermit.permit.selector;\n        bytes4 permit2Selector = IPermit2.permit.selector;\n        /// @solidity memory-safe-assembly\n        assembly { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n            switch permit.length\n            case 100 {\n                mstore(ptr, permitSelector)\n                mstore(add(ptr, 0x04), owner)\n                mstore(add(ptr, 0x24), spender)\n\n                // Compact IERC20Permit.permit(uint256 value, uint32 deadline, uint256 r, uint256 vs)\n                {  // stack too deep\n                    let deadline := shr(224, calldataload(add(permit.offset, 0x20)))\n                    let vs := calldataload(add(permit.offset, 0x44))\n\n                    calldatacopy(add(ptr, 0x44), permit.offset, 0x20) // value\n                    mstore(add(ptr, 0x64), sub(deadline, 1))\n                    mstore(add(ptr, 0x84), add(27, shr(255, vs)))\n                    calldatacopy(add(ptr, 0xa4), add(permit.offset, 0x24), 0x20) // r\n                    mstore(add(ptr, 0xc4), shr(1, shl(1, vs)))\n                }\n                // IERC20Permit.permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s)\n                success := call(gas(), token, 0, ptr, 0xe4, 0, 0)\n            }\n            case 72 {\n                mstore(ptr, daiPermitSelector)\n                mstore(add(ptr, 0x04), owner)\n                mstore(add(ptr, 0x24), spender)\n\n                // Compact IDaiLikePermit.permit(uint32 nonce, uint32 expiry, uint256 r, uint256 vs)\n                {  // stack too deep\n                    let expiry := shr(224, calldataload(add(permit.offset, 0x04)))\n                    let vs := calldataload(add(permit.offset, 0x28))\n\n                    mstore(add(ptr, 0x44), shr(224, calldataload(permit.offset)))\n                    mstore(add(ptr, 0x64), sub(expiry, 1))\n                    mstore(add(ptr, 0x84), true)\n                    mstore(add(ptr, 0xa4), add(27, shr(255, vs)))\n                    calldatacopy(add(ptr, 0xc4), add(permit.offset, 0x08), 0x20) // r\n                    mstore(add(ptr, 0xe4), shr(1, shl(1, vs)))\n                }\n                // IDaiLikePermit.permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s)\n                success := call(gas(), token, 0, ptr, 0x104, 0, 0)\n            }\n            case 224 {\n                mstore(ptr, permitSelector)\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length)\n                // IERC20Permit.permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s)\n                success := call(gas(), token, 0, ptr, add(4, permit.length), 0, 0)\n            }\n            case 256 {\n                mstore(ptr, daiPermitSelector)\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length)\n                // IDaiLikePermit.permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s)\n                success := call(gas(), token, 0, ptr, add(4, permit.length), 0, 0)\n            }\n            case 128 {\n                // Compact IPermit2.permit(address owner, PermitSingle calldata permitSingle, bytes calldata signature)\n                mstore(ptr, permit2Selector)\n                mstore(add(ptr, 0x04), owner)\n                mstore(add(ptr, 0x24), token)\n                calldatacopy(add(ptr, 0x50), permit.offset, 0x14) // amount\n                calldatacopy(add(ptr, 0x7e), add(permit.offset, 0x14), 0x06) // expiration\n                calldatacopy(add(ptr, 0x9e), add(permit.offset, 0x1a), 0x06) // nonce\n                mstore(add(ptr, 0xa4), spender)\n                calldatacopy(add(ptr, 0xc4), add(permit.offset, 0x20), 0x20) // sigDeadline\n                mstore(add(ptr, 0xe4), 0x100)\n                mstore(add(ptr, 0x104), 0x40)\n                calldatacopy(add(ptr, 0x124), add(permit.offset, 0x40), 0x20) // r\n                calldatacopy(add(ptr, 0x144), add(permit.offset, 0x60), 0x20) // vs\n                // IPermit2.permit(address owner, PermitSingle calldata permitSingle, bytes calldata signature)\n                success := call(gas(), _PERMIT2, 0, ptr, 388, 0, 0)\n            }\n            case 384 {\n                mstore(ptr, permit2Selector)\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length)\n                // IPermit2.permit(address owner, PermitSingle calldata permitSingle, bytes calldata signature)\n                success := call(gas(), _PERMIT2, 0, ptr, 388, 0, 0)\n            }\n            default {\n                mstore(ptr, _PERMIT_LENGHT_ERROR)\n                revert(ptr, 4)\n            }\n        }\n    }\n\n    function _makeCall(\n        IERC20 token,\n        bytes4 selector,\n        address to,\n        uint256 amount\n    ) private returns (bool success) {\n        /// @solidity memory-safe-assembly\n        assembly { // solhint-disable-line no-inline-assembly\n            let data := mload(0x40)\n\n            mstore(data, selector)\n            mstore(add(data, 0x04), to)\n            mstore(add(data, 0x24), amount)\n            success := call(gas(), token, 0, data, 0x44, 0x0, 0x20)\n            if success {\n                switch returndatasize()\n                case 0 {\n                    success := gt(extcodesize(token), 0)\n                }\n                default {\n                    success := and(gt(returndatasize(), 31), eq(mload(0), 1))\n                }\n            }\n        }\n    }\n\n    function safeDeposit(IWETH weth, uint256 amount) internal {\n        if (amount > 0) {\n            bytes4 selector = IWETH.deposit.selector;\n            /// @solidity memory-safe-assembly\n            assembly { // solhint-disable-line no-inline-assembly\n                mstore(0, selector)\n                if iszero(call(gas(), weth, amount, 0, 4, 0, 0)) {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n            }\n        }\n    }\n\n    function safeWithdraw(IWETH weth, uint256 amount) internal {\n        bytes4 selector = IWETH.withdraw.selector;\n        /// @solidity memory-safe-assembly\n        assembly {  // solhint-disable-line no-inline-assembly\n            mstore(0, selector)\n            mstore(4, amount)\n            if iszero(call(gas(), weth, 0, 0, 0x24, 0, 0)) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n\n    function safeWithdrawTo(IWETH weth, uint256 amount, address to) internal {\n        safeWithdraw(weth, amount);\n        if (to != address(this)) {\n            /// @solidity memory-safe-assembly\n            assembly {  // solhint-disable-line no-inline-assembly\n                if iszero(call(gas(), to, amount, 0, 0, 0, 0)) {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n            }\n        }\n    }\n}"
    }
  ]
}