{
  "Title": "[M-14] Excess tokens that are not accounted in the token premium portion stuck in the `ParticlePositionManager`",
  "Content": "\nExcess tokens from margins provided by traders when opening position could become stuck inside the `ParticlePositionManager` due to precision loss when calculating the token premium portion.\n\n### Proof of Concept\n\nWhen traders call `openPosition`, eventually it will calculate `cache.token0PremiumPortion` and `cache.token1PremiumPortion` before putting it into lien data.\n\n<https://github.com/code-423n4/2023-12-particle/blob/main/contracts/protocol/ParticlePositionManager.sol#L218-L244>\n\n<details>\n\n```solidity\n    /// @inheritdoc IParticlePositionManager\n    function openPosition(\n        DataStruct.OpenPositionParams calldata params\n    ) public override nonReentrant returns (uint96 lienId, uint256 collateralTo) {\n       ...\n        if (params.zeroForOne) {\n>>>         cache.token0PremiumPortion = Base.uint256ToUint24(\n                ((params.marginFrom + cache.amountFromBorrowed - cache.feeAmount - cache.amountSpent) *\n                    Base.BASIS_POINT) / cache.collateralFrom\n            );\n>>>         cache.token1PremiumPortion = Base.uint256ToUint24(\n                ((cache.amountReceived + cache.amountToBorrowed + params.marginTo - collateralTo) * Base.BASIS_POINT) /\n                    collateralTo\n            );\n            if (\n                cache.token0PremiumPortion < params.tokenFromPremiumPortionMin ||\n                cache.token1PremiumPortion < params.tokenToPremiumPortionMin\n            ) revert Errors.InsufficientPremium();\n        } else {\n>>>         cache.token1PremiumPortion = Base.uint256ToUint24(\n                ((params.marginFrom + cache.amountFromBorrowed - cache.feeAmount - cache.amountSpent) *\n                    Base.BASIS_POINT) / cache.collateralFrom\n            );\n>>>         cache.token0PremiumPortion = Base.uint256ToUint24(\n                ((cache.amountReceived + cache.amountToBorrowed + params.marginTo - collateralTo) * Base.BASIS_POINT) /\n                    collateralTo\n            );\n            if (\n                cache.token0PremiumPortion < params.tokenToPremiumPortionMin ||\n                cache.token1PremiumPortion < params.tokenFromPremiumPortionMin\n            ) revert Errors.InsufficientPremium();\n        }\n\n        // create a new lien\n        liens[keccak256(abi.encodePacked(msg.sender, lienId = _nextRecordId++))] = Lien.Info({\n            tokenId: uint40(params.tokenId),\n            liquidity: params.liquidity,\n            token0PremiumPortion: cache.token0PremiumPortion,\n            token1PremiumPortion: cache.token1PremiumPortion,\n            startTime: uint32(block.timestamp),\n            feeGrowthInside0LastX128: cache.feeGrowthInside0LastX128,\n            feeGrowthInside1LastX128: cache.feeGrowthInside1LastX128,\n            zeroForOne: params.zeroForOne\n        });\n\n        emit OpenPosition(msg.sender, lienId, collateralTo);\n    }\n```\n</details>\n\nIt can be observed that when calculating `cache.token0PremiumPortion` and `cache.token1PremiumPortion`, precision loss could occur, especially when the token used has a high decimals (e.g. 18) while `BASIS_POINT` used only `1_000_000`. When this happens, the token could become stuck inside the `ParticlePositionManager`.\n\nCoded PoC :\n\nThe PoC goal is to check the amount of tokens inside the `ParticlePositionManager` after the position is opened, premium is added, liquidated, the LP withdraws the tokens and collects fees, and the admin collects the treasury.\n\nAdd the following test inside `test/OpenPosition.t.sol` and also add `import \"forge-std/console.sol\";` to the test contract.\n\n<details>\n\n```solidity\n   function testLiquidateAndClearLiquidity() public {\n        address LIQUIDATOR = payable(address(0x7777));\n        uint128 REPAY_LIQUIDITY_PORTION = 1000;\n        testBaseOpenLongPosition();\n        // add enough premium\n        uint128 premium0 = 500 * 1e6;\n        uint128 premium1 = 0.5 ether;\n        vm.startPrank(WHALE);\n        USDC.transfer(SWAPPER, premium0);\n        WETH.transfer(SWAPPER, premium1);\n        vm.stopPrank();\n\n        vm.startPrank(SWAPPER);\n        TransferHelper.safeApprove(address(USDC), address(particlePositionManager), premium0);\n        TransferHelper.safeApprove(address(WETH), address(particlePositionManager), premium1);\n        particlePositionManager.addPremium(0, premium0, premium1);\n        vm.stopPrank();\n        // get lien info\n        (, uint128 liquidityInside, , , , , , ) = particlePositionManager.liens(\n            keccak256(abi.encodePacked(SWAPPER, uint96(0)))\n        );\n        // start reclaim\n        vm.startPrank(LP);\n        vm.warp(block.timestamp + 1);\n        particlePositionManager.reclaimLiquidity(_tokenId);\n        vm.stopPrank();\n        // add back liquidity requirement\n        vm.warp(block.timestamp + 7 days);\n        IUniswapV3Pool _pool = IUniswapV3Pool(uniswapV3Factory.getPool(address(USDC), address(WETH), FEE));\n        (uint160 currSqrtRatioX96, , , , , , ) = _pool.slot0();\n        (uint256 amount0ToReturn, uint256 amount1ToReturn) = LiquidityAmounts.getAmountsForLiquidity(\n            currSqrtRatioX96,\n            _sqrtRatioAX96,\n            _sqrtRatioBX96,\n            liquidityInside + liquidityInside / REPAY_LIQUIDITY_PORTION\n        );\n        (, uint256 ethCollateral) = particleInfoReader.getRequiredCollateral(liquidityInside, _tickLower, _tickUpper);\n\n        // get swap data\n        uint160 currentPrice = particleInfoReader.getCurrentPrice(address(USDC), address(WETH), FEE);\n        uint256 amountSwap = ethCollateral - amount1ToReturn;\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\n            tokenIn: address(WETH),\n            tokenOut: address(USDC),\n            fee: FEE,\n            recipient: address(particlePositionManager),\n            deadline: block.timestamp,\n            amountIn: amountSwap,\n            amountOutMinimum: 0,\n            sqrtPriceLimitX96: currentPrice + currentPrice / SLIPPAGE_FACTOR\n        });\n        bytes memory data = abi.encodeWithSelector(ISwapRouter.exactInputSingle.selector, params);\n        // liquidate position\n        vm.startPrank(LIQUIDATOR);\n        particlePositionManager.liquidatePosition(\n            DataStruct.ClosePositionParams({lienId: uint96(0), amountSwap: amountSwap, data: data}),\n            SWAPPER\n        );\n        vm.stopPrank();\n        vm.startPrank(LP);\n        // console.log(\"liquidity before : \");\n        // console.log(_liquidity);\n        (, , , , , , , _liquidity, , , , ) = nonfungiblePositionManager.positions(_tokenId);\n        (uint256 amount0Decreased, uint256 amount1Decreased) = particlePositionManager.decreaseLiquidity(\n            _tokenId,\n            _liquidity\n        );\n        (uint256 amount0Returned, uint256 amount1Returned) = particlePositionManager.collectLiquidity(_tokenId);\n        vm.stopPrank();\n        vm.startPrank(ADMIN);\n        particlePositionManager.withdrawTreasury(address(USDC), ADMIN);\n        particlePositionManager.withdrawTreasury(address(WETH), ADMIN);\n        vm.stopPrank();\n        uint256 usdcBalanceAfter = USDC.balanceOf(LP);\n        uint256 wethBalanceAfter = WETH.balanceOf(LP);\n        console.log(\"balance LP after - USDC:\");\n        console.log(usdcBalanceAfter);\n        console.log(\"balance LP after -  WETH:\");\n        console.log(wethBalanceAfter);\n        console.log(\"balance inside manager -  USDC:\");\n        console.log(USDC.balanceOf(address(particlePositionManager)));\n        console.log(\"balance inside manager - WETH:\");\n        console.log(WETH.balanceOf(address(particlePositionManager)));\n\n    }\n```\n\n</details>\n\nRun the test :\n\n```shell\nforge test -vv --fork-url $MAINNET_RPC_URL --fork-block-number 18750931 --match-contract OpenPositionTest --match-test testLiquidateAndClearLiquidity -vvv\n```\n\nOutput log :\n\n```shell\n  balance LP after - USDC:\n  15000228083\n\n  balance LP after -  WETH:\n  9999997057795940602\n\n  balance inside manager -  USDC:\n  1123\n\n  balance inside manager - WETH:\n  516472404479\n```\n\nIt can be observed that some tokens stuck inside the `ParticlePositionManager` contract.\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nUse a higher scaling for `BASIS_POINT`, considering the fact that tokens commonly have a high number of decimals.\n\n**[wukong-particle (Particle) acknowledged and commented](https://github.com/code-423n4/2023-12-particle-findings/issues/7#issuecomment-1868144864):**\n > Good point. Appreciated the detailed PoC. On our end, I think we should have documented the use of `tokenPremiumPortion` more clearly.  It's a compromise we took to ensure the `lien` structure stored on chain is less than 3 uint256. We compressed a lot and were only left with `uint24`. \n> \n> We think a dust of ~1000 USDC when a user is spending 15B USDC is acceptable. We could add a function to collect dust if needed (might be complicated though). \n> \n> If there can be a serious attack around this dust, please do raise it. Thanks!\n\n**[adriro (Warden) commented](https://github.com/code-423n4/2023-12-particle-findings/issues/7#issuecomment-1872539065):**\n > These are leftover amounts that are caused by the rounding of the premium as a portion (premium -> portion -> premium). It looks more on the QA side to me.\n\n**[0xleastwood (Judge) commented](https://github.com/code-423n4/2023-12-particle-findings/issues/7#issuecomment-1872947795):**\n > > These are leftover amounts that are caused by the rounding of the premium as a portion (premium -> portion -> premium). It looks more on the QA side to me.\n> \n> This seems considerable and will accrue significantly over the lifetime of the protocol. I think the severity is justified as per the judging criteria.\n> \n> `2 â€” Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.`\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-12-particle",
  "Code": [
    {
      "filename": "contracts/protocol/ParticlePositionManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {IERC721Receiver} from \"../../lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {Multicall} from \"../../lib/openzeppelin-contracts/contracts/utils/Multicall.sol\";\nimport {ReentrancyGuard} from \"../../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport {Ownable2StepUpgradeable} from \"../../lib/openzeppelin-contracts-upgradeable/contracts/access/Ownable2StepUpgradeable.sol\";\nimport {UUPSUpgradeable} from \"../../lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/UUPSUpgradeable.sol\";\nimport {TransferHelper} from \"../../lib/v3-periphery/contracts/libraries/TransferHelper.sol\";\n\nimport {IParticlePositionManager} from \"../interfaces/IParticlePositionManager.sol\";\nimport {Base} from \"../libraries/Base.sol\";\nimport {LiquidityPosition} from \"../libraries/LiquidityPosition.sol\";\nimport {Lien} from \"../libraries/Lien.sol\";\nimport {SwapPosition} from \"../libraries/SwapPosition.sol\";\nimport {DataStruct, DataCache} from \"../libraries/Structs.sol\";\nimport {Errors} from \"../libraries/Errors.sol\";\n\ncontract ParticlePositionManager is\n    IParticlePositionManager,\n    Ownable2StepUpgradeable,\n    UUPSUpgradeable,\n    IERC721Receiver,\n    ReentrancyGuard,\n    Multicall\n{\n    using LiquidityPosition for mapping(uint256 => LiquidityPosition.Info);\n    using Lien for mapping(bytes32 => Lien.Info);\n    using SwapPosition for mapping(bytes32 => SwapPosition.Info);\n\n    /* Constants */\n    uint256 private constant _TREASURY_RATE_MAX = 500_000;\n    uint256 private constant _FEE_FACTOR_MAX = 1_000;\n    uint128 private constant _LIQUIDATION_REWARD_FACTOR_MAX = 100_000;\n    uint256 private constant _LOAN_TERM_MAX = 30 days;\n\n    /* Variables */\n    uint96 private _nextRecordId; ///@dev used for both lien and swap\n    uint256 private _treasuryRate;\n    // solhint-disable var-name-mixedcase\n    address public DEX_AGGREGATOR;\n    uint256 public FEE_FACTOR;\n    uint128 public LIQUIDATION_REWARD_FACTOR;\n    uint256 public LOAN_TERM;\n    // solhint-enable var-name-mixedcase\n\n    /* Storage */\n    mapping(uint256 => LiquidityPosition.Info) public lps; ///@dev tokenId => liquidity position\n    mapping(bytes32 => Lien.Info) public liens; ///@dev (address, lienId) => lien\n    mapping(address => uint256) private _treasury; ///@dev address => amount\n\n    // required by openzeppelin UUPS module\n    // solhint-disable-next-line no-empty-blocks\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address dexAggregator,\n        uint256 feeFactor,\n        uint128 liquidationRewardFactor,\n        uint256 loanTerm,\n        uint256 treasuryRate\n    ) external initializer {\n        __UUPSUpgradeable_init();\n        __Ownable_init();\n        DEX_AGGREGATOR = dexAggregator;\n        FEE_FACTOR = feeFactor;\n        LIQUIDATION_REWARD_FACTOR = liquidationRewardFactor;\n        LOAN_TERM = loanTerm;\n        _treasuryRate = treasuryRate;\n    }\n\n    /*==============================================================\n                        Liquidity Provision Logic\n    ==============================================================*/\n\n    /// @inheritdoc IParticlePositionManager\n    function mint(\n        DataStruct.MintParams calldata params\n    )\n        external\n        override\n        nonReentrant\n        returns (uint256 tokenId, uint128 liquidity, uint256 amount0Minted, uint256 amount1Minted)\n    {\n        (tokenId, liquidity, amount0Minted, amount1Minted) = lps.mint(params);\n    }\n\n    /**\n     * @notice Receiver function upon ERC721 LP position transfer\n     * @dev LP must use safeTransferFrom to trigger onERC721Received\n     * @param from the address which previously owned the NFT\n     * @param tokenId the NFT identifier which is being transferred\n     */\n    function onERC721Received(\n        address,\n        address from,\n        uint256 tokenId,\n        bytes calldata\n    ) external override returns (bytes4) {\n        if (msg.sender == Base.UNI_POSITION_MANAGER_ADDR) {\n            // matched with Uniswap v3 position NFTs\n            lps[tokenId] = LiquidityPosition.Info({owner: from, renewalCutoffTime: 0, token0Owed: 0, token1Owed: 0});\n            (, , , , , , , uint128 liquidity, , , , ) = Base.UNI_POSITION_MANAGER.positions(tokenId);\n            emit LiquidityPosition.SupplyLiquidity(tokenId, from, liquidity);\n        }\n        return this.onERC721Received.selector;\n    }\n\n    /*==============================================================\n                       Liquidity Management Logic\n    ==============================================================*/\n\n    /// @inheritdoc IParticlePositionManager\n    function increaseLiquidity(\n        uint256 tokenId,\n        uint256 amount0,\n        uint256 amount1\n    ) external override nonReentrant returns (uint128 liquidity, uint256 amount0Added, uint256 amount1Added) {\n        (liquidity, amount0Added, amount1Added) = lps.increaseLiquidity(tokenId, amount0, amount1);\n    }\n\n    /// @inheritdoc IParticlePositionManager\n    function decreaseLiquidity(\n        uint256 tokenId,\n        uint128 liquidity\n    ) external override nonReentrant returns (uint256 amount0Decreased, uint256 amount1Decreased) {\n        (amount0Decreased, amount1Decreased) = lps.decreaseLiquidity(tokenId, liquidity);\n    }\n\n    /// @inheritdoc IParticlePositionManager\n    function collectLiquidity(\n        uint256 tokenId\n    ) external override nonReentrant returns (uint256 amount0Collected, uint256 amount1Collected) {\n        (amount0Collected, amount1Collected) = lps.collectLiquidity(tokenId);\n    }\n\n    /// @inheritdoc IParticlePositionManager\n    function reclaimLiquidity(uint256 tokenId) external override nonReentrant {\n        lps.reclaimLiquidity(tokenId);\n    }\n\n    /*=============================================================\n                             Open Position\n    ==============================================================*/\n\n    /// @inheritdoc IParticlePositionManager\n    function openPosition(\n        DataStruct.OpenPositionParams calldata params\n    ) public override nonReentrant returns (uint96 lienId, uint256 collateralTo) {\n        if (params.liquidity == 0) revert Errors.InsufficientBorrow();\n\n        // local cache to avoid stack too deep\n        DataCache.OpenPositionCache memory cache;\n\n        // prepare data for swap\n        (\n            cache.tokenFrom,\n            cache.tokenTo,\n            cache.feeGrowthInside0LastX128,\n            cache.feeGrowthInside1LastX128,\n            cache.collateralFrom,\n            collateralTo\n        ) = Base.prepareLeverage(params.tokenId, params.liquidity, params.zeroForOne);\n\n        // decrease liquidity from LP position, pull the amount to this contract\n        (cache.amountFromBorrowed, cache.amountToBorrowed) = LiquidityPosition.decreaseLiquidity(\n            params.tokenId,\n            params.liquidity\n        );\n        LiquidityPosition.collectLiquidity(\n            params.tokenId,\n            uint128(cache.amountFromBorrowed),\n            uint128(cache.amountToBorrowed),\n            address(this)\n        );\n        if (!params.zeroForOne)\n            (cache.amountFromBorrowed, cache.amountToBorrowed) = (cache.amountToBorrowed, cache.amountFromBorrowed);\n\n        // transfer in enough collateral\n        if (params.marginFrom > 0) {\n            TransferHelper.safeTransferFrom(cache.tokenFrom, msg.sender, address(this), params.marginFrom);\n        }\n        if (params.marginTo > 0) {\n            TransferHelper.safeTransferFrom(cache.tokenTo, msg.sender, address(this), params.marginTo);\n        }\n\n        // pay for fee\n        if (FEE_FACTOR > 0) {\n            cache.feeAmount = ((params.marginFrom + cache.amountFromBorrowed) * FEE_FACTOR) / Base.BASIS_POINT;\n            cache.treasuryAmount = (cache.feeAmount * _treasuryRate) / Base.BASIS_POINT;\n            _treasury[cache.tokenFrom] += cache.treasuryAmount;\n            if (params.zeroForOne) {\n                lps.addTokensOwed(params.tokenId, uint128(cache.feeAmount - cache.treasuryAmount), 0);\n            } else {\n                lps.addTokensOwed(params.tokenId, 0, uint128(cache.feeAmount - cache.treasuryAmount));\n            }\n        }\n\n        // cannot swap more than available amount\n        if (params.amountSwap > params.marginFrom + cache.amountFromBorrowed - cache.feeAmount)\n            revert Errors.OverSpend();\n\n        // swap to meet the collateral requirement\n        (cache.amountSpent, cache.amountReceived) = Base.swap(\n            cache.tokenFrom,\n            cache.tokenTo,\n            params.amountSwap,\n            collateralTo - cache.amountToBorrowed - params.marginTo, // amount needed to meet requirement\n            DEX_AGGREGATOR,\n            params.data\n        );\n\n        // leftover amounts from the collateral are now premiums, and ensure enough premium is stored\n        if (params.zeroForOne) {\n            cache.token0PremiumPortion = Base.uint256ToUint24(\n                ((params.marginFrom + cache.amountFromBorrowed - cache.feeAmount - cache.amountSpent) *\n                    Base.BASIS_POINT) / cache.collateralFrom\n            );\n            cache.token1PremiumPortion = Base.uint256ToUint24(\n                ((cache.amountReceived + cache.amountToBorrowed + params.marginTo - collateralTo) * Base.BASIS_POINT) /\n                    collateralTo\n            );\n            if (\n                cache.token0PremiumPortion < params.tokenFromPremiumPortionMin ||\n                cache.token1PremiumPortion < params.tokenToPremiumPortionMin\n            ) revert Errors.InsufficientPremium();\n        } else {\n            cache.token1PremiumPortion = Base.uint256ToUint24(\n                ((params.marginFrom + cache.amountFromBorrowed - cache.feeAmount - cache.amountSpent) *\n                    Base.BASIS_POINT) / cache.collateralFrom\n            );\n            cache.token0PremiumPortion = Base.uint256ToUint24(\n                ((cache.amountReceived + cache.amountToBorrowed + params.marginTo - collateralTo) * Base.BASIS_POINT) /\n                    collateralTo\n            );\n            if (\n                cache.token0PremiumPortion < params.tokenToPremiumPortionMin ||\n                cache.token1PremiumPortion < params.tokenFromPremiumPortionMin\n            ) revert Errors.InsufficientPremium();\n        }\n\n        // create a new lien\n        liens[keccak256(abi.encodePacked(msg.sender, lienId = _nextRecordId++))] = Lien.Info({\n            tokenId: uint40(params.tokenId),\n            liquidity: params.liquidity,\n            token0PremiumPortion: cache.token0PremiumPortion,\n            token1PremiumPortion: cache.token1PremiumPortion,\n            startTime: uint32(block.timestamp),\n            feeGrowthInside0LastX128: cache.feeGrowthInside0LastX128,\n            feeGrowthInside1LastX128: cache.feeGrowthInside1LastX128,\n            zeroForOne: params.zeroForOne\n        });\n\n        emit OpenPosition(msg.sender, lienId, collateralTo);\n    }\n\n    /*=============================================================\n                             Close Position\n    ==============================================================*/\n\n    /// @inheritdoc IParticlePositionManager\n    function closePosition(DataStruct.ClosePositionParams calldata params) external override nonReentrant {\n        bytes32 lienKey = keccak256(abi.encodePacked(msg.sender, params.lienId));\n        Lien.Info memory lien = liens.getInfo(lienKey);\n\n        // check lien is valid\n        if (lien.liquidity == 0) revert Errors.RecordEmpty();\n\n        // delete lien from storage\n        delete liens[lienKey];\n\n        // local cache to avoid stack too deep\n        DataCache.ClosePositionCache memory cache;\n\n        // prepare data for swap back\n        ///@dev the token/collateralFrom and token/collateralTo are swapped compared to openPosition\n        (cache.tokenTo, cache.tokenFrom, , , cache.collateralTo, cache.collateralFrom) = Base.prepareLeverage(\n            lien.tokenId,\n            lien.liquidity,\n            lien.zeroForOne\n        );\n\n        // get the amount of premium in the lien\n        if (lien.zeroForOne) {\n            (cache.tokenToPremium, cache.tokenFromPremium) = Base.getPremium(\n                cache.collateralTo,\n                cache.collateralFrom,\n                lien.token0PremiumPortion,\n                lien.token1PremiumPortion\n            );\n        } else {\n            (cache.tokenFromPremium, cache.tokenToPremium) = Base.getPremium(\n                cache.collateralFrom,\n                cache.collateralTo,\n                lien.token0PremiumPortion,\n                lien.token1PremiumPortion\n            );\n        }\n\n        // execute actual position closing\n        _closePosition(params, cache, lien, msg.sender);\n\n        emit ClosePosition(msg.sender, lien.tokenId, cache.amountFromAdd, cache.amountToAdd);\n    }\n\n    /// @inheritdoc IParticlePositionManager\n    function liquidatePosition(\n        DataStruct.ClosePositionParams calldata params,\n        address borrower\n    ) external override nonReentrant {\n        bytes32 lienKey = keccak256(abi.encodePacked(borrower, params.lienId));\n        Lien.Info memory lien = liens.getInfo(lienKey);\n\n        // check lien is valid\n        if (lien.liquidity == 0) revert Errors.RecordEmpty();\n\n        // local cache to avoid stack too deep\n        DataCache.ClosePositionCache memory closeCache;\n        DataCache.LiquidatePositionCache memory liquidateCache;\n\n        // get liquidation parameters\n        ///@dev calculate premium outside of _closePosition to allow liquidatePosition to take reward from premium\n        (\n            closeCache.tokenFrom,\n            closeCache.tokenTo,\n            liquidateCache.tokenFromOwed,\n            liquidateCache.tokenToOwed,\n            closeCache.tokenFromPremium,\n            closeCache.tokenToPremium,\n            closeCache.collateralFrom,\n\n        ) = Base.getOwedInfoConverted(\n            DataStruct.OwedInfoParams({\n                tokenId: lien.tokenId,\n                liquidity: lien.liquidity,\n                feeGrowthInside0LastX128: lien.feeGrowthInside0LastX128,\n                feeGrowthInside1LastX128: lien.feeGrowthInside1LastX128,\n                token0PremiumPortion: lien.token0PremiumPortion,\n                token1PremiumPortion: lien.token1PremiumPortion\n            }),\n            lien.zeroForOne\n        );\n\n        // calculate liquidation reward\n        liquidateCache.liquidationRewardFrom =\n            ((closeCache.tokenFromPremium) * LIQUIDATION_REWARD_FACTOR) /\n            uint128(Base.BASIS_POINT);\n        liquidateCache.liquidationRewardTo =\n            ((closeCache.tokenToPremium) * LIQUIDATION_REWARD_FACTOR) /\n            uint128(Base.BASIS_POINT);\n        closeCache.tokenFromPremium -= liquidateCache.liquidationRewardFrom;\n        closeCache.tokenToPremium -= liquidateCache.liquidationRewardTo;\n\n        // check for liquidation condition\n        ///@dev the liquidation condition is that\n        ///     (EITHER premium is not enough) OR (cutOffTime > startTime AND currentTime > startTime + LOAN_TERM)\n        if (\n            !((closeCache.tokenFromPremium < liquidateCache.tokenFromOwed ||\n                closeCache.tokenToPremium < liquidateCache.tokenToOwed) ||\n                (lien.startTime < lps.getRenewalCutoffTime(lien.tokenId) &&\n                    lien.startTime + LOAN_TERM < block.timestamp))\n        ) {\n            revert Errors.LiquidationNotMet();\n        }\n\n        // delete lien from storage\n        delete liens[lienKey];\n\n        // execute actual position closing\n        _closePosition(params, closeCache, lien, borrower);\n\n        // reward liquidator\n        TransferHelper.safeTransfer(closeCache.tokenFrom, msg.sender, liquidateCache.liquidationRewardFrom);\n        TransferHelper.safeTransfer(closeCache.tokenTo, msg.sender, liquidateCache.liquidationRewardTo);\n\n        emit LiquidatePosition(borrower, lien.tokenId, closeCache.amountFromAdd, closeCache.amountToAdd);\n    }\n\n    /**\n     * @notice Internal function to close a position\n     * @dev Caller must ensure either the msg.sender is borrower or liquidation condition is met\n     * @param params close position parameters\n     * @param cache local cache to avoid stack too deep\n     * @param lien lien info\n     * @param borrower borrower address\n     */\n    function _closePosition(\n        DataStruct.ClosePositionParams calldata params,\n        DataCache.ClosePositionCache memory cache,\n        Lien.Info memory lien,\n        address borrower\n    ) internal {\n        // optimistically use the input numbers to swap for repay\n        /// @dev amountSwap overspend will be caught by refundWithCheck step in below\n        (cache.amountSpent, cache.amountReceived) = Base.swap(\n            cache.tokenFrom,\n            cache.tokenTo,\n            params.amountSwap,\n            0, /// @dev we check cache.amountReceived is sufficient to repay LP in below\n            DEX_AGGREGATOR,\n            params.data\n        );\n\n        // based on borrowed liquidity, compute the required return amount\n        /// @dev the from-to swapping direction is reverted compared to openPosition\n        (cache.amountToAdd, cache.amountFromAdd) = Base.getRequiredRepay(lien.liquidity, lien.tokenId);\n        if (!lien.zeroForOne) (cache.amountToAdd, cache.amountFromAdd) = (cache.amountFromAdd, cache.amountToAdd);\n\n        // the liquidity to add must be no less than the available amount\n        /// @dev the max available amount contains the tokensOwed, will have another check in below at refundWithCheck\n        if (\n            cache.amountFromAdd > cache.collateralFrom + cache.tokenFromPremium - cache.amountSpent ||\n            cache.amountToAdd > cache.amountReceived + cache.tokenToPremium\n        ) {\n            revert Errors.InsufficientRepay();\n        }\n\n        // add liquidity back to borrower\n        if (lien.zeroForOne) {\n            (cache.liquidityAdded, cache.amountToAdd, cache.amountFromAdd) = LiquidityPosition.increaseLiquidity(\n                cache.tokenTo,\n                cache.tokenFrom,\n                lien.tokenId,\n                cache.amountToAdd,\n                cache.amountFromAdd\n            );\n        } else {\n            (cache.liquidityAdded, cache.amountFromAdd, cache.amountToAdd) = LiquidityPosition.increaseLiquidity(\n                cache.tokenFrom,\n                cache.tokenTo,\n                lien.tokenId,\n                cache.amountFromAdd,\n                cache.amountToAdd\n            );\n        }\n\n        // obtain the position's latest FeeGrowthInside after increaseLiquidity\n        (, , , , , , , , cache.feeGrowthInside0LastX128, cache.feeGrowthInside1LastX128, , ) = Base\n            .UNI_POSITION_MANAGER\n            .positions(lien.tokenId);\n\n        // caculate the amounts owed since last fee collection during the borrowing period\n        (cache.token0Owed, cache.token1Owed) = Base.getOwedFee(\n            cache.feeGrowthInside0LastX128,\n            cache.feeGrowthInside1LastX128,\n            lien.feeGrowthInside0LastX128,\n            lien.feeGrowthInside1LastX128,\n            lien.liquidity\n        );\n\n        // calculate the the amounts owed to LP up to the premium in the lien\n        // must ensure enough amount is left to pay for interest first, then send gains and fund left to borrower\n        ///@dev refundWithCheck ensures actual cannot be more than expected, since amount owed to LP is in actual,\n        ///     it ensures (1) on the collateralFrom part of refund, tokenOwed is covered, and (2) on the amountReceived\n        ///      part, received is no less than liquidity addback + token owed.\n        if (lien.zeroForOne) {\n            cache.token0Owed = cache.token0Owed < cache.tokenToPremium ? cache.token0Owed : cache.tokenToPremium;\n            cache.token1Owed = cache.token1Owed < cache.tokenFromPremium ? cache.token1Owed : cache.tokenFromPremium;\n            Base.refundWithCheck(\n                borrower,\n                cache.tokenFrom,\n                cache.collateralFrom + cache.tokenFromPremium,\n                cache.amountSpent + cache.amountFromAdd + cache.token1Owed\n            );\n            Base.refundWithCheck(\n                borrower,\n                cache.tokenTo,\n                cache.amountReceived + cache.tokenToPremium,\n                cache.amountToAdd + cache.token0Owed\n            );\n        } else {\n            cache.token0Owed = cache.token0Owed < cache.tokenFromPremium ? cache.token0Owed : cache.tokenFromPremium;\n            cache.token1Owed = cache.token1Owed < cache.tokenToPremium ? cache.token1Owed : cache.tokenToPremium;\n            Base.refundWithCheck(\n                borrower,\n                cache.tokenFrom,\n                cache.collateralFrom + cache.tokenFromPremium,\n                cache.amountSpent + cache.amountFromAdd + cache.token0Owed\n            );\n            Base.refundWithCheck(\n                borrower,\n                cache.tokenTo,\n                cache.amountReceived + cache.tokenToPremium,\n                cache.amountToAdd + cache.token1Owed\n            );\n        }\n\n        // pay for interest\n        lps.addTokensOwed(lien.tokenId, cache.token0Owed, cache.token1Owed);\n    }\n\n    /*=============================================================\n                             Premium Logic\n    ==============================================================*/\n\n    /// @inheritdoc IParticlePositionManager\n    function addPremium(uint96 lienId, uint128 premium0, uint128 premium1) external override nonReentrant {\n        bytes32 lienKey = keccak256(abi.encodePacked(msg.sender, lienId));\n        Lien.Info memory lien = liens.getInfo(lienKey);\n\n        // check lien is valid\n        if (lien.liquidity == 0) revert Errors.RecordEmpty();\n\n        // check LP allows extension of this lien\n        if (lps.getRenewalCutoffTime(lien.tokenId) > lien.startTime) revert Errors.RenewalDisabled();\n\n        (, , address token0, address token1, , int24 tickLower, int24 tickUpper, , , , , ) = Base\n            .UNI_POSITION_MANAGER\n            .positions(lien.tokenId);\n        (uint256 collateral0, uint256 collateral1) = Base.getRequiredCollateral(lien.liquidity, tickLower, tickUpper);\n\n        (uint128 token0Premium, uint128 token1Premium) = Base.getPremium(\n            collateral0,\n            collateral1,\n            lien.token0PremiumPortion,\n            lien.token1PremiumPortion\n        );\n\n        liens.updatePremium(\n            lienKey,\n            uint24(((token0Premium + premium0) * Base.BASIS_POINT) / collateral0),\n            uint24(((token1Premium + premium1) * Base.BASIS_POINT) / collateral1)\n        );\n\n        // transfer in added premium\n        if (premium0 > 0) {\n            TransferHelper.safeTransferFrom(token0, msg.sender, address(this), premium0);\n        }\n        if (premium1 > 0) {\n            TransferHelper.safeTransferFrom(token1, msg.sender, address(this), premium1);\n        }\n\n        emit AddPremium(msg.sender, lienId, premium0, premium1);\n    }\n\n    /*=============================================================\n                              Vanilla Swap\n    ==============================================================*/\n\n    /// @inheritdoc IParticlePositionManager\n    function swap(\n        address token0,\n        address token1,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        bytes calldata data\n    ) external override nonReentrant returns (uint256 amount0, uint256 amount1) {\n        (amount0, amount1) = SwapPosition.swap(token0, token1, amountIn, amountOutMinimum, DEX_AGGREGATOR, data);\n    }\n\n    /*=============================================================\n                              Admin logic\n    ==============================================================*/\n\n    /// @inheritdoc IParticlePositionManager\n    function updateDexAggregator(address dexAggregator) external override onlyOwner {\n        if (dexAggregator == address(0)) revert Errors.InvalidValue();\n        DEX_AGGREGATOR = dexAggregator;\n        emit UpdateDexAggregator(dexAggregator);\n    }\n\n    /// @inheritdoc IParticlePositionManager\n    function updateLiquidationRewardFactor(uint128 liquidationRewardFactor) external override onlyOwner {\n        if (liquidationRewardFactor > _LIQUIDATION_REWARD_FACTOR_MAX) revert Errors.InvalidValue();\n        LIQUIDATION_REWARD_FACTOR = liquidationRewardFactor;\n        emit UpdateLiquidationRewardFactor(liquidationRewardFactor);\n    }\n\n    /// @inheritdoc IParticlePositionManager\n    function updateFeeFactor(uint256 feeFactor) external override onlyOwner {\n        if (feeFactor > _FEE_FACTOR_MAX) revert Errors.InvalidValue();\n        FEE_FACTOR = feeFactor;\n        emit UpdateFeeFactor(feeFactor);\n    }\n\n    /// @inheritdoc IParticlePositionManager\n    function updateLoanTerm(uint256 loanTerm) external override onlyOwner {\n        if (loanTerm > _LOAN_TERM_MAX) revert Errors.InvalidValue();\n        LOAN_TERM = loanTerm;\n        emit UpdateLoanTerm(loanTerm);\n    }\n\n    /// @inheritdoc IParticlePositionManager\n    function updateTreasuryRate(uint256 treasuryRate) external override onlyOwner {\n        if (treasuryRate > _TREASURY_RATE_MAX) revert Errors.InvalidValue();\n        _treasuryRate = treasuryRate;\n        emit UpdateTreasuryRate(treasuryRate);\n    }\n\n    /// @inheritdoc IParticlePositionManager\n    function withdrawTreasury(address token, address recipient) external override onlyOwner nonReentrant {\n        uint256 withdrawAmount = _treasury[token];\n        if (withdrawAmount > 0) {\n            if (recipient == address(0)) {\n                revert Errors.InvalidRecipient();\n            }\n            _treasury[token] = 0;\n            TransferHelper.safeTransfer(token, recipient, withdrawAmount);\n            emit WithdrawTreasury(token, recipient, withdrawAmount);\n        }\n    }\n}"
    }
  ]
}