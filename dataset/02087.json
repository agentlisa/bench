{
  "Title": "M-2: [M-01] Incorrect refund of execution fee to user",
  "Content": "# Issue M-2: [M-01] Incorrect refund of execution fee to user \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/212 \n\n## Found by \nhandsomegiraffe\n\n## Summary\nDuring execution of Deposits, Withdrawals and Orders, users are refunded part of the `executionFee` after accounting for `gasUsed` during the transaction. In the codebase, an incorrect value of `startingGas` is used to calculate the `gasUsed`, resulting in users getting less than what they should be refunded. \n\n## Vulnerability Detail\nVulnerability exists in DepositHandler.sol, WithdrawalHandler.sol and OrderHandler.sol. Using DepositHandler.sol as an example:\n\n![image](https://user-images.githubusercontent.com/83704326/227539224-f59d4cb7-f638-4ddd-a7b3-7949e8fef1b8.png)\n\n((1) In [line 94](https://github.com/gmx-io/gmx-synthetics/blob/b1557fa286c35f54c65a38a7b57baf87ecad1b5b/contracts/exchange/DepositHandler.sol#L94) of DepositHandler.sol, Order Keepers call `executeDeposit()` and `startingGas` is forwarded to an external call `_executeDeposit`. \n(2) In ExecuteDepositUtils.sol, `_executeDeposit` further calls `GasUtils.payExecutionFee(... params.startingGas`. \n(3) Then in GasUtils.sol, `payExecutionFee()` calculates `gasUsed = startingGas - gasleft();` \n(4) `gasUsed` is used to calculate `executionFeeForKeeper`, and after paying the fee to keeper, the remainder of `executionFee` (previously paid by user) is refunded to the user\n\nThe issue lies with (1) where `startingGas` is passed into `_executeDeposit` and assumed to be all remaining gas left. [EIP-150](https://eips.ethereum.org/EIPS/eip-150) defines the \"all but one 64th\" rule, which states that always at least 1/64 of the gas still not used for this transaction cannot be sent along. Therefore, in (3) `gasUsed` is overstated by 1/64 and the refund back to user in (4) is incorrect (less than what user should get back). \n\n**Proof of Concept**\n![image](https://user-images.githubusercontent.com/83704326/227538387-f2f2ca87-d784-49a5-b043-d779a92fcff8.png)\n\nIn the test above, it is demonstrated that external function calls are forwarded with only 63/64 of the remaining gas. A separate internal function call used to demonstrate the difference in gas costs.  \n\n## Impact\nGMX Users will receive an incorrect refund from the execution fee and will be overpaying for deposit, withdraw and order executions.\n\n## Code Snippet\nhttps://github.com/gmx-io/gmx-synthetics/blob/b1557fa286c35f54c65a38a7b57baf87ecad1b5b/contracts/exchange/DepositHandler.sol#L100\nhttps://github.com/gmx-io/gmx-synthetics/blob/b1557fa286c35f54c65a38a7b57baf87ecad1b5b/contracts/exchange/WithdrawalHandler.sol#L130\nhttps://github.com/gmx-io/gmx-synthetics/blob/b1557fa286c35f54c65a38a7b57baf87ecad1b5b/contracts/exchange/OrderHandler.sol#L174\n\n## Tool used\nHardhat\nManual Review\n\n## Recommendation\n\nIn DepositHandler.sol, for `executeDeposit` it is recommended that `startingGas()` is calculated **after** the external call is made.\n![image](https://user-images.githubusercontent.com/83704326/227540020-c570a91b-4bdd-41be-9525-e069bab895f6.png)\n\nAlternatively, in GasUtils.sol, gasUsed could be computed with 63/64 of startingGas, in order to obtain the correct refund amount to the user. This would also apply to Withdraw and Order executions which have similar code flows.\n![image](https://user-images.githubusercontent.com/83704326/227539740-4df5497a-709d-4e4c-ad00-ab492fc5b74c.png)\n\n\n\n## Discussion\n\n**xvi10**\n\nthis is a valid concern but we do not think this requires a change in the contracts, startingGas is measured after withOraclePrices, so there will be some extra gas consumed for that call, additionally the keeper should be incentivised with a small fee to execute the requests, the value for Keys.EXECUTION_GAS_FEE_BASE_AMOUNT can be adjusted to account for these\n\n**Jiaren-tang**\n\nEscalate for 10 USDC. I do not recommend escalating this issue for a reward of 10 USDC, as the impact is too trivial. According to the protocol's comments, not forwarding 1/64th of the gas to compensate for the execution fee does not block order flow execution, and Keys.EXECUTION_GAS_FEE_BASE_AMOUNT can be configured to easily solve this issue.\n\nFurthermore, based on Sherlock's severity guide:\n\nhttps://docs.sherlock.xyz/audits/judging/judging\n\n> a Medium severity rating should only be given if there is a viable scenario (even if unlikely) that could cause the protocol to enter a state where a material amount of funds can be lost. The attack path is possible with assumptions that either mimic on-chain conditions or reflect conditions that have a reasonable chance of becoming true in the future. The more expensive the attack is for an attacker, the less likely it will be included as a Medium (holding all other factors constant). The vulnerability must be something that is not considered an acceptable risk by a reasonable protocol team.\n\nBased on the protocol's comment, this issue is clearly considered an acceptable risk by a reasonable protocol team. Therefore, I do not believe it meets the criteria for a Medium severity rating.\n@xvi10 @IllIllI000\n\n**sherlock-admin**\n\n > Escalate for 10 USDC. I do not recommend escalating this issue for a reward of 10 USDC, as the impact is too trivial. According to the protocol's comments, not forwarding 1/64th of the gas to compensate for the execution fee does not block order flow execution, and Keys.EXECUTION_GAS_FEE_BASE_AMOUNT can be configured to easily solve this issue.\n> \n> Furthermore, based on Sherlock's severity guide:\n> \n> https://docs.sherlock.xyz/audits/judging/judging\n> \n> > a Medium severity rating should only be given if there is a viable scenario (even if unlikely) that could cause the protocol to enter a state where a material amount of funds can be lost. The attack path is possible with assumptions that either mimic on-chain conditions or reflect conditions that have a reasonable chance of becoming true in the future. The more expensive the attack is for an attacker, the less likely it will be included as a Medium (holding all other factors constant). The vulnerability must be something that is not considered an acceptable risk by a reasonable protocol team.\n> \n> Based on the protocol's comment, this issue is clearly considered an acceptable risk by a reasonable protocol team. Therefore, I do not believe it meets the criteria for a Medium severity rating.\n> @xvi10 @IllIllI000\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**chewonithard**\n\nEscalate for 10 USDC. I opine that the issue is valid and should be retained for award.\n1. The protocol has acknowledged this as a valid issue.\n2. While no code change is needed, the protocol said they can adjust Keys.EXECUTION_GAS_FEE_BASE_AMOUNT to account for this -- indicating there was an issue in the first place which needs to be fixed\n3. Keeper is already incentivsed through a defined fee see [link](https://github.com/gmx-io/gmx-synthetics/blob/main/contracts/gas/GasUtils.sol#L50), therefore this additional gas that the user has to pay for is unintended and should be remedied. Given the popularity of the protocol, the aggregate amount of gas users will be overpaying for is significant\n\n**sherlock-admin**\n\n > Escalate for 10 USDC. I opine that the issue is valid and should be retained for award.\n> 1. The protocol has acknowledged this as a valid issue.\n> 2. While no code change is needed, the protocol said they can adjust Keys.EXECUTION_GAS_FEE_BASE_AMOUNT to account for this -- indicating there was an issue in the first place which needs to be fixed\n> 3. Keeper is already incentivsed through a defined fee see [link](https://github.com/gmx-io/gmx-synthetics/blob/main/contracts/gas/GasUtils.sol#L50), therefore this additional gas that the user has to pay for is unintended and should be remedied. Given the popularity of the protocol, the aggregate amount of gas users will be overpaying for is significant\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**IllIllI000**\n\nI agree with the [second](https://github.com/sherlock-audit/2023-02-gmx-judging/issues/212#issuecomment-1495786878) escalation for its stated reasons. In addition, if the swap path is long enough, the base fee may not be large enough to cover the number of swaps\n\n**hrishibhat**\n\nEscalation accepted\n\nConsidering this issue as valid based on Sponsor, 2nd Escalation and Lead Watson comments. \n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Considering this issue as valid based on Sponsor, 2nd Escalation and Lead Watson comments. \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n**xvi10**\n\nFix in https://github.com/gmx-io/gmx-synthetics/pull/119\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "contracts/exchange/DepositHandler.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../utils/GlobalReentrancyGuard.sol\";\n\nimport \"./ExchangeUtils.sol\";\nimport \"../role/RoleModule.sol\";\nimport \"../event/EventEmitter.sol\";\nimport \"../feature/FeatureUtils.sol\";\n\nimport \"../market/Market.sol\";\nimport \"../market/MarketToken.sol\";\n\nimport \"../deposit/Deposit.sol\";\nimport \"../deposit/DepositVault.sol\";\nimport \"../deposit/DepositUtils.sol\";\nimport \"../deposit/ExecuteDepositUtils.sol\";\nimport \"../oracle/Oracle.sol\";\nimport \"../oracle/OracleModule.sol\";\n\n// @title DepositHandler\n// @dev Contract to handle creation, execution and cancellation of deposits\ncontract DepositHandler is GlobalReentrancyGuard, RoleModule, OracleModule {\n    using Deposit for Deposit.Props;\n\n    EventEmitter public immutable eventEmitter;\n    DepositVault public immutable depositVault;\n    Oracle public immutable oracle;\n\n    constructor(\n        RoleStore _roleStore,\n        DataStore _dataStore,\n        EventEmitter _eventEmitter,\n        DepositVault _depositVault,\n        Oracle _oracle\n    ) RoleModule(_roleStore) GlobalReentrancyGuard(_dataStore) {\n        eventEmitter = _eventEmitter;\n        depositVault = _depositVault;\n        oracle = _oracle;\n    }\n\n    // @dev creates a deposit in the deposit store\n    // @param account the depositing account\n    // @param params DepositUtils.CreateDepositParams\n    function createDeposit(\n        address account,\n        DepositUtils.CreateDepositParams calldata params\n    ) external globalNonReentrant onlyController returns (bytes32) {\n        FeatureUtils.validateFeature(dataStore, Keys.createDepositFeatureDisabledKey(address(this)));\n\n        return DepositUtils.createDeposit(\n            dataStore,\n            eventEmitter,\n            depositVault,\n            account,\n            params\n        );\n    }\n\n    // @dev cancels a deposit\n    // @param key the deposit key\n    function cancelDeposit(bytes32 key) external globalNonReentrant onlyController {\n        uint256 startingGas = gasleft();\n\n        DataStore _dataStore = dataStore;\n        Deposit.Props memory deposit = DepositStoreUtils.get(_dataStore, key);\n\n        FeatureUtils.validateFeature(_dataStore, Keys.cancelDepositFeatureDisabledKey(address(this)));\n\n        ExchangeUtils.validateRequestCancellation(\n            _dataStore,\n            deposit.updatedAtBlock(),\n            \"Deposit\"\n        );\n\n        DepositUtils.cancelDeposit(\n            _dataStore,\n            eventEmitter,\n            depositVault,\n            key,\n            deposit.account(),\n            startingGas,\n            Keys.USER_INITIATED_CANCEL,\n            \"\"\n        );\n    }\n\n    // @dev executes a deposit\n    // @param key the key of the deposit to execute\n    // @param oracleParams OracleUtils.SetPricesParams\n    function executeDeposit(\n        bytes32 key,\n        OracleUtils.SetPricesParams calldata oracleParams\n    ) external\n        globalNonReentrant\n        onlyOrderKeeper\n        withOraclePrices(oracle, dataStore, eventEmitter, oracleParams)\n    {\n        uint256 startingGas = gasleft();\n\n        try this._executeDeposit(\n            key,\n            oracleParams,\n            msg.sender,\n            startingGas\n        ) {\n        } catch (bytes memory reasonBytes) {\n            _handleDepositError(\n                key,\n                startingGas,\n                reasonBytes\n            );\n        }\n    }\n\n    // @dev simulate execution of a deposit to check for any errors\n    // @param key the deposit key\n    // @param params OracleUtils.SimulatePricesParams\n    function simulateExecuteDeposit(\n        bytes32 key,\n        OracleUtils.SimulatePricesParams memory params\n    ) external\n        onlyController\n        withSimulatedOraclePrices(oracle, params)\n        globalNonReentrant\n    {\n\n        uint256 startingGas = gasleft();\n        OracleUtils.SetPricesParams memory oracleParams;\n\n        this._executeDeposit(\n            key,\n            oracleParams,\n            msg.sender,\n            startingGas\n        );\n    }\n\n    // @dev executes a deposit\n    // @param oracleParams OracleUtils.SetPricesParams\n    // @param keeper the keeper executing the deposit\n    // @param startingGas the starting gas\n    function _executeDeposit(\n        bytes32 key,\n        OracleUtils.SetPricesParams memory oracleParams,\n        address keeper,\n        uint256 startingGas\n    ) external onlySelf {\n        FeatureUtils.validateFeature(dataStore, Keys.executeDepositFeatureDisabledKey(address(this)));\n\n        uint256[] memory minOracleBlockNumbers = OracleUtils.getUncompactedOracleBlockNumbers(\n            oracleParams.compactedMinOracleBlockNumbers,\n            oracleParams.tokens.length\n        );\n\n        uint256[] memory maxOracleBlockNumbers = OracleUtils.getUncompactedOracleBlockNumbers(\n            oracleParams.compactedMaxOracleBlockNumbers,\n            oracleParams.tokens.length\n        );\n\n        ExecuteDepositUtils.ExecuteDepositParams memory params = ExecuteDepositUtils.ExecuteDepositParams(\n            dataStore,\n            eventEmitter,\n            depositVault,\n            oracle,\n            key,\n            minOracleBlockNumbers,\n            maxOracleBlockNumbers,\n            keeper,\n            startingGas\n        );\n\n        ExecuteDepositUtils.executeDeposit(params);\n    }\n\n    // @dev handle errors from deposits\n    // @param key the deposit key\n    // @param startingGas the starting gas of the txn\n    // @param reasonBytes the reason bytes of the error\n    function _handleDepositError(\n        bytes32 key,\n        uint256 startingGas,\n        bytes memory reasonBytes\n    ) internal {\n        (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n\n        bytes4 errorSelector = ErrorUtils.getErrorSelectorFromData(reasonBytes);\n\n        if (\n            OracleUtils.isEmptyPriceError(errorSelector) ||\n            errorSelector == FeatureUtils.DisabledFeature.selector\n        ) {\n            ErrorUtils.revertWithCustomError(reasonBytes);\n        }\n\n        DepositUtils.cancelDeposit(\n            dataStore,\n            eventEmitter,\n            depositVault,\n            key,\n            msg.sender,\n            startingGas,\n            reason,\n            reasonBytes\n        );\n    }\n}"
    },
    {
      "filename": "contracts/exchange/DepositHandler.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../utils/GlobalReentrancyGuard.sol\";\n\nimport \"./ExchangeUtils.sol\";\nimport \"../role/RoleModule.sol\";\nimport \"../event/EventEmitter.sol\";\nimport \"../feature/FeatureUtils.sol\";\n\nimport \"../market/Market.sol\";\nimport \"../market/MarketToken.sol\";\n\nimport \"../deposit/Deposit.sol\";\nimport \"../deposit/DepositVault.sol\";\nimport \"../deposit/DepositUtils.sol\";\nimport \"../deposit/ExecuteDepositUtils.sol\";\nimport \"../oracle/Oracle.sol\";\nimport \"../oracle/OracleModule.sol\";\n\n// @title DepositHandler\n// @dev Contract to handle creation, execution and cancellation of deposits\ncontract DepositHandler is GlobalReentrancyGuard, RoleModule, OracleModule {\n    using Deposit for Deposit.Props;\n\n    EventEmitter public immutable eventEmitter;\n    DepositVault public immutable depositVault;\n    Oracle public immutable oracle;\n\n    constructor(\n        RoleStore _roleStore,\n        DataStore _dataStore,\n        EventEmitter _eventEmitter,\n        DepositVault _depositVault,\n        Oracle _oracle\n    ) RoleModule(_roleStore) GlobalReentrancyGuard(_dataStore) {\n        eventEmitter = _eventEmitter;\n        depositVault = _depositVault;\n        oracle = _oracle;\n    }\n\n    // @dev creates a deposit in the deposit store\n    // @param account the depositing account\n    // @param params DepositUtils.CreateDepositParams\n    function createDeposit(\n        address account,\n        DepositUtils.CreateDepositParams calldata params\n    ) external globalNonReentrant onlyController returns (bytes32) {\n        FeatureUtils.validateFeature(dataStore, Keys.createDepositFeatureDisabledKey(address(this)));\n\n        return DepositUtils.createDeposit(\n            dataStore,\n            eventEmitter,\n            depositVault,\n            account,\n            params\n        );\n    }\n\n    // @dev cancels a deposit\n    // @param key the deposit key\n    function cancelDeposit(bytes32 key) external globalNonReentrant onlyController {\n        uint256 startingGas = gasleft();\n\n        DataStore _dataStore = dataStore;\n        Deposit.Props memory deposit = DepositStoreUtils.get(_dataStore, key);\n\n        FeatureUtils.validateFeature(_dataStore, Keys.cancelDepositFeatureDisabledKey(address(this)));\n\n        ExchangeUtils.validateRequestCancellation(\n            _dataStore,\n            deposit.updatedAtBlock(),\n            \"Deposit\"\n        );\n\n        DepositUtils.cancelDeposit(\n            _dataStore,\n            eventEmitter,\n            depositVault,\n            key,\n            deposit.account(),\n            startingGas,\n            Keys.USER_INITIATED_CANCEL,\n            \"\"\n        );\n    }\n\n    // @dev executes a deposit\n    // @param key the key of the deposit to execute\n    // @param oracleParams OracleUtils.SetPricesParams\n    function executeDeposit(\n        bytes32 key,\n        OracleUtils.SetPricesParams calldata oracleParams\n    ) external\n        globalNonReentrant\n        onlyOrderKeeper\n        withOraclePrices(oracle, dataStore, eventEmitter, oracleParams)\n    {\n        uint256 startingGas = gasleft();\n\n        try this._executeDeposit(\n            key,\n            oracleParams,\n            msg.sender,\n            startingGas\n        ) {\n        } catch (bytes memory reasonBytes) {\n            _handleDepositError(\n                key,\n                startingGas,\n                reasonBytes\n            );\n        }\n    }\n\n    // @dev simulate execution of a deposit to check for any errors\n    // @param key the deposit key\n    // @param params OracleUtils.SimulatePricesParams\n    function simulateExecuteDeposit(\n        bytes32 key,\n        OracleUtils.SimulatePricesParams memory params\n    ) external\n        onlyController\n        withSimulatedOraclePrices(oracle, params)\n        globalNonReentrant\n    {\n\n        uint256 startingGas = gasleft();\n        OracleUtils.SetPricesParams memory oracleParams;\n\n        this._executeDeposit(\n            key,\n            oracleParams,\n            msg.sender,\n            startingGas\n        );\n    }\n\n    // @dev executes a deposit\n    // @param oracleParams OracleUtils.SetPricesParams\n    // @param keeper the keeper executing the deposit\n    // @param startingGas the starting gas\n    function _executeDeposit(\n        bytes32 key,\n        OracleUtils.SetPricesParams memory oracleParams,\n        address keeper,\n        uint256 startingGas\n    ) external onlySelf {\n        FeatureUtils.validateFeature(dataStore, Keys.executeDepositFeatureDisabledKey(address(this)));\n\n        uint256[] memory minOracleBlockNumbers = OracleUtils.getUncompactedOracleBlockNumbers(\n            oracleParams.compactedMinOracleBlockNumbers,\n            oracleParams.tokens.length\n        );\n\n        uint256[] memory maxOracleBlockNumbers = OracleUtils.getUncompactedOracleBlockNumbers(\n            oracleParams.compactedMaxOracleBlockNumbers,\n            oracleParams.tokens.length\n        );\n\n        ExecuteDepositUtils.ExecuteDepositParams memory params = ExecuteDepositUtils.ExecuteDepositParams(\n            dataStore,\n            eventEmitter,\n            depositVault,\n            oracle,\n            key,\n            minOracleBlockNumbers,\n            maxOracleBlockNumbers,\n            keeper,\n            startingGas\n        );\n\n        ExecuteDepositUtils.executeDeposit(params);\n    }\n\n    // @dev handle errors from deposits\n    // @param key the deposit key\n    // @param startingGas the starting gas of the txn\n    // @param reasonBytes the reason bytes of the error\n    function _handleDepositError(\n        bytes32 key,\n        uint256 startingGas,\n        bytes memory reasonBytes\n    ) internal {\n        (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n\n        bytes4 errorSelector = ErrorUtils.getErrorSelectorFromData(reasonBytes);\n\n        if (\n            OracleUtils.isEmptyPriceError(errorSelector) ||\n            errorSelector == FeatureUtils.DisabledFeature.selector\n        ) {\n            ErrorUtils.revertWithCustomError(reasonBytes);\n        }\n\n        DepositUtils.cancelDeposit(\n            dataStore,\n            eventEmitter,\n            depositVault,\n            key,\n            msg.sender,\n            startingGas,\n            reason,\n            reasonBytes\n        );\n    }\n}"
    },
    {
      "filename": "contracts/exchange/WithdrawalHandler.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../utils/GlobalReentrancyGuard.sol\";\nimport \"../utils/ErrorUtils.sol\";\n\nimport \"./ExchangeUtils.sol\";\nimport \"../role/RoleModule.sol\";\nimport \"../feature/FeatureUtils.sol\";\n\nimport \"../market/Market.sol\";\nimport \"../market/MarketToken.sol\";\n\nimport \"../withdrawal/Withdrawal.sol\";\nimport \"../withdrawal/WithdrawalVault.sol\";\nimport \"../withdrawal/WithdrawalStoreUtils.sol\";\nimport \"../withdrawal/WithdrawalUtils.sol\";\nimport \"../oracle/Oracle.sol\";\nimport \"../oracle/OracleModule.sol\";\n\n// @title WithdrawalHandler\n// @dev Contract to handle creation, execution and cancellation of withdrawals\ncontract WithdrawalHandler is GlobalReentrancyGuard, RoleModule, OracleModule {\n    using Withdrawal for Withdrawal.Props;\n\n    EventEmitter public immutable eventEmitter;\n    WithdrawalVault public immutable withdrawalVault;\n    Oracle public immutable oracle;\n\n    constructor(\n        RoleStore _roleStore,\n        DataStore _dataStore,\n        EventEmitter _eventEmitter,\n        WithdrawalVault _withdrawalVault,\n        Oracle _oracle\n    ) RoleModule(_roleStore) GlobalReentrancyGuard(_dataStore) {\n        eventEmitter = _eventEmitter;\n        withdrawalVault = _withdrawalVault;\n        oracle = _oracle;\n    }\n\n    // @dev creates a withdrawal in the withdrawal store\n    // @param account the withdrawing account\n    // @param params WithdrawalUtils.CreateWithdrawalParams\n    function createWithdrawal(\n        address account,\n        WithdrawalUtils.CreateWithdrawalParams calldata params\n    ) external globalNonReentrant onlyController returns (bytes32) {\n        FeatureUtils.validateFeature(dataStore, Keys.createWithdrawalFeatureDisabledKey(address(this)));\n\n        return WithdrawalUtils.createWithdrawal(\n            dataStore,\n            eventEmitter,\n            withdrawalVault,\n            account,\n            params\n        );\n    }\n\n    // @dev cancels a withdrawal\n    // @param key the withdrawal key\n    function cancelWithdrawal(bytes32 key) external globalNonReentrant onlyController {\n        uint256 startingGas = gasleft();\n\n        DataStore _dataStore = dataStore;\n        Withdrawal.Props memory withdrawal = WithdrawalStoreUtils.get(_dataStore, key);\n\n        FeatureUtils.validateFeature(_dataStore, Keys.cancelWithdrawalFeatureDisabledKey(address(this)));\n\n        ExchangeUtils.validateRequestCancellation(\n            _dataStore,\n            withdrawal.updatedAtBlock(),\n            \"Withdrawal\"\n        );\n\n        WithdrawalUtils.cancelWithdrawal(\n            _dataStore,\n            eventEmitter,\n            withdrawalVault,\n            key,\n            withdrawal.account(),\n            startingGas,\n            Keys.USER_INITIATED_CANCEL,\n            \"\"\n        );\n    }\n\n    // @dev executes a withdrawal\n    // @param key the key of the withdrawal to execute\n    // @param oracleParams OracleUtils.SetPricesParams\n    function executeWithdrawal(\n        bytes32 key,\n        OracleUtils.SetPricesParams calldata oracleParams\n    )\n        external\n        globalNonReentrant\n        onlyOrderKeeper\n        withOraclePrices(oracle, dataStore, eventEmitter, oracleParams)\n    {\n        uint256 startingGas = gasleft();\n\n        try this._executeWithdrawal(\n            key,\n            oracleParams,\n            msg.sender,\n            startingGas\n        ) {\n        } catch (bytes memory reasonBytes) {\n            _handleWithdrawalError(\n                key,\n                startingGas,\n                reasonBytes\n            );\n        }\n    }\n\n    // @dev simulate execution of a withdrawal to check for any errors\n    // @param key the withdrawal key\n    // @param params OracleUtils.SimulatePricesParams\n    function simulateExecuteWithdrawal(\n        bytes32 key,\n        OracleUtils.SimulatePricesParams memory params\n    ) external\n        onlyController\n        withSimulatedOraclePrices(oracle, params)\n        globalNonReentrant\n    {\n\n        uint256 startingGas = gasleft();\n        OracleUtils.SetPricesParams memory oracleParams;\n\n        this._executeWithdrawal(\n            key,\n            oracleParams,\n            msg.sender,\n            startingGas\n        );\n    }\n\n    // @dev executes a withdrawal\n    // @param oracleParams OracleUtils.SetPricesParams\n    // @param keeper the keeper executing the withdrawal\n    // @param startingGas the starting gas\n    function _executeWithdrawal(\n        bytes32 key,\n        OracleUtils.SetPricesParams memory oracleParams,\n        address keeper,\n        uint256 startingGas\n    ) external onlySelf {\n        FeatureUtils.validateFeature(dataStore, Keys.executeWithdrawalFeatureDisabledKey(address(this)));\n\n        uint256[] memory minOracleBlockNumbers = OracleUtils.getUncompactedOracleBlockNumbers(\n            oracleParams.compactedMinOracleBlockNumbers,\n            oracleParams.tokens.length\n        );\n\n        uint256[] memory maxOracleBlockNumbers = OracleUtils.getUncompactedOracleBlockNumbers(\n            oracleParams.compactedMaxOracleBlockNumbers,\n            oracleParams.tokens.length\n        );\n\n        WithdrawalUtils.ExecuteWithdrawalParams memory params = WithdrawalUtils.ExecuteWithdrawalParams(\n            dataStore,\n            eventEmitter,\n            withdrawalVault,\n            oracle,\n            key,\n            minOracleBlockNumbers,\n            maxOracleBlockNumbers,\n            keeper,\n            startingGas\n        );\n\n        WithdrawalUtils.executeWithdrawal(params);\n    }\n\n    function _handleWithdrawalError(\n        bytes32 key,\n        uint256 startingGas,\n        bytes memory reasonBytes\n    ) internal {\n        (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n\n        bytes4 errorSelector = ErrorUtils.getErrorSelectorFromData(reasonBytes);\n\n        if (\n            OracleUtils.isEmptyPriceError(errorSelector) ||\n            errorSelector == FeatureUtils.DisabledFeature.selector\n        ) {\n\n            ErrorUtils.revertWithCustomError(reasonBytes);\n        }\n\n        WithdrawalUtils.cancelWithdrawal(\n            dataStore,\n            eventEmitter,\n            withdrawalVault,\n            key,\n            msg.sender,\n            startingGas,\n            reason,\n            reasonBytes\n        );\n    }\n}"
    },
    {
      "filename": "contracts/exchange/OrderHandler.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./BaseOrderHandler.sol\";\nimport \"../utils/ErrorUtils.sol\";\n\n// @title OrderHandler\n// @dev Contract to handle creation, execution and cancellation of orders\ncontract OrderHandler is BaseOrderHandler {\n    using SafeCast for uint256;\n    using Order for Order.Props;\n    using Array for uint256[];\n\n    error OrderNotUpdatable(Order.OrderType orderType);\n    error InvalidKeeperForFrozenOrder(address keeper);\n\n    constructor(\n        RoleStore _roleStore,\n        DataStore _dataStore,\n        EventEmitter _eventEmitter,\n        OrderVault _orderVault,\n        Oracle _oracle,\n        SwapHandler _swapHandler,\n        IReferralStorage _referralStorage\n    ) BaseOrderHandler(\n        _roleStore,\n        _dataStore,\n        _eventEmitter,\n        _orderVault,\n        _oracle,\n        _swapHandler,\n        _referralStorage\n    ) {}\n\n    // @dev creates an order in the order store\n    // @param account the order's account\n    // @param params BaseOrderUtils.CreateOrderParams\n    function createOrder(\n        address account,\n        BaseOrderUtils.CreateOrderParams calldata params\n    ) external globalNonReentrant onlyController returns (bytes32) {\n        FeatureUtils.validateFeature(dataStore, Keys.createOrderFeatureDisabledKey(address(this), uint256(params.orderType)));\n\n        return OrderUtils.createOrder(\n            dataStore,\n            eventEmitter,\n            orderVault,\n            referralStorage,\n            account,\n            params\n        );\n    }\n\n    /**\n     * @dev Updates the given order with the specified size delta, acceptable price, and trigger price.\n     * The `updateOrder()` feature must be enabled for the given order type. The caller must be the owner\n     * of the order, and the order must not be a market order. The size delta, trigger price, and\n     * acceptable price are updated on the order, and the order is unfrozen. Any additional WNT that is\n     * transferred to the contract is added to the order's execution fee. The updated order is then saved\n     * in the order store, and an `OrderUpdated` event is emitted.\n     *\n     * @param key The unique ID of the order to be updated\n     * @param sizeDeltaUsd The new size delta for the order\n     * @param acceptablePrice The new acceptable price for the order\n     * @param triggerPrice The new trigger price for the order\n     */\n    function updateOrder(\n        bytes32 key,\n        uint256 sizeDeltaUsd,\n        uint256 acceptablePrice,\n        uint256 triggerPrice,\n        uint256 minOutputAmount,\n        Order.Props memory order\n    ) external payable globalNonReentrant onlyController {\n        FeatureUtils.validateFeature(dataStore, Keys.updateOrderFeatureDisabledKey(address(this), uint256(order.orderType())));\n\n        if (BaseOrderUtils.isMarketOrder(order.orderType())) {\n            revert OrderNotUpdatable(order.orderType());\n        }\n\n        order.setSizeDeltaUsd(sizeDeltaUsd);\n        order.setTriggerPrice(triggerPrice);\n        order.setAcceptablePrice(acceptablePrice);\n        order.setMinOutputAmount(minOutputAmount);\n        order.setIsFrozen(false);\n\n        // allow topping up of executionFee as partially filled or frozen orders\n        // will have their executionFee reduced\n        address wnt = TokenUtils.wnt(dataStore);\n        uint256 receivedWnt = orderVault.recordTransferIn(wnt);\n        order.setExecutionFee(order.executionFee() + receivedWnt);\n\n        uint256 estimatedGasLimit = GasUtils.estimateExecuteOrderGasLimit(dataStore, order);\n        GasUtils.validateExecutionFee(dataStore, estimatedGasLimit, order.executionFee());\n\n        order.touch();\n        OrderStoreUtils.set(dataStore, key, order);\n\n        OrderEventUtils.emitOrderUpdated(eventEmitter, key, sizeDeltaUsd, triggerPrice, acceptablePrice);\n    }\n\n    /**\n     * @dev Cancels the given order. The `cancelOrder()` feature must be enabled for the given order\n     * type. The caller must be the owner of the order, and the order must not be a market order. The\n     * order is cancelled by calling the `cancelOrder()` function in the `OrderUtils` contract. This\n     * function also records the starting gas amount and the reason for cancellation, which is passed to\n     * the `cancelOrder()` function.\n     *\n     * @param key The unique ID of the order to be cancelled\n     */\n    function cancelOrder(bytes32 key) external globalNonReentrant onlyController {\n        uint256 startingGas = gasleft();\n\n        DataStore _dataStore = dataStore;\n        Order.Props memory order = OrderStoreUtils.get(_dataStore, key);\n\n        FeatureUtils.validateFeature(_dataStore, Keys.cancelOrderFeatureDisabledKey(address(this), uint256(order.orderType())));\n\n        if (BaseOrderUtils.isMarketOrder(order.orderType())) {\n            ExchangeUtils.validateRequestCancellation(\n                _dataStore,\n                order.updatedAtBlock(),\n                \"Order\"\n            );\n        }\n\n        OrderUtils.cancelOrder(\n            dataStore,\n            eventEmitter,\n            orderVault,\n            key,\n            order.account(),\n            startingGas,\n            Keys.USER_INITIATED_CANCEL,\n            \"\"\n        );\n    }\n\n    // @dev simulate execution of an order to check for any errors\n    // @param key the order key\n    // @param params OracleUtils.SimulatePricesParams\n    function simulateExecuteOrder(\n        bytes32 key,\n        OracleUtils.SimulatePricesParams memory params\n    ) external\n        onlyController\n        withSimulatedOraclePrices(oracle, params)\n        globalNonReentrant\n    {\n        uint256 startingGas = gasleft();\n\n        OracleUtils.SetPricesParams memory oracleParams;\n\n        this._executeOrder(\n            key,\n            oracleParams,\n            msg.sender,\n            startingGas\n        );\n    }\n\n    // @dev executes an order\n    // @param key the key of the order to execute\n    // @param oracleParams OracleUtils.SetPricesParams\n    function executeOrder(\n        bytes32 key,\n        OracleUtils.SetPricesParams calldata oracleParams\n    ) external\n        globalNonReentrant\n        onlyOrderKeeper\n        withOraclePrices(oracle, dataStore, eventEmitter, oracleParams)\n    {\n        uint256 startingGas = gasleft();\n\n        try this._executeOrder(\n            key,\n            oracleParams,\n            msg.sender,\n            startingGas\n        ) {\n        } catch (bytes memory reasonBytes) {\n            _handleOrderError(key, startingGas, reasonBytes);\n        }\n    }\n\n    // @dev executes an order\n    // @param key the key of the order to execute\n    // @param oracleParams OracleUtils.SetPricesParams\n    // @param keeper the keeper executing the order\n    // @param startingGas the starting gas\n    function _executeOrder(\n        bytes32 key,\n        OracleUtils.SetPricesParams memory oracleParams,\n        address keeper,\n        uint256 startingGas\n    ) external onlySelf {\n        BaseOrderUtils.ExecuteOrderParams memory params = _getExecuteOrderParams(key, oracleParams, keeper, startingGas);\n        // limit swaps require frozen order keeper for execution since on creation it can fail due to output amount\n        // which would automatically cause the order to be frozen\n        // limit increase and limit / trigger decrease orders may fail due to output amount as well and become frozen\n        // but only if their acceptablePrice is reached\n        if (params.order.isFrozen() || params.order.orderType() == Order.OrderType.LimitSwap) {\n            _validateFrozenOrderKeeper(keeper);\n        }\n\n        FeatureUtils.validateFeature(params.contracts.dataStore, Keys.executeOrderFeatureDisabledKey(address(this), uint256(params.order.orderType())));\n\n        OrderUtils.executeOrder(params);\n    }\n\n    // @dev handle a caught order error\n    // @param key the order's key\n    // @param startingGas the starting gas\n    // @param reason the error reason\n    // @param reasonKey the hash or the error reason\n    function _handleOrderError(\n        bytes32 key,\n        uint256 startingGas,\n        bytes memory reasonBytes\n    ) internal {\n        (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n\n        bytes4 errorSelector = ErrorUtils.getErrorSelectorFromData(reasonBytes);\n\n        if (\n            OracleUtils.isEmptyPriceError(errorSelector) ||\n            errorSelector == FeatureUtils.DisabledFeature.selector ||\n            errorSelector == InvalidKeeperForFrozenOrder.selector ||\n            // InvalidOrderPrices error should only be raised for limit, trigger orders\n            // it should not be raised for market orders\n            // The transaction is reverted in this case since the oracle prices do not fulfill\n            // the specified trigger price\n            errorSelector == BaseOrderUtils.InvalidOrderPrices.selector\n        ) {\n            ErrorUtils.revertWithCustomError(reasonBytes);\n        }\n\n        Order.Props memory order = OrderStoreUtils.get(dataStore, key);\n        bool isMarketOrder = BaseOrderUtils.isMarketOrder(order.orderType());\n\n        if (isMarketOrder) {\n            OrderUtils.cancelOrder(\n                dataStore,\n                eventEmitter,\n                orderVault,\n                key,\n                msg.sender,\n                startingGas,\n                reason,\n                reasonBytes\n            );\n        } else {\n            // for market orders, the EmptyPosition error should still lead to the\n            // order being cancelled\n            // for limit, trigger orders, the EmptyPosition error should lead to the transaction\n            // being reverted instead\n            // if the position is created or increased later, the oracle prices used to fulfill the order\n            // must be after the position was last increased, this is validated in DecreaseOrderUtils\n            if (errorSelector == PositionUtils.EmptyPosition.selector) {\n                ErrorUtils.revertWithCustomError(reasonBytes);\n            }\n\n            // freeze unfulfillable orders to prevent the order system from being gamed\n            // an example of gaming would be if a user creates a limit order\n            // with size greater than the available amount in the pool\n            // the user waits for their limit price to be hit, and if price\n            // moves in their favour after, they can deposit into the pool\n            // to allow the order to be executed then close the order for a profit\n            //\n            // frozen order keepers will have additional validations before executing\n            // frozen orders to prevent gaming\n            //\n            // alternatively, the user can call updateOrder to unfreeze the order\n            OrderUtils.freezeOrder(\n                dataStore,\n                eventEmitter,\n                orderVault,\n                key,\n                msg.sender,\n                startingGas,\n                reason,\n                reasonBytes\n            );\n        }\n    }\n\n    // @dev validate that the keeper is a frozen order keeper\n    // @param keeper address of the keeper\n    function _validateFrozenOrderKeeper(address keeper) internal view {\n        if (!roleStore.hasRole(keeper, Role.FROZEN_ORDER_KEEPER)) {\n            revert InvalidKeeperForFrozenOrder(keeper);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/gas/GasUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../data/DataStore.sol\";\nimport \"../data/Keys.sol\";\nimport \"../utils/Precision.sol\";\n\nimport \"../deposit/Deposit.sol\";\nimport \"../withdrawal/Withdrawal.sol\";\nimport \"../order/Order.sol\";\nimport \"../order/BaseOrderUtils.sol\";\n\nimport \"../bank/StrictBank.sol\";\n\n// @title GasUtils\n// @dev Library for execution fee estimation and payments\nlibrary GasUtils {\n    using Deposit for Deposit.Props;\n    using Withdrawal for Withdrawal.Props;\n    using Order for Order.Props;\n\n    using EventUtils for EventUtils.AddressItems;\n    using EventUtils for EventUtils.UintItems;\n    using EventUtils for EventUtils.IntItems;\n    using EventUtils for EventUtils.BoolItems;\n    using EventUtils for EventUtils.Bytes32Items;\n    using EventUtils for EventUtils.BytesItems;\n    using EventUtils for EventUtils.StringItems;\n\n    // @param keeper address of the keeper\n    // @param amount the amount of execution fee received\n    event KeeperExecutionFee(address keeper, uint256 amount);\n    // @param user address of the user\n    // @param amount the amount of execution fee refunded\n    event UserRefundFee(address user, uint256 amount);\n\n    function getMinHandleExecutionErrorGas(DataStore dataStore) internal view returns (uint256) {\n        return dataStore.getUint(Keys.MIN_HANDLE_EXECUTION_ERROR_GAS);\n    }\n\n    function getMinHandleExecutionErrorGasToForward(DataStore dataStore) internal view returns (uint256) {\n        return dataStore.getUint(Keys.MIN_HANDLE_EXECUTION_ERROR_GAS_TO_FORWARD);\n    }\n\n    function getMinAdditionalGasForExecution(DataStore dataStore) internal view returns (uint256) {\n        return dataStore.getUint(Keys.MIN_ADDITIONAL_GAS_FOR_EXECUTION);\n    }\n\n    function getExecutionGas(DataStore dataStore, uint256 startingGas) internal view returns (uint256) {\n        uint256 minHandleExecutionErrorGasToForward = GasUtils.getMinHandleExecutionErrorGasToForward(dataStore);\n        if (startingGas < minHandleExecutionErrorGasToForward) {\n            revert Errors.InsufficientExecutionGasForErrorHandling(startingGas, minHandleExecutionErrorGasToForward);\n        }\n\n        return startingGas - minHandleExecutionErrorGasToForward;\n    }\n\n    function validateExecutionGas(DataStore dataS"
    }
  ]
}