{
  "Title": "M-11: Multiple contracts cannot be paused",
  "Content": "# Issue M-11: Multiple contracts cannot be paused \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/64 \n\n## Found by \n0xadrii, GiuseppeDeLaZara, Tendency, bin2chen\n## Summary\nFor safety, tapioca has added `whenNotPaused` restrictions to multiple contracts\nBut there is no method provided to modify the `_paused` state\nIf a security event occurs, it cannot be paused at all\n\n## Vulnerability Detail\nTake `mTOFT.sol` as an example, multiple methods are `whenNotPaused`\n```solidity\n    function executeModule(ITOFT.Module _module, bytes memory _data, bool _forwardRevert)\n        external\n        payable\n@>      whenNotPaused\n        returns (bytes memory returnData)\n    {\n...\n    function sendPacket(LZSendParam calldata _lzSendParam, bytes calldata _composeMsg)\n        public\n        payable\n@>      whenNotPaused\n        returns (MessagingReceipt memory msgReceipt, OFTReceipt memory oftReceipt)\n    {\n\n```\n\nBut the contract does not provide a `public` method to modify `_paused`\nNote: `Pausable.sol` does not have a `public` method to modify `_paused`\n\nIn reality, there have been multiple reports of security incidents where the protocol side wants to pause to prevent losses, but cannot pause, strongly recommend adding\n\nNote: The following contracts cannot be paused\n- mTOFT\n- TOFT\n- Usdo\n- AssetToSGLPLeverageExecutor\n\n## Impact\n\nDue to the inability to modify `_paused`, it poses a security risk\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/TapiocaZ/contracts/tOFT/mTOFT.sol#L50\n## Tool used\n\nManual Review\n\n## Recommendation\n```diff\n+    function pause() external onlyOwner{\n+        _pause();\n+    }\n\n+    function unpause() external onlyOwner{\n+        _unpause();\n+    }\n```\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**WangAudit** commented:\n> refer to 24\n\n\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Tapioca-DAO/TapiocaZ/commit/5cf2563fdd12787f5414690ede10681af6630eb8.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "TapiocaZ/contracts/tOFT/mTOFT.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n//LZ\nimport {IMessagingChannel} from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingChannel.sol\";\nimport {MessagingReceipt, OFTReceipt} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol\";\nimport {OAppReceiver} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppReceiver.sol\";\nimport {Origin} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OApp.sol\";\n\n// External\nimport {ERC20Permit, ERC20} from \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\n\n// Tapioca\nimport {\n    ITOFT,\n    TOFTInitStruct,\n    TOFTModulesInitStruct,\n    LZSendParam,\n    ERC20PermitStruct,\n    IToftVault\n} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\nimport {BaseTapiocaOmnichainEngine} from \"tapioca-periph/tapiocaOmnichainEngine/BaseTapiocaOmnichainEngine.sol\";\nimport {TapiocaOmnichainSender} from \"tapioca-periph/tapiocaOmnichainEngine/TapiocaOmnichainSender.sol\";\nimport {IStargateReceiver} from \"tapioca-periph/interfaces/external/stargate/IStargateReceiver.sol\";\nimport {TOFTReceiver} from \"./modules/TOFTReceiver.sol\";\nimport {TOFTSender} from \"./modules/TOFTSender.sol\";\nimport {BaseTOFT} from \"./BaseTOFT.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title mTOFT\n * @author TapiocaDAO\n * @notice Tapioca OFT wrapper contract that is connected with multiple chains\n * @dev It can be wrapped and unwrapped on multiple connected chains\n */\ncontract mTOFT is BaseTOFT, Pausable, ReentrancyGuard, ERC20Permit, IStargateReceiver {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice allowed chains where you can unwrap your TOFT\n     */\n    mapping(uint256 => bool) public connectedChains;\n\n    /**\n     * @notice map of approved balancers\n     * @dev a balancer can extract the underlying\n     */\n    mapping(address => bool) public balancers;\n\n    /**\n     * @notice max mTOFT mintable\n     */\n    uint256 public mintCap;\n\n    /**\n     * @notice current non-host chain mint fee\n     */\n    uint256 public mintFee;\n\n    address private _stargateRouter;\n\n    event StargateRouterUpdated(address indexed _old, address indexed _new);\n\n    /**\n     * @notice event emitted when a connected chain is reigstered or unregistered\n     */\n    event ConnectedChainStatusUpdated(uint256 indexed _chain, bool indexed _old, bool indexed _new);\n\n    /**\n     * @notice event emitted when balancer status is updated\n     */\n    event BalancerStatusUpdated(address indexed _balancer, bool indexed _bool, bool indexed _new);\n\n    /**\n     * @notice event emitted when rebalancing is performed\n     */\n    event Rebalancing(address indexed _balancer, uint256 indexed _amount, bool indexed _isNative);\n\n    error mTOFT_NotNative();\n    error mTOFT_NotHost();\n    error mTOFT_BalancerNotAuthorized();\n    error mTOFT_NotAuthorized();\n    error mTOFT_CapNotValid();\n    error mTOFT_Failed();\n\n    constructor(TOFTInitStruct memory _tOFTData, TOFTModulesInitStruct memory _modulesData, address _stgRouter)\n        BaseTOFT(_tOFTData)\n        ERC20Permit(_tOFTData.name)\n    {\n        if (_getChainId() == hostEid) {\n            connectedChains[hostEid] = true;\n        }\n\n        mintCap = 1_000_000 * 1e18; // TOFT is always in 18 decimals\n        mintFee = 5e2; // 0.5%\n\n        // Set TOFT execution modules\n        if (_modulesData.tOFTSenderModule == address(0)) revert TOFT_NotValid();\n        if (_modulesData.tOFTReceiverModule == address(0)) {\n            revert TOFT_NotValid();\n        }\n        if (_modulesData.marketReceiverModule == address(0)) {\n            revert TOFT_NotValid();\n        }\n        if (_modulesData.optionsReceiverModule == address(0)) {\n            revert TOFT_NotValid();\n        }\n        if (_modulesData.genericReceiverModule == address(0)) {\n            revert TOFT_NotValid();\n        }\n\n        _setModule(uint8(ITOFT.Module.TOFTSender), _modulesData.tOFTSenderModule);\n        _setModule(uint8(ITOFT.Module.TOFTReceiver), _modulesData.tOFTReceiverModule);\n        _setModule(uint8(ITOFT.Module.TOFTMarketReceiver), _modulesData.marketReceiverModule);\n        _setModule(uint8(ITOFT.Module.TOFTOptionsReceiver), _modulesData.optionsReceiverModule);\n        _setModule(uint8(ITOFT.Module.TOFTGenericReceiver), _modulesData.genericReceiverModule);\n\n        _stargateRouter = _stgRouter;\n\n        vault = IToftVault(_tOFTData.vault);\n        vault.claimOwnership();\n\n        if (address(vault._token()) != erc20) revert TOFT_VaultWrongERC20();\n    }\n\n    /**\n     * @dev Fallback function should handle calls made by endpoint, which should go to the receiver module.\n     */\n    fallback() external payable {\n        /// @dev Call the receiver module on fallback, assume it's gonna be called by endpoint.\n        _executeModule(uint8(ITOFT.Module.TOFTReceiver), msg.data, false);\n    }\n\n    receive() external payable {}\n\n    function transferFrom(address from, address to, uint256 value)\n        public\n        override(BaseTapiocaOmnichainEngine, ERC20)\n        returns (bool)\n    {\n        return BaseTapiocaOmnichainEngine.transferFrom(from, to, value);\n    }\n\n    /**\n     * @dev Slightly modified version of the OFT _lzReceive() operation.\n     * The composed message is sent to `address(this)` instead of `toAddress`.\n     * @dev Internal function to handle the receive on the LayerZero endpoint.\n     * @param _origin The origin information.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address from the src chain.\n     *  - nonce: The nonce of the LayerZero message.\n     * @param _guid The unique identifier for the received LayerZero message.\n     * @param _message The encoded message.\n     * @dev _executor The address of the executor.\n     * @dev _extraData Additional data.\n     */\n    function lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor, // @dev unused in the default implementation.\n        bytes calldata _extraData // @dev unused in the default implementation.\n    ) public payable override {\n        // Call the internal OApp implementation of lzReceive.\n        _executeModule(\n            uint8(ITOFT.Module.TOFTReceiver),\n            abi.encodeWithSelector(OAppReceiver.lzReceive.selector, _origin, _guid, _message, _executor, _extraData),\n            false\n        );\n    }\n\n    /**\n     * @notice Execute a call to a module.\n     * @dev Example on how `_data` should be encoded:\n     *      - abi.encodeCall(IERC20.transfer, (to, amount));\n     * @dev Use abi.encodeCall to encode the function call and its parameters with type safety.\n     *\n     * @param _module The module to execute.\n     * @param _data The data to execute. Should be ABI encoded with the selector.\n     * @param _forwardRevert If true, forward the revert message from the module.\n     *\n     * @return returnData The return data from the module execution, if any.\n     */\n    function executeModule(ITOFT.Module _module, bytes memory _data, bool _forwardRevert)\n        external\n        payable\n        whenNotPaused\n        returns (bytes memory returnData)\n    {\n        return _executeModule(uint8(_module), _data, _forwardRevert);\n    }\n\n    /**\n     * @dev Slightly modified version of the OFT send() operation. Includes a `_msgType` parameter.\n     * The `_buildMsgAndOptionsByType()` appends the packet type to the message.\n     * @dev Executes the send operation.\n     * @param _lzSendParam The parameters for the send operation.\n     *      - _sendParam: The parameters for the send operation.\n     *          - dstEid::uint32: Destination endpoint ID.\n     *          - to::bytes32: Recipient address.\n     *          - amountToSendLD::uint256: Amount to send in local decimals.\n     *          - minAmountToCreditLD::uint256: Minimum amount to credit in local decimals.\n     *      - _fee: The calculated fee for the send() operation.\n     *          - nativeFee::uint256: The native fee.\n     *          - lzTokenFee::uint256: The lzToken fee.\n     *      - _extraOptions::bytes: Additional options for the send() operation.\n     *      - refundAddress::address: The address to refund the native fee to.\n     * @param _composeMsg The composed message for the send() operation. Is a combination of 1 or more TAP specific messages.\n     *\n     * @return msgReceipt The receipt for the send operation.\n     *      - guid::bytes32: The unique identifier for the sent message.\n     *      - nonce::uint64: The nonce of the sent message.\n     *      - fee: The LayerZero fee incurred for the message.\n     *          - nativeFee::uint256: The native fee.\n     *          - lzTokenFee::uint256: The lzToken fee.\n     * @return oftReceipt The OFT receipt information.\n     *      - amountDebitLD::uint256: Amount of tokens ACTUALLY debited in local decimals.\n     *      - amountCreditLD::uint256: Amount of tokens to be credited on the remote side.\n     */\n    function sendPacket(LZSendParam calldata _lzSendParam, bytes calldata _composeMsg)\n        public\n        payable\n        whenNotPaused\n        returns (MessagingReceipt memory msgReceipt, OFTReceipt memory oftReceipt)\n    {\n        (msgReceipt, oftReceipt) = abi.decode(\n            _executeModule(\n                uint8(ITOFT.Module.TOFTSender),\n                abi.encodeCall(TapiocaOmnichainSender.sendPacket, (_lzSendParam, _composeMsg)),\n                false\n            ),\n            (MessagingReceipt, OFTReceipt)\n        );\n    }\n\n    /// =====================\n    /// View\n    /// =====================\n\n    /**\n     * @dev Returns the hash of the struct used by the permit function.\n     * @param _permitData Struct containing permit data.\n     */\n    function getTypedDataHash(ERC20PermitStruct calldata _permitData) public view returns (bytes32) {\n        bytes32 permitTypeHash_ =\n            keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n        bytes32 structHash_ = keccak256(\n            abi.encode(\n                permitTypeHash_,\n                _permitData.owner,\n                _permitData.spender,\n                _permitData.value,\n                _permitData.nonce,\n                _permitData.deadline\n            )\n        );\n        return _hashTypedDataV4(structHash_);\n    }\n\n    /// =====================\n    /// External\n    /// =====================\n    /**\n     * @notice Wrap an ERC20 with a fee if existing.\n     * @dev Minted amount might be less than requested amount. see `mintFee`\n     * @param _fromAddress The address to wrap from.\n     * @param _toAddress The address to wrap the ERC20 to.\n     * @param _amount The amount of ERC20 to wrap.\n     *\n     * @return minted The mtOFT minted amount.\n     */\n    function wrap(address _fromAddress, address _toAddress, uint256 _amount)\n        external\n        payable\n        whenNotPaused\n        nonReentrant\n        returns (uint256 minted)\n    {\n        if (balancers[msg.sender]) revert mTOFT_BalancerNotAuthorized();\n        if (!connectedChains[_getChainId()]) revert mTOFT_NotHost();\n        if (mintCap > 0) {\n            if (totalSupply() + _amount > mintCap) revert mTOFT_CapNotValid();\n        }\n\n        uint256 feeAmount = _checkAndExtractFees(_amount);\n        if (erc20 == address(0)) {\n            _wrapNative(_toAddress, _amount, feeAmount);\n        } else {\n            if (msg.value > 0) revert mTOFT_NotNative();\n            _wrap(_fromAddress, _toAddress, _amount, feeAmount);\n        }\n\n        return _amount - feeAmount;\n    }\n\n    /**\n     * @notice Unwrap an ERC20/Native with a 1:1 ratio.\n     * @param _toAddress The address to wrap the ERC20 to.\n     * @param _amount The amount of tokens to unwrap.\n     */\n    function unwrap(address _toAddress, uint256 _amount) external nonReentrant whenNotPaused {\n        if (!connectedChains[_getChainId()]) revert mTOFT_NotHost();\n        if (balancers[msg.sender]) revert mTOFT_BalancerNotAuthorized();\n        _unwrap(_toAddress, _amount);\n    }\n\n    /**\n     * @notice needed for Stargate Router to receive funds from Balancer.sol contract\n     * @param amountLD Amount to deposit\n     */\n    function sgReceive(uint16, bytes memory, uint256, address, uint256 amountLD, bytes memory) external payable {\n        if (msg.sender != _stargateRouter) revert mTOFT_NotAuthorized();\n\n        if (erc20 == address(0)) {\n            vault.depositNative{value: amountLD}();\n        } else {\n            IERC20(erc20).safeTransfer(address(vault), amountLD);\n        }\n    }\n\n    /// =====================\n    /// Owner\n    /// =====================\n    /**\n     * @notice rescues unused ETH from the contract\n     * @param amount the amount to rescue\n     * @param to the recipient\n     */\n    function rescueEth(uint256 amount, address to) external onlyOwner {\n        (bool success,) = to.call{value: amount}(\"\");\n        if (!success) revert mTOFT_Failed();\n    }\n\n    /**\n     * @notice sets the owner state\n     */\n    struct SetOwnerStateData {\n        address stargateRouter;\n        uint256 mintFee;\n        uint256 mintCap;\n        // connected chains\n        uint256 connectedChain;\n        bool connectedChainState;\n        // balancer\n        address balancerStateAddress;\n        bool balancerState;\n    }\n\n    function setOwnerState(SetOwnerStateData memory _data) external onlyOwner {\n        if (_stargateRouter != _data.stargateRouter) {\n            _stargateRouter = _data.stargateRouter;\n        }\n        if (mintFee != _data.mintFee) {\n            mintFee = _data.mintFee;\n        }\n        if (mintCap != _data.mintCap) {\n            if (_data.mintCap < totalSupply()) revert mTOFT_CapNotValid();\n            mintCap = _data.mintCap;\n        }\n        if (connectedChains[_data.connectedChain] != _data.connectedChainState) {\n            connectedChains[_data.connectedChain] = _data.connectedChainState;\n        }\n        if (balancers[_data.balancerStateAddress] != _data.balancerState) {\n            balancers[_data.balancerStateAddress] = _data.balancerState;\n        }\n    }\n\n    /**\n     * @notice withdraw fees from Vault.\n     * @param _to receiver; usually Balancer.sol contract\n     * @param _amount the fees amount\n     */\n    function withdrawFees(address _to, uint256 _amount) external onlyOwner {\n        vault.transferFees(_to, _amount);\n    }\n\n    /**\n     * @notice extracts the underlying token/native for rebalancing\n     * @param _amount the amount used for rebalancing\n     */\n    function extractUnderlying(uint256 _amount) external nonReentrant {\n        if (!balancers[msg.sender]) revert mTOFT_BalancerNotAuthorized();\n        if (_amount == 0) revert TOFT_NotValid();\n\n        vault.withdraw(msg.sender, _amount);\n\n        emit Rebalancing(msg.sender, _amount, erc20 == address(0));\n    }\n\n    /// =====================\n    /// Private\n    /// =====================\n    function _checkAndExtractFees(uint256 _amount) private returns (uint256 feeAmount) {\n        feeAmount = 0;\n\n        // not on host chain; extract fee\n        // fees are used to rebalance liquidity to host chain\n        if (_getChainId() != hostEid && mintFee > 0) {\n            feeAmount = (_amount * mintFee) / 1e5;\n            if (feeAmount > 0) {\n                if (erc20 == address(0)) {\n                    vault.registerFees{value: feeAmount}(feeAmount);\n                } else {\n                    vault.registerFees(feeAmount);\n                }\n            }\n        }\n    }\n    /**\n     * @notice Return the current chain EID.\n     */\n\n    function _getChainId() internal view override returns (uint32) {\n        return IMessagingChannel(endpoint).eid();\n    }\n}"
    }
  ]
}