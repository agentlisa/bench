{
  "Title": "[L02] Inconsistent quorum calculation",
  "Content": "The [`Governance`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Governance.sol#L21) and [`DoubleSigningSlasher`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/DoubleSigningSlasher.sol#L7) contracts are inconsistently calculating the number of validators required to constitute quorum.\n\n\nIn the [`byzantineQuorumValidatorsInCurrentSet` function](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Governance.sol#L943) of the `Governance` contract, the quorum is calculated by doubling the total amount of validators, then dividing the obtained value by 3 and finally adding 1. On the other hand, in the [`minQuorumSize` function](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/DoubleSigningSlasher.sol#L48) of the `DoubleSigningSlasher` contract, the quorum is calculated by doubling the value of the total amount of validators, then adding 2 and dividing that value by 3. The `return` values of these functions differ when `numberValidatorsInSet` (for the `minQuorumSize` function) and `numberValidatorsInCurrentSet` (for the `byzantineQuorumValidatorsInCurrentSet` function) are equal to any integer multiple of 3. For example, with 21 validators, `byzantineQuorumValidatorsInCurrentSet` will return `15`, while `minQuorumSize` will return `14`. \n\n\nAlso worthy of note is that `byzantineQuorumValidatorsInCurrentSet` uses `SafeMath` functions while `minQuorumSize` does not.\n\n\nConsider being consistent in the calculation of the quorum and thoroughly comment in the source code an explanation regarding how the quorum is being calculated. Consider also using `SafeMath` operations in [`minQuorumSize`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/DoubleSigningSlasher.sol#L48) for better code consistency and security.\n\n\n****Update:*** Fixed in [pull request #2796](https://github.com/celo-org/celo-monorepo/pull/2796). The cLabs team has implemented a [single quorum calculation](https://github.com/celo-org/celo-monorepo/pull/2796/files#diff-0cffec14a25e6876b387a826c4b4946dR239).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/governance/Governance.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/math/Math.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\nimport \"./interfaces/IGovernance.sol\";\nimport \"./Proposals.sol\";\nimport \"../common/ExtractFunctionSignature.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/FixidityLib.sol\";\nimport \"../common/linkedlists/IntegerSortedLinkedList.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/UsingPrecompiles.sol\";\n\n// TODO(asa): Hardcode minimum times for queueExpiry, etc.\n/**\n * @title A contract for making, passing, and executing on-chain governance proposals.\n */\ncontract Governance is\n  IGovernance,\n  Ownable,\n  Initializable,\n  ReentrancyGuard,\n  UsingRegistry,\n  UsingPrecompiles\n{\n  using Proposals for Proposals.Proposal;\n  using FixidityLib for FixidityLib.Fraction;\n  using SafeMath for uint256;\n  using IntegerSortedLinkedList for SortedLinkedList.List;\n  using BytesLib for bytes;\n\n  uint256 private constant FIXED_HALF = 500000000000000000000000;\n\n  enum VoteValue { None, Abstain, No, Yes }\n\n  struct UpvoteRecord {\n    uint256 proposalId;\n    uint256 weight;\n  }\n\n  struct VoteRecord {\n    Proposals.VoteValue value;\n    uint256 proposalId;\n    uint256 weight;\n  }\n\n  struct Voter {\n    // Key of the proposal voted for in the proposal queue\n    UpvoteRecord upvote;\n    uint256 mostRecentReferendumProposal;\n    // Maps a `dequeued` index to a voter's vote record.\n    mapping(uint256 => VoteRecord) referendumVotes;\n  }\n\n  struct ContractConstitution {\n    FixidityLib.Fraction defaultThreshold;\n    // Maps a function ID to a corresponding threshold, overriding the default.\n    mapping(bytes4 => FixidityLib.Fraction) functionThresholds;\n  }\n\n  struct HotfixRecord {\n    bool executed;\n    bool approved;\n    uint256 preparedEpoch;\n    mapping(address => bool) whitelisted;\n  }\n\n  // The baseline is updated as\n  // max{floor, (1 - baselineUpdateFactor) * baseline + baselineUpdateFactor * participation}\n  struct ParticipationParameters {\n    // The average network participation in governance, weighted toward recent proposals.\n    FixidityLib.Fraction baseline;\n    // The lower bound on the participation baseline.\n    FixidityLib.Fraction baselineFloor;\n    // The weight of the most recent proposal's participation on the baseline.\n    FixidityLib.Fraction baselineUpdateFactor;\n    // The proportion of the baseline that constitutes quorum.\n    FixidityLib.Fraction baselineQuorumFactor;\n  }\n\n  Proposals.StageDurations public stageDurations;\n  uint256 public queueExpiry;\n  uint256 public dequeueFrequency;\n  address public approver;\n  uint256 public lastDequeue;\n  uint256 public concurrentProposals;\n  uint256 public proposalCount;\n  uint256 public minDeposit;\n  mapping(address => uint256) public refundedDeposits;\n  mapping(address => ContractConstitution) private constitution;\n  mapping(uint256 => Proposals.Proposal) private proposals;\n  mapping(address => Voter) private voters;\n  mapping(bytes32 => HotfixRecord) public hotfixes;\n  SortedLinkedList.List private queue;\n  uint256[] public dequeued;\n  uint256[] public emptyIndices;\n  ParticipationParameters private participationParameters;\n\n  event ApproverSet(address approver);\n\n  event ConcurrentProposalsSet(uint256 concurrentProposals);\n\n  event MinDepositSet(uint256 minDeposit);\n\n  event QueueExpirySet(uint256 queueExpiry);\n\n  event DequeueFrequencySet(uint256 dequeueFrequency);\n\n  event ApprovalStageDurationSet(uint256 approvalStageDuration);\n\n  event ReferendumStageDurationSet(uint256 referendumStageDuration);\n\n  event ExecutionStageDurationSet(uint256 executionStageDuration);\n\n  event ConstitutionSet(address indexed destination, bytes4 indexed functionId, uint256 threshold);\n\n  event ProposalQueued(\n    uint256 indexed proposalId,\n    address indexed proposer,\n    uint256 transactionCount,\n    uint256 deposit,\n    uint256 timestamp\n  );\n\n  event ProposalUpvoted(uint256 indexed proposalId, address indexed account, uint256 upvotes);\n\n  event ProposalUpvoteRevoked(\n    uint256 indexed proposalId,\n    address indexed account,\n    uint256 revokedUpvotes\n  );\n\n  event ProposalDequeued(uint256 indexed proposalId, uint256 timestamp);\n\n  event ProposalApproved(uint256 indexed proposalId);\n\n  event ProposalVoted(\n    uint256 indexed proposalId,\n    address indexed account,\n    uint256 value,\n    uint256 weight\n  );\n\n  event ProposalExecuted(uint256 indexed proposalId);\n\n  event ProposalExpired(uint256 proposalId);\n\n  event ParticipationBaselineUpdated(uint256 participationBaseline);\n\n  event ParticipationFloorSet(uint256 participationFloor);\n\n  event ParticipationBaselineUpdateFactorSet(uint256 baselineUpdateFactor);\n\n  event ParticipationBaselineQuorumFactorSet(uint256 baselineQuorumFactor);\n\n  event HotfixWhitelisted(bytes32 indexed hash, address whitelister);\n\n  event HotfixApproved(bytes32 indexed hash);\n\n  event HotfixPrepared(bytes32 indexed hash, uint256 indexed epoch);\n\n  event HotfixExecuted(bytes32 indexed hash);\n\n  function() external payable {} // solhint-disable no-empty-blocks\n\n  /**\n   * @notice Initializes critical variables.\n   * @param registryAddress The address of the registry contract.\n   * @param _approver The address that needs to approve proposals to move to the referendum stage.\n   * @param _concurrentProposals The number of proposals to dequeue at once.\n   * @param _minDeposit The minimum Celo Gold deposit needed to make a proposal.\n   * @param _queueExpiry The number of seconds a proposal can stay in the queue before expiring.\n   * @param _dequeueFrequency The number of seconds before the next batch of proposals can be\n   *   dequeued.\n   * @param approvalStageDuration The number of seconds the approver has to approve a proposal\n   *   after it is dequeued.\n   * @param referendumStageDuration The number of seconds users have to vote on a dequeued proposal\n   *   after the approval stage ends.\n   * @param executionStageDuration The number of seconds users have to execute a passed proposal\n   *   after the referendum stage ends.\n   * @param participationBaseline The initial value of the participation baseline.\n   * @param participationFloor The participation floor.\n   * @param baselineUpdateFactor The weight of the new participation in the baseline update rule.\n   * @param baselineQuorumFactor The proportion of the baseline that constitutes quorum.\n   * @dev Should be called only once.\n   */\n  function initialize(\n    address registryAddress,\n    address _approver,\n    uint256 _concurrentProposals,\n    uint256 _minDeposit,\n    uint256 _queueExpiry,\n    uint256 _dequeueFrequency,\n    uint256 approvalStageDuration,\n    uint256 referendumStageDuration,\n    uint256 executionStageDuration,\n    uint256 participationBaseline,\n    uint256 participationFloor,\n    uint256 baselineUpdateFactor,\n    uint256 baselineQuorumFactor\n  ) external initializer {\n    require(\n      _approver != address(0) &&\n        _concurrentProposals != 0 &&\n        _minDeposit != 0 &&\n        _queueExpiry != 0 &&\n        _dequeueFrequency != 0 &&\n        approvalStageDuration != 0 &&\n        referendumStageDuration != 0 &&\n        executionStageDuration != 0,\n      \"Bad input\"\n    );\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    approver = _approver;\n    concurrentProposals = _concurrentProposals;\n    minDeposit = _minDeposit;\n    queueExpiry = _queueExpiry;\n    dequeueFrequency = _dequeueFrequency;\n    stageDurations.approval = approvalStageDuration;\n    stageDurations.referendum = referendumStageDuration;\n    stageDurations.execution = executionStageDuration;\n    setParticipationBaseline(participationBaseline);\n    setParticipationFloor(participationFloor);\n    setBaselineUpdateFactor(baselineUpdateFactor);\n    setBaselineQuorumFactor(baselineQuorumFactor);\n    // solhint-disable-next-line not-rely-on-time\n    lastDequeue = now;\n  }\n\n  /**\n   * @notice Updates the address that has permission to approve proposals in the approval stage.\n   * @param _approver The address that has permission to approve proposals in the approval stage.\n   */\n  function setApprover(address _approver) external onlyOwner {\n    require(_approver != address(0), \"Approver cannot be 0\");\n    require(_approver != approver, \"Approver unchanged\");\n    approver = _approver;\n    emit ApproverSet(_approver);\n  }\n\n  /**\n   * @notice Updates the number of proposals to dequeue at a time.\n   * @param _concurrentProposals The number of proposals to dequeue at at a time.\n   */\n  function setConcurrentProposals(uint256 _concurrentProposals) external onlyOwner {\n    require(_concurrentProposals > 0, \"Number of proposals must be larger than zero\");\n    require(_concurrentProposals != concurrentProposals, \"Number of proposals unchanged\");\n    concurrentProposals = _concurrentProposals;\n    emit ConcurrentProposalsSet(_concurrentProposals);\n  }\n\n  /**\n   * @notice Updates the minimum deposit needed to make a proposal.\n   * @param _minDeposit The minimum Celo Gold deposit needed to make a proposal.\n   */\n  function setMinDeposit(uint256 _minDeposit) external onlyOwner {\n    require(_minDeposit != minDeposit, \"Minimum deposit unchanged\");\n    minDeposit = _minDeposit;\n    emit MinDepositSet(_minDeposit);\n  }\n\n  /**\n   * @notice Updates the number of seconds before a queued proposal expires.\n   * @param _queueExpiry The number of seconds a proposal can stay in the queue before expiring.\n   */\n  function setQueueExpiry(uint256 _queueExpiry) external onlyOwner {\n    require(_queueExpiry > 0, \"QueueExpiry must be larger than 0\");\n    require(_queueExpiry != queueExpiry, \"QueueExpiry unchanged\");\n    queueExpiry = _queueExpiry;\n    emit QueueExpirySet(_queueExpiry);\n  }\n\n  /**\n   * @notice Updates the minimum number of seconds before the next batch of proposals can be\n   *   dequeued.\n   * @param _dequeueFrequency The number of seconds before the next batch of proposals can be\n   *   dequeued.\n   */\n  function setDequeueFrequency(uint256 _dequeueFrequency) external onlyOwner {\n    require(_dequeueFrequency > 0, \"dequeueFrequency must be larger than 0\");\n    require(_dequeueFrequency != dequeueFrequency, \"dequeueFrequency unchanged\");\n    dequeueFrequency = _dequeueFrequency;\n    emit DequeueFrequencySet(_dequeueFrequency);\n  }\n\n  /**\n   * @notice Updates the number of seconds proposals stay in the approval stage.\n   * @param approvalStageDuration The number of seconds proposals stay in the approval stage.\n   */\n  function setApprovalStageDuration(uint256 approvalStageDuration) external onlyOwner {\n    require(approvalStageDuration > 0, \"Duration must be larger than 0\");\n    require(approvalStageDuration != stageDurations.approval, \"Duration unchanged\");\n    stageDurations.approval = approvalStageDuration;\n    emit ApprovalStageDurationSet(approvalStageDuration);\n  }\n\n  /**\n   * @notice Updates the number of seconds proposals stay in the referendum stage.\n   * @param referendumStageDuration The number of seconds proposals stay in the referendum stage.\n   */\n  function setReferendumStageDuration(uint256 referendumStageDuration) external onlyOwner {\n    require(referendumStageDuration > 0, \"Duration must be larger than 0\");\n    require(referendumStageDuration != stageDurations.referendum, \"Duration unchanged\");\n    stageDurations.referendum = referendumStageDuration;\n    emit ReferendumStageDurationSet(referendumStageDuration);\n  }\n\n  /**\n   * @notice Updates the number of seconds proposals stay in the execution stage.\n   * @param executionStageDuration The number of seconds proposals stay in the execution stage.\n   */\n  function setExecutionStageDuration(uint256 executionStageDuration) external onlyOwner {\n    require(executionStageDuration > 0, \"Duration must be larger than 0\");\n    require(executionStageDuration != stageDurations.execution, \"Duration unchanged\");\n    stageDurations.execution = executionStageDuration;\n    emit ExecutionStageDurationSet(executionStageDuration);\n  }\n\n  /**\n   * @notice Updates the participation baseline.\n   * @param participationBaseline The value of the baseline.\n   */\n  function setParticipationBaseline(uint256 participationBaseline) public onlyOwner {\n    FixidityLib.Fraction memory participationBaselineFrac = FixidityLib.wrap(participationBaseline);\n    require(\n      FixidityLib.isProperFraction(participationBaselineFrac),\n      \"Participation baseline greater than one\"\n    );\n    require(\n      !participationBaselineFrac.equals(participationParameters.baseline),\n      \"Participation baseline unchanged\"\n    );\n    participationParameters.baseline = participationBaselineFrac;\n    emit ParticipationBaselineUpdated(participationBaseline);\n  }\n\n  /**\n   * @notice Updates the floor of the participation baseline.\n   * @param participationFloor The value at which the baseline is floored.\n   */\n  function setParticipationFloor(uint256 participationFloor) public onlyOwner {\n    FixidityLib.Fraction memory participationFloorFrac = FixidityLib.wrap(participationFloor);\n    require(\n      FixidityLib.isProperFraction(participationFloorFrac),\n      \"Participation floor greater than one\"\n    );\n    require(\n      !participationFloorFrac.equals(participationParameters.baselineFloor),\n      \"Participation baseline floor unchanged\"\n    );\n    participationParameters.baselineFloor = participationFloorFrac;\n    emit ParticipationFloorSet(participationFloor);\n  }\n\n  /**\n   * @notice Updates the weight of the new participation in the baseline update rule.\n   * @param baselineUpdateFactor The new baseline update factor.\n   */\n  function setBaselineUpdateFactor(uint256 baselineUpdateFactor) public onlyOwner {\n    FixidityLib.Fraction memory baselineUpdateFactorFrac = FixidityLib.wrap(baselineUpdateFactor);\n    require(\n      FixidityLib.isProperFraction(baselineUpdateFactorFrac),\n      \"Baseline update factor greater than one\"\n    );\n    require(\n      !baselineUpdateFactorFrac.equals(participationParameters.baselineUpdateFactor),\n      \"Baseline update factor unchanged\"\n    );\n    participationParameters.baselineUpdateFactor = baselineUpdateFactorFrac;\n    emit ParticipationBaselineUpdateFactorSet(baselineUpdateFactor);\n  }\n\n  /**\n   * @notice Updates the proportion of the baseline that constitutes quorum.\n   * @param baselineQuorumFactor The new baseline quorum factor.\n   */\n  function setBaselineQuorumFactor(uint256 baselineQuorumFactor) public onlyOwner {\n    FixidityLib.Fraction memory baselineQuorumFactorFrac = FixidityLib.wrap(baselineQuorumFactor);\n    require(\n      FixidityLib.isProperFraction(baselineQuorumFactorFrac),\n      \"Baseline quorum factor greater than one\"\n    );\n    require(\n      !baselineQuorumFactorFrac.equals(participationParameters.baselineQuorumFactor),\n      \"Baseline quorum factor unchanged\"\n    );\n    participationParameters.baselineQuorumFactor = baselineQuorumFactorFrac;\n    emit ParticipationBaselineQuorumFactorSet(baselineQuorumFactor);\n  }\n\n  /**\n   * @notice Updates the ratio of yes:yes+no votes needed for a specific class of proposals to pass.\n   * @param destination The destination of proposals for which this threshold should apply.\n   * @param functionId The function ID of proposals for which this threshold should apply. Zero\n   *   will set the default.\n   * @param threshold The threshold.\n   * @dev If no constitution is explicitly set the default is a simple majority, i.e. 1:2.\n   */\n  function setConstitution(address destination, bytes4 functionId, uint256 threshold)\n    external\n    onlyOwner\n  {\n    // TODO(asa): https://github.com/celo-org/celo-monorepo/pull/3414#discussion_r283588332\n    require(destination != address(0), \"Destination cannot be zero\");\n    require(\n      threshold > FIXED_HALF && threshold <= FixidityLib.fixed1().unwrap(),\n      \"Threshold has to be greater than majority and not greater than unanimity\"\n    );\n    if (functionId == 0) {\n      constitution[destination].defaultThreshold = FixidityLib.wrap(threshold);\n    } else {\n      constitution[destination].functionThresholds[functionId] = FixidityLib.wrap(threshold);\n    }\n    emit ConstitutionSet(destination, functionId, threshold);\n  }\n\n  /**\n   * @notice Creates a new proposal and adds it to end of the queue with no upvotes.\n   * @param values The values of Celo Gold to be sent in the proposed transactions.\n   * @param destinations The destination addresses of the proposed transactions.\n   * @param data The concatenated data to be included in the proposed transactions.\n   * @param dataLengths The lengths of each transaction's data.\n   * @return The ID of the newly proposed proposal.\n   * @dev The minimum deposit must be included with the proposal, returned if/when the proposal is\n   *   dequeued.\n   */\n  function propose(\n    uint256[] calldata values,\n    address[] calldata destinations,\n    bytes calldata data,\n    uint256[] calldata dataLengths\n  ) external payable returns (uint256) {\n    dequeueProposalsIfReady();\n    require(msg.value >= minDeposit, \"Too small deposit\");\n\n    proposalCount = proposalCount.add(1);\n    Proposals.Proposal storage proposal = proposals[proposalCount];\n    proposal.make(values, destinations, data, dataLengths, msg.sender, msg.value);\n    queue.push(proposalCount);\n    // solhint-disable-next-line not-rely-on-time\n    emit ProposalQueued(proposalCount, msg.sender, proposal.transactions.length, msg.value, now);\n    return proposalCount;\n  }\n\n  /**\n   * @notice Upvotes a queued proposal.\n   * @param proposalId The ID of the proposal to upvote.\n   * @param lesser The ID of the proposal that will be just behind `proposalId` in the queue.\n   * @param greater The ID of the proposal that will be just ahead `proposalId` in the queue.\n   * @return Whether or not the upvote was made successfully.\n   * @dev Provide 0 for `lesser`/`greater` when the proposal will be at the tail/head of the queue.\n   * @dev Reverts if the account has already upvoted a proposal in the queue.\n   */\n  function upvote(uint256 proposalId, uint256 lesser, uint256 greater)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    // TODO(asa): When upvoting a proposal that will get dequeued, should we let the tx succeed\n    // and return false?\n    dequeueProposalsIfReady();\n    // If acting on an expired proposal, expire the proposal and take no action.\n    // solhint-disable-next-line not-rely-on-time\n    if (queue.contains(proposalId) && now >= proposals[proposalId].timestamp.add(queueExpiry)) {\n      queue.remove(proposalId);\n      emit ProposalExpired(proposalId);\n      return false;\n    }\n    Voter storage voter = voters[account];\n    // If the previously upvoted proposal is still in the queue but has expired, expire the\n    // proposal from the queue.\n    if (\n      queue.contains(voter.upvote.proposalId) &&\n      now >= proposals[voter.upvote.proposalId].timestamp.add(queueExpiry)\n    ) {\n      queue.remove(voter.upvote.proposalId);\n      emit ProposalExpired(voter.upvote.proposalId);\n    }\n    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.\n    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);\n    require(weight > 0, \"cannot upvote without locking gold\");\n    require(isQueued(proposalId), \"cannot upvote a proposal not in the queue\");\n    require(\n      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),\n      \"cannot upvote more than one queued proposal\"\n    );\n    uint256 upvotes = queue.getValue(proposalId).add(weight);\n    queue.update(proposalId, upvotes, lesser, greater);\n    voter.upvote = UpvoteRecord(proposalId, weight);\n    emit ProposalUpvoted(proposalId, account, weight);\n    return true;\n  }\n\n  /**\n   * @notice Returns stage of governance process given proposal is in\n   * @param proposalId The ID of the proposal to query.\n   * @return proposal stage\n   */\n  function getProposalStage(uint256 proposalId) external view returns (Proposals.Stage) {\n    if (proposalId == 0 || proposalId > proposalCount) {\n      return Proposals.Stage.None;\n    } else if (isQueued(proposalId)) {\n      return Proposals.Stage.Queued;\n    } else {\n      return proposals[proposalId].getDequeuedStage(stageDurations);\n    }\n  }\n\n  /**\n   * @notice Revokes an upvote on a queued proposal.\n   * @param lesser The ID of the proposal that will be just behind the previously upvoted proposal\n   *   in the queue.\n   * @param greater The ID of the proposal that will be just ahead of the previously upvoted\n   *   proposal in the queue.\n   * @return Whether or not the upvote was revoked successfully.\n   * @dev Provide 0 for `lesser`/`greater` when the proposal will be at the tail/head of the queue.\n   */\n  function revokeUpvote(uint256 lesser, uint256 greater) external nonReentrant returns (bool) {\n    dequeueProposalsIfReady();\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    Voter storage voter = voters[account];\n    uint256 proposalId = voter.upvote.proposalId;\n    Proposals.Proposal storage proposal = proposals[proposalId];\n    require(proposal.exists(), \"Proposal doesn't exist\");\n    // If acting on an expired proposal, expire the proposal.\n    // TODO(asa): Break this out into a separate function.\n    if (queue.contains(proposalId)) {\n      // solhint-disable-next-line not-rely-on-time\n      if (now >= proposal.timestamp.add(queueExpiry)) {\n        queue.remove(proposalId);\n        emit ProposalExpired(proposalId);\n      } else {\n        queue.update(\n          proposalId,\n          queue.getValue(proposalId).sub(voter.upvote.weight),\n          lesser,\n          greater\n        );\n        emit ProposalUpvoteRevoked(proposalId, account, voter.upvote.weight);\n      }\n    }\n    voter.upvote = UpvoteRecord(0, 0);\n    return true;\n  }\n\n  // TODO(asa): Consider allowing approval to be revoked.\n  // TODO(asa): Everywhere we use an index, require it's less than the array length\n  /**\n   * @notice Approves a proposal in the approval stage.\n   * @param proposalId The ID of the proposal to approve.\n   * @param index The index of the proposal ID in `dequeued`.\n   * @return Whether or not the approval was made successfully.\n   */\n  function approve(uint256 proposalId, uint256 index) external returns (bool) {\n    dequeueProposalsIfReady();\n    Proposals.Proposal storage proposal = proposals[proposalId];\n    require(isDequeuedProposal(proposal, proposalId, index), \"Proposal not dequeued\");\n    Proposals.Stage stage = proposal.getDequeuedStage(stageDurations);\n    if (isDequeuedProposalExpired(proposal, stage)) {\n      deleteDequeuedProposal(proposal, proposalId, index);\n      return false;\n    }\n    require(msg.sender == approver, \"Only approver can approve\");\n    require(!proposal.isApproved(), \"Proposal already approved\");\n    require(stage == Proposals.Stage.Approval, \"Proposal not in approval stage\");\n    proposal.approved = true;\n    // Ensures networkWeight is set by the end of the Referendum stage, even if 0 votes are cast.\n    proposal.networkWeight = getLockedGold().getTotalLockedGold();\n    emit ProposalApproved(proposalId);\n    return true;\n  }\n\n  /**\n   * @notice Votes on a proposal in the referendum stage.\n   * @param proposalId The ID of the proposal to vote on.\n   * @param index The index of the proposal ID in `dequeued`.\n   * @param value Whether to vote yes, no, or abstain.\n   * @return Whether or not the vote was cast successfully.\n   */\n  /* solhint-disable code-complexity */\n  function vote(uint256 proposalId, uint256 index, Proposals.VoteValue value)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    dequeueProposalsIfReady();\n    Proposals.Proposal storage proposal = proposals[proposalId];\n    require(isDequeuedProposal(proposal, proposalId, index), \"Proposal not dequeued\");\n    Proposals.Stage stage = proposal.getDequeuedStage(stageDurations);\n    if (isDequeuedProposalExpired(proposal, stage)) {\n      deleteDequeuedProposal(proposal, proposalId, index);\n      return false;\n    }\n    Voter storage voter = voters[account];\n    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);\n    require(proposal.isApproved(), \"Proposal not approved\");\n    require(\n      stage == Proposals.Stage.Referendum && value != Proposals.VoteValue.None && weight > 0,\n      \"Incorrect proposal state\"\n    );\n    require(value != Proposals.VoteValue.None, \"Vote value unset\");\n    require(weight > 0, \"Voter weight zero\");\n    VoteRecord storage voteRecord = voter.referendumVotes[index];\n    proposal.updateVote(\n      voteRecord.weight,\n      weight,\n      (voteRecord.proposalId == proposalId) ? voteRecord.value : Proposals.VoteValue.None,\n      value\n    );\n    proposal.networkWeight = getLockedGold().getTotalLockedGold();\n    voter.referendumVotes[index] = VoteRecord(value, proposalId, weight);\n    if (proposal.timestamp > voter.mostRecentReferendumProposal) {\n      voter.mostRecentReferendumProposal = proposalId;\n    }\n    emit ProposalVoted(proposalId, account, uint256(value), weight);\n    return true;\n  }\n  /* solhint-enable code-complexity */\n\n  /**\n   * @notice Executes a proposal in the execution stage, removing it from `dequeued`.\n   * @param proposalId The ID of the proposal to vote on.\n   * @param index The index of the proposal ID in `dequeued`.\n   * @return Whether or not the proposal was executed successfully.\n   * @dev Does not remove the proposal if the execution fails.\n   */\n  function execute(uint256 proposalId, uint256 index) external nonReentrant returns (bool) {\n    dequeueProposalsIfReady();\n    Proposals.Proposal storage proposal = proposals[proposalId];\n    require(isDequeuedProposal(proposal, proposalId, index), \"Proposal not dequeued\");\n    Proposals.Stage stage = proposal.getDequeuedStage(stageDurations);\n    bool expired = isDequeuedProposalExpired(proposal, stage);\n    if (!expired) {\n      // TODO(asa): Think through the effects of changing the passing function\n      require(\n        stage == Proposals.Stage.Execution && _isProposalPassing(proposal),\n        \"Proposal not in execution stage or not passing\"\n      );\n      proposal.execute();\n      emit ProposalExecuted(proposalId);\n    }\n    // Proposal must have executed fully or expired if this point is reached.\n    deleteDequeuedProposal(proposal, proposalId, index);\n    return !expired;\n  }\n\n  /**\n   * @notice Whitelists the hash of a hotfix transaction(s).\n   * @param hash The abi encoded keccak256 hash of the hotfix transaction(s) to be whitelisted.\n   */\n  function approveHotfix(bytes32 hash) external {\n    require(!hotfixes[hash].executed, \"hotfix already executed\");\n    require(msg.sender == approver, \"Not approver\");\n    hotfixes[hash].approved = true;\n    emit HotfixApproved(hash);\n  }\n\n  /**\n   * @notice Returns whether given hotfix hash has been whitelisted by given address.\n   * @param hash The abi encoded keccak256 hash of the hotfix transaction(s) to be whitelisted.\n   * @param whitelister Address to check whitelist status of.\n   */\n  function isHotfixWhitelistedBy(bytes32 hash, address whitelister) public view returns (bool) {\n    return hotfixes[hash].whitelisted[whitelister];\n  }\n\n  /**\n   * @notice Whitelists the hash of a hotfix transaction(s).\n   * @param hash The abi encoded keccak256 hash of the hotfix transaction(s) to be whitelisted.\n   */\n  function whitelistHotfix(bytes32 hash) external {\n    require(!hotfixes[hash].executed, \"hotfix already executed\");\n    hotfixes[hash].whitelisted[msg.sender] = true;\n    emit HotfixWhitelisted(hash, msg.sender);\n  }\n\n  /**\n   * @notice Gives hotfix a prepared epoch for execution.\n   * @param hash The hash of the hotfix to be prepared.\n   */\n  function prepareHotfix(bytes32 hash) external {\n    require(!hotfixes[hash].executed, \"hotfix already executed\");\n    require(isHotfixPassing(hash), \"hotfix not whitelisted by 2f+1 validators\");\n    uint256 epoch = getEpochNumber();\n    require(hotfixes[hash].preparedEpoch < epoch, \"hotfix already prepared for this epoch\");\n    hotfixes[hash].preparedEpoch = epoch;\n    emit HotfixPrepared(hash, epoch);\n  }\n\n  /**\n   * @notice Executes a whitelisted proposal.\n   * @param values The values of Celo Gold to be sent in the proposed transactions.\n   * @param destinations The destination addresses of the proposed transactions.\n   * @param data The concatenated data to be included in the proposed transactions.\n   * @param dataLengths The lengths of each transaction's data.\n   * @param salt Secret associated with hotfix which guarantees uniqueness of hash.\n   * @dev Reverts if hotfix is already executed, not approved, or not prepared for current epoch.\n   */\n  function executeHotfix(\n    uint256[] calldata values,\n    address[] calldata destinations,\n    bytes calldata data,\n    uint256[] calldata dataLengths,\n    bytes32 salt\n  ) external {\n    bytes32 hash = keccak256(abi.encode(values, destinations, data, dataLengths, salt));\n\n    (bool approved, bool executed, uint256 preparedEpoch) = getHotfixRecord(hash);\n    require(!executed, \"hotfix already executed\");\n    require(approved, \"hotfix not approved\");\n    require(preparedEpoch == getEpochNumber(), \"hotfix must be prepared for this epoch\");\n\n    Proposals.makeMem(values, destinations, data, dataLengths, msg.sender, 0).executeMem();\n\n    hotfixes[hash].executed = true;\n    emit HotfixExecuted(hash);\n  }\n\n  /**\n   * @notice Withdraws refunded Celo Gold deposits.\n   * @return Whether or not the withdraw was successful.\n   */\n  function withdraw() external nonReentrant returns (bool) {\n    uint256 value = refundedDeposits[msg.sender];\n    require(value > 0, \"Nothing to withdraw\");\n    require(value <= address(this).balance, \"Inconsistent balance\");\n    refundedDeposits[msg.sender] = 0;\n    msg.sender.transfer(value);\n    return true;\n  }\n\n  /**\n   * @notice Returns whether or not a particular account is voting on proposals.\n   * @param account The address of the account.\n   * @return Whether or not the account is voting on proposals.\n   */\n  function isVoting(address account) external view returns (bool) {\n    Voter storage voter = voters[account];\n    uint256 upvotedProposal = voter.upvote.proposalId;\n    bool isVotingQueue = upvotedProposal != 0 && isQueued(upvotedProposal);\n    Proposals.Proposal storage proposal = proposals[voter.mostRecentReferendumProposal];\n    bool isVotingReferendum = (proposal.getDequeuedStage(stageDurations) ==\n      Proposals.Stage.Referendum);\n    return isVotingQueue || isVotingReferendum;\n  }\n\n  /**\n   * @notice Returns the number of seconds proposals stay in approval stage.\n   * @return The number of seconds proposals stay in approval stage.\n   */\n  function getApprovalStageDuration() external view returns (uint256) {\n    return stageDurations.approval;\n  }\n\n  /**\n   * @notice Returns the number of seconds proposals stay in the referendum stage.\n   * @return The number of seconds proposals stay in the referendum stage.\n   */\n  function getReferendumStageDuration() external view returns (uint256) {\n    return stageDurations.referendum;\n  }\n\n  /**\n   * @notice Returns the number of seconds proposals stay in the execution stage.\n   * @return The number of seconds proposals stay in the execution stage.\n   */\n  function getExecutionStageDuration() external view returns (uint256) {\n    return stageDurations.execution;\n  }\n\n  /**\n   * @notice Returns the participation parameters.\n   * @return The participation parameters.\n   */\n  function getParticipationParameters() external view returns (uint256, uint256, uint256, uint256) {\n    return (\n      participationParameters.baseline.unwrap(),\n      participationParameters.baselineFloor.unwrap(),\n      participationParameters.baselineUpdateFactor.unwrap(),\n      participationParameters.baselineQuorumFactor.unwrap()\n    );\n  }\n\n  /**\n   * @notice Returns whether or not a proposal exists.\n   * @param proposalId The ID of the proposal.\n   * @return Whether or not the proposal exists.\n   */\n  function proposalExists(uint256 proposalId) external view returns (bool) {\n    return proposals[proposalId].exists();\n  }\n\n  /**\n   * @notice Returns an unpacked proposal struct with its transaction count.\n   * @param proposalId The ID of the proposal to unpack.\n   * @return The unpacked proposal with its transaction count.\n   */\n  function getProposal(uint256 proposalId)\n    external\n    view\n    returns (address, uint256, uint256, uint256)\n  {\n    return proposals[proposalId].unpack();\n  }\n\n  /**\n   * @notice Returns a specified transaction in a proposal"
    }
  ]
}