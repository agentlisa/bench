{
  "Title": "[M-06] Flashloan fee is not distributed to the factory",
  "Content": "\nWhen user takes a flashloan, then [he pays a fee](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L651) to the PrivatePool.\nThe problem is that the whole fee amount is sent to PrivatePool and factory receives nothing.\n\nHowever, all other function of contract send some part of fees to the factory.\n\nFor example, `change` function, which is similar to the `flashloan` as it doesn't change virtual nft and balance reserves. This function [calculates pool and protocol fees](https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L736-L737).\n\nBut in case of flashloan, only pool receives fees.\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nSend some part of flashloan fee to the factory.\n\n**[outdoteth (Caviar) confirmed and commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/697#issuecomment-1519957289):**\n > Fixed in: https://github.com/outdoteth/caviar-private-pools/pull/8.\n> \n> Proposed fix is to add a method that returns the protocol fee and flash fee. And then have the flash fee function sum the two outputs:\n> \n> ```solidity\n> function flashFeeAndProtocolFee() public view returns (uint256 feeAmount, uint256 protocolFeeAmount) {\n>     // multiply the changeFee to get the fee per NFT (4 decimals of accuracy)\n>     uint256 exponent = baseToken == address(0) ? 18 - 4 : ERC20(baseToken).decimals() - 4;\n>     feeAmount = changeFee * 10 ** exponent;\n>     protocolFeeAmount = feeAmount * Factory(factory).protocolFeeRate() / 10_000;\n> }\n> \n> \n> function flashFee(address, uint256) public view returns (uint256) {\n>     (uint256 feeAmount, uint256 protocolFeeAmount) = flashFeeAndProtocolFee();\n>     return feeAmount + protocolFeeAmount;\n> }\n> ```\n> \n> and then add the protocol payment in the flashLoan method:\n> \n> ```solidity\n> // -- snip -- //\n> \n> if (baseToken != address(0)) {\n>     // transfer the fee from the borrower\n>     ERC20(baseToken).safeTransferFrom(msg.sender, address(this), flashFee);\n> \n>     // transfer the protocol fee to the factory\n>     ERC20(baseToken).safeTransferFrom(msg.sender, factory, protocolFee);\n> } else {\n>     // transfer the protocol fee to the factory\n>     factory.safeTransferETH(protocolFee);\n> }\n> ```\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/697#issuecomment-1528972275):**\n > @outdoteth - Can you please confirm if you originally intended to have the protocol charge a fee for Flashloans?\n\n**[outdoteth (Caviar) commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/697#issuecomment-1530128568):**\n > It was an oversight that we did not charge fees on flash loans. It's implied that it should be paid though since protocol fees are charged everywhere else a user makes a transaction.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/697#issuecomment-1531011905):**\n > The Warden has found an inconsistency as to how fees are paid. After confirming with the Sponsor, I agree with Medium Severity.\n\n**Status:** Mitigation confirmed. Full details in reports from [rbserver](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/31), [KrisApostolov](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/41), and [rvierdiiev](https://github.com/code-423n4/2023-05-caviar-mitigation-contest-findings/issues/11).\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-04-caviar-private-pools",
  "Code": [
    {
      "filename": "src/PrivatePool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/*\n *                                   ____\n *                                /\\|    ~~\\\n *                              /'  |   ,-. `\\\n *                             |       | X |  |\n *                            _|________`-'   |X\n *                          /'          ~~~~~~~~~,\n *                        /'             ,_____,/_\n *                     ,/'        ___,'~~         ;\n * ~~~~~~~~|~~~~~~~|---          /  X,~~~~~~~~~~~~,\n *         |       |            |  XX'____________'\n *         |       |           /' XXX|            ;\n *         |       |        --x|  XXX,~~~~~~~~~~~~,\n *         |       |          X|     '____________'\n *         |   o   |---~~~~\\__XX\\             |XX\n *         |       |          XXX`\\          /XXXX\n * ~~~~~~~~'~~~~~~~'               `\\xXXXXx/' \\XXX\n *                                  /XXXXXX\\\n *                                /XXXXXXXXXX\\\n *                              /XXXXXX/^\\XXXXX\\\n *                             ~~~~~~~~   ~~~~~~~\n */\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC721, ERC721TokenReceiver} from \"solmate/tokens/ERC721.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {MerkleProofLib} from \"solady/utils/MerkleProofLib.sol\";\nimport {IERC2981} from \"openzeppelin/interfaces/IERC2981.sol\";\nimport {IRoyaltyRegistry} from \"royalty-registry-solidity/IRoyaltyRegistry.sol\";\nimport {IERC3156FlashBorrower} from \"openzeppelin/interfaces/IERC3156FlashLender.sol\";\n\nimport {IStolenNftOracle} from \"./interfaces/IStolenNftOracle.sol\";\nimport {Factory} from \"./Factory.sol\";\n\n/// @title Private Pool\n/// @author out.eth (@outdoteth)\n/// @notice A private pool is a an NFT AMM controlled by a single owner with concentrated liquidity, custom fee rates,\n/// stolen NFT filtering, custom NFT weightings, royalty support, and flash loans. You can create a pool and change\n/// these parameters to your liking. Deposit NFTs and base tokens (or ETH) into the pool to enable trading. Earn fees on\n/// each trade.\ncontract PrivatePool is ERC721TokenReceiver {\n    using SafeTransferLib for address payable;\n    using SafeTransferLib for address;\n    using SafeTransferLib for ERC20;\n\n    /// @notice Merkle proof input for a sparse merkle multi proof. It can be generated with a library like:\n    /// https://github.com/OpenZeppelin/merkle-tree#treegetmultiproof\n    struct MerkleMultiProof {\n        bytes32[] proof;\n        bool[] flags;\n    }\n\n    // forgefmt: disable-start\n    event Initialize(address indexed baseToken, address indexed nft, uint128 virtualBaseTokenReserves, uint128 virtualNftReserves, uint56 changeFee, uint16 feeRate, bytes32 merkleRoot, bool useStolenNftOracle, bool payRoyalties);\n    event Buy(uint256[] tokenIds, uint256[] tokenWeights, uint256 inputAmount, uint256 feeAmount, uint256 protocolFeeAmount, uint256 royaltyFeeAmount);\n    event Sell(uint256[] tokenIds, uint256[] tokenWeights, uint256 outputAmount, uint256 feeAmount, uint256 protocolFeeAmount, uint256 royaltyFeeAmount);\n    event Deposit(uint256[] tokenIds, uint256 baseTokenAmount);\n    event Withdraw(address indexed nft, uint256[] tokenIds, address token, uint256 amount);\n    event Change(uint256[] inputTokenIds, uint256[] inputTokenWeights, uint256[] outputTokenIds, uint256[] outputTokenWeights, uint256 feeAmount, uint256 protocolFeeAmount);\n    event SetVirtualReserves(uint128 virtualBaseTokenReserves, uint128 virtualNftReserves);\n    event SetMerkleRoot(bytes32 merkleRoot);\n    event SetFeeRate(uint16 feeRate);\n    event SetUseStolenNftOracle(bool useStolenNftOracle);\n    event SetPayRoyalties(bool payRoyalties);\n    // forgefmt: disable-end\n\n    error AlreadyInitialized();\n    error Unauthorized();\n    error InvalidEthAmount();\n    error InvalidMerkleProof();\n    error InsufficientInputWeight();\n    error FeeRateTooHigh();\n    error NotAvailableForFlashLoan();\n    error FlashLoanFailed();\n    error InvalidRoyaltyFee();\n\n    /// @notice The address of the base ERC20 token.\n    address public baseToken;\n\n    /// @notice The address of the nft.\n    address public nft;\n\n    /// @notice The change/flash fee to 4 decimals of precision. For example, 0.0025 ETH = 25. 500 USDC = 5_000_000.\n    uint56 public changeFee;\n\n    /// @notice The buy/sell fee rate (in basis points) 200 = 2%\n    uint16 public feeRate;\n\n    /// @notice Whether or not the pool has been initialized.\n    bool public initialized;\n\n    /// @notice Whether or not the pool pays royalties to the NFT creator on each trade.\n    bool public payRoyalties;\n\n    /// @notice Whether or not the pool uses the stolen NFT oracle to check if an NFT is stolen.\n    bool public useStolenNftOracle;\n\n    /// @notice The virtual base token reserves used in the xy=k invariant. Changing this will change the liquidity\n    /// depth and price of the pool.\n    uint128 public virtualBaseTokenReserves;\n\n    /// @notice The virtual nft reserves used in the xy=k invariant. Changing this will change the liquidity\n    /// depth and price of the pool.\n    /// @dev The virtual NFT reserves that a user sets. If it's desired to set the reserves to match 16 NFTs then the\n    /// virtual reserves should be set to 16e18. If weights are enabled by setting the merkle root to be non-zero then\n    /// the virtual reserves should be set to the sum of the weights of the NFTs; where floor NFTs all have a weight of\n    /// 1e18. A rarer NFT may have a weight of 2.3e18 if it's 2.3x more valuable than a floor.\n    uint128 public virtualNftReserves;\n\n    /// @notice The merkle root of all the token weights in the pool. If the merkle root is set to bytes32(0) then all\n    /// NFTs are set to have a weight of 1e18.\n    bytes32 public merkleRoot;\n\n    /// @notice The NFT oracle to check if an NFT is stolen.\n    address public immutable stolenNftOracle;\n\n    /// @notice The factory contract that created this pool.\n    address payable public immutable factory;\n\n    /// @notice The royalty registry from manifold.xyz.\n    address public immutable royaltyRegistry;\n\n    modifier onlyOwner() virtual {\n        if (msg.sender != Factory(factory).ownerOf(uint160(address(this)))) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    receive() external payable {}\n\n    /// @dev This is only called when the base implementation contract is deployed. The following immutable parameters\n    /// are set:\n    /// - factory: The address of the factory contract\n    /// - royaltyRegistry: The address of the royalty registry from manifold.xyz\n    /// - stolenNftOracle: The address of the stolen NFT oracle\n    /// These are all stored in immutable storage, which enables all minimal proxy contracts to read them without\n    /// incurring additional deployment costs and re-initializing them at point of creation in the factory contract.\n    constructor(address _factory, address _royaltyRegistry, address _stolenNftOracle) {\n        factory = payable(_factory);\n        royaltyRegistry = _royaltyRegistry;\n        stolenNftOracle = _stolenNftOracle;\n    }\n\n    /// @notice Initializes the private pool and sets the initial parameters. Should only be called once by the factory.\n    /// @param _baseToken The address of the base token\n    /// @param _nft The address of the NFT\n    /// @param _virtualBaseTokenReserves The virtual base token reserves\n    /// @param _virtualNftReserves The virtual NFT reserves\n    /// @param _feeRate The fee rate (in basis points) 200 = 2%\n    /// @param _merkleRoot The merkle root\n    /// @param _useStolenNftOracle Whether or not the pool uses the stolen NFT oracle to check if an NFT is stolen\n    function initialize(\n        address _baseToken,\n        address _nft,\n        uint128 _virtualBaseTokenReserves,\n        uint128 _virtualNftReserves,\n        uint56 _changeFee,\n        uint16 _feeRate,\n        bytes32 _merkleRoot,\n        bool _useStolenNftOracle,\n        bool _payRoyalties\n    ) public {\n        // prevent duplicate initialization\n        if (initialized) revert AlreadyInitialized();\n\n        // check that the fee rate is less than 50%\n        if (_feeRate > 5_000) revert FeeRateTooHigh();\n\n        // set the state variables\n        baseToken = _baseToken;\n        nft = _nft;\n        virtualBaseTokenReserves = _virtualBaseTokenReserves;\n        virtualNftReserves = _virtualNftReserves;\n        changeFee = _changeFee;\n        feeRate = _feeRate;\n        merkleRoot = _merkleRoot;\n        useStolenNftOracle = _useStolenNftOracle;\n        payRoyalties = _payRoyalties;\n\n        // mark the pool as initialized\n        initialized = true;\n\n        // emit the event\n        emit Initialize(\n            _baseToken,\n            _nft,\n            _virtualBaseTokenReserves,\n            _virtualNftReserves,\n            _changeFee,\n            _feeRate,\n            _merkleRoot,\n            _useStolenNftOracle,\n            _payRoyalties\n        );\n    }\n\n    /// @notice Buys NFTs from the pool, paying with base tokens from the caller. Then transfers the bought NFTs to the\n    /// caller. The net cost depends on the current price, fee rate and assigned NFT weights.\n    /// @dev DO NOT call this function directly unless you know what you are doing. Instead, use a wrapper contract that\n    /// will check the max input amount and revert if the slippage is too high.\n    /// @param tokenIds The token IDs of the NFTs to buy.\n    /// @param tokenWeights The weights of the NFTs to buy.\n    /// @param proof The merkle proof for the weights of each NFT to buy.\n    /// @return netInputAmount The amount of base tokens spent inclusive of fees.\n    /// @return feeAmount The amount of base tokens spent on fees.\n    function buy(uint256[] calldata tokenIds, uint256[] calldata tokenWeights, MerkleMultiProof calldata proof)\n        public\n        payable\n        returns (uint256 netInputAmount, uint256 feeAmount, uint256 protocolFeeAmount)\n    {\n        // ~~~ Checks ~~~ //\n\n        // calculate the sum of weights of the NFTs to buy\n        uint256 weightSum = sumWeightsAndValidateProof(tokenIds, tokenWeights, proof);\n\n        // calculate the required net input amount and fee amount\n        (netInputAmount, feeAmount, protocolFeeAmount) = buyQuote(weightSum);\n\n        // check that the caller sent 0 ETH if the base token is not ETH\n        if (baseToken != address(0) && msg.value > 0) revert InvalidEthAmount();\n\n        // ~~~ Effects ~~~ //\n\n        // update the virtual reserves\n        virtualBaseTokenReserves += uint128(netInputAmount - feeAmount - protocolFeeAmount);\n        virtualNftReserves -= uint128(weightSum);\n\n        // ~~~ Interactions ~~~ //\n\n        // calculate the sale price (assume it's the same for each NFT even if weights differ)\n        uint256 salePrice = (netInputAmount - feeAmount - protocolFeeAmount) / tokenIds.length;\n        uint256 royaltyFeeAmount = 0;\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            // transfer the NFT to the caller\n            ERC721(nft).safeTransferFrom(address(this), msg.sender, tokenIds[i]);\n\n            if (payRoyalties) {\n                // get the royalty fee for the NFT\n                (uint256 royaltyFee,) = _getRoyalty(tokenIds[i], salePrice);\n\n                // add the royalty fee to the total royalty fee amount\n                royaltyFeeAmount += royaltyFee;\n            }\n        }\n\n        // add the royalty fee amount to the net input aount\n        netInputAmount += royaltyFeeAmount;\n\n        if (baseToken != address(0)) {\n            // transfer the base token from the caller to the contract\n            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), netInputAmount);\n\n            // if the protocol fee is set then pay the protocol fee\n            if (protocolFeeAmount > 0) ERC20(baseToken).safeTransfer(address(factory), protocolFeeAmount);\n        } else {\n            // check that the caller sent enough ETH to cover the net required input\n            if (msg.value < netInputAmount) revert InvalidEthAmount();\n\n            // if the protocol fee is set then pay the protocol fee\n            if (protocolFeeAmount > 0) factory.safeTransferETH(protocolFeeAmount);\n\n            // refund any excess ETH to the caller\n            if (msg.value > netInputAmount) msg.sender.safeTransferETH(msg.value - netInputAmount);\n        }\n\n        if (payRoyalties) {\n            for (uint256 i = 0; i < tokenIds.length; i++) {\n                // get the royalty fee for the NFT\n                (uint256 royaltyFee, address recipient) = _getRoyalty(tokenIds[i], salePrice);\n\n                // transfer the royalty fee to the recipient if it's greater than 0\n                if (royaltyFee > 0 && recipient != address(0)) {\n                    if (baseToken != address(0)) {\n                        ERC20(baseToken).safeTransfer(recipient, royaltyFee);\n                    } else {\n                        recipient.safeTransferETH(royaltyFee);\n                    }\n                }\n            }\n        }\n\n        // emit the buy event\n        emit Buy(tokenIds, tokenWeights, netInputAmount, feeAmount, protocolFeeAmount, royaltyFeeAmount);\n    }\n\n    /// @notice Sells NFTs into the pool and transfers base tokens to the caller. NFTs are transferred from the caller\n    /// to the pool. The net sale amount depends on the current price, fee rate and assigned NFT weights.\n    /// @dev DO NOT call this function directly unless you know what you are doing. Instead, use a wrapper contract that\n    /// will check the min output amount and revert if the slippage is too high.\n    /// @param tokenIds The token IDs of the NFTs to sell.\n    /// @param tokenWeights The weights of the NFTs to sell.\n    /// @param proof The merkle proof for the weights of each NFT to sell.\n    /// @param stolenNftProofs The proofs that show each NFT is not stolen.\n    /// @return netOutputAmount The amount of base tokens received inclusive of fees.\n    /// @return feeAmount The amount of base tokens to pay in fees.\n    function sell(\n        uint256[] calldata tokenIds,\n        uint256[] calldata tokenWeights,\n        MerkleMultiProof calldata proof,\n        IStolenNftOracle.Message[] memory stolenNftProofs // put in memory to avoid stack too deep error\n    ) public returns (uint256 netOutputAmount, uint256 feeAmount, uint256 protocolFeeAmount) {\n        // ~~~ Checks ~~~ //\n\n        // calculate the sum of weights of the NFTs to sell\n        uint256 weightSum = sumWeightsAndValidateProof(tokenIds, tokenWeights, proof);\n\n        // calculate the net output amount and fee amount\n        (netOutputAmount, feeAmount, protocolFeeAmount) = sellQuote(weightSum);\n\n        //  check the nfts are not stolen\n        if (useStolenNftOracle) {\n            IStolenNftOracle(stolenNftOracle).validateTokensAreNotStolen(nft, tokenIds, stolenNftProofs);\n        }\n\n        // ~~~ Effects ~~~ //\n\n        // update the virtual reserves\n        virtualBaseTokenReserves -= uint128(netOutputAmount + protocolFeeAmount + feeAmount);\n        virtualNftReserves += uint128(weightSum);\n\n        // ~~~ Interactions ~~~ //\n\n        uint256 royaltyFeeAmount = 0;\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            // transfer each nft from the caller\n            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n\n            if (payRoyalties) {\n                // calculate the sale price (assume it's the same for each NFT even if weights differ)\n                uint256 salePrice = (netOutputAmount + feeAmount + protocolFeeAmount) / tokenIds.length;\n\n                // get the royalty fee for the NFT\n                (uint256 royaltyFee, address recipient) = _getRoyalty(tokenIds[i], salePrice);\n\n                // tally the royalty fee amount\n                royaltyFeeAmount += royaltyFee;\n\n                // transfer the royalty fee to the recipient if it's greater than 0\n                if (royaltyFee > 0 && recipient != address(0)) {\n                    if (baseToken != address(0)) {\n                        ERC20(baseToken).safeTransfer(recipient, royaltyFee);\n                    } else {\n                        recipient.safeTransferETH(royaltyFee);\n                    }\n                }\n            }\n        }\n\n        // subtract the royalty fee amount from the net output amount\n        netOutputAmount -= royaltyFeeAmount;\n\n        if (baseToken == address(0)) {\n            // transfer ETH to the caller\n            msg.sender.safeTransferETH(netOutputAmount);\n\n            // if the protocol fee is set then pay the protocol fee\n            if (protocolFeeAmount > 0) factory.safeTransferETH(protocolFeeAmount);\n        } else {\n            // transfer base tokens to the caller\n            ERC20(baseToken).transfer(msg.sender, netOutputAmount);\n\n            // if the protocol fee is set then pay the protocol fee\n            if (protocolFeeAmount > 0) ERC20(baseToken).safeTransfer(address(factory), protocolFeeAmount);\n        }\n\n        // emit the sell event\n        emit Sell(tokenIds, tokenWeights, netOutputAmount, feeAmount, protocolFeeAmount, royaltyFeeAmount);\n    }\n\n    /// @notice Changes a set of NFTs that the caller owns for another set of NFTs in the pool. The caller must approve\n    /// the pool to transfer the NFTs. The sum of the caller's NFT weights must be less than or equal to the sum of the\n    /// output pool NFTs weights. The caller must also pay a fee depending the net input weight and change fee amount.\n    /// @param inputTokenIds The token IDs of the NFTs to change.\n    /// @param inputTokenWeights The weights of the NFTs to change.\n    /// @param inputProof The merkle proof for the weights of each NFT to change.\n    /// @param stolenNftProofs The proofs that show each input NFT is not stolen.\n    /// @param outputTokenIds The token IDs of the NFTs to receive.\n    /// @param outputTokenWeights The weights of the NFTs to receive.\n    /// @param outputProof The merkle proof for the weights of each NFT to receive.\n    function change(\n        uint256[] memory inputTokenIds,\n        uint256[] memory inputTokenWeights,\n        MerkleMultiProof memory inputProof,\n        IStolenNftOracle.Message[] memory stolenNftProofs,\n        uint256[] memory outputTokenIds,\n        uint256[] memory outputTokenWeights,\n        MerkleMultiProof memory outputProof\n    ) public payable returns (uint256 feeAmount, uint256 protocolFeeAmount) {\n        // ~~~ Checks ~~~ //\n\n        // check that the caller sent 0 ETH if base token is not ETH\n        if (baseToken != address(0) && msg.value > 0) revert InvalidEthAmount();\n\n        // check that NFTs are not stolen\n        if (useStolenNftOracle) {\n            IStolenNftOracle(stolenNftOracle).validateTokensAreNotStolen(nft, inputTokenIds, stolenNftProofs);\n        }\n\n        // fix stack too deep\n        {\n            // calculate the sum of weights for the input nfts\n            uint256 inputWeightSum = sumWeightsAndValidateProof(inputTokenIds, inputTokenWeights, inputProof);\n\n            // calculate the sum of weights for the output nfts\n            uint256 outputWeightSum = sumWeightsAndValidateProof(outputTokenIds, outputTokenWeights, outputProof);\n\n            // check that the input weights are greater than or equal to the output weights\n            if (inputWeightSum < outputWeightSum) revert InsufficientInputWeight();\n\n            // calculate the fee amount\n            (feeAmount, protocolFeeAmount) = changeFeeQuote(inputWeightSum);\n        }\n\n        // ~~~ Interactions ~~~ //\n\n        if (baseToken != address(0)) {\n            // transfer the fee amount of base tokens from the caller\n            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), feeAmount);\n\n            // if the protocol fee is non-zero then transfer the protocol fee to the factory\n            if (protocolFeeAmount > 0) ERC20(baseToken).safeTransferFrom(msg.sender, factory, protocolFeeAmount);\n        } else {\n            // check that the caller sent enough ETH to cover the fee amount and protocol fee\n            if (msg.value < feeAmount + protocolFeeAmount) revert InvalidEthAmount();\n\n            // if the protocol fee is non-zero then transfer the protocol fee to the factory\n            if (protocolFeeAmount > 0) factory.safeTransferETH(protocolFeeAmount);\n\n            // refund any excess ETH to the caller\n            if (msg.value > feeAmount + protocolFeeAmount) {\n                msg.sender.safeTransferETH(msg.value - feeAmount - protocolFeeAmount);\n            }\n        }\n\n        // transfer the input nfts from the caller\n        for (uint256 i = 0; i < inputTokenIds.length; i++) {\n            ERC721(nft).safeTransferFrom(msg.sender, address(this), inputTokenIds[i]);\n        }\n\n        // transfer the output nfts to the caller\n        for (uint256 i = 0; i < outputTokenIds.length; i++) {\n            ERC721(nft).safeTransferFrom(address(this), msg.sender, outputTokenIds[i]);\n        }\n\n        // emit the change event\n        emit Change(inputTokenIds, inputTokenWeights, outputTokenIds, outputTokenWeights, feeAmount, protocolFeeAmount);\n    }\n\n    /// @notice Executes a transaction from the pool account to a target contract. The caller must be the owner of the\n    /// pool. This allows for use cases such as claiming airdrops.\n    /// @param target The address of the target contract.\n    /// @param data The data to send to the target contract.\n    /// @return returnData The return data of the transaction.\n    function execute(address target, bytes memory data) public payable onlyOwner returns (bytes memory) {\n        // call the target with the value and data\n        (bool success, bytes memory returnData) = target.call{value: msg.value}(data);\n\n        // if the call succeeded return the return data\n        if (success) return returnData;\n\n        // if we got an error bubble up the error message\n        if (returnData.length > 0) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                let returnData_size := mload(returnData)\n                revert(add(32, returnData), returnData_size)\n            }\n        } else {\n            revert();\n        }\n    }\n\n    /// @notice Deposits base tokens and NFTs into the pool. The caller must approve the pool to transfer their NFTs and\n    /// base tokens.\n    /// @dev DO NOT call this function directly unless you know what you are doing. Instead, use a wrapper contract that\n    /// will check the current price is within the desired bounds.\n    /// @param tokenIds The token IDs of the NFTs to deposit.\n    /// @param baseTokenAmount The amount of base tokens to deposit.\n    function deposit(uint256[] calldata tokenIds, uint256 baseTokenAmount) public payable {\n        // ~~~ Checks ~~~ //\n\n        // ensure the caller sent a valid amount of ETH if base token is ETH or that the caller sent 0 ETH if base token\n        // is not ETH\n        if ((baseToken == address(0) && msg.value != baseTokenAmount) || (msg.value > 0 && baseToken != address(0))) {\n            revert InvalidEthAmount();\n        }\n\n        // ~~~ Interactions ~~~ //\n\n        // transfer the nfts from the caller\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n        }\n\n        if (baseToken != address(0)) {\n            // transfer the base tokens from the caller\n            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), baseTokenAmount);\n        }\n\n        // emit the deposit event\n        emit Deposit(tokenIds, baseTokenAmount);\n    }\n\n    /// @notice Withdraws NFTs and tokens from the pool. Can only be called by the owner of the pool.\n    /// @param _nft The address of the NFT.\n    /// @param tokenIds The token IDs of the NFTs to withdraw.\n    /// @param token The address of the token to withdraw.\n    /// @param tokenAmount The amount of tokens to withdraw.\n    function withdraw(address _nft, uint256[] calldata tokenIds, address token, uint256 tokenAmount) public onlyOwner {\n        // ~~~ Interactions ~~~ //\n\n        // transfer the nfts to the caller\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ERC721(_nft).safeTransferFrom(address(this), msg.sender, tokenIds[i]);\n        }\n\n        if (token == address(0)) {\n            // transfer the ETH to the caller\n            msg.sender.safeTransferETH(tokenAmount);\n        } else {\n            // transfer the tokens to the caller\n            ERC20(token).transfer(msg.sender, tokenAmount);\n        }\n\n        // emit the withdraw event\n        emit Withdraw(_nft, tokenIds, token, tokenAmount);\n    }\n\n    /// @notice Sets the virtual base token reserves and virtual NFT reserves. Can only be called by the owner of the\n    /// pool. These parameters affect the price and liquidity depth of the pool.\n    /// @param newVirtualBaseTokenReserves The new virtual base token reserves.\n    /// @param newVirtualNftReserves The new virtual NFT reserves.\n    function setVirtualReserves(uint128 newVirtualBaseTokenReserves, uint128 newVirtualNftReserves) public onlyOwner {\n        // set the virtual base token reserves and virtual nft reserves\n        virtualBaseTokenReserves = newVirtualBaseTokenReserves;\n        virtualNftReserves = newVirtualNftReserves;\n\n        // emit the set virtual reserves event\n        emit SetVirtualReserves(newVirtualBaseTokenReserves, newVirtualNftReserves);\n    }\n\n    /// @notice Sets the merkle root. Can only be called by the owner of the pool. The merkle root is used to validate\n    /// the NFT weights.\n    /// @param newMerkleRoot The new merkle root.\n    function setMerkleRoot(bytes32 newMerkleRoot) public onlyOwner {\n        // set the merkle root\n        merkleRoot = newMerkleRoot;\n\n        // emit the set merkle root event\n        emit SetMerkleRoot(newMerkleRoot);\n    }\n\n    /// @notice Sets the fee rate. Can only be called by the owner of the pool. The fee rate is used to calculate the\n    /// fee amount when swapping or changing NFTs. The fee rate is in basis points (1/100th of a percent). For example,\n    /// 10_000 == 100%, 200 == 2%, 1 == 0.01%.\n    /// @param newFeeRate The new fee rate (in basis points)\n    function setFeeRate(uint16 newFeeRate) public onlyOwner {\n        // check that the fee rate is less than 50%\n        if (newFeeRate > 5_000) revert FeeRateTooHigh();\n\n        // set the fee rate\n        feeRate = newFeeRate;\n\n        // emit the set fee rate event\n        emit SetFeeRate(newFeeRate);\n    }\n\n    /// @notice Sets the whether or not to use the stolen NFT oracle. Can only be called by the owner of the pool. The\n    /// stolen NFT oracle is used to check if an NFT is stolen.\n    /// @param newUseStolenNftOracle The new use stolen NFT oracle flag.\n    function setUseStolenNftOracle(bool newUseStolenNftOracle) public onlyOwner {\n        // set the use stolen NFT oracle flag\n        useStolenNftOracle = newUseStolenNftOracle;\n\n        // emit the set use stolen NFT oracle event\n        emit SetUseStolenNftOracle(newUseStolenNftOracle);\n    }\n\n    /// @notice Sets the pay royalties flag. Can only be called by the owner of the pool. If royalties are enabled then\n    /// the pool will pay royalties when buying or selling NFTs.\n    /// @param newPayRoyalties The new pay royalties flag.\n    function setPayRoyalties(bool newPayRoyalties) public onlyOwner {\n        // set the pay royalties flag\n        payRoyalties = newPayRoyalties;\n\n        // emit the set pay royalties event\n        emit SetPayRoyalties(newPayRoyalties);\n    }\n\n    /// @notice Updates all parameter settings in one go.\n    /// @param newVirtualBaseTokenReserves The new virtual base token reserves.\n    /// @param newVirtualNftReserves The new virtual NFT reserves.\n    /// @param newMerkleRoot The new merkle root.\n    /// @param newFeeRate The new fee rate (in basis points)\n    /// @param newUseStolenNftOracle The new use stolen NFT oracle flag.\n    /// @param newPayRoyalties The new pay royalties flag.\n    function setAllParameters(\n        uint128 newVirtualBaseTokenReserves,\n        uint128 newVirtualNftReserves,\n        bytes32 newMerkleRoot,\n        uint16 newFeeRate,\n        bool newUseStolenNftOracle,\n        bool newPayRoyalties\n    ) public {\n        setVirtualReserves(newVirtualBaseTokenReserves, newVirtualNftReserves);\n        setMerkleRoot(newMerkleRoot);\n        setFeeRate(newFeeRate);\n        setUseStolenNftOracle(newUseStolenNftOracle);\n        setPayRoyalties(newPayRoyalties);\n    }\n\n    /// @notice Executes a flash loan.\n    /// @param receiver The receiver of the flash loan.\n    /// @param token The address of the NFT contract.\n    /// @param tokenId The ID of the NFT.\n    /// @param data The data to pass to the receiver.\n    /// @return success Whether or not the flash loan was successful.\n    function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 tokenId, bytes calldata data)\n        external\n        payable\n        returns (bool)\n    {\n        // check that the NFT is available for a flash loan\n        if (!availableForFlashLoan(token, tokenId)) revert NotAvailableForFlashLoan();\n\n        // calculate the fee\n        uint256 fee = flashFee(token, tokenId);\n\n        // if base token is ETH then check that caller sent enough for the fee\n        if (baseToken == address(0) && msg.value < fee) revert InvalidEthAmount();\n\n        // transfer the NFT to the borrower\n        ERC721(token).safeTransferFrom(address(this), address(receiver), tokenId);\n\n        // call the borrower\n        bool success =\n            receiver.onFlashLoan(msg.sender, token, tokenId, fee, data) == keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n        // check that flashloan was successful\n        if (!success) revert FlashLoanFailed();\n\n        // transfer the NFT from the borrower\n        ERC721(token).safeTransferFrom(address(receiver), address(this), tokenId);\n\n        // transfer the fee from the borrower\n        if (baseToken != address(0)) ERC20(baseToken).transferFrom(msg.sender, address(this), fee);\n\n        return success;\n    }\n\n    /// @notice Sums the weights of each NFT and validates that the weights are correct by verifying the merkle proof.\n    /// @param tokenIds The token IDs of the NFTs to sum the weights for.\n    /// @param tokenWeights The weights of each NFT in the token IDs array.\n    /// @param proof The merkle proof for the weights of each NFT.\n    /// @return sum The sum of the weights of each NFT.\n    function sumWeightsAndValidateProof(\n        uint256[] memory tokenIds,\n        uint256[] memory tokenWeights,\n        MerkleMultiProof memory proof\n    ) public view returns (uint256) {\n        // if the merkle root is not set then set the weight of each nft to be 1e18\n        if (merkleRoot == bytes32(0)) {\n            return tokenIds.length * 1e18;\n        }\n\n        uint256 sum;\n        bytes32[] memory leafs = new bytes32[](tokenIds.length);\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            // create the leaf for the merkle proof\n            leafs[i] = keccak256(bytes.concat(keccak256(abi.encode(tokenIds[i], tokenWeights[i]))));\n\n            // sum each token weight\n            sum += tokenWeights[i];\n        }\n\n        // validate that the weights are valid against the merkle proof\n        if (!MerkleProofLib.verifyMultiProof(proof.proof, merkleRoot, leafs, proof.flags)) {\n            revert InvalidMerkleProof();\n        }\n\n        return sum;\n    }\n\n    /// @notice Returns the required input of buying a given amount of NFTs inclusive of the fee which is dependent on\n    /// the currently set fee rate.\n    /// @param outputAmount The amount of NFTs to buy multiplied by 1e18.\n    /// @return netInputAmount The required input amount of base tokens inclusive of the fee.\n    /// @return feeAmount The fee amount.\n    function buyQuote(uint256 outputAmount)\n        public\n        view\n        returns (uint256 netInputAmount, uint256 feeAmount, uint256 protocolFeeAmount)\n    {\n        // calculate the input amount based on xy=k invariant and round up by 1 wei\n        uint256 inputAmount =\n            FixedPointMathLib.mulDivUp(outputAmount, virtualBaseTokenReserves, (virtualNftReserves - outputAmount));\n\n        protocolFeeAmount = inputAmount * Factory(factory).protocolFeeRate() / 10_000;\n        feeAmount = inputAmount * feeRate / 10_000;\n        netInputAmount = inputAmount + feeAmount + protocolFeeAmount;\n    }\n\n    /// @notice Returns the output amount of selling a given amount of NFTs inclusive of the fee which is dependent on\n    /// the currently set fee rate.\n    /// @param inputAmount The"
    }
  ]
}