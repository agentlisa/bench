{
  "Title": "We recommend adding an additional parameter when registering an event",
  "Content": "##### Description\nAt the line https://github.com/pie-dao/ExperiPie/blob/facf3c246d9c43f5b1e0bad7dc2b0a9a2a2393c5/contracts/facets/Call/CallFacet.sol#L101 calling the `_call()` function performs any action with any contracts.\nHowever, the `Call` event does not store who called the function.\n\n##### Recommendation\nWe recommend adding one more parameter to save the value of `msg.sender`.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/facets/Call/CallFacet.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\nimport \"diamond-2/contracts/libraries/LibDiamond.sol\";\nimport \"../../interfaces/ICallFacet.sol\";\nimport \"../shared/Reentry/ReentryProtection.sol\";\nimport \"../shared/Access/CallProtection.sol\";\nimport \"./LibCallStorage.sol\";\n\ncontract CallFacet is ReentryProtection, ICallFacet {\n\n  // uses modified call protection modifier to also allow whitelisted addresses to call\n  modifier protectedCall() {\n    require(\n        msg.sender == LibDiamond.diamondStorage().contractOwner ||\n        LibCallStorage.callStorage().canCall[msg.sender] ||\n        msg.sender == address(this), \"NOT_ALLOWED\"\n    );\n    _;\n  }\n\n  function addCaller(address _caller) external override {\n    require(msg.sender == LibDiamond.diamondStorage().contractOwner, \"NOT_ALLOWED\");\n    LibCallStorage.CallStorage storage callStorage = LibCallStorage.callStorage();\n\n    require(!callStorage.canCall[_caller], \"IS_ALREADY_CALLER\");\n\n    callStorage.callers.push(_caller);\n    callStorage.canCall[_caller] = true;\n\n    emit CallerAdded(_caller);\n  }\n\n  function removeCaller(address _caller) external override {\n    require(msg.sender == LibDiamond.diamondStorage().contractOwner, \"NOT_ALLOWED\");\n    LibCallStorage.CallStorage storage callStorage = LibCallStorage.callStorage();\n\n    require(callStorage.canCall[_caller], \"IS_NOT_CALLER\");\n\n    callStorage.canCall[_caller] = false;\n\n    for(uint256 i = 0; i < callStorage.callers.length; i ++) {\n      address currentCaller = callStorage.callers[i];\n\n      // if found remove it\n      if(currentCaller == _caller) {\n        callStorage.callers[i] = callStorage.callers[callStorage.callers.length - 1];\n        callStorage.callers.pop();\n        break;\n      }\n    }\n\n    emit CallerRemoved(_caller);\n  }\n\n  function call(\n    address[] memory _targets,\n    bytes[] memory _calldata,\n    uint256[] memory _values\n  ) public override noReentry protectedCall {\n    require(\n      _targets.length == _calldata.length && _values.length == _calldata.length,\n      \"ARRAY_LENGTH_MISMATCH\"\n    );\n\n    for (uint256 i = 0; i < _targets.length; i++) {\n      _call(_targets[i], _calldata[i], _values[i]);\n    }\n  }\n\n  function callNoValue(\n    address[] memory _targets,\n    bytes[] memory _calldata\n  ) public override noReentry protectedCall {\n    require(\n      _targets.length == _calldata.length,\n      \"ARRAY_LENGTH_MISMATCH\"\n    );\n\n    for (uint256 i = 0; i < _targets.length; i++) {\n      _call(_targets[i], _calldata[i], 0);\n    }\n  }\n\n  function singleCall(\n    address _target,\n    bytes calldata _calldata,\n    uint256 _value\n  ) external override noReentry protectedCall {\n    _call(_target, _calldata, _value);\n  }\n\n  function _call(\n    address _target,\n    bytes memory _calldata,\n    uint256 _value\n  ) internal {\n    (bool success, ) = _target.call{ value: _value }(_calldata);\n    require(success, \"CALL_FAILED\");\n    emit Call(_target, _calldata, _value);\n  }\n\n  function canCall(address _caller) external view override returns (bool) {\n    return LibCallStorage.callStorage().canCall[_caller];\n  }\n\n  function getCallers() external view override returns (address[] memory) {\n    return LibCallStorage.callStorage().callers;\n  }\n}"
    }
  ]
}