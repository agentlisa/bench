{
  "Title": "H-1: All migrated withdrarwals that require more than 135,175 gas may be bricked",
  "Content": "# Issue H-1: All migrated withdrarwals that require more than 135,175 gas may be bricked \n\nSource: https://github.com/sherlock-audit/2023-03-optimism-judging/issues/93 \n\n## Found by \nobront\n\n## Summary\n\nMigrated withdrawals are given an \"outer\" (Portal) gas limit of `calldata cost + 200,000`, and an \"inner\" (CrossDomainMessenger) gas limit of `0`. The assumption is that the CrossDomainMessenger is replayable, so there is no need to specify a correct gas limit.\n\nThis is an incorect assumption. For any withdrawals that require more than 135,175 gas, insufficient gas can be sent such that CrossDomainMessenger's external call reverts and the remaining 1/64th of the gas sent is not enough for replayability to be encoded in the Cross Domain Messenger.\n\nHowever, the remaining 1/64th of gas in the Portal is sufficient to have the transaction finalize, so that the Portal will not process the withdrawal again.\n\n## Vulnerability Detail\n\nWhen old withdrawals are migrated to Bedrock, they are encoded as calls to `L1CrossDomainMessenger.relayMessage()` as follows:\n\n```go\nfunc MigrateWithdrawal(withdrawal *LegacyWithdrawal, l1CrossDomainMessenger *common.Address) (*Withdrawal, error) {\n\t// Attempt to parse the value\n\tvalue, err := withdrawal.Value()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot migrate withdrawal: %w\", err)\n\t}\n\n\tabi, err := bindings.L1CrossDomainMessengerMetaData.GetAbi()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Migrated withdrawals are specified as version 0. Both the\n\t// L2ToL1MessagePasser and the CrossDomainMessenger use the same\n\t// versioning scheme. Both should be set to version 0\n\tversionedNonce := EncodeVersionedNonce(withdrawal.XDomainNonce, new(big.Int))\n\t// Encode the call to `relayMessage` on the `CrossDomainMessenger`.\n\t// The minGasLimit can safely be 0 here.\n\tdata, err := abi.Pack(\n\t\t\"relayMessage\",\n\t\tversionedNonce,\n\t\twithdrawal.XDomainSender,\n\t\twithdrawal.XDomainTarget,\n\t\tvalue,\n\t\tnew(big.Int), // <= THIS IS THE INNER GAS LIMIT BEING SET TO ZERO\n\t\t[]byte(withdrawal.XDomainData),\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot abi encode relayMessage: %w\", err)\n\t}\n\n\tgasLimit := MigrateWithdrawalGasLimit(data)\n\n\tw := NewWithdrawal(\n\t\tversionedNonce,\n\t\t&predeploys.L2CrossDomainMessengerAddr,\n\t\tl1CrossDomainMessenger,\n\t\tvalue,\n\t\tnew(big.Int).SetUint64(gasLimit), // <= THIS IS THE OUTER GAS LIMIT BEING SET\n\t\tdata,\n\t)\n\treturn w, nil\n}\n```\n\nAs we can see, the `relayMessage()` call uses a gasLimit of zero (see comments above), while the outer gas limit is calculated by the `MigrateWithdrawalGasLimit()` function:\n\n```go\nfunc MigrateWithdrawalGasLimit(data []byte) uint64 {\n\t// Compute the cost of the calldata\n\tdataCost := uint64(0)\n\tfor _, b := range data {\n\t\tif b == 0 {\n\t\t\tdataCost += params.TxDataZeroGas\n\t\t} else {\n\t\t\tdataCost += params.TxDataNonZeroGasEIP2028\n\t\t}\n\t}\n\n\t// Set the outer gas limit. This cannot be zero\n\tgasLimit := dataCost + 200_000\n\t// Cap the gas limit to be 25 million to prevent creating withdrawals\n\t// that go over the block gas limit.\n\tif gasLimit > 25_000_000 {\n\t\tgasLimit = 25_000_000\n\t}\n\n\treturn gasLimit\n}\n```\nThis calculates the outer gas limit value by adding the calldata cost to 200,000.\n\nLet's move over to the scenario in which these values are used to see why they can cause a problem.\n\nWhen a transaction is proven, we can call `OptimismPortal.finalizeWithdrawalTransaction()` to execute the transaction. In the case of migrated withdrawals, this executes the following flow:\n- `OptimismPortal` calls to `L1CrossDomainMessenger` with a gas limit of `200,000 + calldata`\n- This guarantees remaining gas for continued execution after the call of `(200_000 + calldata) * 64/63 * 1/64 > 3174`\n- XDM uses `41,002` gas before making the call, leaving `158,998` remaining for the call\n- The `SafeCall.callWithMinGas()` succeeds, since the inner gas limit is set to 0\n- If the call uses up all of the avaialble gas (succeeding or reverting), we are left with `158,998 * 1/64 = 2,484` for the remaining execution\n- The remaining execution includes multiple SSTOREs which totals `23,823` gas, resulting in an OutOfGas revert\n- In fact, if the call uses any amount greater than `135,175`, we will have less than `23,823` gas remaining and will revert\n- As a result, none of the updates to `L1CrossDomainMessenger` occur, and the transaction is not marked in `failedMessages` for replayability\n- However, the remaining `3174` gas is sufficient to complete the transction on the `OptimismPortal`, which sets `finalizedWithdrawals[hash] = true` and locks the withdrawals from ever being made again\n\n## Impact\n\nAny migrated withdrawal that uses more than `135,175` gas will be bricked if insufficient gas is sent. This could be done by a malicious attacker bricking thousands of pending withdrawals or, more likely, could happen to users who accidentally executed their withdrawal with too little gas and ended up losing it permanently.\n\n## Code Snippet\n\nhttps://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/op-chain-ops/crossdomain/migrate.go#L55-L97\n\nhttps://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/op-chain-ops/crossdomain/migrate.go#L99-L119\n\nhttps://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/packages/contracts-bedrock/contracts/L1/OptimismPortal.sol#L315-L412\n\nhttps://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/packages/contracts-bedrock/contracts/universal/CrossDomainMessenger.sol#L291-L383\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThere doesn't seem to be an easy fix for this, except to adjust the migration process so that migrated withdrawals are directly saved as `failedMessages` on the `L1CrossDomainMessenger` (and marked as `finalizedWithdrawals` on the `OptimismPortal`), rather than needing to be reproven through the normal flow.\n\n\n\n## Discussion\n\n**maurelian**\n\nValid but we believe it to be a medium. There definitely exist edge cases of transactions where this is an issue but the majority of transactions it is not an issue.\n\nBased on the following call trace for a finalization of a withdrawal transaction + the address mapping, we believe that this issue is unable to impact transactions transferring ERC20 tokens through the bridge. \n\n```\n{\n  \"from\": \"0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266\",\n  \"gas\": \"0x73bdc\",\n  \"gasUsed\": \"0x3ebbe\",\n  \"to\": \"0x5fc8d32690cc91d4c39d9d3abcbd16989f875707\",\n  \"input\": \"0x8c3152e9000000000000000000000000000000000000000000000000000000000000002000010000000000000000000000000000000000000000000000000000000000000000000000000000000000004200000000000000000000000000000000000007000000000000000000000000dc64a140aa3e981100a9beca4e685f962f0cf6c900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000031b8000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000001e4d764ad0b000100000000000000000000000000000000000000000000000000000000000000000000000000000000000042000000000000000000000000000000000000100000000000000000000000009fe46736679d2d9a65f0992f2272de9f3c7fa6e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000e40166a07a000000000000000000000000e6e340d132b5f46d1e472debcd681b2abc16e57e0000000000000000000000007c6b91d9be155a6db01f749217d76ff02a7227f2000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb922660000000000000000000000000000000000000000000000000de0b6b3a764000000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n  \"calls\": [\n    {\n      \"from\": \"0x5fc8d32690cc91d4c39d9d3abcbd16989f875707\",\n      \"gas\": \"0x70b60\",\n      \"gasUsed\": \"0x3fb97\",\n      \"to\": \"0x0dcd1bf9a1b36ce34237eeafef220932846bcd82\",\n      \"input\": \"0x8c3152e9000000000000000000000000000000000000000000000000000000000000002000010000000000000000000000000000000000000000000000000000000000000000000000000000000000004200000000000000000000000000000000000007000000000000000000000000dc64a140aa3e981100a9beca4e685f962f0cf6c900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000031b8000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000001e4d764ad0b000100000000000000000000000000000000000000000000000000000000000000000000000000000000000042000000000000000000000000000000000000100000000000000000000000009fe46736679d2d9a65f0992f2272de9f3c7fa6e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000e40166a07a000000000000000000000000e6e340d132b5f46d1e472debcd681b2abc16e57e0000000000000000000000007c6b91d9be155a6db01f749217d76ff02a7227f2000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb922660000000000000000000000000000000000000000000000000de0b6b3a764000000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n      \"calls\": [\n        {\n          \"from\": \"0x5fc8d32690cc91d4c39d9d3abcbd16989f875707\",\n          \"gas\": \"0x6b7b4\",\n          \"gasUsed\": \"0x1c91\",\n          \"to\": \"0xcf7ed3acca5a467e9e704c703e8d87f634fb0fc9\",\n          \"input\": \"0x88786272\",\n          \"output\": \"0x0000000000000000000000000000000000000000000000000000000064370353\",\n          \"calls\": [\n            {\n              \"from\": \"0xcf7ed3acca5a467e9e704c703e8d87f634fb0fc9\",\n              \"gas\": \"0x689d2\",\n              \"gasUsed\": \"0x91a\",\n              \"to\": \"0xa51c1fc2f0d1a1b8494ed1fe312d7c3a78ed91c0\",\n              \"input\": \"0x88786272\",\n              \"output\": \"0x0000000000000000000000000000000000000000000000000000000064370353\",\n              \"value\": \"0x0\",\n              \"type\": \"DELEGATECALL\"\n            }\n          ],\n          \"type\": \"STATICCALL\"\n        },\n        {\n          \"from\": \"0x5fc8d32690cc91d4c39d9d3abcbd16989f875707\",\n          \"gas\": \"0x69a01\",\n          \"gasUsed\": \"0x2f3\",\n          \"to\": \"0xcf7ed3acca5a467e9e704c703e8d87f634fb0fc9\",\n          \"input\": \"0xf4daa291\",\n          \"output\": \"0x0000000000000000000000000000000000000000000000000000000000000002\",\n          \"calls\": [\n            {\n              \"from\": \"0xcf7ed3acca5a467e9e704c703e8d87f634fb0fc9\",\n              \"gas\": \"0x67de3\",\n              \"gasUsed\": \"0x110\",\n              \"to\": \"0xa51c1fc2f0d1a1b8494ed1fe312d7c3a78ed91c0\",\n              \"input\": \"0xf4daa291\",\n              \"output\": \"0x0000000000000000000000000000000000000000000000000000000000000002\",\n              \"value\": \"0x0\",\n              \"type\": \"DELEGATECALL\"\n            }\n          ],\n          \"type\": \"STATICCALL\"\n        },\n        {\n          \"from\": \"0x5fc8d32690cc91d4c39d9d3abcbd16989f875707\",\n          \"gas\": \"0x6953a\",\n          \"gasUsed\": \"0x1d86\",\n          \"to\": \"0xcf7ed3acca5a467e9e704c703e8d87f634fb0fc9\",\n          \"input\": \"0xa25ae557000000000000000000000000000000000000000000000000000000000000000b\",\n          \"output\": \"0x3cef4cf4a4886782e55500db2d25325cb17007808ba2d44e0e37e7194f485da2000000000000000000000000000000000000000000000000000000006437057000000000000000000000000000000000000000000000000000000000000000f0\",\n          \"calls\": [\n            {\n              \"from\": \"0xcf7ed3acca5a467e9e704c703e8d87f634fb0fc9\",\n              \"gas\": \"0x6792d\",\n              \"gasUsed\": \"0x1b9a\",\n              \"to\": \"0xa51c1fc2f0d1a1b8494ed1fe312d7c3a78ed91c0\",\n              \"input\": \"0xa25ae557000000000000000000000000000000000000000000000000000000000000000b\",\n              \"output\": \"0x3cef4cf4a4886782e55500db2d25325cb17007808ba2d44e0e37e7194f485da2000000000000000000000000000000000000000000000000000000006437057000000000000000000000000000000000000000000000000000000000000000f0\",\n              \"value\": \"0x0\",\n              \"type\": \"DELEGATECALL\"\n            }\n          ],\n          \"type\": \"STATICCALL\"\n        },\n        {\n          \"from\": \"0x5fc8d32690cc91d4c39d9d3abcbd16989f875707\",\n          \"gas\": \"0x6759c\",\n          \"gasUsed\": \"0x2f3\",\n          \"to\": \"0xcf7ed3acca5a467e9e704c703e8d87f634fb0fc9\",\n          \"input\": \"0xf4daa291\",\n          \"output\": \"0x0000000000000000000000000000000000000000000000000000000000000002\",\n          \"calls\": [\n            {\n              \"from\": \"0xcf7ed3acca5a467e9e704c703e8d87f634fb0fc9\",\n              \"gas\": \"0x65a10\",\n              \"gasUsed\": \"0x110\",\n              \"to\": \"0xa51c1fc2f0d1a1b8494ed1fe312d7c3a78ed91c0\",\n              \"input\": \"0xf4daa291\",\n              \"output\": \"0x0000000000000000000000000000000000000000000000000000000000000002\",\n              \"value\": \"0x0\",\n              \"type\": \"DELEGATECALL\"\n            }\n          ],\n          \"type\": \"STATICCALL\"\n        },\n        {\n          \"from\": \"0x5fc8d32690cc91d4c39d9d3abcbd16989f875707\",\n          \"gas\": \"0x6053e\",\n          \"gasUsed\": \"0x306f9\",\n          \"to\": \"0xdc64a140aa3e981100a9beca4e685f962f0cf6c9\",\n          \"input\": \"0xd764ad0b000100000000000000000000000000000000000000000000000000000000000000000000000000000000000042000000000000000000000000000000000000100000000000000000000000009fe46736679d2d9a65f0992f2272de9f3c7fa6e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000e40166a07a000000000000000000000000e6e340d132b5f46d1e472debcd681b2abc16e57e0000000000000000000000007c6b91d9be155a6db01f749217d76ff02a7227f2000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb922660000000000000000000000000000000000000000000000000de0b6b3a764000000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n          \"calls\": [\n            {\n              \"from\": \"0xdc64a140aa3e981100a9beca4e685f962f0cf6c9\",\n              \"gas\": \"0x5d111\",\n              \"gasUsed\": \"0xc8d\",\n              \"to\": \"0xe7f1725e7734ce288f8367e1bb143e90bb3f0512\",\n              \"input\": \"0xbf40fac10000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001a4f564d5f4c3143726f7373446f6d61696e4d657373656e676572000000000000\",\n              \"output\": \"0x000000000000000000000000610178da211fef7d417bc0e6fed39f05609ad788\",\n              \"type\": \"STATICCALL\"\n            },\n            {\n              \"from\": \"0xdc64a140aa3e981100a9beca4e685f962f0cf6c9\",\n              \"gas\": \"0x5b909\",\n              \"gasUsed\": \"0x2d19f\",\n              \"to\": \"0x610178da211fef7d417bc0e6fed39f05609ad788\",\n              \"input\": \"0xd764ad0b000100000000000000000000000000000000000000000000000000000000000000000000000000000000000042000000000000000000000000000000000000100000000000000000000000009fe46736679d2d9a65f0992f2272de9f3c7fa6e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000e40166a07a000000000000000000000000e6e340d132b5f46d1e472debcd681b2abc16e57e0000000000000000000000007c6b91d9be155a6db01f749217d76ff02a7227f2000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb922660000000000000000000000000000000000000000000000000de0b6b3a764000000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n              \"calls\": [\n                {\n                  \"from\": \"0xdc64a140aa3e981100a9beca4e685f962f0cf6c9\",\n                  \"gas\": \"0x54236\",\n                  \"gasUsed\": \"0x354\",\n                  \"to\": \"0x5fc8d32690cc91d4c39d9d3abcbd16989f875707\",\n                  \"input\": \"0x9bf62d82\",\n                  \"output\": \"0x0000000000000000000000004200000000000000000000000000000000000007\",\n                  \"calls\": [\n                    {\n                      \"from\": \"0x5fc8d32690cc91d4c39d9d3abcbd16989f875707\",\n                      \"gas\": \"0x52b78\",\n                      \"gasUsed\": \"0x171\",\n                      \"to\": \"0x0dcd1bf9a1b36ce34237eeafef220932846bcd82\",\n                      \"input\": \"0x9bf62d82\",\n                      \"output\": \"0x0000000000000000000000004200000000000000000000000000000000000007\",\n                      \"value\": \"0x0\",\n                      \"type\": \"DELEGATECALL\"\n                    }\n                  ],\n                  \"type\": \"STATICCALL\"\n                },\n                {\n                  \"from\": \"0xdc64a140aa3e981100a9beca4e685f962f0cf6c9\",\n                  \"gas\": \"0x50df0\",\n                  \"gasUsed\": \"0x1e56d\",\n                  \"to\": \"0x9fe46736679d2d9a65f0992f2272de9f3c7fa6e0\",\n                  \"input\": \"0x0166a07a000000000000000000000000e6e340d132b5f46d1e472debcd681b2abc16e57e0000000000000000000000007c6b91d9be155a6db01f749217d76ff02a7227f2000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb922660000000000000000000000000000000000000000000000000de0b6b3a764000000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000000\",\n                  \"calls\": [\n                    {\n                      \"from\": \"0x9fe46736679d2d9a65f0992f2272de9f3c7fa6e0\",\n                      \"gas\": \"0x4e57f\",\n                      \"gasUsed\": \"0x92b\",\n                      \"to\": \"0x5fbdb2315678afecb367f032d93f642f64180aa3\",\n                      \"input\": \"0xb7947262\",\n                      \"output\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n                      \"type\": \"STATICCALL\"\n                    },\n                    {\n                      \"from\": \"0x9fe46736679d2d9a65f0992f2272de9f3c7fa6e0\",\n                      \"gas\": \"0x4c8cb\",\n                      \"gasUsed\": \"0x1b395\", // <--- HERE\n                      \"to\": \"0xb7f8bc63bbcad18155201308c8f3540b07f84f5e\",\n                      \"input\": \"0x0166a07a000000000000000000000000e6e340d132b5f46d1e472debcd681b2abc16e57e0000000000000000000000007c6b91d9be155a6db01f749217d76ff02a7227f2000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb922660000000000000000000000000000000000000000000000000de0b6b3a764000000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000000\",\n                      \"calls\": [\n                        {\n                          \"from\": \"0x9fe46736679d2d9a65f0992f2272de9f3c7fa6e0\",\n                          \"gas\": \"0x4b1b5\",\n                          \"gasUsed\": \"0xc75\",\n                          \"to\": \"0xdc64a140aa3e981100a9beca4e685f962f0cf6c9\",\n                          \"input\": \"0x6e296e45\",\n                          \"output\": \"0x0000000000000000000000004200000000000000000000000000000000000010\",\n                          \"calls\": [\n                            {\n                              \"from\": \"0xdc64a140aa3e981100a9beca4e685f962f0cf6c9\",\n                              \"gas\": \"0x49bd4\",\n                              \"gasUsed\": \"0x4bd\",\n                              \"to\": \"0xe7f1725e7734ce288f8367e1bb143e90bb3f0512\",\n                              \"input\": \"0xbf40fac10000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001a4f564d5f4c3143726f7373446f6d61696e4d657373656e676572000000000000\",\n                              \"output\": \"0x000000000000000000000000610178da211fef7d417bc0e6fed39f05609ad788\",\n                              \"type\": \"STATICCALL\"\n                            },\n                            {\n                              \"from\": \"0xdc64a140aa3e981100a9beca4e685f962f0cf6c9\",\n                              \"gas\": \"0x49570\",\n                              \"gasUsed\": \"0x224\",\n                              \"to\": \"0x610178da211fef7d417bc0e6fed39f05609ad788\",\n                              \"input\": \"0x6e296e45\",\n                              \"output\": \"0x0000000000000000000000004200000000000000000000000000000000000010\",\n                              \"value\": \"0x0\",\n                              \"type\": \"DELEGATECALL\"\n                            }\n                          ],\n                          \"type\": \"STATICCALL\"\n                        },\n                        {\n                          \"from\": \"0x9fe46736679d2d9a65f0992f2272de9f3c7fa6e0\",\n                          \"gas\": \"0x7530\",\n                          \"gasUsed\": \"0x7530\",\n                          \"to\": \"0xe6e340d132b5f46d1e472debcd681b2abc16e57e\",\n                          \"input\": \"0x01ffc9a701ffc9a700000000000000000000000000000000000000000000000000000000\",\n                          \"error\": \"write protection\",\n                          \"type\": \"STATICCALL\"\n                        },\n                        {\n                          \"from\": \"0x9fe46736679d2d9a65f0992f2272de9f3c7fa6e0\",\n                          \"gas\": \"0x7530\",\n                          \"gasUsed\": \"0x7530\",\n                          \"to\": \"0xe6e340d132b5f46d1e472debcd681b2abc16e57e\",\n                          \"input\": \"0x01ffc9a701ffc9a700000000000000000000000000000000000000000000000000000000\",\n                          \"error\": \"write protection\",\n                          \"type\": \"STATICCALL\"\n                        },\n                        {\n                          \"from\": \"0x9fe46736679d2d9a65f0992f2272de9f3c7fa6e0\",\n                          \"gas\": \"0x39714\",\n                          \"gasUsed\": \"0x7405\",\n                          \"to\": \"0xe6e340d132b5f46d1e472debcd681b2abc16e57e\",\n                          \"input\": \"0xa9059cbb000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb922660000000000000000000000000000000000000000000000000de0b6b3a7640000\",\n                          \"output\": \"0x0000000000000000000000000000000000000000000000000000000000000001\",\n                          \"value\": \"0x0\",\n                          \"type\": \"CALL\"\n                        }\n                      ],\n                      \"value\": \"0x0\",\n                      \"type\": \"DELEGATECALL\"\n                    }\n                  ],\n                  \"value\": \"0x0\",\n                  \"type\": \"CALL\"\n                }\n              ],\n              \"value\": \"0x0\",\n              \"type\": \"DELEGATECALL\"\n            }\n          ],\n          \"value\": \"0x0\",\n          \"type\": \"CALL\"\n        }\n      ],\n      \"value\": \"0x0\",\n      \"type\": \"DELEGATECALL\"\n    }\n  ],\n  \"value\": \"0x0\",\n  \"type\": \"CALL\"\n}\n```\n\n**GalloDaSballo**\n\nWould suggest checking for known withdrawals and seeing if this can be a concern (and raising to High in that case)\n\nThe conditionality leads me to agree with Med\n\n**GalloDaSballo**\n\nSample list of withdrawals\nhttps://gist.github.com/GalloDaSballo/66d73fb9d2f5fdf904349406ceb5ebfb\n\nAnnotated Gas Consumption of integrations\nhttps://gist.github.com/GalloDaSballo/9dd42b901528f31fe8db244cfb1ef514\nhttps://gist.github.com/GalloDaSballo/f27d5a6cf7bd0ec7dd03b5de7d3bcdaf\n\nI believe there are some cases in which the above txs, which have corresponding events, will require more than 135k gas meaning they are subject to the attack\n\n**GalloDaSballo**\n\nI think this is a valid example:\nhttps://explorer.phalcon.xyz/tx/eth/0x610d1ca15b934970949f138a6e11847179ada6adff867621d03d220962aa5fc9?line=14\n\nrelayMessage -> does something -> send a message back\n\nContract: https://etherscan.io/address/0xcEA770441aa5eFCD3f5501b796185Ec3055A76D7/advanced#internaltx\n\n**koolexcrypto**\n\nEscalate for 10 USDC.\n\nWhile the issue is creatively accurate with the specified gas values, it still requires certain conditions to be feasbile (e.g. only withdrarwals require more than 135,175 gas).\n\nAccording to [Sherlock's Criteria](https://docs.sherlock.xyz/audits/judging/judging#how-to-identify-a-medium-issue), it is a valid medium.\n> Causes a loss of funds but requires certain external conditions or specific states\n\nLastly, all the respect to the good efforts put in behind this finding.\n\n\n**sherlock-admin**\n\n > Escalate for 10 USDC.\n> \n> While the issue is creatively accurate with the specified gas values, it still requires certain conditions to be feasbile (e.g. only withdrarwals require more than 135,175 gas).\n> \n> According to [Sherlock's Criteria](https://docs.sherlock.xyz/audits/judging/judging#how-to-identify-a-medium-issue), it is a valid medium.\n> > Causes a loss of funds but requires certain external conditions or specific states\n> \n> Lastly, all the respect to the good efforts put in behind this finding.\n> \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation rejected\n\nLead Judge comment:\n```\nMaintain High Severity because while the condition is necessary it is not up to the user to decide whether that requirement was met but rather the requirement is imposed by the script \n```\nThis is a valid flaw in the system due to an incorrect assumption. \n\n\n**sherlock-admin**\n\n> Escalation rejected\n> \n> Lead Judge comment:\n> ```\n> Maintain High Severity because while the condition is necessary it is not up to the user to decide whether that requirement was met but rather the requirement is imposed by the script \n> ```\n> This is a valid flaw in the system due to an incorrect assumption. \n> \n\nThis issue's escalations have been rejected!\n\nWatsons who escalated this issue will have their escalation amount deducted from their next payout.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/63",
  "Code": [
    {
      "filename": "op-chain-ops/crossdomain/migrate.go",
      "content": "package crossdomain\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math/big\"\n\n\t\"github.com/ethereum-optimism/optimism/op-bindings/bindings\"\n\t\"github.com/ethereum-optimism/optimism/op-bindings/predeploys\"\n\n\t\"github.com/ethereum/go-ethereum/common\"\n\t\"github.com/ethereum/go-ethereum/core/vm\"\n\t\"github.com/ethereum/go-ethereum/log\"\n\t\"github.com/ethereum/go-ethereum/params\"\n)\n\nvar (\n\tabiTrue                      = common.Hash{31: 0x01}\n\terrLegacyStorageSlotNotFound = errors.New(\"cannot find storage slot\")\n)\n\n// MigrateWithdrawals will migrate a list of pending withdrawals given a StateDB.\nfunc MigrateWithdrawals(withdrawals SafeFilteredWithdrawals, db vm.StateDB, l1CrossDomainMessenger *common.Address, noCheck bool) error {\n\tfor i, legacy := range withdrawals {\n\t\tlegacySlot, err := legacy.StorageSlot()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif !noCheck {\n\t\t\tlegacyValue := db.GetState(predeploys.LegacyMessagePasserAddr, legacySlot)\n\t\t\tif legacyValue != abiTrue {\n\t\t\t\treturn fmt.Errorf(\"%w: %s\", errLegacyStorageSlotNotFound, legacySlot)\n\t\t\t}\n\t\t}\n\n\t\twithdrawal, err := MigrateWithdrawal(legacy, l1CrossDomainMessenger)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tslot, err := withdrawal.StorageSlot()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"cannot compute withdrawal storage slot: %w\", err)\n\t\t}\n\n\t\tdb.SetState(predeploys.L2ToL1MessagePasserAddr, slot, abiTrue)\n\t\tlog.Info(\"Migrated withdrawal\", \"number\", i, \"slot\", slot)\n\t}\n\treturn nil\n}\n\n// MigrateWithdrawal will turn a LegacyWithdrawal into a bedrock\n// style Withdrawal.\nfunc MigrateWithdrawal(withdrawal *LegacyWithdrawal, l1CrossDomainMessenger *common.Address) (*Withdrawal, error) {\n\t// Attempt to parse the value\n\tvalue, err := withdrawal.Value()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot migrate withdrawal: %w\", err)\n\t}\n\n\tabi, err := bindings.L1CrossDomainMessengerMetaData.GetAbi()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Migrated withdrawals are specified as version 0. Both the\n\t// L2ToL1MessagePasser and the CrossDomainMessenger use the same\n\t// versioning scheme. Both should be set to version 0\n\tversionedNonce := EncodeVersionedNonce(withdrawal.XDomainNonce, new(big.Int))\n\t// Encode the call to `relayMessage` on the `CrossDomainMessenger`.\n\t// The minGasLimit can safely be 0 here.\n\tdata, err := abi.Pack(\n\t\t\"relayMessage\",\n\t\tversionedNonce,\n\t\twithdrawal.XDomainSender,\n\t\twithdrawal.XDomainTarget,\n\t\tvalue,\n\t\tnew(big.Int),\n\t\t[]byte(withdrawal.XDomainData),\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot abi encode relayMessage: %w\", err)\n\t}\n\n\tgasLimit := MigrateWithdrawalGasLimit(data)\n\n\tw := NewWithdrawal(\n\t\tversionedNonce,\n\t\t&predeploys.L2CrossDomainMessengerAddr,\n\t\tl1CrossDomainMessenger,\n\t\tvalue,\n\t\tnew(big.Int).SetUint64(gasLimit),\n\t\tdata,\n\t)\n\treturn w, nil\n}\n\nfunc MigrateWithdrawalGasLimit(data []byte) uint64 {\n\t// Compute the cost of the calldata\n\tdataCost := uint64(0)\n\tfor _, b := range data {\n\t\tif b == 0 {\n\t\t\tdataCost += params.TxDataZeroGas\n\t\t} else {\n\t\t\tdataCost += params.TxDataNonZeroGasEIP2028\n\t\t}\n\t}\n\n\t// Set the outer gas limit. This cannot be zero\n\tgasLimit := dataCost + 200_000\n\t// Cap the gas limit to be 25 million to prevent creating withdrawals\n\t// that go over the block gas limit.\n\tif gasLimit > 25_000_000 {\n\t\tgasLimit = 25_000_000\n\t}\n\n\treturn gasLimit\n}"
    },
    {
      "filename": "op-chain-ops/crossdomain/migrate.go",
      "content": "package crossdomain\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math/big\"\n\n\t\"github.com/ethereum-optimism/optimism/op-bindings/bindings\"\n\t\"github.com/ethereum-optimism/optimism/op-bindings/predeploys\"\n\n\t\"github.com/ethereum/go-ethereum/common\"\n\t\"github.com/ethereum/go-ethereum/core/vm\"\n\t\"github.com/ethereum/go-ethereum/log\"\n\t\"github.com/ethereum/go-ethereum/params\"\n)\n\nvar (\n\tabiTrue                      = common.Hash{31: 0x01}\n\terrLegacyStorageSlotNotFound = errors.New(\"cannot find storage slot\")\n)\n\n// MigrateWithdrawals will migrate a list of pending withdrawals given a StateDB.\nfunc MigrateWithdrawals(withdrawals SafeFilteredWithdrawals, db vm.StateDB, l1CrossDomainMessenger *common.Address, noCheck bool) error {\n\tfor i, legacy := range withdrawals {\n\t\tlegacySlot, err := legacy.StorageSlot()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif !noCheck {\n\t\t\tlegacyValue := db.GetState(predeploys.LegacyMessagePasserAddr, legacySlot)\n\t\t\tif legacyValue != abiTrue {\n\t\t\t\treturn fmt.Errorf(\"%w: %s\", errLegacyStorageSlotNotFound, legacySlot)\n\t\t\t}\n\t\t}\n\n\t\twithdrawal, err := MigrateWithdrawal(legacy, l1CrossDomainMessenger)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tslot, err := withdrawal.StorageSlot()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"cannot compute withdrawal storage slot: %w\", err)\n\t\t}\n\n\t\tdb.SetState(predeploys.L2ToL1MessagePasserAddr, slot, abiTrue)\n\t\tlog.Info(\"Migrated withdrawal\", \"number\", i, \"slot\", slot)\n\t}\n\treturn nil\n}\n\n// MigrateWithdrawal will turn a LegacyWithdrawal into a bedrock\n// style Withdrawal.\nfunc MigrateWithdrawal(withdrawal *LegacyWithdrawal, l1CrossDomainMessenger *common.Address) (*Withdrawal, error) {\n\t// Attempt to parse the value\n\tvalue, err := withdrawal.Value()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot migrate withdrawal: %w\", err)\n\t}\n\n\tabi, err := bindings.L1CrossDomainMessengerMetaData.GetAbi()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Migrated withdrawals are specified as version 0. Both the\n\t// L2ToL1MessagePasser and the CrossDomainMessenger use the same\n\t// versioning scheme. Both should be set to version 0\n\tversionedNonce := EncodeVersionedNonce(withdrawal.XDomainNonce, new(big.Int))\n\t// Encode the call to `relayMessage` on the `CrossDomainMessenger`.\n\t// The minGasLimit can safely be 0 here.\n\tdata, err := abi.Pack(\n\t\t\"relayMessage\",\n\t\tversionedNonce,\n\t\twithdrawal.XDomainSender,\n\t\twithdrawal.XDomainTarget,\n\t\tvalue,\n\t\tnew(big.Int),\n\t\t[]byte(withdrawal.XDomainData),\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot abi encode relayMessage: %w\", err)\n\t}\n\n\tgasLimit := MigrateWithdrawalGasLimit(data)\n\n\tw := NewWithdrawal(\n\t\tversionedNonce,\n\t\t&predeploys.L2CrossDomainMessengerAddr,\n\t\tl1CrossDomainMessenger,\n\t\tvalue,\n\t\tnew(big.Int).SetUint64(gasLimit),\n\t\tdata,\n\t)\n\treturn w, nil\n}\n\nfunc MigrateWithdrawalGasLimit(data []byte) uint64 {\n\t// Compute the cost of the calldata\n\tdataCost := uint64(0)\n\tfor _, b := range data {\n\t\tif b == 0 {\n\t\t\tdataCost += params.TxDataZeroGas\n\t\t} else {\n\t\t\tdataCost += params.TxDataNonZeroGasEIP2028\n\t\t}\n\t}\n\n\t// Set the outer gas limit. This cannot be zero\n\tgasLimit := dataCost + 200_000\n\t// Cap the gas limit to be 25 million to prevent creating withdrawals\n\t// that go over the block gas limit.\n\tif gasLimit > 25_000_000 {\n\t\tgasLimit = 25_000_000\n\t}\n\n\treturn gasLimit\n}"
    },
    {
      "filename": "packages/contracts-bedrock/contracts/L1/OptimismPortal.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport { SafeCall } from \"../libraries/SafeCall.sol\";\nimport { L2OutputOracle } from \"./L2OutputOracle.sol\";\nimport { SystemConfig } from \"./SystemConfig.sol\";\nimport { Constants } from \"../libraries/Constants.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { SecureMerkleTrie } from \"../libraries/trie/SecureMerkleTrie.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { ResourceMetering } from \"./ResourceMetering.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @custom:proxied\n * @title OptimismPortal\n * @notice The OptimismPortal is a low-level contract responsible for passing messages between L1\n *         and L2. Messages sent directly to the OptimismPortal have no form of replayability.\n *         Users are encouraged to use the L1CrossDomainMessenger for a higher-level interface.\n */\ncontract OptimismPortal is Initializable, ResourceMetering, Semver {\n    /**\n     * @notice Represents a proven withdrawal.\n     *\n     * @custom:field outputRoot    Root of the L2 output this was proven against.\n     * @custom:field timestamp     Timestamp at whcih the withdrawal was proven.\n     * @custom:field l2OutputIndex Index of the output this was proven against.\n     */\n    struct ProvenWithdrawal {\n        bytes32 outputRoot;\n        uint128 timestamp;\n        uint128 l2OutputIndex;\n    }\n\n    /**\n     * @notice Version of the deposit event.\n     */\n    uint256 internal constant DEPOSIT_VERSION = 0;\n\n    /**\n     * @notice The L2 gas limit set when eth is deposited using the receive() function.\n     */\n    uint64 internal constant RECEIVE_DEFAULT_GAS_LIMIT = 100_000;\n\n    /**\n     * @notice Address of the L2OutputOracle contract.\n     */\n    L2OutputOracle public immutable L2_ORACLE;\n\n    /**\n     * @notice Address of the SystemConfig contract.\n     */\n    SystemConfig public immutable SYSTEM_CONFIG;\n\n    /**\n     * @notice Address that has the ability to pause and unpause withdrawals.\n     */\n    address public immutable GUARDIAN;\n\n    /**\n     * @notice Address of the L2 account which initiated a withdrawal in this transaction. If the\n     *         of this variable is the default L2 sender address, then we are NOT inside of a call\n     *         to finalizeWithdrawalTransaction.\n     */\n    address public l2Sender;\n\n    /**\n     * @notice A list of withdrawal hashes which have been successfully finalized.\n     */\n    mapping(bytes32 => bool) public finalizedWithdrawals;\n\n    /**\n     * @notice A mapping of withdrawal hashes to `ProvenWithdrawal` data.\n     */\n    mapping(bytes32 => ProvenWithdrawal) public provenWithdrawals;\n\n    /**\n     * @notice Determines if cross domain messaging is paused. When set to true,\n     *         deposits and withdrawals are paused. This may be removed in the\n     *         future.\n     */\n    bool public paused;\n\n    /**\n     * @notice Emitted when a transaction is deposited from L1 to L2. The parameters of this event\n     *         are read by the rollup node and used to derive deposit transactions on L2.\n     *\n     * @param from       Address that triggered the deposit transaction.\n     * @param to         Address that the deposit transaction is directed to.\n     * @param version    Version of this deposit transaction event.\n     * @param opaqueData ABI encoded deposit data to be parsed off-chain.\n     */\n    event TransactionDeposited(\n        address indexed from,\n        address indexed to,\n        uint256 indexed version,\n        bytes opaqueData\n    );\n\n    /**\n     * @notice Emitted when a withdrawal transaction is proven.\n     *\n     * @param withdrawalHash Hash of the withdrawal transaction.\n     */\n    event WithdrawalProven(\n        bytes32 indexed withdrawalHash,\n        address indexed from,\n        address indexed to\n    );\n\n    /**\n     * @notice Emitted when a withdrawal transaction is finalized.\n     *\n     * @param withdrawalHash Hash of the withdrawal transaction.\n     * @param success        Whether the withdrawal transaction was successful.\n     */\n    event WithdrawalFinalized(bytes32 indexed withdrawalHash, bool success);\n\n    /**\n     * @notice Emitted when the pause is triggered.\n     *\n     * @param account Address of the account triggering the pause.\n     */\n    event Paused(address account);\n\n    /**\n     * @notice Emitted when the pause is lifted.\n     *\n     * @param account Address of the account triggering the unpause.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @notice Reverts when paused.\n     */\n    modifier whenNotPaused() {\n        require(paused == false, \"OptimismPortal: paused\");\n        _;\n    }\n\n    /**\n     * @custom:semver 1.3.0\n     *\n     * @param _l2Oracle                  Address of the L2OutputOracle contract.\n     * @param _guardian                  Address that can pause deposits and withdrawals.\n     * @param _paused                    Sets the contract's pausability state.\n     * @param _config                    Address of the SystemConfig contract.\n     */\n    constructor(\n        L2OutputOracle _l2Oracle,\n        address _guardian,\n        bool _paused,\n        SystemConfig _config\n    ) Semver(1, 3, 0) {\n        L2_ORACLE = _l2Oracle;\n        GUARDIAN = _guardian;\n        SYSTEM_CONFIG = _config;\n        initialize(_paused);\n    }\n\n    /**\n     * @notice Initializer.\n     */\n    function initialize(bool _paused) public initializer {\n        l2Sender = Constants.DEFAULT_L2_SENDER;\n        paused = _paused;\n        __ResourceMetering_init();\n    }\n\n    /**\n     * @notice Pause deposits and withdrawals.\n     */\n    function pause() external {\n        require(msg.sender == GUARDIAN, \"OptimismPortal: only guardian can pause\");\n        paused = true;\n        emit Paused(msg.sender);\n    }\n\n    /**\n     * @notice Unpause deposits and withdrawals.\n     */\n    function unpause() external {\n        require(msg.sender == GUARDIAN, \"OptimismPortal: only guardian can unpause\");\n        paused = false;\n        emit Unpaused(msg.sender);\n    }\n\n    /**\n     * @notice Accepts value so that users can send ETH directly to this contract and have the\n     *         funds be deposited to their address on L2. This is intended as a convenience\n     *         function for EOAs. Contracts should call the depositTransaction() function directly\n     *         otherwise any deposited funds will be lost due to address aliasing.\n     */\n    // solhint-disable-next-line ordering\n    receive() external payable {\n        depositTransaction(msg.sender, msg.value, RECEIVE_DEFAULT_GAS_LIMIT, false, bytes(\"\"));\n    }\n\n    /**\n     * @notice Accepts ETH value without triggering a deposit to L2. This function mainly exists\n     *         for the sake of the migration between the legacy Optimism system and Bedrock.\n     */\n    function donateETH() external payable {\n        // Intentionally empty.\n    }\n\n    /**\n     * @notice Getter for the resource config. Used internally by the ResourceMetering\n     *         contract. The SystemConfig is the source of truth for the resource config.\n     *\n     * @return ResourceMetering.ResourceConfig\n     */\n    function _resourceConfig()\n        internal\n        view\n        override\n        returns (ResourceMetering.ResourceConfig memory)\n    {\n        return SYSTEM_CONFIG.resourceConfig();\n    }\n\n    /**\n     * @notice Proves a withdrawal transaction.\n     *\n     * @param _tx              Withdrawal transaction to finalize.\n     * @param _l2OutputIndex   L2 output index to prove against.\n     * @param _outputRootProof Inclusion proof of the L2ToL1MessagePasser contract's storage root.\n     * @param _withdrawalProof Inclusion proof of the withdrawal in L2ToL1MessagePasser contract.\n     */\n    function proveWithdrawalTransaction(\n        Types.WithdrawalTransaction memory _tx,\n        uint256 _l2OutputIndex,\n        Types.OutputRootProof calldata _outputRootProof,\n        bytes[] calldata _withdrawalProof\n    ) external whenNotPaused {\n        // Prevent users from creating a deposit transaction where this address is the message\n        // sender on L2. Because this is checked here, we do not need to check again in\n        // `finalizeWithdrawalTransaction`.\n        require(\n            _tx.target != address(this),\n            \"OptimismPortal: you cannot send messages to the portal contract\"\n        );\n\n        // Get the output root and load onto the stack to prevent multiple mloads. This will\n        // revert if there is no output root for the given block number.\n        bytes32 outputRoot = L2_ORACLE.getL2Output(_l2OutputIndex).outputRoot;\n\n        // Verify that the output root can be generated with the elements in the proof.\n        require(\n            outputRoot == Hashing.hashOutputRootProof(_outputRootProof),\n            \"OptimismPortal: invalid output root proof\"\n        );\n\n        // Load the ProvenWithdrawal into memory, using the withdrawal hash as a unique identifier.\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(_tx);\n        ProvenWithdrawal memory provenWithdrawal = provenWithdrawals[withdrawalHash];\n\n        // We generally want to prevent users from proving the same withdrawal multiple times\n        // because each successive proof will update the timestamp. A malicious user can take\n        // advantage of this to prevent other users from finalizing their withdrawal. However,\n        // since withdrawals are proven before an output root is finalized, we need to allow users\n        // to re-prove their withdrawal only in the case that the output root for their specified\n        // output index has been updated.\n        require(\n            provenWithdrawal.timestamp == 0 ||\n                L2_ORACLE.getL2Output(provenWithdrawal.l2OutputIndex).outputRoot !=\n                provenWithdrawal.outputRoot,\n            \"OptimismPortal: withdrawal hash has already been proven\"\n        );\n\n        // Compute the storage slot of the withdrawal hash in the L2ToL1MessagePasser contract.\n        // Refer to the Solidity documentation for more information on how storage layouts are\n        // computed for mappings.\n        bytes32 storageKey = keccak256(\n            abi.encode(\n                withdrawalHash,\n                uint256(0) // The withdrawals mapping is at the first slot in the layout.\n            )\n        );\n\n        // Verify that the hash of this withdrawal was stored in the L2toL1MessagePasser contract\n        // on L2. If this is true, under the assumption that the SecureMerkleTrie does not have\n        // bugs, then we know that this withdrawal was actually triggered on L2 and can therefore\n        // be relayed on L1.\n        require(\n            SecureMerkleTrie.verifyInclusionProof(\n                abi.encode(storageKey),\n                hex\"01\",\n                _withdrawalProof,\n                _outputRootProof.messagePasserStorageRoot\n            ),\n            \"OptimismPortal: invalid withdrawal inclusion proof\"\n        );\n\n        // Designate the withdrawalHash as proven by storing the `outputRoot`, `timestamp`, and\n        // `l2BlockNumber` in the `provenWithdrawals` mapping. A `withdrawalHash` can only be\n        // proven once unless it is submitted again with a different outputRoot.\n        provenWithdrawals[withdrawalHash] = ProvenWithdrawal({\n            outputRoot: outputRoot,\n            timestamp: uint128(block.timestamp),\n            l2OutputIndex: uint128(_l2OutputIndex)\n        });\n\n        // Emit a `WithdrawalProven` event.\n        emit WithdrawalProven(withdrawalHash, _tx.sender, _tx.target);\n    }\n\n    /**\n     * @notice Finalizes a withdrawal transaction.\n     *\n     * @param _tx Withdrawal transaction to finalize.\n     */\n    function finalizeWithdrawalTransaction(Types.WithdrawalTransaction memory _tx)\n        external\n        whenNotPaused\n    {\n        // Make sure that the l2Sender has not yet been set. The l2Sender is set to a value other\n        // than the default value when a withdrawal transaction is being finalized. This check is\n        // a defacto reentrancy guard.\n        require(\n            l2Sender == Constants.DEFAULT_L2_SENDER,\n            \"OptimismPortal: can only trigger one withdrawal per transaction\"\n        );\n\n        // Grab the proven withdrawal from the `provenWithdrawals` map.\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(_tx);\n        ProvenWithdrawal memory provenWithdrawal = provenWithdrawals[withdrawalHash];\n\n        // A withdrawal can only be finalized if it has been proven. We know that a withdrawal has\n        // been proven at least once when its timestamp is non-zero. Unproven withdrawals will have\n        // a timestamp of zero.\n        require(\n            provenWithdrawal.timestamp != 0,\n            \"OptimismPortal: withdrawal has not been proven yet\"\n        );\n\n        // As a sanity check, we make sure that the proven withdrawal's timestamp is greater than\n        // starting timestamp inside the L2OutputOracle. Not strictly necessary but extra layer of\n        // safety against weird bugs in the proving step.\n        require(\n            provenWithdrawal.timestamp >= L2_ORACLE.startingTimestamp(),\n            \"OptimismPortal: withdrawal timestamp less than L2 Oracle starting timestamp\"\n        );\n\n        // A proven withdrawal must wait at least the finalization period before it can be\n        // finalized. This waiting period can elapse in parallel with the waiting period for the\n        // output the withdrawal was proven against. In effect, this means that the minimum\n        // withdrawal time is proposal submission time + finalization period.\n        require(\n            _isFinalizationPeriodElapsed(provenWithdrawal.timestamp),\n            \"OptimismPortal: proven withdrawal finalization period has not elapsed\"\n        );\n\n        // Grab the OutputProposal from the L2OutputOracle, will revert if the output that\n        // corresponds to the given index has not been proposed yet.\n        Types.OutputProposal memory proposal = L2_ORACLE.getL2Output(\n            provenWithdrawal.l2OutputIndex\n        );\n\n        // Check that the output root that was used to prove the withdrawal is the same as the\n        // current output root for the given output index. An output root may change if it is\n        // deleted by the challenger address and then re-proposed.\n        require(\n            proposal.outputRoot == provenWithdrawal.outputRoot,\n            \"OptimismPortal: output root proven is not the same as current output root\"\n        );\n\n        // Check that the output proposal has also been finalized.\n        require(\n            _isFinalizationPeriodElapsed(proposal.timestamp),\n            \"OptimismPortal: output proposal finalization period has not elapsed\"\n        );\n\n        // Check that this withdrawal has not already been finalized, this is replay protection.\n        require(\n            finalizedWithdrawals[withdrawalHash] == false,\n            \"OptimismPortal: withdrawal has already been finalized\"\n        );\n\n        // Mark the withdrawal as finalized so it can't be replayed.\n        finalizedWithdrawals[withdrawalHash] = true;\n\n        // Set the l2Sender so contracts know who triggered this withdrawal on L2.\n        l2Sender = _tx.sender;\n\n        // Trigger the call to the target contract. We use a custom low level method\n        // SafeCall.callWithMinGas to ensure two key properties\n        //   1. Target contracts cannot force this call to run out of gas by returning a very large\n        //      amount of data (and this is OK because we don't care about the returndata here).\n        //   2. The amount of gas provided to the call to the target contract is at least the gas\n        //      limit specified by the user. If there is not enough gas in the callframe to\n        //      accomplish this, `callWithMinGas` will revert.\n        // Additionally, if there is not enough gas remaining to complete the execution after the\n        // call returns, this function will revert.\n        bool success = SafeCall.callWithMinGas(_tx.target, _tx.gasLimit, _tx.value, _tx.data);\n\n        // Reset the l2Sender back to the default value.\n        l2Sender = Constants.DEFAULT_L2_SENDER;\n\n        // All withdrawals are immediately finalized. Replayability can\n        // be achieved through contracts built on top of this contract\n        emit WithdrawalFinalized(withdrawalHash, success);\n\n        // Reverting here is useful for determining the exact gas cost to successfully execute the\n        // sub call to the target contract if the minimum gas limit specified by the user would not\n        // be sufficient to execute the sub call.\n        if (success == false && tx.origin == Constants.ESTIMATION_ADDRESS) {\n            revert(\"OptimismPortal: withdrawal failed\");\n        }\n    }\n\n    /**\n     * @notice Accepts deposits of ETH and data, and emits a TransactionDeposited event for use in\n     *         deriving deposit transactions. Note that if a deposit is made by a contract, its\n     *         address will be aliased when retrieved using `tx.origin` or `msg.sender`. Consider\n     *         using the CrossDomainMessenger contracts for a simpler developer experience.\n     *\n     * @param _to         Target address on L2.\n     * @param _value      ETH value to send to the recipient.\n     * @param _gasLimit   Minimum L2 gas limit (can be greater than or equal to this value).\n     * @param _isCreation Whether or not the transaction is a contract creation.\n     * @param _data       Data to trigger the recipient with.\n     */\n    function depositTransaction(\n        address _to,\n        uint256 _value,\n        uint64 _gasLimit,\n        bool _isCreation,\n        bytes memory _data\n    ) public payable metered(_gasLimit) {\n        // Just to be safe, make sure that people specify address(0) as the target when doing\n        // contract creations.\n        if (_isCreation) {\n            require(\n                _to == address(0),\n                \"OptimismPortal: must send to address(0) when creating a contract\"\n            );\n        }\n\n        // Prevent depositing transactions that have too small of a gas limit.\n        require(_gasLimit >= 21_000, \"OptimismPortal: gas limit must cover instrinsic gas cost\");\n\n        // Transform the from-address to its alias if the caller is a contract.\n        address from = msg.sender;\n        if (msg.sender != tx.origin) {\n            from = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n        }\n\n        // Compute the opaque data that will be emitted as part of the TransactionDeposited event.\n        // We use opaque data so that we can update the TransactionDeposited event in the future\n        // without breaking the current interface.\n        bytes memory opaqueData = abi.encodePacked(\n            msg.value,\n            _value,\n            _gasLimit,\n            _isCreation,\n            _data\n        );\n\n        // Emit a TransactionDeposited event so that the rollup node can derive a deposit\n        // transaction for this deposit.\n        emit TransactionDeposited(from, _to, DEPOSIT_VERSION, opaqueData);\n    }\n\n    /**\n     * @notice Determine if a given output is finalized. Reverts if the call to\n     *         L2_ORACLE.getL2Output reverts. Returns a boolean otherwise.\n     *\n     * @param _l2OutputIndex Index of the L2 output to check.\n     *\n     * @return Whether or not the output is finalized.\n     */\n    function isOutputFinalized(uint256 _l2OutputIndex) external view returns (bool) {\n        return _isFinalizationPeriodElapsed(L2_ORACLE.getL2Output(_l2OutputIndex).timestamp);\n    }\n\n    /**\n     * @notice Determines whether the finalization period has elapsed w/r/t a given timestamp.\n     *\n     * @param _timestamp Timestamp to check.\n     *\n     * @return Whether or not the finalization period has elapsed.\n     */\n    function _isFinalizationPeriodElapsed(uint256 _timestamp) internal view returns (bool) {\n        return block.timestamp > _timestamp + L2_ORACLE.FINALIZATION_PERIOD_SECONDS();\n    }\n}"
    },
    {
      "filename": "packages/contracts-bedrock/contracts/universal/CrossDomainMessenger.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { SafeCall } from \"../libraries/SafeCall.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Encoding } from \"../libraries/Encoding.sol\";\nimport { Constants } from \"../libraries/Constants.sol\";\n\n/**\n * @custom:legacy\n * @title CrossDomainMessengerLegacySpacer0\n * @notice Contract only exists to add a spacer to the CrossDomainMessenger where the\n *         libAddressManager variable used to exist. Must be the first contract in the inheritance\n *         tree of the CrossDomainMessenger.\n */\ncontract CrossDomainMessengerLegacySpacer0 {\n    /**\n     * @custom:legacy\n     * @custom:spacer libAddressManager\n     * @notice Spacer for backwards compatibility.\n     */\n    address private spacer_0_0_20;\n}\n\n/**\n * @custom:legacy\n * @title CrossDomainMessengerLegacySpacer1\n * @notice Contract only exists to add a spacer to the CrossDomainMessenger where the\n *         PausableUpgradable and OwnableUpgradeable variables used to exist. Must be\n *         the third contract in the inheritance tree of the CrossDomainMessenger.\n */\ncontract CrossDomainMessengerLegacySpacer1 {\n    /**\n     * @custom:legacy\n     * @custom:spacer __gap\n     * @notice Spacer for backwards compatibility. Comes from OpenZeppelin\n     *         ContextUpgradable via OwnableUpgradeable.\n     *\n     */\n    uint256[50] private spacer_1_0_1600;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer _owner\n     * @notice Spacer for backwards compatibility.\n     *         Come from OpenZeppelin OwnableUpgradeable.\n     */\n    address private spacer_51_0_20;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer __gap\n     * @notice Spacer for backwards compatibility. Comes from OpenZeppelin\n     *         ContextUpgradable via PausableUpgradable.\n     */\n    uint256[49] private spacer_52_0_1568;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer _paused\n     * @notice Spacer for backwards compatibility. Comes from OpenZeppelin\n     *         PausableUpgradable.\n     */\n    bool private spacer_101_0_1;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer __gap\n     * @notice Spacer for backwards compatibility. Comes from OpenZeppelin\n     *         PausableUpgradable.\n     */\n    uint256[49] private spacer_102_0_1568;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer ReentrancyGuardUpgradeable's `_status` field.\n     * @notice Spacer for backwards compatibility\n     */\n    uint256 private spacer_151_0_32;\n\n    /**\n     * @custom:spacer ReentrancyGuardUpgradeable\n     * @notice Spacer for backwards compatibility\n     */\n    uint256[49] private __gap_reentrancy_guard;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer blockedMessages\n     * @notice Spacer for backwards compatibility.\n     */\n    mapping(bytes32 => bool) private spacer_201_0_32;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer relayedMessages\n     * @notice Spacer for backwards compatibility.\n     */\n    mapping(bytes32 => bool) private spacer_202_0_32;\n}\n\n/**\n * @custom:upgradeable\n * @title CrossDomainMessenger\n * @notice CrossDomainMessenger is a base contract that provides the core logic for the L1 and L2\n *         cross-chain messenger contracts. It's designed to be a universal interface that only\n *         needs to be extended slightly to provide low-level message passing functionality on each\n *         chain it's deployed on. Currently only designed for message passing between two paired\n *         chains and does not support one-to-many interactions.\n *\n *         Any changes to this contract MUST result in a semver bump for contracts that inherit it.\n */\nabstract contract CrossDomainMessenger is\n    CrossDomainMessengerLegacySpacer0,\n    Initializable,\n    CrossDomainMessengerLegacySpacer1\n{\n    /**\n     * @notice Current message version identifier.\n     */\n    uint16 public constant MESSAGE_VERSION = 1;\n\n    /**\n     * @notice Constant overhead added to the base gas for a message.\n     */\n    uint64 public constant MIN_GAS_CONSTANT_OVERHEAD = 200_000;\n\n    /**\n     * @notice Numerator for dynamic overhead added to the base gas for a message.\n     */\n    uint64 public constant MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR = 1016;\n\n    /**\n     * @notice Denominator for dynamic overhead added to the base gas for a message.\n     */\n    uint64 public constant MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR = 1000;\n\n    /**\n     * @notice Extra gas added to base gas for each byte of calldata in a message.\n     */\n    uint64 public constant MIN_GAS_CALLDATA_OVERHEAD = 16;\n\n    /**\n     * @notice Address of the paired CrossDomainMessenger contract on the other chain.\n     */\n    address public immutable OTHER_MESSENGER;\n\n    /**\n     * @notice Mapping of message hashes to boolean receipt values. Note that a message will only\n     *         be present in this mapping if it has successfully been relayed on this chain, and\n     *         can therefore not be relayed again.\n     */\n    mapping(bytes32 => bool) public successfulMessages;\n\n    /**\n     * @notice Address of the sender of the currently executing message on the other chain. If the\n     *         value of this variable is the default value (0x00000000...dead) then no message is\n     *         currently being executed. Use the xDomainMessageSender getter which will throw an\n     *         error if this is the case.\n     */\n    address internal xDomainMsgSender;\n\n    /**\n     * @notice Nonce for the next message to be sent, without the message version applied. Use the\n     *         messageNonce getter which will insert the message version into the nonce to give you\n     *         the actual nonce to be used for the message.\n     */\n    uint240 internal m"
    }
  ]
}