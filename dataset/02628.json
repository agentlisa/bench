{
  "Title": "Lack of address validation in setExecutor",
  "Content": "In the `EmergencyProposal` contract, the function [`setExecutor`](https://github.com/UMAprotocol/protocol/blob/5682c65a9226f63610a6eb391c34d06799eb587d/packages/core/contracts/oracle/implementation/EmergencyProposer.sol#L214) allows the owner of the contract to set a new executor. However, the function does not validate that the `newExecutor` address is not the zero address before updating the value.\n\n\nConsider adding validation to prevent an unintended change that sets the executor to the zero address.\n\n\n**Update:** *Resolved, not an issue. Ability to set executor to zero is a feature of the UMA platform. UMA’s statement:*\n\n\n\n> *The audit fix proposes adding address validation to the setExecutor function such that this value can’t be set to the zero address. We choose to do nothing for this issue as being able to set the executor to the zero address is a feature: this acts to disable the emergencyProposer system, thereby disabling the emergency logic. This could be, for example, an upgrade path for the emergency proposal system or a path forward if governance deems the emergency proposal logic redundant.*\n> \n> \n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/core/contracts/oracle/implementation/EmergencyProposer.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.16;\n\nimport \"./Finder.sol\";\nimport \"./GovernorV2.sol\";\nimport \"./Constants.sol\";\nimport \"../interfaces/OracleAncillaryInterface.sol\";\nimport \"./AdminIdentifierLib.sol\";\nimport \"../../common/implementation/Lockable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title Emergency Proposer contract\n * @dev This is a contract that allows anyone to construct an emergency recovery transaction to bypass the\n * standard voting process by submitting a very large bond, which is considered a quorum in this case. This bond is\n * expected to be about as large as the GAT in the VotingV2 contract. If a proposal is considered invalid, UMA token\n * holders can vote to slash and remove this proposal through the standard governance flow. If valid, a proposal must\n * wait minimumWaitTime before it can be executed and it can only be executed by a privileged account, executor. This\n * includes three tiers of protection to ensure that abuse is extremely risky both from creating market volatility in\n * the underlying token and the threat of the locked tokens being slashed.\n */\ncontract EmergencyProposer is Ownable, Lockable {\n    using SafeERC20 for IERC20;\n    IERC20 public immutable token;\n    uint256 public quorum;\n    uint64 public minimumWaitTime;\n\n    GovernorV2 public immutable governor;\n    Finder public immutable finder;\n\n    struct EmergencyProposal {\n        address sender;\n        uint64 expiryTime;\n        uint256 lockedTokens;\n        GovernorV2.Transaction[] transactions;\n    }\n    EmergencyProposal[] public emergencyProposals;\n    uint256 public currentId;\n    address public executor;\n\n    event QuorumSet(uint256 quorum);\n    event ExecutorSet(address executor);\n    event MinimumWaitTimeSet(uint256 minimumWaitTime);\n    event EmergencyTransactionsProposed(\n        uint256 indexed id,\n        address indexed sender,\n        address indexed caller,\n        uint64 expiryTime,\n        uint256 lockedTokens,\n        GovernorV2.Transaction[] transactions\n    );\n    event EmergencyProposalRemoved(\n        uint256 indexed id,\n        address indexed sender,\n        address indexed caller,\n        uint64 expiryTime,\n        uint256 lockedTokens,\n        GovernorV2.Transaction[] transactions\n    );\n    event EmergencyProposalSlashed(\n        uint256 indexed id,\n        address indexed sender,\n        address indexed caller,\n        uint64 expiryTime,\n        uint256 lockedTokens,\n        GovernorV2.Transaction[] transactions\n    );\n    event EmergencyProposalExecuted(\n        uint256 indexed id,\n        address indexed sender,\n        address indexed caller,\n        uint64 expiryTime,\n        uint256 lockedTokens,\n        GovernorV2.Transaction[] transactions\n    );\n\n    /**\n     * @notice Construct the EmergencyProposer contract.\n     * @param _token the ERC20 token that the quorum is in.\n     * @param _quorum the tokens needed to propose an emergency action..\n     * @param _governor the governor contract that this contract makes proposals to.\n     * @param _finder the finder contract used to look up addresses.\n     */\n    constructor(\n        IERC20 _token,\n        uint256 _quorum,\n        GovernorV2 _governor,\n        Finder _finder,\n        address _executor\n    ) {\n        token = _token;\n        governor = _governor;\n        finder = _finder;\n        setExecutor(_executor);\n        setQuorum(_quorum);\n\n        // Start with a hardcoded value of 1 week.\n        setMinimumWaitTime(1 weeks);\n        transferOwnership(address(_governor));\n    }\n\n    /**\n     * @notice Propose an emergency admin action to execute on the DVM as a set of proposed transactions.\n     * @dev Caller of this method must approve (and have) quorum amount of token to be pulled from their wallet.\n     * @param transactions array of transactions to be executed in the emergency action. When executed, will be sent\n     * via the governor contract.\n     */\n    function emergencyPropose(GovernorV2.Transaction[] memory transactions) external nonReentrant() returns (uint256) {\n        token.safeTransferFrom(msg.sender, address(this), quorum);\n        uint256 id = emergencyProposals.length;\n        EmergencyProposal storage proposal = emergencyProposals.push();\n        proposal.sender = msg.sender;\n        proposal.lockedTokens = quorum;\n        proposal.expiryTime = uint64(getCurrentTime()) + minimumWaitTime;\n\n        for (uint256 i = 0; i < transactions.length; i++) proposal.transactions.push(transactions[i]);\n\n        emit EmergencyTransactionsProposed(id, msg.sender, msg.sender, proposal.expiryTime, quorum, transactions);\n        return id;\n    }\n\n    /**\n     * @notice After the proposal is executable, the executor or proposer can use this function to remove the proposal\n     * without slashing.\n     * @dev This means that the DVM didn't explicitly reject the proposal. Allowing the executor to slash the quorum\n     * would give the executor too much power. So the only control either party has is to remove the proposal,\n     * releasing the bond. The proposal should not be removable before its liveness/expiry to ensure the regular Voting\n     * system's slash cannot be frontrun.\n     * @param id id of the proposal.\n     */\n    function removeProposal(uint256 id) external nonReentrant() {\n        EmergencyProposal storage proposal = emergencyProposals[id];\n        require(proposal.expiryTime <= getCurrentTime(), \"must be expired to remove\");\n        require(msg.sender == proposal.sender || msg.sender == executor, \"proposer or executor\");\n        require(proposal.lockedTokens != 0, \"invalid proposal\");\n        token.safeTransfer(proposal.sender, proposal.lockedTokens);\n        emit EmergencyProposalRemoved(\n            id,\n            proposal.sender,\n            msg.sender,\n            proposal.expiryTime,\n            proposal.lockedTokens,\n            proposal.transactions\n        );\n        delete emergencyProposals[id];\n    }\n\n    /**\n     * @notice Before a proposal expires (or after), this method can be used by the owner, which should generally be\n     * the GovernorV2 contract, to slash the proposer.\n     * @dev The slash results in the proposer's tokens being sent to the Governor contract.\n     * @param id id of the proposal.\n     */\n    function slashProposal(uint256 id) external nonReentrant() onlyOwner() {\n        EmergencyProposal storage proposal = emergencyProposals[id];\n        require(proposal.lockedTokens != 0, \"invalid proposal\");\n        token.safeTransfer(address(governor), proposal.lockedTokens);\n        emit EmergencyProposalSlashed(\n            id,\n            proposal.sender,\n            msg.sender,\n            proposal.expiryTime,\n            proposal.lockedTokens,\n            proposal.transactions\n        );\n        delete emergencyProposals[id];\n    }\n\n    /**\n     * @notice After a proposal expires, this method can be used by the executor to execute the proposal.\n     * @dev This method effectively gives the executor veto power over any proposal.\n     * @param id id of the proposal.\n     */\n    function executeEmergencyProposal(uint256 id) public payable nonReentrant() {\n        require(msg.sender == executor, \"must be called by executor\");\n\n        EmergencyProposal storage proposal = emergencyProposals[id];\n        require(proposal.lockedTokens != 0, \"invalid proposal\");\n        require(proposal.expiryTime <= getCurrentTime(), \"must be expired to execute\");\n\n        for (uint256 i = 0; i < proposal.transactions.length; i++)\n            governor.emergencyExecute{ value: address(this).balance }(proposal.transactions[i]);\n\n        token.safeTransfer(proposal.sender, proposal.lockedTokens);\n        emit EmergencyProposalExecuted(\n            id,\n            proposal.sender,\n            msg.sender,\n            proposal.expiryTime,\n            proposal.lockedTokens,\n            proposal.transactions\n        );\n        delete emergencyProposals[id];\n    }\n\n    /**\n     * @notice Admin method to set the quorum (bond) size.\n     * @dev Admin is intended to be the governance system.\n     * @param newQuorum the new quorum.\n     */\n    function setQuorum(uint256 newQuorum) public nonReentrant() onlyOwner() {\n        require(newQuorum != 0, \"quorum must be > 0\");\n        quorum = newQuorum;\n        emit QuorumSet(newQuorum);\n    }\n\n    /**\n     * @notice Admin method to set the executor address.\n     * @dev Admin is intended to be the governance system.\n     * @param newExecutor the new executor address.\n     */\n    function setExecutor(address newExecutor) public nonReentrant() onlyOwner() {\n        executor = newExecutor;\n        emit ExecutorSet(newExecutor);\n    }\n\n    /**\n     * @notice Admin method to set the minimum wait time for a proposal to be executed.\n     * @dev Admin is intended to be the governance system. The minumum wait time is added to the current time at the\n     * time of the proposal to determine when the proposal will be executable. Any changes to this value after that\n     * point will have no impact on the proposal.\n     * @param newMinimumWaitTime the new minimum wait time.\n     */\n    function setMinimumWaitTime(uint64 newMinimumWaitTime) public nonReentrant() onlyOwner() {\n        require(newMinimumWaitTime != 0, \"minimumWaitTime == 0\");\n        minimumWaitTime = newMinimumWaitTime;\n        emit MinimumWaitTimeSet(newMinimumWaitTime);\n    }\n\n    /**\n     * @notice Returns the current block timestamp.\n     * @dev Can be overridden to control contract time.\n     */\n    function getCurrentTime() public view virtual returns (uint256) {\n        return block.timestamp;\n    }\n}"
    }
  ]
}