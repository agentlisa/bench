{
  "Title": "[M-06] New BAKC Owner Can Steal ApeCoin",
  "Content": "\n### Background\n\nThis section provides a context of the pre-requisite concepts that a reader needs to fully understand the issue.\n\n#### Split Pair Edge Case In Paired Pool\n\nAssume that Jimmy is the owner of BAYC `#8888` and BAKC `#9999` NFTs initially. He participated in the Paired Pool and staked + accrued a total of 100 ApeCoin (APE) at this point, as shown in the diagram below.\n\nJimmy then sold his BAKC `#9999` NFT to Ben. When this happens, both parties (Jimmy and Ben) could close out their staking position. Since Ben owns BAKC `#9999` now, he can close out Jimmy's position anytime and claim all the accrued APE rewards (2 APE below). While Jimmy will obtain the 98 APE that he staked initially.\n\nThe following image is taken from <https://youtu.be/_LO-1f9nyjs?t=640>\n\n![](https://user-images.githubusercontent.com/102820284/206686601-3c34a2a1-6b80-420d-8ed8-2f86ab6ca103.png)\n\nThe `ApeCoinStaking._withdrawPairNft` taken from the official `$APE` Staking Contract shows that the implementation allows both the BAYC/MAYC owners and BAKC owners to close out the staking position. Refer to Line 976 below.\n\nWhen the staking position is closed by the BAKC owners, the entire staking amount must be withdrawn. A partial amount is not allowed per Line 981 below. In Line 984, all the accrued APE rewards will be sent to the BAKC owners. In Line 989, all the staked APEs will be withdrawn (unstake) and sent directly to the wallet of the BAYC owners.\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/dependencies/yoga-labs/ApeCoinStaking.sol#L966>\n\n```solidity\nFile: ApeCoinStaking.sol\n966:     function _withdrawPairNft(uint256 mainTypePoolId, PairNftWithAmount[] calldata _nfts) private {\n967:         for(uint256 i; i < _nfts.length; ++i) {\n968:             uint256 mainTokenId = _nfts[i].mainTokenId;\n969:             uint256 bakcTokenId = _nfts[i].bakcTokenId;\n970:             uint256 amount = _nfts[i].amount;\n971:             address mainTokenOwner = nftContracts[mainTypePoolId].ownerOf(mainTokenId);\n972:             address bakcOwner = nftContracts[BAKC_POOL_ID].ownerOf(bakcTokenId);\n973:             PairingStatus memory mainToSecond = mainToBakc[mainTypePoolId][mainTokenId];\n974:             PairingStatus memory secondToMain = bakcToMain[bakcTokenId][mainTypePoolId];\n975: \n976:             require(mainTokenOwner == msg.sender || bakcOwner == msg.sender, \"At least one token in pair must be owned by caller\");\n977:             require(mainToSecond.tokenId == bakcTokenId && mainToSecond.isPaired\n978:                 && secondToMain.tokenId == mainTokenId && secondToMain.isPaired, \"The provided Token IDs are not paired\");\n979: \n980:             Position storage position = nftPosition[BAKC_POOL_ID][bakcTokenId];\n981:             require(mainTokenOwner == bakcOwner || amount == position.stakedAmount, \"Split pair can't partially withdraw\");\n982: \n983:             if (amount == position.stakedAmount) {\n984:                 uint256 rewardsToBeClaimed = _claim(BAKC_POOL_ID, position, bakcOwner);\n985:                 mainToBakc[mainTypePoolId][mainTokenId] = PairingStatus(0, false);\n986:                 bakcToMain[bakcTokenId][mainTypePoolId] = PairingStatus(0, false);\n987:                 emit ClaimRewardsPairNft(msg.sender, rewardsToBeClaimed, mainTypePoolId, mainTokenId, bakcTokenId);\n988:             }\n989:             _withdraw(BAKC_POOL_ID, position, amount, mainTokenOwner);\n990:             emit WithdrawPairNft(msg.sender, amount, mainTypePoolId, mainTokenId, bakcTokenId);\n991:         }\n992:     }\n```\n\nThe following shows that the `ApeCoinStaking._withdraw` used in the above function will send the unstaked APEs directly to the wallet of BAYC owners. Refer to Line 946 below.\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/dependencies/yoga-labs/ApeCoinStaking.sol#L937>\n\n```solidity\nFile: ApeCoinStaking.sol\n937:     function _withdraw(uint256 _poolId, Position storage _position, uint256 _amount, address _recipient) private {\n938:         require(_amount <= _position.stakedAmount, \"Can't withdraw more than staked amount\");\n939: \n940:         Pool storage pool = pools[_poolId];\n941: \n942:         _position.stakedAmount -= _amount;\n943:         pool.stakedAmount -= _amount;\n944:         _position.rewardsDebt -= (_amount * pool.accumulatedRewardsPerShare).toInt256();\n945: \n946:         apeCoin.safeTransfer(_recipient, _amount);\n947:     }\n```\n\n#### Who is the owner of BAYC/MAYC in ParaSpace?\n\nThe BAYC is held by the `NTokenBAYC` reserve pool, while the MAYC is held by `NTokenMAYC` reserve pool. This causes an issue because, as mentioned in the previous section, all the unstaked APE will be sent directly to the wallet of the BAYC/MAYC owners. This will be used as part of the attack path later on.\n\n#### Does BAKC need to be staked or stored within ParaSpace?\n\nNo. For the purpose of APE staking via ParaSpace , BAKC NFT need not be held in the ParaSpace contract for staking, but Bored Apes and Mutant Apes must be collateralized in the ParaSpace protocol. Refer to [here](https://docs.para.space/para-space/introduction-to-paraspace/borrow-and-stake-apecoin-with-bored-ape-yacht-club-nfts#deposit-and-stake-unstake-and-withdraw). As such, users are free to sell off their BAKC anytime to anyone since it is not being locked up.\n\n### Proof of Concept\n\nUsing back the same example in the previous section. Assume the following:\n\n*   Jimmy is the victim, and Ben is the attacker.\n*   Jimmy is the owner of BAYC `#8888` and BAKC `#9999` NFTs initially. He participated in the Paired Pool and staked + accrued a total of 100 ApeCoin (APE).\n*   Jimmy sold his BAKC `#9999` NFT to Ben. There are many ways Ben can obtain the BAKC `#9999` NFT. Ben could obtain it via the public marketplace (e.g. Opensea) if Jimmy listed it OR Ben could offer an attractive price to Jimmy to purchase it privately.\n*   Ben also participates in the APE staking in ParaSpace via his BAYC `#0002` and BAKC `#0002` NFTs.\n\nBen will close out Jimmy's position by calling the `ApeCoinStaking.withdrawBAKC` function of the official `$APE` Staking Contract to withdraw all the staked APE + accrued APE rewards. As a result, the 98 APE that Jimmy staked initially will be sent directly to the owner of the BAYC `#8888` owner. In this case, the BAYC `#8888` owner is ParaSpace's `NTokenBAYC` reserve pool.\n\nAt this point, it is important to note that Jimmy's 98 APE is stuck in ParaSpace's `NTokenBAYC` reserve pool. If anyone can siphon out Jimmy's 98 APE that is stuck in the contract, that person will be able to get free APE.\n\nThere exist a way to siphon out all the APE coin that resides in ParaSpace's `NTokenBAYC` reserve pool. Anyone who participates in APE staking via ParaSpace with a BAYC, which also means that any user staked in the Paired Pool, can trigger the `ApeStakingLogic.withdrawBAKC` function below by calling the `PoolApeStaking.withdrawBAKC` function.\n\nNotice that in Line 53 below, it will compute the total balance of APE held by ParaSpace's `NTokenBAYC` reserve pool contract. In Line 55, it will send all the APE in the pool contract to the recipient. This effectively performs a sweeping of APE stored in the pool contract.\n\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/tokenization/libraries/ApeStakingLogic.sol#L38>\n\n```solidity\nFile: ApeStakingLogic.sol\n38:     function withdrawBAKC(\n39:         ApeCoinStaking _apeCoinStaking,\n40:         uint256 poolId,\n41:         ApeCoinStaking.PairNftWithAmount[] memory _nftPairs,\n42:         address _apeRecipient\n43:     ) external {\n44:         ApeCoinStaking.PairNftWithAmount[]\n45:             memory _otherPairs = new ApeCoinStaking.PairNftWithAmount[](0);\n46: \n47:         if (poolId == BAYC_POOL_ID) {\n48:             _apeCoinStaking.withdrawBAKC(_nftPairs, _otherPairs);\n49:         } else {\n50:             _apeCoinStaking.withdrawBAKC(_otherPairs, _nftPairs);\n51:         }\n52: \n53:         uint256 balance = _apeCoinStaking.apeCoin().balanceOf(address(this));\n54: \n55:         _apeCoinStaking.apeCoin().safeTransfer(_apeRecipient, balance);\n56:     }\n```\n\nThus, after Ben closes out Jimmy's position by calling the `ApeCoinStaking.withdrawBAKC` function and causes the 98 APE to be sent to ParaSpace's `NTokenBAYC` reserve pool contract, Ben immediately calls the `PoolApeStaking.withdrawBAKC` function against his own BAYC `#0002` and BAKC `#0002` NFTs. This will result in all of Jimmy's 98 APE being swept to his wallet. Bob effectively steals Jimmy's 98 APE.\n\n### Impact\n\nApeCoin of ParaSpace users can be stolen.\n\n### Recommended Mitigation Steps\n\nConsider the potential side effects of the split pair edge case in the pair pool when implementing the APE staking feature in ParaSpace.\n\nThe official APE staking contract has been implemented recently, and only a few protocols have integrated with it. Thus, the edge cases are not widely understood and are prone to errors.\n\nTo mitigate this issue, instead of returning BAKC NFT to the users after staking, consider locking up BAKC NFT in the ParaSpace contract as part of the user's collateral. In this case, the user will not be able to sell off their BAKC, and the \"Split Pair Edge Case In Paired Pool\" scenario will not happen.\n\n**[LSDan (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-11-paraspace-findings/issues/284#issuecomment-1406320116):**\n > I've decided to downgrade this to medium. I think the risks involved are understood by most educated users of the BAYC/MAYC universe, but still valid.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-11-paraspace-contest",
  "Code": [
    {
      "filename": "paraspace-core/contracts/dependencies/yoga-labs/ApeCoinStaking.sol",
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport \"../openzeppelin/contracts/IERC20.sol\";\nimport \"../openzeppelin/contracts/SafeERC20.sol\";\nimport \"../openzeppelin/contracts/SafeCast.sol\";\nimport \"../openzeppelin/contracts/Ownable.sol\";\nimport \"../openzeppelin/contracts/ERC721Enumerable.sol\";\n\n/**\n * @title ApeCoin Staking Contract\n * @notice Stake ApeCoin across four different pools that release hourly rewards\n * @author HorizenLabs\n */\ncontract ApeCoinStaking is Ownable {\n\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    /// @notice State for ApeCoin, BAYC, MAYC, and Pair Pools\n    struct Pool {\n        uint256 lastRewardedTimestampHour;\n        uint256 lastRewardsRangeIndex;\n        uint256 stakedAmount;\n        uint256 accumulatedRewardsPerShare;\n        TimeRange[] timeRanges;\n    }\n\n    /// @notice Pool rules valid for a given duration of time.\n    /// @dev All TimeRange timestamp values must represent whole hours\n    struct TimeRange {\n        uint256 startTimestampHour;\n        uint256 endTimestampHour;\n        uint256 rewardsPerHour;\n        uint256 capPerPosition;\n    }\n\n    /// @dev Convenience struct for front-end applications\n    struct PoolUI {\n        uint256 poolId;\n        uint256 stakedAmount;\n        TimeRange currentTimeRange;\n    }\n\n    /// @dev Per address amount and reward tracking\n    struct Position {\n        uint256 stakedAmount;\n        int256 rewardsDebt;\n    }\n    mapping (address => Position) public addressPosition;\n\n    /// @dev Struct for depositing and withdrawing from the BAYC and MAYC NFT pools\n    struct SingleNft {\n        uint256 tokenId;\n        uint256 amount;\n    }\n    /// @dev Struct for depositing and withdrawing from the BAKC (Pair) pool\n    struct PairNftWithAmount {\n        uint256 mainTokenId;\n        uint256 bakcTokenId;\n        uint256 amount;\n    }\n    /// @dev Struct for claiming from an NFT pool\n    struct PairNft {\n        uint256 mainTokenId;\n        uint256 bakcTokenId;\n    }\n    /// @dev NFT paired status.  Can be used bi-directionally (BAYC/MAYC -> BAKC) or (BAKC -> BAYC/MAYC)\n    struct PairingStatus {\n        uint256 tokenId;\n        bool isPaired;\n    }\n\n    // @dev UI focused payload\n    struct DashboardStake {\n        uint256 poolId;\n        uint256 tokenId;\n        uint256 deposited;\n        uint256 unclaimed;\n        uint256 rewards24hr;\n        DashboardPair pair;\n    }\n    /// @dev Sub struct for DashboardStake\n    struct DashboardPair {\n        uint256 mainTokenId;\n        uint256 mainTypePoolId;\n    }\n    /// @dev Placeholder for pair status, used by ApeCoin Pool\n    DashboardPair private NULL_PAIR = DashboardPair(0, 0);\n\n    /// @notice Internal ApeCoin amount for distributing staking reward claims\n    IERC20 public immutable apeCoin;\n    uint256 private constant APE_COIN_PRECISION = 1e18;\n    uint256 private constant MIN_DEPOSIT = 1 * APE_COIN_PRECISION;\n    uint256 private constant SECONDS_PER_HOUR = 3600;\n    uint256 private constant SECONDS_PER_MINUTE = 60;\n\n    uint256 constant APECOIN_POOL_ID = 0;\n    uint256 constant BAYC_POOL_ID = 1;\n    uint256 constant MAYC_POOL_ID = 2;\n    uint256 constant BAKC_POOL_ID = 3;\n    Pool[4] public pools;\n\n    /// @dev NFT contract mapping per pool\n    mapping(uint256 => ERC721Enumerable) public nftContracts;\n    /// @dev poolId => tokenId => nft position\n    mapping(uint256 => mapping(uint256 => Position)) public nftPosition;\n    /// @dev main type pool ID: 1: BAYC 2: MAYC => main token ID => bakc token ID\n    mapping(uint256 => mapping(uint256 => PairingStatus)) public mainToBakc;\n    /// @dev bakc Token ID => main type pool ID: 1: BAYC 2: MAYC => main token ID\n    mapping(uint256 => mapping(uint256 => PairingStatus)) public bakcToMain;\n\n    /** Custom Events */\n    event UpdatePool(\n        uint256 indexed poolId,\n        uint256 lastRewardedBlock,\n        uint256 stakedAmount,\n        uint256 accumulatedRewardsPerShare\n    );\n    event Deposit(\n        address indexed user,\n        uint256 amount,\n        address recipient\n    );\n    event DepositNft(\n        address indexed user,\n        uint256 indexed poolId,\n        uint256 amount,\n        uint256 tokenId\n    );\n    event DepositPairNft(\n        address indexed user,\n        uint256 amount,\n        uint256 mainTypePoolId,\n        uint256 mainTokenId,\n        uint256 bakcTokenId\n    );\n    event Withdraw(\n        address indexed user,\n        uint256 amount,\n        address recipient\n    );\n    event WithdrawNft(\n        address indexed user,\n        uint256 indexed poolId,\n        uint256 amount,\n        address recipient,\n        uint256 tokenId\n    );\n    event WithdrawPairNft(\n        address indexed user,\n        uint256 amount,\n        uint256 mainTypePoolId,\n        uint256 mainTokenId,\n        uint256 bakcTokenId\n    );\n    event ClaimRewards(\n        address indexed user,\n        uint256 amount,\n        address recipient\n    );\n    event ClaimRewardsNft(\n        address indexed user,\n        uint256 indexed poolId,\n        uint256 amount,\n        uint256 tokenId\n    );\n    event ClaimRewardsPairNft(\n        address indexed user,\n        uint256 amount,\n        uint256 mainTypePoolId,\n        uint256 mainTokenId,\n        uint256 bakcTokenId\n    );\n\n    /**\n     * @notice Construct a new ApeCoinStaking instance\n     * @param _apeCoinContractAddress The ApeCoin ERC20 contract address\n     * @param _baycContractAddress The BAYC NFT contract address\n     * @param _maycContractAddress The MAYC NFT contract address\n     * @param _bakcContractAddress The BAKC NFT contract address\n     */\n    constructor(\n        address _apeCoinContractAddress,\n        address _baycContractAddress,\n        address _maycContractAddress,\n        address _bakcContractAddress\n    ) {\n        apeCoin = IERC20(_apeCoinContractAddress);\n        nftContracts[BAYC_POOL_ID] = ERC721Enumerable(_baycContractAddress);\n        nftContracts[MAYC_POOL_ID] = ERC721Enumerable(_maycContractAddress);\n        nftContracts[BAKC_POOL_ID] = ERC721Enumerable(_bakcContractAddress);\n    }\n\n    // Deposit/Commit Methods\n\n    /**\n     * @notice Deposit ApeCoin to the ApeCoin Pool\n     * @param _amount Amount in ApeCoin\n     * @param _recipient Address the deposit it stored to\n     * @dev ApeCoin deposit must be >= 1 ApeCoin\n     */\n    function depositApeCoin(uint256 _amount, address _recipient) public {\n        require(_amount >= MIN_DEPOSIT, \"Can't deposit less than 1 $APE\");\n        updatePool(APECOIN_POOL_ID);\n\n        Position storage position = addressPosition[_recipient];\n        _deposit(APECOIN_POOL_ID, position, _amount);\n\n        emit Deposit(msg.sender, _amount, _recipient);\n    }\n\n    /**\n     * @notice Deposit ApeCoin to the ApeCoin Pool\n     * @param _amount Amount in ApeCoin\n     * @dev Deposit on behalf of msg.sender. ApeCoin deposit must be >= 1 ApeCoin\n     */\n    function depositSelfApeCoin(uint256 _amount) external {\n        depositApeCoin(_amount, msg.sender);\n    }\n\n    /**\n     * @notice Deposit ApeCoin to the BAYC Pool\n     * @param _nfts Array of SingleNft structs\n     * @dev Commits 1 or more BAYC NFTs, each with an ApeCoin amount to the BAYC pool.\\\n     * Each BAYC committed must attach an ApeCoin amount >= 1 ApeCoin and <= the BAYC pool cap amount.\n     */\n    function depositBAYC(SingleNft[] calldata _nfts) external {\n        _depositNft(BAYC_POOL_ID, _nfts);\n    }\n\n    /**\n     * @notice Deposit ApeCoin to the MAYC Pool\n     * @param _nfts Array of SingleNft structs\n     * @dev Commits 1 or more MAYC NFTs, each with an ApeCoin amount to the MAYC pool.\\\n     * Each MAYC committed must attach an ApeCoin amount >= 1 ApeCoin and <= the MAYC pool cap amount.\n     */\n    function depositMAYC(SingleNft[] calldata _nfts) external {\n        _depositNft(MAYC_POOL_ID, _nfts);\n    }\n\n    /**\n     * @notice Deposit ApeCoin to the Pair Pool, where Pair = (BAYC + BAKC) or (MAYC + BAKC)\n     * @param _baycPairs Array of PairNftWithAmount structs\n     * @param _maycPairs Array of PairNftWithAmount structs\n     * @dev Commits 1 or more Pairs, each with an ApeCoin amount to the Pair pool.\\\n     * Each BAKC committed must attach an ApeCoin amount >= 1 ApeCoin and <= the Pair pool cap amount.\\\n     * Example 1: BAYC + BAKC + 1 ApeCoin:  [[0, 0, \"1000000000000000000\"],[]]\\\n     * Example 2: MAYC + BAKC + 1 ApeCoin:  [[], [0, 0, \"1000000000000000000\"]]\\\n     * Example 3: (BAYC + BAKC + 1 ApeCoin) and (MAYC + BAKC + 1 ApeCoin): [[0, 0, \"1000000000000000000\"], [0, 1, \"1000000000000000000\"]]\n     */\n    function depositBAKC(PairNftWithAmount[] calldata _baycPairs, PairNftWithAmount[] calldata _maycPairs) external {\n        updatePool(BAKC_POOL_ID);\n        _depositPairNft(BAYC_POOL_ID, _baycPairs);\n        _depositPairNft(MAYC_POOL_ID, _maycPairs);\n    }\n\n    // Claim Rewards Methods\n\n    /**\n     * @notice Claim rewards for msg.sender and send to recipient\n     * @param _recipient Address to send claim reward to\n     */\n    function claimApeCoin(address _recipient) public {\n        updatePool(APECOIN_POOL_ID);\n\n        Position storage position = addressPosition[msg.sender];\n        uint256 rewardsToBeClaimed = _claim(APECOIN_POOL_ID, position, _recipient);\n\n        emit ClaimRewards(msg.sender, rewardsToBeClaimed, _recipient);\n    }\n\n    /// @notice Claim and send rewards\n    function claimSelfApeCoin() external {\n        claimApeCoin(msg.sender);\n    }\n\n    /**\n     * @notice Claim rewards for array of BAYC NFTs and send to recipient\n     * @param _nfts Array of NFTs owned and committed by the msg.sender\n     * @param _recipient Address to send claim reward to\n     */\n    function claimBAYC(uint256[] calldata _nfts, address _recipient) external {\n        _claimNft(BAYC_POOL_ID, _nfts, _recipient);\n    }\n\n    /**\n     * @notice Claim rewards for array of BAYC NFTs\n     * @param _nfts Array of NFTs owned and committed by the msg.sender\n     */\n    function claimSelfBAYC(uint256[] calldata _nfts) external {\n        _claimNft(BAYC_POOL_ID, _nfts, msg.sender);\n    }\n\n    /**\n     * @notice Claim rewards for array of MAYC NFTs and send to recipient\n     * @param _nfts Array of NFTs owned and committed by the msg.sender\n     * @param _recipient Address to send claim reward to\n     */\n    function claimMAYC(uint256[] calldata _nfts, address _recipient) external {\n        _claimNft(MAYC_POOL_ID, _nfts, _recipient);\n    }\n\n    /**\n     * @notice Claim rewards for array of MAYC NFTs\n     * @param _nfts Array of NFTs owned and committed by the msg.sender\n     */\n    function claimSelfMAYC(uint256[] calldata _nfts) external {\n        _claimNft(MAYC_POOL_ID, _nfts, msg.sender);\n    }\n\n    /**\n     * @notice Claim rewards for array of Paired NFTs and send to recipient\n     * @param _baycPairs Array of Paired BAYC NFTs owned and committed by the msg.sender\n     * @param _maycPairs Array of Paired MAYC NFTs owned and committed by the msg.sender\n     * @param _recipient Address to send claim reward to\n     */\n    function claimBAKC(PairNft[] calldata _baycPairs, PairNft[] calldata _maycPairs, address _recipient) public {\n        updatePool(BAKC_POOL_ID);\n        _claimPairNft(BAYC_POOL_ID, _baycPairs, _recipient);\n        _claimPairNft(MAYC_POOL_ID, _maycPairs, _recipient);\n    }\n\n    /**\n     * @notice Claim rewards for array of Paired NFTs\n     * @param _baycPairs Array of Paired BAYC NFTs owned and committed by the msg.sender\n     * @param _maycPairs Array of Paired MAYC NFTs owned and committed by the msg.sender\n     */\n    function claimSelfBAKC(PairNft[] calldata _baycPairs, PairNft[] calldata _maycPairs) external {\n        claimBAKC(_baycPairs, _maycPairs, msg.sender);\n    }\n\n    // Uncommit/Withdraw Methods\n\n    /**\n     * @notice Withdraw staked ApeCoin from the ApeCoin pool.  Performs an automatic claim as part of the withdraw process.\n     * @param _amount Amount of ApeCoin\n     * @param _recipient Address to send withdraw amount and claim to\n     */\n    function withdrawApeCoin(uint256 _amount, address _recipient) public {\n        updatePool(APECOIN_POOL_ID);\n\n        Position storage position = addressPosition[msg.sender];\n        if (_amount == position.stakedAmount) {\n            uint256 rewardsToBeClaimed = _claim(APECOIN_POOL_ID, position, _recipient);\n            emit ClaimRewards(msg.sender, rewardsToBeClaimed, _recipient);\n        }\n        _withdraw(APECOIN_POOL_ID, position, _amount, _recipient);\n        emit Withdraw(msg.sender, _amount, _recipient);\n    }\n\n    /**\n     * @notice Withdraw staked ApeCoin from the ApeCoin pool.  If withdraw is total staked amount, performs an automatic claim.\n     * @param _amount Amount of ApeCoin\n     */\n    function withdrawSelfApeCoin(uint256 _amount) external {\n        withdrawApeCoin(_amount, msg.sender);\n    }\n\n    /**\n     * @notice Withdraw staked ApeCoin from the BAYC pool.  If withdraw is total staked amount, performs an automatic claim.\n     * @param _nfts Array of BAYC NFT's with staked amounts\n     * @param _recipient Address to send withdraw amount and claim to\n     */\n    function withdrawBAYC(SingleNft[] calldata _nfts, address _recipient) external {\n        _withdrawNft(BAYC_POOL_ID, _nfts, _recipient);\n    }\n\n    /**\n     * @notice Withdraw staked ApeCoin from the BAYC pool.  If withdraw is total staked amount, performs an automatic claim.\n     * @param _nfts Array of BAYC NFT's with staked amounts\n     */\n    function withdrawSelfBAYC(SingleNft[] calldata _nfts) external {\n        _withdrawNft(BAYC_POOL_ID, _nfts, msg.sender);\n    }\n\n    /**\n     * @notice Withdraw staked ApeCoin from the MAYC pool.  If withdraw is total staked amount, performs an automatic claim.\n     * @param _nfts Array of MAYC NFT's with staked amounts\n     * @param _recipient Address to send withdraw amount and claim to\n     */\n    function withdrawMAYC(SingleNft[] calldata _nfts, address _recipient) external {\n        _withdrawNft(MAYC_POOL_ID, _nfts, _recipient);\n    }\n\n    /**\n     * @notice Withdraw staked ApeCoin from the MAYC pool.  If withdraw is total staked amount, performs an automatic claim.\n     * @param _nfts Array of MAYC NFT's with staked amounts\n     */\n    function withdrawSelfMAYC(SingleNft[] calldata _nfts) external {\n        _withdrawNft(MAYC_POOL_ID, _nfts, msg.sender);\n    }\n\n    /**\n     * @notice Withdraw staked ApeCoin from the Pair pool.  If withdraw is total staked amount, performs an automatic claim.\n     * @param _baycPairs Array of Paired BAYC NFT's with staked amounts\n     * @param _maycPairs Array of Paired MAYC NFT's with staked amounts\n     * @dev if pairs have split ownership and BAKC is attempting a withdraw, the withdraw must be for the total staked amount\n     */\n    function withdrawBAKC(PairNftWithAmount[] calldata _baycPairs, PairNftWithAmount[] calldata _maycPairs) external {\n        updatePool(BAKC_POOL_ID);\n        _withdrawPairNft(BAYC_POOL_ID, _baycPairs);\n        _withdrawPairNft(MAYC_POOL_ID, _maycPairs);\n    }\n\n    // Time Range Methods\n\n    /**\n     * @notice Add single time range with a given rewards per hour for a given pool\n     * @dev In practice one Time Range will represent one quarter (defined by `_startTimestamp`and `_endTimeStamp` as whole hours)\n     * where the rewards per hour is constant for a given pool.\n     * @param _poolId Available pool values 0-3\n     * @param _amount Total amount of ApeCoin to be distributed over the range\n     * @param _startTimestamp Whole hour timestamp representation\n     * @param _endTimeStamp Whole hour timestamp representation\n     * @param _capPerPosition Per position cap amount determined by poolId\n     */\n    function addTimeRange(\n        uint256 _poolId,\n        uint256 _amount,\n        uint256 _startTimestamp,\n        uint256 _endTimeStamp,\n        uint256 _capPerPosition) external onlyOwner\n    {\n        require (_poolId < 4, \"Invalid poolId\");\n        require (_startTimestamp < _endTimeStamp, \"_startTimestamp should be less than _endTimeStamp\");\n        require(getMinute(_startTimestamp) == 0 && getSecond(_startTimestamp) == 0, \"_startTimestamp is not a whole hour\");\n        require(getMinute(_endTimeStamp) == 0 && getSecond(_endTimeStamp) == 0, \"_endTimeStamp is not a whole hour\");\n\n        Pool storage pool = pools[_poolId];\n        require(pool.timeRanges.length == 0 || _startTimestamp == pool.timeRanges[pool.timeRanges.length-1].endTimestampHour\n            ,\"_startTimestamp should be equal to the last endTimestampHour\");\n\n        uint256 hoursInSeconds = _endTimeStamp - _startTimestamp;\n        uint256 rewardsPerHour = _amount * SECONDS_PER_HOUR / hoursInSeconds;\n\n        TimeRange memory next = TimeRange(_startTimestamp, _endTimeStamp, rewardsPerHour, _capPerPosition);\n        pool.timeRanges.push(next);\n    }\n\n    /**\n     * @notice Removes the last Time Range for a given pool.\n     * @param _poolId Available pool values 0-3\n     */\n    function removeLastTimeRange(uint256 _poolId) external onlyOwner {\n        Pool storage pool = pools[_poolId];\n        pool.timeRanges.pop();\n    }\n\n    /**\n     * @return A Pool's timeRanges TimeRange struct by index.\n     * @param _poolId Available pool values 0-3\n     * @param _index Target index in a Pool's timeRanges array\n     */\n    function getTimeRangeBy(uint256 _poolId, uint256 _index) public view returns (TimeRange memory) {\n        Pool memory pool = pools[_poolId];\n        return pool.timeRanges[_index];\n    }\n\n    // Pool Methods\n\n    /**\n     * @return The amount of ApeCoin rewards to be distributed by pool for a given time range\n     * @param _poolId Available pool values 0-3\n     * @param _from Whole hour timestamp representation\n     * @param _to Whole hour timestamp representation\n     */\n    function rewardsBy(uint256 _poolId, uint256 _from, uint256 _to) public view returns (uint256, uint256) {\n        Pool memory pool = pools[_poolId];\n        if(_to < pool.timeRanges[0].startTimestampHour) return (0, pool.lastRewardsRangeIndex);\n\n        uint256 currentIndex = pool.lastRewardsRangeIndex;\n        while(_from > pool.timeRanges[currentIndex].endTimestampHour && _to > pool.timeRanges[currentIndex].endTimestampHour) {\n            ++currentIndex;\n        }\n\n        uint256 rewards;\n        for(uint256 i = currentIndex; i < pool.timeRanges.length; ++i) {\n            TimeRange memory current = pool.timeRanges[i];\n\n            uint256 startTimestampHour = _from <= current.startTimestampHour ? current.startTimestampHour : _from;\n            uint256 endTimestampHour = _to <= current.endTimestampHour ? _to : current.endTimestampHour;\n            rewards = rewards + (endTimestampHour - startTimestampHour) * current.rewardsPerHour / SECONDS_PER_HOUR;\n\n            if(_to <= endTimestampHour) {\n                return (rewards, i);\n            }\n        }\n\n        return (rewards, pool.timeRanges.length - 1);\n    }\n\n    /**\n     * @dev Updates reward variables `lastRewardedTimestampHour`, `accumulatedRewardsPerShare` and `lastRewardsRangeIndex`\n     * for a given pool.\n     * @param _poolId Available pool values 0-3\n     */\n    function updatePool(uint256 _poolId) public {\n        Pool storage pool = pools[_poolId];\n\n        if (block.timestamp < pool.timeRanges[0].startTimestampHour) return;\n        if (block.timestamp <= pool.lastRewardedTimestampHour + SECONDS_PER_HOUR) return;\n\n        uint256 lastTimestampHour = pool.timeRanges[pool.timeRanges.length-1].endTimestampHour;\n        uint256 previousTimestampHour = getPreviousTimestampHour(block.timestamp);\n\n        if (pool.stakedAmount == 0) {\n            pool.lastRewardedTimestampHour = previousTimestampHour > lastTimestampHour ? lastTimestampHour : previousTimestampHour;\n            return;\n        }\n\n        (uint256 rewards, uint256 index) = rewardsBy(_poolId, pool.lastRewardedTimestampHour, previousTimestampHour);\n        if (pool.lastRewardsRangeIndex != index) {\n            pool.lastRewardsRangeIndex = index;\n        }\n        pool.accumulatedRewardsPerShare = pool.accumulatedRewardsPerShare + (rewards * APE_COIN_PRECISION) / pool.stakedAmount;\n        pool.lastRewardedTimestampHour = previousTimestampHour > lastTimestampHour ? lastTimestampHour : previousTimestampHour;\n\n        emit UpdatePool(_poolId, pool.lastRewardedTimestampHour, pool.stakedAmount, pool.accumulatedRewardsPerShare);\n    }\n\n    // Read Methods\n\n    /**\n     * @return The current timeRange index for a pool.\n     * @param pool A Pool struct\n     */\n    function getCurrentTimeRangeIndex(Pool memory pool) private view returns (uint256) {\n        uint256 current = pool.lastRewardsRangeIndex;\n\n        if (block.timestamp < pool.timeRanges[current].startTimestampHour) return current;\n        for(current = pool.lastRewardsRangeIndex; current < pool.timeRanges.length; ++current) {\n            TimeRange memory currentTimeRange = pool.timeRanges[current];\n            if (currentTimeRange.startTimestampHour <= block.timestamp && block.timestamp <= currentTimeRange.endTimestampHour) return current;\n        }\n        revert(\"distribution ended\");\n    }\n\n    /**\n     * @return Relevant values for all the Pools for UI purposes.\n     */\n    function getPoolsUI() public view returns (PoolUI memory, PoolUI memory, PoolUI memory, PoolUI memory) {\n        Pool memory apeCoinPool = pools[0];\n        Pool memory baycPool = pools[1];\n        Pool memory maycPool = pools[2];\n        Pool memory bakcPool = pools[3];\n        uint256 current = getCurrentTimeRangeIndex(apeCoinPool);\n        return (PoolUI(0,apeCoinPool.stakedAmount, apeCoinPool.timeRanges[current]),\n                PoolUI(1,baycPool.stakedAmount, baycPool.timeRanges[current]),\n                PoolUI(2,maycPool.stakedAmount, maycPool.timeRanges[current]),\n                PoolUI(3,bakcPool.stakedAmount, bakcPool.timeRanges[current]));\n    }\n\n    /**\n     * @return staked amount for addressPosition [APECOIN] and nftPositions [BAYC, MAYC, and Pair(BAKC)] for voting.\n     */\n    function stakedTotal(address _addr) external view returns (uint256) {\n        uint256 total = addressPosition[_addr].stakedAmount;\n\n        total += _stakedTotal(BAYC_POOL_ID, _addr);\n        total += _stakedTotal(MAYC_POOL_ID, _addr);\n        total += _stakedTotalPair(_addr);\n\n        return total;\n    }\n\n    function _stakedTotal(uint256 _poolId, address _addr) private view returns (uint256) {\n        uint256 total = 0;\n        uint256 nftCount = nftContracts[_poolId].balanceOf(_addr);\n        for(uint256 i = 0; i < nftCount; ++i) {\n            uint256 tokenId = nftContracts[_poolId].tokenOfOwnerByIndex(_addr, i);\n            total += nftPosition[_poolId][tokenId].stakedAmount;\n        }\n\n        return total;\n    }\n\n    function _stakedTotalPair(address _addr) private view returns (uint256) {\n        uint256 total = 0;\n\n        uint256 nftCount = nftContracts[BAYC_POOL_ID].balanceOf(_addr);\n        for(uint256 i = 0; i < nftCount; ++i) {\n            uint256 baycTokenId = nftContracts[BAYC_POOL_ID].tokenOfOwnerByIndex(_addr, i);\n            if (mainToBakc[BAYC_POOL_ID][baycTokenId].isPaired) {\n                uint256 bakcTokenId = mainToBakc[BAYC_POOL_ID][baycTokenId].tokenId;\n                total += nftPosition[BAKC_POOL_ID][bakcTokenId].stakedAmount;\n            }\n        }\n\n        nftCount = nftContracts[MAYC_POOL_ID].balanceOf(_addr);\n        for(uint256 i = 0; i < nftCount; ++i) {\n            uint256 maycTokenId = nftContracts[MAYC_POOL_ID].tokenOfOwnerByIndex(_addr, i);\n            if (mainToBakc[MAYC_POOL_ID][maycTokenId].isPaired) {\n                uint256 bakcTokenId = mainToBakc[MAYC_POOL_ID][maycTokenId].tokenId;\n                total += nftPosition[BAKC_POOL_ID][bakcTokenId].stakedAmount;\n            }\n        }\n\n        return total;\n    }\n\n    /**\n     * @return staked amount, pending rewards, and estimated rewards over the last 24 hours\n     *      for addressPosition [APECOIN, BAYC, MAYC, BAKC].\n     */\n    function getAllStakes(address _address) public view returns (DashboardStake[] memory) {\n\n        DashboardStake memory apeCoinStake = getApeCoinStake(_address);\n        DashboardStake[] memory baycStakes = getBaycStakes(_address);\n        DashboardStake[] memory maycStakes = getMaycStakes(_address);\n        DashboardStake[] memory bakcStakes = getBakcStakes(_address);\n        DashboardStake[] memory splitStakes = getSplitStakes(_address);\n\n        uint256 count = (baycStakes.length + maycStakes.length + bakcStakes.length + splitStakes.length + 1);\n        DashboardStake[] memory allStakes = new DashboardStake[](count);\n\n        uint256 offset = 0;\n        allStakes[offset] = apeCoinStake;\n        ++offset;\n\n        for(uint256 i = 0; i < baycStakes.length; ++i) {\n            allStakes[offset] = baycStakes[i];\n            ++offset;\n        }\n\n        for(uint256 i = 0; i < maycStakes.length; ++i) {\n            allStakes[offset] = maycStakes[i];\n            ++offset;\n        }\n\n        for(uint256 i = 0; i < bakcStakes.length; ++i) {\n            allStakes[offset] = bakcStakes[i];\n            ++offset;\n        }\n\n        for(uint256 i = 0; i < splitStakes.length; ++i) {\n            allStakes[offset] = splitStakes[i];\n            ++offset;\n        }\n\n        return allStakes;\n    }\n\n    /**\n     * @return staked amount, pending rewards, and estimated rewards over the last 24 hours\n     *      for addressPosition [APECOIN].\n     */\n    function getApeCoinStake(address _address) public view returns (DashboardStake memory) {\n        uint256 tokenId = 0;\n        uint256 deposited = addressPosition[_address].stakedAmount;\n        uint256 unclaimed = deposited > 0 ? this.pendingRewards(0, _address, tokenId) : 0;\n        uint256 rewards24Hrs = deposited > 0 ? _estimate24HourRewards(0, _address, 0) : 0;\n\n        return DashboardStake(APECOIN_POOL_ID, tokenId, deposited, unclaimed, rewards24Hrs, NULL_PAIR);\n    }\n\n    /**\n     * @return staked amount, pending rewards, and estimated rewards over the last 24 hours\n     *      for addressPosition [BAYC].\n     */\n    function getBaycStakes(address _address) public view returns (DashboardStake[] memory) {\n        return _getStakes(_address, BAYC_POOL_ID);\n    }\n\n    /**\n     * @return staked amount, pending rewards, and estimated rewards over the last 24 hours\n     *      for addressPosition [MAYC].\n     */\n    function getMaycStakes(address _address) public view returns (DashboardStake[] memory) {\n        return _getStakes(_address, MAYC_POOL_ID);\n    }\n\n    /**\n     * @return staked amount, pending rewards, and estimated rewards over the last 24 hours\n     *      for addressPosition [BAKC].\n     */\n    function getBakcStakes(address _address) public view returns (DashboardStake[] memory) {\n        return _getStakes(_address, BAKC_POOL_ID);\n    }\n\n    /**\n     * @return staked amount, pending rewards, and estimated rewards over the last 24 hours\n     *      for addressPosition when BAKC Pool Pair is split.\n     *      ie (BAYC/MAYC) and BAKC in pair pool have different owners.\n     */\n    function getSplitStakes(address _address) public view returns (DashboardStake[] memory) {\n        uint256 baycSplits = _getSplitStakeCount(nftContracts[BAYC_POOL_ID].balanceOf(_address), _address, BAYC_POOL_ID);\n        uint256 maycSplits = _getSplitStakeCount(nftContracts[MAYC_POOL_ID].balanceOf(_address), _address, MAYC_POOL_ID);\n        uint256 totalSplits = baycSplits + maycSplits;\n\n        if(totalSplits == 0) {\n            return new DashboardStake[](0);\n        }\n\n        DashboardStake[] memory baycSplitStakes = _getSplitStakes(baycSplits, _address, BAYC_POOL_ID);\n        DashboardStake[] memory maycSplitStakes = _getSplitStakes(maycSplits, _address, MAYC_POOL_ID);\n\n        DashboardStake[] memory splitStakes = new DashboardStake[](totalSplits);\n        uint256 offset = 0;\n        for(uint256 i = 0; i < baycSplitStakes.length; ++i) {\n            splitStakes[offset] = baycSplitStakes[i];\n            ++offset;\n        }\n\n        for(uint256 i = 0; i < maycSplitStakes.length; ++i) {\n            splitStakes[offset] = maycSplitStakes[i];\n            ++offset;\n        }\n\n        return splitStakes;\n    }\n\n    function _getSplitStakes(uint256 splits, address _address, uint256 _mainPoolId) private view returns (DashboardStake[] memory) {\n\n        DashboardStake[] memory dashboardStakes = new DashboardStake[](splits);\n        uint256 counter;\n\n        for(uint256 i = 0; i < nftContracts[_mainPoolId].balanceOf(_address); ++i) {\n            uint256 mainTokenId = nftContracts[_mainPoolId].tokenOfOwnerByIndex(_address, i);\n            if(mainToBakc[_mainPoolId][mainTokenId].isPaired) {\n                uint256 bakcTokenId = mainToBakc[_mainPoolId][mainTokenId].tokenId;\n                address currentOwner = nftContracts[BAKC_POOL_ID].ownerOf(bakcTokenId);\n\n                /* Split Pair Check*/\n                if (currentOwner != _address) {\n                    uint256 deposited = nftPosition[BAKC_POOL_ID][bakcTokenId].stakedAmount;\n                    uint256 unclaimed = deposited > 0 ? this.pendingRewards(BAKC_POOL_ID, currentOwner, bakcTokenId) : 0;\n                    uint256 rewards24Hrs = deposited > 0 ? _estimate24HourRewards(BAKC_POOL_ID, currentOwner, bakcTokenId): 0;\n\n                    DashboardPair memory pair = NULL_PAIR;\n                    if(bakcToMain[bakcTokenId][_mainPoolId].isPaired) {\n                        pair = DashboardPair(bakcToMain[bakcTokenId][_mainPoolId].tokenId, _mainPoolId);\n                    }\n\n                    DashboardStake memory dashboardStake = DashboardStake(BAKC_POOL_ID, bakcTokenId, deposited, unclaimed, rewards24Hrs, pair);\n                    dashboardStakes[counter] = dashboardStake;\n                    ++counter;\n                }\n            }\n        }\n\n        return dashboardStakes;\n    }\n\n    function _getSplitStakeCount(uint256 nftCount, address _address, uint256 _mainPoolId) private view returns (uint256) {\n        uint256 splitCount;\n        for(uint256 i = 0; i < nftCount; ++i) {\n            uint256 mainTokenId = nftContracts[_mainPoolId].tokenOfOwnerByIndex(_address, i);\n            if(mainToBakc[_mainPoolId][mainTokenId].isPaired) {\n                uint256 bakcTokenId = mainToBakc[_mainPoolId][mainTokenId].tokenId;\n                address currentOwner = nftContracts[BAKC_POOL_ID].ownerOf(bakcTokenId);\n                if (currentOwner != _address) {\n                    ++splitCount;\n                }\n            }\n        }\n\n        return splitCount;\n    }\n\n    function _getStakes(address _address, uint256 _poolId) private view returns (DashboardStake[] memory) {\n        uint256 nftCount = nftContracts[_poolId].balanceOf(_address);\n        DashboardStake[] memory dashboardStakes = nftCount > 0 ? new DashboardStake[](nftCount) : new DashboardStake[](0);\n\n        if(nftCount == 0) {\n            return dashboardStakes;\n        }\n\n        for(uint256 i = 0; i < nftCount; ++i) {\n            uint256 tokenId = nftContracts[_poolId].tokenOfOwnerByIndex(_address, i);\n            uint256 deposited = nftPosition[_poolId][tokenId].stakedAmount;\n            uint256 unclaimed = deposited > 0 ? this.pendingRewards(_poolId, _address, tokenId) : 0;\n            uint256 rewards24Hrs = deposited > 0 ? _estimate24HourRewards(_poolId, _address, tokenId): 0;\n\n            DashboardPair memory pair = NULL_PAIR;\n            if(_poolId == BAKC_POOL_ID) {\n                if(bakcToMain[tokenId][BAYC_POOL_ID].isPaired) {\n                    pair = DashboardPair(bakcToMain[tokenId][BAYC_POOL_ID].tokenId, BAYC_POOL_ID);\n                } else if(bakcToMain[tokenId][MAYC_POOL_ID].isPaired) {\n                    pair = DashboardPair(bakcToMain[tokenId][MAYC_POOL_ID].tokenId, MAYC_POOL_ID);\n                }\n            }\n\n            DashboardStake memory dashboardStake = DashboardStake(_poolId, tokenId, deposited, unclaimed, rewards24Hrs, pair);\n            dashboardStakes[i] = dashboardStake;\n        }\n\n        return dashboardStakes;\n    }\n\n    function _estimate24HourRewards(uint256 _poolId, address _address, uint256 _tokenId) private view returns (uint256) {\n        Pool memory pool = pools[_poolId];\n        Position memory position = _poolId == 0 ? addressPosition[_address]: nftPosition[_poolId][_tokenId];\n\n        TimeRange memory rewards = getTimeRangeBy(_poolId, pool.lastRewardsRangeIndex);\n        return (position.stakedAmount * rewards.rewardsPerHour * 24) / pool.stakedAmount;\n    }\n\n    /**\n     * @return current amount of claimable $APE rewards for a given position from a given pool.\n     * @param _poolId Available pool values 0-3\n     * @param _address Address to lookup Position for\n     * @param _tokenId An NFT id\n     */\n    function pendingRewards(uint256 _poolId, address _addres"
    }
  ]
}