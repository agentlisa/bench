{
  "Title": "[C02] Repeatedly resolve proposals",
  "Content": "The `resolveProposal` function of the `Proposer` contract [simply validates](https://github.com/UMAprotocol/protocol/blob/0c4cea3c3d5e48da6f8984b8ba3afdfea4ce47cc/packages/core/contracts/oracle/implementation/Proposer.sol#L78-L81) that the oracle has resolved, but does not check if the bond has been distributed. This means the same proposal can be resolved multiple times, resulting in duplicate bond payments. Consider flagging or deleting existing proposals when they are resolved.\n\n\n**Update:** *Fixed as of commit [`b152718`](https://github.com/UMAprotocol/protocol/pull/3689/commits/b15271849bd002fa76d109d46b4aca0cfdd3890f) in [PR3689](https://github.com/UMAprotocol/protocol/pull/3689).*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "packages/core/contracts/oracle/implementation/Proposer.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"./Finder.sol\";\nimport \"./Governor.sol\";\nimport \"./Constants.sol\";\nimport \"./Voting.sol\";\nimport \"./AdminIdentifierLib.sol\";\nimport \"../../common/implementation/Lockable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title Proposer contract that allows anyone to make governance proposals with a bond.\n */\ncontract Proposer is Ownable, Testable, Lockable {\n    using SafeERC20 for IERC20;\n    IERC20 public token;\n    uint256 public bond;\n    Governor public governor;\n    Finder public finder;\n\n    struct BondedProposal {\n        address sender;\n        // 64 bits to save a storage slot.\n        uint64 time;\n        uint256 lockedBond;\n    }\n    mapping(uint256 => BondedProposal) public bondedProposals;\n\n    event BondSet(uint256 bond);\n    event ProposalResolved(uint256 indexed id, bool success);\n\n    /**\n     * @notice Construct the Proposer contract.\n     * @param _token the ERC20 token that the bond is paid in.\n     * @param _bond the bond amount.\n     * @param _governor the governor contract that this contract makes proposals to.\n     * @param _finder the finder contract used to look up addresses.\n     * @param _timer the timer contract to control the output of getCurrentTime(). Set to 0x0 if in production.\n     */\n    constructor(\n        IERC20 _token,\n        uint256 _bond,\n        Governor _governor,\n        Finder _finder,\n        address _timer\n    ) Testable(_timer) {\n        token = _token;\n        governor = _governor;\n        finder = _finder;\n        setBond(_bond);\n        transferOwnership(address(_governor));\n    }\n\n    /**\n     * @notice Propose a new set of governance transactions for vote.\n     * @dev Pulls bond from the caller.\n     * @param transactions list of transactions for the governor to execute.\n     * @return id the id of the governor proposal.\n     */\n    function propose(Governor.Transaction[] memory transactions) external nonReentrant() returns (uint256 id) {\n        id = governor.numProposals();\n        token.safeTransferFrom(msg.sender, address(this), bond);\n        bondedProposals[id] = BondedProposal({ sender: msg.sender, lockedBond: bond, time: uint64(getCurrentTime()) });\n        governor.propose(transactions);\n    }\n\n    /**\n     * @notice Resolves a proposal by checking the status of the request in the Voting contract.\n     * @dev For the resolution to work correctly, this contract must be a registered contract in the DVM.\n     * @param id proposal id.\n     */\n    function resolveProposal(uint256 id) external nonReentrant() {\n        BondedProposal storage bondedProposal = bondedProposals[id];\n        Voting voting = Voting(finder.getImplementationAddress(OracleInterfaces.Oracle));\n        require(\n            voting.hasPrice(AdminIdentifierLib._constructIdentifier(id), bondedProposal.time, \"\"),\n            \"No price resolved\"\n        );\n        if (voting.getPrice(AdminIdentifierLib._constructIdentifier(id), bondedProposal.time, \"\") != 0) {\n            token.safeTransfer(bondedProposal.sender, bondedProposal.lockedBond);\n            emit ProposalResolved(id, true);\n        } else {\n            token.safeTransfer(finder.getImplementationAddress(OracleInterfaces.Store), bondedProposal.lockedBond);\n            emit ProposalResolved(id, false);\n        }\n    }\n\n    /**\n     * @notice Admin method to set the bond amount.\n     * @dev Admin is intended to be the governance system, itself.\n     * @param _bond the new bond.\n     */\n    function setBond(uint256 _bond) public nonReentrant() onlyOwner() {\n        bond = _bond;\n        emit BondSet(_bond);\n    }\n}"
    }
  ]
}