{
  "Title": "[02] Custom error misleading name",
  "Content": "The name of the following custom error should be renamed as follows to be more in line of its intended purpose:\n\nhttps://github.com/GenerationSoftware/pt-v5-cgda-liquidator/blob/7f95bcacd4a566c2becb98d55c1886cadbaa8897/src/LiquidationPair.sol#L12\n\n```diff\n- error TargetFirstSaleTimeLtPeriodLength(uint passedTargetSaleTime, uint periodLength);\n+ error TargetFirstSaleTimeGtPeriodLength(uint passedTargetSaleTime, uint periodLength);\n```\n\nhttps://github.com/GenerationSoftware/pt-v5-cgda-liquidator/blob/7f95bcacd4a566c2becb98d55c1886cadbaa8897/src/LiquidationPair.sol#L118-L120\n\n```diff\n    if (targetFirstSaleTime >= periodLength) {\n-      revert TargetFirstSaleTimeLtPeriodLength(targetFirstSaleTime, periodLength);\n+      revert TargetFirstSaleTimeGtPeriodLength(targetFirstSaleTime, periodLength);\n    }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-08-pooltogether",
  "Code": [
    {
      "filename": "src/LiquidationPair.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport { ILiquidationSource } from \"pt-v5-liquidator-interfaces/ILiquidationSource.sol\";\nimport { ILiquidationPair } from \"pt-v5-liquidator-interfaces/ILiquidationPair.sol\";\nimport { SD59x18, uEXP_MAX_INPUT, wrap, convert, unwrap } from \"prb-math/SD59x18.sol\";\n\nimport { ContinuousGDA } from \"./libraries/ContinuousGDA.sol\";\n\nerror AmountInZero();\nerror AmountOutZero();\nerror TargetFirstSaleTimeLtPeriodLength(uint passedTargetSaleTime, uint periodLength);\nerror SwapExceedsAvailable(uint256 amountOut, uint256 available);\nerror SwapExceedsMax(uint256 amountInMax, uint256 amountIn);\nerror DecayConstantTooLarge(SD59x18 maxDecayConstant, SD59x18 decayConstant);\nerror PurchasePriceIsZero(uint256 amountOut);\n\n/***\n * @title LiquidationPair\n * @author G9 Software Inc.\n * @notice Auctions one token for another in a periodic continuous gradual dutch auction. Auctions occur over a limit period so that the price can be adjusted.\n * @dev This contract is designed to be used with the LiquidationRouter contract.\n */\ncontract LiquidationPair is ILiquidationPair {\n\n  /* ============ Variables ============ */\n\n  /// @notice The liquidation source that the pair is using.  The source executes the actual token swap, while the pair handles the pricing.\n  ILiquidationSource public immutable source;\n\n  /// @notice The token that is used to pay for auctions\n  address public immutable tokenIn;\n\n  /// @notice The token that is being auctioned.\n  address public immutable tokenOut;\n\n  /// @notice The rate at which the price decays\n  SD59x18 public immutable decayConstant;\n\n  /// @notice The duration of each auction.\n  uint256 public immutable periodLength;\n\n  /// @notice Sets the beginning timestamp for the first period.\n  /// @dev Ensure that the periodOffset is in the past.\n  uint256 public immutable periodOffset;\n\n  /// @notice The time within an auction at which the price of available tokens matches the previous non-zero exchange rate.\n  uint32 public immutable targetFirstSaleTime;\n\n  /// @notice Require a minimum number of tokens before an auction is triggered.\n  /// @dev This is important, because the gas cost ultimately determines the efficiency of the swap.\n  /// If gas cost to auction is 10 cents and the auction is for 11 cents, then the auction price will be driven to zero to make up for the difference.\n  /// If gas cost is 10 cents and we're seeking an efficiency of at least 90%, then the minimum auction amount should be $1 worth of tokens.\n  uint256 public immutable minimumAuctionAmount;\n\n  /// @notice The last non-zero total tokens in for an auction. This is used to configure the target price for the next auction.\n  uint112 _lastNonZeroAmountIn;\n\n  /// @notice The last non-zero total tokens out for an auction.  This is used to configure the target price for the next auction.\n  uint112 _lastNonZeroAmountOut;\n\n  /// @notice The total tokens in for the current auction.\n  uint96 _amountInForPeriod;\n\n  /// @notice The total tokens out for the current auction.\n  uint96 _amountOutForPeriod;\n\n  /// @notice The current auction period. Note that this number can wrap.\n  uint16 _period;\n\n  /// @notice The timestamp at which emissions have been consumed to for the current auction\n  uint48 _lastAuctionTime;\n\n  /// @notice The rate of token emissions for the current auction\n  SD59x18 _emissionRate;\n\n  /// @notice The initial price for the current auction\n  SD59x18 _initialPrice;\n\n  /* ============ Constructor ============ */\n\n  /// @notice Construct a new pair\n  /// @param _source The liquidation source to use for the pair\n  /// @param _tokenIn The token that is used to pay for auctions\n  /// @param _tokenOut The token that is being auctioned\n  /// @param _periodLength The duration of each auction.\n  /// @param _periodOffset Sets the beginning timestamp for the first period\n  /// @param _targetFirstSaleTime The time within an auction at which the price of available tokens matches the previous non-zero exchange rate\n  /// @param _decayConstant The rate at which the price decays\n  /// @param _initialAmountIn The initial amount of tokens in for the first auction (used for the initial exchange rate)\n  /// @param _initialAmountOut The initial amount of tokens out for the first auction (used for the initial exchange rate)\n  /// @param _minimumAuctionAmount Require a minimum number of tokens before an auction is triggered.\n  constructor(\n    ILiquidationSource _source,\n    address _tokenIn,\n    address _tokenOut,\n    uint32 _periodLength,\n    uint32 _periodOffset,\n    uint32 _targetFirstSaleTime,\n    SD59x18 _decayConstant,\n    uint112 _initialAmountIn,\n    uint112 _initialAmountOut,\n    uint256 _minimumAuctionAmount\n  ) {\n    source = _source;\n    tokenIn = _tokenIn;\n    tokenOut = _tokenOut;\n    decayConstant = _decayConstant;\n    periodLength = _periodLength;\n    periodOffset = _periodOffset;\n    targetFirstSaleTime = _targetFirstSaleTime;\n\n    SD59x18 period59 = convert(int256(uint256(_periodLength)));\n    if (_decayConstant.mul(period59).unwrap() > uEXP_MAX_INPUT) {\n      revert DecayConstantTooLarge(wrap(uEXP_MAX_INPUT).div(period59), _decayConstant);\n    }\n\n    if (targetFirstSaleTime >= periodLength) {\n      revert TargetFirstSaleTimeLtPeriodLength(targetFirstSaleTime, periodLength);\n    }\n\n    if (_initialAmountIn == 0) {\n      revert AmountInZero();\n    }\n\n    if (_initialAmountOut == 0) {\n      revert AmountOutZero();\n    }\n\n    _lastNonZeroAmountIn = _initialAmountIn;\n    _lastNonZeroAmountOut = _initialAmountOut;\n    minimumAuctionAmount = _minimumAuctionAmount;\n\n    _updateAuction(0);\n  }\n\n  /* ============ External Read Methods ============ */\n\n  /// @inheritdoc ILiquidationPair\n  function target() external returns (address) {\n    return source.targetOf(tokenIn);\n  }\n\n  /// @inheritdoc ILiquidationPair\n  function maxAmountOut() external returns (uint256) {\n    _checkUpdateAuction();\n    return _maxAmountOut();\n  }\n\n  /// @notice Returns the maximum amount of tokens in\n  /// @return The max number of tokens in\n  function maxAmountIn() external returns (uint256) {\n    _checkUpdateAuction();\n    return _computeExactAmountIn(_maxAmountOut());\n  }\n\n  /// @inheritdoc ILiquidationPair\n  function computeExactAmountIn(uint256 _amountOut) external returns (uint256) {\n    _checkUpdateAuction();\n    return _computeExactAmountIn(_amountOut);\n  }\n\n  /// @inheritdoc ILiquidationPair\n  function estimateAmountOut(uint256 __amountIn) external returns (uint256) {\n    _checkUpdateAuction();\n    return uint(convert(ContinuousGDA.purchaseAmount(\n      convert(int(__amountIn)),\n      _emissionRate,\n      _initialPrice,\n      decayConstant,\n      _getElapsedTime()\n    )));\n  }\n\n  /// @notice Returns the total input tokens for the current auction.\n  /// @return Total tokens in\n  function amountInForPeriod() external returns (uint96) {\n    _checkUpdateAuction();\n    return _amountInForPeriod;\n  }\n\n  /// @notice Returns the total output tokens for the current auction.\n  /// @return Total tokens out\n  function amountOutForPeriod() external returns (uint96) {\n    _checkUpdateAuction();\n    return _amountOutForPeriod;\n  }\n\n  /// @notice Returns the timestamp to which emissions have been consumed.\n  /// @return The timestamp to which emissions have been consumed.\n  function lastAuctionTime() external returns (uint48) {\n    _checkUpdateAuction();\n    return _lastAuctionTime;\n  }\n\n  /// @notice Returns the emission rate in tokens per second for current auction\n  /// @return The emission rate\n  function emissionRate() external returns (SD59x18) {\n    _checkUpdateAuction();\n    return _emissionRate;\n  }\n\n  /// @notice Returns the initial price for the current auction\n  /// @return The initial price\n  function initialPrice() external returns (SD59x18) {\n    _checkUpdateAuction();\n    return _initialPrice;\n  }\n\n  /// @inheritdoc ILiquidationPair\n  function swapExactAmountOut(\n    address _account,\n    uint256 _amountOut,\n    uint256 _amountInMax\n  ) external returns (uint256) {\n    _checkUpdateAuction();\n    uint swapAmountIn = _computeExactAmountIn(_amountOut);\n    if (swapAmountIn > _amountInMax) {\n      revert SwapExceedsMax(_amountInMax, swapAmountIn);\n    }\n    _amountInForPeriod += uint96(swapAmountIn);\n    _amountOutForPeriod += uint96(_amountOut);\n    _lastAuctionTime += uint48(uint256(convert(convert(int256(_amountOut)).div(_emissionRate))));\n    source.liquidate(_account, tokenIn, swapAmountIn, tokenOut, _amountOut);\n    return swapAmountIn;\n  }\n\n  /// @notice Computes the elapsed time within the auction\n  function getElapsedTime() external returns (uint256) {\n    _checkUpdateAuction();\n    return uint256(convert(_getElapsedTime()));\n  }\n\n  /// @notice Returns the current auction start time\n  /// @return The start timestamp\n  function getPeriodStart() external returns (uint256) {\n    _checkUpdateAuction();\n    return _getPeriodStart(_computePeriod());\n  }\n\n  /// @notice Returns the current auction end time\n  /// @return The end timestamp\n  function getPeriodEnd() external returns (uint256) {\n    _checkUpdateAuction();\n    return _getPeriodEnd(_computePeriod());\n  }\n\n  /// @notice Returns the last non-zero auction total input tokens\n  /// @return Total input tokens\n  function lastNonZeroAmountIn() external returns (uint112) {\n    _checkUpdateAuction();\n    return _lastNonZeroAmountIn;\n  }\n\n  /// @notice Returns the last non-zero auction total output tokens\n  /// @return Total output tokens\n  function lastNonZeroAmountOut() external returns (uint112) {\n    _checkUpdateAuction();\n    return _lastNonZeroAmountOut;\n  }\n\n  /* ============ Internal Functions ============ */\n\n  /// @notice Computes the maximum amount of output tokens that can be purchased\n  /// @return Maximum amount of output tokens\n  function _maxAmountOut() internal returns (uint256) {\n    uint emissions = uint(convert(_emissionRate.mul(_getElapsedTime())));\n    uint liquidatable = source.liquidatableBalanceOf(tokenOut);\n    return emissions > liquidatable ? liquidatable : emissions;\n  }\n\n  /// @notice Computes the current emission rate given the available source balance of the output token\n  /// @return The current emission rate\n  function _computeEmissionRate() internal returns (SD59x18) {\n    uint256 amount = source.liquidatableBalanceOf(tokenOut);\n    // console2.log(\"_computeEmissionRate amount\", amount);\n    if (amount < minimumAuctionAmount) {\n      // do not release funds if the minimum is not met\n      amount = 0;\n      // console2.log(\"AMOUNT IS ZERO\");\n    }\n    return convert(int256(amount)).div(convert(int32(int(periodLength))));\n  }\n\n  /// @notice Computes the elapsed time within the current auction\n  /// @return The elapsed time\n  function _getElapsedTime() internal view returns (SD59x18) {\n    if (block.timestamp < _lastAuctionTime) {\n      return wrap(0);\n    }\n    return convert(int256(block.timestamp)).sub(convert(int256(uint256(_lastAuctionTime))));\n  }\n\n  /// @notice Computes the exact amount of input tokens required to purchase the given amount of output tokens\n  /// @param _amountOut The number of output tokens desired\n  /// @return The number of input tokens needed\n  function _computeExactAmountIn(uint256 _amountOut) internal returns (uint256) {\n    if (_amountOut == 0) {\n      return 0;\n    }\n    uint256 maxOut = _maxAmountOut();\n    if (_amountOut > maxOut) {\n      revert SwapExceedsAvailable(_amountOut, maxOut);\n    }\n    SD59x18 elapsed = _getElapsedTime();\n    uint purchasePrice = uint256(convert(ContinuousGDA.purchasePrice(\n        convert(int(_amountOut)),\n        _emissionRate,\n        _initialPrice,\n        decayConstant,\n        elapsed\n      ).ceil()));\n\n    if (purchasePrice == 0) {\n      revert PurchasePriceIsZero(_amountOut);\n    }\n\n    return purchasePrice;\n  }\n\n  /// @notice Checks to see if a new auction has started, and updates the state if so\n  function _checkUpdateAuction() internal {\n    uint256 currentPeriod = _computePeriod();\n    if (currentPeriod != _period) {\n      _updateAuction(currentPeriod);\n    }\n  }\n\n  /// @notice Updates the current auction to the given period\n  /// @param __period The period that the auction should be updated to\n  function _updateAuction(uint256 __period) internal {\n    if (_amountInForPeriod > 0 && _amountOutForPeriod > 0) {\n      // if we sold something, then update the previous non-zero amount\n      _lastNonZeroAmountIn = _amountInForPeriod;\n      _lastNonZeroAmountOut = _amountOutForPeriod;\n    }\n    _amountInForPeriod = 0;\n    _amountOutForPeriod = 0;\n    _lastAuctionTime = uint48(periodOffset + periodLength * __period);\n    _period = uint16(__period);\n    SD59x18 emissionRate_ = _computeEmissionRate();\n    _emissionRate = emissionRate_;\n    if (_emissionRate.unwrap() != 0) {\n      // compute k\n      SD59x18 timeSinceLastAuctionStart = convert(int(uint(targetFirstSaleTime)));\n      SD59x18 purchaseAmount = timeSinceLastAuctionStart.mul(emissionRate_);\n      SD59x18 exchangeRateAmountInToAmountOut = convert(int(uint(_lastNonZeroAmountIn))).div(convert(int(uint(_lastNonZeroAmountOut))));\n      SD59x18 price = exchangeRateAmountInToAmountOut.mul(purchaseAmount);\n      _initialPrice = ContinuousGDA.computeK(\n        emissionRate_,\n        decayConstant,\n        timeSinceLastAuctionStart,\n        purchaseAmount,\n        price\n      );\n    } else {\n      _initialPrice = wrap(0);\n    }\n  }\n\n  /// @notice Computes the start time of the given auction period\n  /// @param __period The auction period, in terms of number of periods since periodOffset\n  /// @return The start timestamp of the given period\n  function _getPeriodStart(uint256 __period) internal view returns (uint256) {\n    return periodOffset + __period * periodLength;\n  }\n\n  /// @notice Computes the end time of the given auction period\n  /// @param __period The auction period, in terms of number of periods since periodOffset\n  /// @return The end timestamp of the given period\n  function _getPeriodEnd(uint256 __period) internal view returns (uint256) {\n    return _getPeriodStart(__period) + periodLength;\n  }\n\n  /// @notice Computes the current auction period\n  /// @return the current period\n  function _computePeriod() internal view returns (uint256) {\n    uint256 _timestamp = block.timestamp;\n    if (_timestamp < periodOffset) {\n      return 0;\n    }\n    return (_timestamp - periodOffset) / periodLength;\n  }\n}"
    },
    {
      "filename": "src/LiquidationPair.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport { ILiquidationSource } from \"pt-v5-liquidator-interfaces/ILiquidationSource.sol\";\nimport { ILiquidationPair } from \"pt-v5-liquidator-interfaces/ILiquidationPair.sol\";\nimport { SD59x18, uEXP_MAX_INPUT, wrap, convert, unwrap } from \"prb-math/SD59x18.sol\";\n\nimport { ContinuousGDA } from \"./libraries/ContinuousGDA.sol\";\n\nerror AmountInZero();\nerror AmountOutZero();\nerror TargetFirstSaleTimeLtPeriodLength(uint passedTargetSaleTime, uint periodLength);\nerror SwapExceedsAvailable(uint256 amountOut, uint256 available);\nerror SwapExceedsMax(uint256 amountInMax, uint256 amountIn);\nerror DecayConstantTooLarge(SD59x18 maxDecayConstant, SD59x18 decayConstant);\nerror PurchasePriceIsZero(uint256 amountOut);\n\n/***\n * @title LiquidationPair\n * @author G9 Software Inc.\n * @notice Auctions one token for another in a periodic continuous gradual dutch auction. Auctions occur over a limit period so that the price can be adjusted.\n * @dev This contract is designed to be used with the LiquidationRouter contract.\n */\ncontract LiquidationPair is ILiquidationPair {\n\n  /* ============ Variables ============ */\n\n  /// @notice The liquidation source that the pair is using.  The source executes the actual token swap, while the pair handles the pricing.\n  ILiquidationSource public immutable source;\n\n  /// @notice The token that is used to pay for auctions\n  address public immutable tokenIn;\n\n  /// @notice The token that is being auctioned.\n  address public immutable tokenOut;\n\n  /// @notice The rate at which the price decays\n  SD59x18 public immutable decayConstant;\n\n  /// @notice The duration of each auction.\n  uint256 public immutable periodLength;\n\n  /// @notice Sets the beginning timestamp for the first period.\n  /// @dev Ensure that the periodOffset is in the past.\n  uint256 public immutable periodOffset;\n\n  /// @notice The time within an auction at which the price of available tokens matches the previous non-zero exchange rate.\n  uint32 public immutable targetFirstSaleTime;\n\n  /// @notice Require a minimum number of tokens before an auction is triggered.\n  /// @dev This is important, because the gas cost ultimately determines the efficiency of the swap.\n  /// If gas cost to auction is 10 cents and the auction is for 11 cents, then the auction price will be driven to zero to make up for the difference.\n  /// If gas cost is 10 cents and we're seeking an efficiency of at least 90%, then the minimum auction amount should be $1 worth of tokens.\n  uint256 public immutable minimumAuctionAmount;\n\n  /// @notice The last non-zero total tokens in for an auction. This is used to configure the target price for the next auction.\n  uint112 _lastNonZeroAmountIn;\n\n  /// @notice The last non-zero total tokens out for an auction.  This is used to configure the target price for the next auction.\n  uint112 _lastNonZeroAmountOut;\n\n  /// @notice The total tokens in for the current auction.\n  uint96 _amountInForPeriod;\n\n  /// @notice The total tokens out for the current auction.\n  uint96 _amountOutForPeriod;\n\n  /// @notice The current auction period. Note that this number can wrap.\n  uint16 _period;\n\n  /// @notice The timestamp at which emissions have been consumed to for the current auction\n  uint48 _lastAuctionTime;\n\n  /// @notice The rate of token emissions for the current auction\n  SD59x18 _emissionRate;\n\n  /// @notice The initial price for the current auction\n  SD59x18 _initialPrice;\n\n  /* ============ Constructor ============ */\n\n  /// @notice Construct a new pair\n  /// @param _source The liquidation source to use for the pair\n  /// @param _tokenIn The token that is used to pay for auctions\n  /// @param _tokenOut The token that is being auctioned\n  /// @param _periodLength The duration of each auction.\n  /// @param _periodOffset Sets the beginning timestamp for the first period\n  /// @param _targetFirstSaleTime The time within an auction at which the price of available tokens matches the previous non-zero exchange rate\n  /// @param _decayConstant The rate at which the price decays\n  /// @param _initialAmountIn The initial amount of tokens in for the first auction (used for the initial exchange rate)\n  /// @param _initialAmountOut The initial amount of tokens out for the first auction (used for the initial exchange rate)\n  /// @param _minimumAuctionAmount Require a minimum number of tokens before an auction is triggered.\n  constructor(\n    ILiquidationSource _source,\n    address _tokenIn,\n    address _tokenOut,\n    uint32 _periodLength,\n    uint32 _periodOffset,\n    uint32 _targetFirstSaleTime,\n    SD59x18 _decayConstant,\n    uint112 _initialAmountIn,\n    uint112 _initialAmountOut,\n    uint256 _minimumAuctionAmount\n  ) {\n    source = _source;\n    tokenIn = _tokenIn;\n    tokenOut = _tokenOut;\n    decayConstant = _decayConstant;\n    periodLength = _periodLength;\n    periodOffset = _periodOffset;\n    targetFirstSaleTime = _targetFirstSaleTime;\n\n    SD59x18 period59 = convert(int256(uint256(_periodLength)));\n    if (_decayConstant.mul(period59).unwrap() > uEXP_MAX_INPUT) {\n      revert DecayConstantTooLarge(wrap(uEXP_MAX_INPUT).div(period59), _decayConstant);\n    }\n\n    if (targetFirstSaleTime >= periodLength) {\n      revert TargetFirstSaleTimeLtPeriodLength(targetFirstSaleTime, periodLength);\n    }\n\n    if (_initialAmountIn == 0) {\n      revert AmountInZero();\n    }\n\n    if (_initialAmountOut == 0) {\n      revert AmountOutZero();\n    }\n\n    _lastNonZeroAmountIn = _initialAmountIn;\n    _lastNonZeroAmountOut = _initialAmountOut;\n    minimumAuctionAmount = _minimumAuctionAmount;\n\n    _updateAuction(0);\n  }\n\n  /* ============ External Read Methods ============ */\n\n  /// @inheritdoc ILiquidationPair\n  function target() external returns (address) {\n    return source.targetOf(tokenIn);\n  }\n\n  /// @inheritdoc ILiquidationPair\n  function maxAmountOut() external returns (uint256) {\n    _checkUpdateAuction();\n    return _maxAmountOut();\n  }\n\n  /// @notice Returns the maximum amount of tokens in\n  /// @return The max number of tokens in\n  function maxAmountIn() external returns (uint256) {\n    _checkUpdateAuction();\n    return _computeExactAmountIn(_maxAmountOut());\n  }\n\n  /// @inheritdoc ILiquidationPair\n  function computeExactAmountIn(uint256 _amountOut) external returns (uint256) {\n    _checkUpdateAuction();\n    return _computeExactAmountIn(_amountOut);\n  }\n\n  /// @inheritdoc ILiquidationPair\n  function estimateAmountOut(uint256 __amountIn) external returns (uint256) {\n    _checkUpdateAuction();\n    return uint(convert(ContinuousGDA.purchaseAmount(\n      convert(int(__amountIn)),\n      _emissionRate,\n      _initialPrice,\n      decayConstant,\n      _getElapsedTime()\n    )));\n  }\n\n  /// @notice Returns the total input tokens for the current auction.\n  /// @return Total tokens in\n  function amountInForPeriod() external returns (uint96) {\n    _checkUpdateAuction();\n    return _amountInForPeriod;\n  }\n\n  /// @notice Returns the total output tokens for the current auction.\n  /// @return Total tokens out\n  function amountOutForPeriod() external returns (uint96) {\n    _checkUpdateAuction();\n    return _amountOutForPeriod;\n  }\n\n  /// @notice Returns the timestamp to which emissions have been consumed.\n  /// @return The timestamp to which emissions have been consumed.\n  function lastAuctionTime() external returns (uint48) {\n    _checkUpdateAuction();\n    return _lastAuctionTime;\n  }\n\n  /// @notice Returns the emission rate in tokens per second for current auction\n  /// @return The emission rate\n  function emissionRate() external returns (SD59x18) {\n    _checkUpdateAuction();\n    return _emissionRate;\n  }\n\n  /// @notice Returns the initial price for the current auction\n  /// @return The initial price\n  function initialPrice() external returns (SD59x18) {\n    _checkUpdateAuction();\n    return _initialPrice;\n  }\n\n  /// @inheritdoc ILiquidationPair\n  function swapExactAmountOut(\n    address _account,\n    uint256 _amountOut,\n    uint256 _amountInMax\n  ) external returns (uint256) {\n    _checkUpdateAuction();\n    uint swapAmountIn = _computeExactAmountIn(_amountOut);\n    if (swapAmountIn > _amountInMax) {\n      revert SwapExceedsMax(_amountInMax, swapAmountIn);\n    }\n    _amountInForPeriod += uint96(swapAmountIn);\n    _amountOutForPeriod += uint96(_amountOut);\n    _lastAuctionTime += uint48(uint256(convert(convert(int256(_amountOut)).div(_emissionRate))));\n    source.liquidate(_account, tokenIn, swapAmountIn, tokenOut, _amountOut);\n    return swapAmountIn;\n  }\n\n  /// @notice Computes the elapsed time within the auction\n  function getElapsedTime() external returns (uint256) {\n    _checkUpdateAuction();\n    return uint256(convert(_getElapsedTime()));\n  }\n\n  /// @notice Returns the current auction start time\n  /// @return The start timestamp\n  function getPeriodStart() external returns (uint256) {\n    _checkUpdateAuction();\n    return _getPeriodStart(_computePeriod());\n  }\n\n  /// @notice Returns the current auction end time\n  /// @return The end timestamp\n  function getPeriodEnd() external returns (uint256) {\n    _checkUpdateAuction();\n    return _getPeriodEnd(_computePeriod());\n  }\n\n  /// @notice Returns the last non-zero auction total input tokens\n  /// @return Total input tokens\n  function lastNonZeroAmountIn() external returns (uint112) {\n    _checkUpdateAuction();\n    return _lastNonZeroAmountIn;\n  }\n\n  /// @notice Returns the last non-zero auction total output tokens\n  /// @return Total output tokens\n  function lastNonZeroAmountOut() external returns (uint112) {\n    _checkUpdateAuction();\n    return _lastNonZeroAmountOut;\n  }\n\n  /* ============ Internal Functions ============ */\n\n  /// @notice Computes the maximum amount of output tokens that can be purchased\n  /// @return Maximum amount of output tokens\n  function _maxAmountOut() internal returns (uint256) {\n    uint emissions = uint(convert(_emissionRate.mul(_getElapsedTime())));\n    uint liquidatable = source.liquidatableBalanceOf(tokenOut);\n    return emissions > liquidatable ? liquidatable : emissions;\n  }\n\n  /// @notice Computes the current emission rate given the available source balance of the output token\n  /// @return The current emission rate\n  function _computeEmissionRate() internal returns (SD59x18) {\n    uint256 amount = source.liquidatableBalanceOf(tokenOut);\n    // console2.log(\"_computeEmissionRate amount\", amount);\n    if (amount < minimumAuctionAmount) {\n      // do not release funds if the minimum is not met\n      amount = 0;\n      // console2.log(\"AMOUNT IS ZERO\");\n    }\n    return convert(int256(amount)).div(convert(int32(int(periodLength))));\n  }\n\n  /// @notice Computes the elapsed time within the current auction\n  /// @return The elapsed time\n  function _getElapsedTime() internal view returns (SD59x18) {\n    if (block.timestamp < _lastAuctionTime) {\n      return wrap(0);\n    }\n    return convert(int256(block.timestamp)).sub(convert(int256(uint256(_lastAuctionTime))));\n  }\n\n  /// @notice Computes the exact amount of input tokens required to purchase the given amount of output tokens\n  /// @param _amountOut The number of output tokens desired\n  /// @return The number of input tokens needed\n  function _computeExactAmountIn(uint256 _amountOut) internal returns (uint256) {\n    if (_amountOut == 0) {\n      return 0;\n    }\n    uint256 maxOut = _maxAmountOut();\n    if (_amountOut > maxOut) {\n      revert SwapExceedsAvailable(_amountOut, maxOut);\n    }\n    SD59x18 elapsed = _getElapsedTime();\n    uint purchasePrice = uint256(convert(ContinuousGDA.purchasePrice(\n        convert(int(_amountOut)),\n        _emissionRate,\n        _initialPrice,\n        decayConstant,\n        elapsed\n      ).ceil()));\n\n    if (purchasePrice == 0) {\n      revert PurchasePriceIsZero(_amountOut);\n    }\n\n    return purchasePrice;\n  }\n\n  /// @notice Checks to see if a new auction has started, and updates the state if so\n  function _checkUpdateAuction() internal {\n    uint256 currentPeriod = _computePeriod();\n    if (currentPeriod != _period) {\n      _updateAuction(currentPeriod);\n    }\n  }\n\n  /// @notice Updates the current auction to the given period\n  /// @param __period The period that the auction should be updated to\n  function _updateAuction(uint256 __period) internal {\n    if (_amountInForPeriod > 0 && _amountOutForPeriod > 0) {\n      // if we sold something, then update the previous non-zero amount\n      _lastNonZeroAmountIn = _amountInForPeriod;\n      _lastNonZeroAmountOut = _amountOutForPeriod;\n    }\n    _amountInForPeriod = 0;\n    _amountOutForPeriod = 0;\n    _lastAuctionTime = uint48(periodOffset + periodLength * __period);\n    _period = uint16(__period);\n    SD59x18 emissionRate_ = _computeEmissionRate();\n    _emissionRate = emissionRate_;\n    if (_emissionRate.unwrap() != 0) {\n      // compute k\n      SD59x18 timeSinceLastAuctionStart = convert(int(uint(targetFirstSaleTime)));\n      SD59x18 purchaseAmount = timeSinceLastAuctionStart.mul(emissionRate_);\n      SD59x18 exchangeRateAmountInToAmountOut = convert(int(uint(_lastNonZeroAmountIn))).div(convert(int(uint(_lastNonZeroAmountOut))));\n      SD59x18 price = exchangeRateAmountInToAmountOut.mul(purchaseAmount);\n      _initialPrice = ContinuousGDA.computeK(\n        emissionRate_,\n        decayConstant,\n        timeSinceLastAuctionStart,\n        purchaseAmount,\n        price\n      );\n    } else {\n      _initialPrice = wrap(0);\n    }\n  }\n\n  /// @notice Computes the start time of the given auction period\n  /// @param __period The auction period, in terms of number of periods since periodOffset\n  /// @return The start timestamp of the given period\n  function _getPeriodStart(uint256 __period) internal view returns (uint256) {\n    return periodOffset + __period * periodLength;\n  }\n\n  /// @notice Computes the end time of the given auction period\n  /// @param __period The auction period, in terms of number of periods since periodOffset\n  /// @return The end timestamp of the given period\n  function _getPeriodEnd(uint256 __period) internal view returns (uint256) {\n    return _getPeriodStart(__period) + periodLength;\n  }\n\n  /// @notice Computes the current auction period\n  /// @return the current period\n  function _computePeriod() internal view returns (uint256) {\n    uint256 _timestamp = block.timestamp;\n    if (_timestamp < periodOffset) {\n      return 0;\n    }\n    return (_timestamp - periodOffset) / periodLength;\n  }\n}"
    }
  ]
}