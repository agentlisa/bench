{
  "Title": "M-4: Users can avoid performance fees by withdrawing before the end of the epoch forcing other users to pay their fees",
  "Content": "# Issue M-4: Users can avoid performance fees by withdrawing before the end of the epoch forcing other users to pay their fees \n\nSource: https://github.com/sherlock-audit/2022-09-knox-judging/issues/75 \n\n## Found by \n0x52\n\n## Summary\n\nNo performance fees are taken when user withdraws early from the vault but their withdrawal value will be used to take fees, which will be taken from other users.\n\n## Vulnerability Detail\n\n    uint256 adjustedTotalAssets = _totalAssets() + l.totalWithdrawals;\n\n    if (adjustedTotalAssets > l.lastTotalAssets) {\n        netIncome = adjustedTotalAssets - l.lastTotalAssets;\n\n        feeInCollateral = l.performanceFee64x64.mulu(netIncome);\n\n        ERC20.safeTransfer(l.feeRecipient, feeInCollateral);\n    }\n\nWhen taking the performance fees, it factors in both the current assets of the vault as well as the total value of withdrawals that happened during the epoch. Fees are paid from the collateral tokens in the vault, at the end of the epoch. Paying the fees like this reduces the share price of all users, which effectively works as a fee applied to all users. The problem is that withdraws that take place during the epoch are not subject to this fee and the total value of all their withdrawals are added to the adjusted assets of the vault. This means that they don't pay any performance fee but the fee is still taken from the vault collateral. In effect they completely avoid the fee force all there other users of the vault to pay it for them.\n\n## Impact\n\nUser can avoid performance fees and force other users to pay them\n\n## Code Snippet\n\n[VaultInternal.sol#L504-L532](https://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/vault/VaultInternal.sol#L504-L532)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nFees should be taken on withdrawals that occur before vault is settled\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/4",
  "Code": [
    {
      "filename": "knox-contracts/contracts/vault/VaultInternal.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@solidstate/contracts/access/ownable/OwnableInternal.sol\";\nimport \"@solidstate/contracts/token/ERC4626/base/ERC4626BaseInternal.sol\";\n\nimport \"../libraries/OptionMath.sol\";\n\nimport \"../vendor/IPremiaPool.sol\";\n\nimport \"./IVault.sol\";\nimport \"./IVaultEvents.sol\";\nimport \"./VaultStorage.sol\";\n\n/**\n * @title Knox Vault Internal Contract\n */\n\ncontract VaultInternal is ERC4626BaseInternal, IVaultEvents, OwnableInternal {\n    using ABDKMath64x64 for int128;\n    using ABDKMath64x64 for uint256;\n    using OptionMath for int128;\n    using OptionMath for uint256;\n    using SafeERC20 for IERC20;\n    using VaultStorage for VaultStorage.Layout;\n\n    IERC20 public immutable ERC20;\n    IPremiaPool public immutable Pool;\n\n    constructor(bool isCall, address pool) {\n        Pool = IPremiaPool(pool);\n        IPremiaPool.PoolSettings memory settings = Pool.getPoolSettings();\n        address asset = isCall ? settings.underlying : settings.base;\n        ERC20 = IERC20(asset);\n    }\n\n    /************************************************\n     *  ACCESS CONTROL\n     ***********************************************/\n\n    /**\n     * @dev Throws if called by any account other than the keeper\n     */\n    modifier onlyKeeper() {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n        require(msg.sender == l.keeper, \"!keeper\");\n        _;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the queue\n     */\n    modifier onlyQueue() {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n        require(msg.sender == address(l.Queue), \"!queue\");\n        _;\n    }\n\n    /**\n     * @dev Throws if called while withdrawals are locked\n     */\n    modifier withdrawalsLocked() {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n\n        /**\n         * the withdrawal lock is active after the auction has started and deactivated\n         * when the auction is processed.\n         *\n         * when the auction has been processed by the keeper the auctionProcessed flag\n         * is set to true, deactivating the lock.\n         *\n         * when the auction is initialized by the keeper the flag is set to false and\n         * the startTime is updated.\n         *\n         * note, the auction must start for the lock to be reactivated. i.e. if the\n         * flag is false but the auction has not started the lock is deactivated.\n         *\n         *\n         *    Auction       Auction      Auction       Auction\n         *  Initialized     Started     Processed    Initialized\n         *       |             |///Locked///|             |\n         *       |             |////////////|             |\n         * -------------------------Time--------------------------->\n         *\n         *\n         */\n\n        if (block.timestamp >= l.startTime) {\n            require(l.auctionProcessed, \"auction has not been processed\");\n        }\n        _;\n    }\n\n    /************************************************\n     *  VIEW\n     ***********************************************/\n\n    /**\n     * @notice calculates the total active vault collateral\n     * @return total vault collateral excluding the total reserves\n     */\n    function _totalCollateral() internal view returns (uint256) {\n        // total reserves are deducted as they are not considered \"active\" assets\n        return ERC20.balanceOf(address(this)) - _totalReserves();\n    }\n\n    /**\n     * @notice calculates the short position value denominated in the collateral asset\n     * @return total short position in collateral amount\n     */\n    function _totalShortAsCollateral() internal view returns (uint256) {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n        VaultStorage.Option memory lastOption = _lastOption(l);\n\n        uint256 totalShortContracts = _totalShortAsContracts();\n\n        // calculates the value of the vaults short position\n        return\n            totalShortContracts.fromContractsToCollateral(\n                l.isCall,\n                l.underlyingDecimals,\n                l.baseDecimals,\n                lastOption.strike64x64\n            );\n    }\n\n    /**\n     * @notice returns the amount in short contracts underwitten by the vault\n     * @return total short contracts\n     */\n    function _totalShortAsContracts() internal view returns (uint256) {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n        uint256 shortTokenId = l.options[_lastEpoch(l)].shortTokenId;\n        return Pool.balanceOf(address(this), shortTokenId);\n    }\n\n    /**\n     * @notice calculates the total reserved collateral\n     * @dev collateral is reserved from the auction to ensure the Vault has sufficent funds to\n     * cover the APY fee\n     * @return total reserved collateral\n     */\n    function _totalReserves() internal view returns (uint256) {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n        return l.reserveRate64x64.mulu(ERC20.balanceOf(address(this)));\n    }\n\n    /************************************************\n     *  ERC4626 OVERRIDES\n     ***********************************************/\n\n    /**\n     * @notice calculates the total active assets by the vault denominated in the collateral asset\n     * @return total active asset amount\n     */\n    function _totalAssets()\n        internal\n        view\n        override(ERC4626BaseInternal)\n        returns (uint256)\n    {\n        return _totalCollateral() + _totalShortAsCollateral();\n    }\n\n    /**\n     * @notice execute a withdrawal of assets on behalf of given address\n     * @dev owner must approve vault to redeem claim tokens\n     * @dev this function may not be called while the auction is in progress\n     * @param assetAmount quantity of assets to withdraw\n     * @param receiver recipient of assets resulting from withdrawal\n     * @param owner holder of shares to be redeemed\n     * @return shareAmount quantity of shares to redeem\n     */\n    function _withdraw(\n        uint256 assetAmount,\n        address receiver,\n        address owner\n    ) internal virtual override(ERC4626BaseInternal) returns (uint256) {\n        require(\n            assetAmount <= _maxWithdraw(owner),\n            \"ERC4626: maximum amount exceeded\"\n        );\n\n        uint256 shareAmount = _previewWithdraw(assetAmount);\n\n        _withdraw(msg.sender, receiver, owner, assetAmount, shareAmount);\n\n        return shareAmount;\n    }\n\n    /**\n     * @notice execute a redemption of shares on behalf of given address\n     * @dev owner must approve vault to redeem claim tokens\n     * @dev this function may not be called while the auction is in progress\n     * @param shareAmount quantity of shares to redeem\n     * @param receiver recipient of assets resulting from withdrawal\n     * @param owner holder of shares to be redeemed\n     * @return assetAmount quantity of assets to withdraw\n     */\n    function _redeem(\n        uint256 shareAmount,\n        address receiver,\n        address owner\n    ) internal virtual override(ERC4626BaseInternal) returns (uint256) {\n        require(\n            shareAmount <= _maxRedeem(owner),\n            \"ERC4626: maximum amount exceeded\"\n        );\n\n        uint256 assetAmount = _previewRedeem(shareAmount);\n\n        _withdraw(msg.sender, receiver, owner, assetAmount, shareAmount);\n\n        return assetAmount;\n    }\n\n    /**\n     * @notice exchange shares for assets on behalf of given address\n     * @param caller transaction operator for purposes of allowance verification\n     * @param receiver recipient of assets resulting from withdrawal\n     * @param owner holder of shares to be redeemed\n     * @param assetAmount quantity of assets to withdraw\n     * @param shareAmount quantity of shares to redeem\n     */\n    function _withdraw(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assetAmount,\n        uint256 shareAmount\n    ) private {\n        VaultStorage.Layout storage l = VaultStorage.layout();\n\n        // prior to withdrawing, the vault will redeem all available claim tokens\n        // in exchange for the pro-rata vault shares\n        l.Queue.redeemMax(receiver, owner);\n\n        require(l.epoch > 0, \"cannot withdraw on epoch 0\");\n\n        if (caller != owner) {\n            // if the owner is not equal to the caller, approve the caller\n            // to spend up to the allowance\n            uint256 allowance = _allowance(owner, caller);\n\n            require(\n                allowance >= shareAmount,\n                \"ERC4626: share amount exceeds allowance\"\n            );\n\n            unchecked {_approve(owner, caller, allowance - shareAmount);}\n        }\n\n        _beforeWithdraw(owner, assetAmount, shareAmount);\n\n        // burns vault shares held by owner\n        _burn(owner, shareAmount);\n\n        // aggregate the total assets withdrawn during the current epoch\n        l.totalWithdrawals += assetAmount;\n\n        // removes any reserved liquidty from pool in the event an option has been exercised\n        _withdrawReservedLiquidity(l);\n\n        // LPs may withdraw funds at any time and receive a proportion of the assets held in\n        // the vault. this means that a withdrawal can be mixture of collateral assets and\n        // short contracts, 100% collateral, or 100% short contracts. if a user wishes to\n        // exit without exposure to a short position, they should wait until the vault holds\n        // no short contracts, or withdraw and reassign their short contracts via Premia's\n        // contracts.\n\n        // calculate the collateral amount and short contract amount distribution\n        (uint256 collateralAmount, uint256 shortContracts) =\n            _calculateDistributions(l, assetAmount);\n\n        // calculates and deducts the withdrawal fee\n        (uint256 collateralAmountSansFee, uint256 shortContractsSansFee) =\n            _collectWithdrawalFee(l, collateralAmount, shortContracts);\n\n        // transfers the collateral and short contracts to the receiver\n        _transferCollateralAndShortAssets(\n            _lastEpoch(l),\n            collateralAmountSansFee,\n            shortContractsSansFee,\n            _lastOption(l).shortTokenId,\n            receiver\n        );\n\n        emit Withdraw(caller, receiver, owner, assetAmount, shareAmount);\n    }\n\n    /************************************************\n     *  WITHDRAW HELPERS\n     ***********************************************/\n\n    /**\n     * @notice calculates the total amount of collateral and short contracts to distribute\n     * @param l vault storage layout\n     * @param assetAmount quantity of assets to withdraw\n     * @return distribution amount in collateral asset\n     * @return distribution amount in the short contracts\n     */\n    function _calculateDistributions(\n        VaultStorage.Layout storage l,\n        uint256 assetAmount\n    ) private view returns (uint256, uint256) {\n        uint256 totalAssets = _totalAssets();\n\n        uint256 collateralAmount =\n            _calculateDistributionAmount(\n                assetAmount,\n                _totalCollateral(),\n                totalAssets\n            );\n\n        VaultStorage.Option memory lastOption = _lastOption(l);\n\n        uint256 totalShortAsCollateral = _totalShortAsCollateral();\n\n        // calculates the distribution of short contracts denominated as collateral\n        uint256 shortAsCollateral =\n            _calculateDistributionAmount(\n                assetAmount,\n                totalShortAsCollateral,\n                totalAssets\n            );\n\n        // converts the collateral amount back to short contracts.\n        uint256 shortContracts =\n            shortAsCollateral.fromContractsToCollateral(\n                l.isCall,\n                l.baseDecimals,\n                lastOption.strike64x64\n            );\n\n        return (collateralAmount, shortContracts);\n    }\n\n    /**\n     * @notice calculates the distribution amount\n     * @param assetAmount quantity of assets to withdraw\n     * @param collateralAmount quantity of asset collateral held by vault\n     * @param totalAssets total amount of assets held by vault, denominated in collateral asset\n     * @return distribution amount, denominated in the collateral asset\n     */\n    function _calculateDistributionAmount(\n        uint256 assetAmount,\n        uint256 collateralAmount,\n        uint256 totalAssets\n    ) private pure returns (uint256) {\n        // calculates the ratio of collateral to total assets\n        int128 assetRatio64x64 =\n            collateralAmount > 0\n                ? collateralAmount.divu(totalAssets)\n                : int128(0);\n        // calculates the amount of the asset which should be withdrawn\n        return assetRatio64x64 > 0 ? assetRatio64x64.mulu(assetAmount) : 0;\n    }\n\n    /**\n     * @notice calculates, deducts, and transfers withdrawal fees to the fee recipient\n     * @param l vault storage layout\n     * @param collateralAmount quantity of asset collateral to deduct fees from\n     * @param shortContracts quantity of short contracts to deduct fees from\n     * @return remaining collateral amount with fees deducted\n     * @return remaining short contract amount with fees deducted\n     */\n    function _collectWithdrawalFee(\n        VaultStorage.Layout storage l,\n        uint256 collateralAmount,\n        uint256 shortContracts\n    ) private returns (uint256, uint256) {\n        // calculates the collateral fee\n        uint256 feeInCollateral = l.withdrawalFee64x64.mulu(collateralAmount);\n\n        // calculates the short contract fee\n        uint256 feesInShortContracts =\n            l.withdrawalFee64x64.mulu(shortContracts);\n\n        VaultStorage.Option memory lastOption = _lastOption(l);\n        uint64 epoch = _lastEpoch(l);\n\n        // transfers the fees to the fee recipient\n        _transferCollateralAndShortAssets(\n            epoch,\n            feeInCollateral,\n            feesInShortContracts,\n            lastOption.shortTokenId,\n            l.feeRecipient\n        );\n\n        emit WithdrawalFeeCollected(\n            epoch,\n            feeInCollateral,\n            feesInShortContracts\n        );\n\n        // deducts the fee from collateral and short contract amounts\n        return (\n            collateralAmount - feeInCollateral,\n            shortContracts - feesInShortContracts\n        );\n    }\n\n    /**\n     * @notice transfers collateral and short contract tokens to receiver\n     * @param epoch vault storage layout\n     * @param collateralAmount quantity of asset collateral to deduct fees from\n     * @param shortContracts quantity of short contracts to deduct fees from\n     * @param shortTokenId quantity of short contracts to deduct fees from\n     * @param receiver quantity of short contracts to deduct fees from\n     */\n    function _transferCollateralAndShortAssets(\n        uint64 epoch,\n        uint256 collateralAmount,\n        uint256 shortContracts,\n        uint256 shortTokenId,\n        address receiver\n    ) private {\n        if (collateralAmount > 0) {\n            // transfers collateral to receiver\n            ERC20.safeTransfer(receiver, collateralAmount);\n        }\n\n        if (shortContracts > 0) {\n            // transfers short contracts to receiver\n            Pool.safeTransferFrom(\n                address(this),\n                receiver,\n                shortTokenId,\n                shortContracts,\n                \"\"\n            );\n        }\n\n        emit DistributionSent(\n            epoch,\n            collateralAmount,\n            shortContracts,\n            receiver\n        );\n    }\n\n    /************************************************\n     *  ADMIN HELPERS\n     ***********************************************/\n\n    /**\n     * @notice sets the parameters for the next option to be sold\n     * @param l vault storage layout\n     * @return the next option to be sold\n     */\n    function _setOptionParameters(VaultStorage.Layout storage l)\n        internal\n        returns (VaultStorage.Option memory)\n    {\n        // sets the expiry for the next Friday\n        uint64 expiry = uint64(_getNextFriday(block.timestamp));\n\n        // calculates the delta strike price\n        int128 strike64x64 =\n            l.Pricer.getDeltaStrikePrice64x64(l.isCall, expiry, l.delta64x64);\n\n        // rounds the delta strike price\n        strike64x64 = l.Pricer.snapToGrid64x64(l.isCall, strike64x64);\n\n        // sets parameters for the next option\n        VaultStorage.Option storage option = l.options[l.epoch];\n        option.expiry = expiry;\n        option.strike64x64 = strike64x64;\n\n        TokenType longTokenType =\n            l.isCall ? TokenType.LONG_CALL : TokenType.LONG_PUT;\n\n        // get the formatted long token id\n        option.longTokenId = _formatTokenId(longTokenType, expiry, strike64x64);\n\n        TokenType shortTokenType =\n            l.isCall ? TokenType.SHORT_CALL : TokenType.SHORT_PUT;\n\n        // get the formatted short token id\n        option.shortTokenId = _formatTokenId(\n            shortTokenType,\n            expiry,\n            strike64x64\n        );\n\n        emit OptionParametersSet(\n            l.epoch,\n            option.expiry,\n            option.strike64x64,\n            option.longTokenId,\n            option.shortTokenId\n        );\n\n        return option;\n    }\n\n    /**\n     * @notice collects performance fees on epoch net income\n     * @dev auction must be processed before fees can be collected, do not call\n     * this function on epoch 0\n     * @param l vault storage layout\n     */\n    function _collectPerformanceFee(VaultStorage.Layout storage l) internal {\n        // pool must return all available \"reserved liquidity\" to the vault after the\n        // option expires and before performance fee can be collected\n        _withdrawReservedLiquidity(l);\n\n        uint256 netIncome;\n        uint256 feeInCollateral;\n\n        // adjusts total assets to account for assets withdrawn during the epoch\n        uint256 adjustedTotalAssets = _totalAssets() + l.totalWithdrawals;\n\n        if (adjustedTotalAssets > l.lastTotalAssets) {\n            // collect performance fee ONLY if the vault returns a positive net income\n            // if the net income is negative, last week's option expired ITM past breakeven,\n            // and the vault took a loss so we do not collect performance fee for last week\n            netIncome = adjustedTotalAssets - l.lastTotalAssets;\n\n            // calculate the performance fee denominated in the collateral asset\n            feeInCollateral = l.performanceFee64x64.mulu(netIncome);\n\n            // send collected fee to recipient wallet\n            ERC20.safeTransfer(l.feeRecipient, feeInCollateral);\n        }\n\n        // reset totalWithdrawals\n        l.totalWithdrawals = 0;\n\n        emit PerformanceFeeCollected(_lastEpoch(l), netIncome, feeInCollateral);\n    }\n\n    /**\n     * @notice removes reserved liquidity from Premia pool\n     * @param l vault storage layout\n     */\n    function _withdrawReservedLiquidity(VaultStorage.Layout storage l)\n        internal\n    {\n        // gets the vaults reserved liquidity balance\n        uint256 reservedLiquidity =\n            Pool.balanceOf(\n                address(this),\n                l.isCall\n                    ? uint256(TokenType.UNDERLYING_RESERVED_LIQ) << 248\n                    : uint256(TokenType.BASE_RESERVED_LIQ) << 248\n            );\n\n        if (reservedLiquidity > 0) {\n            // remove reserved liquidity from the pool, if available\n            Pool.withdraw(reservedLiquidity, l.isCall);\n        }\n\n        emit ReservedLiquidityWithdrawn(l.epoch, reservedLiquidity);\n    }\n\n    /**\n     * @notice calculates and sets the auction prices\n     * @param l vault storage layout\n     */\n    function _setAuctionPrices(VaultStorage.Layout storage l) internal {\n        VaultStorage.Option memory lastOption = _lastOption(l);\n\n        // assumes that the strike price has been set\n        require(lastOption.strike64x64 > 0, \"delta strike unset\");\n\n        // the delta offset is used to calculate an offset strike price which should always be\n        // further OTM.\n\n        // calculates the delta strike price using the offset delta\n        int128 offsetStrike64x64 =\n            l.Pricer.getDeltaStrikePrice64x64(\n                l.isCall,\n                lastOption.expiry,\n                l.delta64x64.sub(l.deltaOffset64x64)\n            );\n\n        // fetches the spot price of the underlying\n        int128 spot64x64 = l.Pricer.latestAnswer64x64();\n\n        // fetches the time to maturity of the option\n        int128 timeToMaturity64x64 =\n            l.Pricer.getTimeToMaturity64x64(lastOption.expiry);\n\n        /**\n         * it is assumed that the rounded strike price will always be further ITM than the offset\n         * strike price. the further ITM option will always be more expensive and will therefore\n         * be used to determine the max price of the auction. likewise, the offset strike price\n         * (further OTM) should resemble a cheaper option and it is therefore used as the min\n         * option price in our auction.\n         *\n         *\n         * Call Option\n         * -----------\n         * Strike    Rounded Strike             Offset Strike\n         *   |  ---------> |                          |\n         *   |             |                          |\n         * -----------------------Price------------------------>\n         *\n         *\n         * Put Option\n         * -----------\n         * Offset Strike              Rounded Strike    Strike\n         *       |                           | <--------- |\n         *       |                           |            |\n         * -----------------------Price------------------------>\n         *\n         *\n         */\n\n        // calculates the auction max price using the strike price further (ITM)\n        int128 maxPrice64x64 =\n            l.Pricer.getBlackScholesPrice64x64(\n                spot64x64,\n                lastOption.strike64x64,\n                timeToMaturity64x64,\n                l.isCall\n            );\n\n        // calculates the auction min price using the offset strike price further (OTM)\n        int128 minPrice64x64 =\n            l.Pricer.getBlackScholesPrice64x64(\n                spot64x64,\n                offsetStrike64x64,\n                timeToMaturity64x64,\n                l.isCall\n            );\n\n        if (l.isCall) {\n            // denominates price in the collateral asset\n            maxPrice64x64 = maxPrice64x64.div(spot64x64);\n            minPrice64x64 = minPrice64x64.div(spot64x64);\n        }\n\n        uint64 epoch = _lastEpoch(l);\n\n        emit AuctionPricesSet(\n            epoch,\n            lastOption.strike64x64,\n            offsetStrike64x64,\n            spot64x64,\n            timeToMaturity64x64,\n            maxPrice64x64,\n            minPrice64x64\n        );\n\n        l.Auction.setAuctionPrices(epoch, maxPrice64x64, minPrice64x64);\n    }\n\n    /************************************************\n     *  PREMIA HELPERS\n     ***********************************************/\n\n    // Premia ERC1155 token types\n    enum TokenType {\n        UNDERLYING_FREE_LIQ,\n        BASE_FREE_LIQ,\n        UNDERLYING_RESERVED_LIQ,\n        BASE_RESERVED_LIQ,\n        LONG_CALL,\n        SHORT_CALL,\n        LONG_PUT,\n        SHORT_PUT\n    }\n\n    /**\n     * @notice calculate ERC1155 token id for given option parameters\n     * @param tokenType TokenType enum\n     * @param maturity timestamp of option maturity\n     * @param strike64x64 64x64 fixed point representation of strike price\n     * @return tokenId token id\n     */\n    function _formatTokenId(\n        TokenType tokenType,\n        uint64 maturity,\n        int128 strike64x64\n    ) internal pure returns (uint256 tokenId) {\n        tokenId =\n            (uint256(tokenType) << 248) +\n            (uint256(maturity) << 128) +\n            uint256(int256(strike64x64));\n    }\n\n    /************************************************\n     *  HELPERS\n     ***********************************************/\n\n    /**\n     * @notice returns the last epoch\n     * @param l vault storage layout\n     * @return last epoch\n     */\n    function _lastEpoch(VaultStorage.Layout storage l)\n        internal\n        view\n        returns (uint64)\n    {\n        return l.epoch > 0 ? l.epoch - 1 : 0;\n    }\n\n    /**\n     * @notice returns option from the last epoch\n     * @param l vault storage layout\n     * @return option from last epoch\n     */\n    function _lastOption(VaultStorage.Layout storage l)\n        internal\n        view\n        returns (VaultStorage.Option memory)\n    {\n        return l.options[_lastEpoch(l)];\n    }\n\n    /**\n     * @notice returns the next Friday 8AM timestamp\n     * @param timestamp is the current timestamp\n     * Examples:\n     * getFriday(week 1 thursday) -> week 1 friday\n     * getFriday(week 1 friday) -> week 2 friday\n     * getFriday(week 1 saturday) -> week 2 friday\n     */\n    function _getFriday(uint256 timestamp) internal pure returns (uint256) {\n        // dayOfWeek = 0 (sunday) - 6 (saturday)\n        uint256 dayOfWeek = ((timestamp / 1 days) + 4) % 7;\n        uint256 nextFriday = timestamp + ((7 + 5 - dayOfWeek) % 7) * 1 days;\n        uint256 friday8am = nextFriday - (nextFriday % (24 hours)) + (8 hours);\n\n        // If the passed timestamp is day = Friday hour > 8am,\n        // we increment it by a week to next Friday\n        if (timestamp >= friday8am) {\n            friday8am += 7 days;\n        }\n        return friday8am;\n    }\n\n    /**\n     * @notice returns the Friday 8AM timestamp of the following week\n     * @param timestamp is the current timestamp\n     * Reference: https://codereview.stackexchange.com/a/33532\n     * Examples:\n     * getNextFriday(week 1 thursday) -> week 2 friday\n     * getNextFriday(week 1 friday) -> week 2 friday\n     * getNextFriday(week 1 saturday) -> week 2 friday\n     */\n    function _getNextFriday(uint256 timestamp) internal pure returns (uint256) {\n        // dayOfWeek = 0 (sunday) - 6 (saturday)\n        uint256 dayOfWeek = ((timestamp / 1 days) + 4) % 7;\n        uint256 nextFriday = timestamp + ((7 + 5 - dayOfWeek) % 7) * 1 days;\n        uint256 friday8am = nextFriday - (nextFriday % (24 hours)) + (8 hours);\n\n        // If the timestamp is on a Friday or between Monday-Thursday\n        // return Friday of the following week\n        if (timestamp >= friday8am || friday8am - timestamp < 4 days) {\n            friday8am += 7 days;\n        }\n        return friday8am;\n    }\n}"
    }
  ]
}