{
  "Title": "M-9: `MultiInvoker._latest` calculates incorrect closable for the current oracle version causing some liquidations to revert",
  "Content": "# Issue M-9: `MultiInvoker._latest` calculates incorrect closable for the current oracle version causing some liquidations to revert \n\nSource: https://github.com/sherlock-audit/2023-10-perennial-judging/issues/32 \n\n## Found by \npanprog\n## Summary\n\n`closable` is the value calculated as the maximum possible position size that can be closed even if some pending position updates are invalidated due to invalid oracle version. There is one tricky edge case at the current oracle version which is calculated incorrectly in `MultiInvoker` (and also in `Vault`). This happens when pending position is updated in the current active oracle version: it is allowed to set this current position to any value conforming to closable of the **previous** pending (or latest) position. For example:\n1. latest settled position = 10\n2. user calls update(20) - pending position at t=200 is set to 20. If we calculate `closable` normally, it will be 10 (latest settled position).\n3. user calls update(0) - pending position at t=200 is set to 0. This is valid and correct. It looks as if we've reduced position by 20, bypassing the `closable = 10` value, but in reality the only enforced `closable` is the previous one (for latest settled position in the example, so it's 10) and it's enforced as a change from previous position, not from current.\n\nNow, if the step 3 happened in the next oracle version, so\n3. user calls update(0) - pending position at t=300 will revert, because user can't close more than 10, and he tries to close 20.\n\nSo in such tricky edge case, `MultiInvoker` (and `Vault`) will calculate `closable = 10` and will try to liquidate with position = 20-10 = 10 instead of 0 and will revert, because `Market._invariant` will calculate `closable = 10` (latest = 10, pending = 10, closable = latest = 10), but it must be 0 to liquidate (step 3. in the example above)\n\nIn `Vault` case, this is less severe as the market will simply allow to redeem and will close smaller amount than it actually can.\n\n## Vulnerability Detail\n\nWhen `Market` calculates `closable`, it's calculated starting from latest settled position up to (but not including) current position:\n```solidity\n// load pending positions\nfor (uint256 id = context.local.latestId + 1; id < context.local.currentId; id++)\n    _processPendingPosition(context, _loadPendingPositionLocal(context, account, id));\n```\n\nPay attention to `id < context.local.currentId` - the loop doesn't include currentId.\n\nAfter the current position is updated to a new user specified value, only then the current position is processed and closable now includes **new** user position change from the previous position:\n\n```solidity\nfunction _update(\n    ...\n    // load\n    _loadUpdateContext(context, account);\n    ...\n    context.currentPosition.local.update(collateral);\n    ...\n    // process current position\n    _processPendingPosition(context, context.currentPosition.local);\n    ...\n    // after\n    _invariant(context, account, newOrder, collateral, protected);\n```\n\nThe `MultiInvoker._latest` logic is different and simply includes calculation of `closable` for all pending positions:\n\n```solidity\nfor (uint256 id = local.latestId + 1; id <= local.currentId; id++) {\n\n    // load pending position\n    Position memory pendingPosition = market.pendingPositions(account, id);\n    pendingPosition.adjust(latestPosition);\n\n    // virtual settlement\n    if (pendingPosition.timestamp <= latestTimestamp) {\n        if (!market.oracle().at(pendingPosition.timestamp).valid) latestPosition.invalidate(pendingPosition);\n        latestPosition.update(pendingPosition);\n\n        previousMagnitude = latestPosition.magnitude();\n        closableAmount = previousMagnitude;\n\n    // process pending positions\n    } else {\n        closableAmount = closableAmount\n            .sub(previousMagnitude.sub(pendingPosition.magnitude().min(previousMagnitude)));\n        previousMagnitude = latestPosition.magnitude();\n    }\n}\n```\n\nThe same incorrect logic is in a `Vault`:\n\n```solidity\n// pending positions\nfor (uint256 id = marketContext.local.latestId + 1; id <= marketContext.local.currentId; id++)\n    previousClosable = _loadPosition(\n        marketContext,\n        marketContext.currentAccountPosition = registration.market.pendingPositions(address(this), id),\n        previousClosable\n    );\n```\n\n## Impact\n\nIn the following edge case:\n- current oracle version = oracle version of the pending position in currentId index\n- AND this (current) pending position increases compared to previous pending/settled position\n\nThe following can happen:\n- liquidation via `MultiInvoker` will revert (medium impact)\n- vault's `maxRedeem` amount will be smaller than actual allowed amount, position will be reduced by a smaller amount than they actually can (low impact)\n\n## Code Snippet\n\n`MultiInvoker` calculates `closable` by simply iterating all pending positions:\nhttps://github.com/sherlock-audit/2023-10-perennial/blob/main/perennial-v2/packages/perennial-extensions/contracts/MultiInvoker.sol#L412-L433\n\n`Vault` calculates it the same way (iterating all positions):\nhttps://github.com/sherlock-audit/2023-10-perennial/blob/main/perennial-v2/packages/perennial-vault/contracts/lib/StrategyLib.sol#L164-L170\n\n`Market` calculates `closable` up to (but not including) current position:\nhttps://github.com/sherlock-audit/2023-10-perennial/blob/main/perennial-v2/packages/perennial/contracts/Market.sol#L287-L289\n\nand then the current position (after being updated to user values) is processed (closable enforced/calculated):\nhttps://github.com/sherlock-audit/2023-10-perennial/blob/main/perennial-v2/packages/perennial/contracts/Market.sol#L362-L363\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWhen calculating `closable` in `MultiInvoker` and `Vault`, add the following logic:\n- if timestamp of pending position at index currentId equals current oracle version, then add the difference between position size at currentId and previous position size to `closable` (both when that position increases and decreases).\n\nFor example, if\n- latest settled position = 10\n- pending position at t=200 = 20\nthen\ninitialize `closable` to `10` (latest)\nadd (pending-latest) = (20-10) to closable (`closable` = 20)\n\n\n\n## Discussion\n\n**kbrizzle**\n\nNote on fix: we will be removing the liquidation action from the MultiInvoker in another fix (as it will be unnecessary). we may or may not fix the vault side of the issue, since as you've laid out, it has minimal downside.\n\n**kbrizzle**\n\n\n- `MultiInvoker` - Resolved as a side-effect of: https://github.com/equilibria-xyz/perennial-v2/pull/165.\n- `Vault` - Won't fix due to the amount of additional complexity required, considering the low severity and expedient self-resolution.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/123",
  "Code": [
    {
      "filename": "perennial-v2/packages/perennial-extensions/contracts/MultiInvoker.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { AggregatorV3Interface } from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport { IEmptySetReserve } from \"@equilibria/emptyset-batcher/interfaces/IEmptySetReserve.sol\";\nimport { IFactory } from \"@equilibria/root/attribute/interfaces/IFactory.sol\";\nimport { IBatcher } from \"@equilibria/emptyset-batcher/interfaces/IBatcher.sol\";\nimport { IInstance } from \"@equilibria/root/attribute/interfaces/IInstance.sol\";\nimport { IPythFactory } from \"@equilibria/perennial-v2-oracle/contracts/interfaces/IPythFactory.sol\";\nimport { IVault } from \"@equilibria/perennial-v2-vault/contracts/interfaces/IVault.sol\";\nimport \"./interfaces/IMultiInvoker.sol\";\nimport \"./types/TriggerOrder.sol\";\nimport \"./types/InterfaceFee.sol\";\nimport \"@equilibria/root/attribute/Kept/Kept.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/// @title MultiInvoker\n/// @notice Extension to handle batched calls to the Perennial protocol\ncontract MultiInvoker is IMultiInvoker, Kept {\n    /// @dev USDC stablecoin address\n    Token6 public immutable USDC; // solhint-disable-line var-name-mixedcase\n\n    /// @dev DSU address\n    Token18 public immutable DSU; // solhint-disable-line var-name-mixedcase\n\n    /// @dev Protocol factory to validate market approvals\n    IFactory public immutable marketFactory;\n\n    /// @dev Vault factory to validate vault approvals\n    IFactory public immutable vaultFactory;\n\n    /// @dev Batcher address\n    IBatcher public immutable batcher;\n\n    /// @dev Reserve address\n    IEmptySetReserve public immutable reserve;\n\n    /// @dev The fixed gas buffer that is added to the keeper reward\n    uint256 public immutable keepBufferBase;\n\n    /// @dev The fixed gas buffer that is added to the calldata portion of  the keeper reward\n    uint256 public immutable keepBufferCalldata;\n\n    /// @dev UID for an order\n    uint256 public latestNonce;\n\n    /// @dev State for the order data\n    mapping(address => mapping(IMarket => mapping(uint256 => TriggerOrderStorage))) private _orders;\n\n    /// @notice Constructs the MultiInvoker contract\n    /// @param usdc_ USDC stablecoin address\n    /// @param dsu_ DSU address\n    /// @param marketFactory_ Protocol factory to validate market approvals\n    /// @param vaultFactory_ Protocol factory to validate vault approvals\n    /// @param batcher_ Batcher address\n    /// @param reserve_ Reserve address\n    /// @param keepBufferBase_ The fixed gas buffer that is added to the keeper reward\n    /// @param keepBufferCalldata_ The fixed calldata buffer that is added to the keeper reward\n    constructor(\n        Token6 usdc_,\n        Token18 dsu_,\n        IFactory marketFactory_,\n        IFactory vaultFactory_,\n        IBatcher batcher_,\n        IEmptySetReserve reserve_,\n        uint256 keepBufferBase_,\n        uint256 keepBufferCalldata_\n    ) {\n        USDC = usdc_;\n        DSU = dsu_;\n        marketFactory = marketFactory_;\n        vaultFactory = vaultFactory_;\n        batcher = batcher_;\n        reserve = reserve_;\n        keepBufferBase = keepBufferBase_;\n        keepBufferCalldata = keepBufferCalldata_;\n    }\n\n    /// @notice Initialize the contract\n    /// @param ethOracle_ Chainlink ETH/USD oracle address\n    function initialize(AggregatorV3Interface ethOracle_) external initializer(1) {\n        __Kept__initialize(ethOracle_, DSU);\n\n        if (address(batcher) != address(0)) {\n            DSU.approve(address(batcher));\n            USDC.approve(address(batcher));\n        }\n\n        DSU.approve(address(reserve));\n        USDC.approve(address(reserve));\n    }\n\n    /// @notice View function to get order state\n    /// @param account Account to get open oder of\n    /// @param market Market to get open order in\n    /// @param nonce UID of order\n    function orders(address account, IMarket market, uint256 nonce) public view returns (TriggerOrder memory) {\n        return _orders[account][market][nonce].read();\n    }\n\n    /// @notice Returns whether an order can be executed\n    /// @param account Account to get open oder of\n    /// @param market Market to get open order in\n    /// @param nonce UID of order\n    /// @return canFill Whether the order can be executed\n    function canExecuteOrder(address account, IMarket market, uint256 nonce) public view returns (bool) {\n        TriggerOrder memory order = orders(account, market, nonce);\n        if (order.fee.isZero()) return false;\n        (, Fixed6 latestPrice, ) = _latest(market, account);\n        return order.fillable(latestPrice);\n    }\n\n    /// @notice entry to perform invocations\n    /// @param invocations List of actions to execute in order\n    function invoke(Invocation[] calldata invocations) external payable {\n        for(uint i = 0; i < invocations.length; ++i) {\n            Invocation memory invocation = invocations[i];\n\n            if (invocation.action == PerennialAction.UPDATE_POSITION) {\n                (\n                    // update data\n                    IMarket market,\n                    UFixed6 newMaker,\n                    UFixed6 newLong,\n                    UFixed6 newShort,\n                    Fixed6 collateral,\n                    bool wrap,\n                    InterfaceFee memory interfaceFee\n                ) = abi.decode(invocation.args, (IMarket, UFixed6, UFixed6, UFixed6, Fixed6, bool, InterfaceFee));\n\n                _update(msg.sender, market, newMaker, newLong, newShort, collateral, wrap, interfaceFee);\n            } else if (invocation.action == PerennialAction.UPDATE_VAULT) {\n                (IVault vault, UFixed6 depositAssets, UFixed6 redeemShares, UFixed6 claimAssets, bool wrap)\n                    = abi.decode(invocation.args, (IVault, UFixed6, UFixed6, UFixed6, bool));\n\n                _vaultUpdate(vault, depositAssets, redeemShares, claimAssets, wrap);\n            } else if (invocation.action == PerennialAction.PLACE_ORDER) {\n                (IMarket market, TriggerOrder memory order) = abi.decode(invocation.args, (IMarket, TriggerOrder));\n\n                _placeOrder(msg.sender, market, order);\n            } else if (invocation.action == PerennialAction.CANCEL_ORDER) {\n                (IMarket market, uint256 nonce) = abi.decode(invocation.args, (IMarket, uint256));\n\n                _cancelOrder(msg.sender, market, nonce);\n            } else if (invocation.action == PerennialAction.EXEC_ORDER) {\n                (address account, IMarket market, uint256 nonce)\n                    = abi.decode(invocation.args, (address, IMarket, uint256));\n\n                _executeOrder(account, market, nonce);\n            } else if (invocation.action == PerennialAction.COMMIT_PRICE) {\n                (address oracleProviderFactory, uint256 value, bytes32[] memory ids, uint256 version, bytes memory data, bool revertOnFailure) =\n                    abi.decode(invocation.args, (address, uint256, bytes32[], uint256, bytes, bool));\n\n                _commitPrice(oracleProviderFactory, value, ids, version, data, revertOnFailure);\n            } else if (invocation.action == PerennialAction.LIQUIDATE) {\n                (IMarket market, address account, bool revertOnFailure) = abi.decode(invocation.args, (IMarket, address, bool));\n\n                _liquidate(market, account, revertOnFailure);\n            } else if (invocation.action == PerennialAction.APPROVE) {\n                (address target) = abi.decode(invocation.args, (address));\n\n                _approve(target);\n            }\n\n            // Eth must not remain in this contract at rest\n            payable(msg.sender).transfer(address(this).balance);\n        }\n    }\n\n    /// @notice Updates market on behalf of account\n    /// @param account Address of account to update\n    /// @param market Address of market up update\n    /// @param newMaker New maker position for account in `market`\n    /// @param newLong New long position for account in `market`\n    /// @param newShort New short position for account in `market`\n    /// @param collateral Net change in collateral for account in `market`\n    /// @param wrap Wheather to wrap/unwrap collateral on deposit/withdrawal\n    /// @param interfaceFee Interface fee to charge\n    function _update(\n        address account,\n        IMarket market,\n        UFixed6 newMaker,\n        UFixed6 newLong,\n        UFixed6 newShort,\n        Fixed6 collateral,\n        bool wrap,\n        InterfaceFee memory interfaceFee\n    ) internal isMarketInstance(market) {\n        Fixed18 balanceBefore =  Fixed18Lib.from(DSU.balanceOf());\n\n        // collateral is transferred here as DSU then an optional interface fee is charged from it\n        if (collateral.sign() == 1) _deposit(collateral.abs(), wrap);\n\n        market.update(account, newMaker, newLong, newShort, collateral, false);\n\n        Fixed6 withdrawAmount = Fixed6Lib.from(Fixed18Lib.from(DSU.balanceOf()).sub(balanceBefore));\n        if (!withdrawAmount.isZero()) _withdraw(account, withdrawAmount.abs(), wrap);\n\n        // charge interface fee\n        _chargeFee(account, market, interfaceFee);\n    }\n\n    /// @notice Update vault on behalf of msg.sender\n    /// @param vault Address of vault to update\n    /// @param depositAssets Amount of assets to deposit into vault\n    /// @param redeemShares Amount of shares to redeem from vault\n    /// @param claimAssets Amount of assets to claim from vault\n    /// @param wrap Whether to wrap assets before depositing\n    function _vaultUpdate(\n        IVault vault,\n        UFixed6 depositAssets,\n        UFixed6 redeemShares,\n        UFixed6 claimAssets,\n        bool wrap\n    ) internal isVaultInstance(vault) {\n        if (!depositAssets.isZero()) {\n            _deposit(depositAssets, wrap);\n        }\n\n        UFixed18 balanceBefore = DSU.balanceOf();\n\n        vault.update(msg.sender, depositAssets, redeemShares, claimAssets);\n\n        // handle socialization, settlement fees, and magic values\n        UFixed6 claimAmount = claimAssets.isZero() ?\n            UFixed6Lib.ZERO :\n            UFixed6Lib.from(DSU.balanceOf().sub(balanceBefore));\n\n        if (!claimAmount.isZero()) {\n            _withdraw(msg.sender, claimAmount, wrap);\n        }\n    }\n\n    /// @notice Liquidates an account for a specific market\n    /// @param market Market to liquidate account in\n    /// @param account Address of market to liquidate\n    function _liquidate(IMarket market, address account, bool revertOnFailure) internal isMarketInstance(market) {\n        (Position memory latestPosition, UFixed6 liquidationFee, UFixed6 closable) = _liquidationFee(market, account);\n        Position memory currentPosition = market.pendingPositions(account, market.locals(account).currentId);\n        currentPosition.adjust(latestPosition);\n\n        try market.update(\n                account,\n                currentPosition.maker.isZero() ? UFixed6Lib.ZERO : currentPosition.maker.sub(closable),\n                currentPosition.long.isZero() ? UFixed6Lib.ZERO : currentPosition.long.sub(closable),\n                currentPosition.short.isZero() ? UFixed6Lib.ZERO : currentPosition.short.sub(closable),\n                Fixed6Lib.from(-1, liquidationFee),\n                true\n        ) {\n            _withdraw(msg.sender, liquidationFee, true);\n        } catch (bytes memory reason) {\n            if (revertOnFailure) Address.verifyCallResult(false, reason, \"\");\n        }\n    }\n\n    /// @notice Helper to max approve DSU for usage in a market or vault deployed by the registered factories\n    /// @param target Market or Vault to approve\n    function _approve(address target) internal {\n        if (\n            !marketFactory.instances(IInstance(target)) &&\n            !vaultFactory.instances(IInstance(target))\n        ) revert MultiInvokerInvalidInstanceError();\n\n        DSU.approve(target);\n    }\n\n    /// @notice Charges an interface fee from collateral in this address during an update to a receiver\n    /// @param account Account to charge fee from\n    /// @param market Market to charge fee from\n    /// @param interfaceFee Interface fee to charge\n    function _chargeFee(address account, IMarket market, InterfaceFee memory interfaceFee) internal {\n        if (interfaceFee.amount.isZero()) return;\n\n        market.update(\n            account,\n            UFixed6Lib.MAX,\n            UFixed6Lib.MAX,\n            UFixed6Lib.MAX,\n            Fixed6Lib.from(-1, interfaceFee.amount),\n            false\n        );\n\n        if (interfaceFee.unwrap) _unwrap(interfaceFee.receiver, UFixed18Lib.from(interfaceFee.amount));\n        else DSU.push(interfaceFee.receiver, UFixed18Lib.from(interfaceFee.amount));\n\n        emit InterfaceFeeCharged(account, market, interfaceFee);\n    }\n\n    /// @notice Pull DSU or wrap and deposit USDC from msg.sender to this address for market usage\n    /// @param amount Amount to transfer\n    /// @param wrap Flag to wrap USDC to DSU\n    function _deposit(UFixed6 amount, bool wrap) internal {\n        if (wrap) {\n            USDC.pull(msg.sender, amount);\n            _wrap(address(this), UFixed18Lib.from(amount));\n        } else {\n            DSU.pull(msg.sender, UFixed18Lib.from(amount));\n        }\n    }\n\n    /// @notice Push DSU or unwrap DSU to push USDC from this address to `account`\n    /// @param account Account to push DSU or USDC to\n    /// @param amount Amount to transfer\n    /// @param wrap flag to unwrap DSU to USDC\n    function _withdraw(address account, UFixed6 amount, bool wrap) internal {\n        if (wrap) {\n            _unwrap(account, UFixed18Lib.from(amount));\n        } else {\n            DSU.push(account, UFixed18Lib.from(amount));\n        }\n    }\n\n    /// @notice Helper function to wrap `amount` USDC from `address(this)` into DSU using the batcher or reserve\n    /// @param receiver Address to receive the DSU\n    /// @param amount Amount of USDC to wrap\n    function _wrap(address receiver, UFixed18 amount) internal {\n        // If the batcher is 0 or  doesn't have enough for this wrap, go directly to the reserve\n        if (address(batcher) == address(0) || amount.gt(DSU.balanceOf(address(batcher)))) {\n            reserve.mint(amount);\n            if (receiver != address(this)) DSU.push(receiver, amount);\n        } else {\n            // Wrap the USDC into DSU and return to the receiver\n            batcher.wrap(amount, receiver);\n        }\n    }\n\n    /// @notice Helper function to unwrap `amount` DSU into USDC and send to `receiver`\n    /// @param receiver Address to receive the USDC\n    /// @param amount Amount of DSU to unwrap\n    function _unwrap(address receiver, UFixed18 amount) internal {\n        // If the batcher is 0 or doesn't have enough for this unwrap, go directly to the reserve\n        if (address(batcher) == address(0) || amount.gt(UFixed18Lib.from(USDC.balanceOf(address(batcher))))) {\n            reserve.redeem(amount);\n            if (receiver != address(this)) USDC.push(receiver, UFixed6Lib.from(amount));\n        } else {\n            // Unwrap the DSU into USDC and return to the receiver\n            batcher.unwrap(amount, receiver);\n        }\n    }\n\n    /// @notice Helper function to commit a price to an oracle\n    /// @param oracleProviderFactory Address of oracle provider factory\n    /// @param value The ether value to pass on with the commit sub-call\n    /// @param version Version of oracle to commit to\n    /// @param data Data to commit to oracle\n    /// @param revertOnFailure Whether to revert on sub-call failure\n    function _commitPrice(\n        address oracleProviderFactory,\n        uint256 value,\n        bytes32[] memory ids,\n        uint256 version,\n        bytes memory data,\n        bool revertOnFailure\n    ) internal {\n        UFixed18 balanceBefore = DSU.balanceOf();\n\n        try IPythFactory(oracleProviderFactory).commit{value: value}(ids, version, data) {\n            // Return through keeper reward if any\n            DSU.push(msg.sender, DSU.balanceOf().sub(balanceBefore));\n        } catch (bytes memory reason) {\n            if (revertOnFailure) Address.verifyCallResult(false, reason, \"\");\n        }\n    }\n\n    /// @notice Helper function to compute the liquidation fee for an account\n    /// @param market Market to compute liquidation fee for\n    /// @param account Account to compute liquidation fee for\n    /// @return liquidationFee Liquidation fee for the account\n    /// @return closable The amount of the position that can be closed\n    function _liquidationFee(IMarket market, address account) internal view returns (Position memory, UFixed6, UFixed6) {\n        // load information about liquidation\n        RiskParameter memory riskParameter = market.riskParameter();\n        (Position memory latestPosition, Fixed6 latestPrice, UFixed6 closableAmount) = _latest(market, account);\n\n        // create placeholder order for liquidation fee calculation (fee is charged the same on all sides)\n        Order memory placeholderOrder;\n        placeholderOrder.maker = Fixed6Lib.from(closableAmount);\n\n        return (\n            latestPosition,\n            placeholderOrder\n                .liquidationFee(OracleVersion(latestPosition.timestamp, latestPrice, true), riskParameter)\n                .min(UFixed6Lib.from(market.token().balanceOf(address(market)))),\n            closableAmount\n        );\n    }\n\n    /// @notice Helper function to compute the latest position and oracle version without a settlement\n    /// @param market Market to compute latest position and oracle version for\n    /// @param account Account to compute latest position and oracle version for\n    /// @return latestPosition Latest position for the account\n    /// @return latestPrice Latest oracle price for the account\n    /// @return closableAmount Amount of position that can be closed\n    function _latest(\n        IMarket market,\n        address account\n    ) internal view returns (Position memory latestPosition, Fixed6 latestPrice, UFixed6 closableAmount) {\n        // load latest price\n        OracleVersion memory latestOracleVersion = market.oracle().latest();\n        latestPrice = latestOracleVersion.price;\n        IPayoffProvider payoff = market.payoff();\n        if (address(payoff) != address(0)) latestPrice = payoff.payoff(latestPrice);\n\n        // load latest settled position\n        uint256 latestTimestamp = latestOracleVersion.timestamp;\n        latestPosition = market.positions(account);\n        closableAmount = latestPosition.magnitude();\n        UFixed6 previousMagnitude = closableAmount;\n\n        // scan pending position for any ready-to-be-settled positions\n        Local memory local = market.locals(account);\n        for (uint256 id = local.latestId + 1; id <= local.currentId; id++) {\n\n            // load pending position\n            Position memory pendingPosition = market.pendingPositions(account, id);\n            pendingPosition.adjust(latestPosition);\n\n            // virtual settlement\n            if (pendingPosition.timestamp <= latestTimestamp) {\n                if (!market.oracle().at(pendingPosition.timestamp).valid) latestPosition.invalidate(pendingPosition);\n                latestPosition.update(pendingPosition);\n\n                previousMagnitude = latestPosition.magnitude();\n                closableAmount = previousMagnitude;\n\n            // process pending positions\n            } else {\n                closableAmount = closableAmount\n                    .sub(previousMagnitude.sub(pendingPosition.magnitude().min(previousMagnitude)));\n                previousMagnitude = latestPosition.magnitude();\n            }\n        }\n    }\n\n    /**\n     * @notice executes an `account's` open order for a `market` and pays a fee to `msg.sender`\n     * @param account Account to execute order of\n     * @param market Market to execute order for\n     * @param nonce Id of open order to index\n     */\n    function _executeOrder(address account, IMarket market, uint256 nonce) internal {\n        if (!canExecuteOrder(account, market, nonce)) revert MultiInvokerCantExecuteError();\n\n        TriggerOrder memory order = orders(account, market, nonce);\n        // Pay out keeper fee based on static gas buffer\n        _handleKeep(account, market, order.fee);\n\n        (Position memory latestPosition, , ) = _latest(market, account);\n        Position memory currentPosition = market.pendingPositions(account, market.locals(account).currentId);\n        currentPosition.adjust(latestPosition);\n\n        order.execute(currentPosition);\n\n        _update(\n            account,\n            market,\n            currentPosition.maker,\n            currentPosition.long,\n            currentPosition.short,\n            currentPosition.collateral,\n            true,\n            order.interfaceFee\n        );\n\n        delete _orders[account][market][nonce];\n        emit OrderExecuted(account, market, nonce);\n    }\n\n    /// @notice Handles paying out keeper reward for an order exection\n    function _handleKeep(address account, IMarket market, UFixed6 fee)\n        private\n        keep(\n            KeepConfig(\n                UFixed18Lib.ZERO,\n                keepBufferBase,\n                UFixed18Lib.ZERO,\n                keepBufferCalldata\n            ),\n            msg.data[0:0],\n            0,\n            abi.encode(account, market, fee)\n        )\n    { }\n\n    /// @notice Helper function to raise keeper fee\n    /// @param keeperFee Keeper fee to raise\n    /// @param data Data to raise keeper fee with\n    function _raiseKeeperFee(UFixed18 keeperFee, bytes memory data) internal override {\n        (address account, IMarket market, UFixed6 fee) = abi.decode(data, (address, IMarket, UFixed6));\n        if (keeperFee.gt(UFixed18Lib.from(fee))) revert MultiInvokerMaxFeeExceededError();\n\n        market.update(\n            account,\n            UFixed6Lib.MAX,\n            UFixed6Lib.MAX,\n            UFixed6Lib.MAX,\n            Fixed6Lib.from(Fixed18Lib.from(-1, keeperFee), true),\n            false\n        );\n    }\n\n    /// @notice Places order on behalf of msg.sender from the invoker\n    /// @param account Account to place order for\n    /// @param market Market to place order in\n    /// @param order Order state to place\n    function _placeOrder(\n        address account,\n        IMarket market,\n        TriggerOrder memory order\n    ) internal isMarketInstance(market) {\n        if (order.fee.isZero()) revert MultiInvokerInvalidOrderError();\n        if (order.comparison != -1 && order.comparison != 1) revert MultiInvokerInvalidOrderError();\n        if (\n            order.side > 3 ||                                       // Invalid side\n            (order.side == 3 && order.delta.gte(Fixed6Lib.ZERO))    // Disallow placing orders that increase collateral\n        ) revert MultiInvokerInvalidOrderError();\n\n        _orders[account][market][++latestNonce].store(order);\n        emit OrderPlaced(account, market, latestNonce, order);\n    }\n\n    /// @notice Cancels an open order for msg.sender\n    /// @param account Account to cancel order for\n    /// @param market Market order is open in\n    /// @param nonce UID of order\n    function _cancelOrder(address account, IMarket market, uint256 nonce) internal {\n        delete _orders[account][market][nonce];\n        emit OrderCancelled(account, market, nonce);\n    }\n\n    /// @notice Target market must be created by MarketFactory\n    modifier isMarketInstance(IMarket market) {\n        if (!marketFactory.instances(market))\n            revert MultiInvokerInvalidInstanceError();\n        _;\n    }\n\n    /// @notice Target vault must be created by VaultFactory\n    modifier isVaultInstance(IVault vault) {\n        if (!vaultFactory.instances(vault))\n            revert MultiInvokerInvalidInstanceError();\n        _;\n    }\n\n}"
    },
    {
      "filename": "perennial-v2/packages/perennial-vault/contracts/lib/StrategyLib.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../types/Registration.sol\";\n\n/// @dev The context of an underlying market\nstruct MarketStrategyContext {\n    /// @dev The market parameter set\n    MarketParameter marketParameter;\n\n    /// @dev The risk parameter set\n    RiskParameter riskParameter;\n\n    /// @dev The local state of the vault\n    Local local;\n\n    /// @dev The vault's current account position\n    Position currentAccountPosition;\n\n    /// @dev The vault's latest account position\n    Position latestAccountPosition;\n\n    /// @dev The current global position\n    Position currentPosition;\n\n    /// @dev The latest valid price\n    Fixed6 latestPrice;\n\n    /// @dev The margin requirement of the vault\n    UFixed6 margin;\n\n    /// @dev The current closable amount of the vault\n    UFixed6 closable;\n}\n\nstruct Strategy {\n    MarketStrategyContext[] marketContexts;\n}\nusing StrategyLib for Strategy global;\n\n/// @title Strategy\n/// @notice Logic for vault capital allocation\n/// @dev - Deploys collateral first to satisfy the margin of each market, then deploys the rest by weight.\n///      - Positions are then targeted based on the amount of collateral that ends up deployed to each market.\nlibrary StrategyLib {\n    /// @dev The maximum multiplier that is allowed for leverage\n    UFixed6 public constant LEVERAGE_BUFFER = UFixed6.wrap(1.2e6);\n\n    /// @dev The target allocation for a market\n    struct MarketTarget {\n        /// @dev The amount of change in collateral\n        Fixed6 collateral;\n\n        /// @dev The new position\n        UFixed6 position;\n    }\n\n    /// @dev Internal struct to avoid stack to deep error\n    struct _AllocateLocals {\n        UFixed6 marketCollateral;\n        UFixed6 marketAssets;\n        UFixed6 minPosition;\n        UFixed6 maxPosition;\n        UFixed6 minAssets;\n        uint256 totalWeight;\n        UFixed6 totalMargin;\n    }\n\n    function load(Registration[] memory registrations) internal view returns (Strategy memory strategy) {\n        strategy.marketContexts = new MarketStrategyContext[](registrations.length);\n        for (uint256 marketId; marketId < registrations.length; marketId++)\n            strategy.marketContexts[marketId] = _loadContext(registrations[marketId]);\n    }\n\n    function maxRedeem(\n        Strategy memory strategy,\n        Registration[] memory registrations,\n        uint256 totalWeight\n    ) internal pure returns (UFixed6 redemptionAssets) {\n        redemptionAssets = UFixed6Lib.MAX;\n        for (uint256 marketId; marketId < strategy.marketContexts.length; marketId++) {\n            MarketStrategyContext memory marketContext = strategy.marketContexts[marketId];\n            Registration memory registration = registrations[marketId];\n\n            // If market has 0 weight, leverage, or position, skip\n            if (\n                registration.weight == 0 ||\n                registration.leverage.isZero() || (\n                    marketContext.latestAccountPosition.maker.isZero() &&\n                    marketContext.currentAccountPosition.maker.isZero()\n                )\n            ) continue;\n\n            UFixed6 collateral = marketContext.currentPosition.maker\n                .sub(marketContext.currentPosition.net().min(marketContext.currentPosition.maker))  // available maker\n                .min(marketContext.closable.mul(StrategyLib.LEVERAGE_BUFFER))                       // available closable\n                .muldiv(marketContext.latestPrice.abs(), registration.leverage)                     // available collateral\n                .muldiv(totalWeight, registration.weight);                                          // collateral in market\n\n            redemptionAssets = redemptionAssets.min(collateral);\n        }\n    }\n\n    /// @notice Compute the target allocation for each market\n    /// @param strategy The strategy of the vault\n    /// @param registrations The registrations of the markets\n    /// @param collateral The amount of collateral to allocate\n    /// @param assets The amount of collateral that is eligible for positions\n    function allocate(\n        Strategy memory strategy,\n        Registration[] memory registrations,\n        UFixed6 collateral,\n        UFixed6 assets\n    ) internal pure returns (MarketTarget[] memory targets) {\n        _AllocateLocals memory _locals;\n        (_locals.totalWeight, _locals.totalMargin) = _aggregate(registrations, strategy.marketContexts);\n\n        targets = new MarketTarget[](registrations.length);\n        for (uint256 marketId; marketId < registrations.length; marketId++) {\n\n            _locals.marketCollateral = strategy.marketContexts[marketId].margin\n                .add(collateral.sub(_locals.totalMargin).muldiv(registrations[marketId].weight, _locals.totalWeight));\n\n            _locals.marketAssets = assets\n                .muldiv(registrations[marketId].weight, _locals.totalWeight)\n                .min(_locals.marketCollateral.mul(LEVERAGE_BUFFER));\n\n            _locals.minAssets = strategy.marketContexts[marketId].riskParameter.minMargin\n                .unsafeDiv(registrations[marketId].leverage.mul(strategy.marketContexts[marketId].riskParameter.maintenance));\n            if (strategy.marketContexts[marketId].marketParameter.closed || _locals.marketAssets.lt(_locals.minAssets))\n                _locals.marketAssets = UFixed6Lib.ZERO;\n\n            (_locals.minPosition, _locals.maxPosition) = _positionLimit(strategy.marketContexts[marketId]);\n\n            (targets[marketId].collateral, targets[marketId].position) = (\n                Fixed6Lib.from(_locals.marketCollateral).sub(strategy.marketContexts[marketId].local.collateral),\n                _locals.marketAssets\n                    .muldiv(registrations[marketId].leverage, strategy.marketContexts[marketId].latestPrice.abs())\n                    .min(_locals.maxPosition)\n                    .max(_locals.minPosition)\n            );\n        }\n    }\n\n    /// @notice Load the context of a market\n    /// @param registration The registration of the market\n    /// @return marketContext The context of the market\n    function _loadContext(Registration memory registration) private view returns (MarketStrategyContext memory marketContext) {\n        marketContext.marketParameter = registration.market.parameter();\n        marketContext.riskParameter = registration.market.riskParameter();\n        marketContext.local = registration.market.locals(address(this));\n        Global memory global = registration.market.global();\n        marketContext.latestPrice = global.latestPrice;\n\n        // latest position\n        UFixed6 previousClosable;\n        previousClosable = _loadPosition(\n            marketContext,\n            marketContext.latestAccountPosition = registration.market.positions(address(this)),\n            previousClosable\n        );\n        marketContext.closable = marketContext.latestAccountPosition.maker;\n\n        // pending positions\n        for (uint256 id = marketContext.local.latestId + 1; id <= marketContext.local.currentId; id++)\n            previousClosable = _loadPosition(\n                marketContext,\n                marketContext.currentAccountPosition = registration.market.pendingPositions(address(this), id),\n                previousClosable\n            );\n\n        // current position\n        Position memory latestPosition = registration.market.position();\n        marketContext.currentPosition = registration.market.pendingPosition(global.currentId);\n        marketContext.currentPosition.adjust(latestPosition);\n    }\n\n    /// @notice Loads one position for the context calculation\n    /// @param marketContext The context of the market\n    /// @param position The position to load\n    /// @param previousMaker The previous maker position\n    /// @return nextMaker The next maker position\n    function _loadPosition(\n        MarketStrategyContext memory marketContext,\n        Position memory position,\n        UFixed6 previousMaker\n    ) private pure returns (UFixed6 nextMaker) {\n        position.adjust(marketContext.latestAccountPosition);\n\n        marketContext.margin = position\n            .margin(OracleVersion(0, marketContext.latestPrice, true), marketContext.riskParameter)\n            .max(marketContext.margin);\n        marketContext.closable = marketContext.closable.sub(previousMaker.sub(position.maker.min(previousMaker)));\n        nextMaker = position.maker;\n    }\n\n    /// @notice Aggregate the context of all markets\n    /// @param registrations The registrations of the markets\n    /// @param marketContexts The contexts of the markets\n    /// @return totalWeight The total weight of all markets\n    /// @return totalMargin The total margin of all markets\n    function _aggregate(\n        Registration[] memory registrations,\n        MarketStrategyContext[] memory marketContexts\n    ) private pure returns (uint256 totalWeight, UFixed6 totalMargin) {\n        for (uint256 marketId; marketId < registrations.length; marketId++) {"
    }
  ]
}