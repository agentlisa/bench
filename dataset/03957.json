{
  "Title": "[M09] Contracts storage layout can be corrupted on upgradeable contracts",
  "Content": "The Celo protocol has an [unstructured storage proxy pattern](https://blog.openzeppelin.com/upgradeability-using-unstructured-storage/) system implemented, very similar to the one proposed in the [OpenZeppelin SDK](https://github.com/OpenZeppelin/openzeppelin-sdk/tree/v2.6.0/packages/lib/contracts/upgradeability).\n\n\nThis upgradeability system consists of a [Proxy](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/Proxy.sol#L9) contract which users interact with directly and that is in charge of forwarding transactions to and from a second contract. This second contract contains the logic, commonly known as the implementation contract. This approach has two main considerations to be aware of:\n\n\n* Storage collisions between the proxy contract and the implementation contract: There can be collisions between the state variables defined for the proxy, such as the [`IMPLEMENTATION_POSITION`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/Proxy.sol#L13), the [`OWNER_POSITION`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/Proxy.sol#L11), and the state variables defined for the logic contract. This is well managed by Celo, by reserving a pseudo-random slot for both the logic contracts’ implementation and owner address. This way, they are guaranteed to not clash with state variables allocated by the compiler, since they depend on the hash of a string that does not start with a storage index.\n* Storage collisions between different implementation versions: There can be storage collisions between different versions of the same implementation contract. Some possible scenarios are:\n* When changing the variables order in the contract\n* When removing the non-latest variable defined in the contract\n* When changing the type of a variable\n* When introducing a new variable before any existing one\n* In some cases, when adding a new field to a struct in the contract\n\n\nThe unstructured storage proxy mechanism does not safeguard against this situation by itself, and there are no validations being done by [the script that is in charge of upgrading contracts](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/scripts/truffle/upgrade.ts) , thus there is no certainty that storage layout will remain safe after an upgrade. Violating any of these storage layout restrictions will cause the upgraded version of the contract to have its storage values mixed up, and can lead to critical errors in Celo protocol’s contracts.\n\n\nConsider checking whether there were changes in the storage layout before upgrading a contract by saving the storage layout of the implementation contract’s previous version and comparing it with the storage layout of the new one.\n\n\nIn addition to this, consider using the [`OpenZeppelin SDK`](https://openzeppelin.com/sdk/), which already covers these scenarios among others, such as multilevel inheritance using a more complete version of the [`Initializable contract`](https://github.com/OpenZeppelin/openzeppelin-sdk/blob/v2.6.0/packages/lib/contracts/Initializable.sol) and the [transparent proxy pattern](https://blog.openzeppelin.com/the-transparent-proxy-pattern/).\n\n\n****Update:*** Not Fixed. cLabs’ statement for this issue:*\n\n\n\n> \n> As stated in the report, there’s a risk of performing not compatible upgrades that use a different storage layout. The actual upgrade script is a development one; on mainnet upgrade will be performed by governance proposal; and when this happens we’ll make sure there are programmatic tools for verifying contract upgrades compatibility. The TransparentProxy pattern is an interesting idea to implement. This can be done before or after mainnet with a governance proposal. To be able to use this, one would need to create a new contract (ContractManager) whose sole responsibility is to perform upgrades; since the Governance contract is the performing upgrade, and also makes other calls to the underlying implementation.\n> \n> \n> \n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/common/Proxy.sol",
      "content": "pragma solidity ^0.5.3;\n/* solhint-disable no-inline-assembly, no-complex-fallback, avoid-low-level-calls */\n\nimport \"./libraries/AddressesHelper.sol\";\n\n/**\n * @title A Proxy utilizing the Unstructured Storage pattern.\n */\ncontract Proxy {\n  // Used to store the address of the owner.\n  bytes32 private constant OWNER_POSITION = keccak256(\"org.celo.owner\");\n  // Used to store the address of the implementation contract.\n  bytes32 private constant IMPLEMENTATION_POSITION = keccak256(\"org.celo.implementation\");\n\n  event OwnerSet(address indexed owner);\n  event ImplementationSet(address indexed implementation);\n\n  constructor() public {\n    _setOwner(msg.sender);\n  }\n\n  /**\n   * @notice Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == _getOwner(), \"sender was not owner\");\n    _;\n  }\n\n  /**\n   * @notice Delegates calls to the implementation contract.\n   */\n  function() external payable {\n    bytes32 implementationPosition = IMPLEMENTATION_POSITION;\n\n    address implementationAddress;\n\n    assembly {\n      implementationAddress := sload(implementationPosition)\n    }\n\n    // Avoid checking if address is a contract or executing delegated call when\n    // implementation address is 0x0\n    if (implementationAddress == address(0)) return;\n\n    require(AddressesHelper.isContract(implementationAddress), \"Invalid contract address\");\n\n    assembly {\n      let newCallDataPosition := mload(0x40)\n      mstore(0x40, add(newCallDataPosition, calldatasize))\n\n      calldatacopy(newCallDataPosition, 0, calldatasize)\n\n      let delegatecallSuccess := delegatecall(\n        gas,\n        implementationAddress,\n        newCallDataPosition,\n        calldatasize,\n        0,\n        0\n      )\n\n      let returnDataSize := returndatasize\n      let returnDataPosition := mload(0x40)\n      mstore(0x40, add(returnDataPosition, returnDataSize))\n      returndatacopy(returnDataPosition, 0, returnDataSize)\n\n      switch delegatecallSuccess\n        case 0 {\n          revert(returnDataPosition, returnDataSize)\n        }\n        default {\n          return(returnDataPosition, returnDataSize)\n        }\n    }\n  }\n\n  /**\n   * @notice Transfers ownership of Proxy to a new owner.\n   * @param newOwner Address of the new owner account.\n   */\n  function _transferOwnership(address newOwner) external onlyOwner {\n    _setOwner(newOwner);\n  }\n\n  /**\n   * @notice Sets the address of the implementation contract and calls into it.\n   * @param implementation Address of the new target contract.\n   * @param callbackData The abi-encoded function call to perform in the implementation\n   * contract.\n   * @dev Throws if the initialization callback fails.\n   * @dev If the target contract does not need initialization, use\n   * setImplementation instead.\n   */\n  function _setAndInitializeImplementation(address implementation, bytes calldata callbackData)\n    external\n    payable\n    onlyOwner\n  {\n    _setImplementation(implementation);\n    bool success;\n    bytes memory returnValue;\n    (success, returnValue) = implementation.delegatecall(callbackData);\n    require(success, \"initialization callback failed\");\n  }\n\n  /**\n   * @notice Returns the implementation address.\n   */\n  function _getImplementation() external view returns (address implementation) {\n    bytes32 implementationPosition = IMPLEMENTATION_POSITION;\n    assembly {\n      implementation := sload(implementationPosition)\n    }\n  }\n\n  /**\n   * @notice Sets the address of the implementation contract.\n   * @param implementation Address of the new target contract.\n   * @dev If the target contract needs to be initialized, call\n   * setAndInitializeImplementation instead.\n   */\n  function _setImplementation(address implementation) public onlyOwner {\n    bytes32 implementationPosition = IMPLEMENTATION_POSITION;\n\n    require(AddressesHelper.isContract(implementation), \"Invalid contract address\");\n\n    assembly {\n      sstore(implementationPosition, implementation)\n    }\n\n    emit ImplementationSet(implementation);\n  }\n\n  /**\n   * @notice Returns the Proxy owner's address.\n   */\n  function _getOwner() public view returns (address owner) {\n    bytes32 position = OWNER_POSITION;\n    assembly {\n      owner := sload(position)\n    }\n  }\n\n  function _setOwner(address newOwner) private {\n    bytes32 position = OWNER_POSITION;\n    assembly {\n      sstore(position, newOwner)\n    }\n    emit OwnerSet(newOwner);\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/common/Proxy.sol",
      "content": "pragma solidity ^0.5.3;\n/* solhint-disable no-inline-assembly, no-complex-fallback, avoid-low-level-calls */\n\nimport \"./libraries/AddressesHelper.sol\";\n\n/**\n * @title A Proxy utilizing the Unstructured Storage pattern.\n */\ncontract Proxy {\n  // Used to store the address of the owner.\n  bytes32 private constant OWNER_POSITION = keccak256(\"org.celo.owner\");\n  // Used to store the address of the implementation contract.\n  bytes32 private constant IMPLEMENTATION_POSITION = keccak256(\"org.celo.implementation\");\n\n  event OwnerSet(address indexed owner);\n  event ImplementationSet(address indexed implementation);\n\n  constructor() public {\n    _setOwner(msg.sender);\n  }\n\n  /**\n   * @notice Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == _getOwner(), \"sender was not owner\");\n    _;\n  }\n\n  /**\n   * @notice Delegates calls to the implementation contract.\n   */\n  function() external payable {\n    bytes32 implementationPosition = IMPLEMENTATION_POSITION;\n\n    address implementationAddress;\n\n    assembly {\n      implementationAddress := sload(implementationPosition)\n    }\n\n    // Avoid checking if address is a contract or executing delegated call when\n    // implementation address is 0x0\n    if (implementationAddress == address(0)) return;\n\n    require(AddressesHelper.isContract(implementationAddress), \"Invalid contract address\");\n\n    assembly {\n      let newCallDataPosition := mload(0x40)\n      mstore(0x40, add(newCallDataPosition, calldatasize))\n\n      calldatacopy(newCallDataPosition, 0, calldatasize)\n\n      let delegatecallSuccess := delegatecall(\n        gas,\n        implementationAddress,\n        newCallDataPosition,\n        calldatasize,\n        0,\n        0\n      )\n\n      let returnDataSize := returndatasize\n      let returnDataPosition := mload(0x40)\n      mstore(0x40, add(returnDataPosition, returnDataSize))\n      returndatacopy(returnDataPosition, 0, returnDataSize)\n\n      switch delegatecallSuccess\n        case 0 {\n          revert(returnDataPosition, returnDataSize)\n        }\n        default {\n          return(returnDataPosition, returnDataSize)\n        }\n    }\n  }\n\n  /**\n   * @notice Transfers ownership of Proxy to a new owner.\n   * @param newOwner Address of the new owner account.\n   */\n  function _transferOwnership(address newOwner) external onlyOwner {\n    _setOwner(newOwner);\n  }\n\n  /**\n   * @notice Sets the address of the implementation contract and calls into it.\n   * @param implementation Address of the new target contract.\n   * @param callbackData The abi-encoded function call to perform in the implementation\n   * contract.\n   * @dev Throws if the initialization callback fails.\n   * @dev If the target contract does not need initialization, use\n   * setImplementation instead.\n   */\n  function _setAndInitializeImplementation(address implementation, bytes calldata callbackData)\n    external\n    payable\n    onlyOwner\n  {\n    _setImplementation(implementation);\n    bool success;\n    bytes memory returnValue;\n    (success, returnValue) = implementation.delegatecall(callbackData);\n    require(success, \"initialization callback failed\");\n  }\n\n  /**\n   * @notice Returns the implementation address.\n   */\n  function _getImplementation() external view returns (address implementation) {\n    bytes32 implementationPosition = IMPLEMENTATION_POSITION;\n    assembly {\n      implementation := sload(implementationPosition)\n    }\n  }\n\n  /**\n   * @notice Sets the address of the implementation contract.\n   * @param implementation Address of the new target contract.\n   * @dev If the target contract needs to be initialized, call\n   * setAndInitializeImplementation instead.\n   */\n  function _setImplementation(address implementation) public onlyOwner {\n    bytes32 implementationPosition = IMPLEMENTATION_POSITION;\n\n    require(AddressesHelper.isContract(implementation), \"Invalid contract address\");\n\n    assembly {\n      sstore(implementationPosition, implementation)\n    }\n\n    emit ImplementationSet(implementation);\n  }\n\n  /**\n   * @notice Returns the Proxy owner's address.\n   */\n  function _getOwner() public view returns (address owner) {\n    bytes32 position = OWNER_POSITION;\n    assembly {\n      owner := sload(position)\n    }\n  }\n\n  function _setOwner(address newOwner) private {\n    bytes32 position = OWNER_POSITION;\n    assembly {\n      sstore(position, newOwner)\n    }\n    emit OwnerSet(newOwner);\n  }\n}"
    }
  ]
}