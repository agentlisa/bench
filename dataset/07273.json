{
  "Title": "[M-10] Public vault slope can overflow",
  "Content": "\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/PublicVault.sol#L562-L568><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/57c2fe33c1d57bc2814bfd23592417fc4d5bf7de/src/LienToken.sol#L702-L704>\n\nThe slope of public vault can overflow in the afterPayment function due to unchecked addition. When this happens, totalAssets will not be correct. This can also result in underflows in slope updates elsewhere, causing large fluctuations in slope and totalAssets.\n\n### Proof of Concept\n\nAssume the token is a normal 18 decimal ERC20 token.<br>\nAfter 5 loans of 1000 tokens, all with the maximum interest rate of 63419583966, the slope will overflow.<br>\n`5 * 1000 * 63419583966 / 2^48 = 1.1265581173`\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nRemove the unchecked block. Also, I think 48 bits might not be enough for slope.\n\n**[SantiagoGregory (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/418)**\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-01-astaria",
  "Code": [
    {
      "filename": "src/PublicVault.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**\n *  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗\n * ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n * ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n * ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n * ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n * ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n *\n * Astaria Labs, Inc\n */\n\npragma solidity =0.8.17;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC4626} from \"solmate/mixins/ERC4626.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\n\nimport {IERC165} from \"core/interfaces/IERC165.sol\";\nimport {ERC4626Cloned} from \"gpl/ERC4626-Cloned.sol\";\nimport {IERC4626} from \"core/interfaces/IERC4626.sol\";\nimport {IERC20} from \"core/interfaces/IERC20.sol\";\nimport {IERC20Metadata} from \"core/interfaces/IERC20Metadata.sol\";\nimport {ERC20Cloned} from \"gpl/ERC20-Cloned.sol\";\nimport {\n  ClonesWithImmutableArgs\n} from \"clones-with-immutable-args/ClonesWithImmutableArgs.sol\";\n\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\n\nimport {VaultImplementation} from \"core/VaultImplementation.sol\";\nimport {WithdrawProxy} from \"core/WithdrawProxy.sol\";\n\nimport {Math} from \"core/utils/Math.sol\";\nimport {IPublicVault} from \"core/interfaces/IPublicVault.sol\";\nimport {IAstariaVaultBase} from \"core/interfaces/IAstariaVaultBase.sol\";\nimport {AstariaVaultBase} from \"core/AstariaVaultBase.sol\";\n\n/*\n * @title PublicVault\n * @author androolloyd\n * @notice\n */\ncontract PublicVault is VaultImplementation, IPublicVault, ERC4626Cloned {\n  using FixedPointMathLib for uint256;\n  using SafeTransferLib for ERC20;\n  using SafeCastLib for uint256;\n\n  uint256 private constant PUBLIC_VAULT_SLOT =\n    uint256(keccak256(\"xyz.astaria.PublicVault.storage.location\")) - 1;\n\n  function asset()\n    public\n    pure\n    virtual\n    override(IAstariaVaultBase, AstariaVaultBase, ERC4626Cloned)\n    returns (address)\n  {\n    return super.asset();\n  }\n\n  function decimals()\n    public\n    pure\n    virtual\n    override(IERC20Metadata)\n    returns (uint8)\n  {\n    return 18;\n  }\n\n  function name()\n    public\n    view\n    virtual\n    override(IERC20Metadata, VaultImplementation)\n    returns (string memory)\n  {\n    return string(abi.encodePacked(\"AST-Vault-\", ERC20(asset()).symbol()));\n  }\n\n  function symbol()\n    public\n    view\n    virtual\n    override(IERC20Metadata, VaultImplementation)\n    returns (string memory)\n  {\n    return string(abi.encodePacked(\"AST-V-\", ERC20(asset()).symbol()));\n  }\n\n  function minDepositAmount()\n    public\n    view\n    virtual\n    override(ERC4626Cloned)\n    returns (uint256)\n  {\n    if (ERC20(asset()).decimals() == uint8(18)) {\n      return 100 gwei;\n    } else {\n      return 10**(ERC20(asset()).decimals() - 1);\n    }\n  }\n\n  /**\n   * @notice Signal a withdrawal of funds (redeeming for underlying asset) in the next epoch.\n   * @param shares The number of VaultToken shares to redeem.\n   * @param receiver The receiver of the WithdrawTokens (and eventual underlying asset)\n   * @param owner The owner of the VaultTokens.\n   * @return assets The amount of the underlying asset redeemed.\n   */\n  function redeem(\n    uint256 shares,\n    address receiver,\n    address owner\n  ) public virtual override(ERC4626Cloned) returns (uint256 assets) {\n    VaultData storage s = _loadStorageSlot();\n    assets = _redeemFutureEpoch(s, shares, receiver, owner, s.currentEpoch);\n  }\n\n  function withdraw(\n    uint256 assets,\n    address receiver,\n    address owner\n  ) public virtual override(ERC4626Cloned) returns (uint256 shares) {\n    shares = previewWithdraw(assets);\n\n    VaultData storage s = _loadStorageSlot();\n\n    _redeemFutureEpoch(s, shares, receiver, owner, s.currentEpoch);\n  }\n\n  function redeemFutureEpoch(\n    uint256 shares,\n    address receiver,\n    address owner,\n    uint64 epoch\n  ) public virtual returns (uint256 assets) {\n    return\n      _redeemFutureEpoch(_loadStorageSlot(), shares, receiver, owner, epoch);\n  }\n\n  function _redeemFutureEpoch(\n    VaultData storage s,\n    uint256 shares,\n    address receiver,\n    address owner,\n    uint64 epoch\n  ) internal virtual returns (uint256 assets) {\n    // check to ensure that the requested epoch is not in the past\n\n    ERC20Data storage es = _loadERC20Slot();\n\n    if (msg.sender != owner) {\n      uint256 allowed = es.allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n      if (allowed != type(uint256).max) {\n        es.allowance[owner][msg.sender] = allowed - shares;\n      }\n    }\n\n    if (epoch < s.currentEpoch) {\n      revert InvalidState(InvalidStates.EPOCH_TOO_LOW);\n    }\n    require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n    // check for rounding error since we round down in previewRedeem.\n\n    //this will underflow if not enough balance\n    es.balanceOf[owner] -= shares;\n\n    // Cannot overflow because the sum of all user\n    // balances can't exceed the max uint256 value.\n    unchecked {\n      es.balanceOf[address(this)] += shares;\n    }\n\n    emit Transfer(owner, address(this), shares);\n    // Deploy WithdrawProxy if no WithdrawProxy exists for the specified epoch\n    _deployWithdrawProxyIfNotDeployed(s, epoch);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n    // WithdrawProxy shares are minted 1:1 with PublicVault shares\n    WithdrawProxy(s.epochData[epoch].withdrawProxy).mint(shares, receiver);\n  }\n\n  function getWithdrawProxy(uint64 epoch) public view returns (WithdrawProxy) {\n    return WithdrawProxy(_loadStorageSlot().epochData[epoch].withdrawProxy);\n  }\n\n  function getCurrentEpoch() public view returns (uint64) {\n    return _loadStorageSlot().currentEpoch;\n  }\n\n  function getSlope() public view returns (uint256) {\n    return uint256(_loadStorageSlot().slope);\n  }\n\n  function getWithdrawReserve() public view returns (uint256) {\n    return uint256(_loadStorageSlot().withdrawReserve);\n  }\n\n  function getLiquidationWithdrawRatio() public view returns (uint256) {\n    return uint256(_loadStorageSlot().liquidationWithdrawRatio);\n  }\n\n  function getYIntercept() public view returns (uint256) {\n    return uint256(_loadStorageSlot().yIntercept);\n  }\n\n  function _deployWithdrawProxyIfNotDeployed(VaultData storage s, uint64 epoch)\n    internal\n  {\n    if (s.epochData[epoch].withdrawProxy == address(0)) {\n      s.epochData[epoch].withdrawProxy = ClonesWithImmutableArgs.clone(\n        IAstariaRouter(ROUTER()).BEACON_PROXY_IMPLEMENTATION(),\n        abi.encodePacked(\n          address(ROUTER()), // router is the beacon\n          uint8(IAstariaRouter.ImplementationType.WithdrawProxy),\n          asset(), // token\n          address(this), // vault\n          epoch + 1 // claimable epoch\n        )\n      );\n    }\n  }\n\n  function mint(uint256 shares, address receiver)\n    public\n    override(ERC4626Cloned)\n    whenNotPaused\n    returns (uint256)\n  {\n    VIData storage s = _loadVISlot();\n    if (s.allowListEnabled) {\n      require(s.allowList[receiver]);\n    }\n    return super.mint(shares, receiver);\n  }\n\n  /**\n   * @notice Deposit funds into the PublicVault.\n   * @param amount The amount of funds to deposit.\n   * @param receiver The receiver of the resulting VaultToken shares.\n   */\n  function deposit(uint256 amount, address receiver)\n    public\n    override(ERC4626Cloned)\n    whenNotPaused\n    returns (uint256)\n  {\n    VIData storage s = _loadVISlot();\n    if (s.allowListEnabled) {\n      require(s.allowList[receiver]);\n    }\n\n    uint256 assets = totalAssets();\n\n    return super.deposit(amount, receiver);\n  }\n\n  /**\n   * @notice Retrieve the domain separator.\n   * @return The domain separator.\n   */\n  function computeDomainSeparator() internal view override returns (bytes32) {\n    return super.domainSeparator();\n  }\n\n  function processEpoch() public {\n    // check to make sure epoch is over\n    if (timeToEpochEnd() > 0) {\n      revert InvalidState(InvalidStates.EPOCH_NOT_OVER);\n    }\n    VaultData storage s = _loadStorageSlot();\n\n    if (s.withdrawReserve > 0) {\n      revert InvalidState(InvalidStates.WITHDRAW_RESERVE_NOT_ZERO);\n    }\n\n    WithdrawProxy currentWithdrawProxy = WithdrawProxy(\n      s.epochData[s.currentEpoch].withdrawProxy\n    );\n\n    // split funds from previous WithdrawProxy with PublicVault if hasn't been already\n    if (s.currentEpoch != 0) {\n      WithdrawProxy previousWithdrawProxy = WithdrawProxy(\n        s.epochData[s.currentEpoch - 1].withdrawProxy\n      );\n      if (\n        address(previousWithdrawProxy) != address(0) &&\n        previousWithdrawProxy.getFinalAuctionEnd() != 0\n      ) {\n        previousWithdrawProxy.claim();\n      }\n    }\n\n    if (s.epochData[s.currentEpoch].liensOpenForEpoch > 0) {\n      revert InvalidState(InvalidStates.LIENS_OPEN_FOR_EPOCH_NOT_ZERO);\n    }\n\n    // reset liquidationWithdrawRatio to prepare for re calcualtion\n    s.liquidationWithdrawRatio = 0;\n\n    // check if there are LPs withdrawing this epoch\n    if ((address(currentWithdrawProxy) != address(0))) {\n      uint256 proxySupply = currentWithdrawProxy.totalSupply();\n\n      s.liquidationWithdrawRatio = proxySupply\n        .mulDivDown(1e18, totalSupply())\n        .safeCastTo88();\n\n      currentWithdrawProxy.setWithdrawRatio(s.liquidationWithdrawRatio);\n      uint256 expected = currentWithdrawProxy.getExpected();\n\n      unchecked {\n        if (totalAssets() > expected) {\n          s.withdrawReserve = (totalAssets() - expected)\n            .mulWadDown(s.liquidationWithdrawRatio)\n            .safeCastTo88();\n        } else {\n          s.withdrawReserve = 0;\n        }\n      }\n      _setYIntercept(\n        s,\n        s.yIntercept -\n          totalAssets().mulDivDown(s.liquidationWithdrawRatio, 1e18)\n      );\n      // burn the tokens of the LPs withdrawing\n      _burn(address(this), proxySupply);\n    }\n\n    // increment epoch\n    unchecked {\n      s.currentEpoch++;\n    }\n  }\n\n  function supportsInterface(bytes4 interfaceId)\n    public\n    pure\n    override(IERC165)\n    returns (bool)\n  {\n    return\n      interfaceId == type(IPublicVault).interfaceId ||\n      interfaceId == type(ERC4626Cloned).interfaceId ||\n      interfaceId == type(ERC4626).interfaceId ||\n      interfaceId == type(ERC20).interfaceId ||\n      interfaceId == type(IERC165).interfaceId;\n  }\n\n  function transferWithdrawReserve() public {\n    VaultData storage s = _loadStorageSlot();\n\n    if (s.currentEpoch == uint64(0)) {\n      return;\n    }\n\n    address currentWithdrawProxy = s\n      .epochData[s.currentEpoch - 1]\n      .withdrawProxy;\n    // prevents transfer to a non-existent WithdrawProxy\n    // withdrawProxies are indexed by the epoch where they're deployed\n    if (currentWithdrawProxy != address(0)) {\n      uint256 withdrawBalance = ERC20(asset()).balanceOf(address(this));\n\n      // prevent transfer of more assets then are available\n      if (s.withdrawReserve <= withdrawBalance) {\n        withdrawBalance = s.withdrawReserve;\n        s.withdrawReserve = 0;\n      } else {\n        unchecked {\n          s.withdrawReserve -= withdrawBalance.safeCastTo88();\n        }\n      }\n\n      ERC20(asset()).safeTransfer(currentWithdrawProxy, withdrawBalance);\n      WithdrawProxy(currentWithdrawProxy).increaseWithdrawReserveReceived(\n        withdrawBalance\n      );\n      emit WithdrawReserveTransferred(withdrawBalance);\n    }\n\n    address withdrawProxy = s.epochData[s.currentEpoch].withdrawProxy;\n    if (\n      s.withdrawReserve > 0 &&\n      timeToEpochEnd() == 0 &&\n      withdrawProxy != address(0)\n    ) {\n      address currentWithdrawProxy = s\n        .epochData[s.currentEpoch - 1]\n        .withdrawProxy;\n      uint256 drainBalance = WithdrawProxy(withdrawProxy).drain(\n        s.withdrawReserve,\n        s.epochData[s.currentEpoch - 1].withdrawProxy\n      );\n      unchecked {\n        s.withdrawReserve -= drainBalance.safeCastTo88();\n      }\n      WithdrawProxy(currentWithdrawProxy).increaseWithdrawReserveReceived(\n        drainBalance\n      );\n    }\n  }\n\n  function _beforeCommitToLien(IAstariaRouter.Commitment calldata params)\n    internal\n    virtual\n    override(VaultImplementation)\n  {\n    VaultData storage s = _loadStorageSlot();\n\n    if (s.withdrawReserve > uint256(0)) {\n      transferWithdrawReserve();\n    }\n    if (timeToEpochEnd() == uint256(0)) {\n      processEpoch();\n    }\n  }\n\n  function _loadStorageSlot() internal pure returns (VaultData storage s) {\n    uint256 slot = PUBLIC_VAULT_SLOT;\n    assembly {\n      s.slot := slot\n    }\n  }\n\n  /**\n   * @dev Hook for updating the slope of the PublicVault after a LienToken is issued.\n   * @param lienId The ID of the lien.\n   */\n  function _afterCommitToLien(\n    uint40 lienEnd,\n    uint256 lienId,\n    uint256 lienSlope\n  ) internal virtual override {\n    VaultData storage s = _loadStorageSlot();\n\n    // increment slope for the new lien\n    _accrue(s);\n    unchecked {\n      uint48 newSlope = s.slope + lienSlope.safeCastTo48();\n      _setSlope(s, newSlope);\n    }\n\n    uint64 epoch = getLienEpoch(lienEnd);\n\n    _increaseOpenLiens(s, epoch);\n    emit LienOpen(lienId, epoch);\n  }\n\n  event SlopeUpdated(uint48 newSlope);\n\n  function accrue() public returns (uint256) {\n    return _accrue(_loadStorageSlot());\n  }\n\n  function _accrue(VaultData storage s) internal returns (uint256) {\n    unchecked {\n      s.yIntercept = (_totalAssets(s)).safeCastTo88();\n      s.last = block.timestamp.safeCastTo40();\n    }\n    emit YInterceptChanged(s.yIntercept);\n\n    return s.yIntercept;\n  }\n\n  /**\n   * @notice Computes the implied value of this PublicVault. This includes interest payments that have not yet been made.\n   * @return The implied value for this PublicVault.\n   */\n  function totalAssets()\n    public\n    view\n    virtual\n    override(ERC4626Cloned)\n    returns (uint256)\n  {\n    VaultData storage s = _loadStorageSlot();\n    return _totalAssets(s);\n  }\n\n  function _totalAssets(VaultData storage s) internal view returns (uint256) {\n    uint256 delta_t = block.timestamp - s.last;\n    return uint256(s.slope).mulDivDown(delta_t, 1) + uint256(s.yIntercept);\n  }\n\n  function totalSupply()\n    public\n    view\n    virtual\n    override(IERC20, ERC20Cloned)\n    returns (uint256)\n  {\n    return\n      _loadERC20Slot()._totalSupply +\n      _loadStorageSlot().strategistUnclaimedShares;\n  }\n\n  function claim() external {\n    require(msg.sender == owner()); //owner is \"strategist\"\n    VaultData storage s = _loadStorageSlot();\n    uint256 unclaimed = s.strategistUnclaimedShares;\n    s.strategistUnclaimedShares = 0;\n    _mint(msg.sender, unclaimed);\n  }\n\n  function beforePayment(BeforePaymentParams calldata params)\n    external\n    onlyLienToken\n  {\n    VaultData storage s = _loadStorageSlot();\n    _accrue(s);\n\n    unchecked {\n      uint48 newSlope = s.slope - params.lienSlope.safeCastTo48();\n      _setSlope(s, newSlope);\n    }\n    _handleStrategistInterestReward(s, params.interestOwed, params.amount);\n  }\n\n  function _setSlope(VaultData storage s, uint48 newSlope) internal {\n    s.slope = newSlope;\n    emit SlopeUpdated(newSlope);\n  }\n\n  function decreaseEpochLienCount(uint64 epoch) public onlyLienToken {\n    _decreaseEpochLienCount(_loadStorageSlot(), epoch);\n  }\n\n  function _decreaseEpochLienCount(VaultData storage s, uint64 epoch) internal {\n    s.epochData[epoch].liensOpenForEpoch--;\n    emit LiensOpenForEpochRemaining(\n      epoch,\n      s.epochData[epoch].liensOpenForEpoch\n    );\n  }\n\n  function getLienEpoch(uint64 end) public pure returns (uint64) {\n    return\n      uint256(Math.ceilDiv(end - uint64(START()), EPOCH_LENGTH()) - 1)\n        .safeCastTo64();\n  }\n\n  function getEpochEnd(uint256 epoch) public pure returns (uint64) {\n    return uint256(START() + (epoch + 1) * EPOCH_LENGTH()).safeCastTo64();\n  }\n\n  function _increaseOpenLiens(VaultData storage s, uint64 epoch) internal {\n    unchecked {\n      s.epochData[epoch].liensOpenForEpoch++;\n    }\n  }\n\n  function afterPayment(uint256 computedSlope) public onlyLienToken {\n    VaultData storage s = _loadStorageSlot();\n    unchecked {\n      s.slope += computedSlope.safeCastTo48();\n    }\n    emit SlopeUpdated(s.slope);\n  }\n\n  /**\n   * @notice After-deposit hook to update the yIntercept of the PublicVault to reflect a capital contribution.\n   * @param assets The amount of assets deposited to the PublicVault.\n   * @param shares The resulting amount of VaultToken shares that were issued.\n   */\n  function afterDeposit(uint256 assets, uint256 shares)\n    internal\n    virtual\n    override\n  {\n    VaultData storage s = _loadStorageSlot();\n\n    unchecked {\n      s.yIntercept += assets.safeCastTo88();\n    }\n    VIData storage v = _loadVISlot();\n    if (v.depositCap != 0 && totalAssets() >= v.depositCap) {\n      revert InvalidState(InvalidStates.DEPOSIT_CAP_EXCEEDED);\n    }\n    emit YInterceptChanged(s.yIntercept);\n  }\n\n  /**\n   * @dev Handles the dilutive fees (on lien repayments) for strategists in VaultTokens.\n   * @param interestOwing the owingInterest for the lien\n   * @param amount The amount that was paid.\n   */\n  function _handleStrategistInterestReward(\n    VaultData storage s,\n    uint256 interestOwing,\n    uint256 amount\n  ) internal virtual {\n    if (VAULT_FEE() != uint256(0)) {\n      uint256 x = (amount > interestOwing) ? interestOwing : amount;\n      uint256 fee = x.mulDivDown(VAULT_FEE(), 10000);\n      uint88 feeInShares = convertToShares(fee).safeCastTo88();\n      s.strategistUnclaimedShares += feeInShares;\n      emit StrategistFee(feeInShares);\n    }\n  }\n\n  function LIEN_TOKEN() public view returns (ILienToken) {\n    return ROUTER().LIEN_TOKEN();\n  }\n\n  function handleBuyoutLien(BuyoutLienParams calldata params)\n    public\n    onlyLienToken\n  {\n    VaultData storage s = _loadStorageSlot();\n\n    unchecked {\n      uint48 newSlope = s.slope - params.lienSlope.safeCastTo48();\n      _setSlope(s, newSlope);\n      s.yIntercept += params.increaseYIntercept.safeCastTo88();\n      s.last = block.timestamp.safeCastTo40();\n    }\n\n    _decreaseEpochLienCount(s, getLienEpoch(params.lienEnd.safeCastTo64()));\n    emit YInterceptChanged(s.yIntercept);\n  }\n\n  function updateAfterLiquidationPayment(\n    LiquidationPaymentParams calldata params\n  ) external onlyLienToken {\n    VaultData storage s = _loadStorageSlot();\n    if (params.remaining > 0)\n      _setYIntercept(s, s.yIntercept - params.remaining);\n  }\n\n  function updateVaultAfterLiquidation(\n    uint256 maxAuctionWindow,\n    AfterLiquidationParams calldata params\n  ) public onlyLienToken returns (address withdrawProxyIfNearBoundary) {\n    VaultData storage s = _loadStorageSlot();\n\n    _accrue(s);\n    unchecked {\n      _setSlope(s, s.slope - params.lienSlope.safeCastTo48());\n    }\n\n    if (s.currentEpoch != 0) {\n      transferWithdrawReserve();\n    }\n    uint64 lienEpoch = getLienEpoch(params.lienEnd);\n    _decreaseEpochLienCount(s, lienEpoch);\n\n    uint256 timeToEnd = timeToEpochEnd(lienEpoch);\n    if (timeToEnd < maxAuctionWindow) {\n      _deployWithdrawProxyIfNotDeployed(s, lienEpoch);\n      withdrawProxyIfNearBoundary = s.epochData[lienEpoch].withdrawProxy;\n\n      WithdrawProxy(withdrawProxyIfNearBoundary).handleNewLiquidation(\n        params.newAmount,\n        maxAuctionWindow\n      );\n    }\n  }\n\n  function increaseYIntercept(uint256 amount) public {\n    VaultData storage s = _loadStorageSlot();\n    uint64 currentEpoch = s.currentEpoch;\n    require(\n      currentEpoch != 0 &&\n        msg.sender == s.epochData[currentEpoch - 1].withdrawProxy\n    );\n    _setYIntercept(s, s.yIntercept + amount);\n  }\n\n  modifier onlyLienToken() {\n    require(msg.sender == address(LIEN_TOKEN()));\n    _;\n  }\n\n  function decreaseYIntercept(uint256 amount) public {\n    VaultData storage s = _loadStorageSlot();\n    uint64 currentEpoch = s.currentEpoch;\n    require(\n      currentEpoch != 0 &&\n        msg.sender == s.epochData[currentEpoch - 1].withdrawProxy\n    );\n    _setYIntercept(s, s.yIntercept - amount);\n  }\n\n  function _setYIntercept(VaultData storage s, uint256 newYIntercept) internal {\n    s.yIntercept = newYIntercept.safeCastTo88();\n    emit YInterceptChanged(s.yIntercept);\n  }\n\n  function timeToEpochEnd() public view returns (uint256) {\n    return timeToEpochEnd(_loadStorageSlot().currentEpoch);\n  }\n\n  function timeToEpochEnd(uint256 epoch) public view returns (uint256) {\n    uint256 epochEnd = START() + ((epoch + 1) * EPOCH_LENGTH());\n\n    if (block.timestamp >= epochEnd) {\n      return uint256(0);\n    }\n\n    return epochEnd - block.timestamp;\n  }\n\n  function _timeToSecondEndIfPublic()\n    internal\n    view\n    override\n    returns (uint256 timeToSecondEpochEnd)\n  {\n    return timeToEpochEnd() + EPOCH_LENGTH();\n  }\n\n  function timeToSecondEpochEnd() public view returns (uint256) {\n    return _timeToSecondEndIfPublic();\n  }\n}"
    },
    {
      "filename": "src/LienToken.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**                                                     \n*  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗ \n* ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n* ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n* ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n* ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n* ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n*\n* Astaria Labs, Inc\n*/\n\npragma solidity =0.8.17;\n\npragma experimental ABIEncoderV2;\n\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\nimport {ERC721} from \"gpl/ERC721.sol\";\nimport {IERC721} from \"core/interfaces/IERC721.sol\";\nimport {IERC165} from \"core/interfaces/IERC165.sol\";\nimport {ITransferProxy} from \"core/interfaces/ITransferProxy.sol\";\nimport {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\n\nimport {CollateralLookup} from \"core/libraries/CollateralLookup.sol\";\n\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {ICollateralToken} from \"core/interfaces/ICollateralToken.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\n\nimport {IPublicVault} from \"core/interfaces/IPublicVault.sol\";\nimport {VaultImplementation} from \"./VaultImplementation.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {AuthInitializable} from \"core/AuthInitializable.sol\";\nimport {Initializable} from \"./utils/Initializable.sol\";\n\n/**\n * @title LienToken\n * @notice This contract handles the creation, payments, buyouts, and liquidations of tokenized NFT-collateralized debt (liens). Vaults which originate loans against supported collateral are issued a LienToken representing the right to loan repayments and auctioned funds on liquidation.\n */\ncontract LienToken is ERC721, ILienToken, AuthInitializable {\n  using FixedPointMathLib for uint256;\n  using CollateralLookup for address;\n  using SafeCastLib for uint256;\n  using SafeTransferLib for ERC20;\n\n  uint256 private constant LIEN_SLOT =\n    uint256(keccak256(\"xyz.astaria.LienToken.storage.location\")) - 1;\n\n  bytes32 constant ACTIVE_AUCTION = bytes32(\"ACTIVE_AUCTION\");\n\n  constructor() {\n    _disableInitializers();\n  }\n\n  function initialize(Authority _AUTHORITY, ITransferProxy _TRANSFER_PROXY)\n    public\n    initializer\n  {\n    __initAuth(msg.sender, address(_AUTHORITY));\n    __initERC721(\"Astaria Lien Token\", \"ALT\");\n    LienStorage storage s = _loadLienStorageSlot();\n    s.TRANSFER_PROXY = _TRANSFER_PROXY;\n    s.maxLiens = uint8(5);\n  }\n\n  function _loadLienStorageSlot()\n    internal\n    pure\n    returns (LienStorage storage s)\n  {\n    uint256 slot = LIEN_SLOT;\n\n    assembly {\n      s.slot := slot\n    }\n  }\n\n  function file(File calldata incoming) external requiresAuth {\n    FileType what = incoming.what;\n    bytes memory data = incoming.data;\n    LienStorage storage s = _loadLienStorageSlot();\n    if (what == FileType.CollateralToken) {\n      s.COLLATERAL_TOKEN = ICollateralToken(abi.decode(data, (address)));\n    } else if (what == FileType.AstariaRouter) {\n      s.ASTARIA_ROUTER = IAstariaRouter(abi.decode(data, (address)));\n    } else {\n      revert UnsupportedFile();\n    }\n    emit FileUpdated(what, data);\n  }\n\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC721, IERC165)\n    returns (bool)\n  {\n    return\n      interfaceId == type(ILienToken).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  function buyoutLien(ILienToken.LienActionBuyout calldata params)\n    external\n    validateStack(params.encumber.lien.collateralId, params.encumber.stack)\n    returns (Stack[] memory, Stack memory newStack)\n  {\n    if (block.timestamp >= params.encumber.stack[params.position].point.end) {\n      revert InvalidState(InvalidStates.EXPIRED_LIEN);\n    }\n    LienStorage storage s = _loadLienStorageSlot();\n    if (!s.ASTARIA_ROUTER.isValidVault(msg.sender)) {\n      revert InvalidSender();\n    }\n    return _buyoutLien(s, params);\n  }\n\n  function _buyoutLien(\n    LienStorage storage s,\n    ILienToken.LienActionBuyout calldata params\n  ) internal returns (Stack[] memory newStack, Stack memory newLien) {\n    //the borrower shouldn't incur more debt from the buyout than they already owe\n    (, newLien) = _createLien(s, params.encumber);\n    if (\n      !s.ASTARIA_ROUTER.isValidRefinance({\n        newLien: params.encumber.lien,\n        position: params.position,\n        stack: params.encumber.stack\n      })\n    ) {\n      revert InvalidRefinance();\n    }\n\n    if (\n      s.collateralStateHash[params.encumber.lien.collateralId] == ACTIVE_AUCTION\n    ) {\n      revert InvalidState(InvalidStates.COLLATERAL_AUCTION);\n    }\n    (uint256 owed, uint256 buyout) = _getBuyout(\n      s,\n      params.encumber.stack[params.position]\n    );\n\n    if (params.encumber.lien.details.maxAmount < owed) {\n      revert InvalidBuyoutDetails(params.encumber.lien.details.maxAmount, owed);\n    }\n\n    uint256 potentialDebt = 0;\n    for (uint256 i = params.encumber.stack.length; i > 0; ) {\n      uint256 j = i - 1;\n      // should not be able to purchase lien if any lien in the stack is expired (and will be liquidated)\n      if (block.timestamp >= params.encumber.stack[j].point.end) {\n        revert InvalidState(InvalidStates.EXPIRED_LIEN);\n      }\n\n      potentialDebt += _getOwed(\n        params.encumber.stack[j],\n        params.encumber.stack[j].point.end\n      );\n\n      if (\n        potentialDebt >\n        params.encumber.stack[j].lien.details.liquidationInitialAsk\n      ) {\n        revert InvalidState(InvalidStates.INITIAL_ASK_EXCEEDED);\n      }\n\n      unchecked {\n        --i;\n      }\n    }\n\n    address payee = _getPayee(\n      s,\n      params.encumber.stack[params.position].point.lienId\n    );\n    s.TRANSFER_PROXY.tokenTransferFrom(\n      params.encumber.stack[params.position].lien.token,\n      msg.sender,\n      payee,\n      buyout\n    );\n\n    if (_isPublicVault(s, payee)) {\n      IPublicVault(payee).handleBuyoutLien(\n        IPublicVault.BuyoutLienParams({\n          lienSlope: calculateSlope(params.encumber.stack[params.position]),\n          lienEnd: params.encumber.stack[params.position].point.end,\n          increaseYIntercept: buyout -\n            params.encumber.stack[params.position].point.amount\n        })\n      );\n    }\n\n    newStack = _replaceStackAtPositionWithNewLien(\n      s,\n      params.encumber.stack,\n      params.position,\n      newLien,\n      params.encumber.stack[params.position].point.lienId\n    );\n    uint256 maxPotentialDebt;\n    uint256 n = newStack.length;\n    uint256 i;\n    for (i; i < n; ) {\n      maxPotentialDebt += _getOwed(newStack[i], newStack[i].point.end);\n      //no need to check validity before the position we're buying\n      if (i == params.position) {\n        if (maxPotentialDebt > params.encumber.lien.details.maxPotentialDebt) {\n          revert InvalidState(InvalidStates.DEBT_LIMIT);\n        }\n      }\n      if (\n        i > params.position &&\n        (maxPotentialDebt > newStack[i].lien.details.maxPotentialDebt)\n      ) {\n        revert InvalidState(InvalidStates.DEBT_LIMIT);\n      }\n      unchecked {\n        ++i;\n      }\n    }\n\n    s.collateralStateHash[params.encumber.lien.collateralId] = keccak256(\n      abi.encode(newStack)\n    );\n  }\n\n  function _replaceStackAtPositionWithNewLien(\n    LienStorage storage s,\n    ILienToken.Stack[] calldata stack,\n    uint256 position,\n    Stack memory newLien,\n    uint256 oldLienId\n  ) internal returns (ILienToken.Stack[] memory newStack) {\n    newStack = stack;\n    newStack[position] = newLien;\n    _burn(oldLienId);\n    delete s.lienMeta[oldLienId];\n  }\n\n  function getInterest(Stack calldata stack) public view returns (uint256) {\n    return _getInterest(stack, block.timestamp);\n  }\n\n  /**\n   * @dev Computes the interest accrued for a lien since its last payment.\n   * @param stack The Lien for the loan to calculate interest for.\n   * @param timestamp The timestamp at which to compute interest for.\n   */\n  function _getInterest(Stack memory stack, uint256 timestamp)\n    internal\n    pure\n    returns (uint256)\n  {\n    uint256 delta_t = timestamp - stack.point.last;\n\n    return (delta_t * stack.lien.details.rate).mulWadDown(stack.point.amount);\n  }\n\n  modifier validateStack(uint256 collateralId, Stack[] memory stack) {\n    LienStorage storage s = _loadLienStorageSlot();\n    bytes32 stateHash = s.collateralStateHash[collateralId];\n    if (stateHash == bytes32(0) && stack.length != 0) {\n      revert InvalidState(InvalidStates.EMPTY_STATE);\n    }\n    if (stateHash != bytes32(0) && keccak256(abi.encode(stack)) != stateHash) {\n      revert InvalidState(InvalidStates.INVALID_HASH);\n    }\n    _;\n  }\n\n  function stopLiens(\n    uint256 collateralId,\n    uint256 auctionWindow,\n    Stack[] calldata stack,\n    address liquidator\n  ) external validateStack(collateralId, stack) requiresAuth {\n    _stopLiens(\n      _loadLienStorageSlot(),\n      collateralId,\n      auctionWindow,\n      stack,\n      liquidator\n    );\n  }\n\n  function _stopLiens(\n    LienStorage storage s,\n    uint256 collateralId,\n    uint256 auctionWindow,\n    Stack[] calldata stack,\n    address liquidator\n  ) internal {\n    AuctionData memory auctionData;\n    auctionData.liquidator = liquidator;\n    auctionData.stack = new AuctionStack[](stack.length);\n    s.auctionData[collateralId].liquidator = liquidator;\n    uint256 i;\n    for (; i < stack.length; ) {\n      AuctionStack memory auctionStack;\n\n      auctionStack.lienId = stack[i].point.lienId;\n      auctionStack.end = stack[i].point.end;\n      uint88 owed = _getOwed(stack[i], block.timestamp);\n      auctionStack.amountOwed = owed;\n      s.lienMeta[auctionStack.lienId].atLiquidation = true;\n      auctionData.stack[i] = auctionStack;\n      address payee = _getPayee(s, auctionStack.lienId);\n      if (_isPublicVault(s, payee)) {\n        // update the public vault state and get the liquidation accountant back if any\n        address withdrawProxyIfNearBoundary = IPublicVault(payee)\n          .updateVaultAfterLiquidation(\n            auctionWindow,\n            IPublicVault.AfterLiquidationParams({\n              lienSlope: calculateSlope(stack[i]),\n              newAmount: owed,\n              lienEnd: stack[i].point.end\n            })\n          );\n\n        if (withdrawProxyIfNearBoundary != address(0)) {\n          _setPayee(s, auctionStack.lienId, withdrawProxyIfNearBoundary);\n        }\n      }\n      unchecked {\n        ++i;\n      }\n    }\n    s.collateralStateHash[collateralId] = ACTIVE_AUCTION;\n    auctionData.startTime = block.timestamp.safeCastTo48();\n    auctionData.endTime = (block.timestamp + auctionWindow).safeCastTo48();\n    auctionData.startAmount = stack[0]\n      .lien\n      .details\n      .liquidationInitialAsk\n      .safeCastTo88();\n    auctionData.endAmount = uint88(1000 wei);\n    s.COLLATERAL_TOKEN.getClearingHouse(collateralId).setAuctionData(\n      auctionData\n    );\n  }\n\n  function tokenURI(uint256 tokenId)\n    public\n    view\n    override(ERC721, IERC721)\n    returns (string memory)\n  {\n    if (!_exists(tokenId)) {\n      revert InvalidTokenId(tokenId);\n    }\n    return \"\";\n  }\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 id\n  ) public override(ERC721, IERC721) {\n    LienStorage storage s = _loadLienStorageSlot();\n    if (_isPublicVault(s, to)) {\n      revert InvalidState(InvalidStates.PUBLIC_VAULT_RECIPIENT);\n    }\n    if (s.lienMeta[id].atLiquidation) {\n      revert InvalidState(InvalidStates.COLLATERAL_AUCTION);\n    }\n    delete s.lienMeta[id].payee;\n    emit PayeeChanged(id, address(0));\n    super.transferFrom(from, to, id);\n  }\n\n  function ASTARIA_ROUTER() public view returns (IAstariaRouter) {\n    return _loadLienStorageSlot().ASTARIA_ROUTER;\n  }\n\n  function COLL"
    }
  ]
}