{
  "Title": "Incorrect require in setter",
  "Content": "# Incorrect require in setter\n\n### Severity\nLow Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/OwnerFacet.sol#L339\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/OwnerFacet.sol#L339</a>\n\n\n## Summary\nThere are 3 setters in `OwnerFacet.sol` which require statement doesn't match with the error message.\n## Vulnerability Details\n`_setInitialMargin`, `_setPrimaryLiquidationCR` and `_setSecondaryLiquidationCR` will revert for the value 100, which will revert with an incorrect error message, which is `\"below 1.0\"`. When 100 is 1.0, not below.   \n*Instances (3)`\n``` solidity\n    function _setInitialMargin(address asset, uint16 value) private {\n        require(value > 100, \"below 1.0\"); // @audit a value of 100 is 1x, so this should be > 101\n        s.asset[asset].initialMargin = value;\n        require(LibAsset.initialMargin(asset) < Constants.CRATIO_MAX, \"above max CR\");\n    }\n\n    function _setPrimaryLiquidationCR(address asset, uint16 value) private {\n        require(value > 100, \"below 1.0\"); // @audit a value of 100 is 1x, so this should be > 101\n        require(value <= 500, \"above 5.0\");\n        require(value < s.asset[asset].initialMargin, \"above initial margin\");\n        s.asset[asset].primaryLiquidationCR = value;\n    }\n\n    function _setSecondaryLiquidationCR(address asset, uint16 value) private {\n        require(value > 100, \"below 1.0\"); // @audit a value of 100 is 1x, so this should be > 101\n        require(value <= 500, \"above 5.0\");\n        require(value < s.asset[asset].primaryLiquidationCR, \"above primary liquidation\");\n        s.asset[asset].secondaryLiquidationCR = value;\n    }\n```\n\nAs it is contrastable, in the below functions, this check is done correctly:\n``` solidity\n    function _setForcedBidPriceBuffer(address asset, uint8 value) private {\n        require(value >= 100, \"below 1.0\");\n        require(value <= 200, \"above 2.0\");\n        s.asset[asset].forcedBidPriceBuffer = value;\n    }\n\n    function _setMinimumCR(address asset, uint8 value) private {\n        require(value >= 100, \"below 1.0\");\n        require(value <= 200, \"above 2.0\");\n        s.asset[asset].minimumCR = value;\n        require(\n            LibAsset.minimumCR(asset) < LibAsset.secondaryLiquidationCR(asset),\n            \"above secondary liquidation\"\n        );\n    }\n```\n## Impact\nThe incorrect value for the require statement could lead to a restriction of precion for this parameters, it wouldn't be possible to input a net value of 100.\n## Tools Used\nManual review.\n## Recommendations\nValue to which is checked the `>` operator should be 101, not 100.",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clm871gl00001mp081mzjdlwc",
  "Code": [
    {
      "filename": "contracts/facets/OwnerFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {STypes, MTypes, SR} from \"contracts/libraries/DataTypes.sol\";\nimport {LibDiamond} from \"contracts/libraries/LibDiamond.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract OwnerFacet is Modifiers {\n    using U256 for uint256;\n\n    /**\n     * @notice Initialize data for newly deployed market\n     * @dev Single use only\n     *\n     * @param asset The market that will be impacted\n     * @param a The market settings\n     */\n\n    /*\n     * @param oracle The oracle for the asset\n     * @param initialMargin Initial margin value of the new market\n     * @param primaryLiquidationCR Liquidation ratio (Maintenance margin) value of the new market\n     * @param secondaryLiquidationCR CRatio threshold for secondary liquidations\n     * @param forcedBidPriceBuffer Liquidation limit value of the new market\n     * @param minimumCR Lowest threshold for shortRecord to not lose collateral during liquidation\n     * @param resetLiquidationTime Time limit for when flagged shorts get reset\n     * @param secondLiquidationTime Time limit for when flagged shorts can be liquidated by others, not just flagger\n     * @param firstLiquidationTime Time limit for when flagged shorts get be liquidated by flagger\n     * @param tappFeePct Primary liquidation fee sent to TAPP out of shorter collateral\n     * @param callerFeePct Primary liquidation fee sent to margin caller out of shorter collateral\n     * @param minBidEth Minimum bid dust amount\n     * @param minAskEth Minimum ask dust amount\n     * @param minShortErc Minimum short record debt amount\n    */\n\n    function createMarket(address asset, STypes.Asset memory a) external onlyDAO {\n        STypes.Asset storage Asset = s.asset[asset];\n        // can check non-zero ORDER_ID to prevent creating same asset\n        if (Asset.orderId != 0) revert Errors.MarketAlreadyCreated();\n\n        Asset.vault = a.vault;\n        _setAssetOracle(asset, a.oracle);\n\n        Asset.assetId = uint8(s.assets.length);\n        s.assetMapping[s.assets.length] = asset;\n        s.assets.push(asset);\n\n        STypes.Order memory guardOrder;\n        guardOrder.prevId = Constants.HEAD;\n        guardOrder.id = Constants.HEAD;\n        guardOrder.nextId = Constants.TAIL;\n        //@dev parts of OB depend on having sell's HEAD's price and creationTime = 0\n        s.asks[asset][Constants.HEAD] = s.shorts[asset][Constants.HEAD] = guardOrder;\n\n        //@dev Using Bid's HEAD's order contain oracle data\n        guardOrder.creationTime = LibOrders.getOffsetTime();\n        guardOrder.ercAmount = uint80(LibOracle.getOraclePrice(asset));\n        s.bids[asset][Constants.HEAD] = guardOrder;\n\n        //@dev hardcoded value\n        Asset.orderId = Constants.STARTING_ID; // 100\n        Asset.startingShortId = Constants.HEAD;\n\n        //@dev comment with initial values\n        _setInitialMargin(asset, a.initialMargin); // 500 -> 5 ether\n        _setPrimaryLiquidationCR(asset, a.primaryLiquidationCR); // 400 -> 4 ether\n        _setSecondaryLiquidationCR(asset, a.secondaryLiquidationCR); // 150 -> 1.5 ether\n        _setForcedBidPriceBuffer(asset, a.forcedBidPriceBuffer); // 110 -> 1.1 ether\n        _setMinimumCR(asset, a.minimumCR); // 110 -> 1.1 ether\n        _setResetLiquidationTime(asset, a.resetLiquidationTime); // 1600 -> 16 hours\n        _setSecondLiquidationTime(asset, a.secondLiquidationTime); // 1200 -> 12 hours\n        _setFirstLiquidationTime(asset, a.firstLiquidationTime); // 1000 -> 10 hours\n        _setTappFeePct(asset, a.tappFeePct); //25 -> .025 ether\n        _setCallerFeePct(asset, a.callerFeePct); //5 -> .005 ether\n        _setMinBidEth(asset, a.minBidEth); //1 -> 0.001 ether\n        _setMinAskEth(asset, a.minAskEth); //1 -> 0.001 ether\n        _setMinShortErc(asset, a.minShortErc); //2000 -> 2000 ether\n\n        // Create TAPP short\n        LibShortRecord.createShortRecord(\n            asset, address(this), SR.FullyFilled, 0, 0, 0, 0, 0\n        );\n        emit Events.CreateMarket(asset, Asset);\n    }\n\n    //@dev does not need read only re-entrancy\n    function owner() external view returns (address) {\n        return LibDiamond.contractOwner();\n    }\n\n    function admin() external view returns (address) {\n        return s.admin;\n    }\n\n    //@dev does not need read only re-entrancy\n    function ownerCandidate() external view returns (address) {\n        return s.ownerCandidate;\n    }\n\n    function transferOwnership(address newOwner) external onlyDAO {\n        s.ownerCandidate = newOwner;\n        emit Events.NewOwnerCandidate(newOwner);\n    }\n\n    //@dev event emitted in setContractOwner\n    function claimOwnership() external {\n        if (s.ownerCandidate != msg.sender) revert Errors.NotOwnerCandidate();\n        LibDiamond.setContractOwner(msg.sender);\n        delete s.ownerCandidate;\n    }\n\n    //No need for claim step because DAO can also set admin\n    function transferAdminship(address newAdmin) external onlyAdminOrDAO {\n        s.admin = newAdmin;\n        emit Events.NewAdmin(newAdmin);\n    }\n\n    //When deactivating an asset make sure to zero out the oracle.\n    function setAssetOracle(address asset, address oracle) external onlyDAO {\n        _setAssetOracle(asset, oracle);\n        emit Events.UpdateAssetOracle(asset, oracle);\n    }\n\n    function createVault(\n        address zeth,\n        uint256 vault,\n        MTypes.CreateVaultParams calldata params\n    ) external onlyDAO {\n        if (s.zethVault[zeth] != 0) revert Errors.VaultAlreadyCreated();\n        s.zethVault[zeth] = vault;\n        _setTithe(vault, params.zethTithePercent);\n        _setDittoMatchedRate(vault, params.dittoMatchedRate);\n        _setDittoShorterRate(vault, params.dittoShorterRate);\n        emit Events.CreateVault(zeth, vault);\n    }\n\n    // Update eligibility requirements for yield accrual\n    function setTithe(uint256 vault, uint16 zethTithePercent) external onlyAdminOrDAO {\n        _setTithe(vault, zethTithePercent);\n        emit Events.ChangeVaultSetting(vault);\n    }\n\n    function setDittoMatchedRate(uint256 vault, uint16 rewardRate)\n        external\n        onlyAdminOrDAO\n    {\n        _setDittoMatchedRate(vault, rewardRate);\n        emit Events.ChangeVaultSetting(vault);\n    }\n\n    function setDittoShorterRate(uint256 vault, uint16 rewardRate)\n        external\n        onlyAdminOrDAO\n    {\n        _setDittoShorterRate(vault, rewardRate);\n        emit Events.ChangeVaultSetting(vault);\n    }\n\n    // For Short Record collateral ratios\n    // initialMargin > primaryLiquidationCR > secondaryLiquidationCR > minimumCR\n    // After initial market creation. Set CRs from smallest to largest to prevent triggering the require checks\n\n    function setInitialMargin(address asset, uint16 value) external onlyAdminOrDAO {\n        require(value > s.asset[asset].primaryLiquidationCR, \"below primary liquidation\");\n        _setInitialMargin(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setPrimaryLiquidationCR(address asset, uint16 value)\n        external\n        onlyAdminOrDAO\n    {\n        require(\n            value > s.asset[asset].secondaryLiquidationCR, \"below secondary liquidation\"\n        );\n        _setPrimaryLiquidationCR(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setSecondaryLiquidationCR(address asset, uint16 value)\n        external\n        onlyAdminOrDAO\n    {\n        _setSecondaryLiquidationCR(asset, value);\n        require(\n            LibAsset.secondaryLiquidationCR(asset) > LibAsset.minimumCR(asset),\n            \"below minimum CR\"\n        );\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setForcedBidPriceBuffer(address asset, uint8 value)\n        external\n        onlyAdminOrDAO\n    {\n        _setForcedBidPriceBuffer(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setMinimumCR(address asset, uint8 value) external onlyAdminOrDAO {\n        _setMinimumCR(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    // Used for Primary Margin Call\n    // resetLiquidationTime > secondLiquidationTime > firstLiquidationTime\n\n    function setResetLiquidationTime(address asset, uint16 value)\n        external\n        onlyAdminOrDAO\n    {\n        _setResetLiquidationTime(asset, value);\n        require(\n            value >= s.asset[asset].secondLiquidationTime, \"below secondLiquidationTime\"\n        );\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setSecondLiquidationTime(address asset, uint16 value)\n        external\n        onlyAdminOrDAO\n    {\n        _setSecondLiquidationTime(asset, value);\n        require(\n            value >= s.asset[asset].firstLiquidationTime, \"below firstLiquidationTime\"\n        );\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setFirstLiquidationTime(address asset, uint16 value)\n        external\n        onlyAdminOrDAO\n    {\n        _setFirstLiquidationTime(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setTappFeePct(address asset, uint8 value) external onlyAdminOrDAO {\n        _setTappFeePct(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setCallerFeePct(address asset, uint8 value) external onlyAdminOrDAO {\n        _setCallerFeePct(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setMinBidEth(address asset, uint8 value) external onlyAdminOrDAO {\n        _setMinBidEth(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setMinAskEth(address asset, uint8 value) external onlyAdminOrDAO {\n        _setMinAskEth(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setMinShortErc(address asset, uint16 value) external onlyAdminOrDAO {\n        _setMinShortErc(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function createBridge(\n        address bridge,\n        uint256 vault,\n        uint16 withdrawalFee,\n        uint8 unstakeFee\n    ) external onlyDAO {\n        s.vaultBridges[vault].push(bridge);\n        s.bridge[bridge].vault = uint8(vault);\n        _setWithdrawalFee(bridge, withdrawalFee);\n        _setUnstakeFee(bridge, unstakeFee);\n        emit Events.CreateBridge(bridge, s.bridge[bridge]);\n    }\n\n    function deleteBridge(address bridge) external onlyDAO {\n        uint256 vault = s.bridge[bridge].vault;\n        if (vault == 0) revert Errors.InvalidBridge();\n\n        address[] storage VaultBridges = s.vaultBridges[vault];\n        uint256 length = VaultBridges.length;\n        for (uint256 i; i < length; i++) {\n            if (VaultBridges[i] == bridge) {\n                if (i != length - 1) {\n                    VaultBridges[i] = VaultBridges[length - 1];\n                }\n                VaultBridges.pop();\n                break;\n            }\n        }\n        delete s.bridge[bridge];\n        emit Events.DeleteBridge(bridge);\n    }\n\n    function setWithdrawalFee(address bridge, uint16 withdrawalFee)\n        external\n        onlyAdminOrDAO\n    {\n        _setWithdrawalFee(bridge, withdrawalFee);\n        emit Events.ChangeBridgeSetting(bridge);\n    }\n\n    function setUnstakeFee(address bridge, uint8 unstakeFee) external onlyAdminOrDAO {\n        _setUnstakeFee(bridge, unstakeFee);\n        emit Events.ChangeBridgeSetting(bridge);\n    }\n\n    function _setAssetOracle(address asset, address oracle) private {\n        if (asset == address(0) || oracle == address(0)) revert Errors.ParameterIsZero();\n        s.asset[asset].oracle = oracle;\n    }\n\n    function _setTithe(uint256 vault, uint16 zethTithePercent) private {\n        if (zethTithePercent > 33_33) revert Errors.InvalidTithe();\n        s.vault[vault].zethTithePercent = zethTithePercent;\n    }\n\n    function _setDittoMatchedRate(uint256 vault, uint16 rewardRate) private {\n        require(rewardRate <= 100, \"above 100\");\n        s.vault[vault].dittoMatchedRate = rewardRate;\n    }\n\n    function _setDittoShorterRate(uint256 vault, uint16 rewardRate) private {\n        require(rewardRate <= 100, \"above 100\");\n        s.vault[vault].dittoShorterRate = rewardRate;\n    }\n\n    function _setInitialMargin(address asset, uint16 value) private {\n        require(value > 100, \"below 1.0\");\n        s.asset[asset].initialMargin = value;\n        require(LibAsset.initialMargin(asset) < Constants.CRATIO_MAX, \"above max CR\");\n    }\n\n    function _setPrimaryLiquidationCR(address asset, uint16 value) private {\n        require(value > 100, \"below 1.0\");\n        require(value <= 500, \"above 5.0\");\n        require(value < s.asset[asset].initialMargin, \"above initial margin\");\n        s.asset[asset].primaryLiquidationCR = value;\n    }\n\n    function _setSecondaryLiquidationCR(address asset, uint16 value) private {\n        require(value > 100, \"below 1.0\");\n        require(value <= 500, \"above 5.0\");\n        require(value < s.asset[asset].primaryLiquidationCR, \"above primary liquidation\");\n        s.asset[asset].secondaryLiquidationCR = value;\n    }\n\n    function _setForcedBidPriceBuffer(address asset, uint8 value) private {\n        require(value >= 100, \"below 1.0\");\n        require(value <= 200, \"above 2.0\");\n        s.asset[asset].forcedBidPriceBuffer = value;\n    }\n\n    function _setMinimumCR(address asset, uint8 value) private {\n        require(value >= 100, \"below 1.0\");\n        require(value <= 200, \"above 2.0\");\n        s.asset[asset].minimumCR = value;\n        require(\n            LibAsset.minimumCR(asset) < LibAsset.secondaryLiquidationCR(asset),\n            \"above secondary liquidation\"\n        );\n    }\n\n    // Used for Primary Margin Call\n    // resetLiquidationTime > secondLiquidationTime > firstLiquidationTime\n\n    function _setResetLiquidationTime(address asset, uint16 value) private {\n        require(value >= 100, \"below 1.00\");\n        require(value <= 4800, \"above 48.00\");\n        s.asset[asset].resetLiquidationTime = value;\n    }\n\n    function _setSecondLiquidationTime(address asset, uint16 value) private {\n        require(value >= 100, \"below 1.00\");\n        require(\n            value <= s.asset[asset].resetLiquidationTime, \"above resetLiquidationTime\"\n        );\n        s.asset[asset].secondLiquidationTime = value;\n    }\n\n    function _setFirstLiquidationTime(address asset, uint16 value) private {\n        require(value >= 100, \"below 1.00\");\n        require(\n            value <= s.asset[asset].secondLiquidationTime, \"above secondLiquidationTime\"\n        );\n        s.asset[asset].firstLiquidationTime = value;\n    }\n\n    function _setTappFeePct(address asset, uint8 value) private {\n        require(value > 0, \"Can't be zero\");\n        require(value <= 250, \"above 25.0\");\n        s.asset[asset].tappFeePct = value;\n    }\n\n    function _setCallerFeePct(address asset, uint8 value) private {\n        require(value > 0, \"Can't be zero\");\n        require(value <= 250, \"above 25.0\");\n        s.asset[asset].callerFeePct = value;\n    }\n\n    function _setMinBidEth(address asset, uint8 value) private {\n        //no upperboard check because uint8 max - 255\n        require(value > 0, \"Can't be zero\");\n        s.asset[asset].minBidEth = value;\n    }\n\n    function _setMinAskEth(address asset, uint8 value) private {\n        //no upperboard check because uint8 max - 255\n        require(value > 0, \"Can't be zero\");\n        s.asset[asset].minAskEth = value;\n    }\n\n    function _setMinShortErc(address asset, uint16 value) private {\n        //no upperboard check because uint8 max - 65,535\n        require(value > 0, \"Can't be zero\");\n        s.asset[asset].minShortErc = value;\n    }\n\n    function _setWithdrawalFee(address bridge, uint16 withdrawalFee) private {\n        require(withdrawalFee <= 1500, \"above 15.00%\");\n        s.bridge[bridge].withdrawalFee = withdrawalFee;\n    }\n\n    function _setUnstakeFee(address bridge, uint8 unstakeFee) private {\n        require(unstakeFee <= 250, \"above 2.50%\");\n        s.bridge[bridge].unstakeFee = unstakeFee;\n    }\n}"
    }
  ]
}