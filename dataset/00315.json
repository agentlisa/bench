{
  "Title": "M-8: Vault and oracle keepers DoS in some situations due to `market.update(account,max,max,max,0,false)`",
  "Content": "# Issue M-8: Vault and oracle keepers DoS in some situations due to `market.update(account,max,max,max,0,false)` \n\nSource: https://github.com/sherlock-audit/2024-02-perennial-v2-3-judging/issues/23 \n\n## Found by \npanprog\n## Summary\n\nWhen user's market account is updated without position and collateral change (by calling `market.update(account,max,max,max,0,false)`), this serves as some kind of \"settling\" the account (which was the only way to settle the account before v2.3). However, this action still reverts if the account is below margin requirement.\n\nThe issue is that some parts of the code use this action to \"settle\" the account in the assumption that it never reverts which is not true. This causes unpexpected reverts and denial of service to users who can not execute transactions in some situations, in particular:\n\n1. Oracle `KeeperFactory.settle` uses this method to settle all accounts in the market for the oracle verison and will revert entire market version's settlement if any account which is being settled is below margin requirement. Example scenario:\n1.1. User increases position to the edge of margin requirement\n1.2. The price rises slightly for the commited oracle version, and user position is settled and is now slightly below margin requirements\n1.3. All attempts to settle accounts for the commited oracle version for this market will revert as user's account collateral is below margin requirements.\n\n2. Vault `Vault._updateUnderlying` uses this method to settle all vault's accounts in the markets. This function is called at the start of `rebalance` and `update`, with `rebalance` also being called before any admin vault parameters changes such as updating market leverages, weights or cap. This becomes especially problematic if any market is \"removed\" from the vault by setting its weight to 0, but the market still has some position due to `minPosition` limitation (as described in another issue). In such case each vault update will bring this market's position to exact edge of margin requirement, meaning a lot of times minimal price changes will put the vault's market account below margin requirement, and as such most Vault functions will revert (`update`, `rebalance` and admin param changes). Moreover, since the vault rebalances collateral and/or position size only in `_manage` (which is called only from `update` and `rebalance`), this means that the vault is basically bricked until this position is either liquidated or goes above margin requirement again due to price changes.\n\n## Vulnerability Detail\n\nWhen `Market.update` is called, any parameters except `protected = true` will perform the following check from the `InvariantLib.validate`:\n```solidity\nif (\n    !PositionLib.margined(\n        context.latestPosition.local.magnitude().add(context.pending.local.pos()),\n        context.latestOracleVersion,\n        context.riskParameter,\n        context.local.collateral\n    )\n) revert IMarket.MarketInsufficientMarginError();\n```\n\nThis means that even updates which do not change anything (empty order and 0 collateral change) still perform this check and revert if the user's collateral is below margin requirement.\n\nSuch method to settle accounts is used in `KeeperOracle._settle`:\n```solidity\nfunction _settle(IMarket market, address account) private {\n    market.update(account, UFixed6Lib.MAX, UFixed6Lib.MAX, UFixed6Lib.MAX, Fixed6Lib.ZERO, false);\n}\n```\n\nThis is called from `KeeperFactory.settle`, which the keepers are supposed to call to settle market accounts after the oracle version is commited. This will revert, thus keepers will temporarily be unable to call this function for the specific oracle version until all users are at or above margin.\n\nThe same method is used to settle accounts in `Vault._updateUnderlying`:\n```solidity\nfunction _updateUnderlying() private {\n    for (uint256 marketId; marketId < totalMarkets; marketId++)\n        _registrations[marketId].read().market.update(\n            address(this),\n            UFixed6Lib.MAX,\n            UFixed6Lib.ZERO,\n            UFixed6Lib.ZERO,\n            Fixed6Lib.ZERO,\n            false\n        );\n}\n```\n\n## Impact\n\n1. Keepers are unable to settle market accounts for the commited oracle version until all accounts are above margin. The oracle fees are still taken from all accounts, but the keepers are blocked from receiving it.\n2. If any Vault's market weight is set to 0 (or if vault's position in any market goes below margin for whatever other reason), most of the time the vault will temporarily be bricked until vault's position in that market is liquidated. The only function working in this state is `Vault.settle`, even all admin functions will revert.\n\n## Code Snippet\n\n`InvariantLib.validate` reverts for all updates (except liquidations) where account is below margin requirements:\nhttps://github.com/sherlock-audit/2024-02-perennial-v2-3/blob/main/perennial-v2/packages/perennial/contracts/libs/InvariantLib.sol#L78-L85\n\n`KeeperOracle._settle` uses `Market.update` to settle accounts:\nhttps://github.com/sherlock-audit/2024-02-perennial-v2-3/blob/main/perennial-v2/packages/perennial-oracle/contracts/keeper/KeeperOracle.sol#L178-L180\n\n`Vault._updateUnderlying` also uses the same method to settle accounts:\nhttps://github.com/sherlock-audit/2024-02-perennial-v2-3/blob/main/perennial-v2/packages/perennial-vault/contracts/Vault.sol#L342-L352\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nDepending on intended functionality:\n1. Ignore the margin requirement for empty orders and collateral change which is >= 0.\n**AND/OR**\n2. Use `Market.settle` instead of `Market.update` to settle accounts, specifically in `KeeperOracle._settle` and in `Vault._updateUnderlying`. There doesn't seem to be any reason or issue to use `settle` instead of `update`, it seems that `update` is there just because there was no `settle` function available before.\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/equilibria-xyz/perennial-v2/pull/309\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/254",
  "Code": [
    {
      "filename": "perennial-v2/packages/perennial/contracts/libs/InvariantLib.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/accumulator/types/Accumulator6.sol\";\nimport \"../interfaces/IMarket.sol\";\nimport \"../types/OracleVersion.sol\";\nimport \"../types/RiskParameter.sol\";\nimport \"../types/Global.sol\";\nimport \"../types/Local.sol\";\nimport \"../types/Order.sol\";\nimport \"../types/Version.sol\";\nimport \"../types/Checkpoint.sol\";\n\n/// @title InvariantLib\n/// @notice Manages the logic for the system invariant\nlibrary InvariantLib {\n    /// @notice Verifies the invariant of the market\n    /// @param context The context to use\n    /// @param account The account to verify the invariant for\n    /// @param newOrder The order to verify the invariant for\n    /// @param collateral The collateral change to verify the invariant for\n    function validate(\n        IMarket.Context memory context,\n        IMarket.UpdateContext memory updateContext,\n        address sender,\n        address account,\n        Order memory newOrder,\n        Fixed6 collateral\n    ) external pure {\n        if (context.pending.local.neg().gt(context.latestPosition.local.magnitude())) revert IMarket.MarketOverCloseError();\n\n        if (newOrder.protected() && (\n            !context.pending.local.neg().eq(context.latestPosition.local.magnitude()) ||\n            context.latestPosition.local.maintained(\n                context.latestOracleVersion,\n                context.riskParameter,\n                context.local.collateral.sub(collateral)\n            ) ||\n            collateral.lt(Fixed6Lib.ZERO) ||\n            newOrder.magnitude().gte(Fixed6Lib.ZERO)\n        )) revert IMarket.MarketInvalidProtectionError();\n\n        if (\n            !(updateContext.currentPosition.local.magnitude().isZero() && context.latestPosition.local.magnitude().isZero()) &&     // sender has no position\n            !(newOrder.isEmpty() && collateral.gte(Fixed6Lib.ZERO)) &&                                                              // sender is depositing zero or more into account, without position change\n            (context.currentTimestamp - context.latestOracleVersion.timestamp >= context.riskParameter.staleAfter)                  // price is not stale\n        ) revert IMarket.MarketStalePriceError();\n\n        if (context.marketParameter.closed && newOrder.increasesPosition())\n            revert IMarket.MarketClosedError();\n\n        if (\n            updateContext.currentPosition.global.maker.gt(context.riskParameter.makerLimit) &&\n            newOrder.increasesMaker()\n        ) revert IMarket.MarketMakerOverLimitError();\n\n        if (\n            !updateContext.currentPosition.local.singleSided() || (\n                context.latestPosition.local.direction() != updateContext.currentPosition.local.direction() &&\n                    !context.latestPosition.local.empty() &&\n                    !updateContext.currentPosition.local.empty()\n            )\n        ) revert IMarket.MarketNotSingleSidedError();\n\n        if (newOrder.protected()) return; // The following invariants do not apply to protected position updates (liquidations)\n\n        if (\n            sender != account &&                                    // sender is operating on own account\n            !updateContext.operator &&                                  // sender is operator approved for account\n            !(newOrder.isEmpty() && collateral.gte(Fixed6Lib.ZERO))     // sender is depositing zero or more into account, without position change\n        ) revert IMarket.MarketOperatorNotAllowedError();\n\n        if (\n            context.global.currentId > context.global.latestId + context.marketParameter.maxPendingGlobal ||\n            context.local.currentId > context.local.latestId + context.marketParameter.maxPendingLocal\n        ) revert IMarket.MarketExceedsPendingIdLimitError();\n\n        if (\n            !PositionLib.margined(\n                context.latestPosition.local.magnitude().add(context.pending.local.pos()),\n                context.latestOracleVersion,\n                context.riskParameter,\n                context.local.collateral\n            )\n        ) revert IMarket.MarketInsufficientMarginError();\n\n        if (context.pending.local.protected() && !newOrder.protected() && !newOrder.isEmpty())\n            revert IMarket.MarketProtectedError();\n\n        if (\n            newOrder.liquidityCheckApplicable(context.marketParameter) &&\n            newOrder.decreasesEfficiency(updateContext.currentPosition.global) &&\n            updateContext.currentPosition.global.efficiency().lt(context.riskParameter.efficiencyLimit)\n        ) revert IMarket.MarketEfficiencyUnderLimitError();\n\n        if (\n            newOrder.liquidityCheckApplicable(context.marketParameter) &&\n            updateContext.currentPosition.global.socialized() &&\n            newOrder.decreasesLiquidity(updateContext.currentPosition.global)\n        ) revert IMarket.MarketInsufficientLiquidityError();\n\n        if (collateral.lt(Fixed6Lib.ZERO) && context.local.collateral.lt(Fixed6Lib.ZERO))\n            revert IMarket.MarketInsufficientCollateralError();\n    }\n}"
    },
    {
      "filename": "perennial-v2/packages/perennial-oracle/contracts/keeper/KeeperOracle.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@equilibria/root/attribute/Instance.sol\";\nimport \"../interfaces/IKeeperFactory.sol\";\n\n/// @title KeeperOracle\n/// @notice Generic implementation of the IOracle interface for keeper-based oracles.\n/// @dev One instance per price feed should be deployed. Multiple products may use the same\n///      KeeperOracle instance if their payoff functions are based on the same underlying oracle.\n///      This implementation only supports non-negative prices.\ncontract KeeperOracle is IKeeperOracle, Instance {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @dev After this amount of time has passed for a version without being committed, the version can be invalidated.\n    uint256 public immutable timeout;\n\n    /// @dev List of all requested oracle versions\n    mapping(uint256 => uint256) public versions;\n\n    /// @dev The global state of the oracle\n    Global private _global;\n\n    /// @dev Mapping from oracle version to oracle version data\n    mapping(uint256 => Fixed6) private _prices;\n\n    /// @dev Mapping from version to a set of registered markets for settlement callback\n    mapping(uint256 => EnumerableSet.AddressSet) private _globalCallbacks;\n\n    /// @dev Mapping from version and market to a set of registered accounts for settlement callback\n    mapping(uint256 => mapping(IMarket => EnumerableSet.AddressSet)) private _localCallbacks;\n\n    /// @notice Constructs the contract\n    /// @param timeout_ The timeout for a version to be committed\n    constructor(uint256 timeout_)  {\n        timeout = timeout_;\n    }\n\n    /// @notice Initializes the contract state\n    function initialize() external initializer(1) {\n        __Instance__initialize();\n    }\n\n    /// @notice Returns the global state of the oracle\n    /// @return The global state of the oracle\n    function global() external view returns (Global memory) { return _global; }\n\n    /// @notice Returns the global oracle callback set for a version\n    /// @param version The version to lookup\n    /// @return The global oracle callback set for the version\n    function globalCallbacks(uint256 version) external view returns (address[] memory) {\n        return _globalCallbacks[version].values();\n    }\n\n    /// @notice Returns the local oracle callback set for a version and market\n    /// @param version The version to lookup\n    /// @param market The market to lookup\n    /// @return The local oracle callback set for the version and market\n    function localCallbacks(uint256 version, IMarket market) external view returns (address[] memory) {\n        return _localCallbacks[version][market].values();\n    }\n\n    /// @notice Returns the next requested oracle version\n    /// @dev Returns 0 if no next version is requested\n    /// @return The next requested oracle version\n    function next() public view returns (uint256) {\n        return versions[_global.latestIndex + 1];\n    }\n\n    /// @notice Records a request for a new oracle version\n    /// @param market The market to callback to\n    /// @param account The account to callback to\n    function request(IMarket market, address account) external onlyAuthorized {\n        uint256 currentTimestamp = current();\n\n        _globalCallbacks[currentTimestamp].add(address(market));\n        _localCallbacks[currentTimestamp][market].add(account);\n        emit CallbackRequested(SettlementCallback(market, account, currentTimestamp));\n\n        if (versions[_global.currentIndex] == currentTimestamp) return;\n        versions[++_global.currentIndex] = currentTimestamp;\n        emit OracleProviderVersionRequested(currentTimestamp);\n    }\n\n    /// @notice Returns the latest synced oracle version and the current oracle version\n    /// @return The latest synced oracle version\n    /// @return The current oracle version collecting new orders\n    function status() external view returns (OracleVersion memory, uint256) {\n        return (latest(), current());\n    }\n\n    /// @notice Returns the latest synced oracle version\n    /// @return Latest oracle version\n    function latest() public view returns (OracleVersion memory) {\n        return at(_global.latestVersion);\n    }\n\n    /// @notice Returns the current oracle version accepting new orders\n    /// @return Current oracle version\n    function current() public view returns (uint256) {\n        return IKeeperFactory(address(factory())).current();\n    }\n\n    /// @notice Returns the oracle version at version `version`\n    /// @param timestamp The timestamp of which to lookup\n    /// @return oracleVersion Oracle version at version `version`\n    function at(uint256 timestamp) public view returns (OracleVersion memory oracleVersion) {\n        (oracleVersion.timestamp, oracleVersion.price) = (timestamp, _prices[timestamp]);\n        oracleVersion.valid = !oracleVersion.price.isZero();\n    }\n\n    /// @notice Commits the price to specified version\n    /// @dev Verification of price happens in the oracle's factory\n    /// @param version The oracle version to commit\n    /// @return requested Whether the commit was requested\n    function commit(OracleVersion memory version) external onlyFactory returns (bool requested) {\n        if (version.timestamp == 0) revert KeeperOracleVersionOutsideRangeError();\n        requested = (version.timestamp == next()) ? _commitRequested(version) : _commitUnrequested(version);\n        _global.latestVersion = uint64(version.timestamp);\n\n        for (uint256 i; i < _globalCallbacks[version.timestamp].length(); i++)\n            _settle(IMarket(_globalCallbacks[version.timestamp].at(i)), address(0));\n\n        emit OracleProviderVersionFulfilled(version);\n    }\n\n    /// @notice Performs an asynchronous local settlement callback\n    /// @dev Distribution of keeper incentive is consolidated in the oracle's factory\n    /// @param market The market to settle\n    /// @param version The version to settle\n    /// @param maxCount The maximum number of settlement callbacks to perform before exiting\n    function settle(IMarket market, uint256 version, uint256 maxCount) external onlyFactory {\n        EnumerableSet.AddressSet storage callbacks = _localCallbacks[version][market];\n\n        if (_global.latestVersion < version) revert KeeperOracleVersionOutsideRangeError();\n        if (maxCount == 0) revert KeeperOracleInvalidCallbackError();\n        if (callbacks.length() == 0) revert KeeperOracleInvalidCallbackError();\n\n        for (uint256 i; i < maxCount && callbacks.length() > 0; i++) {\n            address account = callbacks.at(0);\n            _settle(market, account);\n            callbacks.remove(account);\n            emit CallbackFulfilled(SettlementCallback(market, account, version));\n        }\n    }\n\n    /// @notice Commits the price to a requested version\n    /// @dev This commit function will pay out a keeper fee if the committed version is valid\n    /// @param version The oracle version to commit\n    /// @return Whether the commit was requested\n    function _commitRequested(OracleVersion memory version) private returns (bool) {\n        if (block.timestamp <= (next() + timeout)) {\n            if (!version.valid) revert KeeperOracleInvalidPriceError();\n            _prices[version.timestamp] = version.price;\n        } else {\n            _prices[version.timestamp] = _prices[_global.latestVersion];\n        }\n        _global.latestIndex++;\n        return true;\n    }\n\n    /// @notice Commits the price to a non-requested version\n    /// @param version The oracle version to commit\n    /// @return Whether the commit was requested\n    function _commitUnrequested(OracleVersion memory version) private returns (bool) {\n        if (!version.valid) revert KeeperOracleInvalidPriceError();\n        if (version.timestamp <= _global.latestVersion || (next() != 0 && version.timestamp >= next()))\n            revert KeeperOracleVersionOutsideRangeError();\n        _prices[version.timestamp] = version.price;\n        return false;\n    }\n\n    /// @notice Performs a settlement callback for the account on the market\n    /// @param market The market to settle\n    /// @param account The account to settle\n    function _settle(IMarket market, address account) private {\n        market.update(account, UFixed6Lib.MAX, UFixed6Lib.MAX, UFixed6Lib.MAX, Fixed6Lib.ZERO, false);\n    }\n\n    /// @dev Only allow authorized callers\n    modifier onlyAuthorized {\n        if (!IOracleProviderFactory(address(factory())).authorized(msg.sender)) revert OracleProviderUnauthorizedError();\n        _;\n    }\n}"
    },
    {
      "filename": "perennial-v2/packages/perennial-vault/contracts/Vault.sol",
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport \"@equilibria/root/attribute/Instance.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./interfaces/IVaultFactory.sol\";\nimport \"./types/Account.sol\";\nimport \"./types/Checkpoint.sol\";\nimport \"./types/Registration.sol\";\nimport \"./types/VaultParameter.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./lib/StrategyLib.sol\";\n\n/// @title Vault\n/// @notice Deploys underlying capital by weight in maker positions across registered markets\n/// @dev Vault deploys and rebalances collateral between the registered markets, while attempting to\n///      maintain `targetLeverage` with its open maker positions at any given time. Deposits are only gated in so much\n///      as to cap the maximum amount of assets in the vault.\n///\n///      All registered markets are expected to be on the same \"clock\", i.e. their oracle.current() is always equal.\n///\n///      The vault has a \"delayed settlement\" mechanism. After depositing to or redeeming from the vault, a user must\n///      wait until the next settlement of all underlying markets in order for vault settlement to be available.\ncontract Vault is IVault, Instance {\n    /// @dev The vault's name\n    string private _name;\n\n    /// @dev The underlying asset\n    Token18 public asset;\n\n    /// @dev The vault parameter set\n    VaultParameterStorage private _parameter;\n\n    /// @dev The total number of registered markets\n    uint256 public totalMarkets;\n\n    /// @dev Per-market registration state variables\n    mapping(uint256 => RegistrationStorage) private _registrations;\n\n    /// @dev Per-account accounting state variables\n    mapping(address => AccountStorage) private _accounts;\n\n    /// @dev Per-id accounting state variables\n    mapping(uint256 => CheckpointStorage) private _checkpoints;\n\n    /// @dev DEPRECATED SLOT -- previously the mappings\n    bytes32 private __unused0__;\n\n    /// @notice Initializes the vault\n    /// @param asset_ The underlying asset\n    /// @param initialMarket The initial market to register\n    /// @param name_ The vault's name\n    function initialize(\n        Token18 asset_,\n        IMarket initialMarket,\n        UFixed6 cap,\n        string calldata name_\n    ) external initializer(1) {\n        __Instance__initialize();\n\n        asset = asset_;\n        _name = name_;\n        _register(initialMarket);\n        _updateParameter(VaultParameter(cap));\n    }\n\n    /// @notice Returns the vault parameter set\n    /// @return The vault parameter set\n    function parameter() external view returns (VaultParameter memory) {\n        return _parameter.read();\n    }\n\n    /// @notice Returns the registration for a given market\n    /// @param marketId The market id\n    /// @return The registration for the given market\n    function registrations(uint256 marketId) external view returns (Registration memory) {\n        return _registrations[marketId].read();\n    }\n\n    /// @notice Returns the account state for a account\n    /// @param account The account to query\n    /// @return The account state for the given account\n    function accounts(address account) external view returns (Account memory) {\n        return _accounts[account].read();\n    }\n\n    /// @notice Returns the checkpoint for a given id\n    /// @param id The id to query\n    /// @return The checkpoint for the given id\n    function checkpoints(uint256 id) external view returns (Checkpoint memory) {\n        return _checkpoints[id].read();\n    }\n\n    /// @notice Returns the name of the vault\n    /// @return The name of the vault\n    function name() external view returns (string memory) {\n        return string(abi.encodePacked(\"Perennial V2 Vault: \", _name));\n    }\n\n    /// @notice Returns the total number of underlying assets at the last checkpoint\n    /// @return The total number of underlying assets at the last checkpoint\n    function totalAssets() public view returns (Fixed6) {\n        Checkpoint memory checkpoint = _checkpoints[_accounts[address(0)].read().latest].read();\n        return checkpoint.assets\n            .add(Fixed6Lib.from(checkpoint.deposit))\n            .sub(Fixed6Lib.from(checkpoint.toAssetsGlobal(checkpoint.redemption)));\n    }\n\n    /// @notice Returns the total number of shares at the last checkpoint\n    /// @return The total number of shares at the last checkpoint\n    function totalShares() public view returns (UFixed6) {\n        Checkpoint memory checkpoint = _checkpoints[_accounts[address(0)].read().latest].read();\n        return checkpoint.shares\n            .add(checkpoint.toSharesGlobal(checkpoint.deposit))\n            .sub(checkpoint.redemption);\n    }\n\n    /// @notice Converts a given amount of assets to shares\n    /// @param assets Number of assets to convert to shares\n    /// @return Amount of shares for the given assets\n    function convertToShares(UFixed6 assets) external view returns (UFixed6) {\n        (UFixed6 _totalAssets, UFixed6 _totalShares) =\n            (UFixed6Lib.unsafeFrom(totalAssets()), totalShares());\n        return _totalShares.isZero() ? assets : assets.muldiv(_totalShares, _totalAssets);\n    }\n\n    /// @notice Converts a given amount of shares to assets\n    /// @param shares Number of shares to convert to assets\n    /// @return Amount of assets for the given shares\n    function convertToAssets(UFixed6 shares) external view returns (UFixed6) {\n        (UFixed6 _totalAssets, UFixed6 _totalShares) =\n            (UFixed6Lib.unsafeFrom(totalAssets()), totalShares());\n        return _totalShares.isZero() ? shares : shares.muldiv(_totalAssets, _totalShares);\n    }\n\n    /// @notice Registers a new market\n    /// @param market The market to register\n    function register(IMarket market) external onlyOwner {\n        rebalance(address(0));\n\n        for (uint256 marketId; marketId < totalMarkets; marketId++) {\n            if (_registrations[marketId].read().market == market) revert VaultMarketExistsError();\n        }\n\n        _register(market);\n    }\n\n    /// @notice Handles the registration for a new market\n    /// @param market The market to register\n    function _register(IMarket market) private {\n        if (!IVaultFactory(address(factory())).marketFactory().instances(market)) revert VaultNotMarketError();\n        if (!market.token().eq(asset)) revert VaultIncorrectAssetError();\n\n        asset.approve(address(market));\n\n        uint256 newMarketId = _registerMarket(market);\n        _updateMarket(newMarketId, newMarketId == 0 ? UFixed6Lib.ONE : UFixed6Lib.ZERO, UFixed6Lib.ZERO);\n    }\n\n    /// @notice Processes the state changes for a market registration\n    /// @param market The market to register\n    /// @return newMarketId The new market id\n    function _registerMarket(IMarket market) private returns (uint256 newMarketId) {\n        newMarketId = totalMarkets++;\n        _registrations[newMarketId].store(Registration(market, UFixed6Lib.ZERO, UFixed6Lib.ZERO));\n        emit MarketRegistered(newMarketId, market);\n    }\n\n    /// @notice Processes the state changes for a market update\n    /// @param marketId The market id\n    /// @param newWeight The new weight for the market\n    /// @param newLeverage The new leverage for the market\n    function _updateMarket(uint256 marketId, UFixed6 newWeight, UFixed6 newLeverage) private {\n        Registration memory registration = _registrations[marketId].read();\n        registration.weight = newWeight.eq(UFixed6Lib.MAX) ? registration.weight : newWeight;\n        registration.leverage = newLeverage.eq(UFixed6Lib.MAX) ? registration.leverage : newLeverage;\n        _registrations[marketId].store(registration);\n        emit MarketUpdated(marketId, registration.weight, registration.leverage);\n    }\n\n    /// @notice Settles, then updates the registration parameters for a given market\n    /// @param marketId The market id\n    /// @param newLeverage The new leverage\n    function updateLeverage(uint256 marketId, UFixed6 newLeverage) external onlyOwner {\n        rebalance(address(0));\n\n        if (marketId >= totalMarkets) revert VaultMarketDoesNotExistError();\n\n        _updateMarket(marketId, UFixed6Lib.MAX, newLeverage);\n    }\n\n    /// @notice Updates the set of market weights for the vault\n    /// @param newWeights The new set of market weights\n    function updateWeights(UFixed6[] calldata newWeights) external onlyOwner {\n        rebalance(address(0));\n\n        if (newWeights.length != totalMarkets) revert VaultMarketDoesNotExistError();\n\n        UFixed6 totalWeight;\n        for(uint256 i; i < totalMarkets; i++) {\n            _updateMarket(i, newWeights[i], UFixed6Lib.MAX);\n            totalWeight = totalWeight.add(newWeights[i]);\n        }\n\n        if (!totalWeight.eq(UFixed6Lib.ONE)) revert VaultAggregateWeightError();\n    }\n\n    /// @notice Settles, then updates the vault parameter set\n    /// @param newParameter The new vault parameter set\n    function updateParameter(VaultParameter memory newParameter) external onlyOwner {\n        rebalance(address(0));\n        _updateParameter(newParameter);\n    }\n\n    /// @notice Updates the vault parameter set\n    /// @param newParameter The new vault parameter set\n    function _updateParameter(VaultParameter memory newParameter) private {\n        _parameter.store(newParameter);\n        emit ParameterUpdated(newParameter);\n    }\n\n    /// @notice Syncs `account`'s state up to current\n    /// @dev Rebalances only the collateral of the vault\n    /// @param account The account that should be synced\n    function settle(address account) public whenNotPaused {\n        _settleUnderlying();\n        Context memory context = _loadContext(account);\n\n        _settle(context, account);\n        _saveContext(context, account);\n    }\n\n    /// @notice Syncs `account`'s state up to current\n    /// @dev Rebalances only the collateral of the vault\n    /// @param account The account that should be synced\n    function rebalance(address account) public whenNotPaused {\n        _updateUnderlying();\n        Context memory context = _loadContext(account);\n\n        _settle(context, account);\n        _manage(context, UFixed6Lib.ZERO, UFixed6Lib.ZERO, false);\n        _saveContext(context, account);\n    }\n\n    /// @notice Updates `account`, depositing `depositAssets` assets, redeeming `redeemShares` shares, and claiming `claimAssets` assets\n    /// @param account The account to operate on\n    /// @param depositAssets The amount of assets to deposit\n    /// @param redeemShares The amount of shares to redeem\n    /// @param claimAssets The amount of assets to claim\n    function update(\n        address account,\n        UFixed6 depositAssets,\n        UFixed6 redeemShares,\n        UFixed6 claimAssets\n    ) external whenNotPaused {\n        _updateUnderlying();\n        Context memory context = _loadContext(account);\n\n        _settle(context, account);\n        _checkpoint(context);\n        _update(context, account, depositAssets, redeemShares, claimAssets);\n        _saveContext(context, account);\n    }\n\n    /// @notice Loads or initializes the current checkpoint\n    /// @param context The context to use\n    function _checkpoint(Context memory context) private view {\n        context.currentId = context.global.current;\n        context.currentCheckpoint = _checkpoints[context.currentId].read();\n\n        if (context.currentTimestamp > context.currentCheckpoint.timestamp) {\n            context.currentId++;\n            context.currentCheckpoint.next(context.currentTimestamp, context.global);\n        }\n    }\n\n    /// @notice Handles updating the account's position\n    /// @param context The context to use\n    /// @param account The account to operate on\n    /// @param depositAssets The amount of assets to deposit\n    /// @param redeemShares The amount of shares to redeem\n    /// @param claimAssets The amount of assets to claim\n    function _update(\n        Context memory context,\n        address account,\n        UFixed6 depositAssets,\n        UFixed6 redeemShares,\n        UFixed6 claimAssets\n    ) private {\n        // magic values\n        if (claimAssets.eq(UFixed6Lib.MAX)) claimAssets = context.local.assets;\n        if (redeemShares.eq(UFixed6Lib.MAX)) redeemShares = context.local.shares;\n\n        // invariant\n        if (msg.sender != account && !IVaultFactory(address(factory())).operators(account, msg.sender))\n            revert VaultNotOperatorError();\n        if (!depositAssets.add(redeemShares).add(claimAssets).eq(depositAssets.max(redeemShares).max(claimAssets)))\n            revert VaultNotSingleSidedError();\n        if (depositAssets.gt(_maxDeposit(context)))\n            revert VaultDepositLimitExceededError();\n        if (!depositAssets.isZero() && depositAssets.lt(context.settlementFee))\n            revert VaultInsufficientMinimumError();\n        if (!redeemShares.isZero() && context.latestCheckpoint.toAssets(redeemShares, context.settlementFee).isZero())\n            revert VaultInsufficientMinimumError();\n        if (context.local.current != context.local.latest) revert VaultExistingOrderError();\n\n        // asses socialization\n        UFixed6 claimAmount = _socialize(context, claimAssets);\n\n        // update positions\n        context.global.update(context.currentId, claimAssets, redeemShares, depositAssets, redeemShares);\n        context.local.update(context.currentId, claimAssets, redeemShares, depositAssets, redeemShares);\n        context.currentCheckpoint.update(depositAssets, redeemShares);\n\n        // manage assets\n        asset.pull(msg.sender, UFixed18Lib.from(depositAssets));\n        _manage(context, depositAssets, claimAmount, !depositAssets.isZero() || !redeemShares.isZero());\n        asset.push(msg.sender, UFixed18Lib.from(claimAmount));\n\n        emit Updated(msg.sender, account, context.currentId, depositAssets, redeemShares, claimAssets);\n    }\n\n    /// @notice Returns the claim amount after socialization\n    /// @param context The context to use\n    /// @param claimAssets The amount of assets to claim\n    function _socialize(Context memory context, UFixed6 claimAssets) private pure returns (UFixed6) {\n        return context.global.assets.isZero() ?\n            UFixed6Lib.ZERO :\n            claimAssets.muldiv(\n                UFixed6Lib.unsafeFrom(context.totalCollateral).min(context.global.assets),\n                context.global.assets\n            );\n    }\n\n    /// @notice Handles settling the vault's underlying markets\n    function _settleUnderlying() private {\n        for (uint256 marketId; marketId < totalMarkets; marketId++)\n            _registrations[marketId].read().market.settle(address(this));\n    }\n\n    /// @notice Handles updating the vault's underlying markets\n    function _updateUnderlying() private {\n        for (uint256 marketId; marketId < totalMarkets; marketId++)\n            _registrations[marketId].read().market.update(\n                address(this),\n                UFixed6Lib.MAX,\n                UFixed6Lib.ZERO,\n                UFixed6Lib.ZERO,\n                Fixed6Lib.ZERO,\n                false\n            );\n    }\n\n    /// @notice Handles settling the vault state\n    /// @dev Run before every stateful operation to settle up the latest global state of the vault\n    /// @param context The context to use\n    function _settle(Context memory context, address account) private {\n        Checkpoint memory nextCheckpoint;\n\n        // settle global positions\n        while (\n            context.global.current > context.global.latest &&\n            context.latestTimestamp >= (nextCheckpoint = _checkpoints[context.global.latest + 1].read()).timestamp\n        ) {\n            nextCheckpoint.complete(_checkpointAtId(context, nextCheckpoint.timestamp));\n            context.global.processGlobal(\n                context.global.latest + 1,\n                nextCheckpoint,\n                nextCheckpoint.deposit,\n                nextCheckpoint.redemption\n            );\n            _checkpoints[context.global.latest].store(nextCheckpoint);\n            context.latestCheckpoint = nextCheckpoint;\n        }\n\n        if (account == address(0)) return;\n\n        // settle local position\n        if (\n            context.local.current > context.local.latest &&\n            context.latestTimestamp >= (nextCheckpoint = _checkpoints[context.local.current].read()).timestamp\n        )\n            context.local.processLocal(\n                context.local.current,\n                nextCheckpoint,\n                context.local.deposit,\n                context.local.redemption\n            );\n    }\n\n    /// @notice Manages the internal collateral and position strategy of the vault\n    /// @param deposit The amount of assets that are being deposited into the vault\n    /// @param withdrawal The amount of assets that need to be withdrawn from the markets into the vault\n    /// @param rebalance Whether to rebalance the vault's position\n    function _manage(Context memory context, UFixed6 deposit, UFixed6 withdrawal, bool rebalance) private {\n        if (context.totalCollateral.lt(Fixed6Lib.ZERO)) return;\n\n        StrategyLib.MarketTarget[] memory targets = StrategyLib\n            .load(context.registrations)\n            .allocate(\n                deposit,\n                withdrawal,\n                _ineligable(context, withdrawal)\n            );\n\n        for (uint256 marketId; marketId < context.registrations.length; marketId++)\n            if (targets[marketId].collateral.lt(Fixed6Lib.ZERO))\n                _retarget(context.registrations[marketId], targets[marketId], rebalance);\n        for (uint256 marketId; marketId < context.registrations.length; marketId++)\n            if (targets[marketId].collateral.gte(Fixed6Lib.ZERO))\n                _retarget(context.registrations[marketId], targets[marketId], rebalance);\n    }\n\n    /// @notice Returns the amount of collateral is ineligable for allocation\n    /// @param context The context to use\n    /// @param withdrawal The amount of assets that need to be withdrawn from the markets into the vault\n    /// @return The amount of assets that are ineligable from being allocated\n    function _ineligable(Context memory context, UFixed6 withdrawal) private pure returns (UFixed6) {\n        // assets eligable for redemption\n        UFixed6 redemptionEligable = UFixed6Lib.unsafeFrom(context.totalCollateral)\n            .unsafeSub(withdrawal)\n            .unsafeSub(context.global.assets)\n            .unsafeSub(context.global.deposit);\n\n        return redemptionEligable\n            // approximate assets up for redemption\n            .mul(context.global.redemption.unsafeDiv(context.global.shares.add(context.global.redemption)))\n            // assets pending claim\n            .add(context.global.assets)\n            // assets withdrawing\n            .add(withdrawal);\n    }\n\n    /// @notice Adjusts the position on `market` to `targetPosition`\n    /// @param registration The registration of the market to us"
    }
  ]
}