{
  "Title": "[G-04]  ",
  "Content": "<h2 id=\"g-04--internal-functions-only-called-once-can-be-inlined-to-save-gas\" style=\"position:relative;\"><a href=\"#g-04--internal-functions-only-called-once-can-be-inlined-to-save-gas\" aria-label=\"g 04  internal functions only called once can be inlined to save gas permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[G-04]  <code>internal</code> functions only called once can be inlined to save gas</h2>\n<p>Not inlining costs <strong>20 to 40 gas</strong> because of two extra <code>JUMP</code> instructions and additional stack operations needed for function calls.</p>\n<p><em>There are 3 instances of this issue:</em></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"24\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">File: </span><span class=\"mtk12\">contracts</span><span class=\"mtk1\">/</span><span class=\"mtk12\">governance</span><span class=\"mtk1\">/</span><span class=\"mtk12\">Managed</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">43</span><span class=\"mtk1\">        </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">_notPartialPaused</span><span class=\"mtk1\">() </span><span class=\"mtk11\">internal</span><span class=\"mtk1\"> </span><span class=\"mtk11\">view</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">44</span><span class=\"mtk1\">:           </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(!</span><span class=\"mtk12\">controller</span><span class=\"mtk1\">.</span><span class=\"mtk11\">paused</span><span class=\"mtk1\">(), </span><span class=\"mtk8\">\"Paused\"</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">52</span><span class=\"mtk1\">        </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">_onlyGovernor</span><span class=\"mtk1\">() </span><span class=\"mtk11\">internal</span><span class=\"mtk1\"> </span><span class=\"mtk11\">view</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">53</span><span class=\"mtk1\">:           </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\"> == </span><span class=\"mtk12\">controller</span><span class=\"mtk1\">.</span><span class=\"mtk11\">getGovernor</span><span class=\"mtk1\">(), </span><span class=\"mtk8\">\"Caller must be Controller governor\"</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">56</span><span class=\"mtk1\">        </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">_onlyController</span><span class=\"mtk1\">() </span><span class=\"mtk11\">internal</span><span class=\"mtk1\"> </span><span class=\"mtk11\">view</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">57</span><span class=\"mtk1\">:           </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\"> == </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk12\">controller</span><span class=\"mtk1\">), </span><span class=\"mtk8\">\"Caller must be Controller\"</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p><a href=\"https://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/governance/Managed.sol#L43-L44\">https://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/governance/Managed.sol#L43-L44</a></p>\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-10-the-graph-l2-bridge-contest",
  "Code": [
    {
      "filename": "contracts/governance/Managed.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.7.6;\n\nimport \"./IController.sol\";\n\nimport \"../curation/ICuration.sol\";\nimport \"../epochs/IEpochManager.sol\";\nimport \"../rewards/IRewardsManager.sol\";\nimport \"../staking/IStaking.sol\";\nimport \"../token/IGraphToken.sol\";\nimport \"../arbitrum/ITokenGateway.sol\";\n\n/**\n * @title Graph Managed contract\n * @dev The Managed contract provides an interface to interact with the Controller.\n * It also provides local caching for contract addresses. This mechanism relies on calling the\n * public `syncAllContracts()` function whenever a contract changes in the controller.\n *\n * Inspired by Livepeer:\n * https://github.com/livepeer/protocol/blob/streamflow/contracts/Controller.sol\n */\ncontract Managed {\n    // -- State --\n\n    // Controller that contract is registered with\n    IController public controller;\n    mapping(bytes32 => address) private addressCache;\n    uint256[10] private __gap;\n\n    // -- Events --\n\n    event ParameterUpdated(string param);\n    event SetController(address controller);\n\n    /**\n     * @dev Emitted when contract with `nameHash` is synced to `contractAddress`.\n     */\n    event ContractSynced(bytes32 indexed nameHash, address contractAddress);\n\n    // -- Modifiers --\n\n    function _notPartialPaused() internal view {\n        require(!controller.paused(), \"Paused\");\n        require(!controller.partialPaused(), \"Partial-paused\");\n    }\n\n    function _notPaused() internal view virtual {\n        require(!controller.paused(), \"Paused\");\n    }\n\n    function _onlyGovernor() internal view {\n        require(msg.sender == controller.getGovernor(), \"Caller must be Controller governor\");\n    }\n\n    function _onlyController() internal view {\n        require(msg.sender == address(controller), \"Caller must be Controller\");\n    }\n\n    modifier notPartialPaused() {\n        _notPartialPaused();\n        _;\n    }\n\n    modifier notPaused() {\n        _notPaused();\n        _;\n    }\n\n    // Check if sender is controller.\n    modifier onlyController() {\n        _onlyController();\n        _;\n    }\n\n    // Check if sender is the governor.\n    modifier onlyGovernor() {\n        _onlyGovernor();\n        _;\n    }\n\n    // -- Functions --\n\n    /**\n     * @dev Initialize the controller.\n     */\n    function _initialize(address _controller) internal {\n        _setController(_controller);\n    }\n\n    /**\n     * @notice Set Controller. Only callable by current controller.\n     * @param _controller Controller contract address\n     */\n    function setController(address _controller) external onlyController {\n        _setController(_controller);\n    }\n\n    /**\n     * @dev Set controller.\n     * @param _controller Controller contract address\n     */\n    function _setController(address _controller) internal {\n        require(_controller != address(0), \"Controller must be set\");\n        controller = IController(_controller);\n        emit SetController(_controller);\n    }\n\n    /**\n     * @dev Return Curation interface.\n     * @return Curation contract registered with Controller\n     */\n    function curation() internal view returns (ICuration) {\n        return ICuration(_resolveContract(keccak256(\"Curation\")));\n    }\n\n    /**\n     * @dev Return EpochManager interface.\n     * @return Epoch manager contract registered with Controller\n     */\n    function epochManager() internal view returns (IEpochManager) {\n        return IEpochManager(_resolveContract(keccak256(\"EpochManager\")));\n    }\n\n    /**\n     * @dev Return RewardsManager interface.\n     * @return Rewards manager contract registered with Controller\n     */\n    function rewardsManager() internal view returns (IRewardsManager) {\n        return IRewardsManager(_resolveContract(keccak256(\"RewardsManager\")));\n    }\n\n    /**\n     * @dev Return Staking interface.\n     * @return Staking contract registered with Controller\n     */\n    function staking() internal view returns (IStaking) {\n        return IStaking(_resolveContract(keccak256(\"Staking\")));\n    }\n\n    /**\n     * @dev Return GraphToken interface.\n     * @return Graph token contract registered with Controller\n     */\n    function graphToken() internal view returns (IGraphToken) {\n        return IGraphToken(_resolveContract(keccak256(\"GraphToken\")));\n    }\n\n    /**\n     * @dev Return GraphTokenGateway (L1 or L2) interface.\n     * @return Graph token gateway contract registered with Controller\n     */\n    function graphTokenGateway() internal view returns (ITokenGateway) {\n        return ITokenGateway(_resolveContract(keccak256(\"GraphTokenGateway\")));\n    }\n\n    /**\n     * @dev Resolve a contract address from the cache or the Controller if not found.\n     * @return Address of the contract\n     */\n    function _resolveContract(bytes32 _nameHash) internal view returns (address) {\n        address contractAddress = addressCache[_nameHash];\n        if (contractAddress == address(0)) {\n            contractAddress = controller.getContractProxy(_nameHash);\n        }\n        return contractAddress;\n    }\n\n    /**\n     * @dev Cache a contract address from the Controller registry.\n     * @param _name Name of the contract to sync into the cache\n     */\n    function _syncContract(string memory _name) internal {\n        bytes32 nameHash = keccak256(abi.encodePacked(_name));\n        address contractAddress = controller.getContractProxy(nameHash);\n        if (addressCache[nameHash] != contractAddress) {\n            addressCache[nameHash] = contractAddress;\n            emit ContractSynced(nameHash, contractAddress);\n        }\n    }\n\n    /**\n     * @dev Sync protocol contract addresses from the Controller registry.\n     * This function will cache all the contracts using the latest addresses\n     * Anyone can call the function whenever a Proxy contract change in the\n     * controller to ensure the protocol is using the latest version\n     */\n    function syncAllContracts() external {\n        _syncContract(\"Curation\");\n        _syncContract(\"EpochManager\");\n        _syncContract(\"RewardsManager\");\n        _syncContract(\"Staking\");\n        _syncContract(\"GraphToken\");\n        _syncContract(\"GraphTokenGateway\");\n    }\n}"
    }
  ]
}