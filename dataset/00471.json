{
  "Title": "H-6: Requested withdrawal can be impossible to settle due to EigenLayer shares value appreciate when there are idle funds in deposit pool",
  "Content": "# Issue H-6: Requested withdrawal can be impossible to settle due to EigenLayer shares value appreciate when there are idle funds in deposit pool \n\nSource: https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/109 \n\n## Found by \ng, mstpr-brainbot, zzykxx\n## Summary\nWhen users request a withdrawal, the EigenLayer shares equivalent to their LRT's value are recorded. During settlement, these EigenLayer shares must be deducted to finalize the withdrawal epoch. However, in certain scenarios, the requested EigenLayer shares may be impossible to unwind due to funds idling in the deposit pool. \n## Vulnerability Detail\nLet's assume that 1 LRT equals 1 EigenLayer-cbETH, which equals 1 cbETH initially.\n\nAlice deposits 5e18 cbETH, and her deposits are allocated to operators after rebalancing. Now, Rio holds 5 EigenLayer-cbETH, which is worth 5 cbETH.\n\nAfter some time, Bob deposits 100e18 cbETH to Rio and immediately withdraws it. At the time Bob requests this withdrawal, 100 cbETH is worth 100 EigenLayer-cbETH, so the shares owed are 100 EigenLayer-cbETH. At settlement, 100 EigenLayer-cbETH worth of cbETH has to be sent to the withdrawal queue to settle this epoch.\n\nNow, assume that the value of EigenLayer-cbETH increases, meaning that 1 EigenLayer-cbETH is now worth more cbETH. This is an expected behavior because EigenLayer-cbETH is similar to an ERC4626 vault, and we expect its value to increase over time.\n\nLet's say 1 EigenLayer-cbETH is now worth 1.1 cbETH.\n\nNow, 100 cbETH sits idle in the deposit pool, and there are 5 EigenLayer-cbETH in the operators, which means there are a total of 90.9 + 5 = 95.9 EigenLayer-cbETH worth of cbETH in Rio. However, Bob's withdrawal request is for 100 EigenLayer-cbETH.\n\nThis would mean that Bob's withdrawal request will not be settled, and the entire withdrawal flow will be stuck because this epoch can't be settled.\n\n\n\n**Coded PoC:**\n```solidity\n // forge test --match-contract RioLRTDepositPoolTest --match-test test_InsufficientSharesInWithdrawal -vv\n    function test_InsufficientSharesInWithdrawal() public {\n        uint8 operatorId = addOperatorDelegator(reLST.operatorRegistry, address(reLST.rewardDistributor));\n        address operatorDelegator = reLST.operatorRegistry.getOperatorDetails(operatorId).delegator;\n\n        uint256 AMOUNT = 5e18;\n\n        // Allocate to cbETH strategy.\n        cbETH.approve(address(reLST.coordinator), type(uint256).max);\n        reLST.coordinator.deposit(CBETH_ADDRESS, AMOUNT);\n        console.log(\"SHARES HELD\", reLST.assetRegistry.getAssetSharesHeld(CBETH_ADDRESS));\n\n        // Push funds into EigenLayer.\n        vm.prank(EOA, EOA);\n        reLST.coordinator.rebalance(CBETH_ADDRESS);\n\n        assertEq(cbETH.balanceOf(address(reLST.depositPool)), 0);\n        assertEq(reLST.assetRegistry.getAssetSharesHeld(CBETH_ADDRESS), AMOUNT);\n        console.log(\"SHARES HELD\", reLST.assetRegistry.getAssetSharesHeld(CBETH_ADDRESS));\n\n        // @review before rebalance, deposit 100 * 1e18\n        reLST.coordinator.deposit(CBETH_ADDRESS, 100e18);\n\n        // @review request withdrawal \n        reLST.coordinator.requestWithdrawal(CBETH_ADDRESS, 100e18);\n        console.log(\"SHARES HELD\", reLST.assetRegistry.getAssetSharesHeld(CBETH_ADDRESS));\n\n        // @review donate, the idea is to make EigenLayer shares worth more\n        uint256 donate = 10_000 * 1e18;\n        address tapir = address(69);\n        MockERC20(CBETH_ADDRESS).mint(tapir, donate);\n        console.log(\"before rate\", reLST.assetRegistry.convertFromSharesToAsset(address(cbETHStrategy), 1e18));\n\n        // @review expecting the rate to be higher after donation\n        vm.prank(tapir);\n        MockERC20(CBETH_ADDRESS).transfer(address(cbETHStrategy), donate);\n        console.log(\"after rate\", reLST.assetRegistry.convertFromSharesToAsset(address(cbETHStrategy), 1e18));\n\n        // @review rebalance, expect revert\n        skip(reLST.coordinator.rebalanceDelay());\n        vm.startPrank(EOA, EOA);\n        vm.expectRevert(bytes4(keccak256(\"INCORRECT_NUMBER_OF_SHARES_QUEUED()\")));\n        reLST.coordinator.rebalance(CBETH_ADDRESS);\n        vm.stopPrank();\n    }\n```\n## Impact\nHigh since the further and current withdrawals are not possible. \n## Code Snippet\nhttps://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/restaking/RioLRTCoordinator.sol#L99-L151\n\nhttps://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/utils/OperatorOperations.sol#L113-L134\n## Tool used\n\nManual Review\n\n## Recommendation\n\n\n\n## Discussion\n\n**solimander**\n\nSeems unlikely to have a meaningful effect while rebasing tokens are not supported.\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/rio-org/rio-sherlock-audit/pull/13\n\n\n**Czar102**\n\nFor a more severe impact, see #112.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/176",
  "Code": [
    {
      "filename": "rio-sherlock-audit/contracts/restaking/RioLRTCoordinator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.23;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IRioLRTWithdrawalQueue} from 'contracts/interfaces/IRioLRTWithdrawalQueue.sol';\nimport {UUPSUpgradeable} from '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport {OwnableUpgradeable} from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport {IRioLRTAssetRegistry} from 'contracts/interfaces/IRioLRTAssetRegistry.sol';\nimport {ETH_ADDRESS, MAX_REBALANCE_DELAY} from 'contracts/utils/Constants.sol';\nimport {IRioLRTCoordinator} from 'contracts/interfaces/IRioLRTCoordinator.sol';\nimport {OperatorOperations} from 'contracts/utils/OperatorOperations.sol';\nimport {RioLRTCore} from 'contracts/restaking/base/RioLRTCore.sol';\nimport {ETH_ADDRESS} from 'contracts/utils/Constants.sol';\nimport {Asset} from 'contracts/utils/Asset.sol';\n\ncontract RioLRTCoordinator is IRioLRTCoordinator, OwnableUpgradeable, UUPSUpgradeable, RioLRTCore {\n    using SafeERC20 for *;\n    using Asset for *;\n\n    /// @notice The required delay between rebalances.\n    uint24 public rebalanceDelay;\n\n    /// @notice Tracks the timestamp from which each asset is eligible for rebalancing, inclusive of the defined timestamp.\n    mapping(address asset => uint256 timestamp) public assetNextRebalanceAfter;\n\n    /// @notice Require that the asset is supported, the deposit amount is non-zero, and the\n    /// deposit cap has not been reached.\n    /// @param asset The asset being deposited.\n    /// @param amountIn The amount of the asset being deposited.\n    modifier checkDeposit(address asset, uint256 amountIn) {\n        _checkAssetSupported(asset);\n        _checkAmountGreaterThanZero(amountIn);\n        _checkDepositCapReached(asset, amountIn);\n        _;\n    }\n\n    /// @notice Require that the asset is supported and the withdrawal amount is non-zero.\n    /// @param asset The asset being deposited.\n    /// @param amountIn The amount of the asset being deposited.\n    modifier checkWithdrawal(address asset, uint256 amountIn) {\n        _checkAssetSupported(asset);\n        _checkAmountGreaterThanZero(amountIn);\n        _;\n    }\n\n    /// @notice Require that the rebalance delay has been met.\n    /// @param asset The asset being rebalanced.\n    modifier checkRebalanceDelayMet(address asset) {\n        _checkRebalanceDelayMet(asset);\n        _;\n    }\n\n    /// @param issuer_ The LRT issuer that's authorized to deploy this contract.\n    constructor(address issuer_) RioLRTCore(issuer_) {}\n\n    /// @dev Initializes the contract.\n    /// @param initialOwner The owner of the contract.\n    /// @param token_ The address of the liquid restaking token.\n    function initialize(address initialOwner, address token_) external initializer {\n        __Ownable_init(initialOwner);\n        __UUPSUpgradeable_init();\n        __RioLRTCore_init(token_);\n\n        _setRebalanceDelay(24 hours);\n    }\n\n    /// @notice Returns the total value of all underlying assets in the unit of account.\n    function getTVL() public view returns (uint256 value) {\n        return assetRegistry().getTVL();\n    }\n\n    // forgefmt: disable-next-item\n    /// @notice Deposits ERC20 tokens and mints restaking token(s) to the caller.\n    /// @param asset The asset being deposited.\n    /// @param amountIn The amount of the asset being deposited.\n    function deposit(address asset, uint256 amountIn) external checkDeposit(asset, amountIn) returns (uint256 amountOut) {\n        // Convert deposited asset amount to restaking tokens.\n        amountOut = convertFromAssetToRestakingTokens(asset, amountIn);\n\n        // Pull tokens from the sender to the deposit pool.\n        IERC20(asset).safeTransferFrom(msg.sender, address(depositPool()), amountIn);\n\n        // Mint restaking tokens to the caller.\n        token.mint(msg.sender, amountOut);\n\n        emit Deposited(msg.sender, asset, amountIn, amountOut);\n    }\n\n    /// @notice Deposits ETH and mints restaking token(s) to the caller.\n    function depositETH() external payable returns (uint256) {\n        return _depositETH();\n    }\n\n    // forgefmt: disable-next-item\n    /// @notice Requests a withdrawal to `asset` for `amountIn` restaking tokens.\n    /// @param asset The asset being withdrawn.\n    /// @param amountIn The amount of restaking tokens being redeemed.\n    function requestWithdrawal(address asset, uint256 amountIn) external checkWithdrawal(asset, amountIn) returns (uint256 sharesOwed) {\n        // Determine the amount of shares owed to the withdrawer using the current exchange rate.\n        sharesOwed = convertToSharesFromRestakingTokens(asset, amountIn);\n\n        // If requesting ETH, reduce the precision of the shares owed to the nearest Gwei,\n        // which is the smallest unit of account supported by EigenLayer.\n        if (asset == ETH_ADDRESS) sharesOwed = sharesOwed.reducePrecisionToGwei();\n\n        // Pull restaking tokens from the sender to the withdrawal queue.\n        token.safeTransferFrom(msg.sender, address(withdrawalQueue()), amountIn);\n\n        // Ensure there are enough shares to cover the withdrawal request, and queue the withdrawal.\n        uint256 availableShares = assetRegistry().convertToSharesFromAsset(asset, assetRegistry().getTotalBalanceForAsset(asset));\n        if (sharesOwed > availableShares - withdrawalQueue().getSharesOwedInCurrentEpoch(asset)) {\n            revert INSUFFICIENT_SHARES_FOR_WITHDRAWAL();\n        }\n        withdrawalQueue().queueWithdrawal(msg.sender, asset, sharesOwed, amountIn);\n    }\n\n    /// @notice Rebalances the provided `asset` by processing outstanding withdrawals and\n    /// depositing remaining assets into EigenLayer.\n    /// @param asset The asset to rebalance.\n    function rebalance(address asset) external checkRebalanceDelayMet(asset) {\n        if (!assetRegistry().isSupportedAsset(asset)) revert ASSET_NOT_SUPPORTED(asset);\n        if (msg.sender != tx.origin) revert CALLER_MUST_BE_EOA();\n\n        // Process any outstanding withdrawals using funds from the deposit pool and EigenLayer.\n        uint256 sharesOwed = withdrawalQueue().getSharesOwedInCurrentEpoch(asset);\n        if (sharesOwed > 0) {\n            _processUserWithdrawalsForCurrentEpoch(asset, sharesOwed);\n        }\n\n        // Deposit remaining assets into EigenLayer.\n        (uint256 sharesReceived, bool isDepositCapped) = depositPool().depositBalanceIntoEigenLayer(asset);\n        if (sharesOwed == 0 && sharesReceived == 0) {\n            revert NO_REBALANCE_NEEDED();\n        }\n        if (sharesReceived > 0) {\n            if (asset == ETH_ADDRESS) {\n                assetRegistry().increaseUnverifiedValidatorETHBalance(sharesReceived);\n            } else {\n                assetRegistry().increaseSharesHeldForAsset(asset, sharesReceived);\n            }\n        }\n\n        // When the deposit is not capped, the rebalance is considered complete, and the asset rebalance\n        // timestamp is increased by the specified delay. If capped, the asset may be rebalanced again\n        // immediately as there are more assets to deposit.\n        if (!isDepositCapped) {\n            assetNextRebalanceAfter[asset] = uint40(block.timestamp) + rebalanceDelay;\n        }\n        emit Rebalanced(asset);\n    }\n\n    /// @notice Sets the rebalance delay.\n    /// @param newRebalanceDelay The new rebalance delay, in seconds.\n    function setRebalanceDelay(uint24 newRebalanceDelay) external onlyOwner {\n        _setRebalanceDelay(newRebalanceDelay);\n    }\n\n    /// @notice Converts the unit of account value to its equivalent in restaking tokens.\n    /// The unit of account is the price feed's quote asset.\n    /// @param value The restaking token's value in the unit of account.\n    function convertFromUnitOfAccountToRestakingTokens(uint256 value) public view returns (uint256) {\n        uint256 tvl = getTVL();\n        uint256 supply = token.totalSupply();\n\n        if (supply == 0) {\n            return value;\n        }\n        return value * supply / tvl;\n    }\n\n    /// @notice Converts an amount of restaking tokens to its equivalent value in the unit of account.\n    /// The unit of account is the price feed's quote asset.\n    /// @param amount The amount of restaking tokens to convert.\n    function convertToUnitOfAccountFromRestakingTokens(uint256 amount) public view returns (uint256) {\n        uint256 tvl = getTVL();\n        uint256 supply = token.totalSupply();\n\n        if (supply == 0) {\n            return amount;\n        }\n        return tvl * amount / supply;\n    }\n\n    /// @notice Converts an asset amount to its equivalent value in restaking tokens.\n    /// @param asset The address of the asset to convert.\n    /// @param amount The amount of the asset to convert.\n    function convertFromAssetToRestakingTokens(address asset, uint256 amount) public view returns (uint256) {\n        uint256 value = assetRegistry().convertToUnitOfAccountFromAsset(asset, amount);\n        return convertFromUnitOfAccountToRestakingTokens(value);\n    }\n\n    /// @notice Converts an amount of restaking tokens to the equivalent in the asset.\n    /// @param asset The address of the asset to convert to.\n    /// @param amount The amount of restaking tokens to convert.\n    function convertToAssetFromRestakingTokens(address asset, uint256 amount) public view returns (uint256) {\n        uint256 value = convertToUnitOfAccountFromRestakingTokens(amount);\n        return assetRegistry().convertFromUnitOfAccountToAsset(asset, value);\n    }\n\n    /// @notice Converts an amount of restaking tokens to the equivalent in the provided\n    /// asset's EigenLayer shares.\n    /// @param asset The address of the asset whose EigenLayer shares to convert to.\n    /// @param amount The amount of restaking tokens to convert.\n    function convertToSharesFromRestakingTokens(address asset, uint256 amount) public view returns (uint256 shares) {\n        uint256 assetAmount = convertToAssetFromRestakingTokens(asset, amount);\n        return assetRegistry().convertToSharesFromAsset(asset, assetAmount);\n    }\n\n    /// @notice Deposits ETH and mints restaking token(s) to the caller.\n    receive() external payable {\n        _depositETH();\n    }\n\n    /// @notice Deposits ETH and mints restaking token(s) to the caller.\n    /// @dev This function assumes that the quote asset is ETH.\n    function _depositETH() internal checkDeposit(ETH_ADDRESS, msg.value) returns (uint256 amountOut) {\n        // Convert deposited ETH to restaking tokens and mint to the caller.\n        amountOut = convertFromUnitOfAccountToRestakingTokens(msg.value);\n\n        // Forward ETH to the deposit pool.\n        address(depositPool()).transferETH(msg.value);\n\n        // Mint restaking tokens to the caller.\n        token.mint(msg.sender, amountOut);\n\n        emit Deposited(msg.sender, ETH_ADDRESS, msg.value, amountOut);\n    }\n\n    /// @dev Sets the rebalance delay.\n    /// @param newRebalanceDelay The new rebalance delay, in seconds.\n    function _setRebalanceDelay(uint24 newRebalanceDelay) internal {\n        if (newRebalanceDelay > MAX_REBALANCE_DELAY) revert REBALANCE_DELAY_TOO_LONG();\n        rebalanceDelay = newRebalanceDelay;\n\n        emit RebalanceDelaySet(newRebalanceDelay);\n    }\n\n    // forgefmt: disable-next-item\n    /// @dev Processes user withdrawals for the provided asset by transferring available\n    /// assets from the deposit pool and queueing any remaining amount for withdrawal from\n    /// EigenLayer.\n    /// @param asset The asset being withdrawn.\n    /// @param sharesOwed The amount of shares owed to users.\n    function _processUserWithdrawalsForCurrentEpoch(address asset, uint256 sharesOwed) internal {\n        IRioLRTWithdrawalQueue withdrawalQueue_ = withdrawalQueue();\n        (uint256 assetsSent, uint256 sharesSent) = depositPool().transferMaxAssetsForShares(\n            asset,\n            sharesOwed,\n            address(withdrawalQueue_)\n        );\n        uint256 sharesRemaining = sharesOwed - sharesSent;\n\n        // Exit early if all pending withdrawals were paid from the deposit pool.\n        if (sharesRemaining == 0) {\n            withdrawalQueue_.settleCurrentEpoch(asset, assetsSent, sharesSent);\n            return;\n        }\n\n        address strategy = assetRegistry().getAssetStrategy(asset);\n        bytes32 aggregateRoot = OperatorOperations.queueWithdrawalFromOperatorsForUserSettlement(\n            operatorRegistry(),\n            strategy,\n            sharesRemaining\n        );\n        withdrawalQueue_.queueCurrentEpochSettlement(asset, assetsSent, sharesSent, aggregateRoot);\n    }\n\n    /// @dev Checks if the provided asset is supported.\n    /// @param asset The address of the asset.\n    function _checkAssetSupported(address asset) internal view {\n        if (!assetRegistry().isSupportedAsset(asset)) revert ASSET_NOT_SUPPORTED(asset);\n    }\n\n    /// @dev Checks if the provided amount is greater than zero.\n    /// @param amount The amount being checked.\n    function _checkAmountGreaterThanZero(uint256 amount) internal pure {\n        if (amount == 0) revert AMOUNT_MUST_BE_GREATER_THAN_ZERO();\n    }\n\n    /// @dev Checks if the deposit cap for the asset has been reached.\n    /// @param asset The address of the asset.\n    /// @param amountIn The amount of the asset being deposited.\n    function _checkDepositCapReached(address asset, uint256 amountIn) internal view {\n        IRioLRTAssetRegistry assetRegistry_ = assetRegistry();\n\n        uint256 depositCap = assetRegistry_.getAssetDepositCap(asset);\n        if (depositCap > 0) {\n            uint256 existingBalance = assetRegistry_.getTotalBalanceForAsset(asset);\n            if (existingBalance + amountIn > depositCap) {\n                revert DEPOSIT_CAP_REACHED(asset, depositCap);\n            }\n        }\n    }\n\n    /// @dev Reverts if the rebalance delay has not been met.\n    /// @param asset The asset being rebalanced.\n    function _checkRebalanceDelayMet(address asset) internal view {\n        if (block.timestamp < assetNextRebalanceAfter[asset]) revert REBALANCE_DELAY_NOT_MET();\n    }\n\n    /// @dev Allows the owner to upgrade the gateway implementation.\n    /// @param newImplementation The implementation to upgrade to.\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n}"
    },
    {
      "filename": "rio-sherlock-audit/contracts/utils/OperatorOperations.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.23;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {FixedPointMathLib} from '@solady/utils/FixedPointMathLib.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IRioLRTOperatorRegistry} from 'contracts/interfaces/IRioLRTOperatorRegistry.sol';\nimport {IRioLRTOperatorDelegator} from 'contracts/interfaces/IRioLRTOperatorDelegator.sol';\nimport {BEACON_CHAIN_STRATEGY, ETH_DEPOSIT_SIZE} from 'contracts/utils/Constants.sol';\n\n/// @title Operator delegator deposit and withdrawal operations.\nlibrary OperatorOperations {\n    using FixedPointMathLib for uint256;\n    using SafeERC20 for IERC20;\n\n    /// @notice Thrown when the number of shares queued for withdrawal from EigenLayer\n    /// do not match the number of shares requested.\n    error INCORRECT_NUMBER_OF_SHARES_QUEUED();\n\n    /// @notice Thrown when the amount of shares received is not the expected amount.\n    error INCORRECT_NUMBER_OF_SHARES_RECEIVED();\n\n    /// @notice Deposits ETH into EigenLayer through the operators that are returned from the registry.\n    /// @param operatorRegistry The operator registry used allocate to and deallocate from EigenLayer operators.\n    /// @param amount The amount of ETH to deposit.\n    function depositETHToOperators(IRioLRTOperatorRegistry operatorRegistry, uint256 amount) internal returns (uint256 depositAmount) {\n        uint256 depositCount = amount / ETH_DEPOSIT_SIZE;\n        if (depositCount == 0) return depositAmount;\n\n        // forgefmt: disable-next-item\n        (uint256 depositsAllocated, IRioLRTOperatorRegistry.OperatorETHAllocation[] memory allocations) = operatorRegistry.allocateETHDeposits(\n            depositCount\n        );\n        depositAmount = depositsAllocated * ETH_DEPOSIT_SIZE;\n\n        for (uint256 i = 0; i < allocations.length; ++i) {\n            uint256 deposits = allocations[i].deposits;\n\n            IRioLRTOperatorDelegator(allocations[i].delegator).stakeETH{value: deposits * ETH_DEPOSIT_SIZE}(\n                deposits, allocations[i].pubKeyBatch, allocations[i].signatureBatch\n            );\n        }\n    }\n\n    /// @notice Deposits the given `amount` of tokens into EigenLayer the provided\n    /// EigenLayer `strategy` via the operators that are returned from the registry.\n    /// @param operatorRegistry The operator registry used allocate to and deallocate from EigenLayer operators.\n    /// @param token The address of the token to deposit.\n    /// @param strategy The strategy to deposit the funds into.\n    /// @param sharesToAllocate The amount of strategy shares to allocate.\n    function depositTokenToOperators(\n        IRioLRTOperatorRegistry operatorRegistry,\n        address token,\n        address strategy,\n        uint256 sharesToAllocate\n    ) internal returns (uint256 sharesReceived) {\n        (uint256 sharesAllocated, IRioLRTOperatorRegistry.OperatorStrategyAllocation[] memory  allocations) = operatorRegistry.allocateStrategyShares(\n            strategy, sharesToAllocate\n        );\n\n        for (uint256 i = 0; i < allocations.length; ++i) {\n            IRioLRTOperatorRegistry.OperatorStrategyAllocation memory allocation = allocations[i];\n\n            IERC20(token).safeTransfer(allocation.delegator, allocation.tokens);\n            sharesReceived += IRioLRTOperatorDelegator(allocation.delegator).stakeERC20(strategy, token, allocation.tokens);\n        }\n        if (sharesReceived != sharesAllocated) revert INCORRECT_NUMBER_OF_SHARES_RECEIVED();\n    }\n\n    /// @notice Queues withdrawals from EigenLayer through the operators that are returned from the registry.\n    /// @param operatorRegistry The operator registry used allocate to and deallocate from EigenLayer operators.\n    /// @param strategy The strategy to withdraw the funds from.\n    /// @param amount The amount needed.\n    function queueWithdrawalFromOperatorsForUserSettlement(\n        IRioLRTOperatorRegistry operatorRegistry,\n        address strategy,\n        uint256 amount\n    ) internal returns (bytes32 aggregateRoot) {\n        if (strategy == BEACON_CHAIN_STRATEGY) {\n            return queueETHWithdrawalFromOperatorsForUserSettlement(operatorRegistry, amount);\n        }\n        return queueTokenWithdrawalFromOperatorsForUserSettlement(operatorRegistry, strategy, amount);\n    }\n\n    /// @notice Queues ETH withdrawals from EigenLayer through the operators that are returned from the registry.\n    /// @param operatorRegistry The operator registry used allocate to and deallocate from EigenLayer operators.\n    /// @param amount The amount of ETH needed.\n    function queueETHWithdrawalFromOperatorsForUserSettlement(IRioLRTOperatorRegistry operatorRegistry, uint256 amount) internal returns (bytes32 aggregateRoot) {\n        uint256 depositCount = amount.divUp(ETH_DEPOSIT_SIZE);\n        (, IRioLRTOperatorRegistry.OperatorETHDeallocation[] memory operatorDepositDeallocations) = operatorRegistry.deallocateETHDeposits(\n            depositCount\n        );\n        uint256 length = operatorDepositDeallocations.length;\n        bytes32[] memory roots = new bytes32[](length);\n\n        uint256 remainingAmount = amount;\n        for (uint256 i = 0; i < length; ++i) {\n            address delegator = operatorDepositDeallocations[i].delegator;\n\n            // Ensure we do not send more than needed to the withdrawal queue. The remaining will stay in the Eigen Pod.\n            uint256 amountToWithdraw = (i == length - 1) ? remainingAmount : operatorDepositDeallocations[i].deposits * ETH_DEPOSIT_SIZE;\n\n            remainingAmount -= amountToWithdraw;\n            roots[i] = IRioLRTOperatorDelegator(delegator).queueWithdrawalForUserSettlement(BEACON_CHAIN_STRATEGY, amountToWithdraw);\n        }\n        aggregateRoot = keccak256(abi.encode(roots));\n    }\n\n    /// @notice Queues a withdrawal from EigenLayer through the operators that are returned from the registry.\n    /// @param operatorRegistry The operator registry used allocate to and deallocate from EigenLayer operators.\n    /// @param strategy The strategy to withdraw the funds from.\n    /// @param sharesToWithdraw The number of shares to withdraw.\n    function queueTokenWithdrawalFromOperatorsForUserSettlement(\n        IRioLRTOperatorRegistry operatorRegistry,\n        address strategy,\n        uint256 sharesToWithdraw\n    ) internal returns (bytes32 aggregateRoot) {\n        (, IRioLRTOperatorRegistry.OperatorStrategyDeallocation[] memory operatorDeallocations) = operatorRegistry.deallocateStrategyShares(\n            strategy, sharesToWithdraw\n        );\n        bytes32[] memory roots = new bytes32[](operatorDeallocations.length);\n\n        uint256 sharesQueued;\n        for (uint256 i = 0; i < operatorDeallocations.length; ++i) {\n            address delegator = operatorDeallocations[i].delegator;\n            uint256 shares = operatorDeallocations[i].shares;\n\n            sharesQueued += shares;\n            roots[i] = IRioLRTOperatorDelegator(delegator).queueWithdrawalForUserSettlement(strategy, shares);\n        }\n        if (sharesToWithdraw != sharesQueued) revert INCORRECT_NUMBER_OF_SHARES_QUEUED();\n\n        aggregateRoot = keccak256(abi.encode(roots));\n    }\n}"
    }
  ]
}