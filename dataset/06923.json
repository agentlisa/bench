{
  "Title": "[M-01] deploying contracts with `forceDeployOnAddress` will break contracts when `callConstructor` is false",
  "Content": "\n<https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/ContractDeployer.sol#L212-L227><br>\n<https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/ContractDeployer.sol#L302-L306>\n\nWhen function `forceDeployOnAddress()` used for deploying contract and `callConstructor` is false, then contract's bytecodehash would stay in constructing state and calling the contract won't be possible. it can cause protocol and other contracts that are using it to break and if they call that address and sends some funds, then those funds would be lost. the issue is critical because the updated contract(which is updated by calling `forceDeployOnAddress()`) can be part of important process like bridging or sending messages or withdrawing funds.\n\n### Proof of Concept\n\nThis is `forceDeployOnAddress()` code in ContractDeployer:\n\n```solidity\n    /// @notice The method that can be used to forcefully deploy a contract.\n    /// @param _deployment Information about the forced deployment.\n    /// @param _sender The `msg.sender` inside the constructor call.\n    function forceDeployOnAddress(ForceDeployment calldata _deployment, address _sender) external payable onlySelf {\n        _ensureBytecodeIsKnown(_deployment.bytecodeHash);\n        _storeConstructingByteCodeHashOnAddress(_deployment.newAddress, _deployment.bytecodeHash);\n\n        AccountInfo memory newAccountInfo;\n        newAccountInfo.supportedAAVersion = AccountAbstractionVersion.None;\n        // Accounts have sequential nonces by default.\n        newAccountInfo.nonceOrdering = AccountNonceOrdering.Sequential;\n        _storeAccountInfo(_deployment.newAddress, newAccountInfo);\n\n        if (_deployment.callConstructor) {\n            _constructContract(_sender, _deployment.newAddress, _deployment.input, false);\n        }\n\n        emit ContractDeployed(_sender, _deployment.bytecodeHash, _deployment.newAddress);\n    }\n```\n\nAs you can see in the second line code calls `_storeConstructingByteCodeHashOnAddress()` and it would set constructing bytecode hash the address(the second byte is 1), and when `_deployment.callConstructor` is false, code won't call `_constructContract()` (which sets the address's bytecode hash as constructed after calling constructor) and contract bytecode hash would stay in constructing state after the deployment.\n\nThe constructing bytecode state is there to prevent other contracts to call this contract when this contract's constructor is called. Constructing state means that \"if anyone else call the contract, it will behaves like a contract being constructing (EmptyContract/EOA)\". so contract won't be callable if it stays in the Constructing state. This can cause serious issues, like this scenario:\n\nIf important contracts like L1Messenger, L2EthToken, MsgValueSimulator, ... needed upgrade and their code upgraded with this deployer function(and admin didn't want to call constructor as initiating the contract again would break it), then the contract logics won't be callable by others but it would still behave like EmptyContract, the transaction won't revert and other contracts logics won't get interrupted but they don't work properly, for example user would spend funds(send to the updated contract) but because logics won't get executed the funds would be lost.\n\nThe real impact may be different based on the target contract that is being deployed by this function(when `callConstructor`=false), but in each time the contract deployment would break the contract and deployment would be faulted. the issue can happen every time and using this function to upgrade system contracts without calling constructor is common. for example imagine there is a contract, that have constructor that initialize the state. It is supposed to be called only once, for the first deployment. But protocol want to redeploy contract, that state of the contract is the same as before force deployment. So they want to skip the constructing phrase.\n\n### Tools Used\n\nVIM\n\n### Recommended Mitigation Steps\n\nEven when `callConstructor` is false, and code doesn't call the constructor, code should set the address's bytecode hash to Constructed state after the deployment.\n\n**[miladpiri (zkSync) disagreed with severity and commented](https://github.com/code-423n4/2023-03-zksync-findings/issues/167#issuecomment-1484841996):**\n > The issue is real and fixed.\n> \n> The severity is **Medium**.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-03-zksync-findings/issues/167#issuecomment-1497371822):**\n > The Warden has shown how, the `forceDeployOnAddress` function allows calling a contract in a way that can brick it, because the issue is notable but reliant on a mistake, while I have considered Low Severity (user mistake), I believe Medium Severity to be the most appropriate, because the system is not behaving in the intended way.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-03-zksync",
  "Code": [
    {
      "filename": "contracts/ContractDeployer.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {ImmutableData} from \"./interfaces/IImmutableSimulator.sol\";\nimport \"./interfaces/IContractDeployer.sol\";\nimport {CREATE2_PREFIX, CREATE_PREFIX, NONCE_HOLDER_SYSTEM_CONTRACT, ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT, FORCE_DEPLOYER, MAX_SYSTEM_CONTRACT_ADDRESS, KNOWN_CODE_STORAGE_CONTRACT, ETH_TOKEN_SYSTEM_CONTRACT, IMMUTABLE_SIMULATOR_SYSTEM_CONTRACT} from \"./Constants.sol\";\n\nimport \"./libraries/Utils.sol\";\nimport \"./libraries/EfficientCall.sol\";\nimport {SystemContractHelper, ISystemContract} from \"./libraries/SystemContractHelper.sol\";\n\n/**\n * @author Matter Labs\n * @notice System smart contract that is responsible for deploying other smart contracts on zkSync.\n * @dev The contract is responsible for generating the address of the deployed smart contract,\n * incrementing the deployment nonce and making sure that the constructor is never called twice in a contract.\n * Note, contracts with bytecode that have already been published to L1 once\n * do not need to be published anymore.\n */\ncontract ContractDeployer is IContractDeployer, ISystemContract {\n    /// @notice Information about an account contract.\n    /// @dev For EOA and simple contracts (i.e. not accounts) this value is 0.\n    mapping(address => AccountInfo) internal _accountInfo;\n\n    modifier onlySelf() {\n        require(msg.sender == address(this), \"Callable only by self\");\n        _;\n    }\n\n    /// @notice Returns information about a certain account.\n    function getAccountInfo(address _address) external view returns (AccountInfo memory info) {\n        return _accountInfo[_address];\n    }\n\n    /// @notice Returns the account abstraction version if `_address` is a deployed contract.\n    /// Returns the latest supported account abstraction version if `_address` is an EOA.\n    function extendedAccountVersion(address _address) public view returns (AccountAbstractionVersion) {\n        AccountInfo memory info = _accountInfo[_address];\n        if (info.supportedAAVersion != AccountAbstractionVersion.None) {\n            return info.supportedAAVersion;\n        }\n\n        // It is an EOA, it is still an account.\n        if (ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT.getRawCodeHash(_address) == 0) {\n            return AccountAbstractionVersion.Version1;\n        }\n\n        return AccountAbstractionVersion.None;\n    }\n\n    /// @notice Stores the new account information\n    function _storeAccountInfo(address _address, AccountInfo memory _newInfo) internal {\n        _accountInfo[_address] = _newInfo;\n    }\n\n    /// @notice Update the used version of the account.\n    /// @param _version The new version of the AA protocol to use.\n    /// @dev Note that it allows changes from account to non-account and vice versa.\n    function updateAccountVersion(AccountAbstractionVersion _version) external onlySystemCall {\n        _accountInfo[msg.sender].supportedAAVersion = _version;\n\n        emit AccountVersionUpdated(msg.sender, _version);\n    }\n\n    /// @notice Updates the nonce ordering of the account. Currently,\n    /// it only allows changes from sequential to arbitrary ordering.\n    /// @param _nonceOrdering The new nonce ordering to use.\n    function updateNonceOrdering(AccountNonceOrdering _nonceOrdering) external onlySystemCall {\n        AccountInfo memory currentInfo = _accountInfo[msg.sender];\n\n        require(\n            _nonceOrdering == AccountNonceOrdering.Arbitrary &&\n                currentInfo.nonceOrdering == AccountNonceOrdering.Sequential,\n            \"It is only possible to change from sequential to arbitrary ordering\"\n        );\n\n        currentInfo.nonceOrdering = _nonceOrdering;\n        _storeAccountInfo(msg.sender, currentInfo);\n\n        emit AccountNonceOrderingUpdated(msg.sender, _nonceOrdering);\n    }\n\n    /// @notice Calculates the address of a deployed contract via create2\n    /// @param _sender The account that deploys the contract.\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _salt The create2 salt.\n    /// @param _input The constructor data.\n    /// @return newAddress The derived address of the account.\n    function getNewAddressCreate2(\n        address _sender,\n        bytes32 _bytecodeHash,\n        bytes32 _salt,\n        bytes calldata _input\n    ) public view override returns (address newAddress) {\n        // No collision is possible with the Ethereum's CREATE2, since\n        // the prefix begins with 0x20....\n        bytes32 constructorInputHash = EfficientCall.keccak(_input);\n\n        bytes32 hash = keccak256(\n            bytes.concat(CREATE2_PREFIX, bytes32(uint256(uint160(_sender))), _salt, _bytecodeHash, constructorInputHash)\n        );\n\n        newAddress = address(uint160(uint256(hash)));\n    }\n\n    /// @notice Calculates the address of a deployed contract via create\n    /// @param _sender The account that deploys the contract.\n    /// @param _senderNonce The deploy nonce of the sender's account.\n    function getNewAddressCreate(\n        address _sender,\n        uint256 _senderNonce\n    ) public pure override returns (address newAddress) {\n        // No collision is possible with the Ethereum's CREATE, since\n        // the prefix begins with 0x63....\n        bytes32 hash = keccak256(\n            bytes.concat(CREATE_PREFIX, bytes32(uint256(uint160(_sender))), bytes32(_senderNonce))\n        );\n\n        newAddress = address(uint160(uint256(hash)));\n    }\n\n    /// @notice Deploys a contract with similar address derivation rules to the EVM's `CREATE2` opcode.\n    /// @param _salt The CREATE2 salt\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _input The constructor calldata\n    /// @dev In case of a revert, the zero address should be returned.\n    function create2(\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes calldata _input\n    ) external payable override returns (address) {\n        return create2Account(_salt, _bytecodeHash, _input, AccountAbstractionVersion.None);\n    }\n\n    /// @notice Deploys a contract with similar address derivation rules to the EVM's `CREATE` opcode.\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _input The constructor calldata\n    /// @dev This method also accepts nonce as one of its parameters.\n    /// It is not used anywhere and it needed simply for the consistency for the compiler\n    /// @dev In case of a revert, the zero address should be returned.\n    /// Note: this method may be callable only in system mode,\n    /// that is checked in the `createAccount` by `onlySystemCall` modifier.\n    function create(\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes calldata _input\n    ) external payable override returns (address) {\n        return createAccount(_salt, _bytecodeHash, _input, AccountAbstractionVersion.None);\n    }\n\n    /// @notice Deploys a contract account with similar address derivation rules to the EVM's `CREATE2` opcode.\n    /// @param _salt The CREATE2 salt\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _input The constructor calldata.\n    /// @param _aaVersion The account abstraction version to use.\n    /// @dev In case of a revert, the zero address should be returned.\n    /// Note: this method may be callable only in system mode,\n    /// that is checked in the `createAccount` by `onlySystemCall` modifier.\n    function create2Account(\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes calldata _input,\n        AccountAbstractionVersion _aaVersion\n    ) public payable override onlySystemCall returns (address) {\n        NONCE_HOLDER_SYSTEM_CONTRACT.incrementDeploymentNonce(msg.sender);\n        address newAddress = getNewAddressCreate2(msg.sender, _bytecodeHash, _salt, _input);\n\n        _nonSystemDeployOnAddress(_bytecodeHash, newAddress, _aaVersion, _input);\n\n        return newAddress;\n    }\n\n    /// @notice Deploys a contract account with similar address derivation rules to the EVM's `CREATE` opcode.\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _input The constructor calldata.\n    /// @param _aaVersion The account abstraction version to use.\n    /// @dev This method also accepts salt as one of its parameters.\n    /// It is not used anywhere and it needed simply for the consistency for the compiler\n    /// @dev In case of a revert, the zero address should be returned.\n    function createAccount(\n        bytes32, // salt\n        bytes32 _bytecodeHash,\n        bytes calldata _input,\n        AccountAbstractionVersion _aaVersion\n    ) public payable override onlySystemCall returns (address) {\n        uint256 senderNonce = NONCE_HOLDER_SYSTEM_CONTRACT.incrementDeploymentNonce(msg.sender);\n        address newAddress = getNewAddressCreate(msg.sender, senderNonce);\n\n        _nonSystemDeployOnAddress(_bytecodeHash, newAddress, _aaVersion, _input);\n\n        return newAddress;\n    }\n\n    /// @notice A struct that describes a forced deployment on an address\n    struct ForceDeployment {\n        // The bytecode hash to put on an address\n        bytes32 bytecodeHash;\n        // The address on which to deploy the bytecodehash to\n        address newAddress;\n        // Whether to run the constructor on the force deployment\n        bool callConstructor;\n        // The value with which to initialize a contract\n        uint256 value;\n        // The constructor calldata\n        bytes input;\n    }\n\n    /// @notice The method that can be used to forcefully deploy a contract.\n    /// @param _deployment Information about the forced deployment.\n    /// @param _sender The `msg.sender` inside the constructor call.\n    function forceDeployOnAddress(ForceDeployment calldata _deployment, address _sender) external payable onlySelf {\n        _ensureBytecodeIsKnown(_deployment.bytecodeHash);\n        _storeConstructingByteCodeHashOnAddress(_deployment.newAddress, _deployment.bytecodeHash);\n\n        AccountInfo memory newAccountInfo;\n        newAccountInfo.supportedAAVersion = AccountAbstractionVersion.None;\n        // Accounts have sequential nonces by default.\n        newAccountInfo.nonceOrdering = AccountNonceOrdering.Sequential;\n        _storeAccountInfo(_deployment.newAddress, newAccountInfo);\n\n        if (_deployment.callConstructor) {\n            _constructContract(_sender, _deployment.newAddress, _deployment.input, false);\n        }\n\n        emit ContractDeployed(_sender, _deployment.bytecodeHash, _deployment.newAddress);\n    }\n\n    /// @notice This method is to be used only during an upgrade to set bytecodes on specific addresses.\n    /// @dev We do not require `onlySystemCall` here, since the method is accessible only\n    /// by `FORCE_DEPLOYER`.\n    function forceDeployOnAddresses(ForceDeployment[] calldata _deployments) external payable {\n        require(msg.sender == FORCE_DEPLOYER, \"Can only be called by FORCE_DEPLOYER_CONTRACT\");\n\n        uint256 deploymentsLength = _deployments.length;\n        // We need to ensure that the `value` provided by the call is enough to provide `value`\n        // for all of the deployments\n        uint256 sumOfValues = 0;\n        for (uint256 i = 0; i < deploymentsLength; ++i) {\n            sumOfValues += _deployments[i].value;\n        }\n        require(msg.value == sumOfValues, \"`value` provided is not equal to the combined `value`s of deployments\");\n\n        for (uint256 i = 0; i < deploymentsLength; ++i) {\n            this.forceDeployOnAddress{value: _deployments[i].value}(_deployments[i], msg.sender);\n        }\n    }\n\n    function _nonSystemDeployOnAddress(\n        bytes32 _bytecodeHash,\n        address _newAddress,\n        AccountAbstractionVersion _aaVersion,\n        bytes calldata _input\n    ) internal {\n        require(_bytecodeHash != bytes32(0x0), \"BytecodeHash can not be zero\");\n        require(uint160(_newAddress) > MAX_SYSTEM_CONTRACT_ADDRESS, \"Can not deploy contracts in kernel space\");\n\n        // We do not allow deploying twice on the same address.\n        require(\n            ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT.getCodeHash(uint256(uint160(_newAddress))) == 0x0,\n            \"Code hash is non-zero\"\n        );\n        // Do not allow deploying contracts to default accounts that have already executed transactions.\n        require(NONCE_HOLDER_SYSTEM_CONTRACT.getRawNonce(_newAddress) == 0x00, \"Account is occupied\");\n\n        _performDeployOnAddress(_bytecodeHash, _newAddress, _aaVersion, _input);\n    }\n\n    /// @notice Deploy a certain bytecode on the address.\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _newAddress The address of the contract to be deployed.\n    /// @param _aaVersion The version of the account abstraction protocol to use.\n    /// @param _input The constructor calldata.\n    function _performDeployOnAddress(\n        bytes32 _bytecodeHash,\n        address _newAddress,\n        AccountAbstractionVersion _aaVersion,\n        bytes calldata _input\n    ) internal {\n        _ensureBytecodeIsKnown(_bytecodeHash);\n        _storeConstructingByteCodeHashOnAddress(_newAddress, _bytecodeHash);\n\n        AccountInfo memory newAccountInfo;\n        newAccountInfo.supportedAAVersion = _aaVersion;\n        // Accounts have sequential nonces by default.\n        newAccountInfo.nonceOrdering = AccountNonceOrdering.Sequential;\n        _storeAccountInfo(_newAddress, newAccountInfo);\n\n        _constructContract(msg.sender, _newAddress, _input, false);\n        emit ContractDeployed(msg.sender, _bytecodeHash, _newAddress);\n    }\n\n    /// @notice Check that bytecode hash is marked as known on the `KnownCodeStorage` system contracts\n    function _ensureBytecodeIsKnown(bytes32 _bytecodeHash) internal view {\n        uint256 knownCodeMarker = KNOWN_CODE_STORAGE_CONTRACT.getMarker(_bytecodeHash);\n        require(knownCodeMarker > 0, \"The code hash is not known\");\n    }\n\n    /// @notice Ensures that the _newAddress and assigns a new contract hash to it\n    /// @param _newAddress The address of the deployed contract\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    function _storeConstructingByteCodeHashOnAddress(address _newAddress, bytes32 _bytecodeHash) internal {\n        // Set the \"isConstructor\" flag to the bytecode hash\n        bytes32 constructingBytecodeHash = Utils.constructingBytecodeHash(_bytecodeHash);\n        ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT.storeAccountConstructingCodeHash(_newAddress, constructingBytecodeHash);\n    }\n\n    /// @notice Transfers the `msg.value` ETH to the deployed account & invokes its constructor.\n    /// This function must revert in case the deployment fails.\n    /// @param _sender The msg.sender to be used in the constructor\n    /// @param _newAddress The address of the deployed contract\n    /// @param _input The constructor calldata\n    /// @param _isSystem Whether the call should be a system call (could be possibly required in the future).\n    function _constructContract(address _sender, address _newAddress, bytes calldata _input, bool _isSystem) internal {\n        // Transfer the balance to the new address on the constructor call.\n        uint256 value = msg.value;\n        if (value > 0) {\n            ETH_TOKEN_SYSTEM_CONTRACT.transferFromTo(address(this), _newAddress, value);\n            // Safe to cast value, because `msg.value` <= `uint128.max` due to `MessageValueSimulator` invariant\n            SystemContractHelper.setValueForNextFarCall(uint128(value));\n        }\n\n        bytes memory returnData = EfficientCall.mimicCall(gasleft(), _newAddress, _input, _sender, true, _isSystem);\n        ImmutableData[] memory immutables = abi.decode(returnData, (ImmutableData[]));\n        IMMUTABLE_SIMULATOR_SYSTEM_CONTRACT.setImmutables(_newAddress, immutables);\n        ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT.markAccountCodeHashAsConstructed(_newAddress);\n    }\n}"
    },
    {
      "filename": "contracts/ContractDeployer.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {ImmutableData} from \"./interfaces/IImmutableSimulator.sol\";\nimport \"./interfaces/IContractDeployer.sol\";\nimport {CREATE2_PREFIX, CREATE_PREFIX, NONCE_HOLDER_SYSTEM_CONTRACT, ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT, FORCE_DEPLOYER, MAX_SYSTEM_CONTRACT_ADDRESS, KNOWN_CODE_STORAGE_CONTRACT, ETH_TOKEN_SYSTEM_CONTRACT, IMMUTABLE_SIMULATOR_SYSTEM_CONTRACT} from \"./Constants.sol\";\n\nimport \"./libraries/Utils.sol\";\nimport \"./libraries/EfficientCall.sol\";\nimport {SystemContractHelper, ISystemContract} from \"./libraries/SystemContractHelper.sol\";\n\n/**\n * @author Matter Labs\n * @notice System smart contract that is responsible for deploying other smart contracts on zkSync.\n * @dev The contract is responsible for generating the address of the deployed smart contract,\n * incrementing the deployment nonce and making sure that the constructor is never called twice in a contract.\n * Note, contracts with bytecode that have already been published to L1 once\n * do not need to be published anymore.\n */\ncontract ContractDeployer is IContractDeployer, ISystemContract {\n    /// @notice Information about an account contract.\n    /// @dev For EOA and simple contracts (i.e. not accounts) this value is 0.\n    mapping(address => AccountInfo) internal _accountInfo;\n\n    modifier onlySelf() {\n        require(msg.sender == address(this), \"Callable only by self\");\n        _;\n    }\n\n    /// @notice Returns information about a certain account.\n    function getAccountInfo(address _address) external view returns (AccountInfo memory info) {\n        return _accountInfo[_address];\n    }\n\n    /// @notice Returns the account abstraction version if `_address` is a deployed contract.\n    /// Returns the latest supported account abstraction version if `_address` is an EOA.\n    function extendedAccountVersion(address _address) public view returns (AccountAbstractionVersion) {\n        AccountInfo memory info = _accountInfo[_address];\n        if (info.supportedAAVersion != AccountAbstractionVersion.None) {\n            return info.supportedAAVersion;\n        }\n\n        // It is an EOA, it is still an account.\n        if (ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT.getRawCodeHash(_address) == 0) {\n            return AccountAbstractionVersion.Version1;\n        }\n\n        return AccountAbstractionVersion.None;\n    }\n\n    /// @notice Stores the new account information\n    function _storeAccountInfo(address _address, AccountInfo memory _newInfo) internal {\n        _accountInfo[_address] = _newInfo;\n    }\n\n    /// @notice Update the used version of the account.\n    /// @param _version The new version of the AA protocol to use.\n    /// @dev Note that it allows changes from account to non-account and vice versa.\n    function updateAccountVersion(AccountAbstractionVersion _version) external onlySystemCall {\n        _accountInfo[msg.sender].supportedAAVersion = _version;\n\n        emit AccountVersionUpdated(msg.sender, _version);\n    }\n\n    /// @notice Updates the nonce ordering of the account. Currently,\n    /// it only allows changes from sequential to arbitrary ordering.\n    /// @param _nonceOrdering The new nonce ordering to use.\n    function updateNonceOrdering(AccountNonceOrdering _nonceOrdering) external onlySystemCall {\n        AccountInfo memory currentInfo = _accountInfo[msg.sender];\n\n        require(\n            _nonceOrdering == AccountNonceOrdering.Arbitrary &&\n                currentInfo.nonceOrdering == AccountNonceOrdering.Sequential,\n            \"It is only possible to change from sequential to arbitrary ordering\"\n        );\n\n        currentInfo.nonceOrdering = _nonceOrdering;\n        _storeAccountInfo(msg.sender, currentInfo);\n\n        emit AccountNonceOrderingUpdated(msg.sender, _nonceOrdering);\n    }\n\n    /// @notice Calculates the address of a deployed contract via create2\n    /// @param _sender The account that deploys the contract.\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _salt The create2 salt.\n    /// @param _input The constructor data.\n    /// @return newAddress The derived address of the account.\n    function getNewAddressCreate2(\n        address _sender,\n        bytes32 _bytecodeHash,\n        bytes32 _salt,\n        bytes calldata _input\n    ) public view override returns (address newAddress) {\n        // No collision is possible with the Ethereum's CREATE2, since\n        // the prefix begins with 0x20....\n        bytes32 constructorInputHash = EfficientCall.keccak(_input);\n\n        bytes32 hash = keccak256(\n            bytes.concat(CREATE2_PREFIX, bytes32(uint256(uint160(_sender))), _salt, _bytecodeHash, constructorInputHash)\n        );\n\n        newAddress = address(uint160(uint256(hash)));\n    }\n\n    /// @notice Calculates the address of a deployed contract via create\n    /// @param _sender The account that deploys the contract.\n    /// @param _senderNonce The deploy nonce of the sender's account.\n    function getNewAddressCreate(\n        address _sender,\n        uint256 _senderNonce\n    ) public pure override returns (address newAddress) {\n        // No collision is possible with the Ethereum's CREATE, since\n        // the prefix begins with 0x63....\n        bytes32 hash = keccak256(\n            bytes.concat(CREATE_PREFIX, bytes32(uint256(uint160(_sender))), bytes32(_senderNonce))\n        );\n\n        newAddress = address(uint160(uint256(hash)));\n    }\n\n    /// @notice Deploys a contract with similar address derivation rules to the EVM's `CREATE2` opcode.\n    /// @param _salt The CREATE2 salt\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _input The constructor calldata\n    /// @dev In case of a revert, the zero address should be returned.\n    function create2(\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes calldata _input\n    ) external payable override returns (address) {\n        return create2Account(_salt, _bytecodeHash, _input, AccountAbstractionVersion.None);\n    }\n\n    /// @notice Deploys a contract with similar address derivation rules to the EVM's `CREATE` opcode.\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _input The constructor calldata\n    /// @dev This method also accepts nonce as one of its parameters.\n    /// It is not used anywhere and it needed simply for the consistency for the compiler\n    /// @dev In case of a revert, the zero address should be returned.\n    /// Note: this method may be callable only in system mode,\n    /// that is checked in the `createAccount` by `onlySystemCall` modifier.\n    function create(\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes calldata _input\n    ) external payable override returns (address) {\n        return createAccount(_salt, _bytecodeHash, _input, AccountAbstractionVersion.None);\n    }\n\n    /// @notice Deploys a contract account with similar address derivation rules to the EVM's `CREATE2` opcode.\n    /// @param _salt The CREATE2 salt\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _input The constructor calldata.\n    /// @param _aaVersion The account abstraction version to use.\n    /// @dev In case of a revert, the zero address should be returned.\n    /// Note: this method may be callable only in system mode,\n    /// that is checked in the `createAccount` by `onlySystemCall` modifier.\n    function create2Account(\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes calldata _input,\n        AccountAbstractionVersion _aaVersion\n    ) public payable override onlySystemCall returns (address) {\n        NONCE_HOLDER_SYSTEM_CONTRACT.incrementDeploymentNonce(msg.sender);\n        address newAddress = getNewAddressCreate2(msg.sender, _bytecodeHash, _salt, _input);\n\n        _nonSystemDeployOnAddress(_bytecodeHash, newAddress, _aaVersion, _input);\n\n        return newAddress;\n    }\n\n    /// @notice Deploys a contract account with similar address derivation rules to the EVM's `CREATE` opcode.\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _input The constructor calldata.\n    /// @param _aaVersion The account abstraction version to use.\n    /// @dev This method also accepts salt as one of its parameters.\n    /// It is not used anywhere and it needed simply for the consistency for the compiler\n    /// @dev In case of a revert, the zero address should be returned.\n    function createAccount(\n        bytes32, // salt\n        bytes32 _bytecodeHash,\n        bytes calldata _input,\n        AccountAbstractionVersion _aaVersion\n    ) public payable override onlySystemCall returns (address) {\n        uint256 senderNonce = NONCE_HOLDER_SYSTEM_CONTRACT.incrementDeploymentNonce(msg.sender);\n        address newAddress = getNewAddressCreate(msg.sender, senderNonce);\n\n        _nonSystemDeployOnAddress(_bytecodeHash, newAddress, _aaVersion, _input);\n\n        return newAddress;\n    }\n\n    /// @notice A struct that describes a forced deployment on an address\n    struct ForceDeployment {\n        // The bytecode hash to put on an address\n        bytes32 bytecodeHash;\n        // The address on which to deploy the bytecodehash to\n        address newAddress;\n        // Whether to run the constructor on the force deployment\n        bool callConstructor;\n        // The value with which to initialize a contract\n        uint256 value;\n        // The constructor calldata\n        bytes input;\n    }\n\n    /// @notice The method that can be used to forcefully deploy a contract.\n    /// @param _deployment Information about the forced deployment.\n    /// @param _sender The `msg.sender` inside the constructor call.\n    function forceDeployOnAddress(ForceDeployment calldata _deployment, address _sender) external payable onlySelf {\n        _ensureBytecodeIsKnown(_deployment.bytecodeHash);\n        _storeConstructingByteCodeHashOnAddress(_deployment.newAddress, _deployment.bytecodeHash);\n\n        AccountInfo memory newAccountInfo;\n        newAccountInfo.supportedAAVersion = AccountAbstractionVersion.None;\n        // Accounts have sequential nonces by default.\n        newAccountInfo.nonceOrdering = AccountNonceOrdering.Sequential;\n        _storeAccountInfo(_deployment.newAddress, newAccountInfo);\n\n        if (_deployment.callConstructor) {\n            _constructContract(_sender, _deployment.newAddress, _deployment.input, false);\n        }\n\n        emit ContractDeployed(_sender, _deployment.bytecodeHash, _deployment.newAddress);\n    }\n\n    /// @notice This method is to be used only during an upgrade to set bytecodes on specific addresses.\n    /// @dev We do not require `onlySystemCall` here, since the method is accessible only\n    /// by `FORCE_DEPLOYER`.\n    function forceDeployOnAddresses(ForceDeployment[] calldata _deployments) external payable {\n        require(msg.sender == FORCE_DEPLOYER, \"Can only be called by FORCE_DEPLOYER_CONTRACT\");\n\n        uint256 deploymentsLength = _deployments.length;\n        // We need to ensure that the `value` provided by the call is enough to provide `value`\n        // for all of the deployments\n        uint256 sumOfValues = 0;\n        for (uint256 i = 0; i < deploymentsLength; ++i) {\n            sumOfValues += _deployments[i].value;\n        }\n        require(msg.value == sumOfValues, \"`value` provided is not equal to the combined `value`s of deployments\");\n\n        for (uint256 i = 0; i < deploymentsLength; ++i) {\n            this.forceDeployOnAddress{value: _deployments[i].value}(_deployments[i], msg.sender);\n        }\n    }\n\n    function _nonSystemDeployOnAddress(\n        bytes32 _bytecodeHash,\n        address _newAddress,\n        AccountAbstractionVersion _aaVersion,\n        bytes calldata _input\n    ) internal {\n        require(_bytecodeHash != bytes32(0x0), \"BytecodeHash can not be zero\");\n        require(uint160(_newAddress) > MAX_SYSTEM_CONTRACT_ADDRESS, \"Can not deploy contracts in kernel space\");\n\n        // We do not allow deploying twice on the same address.\n        require(\n            ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT.getCodeHash(uint256(uint160(_newAddress))) == 0x0,\n            \"Code hash is non-zero\"\n        );\n        // Do not allow deploying contracts to default accounts that have already executed transactions.\n        require(NONCE_HOLDER_SYSTEM_CONTRACT.getRawNonce(_newAddress) == 0x00, \"Account is occupied\");\n\n        _performDeployOnAddress(_bytecodeHash, _newAddress, _aaVersion, _input);\n    }\n\n    /// @notice Deploy a certain bytecode on the address.\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    /// @param _newAddress The address of the contract to be deployed.\n    /// @param _aaVersion The version of the account abstraction protocol to use.\n    /// @param _input The constructor calldata.\n    function _performDeployOnAddress(\n        bytes32 _bytecodeHash,\n        address _newAddress,\n        AccountAbstractionVersion _aaVersion,\n        bytes calldata _input\n    ) internal {\n        _ensureBytecodeIsKnown(_bytecodeHash);\n        _storeConstructingByteCodeHashOnAddress(_newAddress, _bytecodeHash);\n\n        AccountInfo memory newAccountInfo;\n        newAccountInfo.supportedAAVersion = _aaVersion;\n        // Accounts have sequential nonces by default.\n        newAccountInfo.nonceOrdering = AccountNonceOrdering.Sequential;\n        _storeAccountInfo(_newAddress, newAccountInfo);\n\n        _constructContract(msg.sender, _newAddress, _input, false);\n        emit ContractDeployed(msg.sender, _bytecodeHash, _newAddress);\n    }\n\n    /// @notice Check that bytecode hash is marked as known on the `KnownCodeStorage` system contracts\n    function _ensureBytecodeIsKnown(bytes32 _bytecodeHash) internal view {\n        uint256 knownCodeMarker = KNOWN_CODE_STORAGE_CONTRACT.getMarker(_bytecodeHash);\n        require(knownCodeMarker > 0, \"The code hash is not known\");\n    }\n\n    /// @notice Ensures that the _newAddress and assigns a new contract hash to it\n    /// @param _newAddress The address of the deployed contract\n    /// @param _bytecodeHash The correctly formatted hash of the bytecode.\n    function _storeConstructingByteCodeHashOnAddress(address _newAddress, bytes32 _bytecodeHash) internal {\n        // Set the \"isConstructor\" flag to the bytecode hash\n        bytes32 constructingBytecodeHash = Utils.constructingBytecodeHash(_bytecodeHash);\n        ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT.storeAccountConstructingCodeHash(_newAddress, constructingBytecodeHash);\n    }\n\n    /// @notice Transfers the `msg.value` ETH to the deployed account & invokes its constructor.\n    /// This function must revert in case the deployment fails.\n    /// @param _sender The msg.sender to be used in the constructor\n    /// @param _newAddress The address of the deployed contract\n    /// @param _input The constructor calldata\n    /// @param _isSystem Whether the call should be a system call (could be possibly required in the future).\n    function _constructContract(address _sender, address _newAddress, bytes calldata _input, bool _isSystem) internal {\n        // Transfer the balance to the new address on the constructor call.\n        uint256 value = msg.value;\n        if (value > 0) {\n            ETH_TOKEN_SYSTEM_CONTRACT.transferFromTo(address(this), _newAddress, value);\n            // Safe to cast value, because `msg.value` <= `uint128.max` due to `MessageValueSimulator` invariant\n            SystemContractHelper.setValueForNextFarCall(uint128(value));\n        }\n\n        bytes memory returnData = EfficientCall.mimicCall(gasleft(), _newAddress, _input, _sender, true, _isSystem);\n        ImmutableData[] memory immutables = abi.decode(returnData, (ImmutableData[]));\n        IMMUTABLE_SIMULATOR_SYSTEM_CONTRACT.setImmutables(_newAddress, immutables);\n        ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT.markAccountCodeHashAsConstructed(_newAddress);\n    }\n}"
    }
  ]
}