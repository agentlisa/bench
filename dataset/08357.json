{
  "Title": "[M-09] `GolomToken.sol` doesn't contain a function to mint treasury tokens",
  "Content": "\n[GolomToken.sol#L14-L73](https://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/governance/GolomToken.sol#L14-L73)<br>\n\nPotential downtime in GolomTrader\n\n### Proof of Concept\n\nGolomToken.sol doesn't have a function to mint the treasury tokens as specified in the docs (<https://docs.golom.io/tokenomics-and-airdrop>). In order for these tokens to be minted, the minter would have to be changed via `setMinter()` and `executeSetMinter()` to a contract that can mint the treasury tokens. Because of the 24 hour timelock, this would lead to downtime for GolomTrader.sol if trading has already begun. This is because GolomTrader.sol calls `RewardDistributor.sol#addFees` each time there is a filled order. When the epoch changes, RewardDistributor.sol will try to call the mint function in GolomToken.sol. Because of the timelock, there will be at least a 24 hours period where RewardDistributor.sol is not the minter and doesn't have the permission to mint. This means that during that period all trades will revert.\n\n### Recommended Mitigation Steps\n\nAdd a function to GolomToken.sol to mint the treasury tokens similar to the `mintAirdrop()` and `mintGenesisReward()` functions.\n\n**[0xsaruman (Golom) confirmed, but disagreed with severity](https://github.com/code-423n4/2022-07-golom-findings/issues/205)**\n\n**[0xsaruman (Golom) resolved and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/205#issuecomment-1236300333):**\n > https://github.com/golom-protocol/contracts/commit/746507ea6f71a017be178f7eeb66d2dbf92a4524\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-07-golom-contest",
  "Code": [
    {
      "filename": "contracts/governance/GolomToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\n/// @title Golom ERC20 governance token\n/// @notice Explain to an end user what this does\n/// @dev Implements ERC20, ERC20Votes and ERC20Permits from OpenZepellin\n\n// Tokens are minted on the initial mint\n// Additionally mint function is called to mint the tokens, only the reward distributor contract will be able to mint the token\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol';\n\ncontract GolomToken is ERC20Votes, Ownable {\n    address public minter;\n\n    uint256 public minterEnableDate;\n    address public pendingMinter;\n\n    bool public isAirdropMinted;\n    bool public isGenesisRewardMinted;\n\n    modifier onlyMinter() {\n        require(msg.sender == minter, 'GolomToken: only reward distributor can enable');\n        _;\n    }\n\n    constructor(address _governance) ERC20('Golom', 'GOL') ERC20Permit('Golom') {\n        _transferOwnership(_governance); // set the new owner\n    }\n\n    /// @notice Mints the tokens\n    /// @dev only minter can mint the tokens, minter will be RewardDistributor.sol\n    /// @param _account Address where the tokens will be minted\n    /// @param _amount Number of tokens to be minted\n    function mint(address _account, uint256 _amount) external onlyMinter {\n        _mint(_account, _amount);\n    }\n\n    /// @notice Mints 150M for the airdrop\n    /// @param _airdrop Airdrop contract\n    function mintAirdrop(address _airdrop) external onlyOwner {\n        require(!isAirdropMinted, 'already minted');\n        _mint(_airdrop, 150_000_000 * 1e18);\n        isAirdropMinted = true;\n    }\n\n    /// @notice Mint Genesis Reward\n    /// @param _rewardDistributor Address of the rewardDistributor\n    function mintGenesisReward(address _rewardDistributor) external onlyOwner {\n        require(!isGenesisRewardMinted, 'already minted');\n        _mint(_rewardDistributor, 62_500_000 * 1e18);\n        isGenesisRewardMinted = true;\n    }\n\n    /// @notice sets the minter with timelock, once setup admin needs to call executeSetMinter()\n    /// @param _minter Address of the new minter\n    function setMinter(address _minter) external onlyOwner {\n        pendingMinter = _minter;\n        minterEnableDate = block.timestamp + 1 days;\n    }\n\n    /// @notice Executes the set minter function after the timelock\n    /// @dev If being called first time, there won't be any timelock\n    function executeSetMinter() external onlyOwner {\n        if (minter == address(0)) {\n            minter = pendingMinter;\n        } else {\n            require(minterEnableDate <= block.timestamp, 'GolomToken: wait for timelock');\n            minter = pendingMinter;\n        }\n    }\n}"
    }
  ]
}