{
  "Title": "GaugeExtraRewarder's Reward Rate Can Be Set to an Arbitrary Value",
  "Content": "The owner of the [`GaugeExtraRewarder`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/GaugeExtraRewarder.sol) contract is able to [set an arbitrary value as reward rate](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/GaugeExtraRewarder.sol#L113-L116). However, the reward rate should always be [calculated based on the existing reward amount and the distribution period](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/GaugeExtraRewarder.sol#L129) otherwise inconsistent accounting is possible, resulting in unfair rewards distribution among the users.\n\n\nConsider removing the function [`setRewardPerSecond`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/GaugeExtraRewarder.sol#L113) and always using [`setDistributionRate`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/GaugeExtraRewarder.sol#L119) instead in order to avoid inconsistent rewards accounting.\n\n\n***Update:** Resolved in [pull request #4](https://github.com/ThenafiBNB/THENA-Contracts/pull/4) at commit [e8b757f](https://github.com/ThenafiBNB/THENA-Contracts/pull/4/commits/e8b757fa98edaeebca3da564ced94586f7a70e38).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/GaugeExtraRewarder.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./libraries/SignedSafeMath.sol\";\n\n\ninterface IRewarder {\n    function onReward(uint256 pid, address user, address recipient, uint256 lqdrAmount, uint256 newLpAmount) external;\n    function pendingTokens(uint256 pid, address user, uint256 lqdrAmount) external view returns (IERC20[] memory, uint256[] memory);\n}\n\ninterface IGauge {\n    function TOKEN() external view returns(address);\n}\n\n\ncontract GaugeExtraRewarder is Ownable {\n\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    bool public stop = false;\n\n    IERC20 public immutable rewardToken;\n\n    /// @notice Info of each user.\n    struct UserInfo {\n        uint256 amount;\n        int256 rewardDebt;\n    }\n\n    /// @notice Struct of pool info\n   \n    struct PoolInfo {\n        uint256 accRewardPerShare;\n        uint256 lastRewardTime;\n    }\n\n    /// @notice pool info\n    PoolInfo public poolInfo;\n\n    /// @notice Info of each user that stakes tokens.\n    mapping(address => UserInfo) public userInfo;\n\n    uint public lastDistributedTime;\n    uint public rewardPerSecond;\n    uint public distributePeriod = 86400 * 7;\n    uint public ACC_TOKEN_PRECISION = 1e12;\n\n\n    address private immutable GAUGE;\n\n    event LogOnReward(address indexed user, uint256 indexed pid, uint256 amount, address indexed to);\n\n    constructor (IERC20 _rewardToken, address gauge) {\n        rewardToken = _rewardToken;\n        poolInfo = PoolInfo({\n            lastRewardTime: block.timestamp,\n            accRewardPerShare: 0\n        });\n        GAUGE = gauge;\n    }\n\n\n    function onReward(uint256 /*pid*/, address _user, address to, uint256 /*extraData*/, uint256 lpToken) onlyGauge external {\n        if(stop) return;\n        PoolInfo memory pool = updatePool();\n        UserInfo storage user = userInfo[_user];\n        uint256 pending;\n        uint256 accRewardPerShare = pool.accRewardPerShare;\n        if (user.amount > 0) {\n            pending = int256( user.amount.mul(accRewardPerShare) / ACC_TOKEN_PRECISION ).sub(user.rewardDebt).toUInt256();\n            rewardToken.safeTransfer(to, pending);\n        }\n        user.amount = lpToken;\n        user.rewardDebt = int256(lpToken.mul(pool.accRewardPerShare) / ACC_TOKEN_PRECISION);\n    }\n\n\n    /// @notice View function to see pending WBNB on frontend.\n    /// @param _user Address of user.\n    /// @return pending rewardToken reward for a given user.\n    function pendingReward(address _user) external view returns (uint256 pending){\n        PoolInfo memory pool = poolInfo;\n        UserInfo storage user = userInfo[_user];\n        uint256 accRewardPerShare = pool.accRewardPerShare;\n        uint256 lpSupply = IERC20(IGauge(GAUGE).TOKEN()).balanceOf(GAUGE);\n\n        if (block.timestamp > pool.lastRewardTime && lpSupply != 0) {\n            uint256 time = block.timestamp.sub(pool.lastRewardTime);\n            uint256 reward = time.mul(rewardPerSecond);\n            accRewardPerShare = accRewardPerShare.add( reward.mul(ACC_TOKEN_PRECISION) / lpSupply );\n        }\n        pending = int256( user.amount.mul(accRewardPerShare) / ACC_TOKEN_PRECISION ).sub(user.rewardDebt).toUInt256();\n    }\n\n\n    modifier onlyGauge {\n        require(msg.sender == GAUGE,\"!GAUGE\");\n        _;\n    }\n\n\n\n    /// @notice Sets the reward per second to be distributed. Can only be called by the owner.\n    /// @param _rewardPerSecond The amount of Reward to be distributed per second.\n    function setRewardPerSecond(uint256 _rewardPerSecond) public onlyOwner {\n        updatePool();\n        rewardPerSecond = _rewardPerSecond;\n    }\n\n\n    function setDistributionRate(uint256 amount) public onlyOwner {\n        updatePool();\n        require(IERC20(rewardToken).balanceOf(address(this)) >= amount);\n        uint256 notDistributed;\n        if (lastDistributedTime > 0 && block.timestamp < lastDistributedTime) {\n            uint256 timeLeft = lastDistributedTime.sub(block.timestamp);\n            notDistributed = rewardPerSecond.mul(timeLeft);\n        }\n\n        amount = amount.add(notDistributed);\n        uint256 _rewardPerSecond = amount.div(distributePeriod);\n        rewardPerSecond = _rewardPerSecond;\n        lastDistributedTime = block.timestamp.add(distributePeriod);\n    }\n\n\n\n    /// @notice Update reward variables of the given pool.\n    /// @return pool Returns the pool that was updated.\n    function updatePool() public returns (PoolInfo memory pool) {\n        pool = poolInfo;\n\n        if (block.timestamp > pool.lastRewardTime) {\n            uint256 lpSupply = IERC20(IGauge(GAUGE).TOKEN()).balanceOf(GAUGE);\n            if (lpSupply > 0) {\n                uint256 time = block.timestamp.sub(pool.lastRewardTime);\n                uint256 reward = time.mul(rewardPerSecond);\n                pool.accRewardPerShare = pool.accRewardPerShare.add( reward.mul(ACC_TOKEN_PRECISION).div(lpSupply) );\n            }\n            pool.lastRewardTime = block.timestamp;\n            poolInfo = pool;\n        }\n    }\n\n\n    function recoverERC20(uint amount, address token) external onlyOwner {\n        require(amount > 0);\n        require(token != address(0));\n        require(IERC20(token).balanceOf(address(this)) >= amount);\n        IERC20(token).safeTransfer(msg.sender, amount);\n    }\n\n    function stopRewarder() external onlyOwner {\n        stop = true;\n    }\n\n    function startRewarder() external onlyOwner {\n        stop = false;\n    }\n\n\n}"
    }
  ]
}