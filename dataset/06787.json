{
  "Title": "[M-07] `totalVotingPower` needs to be snapshotted for each proposal because it can change and thereby affect consensus when accepting / vetoing proposals",
  "Content": "\n<https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernance.sol#L598-L605>\n\n<https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/VetoProposal.sol#L46-L51>\n\nThis issue does not manifest itself in a limited segment of the code.\n\nInstead it spans multiple contracts and derives its impact from the interaction of these contracts.\n\nIn the PoC section I will do my best in explaining how this results in an issue.\n\nI discussed this with the sponsor and they explained to me that this issue is due to a PR that has unintentionally not been merged.\n\n![Discord message](https://user-images.githubusercontent.com/118979828/231990051-b9f731f1-1678-43e3-81e4-7ec0164bdc10.png)\n\nSo they have already written the code that is necessary to fix this issue. It's just not been merged with this branch. So since the sponsor knows about this already and it's just the PR that has gone missing it's not necessary for me to provide the full Solidity code to fix this issue.\n\nIn short, this issue is due to the fact that the `totalVotingPower` is not snapshotted when a proposal is created.\n\nThe votes that are used to vote for a proposal (or veto it) are based on a specific snapshot (1 block prior to the proposal being created).\n\nWhen the `totalVotingPower` changes this leads to unintended consequences.\n\nWhen `totalVotingPower` decreases, votes become more valuable than they should be.\n\nAnd when `totalVotingPower` increases, votes become less valuable than they should be.\n\n### Proof of Concept\n\nWhen a proposal is created via the [`PartyGovernance.propose`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernance.sol#L527-L548) function, the proposal's `proposedTime` is set:\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernance.sol#L537-L543)\n\n```solidity\nProposalStateValues({\n    proposedTime: uint40(block.timestamp),\n    passedTime: 0,\n    executedTime: 0,\n    completedTime: 0,\n    votes: 0\n}),\n```\n\nWhen users then vote in order to accept the proposal or veto the proposal, their votes are based on the snapshot at the `proposedTime - 1` timestamp.\n\nWe can see this in the `PartyGovernance.accept` function:\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernance.sol#L592)\n\n```solidity\nuint96 votingPower = getVotingPowerAt(msg.sender, values.proposedTime - 1, snapIndex);\n```\n\nAnd we can see it in the `VetoProposal.voteToVeto` function:\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/VetoProposal.sol#L37-L41)\n\n```solidity\nuint96 votingPower = party.getVotingPowerAt(\n    msg.sender,\n    proposalValues.proposedTime - 1,\n    snapIndex\n);\n```\n\nHowever the `totalVotingPower` to determine whether enough votes have been collected is the current `totalVotingPower`:\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernance.sol#L598-L605)\n\n```solidity\nif (\n    values.passedTime == 0 &&\n    _areVotesPassing(\n        values.votes,\n        _governanceValues.totalVotingPower,\n        _governanceValues.passThresholdBps\n    )\n) {\n```\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/VetoProposal.sol#L46-L51)\n\n```solidity\nif (\n    _areVotesPassing(\n        newVotes,\n        governanceValues.totalVotingPower,\n        governanceValues.passThresholdBps\n    )\n```\n\nThe `totalVotingPower` is not constant. It can increase and decrease.\n\nNow we can understand the issue. The `totalVotingPower` must be based on the same time as the votes (i.e. `proposedTime - 1`).\n\nLet's look at a scenario:\n\n    At the time of proposal creation (proposedTime - 1):\n\n    Alice: 100 Votes\n    Bob: 50 Votes\n    Chris: 50 Votes\n\n    totalVotingPower=200\n\nLet's say 80% of votes are necessary for the proposal to pass.\n\nNow the `totalVotingPower` is increased (e.g. by a `ReraiseETHCrowdfund`) since David now has 100 Votes:\n\n    Alice: 100 Votes\n    Bob: 50 Votes\n    Chris: 50 Votes\n    David: 100 Votes \n\n    totalVotingPower=300\n\nNow it is impossible for the proposal to pass.\n\nThe proposal needs 80% of 300 Votes which is 240 Votes. But the votes are used from the old snapshot and there were only 200 Votes.\n\nThe old `totalVotingPower` should have been used (200 Votes instead of 300 Votes).\n\nSimilarly there is an issue when `totalVotingPower` decreases:\n\n    Alice: 100 Votes\n    Bob: 50 Votes\n    Chris: 0 Votes\n\n    totalVotingPower=150\n\nIf 60% of the votes are necessary for the proposal to pass, Alice can make the proposal pass on her own because `totalVotingPower=150` is used even though the old `totalVotingPower=200` should be used.\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nAs explained above the sponsor already has the code to implement snapshotting the `totalVotingPower`.\n\nIn short the following changes need to be made:\n\n1.  Snapshot `totalVotingPower` whenever it is changed\n\n2.  Whenever `totalVotingPower` is used to calculate whether a proposal is accepted / vetoed, the snapshot should be used\n\n**[0xble (Party) confirmed](https://github.com/code-423n4/2023-04-party-findings/issues/9#issuecomment-1512082754)**\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-04-party",
  "Code": [
    {
      "filename": "contracts/party/PartyGovernance.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"../distribution/ITokenDistributorParty.sol\";\nimport \"../distribution/ITokenDistributor.sol\";\nimport \"../utils/ReadOnlyDelegateCall.sol\";\nimport \"../tokens/IERC721.sol\";\nimport \"../tokens/IERC20.sol\";\nimport \"../tokens/IERC1155.sol\";\nimport \"../tokens/ERC721Receiver.sol\";\nimport \"../tokens/ERC1155Receiver.sol\";\nimport \"../utils/LibERC20Compat.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/LibSafeCast.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../globals/LibGlobals.sol\";\nimport \"../proposals/IProposalExecutionEngine.sol\";\nimport \"../proposals/LibProposal.sol\";\nimport \"../proposals/ProposalStorage.sol\";\n\nimport \"./IPartyFactory.sol\";\n\n/// @notice Base contract for a Party encapsulating all governance functionality.\nabstract contract PartyGovernance is\n    ITokenDistributorParty,\n    ERC721Receiver,\n    ERC1155Receiver,\n    ProposalStorage,\n    Implementation,\n    ReadOnlyDelegateCall\n{\n    using LibERC20Compat for IERC20;\n    using LibRawResult for bytes;\n    using LibSafeCast for uint256;\n    using LibSafeCast for int192;\n    using LibSafeCast for uint96;\n\n    // States a proposal can be in.\n    enum ProposalStatus {\n        // The proposal does not exist.\n        Invalid,\n        // The proposal has been proposed (via `propose()`), has not been vetoed\n        // by a party host, and is within the voting window. Members can vote on\n        // the proposal and party hosts can veto the proposal.\n        Voting,\n        // The proposal has either exceeded its voting window without reaching\n        // `passThresholdBps` of votes or was vetoed by a party host.\n        Defeated,\n        // The proposal reached at least `passThresholdBps` of votes but is still\n        // waiting for `executionDelay` to pass before it can be executed. Members\n        // can continue to vote on the proposal and party hosts can veto at this time.\n        Passed,\n        // Same as `Passed` but now `executionDelay` has been satisfied. Any member\n        // may execute the proposal via `execute()`, unless `maxExecutableTime`\n        // has arrived.\n        Ready,\n        // The proposal has been executed at least once but has further steps to\n        // complete so it needs to be executed again. No other proposals may be\n        // executed while a proposal is in the `InProgress` state. No voting or\n        // vetoing of the proposal is allowed, however it may be forcibly cancelled\n        // via `cancel()` if the `cancelDelay` has passed since being first executed.\n        InProgress,\n        // The proposal was executed and completed all its steps. No voting or\n        // vetoing can occur and it cannot be cancelled nor executed again.\n        Complete,\n        // The proposal was executed at least once but did not complete before\n        // `cancelDelay` seconds passed since the first execute and was forcibly cancelled.\n        Cancelled\n    }\n\n    struct GovernanceOpts {\n        // Address of initial party hosts.\n        address[] hosts;\n        // How long people can vote on a proposal.\n        uint40 voteDuration;\n        // How long to wait after a proposal passes before it can be\n        // executed.\n        uint40 executionDelay;\n        // Minimum ratio of accept votes to consider a proposal passed,\n        // in bps, where 10,000 == 100%.\n        uint16 passThresholdBps;\n        // Total voting power of governance NFTs.\n        uint96 totalVotingPower;\n        // Fee bps for distributions.\n        uint16 feeBps;\n        // Fee recipeint for distributions.\n        address payable feeRecipient;\n    }\n\n    // Subset of `GovernanceOpts` that are commonly read together for\n    // efficiency.\n    struct GovernanceValues {\n        uint40 voteDuration;\n        uint40 executionDelay;\n        uint16 passThresholdBps;\n        uint96 totalVotingPower;\n    }\n\n    // A snapshot of voting power for a member.\n    struct VotingPowerSnapshot {\n        // The timestamp when the snapshot was taken.\n        uint40 timestamp;\n        // Voting power that was delegated to this user by others.\n        uint96 delegatedVotingPower;\n        // The intrinsic (not delegated from someone else) voting power of this user.\n        uint96 intrinsicVotingPower;\n        // Whether the user was delegated to another at this snapshot.\n        bool isDelegated;\n    }\n\n    // Proposal details chosen by proposer.\n    struct Proposal {\n        // Time beyond which the proposal can no longer be executed.\n        // If the proposal has already been executed, and is still InProgress,\n        // this value is ignored.\n        uint40 maxExecutableTime;\n        // The minimum seconds this proposal can remain in the InProgress status\n        // before it can be cancelled.\n        uint40 cancelDelay;\n        // Encoded proposal data. The first 4 bytes are the proposal type, followed\n        // by encoded proposal args specific to the proposal type. See\n        // ProposalExecutionEngine for details.\n        bytes proposalData;\n    }\n\n    // Accounting and state tracking values for a proposal.\n    // Fits in a word.\n    struct ProposalStateValues {\n        // When the proposal was proposed.\n        uint40 proposedTime;\n        // When the proposal passed the vote.\n        uint40 passedTime;\n        // When the proposal was first executed.\n        uint40 executedTime;\n        // When the proposal completed.\n        uint40 completedTime;\n        // Number of accept votes.\n        uint96 votes; // -1 == vetoed\n    }\n\n    // Storage states for a proposal.\n    struct ProposalState {\n        // Accounting and state tracking values.\n        ProposalStateValues values;\n        // Hash of the proposal.\n        bytes32 hash;\n        // Whether a member has voted for (accepted) this proposal already.\n        mapping(address => bool) hasVoted;\n    }\n\n    event Proposed(uint256 proposalId, address proposer, Proposal proposal);\n    event ProposalAccepted(uint256 proposalId, address voter, uint256 weight);\n    event EmergencyExecute(address target, bytes data, uint256 amountEth);\n\n    event ProposalPassed(uint256 indexed proposalId);\n    event ProposalVetoed(uint256 indexed proposalId, address host);\n    event ProposalExecuted(uint256 indexed proposalId, address executor, bytes nextProgressData);\n    event ProposalCancelled(uint256 indexed proposalId);\n    event DistributionCreated(\n        ITokenDistributor.TokenType tokenType,\n        address token,\n        uint256 tokenId\n    );\n    event VotingPowerDelegated(address indexed owner, address indexed delegate);\n    event HostStatusTransferred(address oldHost, address newHost);\n    event EmergencyExecuteDisabled();\n\n    error MismatchedPreciousListLengths();\n    error BadProposalStatusError(ProposalStatus status);\n    error BadProposalHashError(bytes32 proposalHash, bytes32 actualHash);\n    error ExecutionTimeExceededError(uint40 maxExecutableTime, uint40 timestamp);\n    error OnlyPartyHostError();\n    error OnlyActiveMemberError();\n    error InvalidDelegateError();\n    error BadPreciousListError();\n    error OnlyPartyDaoError(address notDao, address partyDao);\n    error OnlyPartyDaoOrHostError(address notDao, address partyDao);\n    error OnlyWhenEmergencyActionsAllowedError();\n    error OnlyWhenEnabledError();\n    error AlreadyVotedError(address voter);\n    error InvalidNewHostError();\n    error ProposalCannotBeCancelledYetError(uint40 currentTime, uint40 cancelTime);\n    error InvalidBpsError(uint16 bps);\n    error DistributionsRequireVoteError();\n    error PartyNotStartedError();\n\n    uint256 private constant UINT40_HIGH_BIT = 1 << 39;\n    uint96 private constant VETO_VALUE = type(uint96).max;\n\n    // The `Globals` contract storing global configuration values. This contract\n    // is immutable and itâ€™s address will never change.\n    IGlobals private immutable _GLOBALS;\n\n    /// @notice Whether the DAO has emergency powers for this party.\n    bool public emergencyExecuteDisabled;\n    /// @notice Distribution fee bps.\n    uint16 public feeBps;\n    /// @notice Distribution fee recipient.\n    address payable public feeRecipient;\n    /// @notice The hash of the list of precious NFTs guarded by the party.\n    bytes32 public preciousListHash;\n    /// @notice The last proposal ID that was used. 0 means no proposals have been made.\n    uint256 public lastProposalId;\n    /// @notice Whether an address is a party host.\n    mapping(address => bool) public isHost;\n    /// @notice The last person a voter delegated its voting power to.\n    mapping(address => address) public delegationsByVoter;\n    // Governance parameters for this party.\n    GovernanceValues internal _governanceValues;\n    // ProposalState by proposal ID.\n    mapping(uint256 => ProposalState) private _proposalStateByProposalId;\n    // Snapshots of voting power per user, each sorted by increasing time.\n    mapping(address => VotingPowerSnapshot[]) private _votingPowerSnapshotsByVoter;\n\n    modifier onlyHost() {\n        if (!isHost[msg.sender]) {\n            revert OnlyPartyHostError();\n        }\n        _;\n    }\n\n    // Caller must have voting power at the current time.\n    modifier onlyActiveMember() {\n        {\n            VotingPowerSnapshot memory snap = _getLastVotingPowerSnapshotForVoter(msg.sender);\n            // Must have either delegated voting power or intrinsic voting power.\n            if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {\n                revert OnlyActiveMemberError();\n            }\n        }\n        _;\n    }\n\n    // Only the party DAO multisig can call.\n    modifier onlyPartyDao() {\n        {\n            address partyDao = _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);\n            if (msg.sender != partyDao) {\n                revert OnlyPartyDaoError(msg.sender, partyDao);\n            }\n        }\n        _;\n    }\n\n    // Only the party DAO multisig or a party host can call.\n    modifier onlyPartyDaoOrHost() {\n        address partyDao = _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);\n        if (msg.sender != partyDao && !isHost[msg.sender]) {\n            revert OnlyPartyDaoOrHostError(msg.sender, partyDao);\n        }\n        _;\n    }\n\n    // Only if `emergencyExecuteDisabled` is not true.\n    modifier onlyWhenEmergencyExecuteAllowed() {\n        if (emergencyExecuteDisabled) {\n            revert OnlyWhenEmergencyActionsAllowedError();\n        }\n        _;\n    }\n\n    modifier onlyWhenNotGloballyDisabled() {\n        if (_GLOBALS.getBool(LibGlobals.GLOBAL_DISABLE_PARTY_ACTIONS)) {\n            revert OnlyWhenEnabledError();\n        }\n        _;\n    }\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) {\n        _GLOBALS = globals;\n    }\n\n    // Initialize storage for proxy contracts and initialize the proposal execution engine.\n    function _initialize(\n        GovernanceOpts memory govOpts,\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds\n    ) internal virtual {\n        // Check BPS are valid.\n        if (govOpts.feeBps > 1e4) {\n            revert InvalidBpsError(govOpts.feeBps);\n        }\n        if (govOpts.passThresholdBps > 1e4) {\n            revert InvalidBpsError(govOpts.passThresholdBps);\n        }\n        // Initialize the proposal execution engine.\n        _initProposalImpl(\n            IProposalExecutionEngine(_GLOBALS.getAddress(LibGlobals.GLOBAL_PROPOSAL_ENGINE_IMPL)),\n            abi.encode(proposalEngineOpts)\n        );\n        // Set the governance parameters.\n        _governanceValues = GovernanceValues({\n            voteDuration: govOpts.voteDuration,\n            executionDelay: govOpts.executionDelay,\n            passThresholdBps: govOpts.passThresholdBps,\n            totalVotingPower: govOpts.totalVotingPower\n        });\n        // Set fees.\n        feeBps = govOpts.feeBps;\n        feeRecipient = govOpts.feeRecipient;\n        // Set the precious list.\n        _setPreciousList(preciousTokens, preciousTokenIds);\n        // Set the party hosts.\n        for (uint256 i = 0; i < govOpts.hosts.length; ++i) {\n            isHost[govOpts.hosts[i]] = true;\n        }\n    }\n\n    /// @dev Forward all unknown read-only calls to the proposal execution engine.\n    ///      Initial use case is to facilitate eip-1271 signatures.\n    fallback() external {\n        _readOnlyDelegateCall(address(_getSharedProposalStorage().engineImpl), msg.data);\n    }\n\n    /// @inheritdoc EIP165\n    /// @dev Combined logic for `ERC721Receiver` and `ERC1155Receiver`.\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public pure virtual override(ERC721Receiver, ERC1155Receiver) returns (bool) {\n        return\n            ERC721Receiver.supportsInterface(interfaceId) ||\n            ERC1155Receiver.supportsInterface(interfaceId);\n    }\n\n    /// @notice Get the current `ProposalExecutionEngine` instance.\n    function getProposalExecutionEngine() external view returns (IProposalExecutionEngine) {\n        return _getSharedProposalStorage().engineImpl;\n    }\n\n    /// @notice Get the current `ProposalEngineOpts` options.\n    function getProposalEngineOpts() external view returns (ProposalEngineOpts memory) {\n        return _getSharedProposalStorage().opts;\n    }\n\n    /// @notice Get the total voting power of `voter` at a `timestamp`.\n    /// @param voter The address of the voter.\n    /// @param timestamp The timestamp to get the voting power at.\n    /// @return votingPower The total voting power of `voter` at `timestamp`.\n    function getVotingPowerAt(\n        address voter,\n        uint40 timestamp\n    ) external view returns (uint96 votingPower) {\n        return getVotingPowerAt(voter, timestamp, type(uint256).max);\n    }\n\n    /// @notice Get the total voting power of `voter` at a snapshot `snapIndex`, with checks to\n    ///         make sure it is the latest voting snapshot =< `timestamp`.\n    /// @param voter The address of the voter.\n    /// @param timestamp The timestamp to get the voting power at.\n    /// @param snapIndex The index of the snapshot to get the voting power at.\n    /// @return votingPower The total voting power of `voter` at `timestamp`.\n    function getVotingPowerAt(\n        address voter,\n        uint40 timestamp,\n        uint256 snapIndex\n    ) public view returns (uint96 votingPower) {\n        VotingPowerSnapshot memory snap = _getVotingPowerSnapshotAt(voter, timestamp, snapIndex);\n        return (snap.isDelegated ? 0 : snap.intrinsicVotingPower) + snap.delegatedVotingPower;\n    }\n\n    /// @notice Get the state of a proposal.\n    /// @param proposalId The ID of the proposal.\n    /// @return status The status of the proposal.\n    /// @return values The state of the proposal.\n    function getProposalStateInfo(\n        uint256 proposalId\n    ) external view returns (ProposalStatus status, ProposalStateValues memory values) {\n        values = _proposalStateByProposalId[proposalId].values;\n        status = _getProposalStatus(values);\n    }\n\n    /// @notice Retrieve fixed governance parameters.\n    /// @return gv The governance parameters of this party.\n    function getGovernanceValues() external view returns (GovernanceValues memory gv) {\n        return _governanceValues;\n    }\n\n    /// @notice Get the hash of a proposal.\n    /// @dev Proposal details are not stored on-chain so the hash is used to enforce\n    ///      consistency between calls.\n    /// @param proposal The proposal to hash.\n    /// @return proposalHash The hash of the proposal.\n    function getProposalHash(Proposal memory proposal) public pure returns (bytes32 proposalHash) {\n        // Hash the proposal in-place. Equivalent to:\n        // keccak256(abi.encode(\n        //   proposal.maxExecutableTime,\n        //   proposal.cancelDelay,\n        //   keccak256(proposal.proposalData)\n        // ))\n        bytes32 dataHash = keccak256(proposal.proposalData);\n        assembly {\n            // Overwrite the data field with the hash of its contents and then\n            // hash the struct.\n            let dataPos := add(proposal, 0x40)\n            let t := mload(dataPos)\n            mstore(dataPos, dataHash)\n            proposalHash := keccak256(proposal, 0x60)\n            // Restore the data field.\n            mstore(dataPos, t)\n        }\n    }\n\n    /// @notice Get the index of the most recent voting power snapshot <= `timestamp`.\n    /// @param voter The address of the voter.\n    /// @param timestamp The timestamp to get the snapshot index at.\n    /// @return index The index of the snapshot.\n    function findVotingPowerSnapshotIndex(\n        address voter,\n        uint40 timestamp\n    ) public view returns (uint256 index) {\n        VotingPowerSnapshot[] storage snaps = _votingPowerSnapshotsByVoter[voter];\n\n        // Derived from Open Zeppelin binary search\n        // ref: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Checkpoints.sol#L39\n        uint256 high = snaps.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = (low + high) / 2;\n            if (snaps[mid].timestamp > timestamp) {\n                // Entry is too recent.\n                high = mid;\n            } else {\n                // Entry is older. This is our best guess for now.\n                low = mid + 1;\n            }\n        }\n\n        // Return `type(uint256).max` if no valid voting snapshots found.\n        return high == 0 ? type(uint256).max : high - 1;\n    }\n\n    /// @notice Pledge your intrinsic voting power to a new delegate, removing it from\n    ///         the old one (if any).\n    /// @param delegate The address to delegating voting power to.\n    function delegateVotingPower(address delegate) external onlyDelegateCall {\n        _adjustVotingPower(msg.sender, 0, delegate);\n        emit VotingPowerDelegated(msg.sender, delegate);\n    }\n\n    /// @notice Transfer party host status to another.\n    /// @param newPartyHost The address of the new host.\n    function abdicateHost(address newPartyHost) external onlyHost onlyDelegateCall {\n        // 0 is a special case burn address.\n        if (newPartyHost != address(0)) {\n            // Cannot transfer host status to an existing host.\n            if (isHost[newPartyHost]) {\n                revert InvalidNewHostError();\n            }\n            isHost[newPartyHost] = true;\n        }\n        isHost[msg.sender] = false;\n        emit HostStatusTransferred(msg.sender, newPartyHost);\n    }\n\n    /// @notice Create a token distribution by moving the party's entire balance\n    ///         to the `TokenDistributor` contract and immediately creating a\n    ///         distribution governed by this party.\n    /// @dev The `feeBps` and `feeRecipient` this party was created with will be\n    ///      propagated to the distribution. Party members are entitled to a\n    ///      share of the distribution's tokens proportionate to their relative\n    ///      voting power in this party (less the fee).\n    /// @dev Allow this to be called by the party itself for `FractionalizeProposal`.\n    /// @param tokenType The type of token to distribute.\n    /// @param token The address of the token to distribute.\n    /// @param tokenId The ID of the token to distribute. Currently unused but\n    ///                may be used in the future to support other distribution types.\n    /// @return distInfo The information about the created distribution.\n    function distribute(\n        uint256 amount,\n        ITokenDistributor.TokenType tokenType,\n        address token,\n        uint256 tokenId\n    )\n        external\n        onlyWhenNotGloballyDisabled\n        onlyDelegateCall\n        returns (ITokenDistributor.DistributionInfo memory distInfo)\n    {\n        // Ignore if the party is calling functions on itself, like with\n        // `FractionalizeProposal` and `DistributionProposal`.\n        if (msg.sender != address(this)) {\n            // Must not require a vote to create a distribution, otherwise\n            // distributions can only be created through a distribution\n            // proposal.\n            if (_getSharedProposalStorage().opts.distributionsRequireVote) {\n                revert DistributionsRequireVoteError();\n            }\n            // Must be an active member.\n            VotingPowerSnapshot memory snap = _getLastVotingPowerSnapshotForVoter(msg.sender);\n            if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {\n                revert OnlyActiveMemberError();\n            }\n        }\n        // Prevent creating a distribution if the party has not started.\n        if (_getTotalVotingPower() == 0) {\n            revert PartyNotStartedError();\n        }\n        // Get the address of the token distributor.\n        ITokenDistributor distributor = ITokenDistributor(\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_TOKEN_DISTRIBUTOR)\n        );\n        emit DistributionCreated(tokenType, token, tokenId);\n        // Create a native token distribution.\n        address payable feeRecipient_ = feeRecipient;\n        uint16 feeBps_ = feeBps;\n        if (tokenType == ITokenDistributor.TokenType.Native) {\n            return\n                distributor.createNativeDistribution{ value: amount }(this, feeRecipient_, feeBps_);\n        }\n        // Otherwise must be an ERC20 token distribution.\n        assert(tokenType == ITokenDistributor.TokenType.Erc20);\n        IERC20(token).compatTransfer(address(distributor), amount);\n        return distributor.createErc20Distribution(IERC20(token), this, feeRecipient_, feeBps_);\n    }\n\n    /// @notice Make a proposal for members to vote on and cast a vote to accept it\n    ///         as well.\n    /// @dev Only an active member (has voting power) can call this.\n    ///      Afterwards, members can vote to support it with `accept()` or a party\n    ///      host can unilaterally reject the proposal with `veto()`.\n    /// @param proposal The details of the proposal.\n    /// @param latestSnapIndex The index of the caller's most recent voting power\n    ///                        snapshot before the proposal was created. Should\n    ///                        be retrieved off-chain and passed in.\n    function propose(\n        Proposal memory proposal,\n        uint256 latestSnapIndex\n    ) external onlyActiveMember onlyDelegateCall returns (uint256 proposalId) {\n        proposalId = ++lastProposalId;\n        // Store the time the proposal was created and the proposal hash.\n        (\n            _proposalStateByProposalId[proposalId].values,\n            _proposalStateByProposalId[proposalId].hash\n        ) = (\n            ProposalStateValues({\n                proposedTime: uint40(block.timestamp),\n                passedTime: 0,\n                executedTime: 0,\n                completedTime: 0,\n                votes: 0\n            }),\n            getProposalHash(proposal)\n        );\n        emit Proposed(proposalId, msg.sender, proposal);\n        accept(proposalId, latestSnapIndex);\n    }\n\n    /// @notice Vote to support a proposed proposal.\n    /// @dev The voting power cast will be the effective voting power of the caller\n    ///      just before `propose()` was called (see `getVotingPowerAt()`).\n    ///      If the proposal reaches `passThresholdBps` acceptance ratio then the\n    ///      proposal will be in the `Passed` state and will be executable after\n    ///      the `executionDelay` has passed, putting it in the `Ready` state.\n    /// @param proposalId The ID of the proposal to accept.\n    /// @param snapIndex The index of the caller's last voting power snapshot\n    ///                  before the proposal was created. Should be retrieved\n    ///                  off-chain and passed in.\n    /// @return totalVotes The total votes cast on the proposal.\n    function accept(\n        uint256 proposalId,\n        uint256 snapIndex\n    ) public onlyDelegateCall returns (uint256 totalVotes) {\n        // Get the information about the proposal.\n        ProposalState storage info = _proposalStateByProposalId[proposalId];\n        ProposalStateValues memory values = info.values;\n\n        // Can only vote in certain proposal statuses.\n        {\n            ProposalStatus status = _getProposalStatus(values);\n            // Allow voting even if the proposal is passed/ready so it can\n            // potentially reach 100% consensus, which unlocks special\n            // behaviors for certain proposal types.\n            if (\n                status != ProposalStatus.Voting &&\n                status != ProposalStatus.Passed &&\n                status != ProposalStatus.Ready\n            ) {\n                revert BadProposalStatusError(status);\n            }\n        }\n\n        // Cannot vote twice.\n        if (info.hasVoted[msg.sender]) {\n            revert AlreadyVotedError(msg.sender);\n        }\n        // Mark the caller as having voted.\n        info.hasVoted[msg.sender] = true;\n\n        // Increase the total votes that have been cast on this proposal.\n        uint96 votingPower = getVotingPowerAt(msg.sender, values.proposedTime - 1, snapIndex);\n        values.votes += votingPower;\n        info.values = values;\n        emit ProposalAccepted(proposalId, msg.sender, votingPower);\n\n        // Update the proposal status if it has reached the pass threshold.\n        if (\n            values.passedTime == 0 &&\n            _areVotesPassing(\n                values.votes,\n                _governanceValues.totalVotingPower,\n                _governanceValues.passThresholdBps\n            )\n        ) {\n            info.values.passedTime = uint40(block.timestamp);\n            emit ProposalPassed(proposalId);\n        }\n        return values.votes;\n    }\n\n    /// @notice As a party host, veto a proposal, unilaterally rejecting it.\n    /// @dev The proposal will never be executable and cannot be voted on anymore.\n    ///      A proposal that has been already executed at least once (in the `InProgress` status)\n    ///      cannot be vetoed.\n    /// @param proposalId The ID of the proposal to veto.\n    function veto(uint256 proposalId) external onlyHost onlyDelegateCall {\n        // Setting `votes` to -1 indicates a veto.\n        ProposalState storage info = _proposalStateByProposalId[proposalId];\n        ProposalStateValues memory values = info.values;\n\n        {\n            ProposalStatus status = _getProposalStatus(values);\n            // Proposal must be in one of the following states.\n            if (\n                status != ProposalStatus.Voting &&\n                status != ProposalStatus.Passed &&\n                status != ProposalStatus.Ready\n            ) {\n                revert BadProposalStatusError(status);\n            }\n        }\n\n        // -1 indicates veto.\n        info.values.votes = VETO_VALUE;\n        emit ProposalVetoed(proposalId, msg.sender);\n    }\n\n    /// @notice Executes a proposal that has passed governance.\n    /// @dev The proposal must be in the `Ready` or `InProgress` status.\n    ///      A `ProposalExecuted` event will be emitted with a non-empty `nextProgressData`\n    ///      if the proposal has extra steps (must be executed again) to carry out,\n    ///      in which case `nextProgressData` should be passed into the next `execute()` call.\n    ///      The `ProposalExecutionEngine` enforces that only one `InProgress` proposal\n    ///      is active at a time, so that proposal must be completed or cancelled via `cancel()`\n    ///      in order to execute a different proposal.\n    ///      `extraData` is optional, off-chain data a proposal might need to execute a step.\n    /// @param proposalId The ID of the proposal to execute.\n    /// @param proposal The details of the proposal.\n    /// @param preciousTokens The tokens that the party considers precious.\n    /// @param preciousTokenIds The token IDs associated with each precious token.\n    /// @param progressData The data returned from the last `execute()` call, if any.\n    /// @param extraData Off-chain data a proposal might need to execute a step.\n    function execute(\n        uint256 proposalId,\n        Proposal memory proposal,\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds,\n        bytes calldata progressData,\n        bytes calldata extraData\n    ) external payable onlyActiveMember onlyWhenNotGloballyDisabled onlyDelegateCall {\n        // Get information about the proposal.\n        ProposalState storage proposalState = _proposalStateByProposalId[proposalId];\n        // Proposal details must remain the same from `propose()`.\n        _validateProposalHash(proposal, proposalState.hash);\n        ProposalStateValues memory values = proposalState.values;\n        ProposalStatus status = _getProposalStatus(values);\n        // The proposal must be executable or have already been executed but still\n        // has more steps to go.\n        if (status != ProposalStatus.Ready && status != ProposalStatus.InProgress) {\n            revert BadProposalStatusError(status);\n        }\n        if (status == ProposalStatus.Ready) {\n            // If the proposal has not been executed yet, make sure it hasn't\n            // expired. Note that proposals that have been executed\n            // (but still have more steps) ignore `maxExecutableTime`.\n            if (proposal.maxExecutableTime < block.timestamp) {\n                revert ExecutionTimeExceededError(\n                    proposal.maxExecutableTime,\n                    uint40(block.timestamp)\n                );\n            }\n            proposalState.values.executedTime = uint40(block.timestamp);\n        }\n        // Check that the precious list is valid.\n        if (!_isPreciousListCorrect(preciousTokens, preciousTokenIds)) {\n            revert BadPreciousListError();\n        }\n        // Preemptively set the proposal to completed to avoid it being executed\n        // again in a deeper call.\n        proposalState.values.completedTime = uint40(block.timestamp);\n        // Execute the proposal.\n        bool completed = _executeProposal(\n            proposalId,\n            proposal,\n            preciousTokens,\n            preciousTokenIds,\n            _getProposalFlags(values),\n            progressData,\n            extraData\n        );\n        if (!completed) {\n            // Proposal did not complete.\n            proposalState.values.completedTime = 0;\n        }\n    }\n\n    /// @notice Cancel a (probably stuck) InProgress proposal.\n    /// @dev `proposal.cancelDelay` seconds must have passed since it was first\n    ///      executed for this to be valid. The currently active proposal will\n    ///      simply be yeeted out of existence so another proposal can execute.\n    ///      This is intended to be a last resort and can leave the party in a\n    ///      broken state. Whenever possible, active proposals should be\n    ///      allowed to complete their lifecycle.\n    /// @param proposalId The ID of the proposal to cancel.\n    /// @param proposal The details of the proposal to cancel.\n    function cancel(\n        uint256 proposalId,\n        Proposal calldata proposal\n    ) external onlyActiveMember onlyDelegateCall {\n        // Get information about the proposal.\n        ProposalState storage proposalState = _proposalStateByProposalId[proposalId];\n        // Proposal details must remain the same from `propose()`.\n        _validateProposalHash(proposal, proposalState.hash);\n        ProposalStateValues memory values = proposalState.values;\n        {\n            // Must be `InProgress`.\n            ProposalStatus status = _getProposalStatus(values);\n            if (status != ProposalStatus.InProgress) {\n                revert BadProposalStatusError(status);\n            }\n        }\n        {\n            // Limit the `cancelDelay` to the global max and min cancel delay\n            // to mitigate parties accidentally getting stuck forever by setting an\n            // unrealistic `cancelDelay` or being reckless with too low a\n            // cancel delay.\n            uint256 cancelDelay = proposal.cancelDelay;\n            uint256 globalMaxCancelDelay = _GLOBALS.getUint256(\n                LibGlobals.GLOBAL_PROPOSAL_MAX_CANCEL_DURATION\n            );\n            uint256 globalMinCancelDelay = _GLOBALS.getUint256(\n                LibGlobals.GLOBAL_PROPOSAL_MIN_CANCEL_DURATION\n            );\n            if (globalMaxCancelDelay != 0) {\n                // Only if we have one set.\n                if (cancelDelay > globalMaxCancelDelay) {\n                    cancelDelay = globalMaxCancelDelay;\n                }\n            }\n            if (globalMinCancelDelay != 0) {\n                // Only if we have one set.\n                if (cancelDelay < globalMinCancelDelay) {\n                    cancelDelay = globalMinCancelDelay;"
    }
  ]
}