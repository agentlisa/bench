{
  "Title": "M-2: `oracleSlippagePercentOrLimit` can exceed the `Constants.SLIPPAGE_LIMIT_PRECISION`",
  "Content": "# Issue M-2: `oracleSlippagePercentOrLimit` can exceed the `Constants.SLIPPAGE_LIMIT_PRECISION` \n\nSource: https://github.com/sherlock-audit/2023-02-notional-judging/issues/19 \n\n## Found by \nxiaoming90\n\n## Summary\n\nTrade might be settled with a large slippage causing a loss of assets as the `oracleSlippagePercentOrLimit` limit is not bounded and can exceed the `Constants.SLIPPAGE_LIMIT_PRECISION` threshold.\n\n## Vulnerability Detail\n\nThe code at Line 73-75 only checks if the `oracleSlippagePercentOrLimit` is within the `Constants.SLIPPAGE_LIMIT_PRECISION` if `useDynamicSlippage` is `true`. If the trade is performed without dynamic slippage, the trade can be executed with an arbitrary limit.\n\nhttps://github.com/sherlock-audit/2023-02-notional/blob/main/leveraged-vaults/contracts/vaults/common/internal/strategy/StrategyUtils.sol#L62\n\n```solidity\nFile: StrategyUtils.sol\n62:     function _executeTradeExactIn(\n63:         TradeParams memory params,\n64:         ITradingModule tradingModule,\n65:         address sellToken,\n66:         address buyToken,\n67:         uint256 amount,\n68:         bool useDynamicSlippage\n69:     ) internal returns (uint256 amountSold, uint256 amountBought) {\n70:         require(\n71:             params.tradeType == TradeType.EXACT_IN_SINGLE || params.tradeType == TradeType.EXACT_IN_BATCH\n72:         );\n73:         if (useDynamicSlippage) {\n74:             require(params.oracleSlippagePercentOrLimit <= Constants.SLIPPAGE_LIMIT_PRECISION);\n75:         }\n76: \n77:         // Sell residual secondary balance\n78:         Trade memory trade = Trade(\n79:             params.tradeType,\n80:             sellToken,\n81:             buyToken,\n82:             amount,\n83:             useDynamicSlippage ? 0 : params.oracleSlippagePercentOrLimit,\n84:             block.timestamp, // deadline\n85:             params.exchangeData\n86:         );\n```\n\nThe `StrategyUtils._executeTradeExactIn` function is utilized by the Curve Vault.\n\n## Impact\n\nTrade might be settled with a large slippage causing a loss of assets.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-notional/blob/main/leveraged-vaults/contracts/vaults/common/internal/strategy/StrategyUtils.sol#L62\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider restricting the slippage limit when a trade is executed without dynamic slippage.\n\n```diff\n    function _executeTradeExactIn(\n        TradeParams memory params,\n        ITradingModule tradingModule,\n        address sellToken,\n        address buyToken,\n        uint256 amount,\n        bool useDynamicSlippage\n    ) internal returns (uint256 amountSold, uint256 amountBought) {\n        require(\n            params.tradeType == TradeType.EXACT_IN_SINGLE || params.tradeType == TradeType.EXACT_IN_BATCH\n        );\n        if (useDynamicSlippage) {\n            require(params.oracleSlippagePercentOrLimit <= Constants.SLIPPAGE_LIMIT_PRECISION);\n-       }\n+\t\t} else {\n+ \t\t\trequire(params.oracleSlippagePercentOrLimit != 0 && params.oracleSlippagePercentOrLimit <= Constants.SLIPPAGE_LIMIT_PRECISION_FOR_NON_DYNAMIC_TRADE);\n+ \t\t}     \n```\n\n## Discussion\n\n**jeffywu**\n\nValid, I agree with the intent in this issue although I'm not sure if the proposed solution is workable. We don't have guardrails against this method being called with dynamicSlippage set to false by a non-authenticated account from an internal code perspective. We should consider some sort of internal check to ensure that this is the case.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/52",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/common/internal/strategy/StrategyUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {VaultConstants} from \"../../VaultConstants.sol\";\nimport {StrategyContext, TradeParams, StrategyVaultState} from \"../../VaultTypes.sol\";\nimport {TokenUtils, IERC20} from \"../../../../utils/TokenUtils.sol\";\nimport {TradeHandler} from \"../../../../trading/TradeHandler.sol\";\nimport {Deployments} from \"../../../../global/Deployments.sol\";\nimport {Constants} from \"../../../../global/Constants.sol\";\nimport {ITradingModule, Trade, TradeType} from \"../../../../../interfaces/trading/ITradingModule.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {VaultStorage} from \"../../VaultStorage.sol\";\n\nlibrary StrategyUtils {\n    using TradeHandler for Trade;\n    using TokenUtils for IERC20;\n    using TypeConvert for uint256;\n    using VaultStorage for StrategyVaultState;\n\n    function _checkPriceLimit(\n        StrategyContext memory strategyContext,\n        uint256 oraclePrice,\n        uint256 poolPrice\n    ) internal pure {\n        uint256 lowerLimit = (oraclePrice * \n            (VaultConstants.VAULT_PERCENT_BASIS - strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            VaultConstants.VAULT_PERCENT_BASIS;\n        uint256 upperLimit = (oraclePrice * \n            (VaultConstants.VAULT_PERCENT_BASIS + strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            VaultConstants.VAULT_PERCENT_BASIS;\n\n        if (poolPrice < lowerLimit || upperLimit < poolPrice) {\n            revert Errors.InvalidPrice(oraclePrice, poolPrice);\n        }\n    }\n\n    /// @notice Converts strategy tokens to LP tokens\n    function _convertStrategyTokensToPoolClaim(StrategyContext memory context, uint256 strategyTokenAmount)\n        internal pure returns (uint256 poolClaim) {\n        require(strategyTokenAmount <= context.vaultState.totalStrategyTokenGlobal);\n        if (context.vaultState.totalStrategyTokenGlobal > 0) {\n            poolClaim = (strategyTokenAmount * context.vaultState.totalPoolClaim) / context.vaultState.totalStrategyTokenGlobal;\n        }\n    }\n\n    /// @notice Converts LP tokens to strategy tokens\n    function _convertPoolClaimToStrategyTokens(StrategyContext memory context, uint256 poolClaim)\n        internal pure returns (uint256 strategyTokenAmount) {\n        if (context.vaultState.totalPoolClaim == 0) {\n            // Strategy tokens are in 8 decimal precision. Scale the minted amount according to pool claim precision.\n            return (poolClaim * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / \n                context.poolClaimPrecision;\n        }\n\n        // Pool claim in maturity is calculated before the new pool tokens are minted, so this calculation\n        // is the tokens minted that will give the account a corresponding share of the new pool balance held.\n        // The precision here will be the same as strategy token supply.\n        strategyTokenAmount = (poolClaim * context.vaultState.totalStrategyTokenGlobal) / context.vaultState.totalPoolClaim;\n    }\n\n    function _executeTradeExactIn(\n        TradeParams memory params,\n        ITradingModule tradingModule,\n        address sellToken,\n        address buyToken,\n        uint256 amount,\n        bool useDynamicSlippage\n    ) internal returns (uint256 amountSold, uint256 amountBought) {\n        require(\n            params.tradeType == TradeType.EXACT_IN_SINGLE || params.tradeType == TradeType.EXACT_IN_BATCH\n        );\n        if (useDynamicSlippage) {\n            require(params.oracleSlippagePercentOrLimit <= Constants.SLIPPAGE_LIMIT_PRECISION);\n        }\n\n        // Sell residual secondary balance\n        Trade memory trade = Trade(\n            params.tradeType,\n            sellToken,\n            buyToken,\n            amount,\n            useDynamicSlippage ? 0 : params.oracleSlippagePercentOrLimit,\n            block.timestamp, // deadline\n            params.exchangeData\n        );\n\n        // stETH generally has deeper liquidity than wstETH, setting tradeUnwrapped\n        // to lets the contract trade in stETH instead of wstETH\n        if (params.tradeUnwrapped) {\n            if (sellToken == address(Deployments.WRAPPED_STETH)) {\n                trade.sellToken = Deployments.WRAPPED_STETH.stETH();\n                uint256 amountBeforeUnwrap = IERC20(trade.sellToken).balanceOf(address(this));\n                // NOTE: the amount returned by unwrap is not always accurate for some reason\n                Deployments.WRAPPED_STETH.unwrap(trade.amount);\n                trade.amount = IERC20(trade.sellToken).balanceOf(address(this)) - amountBeforeUnwrap;\n            }\n            if (buyToken == address(Deployments.WRAPPED_STETH)) {\n                trade.buyToken = Deployments.WRAPPED_STETH.stETH();\n            }\n        }\n\n        if (useDynamicSlippage) {\n            /// @dev params.oracleSlippagePercentOrLimit checked above\n            (amountSold, amountBought) = trade._executeTradeWithDynamicSlippage(\n                params.dexId, tradingModule, uint32(params.oracleSlippagePercentOrLimit)\n            );\n        } else {\n            (amountSold, amountBought) = trade._executeTrade(\n                params.dexId, tradingModule\n            );\n        }\n\n        if (params.tradeUnwrapped) {\n            if (sellToken == address(Deployments.WRAPPED_STETH)) {\n                // Setting amountSold to the original wstETH amount because _executeTradeWithDynamicSlippage\n                // returns the amount of stETH sold in this case\n                /// @notice amountSold == amount because this function only supports EXACT_IN trades\n                amountSold = amount;\n            }\n            if (buyToken == address(Deployments.WRAPPED_STETH) && amountBought > 0) {\n                // trade.buyToken == stETH here\n                IERC20(trade.buyToken).checkApprove(address(Deployments.WRAPPED_STETH), amountBought);\n                uint256 amountBeforeWrap = Deployments.WRAPPED_STETH.balanceOf(address(this));\n                /// @notice the amount returned by wrap is not always accurate for some reason\n                Deployments.WRAPPED_STETH.wrap(amountBought);\n                amountBought = Deployments.WRAPPED_STETH.balanceOf(address(this)) - amountBeforeWrap;\n            }\n        }\n    }\n\n    function _mintStrategyTokens(\n        StrategyContext memory strategyContext,\n        uint256 poolClaimMinted\n    ) internal returns (uint256 strategyTokensMinted) {\n        strategyTokensMinted = _convertPoolClaimToStrategyTokens(strategyContext, poolClaimMinted);\n\n        if (strategyTokensMinted == 0) {\n            revert Errors.ZeroStrategyTokens();\n        }\n\n        strategyContext.vaultState.totalPoolClaim += poolClaimMinted;\n        strategyContext.vaultState.totalStrategyTokenGlobal += strategyTokensMinted.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n\n    function _redeemStrategyTokens(\n        StrategyContext memory strategyContext,\n        uint256 strategyTokens\n    ) internal returns (uint256 poolClaim) {\n        poolClaim = _convertStrategyTokensToPoolClaim(strategyContext, strategyTokens);\n\n        if (poolClaim == 0) {\n            revert Errors.ZeroPoolClaim();\n        }\n\n        strategyContext.vaultState.totalPoolClaim -= poolClaim;\n        strategyContext.vaultState.totalStrategyTokenGlobal -= strategyTokens.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/common/internal/strategy/StrategyUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {VaultConstants} from \"../../VaultConstants.sol\";\nimport {StrategyContext, TradeParams, StrategyVaultState} from \"../../VaultTypes.sol\";\nimport {TokenUtils, IERC20} from \"../../../../utils/TokenUtils.sol\";\nimport {TradeHandler} from \"../../../../trading/TradeHandler.sol\";\nimport {Deployments} from \"../../../../global/Deployments.sol\";\nimport {Constants} from \"../../../../global/Constants.sol\";\nimport {ITradingModule, Trade, TradeType} from \"../../../../../interfaces/trading/ITradingModule.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {VaultStorage} from \"../../VaultStorage.sol\";\n\nlibrary StrategyUtils {\n    using TradeHandler for Trade;\n    using TokenUtils for IERC20;\n    using TypeConvert for uint256;\n    using VaultStorage for StrategyVaultState;\n\n    function _checkPriceLimit(\n        StrategyContext memory strategyContext,\n        uint256 oraclePrice,\n        uint256 poolPrice\n    ) internal pure {\n        uint256 lowerLimit = (oraclePrice * \n            (VaultConstants.VAULT_PERCENT_BASIS - strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            VaultConstants.VAULT_PERCENT_BASIS;\n        uint256 upperLimit = (oraclePrice * \n            (VaultConstants.VAULT_PERCENT_BASIS + strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            VaultConstants.VAULT_PERCENT_BASIS;\n\n        if (poolPrice < lowerLimit || upperLimit < poolPrice) {\n            revert Errors.InvalidPrice(oraclePrice, poolPrice);\n        }\n    }\n\n    /// @notice Converts strategy tokens to LP tokens\n    function _convertStrategyTokensToPoolClaim(StrategyContext memory context, uint256 strategyTokenAmount)\n        internal pure returns (uint256 poolClaim) {\n        require(strategyTokenAmount <= context.vaultState.totalStrategyTokenGlobal);\n        if (context.vaultState.totalStrategyTokenGlobal > 0) {\n            poolClaim = (strategyTokenAmount * context.vaultState.totalPoolClaim) / context.vaultState.totalStrategyTokenGlobal;\n        }\n    }\n\n    /// @notice Converts LP tokens to strategy tokens\n    function _convertPoolClaimToStrategyTokens(StrategyContext memory context, uint256 poolClaim)\n        internal pure returns (uint256 strategyTokenAmount) {\n        if (context.vaultState.totalPoolClaim == 0) {\n            // Strategy tokens are in 8 decimal precision. Scale the minted amount according to pool claim precision.\n            return (poolClaim * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / \n                context.poolClaimPrecision;\n        }\n\n        // Pool claim in maturity is calculated before the new pool tokens are minted, so this calculation\n        // is the tokens minted that will give the account a corresponding share of the new pool balance held.\n        // The precision here will be the same as strategy token supply.\n        strategyTokenAmount = (poolClaim * context.vaultState.totalStrategyTokenGlobal) / context.vaultState.totalPoolClaim;\n    }\n\n    function _executeTradeExactIn(\n        TradeParams memory params,\n        ITradingModule tradingModule,\n        address sellToken,\n        address buyToken,\n        uint256 amount,\n        bool useDynamicSlippage\n    ) internal returns (uint256 amountSold, uint256 amountBought) {\n        require(\n            params.tradeType == TradeType.EXACT_IN_SINGLE || params.tradeType == TradeType.EXACT_IN_BATCH\n        );\n        if (useDynamicSlippage) {\n            require(params.oracleSlippagePercentOrLimit <= Constants.SLIPPAGE_LIMIT_PRECISION);\n        }\n\n        // Sell residual secondary balance\n        Trade memory trade = Trade(\n            params.tradeType,\n            sellToken,\n            buyToken,\n            amount,\n            useDynamicSlippage ? 0 : params.oracleSlippagePercentOrLimit,\n            block.timestamp, // deadline\n            params.exchangeData\n        );\n\n        // stETH generally has deeper liquidity than wstETH, setting tradeUnwrapped\n        // to lets the contract trade in stETH instead of wstETH\n        if (params.tradeUnwrapped) {\n            if (sellToken == address(Deployments.WRAPPED_STETH)) {\n                trade.sellToken = Deployments.WRAPPED_STETH.stETH();\n                uint256 amountBeforeUnwrap = IERC20(trade.sellToken).balanceOf(address(this));\n                // NOTE: the amount returned by unwrap is not always accurate for some reason\n                Deployments.WRAPPED_STETH.unwrap(trade.amount);\n                trade.amount = IERC20(trade.sellToken).balanceOf(address(this)) - amountBeforeUnwrap;\n            }\n            if (buyToken == address(Deployments.WRAPPED_STETH)) {\n                trade.buyToken = Deployments.WRAPPED_STETH.stETH();\n            }\n        }\n\n        if (useDynamicSlippage) {\n            /// @dev params.oracleSlippagePercentOrLimit checked above\n            (amountSold, amountBought) = trade._executeTradeWithDynamicSlippage(\n                params.dexId, tradingModule, uint32(params.oracleSlippagePercentOrLimit)\n            );\n        } else {\n            (amountSold, amountBought) = trade._executeTrade(\n                params.dexId, tradingModule\n            );\n        }\n\n        if (params.tradeUnwrapped) {\n            if (sellToken == address(Deployments.WRAPPED_STETH)) {\n                // Setting amountSold to the original wstETH amount because _executeTradeWithDynamicSlippage\n                // returns the amount of stETH sold in this case\n                /// @notice amountSold == amount because this function only supports EXACT_IN trades\n                amountSold = amount;\n            }\n            if (buyToken == address(Deployments.WRAPPED_STETH) && amountBought > 0) {\n                // trade.buyToken == stETH here\n                IERC20(trade.buyToken).checkApprove(address(Deployments.WRAPPED_STETH), amountBought);\n                uint256 amountBeforeWrap = Deployments.WRAPPED_STETH.balanceOf(address(this));\n                /// @notice the amount returned by wrap is not always accurate for some reason\n                Deployments.WRAPPED_STETH.wrap(amountBought);\n                amountBought = Deployments.WRAPPED_STETH.balanceOf(address(this)) - amountBeforeWrap;\n            }\n        }\n    }\n\n    function _mintStrategyTokens(\n        StrategyContext memory strategyContext,\n        uint256 poolClaimMinted\n    ) internal returns (uint256 strategyTokensMinted) {\n        strategyTokensMinted = _convertPoolClaimToStrategyTokens(strategyContext, poolClaimMinted);\n\n        if (strategyTokensMinted == 0) {\n            revert Errors.ZeroStrategyTokens();\n        }\n\n        strategyContext.vaultState.totalPoolClaim += poolClaimMinted;\n        strategyContext.vaultState.totalStrategyTokenGlobal += strategyTokensMinted.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n\n    function _redeemStrategyTokens(\n        StrategyContext memory strategyContext,\n        uint256 strategyTokens\n    ) internal returns (uint256 poolClaim) {\n        poolClaim = _convertStrategyTokensToPoolClaim(strategyContext, strategyTokens);\n\n        if (poolClaim == 0) {\n            revert Errors.ZeroPoolClaim();\n        }\n\n        strategyContext.vaultState.totalPoolClaim -= poolClaim;\n        strategyContext.vaultState.totalStrategyTokenGlobal -= strategyTokens.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n}"
    }
  ]
}