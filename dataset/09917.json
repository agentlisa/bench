{
  "Title": "[M-17] ThecosomataETH: Oracle price can be better secured (freshness + tamper-resistance)",
  "Content": "_Submitted by hickuphh3_\n\n[ThecosomataETH.sol#L94-L110](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L94-L110)<br>\n\nThe `ThecosomataETH` contract adds ETH and BTRFLY tokens as liquidity into the [ETH-BTRFLY curve crypto pool](https://etherscan.io/address/0xf43b15ab692fde1f9c24a9fce700adcc809d5391). The `calculateAmountRequiredForLP()` function relies on the `price_oracle` value returned by the pool to calculate the ETH and BTRFLY amounts to be added as liquidity. It is therefore important to ensure that `price_oracle` is accurate.\n\nAt the time of writing, the pool has about \\$5M in liquidity, which is comparable to that of the [liquidity provided on UniswapV3](https://info.uniswap.org/#/pools/0xdf9ab3c649005ebfdf682d2302ca1f673e0d37a2). Flash loan attacks are therefore possible, but ineffective (explained further later).\n\nIn the [curve v2 whitepaper](https://curve.fi/files/crypto-pools-paper.pdf), the price oracle mechanism is explained briefly in the “Algorithm for repegging” section. It is reproduced below for convenience.\n\n> Internally, we have a price oracle given by an exponential moving average (EMA) applied in N-dimensional price space. Suppose that the last reported price is `pLast`, and the update happened `t` seconds ago while the half-time of the EMA is `T1/2`. Then the oracle price `p_new` is given as:\n\n```jsx\nα = 2^(− t / T1/2);\np_new = pLast * (1 - α) + α * p_old // p_old = current price_oracle\n```\n\n### Impact\n\nWith oracles (curve pool now, to be switched to chainlink based oracle as per comment in L27), there is an inverse correlation between freshness and tamper-resistance.\n\nWe can expect `price_oracle` to be relatively fresh as trades will occur whenever arbitrage opportunities arise against the UniV3 pool which has comparable liquidity. Note that the `ETH-BTRFLY` pool has a half-time of 10 minutes (`T1/2 = 600`). This means that after exactly 10 mins, both `pLast` and `p_old` have equal weightage.\n\nIt is unclear how resistant the EMA oracle is against manipulation. Flash loan attacks, while possible, will be ineffective because `t` will be zero (`pLast` will be ignored in the update). However, a sophisticated attacker could possibly skew the price oracle by inflating the price of `BTRFLY` a couple of blocks before the `performUpkeep()` transaction to get the treasury to deposit more `ETH` / burn more `BTRFLY` than necessary.\n\n### Recommended Mitigation Steps\n\nIn my opinion, both freshness and tamper-resistance can be better secured.\n\nThis can be done by:\n\n1.  Ensuring that the price was updated within a certain limit.\n\n```jsx\n// eg. last price update / trade must have been executed within the past hour\nuint256 lastPricesTimestamp = ICurveCryptoPool(CURVEPOOL).last_prices_timestamp();\nrequire(block.timestamp - lastPricesTimestamp <= 1 hours, 'stale price');\n```\n\n2.  Checking that the last reported price `pLast` has not deviated too far from the current oracle price `p_old`. One can argue that it would be safer to add liquidity when the market isn’t volatile.\n\n```jsx\nuint256 lastPrice = ICurveCryptoPool(CURVEPOOL).last_prices();\nuint256 oraclePrice = ICurveCryptoPool(CURVEPOOL).price_oracle();\nuint256 percentDiff;\n// eg. require difference in prices to be within 5%\nif (lastPrice > oraclePrice) {\n  percentDiff = (lastPrice - oraclePrice) * 1e18 / oraclePrice;\n} else {\n  percentDiff = (oraclePrice - lastPrice) * 1e18 / oraclePrice;\n}\nrequire(percentDiff <= 5e16, 'volatile market');\n```\n\n**[drahrealm (Redacted Cartel) commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/49#issuecomment-1042571538):**\n > Idem with M-05, we will proceed with doing calculating the min token amount off-chain, then specify it when calling `performUpKeep`.\n> \n> Thanks for the finding.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/49#issuecomment-1060059235):**\n > Agree that solution is based off of M-05.<br> \n> While I believe simpler solutions where highlighted, I feel the warden put in the extra effort to make a valuable submission.\n> \n> As such, I'll mark the finding as unique.\n> \n> Personally I would not trust Curve Pricing model over a Price Feed at this time, however am happy to be proven wrong.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-redacted-cartel-contest",
  "Code": [
    {
      "filename": "contracts/ThecosomataETH.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IBTRFLY is IERC20 {\n    function burn(uint256 amount) external;\n\n    function decimals() external view returns (uint8);\n}\n\ninterface IRedactedTreasury {\n    function manage(address _token, uint256 _amount) external;\n}\n\ninterface ICurveCryptoPool {\n    function add_liquidity(uint256[2] calldata amounts, uint256 min_mint_amount)\n        external\n        payable;\n\n    function calc_token_amount(uint256[2] calldata amounts)\n        external\n        view\n        returns (uint256);\n\n    // Would be replaced by Chainlink based oracle\n    function price_oracle() external view returns (uint256);\n\n    function token() external view returns (address);\n}\n\ncontract ThecosomataETH is Ownable {\n    address public immutable BTRFLY;\n    address public immutable WETH;\n    address public immutable CURVEPOOL;\n    address public immutable TREASURY;\n\n    uint256 private immutable _btrflyDecimals;\n    uint256 private immutable _ethDecimals;\n\n    uint256 public slippage = 5; // in 1000th\n\n    event AddLiquidity(\n        uint256 ethLiquidity,\n        uint256 btrflyLiquidity,\n        uint256 btrflyBurned\n    );\n\n    constructor(\n        address _BTRFLY,\n        address _WETH,\n        address _TREASURY,\n        address _CURVEPOOL\n    ) {\n        require(_BTRFLY != address(0), \"Invalid BTRFLY address\");\n        BTRFLY = _BTRFLY;\n\n        require(_WETH != address(0), \"Invalid WETH address\");\n        WETH = _WETH;\n\n        require(_CURVEPOOL != address(0), \"Invalid POOL address\");\n        CURVEPOOL = _CURVEPOOL;\n\n        require(_TREASURY != address(0), \"Invalid TREASURY address\");\n        TREASURY = _TREASURY;\n\n        IERC20(_BTRFLY).approve(_CURVEPOOL, 2**256 - 1);\n        IERC20(_WETH).approve(_CURVEPOOL, 2**256 - 1);\n\n        _btrflyDecimals = IBTRFLY(_BTRFLY).decimals();\n        _ethDecimals = IBTRFLY(_WETH).decimals();\n    }\n\n    // Update slippage percentage (in 1000th)\n    function setSlippage(uint256 _slippage) external onlyOwner {\n        // Make sure the slippage is less than 10%\n        require(_slippage < 100, \"Slippage too high\");\n        slippage = _slippage;\n    }\n\n    // Return whether we should perform an upkeep based on the contract's BTRFLY balance\n    function checkUpkeep()\n        public\n        view\n        returns (bool upkeepNeeded)\n    {\n        if (IBTRFLY(BTRFLY).balanceOf(address(this)) > 0) {\n            return true;\n        }\n    }\n\n    // Fetch the equivalent value of either specified BTRFLY/ETH amount\n    function calculateAmountRequiredForLP(uint256 amount, bool isBTRFLY)\n        internal\n        view\n        returns (uint256)\n    {\n        // Default price is based off \"1 BTRFLY = X ETH\", in 10^18 format\n        uint256 priceOracle = ICurveCryptoPool(CURVEPOOL).price_oracle();\n\n        if (isBTRFLY) {\n            return (((amount * priceOracle) / (10**18)) * (10**_ethDecimals)) /\n                (10**_btrflyDecimals);\n        }\n\n        return\n            (((amount * (10**18)) / priceOracle) *\n                (10**_btrflyDecimals)) / (10**_ethDecimals);\n    }\n\n    // Calculate the min. LP token amount (after slippage) and attempt to add liquidity\n    function addLiquidity(uint256 ethAmount, uint256 btrflyAmount) internal {\n        uint256[2] memory amounts = [ethAmount, btrflyAmount];\n        uint256 expectedAmount = ICurveCryptoPool(CURVEPOOL).calc_token_amount(\n            amounts\n        );\n        uint256 minAmount = expectedAmount - ((expectedAmount * slippage) / 1000);\n\n        ICurveCryptoPool(CURVEPOOL).add_liquidity(amounts, minAmount);\n    }\n\n    // Perform the actual upkeep flow\n    function performUpkeep() external onlyOwner {\n        require(checkUpkeep(), \"Invalid upkeep state\");\n\n        uint256 btrfly = IBTRFLY(BTRFLY).balanceOf(address(this));\n        uint256 ethAmount = calculateAmountRequiredForLP(btrfly, true);\n        uint256 ethCap = IERC20(WETH).balanceOf(TREASURY);\n        uint256 ethLiquidity = ethCap > ethAmount ? ethAmount : ethCap;\n\n        // Use BTRFLY balance if remaining capacity is enough, otherwise, calculate BTRFLY amount\n        uint256 btrflyLiquidity = ethCap > ethAmount\n            ? btrfly\n            : calculateAmountRequiredForLP(ethLiquidity, false);\n\n        IRedactedTreasury(TREASURY).manage(WETH, ethLiquidity);\n\n        // Only complete upkeep only on sufficient amounts\n        require(ethLiquidity > 0 && btrflyLiquidity > 0, \"Insufficient amounts\");\n        addLiquidity(ethLiquidity, btrflyLiquidity);\n\n        // Transfer out the pool token to treasury\n        address token = ICurveCryptoPool(CURVEPOOL).token();\n        uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n        IERC20(token).transfer(TREASURY, tokenBalance);\n\n        uint256 unusedBTRFLY = IBTRFLY(BTRFLY).balanceOf(address(this));\n\n        if (unusedBTRFLY > 0) {\n            IBTRFLY(BTRFLY).burn(unusedBTRFLY);\n        }\n\n        emit AddLiquidity(ethLiquidity, btrflyLiquidity, unusedBTRFLY);\n    }\n\n    // Withdraw arbitrary token and amount owned by the contract\n    function withdraw(\n        address token,\n        uint256 amount,\n        address recipient\n    ) external onlyOwner {\n        require(recipient != address(0), \"Invalid recipient\");\n        IERC20(token).transfer(recipient, amount);\n    }\n}"
    }
  ]
}