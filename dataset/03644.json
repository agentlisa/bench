{
  "Title": "Possible admin control loss",
  "Content": "##### Description\nIn the current version of protocol, admin can set address of a new admin to zero, which means that nobody can call admin functions after that:\nhttps://github.com/lidofinance/steth-price-feed/blob/459495f07c97d04f6e3839e7a3b32acfcade22ad/contracts/PriceFeedProxy.sol#L106\nhttps://github.com/lidofinance/steth-price-feed/blob/459495f07c97d04f6e3839e7a3b32acfcade22ad/contracts/StEthPriceFeed.vy#L151\n##### Recommendation\nWe recommend to add simple check:\n```solidity=\nrequire(newAdmin != 0, \"Incorrect admin address\");\n```",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/PriceFeedProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"OpenZeppelin/openzeppelin-contracts@4.0.0/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\nimport \"OpenZeppelin/openzeppelin-contracts@4.0.0/contracts/utils/Address.sol\";\n\n/**\n * @dev Copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.1.0/contracts/utils/StorageSlot.sol\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n\ninterface IPriceFeed {\n    function initialize(\n        uint256 maxSafePriceDifference,\n        address stableSwapOracleAddress,\n        address curvePoolAddress,\n        address admin\n    ) external;\n}\n\ncontract PriceFeedProxy is ERC1967Proxy {\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation\n     *      specified by `priceFeedImpl`, calling its `initialize` function\n     *      on the proxy contract state.\n     */\n    constructor(\n        address priceFeedImpl,\n        uint256 maxSafePriceDifference,\n        address stableSwapOracleAddress,\n        address curvePoolAddress,\n        address admin\n    )\n        payable\n        ERC1967Proxy(\n            priceFeedImpl,\n            abi.encodeWithSelector(\n                IPriceFeed(address(0)).initialize.selector,\n                maxSafePriceDifference,\n                stableSwapOracleAddress,\n                curvePoolAddress,\n                admin\n            )\n        )\n    {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _setAdmin(admin);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function implementation() external view returns (address) {\n        return _implementation();\n    }\n\n    /**\n     * @dev Upgrades the proxy to a new implementation, optionally performing an additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @param setupCalldata Data for the setup call. The call is skipped if data is empty.\n     */\n    function upgradeTo(address newImplementation, bytes memory setupCalldata) external {\n        require(msg.sender == _getAdmin(), \"ERC1967: unauthorized\");\n        _upgradeTo(newImplementation);\n        if (setupCalldata.length > 0) {\n            Address.functionDelegateCall(newImplementation, setupCalldata, \"ERC1967: setup failed\");\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Returns the current admin of the proxy.\n     */\n    function getProxyAdmin() external view returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function changeProxyAdmin(address newAdmin) external {\n        address admin = _getAdmin();\n        require(msg.sender == admin, \"ERC1967: unauthorized\");\n        emit AdminChanged(admin, newAdmin);\n        _setAdmin(newAdmin);\n    }\n}"
    },
    {
      "filename": "contracts/StEthPriceFeed.vy",
      "content": "# SPDX-License-Identifier: MIT\n# @author Lido <info@lido.fi>\n# @version 0.2.12\n\n\nCURVE_ETH_INDEX: constant(uint256) = 0\nCURVE_STETH_INDEX: constant(uint256) = 1\n\nadmin: public(address)\nmax_safe_price_difference: public(uint256)\nsafe_price_value: public(uint256)\nsafe_price_timestamp: public(uint256)\ncurve_pool_address: public(address)\nstable_swap_oracle_address: public(address)\n\n\ninterface StableSwap:\n    def get_dy(i: int128, j: int128, x: uint256) -> uint256: view\n\n\ninterface StableSwapStateOracle:\n    def stethPrice() -> uint256: view\n\n\nevent SafePriceUpdated:\n    from_price: uint256\n    to_price: uint256\n\n\n@external\ndef initialize(\n    max_safe_price_difference: uint256,\n    stable_swap_oracle_address: address,\n    curve_pool_address: address,\n    admin: address\n):\n    \"\"\"\n    @dev Initializes the feed.\n\n    @param max_safe_price_difference maximum allowed safe price change. 10000 equals to 100%\n    @param admin Contract admin address, that's allowed to change the maximum allowed price change\n    @param curve_pool_address Curve stEth/Eth pool address\n    @param stable_swap_oracle_address Stable swap oracle address\n    \"\"\"\n    assert self.curve_pool_address == ZERO_ADDRESS\n    assert max_safe_price_difference <= 10000\n    assert stable_swap_oracle_address != ZERO_ADDRESS\n    assert curve_pool_address != ZERO_ADDRESS\n\n    self.max_safe_price_difference = max_safe_price_difference\n    self.admin = admin\n    self.stable_swap_oracle_address = stable_swap_oracle_address\n    self.curve_pool_address = curve_pool_address\n\n\n@view\n@internal\ndef _percentage_diff(new: uint256, old: uint256) -> uint256:\n    if new > old :\n        return (new - old) * 10000 / old\n    else:\n        return (old - new) * 10000 / old\n\n\n@view\n@external\ndef safe_price() -> (uint256, uint256):\n    \"\"\"\n    @dev Returns the cached safe price and its timestamp. Reverts if no cached price was set.\n    \"\"\"\n    safe_price_timestamp: uint256 = self.safe_price_timestamp\n    assert safe_price_timestamp != 0\n    return (self.safe_price_value, safe_price_timestamp)\n\n\n@view\n@internal\ndef _current_price() -> (uint256, bool, uint256):\n    pool_price: uint256 = StableSwap(self.curve_pool_address).get_dy(CURVE_STETH_INDEX, CURVE_ETH_INDEX, 10**18)\n    oracle_price: uint256 = StableSwapStateOracle(self.stable_swap_oracle_address).stethPrice()\n    has_changed_unsafely: bool = self._percentage_diff(pool_price, oracle_price) > self.max_safe_price_difference\n    return (pool_price, has_changed_unsafely, oracle_price)\n\n\n@view\n@external\ndef current_price() -> (uint256, bool, uint256):\n    \"\"\"\n    @dev Returns the current pool price and whether the price is safe.\n    \"\"\"\n    current_price: uint256 = 0\n    has_changed_unsafely: bool = True\n    oracle_price: uint256 = 0\n    current_price, has_changed_unsafely, oracle_price = self._current_price()\n    is_safe: bool = current_price <= 10**18 and not has_changed_unsafely\n    return (current_price, is_safe, oracle_price)\n\n\n@internal\ndef _update_safe_price() -> uint256:\n    price: uint256 = 0\n    has_changed_unsafely: bool = True\n    _: uint256 = 0\n    price, has_changed_unsafely, _ = self._current_price()\n    assert not has_changed_unsafely, \"price is not safe\"\n\n    price = min(10**18, price)\n    log SafePriceUpdated(self.safe_price_value, price)\n\n    self.safe_price_value = price\n    self.safe_price_timestamp = block.timestamp\n\n    return price\n\n\n@external\ndef update_safe_price() -> uint256:\n    \"\"\"\n    @dev Sets the cached safe price to the current pool price.\n\n    If the price is higher than 10**18, sets the cached safe price to 10**18.\n    If the price is not safe for any other reason, reverts.\n    \"\"\"\n    return self._update_safe_price()\n\n\n@external\ndef fetch_safe_price(max_age: uint256) -> (uint256, uint256):\n    \"\"\"\n    @dev Returns the cached safe price and its timestamp.\n\n    Calls `update_safe_price()` prior to that if the cached safe price\n    is older than `max_age` seconds.\n    \"\"\"\n    safe_price_timestamp: uint256 = self.safe_price_timestamp\n    if safe_price_timestamp == 0 or block.timestamp - safe_price_timestamp > max_age:\n        price: uint256 = self._update_safe_price()\n        return (price, block.timestamp)\n    else:\n        return (self.safe_price_value, safe_price_timestamp)\n\n\n@external\ndef set_admin(admin: address):\n    \"\"\"\n    @dev Updates the admin address.\n\n    May only be called by the current admin.\n    \"\"\"\n    assert msg.sender == self.admin\n    self.admin = admin\n\n\n@external\ndef set_max_safe_price_difference(max_safe_price_difference: uint256):\n    \"\"\"\n    @dev Updates the maximum difference between the safe price and the time-shifted price.\n\n    May only be called by the admin.\n    \"\"\"\n    assert msg.sender == self.admin\n    assert max_safe_price_difference <= 10000\n    self.max_safe_price_difference = max_safe_price_difference"
    }
  ]
}