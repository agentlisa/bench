{
  "Title": "[G-05] require() or revert() statements that check input arguments should be at the top of the function (Also restructured some if's)",
  "Content": "\n**Fail early and cheaply**\n\nChecks that involve constants should come before checks that involve state variables, function calls, and calculations. By doing these checks first, the function is able to revert before wasting alot of gas in a function that may ultimately revert in the unhappy case.\n\nhttps://github.com/AstariaXYZ/astaria-gpl/blob/4b49fe993d9b807fe68b3421ee7f2fe91267c9ef/src/ERC721.sol#L106-L124\n```solidity\nFile: /src/ERC721.sol\n106:  function transferFrom(\n107:    address from,\n108:    address to,\n109:    uint256 id\n110:  ) public virtual override(IERC721) {\n111:    ERC721Storage storage s = _loadERC721Slot();\n\n113:    require(from == s._ownerOf[id], \"WRONG_FROM\");\n\n115:    require(to != address(0), \"INVALID_RECIPIENT\");\n```\n\n```diff\ndiff --git a/src/ERC721.sol b/src/ERC721.sol\nindex 232ccb9..a31968e 100644\n--- a/src/ERC721.sol\n+++ b/src/ERC721.sol\n@@ -108,12 +108,13 @@ abstract contract ERC721 is Initializable, IERC721 {\n     address to,\n     uint256 id\n   ) public virtual override(IERC721) {\n+\n+    require(to != address(0), \"INVALID_RECIPIENT\");\n\n     ERC721Storage storage s = _loadERC721Slot();\n\n     require(from == s._ownerOf[id], \"WRONG_FROM\");\n\n-    require(to != address(0), \"INVALID_RECIPIENT\");\n     require(\n       msg.sender == from ||\n         s.isApprovedForAll[from][msg.sender] ||\n```\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L64-L71\n```solidity\nFile: /src/VaultImplementation.sol\n64:  function incrementNonce() external {\n65:    VIData storage s = _loadVISlot();\n66:    if (msg.sender != owner() && msg.sender != s.delegate) {\n67:      revert InvalidRequest(InvalidRequestReason.NO_AUTHORITY);\n68:    }\n69:    s.strategistNonce++;\n70:    emit NonceUpdated(s.strategistNonce);\n71:  }\n```\n\nSince we revert on two occassions ie `msg.sender != owner() && msg.sender != s.delegate` which means that both of those conditions need to be true, we could save some gas used in evaluating the line `VIData storage s = _loadVISlot();` if it so happens that `msg.sender` is not equal to `owner()`. Working as it is, even if the first condition fails, we would have already sent some gas evaluating `VIData storage s = _loadVISlot();` Splitting the if's would avoid the unneccessary wastage of gas incase we fail at the check `msg.sender != owner()`\n\n```diff\ndiff --git a/src/VaultImplementation.sol b/src/VaultImplementation.sol\nindex b5ff5d7..ae86f0f 100644\n--- a/src/VaultImplementation.sol\n+++ b/src/VaultImplementation.sol\n@@ -62,8 +62,11 @@ abstract contract VaultImplementation is\n   }\n\n   function incrementNonce() external {\n+    if (msg.sender != owner()){\n+     revert InvalidRequest(InvalidRequestReason.NO_AUTHORITY);\n+    }\n     VIData storage s = _loadVISlot();\n-    if (msg.sender != owner() && msg.sender != s.delegate) {\n+    if (msg.sender != s.delegate) {\n       revert InvalidRequest(InvalidRequestReason.NO_AUTHORITY);\n     }\n     s.strategistNonce++;\n```\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L524-L539\n```solidity\nFile: /src/CollateralToken.sol\n524: function settleAuction(uint256 collateralId) public {\n525:    CollateralStorage storage s = _loadCollateralSlot();\n526:    if (\n527:      s.collateralIdToAuction[collateralId] == bytes32(0) &&\n528:      ERC721(s.idToUnderlying[collateralId].tokenContract).ownerOf(\n529:        s.idToUnderlying[collateralId].tokenId\n530:      ) !=\n531:      s.clearingHouse[collateralId]\n532:    ) {\n533:      revert InvalidCollateralState(InvalidCollateralStates.NO_AUCTION);\n534:    }\n535:    require(msg.sender == s.clearingHouse[collateralId]);\n```\n\n```diff\ndiff --git a/src/CollateralToken.sol b/src/CollateralToken.sol\nindex c82b400..6640cca 100644\n--- a/src/CollateralToken.sol\n+++ b/src/CollateralToken.sol\n@@ -523,6 +523,8 @@ contract CollateralToken is\n\n   function settleAuction(uint256 collateralId) public {\n     CollateralStorage storage s = _loadCollateralSlot();\n+    require(msg.sender == s.clearingHouse[collateralId]);\n     if (\n       s.collateralIdToAuction[collateralId] == bytes32(0) &&\n       ERC721(s.idToUnderlying[collateralId].tokenContract).ownerOf(\n@@ -532,7 +534,6 @@ contract CollateralToken is\n     ) {\n       revert InvalidCollateralState(InvalidCollateralStates.NO_AUCTION);\n     }\n-    require(msg.sender == s.clearingHouse[collateralId]);\n     _settleAuction(s, collateralId);\n     delete s.idToUnderlying[collateralId];\n     _burn(collateralId);\n```\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L109-L143\n```solidity\nFile: /src/CollateralToken.sol\n109:  function liquidatorNFTClaim(OrderParameters memory params) external {\n110:    CollateralStorage storage s = _loadCollateralSlot();\n\n112:    uint256 collateralId = params.offer[0].token.computeId(\n113:      params.offer[0].identifierOrCriteria\n114:    );\n115:    address liquidator = s.LIEN_TOKEN.getAuctionLiquidator(collateralId);\n116:    if (\n117:      s.collateralIdToAuction[collateralId] == bytes32(0) ||\n118:      liquidator == address(0)\n119:    ) {\n120:      //revert no auction\n121:      revert InvalidCollateralState(InvalidCollateralStates.NO_AUCTION);\n122:    }\n123:    if (\n124:      s.collateralIdToAuction[collateralId] != keccak256(abi.encode(params))\n125:    ) {\n126:      //revert auction params dont match\n127:      revert InvalidCollateralState(\n128:        InvalidCollateralStates.INVALID_AUCTION_PARAMS\n129:      );\n130:    }\n\n132:    if (block.timestamp < params.endTime) {\n133:      //auction hasn't ended yet\n134:      revert InvalidCollateralState(InvalidCollateralStates.AUCTION_ACTIVE);\n135:    }\n```\n\n```diff\ndiff --git a/src/CollateralToken.sol b/src/CollateralToken.sol\nindex c82b400..46341f3 100644\n--- a/src/CollateralToken.sol\n+++ b/src/CollateralToken.sol\n@@ -107,6 +107,11 @@ contract CollateralToken is\n   }\n\n   function liquidatorNFTClaim(OrderParameters memory params) external {\n+\n+    if (block.timestamp < params.endTime) {\n+      //auction hasn't ended yet\n+      revert InvalidCollateralState(InvalidCollateralStates.AUCTION_ACTIVE);\n+    }\n     CollateralStorage storage s = _loadCollateralSlot();\n\n     uint256 collateralId = params.offer[0].token.computeId(\n@@ -129,10 +134,6 @@ contract CollateralToken is\n       );\n     }\n\n-    if (block.timestamp < params.endTime) {\n-      //auction hasn't ended yet\n-      revert InvalidCollateralState(InvalidCollateralStates.AUCTION_ACTIVE);\n-    }\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-01-astaria",
  "Code": [
    {
      "filename": "src/VaultImplementation.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**                                                     \n*  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗ \n* ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n* ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n* ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n* ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n* ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n*\n* Astaria Labs, Inc\n*/\n\npragma solidity =0.8.17;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC721, ERC721TokenReceiver} from \"solmate/tokens/ERC721.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {CollateralLookup} from \"core/libraries/CollateralLookup.sol\";\n\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {LienToken} from \"core/LienToken.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\nimport {IPublicVault} from \"core/interfaces/IPublicVault.sol\";\nimport {AstariaVaultBase} from \"core/AstariaVaultBase.sol\";\nimport {IVaultImplementation} from \"core/interfaces/IVaultImplementation.sol\";\nimport {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\n\n/**\n * @title VaultImplementation\n * @notice A base implementation for the minimal features of an Astaria Vault.\n */\nabstract contract VaultImplementation is\n  AstariaVaultBase,\n  ERC721TokenReceiver,\n  IVaultImplementation\n{\n  using SafeTransferLib for ERC20;\n  using SafeCastLib for uint256;\n  using CollateralLookup for address;\n  using FixedPointMathLib for uint256;\n\n  bytes32 public constant STRATEGY_TYPEHASH =\n    keccak256(\"StrategyDetails(uint256 nonce,uint256 deadline,bytes32 root)\");\n\n  bytes32 constant EIP_DOMAIN =\n    keccak256(\n      \"EIP712Domain(string version,uint256 chainId,address verifyingContract)\"\n    );\n  bytes32 constant VERSION = keccak256(\"0\");\n\n  function name() external view virtual override returns (string memory);\n\n  function symbol() external view virtual override returns (string memory);\n\n  uint256 private constant VI_SLOT =\n    uint256(keccak256(\"xyz.astaria.VaultImplementation.storage.location\")) - 1;\n\n  function getStrategistNonce() external view returns (uint256) {\n    return _loadVISlot().strategistNonce;\n  }\n\n  function incrementNonce() external {\n    VIData storage s = _loadVISlot();\n    if (msg.sender != owner() && msg.sender != s.delegate) {\n      revert InvalidRequest(InvalidRequestReason.NO_AUTHORITY);\n    }\n    s.strategistNonce++;\n    emit NonceUpdated(s.strategistNonce);\n  }\n\n  /**\n   * @notice modify the deposit cap for the vault\n   * @param newCap The deposit cap.\n   */\n  function modifyDepositCap(uint256 newCap) external {\n    require(msg.sender == owner()); //owner is \"strategist\"\n    _loadVISlot().depositCap = newCap.safeCastTo88();\n  }\n\n  function _loadVISlot() internal pure returns (VIData storage s) {\n    uint256 slot = VI_SLOT;\n\n    assembly {\n      s.slot := slot\n    }\n  }\n\n  /**\n   * @notice modify the allowlist for the vault\n   * @param depositor the depositor to modify\n   * @param enabled the status of the depositor\n   */\n  function modifyAllowList(address depositor, bool enabled) external virtual {\n    require(msg.sender == owner()); //owner is \"strategist\"\n    _loadVISlot().allowList[depositor] = enabled;\n    emit AllowListUpdated(depositor, enabled);\n  }\n\n  /**\n   * @notice disable the allowList for the vault\n   */\n  function disableAllowList() external virtual {\n    require(msg.sender == owner()); //owner is \"strategist\"\n    _loadVISlot().allowListEnabled = false;\n    emit AllowListEnabled(false);\n  }\n\n  /**\n   * @notice enable the allowList for the vault\n   */\n  function enableAllowList() external virtual {\n    require(msg.sender == owner()); //owner is \"strategist\"\n    _loadVISlot().allowListEnabled = true;\n    emit AllowListEnabled(true);\n  }\n\n  /**\n   * @notice receive hook for ERC721 tokens, nothing special done\n   */\n  function onERC721Received(\n    address, // operator_\n    address, // from_\n    uint256, // tokenId_\n    bytes calldata // data_\n  ) external pure override returns (bytes4) {\n    return ERC721TokenReceiver.onERC721Received.selector;\n  }\n\n  modifier whenNotPaused() {\n    if (ROUTER().paused()) {\n      revert InvalidRequest(InvalidRequestReason.PAUSED);\n    }\n\n    if (_loadVISlot().isShutdown) {\n      revert InvalidRequest(InvalidRequestReason.SHUTDOWN);\n    }\n    _;\n  }\n\n  function getShutdown() external view returns (bool) {\n    return _loadVISlot().isShutdown;\n  }\n\n  function shutdown() external {\n    require(msg.sender == owner()); //owner is \"strategist\"\n    _loadVISlot().isShutdown = true;\n    emit VaultShutdown();\n  }\n\n  function domainSeparator() public view virtual returns (bytes32) {\n    return\n      keccak256(\n        abi.encode(\n          EIP_DOMAIN,\n          VERSION, //version\n          block.chainid,\n          address(this)\n        )\n      );\n  }\n\n  /*\n   * @notice encodes the data for a 712 signature\n   * @param tokenContract The address of the token contract\n   * @param tokenId The id of the token\n   * @param amount The amount of the token\n   */\n  function encodeStrategyData(\n    IAstariaRouter.StrategyDetailsParam calldata strategy,\n    bytes32 root\n  ) external view returns (bytes memory) {\n    VIData storage s = _loadVISlot();\n    return _encodeStrategyData(s, strategy, root);\n  }\n\n  function _encodeStrategyData(\n    VIData storage s,\n    IAstariaRouter.StrategyDetailsParam calldata strategy,\n    bytes32 root\n  ) internal view returns (bytes memory) {\n    bytes32 hash = keccak256(\n      abi.encode(STRATEGY_TYPEHASH, s.strategistNonce, strategy.deadline, root)\n    );\n    return\n      abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), hash);\n  }\n\n  function init(InitParams calldata params) external virtual {\n    require(msg.sender == address(ROUTER()));\n    VIData storage s = _loadVISlot();\n\n    if (params.delegate != address(0)) {\n      s.delegate = params.delegate;\n    }\n    s.depositCap = params.depositCap.safeCastTo88();\n    if (params.allowListEnabled) {\n      s.allowListEnabled = true;\n      uint256 i;\n      for (; i < params.allowList.length; ) {\n        s.allowList[params.allowList[i]] = true;\n        unchecked {\n          ++i;\n        }\n      }\n    }\n  }\n\n  function setDelegate(address delegate_) external {\n    require(msg.sender == owner()); //owner is \"strategist\"\n    VIData storage s = _loadVISlot();\n    s.delegate = delegate_;\n    emit DelegateUpdated(delegate_);\n    emit AllowListUpdated(delegate_, true);\n  }\n\n  /**\n   * @dev Validates the terms for a requested loan.\n   * Who is requesting the borrow, is it a smart contract? or is it a user?\n   * if a smart contract, then ensure that the contract is approved to borrow and is also receiving the funds.\n   * if a user, then ensure that the user is approved to borrow and is also receiving the funds.\n   * The terms are hashed and signed by the borrower, and the signature validated against the strategist's address\n   * lien details are decoded from the obligation data and validated the collateral\n   *\n   * @param params The Commitment information containing the loan parameters and the merkle proof for the strategy supporting the requested loan.\n   * @param receiver The address of the prospective borrower.\n   */\n  function _validateCommitment(\n    IAstariaRouter.Commitment calldata params,\n    address receiver\n  ) internal view {\n    uint256 collateralId = params.tokenContract.computeId(params.tokenId);\n    ERC721 CT = ERC721(address(COLLATERAL_TOKEN()));\n    address holder = CT.ownerOf(collateralId);\n    address operator = CT.getApproved(collateralId);\n    if (\n      msg.sender != holder &&\n      receiver != holder &&\n      receiver != operator &&\n      !CT.isApprovedForAll(holder, msg.sender)\n    ) {\n      revert InvalidRequest(InvalidRequestReason.NO_AUTHORITY);\n    }\n    VIData storage s = _loadVISlot();\n    address recovered = ecrecover(\n      keccak256(\n        _encodeStrategyData(\n          s,\n          params.lienRequest.strategy,\n          params.lienRequest.merkle.root\n        )\n      ),\n      params.lienRequest.v,\n      params.lienRequest.r,\n      params.lienRequest.s\n    );\n    if (\n      (recovered != owner() && recovered != s.delegate) ||\n      recovered == address(0)\n    ) {\n      revert IVaultImplementation.InvalidRequest(\n        InvalidRequestReason.INVALID_SIGNATURE\n      );\n    }\n  }\n\n  function _afterCommitToLien(\n    uint40 end,\n    uint256 lienId,\n    uint256 slope\n  ) internal virtual {}\n\n  function _beforeCommitToLien(IAstariaRouter.Commitment calldata)\n    internal\n    virtual\n  {}\n\n  /**\n   * @notice Pipeline for lifecycle of new loan origination.\n   * Origination consists of a few phases: pre-commitment validation, lien token issuance, strategist reward, and after commitment actions\n   * Starts by depositing collateral and take optimized-out a lien against it. Next, verifies the merkle proof for a loan commitment. Vault owners are then rewarded fees for successful loan origination.\n   * @param params Commitment data for the incoming lien request\n   * @param receiver The borrower receiving the loan.\n   * @return lienId The id of the newly minted lien token.\n   */\n  function commitToLien(\n    IAstariaRouter.Commitment calldata params,\n    address receiver\n  )\n    external\n    whenNotPaused\n    returns (uint256 lienId, ILienToken.Stack[] memory stack, uint256 payout)\n  {\n    _beforeCommitToLien(params);\n    uint256 slopeAddition;\n    (lienId, stack, slopeAddition, payout) = _requestLienAndIssuePayout(\n      params,\n      receiver\n    );\n    _afterCommitToLien(\n      stack[stack.length - 1].point.end,\n      lienId,\n      slopeAddition\n    );\n  }\n\n  /**\n   * @notice Buy optimized-out a lien to replace it with new terms.\n   * @param position The position of the specified lien.\n   * @param incomingTerms The loan terms of the new lien.\n   */\n  function buyoutLien(\n    ILienToken.Stack[] calldata stack,\n    uint8 position,\n    IAstariaRouter.Commitment calldata incomingTerms\n  )\n    external\n    whenNotPaused\n    returns (ILienToken.Stack[] memory, ILienToken.Stack memory)\n  {\n    LienToken lienToken = LienToken(address(ROUTER().LIEN_TOKEN()));\n\n    (uint256 owed, uint256 buyout) = lienToken.getBuyout(stack[position]);\n\n    if (buyout > ERC20(asset()).balanceOf(address(this))) {\n      revert IVaultImplementation.InvalidRequest(\n        InvalidRequestReason.INSUFFICIENT_FUNDS\n      );\n    }\n\n    _validateCommitment(incomingTerms, recipient());\n\n    ERC20(asset()).safeApprove(address(ROUTER().TRANSFER_PROXY()), buyout);\n\n    return\n      lienToken.buyoutLien(\n        ILienToken.LienActionBuyout({\n          position: position,\n          encumber: ILienToken.LienActionEncumber({\n            amount: owed,\n            receiver: recipient(),\n            lien: ROUTER().validateCommitment({\n              commitment: incomingTerms,\n              timeToSecondEpochEnd: _timeToSecondEndIfPublic()\n            }),\n            stack: stack\n          })\n        })\n      );\n  }\n\n  function _timeToSecondEndIfPublic()\n    internal\n    view\n    virtual\n    returns (uint256 timeToSecondEpochEnd)\n  {\n    return 0;\n  }\n\n  /**\n   * @notice Retrieves the recipient of loan repayments. For PublicVaults (VAULT_TYPE 2), this is always the vault address. For PrivateVaults, retrieves the owner() of the vault.\n   * @return The address of the recipient.\n   */\n  function recipient() public view returns (address) {\n    if (IMPL_TYPE() == uint8(IAstariaRouter.ImplementationType.PublicVault)) {\n      return address(this);\n    } else {\n      return owner();\n    }\n  }\n\n  /**\n   * @dev Generates a Lien for a valid loan commitment proof and sends the loan amount to the borrower.\n   * @param c The Commitment information containing the loan parameters and the merkle proof for the strategy supporting the requested loan.\n   * @param receiver The borrower requesting the loan.\n   */\n  function _requestLienAndIssuePayout(\n    IAstariaRouter.Commitment calldata c,\n    address receiver\n  )\n    internal\n    returns (\n      uint256 newLienId,\n      ILienToken.Stack[] memory stack,\n      uint256 slope,\n      uint256 payout\n    )\n  {\n    _validateCommitment(c, receiver);\n    (newLienId, stack, slope) = ROUTER().requestLienPosition(c, recipient());\n    payout = _handleProtocolFee(c.lienRequest.amount);\n    ERC20(asset()).safeTransfer(receiver, payout);\n  }\n\n  function _handleProtocolFee(uint256 amount) internal returns (uint256) {\n    address feeTo = ROUTER().feeTo();\n    bool feeOn = feeTo != address(0);\n    if (feeOn) {\n      uint256 fee = ROUTER().getProtocolFee(amount);\n\n      unchecked {\n        amount -= fee;\n      }\n      ERC20(asset()).safeTransfer(feeTo, fee);\n    }\n    return amount;\n  }\n}"
    },
    {
      "filename": "src/CollateralToken.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**\n *  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗\n * ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n * ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n * ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n * ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n * ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n *\n * Astaria Labs, Inc\n */\n\npragma solidity =0.8.17;\n\npragma experimental ABIEncoderV2;\n\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {ICollateralToken} from \"core/interfaces/ICollateralToken.sol\";\nimport {IERC165} from \"core/interfaces/IERC165.sol\";\nimport {IERC721} from \"core/interfaces/IERC721.sol\";\nimport {IERC721Receiver} from \"core/interfaces/IERC721Receiver.sol\";\nimport {IFlashAction} from \"core/interfaces/IFlashAction.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\nimport {ISecurityHook} from \"core/interfaces/ISecurityHook.sol\";\nimport {ITransferProxy} from \"core/interfaces/ITransferProxy.sol\";\nimport {Authority} from \"solmate/auth/Auth.sol\";\nimport {CollateralLookup} from \"core/libraries/CollateralLookup.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC721} from \"gpl/ERC721.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {VaultImplementation} from \"core/VaultImplementation.sol\";\nimport {ZoneInterface} from \"seaport/interfaces/ZoneInterface.sol\";\nimport {Bytes32AddressLib} from \"solmate/utils/Bytes32AddressLib.sol\";\nimport {\n  ClonesWithImmutableArgs\n} from \"clones-with-immutable-args/ClonesWithImmutableArgs.sol\";\n\nimport {\n  ConduitControllerInterface\n} from \"seaport/interfaces/ConduitControllerInterface.sol\";\nimport {\n  ConsiderationInterface\n} from \"seaport/interfaces/ConsiderationInterface.sol\";\nimport {\n  AdvancedOrder,\n  CriteriaResolver,\n  OfferItem,\n  ConsiderationItem,\n  ItemType,\n  OrderParameters,\n  OrderComponents,\n  OrderType,\n  Order\n} from \"seaport/lib/ConsiderationStructs.sol\";\n\nimport {Consideration} from \"seaport/lib/Consideration.sol\";\nimport {SeaportInterface} from \"seaport/interfaces/SeaportInterface.sol\";\nimport {ClearingHouse} from \"core/ClearingHouse.sol\";\nimport {AuthInitializable} from \"core/AuthInitializable.sol\";\n\ncontract CollateralToken is\n  AuthInitializable,\n  ERC721,\n  IERC721Receiver,\n  ICollateralToken,\n  ZoneInterface\n{\n  using SafeTransferLib for ERC20;\n  using CollateralLookup for address;\n  using FixedPointMathLib for uint256;\n  uint256 private constant COLLATERAL_TOKEN_SLOT =\n    uint256(keccak256(\"xyz.astaria.CollateralToken.storage.location\")) - 1;\n\n  constructor() {\n    _disableInitializers();\n  }\n\n  function initialize(\n    Authority AUTHORITY_,\n    ITransferProxy TRANSFER_PROXY_,\n    ILienToken LIEN_TOKEN_,\n    ConsiderationInterface SEAPORT_\n  ) public initializer {\n    __initAuth(msg.sender, address(AUTHORITY_));\n    __initERC721(\"Astaria Collateral Token\", \"ACT\");\n    CollateralStorage storage s = _loadCollateralSlot();\n    s.TRANSFER_PROXY = TRANSFER_PROXY_;\n    s.LIEN_TOKEN = LIEN_TOKEN_;\n    s.SEAPORT = SEAPORT_;\n    (, , address conduitController) = s.SEAPORT.information();\n    bytes32 CONDUIT_KEY = Bytes32AddressLib.fillLast12Bytes(address(this));\n    s.CONDUIT_KEY = CONDUIT_KEY;\n    s.CONDUIT_CONTROLLER = ConduitControllerInterface(conduitController);\n\n    s.CONDUIT = s.CONDUIT_CONTROLLER.createConduit(CONDUIT_KEY, address(this));\n    s.CONDUIT_CONTROLLER.updateChannel(\n      address(s.CONDUIT),\n      address(SEAPORT_),\n      true\n    );\n  }\n\n  function SEAPORT() public view returns (ConsiderationInterface) {\n    return _loadCollateralSlot().SEAPORT;\n  }\n\n  function liquidatorNFTClaim(OrderParameters memory params) external {\n    CollateralStorage storage s = _loadCollateralSlot();\n\n    uint256 collateralId = params.offer[0].token.computeId(\n      params.offer[0].identifierOrCriteria\n    );\n    address liquidator = s.LIEN_TOKEN.getAuctionLiquidator(collateralId);\n    if (\n      s.collateralIdToAuction[collateralId] == bytes32(0) ||\n      liquidator == address(0)\n    ) {\n      //revert no auction\n      revert InvalidCollateralState(InvalidCollateralStates.NO_AUCTION);\n    }\n    if (\n      s.collateralIdToAuction[collateralId] != keccak256(abi.encode(params))\n    ) {\n      //revert auction params dont match\n      revert InvalidCollateralState(\n        InvalidCollateralStates.INVALID_AUCTION_PARAMS\n      );\n    }\n\n    if (block.timestamp < params.endTime) {\n      //auction hasn't ended yet\n      revert InvalidCollateralState(InvalidCollateralStates.AUCTION_ACTIVE);\n    }\n\n    Asset memory underlying = s.idToUnderlying[collateralId];\n    address tokenContract = underlying.tokenContract;\n    uint256 tokenId = underlying.tokenId;\n    ClearingHouse CH = ClearingHouse(payable(s.clearingHouse[collateralId]));\n    CH.settleLiquidatorNFTClaim();\n    _releaseToAddress(s, underlying, collateralId, liquidator);\n  }\n\n  function _loadCollateralSlot()\n    internal\n    pure\n    returns (CollateralStorage storage s)\n  {\n    uint256 slot = COLLATERAL_TOKEN_SLOT;\n\n    assembly {\n      s.slot := slot\n    }\n  }\n\n  function isValidOrder(\n    bytes32 orderHash,\n    address caller,\n    address offerer,\n    bytes32 zoneHash\n  ) external view returns (bytes4 validOrderMagicValue) {\n    CollateralStorage storage s = _loadCollateralSlot();\n    return\n      s.collateralIdToAuction[uint256(zoneHash)] == orderHash\n        ? ZoneInterface.isValidOrder.selector\n        : bytes4(0xffffffff);\n  }\n\n  // Called by Consideration whenever any extraData is provided by the caller.\n  function isValidOrderIncludingExtraData(\n    bytes32 orderHash,\n    address caller,\n    AdvancedOrder calldata order,\n    bytes32[] calldata priorOrderHashes,\n    CriteriaResolver[] calldata criteriaResolvers\n  ) external view returns (bytes4 validOrderMagicValue) {\n    CollateralStorage storage s = _loadCollateralSlot();\n    return\n      s.collateralIdToAuction[uint256(order.parameters.zoneHash)] == orderHash\n        ? ZoneInterface.isValidOrder.selector\n        : bytes4(0xffffffff);\n  }\n\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC721, IERC165)\n    returns (bool)\n  {\n    return\n      interfaceId == type(ICollateralToken).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  function fileBatch(File[] calldata files) external requiresAuth {\n    uint256 i;\n    for (; i < files.length; ) {\n      _file(files[i]);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function file(File calldata incoming) public requiresAuth {\n    _file(incoming);\n  }\n\n  function _file(File calldata incoming) internal {\n    CollateralStorage storage s = _loadCollateralSlot();\n\n    FileType what = incoming.what;\n    bytes memory data = incoming.data;\n    if (what == FileType.AstariaRouter) {\n      address addr = abi.decode(data, (address));\n      s.ASTARIA_ROUTER = IAstariaRouter(addr);\n    } else if (what == FileType.SecurityHook) {\n      (address target, address hook) = abi.decode(data, (address, address));\n      s.securityHooks[target] = hook;\n    } else if (what == FileType.FlashEnabled) {\n      (address target, bool enabled) = abi.decode(data, (address, bool));\n      s.flashEnabled[target] = enabled;\n    } else if (what == FileType.Seaport) {\n      s.SEAPORT = ConsiderationInterface(abi.decode(data, (address)));\n      (, , address conduitController) = s.SEAPORT.information();\n      if (s.CONDUIT_KEY == bytes32(0)) {\n        s.CONDUIT_KEY = Bytes32AddressLib.fillLast12Bytes(address(this));\n      }\n      s.CONDUIT_CONTROLLER = ConduitControllerInterface(conduitController);\n      (address conduit, bool exists) = s.CONDUIT_CONTROLLER.getConduit(\n        s.CONDUIT_KEY\n      );\n      if (!exists) {\n        s.CONDUIT = s.CONDUIT_CONTROLLER.createConduit(\n          s.CONDUIT_KEY,\n          address(this)\n        );\n      } else {\n        s.CONDUIT = conduit;\n      }\n      s.CONDUIT_CONTROLLER.updateChannel(\n        address(s.CONDUIT),\n        address(s.SEAPORT),\n        true\n      );\n    } else {\n      revert UnsupportedFile();\n    }\n    emit FileUpdated(what, data);\n  }\n\n  modifier releaseCheck(uint256 collateralId) {\n    CollateralStorage storage s = _loadCollateralSlot();\n\n    if (s.LIEN_TOKEN.getCollateralState(collateralId) != bytes32(0)) {\n      revert InvalidCollateralState(InvalidCollateralStates.ACTIVE_LIENS);\n    }\n    if (s.collateralIdToAuction[collateralId] != bytes32(0)) {\n      revert InvalidCollateralState(InvalidCollateralStates.AUCTION_ACTIVE);\n    }\n    _;\n  }\n\n  modifier onlyOwner(uint256 collateralId) {\n    require(ownerOf(collateralId) == msg.sender);\n    _;\n  }\n\n  function flashAction(\n    IFlashAction receiver,\n    uint256 collateralId,\n    bytes calldata data\n  ) external onlyOwner(collateralId) {\n    address addr;\n    uint256 tokenId;\n    CollateralStorage storage s = _loadCollateralSlot();\n    (addr, tokenId) = getUnderlying(collateralId);\n\n    if (!s.flashEnabled[addr]) {\n      revert InvalidCollateralState(InvalidCollateralStates.FLASH_DISABLED);\n    }\n\n    if (\n      s.LIEN_TOKEN.getCollateralState(collateralId) == bytes32(\"ACTIVE_AUCTION\")\n    ) {\n      revert InvalidCollateralState(InvalidCollateralStates.AUCTION_ACTIVE);\n    }\n\n    bytes32 preTransferState;\n    //look to see if we have a security handler for this asset\n\n    address securityHook = s.securityHooks[addr];\n    if (securityHook != address(0)) {\n      preTransferState = ISecurityHook(securityHook).getState(addr, tokenId);\n    }\n    // transfer the NFT to the destination optimistically\n\n    ClearingHouse(s.clearingHouse[collateralId]).transferUnderlying(\n      addr,\n      tokenId,\n      address(receiver)\n    );\n\n    //trigger the flash action on the receiver\n    if (\n      receiver.onFlashAction(\n        IFlashAction.Underlying(s.clearingHouse[collateralId], addr, tokenId),\n        data\n      ) != keccak256(\"FlashAction.onFlashAction\")\n    ) {\n      revert FlashActionCallbackFailed();\n    }\n\n    if (\n      securityHook != address(0) &&\n      preTransferState != ISecurityHook(securityHook).getState(addr, tokenId)\n    ) {\n      revert FlashActionSecurityCheckFailed();\n    }\n\n    // validate that the NFT returned after the call\n\n    if (\n      IERC721(addr).ownerOf(tokenId) != address(s.clearingHouse[collateralId])\n    ) {\n      revert FlashActionNFTNotReturned();\n    }\n  }\n\n  function releaseToAddress(uint256 collateralId, address releaseTo)\n    public\n    releaseCheck(collateralId)\n    onlyOwner(collateralId)\n  {\n    CollateralStorage storage s = _loadCollateralSlot();\n\n    if (msg.sender != ownerOf(collateralId)) {\n      revert InvalidSender();\n    }\n    Asset memory underlying = s.idToUnderlying[collateralId];\n    address tokenContract = underlying.tokenContract;\n    _burn(collateralId);\n    delete s.idToUnderlying[collateralId];\n    _releaseToAddress(s, underlying, collateralId, releaseTo);\n  }\n\n  /**\n   * @dev Transfers locked collateral to a specified address and deletes the reference to the CollateralToken for that NFT.\n   * @param releaseTo The address to send the NFT to.\n   */\n  function _releaseToAddress(\n    CollateralStorage storage s,\n    Asset memory underlyingAsset,\n    uint256 collateralId,\n    address releaseTo\n  ) internal {\n    ClearingHouse(s.clearingHouse[collateralId]).transferUnderlying(\n      underlyingAsset.tokenContract,\n      underlyingAsset.tokenId,\n      releaseTo\n    );\n    emit ReleaseTo(\n      underlyingAsset.tokenContract,\n      underlyingAsset.tokenId,\n      releaseTo\n    );\n  }\n\n  function getConduitKey() public view returns (bytes32) {\n    CollateralStorage storage s = _loadCollateralSlot();\n    return s.CONDUIT_KEY;\n  }\n\n  function getConduit() public view returns (address) {\n    CollateralStorage storage s = _loadCollateralSlot();\n    return s.CONDUIT;\n  }\n\n  /**\n   * @notice Retrieve the address and tokenId of the underlying NFT of a CollateralToken.\n   * @param collateralId The ID of the CollateralToken wrapping the NFT.\n   * @return The address and tokenId of the underlying NFT.\n   */\n  function getUnderlying(uint256 collateralId)\n    public\n    view\n    returns (address, uint256)\n  {\n    Asset memory underlying = _loadCollateralSlot().idToUnderlying[\n      collateralId\n    ];\n    return (underlying.tokenContract, underlying.tokenId);\n  }\n\n  /**\n   * @notice Retrieve the tokenURI for a CollateralToken.\n   * @param collateralId The ID of the CollateralToken.\n   * @return the URI of the CollateralToken.\n   */\n  function tokenURI(uint256 collateralId)\n    public\n    view\n    virtual\n    override(ERC721, IERC721)\n    returns (string memory)\n  {\n    (address underlyingAsset, uint256 assetId) = getUnderlying(collateralId);\n    return ERC721(underlyingAsset).tokenURI(assetId);\n  }\n\n  function securityHooks(address target) public view returns (address) {\n    return _loadCollateralSlot().securityHooks[target];\n  }\n\n  function getClearingHouse(uint256 collateralId)\n    external\n    view\n    returns (ClearingHouse)\n  {\n    return\n      ClearingHouse(payable(_loadCollateralSlot().clearingHouse[collateralId]));\n  }\n\n  function _generateValidOrderParameters(\n    CollateralStorage storage s,\n    address settlementToken,\n    uint256 collateralId,\n    uint256[] memory prices,\n    uint256 maxDuration\n  ) internal returns (OrderParameters memory orderParameters) {\n    OfferItem[] memory offer = new OfferItem[](1);\n\n    Asset memory underlying = s.idToUnderlying[collateralId];\n\n    offer[0] = OfferItem(\n      ItemType.ERC721,\n      underlying.tokenContract,\n      underlying.tokenId,\n      1,\n      1\n    );\n\n    ConsiderationItem[] memory considerationItems = new ConsiderationItem[](2);\n    considerationItems[0] = ConsiderationItem(\n      ItemType.ERC20,\n      settlementToken,\n      uint256(0),\n      prices[0],\n      prices[1],\n      payable(address(s.clearingHouse[collateralId]))\n    );\n    considerationItems[1] = ConsiderationItem(\n      ItemType.ERC1155,\n      s.clearingHouse[collateralId],\n      uint256(uint160(settlementToken)),\n      prices[0],\n      prices[1],\n      payable(s.clearingHouse[collateralId])\n    );\n\n    orderParameters = OrderParameters({\n      offerer: s.clearingHouse[collateralId],\n      zone: address(this), // 0x20\n      offer: offer,\n      consideration: considerationItems,\n      orderType: OrderType.FULL_OPEN,\n      startTime: uint256(block.timestamp),\n      endTime: uint256(block.timestamp + maxDuration),\n      zoneHash: bytes32(collateralId),\n      salt: uint256(blockhash(block.number)),\n      conduitKey: s.CONDUIT_KEY, // 0x120\n      totalOriginalConsiderationItems: considerationItems.length\n    });\n  }\n\n  function auctionVault(AuctionVaultParams calldata params)\n    external\n    requiresAuth\n    returns (OrderParameters memory orderParameters)\n  {\n    CollateralStorage storage s = _loadCollateralSlot();\n\n    uint256[] memory prices = new uint256[](2);\n    prices[0] = params.startingPrice;\n    prices[1] = params.endingPrice;\n    orderParameters = _generateValidOrderParameters(\n      s,\n      params.settlementToken,\n      params.collateralId,\n      prices,\n      params.maxDuration\n    );\n\n    _listUnderlyingOnSeaport(\n      s,\n      params.collateralId,\n      Order(orderParameters, new bytes(0))\n    );\n  }\n\n  function _listUnderlyingOnSeaport(\n    CollateralStorage storage s,\n    uint256 collateralId,\n    Order memory listingOrder\n  ) internal {\n    //get total Debt and ensure its being sold for more than that\n\n    if (listingOrder.parameters.conduitKey != s.CONDUIT_KEY) {\n      revert InvalidConduitKey();\n    }\n    if (listingOrder.parameters.zone != address(this)) {\n      revert InvalidZone();\n    }\n\n    ClearingHouse(s.clearingHouse[collateralId]).validateOrder(listingOrder);\n    emit ListedOnSeaport(collateralId, listingOrder);\n\n    s.collateralIdToAuction[collateralId] = keccak256(\n      abi.encode(listingOrder.parameters)\n    );\n  }\n\n  function settleAuction(uint256 collateralId) public {\n    CollateralStorage storage s = _loadCollateralSlot();\n    if (\n      s.collateralIdToAuction[collateralId] == bytes32(0) &&\n      ERC721(s.idToUnderlying[collateralId].tokenContract).ownerOf(\n        s.idToUnderlying[collateralId].tokenId\n      ) !=\n      s.clearingHouse[collateralId]\n    ) {\n      revert InvalidCollateralState(InvalidCollateralStates.NO_AUCTION);\n    }\n    require(msg.sender == s.clearingHouse[collateralId]);\n    _settleAuction(s, collateralId);\n    delete s.idToUnderlying[collateralId];\n    _burn(collateralId);\n  }\n\n  function _settleAuction(CollateralStorage storage s, uint256 collateralId)\n    internal\n  {\n    delete s.collateralIdToAuction[collateralId];\n  }\n\n  /**\n   * @dev Mints a new CollateralToken wrapping an NFT.\n   * @param from_ the owner of the collateral deposited\n   * @param tokenId_ The NFT token ID\n   * @return a static return of the receive signature\n   */\n  function onERC721Received(\n    address, /* operator_ */\n    address from_,\n    uint256 tokenId_,\n    bytes calldata // calldata data_\n  ) external override whenNotPaused returns (bytes4) {\n    CollateralStorage storage s = _loadCollateralSlot();\n    uint256 collateralId = msg.sender.computeId(tokenId_);\n\n    Asset memory incomingAsset = s.idToUnderlying[collateralId];\n    if (incomingAsset.tokenContract == address(0)) {\n      require(ERC721(msg.sender).ownerOf(tokenId_) == address(this));\n\n      if (s.clearingHouse[collateralId] == address(0)) {\n        address clearingHouse = ClonesWithImmutableArgs.clone(\n          s.ASTARIA_ROUTER.BEACON_PROXY_IMPLEMENTATION(),\n          abi.encodePacked(\n            address(s.ASTARIA_ROUTER),\n            uint8(IAstariaRouter.ImplementationType.ClearingHouse),\n            collateralId\n          )\n        );\n\n        s.clearingHouse[collateralId] = clearingHouse;\n      }\n      ERC721(msg.sender).safeTransferFrom(\n        address(this),\n        s.clearingHouse[collateralId],\n        tokenId_\n      );\n\n      if (msg.sender == address(this) || msg.sender == address(s.LIEN_TOKEN)) {\n        revert InvalidCollateral();\n      }\n\n      _mint(from_, collateralId);\n\n      s.idToUnderlying[collateralId] = Asset({\n        tokenContract: msg.sender,\n        tokenId: tokenId_\n      });\n\n      emit Deposit721(msg.sender, tokenId_, collateralId, from_);\n      return IERC721Receiver.onERC721Received.selector;\n    } else {\n      revert();\n    }\n  }\n\n  modifier whenNotPaused() {\n    if (_loadCollateralSlot().ASTARIA_ROUTER.paused()) {\n      revert ProtocolPaused();\n    }\n    _;\n  }\n}"
    },
    {
      "filename": "src/CollateralToken.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**\n *  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗\n * ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n * ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n * ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n * ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n * ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n *\n * Astaria Labs, Inc\n */\n\npragma solidity =0.8.17;\n\npragma experimental ABIEncoderV2;\n\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {ICollateralToken} from \"core/interfaces/ICollateralToken.sol\";\nimport {IERC165} from \"core/interfaces/IERC165.sol\";\nimport {IERC721} from \"core/interfaces/IERC721.sol\";\nimport {IERC721Receiver} from \"core/interfaces/IERC721Receiver.sol\";\nimport {IFlashAction} from \"core/interfaces/IFlashAction.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\nimport {ISecurityHook} from \"core/interfaces/ISecurityHook.sol\";\nimport {ITransferProxy} from \"core/interfaces/ITransferProxy.sol\";\nimport {Authority} from \"solmate/auth/Auth.sol\";\nimport {CollateralLookup} from \"core/libraries/CollateralLookup.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC721} from \"gpl/ERC721.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/"
    }
  ]
}