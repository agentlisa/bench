{
  "Title": "[M-16] User can grief bootstrap process by sending the cap amount of unlocked tokens to it.",
  "Content": "\nThe bootstrap process relies on users locking up all their tokens as it will only use tokens that are marked locked in `totals[MIM].locked` and `totals[USDB].locked`.\n\n[BlastOnboardingBoot.sol#L96-L127](https://github.com/code-423n4/2024-03-abracadabra-money/blob/main/src/blast/BlastOnboardingBoot.sol#L96-L127)\n\n```solidity\n    function bootstrap(uint256 minAmountOut) external onlyOwner onlyState(State.Closed) returns (address, address, uint256) {\n        if (pool != address(0)) {\n            revert ErrAlreadyBootstrapped();\n        }\n\n=>      uint256 baseAmount = totals[MIM].locked;\n=>      uint256 quoteAmount = totals[USDB].locked;\n        MIM.safeApprove(address(router), type(uint256).max);\n        USDB.safeApprove(address(router), type(uint256).max);\n\n        (pool, totalPoolShares) = router.createPool(MIM, USDB, FEE_RATE, I, K, address(this), baseAmount, quoteAmount);\n\n        if (totalPoolShares < minAmountOut) {\n            revert ErrInsufficientAmountOut();\n        }\n\n        // Create staking contract\n        // 3x boosting for locker, 7 days reward duration, 13 weeks lp locking\n        // make this contract temporary the owner the set it as an operator\n        // for permissionned `stakeFor` during the claiming process and then\n        // transfer the ownership to the onboarding owner.\n        staking = new LockingMultiRewards(pool, 30_000, 7 days, 13 weeks, address(this));\n        staking.setOperator(address(this), true);\n        staking.transferOwnership(owner);\n\n        // Approve staking contract\n        pool.safeApprove(address(staking), totalPoolShares);\n\n        emit LogLiquidityBootstrapped(pool, address(staking), totalPoolShares);\n\n        return (pool, address(staking), totalPoolShares);\n    }\n```\n\nHowever, it is possible that these values can be zero because there is a cap on the amount of tokens that can be stored in the contract.\n\n[BlastOnboarding.sol#L101-L121](https://github.com/code-423n4/2024-03-abracadabra-money/blob/main/src/blast/BlastOnboarding.sol#L101-L121)\n\n```solidity\n    function deposit(address token, uint256 amount, bool lock_) external whenNotPaused onlyState(State.Opened) onlySupportedTokens(token) {\n        token.safeTransferFrom(msg.sender, address(this), amount);\n\n        if (lock_) {\n            totals[token].locked += amount;\n            balances[msg.sender][token].locked += amount;\n        } else {\n            totals[token].unlocked += amount;\n            balances[msg.sender][token].unlocked += amount;\n        }\n\n        totals[token].total += amount;\n\n        if (caps[token] > 0 && totals[token].total > caps[token]) {\n            revert ErrCapReached();\n        }\n\n        balances[msg.sender][token].total += amount;\n\n        emit LogDeposit(msg.sender, token, amount, lock_);\n    }\n```\n\nIn the code above, notice that there is a cap on the amount of tokens that can be sent to the contract `caps[token]`. The problem here is that it is checked against the total token amount `totals[token].total` rather than the locked amount `totals[token].locked`.\n\nTherefore a griefer can deposit tokens up to the `caps[token]` with `lock_ = false`. The result, is that no one else can deposit tokens into the contract.\n\nDuring bootstrap, since these tokens are still considered unlocked, then  `totals[MIM].locked = 0` and `totals[USDB].locked = 0`, therefore there won't be any locked tokens available for the bootstrapping process.\n\n### Recommended Mitigation Steps\n\nInstead of checking `caps[token]` against `totals[token].total`, it should be checked against `totals[token].locked`.\n\n**[0xCalibur (Abracadabra) confirmed, but disagreed with severity and and commented](https://github.com/code-423n4/2024-03-abracadabra-money-findings/issues/7#issuecomment-2000052685):**\n > https://github.com/Abracadabra-money/abracadabra-money-contracts/pull/139\n\n**[cccz (Judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-03-abracadabra-money-findings/issues/7#issuecomment-2026868444):**\n > Incorrect cap check, consider M.\n\n_Note: For full discussion, see [here](https://github.com/code-423n4/2024-03-abracadabra-money-findings/issues/7)._\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-03-abracadabra-money",
  "Code": [
    {
      "filename": "src/blast/BlastOnboardingBoot.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport {BlastOnboarding} from \"/blast/BlastOnboarding.sol\";\nimport {BlastOnboardingData} from \"/blast/BlastOnboarding.sol\";\nimport {Router} from \"/mimswap/periphery/Router.sol\";\nimport {IFeeRateModel} from \"/mimswap/interfaces/IFeeRateModel.sol\";\nimport {IFactory} from \"/mimswap/interfaces/IFactory.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {DecimalMath} from \"/mimswap/libraries/DecimalMath.sol\";\nimport {LockingMultiRewards} from \"staking/LockingMultiRewards.sol\";\n\naddress constant USDB = 0x4300000000000000000000000000000000000003;\naddress constant MIM = 0x76DA31D7C9CbEAE102aff34D3398bC450c8374c1;\nuint256 constant FEE_RATE = 0.0005 ether; // 0.05%\nuint256 constant K = 0.00025 ether; // 0.00025, 1.25% price fluctuation, similar to A2000 in curve\nuint256 constant I = 0.998 ether; // 1 MIM = 0.998 USDB\nuint256 constant USDB_TO_MIN = 1.002 ether; // 1 USDB = 1.002 MIM\nuint256 constant MIM_TO_MIN = I;\n\n// Add a new data contract each bootstrap upgrade that involves\n// adding new storage variables.\ncontract BlastOnboardingBootDataV1 is BlastOnboardingData {\n    address public pool;\n    Router public router;\n    IFactory public factory;\n    uint256 public totalPoolShares;\n    bool public ready;\n    LockingMultiRewards public staking;\n    mapping(address user => bool claimed) public claimed;\n}\n\n/// @dev Functions are postfixed with the version number to avoid collisions\ncontract BlastOnboardingBoot is BlastOnboardingBootDataV1 {\n    using SafeTransferLib for address;\n\n    event LogReadyChanged(bool ready);\n    event LogClaimed(address indexed user, uint256 shares, bool lock);\n    event LogInitialized(Router indexed router);\n    event LogLiquidityBootstrapped(address indexed pool, address indexed staking, uint256 amountOut);\n    event LogStakingChanged(address indexed staking);\n\n    error ErrInsufficientAmountOut();\n    error ErrNotReady();\n    error ErrAlreadyClaimed();\n    error ErrWrongFeeRateModel();\n    error ErrAlreadyBootstrapped();\n    error ErrNothingToClaim();\n    error ErrCannotChangeOnceReady();\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// PUBLIC\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function claim(bool lock) external returns (uint256 shares) {\n        if (!ready) {\n            revert ErrNotReady();\n        }\n        if (claimed[msg.sender]) {\n            revert ErrAlreadyClaimed();\n        }\n\n        shares = _claimable(msg.sender);\n        if (shares == 0) {\n            revert ErrNothingToClaim();\n        }\n\n        claimed[msg.sender] = true;\n        staking.stakeFor(msg.sender, shares, lock);\n\n        emit LogClaimed(msg.sender, shares, lock);\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// VIEWS\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function claimable(address user) external view returns (uint256 shares) {\n        if (!ready || claimed[user]) {\n            return 0;\n        }\n\n        return _claimable(user);\n    }\n\n    function previewTotalPoolShares() external view returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount, uint256 shares) {\n        uint256 baseAmount = totals[MIM].locked;\n        uint256 quoteAmount = totals[USDB].locked;\n        return router.previewCreatePool(I, baseAmount, quoteAmount);\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// ADMIN\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function bootstrap(uint256 minAmountOut) external onlyOwner onlyState(State.Closed) returns (address, address, uint256) {\n        if (pool != address(0)) {\n            revert ErrAlreadyBootstrapped();\n        }\n\n        uint256 baseAmount = totals[MIM].locked;\n        uint256 quoteAmount = totals[USDB].locked;\n        MIM.safeApprove(address(router), type(uint256).max);\n        USDB.safeApprove(address(router), type(uint256).max);\n\n        (pool, totalPoolShares) = router.createPool(MIM, USDB, FEE_RATE, I, K, address(this), baseAmount, quoteAmount);\n\n        if (totalPoolShares < minAmountOut) {\n            revert ErrInsufficientAmountOut();\n        }\n\n        // Create staking contract\n        // 3x boosting for locker, 7 days reward duration, 13 weeks lp locking\n        // make this contract temporary the owner the set it as an operator\n        // for permissionned `stakeFor` during the claiming process and then\n        // transfer the ownership to the onboarding owner.\n        staking = new LockingMultiRewards(pool, 30_000, 7 days, 13 weeks, address(this));\n        staking.setOperator(address(this), true);\n        staking.transferOwnership(owner);\n\n        // Approve staking contract\n        pool.safeApprove(address(staking), totalPoolShares);\n\n        emit LogLiquidityBootstrapped(pool, address(staking), totalPoolShares);\n\n        return (pool, address(staking), totalPoolShares);\n    }\n\n    function initialize(Router _router) external onlyOwner {\n        router = Router(payable(_router));\n        factory = IFactory(router.factory());\n        emit LogInitialized(_router);\n    }\n\n    // Just in case we need to change the staking contract after\n    // the automatic bootstrapping process\n    function setStaking(LockingMultiRewards _staking) external onlyOwner {\n        if (ready) {\n            revert ErrCannotChangeOnceReady();\n        }\n\n        staking = _staking;\n        emit LogStakingChanged(address(_staking));\n    }\n\n    function setReady(bool _ready) external onlyOwner onlyState(State.Closed) {\n        ready = _ready;\n        emit LogReadyChanged(ready);\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// INTERNALS\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function _claimable(address user) internal view returns (uint256 shares) {\n        uint256 totalLocked = totals[MIM].locked + totals[USDB].locked;\n\n        if (totalLocked == 0) {\n            return 0;\n        }\n\n        uint256 userLocked = balances[user][MIM].locked + balances[user][USDB].locked;\n        return (userLocked * totalPoolShares) / totalLocked;\n    }\n}"
    },
    {
      "filename": "src/blast/BlastOnboarding.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {BlastYields} from \"/blast/libraries/BlastYields.sol\";\nimport {BlastTokenRegistry} from \"/blast/BlastTokenRegistry.sol\";\nimport {Proxy} from \"openzeppelin-contracts/proxy/Proxy.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {BlastPoints} from \"/blast/libraries/BlastPoints.sol\";\nimport {Pausable} from \"openzeppelin-contracts/security/Pausable.sol\";\n\ncontract BlastOnboardingData is Owned, Pausable {\n    error ErrZeroAddress();\n    error ErrWrongState();\n    error ErrUnsupportedToken();\n    error ErrNotAllowed();\n\n    enum State {\n        Idle,\n        Opened,\n        Closed\n    }\n\n    struct Balances {\n        uint256 unlocked;\n        uint256 locked;\n        uint256 total;\n    }\n\n    State public state;\n    address public bootstrapper;\n    address public feeTo;\n    BlastTokenRegistry public registry;\n\n    // Global\n    mapping(address token => bool) public supportedTokens;\n    mapping(address token => Balances) public totals;\n    mapping(address token => uint256 cap) public caps;\n\n    // Per-user\n    mapping(address user => mapping(address token => Balances)) public balances;\n\n    modifier onlyState(State _state) {\n        if (state != _state) {\n            revert ErrWrongState();\n        }\n        _;\n    }\n\n    modifier onlySupportedTokens(address token) {\n        if (!supportedTokens[token]) {\n            revert ErrUnsupportedToken();\n        }\n\n        _;\n    }\n\n    constructor() Owned(msg.sender) {\n        BlastYields.configureDefaultClaimables(address(this));\n        BlastPoints.configure();\n    }\n}\n\ncontract BlastOnboarding is BlastOnboardingData, Proxy {\n    using SafeTransferLib for address;\n\n    event LogBootstrapperChanged(address indexed bootstrapper);\n    event LogTokenSupported(address indexed token, bool supported);\n    event LogDeposit(address indexed user, address indexed token, uint256 amount, bool lock);\n    event LogLock(address indexed user, address indexed token, uint256 amount);\n    event LogFeeToChanged(address indexed feeTo);\n    event LogWithdraw(address indexed user, address indexed token, uint256 amount);\n    event LogTokenCapChanged(address indexed token, uint256 cap);\n    event LogStateChange(State state);\n    event LogTokenRescue(address indexed token, address indexed to, uint256 amount);\n\n    error ErrUnsupported();\n    error ErrCapReached();\n\n    receive() external payable override {\n        revert ErrUnsupported();\n    }\n\n    constructor(BlastTokenRegistry registry_, address feeTo_) {\n        if (address(registry_) == address(0)) {\n            revert ErrZeroAddress();\n        }\n\n        if (feeTo_ == address(0)) {\n            revert ErrZeroAddress();\n        }\n\n        registry = registry_;\n        feeTo = feeTo_;\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// PUBLIC\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function deposit(address token, uint256 amount, bool lock_) external whenNotPaused onlyState(State.Opened) onlySupportedTokens(token) {\n        token.safeTransferFrom(msg.sender, address(this), amount);\n\n        if (lock_) {\n            totals[token].locked += amount;\n            balances[msg.sender][token].locked += amount;\n        } else {\n            totals[token].unlocked += amount;\n            balances[msg.sender][token].unlocked += amount;\n        }\n\n        totals[token].total += amount;\n\n        if (caps[token] > 0 && totals[token].total > caps[token]) {\n            revert ErrCapReached();\n        }\n\n        balances[msg.sender][token].total += amount;\n\n        emit LogDeposit(msg.sender, token, amount, lock_);\n    }\n\n    function lock(address token, uint256 amount) external whenNotPaused onlyState(State.Opened) onlySupportedTokens(token) {\n        balances[msg.sender][token].unlocked -= amount;\n        balances[msg.sender][token].locked += amount;\n        totals[token].unlocked -= amount;\n        totals[token].locked += amount;\n\n        emit LogLock(msg.sender, token, amount);\n    }\n\n    function withdraw(address token, uint256 amount) external whenNotPaused onlySupportedTokens(token) {\n        balances[msg.sender][token].unlocked -= amount;\n        balances[msg.sender][token].total -= amount;\n        totals[token].unlocked -= amount;\n        totals[token].total -= amount;\n\n        token.safeTransfer(msg.sender, amount);\n\n        emit LogWithdraw(msg.sender, token, amount);\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// ADMIN\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function setFeeTo(address feeTo_) external onlyOwner {\n        if (feeTo_ == address(0)) {\n            revert ErrZeroAddress();\n        }\n\n        feeTo = feeTo_;\n        emit LogFeeToChanged(feeTo_);\n    }\n\n    function callBlastPrecompile(bytes calldata data) external onlyOwner {\n        BlastYields.callPrecompile(data);\n    }\n\n    function claimGasYields() external onlyOwner returns (uint256) {\n        return BlastYields.claimMaxGasYields(feeTo);\n    }\n\n    function claimTokenYields(address[] memory tokens) external onlyOwner {\n        for (uint256 i = 0; i < tokens.length; i++) {\n            if (!supportedTokens[tokens[i]]) {\n                revert ErrUnsupportedToken();\n            }\n            if (registry.nativeYieldTokens(tokens[i])) {\n                BlastYields.claimAllTokenYields(tokens[i], feeTo);\n            }\n        }\n    }\n\n    function setTokenSupported(address token, bool supported) external onlyOwner {\n        supportedTokens[token] = supported;\n\n        if (registry.nativeYieldTokens(token)) {\n            BlastYields.enableTokenClaimable(token);\n        }\n\n        emit LogTokenSupported(token, supported);\n    }\n\n    function setCap(address token, uint256 cap) external onlyOwner onlySupportedTokens(token) {\n        caps[token] = cap;\n        emit LogTokenCapChanged(token, cap);\n    }\n\n    function setBootstrapper(address bootstrapper_) external onlyOwner {\n        bootstrapper = bootstrapper_;\n        emit LogBootstrapperChanged(bootstrapper_);\n    }\n\n    function open() external onlyOwner onlyState(State.Idle) {\n        state = State.Opened;\n        emit LogStateChange(State.Opened);\n    }\n\n    function close() external onlyOwner onlyState(State.Opened) {\n        state = State.Closed;\n        emit LogStateChange(State.Closed);\n    }\n\n    function rescue(address token, address to, uint256 amount) external onlyOwner {\n        if (supportedTokens[token]) {\n            revert ErrNotAllowed();\n        }\n\n        token.safeTransfer(to, amount);\n        emit LogTokenRescue(token, to, amount);\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// PROXY IMPLEMENTATION\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function _implementation() internal view override returns (address) {\n        return address(bootstrapper);\n    }\n}"
    }
  ]
}