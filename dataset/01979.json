{
  "Title": "M-7: BlueBerryBank#getPositionValue causes DOS if reward token is added that doens't have an oracle",
  "Content": "# Issue M-7: BlueBerryBank#getPositionValue causes DOS if reward token is added that doens't have an oracle \n\nSource: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/115 \n\n## Found by \n0x52, nobody2018\n## Summary\n\ncollToken.pendingRewards pulls the most recent reward list from Aura/Convex. In the event that reward tokens are added to pools that don't currently have an oracle then it will DOS every action (repaying, liquidating, etc.). While this is only temporary it prevents liquidation which is a key process that should have 100% uptime otherwise the protocol could easily be left with bad debt.\n\n## Vulnerability Detail\n\n[BlueBerryBank.sol#L408-L413](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/BlueBerryBank.sol#L408-L413)\n\n          (address[] memory tokens, uint256[] memory rewards) = IERC20Wrapper(\n              pos.collToken\n          ).pendingRewards(pos.collId, pos.collateralSize);\n          for (uint256 i; i < tokens.length; i++) {\n              rewardsValue += oracle.getTokenValue(tokens[i], rewards[i]);\n          }\n\nUsing the pendingRewards method pulls a fresh list of all tokens. When a token is added as a reward but can't be priced then the call to getTokenValue will revert. Since getPostionValue is used in liquidations, it temporarily breaks liquidations which in a volatile market can cause bad debt to accumulate.\n\n## Impact\n\nTemporary DOS to liquidations which can result in bad debt\n\n## Code Snippet\n\n[BlueBerryBank.sol#L392-L417](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/BlueBerryBank.sol#L392-L417)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nReturn zero valuation if extra reward token can't be priced.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/69",
  "Code": [
    {
      "filename": "blueberry-core/contracts/BlueBerryBank.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport \"./utils/BlueBerryConst.sol\" as Constants;\nimport \"./utils/BlueBerryErrors.sol\" as Errors;\nimport \"./utils/EnsureApprove.sol\";\nimport \"./utils/ERC1155NaiveReceiver.sol\";\nimport \"./interfaces/IBank.sol\";\nimport \"./interfaces/ICoreOracle.sol\";\nimport \"./interfaces/ISoftVault.sol\";\nimport \"./interfaces/IHardVault.sol\";\nimport \"./interfaces/compound/ICErc20.sol\";\nimport \"./libraries/BBMath.sol\";\n\n/**\n * @title BlueberryBank\n * @author BlueberryProtocol\n * @notice Blueberry Bank is the main contract that stores user's positions and track the borrowing of tokens\n */\ncontract BlueBerryBank is\n    OwnableUpgradeable,\n    ERC1155NaiveReceiver,\n    IBank,\n    EnsureApprove\n{\n    using BBMath for uint256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private constant _NO_ID = type(uint256).max;\n    address private constant _NO_ADDRESS = address(1);\n\n    uint256 public _GENERAL_LOCK; // TEMPORARY: re-entrancy lock guard.\n    uint256 public _IN_EXEC_LOCK; // TEMPORARY: exec lock guard.\n    uint256 public POSITION_ID; // TEMPORARY: position ID currently under execution.\n    address public SPELL; // TEMPORARY: spell currently under execution.\n\n    IProtocolConfig public config;\n    ICoreOracle public oracle; // The oracle address for determining prices.\n    IFeeManager public feeManager;\n\n    uint256 public nextPositionId; // Next available position ID, starting from 1 (see initialize).\n    uint256 public bankStatus; // Each bit stores certain bank status, e.g. borrow allowed, repay allowed\n\n    address[] public allBanks; // The list of all listed banks.\n    mapping(address => Bank) public banks; // Mapping from token to bank data.\n    mapping(address => bool) public bTokenInBank; // Mapping from bToken to its existence in bank.\n    mapping(uint256 => Position) public positions; // Mapping from position ID to position data.\n\n    bool public allowContractCalls; // The boolean status whether to allow call from contract (false = onlyEOA)\n    mapping(address => bool) public whitelistedTokens; // Mapping from token to whitelist status\n    mapping(address => bool) public whitelistedWrappedTokens; // Mapping from token to whitelist status\n    mapping(address => bool) public whitelistedSpells; // Mapping from spell to whitelist status\n    mapping(address => bool) public whitelistedContracts; // Mapping from user to whitelist status\n\n    /// @dev Ensure that the function is called from EOA\n    /// when allowContractCalls is set to false and caller is not whitelisted\n    modifier onlyEOAEx() {\n        if (!allowContractCalls && !whitelistedContracts[msg.sender]) {\n            if (AddressUpgradeable.isContract(msg.sender))\n                revert Errors.NOT_EOA(msg.sender);\n        }\n        _;\n    }\n\n    /// @dev Ensure that the token is already whitelisted\n    modifier onlyWhitelistedToken(address token) {\n        if (!whitelistedTokens[token])\n            revert Errors.TOKEN_NOT_WHITELISTED(token);\n        _;\n    }\n\n    /// @dev Ensure that the wrapped ERC1155 is already whitelisted\n    modifier onlyWhitelistedERC1155(address token) {\n        if (!whitelistedWrappedTokens[token])\n            revert Errors.TOKEN_NOT_WHITELISTED(token);\n        _;\n    }\n\n    /// @dev Reentrancy lock guard.\n    modifier lock() {\n        if (_GENERAL_LOCK != _NOT_ENTERED) revert Errors.LOCKED();\n        _GENERAL_LOCK = _ENTERED;\n        _;\n        _GENERAL_LOCK = _NOT_ENTERED;\n    }\n\n    /// @dev Ensure that the function is called from within the execution scope.\n    modifier inExec() {\n        if (POSITION_ID == _NO_ID) revert Errors.NOT_IN_EXEC();\n        if (SPELL != msg.sender) revert Errors.NOT_FROM_SPELL(msg.sender);\n        if (_IN_EXEC_LOCK != _NOT_ENTERED) revert Errors.LOCKED();\n        _IN_EXEC_LOCK = _ENTERED;\n        _;\n        _IN_EXEC_LOCK = _NOT_ENTERED;\n    }\n\n    /// @dev Ensure that the interest rate of the given token is accrued.\n    modifier poke(address token) {\n        accrue(token);\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @dev Initialize the bank smart contract, using msg.sender as the first governor.\n    /// @param oracle_ The oracle smart contract address.\n    /// @param config_ The Protocol config address\n    function initialize(\n        ICoreOracle oracle_,\n        IProtocolConfig config_\n    ) external initializer {\n        __Ownable_init();\n        if (address(oracle_) == address(0) || address(config_) == address(0)) {\n            revert Errors.ZERO_ADDRESS();\n        }\n        _GENERAL_LOCK = _NOT_ENTERED;\n        _IN_EXEC_LOCK = _NOT_ENTERED;\n        POSITION_ID = _NO_ID;\n        SPELL = _NO_ADDRESS;\n\n        config = config_;\n        oracle = oracle_;\n        feeManager = config_.feeManager();\n\n        nextPositionId = 1;\n        bankStatus = 15; // 0x1111: allow borrow, repay, lend, withdrawLend as default\n\n        emit SetOracle(address(oracle_));\n    }\n\n    /// @dev Return the current executor (the owner of the current position).\n    function EXECUTOR() external view override returns (address) {\n        uint256 positionId = POSITION_ID;\n        if (positionId == _NO_ID) {\n            revert Errors.NOT_UNDER_EXECUTION();\n        }\n        return positions[positionId].owner;\n    }\n\n    /// @dev Set allowContractCalls\n    /// @param ok The status to set allowContractCalls to (false = onlyEOA)\n    function setAllowContractCalls(bool ok) external onlyOwner {\n        allowContractCalls = ok;\n    }\n\n    /// @notice Set whitelist user status\n    /// @param contracts list of users to change status\n    /// @param statuses list of statuses to change to\n    function whitelistContracts(\n        address[] calldata contracts,\n        bool[] calldata statuses\n    ) external onlyOwner {\n        if (contracts.length != statuses.length) {\n            revert Errors.INPUT_ARRAY_MISMATCH();\n        }\n        for (uint256 idx = 0; idx < contracts.length; idx++) {\n            if (contracts[idx] == address(0)) {\n                revert Errors.ZERO_ADDRESS();\n            }\n            whitelistedContracts[contracts[idx]] = statuses[idx];\n        }\n    }\n\n    /// @dev Set whitelist spell status\n    /// @param spells list of spells to change status\n    /// @param statuses list of statuses to change to\n    function whitelistSpells(\n        address[] calldata spells,\n        bool[] calldata statuses\n    ) external onlyOwner {\n        if (spells.length != statuses.length) {\n            revert Errors.INPUT_ARRAY_MISMATCH();\n        }\n        for (uint256 idx = 0; idx < spells.length; idx++) {\n            if (spells[idx] == address(0)) {\n                revert Errors.ZERO_ADDRESS();\n            }\n            whitelistedSpells[spells[idx]] = statuses[idx];\n        }\n    }\n\n    /// @notice Set whitelist token status\n    /// @param tokens list of tokens to change status\n    /// @param statuses list of statuses to change to\n    function whitelistTokens(\n        address[] calldata tokens,\n        bool[] calldata statuses\n    ) external onlyOwner {\n        if (tokens.length != statuses.length) {\n            revert Errors.INPUT_ARRAY_MISMATCH();\n        }\n        for (uint256 idx = 0; idx < tokens.length; idx++) {\n            if (statuses[idx] && !oracle.isTokenSupported(tokens[idx]))\n                revert Errors.ORACLE_NOT_SUPPORT(tokens[idx]);\n            whitelistedTokens[tokens[idx]] = statuses[idx];\n            emit SetWhitelistToken(tokens[idx], statuses[idx]);\n        }\n    }\n\n    /// @notice Whitelist ERC1155(wrapped tokens)\n    /// @param tokens List of tokens to set whitelist status\n    /// @param ok Whitelist status\n    function whitelistERC1155(\n        address[] memory tokens,\n        bool ok\n    ) external onlyOwner {\n        for (uint256 idx = 0; idx < tokens.length; idx++) {\n            address token = tokens[idx];\n            if (token == address(0)) revert Errors.ZERO_ADDRESS();\n            whitelistedWrappedTokens[token] = ok;\n            emit SetWhitelistERC1155(token, ok);\n        }\n    }\n\n    /**\n     * @dev Add a new bank to the ecosystem.\n     * @param token The underlying token for the bank.\n     * @param softVault The address of softVault.\n     * @param hardVault The address of hardVault.\n     */\n    function addBank(\n        address token,\n        address softVault,\n        address hardVault,\n        uint256 liqThreshold\n    ) external onlyOwner onlyWhitelistedToken(token) {\n        if (softVault == address(0) || hardVault == address(0))\n            revert Errors.ZERO_ADDRESS();\n        if (liqThreshold > Constants.DENOMINATOR)\n            revert Errors.LIQ_THRESHOLD_TOO_HIGH(liqThreshold);\n        if (liqThreshold < Constants.MIN_LIQ_THRESHOLD)\n            revert Errors.LIQ_THRESHOLD_TOO_LOW(liqThreshold);\n\n        Bank storage bank = banks[token];\n        address bToken = address(ISoftVault(softVault).bToken());\n\n        if (bTokenInBank[bToken]) revert Errors.BTOKEN_ALREADY_ADDED();\n        if (bank.isListed) revert Errors.BANK_ALREADY_LISTED();\n        if (allBanks.length >= 256) revert Errors.BANK_LIMIT();\n\n        bTokenInBank[bToken] = true;\n        bank.isListed = true;\n        bank.index = uint8(allBanks.length);\n        bank.bToken = bToken;\n        bank.softVault = softVault;\n        bank.hardVault = hardVault;\n        bank.liqThreshold = liqThreshold;\n\n        IHardVault(hardVault).setApprovalForAll(hardVault, true);\n        allBanks.push(token);\n\n        emit AddBank(token, bToken, softVault, hardVault);\n    }\n\n    /// @dev Set bank status\n    /// @param _bankStatus new bank status to change to\n    function setBankStatus(uint256 _bankStatus) external onlyOwner {\n        bankStatus = _bankStatus;\n    }\n\n    /// @dev Bank borrow status allowed or not\n    /// @notice check last bit of bankStatus\n    function isBorrowAllowed() public view returns (bool) {\n        return (bankStatus & 0x01) > 0;\n    }\n\n    /// @dev Bank repay status allowed or not\n    /// @notice Check second-to-last bit of bankStatus\n    function isRepayAllowed() public view returns (bool) {\n        return (bankStatus & 0x02) > 0;\n    }\n\n    /// @dev Bank borrow status allowed or not\n    /// @notice check last bit of bankStatus\n    function isLendAllowed() public view returns (bool) {\n        return (bankStatus & 0x04) > 0;\n    }\n\n    /// @dev Bank borrow status allowed or not\n    /// @notice check last bit of bankStatus\n    function isWithdrawLendAllowed() public view returns (bool) {\n        return (bankStatus & 0x08) > 0;\n    }\n\n    /// @dev Trigger interest accrual for the given bank.\n    /// @param token The underlying token to trigger the interest accrual.\n    function accrue(address token) public override {\n        Bank storage bank = banks[token];\n        if (!bank.isListed) revert Errors.BANK_NOT_LISTED(token);\n        ICErc20(bank.bToken).borrowBalanceCurrent(address(this));\n    }\n\n    /// @dev Convenient function to trigger interest accrual for a list of banks.\n    /// @param tokens The list of banks to trigger interest accrual.\n    function accrueAll(address[] memory tokens) external {\n        for (uint256 idx = 0; idx < tokens.length; idx++) {\n            accrue(tokens[idx]);\n        }\n    }\n\n    function _borrowBalanceStored(\n        address token\n    ) internal view returns (uint256) {\n        return ICErc20(banks[token].bToken).borrowBalanceStored(address(this));\n    }\n\n    /// @dev Trigger interest accrual and return the current debt balance.\n    /// @param positionId The position to query for debt balance.\n    function currentPositionDebt(\n        uint256 positionId\n    )\n        external\n        override\n        poke(positions[positionId].debtToken)\n        returns (uint256)\n    {\n        return getPositionDebt(positionId);\n    }\n\n    /// @notice Return the debt of given position considering the debt interest stored.\n    /// @dev Should call accrue first to get current debt\n    /// @param positionId position id to get debts of\n    function getPositionDebt(\n        uint256 positionId\n    ) public view returns (uint256 debt) {\n        Position memory pos = positions[positionId];\n        Bank memory bank = banks[pos.debtToken];\n        if (pos.debtShare == 0 || bank.totalShare == 0) {\n            return 0;\n        }\n        debt = (pos.debtShare * _borrowBalanceStored(pos.debtToken)).divCeil(\n            bank.totalShare\n        );\n    }\n\n    /// @dev Return bank information for the given token.\n    /// @param token The token address to query for bank information.\n    function getBankInfo(\n        address token\n    )\n        external\n        view\n        override\n        returns (bool isListed, address bToken, uint256 totalShare)\n    {\n        Bank memory bank = banks[token];\n        return (bank.isListed, bank.bToken, bank.totalShare);\n    }\n\n    /// @dev Return position info by given positionId\n    function getPositionInfo(\n        uint256 positionId\n    ) external view override returns (Position memory) {\n        return positions[positionId];\n    }\n\n    /// @dev Return current position information\n    function getCurrentPositionInfo()\n        external\n        view\n        override\n        returns (Position memory)\n    {\n        if (POSITION_ID == _NO_ID) revert Errors.BAD_POSITION(POSITION_ID);\n        return positions[POSITION_ID];\n    }\n\n    /**\n     * @notice Return the USD value of total collateral of the given position\n     *         considering yields generated from the collaterals.\n     * @param positionId The position ID to query for the collateral value.\n     */\n    function getPositionValue(\n        uint256 positionId\n    ) public view override returns (uint256 positionValue) {\n        Position memory pos = positions[positionId];\n        if (pos.collateralSize == 0) {\n            return 0;\n        } else {\n            if (pos.collToken == address(0))\n                revert Errors.BAD_COLLATERAL(positionId);\n            uint256 collValue = oracle.getWrappedTokenValue(\n                pos.collToken,\n                pos.collId,\n                pos.collateralSize\n            );\n\n            uint rewardsValue;\n            (address[] memory tokens, uint256[] memory rewards) = IERC20Wrapper(\n                pos.collToken\n            ).pendingRewards(pos.collId, pos.collateralSize);\n            for (uint256 i; i < tokens.length; i++) {\n                rewardsValue += oracle.getTokenValue(tokens[i], rewards[i]);\n            }\n\n            return collValue + rewardsValue;\n        }\n    }\n\n    /// @notice Return the USD value of total debt of the given position considering debt interest stored\n    /// @dev Should call accrue first to get current debt\n    /// @param positionId The position ID to query for the debt value.\n    function getDebtValue(\n        uint256 positionId\n    ) public view override returns (uint256 debtValue) {\n        Position memory pos = positions[positionId];\n        uint256 debt = getPositionDebt(positionId);\n        debtValue = oracle.getTokenValue(pos.debtToken, debt);\n    }\n\n    /// @notice Return the USD value of isolated collateral of given position considering stored lending interest\n    /// @dev Should call accrue first to get current debt\n    /// @param positionId The position ID to query the isolated collateral value\n    function getIsolatedCollateralValue(\n        uint256 positionId\n    ) public view override returns (uint256 icollValue) {\n        Position memory pos = positions[positionId];\n        // NOTE: exchangeRateStored has 18 decimals.\n        uint256 underlyingAmount;\n        if (_isSoftVault(pos.underlyingToken)) {\n            underlyingAmount =\n                (ICErc20(banks[pos.debtToken].bToken).exchangeRateStored() *\n                    pos.underlyingVaultShare) /\n                Constants.PRICE_PRECISION;\n        } else {\n            underlyingAmount = pos.underlyingVaultShare;\n        }\n        icollValue = oracle.getTokenValue(\n            pos.underlyingToken,\n            underlyingAmount\n        );\n    }\n\n    /// @dev Return the risk ratio of given position, higher value, higher risk\n    /// @param positionId id of position to check the risk of\n    /// @return risk risk ratio, based 1e4\n    function getPositionRisk(\n        uint256 positionId\n    ) public view returns (uint256 risk) {\n        uint256 pv = getPositionValue(positionId);\n        uint256 ov = getDebtValue(positionId);\n        uint256 cv = getIsolatedCollateralValue(positionId);\n\n        if (\n            (cv == 0 && pv == 0 && ov == 0) || pv >= ov // Closed position or Overcollateralized position\n        ) {\n            risk = 0;\n        } else if (cv == 0) {\n            // Sth bad happened to isolated underlying token\n            risk = Constants.DENOMINATOR;\n        } else {\n            risk = ((ov - pv) * Constants.DENOMINATOR) / cv;\n        }\n    }\n\n    /// @dev Return the possibility of liquidation\n    /// @param positionId id of position to check the liquidation of\n    function isLiquidatable(uint256 positionId) public view returns (bool) {\n        return\n            getPositionRisk(positionId) >=\n            banks[positions[positionId].underlyingToken].liqThreshold;\n    }\n\n    /// @dev Liquidate a position. Pay debt for its owner and take the collateral.\n    /// @param positionId The position ID to liquidate.\n    /// @param debtToken The debt token to repay.\n    /// @param amountCall The amount to repay when doing transferFrom call.\n    function liquidate(\n        uint256 positionId,\n        address debtToken,\n        uint256 amountCall\n    ) external override lock poke(debtToken) {\n        if (!isRepayAllowed()) revert Errors.REPAY_NOT_ALLOWED();\n        if (amountCall == 0) revert Errors.ZERO_AMOUNT();\n        if (!isLiquidatable(positionId))\n            revert Errors.NOT_LIQUIDATABLE(positionId);\n\n        Position storage pos = positions[positionId];\n        Bank memory bank = banks[pos.underlyingToken];\n        if (pos.collToken == address(0))\n            revert Errors.BAD_COLLATERAL(positionId);\n\n        uint256 oldShare = pos.debtShare;\n        (uint256 amountPaid, uint256 share) = _repay(\n            positionId,\n            debtToken,\n            amountCall\n        );\n\n        uint256 liqSize = (pos.collateralSize * share) / oldShare;\n        uint256 uVaultShare = (pos.underlyingVaultShare * share) / oldShare;\n\n        pos.collateralSize -= liqSize;\n        pos.underlyingVaultShare -= uVaultShare;\n\n        // Transfer position (Wrapped LP Tokens) to liquidator\n        IERC1155Upgradeable(pos.collToken).safeTransferFrom(\n            address(this),\n            msg.sender,\n            pos.collId,\n            liqSize,\n            \"\"\n        );\n        // Transfer underlying collaterals(vault share tokens) to liquidator\n        if (_isSoftVault(pos.underlyingToken)) {\n            IERC20Upgradeable(bank.softVault).safeTransfer(\n                msg.sender,\n                uVaultShare\n            );\n        } else {\n            IERC1155Upgradeable(bank.hardVault).safeTransferFrom(\n                address(this),\n                msg.sender,\n                uint256(uint160(pos.underlyingToken)),\n                uVaultShare,\n                \"\"\n            );\n        }\n\n        emit Liquidate(\n            positionId,\n            msg.sender,\n            debtToken,\n            amountPaid,\n            share,\n            liqSize,\n            uVaultShare\n        );\n    }\n\n    /// @dev Execute the action with the supplied data.\n    /// @param positionId The position ID to execute the action, or zero for new position.\n    /// @param spell The target spell to invoke the execution.\n    /// @param data Extra data to pass to the target for the execution.\n    function execute(\n        uint256 positionId,\n        address spell,\n        bytes memory data\n    ) external lock onlyEOAEx returns (uint256) {\n        if (!whitelistedSpells[spell])\n            revert Errors.SPELL_NOT_WHITELISTED(spell);\n        if (positionId == 0) {\n            positionId = nextPositionId++;\n            positions[positionId].owner = msg.sender;\n        } else {\n            if (positionId >= nextPositionId)\n                revert Errors.BAD_POSITION(positionId);\n            if (msg.sender != positions[positionId].owner)\n                revert Errors.NOT_FROM_OWNER(positionId, msg.sender);\n        }\n        POSITION_ID = positionId;\n        SPELL = spell;\n\n        (bool ok, bytes memory returndata) = SPELL.call(data);\n        if (!ok) {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(\"bad cast call\");\n            }\n        }\n\n        if (isLiquidatable(positionId)) revert Errors.INSUFFICIENT_COLLATERAL();\n\n        POSITION_ID = _NO_ID;\n        SPELL = _NO_ADDRESS;\n\n        emit Execute(positionId, msg.sender);\n\n        return positionId;\n    }\n\n    /**\n     * @dev Lend tokens to bank as isolated collateral. Must only be called while under execution.\n     * @param token The token to deposit on bank as isolated collateral\n     * @param amount The amount of tokens to lend.\n     */\n    function lend(\n        address token,\n        uint256 amount\n    ) external override inExec poke(token) onlyWhitelistedToken(token) {\n        if (!isLendAllowed()) revert Errors.LEND_NOT_ALLOWED();\n\n        Position storage pos = positions[POSITION_ID];\n        Bank storage bank = banks[token];\n        if (pos.underlyingToken != address(0)) {\n            // already have isolated collateral, allow same isolated collateral\n            if (pos.underlyingToken != token)\n                revert Errors.INCORRECT_UNDERLYING(token);\n        } else {\n            pos.underlyingToken = token;\n        }\n\n        IERC20Upgradeable(token).safeTransferFrom(\n            pos.owner,\n            address(this),\n            amount\n        );\n        _ensureApprove(token, address(feeManager), amount);\n        amount = feeManager.doCutDepositFee(token, amount);\n\n        if (_isSoftVault(token)) {\n            _ensureApprove(token, bank.softVault, amount);\n            pos.underlyingVaultShare += ISoftVault(bank.softVault).deposit(\n                amount\n            );\n        } else {\n            _ensureApprove(token, bank.hardVault, amount);\n            pos.underlyingVaultShare += IHardVault(bank.hardVault).deposit(\n                token,\n                amount\n            );\n        }\n\n        emit Lend(POSITION_ID, msg.sender, token, amount);\n    }\n\n    /**\n     * @dev Withdraw isolated collateral tokens lent to bank. Must only be called from spell while under execution.\n     * @param token Isolated collateral token address\n     * @param shareAmount The amount of vaule share token to withdraw.\n     */\n    function withdrawLend(\n        address token,\n        uint256 shareAmount\n    ) external override inExec poke(token) {\n        if (!isWithdrawLendAllowed()) revert Errors.WITHDRAW_LEND_NOT_ALLOWED();\n        Position storage pos = positions[POSITION_ID];\n        Bank memory bank = banks[token];\n        if (token != pos.underlyingToken) revert Errors.INVALID_UTOKEN(token);\n        if (shareAmount == type(uint256).max) {\n            shareAmount = pos.underlyingVaultShare;\n        }\n\n        uint256 wAmount;\n        if (_isSoftVault(token)) {\n            _ensureApprove(bank.softVault, bank.softVault, shareAmount);\n            wAmount = ISoftVault(bank.softVault).withdraw(shareAmount);\n        } else {\n            wAmount = IHardVault(bank.hardVault).withdraw(token, shareAmount);\n        }\n\n        pos.underlyingVaultShare -= shareAmount;\n\n        _ensureApprove(token, address(feeManager), wAmount);\n        wAmount = feeManager.doCutWithdrawFee(token, wAmount);\n\n        IERC20Upgradeable(token).safeTransfer(msg.sender, wAmount);\n\n        emit WithdrawLend(POSITION_ID, msg.sender, token, wAmount);\n    }\n\n    /// @dev Borrow tokens from given bank. Must only be called from spell while under execution.\n    /// @param token The token to borrow from the bank.\n    /// @param amount The amount of tokens to borrow.\n    /// @return borrowedAmount Returns the borrowed amount\n    function borrow(\n        address token,\n        uint256 amount\n    )\n        external\n        override\n        inExec\n        poke(token)\n        onlyWhitelistedToken(token)\n        returns (uint256 borrowedAmount)\n    {\n        if (!isBorrowAllowed()) revert Errors.BORROW_NOT_ALLOWED();\n        Bank storage bank = banks[token];\n        Position storage pos = positions[POSITION_ID];\n        if (pos.debtToken != address(0)) {\n            // already have some debts, allow same debt token\n            if (pos.debtToken != token) revert Errors.INCORRECT_DEBT(token);\n        } else {\n            pos.debtToken = token;\n        }\n\n        uint256 totalShare = bank.totalShare;\n        uint256 totalDebt = _borrowBalanceStored(token);\n        uint256 share = totalShare == 0\n            ? amount\n            : (amount * totalShare).divCeil(totalDebt);\n        if (share == 0) revert Errors.BORROW_ZERO_SHARE(amount);\n        bank.totalShare += share;\n        pos.debtShare += share;\n\n        borrowedAmount = _doBorrow(token, amount);\n        IERC20Upgradeable(token).safeTransfer(msg.sender, borrowedAmount);\n\n        emit Borrow(POSITION_ID, msg.sender, token, amount, share);\n    }\n\n    /// @dev Repay tokens to the bank. Must only be called while under execution.\n    /// @param token The token to repay to the bank.\n    /// @param amountCall The amount of tokens to repay via transferFrom.\n    function repay(\n        address token,\n        uint256 amountCall\n    ) external override inExec poke(token) onlyWhitelistedToken(token) {\n        if (!isRepayAllowed()) revert Errors.REPAY_NOT_ALLOWED();\n        (uint256 amount, uint256 share) = _repay(\n            POSITION_ID,\n            token,\n            amountCall\n        );\n        emit Repay(POSITION_ID, msg.sender, token, amount, share);\n    }\n\n    /// @dev Perform repay action. Return the amount actually taken and the debt share reduced.\n    /// @param positionId The position ID to repay the debt.\n    /// @param token The bank token to pay the debt.\n    /// @param amountCall The amount to repay by calling transferFrom, or -1 for debt size.\n    function _repay(\n        uint256 positionId,\n        address token,\n        uint256 amountCall\n    ) internal returns (uint256, uint256) {\n        Bank storage bank = banks[token];\n        Position storage pos = positions[positionId];\n        if (pos.debtToken != token) revert Errors.INCORRECT_DEBT(token);\n        uint256 totalShare = bank.totalShare;\n        uint256 totalDebt = _borrowBalanceStored(token);\n        uint256 oldShare = pos.debtShare;\n        uint256 oldDebt = (oldShare * totalDebt).divCeil(totalShare);\n        if (amountCall > oldDebt) {\n            amountCall = oldDebt;\n        }\n        amountCall = _doERC20TransferIn(token, amountCall);\n        uint256 paid = _doRepay(token, amountCall);\n        if (paid > oldDebt) revert Errors.REPAY_EXCEEDS_DEBT(paid, oldDebt); // prevent share overflow attack\n        uint256 lessShare = paid == oldDebt\n            ? oldShare\n            : (paid * totalShare) / totalDebt;\n        bank.totalShare -= lessShare;\n        pos.debtShare -= lessShare;\n        return (paid, lessShare);\n    }\n\n    /// @dev Put more collateral for users. Must only be called during execution.\n    /// @param collToken The ERC1155 token wrapped for collateral. (Wrapped token of LP)\n    /// @param collId The token id to collateral. (Uint256 format of LP address)\n    /// @param amountCall The amount of tokens to put via transferFrom.\n    function putCollateral(\n        address collToken,\n        uint256 collId,\n        uint256 amountCall\n    ) external override inExec onlyWhitelistedERC1155(collToken) {\n        Position storage pos = positions[POSITION_ID];\n        if (pos.collToken != collToken || pos.collId != collId) {\n            if (!oracle.isWrappedTokenSupported(collToken, collId))\n                revert Errors.ORACLE_NOT_SUPPORT_WTOKEN(collToken);\n            if (pos.collateralSize > 0)\n                revert Errors.DIFF_COL_EXIST(pos.collToken);\n            pos.collToken = collToken;\n            pos.collId = collId;\n        }\n        uint256 amount = _doERC1155TransferIn(collToken, collId, amountCall);\n        pos.collateralSize += amount;\n        emit PutCollateral(\n            POSITION_ID,\n            pos.owner,\n            msg.sender,\n            collToken,\n            collId,\n            amount\n        );\n    }\n\n    /// @dev Take some collateral back. Must only be called during execution.\n    /// @param amount The amount of tokens to take back via transfer.\n    function takeCollateral(\n        uint256 amount\n    ) external override inExec returns (uint256) {\n        Position storage pos = positions[POSITION_ID];\n        if (amount == type(uint256).max) {\n            amount = pos.collateralSize;\n        }\n        pos.collateralSize -= amount;\n        IERC1155Upgradeable(pos.collToken).safeTransferFrom(\n            address(this),\n            msg.sender,\n            pos.collId,\n            amount,\n            \"\"\n        );\n        emit TakeCollateral(\n            POSITION_ID,\n            msg.sender,\n            pos.collToken,\n            pos.collId,\n            amount\n        );\n\n        return amount;\n    }\n\n    /**\n     * @dev Internal function to perform borrow from the bank and return the amount received.\n     * @param token The token to perform borrow action.\n     * @param amountCall The amount use in the transferFrom call.\n     * NOTE: Caller must ensure that bToken interest was already accrued up to this block.\n     */\n    function _doBorrow(\n        address token,\n        uint256 amountCall\n    ) internal returns (uint256 borrowAmount) {\n        address bToken = banks[token].bToken;\n\n        IERC20Upgradeable uToken = IERC20Upgradeable(token);\n        uint256 uBalanceBefore = uToken.balanceOf(address(this));\n        if (ICErc20(bToken).borrow(amountCall) != 0)\n            revert Errors.BORROW_FAILED(amountCall);\n        uint256 uBalanceAfter = uToken.balanceOf(address(this));\n\n        borrowAmount = uBalanceAfter - uBalanceBefore;\n    }\n\n    /**\n     * @dev Internal function to perform repay to the bank and return the amount actually repaid.\n     * @param token The token to perform repay action.\n     * @param amountCall The amount to use in the repay call.\n     * NOTE: Caller must ensure that bToken interest was already accrued up to this block.\n     */\n    function _doRepay(\n        address token,\n        uint256 amountCall\n    ) internal returns (uint256 repaidAmount) {\n        address bToken = banks[token].bToken;\n        _ensureApprove(token, bToken, amountCall);\n        uint256 beforeDebt = _borrowBalanceStored(token);\n        if (ICErc20(bToken).repayBorrow(amountCall) != 0)\n            revert Errors.REPAY_FAILED(amountCall);\n        uint256 newDebt = _borrowBalanceStored(token);\n        repaidAmount = beforeDebt - newDebt;\n    }\n\n    /// @dev Internal function to perform ERC20 transfer in and return amount actually received.\n    /// @param token The token to perform transferFrom action.\n    /// @param amountCall The amount use in the transferFrom call.\n    function _doERC20TransferIn(\n        address token,\n        uint256 amountCall\n    ) internal returns (uint256) {\n        uint256 balanceBefore = IERC20Upgradeable(token).balanceOf(\n            address(this)\n        );\n        IERC20Upgradeable(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amountCall\n        );\n        uint256 balanceAfter = IERC20Upgradeable(token).balanceOf(\n            address(this)\n        );\n        return balanceAfter - balanceBefore;\n    }\n\n    /// @dev Int"
    }
  ]
}