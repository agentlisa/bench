{
  "Title": "[L12] Inconsistent and error-prone storage references in proxy contracts",
  "Content": "There are three different proxy contracts implemented, all of them following a different approach when handling storage references.\n\n\n* The `OVM_ProxySequencerEntrypoint` contract stores the implementation and owner addresses in continuous storage slots at positions 0 and 1 (as can be seen in the [internal getter and setter functions](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/predeploys/OVM_ProxySequencerEntrypoint.sol#L69-L115) for these addresses). While this approach is certainly simple, it can be considered fragile and error-prone. In particular, any poorly constructed implementation that does not take into account the storage layout of the the proxy might accidentally cause a storage collision, and overwrite these two sensitive proxy variables. The problem is aggravated by the fact that the two state variables are not explicitly declared (and therefore visible) in the contract’s state, but rather low-level `ovmSSTORE` and `ovmSLOAD` operations are performed to handle them.\n* The [`OVM_ProxyEOA` contract](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/accounts/OVM_ProxyEOA.sol) stores the implementation address in the storage slot dictated by its [`IMPLEMENTATION_KEY` constant](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/OVM/accounts/OVM_ProxyEOA.sol#L23), currently set to `0xdeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead`.\n* The [`Lib_ResolvedDelegateProxy` contract](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/resolver/Lib_ResolvedDelegateProxy.sol) does not follow either of the previous approaches. Instead, it uses [private mappings](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/resolver/Lib_ResolvedDelegateProxy.sol#L24-L25) in state to [store two addresses](https://github.com/ben-chain/contracts-v2/blob/a935e276f5620b40802b52721e3474232e458f72/contracts/optimistic-ethereum/libraries/resolver/Lib_ResolvedDelegateProxy.sol#L41-L42) corresponding to the `Lib_AddressManager` and implementation contracts, which is said to include a “known flaw” without providing further details.\n\n\nFor a more robust and consistent implementation of proxy contracts, consider always following standardized storage slots for relevant addresses in state. Refer to [EIP 1967](https://eips.ethereum.org/EIPS/eip-1967) for one possible approach. This should allow building common, reusable tooling to facilitate reliable inspection and interaction with all proxy contracts in the system.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/optimistic-ethereum/OVM/predeploys/OVM_ProxySequencerEntrypoint.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\n\n/* Library Imports */\nimport { Lib_SafeExecutionManagerWrapper } from \"../../libraries/wrappers/Lib_SafeExecutionManagerWrapper.sol\";\n\n/**\n * @title OVM_ProxySequencerEntrypoint \n * @dev The Proxy Sequencer Entrypoint is a predeployed proxy to the implementation of the \n * Sequencer Entrypoint. This will enable the Optimism team to upgrade the Sequencer Entrypoint \n * contract.\n * \n * Compiler used: solc\n * Runtime target: OVM\n */\ncontract OVM_ProxySequencerEntrypoint {\n\n    /*********************\n     * Fallback Function *\n     *********************/\n\n    fallback()\n        external\n    {\n        Lib_SafeExecutionManagerWrapper.safeDELEGATECALL(\n            gasleft(),\n            _getImplementation(),\n            msg.data\n        );\n    }\n\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    function init(\n        address _implementation,\n        address _owner\n    )\n        external\n    {\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(\n            _getOwner() == address(0),\n            \"ProxySequencerEntrypoint has already been inited\"\n        );\n        _setOwner(_owner);\n        _setImplementation(_implementation);\n    }\n\n    function upgrade(\n        address _implementation\n    )\n        external\n    {\n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(\n            _getOwner() == Lib_SafeExecutionManagerWrapper.safeCALLER(),\n            \"Only owner can upgrade the Entrypoint\"\n        );\n\n        _setImplementation(_implementation);\n    }\n\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function _setImplementation(\n        address _implementation\n    )\n        internal\n    {\n        Lib_SafeExecutionManagerWrapper.safeSSTORE(\n            bytes32(uint256(0)),\n            bytes32(uint256(uint160(_implementation)))\n        );\n    }\n\n    function _getImplementation()\n        internal\n        returns (\n            address _implementation\n        )\n    {\n        return address(uint160(uint256(\n            Lib_SafeExecutionManagerWrapper.safeSLOAD(\n                bytes32(uint256(0))\n            )\n        )));\n    }\n\n    function _setOwner(\n        address _owner\n    )\n        internal\n    {\n        Lib_SafeExecutionManagerWrapper.safeSSTORE(\n            bytes32(uint256(1)),\n            bytes32(uint256(uint160(_owner)))\n        );\n    }\n\n    function _getOwner()\n        internal\n        returns (\n            address _owner\n        )\n    {\n        return address(uint160(uint256(\n            Lib_SafeExecutionManagerWrapper.safeSLOAD(\n                bytes32(uint256(1))\n            )\n        )));\n    }\n}"
    }
  ]
}