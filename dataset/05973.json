{
  "Title": "[H-01] Too many rewards are distributed when a draw is closed",
  "Content": "\n<https://github.com/GenerationSoftware/pt-v5-draw-auction/blob/f1c6d14a1772d6609de1870f8713fb79977d51c1/src/RngRelayAuction.sol#L178-L184><br>\n<https://github.com/GenerationSoftware/pt-v5-draw-auction/blob/f1c6d14a1772d6609de1870f8713fb79977d51c1/src/RngRelayAuction.sol#L154-L157><br>\n<https://github.com/GenerationSoftware/pt-v5-prize-pool/blob/26557afa439934afc080eca6165fe3ce5d4b63cd/src/PrizePool.sol#L366><br>\n<https://github.com/GenerationSoftware/pt-v5-prize-pool/blob/26557afa439934afc080eca6165fe3ce5d4b63cd/src/abstract/TieredLiquidityDistributor.sol#L374>\n\nA relayer completes a prize pool draw by calling `rngComplete` in `RngRelayAuction.sol`. This method closes the prize pool draw with the relayed random number and distributes the rewards to the RNG auction recipient and the RNG relay auction recipient. These rewards are calculated based on a fraction of the prize pool reserve rather than an actual value.\n\nHowever, the current reward calculation mistakenly includes an extra `reserveForOpenDraw` amount just after the draw has been closed. Therefore the fraction over which the rewards are being calculated includes tokens that have not been added to the reserve and will actually only be added to the reserve when the next draw is finalised. As a result, the reward recipients are rewarded too many tokens.\n\n### Proof of Concept\n\nBefore deciding whether or not to relay an auction result, a bot can call `computeRewards` to calculate how many rewards they'll be getting based on the size of the reserve, the state of the auction and the reward fraction of the RNG auction recipient:\n\n      function computeRewards(AuctionResult[] calldata __auctionResults) external returns (uint256[] memory) {\n        uint256 totalReserve = prizePool.reserve() + prizePool.reserveForOpenDraw();\n        return _computeRewards(__auctionResults, totalReserve);\n      }\n\nHere, the total reserve is calculated as the sum of the current reserve and and amount of new tokens that will be added to the reserve once the currently open draw is closed. This method is correct and correctly calculates how many rewards should be distributed when a draw is closed.\n\nA bot can choose to close the draw by calling `rngComplete` (via a relayer), at which point the rewards are calculated and distributed. Below is the interesting part of this method:\n\n        uint32 drawId = prizePool.closeDraw(_randomNumber);\n\n        uint256 futureReserve = prizePool.reserve() + prizePool.reserveForOpenDraw();\n        uint256[] memory _rewards = RewardLib.rewards(auctionResults, futureReserve);\n\nAs you can see, the draw is first closed and then the future reserve is used to calculate the rewards that should be distributed. However, when `closeDraw` is called on the pool, the `reserveForOpenDraw` for the previously open draw is added to the existing reserves. So `reserve()` is now equal to the `totalReserve` value in the earlier call to `computeRewards`. By including `reserveForOpenDraw()` when computing the actual reward to be distributed we've accidentally counted the tokens that are only going to be added in when the next draw is closed. So now the rewards distribution calculation includes the pending reserves for 2 draws rather than 1.\n\n### Recommended Mitigation Steps\n\nWhen distributing rewards in the call to `rngComplete`, the rewards should not be calculated with the new value of `reserveForOpenDraw` because the previous `reserveForOpenDraw` value has already been added to the reserves when `closeDraw` is called on the prize pool. Below is a suggested diff:\n\n```\ndiff --git a/src/RngRelayAuction.sol b/src/RngRelayAuction.sol\nindex 8085169..cf3c210 100644\n--- a/src/RngRelayAuction.sol\n+++ b/src/RngRelayAuction.sol\n@@ -153,8 +153,8 @@ contract RngRelayAuction is IRngAuctionRelayListener, IAuction {\n \n     uint32 drawId = prizePool.closeDraw(_randomNumber);\n \n-    uint256 futureReserve = prizePool.reserve() + prizePool.reserveForOpenDraw();\n-    uint256[] memory _rewards = RewardLib.rewards(auctionResults, futureReserve);\n+    uint256 reserve = prizePool.reserve();\n+    uint256[] memory _rewards = RewardLib.rewards(auctionResults, reserve);\n \n     emit RngSequenceCompleted(\n       _sequenceId,\n\n```\n\n### Assessed type\n\nMath\n\n**[asselstine (PoolTogether) confirmed and commented](https://github.com/code-423n4/2023-08-pooltogether-findings/issues/139#issuecomment-1673817657):**\n > Nice catch!\n\n**[hickuphh3 (judge) commented](https://github.com/code-423n4/2023-08-pooltogether-findings/issues/139#issuecomment-1676811646):**\n > Great find!\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-08-pooltogether",
  "Code": [
    {
      "filename": "src/RngRelayAuction.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport { UD2x18 } from \"prb-math/UD2x18.sol\";\nimport { convert } from \"prb-math/UD60x18.sol\";\nimport { PrizePool } from \"pt-v5-prize-pool/PrizePool.sol\";\n\nimport { RewardLib } from \"./libraries/RewardLib.sol\";\nimport { IRngAuctionRelayListener } from \"./interfaces/IRngAuctionRelayListener.sol\";\nimport { IAuction, AuctionResult } from \"./interfaces/IAuction.sol\";\nimport { RngAuction } from \"./RngAuction.sol\";\n\n/* ============ Custom Errors ============ */\n\n/// @notice Thrown if the auction period is zero.\nerror AuctionDurationZero();\n\n/// @notice Thrown if the auction target time is zero.\nerror AuctionTargetTimeZero();\n\n/**\n  * @notice Thrown if the auction target time exceeds the auction duration.\n  * @param auctionTargetTime The auction target time to complete in seconds\n  * @param auctionDuration The auction duration in seconds\n  */\nerror AuctionTargetTimeExceedsDuration(uint64 auctionDuration, uint64 auctionTargetTime);\n\n/// @notice Thrown if the RngAuction address is the zero address.\nerror RngRelayerZeroAddress();\n\n/// @notice Thrown if the current sequence has already been completed.\nerror SequenceAlreadyCompleted();\n\n/// @notice Thrown if the current draw auction has expired.\nerror AuctionExpired();\n\n/// @notice Thrown if the PrizePool address is the zero address.\nerror PrizePoolZeroAddress();\n\n/**\n * @title   RngRelayAuction\n * @author  G9 Software Inc.\n * @notice  This contract auctions off the RNG relay, then closes the Prize Pool using the RNG results.\n */\ncontract RngRelayAuction is IRngAuctionRelayListener, IAuction {\n\n  /// @notice Emitted for each auction that is rewarded within the sequence.\n  /// @dev Not that the reward fractions compound\n  /// @param sequenceId The sequence ID of the auction\n  /// @param recipient The recipient of the reward\n  /// @param index The order in which this reward occurred\n  /// @param reward The reward amount\n  event AuctionRewardDistributed(\n    uint32 indexed sequenceId,\n    address indexed recipient,\n    uint32 index,\n    uint256 reward\n  );\n\n  /// @notice Emitted once when the sequence is completed and the Prize Pool draw is closed.\n  /// @param sequenceId The sequence id\n  /// @param drawId The draw id that was closed\n  /// @param rewardRecipient The recipient of the Rng Relay Reward\n  /// @param auctionElapsedSeconds The elapsed time of the Rng Relay Auction\n  /// @param rewardFraction The reward fraction of the Rng Relay Auction. Note that this fraction is applied after the Rng Auction fraction is taken.\n  event RngSequenceCompleted(\n    uint32 indexed sequenceId,\n    uint32 indexed drawId,\n    address indexed rewardRecipient,\n    uint64 auctionElapsedSeconds,\n    UD2x18 rewardFraction\n  );\n\n  /// @notice The PrizePool whose draw wil be closed.\n  PrizePool public immutable prizePool;\n\n  /// @notice The relayer that RNG results must originate from.\n  /// @dev Note that this may be a Remote Owner if relayed over an ERC-5164 bridge.\n  address public immutable rngAuctionRelayer;\n\n  /* ============ Variables ============ */\n\n  /// @notice The sequence ID that was used in the last auction\n  uint32 internal _lastSequenceId;\n\n  /// @notice The auction duration in seconds\n  uint64 internal _auctionDurationSeconds;\n\n  /// @notice The target time to complete the auction as a fraction of the auction duration\n  UD2x18 internal _auctionTargetTimeFraction;\n\n  /// @notice The last completed auction results\n  AuctionResult internal _auctionResults;\n\n  /* ============ Constructor ============ */\n\n  /// @notice Construct a new contract\n  /// @param prizePool_ The target Prize Pool to close draws for\n  /// @param _rngAuctionRelayer The relayer that RNG results must originate from\n  /// @param auctionDurationSeconds_ The auction duration in seconds\n  /// @param auctionTargetTime_ The target time to complete the auction\n  constructor(\n    PrizePool prizePool_,\n    address _rngAuctionRelayer,\n    uint64 auctionDurationSeconds_,\n    uint64 auctionTargetTime_\n  ) {\n    if (address(prizePool_) == address(0)) revert PrizePoolZeroAddress();\n    prizePool = prizePool_;\n    if (address(_rngAuctionRelayer) == address(0)) revert RngRelayerZeroAddress();\n    if (auctionDurationSeconds_ == 0) revert AuctionDurationZero();\n    if (auctionTargetTime_ == 0) revert AuctionTargetTimeZero();\n    if (auctionTargetTime_ > auctionDurationSeconds_) {\n      revert AuctionTargetTimeExceedsDuration(auctionDurationSeconds_, auctionTargetTime_);\n    }\n    rngAuctionRelayer = _rngAuctionRelayer;\n    _auctionDurationSeconds = auctionDurationSeconds_;\n    _auctionTargetTimeFraction = UD2x18.wrap(\n      uint64(convert(auctionTargetTime_).div(convert(_auctionDurationSeconds)).unwrap())\n    );\n  }\n\n  /* ============ External Functions ============ */\n\n  /// @notice Called by the relayer to complete the Rng relay auction.\n  /// @param _randomNumber The random number that was generated\n  /// @param _rngCompletedAt The timestamp that the RNG was completed at\n  /// @param _rewardRecipient The recipient of the relay auction reward\n  /// @param _sequenceId The sequence ID of the auction\n  /// @param _rngAuctionResult The result of the RNG auction\n  function rngComplete(\n    uint256 _randomNumber,\n    uint256 _rngCompletedAt,\n    address _rewardRecipient,\n    uint32 _sequenceId,\n    AuctionResult calldata _rngAuctionResult\n  ) external returns (bytes32) {\n    if (_sequenceHasCompleted(_sequenceId)) revert SequenceAlreadyCompleted();\n    uint64 _auctionElapsedSeconds = uint64(block.timestamp < _rngCompletedAt ? 0 : block.timestamp - _rngCompletedAt);\n    if (_auctionElapsedSeconds > (_auctionDurationSeconds-1)) revert AuctionExpired();\n    // Calculate the reward fraction and set the draw auction results\n    UD2x18 rewardFraction = _fractionalReward(_auctionElapsedSeconds);\n    _auctionResults.rewardFraction = rewardFraction;\n    _auctionResults.recipient = _rewardRecipient;\n    _lastSequenceId = _sequenceId;\n\n    AuctionResult[] memory auctionResults = new AuctionResult[](2);\n    auctionResults[0] = _rngAuctionResult;\n    auctionResults[1] = AuctionResult({\n      rewardFraction: rewardFraction,\n      recipient: _rewardRecipient\n    });\n\n    uint32 drawId = prizePool.closeDraw(_randomNumber);\n\n    uint256 futureReserve = prizePool.reserve() + prizePool.reserveForOpenDraw();\n    uint256[] memory _rewards = RewardLib.rewards(auctionResults, futureReserve);\n\n    emit RngSequenceCompleted(\n      _sequenceId,\n      drawId,\n      _rewardRecipient,\n      _auctionElapsedSeconds,\n      rewardFraction\n    );\n\n    for (uint8 i = 0; i < _rewards.length; i++) {\n      uint104 _reward = uint104(_rewards[i]);\n      if (_reward > 0) {\n        prizePool.withdrawReserve(auctionResults[i].recipient, _reward);\n        emit AuctionRewardDistributed(_sequenceId, auctionResults[i].recipient, i, _reward);\n      }\n    }\n\n    return bytes32(uint(drawId));\n  }\n\n  /// @notice Computes the actual rewards that will be distributed to the recipients using the current Prize Pool reserve.\n  /// @param __auctionResults The auction results to use for calculation\n  /// @return rewards The rewards that will be distributed\n  function computeRewards(AuctionResult[] calldata __auctionResults) external returns (uint256[] memory) {\n    uint256 totalReserve = prizePool.reserve() + prizePool.reserveForOpenDraw();\n    return _computeRewards(__auctionResults, totalReserve);\n  }\n\n  /// @notice Computes the actual rewards that will be distributed to the recipients given the passed total reserve\n  /// @param __auctionResults The auction results to use for calculation\n  /// @param _totalReserve The total reserve to use for calculation\n  /// @return rewards The rewards that will be distributed.\n  function computeRewardsWithTotal(AuctionResult[] calldata __auctionResults, uint256 _totalReserve) external returns (uint256[] memory) {\n    return _computeRewards(__auctionResults, _totalReserve);\n  }\n\n  /// @notice Returns whether the given sequence has complete.\n  /// @param _sequenceId The sequence to check\n  /// @return True if the sequence has already completed\n  function isSequenceCompleted(uint32 _sequenceId) external view returns (bool) {\n    return _sequenceHasCompleted(_sequenceId);\n  }\n\n  /// @notice Returns the duration of the auction in seconds. \n  function auctionDuration() external view returns (uint64) {\n    return _auctionDurationSeconds;\n  }\n\n  /// @notice Computes the reward fraction for the given auction elapsed time\n  /// @param _auctionElapsedTime The elapsed time of the auction\n  /// @return The reward fraction\n  function computeRewardFraction(uint64 _auctionElapsedTime) external view returns (UD2x18) {\n    return _fractionalReward(_auctionElapsedTime);\n  }\n\n  /// @notice Returns the last completed sequence id\n  function lastSequenceId() external view returns (uint32) {\n    return _lastSequenceId;\n  }\n\n  /// @notice Returns the last auction result\n  function getLastAuctionResult()\n    external\n    view\n    returns (AuctionResult memory)\n  {\n    return _auctionResults;\n  }\n\n  /* ============ Internal Functions ============ */\n\n  /// @notice Computes the rewards for each reward recipient based on their reward fraction.\n  /// @dev Note that the fractions compound, such that the second reward fraction is a fraction of the remained of the previous, etc.\n  /// @param __auctionResults The auction results to use for calculation\n  /// @param _totalReserve The total reserve to use for calculation\n  /// @return The actual rewards for each reward recipient\n  function _computeRewards(AuctionResult[] calldata __auctionResults, uint256 _totalReserve) internal returns (uint256[] memory) {\n    return RewardLib.rewards(__auctionResults, _totalReserve);\n  }\n\n  /// @notice Returns whether the given sequence has completed.\n  /// @param _sequenceId The sequence to check\n  /// @return True if the sequence has already completed, false otherwise\n  function _sequenceHasCompleted(uint32 _sequenceId) internal view returns (bool) {\n    return _lastSequenceId >= _sequenceId;\n  }\n\n  /**\n   * @notice Calculates the reward fraction for an auction if it were to be completed after the elapsed time.\n   * @dev Uses the last sold fraction as the target price for this auction.\n   * @return The reward fraction as a UD2x18 value\n   */\n  function _fractionalReward(uint64 _elapsedSeconds) internal view returns (UD2x18) {\n    return\n      RewardLib.fractionalReward(\n        _elapsedSeconds,\n        _auctionDurationSeconds,\n        _auctionTargetTimeFraction,\n        _auctionResults.rewardFraction\n      );\n  }\n}"
    },
    {
      "filename": "src/RngRelayAuction.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport { UD2x18 } from \"prb-math/UD2x18.sol\";\nimport { convert } from \"prb-math/UD60x18.sol\";\nimport { PrizePool } from \"pt-v5-prize-pool/PrizePool.sol\";\n\nimport { RewardLib } from \"./libraries/RewardLib.sol\";\nimport { IRngAuctionRelayListener } from \"./interfaces/IRngAuctionRelayListener.sol\";\nimport { IAuction, AuctionResult } from \"./interfaces/IAuction.sol\";\nimport { RngAuction } from \"./RngAuction.sol\";\n\n/* ============ Custom Errors ============ */\n\n/// @notice Thrown if the auction period is zero.\nerror AuctionDurationZero();\n\n/// @notice Thrown if the auction target time is zero.\nerror AuctionTargetTimeZero();\n\n/**\n  * @notice Thrown if the auction target time exceeds the auction duration.\n  * @param auctionTargetTime The auction target time to complete in seconds\n  * @param auctionDuration The auction duration in seconds\n  */\nerror AuctionTargetTimeExceedsDuration(uint64 auctionDuration, uint64 auctionTargetTime);\n\n/// @notice Thrown if the RngAuction address is the zero address.\nerror RngRelayerZeroAddress();\n\n/// @notice Thrown if the current sequence has already been completed.\nerror SequenceAlreadyCompleted();\n\n/// @notice Thrown if the current draw auction has expired.\nerror AuctionExpired();\n\n/// @notice Thrown if the PrizePool address is the zero address.\nerror PrizePoolZeroAddress();\n\n/**\n * @title   RngRelayAuction\n * @author  G9 Software Inc.\n * @notice  This contract auctions off the RNG relay, then closes the Prize Pool using the RNG results.\n */\ncontract RngRelayAuction is IRngAuctionRelayListener, IAuction {\n\n  /// @notice Emitted for each auction that is rewarded within the sequence.\n  /// @dev Not that the reward fractions compound\n  /// @param sequenceId The sequence ID of the auction\n  /// @param recipient The recipient of the reward\n  /// @param index The order in which this reward occurred\n  /// @param reward The reward amount\n  event AuctionRewardDistributed(\n    uint32 indexed sequenceId,\n    address indexed recipient,\n    uint32 index,\n    uint256 reward\n  );\n\n  /// @notice Emitted once when the sequence is completed and the Prize Pool draw is closed.\n  /// @param sequenceId The sequence id\n  /// @param drawId The draw id that was closed\n  /// @param rewardRecipient The recipient of the Rng Relay Reward\n  /// @param auctionElapsedSeconds The elapsed time of the Rng Relay Auction\n  /// @param rewardFraction The reward fraction of the Rng Relay Auction. Note that this fraction is applied after the Rng Auction fraction is taken.\n  event RngSequenceCompleted(\n    uint32 indexed sequenceId,\n    uint32 indexed drawId,\n    address indexed rewardRecipient,\n    uint64 auctionElapsedSeconds,\n    UD2x18 rewardFraction\n  );\n\n  /// @notice The PrizePool whose draw wil be closed.\n  PrizePool public immutable prizePool;\n\n  /// @notice The relayer that RNG results must originate from.\n  /// @dev Note that this may be a Remote Owner if relayed over an ERC-5164 bridge.\n  address public immutable rngAuctionRelayer;\n\n  /* ============ Variables ============ */\n\n  /// @notice The sequence ID that was used in the last auction\n  uint32 internal _lastSequenceId;\n\n  /// @notice The auction duration in seconds\n  uint64 internal _auctionDurationSeconds;\n\n  /// @notice The target time to complete the auction as a fraction of the auction duration\n  UD2x18 internal _auctionTargetTimeFraction;\n\n  /// @notice The last completed auction results\n  AuctionResult internal _auctionResults;\n\n  /* ============ Constructor ============ */\n\n  /// @notice Construct a new contract\n  /// @param prizePool_ The target Prize Pool to close draws for\n  /// @param _rngAuctionRelayer The relayer that RNG results must originate from\n  /// @param auctionDurationSeconds_ The auction duration in seconds\n  /// @param auctionTargetTime_ The target time to complete the auction\n  constructor(\n    PrizePool prizePool_,\n    address _rngAuctionRelayer,\n    uint64 auctionDurationSeconds_,\n    uint64 auctionTargetTime_\n  ) {\n    if (address(prizePool_) == address(0)) revert PrizePoolZeroAddress();\n    prizePool = prizePool_;\n    if (address(_rngAuctionRelayer) == address(0)) revert RngRelayerZeroAddress();\n    if (auctionDurationSeconds_ == 0) revert AuctionDurationZero();\n    if (auctionTargetTime_ == 0) revert AuctionTargetTimeZero();\n    if (auctionTargetTime_ > auctionDurationSeconds_) {\n      revert AuctionTargetTimeExceedsDuration(auctionDurationSeconds_, auctionTargetTime_);\n    }\n    rngAuctionRelayer = _rngAuctionRelayer;\n    _auctionDurationSeconds = auctionDurationSeconds_;\n    _auctionTargetTimeFraction = UD2x18.wrap(\n      uint64(convert(auctionTargetTime_).div(convert(_auctionDurationSeconds)).unwrap())\n    );\n  }\n\n  /* ============ External Functions ============ */\n\n  /// @notice Called by the relayer to complete the Rng relay auction.\n  /// @param _randomNumber The random number that was generated\n  /// @param _rngCompletedAt The timestamp that the RNG was completed at\n  /// @param _rewardRecipient The recipient of the relay auction reward\n  /// @param _sequenceId The sequence ID of the auction\n  /// @param _rngAuctionResult The result of the RNG auction\n  function rngComplete(\n    uint256 _randomNumber,\n    uint256 _rngCompletedAt,\n    address _rewardRecipient,\n    uint32 _sequenceId,\n    AuctionResult calldata _rngAuctionResult\n  ) external returns (bytes32) {\n    if (_sequenceHasCompleted(_sequenceId)) revert SequenceAlreadyCompleted();\n    uint64 _auctionElapsedSeconds = uint64(block.timestamp < _rngCompletedAt ? 0 : block.timestamp - _rngCompletedAt);\n    if (_auctionElapsedSeconds > (_auctionDurationSeconds-1)) revert AuctionExpired();\n    // Calculate the reward fraction and set the draw auction results\n    UD2x18 rewardFraction = _fractionalReward(_auctionElapsedSeconds);\n    _auctionResults.rewardFraction = rewardFraction;\n    _auctionResults.recipient = _rewardRecipient;\n    _lastSequenceId = _sequenceId;\n\n    AuctionResult[] memory auctionResults = new AuctionResult[](2);\n    auctionResults[0] = _rngAuctionResult;\n    auctionResults[1] = AuctionResult({\n      rewardFraction: rewardFraction,\n      recipient: _rewardRecipient\n    });\n\n    uint32 drawId = prizePool.closeDraw(_randomNumber);\n\n    uint256 futureReserve = prizePool.reserve() + prizePool.reserveForOpenDraw();\n    uint256[] memory _rewards = RewardLib.rewards(auctionResults, futureReserve);\n\n    emit RngSequenceCompleted(\n      _sequenceId,\n      drawId,\n      _rewardRecipient,\n      _auctionElapsedSeconds,\n      rewardFraction\n    );\n\n    for (uint8 i = 0; i < _rewards.length; i++) {\n      uint104 _reward = uint104(_rewards[i]);\n      if (_reward > 0) {\n        prizePool.withdrawReserve(auctionResults[i].recipient, _reward);\n        emit AuctionRewardDistributed(_sequenceId, auctionResults[i].recipient, i, _reward);\n      }\n    }\n\n    return bytes32(uint(drawId));\n  }\n\n  /// @notice Computes the actual rewards that will be distributed to the recipients using the current Prize Pool reserve.\n  /// @param __auctionResults The auction results to use for calculation\n  /// @return rewards The rewards that will be distributed\n  function computeRewards(AuctionResult[] calldata __auctionResults) external returns (uint256[] memory) {\n    uint256 totalReserve = prizePool.reserve() + prizePool.reserveForOpenDraw();\n    return _computeRewards(__auctionResults, totalReserve);\n  }\n\n  /// @notice Computes the actual rewards that will be distributed to the recipients given the passed total reserve\n  /// @param __auctionResults The auction results to use for calculation\n  /// @param _totalReserve The total reserve to use for calculation\n  /// @return rewards The rewards that will be distributed.\n  function computeRewardsWithTotal(AuctionResult[] calldata __auctionResults, uint256 _totalReserve) external returns (uint256[] memory) {\n    return _computeRewards(__auctionResults, _totalReserve);\n  }\n\n  /// @notice Returns whether the given sequence has complete.\n  /// @param _sequenceId The sequence to check\n  /// @return True if the sequence has already completed\n  function isSequenceCompleted(uint32 _sequenceId) external view returns (bool) {\n    return _sequenceHasCompleted(_sequenceId);\n  }\n\n  /// @notice Returns the duration of the auction in seconds. \n  function auctionDuration() external view returns (uint64) {\n    return _auctionDurationSeconds;\n  }\n\n  /// @notice Computes the reward fraction for the given auction elapsed time\n  /// @param _auctionElapsedTime The elapsed time of the auction\n  /// @return The reward fraction\n  function computeRewardFraction(uint64 _auctionElapsedTime) external view returns (UD2x18) {\n    return _fractionalReward(_auctionElapsedTime);\n  }\n\n  /// @notice Returns the last completed sequence id\n  function lastSequenceId() external view returns (uint32) {\n    return _lastSequenceId;\n  }\n\n  /// @notice Returns the last auction result\n  function getLastAuctionResult()\n    external\n    view\n    returns (AuctionResult memory)\n  {\n    return _auctionResults;\n  }\n\n  /* ============ Internal Functions ============ */\n\n  /// @notice Computes the rewards for each reward recipient based on their reward fraction.\n  /// @dev Note that the fractions compound, such that the second reward fraction is a fraction of the remained of the previous, etc.\n  /// @param __auctionResults The auction results to use for calculation\n  /// @param _totalReserve The total reserve to use for calculation\n  /// @return The actual rewards for each reward recipient\n  function _computeRewards(AuctionResult[] calldata __auctionResults, uint256 _totalReserve) internal returns (uint256[] memory) {\n    return RewardLib.rewards(__auctionResults, _totalReserve);\n  }\n\n  /// @notice Returns whether the given sequence has completed.\n  /// @param _sequenceId The sequence to check\n  /// @return True if the sequence has already completed, false otherwise\n  function _sequenceHasCompleted(uint32 _sequenceId) internal view returns (bool) {\n    return _lastSequenceId >= _sequenceId;\n  }\n\n  /**\n   * @notice Calculates the reward fraction for an auction if it were to be completed after the elapsed time.\n   * @dev Uses the last sold fraction as the target price for this auction.\n   * @return The reward fraction as a UD2x18 value\n   */\n  function _fractionalReward(uint64 _elapsedSeconds) internal view returns (UD2x18) {\n    return\n      RewardLib.fractionalReward(\n        _elapsedSeconds,\n        _auctionDurationSeconds,\n        _auctionTargetTimeFraction,\n        _auctionResults.rewardFraction\n      );\n  }\n}"
    },
    {
      "filename": "src/PrizePool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"forge-std/console2.sol\";\n\nimport { IERC20 } from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport { E, SD59x18, sd } from \"prb-math/SD59x18.sol\";\nimport { UD60x18, ud, convert, intoSD59x18 } from \"prb-math/UD60x18.sol\";\nimport { UD2x18, intoUD60x18 } from \"prb-math/UD2x18.sol\";\nimport { SD1x18, unwrap, UNIT } from \"prb-math/SD1x18.sol\";\nimport { TwabController } from \"pt-v5-twab-controller/TwabController.sol\";\n\nimport { UD34x4, fromUD60x18 as fromUD60x18toUD34x4, intoUD60x18 as fromUD34x4toUD60x18, toUD34x4 } from \"./libraries/UD34x4.sol\";\nimport { DrawAccumulatorLib, Observation } from \"./libraries/DrawAccumulatorLib.sol\";\nimport { TieredLiquidityDistributor, Tier } from \"./abstract/TieredLiquidityDistributor.sol\";\nimport { TierCalculationLib } from \"./libraries/TierCalculationLib.sol\";\n\n/// @notice Emitted when someone tries to set the draw manager.\nerror DrawManagerAlreadySet();\n\n/// @notice Emitted when someone tries to claim a prize that was already claimed.\n/// @param winner The winner of the prize\n/// @param tier The prize tier\nerror AlreadyClaimedPrize(\n  address vault,\n  address winner,\n  uint8 tier,\n  uint32 prizeIndex,\n  address recipient\n);\n\n/// @notice Emitted when someone tries to withdraw too many rewards.\n/// @param requested The requested reward amount to withdraw\n/// @param available The total reward amount available for the caller to withdraw\nerror InsufficientRewardsError(uint256 requested, uint256 available);\n\n/// @notice Emitted when an address did not win the specified prize on a vault when claiming.\n/// @param winner The address checked for the prize\n/// @param vault The vault address\n/// @param tier The prize tier\n/// @param prizeIndex The prize index\nerror DidNotWin(address vault, address winner, uint8 tier, uint32 prizeIndex);\n\n/// @notice Emitted when the fee being claimed is larger than the max allowed fee.\n/// @param fee The fee being claimed\n/// @param maxFee The max fee that can be claimed\nerror FeeTooLarge(uint256 fee, uint256 maxFee);\n\n/// @notice Emitted when the initialized smoothing number is not less than one.\n/// @param smoothing The unwrapped smoothing value that exceeds the limit\nerror SmoothingGTEOne(int64 smoothing);\n\n/// @notice Emitted when the contributed amount is more than the available, un-accounted balance.\n/// @param amount The contribution amount that is being claimed\n/// @param available The available un-accounted balance that can be claimed as a contribution\nerror ContributionGTDeltaBalance(uint256 amount, uint256 available);\n\n/// @notice Emitted when the withdraw amount is greater than the available reserve.\n/// @param amount The amount being withdrawn\n/// @param reserve The total reserve available for withdrawal\nerror InsufficientReserve(uint104 amount, uint104 reserve);\n\n/// @notice Emitted when the winning random number is zero.\nerror RandomNumberIsZero();\n\n/// @notice Emitted when the draw cannot be closed since it has not finished.\n/// @param drawEndsAt The timestamp in seconds at which the draw ends\n/// @param errorTimestamp The timestamp in seconds at which the error occured\nerror DrawNotFinished(uint64 drawEndsAt, uint64 errorTimestamp);\n\n/// @notice Emitted when prize index is greater or equal to the max prize count for the tier.\n/// @param invalidPrizeIndex The invalid prize index\n/// @param prizeCount The prize count for the tier\n/// @param tier The tier number\nerror InvalidPrizeIndex(uint32 invalidPrizeIndex, uint32 prizeCount, uint8 tier);\n\n/// @notice Emitted when there are no closed draws when a computation requires a closed draw.\nerror NoClosedDraw();\n\n/// @notice Emitted when attempting to claim from a tier that does not exist.\n/// @param tier The tier number that does not exist\n/// @param numberOfTiers The current number of tiers\nerror InvalidTier(uint8 tier, uint8 numberOfTiers);\n\n/// @notice Emitted when the caller is not the draw manager.\n/// @param caller The caller address\n/// @param drawManager The drawManager address\nerror CallerNotDrawManager(address caller, address drawManager);\n\n/**\n * @notice Constructor Parameters\n * @param prizeToken The token to use for prizes\n * @param twabController The Twab Controller to retrieve time-weighted average balances from\n * @param drawManager The address of the draw manager for the prize pool\n * @param drawPeriodSeconds The number of seconds between draws. E.g. a Prize Pool with a daily draw should have a draw period of 86400 seconds.\n * @param firstDrawStartsAt The timestamp at which the first draw will start.\n * @param numberOfTiers The number of tiers to start with. Must be greater than or equal to the minimum number of tiers.\n * @param tierShares The number of shares to allocate to each tier\n * @param canaryShares The number of shares to allocate to the canary tier.\n * @param reserveShares The number of shares to allocate to the reserve.\n * @param claimExpansionThreshold The percentage of prizes that must be claimed to bump the number of tiers. This threshold is used for both standard prizes and canary prizes.\n * @param smoothing The amount of smoothing to apply to vault contributions. Must be less than 1. A value of 0 is no smoothing, while greater values smooth until approaching infinity\n */\nstruct ConstructorParams {\n  IERC20 prizeToken;\n  TwabController twabController;\n  address drawManager;\n  uint32 drawPeriodSeconds;\n  uint64 firstDrawStartsAt;\n  uint8 numberOfTiers;\n  uint8 tierShares;\n  uint8 canaryShares;\n  uint8 reserveShares;\n  UD2x18 claimExpansionThreshold;\n  SD1x18 smoothing;\n}\n\n/**\n * @title PoolTogether V5 Prize Pool\n * @author PoolTogether Inc Team\n * @notice The Prize Pool holds the prize liquidity and allows vaults to claim prizes.\n */\ncontract PrizePool is TieredLiquidityDistributor {\n  using SafeERC20 for IERC20;\n\n  /* ============ Events ============ */\n\n  /// @notice Emitted when a prize is claimed.\n  /// @param vault The address of the vault that claimed the prize.\n  /// @param winner The address of the winner\n  /// @param recipient The address of the prize recipient\n  /// @param drawId The draw ID of the draw that was claimed.\n  /// @param tier The prize tier that was claimed.\n  /// @param payout The amount of prize tokens that were paid out to the winner\n  /// @param fee The amount of prize tokens that were paid to the claimer\n  /// @param feeRecipient The address that the claim fee was sent to\n  event ClaimedPrize(\n    address indexed vault,\n    address indexed winner,\n    address indexed recipient,\n    uint16 drawId,\n    uint8 tier,\n    uint32 prizeIndex,\n    uint152 payout,\n    uint96 fee,\n    address feeRecipient\n  );\n\n  /// @notice Emitted when a draw is closed.\n  /// @param drawId The ID of the draw that was closed\n  /// @param winningRandomNumber The winning random number for the closed draw\n  /// @param numTiers The number of prize tiers in the closed draw\n  /// @param nextNumTiers The number of tiers for the next draw\n  /// @param reserve The resulting reserve available for the next draw\n  /// @param prizeTokensPerShare The amount of prize tokens per share for the next draw\n  /// @param drawStartedAt The start timestamp of the draw\n  event DrawClosed(\n    uint16 indexed drawId,\n    uint256 winningRandomNumber,\n    uint8 numTiers,\n    uint8 nextNumTiers,\n    uint104 reserve,\n    UD34x4 prizeTokensPerShare,\n    uint64 drawStartedAt\n  );\n\n  /// @notice Emitted when any amount of the reserve is withdrawn.\n  /// @param to The address the assets are transferred to\n  /// @param amount The amount of assets transferred\n  event WithdrawReserve(address indexed to, uint256 amount);\n\n  /// @notice Emitted when the reserve is manually increased.\n  /// @param user The user who increased the reserve\n  /// @param amount The amount of assets transferred\n  event IncreaseReserve(address user, uint256 amount);\n\n  /// @notice Emitted when a vault contributes prize tokens to the pool.\n  /// @param vault The address of the vault that is contributing tokens\n  /// @param drawId The ID of the first draw that the tokens will be applied to\n  /// @param amount The amount of tokens contributed\n  event ContributePrizeTokens(address indexed vault, uint16 indexed drawId, uint256 amount);\n\n  /// @notice Emitted when an address withdraws their prize claim rewards.\n  /// @param to The address the rewards are sent to\n  /// @param amount The amount withdrawn\n  /// @param available The total amount that was available to withdraw before the transfer\n  event WithdrawClaimRewards(address indexed to, uint256 amount, uint256 available);\n\n  /// @notice Emitted when an address receives new prize claim rewards.\n  /// @param to The address the rewards are given to\n  /// @param amount The amount increased\n  event IncreaseClaimRewards(address indexed to, uint256 amount);\n\n  /// @notice Emitted when the drawManager is set.\n  /// @param drawManager The draw manager\n  event DrawManagerSet(address indexed drawManager);\n\n  /* ============ State ============ */\n\n  /// @notice The DrawAccumulator that tracks the exponential moving average of the contributions by a vault.\n  mapping(address => DrawAccumulatorLib.Accumulator) internal vaultAccumulator;\n\n  /// @notice Records the claim record for a winner.\n  /// @dev vault => account => drawId => tier => prizeIndex => claimed\n  mapping(address => mapping(address => mapping(uint16 => mapping(uint8 => mapping(uint32 => bool)))))\n    internal claimedPrizes;\n\n  /// @notice Tracks the total fees accrued to each claimer.\n  mapping(address => uint256) internal claimerRewards;\n\n  /// @notice The degree of POOL contribution smoothing. 0 = no smoothing, ~1 = max smoothing. Smoothing spreads out vault contribution over multiple draws; the higher the smoothing the more draws.\n  SD1x18 public immutable smoothing;\n\n  /// @notice The token that is being contributed and awarded as prizes.\n  IERC20 public immutable prizeToken;\n\n  /// @notice The Twab Controller to use to retrieve historic balances.\n  TwabController public immutable twabController;\n\n  /// @notice The draw manager address.\n  address public drawManager;\n\n  /// @notice The number of seconds between draws.\n  uint32 public immutable drawPeriodSeconds;\n\n  /// @notice Percentage of prizes that must be claimed to bump the number of tiers.\n  UD2x18 public immutable claimExpansionThreshold;\n\n  /// @notice The exponential weighted average of all vault contributions.\n  DrawAccumulatorLib.Accumulator internal totalAccumulator;\n\n  /// @notice The total amount of prize tokens that have been claimed for all time.\n  uint256 internal _totalWithdrawn;\n\n  /// @notice The winner random number for the last closed draw.\n  uint256 internal _winningRandomNumber;\n\n  /// @notice The number of prize claims for the last closed draw.\n  uint32 public claimCount;\n\n  /// @notice The number of canary prize claims for the last closed draw.\n  uint32 public canaryClaimCount;\n\n  /// @notice The largest tier claimed so far for the last closed draw.\n  uint8 public largestTierClaimed;\n\n  /// @notice The timestamp at which the last closed draw started.\n  uint64 internal _lastClosedDrawStartedAt;\n\n  /// @notice The timestamp at which the last closed draw was awarded.\n  uint64 internal _lastClosedDrawAwardedAt;\n\n  /* ============ Constructor ============ */\n\n  /// @notice Constructs a new Prize Pool.\n  /// @param params A struct of constructor parameters\n  constructor(\n    ConstructorParams memory params"
    }
  ]
}