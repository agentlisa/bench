{
  "Title": "M-8: BlockSpecimenProofChain::submitBlockSpecimenProof Block specimen producer can greatly reduce session duration by submitting fake block specimen in the future",
  "Content": "# Issue M-8: BlockSpecimenProofChain::submitBlockSpecimenProof Block specimen producer can greatly reduce session duration by submitting fake block specimen in the future \n\nSource: https://github.com/sherlock-audit/2023-11-covalent-judging/issues/79 \n\n## Found by \ncergyk\n## Summary\nBlock specimen producers submit specimens for a given block number during a limited time called a session. Any block producer can start a session by calling `submitBlockSpecimenProof` for a given block number. This means that a block specimen producer can start a session for a block which does not exist yet, and severily reduce the actual session time, since honest block specimen producer can only participate between the time the block has been created and the end of session.\n\n## Vulnerability Detail\nWe can see that a session is started when the first specimen for the block height is submitted:\nhttps://github.com/sherlock-audit/2023-11-covalent/blob/main/cqt-staking/contracts/BlockSpecimenProofChain.sol#L346-L348\n\nThis means that if a malicious block specimen producer has sent some invalid data for a block height which is in the future, the session is still started for that block. The following check ensures that a producer can not call submit for a block too far in the future:\nhttps://github.com/sherlock-audit/2023-11-covalent/blob/main/cqt-staking/contracts/BlockSpecimenProofChain.sol#L344\n\nBut since the default value for `cd.allowedThreshold` would be 100 blocks, and a session duration would be approximately 240 blocks, we can see that a malicious block producer can reduce the actual session duration for honest producers by half.\n\n## Impact\nThe block specimen production session can be greatly reduced by a malicious producer (up to a half with current deploy parameters).\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\nPlease consider starting the session at the estimated timestamp of the considered `blockHeight`:\n```diff\n- session.sessionDeadline = uint64(block.number + _blockSpecimenSessionDuration);\n+ uint64 timestampOnDestChain = (blockHeight-cd.blockOnTargetChain)*cd.secondsPerBlock-cd.blockOnCurrentChain*_secondsPerBlock; \n+ session.sessionDeadline = uint64(timestampOnDestChain + _blockSpecimenSessionDuration);\n```\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid: user can submit fake here also; medium(3)\n\n\n\n**noslav**\n\nwe can mitigate this a bit although not completely as we’re currently tied to this way of doing things. We use the block numbers on the current chain (aka current block number on moonbeam + number of blocks to wait for session duration) to determine the deadline for any input block specimen number.. there’s currently no way to know the head of the source chain (ethereum) except through the estimated calculation being done in the contract where block time * time diff from last chain sync tx and we can use to create a shorted upper bound so blocks too far in the future cannot be submitted!\n\n**noslav**\n\npartially fixed by [impl proof submission upper bounds to mitigate future block deadlines](https://github.com/covalenthq/cqt-staking/pull/125/commits/481fcd4ea97e7f6e998dd30ef15122a8e256e5dc)\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/127",
  "Code": [
    {
      "filename": "cqt-staking/contracts/BlockSpecimenProofChain.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"./IOperationalStaking.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract BlockSpecimenProofChain is OwnableUpgradeable {\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.Bytes32Set;\n\n    IOperationalStaking _stakingInterface; // staking contract (deprecated)\n\n    bytes32 public constant GOVERNANCE_ROLE = keccak256(\"GOVERNANCE_ROLE\");\n    bytes32 public constant BLOCK_SPECIMEN_PRODUCER_ROLE = keccak256(\"BLOCK_SPECIMEN_PRODUCER_ROLE\");\n    bytes32 public constant AUDITOR_ROLE = keccak256(\"AUDITOR_ROLE\");\n    uint256 private constant _DIVIDER = 10 ** 18; // 18 decimals used for scaling\n\n    uint256 private _blockSpecimenQuorum; // The value is represented as a uint <= 10**18. The threshold value will later be divided by 10**18 to represent it as a percentage.  e.g.) 10**18 == 100%; 5 * 10**17 == 50%;\n    uint256 private _secondsPerBlock; // average block time on the chain where the ProofChain is deployed\n    uint128 private _blockSpecimenRewardAllocation; // the reward allocated per block hash\n    uint128 private _bspRequiredStake; // how much a validator should have staked in order to run an operator\n    uint64 private _blockSpecimenSessionDuration; // the length of a session in blocks\n    uint64 private _minSubmissionsRequired; // min number of participants who submitted the agreed specimen hash in order for the quorum to be achieved\n\n    EnumerableSetUpgradeable.Bytes32Set private _roleNames; // set of all role names\n\n    EnumerableSetUpgradeable.AddressSet private _blockSpecimenProducers; // currently enabled block specimen producer operators\n    EnumerableSetUpgradeable.AddressSet private _governors; // governor operators\n    EnumerableSetUpgradeable.AddressSet private _auditors; // auditor operators\n\n    mapping(address => uint128) public validatorIDs; // maps an operator address to validatorId\n    mapping(uint128 => EnumerableSetUpgradeable.AddressSet) private _validatorOperators; // operator addresses that validator owns\n    mapping(address => bytes32) public operatorRoles; // operator address => role\n    mapping(uint128 => uint128) private _validatorActiveOperatorsCounters; // how many operators are enabled per validator given validator id\n    mapping(uint64 => mapping(uint64 => BlockSpecimenSession)) private _sessions; // chainId => blockHeight\n    mapping(uint64 => ChainData) private _chainData; // by chain id\n\n    mapping(bytes32 => string[]) private _urls; // hash => urls\n    mapping(uint128 => address) private _validatorAddresses; // validatorId => validator address (deprecated)\n    mapping(uint128 => bool) private _validatorEnabled; // validatorId => enabled?\n    address private _stakingManager;\n\n    struct ChainData {\n        uint256 blockOnTargetChain; // block number on the chain for which BSP are produced which is mapped to the current chain block\n        uint256 blockOnCurrentChain; // block number on the chain where the ProofChain is deployed. it is mapped to the target chain block\n        uint256 secondsPerBlock; // average block time on the chain for which BSP is generated\n        uint128 allowedThreshold; // block offsett threshold, used to handle minor de-synchronization over time\n        uint128 maxSubmissionsPerBlockHeight; // max number of block hashes allowed to submit per block height\n        uint64 nthBlock; // block divisor\n    }\n\n    struct BlockProperties {\n        mapping(bytes32 => address[]) participants; // specimen hash => operators who submitted the specimen hash\n        bytes32[] specimenHashes; // raw specimen hashes\n    }\n\n    struct SessionParticipantData {\n        uint128 stake; // stake at the time when an operator submitted the first specimen hash (deprecate now (always 0))\n        uint128 submissionCounter; // how many specimen hashes an operator has submitted\n    }\n\n    struct BlockSpecimenSession {\n        mapping(bytes32 => BlockProperties) blockProperties; // block hash => block properties\n        bytes32[] blockHashesRaw;\n        mapping(address => SessionParticipantData) participantsData; // stake and submission counter, pack these together to save gas\n        uint64 sessionDeadline; // the last block when an operator can submit a specimen hash\n        bool requiresAudit; // auditor can arbitrate the session only if this is set to true\n    }\n\n    event OperatorAdded(address operator, uint128 validatorId, bytes32 role);\n\n    event OperatorRemoved(address operator, uint128 validatorId, uint128 activeOperatorCount, bytes32 role);\n\n    event ValidatorEnabled(uint128 validatorId);\n\n    event ValidatorDisabled(uint128 validatorId);\n\n    event BlockSpecimenProductionProofSubmitted(\n        uint64 chainId,\n        uint64 blockHeight,\n        bytes32 blockHash,\n        bytes32 specimenHash, // SHA-256 content-hash of specimen object file;\n        string storageURL // URL of specimen storage\n    );\n\n    event SessionStarted(uint64 indexed chainId, uint64 indexed blockHeight, uint64 deadline);\n\n    event QuorumNotReached(uint64 indexed chainId, uint64 blockHeight);\n\n    event BlockSpecimenRewardChanged(uint128 newBlockSpecimenRewardAllocation);\n\n    event MinimumRequiredStakeChanged(uint128 newStakeRequirement);\n\n    event StakingManagerChanged(address newStakingManager);\n\n    event SpecimenSessionQuorumChanged(uint256 newQuorumThreshold);\n\n    event SpecimenSessionDurationChanged(uint64 newSessionDuration);\n\n    event SpecimenSessionMinSubmissionChanged(uint64 minSubmissions);\n\n    event NthBlockChanged(uint64 indexed chainId, uint64 indexed nthBlock);\n\n    event MaxSubmissionsPerBlockHeightChanged(uint256 maxSubmissions);\n\n    event ChainSyncDataChanged(uint64 indexed chainId, uint256 blockOnTargetChain, uint256 blockOnCurrentChain, uint256 secondsPerBlock);\n\n    event SecondsPerBlockChanged(uint64 indexed secondsPerBlock);\n\n    event BlockHeightSubmissionThresholdChanged(uint64 indexed chainId, uint64 threshold);\n\n    event BlockSpecimenQuorum(uint64 indexed chainId, uint64 indexed blockHeight, uint256 validatorBitMap, bytes32 indexed blockHash, bytes32 specimenHash);\n\n    modifier onlyGovernor() {\n        require(_governors.contains(msg.sender), \"Sender is not GOVERNANCE_ROLE\");\n        _;\n    }\n\n    modifier onlyStakingManager() {\n        require(msg.sender == _stakingManager, \"Sender is not staking manager\");\n        _;\n    }\n\n    function initialize(address initialOwner, address stakingManager) public initializer {\n        __Ownable_init();\n\n        _governors.add(msg.sender);\n\n        _roleNames.add(GOVERNANCE_ROLE);\n        _roleNames.add(BLOCK_SPECIMEN_PRODUCER_ROLE);\n        _roleNames.add(AUDITOR_ROLE);\n\n        setQuorumThreshold(_DIVIDER / 2); // 50%\n        setBlockSpecimenReward(10 ** 14); // 0.0001\n        setBlockSpecimenSessionDuration(240); // blocks\n        setMinSubmissionsRequired(2);\n        setStakingManagerAddress(stakingManager);\n        _governors.remove(msg.sender);\n\n        operatorRoles[initialOwner] = GOVERNANCE_ROLE;\n        _governors.add(initialOwner);\n        emit OperatorAdded(initialOwner, 0, GOVERNANCE_ROLE);\n    }\n\n    function disableValidator(uint128 validatorId) external onlyStakingManager {\n        // when remove/disable bsp is called, it emits an event, which might then cause bridge agent to\n        // disable this.\n        _validatorEnabled[validatorId] = false;\n        emit ValidatorDisabled(validatorId);\n    }\n\n    /**\n     * Enables the given operator on the staking contract\n     */\n    function enableValidator(uint128 validatorId) external onlyStakingManager {\n        // when addBsp is done, it emits an event, which might then cause bridge agent\n        // to enable this.\n        _validatorEnabled[validatorId] = true;\n        emit ValidatorEnabled(validatorId);\n    }\n\n    /**\n     * Disables the operator instance.\n     * If all addresses of the operator are disabled, then the operator (validator) instance will get disabled on the staking contract\n     */\n    function _removeBSPOperatorFromActiveInstances(address operator) internal {\n        _blockSpecimenProducers.remove(operator);\n        uint128 validatorId = validatorIDs[operator];\n        _validatorActiveOperatorsCounters[validatorId]--;\n    }\n\n    /**\n     * Adds the given address to the block specimen producers set\n     */\n    function addBSPOperator(address operator, uint128 validatorId) external onlyGovernor {\n        require(operatorRoles[operator] == 0, \"Operator already exists\");\n        operatorRoles[operator] = BLOCK_SPECIMEN_PRODUCER_ROLE;\n        validatorIDs[operator] = validatorId;\n        _validatorOperators[validatorId].add(operator);\n\n        _blockSpecimenProducers.add(operator);\n        _validatorActiveOperatorsCounters[validatorId]++;\n        emit OperatorAdded(operator, validatorId, BLOCK_SPECIMEN_PRODUCER_ROLE);\n    }\n\n    /**\n     * Removes the given address from the block specimen producers set\n     */\n    function removeBSPOperator(address operator) external onlyGovernor {\n        require(operatorRoles[operator] == BLOCK_SPECIMEN_PRODUCER_ROLE, \"Operator is not BSP\");\n        _removeBSPOperatorFromActiveInstances(operator);\n        uint128 validatorID = validatorIDs[operator];\n        _validatorOperators[validatorID].remove(operator);\n        validatorIDs[operator] = 0;\n        operatorRoles[operator] = 0;\n        emit OperatorRemoved(operator, validatorID, _validatorActiveOperatorsCounters[validatorID], BLOCK_SPECIMEN_PRODUCER_ROLE);\n    }\n\n    /**\n     * Adds the given address to the auditors set\n     */\n    function addAuditor(address auditor) external onlyGovernor {\n        require(operatorRoles[auditor] == 0, \"Operator already exists\");\n        operatorRoles[auditor] = AUDITOR_ROLE;\n        _auditors.add(auditor);\n        emit OperatorAdded(auditor, 0, AUDITOR_ROLE);\n    }\n\n    /**\n     * Removes the given address from the auditors set\n     */\n    function removeAuditor(address auditor) external onlyGovernor {\n        require(operatorRoles[auditor] == AUDITOR_ROLE, \"Operator is not auditor\");\n        operatorRoles[auditor] = 0;\n        _auditors.remove(auditor);\n        emit OperatorRemoved(auditor, 0, 0, AUDITOR_ROLE);\n    }\n\n    /**\n     * Adds the given address to the governors set\n     */\n    function addGovernor(address governor) external onlyOwner {\n        require(operatorRoles[governor] == 0, \"Operator already exists\");\n        operatorRoles[governor] = GOVERNANCE_ROLE;\n        _governors.add(governor);\n        emit OperatorAdded(governor, 0, GOVERNANCE_ROLE);\n    }\n\n    /**\n     * Removes the given address from the governors set\n     */\n    function removeGovernor(address governor) external onlyOwner {\n        require(operatorRoles[governor] == GOVERNANCE_ROLE, \"Operator is not governor\");\n        operatorRoles[governor] = 0;\n        _governors.remove(governor);\n        emit OperatorRemoved(governor, 0, 0, GOVERNANCE_ROLE);\n    }\n\n    /**\n     * Updates the address of the staking manager\n     */\n    function setStakingManagerAddress(address stakingManagerAddress) public onlyGovernor {\n        require(stakingManagerAddress != address(0), \"Invalid address\");\n        _stakingManager = stakingManagerAddress;\n        emit StakingManagerChanged(stakingManagerAddress);\n    }\n\n    /**\n     * Update the Block Specimen Quorum Threshold.\n     */\n    function setQuorumThreshold(uint256 quorum) public onlyGovernor {\n        _blockSpecimenQuorum = quorum;\n        emit SpecimenSessionQuorumChanged(quorum);\n    }\n\n    /**\n     * Update block divisor\n     */\n    function setNthBlock(uint64 chainId, uint64 n) public onlyGovernor {\n        _chainData[chainId].nthBlock = n;\n        emit NthBlockChanged(chainId, n);\n    }\n\n    /**\n     * Update the reward allocation per block specimen.\n     */\n    function setBlockSpecimenReward(uint128 newBlockSpecimenReward) public onlyGovernor {\n        _blockSpecimenRewardAllocation = newBlockSpecimenReward;\n        emit BlockSpecimenRewardChanged(newBlockSpecimenReward);\n    }\n\n    /**\n     * Update the duration of a specimen session in blocks\n     */\n    function setBlockSpecimenSessionDuration(uint64 newSessionDuration) public onlyGovernor {\n        _blockSpecimenSessionDuration = newSessionDuration;\n        emit SpecimenSessionDurationChanged(newSessionDuration);\n    }\n\n    /**\n     * Update the minimum # of submissions required in order to reach quorum\n     */\n    function setMinSubmissionsRequired(uint64 minSubmissions) public onlyGovernor {\n        _minSubmissionsRequired = minSubmissions;\n        emit SpecimenSessionMinSubmissionChanged(minSubmissions);\n    }\n\n    /**\n     * Update the max # of submissions per operator per block height\n     */\n    function setMaxSubmissionsPerBlockHeight(uint64 chainId, uint64 maxSubmissions) public onlyGovernor {\n        _chainData[chainId].maxSubmissionsPerBlockHeight = maxSubmissions;\n        emit MaxSubmissionsPerBlockHeightChanged(maxSubmissions);\n    }\n\n    /**\n     * Update chain sync data\n     */\n    function setChainSyncData(uint64 chainId, uint256 blockOnTargetChain, uint256 blockOnCurrentChain, uint256 secondsPerBlock) external onlyGovernor {\n        ChainData storage cd = _chainData[chainId];\n        require(secondsPerBlock > 0, \"Seconds per block cannot be 0\");\n        cd.blockOnTargetChain = blockOnTargetChain;\n        cd.blockOnCurrentChain = blockOnCurrentChain;\n        cd.secondsPerBlock = secondsPerBlock;\n        emit ChainSyncDataChanged(chainId, blockOnTargetChain, blockOnCurrentChain, secondsPerBlock);\n    }\n\n    /**\n     * Update block height submission threshold for live sync\n     */\n    function setBlockHeightSubmissionsThreshold(uint64 chainId, uint64 threshold) external onlyGovernor {\n        _chainData[chainId].allowedThreshold = threshold;\n        emit BlockHeightSubmissionThresholdChanged(chainId, threshold);\n    }\n\n    /**\n     * Update seconds per block on the chain where the ProofChain is deployed\n     */\n    function setSecondsPerBlock(uint64 secondsPerBlock) external onlyGovernor {\n        _secondsPerBlock = secondsPerBlock;\n        emit SecondsPerBlockChanged(secondsPerBlock);\n    }\n\n    /**\n     * Block Specimen Producers submit their block specimen proofs using this function.\n     */\n    function submitBlockSpecimenProof(uint64 chainId, uint64 blockHeight, bytes32 blockHash, bytes32 specimenHash, string calldata storageURL) external {\n        require(_blockSpecimenProducers.contains(msg.sender), \"Sender is not BLOCK_SPECIMEN_PRODUCER_ROLE\");\n        ChainData storage cd = _chainData[chainId];\n        require(cd.nthBlock != 0, \"Invalid chain ID\");\n        require(blockHeight % cd.nthBlock == 0, \"Invalid block height\");\n\n        BlockSpecimenSession storage session = _sessions[chainId][blockHeight];\n        uint64 sessionDeadline = session.sessionDeadline;\n        SessionParticipantData storage participantsData = session.participantsData[msg.sender];\n\n        // if this is the first specimen to be submitted for a block, initialize a new session\n        if (sessionDeadline == 0) {\n            require(!session.requiresAudit, \"Session submissions have closed\");\n\n            uint256 currentBlockOnTargetChain = cd.blockOnTargetChain + (((block.number - cd.blockOnCurrentChain) * _secondsPerBlock) / cd.secondsPerBlock);\n            uint256 lowerBound = currentBlockOnTargetChain >= cd.allowedThreshold ? currentBlockOnTargetChain - cd.allowedThreshold : 0;\n            require(lowerBound <= blockHeight && blockHeight <= currentBlockOnTargetChain + cd.allowedThreshold, \"Block height is out of bounds for live sync\");\n\n            session.sessionDeadline = uint64(block.number + _blockSpecimenSessionDuration);\n\n            emit SessionStarted(chainId, blockHeight, session.sessionDeadline);\n\n            uint128 validatorID = validatorIDs[msg.sender];\n\n            require(_validatorEnabled[validatorID], \"Validator is not enabled\");\n\n            session.blockHashesRaw.push(blockHash);\n            BlockProperties storage bh = session.blockProperties[blockHash];\n            bh.specimenHashes.push(specimenHash);\n\n            bh.participants[specimenHash].push(msg.sender);\n            participantsData.submissionCounter++;\n        } else {\n            require(block.number <= sessionDeadline, \"Session submissions have closed\");\n            require(participantsData.submissionCounter < cd.maxSubmissionsPerBlockHeight, \"Max submissions limit exceeded\");\n\n            BlockProperties storage bh = session.blockProperties[blockHash];\n            bytes32[] storage specimenHashes = bh.specimenHashes;\n\n            uint128 validatorID = validatorIDs[msg.sender];\n            require(_validatorEnabled[validatorID], \"Validator is not enabled\");\n\n            // check if it was submitted for the same block hash\n            // this should be at most 10 iterations\n            for (uint256 j = 0; j < specimenHashes.length; j++) {\n                address[] storage specimenHashParticipants = bh.participants[specimenHashes[j]];\n                for (uint256 k = 0; k < specimenHashParticipants.length; k++)\n                    require(specimenHashParticipants[k] != msg.sender, \"Operator already submitted for the provided block hash\");\n            }\n\n            address[] storage participants = bh.participants[specimenHash];\n            if (specimenHashes.length != 0) {\n                if (participants.length == 0) specimenHashes.push(specimenHash);\n            } else {\n                session.blockHashesRaw.push(blockHash);\n                specimenHashes.push(specimenHash);\n            }\n\n            participants.push(msg.sender);\n            participantsData.submissionCounter++;\n        }\n        _urls[specimenHash].push(storageURL);\n\n        emit BlockSpecimenProductionProofSubmitted(chainId, blockHeight, blockHash, specimenHash, storageURL);\n    }\n\n    /**\n     * This is the new finalize function that works with staking contract in ethereum\n     */\n    function finalizeSpecimenSession(uint64 chainId, uint64 blockHeight) public {\n        BlockSpecimenSession storage session = _sessions[chainId][blockHeight];\n        uint64 sessionDeadline = session.sessionDeadline;\n        require(block.number > sessionDeadline, \"Session not past deadline\");\n        require(!session.requiresAudit, \"Session cannot be finalized\");\n        require(sessionDeadline != 0, \"Session not started\");\n\n        uint256 contributorsN;\n        bytes32 specimenHash;\n\n        uint256 max;\n        bytes32 agreedBlockHash;\n        bytes32 agreedSpecimenHash;\n\n        bytes32[] storage blockHashesRaw = session.blockHashesRaw;\n        bytes32 rawBlockHash;\n        uint256 blockSpecimenHashesLength = blockHashesRaw.length;\n\n        // find the block hash and specimen hashes that the quorum agrees on by finding the specimen hash with the highest number of participants\n        for (uint256 i = 0; i < blockSpecimenHashesLength; i++) {\n            rawBlockHash = blockHashesRaw[i];\n            BlockProperties storage bh = session.blockProperties[rawBlockHash];\n            for (uint256 j = 0; j < bh.specimenHashes.length; j++) {\n                specimenHash = bh.specimenHashes[j];\n                uint256 len = bh.participants[specimenHash].length;\n                contributorsN += len;\n                if (len > max) {\n                    max = len;\n                    agreedBlockHash = rawBlockHash;\n                    agreedSpecimenHash = specimenHash;\n                }\n            }\n        }\n        // check if the number of submissions is sufficient and if the quorum is achieved\n        if (_minSubmissionsRequired <= max && (max * _DIVIDER) / contributorsN > _blockSpecimenQuorum) {\n            // TODO: doesn't free session space. Though it should.\n            _finalizeWithParticipants(session, chainId, blockHeight, agreedBlockHash, agreedSpecimenHash);\n        } else emit QuorumNotReached(chainId, blockHeight);\n\n        session.requiresAudit = true;\n        // set session deadline to 0 to release gas\n        session.sessionDeadline = 0;\n    }\n\n    function _finalizeWithParticipants(BlockSpecimenSession storage session, uint64 chainId, uint64 blockHeight, bytes32 agreedBlockHash, bytes32 agreedSpecimenHash) internal {\n        address participant;\n        address[] storage participants = session.blockProperties[agreedBlockHash].participants[agreedSpecimenHash];\n        uint256 len = participants.length;\n        uint256 validatorBitMap; // sets the ith bit to 1 if the ith validator submits the agreed specimen hash\n\n        mapping(address => SessionParticipantData) storage participantsData = session.participantsData;\n\n        for (uint256 i = 0; i < len; i++) {\n            participant = participants[i];\n            SessionParticipantData storage pd = participantsData[participant];\n            validatorBitMap |= (1 << (255 - validatorIDs[participant]));\n            // release gas if possible\n            if (pd.submissionCounter == 1) {\n                pd.submissionCounter = 0;\n                pd.stake = 0;\n            }\n        }\n\n        emit BlockSpecimenQuorum(chainId, blockHeight, validatorBitMap, agreedBlockHash, agreedSpecimenHash);\n\n        delete session.blockProperties[agreedBlockHash]; // release gas\n    }\n\n    /**\n     * Returns contract meta data\n     */\n    function getMetadata()\n        public\n        view\n        returns (\n            address stakingManager,\n            uint128 blockSpecimenRewardAllocation,\n            uint64 blockSpecimenSessionDuration,\n            uint64 minSubmissionsRequired,\n            uint256 blockSpecimenQuorum,\n            uint256 secondsPerBlock\n        )\n    {\n        return (address(_stakingManager), _blockSpecimenRewardAllocation, _blockSpecimenSessionDuration, _minSubmissionsRequired, _blockSpecimenQuorum, _secondsPerBlock);\n    }\n\n    /**\n     * Returns data used for chain sync\n     */\n    function getChainData(\n        uint64 chainId\n    )\n        external\n        view\n        returns (uint256 blockOnTargetChain, uint256 blockOnCurrentChain, uint256 secondsPerBlock, uint128 allowedThreshold, uint128 maxSubmissionsPerBlockHeight, uint64 nthBlock)\n    {\n        ChainData memory cd = _chainData[chainId];\n        return (cd.blockOnTargetChain, cd.blockOnCurrentChain, cd.secondsPerBlock, cd.allowedThreshold, cd.maxSubmissionsPerBlockHeight, cd.nthBlock);\n    }\n\n    /**\n     * Returns all bsp operator addresses (disabled and enabled) of a given validator\n     */\n    function getOperators(uint128 validatorId) external view returns (address[] memory) {\n        return _validatorOperators[validatorId].values();\n    }\n\n    /**\n     * Returns all enabled operators by role type\n     */\n    function getAllOperators() external view returns (address[] memory _bsps, address[] memory __governors, address[] memory __auditors) {\n        return (_blockSpecimenProducers.values(), _governors.values(), _auditors.values());\n    }\n\n    /**\n     * returns enabled operator count for a validator\n     */\n    function getEnabledOperatorCount(uint128 validatorId) external view returns (uint128) {\n        return _validatorActiveOperatorsCounters[validatorId];\n    }\n\n    /**\n     * Returns required stake and enabled block specimen producer operators\n     */\n    function getBSPRoleData() external view returns (uint128 requiredStake, address[] memory activeMembers) {\n        return (_bspRequiredStake, _blockSpecimenProducers.values());\n    }\n\n    /**\n     * Returns true if the given operator is enabled.\n     * Returns false if the operator is disabled or does not exist\n     */\n    function isEnabled(address operator) external view returns (bool) {\n        return _blockSpecimenProducers.contains(operator);\n    }\n\n    /**\n     * Returns true if the given validator is enabled.\n     * Returns false if the validator is disabled or does not exist\n     */\n    function isValidatorEnabled(uint128 validatorId) external view returns (bool) {\n        return _validatorEnabled[validatorId];\n    }\n\n    /**\n     * Returns IPFS urls where specimens reside\n     */\n    function getURLS(bytes32 specimenhash) external view returns (string[] memory) {\n        return _urls[specimenhash];\n    }\n\n    /**\n     * This function is called to check whether the sesion is open for the given chain id and block height\n     */\n    function isSessionOpen(uint64 chainId, uint64 blockHeight, address operator) public view returns (bool) {\n        BlockSpecimenSession storage session = _sessions[chainId][blockHeight];\n        uint64 sessionDeadline = session.sessionDeadline;\n        SessionParticipantData storage participantsData = session.participantsData[operator];\n        bool submissionLimitExceeded = participantsData.submissionCounter == _chainData[chainId].maxSubmissionsPerBlockHeight;\n        return (!submissionLimitExceeded && block.number <= sessionDeadline) || (sessionDeadline == 0 && !session.requiresAudit);\n    }\n}"
    },
    {
      "filename": "cqt-staking/contracts/BlockSpecimenProofChain.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"./IOperationalStaking.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract BlockSpecimenProofChain is OwnableUpgradeable {\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.Bytes32Set;\n\n    IOperationalStaking _stakingInterface; // staking contract (deprecated)\n\n    bytes32 public constant GOVERNANCE_ROLE = keccak256(\"GOVERNANCE_ROLE\");\n    bytes32 public constant BLOCK_SPECIMEN_PRODUCER_ROLE = keccak256(\"BLOCK_SPECIMEN_PRODUCER_ROLE\");\n    bytes32 public constant AUDITOR_ROLE = keccak256(\"AUDITOR_ROLE\");\n    uint256 private constant _DIVIDER = 10 ** 18; // 18 decimals used for scaling\n\n    uint256 private _blockSpecimenQuorum; // The value is represented as a uint <= 10**18. The threshold value will later be divided by 10**18 to represent it as a percentage.  e.g.) 10**18 == 100%; 5 * 10**17 == 50%;\n    uint256 private _secondsPerBlock; // average block time on the chain where the ProofChain is deployed\n    uint128 private _blockSpecimenRewardAllocation; // the reward allocated per block hash\n    uint128 private _bspRequiredStake; // how much a validator should have staked in order to run an operator\n    uint64 private _blockSpecimenSessionDuration; // the length of a session in blocks\n    uint64 private _minSubmissionsRequired; // min number of participants who submitted the agreed specimen hash in order for the quorum to be achieved\n\n    EnumerableSetUpgradeable.Bytes32Set private _roleNames; // set of all role names\n\n    EnumerableSetUpgradeable.AddressSet private _blockSpecimenProducers; // currently enabled block specimen producer operators\n    EnumerableSetUpgradeable.AddressSet private _governors; // governor operators\n    EnumerableSetUpgradeable.AddressSet private _auditors; // auditor operators\n\n    mapping(address => uint128) public validatorIDs; // maps an operator address to validatorId\n    mapping(uint128 => EnumerableSetUpgradeable.AddressSet) private _validatorOperators; // operator addresses that validator owns\n    mapping(address => bytes32) public operatorRoles; // operator address => role\n    mapping(uint128 => uint128) private _validatorActiveOperatorsCounters; // how many operators are enabled per validator given validator id\n    mapping(uint64 => mapping(uint64 => BlockSpecimenSession)) private _sessions; // chainId => blockHeight\n    mapping(uint64 => ChainData) private _chainData; // by chain id\n\n    mapping(bytes32 => string[]) private _urls; // hash => urls\n    mapping(uint128 => address) private _validatorAddresses; // validatorId => validator address (deprecated)\n    mapping(uint128 => bool) private _validatorEnabled; // validatorId => enabled?\n    address private _stakingManager;\n\n    struct ChainData {\n        uint256 blockOnTargetChain; // block number on the chain for which BSP are produced which is mapped to the current chain block\n        uint256 blockOnCurrentChain; // block number on the chain where the ProofChain is deployed. it is mapped to the target chain block\n        uint256 secondsPerBlock; // average block time on the chain for which BSP is generated\n        uint128 allowedThreshold; // block offsett threshold, used to handle minor de-synchronization over time\n        uint128 maxSubmissionsPerBlockHeight; // max number of block hashes allowed to submit per block height\n        uint64 nthBlock; // block divisor\n    }\n\n    struct BlockProperties {\n        mapping(bytes32 => address[]) participants; // specimen hash => operators who submitted the specimen hash\n        bytes32[] specimenHashes; // raw specimen hashes\n    }\n\n    struct SessionParticipantData {\n        uint128 stake; // stake at the time when an operator submitted the first specimen hash (deprecate now (always 0))\n        uint128 submissionCounter; // how many specimen hashes an operator has submitted\n    }\n\n    struct BlockSpecimenSession {\n        mapping(bytes32 => BlockProperties) blockProperties; // block hash => block properties\n        bytes32[] blockHashesRaw;\n        mapping(address => SessionParticipantData) participantsData; // stake and submission counter, pack these together to save gas\n        uint64 sessionDeadline; // the last block when an operator can submit a specimen hash\n        bool requiresAudit; // auditor can arbitrate the session only if this is set to true\n    }\n\n    event OperatorAdded(address operator, uint128 validatorId, bytes32 role);\n\n    event OperatorRemoved(address operator, uint128 validatorId, uint128 activeOperatorCount, bytes32 role);\n\n    event ValidatorEnabled(uint128 validatorId);\n\n    event ValidatorDisabled(uint128 validatorId);\n\n    event BlockSpecimenProductionProofSubmitted(\n        uint64 chainId,\n        uint64 blockHeight,\n        bytes32 blockHash,\n        bytes32 specimenHash, // SHA-256 content-hash of specimen object file;\n        string storageURL // URL of specimen storage\n    );\n\n    event SessionStarted(uint64 indexed chainId, uint64 indexed blockHeight, uint64 deadline);\n\n    event QuorumNotReached(uint64 indexed chainId, uint64 blockHeight);\n\n    event BlockSpecimenRewardChanged(uint128 newBlockSpecimenRewardAllocation);\n\n    event MinimumRequiredStakeChanged(uint128 newStakeRequirement);\n\n    event StakingManagerChanged(address newStakingManager);\n\n    event SpecimenSessionQuorumChanged(uint256 newQuorumThreshold);\n\n    event SpecimenSessionDurationChanged(uint64 newSessionDuration);\n\n    event SpecimenSessionMinSubmissionChanged(uint64 minSubmissions);\n\n    event NthBlockChanged(uint64 indexed chainId, uint64 indexed nthBlock);\n\n    event MaxSubmissionsPerBlockHeightChanged(uint256 maxSubmissions);\n\n    event ChainSyncDataChanged(uint64 indexed chainId, uint256 blockOnTargetChain, uint256 blockOnCurrentChain, uint256 secondsPerBlock);\n\n    event SecondsPerBlockChanged(uint64 indexed secondsPerBlock);\n\n    event BlockHeightSubmissionThresholdChanged(uint64 indexed chainId, uint64 threshold);\n\n    event BlockSpecimenQuorum(uint64 indexed chainId, uint64 indexed blockHeight, uint256 validatorBitMap, bytes32 indexed blockHash, bytes32 specimenHash);\n\n    modifier onlyGovernor() {\n        require(_governors.contains(msg.sender), \"Sender is not GOVERNANCE_ROLE\");\n        _;\n    }\n\n    modifier onlyStakingManager() {\n        require(msg.sender == _stakingManager, \"Sender is not staking manager\");\n        _;\n    }\n\n    function initialize(address initialOwner, address stakingManager) public initializer {\n        __Ownable_init();\n\n        _governors.add(msg.sender);\n\n        _roleNames.add(GOVERNANCE_ROLE);\n        _roleNames.add(BLOCK_SPECIMEN_PRODUCER_ROLE);\n        _roleNames.add(AUDITOR_ROLE);\n\n        setQuorumThreshold(_DIVIDER / 2); // 50%\n        setBlockSpecimenReward(10 ** 14); // 0.0001\n        setBlockSpecimenSessionDuration(240); // blocks\n        setMinSubmissionsRequired(2);\n        setStakingManagerAddress(stakingManager);\n        _governors.remove(msg.sender);\n\n        operatorRoles[initialOwner] = GOVERNANCE_ROLE;\n        _governors.add(initialOwner);\n        emit OperatorAdded(initialOwner, 0, GOVERNANCE_ROLE);\n    }\n\n    function disableValidator(uint128 validatorId) external onlyStakingManager {\n        // when remove/disable bsp is called, it emits an event, which might then cause bridge agent to\n        // disable this.\n        _validatorEnabled[validatorId] = false;\n        emit ValidatorDisabled"
    }
  ]
}