{
  "Title": "[H-02] ERC777 and similar token implementations allow a stealing of funds when transferring tokens",
  "Content": "\nA malicious actor can trick a `TokenManager` into thinking that a bigger amount of tokens were transferred. On the destination chain, the malicious actor will be able to receive more tokens than they sent on the source chain.\n\n### Proof of Concept\n\n[TokenManagerLockUnlock](https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/its/token-manager/implementations/TokenManagerLockUnlock.sol#L16) and [TokenManagerLiquidityPool](https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/its/token-manager/implementations/TokenManagerLiquidityPool.sol#L17) are `TokenManager` implementations that transfer tokens from/to users when sending tokens cross-chain. The low-level `_takeToken` function ([TokenManagerLiquidityPool.\\_takeToken](https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/its/token-manager/implementations/TokenManagerLiquidityPool.sol#L77), [TokenManagerLockUnlock.\\_takeToken](https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/its/token-manager/implementations/TokenManagerLockUnlock.sol#L44)) is used to take tokens from a user on the source chain before emitting a cross-chain message, e.g. via the [TokenManager.sendToken](https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/its/token-manager/TokenManager.sol#L83) function. The function computes the difference in the balance of the liquidity pool or the token manager before and after the transfer, to track the actual amount of tokens transferred. The amount is then [passed in the cross-chain message](https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/its/token-manager/TokenManager.sol#L90-L99) to tell the `InterchainTokenService` contract on the destination chain [how many tokens to give to the recipient](https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/its/interchain-token-service/InterchainTokenService.sol#L610).\n\nThe `_takeToken` function, however, is not protected from reentrance, which opens up the following attack scenario:\n\n1. A malicious contract initiates transferring of 100 ERC777 tokens by calling [TokenManager.sendToken](https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/its/token-manager/TokenManager.sol#L83).\n\n2. The `_takeToken` function calls `transferFrom` on the ERC777 token contract, which calls the [tokensToSend](https://eips.ethereum.org/EIPS/eip-777#erc777tokenssender-and-the-tokenstosend-hook) hook on the malicious contract (the sender).\n\n3. In the hook, the malicious contract makes another call to `TokenManager.sendToken` and sends 100 more tokens.\n\n4. In the nested `_takeToken` call, the balance change will equal 100 since, in ERC777, the balance state is updated only after the `tokensToSend` hook, so only the re-entered token transfer will be counted.\n\n5. The re-entered call to `TokenManager.sendToken` will result in 100 tokens transferred cross-chain.\n\n6. In the first `_takeToken` call, the balance change will equal 200 because the balance of the receiver will increase twice during the `transferFrom` call; once for the first call and once for the re-entered call.\n\n7. As a result, the malicious contract will transfer 100+100 = 200 tokens, but the `TokenManager` contract will emit two cross-chain messages; one will transfer 100 tokens (the re-entered call) and the other will transfer 200 tokens (the first call). This will let the malicious actor to receive 300 tokens on the destination chain, while spending only 200 tokens on the source chain.\n\nSince the protocol is expected to support different implementations of ERC20 tokens, including custom ones, the attack scenario is valid for any token implementation that uses hooks during transfers.\n\n### Recommended Mitigation Steps\n\nConsider adding re-entrancy protection to the `TokenManagerLiquidityPool._takeToken` and `TokenManagerLockUnlock._takeToken` functions, for example by using the [ReentrancyGuard](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master) from OpenZeppelin.\n\n### Assessed type\n\nReentrancy\n\n**[deanamiel (Axelar) confirmed and commented](https://github.com/code-423n4/2023-07-axelar-findings/issues/317#issuecomment-1693739752):**\n> We have added a separate token manager for fee on transfer tokens, which is protected from reentrancy.\n>\n> Link to the public PR: https://github.com/axelarnetwork/interchain-token-service/pull/96.\n\n***\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-07-axelar",
  "Code": [
    {
      "filename": "contracts/its/token-manager/implementations/TokenManagerLockUnlock.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { TokenManagerAddressStorage } from './TokenManagerAddressStorage.sol';\nimport { IERC20 } from '../../../gmp-sdk/interfaces/IERC20.sol';\n\nimport { SafeTokenTransferFrom, SafeTokenTransfer } from '../../../gmp-sdk/util/SafeTransfer.sol';\n\n/**\n * @title TokenManagerLockUnlock\n * @notice This contract is an implementation of TokenManager that locks and unlocks a specific token on behalf of the interchain token service.\n * @dev This contract extends TokenManagerAddressStorage and provides implementation for its abstract methods.\n * It uses the Axelar SDK to safely transfer tokens.\n */\ncontract TokenManagerLockUnlock is TokenManagerAddressStorage {\n    /**\n     * @dev Constructs an instance of TokenManagerLockUnlock. Calls the constructor\n     * of TokenManagerAddressStorage which calls the constructor of TokenManager.\n     * @param interchainTokenService_ The address of the interchain token service contract\n     */\n    constructor(address interchainTokenService_) TokenManagerAddressStorage(interchainTokenService_) {}\n\n    function implementationType() external pure returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev Sets up the token address.\n     * @param params The setup parameters in bytes. Should be encoded with the token address.\n     */\n    function _setup(bytes calldata params) internal override {\n        // The first argument is reserved for the operator.\n        (, address tokenAddress) = abi.decode(params, (bytes, address));\n        _setTokenAddress(tokenAddress);\n    }\n\n    /**\n     * @dev Transfers a specified amount of tokens from a specified address to this contract.\n     * @param from The address to transfer tokens from\n     * @param amount The amount of tokens to transfer\n     * @return uint The actual amount of tokens transferred. This allows support for fee-on-transfer tokens.\n     */\n    function _takeToken(address from, uint256 amount) internal override returns (uint256) {\n        IERC20 token = IERC20(tokenAddress());\n        uint256 balance = token.balanceOf(address(this));\n\n        SafeTokenTransferFrom.safeTransferFrom(token, from, address(this), amount);\n\n        // Note: This allows support for fee-on-transfer tokens\n        return IERC20(token).balanceOf(address(this)) - balance;\n    }\n\n    /**\n     * @dev Transfers a specified amount of tokens from this contract to a specified address.\n     * @param to The address to transfer tokens to\n     * @param amount The amount of tokens to transfer\n     * @return uint The actual amount of tokens transferred\n     */\n    function _giveToken(address to, uint256 amount) internal override returns (uint256) {\n        IERC20 token = IERC20(tokenAddress());\n        uint256 balance = IERC20(token).balanceOf(to);\n\n        SafeTokenTransfer.safeTransfer(token, to, amount);\n\n        return IERC20(token).balanceOf(to) - balance;\n    }\n}"
    },
    {
      "filename": "contracts/its/token-manager/TokenManager.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ITokenManager } from '../interfaces/ITokenManager.sol';\nimport { IInterchainTokenService } from '../interfaces/IInterchainTokenService.sol';\nimport { ITokenManagerProxy } from '../interfaces/ITokenManagerProxy.sol';\n\nimport { Operatable } from '../utils/Operatable.sol';\nimport { FlowLimit } from '../utils/FlowLimit.sol';\nimport { AddressBytesUtils } from '../libraries/AddressBytesUtils.sol';\nimport { Implementation } from '../utils/Implementation.sol';\n\n/**\n * @title The main functionality of TokenManagers.\n * @notice This contract is responsible for handling tokens before initiating a cross chain token transfer, or after receiving one.\n */\nabstract contract TokenManager is ITokenManager, Operatable, FlowLimit, Implementation {\n    using AddressBytesUtils for bytes;\n\n    IInterchainTokenService public immutable interchainTokenService;\n\n    /**\n     * @notice Constructs the TokenManager contract.\n     * @param interchainTokenService_ The address of the interchain token service\n     */\n    constructor(address interchainTokenService_) {\n        if (interchainTokenService_ == address(0)) revert TokenLinkerZeroAddress();\n        interchainTokenService = IInterchainTokenService(interchainTokenService_);\n    }\n\n    /**\n     * @dev A modifier that allows only the interchain token service to execute the function.\n     */\n    modifier onlyService() {\n        if (msg.sender != address(interchainTokenService)) revert NotService();\n        _;\n    }\n\n    /**\n     * @dev A modifier that allows only the token to execute the function.\n     */\n    modifier onlyToken() {\n        if (msg.sender != tokenAddress()) revert NotToken();\n        _;\n    }\n\n    /**\n     * @notice A function that should return the address of the token.\n     * Must be overridden in the inheriting contract.\n     * @return address address of the token.\n     */\n    function tokenAddress() public view virtual returns (address);\n\n    /**\n     * @dev This function should only be called by the proxy, and only once from the proxy constructor\n     * @param params the parameters to be used to initialize the TokenManager. The exact format depends\n     * on the type of TokenManager used but the first 32 bytes are reserved for the address of the operator,\n     * stored as bytes (to be compatible with non-EVM chains)\n     */\n    function setup(bytes calldata params) external override onlyProxy {\n        bytes memory operatorBytes = abi.decode(params, (bytes));\n        address operator_;\n        /**\n         * @dev Specifying an empty operator will default to the service being the operator. This makes it easy to deploy\n         * remote standardized tokens without knowing anything about the service address at the destination.\n         */\n        if (operatorBytes.length == 0) {\n            operator_ = address(interchainTokenService);\n        } else {\n            operator_ = operatorBytes.toAddress();\n        }\n        _setOperator(operator_);\n        _setup(params);\n    }\n\n    /**\n     * @notice Calls the service to initiate the a cross-chain transfer after taking the appropriate amount of tokens from the user.\n     * @param destinationChain the name of the chain to send tokens to.\n     * @param destinationAddress the address of the user to send tokens to.\n     * @param amount the amount of tokens to take from msg.sender.\n     */\n    function sendToken(\n        string calldata destinationChain,\n        bytes calldata destinationAddress,\n        uint256 amount,\n        bytes calldata metadata\n    ) external payable virtual {\n        address sender = msg.sender;\n        amount = _takeToken(sender, amount);\n        _addFlowOut(amount);\n        interchainTokenService.transmitSendToken{ value: msg.value }(\n            _getTokenId(),\n            sender,\n            destinationChain,\n            destinationAddress,\n            amount,\n            metadata\n        );\n    }\n\n    /**\n     * @notice Calls the service to initiate the a cross-chain transfer with data after taking the appropriate amount of tokens from the user.\n     * @param destinationChain the name of the chain to send tokens to.\n     * @param destinationAddress the address of the user to send tokens to.\n     * @param amount the amount of tokens to take from msg.sender.\n     * @param data the data to pass to the destination contract.\n     */\n    function callContractWithInterchainToken(\n        string calldata destinationChain,\n        bytes calldata destinationAddress,\n        uint256 amount,\n        bytes calldata data\n    ) external payable virtual {\n        address sender = msg.sender;\n        amount = _takeToken(sender, amount);\n        _addFlowOut(amount);\n        uint32 version = 0;\n        interchainTokenService.transmitSendToken{ value: msg.value }(\n            _getTokenId(),\n            sender,\n            destinationChain,\n            destinationAddress,\n            amount,\n            abi.encodePacked(version, data)\n        );\n    }\n\n    /**\n     * @notice Calls the service to initiate the a cross-chain transfer after taking the appropriate amount of tokens from the user. This can only be called by the token itself.\n     * @param sender the address of the user paying for the cross chain transfer.\n     * @param destinationChain the name of the chain to send tokens to.\n     * @param destinationAddress the address of the user to send tokens to.\n     * @param amount the amount of tokens to take from msg.sender.\n     */\n    function transmitInterchainTransfer(\n        address sender,\n        string calldata destinationChain,\n        bytes calldata destinationAddress,\n        uint256 amount,\n        bytes calldata metadata\n    ) external payable virtual onlyToken {\n        amount = _takeToken(sender, amount);\n        _addFlowOut(amount);\n        interchainTokenService.transmitSendToken{ value: msg.value }(\n            _getTokenId(),\n            sender,\n            destinationChain,\n            destinationAddress,\n            amount,\n            metadata\n        );\n    }\n\n    /**\n     * @notice This function gives token to a specified address. Can only be called by the service.\n     * @param destinationAddress the address to give tokens to.\n     * @param amount the amount of token to give.\n     * @return the amount of token actually given, which will onle be differen than `amount` in cases where the token takes some on-transfer fee.\n     */\n    function giveToken(address destinationAddress, uint256 amount) external onlyService returns (uint256) {\n        amount = _giveToken(destinationAddress, amount);\n        _addFlowIn(amount);\n        return amount;\n    }\n\n    /**\n     * @notice This function sets the flow limit for this TokenManager. Can only be called by the operator.\n     * @param flowLimit the maximum difference between the tokens flowing in and/or out at any given interval of time (6h)\n     */\n    function setFlowLimit(uint256 flowLimit) external onlyOperator {\n        _setFlowLimit(flowLimit);\n    }\n\n    /**\n     * @notice Transfers tokens from a specific address to this contract.\n     * Must be overridden in the inheriting contract.\n     * @param from The address from which the tokens will be sent\n     * @param amount The amount of tokens to receive\n     * @return uint amount of tokens received\n     */\n    function _takeToken(address from, uint256 amount) internal virtual returns (uint256);\n\n    /**\n     * @notice Transfers tokens from this contract to a specific address.\n     * Must be overridden in the inheriting contract.\n     * @param from The address to which the tokens will be sent\n     * @param amount The amount of tokens to send\n     * @return uint amount of tokens sent\n     */\n    function _giveToken(address from, uint256 amount) internal virtual returns (uint256);\n\n    /**\n     * @dev Additional setup logic to perform\n     * Must be overridden in the inheriting contract.\n     * @param params The setup parameters\n     */\n    function _setup(bytes calldata params) internal virtual;\n\n    /**\n     * @notice Gets the token ID from the token manager proxy.\n     * @return tokenId The ID of the token\n     */\n    function _getTokenId() internal view returns (bytes32 tokenId) {\n        tokenId = ITokenManagerProxy(address(this)).tokenId();\n    }\n}"
    }
  ]
}