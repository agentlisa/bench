{
  "Title": "[M-05] QTokens with the same symbol will lead to mistakes",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/QTokenStringUtils.sol#L115-L130\n\n\n# Vulnerability details\n\nThe `README.md` states:\n> Bob can then trade the QToken with Alice for a premium. The method for doing that is beyond the scope of the protocol but can be done via any smart contract trading platform e.g. 0x.\n\nhttps://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/README.md?plain=1#L70\n\nIt is therefore important that tokens be easily identifiable so that trading on DEXes is not error-prone.\n\n## Impact\nCurrently the `QToken` `name` includes the full year but the `QToken` symbol only contains the last two digits of the year, which can lead to mistakes. If someone mints a QToken with an expiry 100 years into the future, then the year will be truncated and appear as if the token expired this year. Normal centralized exchanges prevent this by listing options themselves and ensuring that there are never two options with the same identifier at the same time. The Rolla protocol does not have any such protections. Users must be told to not only check that the symbol name is what they expect, but to also separately check the token name or the specific expiry, or they might buy the wrong option on a DEX, or have fat-fingered during minting on a non-Rolla web interface. It's important to minimize the possibility of mistakes, and not including the full year in the symbol makes things error-prone, and will lead to other options providers winning out.\n\nThe 0x [REST interface](https://docs.0x.org/0x-api-swap/api-references/get-swap-v1-quote) for swaps has the ability to do a swap by token name rather than by token address. I was unable to figure out whether there was an allow-list of token names, or if it is easy to add a new token. If there is no, or an easily bypassed, access-control for adding new tokens, I would say this finding should be upgraded to high-severity, though I doubt this is the case.\n\n## Proof of Concept\n```solidity\n        /// concatenated symbol string\n        tokenSymbol = string(\n            abi.encodePacked(\n                \"ROLLA\",\n                \"-\",\n                underlying,\n                \"-\",\n                _uintToChars(day),\n                monthSymbol,\n                _uintToChars(year),\n                \"-\",\n                displayStrikePrice,\n                \"-\",\n                typeSymbol\n            )\n        );\n```\nhttps://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/QTokenStringUtils.sol#L115-L130\n\n```solidity\n    /// @return 2 characters that correspond to a number\n    function _uintToChars(uint256 _number)\n        internal\n        pure\n        virtual\n        returns (string memory)\n    {\n        if (_number > 99) {\n            _number %= 100;\n        }\n\n        string memory str = Strings.toString(_number);\n\n        if (_number < 10) {\n            return string(abi.encodePacked(\"0\", str));\n        }\n\n        return str;\n    }\n```\nhttps://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/QTokenStringUtils.sol#L181-L199\n\n## Tools Used\nCode inspection\n\n## Recommended Mitigation Steps\nInclude the full year in the token's symbol\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-03-rolla-contest",
  "Code": [
    {
      "filename": "quant-protocol/contracts/options/QTokenStringUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@quant-finance/solidity-datetime/contracts/DateTime.sol\";\nimport \"../interfaces/IAssetsRegistry.sol\";\nimport \"../interfaces/IQuantConfig.sol\";\nimport \"../libraries/ProtocolValue.sol\";\n\nabstract contract QTokenStringUtils {\n    /// @notice get the ERC20 token symbol from the AssetsRegistry\n    /// @dev the asset is assumed to be in the AssetsRegistry since QTokens\n    /// must be created through the OptionsFactory, which performs that check\n    /// @param _quantConfig address of the Quant system configuration contract\n    /// @param _asset address of the asset in the AssetsRegistry\n    /// @return assetSymbol string stored as the ERC20 token symbol\n    function _assetSymbol(address _quantConfig, address _asset)\n        internal\n        view\n        virtual\n        returns (string memory assetSymbol)\n    {\n        (, assetSymbol, ) = IAssetsRegistry(\n            IQuantConfig(_quantConfig).protocolAddresses(\n                ProtocolValue.encode(\"assetsRegistry\")\n            )\n        ).assetProperties(_asset);\n    }\n\n    /// @notice generates the name for an option\n    /// @param _quantConfig address of the Quant system configuration contract\n    /// @param _underlyingAsset asset that the option references\n    /// @param _strikePrice strike price with as many decimals in the strike asset\n    /// @param _expiryTime expiration timestamp as a unix timestamp\n    /// @param _isCall true if it's a call option, false if it's a put option\n    /// @return tokenName name string for the QToken\n    function _qTokenName(\n        address _quantConfig,\n        address _underlyingAsset,\n        address _strikeAsset,\n        uint256 _strikePrice,\n        uint256 _expiryTime,\n        bool _isCall\n    ) internal view virtual returns (string memory tokenName) {\n        string memory underlying = _assetSymbol(_quantConfig, _underlyingAsset);\n        string memory displayStrikePrice = _displayedStrikePrice(\n            _strikePrice,\n            _strikeAsset\n        );\n\n        // convert the expiry to a readable string\n        (uint256 year, uint256 month, uint256 day) = DateTime.timestampToDate(\n            _expiryTime\n        );\n\n        // get option type string\n        (, string memory typeFull) = _getOptionType(_isCall);\n\n        // get option month string\n        (, string memory monthFull) = _getMonth(month);\n\n        /// concatenated name string\n        tokenName = string(\n            abi.encodePacked(\n                \"ROLLA\",\n                \" \",\n                underlying,\n                \" \",\n                _uintToChars(day),\n                \"-\",\n                monthFull,\n                \"-\",\n                Strings.toString(year),\n                \" \",\n                displayStrikePrice,\n                \" \",\n                typeFull\n            )\n        );\n    }\n\n    /// @notice generates the symbol for an option\n    /// @param _underlyingAsset asset that the option references\n    /// @param _quantConfig address of the Quant system configuration contract\n    /// @param _strikePrice strike price with as many decimals in the strike asset\n    /// @param _expiryTime expiration timestamp as a unix timestamp\n    /// @param _isCall true if it's a call option, false if it's a put option\n    /// @return tokenSymbol symbol string for the QToken\n    function _qTokenSymbol(\n        address _quantConfig,\n        address _underlyingAsset,\n        address _strikeAsset,\n        uint256 _strikePrice,\n        uint256 _expiryTime,\n        bool _isCall\n    ) internal view virtual returns (string memory tokenSymbol) {\n        string memory underlying = _assetSymbol(_quantConfig, _underlyingAsset);\n        string memory displayStrikePrice = _displayedStrikePrice(\n            _strikePrice,\n            _strikeAsset\n        );\n\n        // convert the expiry to a readable string\n        (uint256 year, uint256 month, uint256 day) = DateTime.timestampToDate(\n            _expiryTime\n        );\n\n        // get option type string\n        (string memory typeSymbol, ) = _getOptionType(_isCall);\n\n        // get option month string\n        (string memory monthSymbol, ) = _getMonth(month);\n\n        /// concatenated symbol string\n        tokenSymbol = string(\n            abi.encodePacked(\n                \"ROLLA\",\n                \"-\",\n                underlying,\n                \"-\",\n                _uintToChars(day),\n                monthSymbol,\n                _uintToChars(year),\n                \"-\",\n                displayStrikePrice,\n                \"-\",\n                typeSymbol\n            )\n        );\n    }\n\n    /// @dev convert the option strike price scaled to a human readable value\n    /// @param _strikePrice the option strike price scaled by 1e20\n    /// @return strike price string\n    function _displayedStrikePrice(uint256 _strikePrice, address _strikeAsset)\n        internal\n        view\n        virtual\n        returns (string memory)\n    {\n        uint256 strikePriceDigits = ERC20(_strikeAsset).decimals();\n        uint256 strikePriceScale = 10**strikePriceDigits;\n        uint256 remainder = _strikePrice % strikePriceScale;\n        uint256 quotient = _strikePrice / strikePriceScale;\n        string memory quotientStr = Strings.toString(quotient);\n\n        if (remainder == 0) {\n            return quotientStr;\n        }\n\n        uint256 trailingZeroes;\n        while (remainder % 10 == 0) {\n            remainder /= 10;\n            trailingZeroes++;\n        }\n\n        // pad the number with \"1 + starting zeroes\"\n        remainder += 10**(strikePriceDigits - trailingZeroes);\n\n        string memory tmp = Strings.toString(remainder);\n        tmp = _slice(tmp, 1, (1 + strikePriceDigits) - trailingZeroes);\n\n        return string(abi.encodePacked(quotientStr, \".\", tmp));\n    }\n\n    /// @dev get the string representation of the option type\n    /// @return a 1 character representation of the option type\n    /// @return a full length string of the option type\n    function _getOptionType(bool _isCall)\n        internal\n        pure\n        virtual\n        returns (string memory, string memory)\n    {\n        return _isCall ? (\"C\", \"Call\") : (\"P\", \"Put\");\n    }\n\n    /// @dev get the representation of a number using 2 characters, adding a leading 0 if it's one digit,\n    /// and two trailing digits if it's a 3 digit number\n    /// @return 2 characters that correspond to a number\n    function _uintToChars(uint256 _number)\n        internal\n        pure\n        virtual\n        returns (string memory)\n    {\n        if (_number > 99) {\n            _number %= 100;\n        }\n\n        string memory str = Strings.toString(_number);\n\n        if (_number < 10) {\n            return string(abi.encodePacked(\"0\", str));\n        }\n\n        return str;\n    }\n\n    /// @dev cut a string into string[start:end]\n    /// @param _s string to cut\n    /// @param _start the starting index\n    /// @param _end the ending index (not inclusive)\n    /// @return the indexed string\n    function _slice(\n        string memory _s,\n        uint256 _start,\n        uint256 _end\n    ) internal pure virtual returns (string memory) {\n        uint256 range = _end - _start;\n        bytes memory slice = new bytes(range);\n        for (uint256 i = 0; i < range; ) {\n            slice[i] = bytes(_s)[_start + 1];\n            unchecked {\n                ++i;\n            }\n        }\n\n        return string(slice);\n    }\n\n    /// @dev get the string representations of a month\n    /// @return a 3 character representation\n    /// @return a full length string representation\n    function _getMonth(uint256 _month)\n        internal\n        pure\n        virtual\n        returns (string memory, string memory)\n    {\n        if (_month == 1) {\n            return (\"JAN\", \"January\");\n        } else if (_month == 2) {\n            return (\"FEB\", \"February\");\n        } else if (_month == 3) {\n            return (\"MAR\", \"March\");\n        } else if (_month == 4) {\n            return (\"APR\", \"April\");\n        } else if (_month == 5) {\n            return (\"MAY\", \"May\");\n        } else if (_month == 6) {\n            return (\"JUN\", \"June\");\n        } else if (_month == 7) {\n            return (\"JUL\", \"July\");\n        } else if (_month == 8) {\n            return (\"AUG\", \"August\");\n        } else if (_month == 9) {\n            return (\"SEP\", \"September\");\n        } else if (_month == 10) {\n            return (\"OCT\", \"October\");\n        } else if (_month == 11) {\n            return (\"NOV\", \"November\");\n        } else {\n            return (\"DEC\", \"December\");\n        }\n    }\n}"
    }
  ]
}