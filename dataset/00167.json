{
  "Title": "Using bytes number instead of slots number in the next slot calculation",
  "Content": "# Using bytes number instead of slots number in the next slot calculation\n\n### Severity\nLow Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-04-Beanstalk-DIB/blob/038609d8adf1bf941f8abd12820bc92ecd998375/src/pumps/MultiFlowPump.sol#L512\">https://github.com/Cyfrin/2024-04-Beanstalk-DIB/blob/038609d8adf1bf941f8abd12820bc92ecd998375/src/pumps/MultiFlowPump.sol#L512</a>\n\n\n## Summary\nThe `MultiFlowPump._getSlotsOffset` function correctly calculates \"the starting byte of the slot that contains the `n`th element of an array\". But this is not the correct value for the use cases where the function is invoked. So storage values are stored in unexpected slots.  \n\n## Vulnerability Details\nThe `MultiFlowPump._getSlotsOffset` function is invoked to calculate a slot number after `reserves`.\n```solidity\n    function update(uint256[] calldata reserves, bytes calldata data) external {\n<...>\n        pumpState.lastReserves = _capReserves(msg.sender, pumpState.lastReserves, reserves, capExponent, crp);\n\n\n        // Read: Cumulative & EMA Reserves\n>>      // Start at the slot after `pumpState.lastReserves`\n>>      uint256 numSlots = _getSlotsOffset(numberOfReserves);\n        assembly {\n            slot := add(slot, numSlots)\n        }\n        pumpState.emaReserves = slot.readBytes16(numberOfReserves);\n        assembly {\n            slot := add(slot, numSlots)\n        }\n```\nBut the `_getSlotsOffset` returns an offset in the bytes number instead of the slots number which is necessary for the store. So the actual offset is 32 times more than the expected one:\n```solidity\n    /**\n     * @dev Get the starting byte of the slot that contains the `n`th element of an array.\n     */\n    function _getSlotsOffset(uint256 numberOfReserves) internal pure returns (uint256 _slotsOffset) {\n        _slotsOffset = ((numberOfReserves - 1) / 2 + 1) << 5;\n    }\n```\n\n## Impact\nUnintended behavior\n\n## Tools used\nManual Review\n\n## Recommendations\nConsider using slots number instead of bytes\n```diff\n    /**\n-    * @dev Get the starting byte of the slot that contains the `n`th element of an array.\n+    * @dev Get the slot number that contains the `n`th element of an array.\n     */\n    function _getSlotsOffset(uint256 numberOfReserves) internal pure returns (uint256 _slotsOffset) {\n-       _slotsOffset = ((numberOfReserves - 1) / 2 + 1) << 5;\n+       _slotsOffset = ((numberOfReserves - 1) / 2 + 1);\n    }\n```",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clv1eptuo0003bcnzce1ap7om",
  "Code": [
    {
      "filename": "src/pumps/MultiFlowPump.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {IPump} from \"src/interfaces/pumps/IPump.sol\";\nimport {IMultiFlowPumpErrors} from \"src/interfaces/pumps/IMultiFlowPumpErrors.sol\";\nimport {IWell, Call} from \"src/interfaces/IWell.sol\";\nimport {IInstantaneousPump} from \"src/interfaces/pumps/IInstantaneousPump.sol\";\nimport {IMultiFlowPumpWellFunction} from \"src/interfaces/IMultiFlowPumpWellFunction.sol\";\nimport {ICumulativePump} from \"src/interfaces/pumps/ICumulativePump.sol\";\nimport {ABDKMathQuad} from \"src/libraries/ABDKMathQuad.sol\";\nimport {LibBytes16} from \"src/libraries/LibBytes16.sol\";\nimport {LibLastReserveBytes} from \"src/libraries/LibLastReserveBytes.sol\";\nimport {Math} from \"oz/utils/math/Math.sol\";\nimport {SafeCast} from \"oz/utils/math/SafeCast.sol\";\nimport {LibMath} from \"src/libraries/LibMath.sol\";\n\n/**\n * @title MultiFlowPump\n * @author Publius\n * @notice Stores a geometric EMA and cumulative geometric SMA for each reserve.\n * @dev A Pump designed for use in Beanstalk with 2 tokens.\n *\n * This Pump has 3 main features:\n *  1. Multi-block MEV resistence reserves\n *  2. MEV-resistant Geometric EMA intended for instantaneous reserve queries\n *  3. MEV-resistant Cumulative Geometric intended for SMA reserve queries\n *\n * Note: If an `update` call is made with a reserve of 0, the Geometric mean oracles will be set to 0.\n * Each Well is responsible for ensuring that an `update` call cannot be made with a reserve of 0.\n */\n\ncontract MultiFlowPump is IPump, IMultiFlowPumpErrors, IInstantaneousPump, ICumulativePump {\n    using LibLastReserveBytes for bytes32;\n    using LibBytes16 for bytes32;\n    using ABDKMathQuad for bytes16;\n    using ABDKMathQuad for uint256;\n    using SafeCast for int256;\n    using Math for uint256;\n    using LibMath for uint256;\n\n    uint256 constant CAP_PRECISION = 1e18;\n    uint256 constant CAP_PRECISION2 = 2 ** 128;\n    bytes16 constant MAX_CONVERT_TO_128x128 = 0x407dffffffffffffffffffffffffffff;\n    uint256 constant MAX_UINT256_SQRT = 340_282_366_920_938_463_463_374_607_431_768_211_455;\n\n    struct PumpState {\n        uint40 lastTimestamp;\n        uint256[] lastReserves;\n        bytes16[] emaReserves;\n        bytes16[] cumulativeReserves;\n    }\n\n    struct CapReservesParameters {\n        bytes16[][] maxRateChanges;\n        bytes16 maxLpSupplyIncrease;\n        bytes16 maxLpSupplyDecrease;\n    }\n\n    struct CapRatesVariables {\n        uint256 r;\n        uint256 rLast;\n        uint256 rLimit;\n        uint256[] ratios;\n    }\n\n    //////////////////// PUMP ////////////////////\n\n    /**\n     * @dev Update the Pump's manipulation resistant reserve balances for a given `well` with `reserves`.\n     */\n    function update(uint256[] calldata reserves, bytes calldata data) external {\n        (bytes16 alpha, uint256 capInterval, CapReservesParameters memory crp) =\n            abi.decode(data, (bytes16, uint256, CapReservesParameters));\n        uint256 numberOfReserves = reserves.length;\n        PumpState memory pumpState;\n\n        // All reserves are stored starting at the msg.sender address slot in storage.\n        bytes32 slot = _getSlotForAddress(msg.sender);\n\n        // Read: Last Timestamp & Last Reserves\n        (, pumpState.lastTimestamp, pumpState.lastReserves) = slot.readLastReserves();\n\n        // If the last timestamp is 0, then the pump has never been used before.\n        if (pumpState.lastTimestamp == 0) {\n            _init(slot, uint40(block.timestamp), reserves);\n            return;\n        }\n\n        bytes16 alphaN;\n        bytes16 deltaTimestampBytes;\n        uint256 capExponent;\n        // Isolate in brackets to prevent stack too deep errors\n        {\n            uint256 deltaTimestamp = _getDeltaTimestamp(pumpState.lastTimestamp);\n            // If no time has passed, don't update the pump reserves.\n            if (deltaTimestamp == 0) return;\n            alphaN = alpha.powu(deltaTimestamp);\n            deltaTimestampBytes = deltaTimestamp.fromUInt();\n            // Round up in case capInterval > block time to guarantee capExponent > 0 if time has passed since the last update.\n            capExponent = calcCapExponent(deltaTimestamp, capInterval);\n        }\n\n        pumpState.lastReserves = _capReserves(msg.sender, pumpState.lastReserves, reserves, capExponent, crp);\n\n        // Read: Cumulative & EMA Reserves\n        // Start at the slot after `pumpState.lastReserves`\n        uint256 numSlots = _getSlotsOffset(numberOfReserves);\n        assembly {\n            slot := add(slot, numSlots)\n        }\n        pumpState.emaReserves = slot.readBytes16(numberOfReserves);\n        assembly {\n            slot := add(slot, numSlots)\n        }\n        pumpState.cumulativeReserves = slot.readBytes16(numberOfReserves);\n\n        bytes16 lastReserve;\n        for (uint256 i; i < numberOfReserves; ++i) {\n            lastReserve = pumpState.lastReserves[i].fromUIntToLog2();\n            pumpState.emaReserves[i] =\n                lastReserve.mul((ABDKMathQuad.ONE.sub(alphaN))).add(pumpState.emaReserves[i].mul(alphaN));\n            pumpState.cumulativeReserves[i] = pumpState.cumulativeReserves[i].add(lastReserve.mul(deltaTimestampBytes));\n        }\n\n        // Write: Cumulative & EMA Reserves\n        // Order matters: work backwards to avoid using a new memory var to count up\n        slot.storeBytes16(pumpState.cumulativeReserves);\n        assembly {\n            slot := sub(slot, numSlots)\n        }\n        slot.storeBytes16(pumpState.emaReserves);\n        assembly {\n            slot := sub(slot, numSlots)\n        }\n\n        // Write: Last Timestamp & Last Reserves\n        slot.storeLastReserves(uint40(block.timestamp), pumpState.lastReserves);\n    }\n\n    /**\n     * @dev On first update for a particular Well, initialize oracle with\n     * reserves data.\n     */\n    function _init(bytes32 slot, uint40 lastTimestamp, uint256[] memory reserves) internal {\n        uint256 numberOfReserves = reserves.length;\n        bytes16[] memory byteReserves = new bytes16[](numberOfReserves);\n\n        // Skip {_capReserve} since we have no prior reference\n\n        for (uint256 i; i < numberOfReserves; ++i) {\n            uint256 _reserve = reserves[i];\n            if (_reserve == 0) return;\n            byteReserves[i] = _reserve.fromUIntToLog2();\n        }\n\n        // Write: Last Timestamp & Last Reserves\n        slot.storeLastReserves(lastTimestamp, reserves);\n\n        // Write: EMA Reserves\n        // Start at the slot after `byteReserves`\n        uint256 numSlots = _getSlotsOffset(numberOfReserves);\n        assembly {\n            slot := add(slot, numSlots)\n        }\n        slot.storeBytes16(byteReserves); // EMA Reserves\n    }\n\n    //////////////////// LAST RESERVES ////////////////////\n\n    /**\n     * @dev Reads the last capped reserves from the Pump from storage.\n     */\n    function readLastCappedReserves(\n        address well,\n        bytes memory\n    ) public view returns (uint256[] memory lastCappedReserves) {\n        uint8 numberOfReserves;\n        (numberOfReserves,, lastCappedReserves) = _getSlotForAddress(well).readLastReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n    }\n\n    /**\n     * @dev Reads the capped reserves from the Pump updated to the current block using the current reserves of `well`.\n     */\n    function readCappedReserves(\n        address well,\n        bytes calldata data\n    ) external view returns (uint256[] memory cappedReserves) {\n        (, uint256 capInterval, CapReservesParameters memory crp) =\n            abi.decode(data, (bytes16, uint256, CapReservesParameters));\n        bytes32 slot = _getSlotForAddress(well);\n        uint256[] memory currentReserves = IWell(well).getReserves();\n        uint8 numberOfReserves;\n        uint40 lastTimestamp;\n        (numberOfReserves, lastTimestamp, cappedReserves) = slot.readLastReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        uint256 deltaTimestamp = _getDeltaTimestamp(lastTimestamp);\n        if (deltaTimestamp == 0) {\n            return cappedReserves;\n        }\n\n        uint256 capExponent = calcCapExponent(deltaTimestamp, capInterval);\n        cappedReserves = _capReserves(well, cappedReserves, currentReserves, capExponent, crp);\n    }\n\n    /**\n     * @notice Cap `reserves` to have at most a maximum % increase/decrease in rate and a maximum % increase/decrease in total liquidity\n     * in relation to `lastReserves` based on the parameters defined in `crp` and the time passed since the last update, which is used\n     * to calculate `capExponent`.\n     * @param well The address of the Well\n     * @param lastReserves The last capped reserves.\n     * @param reserves The current reserves being capped.\n     * @param capExponent The exponent to raise the all % changes to.\n     * @param crp The parameters for capping reserves. See {CapReservesParameters}.\n     * @return cappedReserves The current reserves capped to the maximum % changes defined by `crp`.\n     */\n    function _capReserves(\n        address well,\n        uint256[] memory lastReserves,\n        uint256[] memory reserves,\n        uint256 capExponent,\n        CapReservesParameters memory crp\n    ) internal view returns (uint256[] memory cappedReserves) {\n        // Assume two token well\n        if (reserves.length != 2) {\n            revert TooManyTokens();\n        }\n\n        Call memory wf = IWell(well).wellFunction();\n        IMultiFlowPumpWellFunction mfpWf = IMultiFlowPumpWellFunction(wf.target);\n\n        // The order that the LP token supply and the rates are capped are dependent upon the values of the reserves to maximize precision.\n        cappedReserves = _capLpTokenSupply(lastReserves, reserves, capExponent, crp, mfpWf, wf.data, true);\n\n        // If `_capLpTokenSupply` returns an empty array, then the rates should be capped first.\n        if (cappedReserves.length == 0) {\n            cappedReserves = _capRates(lastReserves, reserves, capExponent, crp, mfpWf, wf.data);\n\n            cappedReserves = _capLpTokenSupply(lastReserves, cappedReserves, capExponent, crp, mfpWf, wf.data, false);\n        } else {\n            cappedReserves = _capRates(lastReserves, cappedReserves, capExponent, crp, mfpWf, wf.data);\n        }\n    }\n\n    /**\n     * @dev Cap the change in ratio of `reserves` to a maximum % change from `lastReserves`.\n     */\n    function _capRates(\n        uint256[] memory lastReserves,\n        uint256[] memory reserves,\n        uint256 capExponent,\n        CapReservesParameters memory crp,\n        IMultiFlowPumpWellFunction mfpWf,\n        bytes memory data\n    ) internal view returns (uint256[] memory cappedReserves) {\n        cappedReserves = reserves;\n        // Part 1: Cap Rates\n        // Use the larger reserve as the numerator for the ratio to maximize precision\n        (uint256 i, uint256 j) = lastReserves[0] > lastReserves[1] ? (0, 1) : (1, 0);\n        CapRatesVariables memory crv;\n        crv.rLast = mfpWf.calcRate(lastReserves, i, j, data);\n        crv.r = mfpWf.calcRate(cappedReserves, i, j, data);\n\n        // If the ratio increased, check that it didn't increase above the max.\n        if (crv.r > crv.rLast) {\n            bytes16 tempExp = ABDKMathQuad.ONE.add(crp.maxRateChanges[i][j]).powu(capExponent);\n            crv.rLimit = tempExp.cmp(MAX_CONVERT_TO_128x128) != -1\n                ? crv.rLimit = type(uint256).max\n                : crv.rLast.mulDivOrMax(tempExp.to128x128().toUint256(), CAP_PRECISION2);\n            if (cappedReserves[i].mulDiv(CAP_PRECISION, cappedReserves[j]) > crv.rLimit) {\n                calcReservesAtRatioSwap(mfpWf, crv.rLimit, cappedReserves, i, j, data);\n            }\n            // If the ratio decreased, check that it didn't decrease below the max.\n        } else if (crv.r < crv.rLast) {\n            crv.rLimit = crv.rLast.mulDiv(\n                ABDKMathQuad.ONE.div(ABDKMathQuad.ONE.add(crp.maxRateChanges[j][i])).powu(capExponent).to128x128()\n                    .toUint256(),\n                CAP_PRECISION2\n            );\n            if (cappedReserves[i].mulDiv(CAP_PRECISION, cappedReserves[j]) < crv.rLimit) {\n                calcReservesAtRatioSwap(mfpWf, crv.rLimit, cappedReserves, i, j, data);\n            }\n        }\n    }\n\n    /**\n     * @dev Cap the change in LP Token Supply of `reserves` to a maximum % change from `lastReserves`.\n     */\n    function _capLpTokenSupply(\n        uint256[] memory lastReserves,\n        uint256[] memory reserves,\n        uint256 capExponent,\n        CapReservesParameters memory crp,\n        IMultiFlowPumpWellFunction mfpWf,\n        bytes memory data,\n        bool returnIfBelowMin\n    ) internal view returns (uint256[] memory cappedReserves) {\n        cappedReserves = reserves;\n        // Part 2: Cap LP Token Supply Change\n        uint256 lastLpTokenSupply = tryCalcLpTokenSupply(mfpWf, lastReserves, data);\n        uint256 lpTokenSupply = tryCalcLpTokenSupply(mfpWf, cappedReserves, data);\n\n        // If LP Token Supply increased, check that it didn't increase above the max.\n        if (lpTokenSupply > lastLpTokenSupply) {\n            bytes16 tempExp = ABDKMathQuad.ONE.add(crp.maxLpSupplyIncrease).powu(capExponent);\n            uint256 maxLpTokenSupply = tempExp.cmp(MAX_CONVERT_TO_128x128) != -1\n                ? type(uint256).max\n                : lastLpTokenSupply.mulDiv(tempExp.to128x128().toUint256(), CAP_PRECISION2);\n\n            if (lpTokenSupply > maxLpTokenSupply) {\n                // If `_capLpTokenSupply` decreases the reserves, cap the ratio first, to maximize precision.\n                if (returnIfBelowMin) return new uint256[](0);\n                cappedReserves = tryCalcLPTokenUnderlying(mfpWf, maxLpTokenSupply, cappedReserves, lpTokenSupply, data);\n            }\n            // If LP Token Suppply decreased, check that it didn't increase below the min.\n        } else if (lpTokenSupply < lastLpTokenSupply) {\n            uint256 minLpTokenSupply = lastLpTokenSupply\n                * (ABDKMathQuad.ONE.sub(crp.maxLpSupplyDecrease)).powu(capExponent).to128x128().toUint256() / CAP_PRECISION2;\n            if (lpTokenSupply < minLpTokenSupply) {\n                cappedReserves = tryCalcLPTokenUnderlying(mfpWf, minLpTokenSupply, cappedReserves, lpTokenSupply, data);\n            }\n        }\n    }\n\n    //////////////////// EMA RESERVES ////////////////////\n\n    function readLastInstantaneousReserves(\n        address well,\n        bytes memory\n    ) external view returns (uint256[] memory emaReserves) {\n        bytes32 slot = _getSlotForAddress(well);\n        uint8 numberOfReserves = slot.readNumberOfReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        uint256 offset = _getSlotsOffset(numberOfReserves);\n        assembly {\n            slot := add(slot, offset)\n        }\n        bytes16[] memory byteReserves = slot.readBytes16(numberOfReserves);\n        emaReserves = new uint256[](numberOfReserves);\n        for (uint256 i; i < numberOfReserves; ++i) {\n            emaReserves[i] = byteReserves[i].pow_2ToUInt();\n        }\n    }\n\n    function readInstantaneousReserves(\n        address well,\n        bytes memory data\n    ) external view returns (uint256[] memory emaReserves) {\n        (bytes16 alpha, uint256 capInterval, CapReservesParameters memory crp) =\n            abi.decode(data, (bytes16, uint256, CapReservesParameters));\n        bytes32 slot = _getSlotForAddress(well);\n        uint256[] memory reserves = IWell(well).getReserves();\n        (uint8 numberOfReserves, uint40 lastTimestamp, uint256[] memory lastReserves) = slot.readLastReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        uint256 offset = _getSlotsOffset(numberOfReserves);\n        assembly {\n            slot := add(slot, offset)\n        }\n        bytes16[] memory lastEmaReserves = slot.readBytes16(numberOfReserves);\n        emaReserves = new uint256[](numberOfReserves);\n        uint256 deltaTimestamp = _getDeltaTimestamp(lastTimestamp);\n        // If no time has passed, return last EMA reserves.\n        if (deltaTimestamp == 0) {\n            for (uint256 i; i < numberOfReserves; ++i) {\n                emaReserves[i] = lastEmaReserves[i].pow_2ToUInt();\n            }\n            return emaReserves;\n        }\n        uint256 capExponent = calcCapExponent(deltaTimestamp, capInterval);\n        lastReserves = _capReserves(well, lastReserves, reserves, capExponent, crp);\n        bytes16 alphaN = alpha.powu(deltaTimestamp);\n        for (uint256 i; i < numberOfReserves; ++i) {\n            emaReserves[i] = lastReserves[i].fromUIntToLog2().mul((ABDKMathQuad.ONE.sub(alphaN))).add(\n                lastEmaReserves[i].mul(alphaN)\n            ).pow_2ToUInt();\n        }\n    }\n\n    //////////////////// CUMULATIVE RESERVES ////////////////////\n\n    /**\n     * @notice Read the latest cumulative reserves of `well`.\n     */\n    function readLastCumulativeReserves(\n        address well,\n        bytes memory\n    ) external view returns (bytes16[] memory cumulativeReserves) {\n        bytes32 slot = _getSlotForAddress(well);\n        uint8 numberOfReserves = slot.readNumberOfReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        uint256 offset = _getSlotsOffset(numberOfReserves) << 1;\n        assembly {\n            slot := add(slot, offset)\n        }\n        cumulativeReserves = slot.readBytes16(numberOfReserves);\n    }\n\n    function readCumulativeReserves(\n        address well,\n        bytes memory data\n    ) external view returns (bytes memory cumulativeReserves) {\n        bytes16[] memory byteCumulativeReserves = _readCumulativeReserves(well, data);\n        cumulativeReserves = abi.encode(byteCumulativeReserves);\n    }\n\n    function _readCumulativeReserves(\n        address well,\n        bytes memory data\n    ) internal view returns (bytes16[] memory cumulativeReserves) {\n        (, uint256 capInterval, CapReservesParameters memory crp) =\n            abi.decode(data, (bytes16, uint256, CapReservesParameters));\n        bytes32 slot = _getSlotForAddress(well);\n        uint256[] memory reserves = IWell(well).getReserves();\n        (uint8 numberOfReserves, uint40 lastTimestamp, uint256[] memory lastReserves) = slot.readLastReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        uint256 offset = _getSlotsOffset(numberOfReserves) << 1;\n        assembly {\n            slot := add(slot, offset)\n        }\n        cumulativeReserves = slot.readBytes16(numberOfReserves);\n        uint256 deltaTimestamp = _getDeltaTimestamp(lastTimestamp);\n        // If no time has passed, return last cumulative reserves.\n        if (deltaTimestamp == 0) {\n            return cumulativeReserves;\n        }\n        bytes16 deltaTimestampBytes = deltaTimestamp.fromUInt();\n        uint256 capExponent = calcCapExponent(deltaTimestamp, capInterval);\n        lastReserves = _capReserves(well, lastReserves, reserves, capExponent, crp);\n        // Currently, there is so support for overflow.\n        for (uint256 i; i < cumulativeReserves.length; ++i) {\n            cumulativeReserves[i] = cumulativeReserves[i].add(lastReserves[i].fromUIntToLog2().mul(deltaTimestampBytes));\n        }\n    }\n\n    function readTwaReserves(\n        address well,\n        bytes calldata startCumulativeReserves,\n        uint256 startTimestamp,\n        bytes memory data\n    ) public view returns (uint256[] memory twaReserves, bytes memory cumulativeReserves) {\n        bytes16[] memory byteCumulativeReserves = _readCumulativeReserves(well, data);\n        bytes16[] memory byteStartCumulativeReserves = abi.decode(startCumulativeReserves, (bytes16[]));\n        twaReserves = new uint256[](byteCumulativeReserves.length);\n\n        // Overflow is desired on `startTimestamp`, so SafeCast is not used.\n        bytes16 deltaTimestamp = _getDeltaTimestamp(uint40(startTimestamp)).fromUInt();\n        if (deltaTimestamp == bytes16(0)) {\n            revert NoTimePassed();\n        }\n        for (uint256 i; i < byteCumulativeReserves.length; ++i) {\n            // Currently, there is no support for overflow.\n            twaReserves[i] =\n                (byteCumulativeReserves[i].sub(byteStartCumulativeReserves[i])).div(deltaTimestamp).pow_2ToUInt();\n        }\n        cumulativeReserves = abi.encode(byteCumulativeReserves);\n    }\n\n    //////////////////// HELPERS ////////////////////\n\n    /**\n     * @dev Calculate the cap exponent for a given `deltaTimestamp` and `capInterval`.\n     */\n    function calcCapExponent(uint256 deltaTimestamp, uint256 capInterval) private pure returns (uint256 capExponent) {\n        capExponent = ((deltaTimestamp - 1) / capInterval + 1);\n    }\n\n    /**\n     * @dev Calculates the capped reserves given a rate limit.\n     */\n    function calcReservesAtRatioSwap(\n        IMultiFlowPumpWellFunction mfpWf,\n        uint256 rLimit,\n        uint256[] memory reserves,\n        uint256 i,\n        uint256 j,\n        bytes memory data\n    ) private view returns (uint256[] memory) {\n        uint256[] memory ratios = new uint256[](2);\n        ratios[i] = rLimit;\n        ratios[j] = CAP_PRECISION;\n        // Use a minimum of 1 for reserve. Geometric means will be set to 0 if a reserve is 0.\n        uint256 cappedReserveI = Math.max(tryCalcReserveAtRatioSwap(mfpWf, reserves, i, ratios, data), 1);\n        reserves[j] = Math.max(tryCalcReserveAtRatioSwap(mfpWf, reserves, j, ratios, data), 1);\n        reserves[i] = cappedReserveI;\n        return reserves;\n    }\n\n    /**\n     * @dev Convert an `address` into a `bytes32` by zero padding the right 12 bytes.\n     */\n    function _getSlotForAddress(address addressValue) internal pure returns (bytes32 _slot) {\n        _slot = bytes32(bytes20(addressValue)); // Because right padded, no collision on adjacent\n    }\n\n    /**\n     * @dev Get the starting byte of the slot that contains the `n`th element of an array.\n     */\n    function _getSlotsOffset(uint256 numberOfReserves) internal pure returns (uint256 _slotsOffset) {\n        _slotsOffset = ((numberOfReserves - 1) / 2 + 1) << 5;\n    }\n\n    /**\n     * @dev Get the delta between the current and provided timestamp as a `uint256`.\n     */\n    function _getDeltaTimestamp(uint40 lastTimestamp) internal view returns (uint256 _deltaTimestamp) {\n        return uint256(uint40(block.timestamp) - lastTimestamp);\n    }\n\n    /**\n     * @dev Assumes that if `calcReserveAtRatioSwap` fails, it fails because of overflow.\n     * If the call fails, returns the maximum possible return value for `calcReserveAtRatioSwap`.\n     */\n    function tryCalcReserveAtRatioSwap(\n        IMultiFlowPumpWellFunction wf,\n        uint256[] memory reserves,\n        uint256 i,\n        uint256[] memory ratios,\n        bytes memory data\n    ) internal view returns (uint256 reserve) {\n        try wf.calcReserveAtRatioSwap(reserves, i, ratios, data) returns (uint256 _reserve) {\n            reserve = _reserve;\n        } catch {\n            reserve = type(uint256).max;\n        }\n    }\n\n    /**\n     * @dev Assumes that if `calcLpTokenSupply` fails, it fails because of overflow.\n     * If it fails, returns the maximum possible return value for `calcLpTokenSupply`.\n     */\n    function tryCalcLpTokenSupply(\n        IMultiFlowPumpWellFunction wf,\n        uint256[] memory reserves,\n        bytes memory data\n    ) internal view returns (uint256 lpTokenSupply) {\n        try wf.calcLpTokenSupply(reserves, data) returns (uint256 _lpTokenSupply) {\n            lpTokenSupply = _lpTokenSupply;\n        } catch {\n            lpTokenSupply = MAX_UINT256_SQRT;\n        }\n    }\n\n    /**\n     * @dev Assumes that if `calcLPTokenUnderlying` fails, it fails because of overflow.\n     * If the call fails, returns the maximum possible return value for `calcLPTokenUnderlying`.\n     * Also, enforces a minimum of 1 for each reserve.\n     */\n    function tryCalcLPTokenUnderlying(\n        IMultiFlowPumpWellFunction wf,\n        uint256 lpTokenAmount,\n        uint256[] memory reserves,\n        uint256 lpTokenSupply,\n        bytes memory data\n    ) internal view returns (uint256[] memory underlyingAmounts) {\n        try wf.calcLPTokenUnderlying(lpTokenAmount, reserves, lpTokenSupply, data) returns (\n            uint256[] memory _underlyingAmounts\n        ) {\n            underlyingAmounts = _underlyingAmounts;\n            for (uint256 i; i < underlyingAmounts.length; ++i) {\n                if (underlyingAmounts[i] == 0) {\n                    underlyingAmounts[i] = 1;\n                }\n            }\n        } catch {\n            underlyingAmounts = new uint256[](reserves.length);\n            for (uint256 i; i < reserves.length; ++i) {\n                underlyingAmounts[i] = type(uint256).max;\n            }\n        }\n    }\n}"
    }
  ]
}