{
  "Title": "[21] `revert` WITH CUSTOM ERRORS CAN BE EXECUTED INSTEAD OF EXECUTING `require` OR `revert` WITH REASON STRINGS",
  "Content": "As mentioned [here](https://blog.soliditylang.org/2021/04/21/custom-errors), executing `revert` with a custom error can be more efficient than executing `require` or `revert` with a reason string. The following examples are some where `require` or `revert` is executed. To make the code more efficient, please consider using `revert` statements with custom errors to replace the relevant `require` and `revert` statements.\n\nhttps://github.com/ethereum-optimism/optimism/blob/6eb05430d1ec1ae18ee96c2a206c60cc80fcbcf6/packages/contracts-bedrock/contracts/L1/OptimismPortal.sol#L434-L483\n```solidity\n    function depositTransaction(\n        address _to,\n        uint256 _value,\n        uint64 _gasLimit,\n        bool _isCreation,\n        bytes memory _data\n    ) public payable metered(_gasLimit) {\n        ...\n        if (_isCreation) {\n            require(\n                _to == address(0),\n                \"OptimismPortal: must send to address(0) when creating a contract\"\n            );\n        }\n\n        ...\n        require(\n            _gasLimit >= minimumGasLimit(uint64(_data.length)),\n            \"OptimismPortal: gas limit too small\"\n        );\n\n        ...\n        require(_data.length <= 120_000, \"OptimismPortal: data too large\");\n\n        ...\n    }\n```\n\nhttps://github.com/ethereum-optimism/optimism/blob/536178b0e28f7015e036ad050945ea5633dacf02/packages/contracts-bedrock/contracts/deployment/SystemDictator.sol#L338-L411\n```solidity\n    function step5() public onlyOwner step(5) {\n        ...\n        require(dynamicConfigSet, \"SystemDictator: dynamic oracle config is not yet initialized\");\n        ...\n        try\n            L1CrossDomainMessenger(config.proxyAddressConfig.l1CrossDomainMessengerProxy)\n                .initialize()\n        {\n            ...\n        } catch Error(string memory reason) {\n            require(\n                keccak256(abi.encodePacked(reason)) ==\n                    keccak256(\"Initializable: contract is already initialized\"),\n                string.concat(\"SystemDictator: unexpected error initializing L1XDM: \", reason)\n            );\n        } catch {\n            revert(\"SystemDictator: unexpected error initializing L1XDM (no reason)\");\n        }\n        ...\n    }\n```\n\nhttps://github.com/ethereum-optimism/optimism/blob/6eb05430d1ec1ae18ee96c2a206c60cc80fcbcf6/packages/contracts-bedrock/contracts/L1/OptimismPortal.sol#L325-L420\n```solidity\n    function finalizeWithdrawalTransaction(Types.WithdrawalTransaction memory _tx)\n        external\n        whenNotPaused\n    {\n        ...\n        require(\n            l2Sender == Constants.DEFAULT_L2_SENDER,\n            \"OptimismPortal: can only trigger one withdrawal per transaction\"\n        );\n        ...\n        require(\n            provenWithdrawal.timestamp != 0,\n            \"OptimismPortal: withdrawal has not been proven yet\"\n        );\n        ...\n        require(\n            provenWithdrawal.timestamp >= L2_ORACLE.startingTimestamp(),\n            \"OptimismPortal: withdrawal timestamp less than L2 Oracle starting timestamp\"\n        );\n        ...\n        require(\n            _isFinalizationPeriodElapsed(provenWithdrawal.timestamp),\n            \"OptimismPortal: proven withdrawal finalization period has not elapsed\"\n        );\n        ...\n        require(\n            proposal.outputRoot == provenWithdrawal.outputRoot,\n            \"OptimismPortal: output root proven is not the same as current output root\"\n        );\n        ...\n        require(\n            _isFinalizationPeriodElapsed(proposal.timestamp),\n            \"OptimismPortal: output proposal finalization period has not elapsed\"\n        );\n        ...\n        require(\n            finalizedWithdrawals[withdrawalHash] == false,\n            \"OptimismPortal: withdrawal has already been finalized\"\n        );\n        ...\n        if (success == false && tx.origin == Constants.ESTIMATION_ADDRESS) {\n            revert(\"OptimismPortal: withdrawal failed\");\n        }\n    }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-05-base",
  "Code": [
    {
      "filename": "packages/contracts-bedrock/contracts/L1/OptimismPortal.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport { SafeCall } from \"../libraries/SafeCall.sol\";\nimport { L2OutputOracle } from \"./L2OutputOracle.sol\";\nimport { SystemConfig } from \"./SystemConfig.sol\";\nimport { Constants } from \"../libraries/Constants.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { SecureMerkleTrie } from \"../libraries/trie/SecureMerkleTrie.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { ResourceMetering } from \"./ResourceMetering.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @custom:proxied\n * @title OptimismPortal\n * @notice The OptimismPortal is a low-level contract responsible for passing messages between L1\n *         and L2. Messages sent directly to the OptimismPortal have no form of replayability.\n *         Users are encouraged to use the L1CrossDomainMessenger for a higher-level interface.\n */\ncontract OptimismPortal is Initializable, ResourceMetering, Semver {\n    /**\n     * @notice Represents a proven withdrawal.\n     *\n     * @custom:field outputRoot    Root of the L2 output this was proven against.\n     * @custom:field timestamp     Timestamp at whcih the withdrawal was proven.\n     * @custom:field l2OutputIndex Index of the output this was proven against.\n     */\n    struct ProvenWithdrawal {\n        bytes32 outputRoot;\n        uint128 timestamp;\n        uint128 l2OutputIndex;\n    }\n\n    /**\n     * @notice Version of the deposit event.\n     */\n    uint256 internal constant DEPOSIT_VERSION = 0;\n\n    /**\n     * @notice The L2 gas limit set when eth is deposited using the receive() function.\n     */\n    uint64 internal constant RECEIVE_DEFAULT_GAS_LIMIT = 100_000;\n\n    /**\n     * @notice Address of the L2OutputOracle contract.\n     */\n    L2OutputOracle public immutable L2_ORACLE;\n\n    /**\n     * @notice Address of the SystemConfig contract.\n     */\n    SystemConfig public immutable SYSTEM_CONFIG;\n\n    /**\n     * @notice Address that has the ability to pause and unpause withdrawals.\n     */\n    address public immutable GUARDIAN;\n\n    /**\n     * @notice Address of the L2 account which initiated a withdrawal in this transaction. If the\n     *         of this variable is the default L2 sender address, then we are NOT inside of a call\n     *         to finalizeWithdrawalTransaction.\n     */\n    address public l2Sender;\n\n    /**\n     * @notice A list of withdrawal hashes which have been successfully finalized.\n     */\n    mapping(bytes32 => bool) public finalizedWithdrawals;\n\n    /**\n     * @notice A mapping of withdrawal hashes to `ProvenWithdrawal` data.\n     */\n    mapping(bytes32 => ProvenWithdrawal) public provenWithdrawals;\n\n    /**\n     * @notice Determines if cross domain messaging is paused. When set to true,\n     *         withdrawals are paused. This may be removed in the future.\n     */\n    bool public paused;\n\n    /**\n     * @notice Emitted when a transaction is deposited from L1 to L2. The parameters of this event\n     *         are read by the rollup node and used to derive deposit transactions on L2.\n     *\n     * @param from       Address that triggered the deposit transaction.\n     * @param to         Address that the deposit transaction is directed to.\n     * @param version    Version of this deposit transaction event.\n     * @param opaqueData ABI encoded deposit data to be parsed off-chain.\n     */\n    event TransactionDeposited(\n        address indexed from,\n        address indexed to,\n        uint256 indexed version,\n        bytes opaqueData\n    );\n\n    /**\n     * @notice Emitted when a withdrawal transaction is proven.\n     *\n     * @param withdrawalHash Hash of the withdrawal transaction.\n     */\n    event WithdrawalProven(\n        bytes32 indexed withdrawalHash,\n        address indexed from,\n        address indexed to\n    );\n\n    /**\n     * @notice Emitted when a withdrawal transaction is finalized.\n     *\n     * @param withdrawalHash Hash of the withdrawal transaction.\n     * @param success        Whether the withdrawal transaction was successful.\n     */\n    event WithdrawalFinalized(bytes32 indexed withdrawalHash, bool success);\n\n    /**\n     * @notice Emitted when the pause is triggered.\n     *\n     * @param account Address of the account triggering the pause.\n     */\n    event Paused(address account);\n\n    /**\n     * @notice Emitted when the pause is lifted.\n     *\n     * @param account Address of the account triggering the unpause.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @notice Reverts when paused.\n     */\n    modifier whenNotPaused() {\n        require(paused == false, \"OptimismPortal: paused\");\n        _;\n    }\n\n    /**\n     * @custom:semver 1.6.0\n     *\n     * @param _l2Oracle                  Address of the L2OutputOracle contract.\n     * @param _guardian                  Address that can pause deposits and withdrawals.\n     * @param _paused                    Sets the contract's pausability state.\n     * @param _config                    Address of the SystemConfig contract.\n     */\n    constructor(\n        L2OutputOracle _l2Oracle,\n        address _guardian,\n        bool _paused,\n        SystemConfig _config\n    ) Semver(1, 6, 0) {\n        L2_ORACLE = _l2Oracle;\n        GUARDIAN = _guardian;\n        SYSTEM_CONFIG = _config;\n        initialize(_paused);\n    }\n\n    /**\n     * @notice Initializer.\n     */\n    function initialize(bool _paused) public initializer {\n        l2Sender = Constants.DEFAULT_L2_SENDER;\n        paused = _paused;\n        __ResourceMetering_init();\n    }\n\n    /**\n     * @notice Pause deposits and withdrawals.\n     */\n    function pause() external {\n        require(msg.sender == GUARDIAN, \"OptimismPortal: only guardian can pause\");\n        paused = true;\n        emit Paused(msg.sender);\n    }\n\n    /**\n     * @notice Unpause deposits and withdrawals.\n     */\n    function unpause() external {\n        require(msg.sender == GUARDIAN, \"OptimismPortal: only guardian can unpause\");\n        paused = false;\n        emit Unpaused(msg.sender);\n    }\n\n    /**\n     * @notice Computes the minimum gas limit for a deposit. The minimum gas limit\n     *         linearly increases based on the size of the calldata. This is to prevent\n     *         users from creating L2 resource usage without paying for it. This function\n     *         can be used when interacting with the portal to ensure forwards compatibility.\n     *\n     */\n    function minimumGasLimit(uint64 _byteCount) public pure returns (uint64) {\n        return _byteCount * 16 + 21000;\n    }\n\n    /**\n     * @notice Accepts value so that users can send ETH directly to this contract and have the\n     *         funds be deposited to their address on L2. This is intended as a convenience\n     *         function for EOAs. Contracts should call the depositTransaction() function directly\n     *         otherwise any deposited funds will be lost due to address aliasing.\n     */\n    // solhint-disable-next-line ordering\n    receive() external payable {\n        depositTransaction(msg.sender, msg.value, RECEIVE_DEFAULT_GAS_LIMIT, false, bytes(\"\"));\n    }\n\n    /**\n     * @notice Accepts ETH value without triggering a deposit to L2. This function mainly exists\n     *         for the sake of the migration between the legacy Optimism system and Bedrock.\n     */\n    function donateETH() external payable {\n        // Intentionally empty.\n    }\n\n    /**\n     * @notice Getter for the resource config. Used internally by the ResourceMetering\n     *         contract. The SystemConfig is the source of truth for the resource config.\n     *\n     * @return ResourceMetering.ResourceConfig\n     */\n    function _resourceConfig()\n        internal\n        view\n        override\n        returns (ResourceMetering.ResourceConfig memory)\n    {\n        return SYSTEM_CONFIG.resourceConfig();\n    }\n\n    /**\n     * @notice Proves a withdrawal transaction.\n     *\n     * @param _tx              Withdrawal transaction to finalize.\n     * @param _l2OutputIndex   L2 output index to prove against.\n     * @param _outputRootProof Inclusion proof of the L2ToL1MessagePasser contract's storage root.\n     * @param _withdrawalProof Inclusion proof of the withdrawal in L2ToL1MessagePasser contract.\n     */\n    function proveWithdrawalTransaction(\n        Types.WithdrawalTransaction memory _tx,\n        uint256 _l2OutputIndex,\n        Types.OutputRootProof calldata _outputRootProof,\n        bytes[] calldata _withdrawalProof\n    ) external whenNotPaused {\n        // Prevent users from creating a deposit transaction where this address is the message\n        // sender on L2. Because this is checked here, we do not need to check again in\n        // `finalizeWithdrawalTransaction`.\n        require(\n            _tx.target != address(this),\n            \"OptimismPortal: you cannot send messages to the portal contract\"\n        );\n\n        // Get the output root and load onto the stack to prevent multiple mloads. This will\n        // revert if there is no output root for the given block number.\n        bytes32 outputRoot = L2_ORACLE.getL2Output(_l2OutputIndex).outputRoot;\n\n        // Verify that the output root can be generated with the elements in the proof.\n        require(\n            outputRoot == Hashing.hashOutputRootProof(_outputRootProof),\n            \"OptimismPortal: invalid output root proof\"\n        );\n\n        // Load the ProvenWithdrawal into memory, using the withdrawal hash as a unique identifier.\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(_tx);\n        ProvenWithdrawal memory provenWithdrawal = provenWithdrawals[withdrawalHash];\n\n        // We generally want to prevent users from proving the same withdrawal multiple times\n        // because each successive proof will update the timestamp. A malicious user can take\n        // advantage of this to prevent other users from finalizing their withdrawal. However,\n        // since withdrawals are proven before an output root is finalized, we need to allow users\n        // to re-prove their withdrawal only in the case that the output root for their specified\n        // output index has been updated.\n        require(\n            provenWithdrawal.timestamp == 0 ||\n                L2_ORACLE.getL2Output(provenWithdrawal.l2OutputIndex).outputRoot !=\n                provenWithdrawal.outputRoot,\n            \"OptimismPortal: withdrawal hash has already been proven\"\n        );\n\n        // Compute the storage slot of the withdrawal hash in the L2ToL1MessagePasser contract.\n        // Refer to the Solidity documentation for more information on how storage layouts are\n        // computed for mappings.\n        bytes32 storageKey = keccak256(\n            abi.encode(\n                withdrawalHash,\n                uint256(0) // The withdrawals mapping is at the first slot in the layout.\n            )\n        );\n\n        // Verify that the hash of this withdrawal was stored in the L2toL1MessagePasser contract\n        // on L2. If this is true, under the assumption that the SecureMerkleTrie does not have\n        // bugs, then we know that this withdrawal was actually triggered on L2 and can therefore\n        // be relayed on L1.\n        require(\n            SecureMerkleTrie.verifyInclusionProof(\n                abi.encode(storageKey),\n                hex\"01\",\n                _withdrawalProof,\n                _outputRootProof.messagePasserStorageRoot\n            ),\n            \"OptimismPortal: invalid withdrawal inclusion proof\"\n        );\n\n        // Designate the withdrawalHash as proven by storing the `outputRoot`, `timestamp`, and\n        // `l2BlockNumber` in the `provenWithdrawals` mapping. A `withdrawalHash` can only be\n        // proven once unless it is submitted again with a different outputRoot.\n        provenWithdrawals[withdrawalHash] = ProvenWithdrawal({\n            outputRoot: outputRoot,\n            timestamp: uint128(block.timestamp),\n            l2OutputIndex: uint128(_l2OutputIndex)\n        });\n\n        // Emit a `WithdrawalProven` event.\n        emit WithdrawalProven(withdrawalHash, _tx.sender, _tx.target);\n    }\n\n    /**\n     * @notice Finalizes a withdrawal transaction.\n     *\n     * @param _tx Withdrawal transaction to finalize.\n     */\n    function finalizeWithdrawalTransaction(Types.WithdrawalTransaction memory _tx)\n        external\n        whenNotPaused\n    {\n        // Make sure that the l2Sender has not yet been set. The l2Sender is set to a value other\n        // than the default value when a withdrawal transaction is being finalized. This check is\n        // a defacto reentrancy guard.\n        require(\n            l2Sender == Constants.DEFAULT_L2_SENDER,\n            \"OptimismPortal: can only trigger one withdrawal per transaction\"\n        );\n\n        // Grab the proven withdrawal from the `provenWithdrawals` map.\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(_tx);\n        ProvenWithdrawal memory provenWithdrawal = provenWithdrawals[withdrawalHash];\n\n        // A withdrawal can only be finalized if it has been proven. We know that a withdrawal has\n        // been proven at least once when its timestamp is non-zero. Unproven withdrawals will have\n        // a timestamp of zero.\n        require(\n            provenWithdrawal.timestamp != 0,\n            \"OptimismPortal: withdrawal has not been proven yet\"\n        );\n\n        // As a sanity check, we make sure that the proven withdrawal's timestamp is greater than\n        // starting timestamp inside the L2OutputOracle. Not strictly necessary but extra layer of\n        // safety against weird bugs in the proving step.\n        require(\n            provenWithdrawal.timestamp >= L2_ORACLE.startingTimestamp(),\n            \"OptimismPortal: withdrawal timestamp less than L2 Oracle starting timestamp\"\n        );\n\n        // A proven withdrawal must wait at least the finalization period before it can be\n        // finalized. This waiting period can elapse in parallel with the waiting period for the\n        // output the withdrawal was proven against. In effect, this means that the minimum\n        // withdrawal time is proposal submission time + finalization period.\n        require(\n            _isFinalizationPeriodElapsed(provenWithdrawal.timestamp),\n            \"OptimismPortal: proven withdrawal finalization period has not elapsed\"\n        );\n\n        // Grab the OutputProposal from the L2OutputOracle, will revert if the output that\n        // corresponds to the given index has not been proposed yet.\n        Types.OutputProposal memory proposal = L2_ORACLE.getL2Output(\n            provenWithdrawal.l2OutputIndex\n        );\n\n        // Check that the output root that was used to prove the withdrawal is the same as the\n        // current output root for the given output index. An output root may change if it is\n        // deleted by the challenger address and then re-proposed.\n        require(\n            proposal.outputRoot == provenWithdrawal.outputRoot,\n            \"OptimismPortal: output root proven is not the same as current output root\"\n        );\n\n        // Check that the output proposal has also been finalized.\n        require(\n            _isFinalizationPeriodElapsed(proposal.timestamp),\n            \"OptimismPortal: output proposal finalization period has not elapsed\"\n        );\n\n        // Check that this withdrawal has not already been finalized, this is replay protection.\n        require(\n            finalizedWithdrawals[withdrawalHash] == false,\n            \"OptimismPortal: withdrawal has already been finalized\"\n        );\n\n        // Mark the withdrawal as finalized so it can't be replayed.\n        finalizedWithdrawals[withdrawalHash] = true;\n\n        // Set the l2Sender so contracts know who triggered this withdrawal on L2.\n        l2Sender = _tx.sender;\n\n        // Trigger the call to the target contract. We use a custom low level method\n        // SafeCall.callWithMinGas to ensure two key properties\n        //   1. Target contracts cannot force this call to run out of gas by returning a very large\n        //      amount of data (and this is OK because we don't care about the returndata here).\n        //   2. The amount of gas provided to the execution context of the target is at least the\n        //      gas limit specified by the user. If there is not enough gas in the current context\n        //      to accomplish this, `callWithMinGas` will revert.\n        bool success = SafeCall.callWithMinGas(_tx.target, _tx.gasLimit, _tx.value, _tx.data);\n\n        // Reset the l2Sender back to the default value.\n        l2Sender = Constants.DEFAULT_L2_SENDER;\n\n        // All withdrawals are immediately finalized. Replayability can\n        // be achieved through contracts built on top of this contract\n        emit WithdrawalFinalized(withdrawalHash, success);\n\n        // Reverting here is useful for determining the exact gas cost to successfully execute the\n        // sub call to the target contract if the minimum gas limit specified by the user would not\n        // be sufficient to execute the sub call.\n        if (success == false && tx.origin == Constants.ESTIMATION_ADDRESS) {\n            revert(\"OptimismPortal: withdrawal failed\");\n        }\n    }\n\n    /**\n     * @notice Accepts deposits of ETH and data, and emits a TransactionDeposited event for use in\n     *         deriving deposit transactions. Note that if a deposit is made by a contract, its\n     *         address will be aliased when retrieved using `tx.origin` or `msg.sender`. Consider\n     *         using the CrossDomainMessenger contracts for a simpler developer experience.\n     *\n     * @param _to         Target address on L2.\n     * @param _value      ETH value to send to the recipient.\n     * @param _gasLimit   Minimum L2 gas limit (can be greater than or equal to this value).\n     * @param _isCreation Whether or not the transaction is a contract creation.\n     * @param _data       Data to trigger the recipient with.\n     */\n    function depositTransaction(\n        address _to,\n        uint256 _value,\n        uint64 _gasLimit,\n        bool _isCreation,\n        bytes memory _data\n    ) public payable metered(_gasLimit) {\n        // Just to be safe, make sure that people specify address(0) as the target when doing\n        // contract creations.\n        if (_isCreation) {\n            require(\n                _to == address(0),\n                \"OptimismPortal: must send to address(0) when creating a contract\"\n            );\n        }\n\n        // Prevent depositing transactions that have too small of a gas limit. Users should pay\n        // more for more resource usage.\n        require(\n            _gasLimit >= minimumGasLimit(uint64(_data.length)),\n            \"OptimismPortal: gas limit too small\"\n        );\n\n        // Prevent the creation of deposit transactions that have too much calldata. This gives an\n        // upper limit on the size of unsafe blocks over the p2p network. 120kb is chosen to ensure\n        // that the transaction can fit into the p2p network policy of 128kb even though deposit\n        // transactions are not gossipped over the p2p network.\n        require(_data.length <= 120_000, \"OptimismPortal: data too large\");\n\n        // Transform the from-address to its alias if the caller is a contract.\n        address from = msg.sender;\n        if (msg.sender != tx.origin) {\n            from = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n        }\n\n        // Compute the opaque data that will be emitted as part of the TransactionDeposited event.\n        // We use opaque data so that we can update the TransactionDeposited event in the future\n        // without breaking the current interface.\n        bytes memory opaqueData = abi.encodePacked(\n            msg.value,\n            _value,\n            _gasLimit,\n            _isCreation,\n            _data\n        );\n\n        // Emit a TransactionDeposited event so that the rollup node can derive a deposit\n        // transaction for this deposit.\n        emit TransactionDeposited(from, _to, DEPOSIT_VERSION, opaqueData);\n    }\n\n    /**\n     * @notice Determine if a given output is finalized. Reverts if the call to\n     *         L2_ORACLE.getL2Output reverts. Returns a boolean otherwise.\n     *\n     * @param _l2OutputIndex Index of the L2 output to check.\n     *\n     * @return Whether or not the output is finalized.\n     */\n    function isOutputFinalized(uint256 _l2OutputIndex) external view returns (bool) {\n        return _isFinalizationPeriodElapsed(L2_ORACLE.getL2Output(_l2OutputIndex).timestamp);\n    }\n\n    /**\n     * @notice Determines whether the finalization period has elapsed w/r/t a given timestamp.\n     *\n     * @param _timestamp Timestamp to check.\n     *\n     * @return Whether or not the finalization period has elapsed.\n     */\n    function _isFinalizationPeriodElapsed(uint256 _timestamp) internal view returns (bool) {\n        return block.timestamp > _timestamp + L2_ORACLE.FINALIZATION_PERIOD_SECONDS();\n    }\n}"
    },
    {
      "filename": "packages/contracts-bedrock/contracts/deployment/SystemDictator.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {\n    OwnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { OptimismPortal } from \"../L1/OptimismPortal.sol\";\nimport { L1CrossDomainMessenger } from \"../L1/L1CrossDomainMessenger.sol\";\nimport { L1ERC721Bridge } from \"../L1/L1ERC721Bridge.sol\";\nimport { L1StandardBridge } from \"../L1/L1StandardBridge.sol\";\nimport { L1ChugSplashProxy } from \"../legacy/L1ChugSplashProxy.sol\";\nimport { AddressManager } from \"../legacy/AddressManager.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\nimport { ProxyAdmin } from \"../universal/ProxyAdmin.sol\";\nimport { OptimismMintableERC20Factory } from \"../universal/OptimismMintableERC20Factory.sol\";\nimport { PortalSender } from \"./PortalSender.sol\";\nimport { SystemConfig } from \"../L1/SystemConfig.sol\";\nimport { ResourceMetering } from \"../L1/ResourceMetering.sol\";\nimport { Constants } from \"../libraries/Constants.sol\";\n\n/**\n * @title SystemDictator\n * @notice The SystemDictator is responsible for coordinating the deployment of a full Bedrock\n *         system. The SystemDictator is designed to support both fresh network deployments and\n *         upgrades to existing pre-Bedrock systems.\n */\ncontract SystemDictator is OwnableUpgradeable {\n    /**\n     * @notice Basic system configuration.\n     */\n    struct GlobalConfig {\n        AddressManager addressManager;\n        ProxyAdmin proxyAdmin;\n        address controller;\n        address finalOwner;\n    }\n\n    /**\n     * @notice Set of proxy addresses.\n     */\n    struct ProxyAddressConfig {\n        address l2OutputOracleProxy;\n        address optimismPortalProxy;\n        address l1CrossDomainMessengerProxy;\n        address l1StandardBridgeProxy;\n        address optimismMintableERC20FactoryProxy;\n        address l1ERC721BridgeProxy;\n        address systemConfigProxy;\n    }\n\n    /**\n     * @notice Set of implementation addresses.\n     */\n    struct ImplementationAddressConfig {\n        L2OutputOracle l2OutputOracleImpl;\n        OptimismPortal optimismPortalImpl;\n        L1CrossDomainMessenger l1CrossDomainMessengerImpl;\n        L1StandardBridge l1StandardBridgeImpl;\n        OptimismMintableERC20Factory optimismMintableERC20FactoryImpl;\n        L1ERC721Bridge l1ERC721BridgeImpl;\n        PortalSender portalSenderImpl;\n        SystemConfig systemConfigImpl;\n    }\n\n    /**\n     * @notice Dynamic L2OutputOracle config.\n     */\n    struct L2OutputOracleDynamicConfig {\n        uint256 l2OutputOracleStartingBlockNumber;\n        uint256 l2OutputOracleStartingTimestamp;\n    }\n\n    /**\n     * @notice Values for the system config contract.\n     */\n    struct SystemConfigConfig {\n        address owner;\n        uint256 overhead;\n        uint256 scalar;\n        bytes32 batcherHash;\n        uint64 gasLimit;\n        address unsafeBlockSigner;\n        ResourceMetering.ResourceConfig resourceConfig;\n    }\n\n    /**\n     * @notice Combined system configuration.\n     */\n    struct DeployConfig {\n        GlobalConfig globalConfig;\n        ProxyAddressConfig proxyAddressConfig;\n        ImplementationAddressConfig implementationAddressConfig;\n        SystemConfigConfig systemConfigConfig;\n    }\n\n    /**\n     * @notice Step after which exit 1 can no longer be used.\n     */\n    uint8 public constant EXIT_1_NO_RETURN_STEP = 3;\n\n    /**\n     * @notice Step where proxy ownership is transferred.\n     */\n    uint8 public constant PROXY_TRANSFER_STEP = 4;\n\n    /**\n     * @notice System configuration.\n     */\n    DeployConfig public config;\n\n    /**\n     * @notice Dynamic configuration for the L2OutputOracle.\n     */\n    L2OutputOracleDynamicConfig public l2OutputOracleDynamicConfig;\n\n    /**\n     * @notice Dynamic configuration for the OptimismPortal. Determines\n     *         if the system should be paused when initialized.\n     */\n    bool public optimismPortalDynamicConfig;\n\n    /**\n     * @notice Current step;\n     */\n    uint8 public currentStep;\n\n    /**\n     * @notice Whether or not dynamic config has been set.\n     */\n    bool public dynamicConfigSet;\n\n    /**\n     * @notice Whether or not the deployment is finalized.\n     */\n    bool public finalized;\n\n    /**\n     * @notice Whether or not the deployment has been exited.\n     */\n    bool public exited;\n\n    /**\n     * @notice Address of the old L1CrossDomainMessenger implementation.\n     */\n    address public oldL1CrossDomainMessenger;\n\n    /**\n     * @notice Checks that the current step is the expected step, then bumps the current step.\n     *\n     * @param _step Current step.\n     */\n    modifier step(uint8 _step) {\n        require(!finalized, \"SystemDictator: already finalized\");\n        require(!exited, \"SystemDictator: already exited\");\n        require(currentStep == _step, \"SystemDictator: incorrect step\");\n        _;\n        currentStep++;\n    }\n\n    /**\n     * @notice Constructor required to ensure that the implementation of the SystemDictator is\n     *         initialized upon deployment.\n     */\n    constructor() {\n        ResourceMetering.ResourceConfig memory rcfg = Constants.DEFAULT_RESOURCE_CONFIG();\n\n        // Using this shorter variable as an alias for address(0) just prevents us from having to\n        // to use a new line for every single parameter.\n        address zero = address(0);\n        initialize(\n            DeployConfig(\n                GlobalConfig(AddressManager(zero), ProxyAdmin(zero), zero, zero),\n                ProxyAddressConfig(zero, zero, zero, zero, zero, zero, zero),\n                ImplementationAddressConfig(\n                    L2OutputOracle(zero),\n                    OptimismPortal(payable(zero)),\n                    L1CrossDomainMessenger(zero),\n                    L1StandardBridge(payable(zero)),\n                    OptimismMintableERC20Factory(zero),\n                    L1ERC721Bridge(zero),\n                    PortalSender(zero),\n                    SystemConfig(zero)\n                ),\n                SystemConfigConfig(zero, 0, 0, bytes32(0), 0, zero, rcfg)\n            )\n        );\n    }\n\n    /**\n     * @param _config System configuration.\n     */\n    function initialize(DeployConfig memory _config) public initializer {\n        config = _config;\n        currentStep = 1;\n        __Ownable_init();\n        _transferOwnership(config.globalConfig.controller);\n    }\n\n    /**\n     * @notice Allows the owner to update dynamic config.\n     *\n     * @param _l2OutputOracleDynamicConfig Dynamic L2OutputOracle config.\n     * @param _optimismPortalDynamicConfig Dynamic OptimismPortal config.\n     */\n    function updateDynamicConfig(\n        L2OutputOracleDynamicConfig memory _l2OutputOracleDynamicConfig,\n        bool _optimismPortalDynamicConfig\n    ) external onlyOwner {\n        l2OutputOracleDynamicConfig = _l2OutputOracleDynamicConfig;\n        optimismPortalDynamicConfig = _optimismPortalDynamicConfig;\n        dynamicConfigSet = true;\n    }\n\n    /**\n     * @notice Configures the ProxyAdmin contract.\n     */\n    function step1() public onlyOwner step(1) {\n        // Set the AddressManager in the ProxyAdmin.\n        config.globalConfig.proxyAdmin.setAddressManager(config.globalConfig.addressManager);\n\n        // Set the L1CrossDomainMessenger to the RESOLVED proxy type.\n        config.globalConfig.proxyAdmin.setProxyType(\n            config.proxyAddressConfig.l1CrossDomainMessengerProxy,\n            ProxyAdmin.ProxyType.RESOLVED\n        );\n\n        // Set the implementation name for the L1CrossDomainMessenger.\n        config.globalConfig.proxyAdmin.setImplementationName(\n            config.proxyAddressConfig.l1CrossDomainMessengerProxy,\n            \"OVM_L1CrossDomainMessenger\"\n        );\n\n        // Set the L1StandardBridge to the CHUGSPLASH proxy type.\n        config.globalConfig.proxyAdmin.setProxyType(\n            config.proxyAddressConfig.l1StandardBridgeProxy,\n            ProxyAdmin.ProxyType.CHUGSPLASH\n        );\n\n        // Upgrade and initialize the SystemConfig so the Sequencer can start up.\n        config.globalConfig.proxyAdmin.upgradeAndCall(\n            payable(config.proxyAddressConfig.systemConfigProxy),\n            address(config.implementationAddressConfig.systemConfigImpl),\n            abi.encodeCall(\n                SystemConfig.initialize,\n                (\n                    config.systemConfigConfig.owner,\n                    config.systemConfigConfig.overhead,\n                    config.systemConfigConfig.scalar,\n                    config.systemConfigConfig.batcherHash,\n                    config.systemConfigConfig.gasLimit,\n                    config.systemConfigConfig.unsafeBlockSigner,\n                    config.systemConfigConfig.resourceConfig\n                )\n            )\n        );\n    }\n\n    /**\n     * @notice Pauses the system by shutting down the L1CrossDomainMessenger and setting the\n     *         deposit halt flag to tell the Sequencer's DTL to stop accepting deposits.\n     */\n    function step2() public onlyOwner step(2) {\n        // Store the address of the old L1CrossDomainMessenger implementation. We will need this\n        // address in the case that we have to exit early.\n        oldL1CrossDomainMessenger = config.globalConfig.addressManager.getAddress(\n            \"OVM_L1CrossDomainMessenger\"\n        );\n\n        // Temporarily brick the L1CrossDomainMessenger by setting its implementation address to\n        // address(0) which will cause the ResolvedDelegateProxy to revert. Better than pausing\n        // the L1CrossDomainMessenger via pause() because it can be easily reverted.\n        config.globalConfig.addressManager.setAddress(\"OVM_L1CrossDomainMessenger\", address(0));\n\n        // Set the DTL shutoff block, which will tell the DTL to stop syncing new deposits from the\n        // CanonicalTransactionChain. We do this by setting an address in the AddressManager\n        // because the DTL already has a reference to the AddressManager and this way we don't also\n        // need to give it a reference to the SystemDictator.\n        config.globalConfig.addressManager.setAddress(\n            \"DTL_SHUTOFF_BLOCK\",\n            address(uint160(block.number))\n        );\n    }\n\n    /**\n     * @notice Removes deprecated addresses from the AddressManager.\n     */\n    function step3() public onlyOwner step(EXIT_1_NO_RETURN_STEP) {\n        // Remove all deprecated addresses from the AddressManager\n        string[17] memory deprecated = [\n            \"OVM_CanonicalTransactionChain\",\n            \"OVM_L2CrossDomainMessenger\",\n            \"OVM_DecompressionPrecompileAddress\",\n            \"OVM_Sequencer\",\n            \"OVM_Proposer\",\n            \"OVM_ChainStorageContainer-CTC-batches\",\n            \"OVM_ChainStorageContainer-CTC-queue\",\n            \"OVM_CanonicalTransactionChain\",\n            \"OVM_StateCommitmentChain\",\n            \"OVM_BondManager\",\n            \"OVM_ExecutionManager\",\n            \"OVM_FraudVerifier\",\n            \"OVM_StateManagerFactory\",\n            \"OVM_StateTransitionerFactory\",\n            \"OVM_SafetyChecker\",\n            \"OVM_L1MultiMessageRelayer\",\n            \"BondManager\"\n        ];\n\n        for (uint256 i = 0; i < deprecated.length; i++) {\n            config.globalConfig.addressManager.setAddress(deprecated[i], address(0));\n        }\n    }\n\n    /**\n     * @notice Transfers system ownership to the ProxyAdmin.\n     */\n    function step4() public onlyOwner step(PROXY_TRANSFER_STEP) {\n        // Transfer ownership of the AddressManager to the ProxyAdmin.\n        config"
    }
  ]
}