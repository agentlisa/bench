{
  "Title": "H-4: Bought/Purchased Token Can Be Sent To Attacker's Wallet Using 0x Adaptor",
  "Content": "# Issue H-4: Bought/Purchased Token Can Be Sent To Attacker's Wallet Using 0x Adaptor \n\nSource: https://github.com/sherlock-audit/2022-09-notional-judging/issues/75 \n\n## Found by \nxiaoming90\n\n## Summary\n\nThe lack of recipient validation against the 0x order within the 0x adaptor (`ZeroExAdapter`) allows the purchased/output tokens of the trade to be sent to the attacker's wallet.\n\n## Vulnerability Detail\n\n#### Background\n\n**How does the emergency vault settlement process work?**\n\n1. Anyone can call the `settleVaultEmergency` function to trigger the emergency vault settlement as it is permissionless\n2. The `_getEmergencySettlementParams` function will calculate the excess BPT tokens within the vault to be settled/sold\n3. The amount of excess BPT tokens will be converted to an equivalence amount of strategy tokens to be settled\n4. The strategy tokens will be settled by withdrawing staked BPT tokens from Aura Finance back to the vault for redemption.\n5. The vault will then redeem the BTP tokens from Balancer to redeem its underlying assets (WETH and stETH)\n6. The primary and secondary assets of the vault are WETH and stETH respectively. The secondary asset (stETH) will be traded for the primary asset (WETH) in one of the supported DEXes. In the end, only the primary assets (WETH) should remain within the vault.\n7. The WETH within the vault will be sent to Notional, and Notional will mint the asset tokens (cEther) for the vault in return.\n8. After completing the emergency vault settlement process, the vault will gain asset tokens (cEther) after settling/selling its excess BPT tokens.\n\n#### Issue Description\n\nThe caller of the `settleVaultEmergency` function can specify the trade parameters to sell the secondary tokens (stETH) for primary tokens (WETH) in any of the supported 5 DEX protocols (Curve, Balancer V2, Uniswap V2 & V3 and 0x) in Step 5 of the above emergency vault settlement process.\n\nAfter analyzing the adaptors of 5 DEX protocols (Curve, Balancer V2, Uniswap V2 & V3 and 0x), it was observed that Curve, Balancer V2, Uniswap V2, and Uniswap V3 are designed in a way that the purchased tokens can only be returned to the vault.\n\nTake the Uniswap V2 adaptor as an example. When the vault triggers the trade execution, it will always pass its own address `address(this)` to the `from` parameter of the `getExecutionData` function. The value of `from` parameter will be passed to the `to` parameter of Uniswap's `swapExactTokensForTokens` function, which indicates the recipient of the output/purchased tokens. Therefore, it is impossible for the caller to specify the recipient of the output tokens to another address. This is also the same for Curve, Balancer V2, and Uniswap V3.\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/trading/adapters/UniV2Adapter.sol#L12\n\n```solidity\nFile: UniV2Adapter.sol\n12:     function getExecutionData(address from, Trade calldata trade)\n..SNIP..\n31:             executionCallData = abi.encodeWithSelector(\n32:                 IUniV2Router2.swapExactTokensForTokens.selector,\n33:                 trade.amount,\n34:                 trade.limit,\n35:                 data.path,\n36:                 from,\n37:                 trade.deadline\n38:             );\n```\n\nNote: Specification of `swapExactTokensForTokens` function can be found at https://docs.uniswap.org/protocol/V2/reference/smart-contracts/router-02#swapexacttokensfortokens\n\nHowever, this is not implemented for the 0x adaptor (`ZeroExAdapter`). The `from` of the `getExecutionData` is completely ignored, and the caller has the full flexibility of crafting an order that benefits the caller.\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/trading/adapters/ZeroExAdapter.sol#L7\n\n```solidity\nFile: ZeroExAdapter.sol\n07: library ZeroExAdapter {\n08:     /// @dev executeTrade validates pre and post trade balances and also\n09:     /// sets and revokes all approvals. We are also only calling a trusted\n10:     /// zero ex proxy in this case. Therefore no order validation is done\n11:     /// to allow for flexibility.\n12:     function getExecutionData(address from, Trade calldata trade)\n13:         internal view returns (\n14:             address spender,\n15:             address target,\n16:             uint256 /* msgValue */,\n17:             bytes memory executionCallData\n18:         )\n19:     {\n20:         spender = Deployments.ZERO_EX;\n21:         target = Deployments.ZERO_EX;\n22:         // msgValue is always zero\n23:         executionCallData = trade.exchangeData;\n24:     }\n25: }\n```\n\nA number of features are supported by 0x. The full list of the supported features can be found [here](https://docs.0x.org/protocol/docs/exchange-proxy/features). Specifically, the following are the functions of attacker interest because it allows the attacker to configure the `recipient` parameter so that the bought tokens will be redirected to the attacker's wallet instead of the vault.\n\n- LiquidityProviderFeature - [sellToLiquidityProvider](https://github.com/0xProject/protocol/blob/6f72a8e8e3306fa6cc77081547192c4f630ca316/contracts/zero-ex/contracts/src/features/LiquidityProviderFeature.sol#L86)\n\n```solidity\n    /// @dev Sells `sellAmount` of `inputToken` to the liquidity provider\n    ///      at the given `provider` address.\n    /// @param inputToken The token being sold.\n    /// @param outputToken The token being bought.\n    /// @param provider The address of the on-chain liquidity provider\n    ///        to trade with.\n    /// @param recipient The recipient of the bought tokens. If equal to\n    ///        address(0), `msg.sender` is assumed to be the recipient.\n    /// @param sellAmount The amount of `inputToken` to sell.\n    /// @param minBuyAmount The minimum acceptable amount of `outputToken` to\n    ///        buy. Reverts if this amount is not satisfied.\n    /// @param auxiliaryData Auxiliary data supplied to the `provider` contract.\n    /// @return boughtAmount The amount of `outputToken` bought.\n    function sellToLiquidityProvider(\n        IERC20TokenV06 inputToken,\n        IERC20TokenV06 outputToken,\n        ILiquidityProvider provider,\n        address recipient,\n        uint256 sellAmount,\n        uint256 minBuyAmount,\n        bytes calldata auxiliaryData\n    )\n```\n\n- UniswapV3Feature - [sellTokenForTokenToUniswapV3](https://github.com/0xProject/protocol/blob/6f72a8e8e3306fa6cc77081547192c4f630ca316/contracts/zero-ex/contracts/src/features/UniswapV3Feature.sol#L160)\n\n```solidity\n    /// @dev Sell a token for another token directly against uniswap v3.\n    /// @param encodedPath Uniswap-encoded path.\n    /// @param sellAmount amount of the first token in the path to sell.\n    /// @param minBuyAmount Minimum amount of the last token in the path to buy.\n    /// @param recipient The recipient of the bought tokens. Can be zero for sender.\n    /// @return buyAmount Amount of the last token in the path bought.\n    function sellTokenForTokenToUniswapV3(\n        bytes memory encodedPath,\n        uint256 sellAmount,\n        uint256 minBuyAmount,\n        address recipient\n    )\n```\n\nThe malicious user could perform the following actions to steal the assets:\n\n- Allow malicious users to specify the recipient of the output/purchased tokens to be themselves instead of the vault. This will cause the output/purchased tokens of the trade to be redirected to the malicious users instead of the vault\n- Specify the `minBuyAmount` parameter of the order to `1 WEI` so that he only needs to provide `1 WEI` to fill the order to obtain all the secondary token (stETH) that need to be sold. This is allowed as there is no slippage control within 0x adaptor (Refer to my \"No Slippage Control If The Trade Executes Via 0x DEX During Emergency Vault Settlement\" issue write-up)\n\n## Impact\n\nAttackers can craft a 0x order that redirects the assets to their wallet, leading to loss of assets for the vaults and their users.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/trading/adapters/UniV2Adapter.sol#L12\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/trading/adapters/ZeroExAdapter.sol#L7\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIt is recommended to implement validation against the submitted 0x trade order to ensure that the recipient of the bought tokens is set to the vault when using the 0x DEX. Consider implementing the following validation checks.\n\n```solidity\nlibrary ZeroExAdapter {\n    /// @dev executeTrade validates pre and post trade balances and also\n    /// sets and revokes all approvals. We are also only calling a trusted\n    /// zero ex proxy in this case. Therefore no order validation is done\n    /// to allow for flexibility.\n    function getExecutionData(address from, Trade calldata trade)\n        internal view returns (\n            address spender,\n            address target,\n            uint256 /* msgValue */,\n            bytes memory executionCallData\n        )\n    {\n        spender = Deployments.ZERO_EX;\n        target = Deployments.ZERO_EX;\n\t\t\n\t\t_validateExchangeData(from, trade);\n\t\t\n        // msgValue is always zero\n        executionCallData = trade.exchangeData;\n    }\n\t\n\tfunction _validateExchangeData(address from, Trade calldata trade) internal pure {\n        bytes calldata _data = trade.exchangeData;\n\n        address inputToken;\n        address outputToken;\n        address recipient;\n        uint256 inputTokenAmount;\n        uint256 minOutputTokenAmount;\n\n\t\trequire(_data.length >= 4, \"Invalid calldata\");\n\t\tbytes4 selector;\n\t\tassembly {\n\t\t\tselector := and(\n\t\t\t\t// Read the first 4 bytes of the _data array from calldata.\n\t\t\t\tcalldataload(add(36, calldataload(164))), // 164 = 5 * 32 + 4\n\t\t\t\t0xffffffff00000000000000000000000000000000000000000000000000000000\n\t\t\t)\n\t\t}\n\t\t\n\t\tif (selector == 0xf7fcd384) {\n\t\t\t\n\t\t\t(\n\t\t\t\tinputToken, \n\t\t\t\toutputToken, \n\t\t\t\t, \n\t\t\t\trecipient, \n\t\t\t\tinputTokenAmount, \n\t\t\t\tminOutputTokenAmount\n\t\t\t) = abi.decode(_data[4:], (address, address, address, address, uint256, uint256));\n\t\t\trequire(recipient == from, \"Mismatched recipient\");\n\t\t} else if (selector == 0x6af479b2) {\n\t\t\t// sellTokenForTokenToUniswapV3()\n\t\t\tbytes memory encodedPath;\n\t\t\t// prettier-ignore\n\t\t\t(\n\t\t\t\tencodedPath,\n\t\t\t\tinputTokenAmount, \n\t\t\t\tminOutputTokenAmount, \n\t\t\t\trecipient\n\t\t\t) = abi.decode(_data[4:], (bytes, uint256, uint256, address));\n\t\t\trequire(recipient == from, \"Mismatched recipient\");\n\t\t}\n\t}\n}\n```\n\n## Discussion\n\n**jeffywu**\n\nThis looks valid\n\n**weitianjie2000**\n\nIt's not possible to redirect the proceeds because we validate the amount received at the end of the trade. However, we've decided to disable the 0x adapter for now pending further testing.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/2",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/trading/adapters/UniV2Adapter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"../../../interfaces/trading/ITradingModule.sol\";\nimport \"../../../interfaces/uniswap/v2/IUniV2Router2.sol\";\nimport {Deployments} from \"../../global/Deployments.sol\";\n\nlibrary UniV2Adapter {\n\n    struct UniV2Data { address[] path; }\n\n    function getExecutionData(address from, Trade calldata trade)\n        internal view returns (\n            address spender,\n            address target,\n            uint256 /* msgValue */,\n            bytes memory executionCallData\n        )\n    {\n        TradeType tradeType = trade.tradeType;\n        UniV2Data memory data = abi.decode(trade.exchangeData, (UniV2Data));\n\n        spender = address(Deployments.UNIV2_ROUTER);\n        target = address(Deployments.UNIV2_ROUTER);\n        // msgValue is always zero for uniswap\n\n        if (\n            tradeType == TradeType.EXACT_IN_SINGLE ||\n            tradeType == TradeType.EXACT_IN_BATCH\n        ) {\n            executionCallData = abi.encodeWithSelector(\n                IUniV2Router2.swapExactTokensForTokens.selector,\n                trade.amount,\n                trade.limit,\n                data.path,\n                from,\n                trade.deadline\n            );\n        } else if (\n            tradeType == TradeType.EXACT_OUT_SINGLE ||\n            tradeType == TradeType.EXACT_OUT_BATCH\n        ) {\n            executionCallData = abi.encodeWithSelector(\n                IUniV2Router2.swapTokensForExactTokens.selector,\n                trade.amount,\n                trade.limit,\n                data.path,\n                from,\n                trade.deadline\n            );\n        }\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/trading/adapters/ZeroExAdapter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {Deployments} from \"../../global/Deployments.sol\";\nimport {Trade} from \"../../../interfaces/trading/ITradingModule.sol\";\n\nlibrary ZeroExAdapter {\n    /// @dev executeTrade validates pre and post trade balances and also\n    /// sets and revokes all approvals. We are also only calling a trusted\n    /// zero ex proxy in this case. Therefore no order validation is done\n    /// to allow for flexibility.\n    function getExecutionData(address from, Trade calldata trade)\n        internal view returns (\n            address spender,\n            address target,\n            uint256 /* msgValue */,\n            bytes memory executionCallData\n        )\n    {\n        spender = Deployments.ZERO_EX;\n        target = Deployments.ZERO_EX;\n        // msgValue is always zero\n        executionCallData = trade.exchangeData;\n    }\n}"
    },
    {
      "filename": "contracts/zero-ex/contracts/src/features/LiquidityProviderFeature.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\n/*\n\n  Copyright 2020 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.6.5;\npragma experimental ABIEncoderV2;\n\nimport \"@0x/contracts-erc20/contracts/src/v06/IERC20TokenV06.sol\";\nimport \"@0x/contracts-utils/contracts/src/v06/errors/LibRichErrorsV06.sol\";\nimport \"@0x/contracts-utils/contracts/src/v06/LibSafeMathV06.sol\";\nimport \"@0x/contracts-erc20/contracts/src/v06/IERC20TokenV06.sol\";\nimport \"../errors/LibLiquidityProviderRichErrors.sol\";\nimport \"../external/ILiquidityProviderSandbox.sol\";\nimport \"../external/LiquidityProviderSandbox.sol\";\nimport \"../fixins/FixinCommon.sol\";\nimport \"../fixins/FixinTokenSpender.sol\";\nimport \"../migrations/LibMigrate.sol\";\nimport \"../transformers/LibERC20Transformer.sol\";\nimport \"./interfaces/IFeature.sol\";\nimport \"./interfaces/ILiquidityProviderFeature.sol\";\n\n\ncontract LiquidityProviderFeature is\n    IFeature,\n    ILiquidityProviderFeature,\n    FixinCommon,\n    FixinTokenSpender\n{\n    using LibSafeMathV06 for uint256;\n    using LibRichErrorsV06 for bytes;\n\n    /// @dev Name of this feature.\n    string public constant override FEATURE_NAME = \"LiquidityProviderFeature\";\n    /// @dev Version of this feature.\n    uint256 public immutable override FEATURE_VERSION = _encodeVersion(1, 0, 4);\n\n    /// @dev The sandbox contract address.\n    ILiquidityProviderSandbox public immutable sandbox;\n\n    constructor(LiquidityProviderSandbox sandbox_)\n        public\n        FixinCommon()\n    {\n        sandbox = sandbox_;\n    }\n\n    /// @dev Initialize and register this feature.\n    ///      Should be delegatecalled by `Migrate.migrate()`.\n    /// @return success `LibMigrate.SUCCESS` on success.\n    function migrate()\n        external\n        returns (bytes4 success)\n    {\n        _registerFeatureFunction(this.sellToLiquidityProvider.selector);\n        return LibMigrate.MIGRATE_SUCCESS;\n    }\n\n    /// @dev Sells `sellAmount` of `inputToken` to the liquidity provider\n    ///      at the given `provider` address.\n    /// @param inputToken The token being sold.\n    /// @param outputToken The token being bought.\n    /// @param provider The address of the on-chain liquidity provider\n    ///        to trade with.\n    /// @param recipient The recipient of the bought tokens. If equal to\n    ///        address(0), `msg.sender` is assumed to be the recipient.\n    /// @param sellAmount The amount of `inputToken` to sell.\n    /// @param minBuyAmount The minimum acceptable amount of `outputToken` to\n    ///        buy. Reverts if this amount is not satisfied.\n    /// @param auxiliaryData Auxiliary data supplied to the `provider` contract.\n    /// @return boughtAmount The amount of `outputToken` bought.\n    function sellToLiquidityProvider(\n        IERC20TokenV06 inputToken,\n        IERC20TokenV06 outputToken,\n        ILiquidityProvider provider,\n        address recipient,\n        uint256 sellAmount,\n        uint256 minBuyAmount,\n        bytes calldata auxiliaryData\n    )\n        external\n        override\n        payable\n        returns (uint256 boughtAmount)\n    {\n        if (recipient == address(0)) {\n            recipient = msg.sender;\n        }\n\n        // Forward all attached ETH to the provider.\n        if (msg.value > 0) {\n            payable(address(provider)).transfer(msg.value);\n        }\n\n        if (!LibERC20Transformer.isTokenETH(inputToken)) {\n            // Transfer input ERC20 tokens to the provider.\n            _transferERC20TokensFrom(\n                inputToken,\n                msg.sender,\n                address(provider),\n                sellAmount\n            );\n        }\n\n        if (LibERC20Transformer.isTokenETH(inputToken)) {\n            uint256 balanceBefore = outputToken.balanceOf(recipient);\n            sandbox.executeSellEthForToken(\n                provider,\n                outputToken,\n                recipient,\n                minBuyAmount,\n                auxiliaryData\n            );\n            boughtAmount = IERC20TokenV06(outputToken).balanceOf(recipient).safeSub(balanceBefore);\n        } else if (LibERC20Transformer.isTokenETH(outputToken)) {\n            uint256 balanceBefore = recipient.balance;\n            sandbox.executeSellTokenForEth(\n                provider,\n                inputToken,\n                recipient,\n                minBuyAmount,\n                auxiliaryData\n            );\n            boughtAmount = recipient.balance.safeSub(balanceBefore);\n        } else {\n            uint256 balanceBefore = outputToken.balanceOf(recipient);\n            sandbox.executeSellTokenForToken(\n                provider,\n                inputToken,\n                outputToken,\n                recipient,\n                minBuyAmount,\n                auxiliaryData\n            );\n            boughtAmount = outputToken.balanceOf(recipient).safeSub(balanceBefore);\n        }\n\n        if (boughtAmount < minBuyAmount) {\n            LibLiquidityProviderRichErrors.LiquidityProviderIncompleteSellError(\n                address(provider),\n                address(outputToken),\n                address(inputToken),\n                sellAmount,\n                boughtAmount,\n                minBuyAmount\n            ).rrevert();\n        }\n\n        emit LiquidityProviderSwap(\n            inputToken,\n            outputToken,\n            sellAmount,\n            boughtAmount,\n            provider,\n            recipient\n        );\n    }\n}"
    },
    {
      "filename": "contracts/zero-ex/contracts/src/features/UniswapV3Feature.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\n/*\n\n  Copyright 2021 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity ^0.6.5;\npragma experimental ABIEncoderV2;\n\nimport \"@0x/contracts-erc20/contracts/src/v06/IERC20TokenV06.sol\";\nimport \"@0x/contracts-erc20/contracts/src/v06/IEtherTokenV06.sol\";\nimport \"../vendor/IUniswapV3Pool.sol\";\nimport \"../migrations/LibMigrate.sol\";\nimport \"../fixins/FixinCommon.sol\";\nimport \"../fixins/FixinTokenSpender.sol\";\nimport \"./interfaces/IFeature.sol\";\nimport \"./interfaces/IUniswapV3Feature.sol\";\n\n\n/// @dev VIP uniswap fill functions.\ncontract UniswapV3Feature is\n    IFeature,\n    IUniswapV3Feature,\n    FixinCommon,\n    FixinTokenSpender\n{\n    /// @dev Name of this feature.\n    string public constant override FEATURE_NAME = \"UniswapV3Feature\";\n    /// @dev Version of this feature.\n    uint256 public immutable override FEATURE_VERSION = _encodeVersion(1, 1, 0);\n    /// @dev WETH contract.\n    IEtherTokenV06 private immutable WETH;\n    /// @dev UniswapV3 Factory contract address prepended with '0xff' and left-aligned.\n    bytes32 private immutable UNI_FF_FACTORY_ADDRESS;\n    /// @dev UniswapV3 pool init code hash.\n    bytes32 private immutable UNI_POOL_INIT_CODE_HASH;\n    /// @dev Minimum size of an encoded swap path:\n    ///      sizeof(address(inputToken) | uint24(fee) | address(outputToken))\n    uint256 private constant SINGLE_HOP_PATH_SIZE = 20 + 3 + 20;\n    /// @dev How many bytes to skip ahead in an encoded path to start at the next hop:\n    ///      sizeof(address(inputToken) | uint24(fee))\n    uint256 private constant PATH_SKIP_HOP_SIZE = 20 + 3;\n    /// @dev The size of the swap callback data.\n    uint256 private constant SWAP_CALLBACK_DATA_SIZE = 128;\n    /// @dev Minimum tick price sqrt ratio.\n    uint160 internal constant MIN_PRICE_SQRT_RATIO = 4295128739;\n    /// @dev Minimum tick price sqrt ratio.\n    uint160 internal constant MAX_PRICE_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n    /// @dev Mask of lower 20 bytes.\n    uint256 private constant ADDRESS_MASK = 0x00ffffffffffffffffffffffffffffffffffffffff;\n    /// @dev Mask of lower 3 bytes.\n    uint256 private constant UINT24_MASK = 0xffffff;\n\n    /// @dev Construct this contract.\n    /// @param weth The WETH contract.\n    /// @param uniFactory The UniswapV3 factory contract.\n    /// @param poolInitCodeHash The UniswapV3 pool init code hash.\n    constructor(\n        IEtherTokenV06 weth,\n        address uniFactory,\n        bytes32 poolInitCodeHash\n    ) public {\n        WETH = weth;\n        UNI_FF_FACTORY_ADDRESS = bytes32((uint256(0xff) << 248) | (uint256(uniFactory) << 88));\n        UNI_POOL_INIT_CODE_HASH = poolInitCodeHash;\n    }\n\n    /// @dev Initialize and register this feature.\n    ///      Should be delegatecalled by `Migrate.migrate()`.\n    /// @return success `LibMigrate.SUCCESS` on success.\n    function migrate()\n        external\n        returns (bytes4 success)\n    {\n        _registerFeatureFunction(this.sellEthForTokenToUniswapV3.selector);\n        _registerFeatureFunction(this.sellTokenForEthToUniswapV3.selector);\n        _registerFeatureFunction(this.sellTokenForTokenToUniswapV3.selector);\n        _registerFeatureFunction(this._sellHeldTokenForTokenToUniswapV3.selector);\n        _registerFeatureFunction(this.uniswapV3SwapCallback.selector);\n        return LibMigrate.MIGRATE_SUCCESS;\n    }\n\n    /// @dev Sell attached ETH directly against uniswap v3.\n    /// @param encodedPath Uniswap-encoded path, where the first token is WETH.\n    /// @param recipient The recipient of the bought tokens. Can be zero for sender.\n    /// @param minBuyAmount Minimum amount of the last token in the path to buy.\n    /// @return buyAmount Amount of the last token in the path bought.\n    function sellEthForTokenToUniswapV3(\n        bytes memory encodedPath,\n        uint256 minBuyAmount,\n        address recipient\n    )\n        public\n        payable\n        override\n        returns (uint256 buyAmount)\n    {\n        // Wrap ETH.\n        WETH.deposit{ value: msg.value }();\n        return _swap(\n            encodedPath,\n            msg.value,\n            minBuyAmount,\n            address(this), // we are payer because we hold the WETH\n            _normalizeRecipient(recipient)\n        );\n    }\n\n    /// @dev Sell a token for ETH directly against uniswap v3.\n    /// @param encodedPath Uniswap-encoded path, where the last token is WETH.\n    /// @param sellAmount amount of the first token in the path to sell.\n    /// @param minBuyAmount Minimum amount of ETH to buy.\n    /// @param recipient The recipient of the bought tokens. Can be zero for sender.\n    /// @return buyAmount Amount of ETH bought.\n    function sellTokenForEthToUniswapV3(\n        bytes memory encodedPath,\n        uint256 sellAmount,\n        uint256 minBuyAmount,\n        address payable recipient\n    )\n        public\n        override\n        returns (uint256 buyAmount)\n    {\n        buyAmount = _swap(\n            encodedPath,\n            sellAmount,\n            minBuyAmount,\n            msg.sender,\n            address(this) // we are recipient because we need to unwrap WETH\n        );\n        WETH.withdraw(buyAmount);\n        // Transfer ETH to recipient.\n        (bool success, bytes memory revertData) =\n            _normalizeRecipient(recipient).call{ value: buyAmount }(\"\");\n        if (!success) {\n            revertData.rrevert();\n        }\n    }\n\n    /// @dev Sell a token for another token directly against uniswap v3.\n    /// @param encodedPath Uniswap-encoded path.\n    /// @param sellAmount amount of the first token in the path to sell.\n    /// @param minBuyAmount Minimum amount of the last token in the path to buy.\n    /// @param recipient The recipient of the bought tokens. Can be zero for sender.\n    /// @return buyAmount Amount of the last token in the path bought.\n    function sellTokenForTokenToUniswapV3(\n        bytes memory encodedPath,\n        uint256 sellAmount,\n        uint256 minBuyAmount,\n        address recipient\n    )\n        public\n        override\n        returns (uint256 buyAmount)\n    {\n        buyAmount = _swap(\n            encodedPath,\n            sellAmount,\n            minBuyAmount,\n            msg.sender,\n            _normalizeRecipient(recipient)\n        );\n    }\n\n    /// @dev Sell a token for another token directly against uniswap v3.\n    ///      Private variant, uses tokens held by `address(this)`.\n    /// @param encodedPath Uniswap-encoded path.\n    /// @param sellAmount amount of the first token in the path to sell.\n    /// @param minBuyAmount Minimum amount of the last token in the path to buy.\n    /// @param recipient The recipient of the bought tokens. Can be zero for sender.\n    /// @return buyAmount Amount of the last token in the path bought.\n    function _sellHeldTokenForTokenToUniswapV3(\n        bytes memory encodedPath,\n        uint256 sellAmount,\n        uint256 minBuyAmount,\n        address recipient\n    )\n        public\n        override\n        onlySelf\n        returns (uint256 buyAmount)\n    {\n        buyAmount = _swap(\n            encodedPath,\n            sellAmount,\n            minBuyAmount,\n            address(this),\n            _normalizeRecipient(recipient)\n        );\n    }\n\n    /// @dev The UniswapV3 pool swap callback which pays the funds requested\n    ///      by the caller/pool to the pool. Can only be called by a valid\n    ///      UniswapV3 pool.\n    /// @param amount0Delta Token0 amount owed.\n    /// @param amount1Delta Token1 amount owed.\n    /// @param data Arbitrary data forwarded from swap() caller. An ABI-encoded\n    ///        struct of: inputToken, outputToken, fee, payer\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    )\n        external\n        override\n    {\n        IERC20TokenV06 token0;\n        IERC20TokenV06 token1;\n        address payer;\n        {\n            uint24 fee;\n            // Decode the data.\n            require(data.length == SWAP_CALLBACK_DATA_SIZE, \"UniswapFeature/INVALID_SWAP_CALLBACK_DATA\");\n            assembly {\n                let p := add(36, calldataload(68))\n                token0 := calldataload(p)\n                token1 := calldataload(add(p, 32))\n                fee := calldataload(add(p, 64))\n                payer := calldataload(add(p, 96))\n            }\n            (token0, token1) = token0 < token1\n                ? (token0, token1)\n                : (token1, token0);\n            // Only a valid pool contract can call this function.\n            require(\n                msg.sender == address(_toPool(token0, fee, token1)),\n                \"UniswapV3Feature/INVALID_SWAP_CALLBACK_CALLER\"\n            );\n        }\n        // Pay the amount owed to the pool.\n        if (amount0Delta > 0) {\n            _pay(token0, payer, msg.sender, uint256(amount0Delta));\n        } else if (amount1Delta > 0) {\n            _pay(token1, payer, msg.sender, uint256(amount1Delta));\n        } else {\n            revert(\"UniswapV3Feature/INVALID_SWAP_AMOUNTS\");\n        }\n    }\n\n    // Executes successive swaps along an encoded uniswap path.\n    function _swap(\n        bytes memory encodedPath,\n        uint256 sellAmount,\n        uint256 minBuyAmount,\n        address payer,\n        address recipient\n    )\n        private\n        returns (uint256 buyAmount)\n    {\n        if (sellAmount != 0) {\n            require(sellAmount <= uint256(type(int256).max), \"UniswapV3Feature/SELL_AMOUNT_OVERFLOW\");\n\n            // Perform a swap for each hop in the path.\n            bytes memory swapCallbackData = new bytes(SWAP_CALLBACK_DATA_SIZE);\n            while (true) {\n                bool isPathMultiHop = _isPathMultiHop(encodedPath);\n                bool zeroForOne;\n                IUniswapV3Pool pool;\n                {\n                    (\n                        IERC20TokenV06 inputToken,\n                        uint24 fee,\n                        IERC20TokenV06 outputToken\n                    ) = _decodeFirstPoolInfoFromPath(encodedPath);\n                    pool = _toPool(inputToken, fee, outputToken);\n                    zeroForOne = inputToken < outputToken;\n                    _updateSwapCallbackData(\n                        swapCallbackData,\n                        inputToken,\n                        outputToken,\n                        fee,\n                        payer\n                    );\n                }\n                (int256 amount0, int256 amount1) = pool.swap(\n                    // Intermediate tokens go to this contract.\n                    isPathMultiHop ? address(this) : recipient,\n                    zeroForOne,\n                    int256(sellAmount),\n                    zeroForOne\n                        ? MIN_PRICE_SQRT_RATIO + 1\n                        : MAX_PRICE_SQRT_RATIO - 1,\n                    swapCallbackData\n                );\n                {\n                    int256 _buyAmount = -(zeroForOne ? amount1 : amount0);\n                    require(_buyAmount >= 0, \"UniswapV3Feature/INVALID_BUY_AMOUNT\");\n                    buyAmount = uint256(_buyAmount);\n                }\n                if (!isPathMultiHop) {\n                    // Done.\n                    break;\n                }\n                // Continue with next hop.\n                payer = address(this); // Subsequent hops are paid for by us.\n                sellAmount = buyAmount;\n                // Skip to next hop along path.\n                encodedPath = _shiftHopFromPathInPlace(encodedPath);\n            }\n        }\n        require(minBuyAmount <= buyAmount, \"UniswapV3Feature/UNDERBOUGHT\");\n    }\n\n    // Pay tokens from `payer` to `to`, using `transferFrom()` if\n    // `payer` != this contract.\n    function _pay(\n        IERC20TokenV06 token,\n        address payer,\n        address to,\n        uint256 amount\n    )\n        private\n    {\n        if (payer != address(this)) {\n            _transferERC20TokensFrom(token, payer, to, amount);\n        } else {\n            _transferERC20Tokens(token, to, amount);\n        }\n    }\n\n    // Update `swapCallbackData` in place with new values.\n    function _updateSwapCallbackData(\n        bytes memory swapCallbackData,\n        IERC20TokenV06 inputToken,\n        IERC20TokenV06 outputToken,\n        uint24 fee,\n        address payer\n    )\n        private\n        pure\n    {\n        assembly {\n            let p := add(swapCallbackData, 32)\n            mstore(p, inputToken)\n            mstore(add(p, 32), outputToken)\n            mstore(add(p, 64), and(UINT24_MASK, fee))\n            mstore(add(p, 96), and(ADDRESS_MASK, payer))\n        }\n    }\n\n    // Compute the pool address given two tokens and a fee.\n    function _toPool(\n        IERC20TokenV06 inputToken,\n        uint24 fee,\n        IERC20TokenV06 outputToken\n    )\n        private\n        view\n        returns (IUniswapV3Pool pool)\n    {\n        // address(keccak256(abi.encodePacked(\n        //     hex\"ff\",\n        //     UNI_FACTORY_ADDRESS,\n        //     keccak256(abi.encode(inputToken, outputToken, fee)),\n        //     UNI_POOL_INIT_CODE_HASH\n        // )))\n        bytes32 ffFactoryAddress = UNI_FF_FACTORY_ADDRESS;\n        bytes32 poolInitCodeHash = UNI_POOL_INIT_CODE_HASH;\n        (IERC20TokenV06 token0, IERC20TokenV06 token1) = inputToken < outputToken\n            ? (inputToken, outputToken)\n            : (outputToken, inputToken);\n        assembly {\n            let s := mload(0x40)\n            let p := s\n            mstore(p, ffFactoryAddress)\n            p := add(p, 21)\n            // Compute the inner hash in-place\n                mstore(p, token0)\n                mstore(add(p, 32), token1)\n                mstore(add(p, 64), and(UINT24_MASK, fee))\n                mstore(p, keccak256(p, 96))\n            p := add(p, 32)\n            mstore(p, poolInitCodeHash)\n            pool := and(ADDRESS_MASK, keccak256(s, 85))\n        }\n    }\n\n    // Return whether or not an encoded uniswap path contains more than one hop.\n    function _isPathMultiHop(bytes memory encodedPath)\n        private\n        pure\n        returns (bool isMultiHop)\n    {\n        return encodedPath.length > SINGLE_HOP_PATH_SIZE;\n    }\n\n\n    // Return the first input token, output token, and fee of an encoded uniswap path.\n    function _decodeFirstPoolInfoFromPath(bytes memory encodedPath)\n        private\n        pure\n        returns (\n            IERC20TokenV06 inputToken,\n            uint24 fee,\n            IERC20TokenV06 outputToken\n        )\n    {\n        require(encodedPath.length >= SINGLE_HOP_PATH_SIZE, \"UniswapV3Feature/BAD_PATH_ENCODING\");\n        assembly {\n            let p := add(encodedPath, 32)\n            inputToken := shr(96, mload(p))\n            p := add(p, 20)\n            fee := shr(232, mload(p))\n            p := add(p, 3)\n            outputToken := shr(96, mload(p))\n        }\n    }\n\n    // Skip past the first hop of an encoded uniswap path in-place.\n    function _shiftHopFromPathInPlace(bytes memory encodedPath)\n        private\n        pure\n        returns (bytes memory shiftedEncodedPath)\n    {\n        require(encodedPath.length >= PATH_SKIP_HOP_SIZE, \"UniswapV3Feature/BAD_PATH_ENCODING\");\n        uint256 shiftSize = PATH_SKIP_HOP_SIZE;\n        uint256 newSize = encodedPath.length - shiftSize;\n        assembly {\n            shiftedEncodedPath := add(encodedPath, shiftSize)\n            mstore(shiftedEncodedPath, newSize)\n        }\n    }\n\n    // Convert null address values to msg.sender.\n    function _normalizeRecipient(address recipient)\n        private\n        view\n        returns (address payable normalizedRecipient)\n    {\n        return recipient == address(0) ? msg.sender : payable(recipient);\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/trading/adapters/UniV2Adapter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"../../../interfaces/trading/ITradingModule.sol\";\nimport \"../../../interfaces/uniswap/v2/IUniV2Router2.sol\";\nimport {Deployments} from \"../../global/Deployments.sol\";\n\nlibrary UniV2Adapter {\n\n    struct UniV2Data { address[] path; }\n\n    function getExecutionData(address from, Trade calldata trade)\n        internal view returns (\n            address spender,\n            address target,\n            uint256 /* msgValue */,\n            bytes memory executionCallData\n        )\n    {\n        TradeType tradeType = trade.tradeType;\n        UniV2Data memory data = abi.decode(trade.exchangeData, (UniV2Data));\n\n        spender = address(Deployments.UNIV2_ROUTER);\n        target = address(Deployments.UNIV2_ROUTER);\n        // msgValue is always zero for uniswap\n\n        if (\n            tradeType == TradeType.EXACT_IN_SINGLE ||\n            tradeType == TradeType.EXACT_IN_BATCH\n        ) {\n            executionCallData = abi.encodeWithSelector(\n                IUniV2Router2.swapExactTokensForTokens.selector,\n                trade.amount,\n                trade.limit,\n                data.path,\n                from,\n                trade.deadline\n            );\n        } else if (\n            tradeType == TradeType.EXACT_OUT_SINGLE ||\n            tradeType == TradeType.EXACT_OUT_BATCH\n        ) {\n            executionCallData = abi.encodeWithSelector(\n                IUniV2Router2.swapTokensForExactTokens.selector,\n                trade.amount,\n                trade.limit,\n                data.path,\n                from,\n                trade.deadline\n            );\n        }\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/trading/adapters/ZeroExAdapter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {Deployments} from \"../../global/Deployments.sol\";\nimport {Trade} from \"../../../interfaces/trading/ITradingModule.sol\";\n\nlibrary ZeroExAdapter {\n    /// @dev executeTrade validates pre and post trade balances and also\n    /// sets and revokes all approvals. We are also only calling a trusted\n    /// zero ex proxy in this case. Therefore no order validation is done\n    /// to allow for flexibility.\n    function getExecutionData(address from, Trade calldata trade)\n        internal view returns (\n            address spender,\n            address target,\n            uint256 /* msgValue */,\n            bytes memory executionCallData\n        )\n    {\n        spender = Deployments.ZERO_EX;\n        target = Deployments.ZERO_EX;\n        // msgValue is always zero\n        executionCallData = trade.exchangeData;\n    }\n}"
    }
  ]
}