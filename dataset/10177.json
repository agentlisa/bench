{
  "Title": "[M-04] Underflow problems occurring when a token has >18 decimals",
  "Content": "_Submitted by tensors, also found by s1m0_\n\nThe contracts assume that all tokens will have <=18 decimals. This isn't necessarily a problem if the Tracer team is the only people deploying the contracts and they keep it in mind. But, If the contracts are to be deployed by other people, this assumption should be made explicit and hard-coded.\n\nWe can see that the scaler computations will underflow and be defined when it should not be In [L220-L232](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibBalances.sol#L220-L232).\n\nRecommend writing a require check that ensures `tokenDecimals <= 18` before running the above functions.\n\n**[raymogg (Tracer) confirmed](https://github.com/code-423n4/2021-06-tracer-findings/issues/116#issuecomment-873755853):**\n > Valid issue and makes sense as a medium.\n>\n> Suggested mitigation will be implemented.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2021-06-tracer",
  "Code": [
    {
      "filename": "src/contracts/lib/LibBalances.sol",
      "content": "//SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"./LibMath.sol\";\nimport \"../Interfaces/Types.sol\";\nimport \"prb-math/contracts/PRBMathSD59x18.sol\";\nimport \"prb-math/contracts/PRBMathUD60x18.sol\";\nimport \"./LibPerpetuals.sol\";\n\nlibrary Balances {\n    using LibMath for int256;\n    using LibMath for uint256;\n    using PRBMathSD59x18 for int256;\n    using PRBMathUD60x18 for uint256;\n\n    uint256 public constant MAX_DECIMALS = 18;\n\n    // Size of a position\n    struct Position {\n        int256 quote;\n        int256 base;\n    }\n\n    // Information about a trade\n    struct Trade {\n        uint256 price;\n        uint256 amount;\n        Perpetuals.Side side;\n    }\n\n    // Contains information about the balance of an account in a Tracer market\n    struct Account {\n        Position position;\n        uint256 totalLeveragedValue;\n        uint256 lastUpdatedIndex;\n        uint256 lastUpdatedGasPrice;\n    }\n\n    /**\n     * @notice Calculates the notional value of a position as base * price\n     * @param position the position the account is currently in\n     * @param price The (fair) price of the base asset\n     * @return Notional value of a position given the price\n     */\n    function notionalValue(Position memory position, uint256 price) internal pure returns (uint256) {\n        /* cast is safe due to semantics of `abs` */\n        return PRBMathUD60x18.mul(uint256(PRBMathSD59x18.abs(position.base)), price);\n    }\n\n    /**\n     * @notice Calculates the margin as quote + base * base_price\n     * @param position The position the account is currently in\n     * @param price The price of the base asset\n     * @return Margin of the position\n     */\n    function margin(Position memory position, uint256 price) internal pure returns (int256) {\n        /*\n         * A cast *must* occur somewhere here in order for this to type check.\n         *\n         * After you've convinced yourself of this, the next intellectual jump\n         * that needs to be made is *what* to cast. We can't cast `quote` as it's\n         * allowed to be negative. We can't cast `base` as it's allowed to be\n         * negative. Thus, by elimination, the only thing we're left with is\n         * `price`.\n         *\n         * `price` has type `uint256` (i.e., it's unsigned). Thus, our below\n         * cast **will** throw iff. `price >= type(int256).max()`.\n         */\n        int256 signedPrice = LibMath.toInt256(price);\n        return position.quote + PRBMathSD59x18.mul(position.base, signedPrice);\n    }\n\n    /**\n     * @notice Calculates the notional value. i.e. the absolute value of a position\n     * @param position The position the account is currently in\n     * @param price The price of the base asset\n     */\n    function leveragedNotionalValue(Position memory position, uint256 price) internal pure returns (uint256) {\n        uint256 _notionalValue = notionalValue(position, price);\n        int256 marginValue = margin(position, price);\n\n        int256 signedNotionalValue = LibMath.toInt256(_notionalValue);\n\n        if (signedNotionalValue - marginValue < 0) {\n            return 0;\n        } else {\n            return uint256(signedNotionalValue - marginValue);\n        }\n    }\n\n    /**\n     * @notice Calculates the minimum margin needed for an account.\n     * Calculated as minMargin = notionalValue / maxLev + 6 * liquidationGasCost\n     *                         = (base * price) / maxLev + 6 * liquidationGasCost\n     * @param position Position to calculate the minimum margin for\n     * @param price Price by which to evaluate the minimum margin\n     * @param liquidationGasCost Cost for liquidation denominated in quote tokens\n     * @param maximumLeverage (True) maximum leverage of a market.\n     *   May be less than the set max leverage of the market because\n     *   of deleveraging\n     * @return Minimum margin of the position given the parameters\n     */\n    function minimumMargin(\n        Position memory position,\n        uint256 price,\n        uint256 liquidationGasCost,\n        uint256 maximumLeverage\n    ) internal pure returns (uint256) {\n        // There should be no Minimum margin when user has no position\n        if (position.base == 0) {\n            return 0;\n        }\n\n        uint256 _notionalValue = notionalValue(position, price);\n\n        uint256 adjustedLiquidationGasCost = liquidationGasCost * 6;\n\n        uint256 minimumMarginWithoutGasCost = PRBMathUD60x18.div(_notionalValue, maximumLeverage);\n\n        return adjustedLiquidationGasCost + minimumMarginWithoutGasCost;\n    }\n\n    /**\n     * @notice Checks the validity of a potential margin given the necessary parameters\n     * @param position The position\n     * @param liquidationGasCost The cost of calling liquidate\n     * @return a bool representing the validity of a margin\n     */\n    function marginIsValid(\n        Balances.Position memory position,\n        uint256 liquidationGasCost,\n        uint256 price,\n        uint256 trueMaxLeverage\n    ) internal pure returns (bool) {\n        uint256 minMargin = minimumMargin(position, price, liquidationGasCost, trueMaxLeverage);\n        int256 _margin = margin(position, price);\n\n        if (_margin < 0) {\n            /* Margin being less than 0 is always invalid, even if position is 0.\n               This could happen if user attempts to over-withdraw */\n            return false;\n        }\n\n        return (uint256(_margin) >= minMargin);\n    }\n\n    /**\n     * @notice Gets the amount that can be matched between two orders\n     *         Calculated as min(amountRemaining)\n     * @param orderA First order\n     * @param fillA Amount of the first order that has been filled\n     * @param orderB Second order\n     * @param fillB Amount of the second order that has been filled\n     * @return Amount matched between two orders\n     */\n    function fillAmount(\n        Perpetuals.Order memory orderA,\n        uint256 fillA,\n        Perpetuals.Order memory orderB,\n        uint256 fillB\n    ) internal pure returns (uint256) {\n        return LibMath.min(orderA.amount - fillA, orderB.amount - fillB);\n    }\n\n    /**\n     * @notice Applies changes to a position given a trade\n     * @param position Position of the people giving the trade\n     * @param trade Amount of the first order that has been filled\n     * @param feeRate Fee rate being applied to the trade\n     * @return New position\n     */\n    function applyTrade(\n        Position memory position,\n        Trade memory trade,\n        uint256 feeRate\n    ) internal pure returns (Position memory) {\n        int256 signedAmount = LibMath.toInt256(trade.amount);\n        int256 signedPrice = LibMath.toInt256(trade.price);\n        int256 quoteChange = PRBMathSD59x18.mul(signedAmount, signedPrice);\n        int256 fee = getFee(trade.amount, trade.price, feeRate);\n\n        int256 newQuote = 0;\n        int256 newBase = 0;\n\n        if (trade.side == Perpetuals.Side.Long) {\n            newBase = position.base + signedAmount;\n            newQuote = position.quote - quoteChange + fee;\n        } else if (trade.side == Perpetuals.Side.Short) {\n            newBase = position.base - signedAmount;\n            newQuote = position.quote + quoteChange - fee;\n        }\n\n        Position memory newPosition = Position(newQuote, newBase);\n\n        return newPosition;\n    }\n\n    /**\n     * @notice Calculates the fee (in quote tokens)\n     * @param amount The position (in base tokens)\n     * @param executionPrice The execution price (denominated in quote/base)\n     * @param feeRate Fee rate being applied to the trade (a %, in WAD)\n     * @return Value of the fee being applied to the trade\n     */\n    function getFee(\n        uint256 amount,\n        uint256 executionPrice,\n        uint256 feeRate\n    ) internal pure returns (int256) {\n        uint256 quoteChange = PRBMathUD60x18.mul(amount, executionPrice);\n\n        int256 fee = PRBMathUD60x18.mul(quoteChange, feeRate).toInt256();\n        return fee;\n    }\n\n    /**\n     * @notice converts a raw token amount to its WAD representation. Used for tokens\n     * that don't have 18 decimal places\n     */\n    function tokenToWad(uint256 tokenDecimals, uint256 amount) internal pure returns (int256) {\n        uint256 scaler = 10**(MAX_DECIMALS - tokenDecimals);\n        return amount.toInt256() * scaler.toInt256();\n    }\n\n    /**\n     * @notice converts a wad token amount to its raw representation.\n     */\n    function wadToToken(uint256 tokenDecimals, uint256 wadAmount) internal pure returns (uint256) {\n        uint256 scaler = uint256(10**(MAX_DECIMALS - tokenDecimals));\n        return uint256(wadAmount / scaler);\n    }\n}"
    }
  ]
}