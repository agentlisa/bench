{
  "Title": "H-3: `TradingUtils::_executeTrade` will leak ETH to WETH",
  "Content": "# Issue H-3: `TradingUtils::_executeTrade` will leak ETH to WETH \n\nSource: https://github.com/sherlock-audit/2022-09-notional-judging/issues/98 \n\n## Found by \nlemonmon\n\n## Summary\n\nIf sellToken is ETH, and using Uniswap for the dex, and it is exact out trade, too much is deposited to the WETH and does not withdraw the excess amount. It will give wrong `amountSold` value as well as accounting error.\n\n## Vulnerability Detail\n\n`trade.sellToken` is ETH and using Uniswap as dex, WETH should be used instead of ETH as Uniswap does not support ETH. There for TradingUtils wraps the ETH to WETH before trading.\n\nIf the trade would be exact out, the amount `trade.limit` will be deposited to WETH instead of the `trade.amount`. However, because it is exact out, not all ETH deposited will be traded. In the current implementation, there is no logic to recover the excess deposit.\n\nAs the `TradingUtils::_executeInternal`, which uses the `TradingUtils::_executeTrade` will calculate the `amountSold` based on the balance of ETH, it will return the `trade.limit` as the `amountSold`, thus resulting in accounting error.\n\nNote: in the current implementation, the trade using Uniswap with ETH as sellToken would not even work, because the WETH is not properly approved (issue 2). This issue assumes that the issue is resolved. \n\n## Impact\n\n`amountSold` will reflect not the amount really sold, rather the `trade.limit`. It is unclear whether the excess amount of ETH, which is deposited for WETH can be recovered.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/trading/TradingUtils.sol?plain=1#L118-L137\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/trading/TradingUtils.sol?plain=1#L29-L64\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIn the `_executeTrade`, if the sellToken is ETH and it is exact out trade, recover excess deposit.\n\n\n## Discussion\n\n**jeffywu**\n\n@Evert0x I don't think this is a duplicate of #110\n\n**weitianjie2000**\n\nlegit issue, will be fixed\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/2",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/trading/TradingUtils.sol?plain=1",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {Deployments} from \"../global/Deployments.sol\";\nimport {Constants} from \"../global/Constants.sol\";\nimport {TokenUtils, IERC20} from \"../utils/TokenUtils.sol\";\nimport \"../../interfaces/trading/IVaultExchange.sol\";\nimport \"../../interfaces/trading/ITradingModule.sol\";\nimport {nProxy} from \"../proxy/nProxy.sol\";\n\n/// @notice Utility library used by the trading module\nlibrary TradingUtils {\n    using TokenUtils for IERC20;\n\n    error ERC20Error();\n    error TradeExecution(bytes returnData);\n    error PreValidationExactIn(uint256 maxAmountIn, uint256 preTradeSellBalance);\n    error PreValidationExactOut(uint256 maxAmountIn, uint256 preTradeSellBalance);\n    error PostValidationExactIn(uint256 minAmountOut, uint256 amountReceived);\n    error PostValidationExactOut(uint256 exactAmountOut, uint256 amountReceived);\n\n    event TradeExecuted(\n        address indexed sellToken,\n        address indexed buyToken,\n        uint256 sellAmount,\n        uint256 buyAmount\n    );\n\n    function _executeInternal(\n        Trade memory trade,\n        uint16 dexId,\n        address spender,\n        address target,\n        uint256 msgValue,\n        bytes memory executionData\n    ) internal returns (uint256 amountSold, uint256 amountBought) {\n        // Get pre-trade token balances\n        (uint256 preTradeSellBalance, uint256 preTradeBuyBalance) = _getBalances(trade);\n\n        // Make sure we have enough tokens to sell\n        _preValidate(trade, preTradeSellBalance);\n\n        // No need to approve ETH trades\n        if (spender != Deployments.ETH_ADDRESS && DexId(dexId) != DexId.NOTIONAL_VAULT) {\n            _approve(trade, spender);\n        }\n\n        _executeTrade(target, msgValue, executionData, spender, trade);\n\n        // Get post-trade token balances\n        (uint256 postTradeSellBalance, uint256 postTradeBuyBalance) = _getBalances(trade);\n\n        _postValidate(trade, postTradeBuyBalance - preTradeBuyBalance);\n\n        // No need to revoke ETH trades\n        if (spender != Deployments.ETH_ADDRESS && DexId(dexId) != DexId.NOTIONAL_VAULT) {\n            IERC20(trade.sellToken).checkRevoke(spender);\n        }\n\n        amountSold = preTradeSellBalance - postTradeSellBalance;\n        amountBought = postTradeBuyBalance - preTradeBuyBalance;\n\n        emit TradeExecuted(trade.sellToken, trade.buyToken, amountSold, amountBought);\n    }\n\n    function _getBalances(Trade memory trade) private view returns (uint256, uint256) {\n        return (\n            trade.sellToken == Deployments.ETH_ADDRESS\n                ? address(this).balance\n                : IERC20(trade.sellToken).balanceOf(address(this)),\n            trade.buyToken == Deployments.ETH_ADDRESS\n                ? address(this).balance\n                : IERC20(trade.buyToken).balanceOf(address(this))\n        );\n    }\n\n    function _isExactIn(Trade memory trade) private pure returns (bool) {\n        return\n            trade.tradeType == TradeType.EXACT_IN_SINGLE ||\n            trade.tradeType == TradeType.EXACT_IN_BATCH;\n    }\n\n    function _isExactOut(Trade memory trade) private pure returns (bool) {\n        return\n            trade.tradeType == TradeType.EXACT_OUT_SINGLE ||\n            trade.tradeType == TradeType.EXACT_OUT_BATCH;\n    }\n\n    function _preValidate(Trade memory trade, uint256 preTradeSellBalance) private pure {\n        if (_isExactIn(trade) && preTradeSellBalance < trade.amount) {\n            revert PreValidationExactIn(trade.amount, preTradeSellBalance);\n        } \n        \n        if (_isExactOut(trade) && preTradeSellBalance < trade.limit) {\n            // NOTE: this implies that vaults cannot execute market trades on exact out\n            revert PreValidationExactOut(trade.limit, preTradeSellBalance);\n        }\n    }\n\n    function _postValidate(Trade memory trade, uint256 amountReceived) private pure {\n        if (_isExactIn(trade) && amountReceived < trade.limit) {\n            revert PostValidationExactIn(trade.limit, amountReceived);\n        }\n\n        if (_isExactOut(trade) && amountReceived != trade.amount) {\n            revert PostValidationExactOut(trade.amount, amountReceived);\n        }\n    }\n\n    /// @notice Approve exchange to pull from this contract\n    /// @dev approve up to trade.amount for EXACT_IN trades and up to trade.limit\n    /// for EXACT_OUT trades\n    function _approve(Trade memory trade, address spender) private {\n        uint256 allowance = _isExactIn(trade) ? trade.amount : trade.limit;\n        IERC20(trade.sellToken).checkApprove(spender, allowance);\n    }\n\n    function _executeTrade(\n        address target,\n        uint256 msgValue,\n        bytes memory params,\n        address spender,\n        Trade memory trade\n    ) private {\n        uint256 preTradeBalance;\n\n        if (trade.sellToken == address(Deployments.WETH) && spender == Deployments.ETH_ADDRESS) {\n            preTradeBalance = address(this).balance;\n            // Curve doesn't support Deployments.WETH (spender == address(0))\n            uint256 withdrawAmount = _isExactIn(trade) ? trade.amount : trade.limit;\n            Deployments.WETH.withdraw(withdrawAmount);\n        } else if (trade.sellToken == Deployments.ETH_ADDRESS && spender != Deployments.ETH_ADDRESS) {\n            preTradeBalance = IERC20(address(Deployments.WETH)).balanceOf(address(this));\n            // UniswapV3 doesn't support ETH (spender != address(0))\n            uint256 depositAmount = _isExactIn(trade) ? trade.amount : trade.limit;\n            Deployments.WETH.deposit{value: depositAmount }();\n        }\n\n        (bool success, bytes memory returnData) = target.call{value: msgValue}(params);\n        if (!success) revert TradeExecution(returnData);\n\n        if (trade.buyToken == address(Deployments.WETH)) {\n            if (address(this).balance > preTradeBalance) {\n                // If the caller specifies that they want to receive Deployments.WETH but we have received ETH,\n                // wrap the ETH to Deployments.WETH.\n                uint256 depositAmount;\n                unchecked { depositAmount = address(this).balance - preTradeBalance; }\n                Deployments.WETH.deposit{value: depositAmount}();\n            }\n        } else if (trade.buyToken == Deployments.ETH_ADDRESS) {\n            uint256 postTradeBalance = IERC20(address(Deployments.WETH)).balanceOf(address(this));\n            if (postTradeBalance > preTradeBalance) {\n                // If the caller specifies that they want to receive ETH but we have received Deployments.WETH,\n                // unwrap the Deployments.WETH to ETH.\n                uint256 withdrawAmount;\n                unchecked { withdrawAmount = postTradeBalance - preTradeBalance; }\n                Deployments.WETH.withdraw(withdrawAmount);\n            }\n        }\n    }\n\n    function _getLimitAmount(\n        TradeType tradeType,\n        address sellToken,\n        address buyToken,\n        uint256 amount,\n        uint32 slippageLimit,\n        uint256 oraclePrice,\n        uint256 oracleDecimals\n    ) internal view returns (uint256 limitAmount) {\n        uint256 sellTokenDecimals = 10 **\n            (\n                sellToken == Deployments.ETH_ADDRESS\n                    ? 18\n                    : IERC20(sellToken).decimals()\n            );\n        uint256 buyTokenDecimals = 10 **\n            (\n                buyToken == Deployments.ETH_ADDRESS\n                    ? 18\n                    : IERC20(buyToken).decimals()\n            );\n\n        if (tradeType == TradeType.EXACT_OUT_SINGLE || tradeType == TradeType.EXACT_OUT_BATCH) {\n            // 0 means no slippage limit\n            if (slippageLimit == 0) {\n                return type(uint256).max;\n            }\n            // For exact out trades, we need to invert the oracle price (1 / oraclePrice)\n            // We increase the precision before we divide because oraclePrice is in\n            // oracle decimals\n            oraclePrice = (oracleDecimals * oracleDecimals) / oraclePrice;\n            // For exact out trades, limitAmount is the max amount of sellToken the DEX can\n            // pull from the contract\n            limitAmount =\n                ((oraclePrice + \n                    ((oraclePrice * uint256(slippageLimit)) /\n                        Constants.SLIPPAGE_LIMIT_PRECISION)) * amount) / \n                oracleDecimals;\n\n            // limitAmount is in buyToken precision after the previous calculation,\n            // convert it to sellToken precision\n            limitAmount = (limitAmount * sellTokenDecimals) / buyTokenDecimals;\n        } else {\n            // 0 means no slippage limit\n            if (slippageLimit == 0) {\n                return 0;\n            }\n            // For exact in trades, limitAmount is the min amount of buyToken the contract\n            // expects from the DEX\n            limitAmount =\n                ((oraclePrice -\n                    ((oraclePrice * uint256(slippageLimit)) /\n                        Constants.SLIPPAGE_LIMIT_PRECISION)) * amount) /\n                oracleDecimals;\n\n            // limitAmount is in sellToken precision after the previous calculation,\n            // convert it to buyToken precision\n            limitAmount = (limitAmount * buyTokenDecimals) / sellTokenDecimals;\n        }\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/trading/TradingUtils.sol?plain=1",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {Deployments} from \"../global/Deployments.sol\";\nimport {Constants} from \"../global/Constants.sol\";\nimport {TokenUtils, IERC20} from \"../utils/TokenUtils.sol\";\nimport \"../../interfaces/trading/IVaultExchange.sol\";\nimport \"../../interfaces/trading/ITradingModule.sol\";\nimport {nProxy} from \"../proxy/nProxy.sol\";\n\n/// @notice Utility library used by the trading module\nlibrary TradingUtils {\n    using TokenUtils for IERC20;\n\n    error ERC20Error();\n    error TradeExecution(bytes returnData);\n    error PreValidationExactIn(uint256 maxAmountIn, uint256 preTradeSellBalance);\n    error PreValidationExactOut(uint256 maxAmountIn, uint256 preTradeSellBalance);\n    error PostValidationExactIn(uint256 minAmountOut, uint256 amountReceived);\n    error PostValidationExactOut(uint256 exactAmountOut, uint256 amountReceived);\n\n    event TradeExecuted(\n        address indexed sellToken,\n        address indexed buyToken,\n        uint256 sellAmount,\n        uint256 buyAmount\n    );\n\n    function _executeInternal(\n        Trade memory trade,\n        uint16 dexId,\n        address spender,\n        address target,\n        uint256 msgValue,\n        bytes memory executionData\n    ) internal returns (uint256 amountSold, uint256 amountBought) {\n        // Get pre-trade token balances\n        (uint256 preTradeSellBalance, uint256 preTradeBuyBalance) = _getBalances(trade);\n\n        // Make sure we have enough tokens to sell\n        _preValidate(trade, preTradeSellBalance);\n\n        // No need to approve ETH trades\n        if (spender != Deployments.ETH_ADDRESS && DexId(dexId) != DexId.NOTIONAL_VAULT) {\n            _approve(trade, spender);\n        }\n\n        _executeTrade(target, msgValue, executionData, spender, trade);\n\n        // Get post-trade token balances\n        (uint256 postTradeSellBalance, uint256 postTradeBuyBalance) = _getBalances(trade);\n\n        _postValidate(trade, postTradeBuyBalance - preTradeBuyBalance);\n\n        // No need to revoke ETH trades\n        if (spender != Deployments.ETH_ADDRESS && DexId(dexId) != DexId.NOTIONAL_VAULT) {\n            IERC20(trade.sellToken).checkRevoke(spender);\n        }\n\n        amountSold = preTradeSellBalance - postTradeSellBalance;\n        amountBought = postTradeBuyBalance - preTradeBuyBalance;\n\n        emit TradeExecuted(trade.sellToken, trade.buyToken, amountSold, amountBought);\n    }\n\n    function _getBalances(Trade memory trade) private view returns (uint256, uint256) {\n        return (\n            trade.sellToken == Deployments.ETH_ADDRESS\n                ? address(this).balance\n                : IERC20(trade.sellToken).balanceOf(address(this)),\n            trade.buyToken == Deployments.ETH_ADDRESS\n                ? address(this).balance\n                : IERC20(trade.buyToken).balanceOf(address(this))\n        );\n    }\n\n    function _isExactIn(Trade memory trade) private pure returns (bool) {\n        return\n            trade.tradeType == TradeType.EXACT_IN_SINGLE ||\n            trade.tradeType == TradeType.EXACT_IN_BATCH;\n    }\n\n    function _isExactOut(Trade memory trade) private pure returns (bool) {\n        return\n            trade.tradeType == TradeType.EXACT_OUT_SINGLE ||\n            trade.tradeType == TradeType.EXACT_OUT_BATCH;\n    }\n\n    function _preValidate(Trade memory trade, uint256 preTradeSellBalance) private pure {\n        if (_isExactIn(trade) && preTradeSellBalance < trade.amount) {\n            revert PreValidationExactIn(trade.amount, preTradeSellBalance);\n        } \n        \n        if (_isExactOut(trade) && preTradeSellBalance < trade.limit) {\n            // NOTE: this implies that vaults cannot execute market trades on exact out\n            revert PreValidationExactOut(trade.limit, preTradeSellBalance);\n        }\n    }\n\n    function _postValidate(Trade memory trade, uint256 amountReceived) private pure {\n        if (_isExactIn(trade) && amountReceived < trade.limit) {\n            revert PostValidationExactIn(trade.limit, amountReceived);\n        }\n\n        if (_isExactOut(trade) && amountReceived != trade.amount) {\n            revert PostValidationExactOut(trade.amount, amountReceived);\n        }\n    }\n\n    /// @notice Approve exchange to pull from this contract\n    /// @dev approve up to trade.amount for EXACT_IN trades and up to trade.limit\n    /// for EXACT_OUT trades\n    function _approve(Trade memory trade, address spender) private {\n        uint256 allowance = _isExactIn(trade) ? trade.amount : trade.limit;\n        IERC20(trade.sellToken).checkApprove(spender, allowance);\n    }\n\n    function _executeTrade(\n        address target,\n        uint256 msgValue,\n        bytes memory params,\n        address spender,\n        Trade memory trade\n    ) private {\n        uint256 preTradeBalance;\n\n        if (trade.sellToken == address(Deployments.WETH) && spender == Deployments.ETH_ADDRESS) {\n            preTradeBalance = address(this).balance;\n            // Curve doesn't support Deployments.WETH (spender == address(0))\n            uint256 withdrawAmount = _isExactIn(trade) ? trade.amount : trade.limit;\n            Deployments.WETH.withdraw(withdrawAmount);\n        } else if (trade.sellToken == Deployments.ETH_ADDRESS && spender != Deployments.ETH_ADDRESS) {\n            preTradeBalance = IERC20(address(Deployments.WETH)).balanceOf(address(this));\n            // UniswapV3 doesn't support ETH (spender != address(0))\n            uint256 depositAmount = _isExactIn(trade) ? trade.amount : trade.limit;\n            Deployments.WETH.deposit{value: depositAmount }();\n        }\n\n        (bool success, bytes memory returnData) = target.call{value: msgValue}(params);\n        if (!success) revert TradeExecution(returnData);\n\n        if (trade.buyToken == address(Deployments.WETH)) {\n            if (address(this).balance > preTradeBalance) {\n                // If the caller specifies that they want to receive Deployments.WETH but we have received ETH,\n                // wrap the ETH to Deployments.WETH.\n                uint256 depositAmount;\n                unchecked { depositAmount = address(this).balance - preTradeBalance; }\n                Deployments.WETH.deposit{value: depositAmount}();\n            }\n        } else if (trade.buyToken == Deployments.ETH_ADDRESS) {\n            uint256 postTradeBalance = IERC20(address(Deployments.WETH)).balanceOf(address(this));\n            if (postTradeBalance > preTradeBalance) {\n                // If the caller specifies that they want to receive ETH but we have received Deployments.WETH,\n                // unwrap the Deployments.WETH to ETH.\n                uint256 withdrawAmount;\n                unchecked { withdrawAmount = postTradeBalance - preTradeBalance; }\n                Deployments.WETH.withdraw(withdrawAmount);\n            }\n        }\n    }\n\n    function _getLimitAmount(\n        TradeType tradeType,\n        address sellToken,\n        address buyToken,\n        uint256 amount,\n        uint32 slippageLimit,\n        uint256 oraclePrice,\n        uint256 oracleDecimals\n    ) internal view returns (uint256 limitAmount) {\n        uint256 sellTokenDecimals = 10 **\n            (\n                sellToken == Deployments.ETH_ADDRESS\n                    ? 18\n                    : IERC20(sellToken).decimals()\n            );\n        uint256 buyTokenDecimals = 10 **\n            (\n                buyToken == Deployments.ETH_ADDRESS\n                    ? 18\n                    : IERC20(buyToken).decimals()\n            );\n\n        if (tradeType == TradeType.EXACT_OUT_SINGLE || tradeType == TradeType.EXACT_OUT_BATCH) {\n            // 0 means no slippage limit\n            if (slippageLimit == 0) {\n                return type(uint256).max;\n            }\n            // For exact out trades, we need to invert the oracle price (1 / oraclePrice)\n            // We increase the precision before we divide because oraclePrice is in\n            // oracle decimals\n            oraclePrice = (oracleDecimals * oracleDecimals) / oraclePrice;\n            // For exact out trades, limitAmount is the max amount of sellToken the DEX can\n            // pull from the contract\n            limitAmount =\n                ((oraclePrice + \n                    ((oraclePrice * uint256(slippageLimit)) /\n                        Constants.SLIPPAGE_LIMIT_PRECISION)) * amount) / \n                oracleDecimals;\n\n            // limitAmount is in buyToken precision after the previous calculation,\n            // convert it to sellToken precision\n            limitAmount = (limitAmount * sellTokenDecimals) / buyTokenDecimals;\n        } else {\n            // 0 means no slippage limit\n            if (slippageLimit == 0) {\n                return 0;\n            }\n            // For exact in trades, limitAmount is the min amount of buyToken the contract\n            // expects from the DEX\n            limitAmount =\n                ((oraclePrice -\n                    ((oraclePrice * uint256(slippageLimit)) /\n                        Constants.SLIPPAGE_LIMIT_PRECISION)) * amount) /\n                oracleDecimals;\n\n            // limitAmount is in sellToken precision after the previous calculation,\n            // convert it to buyToken precision\n            limitAmount = (limitAmount * buyTokenDecimals) / sellTokenDecimals;\n        }\n    }\n}"
    }
  ]
}