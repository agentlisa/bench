{
  "Title": "M-16: Gas parameters for Stargate swap are hardcoded leading to stuck messages",
  "Content": "# Issue M-16: Gas parameters for Stargate swap are hardcoded leading to stuck messages \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/72 \n\n## Found by \nGiuseppeDeLaZara\n## Summary\nThe `dstGasForCall` for transferring erc20s through Stargate is hardcoded to 0 in the `Balancer` contract leading to `sgReceive` not being called during Stargate swap.\nAs a consequence, the `sgReceive` has to be manually called to clear the `cachedSwapLookup` mapping, but this can be DoSed due to the fact that the `mTOFT::sgReceive` doesn't validate any of its parameters.\nThis can be exploited to perform a long-term DoS attack. \n\n## Vulnerability Detail\n### Gas parameters for Stargate\n\nStargate Swap allows the caller to specify the:\n\n- `dstGasForCall` which is the gas amount forwarded while calling the `sgReceive` on the destination contract.\n- `dstNativeAmount` and `dstNativeAddr` which is the amount and address where the native token is sent to.\n\nInside the `Balancer.sol` contract, the [`dstGasForCall` is hardcoded to 0](https://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/TapiocaZ/contracts/Balancer.sol#L316). \nThe `dstGasForCall` gets forwarded from Stargate `Router` into the Stargate [`Bridge`](https://github.com/stargate-protocol/stargate/blob/c647a3a647fc693c38b16ef023c54e518b46e206/contracts/Bridge.sol#L115) contract.\n\n```solidity\n    function swap(\n        uint16 _chainId,\n        uint256 _srcPoolId,\n        uint256 _dstPoolId,\n        address payable _refundAddress,\n        Pool.CreditObj memory _c,\n        Pool.SwapObj memory _s,\n>>>>>>        IStargateRouter.lzTxObj memory _lzTxParams, \n        bytes calldata _to,\n        bytes calldata _payload\n    ) external payable onlyRouter {\n>>>>>>        bytes memory payload = abi.encode(TYPE_SWAP_REMOTE, _srcPoolId, _dstPoolId, _lzTxParams.dstGasForCall, _c, _s, _to, _payload);\n        _call(_chainId, TYPE_SWAP_REMOTE, _refundAddress, _lzTxParams, payload);\n    }\n\n    function _call(\n        uint16 _chainId,\n        uint8 _type,\n        address payable _refundAddress,\n        IStargateRouter.lzTxObj memory _lzTxParams,\n        bytes memory _payload\n    ) internal {\n        bytes memory lzTxParamBuilt = _txParamBuilder(_chainId, _type, _lzTxParams);\n        uint64 nextNonce = layerZeroEndpoint.getOutboundNonce(_chainId, address(this)) + 1;\n        layerZeroEndpoint.send{value: msg.value}(_chainId, bridgeLookup[_chainId], _payload, _refundAddress, address(this), lzTxParamBuilt);\n        emit SendMsg(_type, nextNonce);\n    }\n```\n\nIt gets encoded inside the payload that is sent through the LayerZero message. \nThe payload gets decoded inside the [`Bridge::lzReceive`](https://github.com/stargate-protocol/stargate/blob/c647a3a647fc693c38b16ef023c54e518b46e206/contracts/Bridge.sol#L79) on destination chain. \nAnd `dstGasForCall` is forwarded to the [`sgReceive`](https://github.com/stargate-protocol/stargate/blob/c647a3a647fc693c38b16ef023c54e518b46e206/contracts/Router.sol#L406) function:\n\n```solidity\n## Bridge.sol\n\n function lzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) external override {\n        if (functionType == TYPE_SWAP_REMOTE) {\n            (\n                ,\n                uint256 srcPoolId,\n                uint256 dstPoolId,\n>>>>>                uint256 dstGasForCall,\n                Pool.CreditObj memory c,\n                Pool.SwapObj memory s,\n                bytes memory to,\n                bytes memory payload\n            ) = abi.decode(_payload, (uint8, uint256, uint256, uint256, Pool.CreditObj, Pool.SwapObj, bytes, bytes));\n```\n\nIf it is zero like in the `Balancer.sol` contract or its value is too small the `sgReceive` will fail, but the payload will be saved in the `cachedSwapLookup` mapping. At the same time the tokens are transferred to the destination contract, which is the `mTOFT`.\nNow anyone can call the `sgReceive` manually through the [`clearCachedSwap`](https://github.com/stargate-protocol/stargate/blob/c647a3a647fc693c38b16ef023c54e518b46e206/contracts/Router.sol#L285) function:\n\n```solidity\n    function clearCachedSwap(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        uint256 _nonce\n    ) external {\n        CachedSwap memory cs = cachedSwapLookup[_srcChainId][_srcAddress][_nonce];\n        require(cs.to != address(0x0), \"Stargate: cache already cleared\");\n        // clear the data\n        cachedSwapLookup[_srcChainId][_srcAddress][_nonce] = CachedSwap(address(0x0), 0, address(0x0), \"\");\n        IStargateReceiver(cs.to).sgReceive(_srcChainId, _srcAddress, _nonce, cs.token, cs.amountLD, cs.payload);\n    }\n```\n\nAlthough not the intended behavior there seems to be no issue with erc20 token sitting on the `mTOFT` contract for a shorter period of time.\n\n### sgReceive\n\nThis leads to the second issue. The `sgReceive` function interface specifies the `chainId`, `srcAddress`, and `token`.\n- `chainId` is the layerZero chainId of the source chain. In their docs referred to endpointId: https://layerzero.gitbook.io/docs/technical-reference/mainnet/supported-chain-ids\n- `srcAddress` is the address of the source sending contract\n- `token` is the address of the token that was sent to the destination contract. \n\nIn the current implementation, the `sgReceive` function doesn't check any of these parameters. In practice this means that anyone can specify the `mTOFT` address as the receiver and initiate Stargate Swap from any chain to the `mTOFT` contract.\n\nIn conjunction with the first issue, this opens up the possibility of a DoS attack.\n\nLet's imagine the following scenario: \n\n- Rebalancing operation needs to be performed between `mTOFT` on Ethereum and Avalanche that hold `USDC` as the underlying token.\n- Rebalancing is initiated from Ethereum but the `sgReceive` on Avalanche fails and 1000 USDCs are sitting on `mTOFT` contract on Avalanche.\n- A griever noticed this and initiated Stargate swap from Ethereum to Avalanche for 1 USDT specifying the `mTOFT` contract as the receiver.\n- This is successful and now `mTOFT` has 1 `USDT` but 999 `USDC` as the griever's transaction has called the `sgRecieve` function that pushed 1 USDC to the `TOFTVault`. \n- As a consequence, the `clearCachedSwap` function fails because it tries to transfer the original 1000 USDC. \n\n```solidity\n    function sgReceive(uint16, bytes memory, uint256, address, uint256 amountLD, bytes memory) external payable {\n        if (msg.sender != _stargateRouter) revert mTOFT_NotAuthorized();\n\n        if (erc20 == address(0)) {\n            vault.depositNative{value: amountLD}();\n        } else {\n>>>>>            IERC20(erc20).safeTransfer(address(vault), amountLD); // amountLD is the original 1000 USDC\n        }\n    }\n```\n- The only solution here is to manually transfer that 1 USDC to the `mTOFT` contract and try calling the `clearCachedSwap` again.\n- The griever can repeat this process multiple times.\n\n\n## Impact\nHardcoding the `dstGasCall` to 0 in conjuction with not checking the `sgReceive` parameters opens up the possibility of a long-term DoS attack.  \n\n## Code Snippet\n- https://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/TapiocaZ/contracts/tOFT/mTOFT.sol#L326\n- https://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/TapiocaZ/contracts/Balancer.sol#L316\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe `dstGasForCall` shouldn't be hardcoded to 0. It should be a configurable value that is set by the admin of the `Balancer` contract. \n\nTake into account that this value will be different for different chains.\n\nFor instance, Arbitrum has a different gas model than Ethereum due to its specific precompiles: https://docs.arbitrum.io/arbos/gas.\n<img width=\"865\" alt=\"Screenshot 2024-03-13 at 14 52 09\" src=\"https://github.com/sherlock-audit/2024-02-tapioca-windhustler/assets/38017754/874dbe44-6641-47a2-b41b-6c55e2a93a3c\">\n\nThe recommended solution is:\n\n```diff\n contract Balancer is Ownable {\n     using SafeERC20 for IERC20;\n\n+    mapping(uint16 => uint256) internal sgReceiveGas;\n\n+    function setSgReceiveGas(uint16 eid, uint256 gas) external onlyOwner {\n+        sgReceiveGas[eid] = gas;\n+    }\n+\n+    function getSgReceiveGas(uint16 eid) internal view returns (uint256) {\n+        uint256 gas = sgReceiveGas[eid];\n+        if (gas == 0) revert();\n+        return gas;\n+    }\n+\n-    IStargateRouterBase.lzTxObj({dstGasForCall: 0, dstNativeAmount: 0, dstNativeAddr: \"0x0\"}),\n+    IStargateRouterBase.lzTxObj({dstGasForCall: getSgReceiveGas(_dstChainId), dstNativeAmount: 0, dstNativeAddr: \"0x0\"}),\n```\n\n\n\n## Discussion\n\n**cryptotechmaker**\n\nLow/Informational/ It's not a required feature. This allows you to airdrop some native tokens to a destination\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Tapioca-DAO/TapiocaZ/pull/177.\n\n**HollaDieWaldfee100**\n\nEscalate\n\nThe sponsor's comment is misleading. He is referencing the `dstNativeAmount` and `dstNativeAddr` which can be left as 0, as this functionality is not needed.Â \nThe whole report talks about the `dstGasForCall` that is hardcoded to 0. This will lead to `sgReceive` not being called and open up the possibility of a DoS attack vector on the receiving side.Â Â \nThe report also highlights the gas differences between chains and the importance of properly setting `dstGasForCall` per destination chain. Recommendations were implemented in theÂ Tapioca-DAO/TapiocaZ#177.\nBased on all the arguments this should be a valid medium severity issue.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> The sponsor's comment is misleading. He is referencing the `dstNativeAmount` and `dstNativeAddr` which can be left as 0, as this functionality is not needed.Â \n> The whole report talks about the `dstGasForCall` that is hardcoded to 0. This will lead to `sgReceive` not being called and open up the possibility of a DoS attack vector on the receiving side.Â Â \n> The report also highlights the gas differences between chains and the importance of properly setting `dstGasForCall` per destination chain. Recommendations were implemented in theÂ Tapioca-DAO/TapiocaZ#177.\n> Based on all the arguments this should be a valid medium severity issue.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Tendency001**\n\nHardcoding zero gas actually triggers a revert on the same chain down the logic in `RelayerV2::_getPrices`\n```solidity\n        // decoding the _adapterParameters - reverts if type 2 and there is no dstNativeAddress\n        require(_adapterParameters.length == 34 || _adapterParameters.length > 66, \"Relayer: wrong _adapterParameters size\");\n        uint16 txType;\n        uint extraGas;\n        assembly {\n            txType := mload(add(_adapterParameters, 2))\n            extraGas := mload(add(_adapterParameters, 34))\n        }\n        require(extraGas > 0, \"Relayer: gas too low\");\n```\nThe call never gets delivered to the destination chain to introduce the said DOS\n\n**windhustler**\n\nThis call does get delivered to the destination chain. The `dstGasForCall` is the gas passed to the `sgReceive`, and the [base gas is a configuration inside Stargate](https://github.com/stargate-protocol/stargate/blob/main/contracts/Bridge.sol#L285-#L289):\n\n```solidity\n    function _txParamBuilder(\n        uint16 _chainId,\n        uint8 _type,\n        IStargateRouter.lzTxObj memory _lzTxParams\n    ) internal view returns (bytes memory) {\n        bytes memory lzTxParam;\n        address dstNativeAddr;\n        {\n            bytes memory dstNativeAddrBytes = _lzTxParams.dstNativeAddr;\n            assembly {\n                dstNativeAddr := mload(add(dstNativeAddrBytes, 20))\n            }\n        }\n\n>>>        uint256 totalGas = gasLookup[_chainId][_type].add(_lzTxParams.dstGasForCall);\n        if (_lzTxParams.dstNativeAmount > 0 && dstNativeAddr != address(0x0)) {\n>>>            lzTxParam = txParamBuilderType2(totalGas, _lzTxParams.dstNativeAmount, _lzTxParams.dstNativeAddr);\n        } else {\n>>>            lzTxParam = txParamBuilderType1(totalGas);\n        }\n\n        return lzTxParam;\n    }\n```\n\nYou can see that `dstGasForCall` is simply added to the totalGas. In other words, Stargate will always deliver the message but if you hardcode `dstGasForCall` to 0 `sgReceive` will revert.\n\nSetting `dstGasForCall` to 0 would be a strange configuration parameter if it would disallow sending messages. \n\n**Tendency001**\n\nYou are right.\nGreat find ðŸ«¡\n\n**maarcweiss**\n\n@windhustler should we also use the set gas receiver stuff on the following PR, correct?: https://github.com/Tapioca-DAO/TapiocaZ/pull/174/files\n\n**windhustler**\n\nHey, yes you need to use the appropriate `dstGasForCall` here as well. You can reuse the `_sgReceiveGas` value from here: https://github.com/Tapioca-DAO/TapiocaZ/pull/177/files. \n\n**cvetanovv**\n\nWhile it is a valid report, the main root is hardcoded `dstGasCall`Â to 0. And the same root vulnerability was found in the \"Pashov Audit Group\" audit - [H-07](https://3014726245-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FfBay3bZwWmLdUX02P7Qc%2Fuploads%2FacpTKQyK9l2Yc61DQbch%2FTapiocaDAO-security-review-report.pdf?alt=media&token=6eedce9c-8ac8-4fa2-9605-05e4a96bddaa). \nAccording to Sherlock's rules, this makes the report invalid. \n\n@nevillehuang what do you think?\n\n**windhustler**\n\n@cvetanovv I've just checked [H-07](https://3014726245-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FfBay3bZwWmLdUX02P7Qc%2Fuploads%2FacpTKQyK9l2Yc61DQbch%2FTapiocaDAO-security-review-report.pdf?alt=media&token=6eedce9c-8ac8-4fa2-9605-05e4a96bddaa). It has several false/inaccurate claims which is probably the reason why Tapioca team hasn't fixed this:\n\n- It claims if `dstGasForCall == 0`, a fee will be charged based on the default 200k gas, i.e. `sgRecieve` on the destination will be called with 200k gas. This is not correct, see https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/72#issuecomment-2034713451. The 200k gas is the default value if you are sending layer zero messages with gas set to 0. Using Stargate is different. `dstGasForCall` is exclusively used as gas passed for `sgReceive`. \n\n- Based on the false assumptions it derives the impact of underpaying/overpaying Stargate fees which is quite different than the impact this report claims. \n\n- It doesn't make the distinction between setting different gas configurations for different chains. \n\n**cvetanovv**\n\nAfter doing some research I agree with @windhustler comment. So, I plan to accept the escalation and make the issue a valid Medium.\n\n**nevillehuang**\n\nI think I agree with medium severity, unless @cryptotechmaker would like to clarify the above comment [here](https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/72#issuecomment-2018276507)\n\n**Evert0x**\n\nResult:\nMedium\nUnique\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [HollaDieWaldfee100](https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/72/#issuecomment-2034505558): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "TapiocaZ/contracts/Balancer.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {IStargateRouter, IStargateRouterBase} from \"tapioca-periph/interfaces/external/stargate/IStargateRouter.sol\";\nimport {IStargateEthVault} from \"tapioca-periph/interfaces/external/stargate/IStargateEthVault.sol\";\nimport {ITOFTVault} from \"tapioca-periph/interfaces/tapiocaz/ITOFTVault.sol\";\nimport {ITOFT} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\n\n/*\n\nâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— \nâ•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—\n   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘\n   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘\n   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘\n   â•šâ•â•   â•šâ•â•  â•šâ•â•â•šâ•â•     â•šâ•â• â•šâ•â•â•â•â•â•  â•šâ•â•â•â•â•â•â•šâ•â•  â•šâ•â•\n   \n*/\n\n/**\n * @title Balancer\n * @author TapiocaDAO\n * @notice Rebalances mTOFT by transferring underlying tokens to other layers through Stargate\n */\ncontract Balancer is Ownable {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice current OFT => chain => destination OFT\n     * @dev chain ids (https://stargateprotocol.gitbook.io/stargate/developers/chain-ids):\n     *         - Ethereum: 101\n     *         - BNB: 102\n     *         - Avalanche: 106\n     *         - Polygon: 109\n     *         - Arbitrum: 110\n     *         - Optimism: 111\n     *         - Fantom: 112\n     *         - Metis: 151\n     *     pool ids https://stargateprotocol.gitbook.io/stargate/developers/pool-ids\n     */\n    mapping(address => mapping(uint16 => OFTData)) public connectedOFTs;\n\n    struct OFTData {\n        uint256 srcPoolId;\n        uint256 dstPoolId;\n        address dstOft;\n        uint256 rebalanceable;\n    }\n\n    IStargateRouter public immutable routerETH;\n    IStargateRouter public immutable router;\n\n    address public rebalancer;\n\n    // @dev swapEth is not available on some chains\n    bool public disableEth;\n\n    event ConnectedChainUpdated(address indexed _srcOft, uint16 indexed _dstChainId, address indexed _dstOft);\n    event Rebalanced(\n        address indexed _srcOft, uint16 indexed _dstChainId, uint256 indexed _slippage, uint256 _amount, bool _isNative\n    );\n    event RebalanceAmountUpdated(\n        address indexed _srcOft, uint16 indexed _dstChainId, uint256 indexed _amount, uint256 _totalAmount\n    );\n    event ToggledSwapEth(bool indexed _old, bool indexed _new);\n    event EmergencySaved(address indexed _token, uint256 indexed _amount, bool indexed _native);\n    event RebalancerUpdated(address indexed prev, address indexed current);\n\n    error NotAuthorized();\n    error RouterNotValid();\n    error ExceedsBalance();\n    error DestinationNotValid();\n    error SlippageNotValid();\n    error FeeAmountNotSet();\n    error PoolInfoRequired();\n    error RebalanceAmountNotSet();\n    error Failed();\n    error SwapNotEnabled();\n    error AlreadyInitialized();\n    error RebalanceAmountNotValid();\n\n    modifier onlyValidDestination(address _srcOft, uint16 _dstChainId) {\n        if (connectedOFTs[_srcOft][_dstChainId].dstOft == address(0)) {\n            revert DestinationNotValid();\n        }\n        _;\n    }\n\n    modifier onlyValidSlippage(uint256 _slippage) {\n        // @dev a slippage higher than 20% shouldn't be necessary\n        if (_slippage >= 2e4) revert SlippageNotValid();\n        _;\n    }\n\n    constructor(address _routerETH, address _router, address _owner) {\n        if (_router == address(0)) revert RouterNotValid();\n        if (_routerETH == address(0)) revert RouterNotValid();\n        routerETH = IStargateRouter(_routerETH);\n        router = IStargateRouter(_router);\n\n        transferOwnership(_owner);\n        rebalancer = _owner;\n        emit RebalancerUpdated(address(0), _owner);\n    }\n\n    receive() external payable {}\n\n    /// =====================\n    /// View\n    /// =====================\n    function checker(address payable _srcOft, uint16 _dstChainId, uint256 _slippage)\n        external\n        view\n        returns (bool canExec, bytes memory execPayload)\n    {\n        bytes memory ercData;\n        {\n            if (ITOFT(_srcOft).erc20() != address(0)) {\n                ercData = abi.encode(\n                    connectedOFTs[_srcOft][_dstChainId].srcPoolId, connectedOFTs[_srcOft][_dstChainId].dstPoolId\n                );\n            }\n        }\n\n        canExec = connectedOFTs[_srcOft][_dstChainId].rebalanceable > 0;\n        execPayload = abi.encodeCall(\n            Balancer.rebalance,\n            (_srcOft, _dstChainId, _slippage, connectedOFTs[_srcOft][_dstChainId].rebalanceable, ercData)\n        );\n    }\n\n    /// =====================\n    /// Owner\n    /// =====================\n\n    /**\n     * @notice set rebalancer role\n     * @param _addr the new address\n     */\n    function setRebalancer(address _addr) external onlyOwner {\n        rebalancer = _addr;\n        emit RebalancerUpdated(rebalancer, _addr);\n    }\n\n    /**\n     * @notice toggle swap eth\n     * @param _val true/false\n     */\n    function setSwapEth(bool _val) external onlyOwner {\n        emit ToggledSwapEth(disableEth, _val);\n        disableEth = _val;\n    }\n\n    /**\n     * @notice performs a rebalance operation\n     * @dev callable only by the owner\n     * @param _srcOft the source TOFT address\n     * @param _dstChainId the destination LayerZero id\n     * @param _slippage the destination LayerZero id\n     * @param _amount the rebalanced amount\n     * @param _ercData custom send data\n     */\n    function rebalance(\n        address payable _srcOft,\n        uint16 _dstChainId,\n        uint256 _slippage,\n        uint256 _amount,\n        bytes memory _ercData\n    ) external payable onlyValidDestination(_srcOft, _dstChainId) onlyValidSlippage(_slippage) {\n        if (msg.sender != owner() || msg.sender != rebalancer) revert NotAuthorized();\n\n        if (connectedOFTs[_srcOft][_dstChainId].rebalanceable < _amount) {\n            revert RebalanceAmountNotSet();\n        }\n\n        //extract\n        ITOFT(_srcOft).extractUnderlying(_amount);\n\n        //send\n        {\n            bool _isNative = ITOFT(_srcOft).erc20() == address(0);\n            if (msg.value == 0) revert FeeAmountNotSet();\n            if (_isNative) {\n                if (disableEth) revert SwapNotEnabled();\n                _sendNative(_srcOft, _amount, _dstChainId, _slippage);\n            } else {\n                _sendToken(_srcOft, _amount, _dstChainId, _slippage, _ercData);\n            }\n\n            connectedOFTs[_srcOft][_dstChainId].rebalanceable -= _amount;\n            emit Rebalanced(_srcOft, _dstChainId, _slippage, _amount, _isNative);\n        }\n    }\n\n    /**\n     * @notice saves token/native gas from this contract\n     * @param _token the token address; `address(0)` should be passed for the Native coin\n     * @param _amount the amount to be saved\n     */\n    function emergencySaveTokens(address _token, uint256 _amount) external onlyOwner {\n        if (_token == address(0)) {\n            (bool sent,) = msg.sender.call{value: _amount}(\"\");\n            if (!sent) revert Failed();\n            emit EmergencySaved(_token, _amount, true);\n        } else {\n            IERC20(_token).safeTransfer(msg.sender, _amount);\n            emit EmergencySaved(_token, _amount, false);\n        }\n    }\n\n    /**\n     * @notice registeres mTapiocaOFT for rebalancing\n     * @param _srcOft the source TOFT address\n     * @param _dstChainId the destination LayerZero id\n     * @param _dstOft the destination TOFT address\n     * @param _ercData custom send data\n     */\n    function initConnectedOFT(address _srcOft, uint16 _dstChainId, address _dstOft, bytes memory _ercData)\n        external\n        onlyOwner\n    {\n        if (connectedOFTs[_srcOft][_dstChainId].rebalanceable > 0) {\n            revert AlreadyInitialized();\n        }\n        bool isNative = ITOFT(_srcOft).erc20() == address(0);\n        if (!isNative && _ercData.length == 0) revert PoolInfoRequired();\n\n        (uint256 _srcPoolId, uint256 _dstPoolId) = abi.decode(_ercData, (uint256, uint256));\n\n        OFTData memory oftData =\n            OFTData({srcPoolId: _srcPoolId, dstPoolId: _dstPoolId, dstOft: _dstOft, rebalanceable: 0});\n\n        connectedOFTs[_srcOft][_dstChainId] = oftData;\n        emit ConnectedChainUpdated(_srcOft, _dstChainId, _dstOft);\n    }\n\n    /**\n     * @notice assings more rebalanceable amount for TOFT\n     * @param _srcOft the source TOFT address\n     * @param _dstChainId the destination LayerZero id\n     * @param _amount the rebalanced amount\n     */\n    function addRebalanceAmount(address _srcOft, uint16 _dstChainId, uint256 _amount)\n        external\n        onlyValidDestination(_srcOft, _dstChainId)\n        onlyOwner\n    {\n        connectedOFTs[_srcOft][_dstChainId].rebalanceable += _amount;\n        uint256 totalToftSupply = ITOFTVault(ITOFT(_srcOft).vault()).viewSupply();\n        if (connectedOFTs[_srcOft][_dstChainId].rebalanceable > totalToftSupply) {\n            revert RebalanceAmountNotValid();\n        }\n        emit RebalanceAmountUpdated(_srcOft, _dstChainId, _amount, connectedOFTs[_srcOft][_dstChainId].rebalanceable);\n    }\n\n    function retryRevert(uint16 _srcChainId, bytes calldata _srcAddress, uint256 _nonce) external payable onlyOwner {\n        router.retryRevert{value: msg.value}(_srcChainId, _srcAddress, _nonce);\n    }\n\n    /// =====================\n    /// Private\n    /// =====================\n    function _sendNative(address payable _oft, uint256 _amount, uint16 _dstChainId, uint256 _slippage) private {\n        if (address(this).balance < _amount) revert ExceedsBalance();\n        uint256 valueAmount = msg.value + _amount;\n        routerETH.swapETH{value: valueAmount}(\n            _dstChainId,\n            payable(this),\n            abi.encodePacked(connectedOFTs[_oft][_dstChainId].dstOft),\n            _amount,\n            _computeMinAmount(_amount, _slippage)\n        );\n    }\n\n    function _sendToken(\n        address payable _oft,\n        uint256 _amount,\n        uint16 _dstChainId,\n        uint256 _slippage,\n        bytes memory _data\n    ) private {\n        address erc20 = ITOFT(_oft).erc20();\n        if (IERC20Metadata(erc20).balanceOf(address(this)) < _amount) {\n            revert ExceedsBalance();\n        }\n        {\n            (uint256 _srcPoolId, uint256 _dstPoolId) = abi.decode(_data, (uint256, uint256));\n            _routerSwap(_dstChainId, _srcPoolId, _dstPoolId, _amount, _slippage, _oft, erc20);\n        }\n    }\n\n    function _routerSwap(\n        uint16 _dstChainId,\n        uint256 _srcPoolId,\n        uint256 _dstPoolId,\n        uint256 _amount,\n        uint256 _slippage,\n        address payable _oft,\n        address _erc20\n    ) private {\n        bytes memory _dst = abi.encodePacked(connectedOFTs[_oft][_dstChainId].dstOft);\n        IERC20(_erc20).safeApprove(address(router), _amount);\n        router.swap{value: msg.value}(\n            _dstChainId,\n            _srcPoolId,\n            _dstPoolId,\n            payable(this),\n            _amount,\n            _computeMinAmount(_amount, _slippage),\n            IStargateRouterBase.lzTxObj({dstGasForCall: 0, dstNativeAmount: 0, dstNativeAddr: \"0x0\"}),\n            _dst,\n            \"0x\"\n        );\n    }\n\n    function _computeMinAmount(uint256 _amount, uint256 _slippage) private pure returns (uint256) {\n        return _amount - ((_amount * _slippage) / 1e5);\n    }\n}"
    },
    {
      "filename": "contracts/Bridge.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\n// imports\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./Pool.sol\";\nimport \"./Router.sol\";\n\n// libraries\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./interfaces/ILayerZeroReceiver.sol\";\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\nimport \"./interfaces/ILayerZeroUserApplicationConfig.sol\";\n\ncontract Bridge is Ownable, ILayerZeroReceiver, ILayerZeroUserApplicationConfig {\n    using SafeMath for uint256;\n\n    //---------------------------------------------------------------------------\n    // CONSTANTS\n    uint8 internal constant TYPE_SWAP_REMOTE = 1;\n    uint8 internal constant TYPE_ADD_LIQUIDITY = 2;\n    uint8 internal constant TYPE_REDEEM_LOCAL_CALL_BACK = 3;\n    uint8 internal constant TYPE_WITHDRAW_REMOTE = 4;\n\n    //---------------------------------------------------------------------------\n    // VARIABLES\n    ILayerZeroEndpoint public immutable layerZeroEndpoint;\n    mapping(uint16 => bytes) public bridgeLookup;\n    mapping(uint16 => mapping(uint8 => uint256)) public gasLookup;\n    Router public immutable router;\n    bool public useLayerZeroToken;\n\n    //---------------------------------------------------------------------------\n    // EVENTS\n    event SendMsg(uint8 msgType, uint64 nonce);\n\n    //---------------------------------------------------------------------------\n    // MODIFIERS\n    modifier onlyRouter() {\n        require(msg.sender == address(router), \"Stargate: caller must be Router.\");\n        _;\n    }\n\n    constructor(address _layerZeroEndpoint, address _router) {\n        require(_layerZeroEndpoint != address(0x0), \"Stargate: _layerZeroEndpoint cannot be 0x0\");\n        require(_router != address(0x0), \"Stargate: _router cannot be 0x0\");\n        layerZeroEndpoint = ILayerZeroEndpoint(_layerZeroEndpoint);\n        router = Router(_router);\n    }\n\n    //---------------------------------------------------------------------------\n    // EXTERNAL functions\n\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) external override {\n        require(msg.sender == address(layerZeroEndpoint), \"Stargate: only LayerZero endpoint can call lzReceive\");\n        require(\n            _srcAddress.length == bridgeLookup[_srcChainId].length && keccak256(_srcAddress) == keccak256(bridgeLookup[_srcChainId]),\n            \"Stargate: bridge does not match\"\n        );\n\n        uint8 functionType;\n        assembly {\n            functionType := mload(add(_payload, 32))\n        }\n\n        if (functionType == TYPE_SWAP_REMOTE) {\n            (\n                ,\n                uint256 srcPoolId,\n                uint256 dstPoolId,\n                uint256 dstGasForCall,\n                Pool.CreditObj memory c,\n                Pool.SwapObj memory s,\n                bytes memory to,\n                bytes memory payload\n            ) = abi.decode(_payload, (uint8, uint256, uint256, uint256, Pool.CreditObj, Pool.SwapObj, bytes, bytes));\n            address toAddress;\n            assembly {\n                toAddress := mload(add(to, 20))\n            }\n            router.creditChainPath(_srcChainId, srcPoolId, dstPoolId, c);\n            router.swapRemote(_srcChainId, _srcAddress, _nonce, srcPoolId, dstPoolId, dstGasForCall, toAddress, s, payload);\n        } else if (functionType == TYPE_ADD_LIQUIDITY) {\n            (, uint256 srcPoolId, uint256 dstPoolId, Pool.CreditObj memory c) = abi.decode(_payload, (uint8, uint256, uint256, Pool.CreditObj));\n            router.creditChainPath(_srcChainId, srcPoolId, dstPoolId, c);\n        } else if (functionType == TYPE_REDEEM_LOCAL_CALL_BACK) {\n            (, uint256 srcPoolId, uint256 dstPoolId, Pool.CreditObj memory c, uint256 amountSD, uint256 mintAmountSD, bytes memory to) = abi\n                .decode(_payload, (uint8, uint256, uint256, Pool.CreditObj, uint256, uint256, bytes));\n            address toAddress;\n            assembly {\n                toAddress := mload(add(to, 20))\n            }\n            router.creditChainPath(_srcChainId, srcPoolId, dstPoolId, c);\n            router.redeemLocalCallback(_srcChainId, _srcAddress, _nonce, srcPoolId, dstPoolId, toAddress, amountSD, mintAmountSD);\n        } else if (functionType == TYPE_WITHDRAW_REMOTE) {\n            (, uint256 srcPoolId, uint256 dstPoolId, Pool.CreditObj memory c, uint256 amountSD, bytes memory to) = abi.decode(\n                _payload,\n                (uint8, uint256, uint256, Pool.CreditObj, uint256, bytes)\n            );\n            router.creditChainPath(_srcChainId, srcPoolId, dstPoolId, c);\n            router.redeemLocalCheckOnRemote(_srcChainId, _srcAddress, _nonce, srcPoolId, dstPoolId, amountSD, to);\n        }\n    }\n\n    //---------------------------------------------------------------------------\n    // LOCAL CHAIN FUNCTIONS\n    function swap(\n        uint16 _chainId,\n        uint256 _srcPoolId,\n        uint256 _dstPoolId,\n        address payable _refundAddress,\n        Pool.CreditObj memory _c,\n        Pool.SwapObj memory _s,\n        IStargateRouter.lzTxObj memory _lzTxParams,\n        bytes calldata _to,\n        bytes calldata _payload\n    ) external payable onlyRouter {\n        bytes memory payload = abi.encode(TYPE_SWAP_REMOTE, _srcPoolId, _dstPoolId, _lzTxParams.dstGasForCall, _c, _s, _to, _payload);\n        _call(_chainId, TYPE_SWAP_REMOTE, _refundAddress, _lzTxParams, payload);\n    }\n\n    function redeemLocalCallback(\n        uint16 _chainId,\n        address payable _refundAddress,\n        Pool.CreditObj memory _c,\n        IStargateRouter.lzTxObj memory _lzTxParams,\n        bytes memory _payload\n    ) external payable onlyRouter {\n        bytes memory payload;\n\n        {\n            (, uint256 srcPoolId, uint256 dstPoolId, uint256 amountSD, uint256 mintAmountSD, bytes memory to) = abi.decode(\n                _payload,\n                (uint8, uint256, uint256, uint256, uint256, bytes)\n            );\n\n            // swap dst and src because we are headed back\n            payload = abi.encode(TYPE_REDEEM_LOCAL_CALL_BACK, dstPoolId, srcPoolId, _c, amountSD, mintAmountSD, to);\n        }\n\n        _call(_chainId, TYPE_REDEEM_LOCAL_CALL_BACK, _refundAddress, _lzTxParams, payload);\n    }\n\n    function redeemLocal(\n        uint16 _chainId,\n        uint256 _srcPoolId,\n        uint256 _dstPoolId,\n        address payable _refundAddress,\n        Pool.CreditObj memory _c,\n        uint256 _amountSD,\n        bytes calldata _to,\n        IStargateRouter.lzTxObj memory _lzTxParams\n    ) external payable onlyRouter {\n        bytes memory payload = abi.encode(TYPE_WITHDRAW_REMOTE, _srcPoolId, _dstPoolId, _c, _amountSD, _to);\n        _call(_chainId, TYPE_WITHDRAW_REMOTE, _refundAddress, _lzTxParams, payload);\n    }\n\n    function sendCredits(\n        uint16 _chainId,\n        uint256 _srcPoolId,\n        uint256 _dstPoolId,\n        address payable _refundAddress,\n        Pool.CreditObj memory _c\n    ) external payable onlyRouter {\n        bytes memory payload = abi.encode(TYPE_ADD_LIQUIDITY, _srcPoolId, _dstPoolId, _c);\n        IStargateRouter.lzTxObj memory lzTxObj = IStargateRouter.lzTxObj(0, 0, \"0x\");\n        _call(_chainId, TYPE_ADD_LIQUIDITY, _refundAddress, lzTxObj, payload);\n    }\n\n    function quoteLayerZeroFee(\n        uint16 _chainId,\n        uint8 _functionType,\n        bytes calldata _toAddress,\n        bytes calldata _transferAndCallPayload,\n        IStargateRouter.lzTxObj memory _lzTxParams\n    ) external view returns (uint256, uint256) {\n        bytes memory payload = \"\";\n        Pool.CreditObj memory c = Pool.CreditObj(1, 1);\n        if (_functionType == TYPE_SWAP_REMOTE) {\n            Pool.SwapObj memory s = Pool.SwapObj(1, 1, 1, 1, 1, 1);\n            payload = abi.encode(TYPE_SWAP_REMOTE, 0, 0, 0, c, s, _toAddress, _transferAndCallPayload);\n        } else if (_functionType == TYPE_ADD_LIQUIDITY) {\n            payload = abi.encode(TYPE_ADD_LIQUIDITY, 0, 0, c);\n        } else if (_functionType == TYPE_REDEEM_LOCAL_CALL_BACK) {\n            payload = abi.encode(TYPE_REDEEM_LOCAL_CALL_BACK, 0, 0, c, 0, 0, _toAddress);\n        } else if (_functionType == TYPE_WITHDRAW_REMOTE) {\n            payload = abi.encode(TYPE_WITHDRAW_REMOTE, 0, 0, c, 0, _toAddress);\n        } else {\n            revert(\"Stargate: unsupported function type\");\n        }\n\n        bytes memory lzTxParamBuilt = _txParamBuilder(_chainId, _functionType, _lzTxParams);\n        return layerZeroEndpoint.estimateFees(_chainId, address(this), payload, useLayerZeroToken, lzTxParamBuilt);\n    }\n\n    //---------------------------------------------------------------------------\n    // dao functions\n    function setBridge(uint16 _chainId, bytes calldata _bridgeAddress) external onlyOwner {\n        require(bridgeLookup[_chainId].length == 0, \"Stargate: Bridge already set!\");\n        bridgeLookup[_chainId] = _bridgeAddress;\n    }\n\n    function setGasAmount(\n        uint16 _chainId,\n        uint8 _functionType,\n        uint256 _gasAmount\n    ) external onlyOwner {\n        require(_functionType >= 1 && _functionType <= 4, \"Stargate: invalid _functionType\");\n        gasLookup[_chainId][_functionType] = _gasAmount;\n    }\n\n    function approveTokenSpender(\n        address token,\n        address spender,\n        uint256 amount\n    ) external onlyOwner {\n        IERC20(token).approve(spender, amount);\n    }\n\n    function setUseLayerZeroToken(bool enable) external onlyOwner {\n        useLayerZeroToken = enable;\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\n        layerZeroEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    //---------------------------------------------------------------------------\n    // generic config for user Application\n    function setConfig(\n        uint16 _version,\n        uint16 _chainId,\n        uint256 _configType,\n        bytes calldata _config\n    ) external override onlyOwner {\n        layerZeroEndpoint.setConfig(_version, _chainId, _configType, _config);\n    }\n\n    function setSendVersion(uint16 version) external override onlyOwner {\n        layerZeroEndpoint.setSendVersion(version);\n    }\n\n    function setReceiveVersion(uint16 version) external override onlyOwner {\n        layerZeroEndpoint.setReceiveVersion(version);\n    }\n\n    //---------------------------------------------------------------------------\n    // INTERNAL functions\n    function txParamBuilderType1(uint256 _gasAmount) internal pure returns (bytes memory) {\n        uint16 txType = 1;\n        return abi.encodePacked(txType, _gasAmount);\n    }\n\n    function txParamBuilderType2(\n        uint256 _gasAmount,\n        uint256 _dstNativeAmount,\n        bytes memory _dstNativeAddr\n    ) internal pure returns (bytes memory) {\n        uint16 txType = 2;\n        return abi.encodePacked(txType, _gasAmount, _dstNativeAmount, _dstNativeAddr);\n    }\n\n    function _txParamBuilder(\n        uint16 _chainId,\n        uint8 _type,\n        IStargateRouter.lzTxObj memory _lzTxParams\n    ) internal view returns (bytes memory) {\n        bytes memory lzTxParam;\n        address dstNativeAddr;\n        {\n            bytes memory dstNativeAddrBytes = _lzTxParams.dstNativeAddr;\n            assembly {\n                dstNativeAddr := mload(add(dstNativeAddrBytes, 20))\n            }\n        }\n\n        uint256 totalGas = gasLookup[_chainId][_type].add(_lzTxParams.dstGasForCall);\n        if (_lzTxParams.dstNativeAmount > 0 && dstNativeAddr != address(0x0)) {\n            lzTxParam = txParamBuilderType2(totalGas, _lzTxParams.dstNativeAmount, _lzTxParams.dstNativeAddr);\n        } else {\n            lzTxParam = txParamBuilderType1(totalGas);\n        }\n\n        return lzTxParam;\n    }\n\n    function _call(\n        uint16 _chainId,\n        uint8 _type,\n        address payable _refundAddress,\n        IStargateRouter.lzTxObj memory _lzTxParams,\n        bytes memory _payload\n    ) internal {\n        bytes memory lzTxParamBuilt = _txParamBuilder(_chainId, _type, _lzTxParams);\n        uint64 nextNonce = layerZeroEndpoint.getOutboundNonce(_chainId, address(this)) + 1;\n        layerZeroEndpoint.send{value: msg.value}(_chainId, bridgeLookup[_chainId], _payload, _refundAddress, address(this), lzTxParamBuilt);\n        emit SendMsg(_type, nextNonce);\n    }\n\n    function renounceOwnership() public override onlyOwner {}\n}"
    },
    {
      "filename": "contracts/Bridge.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\n// imports\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./Pool.sol\";\nimport \"./Router.sol\";\n\n// libraries\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./interfaces/ILayerZeroReceiver.sol\";\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\nimport \"./interfaces/ILayerZeroUserApplicationConfig.sol\";\n\ncontract Bridge is Ownable, ILayerZeroReceiver, ILayerZeroUserApplicationConfig {\n    using SafeMath for uint256;\n\n    //---------------------------------------------------------------------------\n    // CONSTANTS\n    uint8 internal constant TYPE_SWAP_REMOTE = 1;\n    uint8 internal constant TYPE_ADD_LIQUIDITY = 2;\n    uint8 internal constant TYPE_REDEEM_LOCAL_CALL_BACK = 3;\n    uint8 internal constant TYPE_WITHDRAW_REMOTE = 4;\n\n    //---------------------------------------------------------------------------\n    // VARIABLES\n    ILayerZeroEndpoint public immutable layerZeroEndpoint;\n    mapping(uint16 => bytes) public bridgeLookup;\n    mapping(uint16 => mapping(uint8 => uint256)) public gasLookup;\n    Router public immutable router;\n    bool public useLayerZeroToken;\n\n    //---------------------------------------------------------------------------\n    // EVENTS\n    event SendMsg(uint8 msgType, uint64 nonce);\n\n    //---------------------------------------------------------------------------\n    // MODIFIERS\n    modifier onlyRouter() {\n        require(msg.sender == address(router), \"Stargate: caller must be Router.\");\n        _;\n    }\n\n    constructor(address _layerZeroEndpoint, address _router) {\n        require(_layerZeroEndpoint != address(0x0), \"Stargate: _layerZeroEndpoint cannot be 0x0\");\n        require(_router != address(0x0), \"Stargate: _router cannot be 0x0\");\n        layerZeroEndpoint = ILayerZeroEndpoint(_layerZeroEndpoint);\n        router = Router(_router);\n    }\n\n    //---------------------------------------------------------------------------\n    // EXTERNAL functions\n\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) external override {\n        require(msg.sender == address(layerZeroEndpoint), \"Stargate: only LayerZero endpoint can call lzReceive\");\n        require(\n            _srcAddress.length == bridgeLookup[_srcChainId].length && keccak256(_srcAddress) == keccak256(bridgeLookup[_srcChainId]),\n            \"Stargate: bridge does not match\"\n        );\n\n        uint8 functionType;\n        assembly {\n            functionType := mload(add(_payload, 32))\n        }\n\n        if (functionType == TYPE_SWAP_REMOTE) {\n            (\n                ,\n                uint256 srcPoolId,\n                uint256 dstPoolId,\n                uint256 dstGasForCall,\n                Pool.CreditObj memory c,\n                Pool.SwapObj memory s,\n                bytes memory to,\n                bytes memory payload\n            ) = abi.decode(_payload, (uint8, uint256, uint256, uint256, Pool.CreditObj, Pool.SwapObj, bytes, bytes));\n            address toAddress;\n            assembly {\n                toAddress := mload(add(to, 20))\n            }\n            router.creditChainPath(_srcChainId, srcPoolId, dstPoolId, c);\n            router.swapRemote(_srcChainId, _srcAddress, _nonce, srcPoolId, dstPoolId, dstGasForCall, toAddress, s, payload);\n        } else if (functionType == TYPE_ADD_LIQUIDITY) {\n            (, uint256 srcPoolId, uint256 dstPoolId, Pool.CreditObj memory c) = abi.decode(_payload, (uint8, uint256, uint256, Pool.CreditObj));\n            router.creditChainPath(_srcChainId, srcPoolId, dstPoolId, c);\n        } else if (functionType == TYPE_REDEEM_LOCAL_CALL_BACK) {\n            (, uint256 srcPoolId, uint256 dstPoolId, Pool.CreditObj memory c, uint256 amountSD, uint256 mintAmountSD, bytes memory to) = abi\n                .decode(_payload, (uint8, uint256, uint256, Pool.CreditObj, uint256, uint256, bytes));\n            address toAddress;\n            assembly {\n                toAddress := mload(add(to, 20))\n            }\n            router.creditChainPath(_srcChainId, srcPoolId, dstPoolId, c);\n            router.redeemLocalCallback(_srcChainId, _srcAddress, _nonce, srcPoolId, dstPoolId, toAddress, amountSD, mintAmountSD);\n        } else if (functionType == TYPE_WITHDRAW_REMOTE) {\n            (, uint256 srcPoolId, uint256 dstPoolId, Pool.CreditObj memory c, uint256 amountSD, bytes memory to) = abi.decode(\n                _payload,\n                (uint8, uint256, uint256, Pool.CreditObj, uint256, bytes)\n            );\n            router.creditChainPath(_srcChainId, srcPoolId, dstPoolId, c);\n            router.redeemLocalCheckOnRemote(_srcChainId, _srcAddress, _nonce, srcPoolId, dstPoolId, amountSD, to);\n        }\n    }\n\n    //---------------------------------------------------------------------------\n    // LOCAL CHAIN FUNCTIONS\n    function swap(\n        uint16 _chainId,\n        uint256 _srcPoolId,\n        uint256 _dstPoolId,\n        address payable _refundAddress,\n        Pool.CreditObj memory _c,\n        Pool.SwapObj memory _s,\n        IStargateRouter.lzTxObj memory _lzTxParams,\n        bytes calldata _to,\n        bytes calldata _payload\n    ) external payable onlyRouter {\n        bytes memory payload = abi.encode(TYPE_SWAP_REMOTE, _srcPoolId, _dstPoolId, _lzTxParams.dstGasForCall, _c, _s, _to, _payload);\n        _call(_chainId, TYPE_SWAP_REMOTE, _refundAddress, _lzTxParams, payload);\n    }\n\n    function redeemLocalCallback(\n        uint16 _chainId,\n        address payable _refundAddress,\n        Pool.CreditObj memory _c,\n        IStargateRouter.lzTxObj memory _lzTxParams,\n        bytes memory _payload\n    ) external payable onlyRouter {\n        bytes memory payload;\n\n        {\n            (, uint256 srcPoolId, uint256 dstPoolId, uint256 amountSD, uint256 mintAmountSD, bytes memory to) = abi.decode(\n                _payload,\n                (uint8, uint256, uint256, uint256, uint256, bytes)\n            );\n\n            // swap dst and src because we are headed back\n            payload = abi.encode(TYPE_REDEEM_LOCAL_CALL_BACK, dstPoolId, srcPoolId, _c, amountSD, mintAmountSD, to);\n        }\n\n        _call(_chainId, TYPE_REDEEM_LOCAL_CALL_BACK, _refundAddress, _lzTxParams, payload);\n    }\n\n    function redeemLocal(\n        uint16 _chainId,\n        uint256 _srcPoolId,\n        uint256 _dstPoolId,\n        address payable _refundAddress,\n        Pool.CreditObj memory _c,\n        uint256 _amountSD,\n        bytes calldata _to,\n        IStargateRouter.lzTxObj memory _lzTxParams\n    ) external payable onlyRouter {\n        bytes memory payload = abi.encode(TYPE_WITHDRAW_REMOTE, _srcPoolId, _dstPoolId, _c, _amountSD, _to);\n        _call(_chainId, TYPE_WITHDRAW_REMOTE, _refundAddress, _lzTxParams, payload);\n    }\n\n    function sendCredits(\n        uint16 _chainId,\n        uint256 _srcPoolId,\n        uint256 _dstPoolId,\n        address payable _refundAddress,\n        Pool.CreditObj memory _c\n    ) external payable onlyRouter {\n        bytes memory payload = abi.encode(TYPE_ADD_LIQUIDITY, _srcPoolId, _dstPoolId, _c);\n        IStargateRouter.lzTxObj memory lzTxObj = IStargateRouter.lzTxObj(0, 0, \"0x\");\n        _call(_chainId, TYPE_ADD_LIQUIDITY, _refundAddress, lzTxObj, payload);\n    }\n\n    function quoteLayerZeroFee(\n        uint16 _chainId,\n        uint8 _functionType,\n        bytes calldata _toAddress,\n        bytes calldata _transferAndCallPayload,\n        IStargateRouter.lzTxObj memory _lzTxParams\n    ) external view returns (uint256, uint256) {\n        bytes memory payload = \"\";\n        Pool.CreditObj memory c = Pool.CreditObj(1, 1);\n        if (_functionType == TYPE_SWAP_REMOTE) {\n            Pool.SwapObj memory s = Pool.SwapObj(1, 1, 1, 1, 1, 1);\n            payload = abi.encode(TYPE_SWAP_REMOTE, 0, 0, 0, c, s, _toAddress, _transferAndCallPayload);\n        } else if (_functionType == TYPE_ADD_LIQUIDITY) {\n            payload = abi.encode(TYPE_ADD_LIQUIDITY, 0, 0, c);\n        } else if (_functionType == TYPE_REDEEM_LOCAL_CALL_BACK) {\n            payload = abi.encode(TYPE_REDEEM_LOCAL_CALL_BACK, 0, 0, c, 0, 0, _toAddress);\n        } else if (_functionType == TYPE_WITHDRAW_REMOTE) {\n            payload = abi.encode(TYPE_WITHDRAW_REMOTE, 0, 0, c, 0, _toAddress);\n        } else {\n            revert(\"Stargate: unsupported function type\");\n        }\n\n        bytes memory lzTxParamBuilt = _txParamBuilder(_chainId, _functionType, _lzTxParams);\n        return layerZeroEndpoint.estimateFees(_chainId, address(this), payload, useLayerZeroToken, lzTxParamBuilt);\n    }\n\n    //---------------------------------------------------------------------"
    }
  ]
}