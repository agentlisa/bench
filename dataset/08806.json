{
  "Title": "[M-12] Incorrect Adopted mapping on updating wrapper token",
  "Content": "_Submitted by codexploder_\n\n[AssetFacet.sol#L100](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/AssetFacet.sol#L100)<br>\n\n1.  Admin can call setWrapper function to setup a new wrapper Y instead of old wrapper X\n\n2.  This becomes a problem for any old asset which was setup during setupAsset call where `s.canonicalToAdopted[_canonical.id]`  will still point to old wrapper X instead of Y\n\n### Recommended Mitigation Steps\n\nIf wrapper is changed then all variables storing this wrapper should also update.\n\n**[jakekidd (Connext) confirmed and commented](https://github.com/code-423n4/2022-06-connext-findings/issues/86#issuecomment-1166617403):**\n > Good spot. This line in `setupAsset` suggests that we should be setting the wrapper for `canonicalToAdopted`, so this is correct:\n> \n> [AssetFacet.sol#L143](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/AssetFacet.sol#L143)<br>\n> \n> Fixing this won't be super straightforward - we'll have to add another property to tell us the canonical ID(s?) that are currently pointing to the wrapper contract as the adopted asset.\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-06-connext-findings/issues/86#issuecomment-1214478669):**\n > Agree that this would cause compatibility issues. The admin will be unable to call `setupAsset` and update the adopted mapping correctly.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-06-connext",
  "Code": [
    {
      "filename": "contracts/contracts/core/connext/facets/AssetFacet.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\nimport {ConnextMessage} from \"../libraries/ConnextMessage.sol\";\nimport {IStableSwap} from \"../interfaces/IStableSwap.sol\";\nimport {IWrapped} from \"../interfaces/IWrapped.sol\";\nimport {ITokenRegistry} from \"../interfaces/ITokenRegistry.sol\";\n\ncontract AssetFacet is BaseConnextFacet {\n  // ========== Custom Errors ===========\n  error AssetFacet__setWrapper_invalidWrapper();\n  error AssetFacet__setTokenRegistry_invalidTokenRegistry();\n  error AssetFacet__addAssetId_alreadyAdded();\n  error AssetFacet__removeAssetId_notAdded();\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when the wrapper variable is updated\n   * @param oldWrapper - The wrapper old value\n   * @param newWrapper - The wrapper new value\n   * @param caller - The account that called the function\n   */\n  event WrapperUpdated(address oldWrapper, address newWrapper, address caller);\n\n  /**\n   * @notice Emitted when the tokenRegistry variable is updated\n   * @param oldTokenRegistry - The tokenRegistry old value\n   * @param newTokenRegistry - The tokenRegistry new value\n   * @param caller - The account that called the function\n   */\n  event TokenRegistryUpdated(address oldTokenRegistry, address newTokenRegistry, address caller);\n\n  /**\n   * @notice Emitted when a new stable-swap AMM is added for the local <> adopted token\n   * @param canonicalId - The canonical identifier of the token the local <> adopted AMM is for\n   * @param domain - The domain of the canonical token for the local <> adopted amm\n   * @param swapPool - The address of the AMM\n   * @param caller - The account that called the function\n   */\n  event StableSwapAdded(bytes32 canonicalId, uint32 domain, address swapPool, address caller);\n\n  /**\n   * @notice Emitted when a new asset is added\n   * @param canonicalId - The canonical identifier of the token the local <> adopted AMM is for\n   * @param domain - The domain of the canonical token for the local <> adopted amm\n   * @param adoptedAsset - The address of the adopted (user-expected) asset\n   * @param supportedAsset - The address of the whitelisted asset. If the native asset is to be whitelisted,\n   * the address of the wrapped version will be stored\n   * @param caller - The account that called the function\n   */\n  event AssetAdded(bytes32 canonicalId, uint32 domain, address adoptedAsset, address supportedAsset, address caller);\n\n  /**\n   * @notice Emitted when an asset is removed from whitelists\n   * @param canonicalId - The canonical identifier of the token removed\n   * @param caller - The account that called the function\n   */\n  event AssetRemoved(bytes32 canonicalId, address caller);\n\n  // ============ Getters ============\n\n  function canonicalToAdopted(bytes32 _canonicalId) public view returns (address) {\n    return s.canonicalToAdopted[_canonicalId];\n  }\n\n  function adoptedToCanonical(address _adopted) public view returns (ConnextMessage.TokenId memory) {\n    ConnextMessage.TokenId memory canonical = ConnextMessage.TokenId(\n      s.adoptedToCanonical[_adopted].domain,\n      s.adoptedToCanonical[_adopted].id\n    );\n    return canonical;\n  }\n\n  function approvedAssets(bytes32 _asset) public view returns (bool) {\n    return s.approvedAssets[_asset];\n  }\n\n  function adoptedToLocalPools(bytes32 _adopted) public view returns (IStableSwap) {\n    return s.adoptedToLocalPools[_adopted];\n  }\n\n  function wrapper() public view returns (IWrapped) {\n    return s.wrapper;\n  }\n\n  function tokenRegistry() public view returns (ITokenRegistry) {\n    return s.tokenRegistry;\n  }\n\n  // ============ Admin functions ============\n\n  /**\n   * @notice Updates the native-asset wrapper interface\n   * @param _wrapper The address of the new wrapper\n   */\n  function setWrapper(address _wrapper) external onlyOwner {\n    address old = address(s.wrapper);\n    if (old == _wrapper || !Address.isContract(_wrapper)) revert AssetFacet__setWrapper_invalidWrapper();\n\n    s.wrapper = IWrapped(_wrapper);\n    emit WrapperUpdated(old, _wrapper, msg.sender);\n  }\n\n  /**\n   * @notice Updates the token registry\n   * @param _tokenRegistry The new token registry address\n   */\n  function setTokenRegistry(address _tokenRegistry) external onlyOwner {\n    address old = address(s.tokenRegistry);\n    if (old == _tokenRegistry || !Address.isContract(_tokenRegistry))\n      revert AssetFacet__setTokenRegistry_invalidTokenRegistry();\n\n    s.tokenRegistry = ITokenRegistry(_tokenRegistry);\n    emit TokenRegistryUpdated(old, _tokenRegistry, msg.sender);\n  }\n\n  /**\n   * @notice Used to add supported assets. This is an admin only function\n   * @dev When whitelisting the canonical asset, all representational assets would be\n   * whitelisted as well. In the event you have a different adopted asset (i.e. PoS USDC\n   * on polygon), you should *not* whitelist the adopted asset. The stable swap pool\n   * address used should allow you to swap between the local <> adopted asset\n   * @param _canonical - The canonical asset to add by id and domain. All representations\n   * will be whitelisted as well\n   * @param _adoptedAssetId - The used asset id for this domain (i.e. PoS USDC for\n   * polygon)\n   */\n  function setupAsset(\n    ConnextMessage.TokenId calldata _canonical,\n    address _adoptedAssetId,\n    address _stableSwapPool\n  ) external onlyOwner {\n    // Sanity check: needs approval\n    if (s.approvedAssets[_canonical.id]) revert AssetFacet__addAssetId_alreadyAdded();\n\n    // Update approved assets mapping\n    s.approvedAssets[_canonical.id] = true;\n\n    address supported = _adoptedAssetId == address(0) ? address(s.wrapper) : _adoptedAssetId;\n\n    // Update the adopted mapping\n    s.adoptedToCanonical[supported].domain = _canonical.domain;\n    s.adoptedToCanonical[supported].id = _canonical.id;\n\n    // Update the canonical mapping\n    s.canonicalToAdopted[_canonical.id] = supported;\n\n    // Emit event\n    emit AssetAdded(_canonical.id, _canonical.domain, _adoptedAssetId, supported, msg.sender);\n\n    // Add the swap pool\n    _addStableSwapPool(_canonical, _stableSwapPool);\n  }\n\n  /**\n   * @notice Adds a stable swap pool for the local <> adopted asset.\n   */\n  function addStableSwapPool(ConnextMessage.TokenId calldata _canonical, address _stableSwapPool) external onlyOwner {\n    _addStableSwapPool(_canonical, _stableSwapPool);\n  }\n\n  /**\n   * @notice Used to remove assets from the whitelist\n   * @param _canonicalId - Token id to remove\n   * @param _adoptedAssetId - Corresponding adopted asset to remove\n   */\n  function removeAssetId(bytes32 _canonicalId, address _adoptedAssetId) external onlyOwner {\n    // Sanity check: already approval\n    if (!s.approvedAssets[_canonicalId]) revert AssetFacet__removeAssetId_notAdded();\n\n    // Delete from approved assets mapping\n    delete s.approvedAssets[_canonicalId];\n\n    // Delete from pools\n    delete s.adoptedToLocalPools[_canonicalId];\n\n    // Delete from adopted mapping\n    delete s.adoptedToCanonical[_adoptedAssetId == address(0) ? address(s.wrapper) : _adoptedAssetId];\n\n    // Delete from canonical mapping\n    delete s.canonicalToAdopted[_canonicalId];\n\n    // Emit event\n    emit AssetRemoved(_canonicalId, msg.sender);\n  }\n\n  // ============ Private Functions ============\n\n  /**\n   * @notice Used to add an AMM for adopted <> local assets\n   * @param _canonical - The canonical TokenId to add (domain and id)\n   * @param _stableSwap - The address of the amm to add\n   */\n  function _addStableSwapPool(ConnextMessage.TokenId calldata _canonical, address _stableSwap) internal {\n    // Update the pool mapping\n    s.adoptedToLocalPools[_canonical.id] = IStableSwap(_stableSwap);\n\n    emit StableSwapAdded(_canonical.id, _canonical.domain, _stableSwap, msg.sender);\n  }\n}"
    },
    {
      "filename": "contracts/contracts/core/connext/facets/AssetFacet.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\nimport {ConnextMessage} from \"../libraries/ConnextMessage.sol\";\nimport {IStableSwap} from \"../interfaces/IStableSwap.sol\";\nimport {IWrapped} from \"../interfaces/IWrapped.sol\";\nimport {ITokenRegistry} from \"../interfaces/ITokenRegistry.sol\";\n\ncontract AssetFacet is BaseConnextFacet {\n  // ========== Custom Errors ===========\n  error AssetFacet__setWrapper_invalidWrapper();\n  error AssetFacet__setTokenRegistry_invalidTokenRegistry();\n  error AssetFacet__addAssetId_alreadyAdded();\n  error AssetFacet__removeAssetId_notAdded();\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when the wrapper variable is updated\n   * @param oldWrapper - The wrapper old value\n   * @param newWrapper - The wrapper new value\n   * @param caller - The account that called the function\n   */\n  event WrapperUpdated(address oldWrapper, address newWrapper, address caller);\n\n  /**\n   * @notice Emitted when the tokenRegistry variable is updated\n   * @param oldTokenRegistry - The tokenRegistry old value\n   * @param newTokenRegistry - The tokenRegistry new value\n   * @param caller - The account that called the function\n   */\n  event TokenRegistryUpdated(address oldTokenRegistry, address newTokenRegistry, address caller);\n\n  /**\n   * @notice Emitted when a new stable-swap AMM is added for the local <> adopted token\n   * @param canonicalId - The canonical identifier of the token the local <> adopted AMM is for\n   * @param domain - The domain of the canonical token for the local <> adopted amm\n   * @param swapPool - The address of the AMM\n   * @param caller - The account that called the function\n   */\n  event StableSwapAdded(bytes32 canonicalId, uint32 domain, address swapPool, address caller);\n\n  /**\n   * @notice Emitted when a new asset is added\n   * @param canonicalId - The canonical identifier of the token the local <> adopted AMM is for\n   * @param domain - The domain of the canonical token for the local <> adopted amm\n   * @param adoptedAsset - The address of the adopted (user-expected) asset\n   * @param supportedAsset - The address of the whitelisted asset. If the native asset is to be whitelisted,\n   * the address of the wrapped version will be stored\n   * @param caller - The account that called the function\n   */\n  event AssetAdded(bytes32 canonicalId, uint32 domain, address adoptedAsset, address supportedAsset, address caller);\n\n  /**\n   * @notice Emitted when an asset is removed from whitelists\n   * @param canonicalId - The canonical identifier of the token removed\n   * @param caller - The account that called the function\n   */\n  event AssetRemoved(bytes32 canonicalId, address caller);\n\n  // ============ Getters ============\n\n  function canonicalToAdopted(bytes32 _canonicalId) public view returns (address) {\n    return s.canonicalToAdopted[_canonicalId];\n  }\n\n  function adoptedToCanonical(address _adopted) public view returns (ConnextMessage.TokenId memory) {\n    ConnextMessage.TokenId memory canonical = ConnextMessage.TokenId(\n      s.adoptedToCanonical[_adopted].domain,\n      s.adoptedToCanonical[_adopted].id\n    );\n    return canonical;\n  }\n\n  function approvedAssets(bytes32 _asset) public view returns (bool) {\n    return s.approvedAssets[_asset];\n  }\n\n  function adoptedToLocalPools(bytes32 _adopted) public view returns (IStableSwap) {\n    return s.adoptedToLocalPools[_adopted];\n  }\n\n  function wrapper() public view returns (IWrapped) {\n    return s.wrapper;\n  }\n\n  function tokenRegistry() public view returns (ITokenRegistry) {\n    return s.tokenRegistry;\n  }\n\n  // ============ Admin functions ============\n\n  /**\n   * @notice Updates the native-asset wrapper interface\n   * @param _wrapper The address of the new wrapper\n   */\n  function setWrapper(address _wrapper) external onlyOwner {\n    address old = address(s.wrapper);\n    if (old == _wrapper || !Address.isContract(_wrapper)) revert AssetFacet__setWrapper_invalidWrapper();\n\n    s.wrapper = IWrapped(_wrapper);\n    emit WrapperUpdated(old, _wrapper, msg.sender);\n  }\n\n  /**\n   * @notice Updates the token registry\n   * @param _tokenRegistry The new token registry address\n   */\n  function setTokenRegistry(address _tokenRegistry) external onlyOwner {\n    address old = address(s.tokenRegistry);\n    if (old == _tokenRegistry || !Address.isContract(_tokenRegistry))\n      revert AssetFacet__setTokenRegistry_invalidTokenRegistry();\n\n    s.tokenRegistry = ITokenRegistry(_tokenRegistry);\n    emit TokenRegistryUpdated(old, _tokenRegistry, msg.sender);\n  }\n\n  /**\n   * @notice Used to add supported assets. This is an admin only function\n   * @dev When whitelisting the canonical asset, all representational assets would be\n   * whitelisted as well. In the event you have a different adopted asset (i.e. PoS USDC\n   * on polygon), you should *not* whitelist the adopted asset. The stable swap pool\n   * address used should allow you to swap between the local <> adopted asset\n   * @param _canonical - The canonical asset to add by id and domain. All representations\n   * will be whitelisted as well\n   * @param _adoptedAssetId - The used asset id for this domain (i.e. PoS USDC for\n   * polygon)\n   */\n  function setupAsset(\n    ConnextMessage.TokenId calldata _canonical,\n    address _adoptedAssetId,\n    address _stableSwapPool\n  ) external onlyOwner {\n    // Sanity check: needs approval\n    if (s.approvedAssets[_canonical.id]) revert AssetFacet__addAssetId_alreadyAdded();\n\n    // Update approved assets mapping\n    s.approvedAssets[_canonical.id] = true;\n\n    address supported = _adoptedAssetId == address(0) ? address(s.wrapper) : _adoptedAssetId;\n\n    // Update the adopted mapping\n    s.adoptedToCanonical[supported].domain = _canonical.domain;\n    s.adoptedToCanonical[supported].id = _canonical.id;\n\n    // Update the canonical mapping\n    s.canonicalToAdopted[_canonical.id] = supported;\n\n    // Emit event\n    emit AssetAdded(_canonical.id, _canonical.domain, _adoptedAssetId, supported, msg.sender);\n\n    // Add the swap pool\n    _addStableSwapPool(_canonical, _stableSwapPool);\n  }\n\n  /**\n   * @notice Adds a stable swap pool for the local <> adopted asset.\n   */\n  function addStableSwapPool(ConnextMessage.TokenId calldata _canonical, address _stableSwapPool) external onlyOwner {\n    _addStableSwapPool(_canonical, _stableSwapPool);\n  }\n\n  /**\n   * @notice Used to remove assets from the whitelist\n   * @param _canonicalId - Token id to remove\n   * @param _adoptedAssetId - Corresponding adopted asset to remove\n   */\n  function removeAssetId(bytes32 _canonicalId, address _adoptedAssetId) external onlyOwner {\n    // Sanity check: already approval\n    if (!s.approvedAssets[_canonicalId]) revert AssetFacet__removeAssetId_notAdded();\n\n    // Delete from approved assets mapping\n    delete s.approvedAssets[_canonicalId];\n\n    // Delete from pools\n    delete s.adoptedToLocalPools[_canonicalId];\n\n    // Delete from adopted mapping\n    delete s.adoptedToCanonical[_adoptedAssetId == address(0) ? address(s.wrapper) : _adoptedAssetId];\n\n    // Delete from canonical mapping\n    delete s.canonicalToAdopted[_canonicalId];\n\n    // Emit event\n    emit AssetRemoved(_canonicalId, msg.sender);\n  }\n\n  // ============ Private Functions ============\n\n  /**\n   * @notice Used to add an AMM for adopted <> local assets\n   * @param _canonical - The canonical TokenId to add (domain and id)\n   * @param _stableSwap - The address of the amm to add\n   */\n  function _addStableSwapPool(ConnextMessage.TokenId calldata _canonical, address _stableSwap) internal {\n    // Update the pool mapping\n    s.adoptedToLocalPools[_canonical.id] = IStableSwap(_stableSwap);\n\n    emit StableSwapAdded(_canonical.id, _canonical.domain, _stableSwap, msg.sender);\n  }\n}"
    }
  ]
}