{
  "Title": "H-6: Outstanding loans cannot be closed or liquidated if collateral is paused",
  "Content": "# Issue H-6: Outstanding loans cannot be closed or liquidated if collateral is paused \n\nSource: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/57 \n\n## Found by \n0x52, HonorLt\n\n## Summary\n\nWhen a collateral is paused by governance, `collateralValid` is set to false. This causes closing and liquidating of loans to be impossible, leading to two issues. The first is that users with exist loans are unable to close their loans to recover their collateral. The second is that since debt is impossible to liquidate the protocol could end up being stuck with a lot of bad debt.\n\n## Vulnerability Detail\n\n    function pauseCollateralType(\n        address _collateralAddress,\n        bytes32 _currencyKey\n        ) external collateralExists(_collateralAddress) onlyAdmin {\n        require(_collateralAddress != address(0)); //this should get caught by the collateralExists check but just to be careful\n        //checks two inputs to help prevent input mistakes\n        require( _currencyKey == collateralProps[_collateralAddress].currencyKey, \"Mismatched data\");\n        collateralValid[_collateralAddress] = false;\n        collateralPaused[_collateralAddress] = true;\n    }\n\nWhen a collateral is paused `collateralValid[_collateralAddress]` is set to `false`. For `Vault_Lyra` `Vault_Synths` and `Vault_Velo` this will cause `closeLoan` and `callLiquidation` to revert. This traps existing users and prevents liquidations which will result in bad debt for the protocol\n\n## Impact\n\nOutstanding loans cannot be closed or liquidated, freezing user funds and causing the protocol to take on bad debt\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/CollateralBook.sol#L185-L195\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAllow liquidations and loan closure when collateral is paused\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor confirmed, will fix. We will make it possible to close a loan or liquidate a loan when the collateral is paused.\n\n**kree-dotcom**\n\nFixed. https://github.com/kree-dotcom/isomorph/commit/9fef84211c150a6d184b2c492f77fa13b8adc61b \n\nBy decoupling the switching of the CollateralValid mapping in the `CollateralBook.sol` from CollateralPaused we can now introduce an additional check in `OpenLoan()` of `require(!collateralBook.collateralPaused(_collateralAddress), \"Paused collateral!\");` \nThis means `increaseCollateralAmount()`, `closeLoan()` and `callLiquidation()` can all occur for paused collaterals.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/22",
  "Code": [
    {
      "filename": "contracts/Isomorph/contracts/CollateralBook.sol",
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.9;\npragma abicoder v2;\nimport \"./RoleControl.sol\";\nimport \"./interfaces/ICollateralBook.sol\";\nimport \"./interfaces/IVault.sol\";\n\nuint256 constant COLLATERAL_BOOK_TIME_DELAY = 3 days;\n\ncontract CollateralBook is RoleControl(COLLATERAL_BOOK_TIME_DELAY){\n\n    mapping(address => bool) public collateralValid;\n    mapping(address => bool) public collateralPaused;\n    mapping(address => Collateral) public collateralProps;\n    mapping(bytes32 => address) public liquidityPoolOf;\n    mapping(uint256 => address) public vaults;\n\n    \n    bytes32 public constant VAULT_ROLE = keccak256(\"MINTER_ROLE\");\n\n    uint256 public constant THREE_MIN = 180;\n    uint256 public constant DIVISION_BASE = 1 ether;\n    uint256 public constant CHANGE_COLLATERAL_DELAY = 200; //2 days\n\n    //temporary data stores for changing Collateral variables\n    address queuedCollateralAddress;\n    bytes32 queuedCurrencyKey;\n    uint256 queuedMinimumRatio;\n    uint256 queuedLiquidationRatio;\n    uint256 queuedInterestPer3Min;\n    address queuedLiquidityPool;\n    uint256 queuedTimestamp;\n\n    // @notice minOpeningMargin MUST always be set high enough that \n    // a single update in the Chainlink pricefeed underlying Synthetix \n    // is significantly unlikely to produce an undercollateralized loan else the system is frontrunnable.\n    struct Collateral {\n        bytes32 currencyKey; //used by synthetix to identify synths\n        uint256 minOpeningMargin; //minimum loan margin required on opening or adjusting a loan\n        uint256 liquidatableMargin; //margin point below which a loan can be liquidated\n        uint256 interestPer3Min; //what percentage the interest grows by every 3 minutes\n        uint256 lastUpdateTime; //last blocktimestamp this collateral's virtual price was updated\n        uint256 virtualPrice; //price accounting for growing interest accrued on any loans taken in this collateral\n        uint256 assetType; //number to indicate what system this collateral token belongs to, \n                            // assetType is used to determine which Vault we are looking at\n    }\n\n\n    modifier collateralExists(address _collateralAddress){\n        require(collateralValid[_collateralAddress], \"Unsupported collateral!\");\n        _;\n    }\n\n    modifier onlyVault{\n        require(hasRole(VAULT_ROLE, msg.sender), \"Only updatable by vault\");\n        _;\n    }\n\n     constructor() {\n        //we dont want the `DEFAULT_ADMIN_ROLE` to exist as this doesn't require a \n        // time delay to add/remove any role and so is dangerous. \n        //So we do not set it and set our weaker admin role.\n        _setupRole(ADMIN_ROLE, msg.sender);\n    }\n\n    /**\n      * @notice Used for testing or when a bot wants to check virtualPrice of an asset\n      * @param _collateralAddress address of collateral token being used.\n       */\n    function viewVirtualPriceforAsset(address _collateralAddress) external view returns(uint256){\n        return (collateralProps[_collateralAddress].virtualPrice);\n    }\n\n    /**\n      * @notice Used for testing or when a bot wants to check if a collateral token needs the virtualPrice \n            manually updated due to inactivity.\n      * @param _collateralAddress address of collateral token being used.\n       */\n    function viewLastUpdateTimeforAsset(address _collateralAddress) external view returns(uint256){\n        return (collateralProps[_collateralAddress].lastUpdateTime);\n    }\n\n     /**\n      * @notice Only Admin can modify collateral tokens,\n      * @notice two step process to enforce a timelock for changing collateral\n      * @notice first you call queueCollateralChange() then changeCollateralType() after timelock period ends\n      * @dev does not allow changing token address, if this changes add a new collateral.\n      * @param _collateralAddress address of collateral token being used.\n      * @param _currencyKey symbol() returned string, used for synthetix calls\n      * @param _minimumRatio lowest margin ratio for opening debts with new collateral token\n      * @param _liquidationRatio margin ratio at which a loan backed by said collateral can be liquidated.\n      * @param _interestPer3Min interest charged per block to loan holders using this collateral.\n      * @param _liquidityPool only set for Lyra LP tokens, this address is where price info of the LP token is stored. The Zero address is used for non-Lyra Collateral\n     **/\n    function queueCollateralChange(\n        address _collateralAddress,\n        bytes32 _currencyKey,\n        uint256 _minimumRatio,\n        uint256 _liquidationRatio,\n        uint256 _interestPer3Min,\n        uint256 _assetType,\n        address _liquidityPool\n\n    ) external collateralExists(_collateralAddress) onlyAdmin {\n        require(_collateralAddress != address(0));\n        require(_minimumRatio > _liquidationRatio);\n        require(_liquidationRatio != 0);\n        require(vaults[_assetType] != address(0), \"Vault not deployed yet\");\n        IVault vault = IVault(vaults[_assetType]);\n        //prevent setting liquidationRatio too low such that it would cause an overflow in callLiquidation, see appendix on liquidation maths for details.\n        require( vault.LIQUIDATION_RETURN() *_liquidationRatio >= 10 ** 36, \"Liquidation ratio too low\");\n\n        queuedCollateralAddress = _collateralAddress;\n        queuedCurrencyKey = _currencyKey;\n        queuedMinimumRatio = _minimumRatio;\n        queuedLiquidationRatio = _liquidationRatio;\n        queuedInterestPer3Min = _interestPer3Min;\n        queuedLiquidityPool = _liquidityPool;\n        queuedTimestamp = block.timestamp;\n    }\n    /**\n    * @notice Only Admin can modify collateral tokens, \n    * @notice forces virtualPrice to be up-to-date when updating to prevent retroactive interest rate changes.\n    * @dev if time since last virtual price update is too long, \n    * @dev you must cycle it via the vault.updateVirtualPriceSlowly function or this function will revert\n     */\n    function changeCollateralType() external onlyAdmin {\n        uint256 submissionTimestamp = queuedTimestamp;\n        require(submissionTimestamp != 0, \"Uninitialized collateral change\");\n        require(submissionTimestamp + CHANGE_COLLATERAL_DELAY <= block.timestamp, \"Not enough time passed\");\n        address collateralAddress = queuedCollateralAddress;\n        bytes32 currencyKey = queuedCurrencyKey;\n        uint256 minimumRatio = queuedMinimumRatio;\n        uint256 liquidationRatio = queuedLiquidationRatio;\n        uint256 interestPer3Min = queuedInterestPer3Min;\n        address liquidityPool = queuedLiquidityPool;\n        \n\n        //Now we must ensure interestPer3Min changes aren't applied retroactively\n        // by updating the assets virtualPrice to current block timestamp\n        uint256 timeDelta = (block.timestamp - collateralProps[collateralAddress].lastUpdateTime) / THREE_MIN;\n        if (timeDelta != 0){ \n           updateVirtualPriceSlowly(collateralAddress, timeDelta );\n        }\n        bytes32 oldCurrencyKey = collateralProps[collateralAddress].currencyKey;\n\n        _changeCollateralParameters(\n            collateralAddress,\n            currencyKey,\n            minimumRatio,\n            liquidationRatio,\n            interestPer3Min\n        );\n        //Then update LiqPool as this isn't stored in the struct and requires the currencyKey also.\n        liquidityPoolOf[oldCurrencyKey]= address(0); \n        liquidityPoolOf[currencyKey]= liquidityPool;\n        \n    }\n\n   /** \n      * @dev This function should only be used by trusted functions that have validated all inputs already\n      * @param _collateralAddress address of collateral token being used.\n      * @param _currencyKey symbol() returned string, used for synthetix calls\n      * @param _minimumRatio lowest margin ratio for opening debts with new collateral token\n      * @param _liquidationRatio margin ratio at which a loan backed by said collateral can be liquidated.\n      * @param _interestPer3Min interest charged per block to loan holders using this collateral.\n     **/ \n    function _changeCollateralParameters(\n        address _collateralAddress,\n        bytes32 _currencyKey,\n        uint256 _minimumRatio,\n        uint256 _liquidationRatio,\n        uint256 _interestPer3Min\n        ) internal {\n        collateralProps[_collateralAddress].currencyKey = _currencyKey;\n        collateralProps[_collateralAddress].minOpeningMargin = _minimumRatio;\n        collateralProps[_collateralAddress].liquidatableMargin = _liquidationRatio;\n        collateralProps[_collateralAddress].interestPer3Min = _interestPer3Min;\n    }\n\n  /// @notice  Allows governance to pause a collateral type if necessary\n  /// @param _collateralAddress the token address of the collateral we wish to remove\n  /// @param _currencyKey the related synthcode, here we use this to prevent accidentally pausing the wrong collateral token.\n  /// @dev this should only be called on collateral no longer used by loans.\n    function pauseCollateralType(\n        address _collateralAddress,\n        bytes32 _currencyKey\n        ) external collateralExists(_collateralAddress) onlyAdmin {\n        require(_collateralAddress != address(0)); //this should get caught by the collateralExists check but just to be careful\n        //checks two inputs to help prevent input mistakes\n        require( _currencyKey == collateralProps[_collateralAddress].currencyKey, \"Mismatched data\");\n        collateralValid[_collateralAddress] = false;\n        collateralPaused[_collateralAddress] = true;\n        \n    }\n\n  /// @notice  Allows governance to unpause a collateral type if necessary\n  /// @param _collateralAddress the token address of the collateral we wish to remove\n  /// @param _currencyKey the related synthcode, here we use this to prevent accidentally unpausing the wrong collateral token.\n  /// @dev this should only be called on collateral that should be reenabled for taking loans against\n    function unpauseCollateralType(\n        address _collateralAddress,\n        bytes32 _currencyKey\n        ) external onlyAdmin {\n        require(_collateralAddress != address(0));\n        require(collateralPaused[_collateralAddress], \"Unsupported collateral or not Paused\");\n        //checks two inputs to help prevent input mistakes\n        require( _currencyKey == collateralProps[_collateralAddress].currencyKey, \"Mismatched data\");\n        collateralValid[_collateralAddress] = true;\n        collateralPaused[_collateralAddress] = false;\n        \n    }\n    /// @dev Governnance callable only, this should be set once atomically on construction \n    /// @notice once called it can no longer be called.\n    /// @param _vault the address of the vault system\n    function addVaultAddress(address _vault, uint256 _assetType) external onlyAdmin{\n        require(_vault != address(0), \"Zero address\");\n        require(vaults[_assetType] == address(0), \"Asset type already has vault\");\n        _setupRole(VAULT_ROLE, _vault);\n        vaults[_assetType]= _vault;\n    }\n    \n    /// @notice this takes in the updated virtual price of a collateral and records it as well as the time it was updated.\n    /// @dev this should only be called by vault functions which have updated the virtual price and need to log this.\n    /// @dev it is only callable by vault functions as a result.\n    /// @notice both virtualPrice and updateTime are strictly monotonically increasing so we verify this with require statements\n    /// @param _collateralAddress the token address of the collateral we are updating\n    /// @param _virtualPriceUpdate interest calculation update for it's virtual price\n    /// @param _updateTime block timestamp to keep track of last updated time.\n    \n    function _updateVirtualPriceAndTime(\n        address _collateralAddress,\n        uint256 _virtualPriceUpdate,\n        uint256 _updateTime\n        ) internal  {\n\n        require( collateralProps[_collateralAddress].virtualPrice < _virtualPriceUpdate, \"Incorrect virtual price\" );\n        require( collateralProps[_collateralAddress].lastUpdateTime < _updateTime, \"Incorrect timestamp\" );\n        collateralProps[_collateralAddress].virtualPrice = _virtualPriceUpdate;\n        collateralProps[_collateralAddress].lastUpdateTime = _updateTime;\n    }\n\n    /// @dev external function to enable the Vault to update the collateral virtual price & update timestamp\n    ///      while maintaining the same method as the slow update below for consistency.\n    function vaultUpdateVirtualPriceAndTime(\n        address _collateralAddress,\n        uint256 _virtualPriceUpdate,\n        uint256 _updateTime\n    ) external onlyVault collateralExists(_collateralAddress){\n        _updateVirtualPriceAndTime(_collateralAddress, _virtualPriceUpdate, _updateTime);\n    }\n\n\n    /// @dev this function is intentionally callable by anyone\n    /// @notice it is designed to prevent DOS situations occuring if there is a long period of inactivity for a collateral token\n    /// @param _collateralAddress the collateral token you are updating the virtual price of\n    /// @param _cycles how many updates (currently equal to seconds) to process the virtual price for.\n    function updateVirtualPriceSlowly(\n        address _collateralAddress,\n        uint256 _cycles\n        ) public collateralExists(_collateralAddress){ \n            Collateral memory collateral = collateralProps[_collateralAddress];\n            uint256 timeDelta = block.timestamp - collateral.lastUpdateTime;\n            uint256 threeMinDelta = timeDelta / THREE_MIN;\n    \n            require(_cycles <= threeMinDelta, 'Cycle count too high');\n                for (uint256 i = 0; i < _cycles; i++ ){\n                    collateral.virtualPrice = (collateral.virtualPrice * collateral.interestPer3Min) / DIVISION_BASE; \n                }\n            _updateVirtualPriceAndTime(_collateralAddress, collateral.virtualPrice, collateral.lastUpdateTime + (_cycles*THREE_MIN));\n        }\n    \n    \n    \n\n    /**\n      * @notice Only governance can add new collateral tokens\n      * @dev adds new synth token to approved list of collateral\n      * @dev includes sanity checks \n      * @param _collateralAddress address of collateral token being used.\n      * @param _currencyKey symbol() returned string, used for synthetix calls\n      * @param _minimumRatio lowest margin ratio for opening debts with new collateral token\n      * @param _liquidationRatio margin ratio at which a loan backed by said collateral can be liquidated.\n      * @param _interestPer3Min interest charged per block to loan holders using this collateral.\n      * @param _assetType number to indicate what system this collateral token belongs to, \n                          used to determine value function in vault.\n     **/\n    function addCollateralType(\n        address _collateralAddress,\n        bytes32 _currencyKey,\n        uint256 _minimumRatio,\n        uint256 _liquidationRatio,\n        uint256 _interestPer3Min,\n        uint256 _assetType,\n        address _liquidityPool\n        ) external onlyAdmin {\n\n        require(!collateralValid[_collateralAddress], \"Collateral already exists\");\n        require(!collateralPaused[_collateralAddress], \"Collateral already exists\");\n        require(_collateralAddress != address(0));\n        require(_minimumRatio > _liquidationRatio);\n        require(_liquidationRatio > 0);\n        require(vaults[_assetType] != address(0), \"Vault not deployed yet\");\n        IVault vault = IVault(vaults[_assetType]);\n\n        //prevent setting liquidationRatio too low such that it would cause an overflow in callLiquidation, see appendix on liquidation maths for details.\n        require( vault.LIQUIDATION_RETURN() *_liquidationRatio >= 10 ** 36, \"Liquidation ratio too low\"); //i.e. 1 when multiplying two 1 ether scale numbers.\n        collateralValid[_collateralAddress] = true;\n        collateralProps[_collateralAddress] = Collateral(\n            _currencyKey,\n            _minimumRatio,\n            _liquidationRatio,\n            _interestPer3Min,\n            block.timestamp,\n            1 ether,\n            _assetType\n            );\n        //Then update LiqPool as this isn't stored in the struct and requires the currencyKey also.\n        liquidityPoolOf[_currencyKey]= _liquidityPool; \n    }\n\n}"
    }
  ]
}