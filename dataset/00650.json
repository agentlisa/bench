{
  "Title": "Redundant `require` statement due to non-decreasing `queueId`",
  "Content": "##### Description\nThe issue is identified in the `WithdrawalQueue._withdrawalQueue` function.\nThe condition checks if `userQueueIds_[_receiver].add(_queueId)` already exists, which is intended to prevent duplicate `queueId` entries for a receiver. However, this check is unnecessary because the `queueId` is non-decreasing by design. This means that each new `queueId` is guaranteed to be unique and larger than the previous ones, rendering the check for an existing `queueId` redundant.\n\nRelated code - _withdrawalQueue: https://github.com/aspidanet/aspida-contract/blob/a94928e27a72baabb8c73b42634350ca934b3353/contracts/core/WithdrawalQueue.sol#L96\n##### Recommendation\nWe recommend removing the `require` statement that checks for the existence of a `_queueId`.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/core/WithdrawalQueue.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport \"../library/TransferHelper.sol\";\n\n/**\n * @title Aspida's WithdrawalQueue model\n * @dev This contract implements a withdrawal queue for users to withdraw their funds in a fair manner.\n * Users can withdraw their funds immediately if there are enough funds available, otherwise they will be added to the queue.\n * The queue is processed in a first-in-first-out (FIFO) manner.\n * Users can claim their funds from the queue at any time.\n * @author Aspida engineer\n */\nabstract contract WithdrawalQueue {\n    using EnumerableSet for EnumerableSet.UintSet;\n    using TransferHelper for address;\n\n    uint256 internal totalWithdrawn_; // Total amount of funds withdrawn\n    uint256 internal totalClaimed_; // Total amount of funds claimed\n    uint256 internal pendingClaimAmount_; // Total amount of funds in the queue\n\n    uint256 internal lastQueueId_; // The last queue ID\n    mapping(address => EnumerableSet.UintSet) internal userQueueIds_; // Mapping of user addresses to their queue IDs\n    struct Claim {\n        uint256 amount; // The amount of funds in the queue\n        uint256 accumulated; // The accumulated amount of funds in the queue\n    }\n    mapping(uint256 => Claim) internal claims_; // Mapping of queue IDs to their claim data\n\n    /**\n     * @dev Emitted when the total amount of funds in the queue is updated.\n     */\n    event UpdatePendingClaim(uint256 pendingClaimAmount);\n\n    /**\n     * @dev Emitted when the total amount of funds claimed is updated.\n     */\n    event UpdateTotalClaimed(uint256 totalClaimed);\n\n    /**\n     * @dev Emitted when a user is added to the withdrawal queue.\n     */\n    event EnterWithdrawalQueue(\n        address sender,\n        address recipient,\n        uint256 queueId,\n        uint256 claimAmount,\n        uint256 accumulated\n    );\n\n    /**\n     * @dev Emitted when a user is removed from the withdrawal queue.\n     */\n    event ExitWithdrawalQueue(address sender, address recipient, uint256 queueId, uint256 claimAmount);\n\n    /**\n     * @dev Emitted when funds are withdrawn from the contract.\n     */\n    event Withdrawn(address sender, address recipient, uint256 amount);\n\n    /**\n     * @dev Emitted when funds are claimed from the queue.\n     */\n    event Claimed(address sender, address recipient, uint256 amount);\n\n    /**\n     * @dev Updates the total amount of funds in the queue.\n     * @param _pendingClaimAmount The new total amount of funds in the queue.\n     */\n    function _updatePendingClaim(uint256 _pendingClaimAmount) internal {\n        pendingClaimAmount_ = _pendingClaimAmount;\n        emit UpdatePendingClaim(_pendingClaimAmount);\n    }\n\n    /**\n     * @dev Updates the total amount of funds claimed.\n     * @param _totalClaimed The new total amount of funds claimed.\n     */\n    function _updateTotalClaimed(uint256 _totalClaimed) internal {\n        totalClaimed_ = _totalClaimed;\n        emit UpdateTotalClaimed(_totalClaimed);\n    }\n\n    /**\n     * @dev Adds the user to the withdrawal queue.\n     * @param _receiver The address of the user to add to the queue.\n     * @param _amount The amount of funds to add to the queue.\n     */\n    function _withdrawalQueue(address _receiver, uint256 _amount) internal {\n        uint256 _queueId = lastQueueId_;\n        uint256 _accumulated = claims_[_queueId].accumulated;\n\n        _queueId += 1;\n        require(userQueueIds_[_receiver].add(_queueId), \"_withdrawalQueue: Queue id already exists\");\n\n        Claim storage _claimData = claims_[_queueId];\n        _claimData.amount = _amount;\n        _claimData.accumulated = _accumulated + _amount;\n\n        lastQueueId_ = _queueId;\n        _updatePendingClaim(pendingClaimAmount_ + _amount);\n        emit EnterWithdrawalQueue(msg.sender, _receiver, _queueId, _claimData.amount, _claimData.accumulated);\n    }\n\n    /**\n     * @dev Withdraws funds from the contract.\n     * @param _sender The address of the user withdrawing the funds.\n     * @param _receiver The address of the user receiving the funds.\n     * @param _amount The amount of funds to withdraw.\n     */\n    function _withdraw(address _sender, address _receiver, uint256 _amount) internal virtual {\n        require(_amount > 0, \"_withdraw: withdraw amount cannot be 0\");\n        if (_withdrawableAmount() < _amount) {\n            _withdrawalQueue(_receiver, _amount);\n            return;\n        }\n\n        totalWithdrawn_ += _amount;\n        _receiver.safeTransferETH(_amount);\n        emit Withdrawn(_sender, _receiver, _amount);\n    }\n\n    /**\n     * @dev Claims funds from the queue for a specific user.\n     * @param _sender The address of the user claiming the funds.\n     * @param _receiver The address of the user receiving the funds.\n     */\n    function _claimByAddress(address _sender, address _receiver) internal virtual {\n        EnumerableSet.UintSet storage _userQueueIds = userQueueIds_[_sender];\n        _claimByQueueId(_sender, _receiver, _userQueueIds.values(), _userQueueIds);\n    }\n\n    /**\n     * @dev Claims funds from the queue for a specific user and queue IDs.\n     * @param _sender The address of the user claiming the funds.\n     * @param _receiver The address of the user receiving the funds.\n     * @param _queueIds The list of queue IDs to claim from.\n     * @param _userQueueIds The user's queue IDs.\n     */\n    function _claimByQueueId(\n        address _sender,\n        address _receiver,\n        uint256[] memory _queueIds,\n        EnumerableSet.UintSet storage _userQueueIds\n    ) internal virtual {\n        require(_queueIds.length > 0, \"_claimByQueueId: Queue list cannot be empty\");\n\n        uint256 _availableBalance = _claimableAmount();\n        uint256 _claimAmount;\n        for (uint256 i = 0; i < _queueIds.length; i++) {\n            uint256 _amount = _getClaimAmount(_queueIds[i], _availableBalance);\n            if (_amount == 0) continue;\n\n            require(_userQueueIds.remove(_queueIds[i]), \"_claimByQueueId: Queue id does not exist\");\n            emit ExitWithdrawalQueue(_sender, _receiver, _queueIds[i], _amount);\n\n            _claimAmount += _amount;\n        }\n\n        require(_claimAmount > 0, \"_claimByQueueId: No claim amount\");\n\n        _updatePendingClaim(pendingClaimAmount_ - _claimAmount);\n        _updateTotalClaimed(totalClaimed_ + _claimAmount);\n\n        _receiver.safeTransferETH(_claimAmount);\n        emit Claimed(_sender, _receiver, _claimAmount);\n    }\n\n    /**\n     * @dev Returns the amount of funds that can be withdrawn.\n     * @return _availableAmount The available amount of funds that can be withdrawn.\n     */\n    function _withdrawableAmount() internal view virtual returns (uint256 _availableAmount) {\n        uint256 _balance = address(this).balance;\n        uint256 _locked = pendingClaimAmount_;\n        if (_balance > _locked) _availableAmount = _balance - _locked;\n    }\n\n    /**\n     * @dev Returns the amount of funds that can be claimed.\n     * @return _claimableAmount The claimable amount of funds.\n     */\n    function _claimableAmount() internal view virtual returns (uint256) {\n        return address(this).balance + totalClaimed_;\n    }\n\n    /**\n     * @dev Returns the claim amount for a specific queue ID.\n     * @param _queueId The queue ID.\n     * @param _claimable The claimable amount of funds.\n     * @return _claimAmount The claim amount for the queue ID.\n     */\n    function _getClaimAmount(uint256 _queueId, uint256 _claimable) internal view returns (uint256 _claimAmount) {\n        Claim storage _claimData = claims_[_queueId];\n        if (_claimable >= _claimData.accumulated) _claimAmount = _claimData.amount;\n    }\n\n    /**\n     * @dev Allows a user to withdraw funds.\n     * @param _amount The amount of funds to withdraw.\n     */\n    function withdraw(uint256 _amount) external {\n        _withdraw(msg.sender, msg.sender, _amount);\n    }\n\n    /**\n     * @dev Allows a user to withdraw funds and specify a receiver address.\n     * @param _amount The amount of funds to withdraw.\n     * @param _receiver The address of the receiver.\n     */\n    function withdraw(uint256 _amount, address _receiver) external {\n        _withdraw(msg.sender, _receiver, _amount);\n    }\n\n    /**\n     * @dev Allows a user to claim their funds from the queue.\n     */\n    function claim() external {\n        _claimByAddress(msg.sender, msg.sender);\n    }\n\n    /**\n     * @dev Allows a user to claim their funds from the queue and specify a receiver address.\n     * @param _receiver The address of the receiver.\n     */\n    function claim(address _receiver) external {\n        _claimByAddress(msg.sender, _receiver);\n    }\n\n    /**\n     * @dev Allows a user to claim their funds from the queue using specific queue IDs.\n     * @param _queueIds The list of queue IDs to claim from.\n     */\n    function claim(uint256[] memory _queueIds) external {\n        _claimByQueueId(msg.sender, msg.sender, _queueIds, userQueueIds_[msg.sender]);\n    }\n\n    /**\n     * @dev Allows a user to claim their funds from the queue using specific queue IDs and specify a receiver address.\n     * @param _receiver The address of the receiver.\n     * @param _queueIds The list of queue IDs to claim from.\n     */\n    function claim(address _receiver, uint256[] memory _queueIds) external {\n        _claimByQueueId(msg.sender, _receiver, _queueIds, userQueueIds_[msg.sender]);\n    }\n\n    /**\n     * @dev Returns the total amount of funds withdrawn.\n     * @return The total amount of funds withdrawn.\n     */\n    function totalWithdrawn() external view returns (uint256) {\n        return totalWithdrawn_;\n    }\n\n    /**\n     * @dev Returns the total amount of funds claimed.\n     * @return The total amount of funds claimed.\n     */\n    function totalClaimed() external view returns (uint256) {\n        return totalClaimed_;\n    }\n\n    /**\n     * @dev Returns the total amount of funds in the queue.\n     * @return The total amount of funds in the queue.\n     */\n    function pendingClaimAmount() external view returns (uint256) {\n        return pendingClaimAmount_;\n    }\n\n    /**\n     * @dev Returns the last queue ID.\n     * @return The last queue ID.\n     */\n    function lastQueueId() external view returns (uint256) {\n        return lastQueueId_;\n    }\n\n    /**\n     * @dev Returns the accumulated amount of funds in the queue.\n     * @return The accumulated amount of funds in the queue.\n     */\n    function accumulated() external view returns (uint256) {\n        return claims_[lastQueueId_].accumulated;\n    }\n\n    /**\n     * @dev Returns the amount of funds that can be withdrawn.\n     * @return The amount of funds that can be withdrawn.\n     */\n    function withdrawableAmount() external view returns (uint256) {\n        return _withdrawableAmount();\n    }\n\n    /**\n     * @dev Returns the amount of funds that can be claimed.\n     * @return The amount of funds that can be claimed.\n     */\n    function claimableAmount() external view returns (uint256) {\n        return _claimableAmount();\n    }\n\n    /**\n     * @dev Returns the claim data for a specific queue ID.\n     * @param _queueId The queue ID.\n     * @return The claim data for the queue ID.\n     */\n    function claimData(uint256 _queueId) external view returns (Claim memory) {\n        return claims_[_queueId];\n    }\n\n    /**\n     * @dev Returns the claim data for a specific address.\n     * @param _account The address to get claim data for.\n     * @return _ids The IDs of the claims.\n     * @return _claimAmounts The amounts of the claims.\n     * @return _claimStatuses The statuses of the claims.\n     */\n    function claimDataByAddress(\n        address _account\n    ) external view returns (uint256[] memory _ids, uint256[] memory _claimAmounts, bool[] memory _claimStatuses) {\n        _ids = userQueueIds_[_account].values();\n        _claimAmounts = new uint256[](_ids.length);\n        _claimStatuses = new bool[](_ids.length);\n\n        uint256 _claimable = _claimableAmount();\n        for (uint256 i = 0; i < _ids.length; i++) {\n            _claimAmounts[i] = claims_[_ids[i]].amount;\n            _claimStatuses[i] = _claimable >= claims_[_ids[i]].accumulated;\n        }\n    }\n\n    /**\n     * @dev Returns the queue IDs and claim data for a specific user.\n     * @param _account The address of the user.\n     * @return _ids The IDs of the user's claims.\n     * @return _claimData The claim data for each of the user's claims.\n     */\n    function userQueueIds(address _account) external view returns (uint256[] memory _ids, Claim[] memory _claimData) {\n        _ids = userQueueIds_[_account].values();\n        _claimData = new Claim[](_ids.length);\n        for (uint256 i = 0; i < _claimData.length; i++) {\n            _claimData[i] = claims_[_ids[i]];\n        }\n    }\n}"
    }
  ]
}