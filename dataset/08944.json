{
  "Title": "[N-05] Large multiples of ten should use scientific notation (e.g. `1e6`) rather than decimal literals (e.g. `1000000`), for readability",
  "Content": "\n*There is 1 instance of this issue:*\n\n```\nFile: contracts/VeTokenMinter.sol   \\#1\n\n15:       uint256 public constant maxSupply = 30 * 1000000 * 1e18; //30mil\n```\n\n<https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeTokenMinter.sol#L15>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-05-vetoken",
  "Code": [
    {
      "filename": "contracts/VeTokenMinter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract VeTokenMinter is Ownable {\n    using SafeERC20 for ERC20;\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 public constant maxSupply = 30 * 1000000 * 1e18; //30mil\n    ERC20 public veToken;\n    EnumerableSet.AddressSet internal operators;\n    uint256 public totalCliffs;\n    uint256 public reductionPerCliff;\n    uint256 public totalSupply;\n    mapping(address => uint256) public veAssetWeights;\n    uint256 public totalWeight;\n\n    event Withdraw(address destination, uint256 amount);\n\n    constructor(address veTokenAddress) {\n        veToken = ERC20(veTokenAddress);\n        totalCliffs = 1000;\n        reductionPerCliff = maxSupply.div(totalCliffs);\n    }\n\n    function addOperator(address _newOperator) public onlyOwner {\n        operators.add(_newOperator);\n    }\n\n    function removeOperator(address _operator) public onlyOwner {\n        operators.remove(_operator);\n    }\n\n    ///@dev weight is 10**25 precision\n    function updateveAssetWeight(address veAssetOperator, uint256 newWeight) external onlyOwner {\n        require(operators.contains(veAssetOperator), \"not an veAsset operator\");\n        totalWeight -= veAssetWeights[veAssetOperator];\n        veAssetWeights[veAssetOperator] = newWeight;\n        totalWeight += newWeight;\n    }\n\n    function mint(address _to, uint256 _amount) external {\n        require(operators.contains(_msgSender()), \"not an operator\");\n\n        uint256 supply = totalSupply;\n\n        //use current supply to gauge cliff\n        //this will cause a bit of overflow into the next cliff range\n        //but should be within reasonable levels.\n        //requires a max supply check though\n        uint256 cliff = supply.div(reductionPerCliff);\n        //mint if below total cliffs\n        if (cliff < totalCliffs) {\n            //for reduction% take inverse of current cliff\n            uint256 reduction = totalCliffs.sub(cliff);\n            //reduce\n            _amount = _amount.mul(reduction).div(totalCliffs);\n\n            //supply cap check\n            uint256 amtTillMax = maxSupply.sub(supply);\n            if (_amount > amtTillMax) {\n                _amount = amtTillMax;\n            }\n\n            //mint\n            veToken.safeTransfer(_to, _amount);\n            totalSupply += _amount;\n        }\n    }\n\n    function withdraw(address _destination, uint256 _amount) external onlyOwner {\n        veToken.safeTransfer(_destination, _amount);\n\n        emit Withdraw(_destination, _amount);\n    }\n}"
    }
  ]
}