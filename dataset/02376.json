{
  "Title": "H-1: The renewal grace period gives users insurance for no premium",
  "Content": "# Issue H-1: The renewal grace period gives users insurance for no premium \n\nSource: https://github.com/sherlock-audit/2023-02-carapace-judging/issues/308 \n\n## Found by \nmonrel, jkoppel, 0x52, libratus\n\n## Summary\n\nWhen a protection position is renewed, the contract checks that the expired timestamp is within the grace period of the current timestamp. The issue is that when it is renewed, it starts insurance at block.timestamp rather than the expiration of the previous protection. The result is that the grace period is effectively free insurance for the user.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-02-carapace/blob/main/contracts/libraries/ProtectionPoolHelper.sol#L390-L397\n\nWhen checking if a position can be renewed it checks the expiration of the previous protection to confirm that it is being renewed within the grace period. \n\nhttps://github.com/sherlock-audit/2023-02-carapace/blob/main/contracts/core/pool/ProtectionPool.sol#L181-L194\n\nAfter checking if the protection can be removed it starts the insurance at block.timestamp. The result is that the grace period doesn't collect any premium for it's duration. To abuse this the user would keep renewing at the end of the grace period for the shortest amount of time so that they would get the most amount of insurance for free.\n\nOne might argue that the buyer didn't have insurance during this time but protection can be renewed at any time during the grace period and late payments are very easy to see coming (i.e. if the payment is due in 30 days and it's currently day 29). The result is that even though *technically* there isn't insurance the user is still basically insured because they would always be able to renew before a default.\n\n## Impact\n\nRenewal grace period can be abused to get free insurance\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-carapace/blob/main/contracts/core/pool/ProtectionPool.sol#L176-L195\n\n## Tool used\n\nChatGPT\n\n## Recommendation\n\nWhen renewing protection, the protection should renew from the end of the expired protection not block.timestamp.\n\n## Discussion\n\n**clems4ev3r**\n\nlooks like a duplicate of #179\n\n**vnadoda**\n\n@clems4ev3r actually this is a duplicate of #190 \n\n**clems4ev3r**\n\n@vnadoda agreed, as per my comment on #190:\n#190 #308 and #179 are duplicates\n\n**IAm0x52**\n\nEscalate for 50 USDC\n\nGiven the yield of the sellers is directly harmed by this and there are no prerequisites for this to happen, I believe that this should be high risk. I would like to point out that #179 and #190 already categorize this as high.\n\n**sherlock-admin**\n\n > Escalate for 50 USDC\n> \n> Given the yield of the sellers is directly harmed by this and there are no prerequisites for this to happen, I believe that this should be high risk. I would like to point out that #179 and #190 already categorize this as high.\n\nYou've created a valid escalation for 50 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted\n\nConsidering this issue as high\n\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Considering this issue as high\n> \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/40",
  "Code": [
    {
      "filename": "contracts/libraries/ProtectionPoolHelper.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {EnumerableSetUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\n\nimport {ProtectionPurchaseParams, LendingPoolStatus, IReferenceLendingPools} from \"../interfaces/IReferenceLendingPools.sol\";\nimport {ProtectionPoolInfo, ProtectionInfo, ProtectionBuyerAccount, IProtectionPool, LendingPoolDetail, ProtectionPoolPhase} from \"../interfaces/IProtectionPool.sol\";\nimport {IProtectionPoolCycleManager} from \"../interfaces/IProtectionPoolCycleManager.sol\";\nimport {IDefaultStateManager} from \"../interfaces/IDefaultStateManager.sol\";\nimport {IPremiumCalculator} from \"../interfaces/IPremiumCalculator.sol\";\n\nimport \"./AccruedPremiumCalculator.sol\";\nimport \"./Constants.sol\";\n\nimport \"hardhat/console.sol\";\n\n/**\n * @title ProtectionPoolHelper\n * @author Carapace Finance\n * @notice Helper library contract for ProtectionPool contract, mainly for size reduction.\n */\nlibrary ProtectionPoolHelper {\n  using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\n\n  /**\n   * @notice Verifies that the status of the lending pool is ACTIVE and protection can be bought,\n   * otherwise reverts with the appropriate error message.\n   * @param poolCycleManager the pool cycle manager contract\n   * @param defaultStateManager the default state manager contract\n   * @param _protectionPool the address of the protection pool\n   * @param poolInfo storage pointer to the protection pool info\n   * @param _protectionStartTimestamp the timestamp when the protection starts\n   * @param _protectionPurchaseParams the protection purchase params\n   * @param _isRenewal whether the protection is being renewed or not\n   */\n  function verifyProtection(\n    IProtectionPoolCycleManager poolCycleManager,\n    IDefaultStateManager defaultStateManager,\n    address _protectionPool,\n    ProtectionPoolInfo storage poolInfo,\n    uint256 _protectionStartTimestamp,\n    ProtectionPurchaseParams calldata _protectionPurchaseParams,\n    bool _isRenewal\n  ) external {\n    /// Verify that the pool is not in OpenToSellers phase\n    if (poolInfo.currentPhase == ProtectionPoolPhase.OpenToSellers) {\n      revert IProtectionPool.ProtectionPoolInOpenToSellersPhase();\n    }\n\n    /// a buyer needs to buy protection longer than min protection duration specified in the pool params\n    /// or to renew protection longer than a day\n    _verifyProtectionDuration(\n      poolCycleManager,\n      _protectionPool,\n      _protectionStartTimestamp,\n      _protectionPurchaseParams.protectionDurationInSeconds,\n      _isRenewal\n        ? Constants.SECONDS_IN_DAY_UINT\n        : poolInfo.params.minProtectionDurationInSeconds\n    );\n\n    /// Verify that the lending pool is active\n    _verifyLendingPoolIsActive(\n      defaultStateManager,\n      _protectionPool,\n      _protectionPurchaseParams.lendingPoolAddress\n    );\n\n    if (\n      !poolInfo.referenceLendingPools.canBuyProtection(\n        msg.sender,\n        _protectionPurchaseParams,\n        _isRenewal\n      )\n    ) {\n      revert IProtectionPool.ProtectionPurchaseNotAllowed(\n        _protectionPurchaseParams\n      );\n    }\n  }\n\n  /**\n   * @notice Calculates the protection premium amount and related vars.\n   * @param premiumCalculator the premium calculator contract\n   * @param poolInfo storage pointer to the protection pool info\n   * @param _protectionPurchaseParams the protection purchase params\n   * @param totalSTokenUnderlying the total sToken underlying amount\n   * @param _leverageRatio the leverage ratio scaled to 18 decimals\n   * @return _premiumAmountIn18Decimals The premium amount scaled to 18 decimals.\n   * @return _premiumAmount The premium amount in underlying token decimals.\n   * @return _isMinPremium True if the premium amount is equal to the minimum premium amount, false otherwise.\n   */\n  function calculateProtectionPremium(\n    IPremiumCalculator premiumCalculator,\n    ProtectionPoolInfo storage poolInfo,\n    ProtectionPurchaseParams calldata _protectionPurchaseParams,\n    uint256 totalSTokenUnderlying,\n    uint256 _leverageRatio\n  )\n    public\n    view\n    returns (\n      uint256 _premiumAmountIn18Decimals,\n      uint256 _premiumAmount,\n      bool _isMinPremium\n    )\n  {\n    /// Calculate the protection premium amount scaled to 18 decimals and scale it to the underlying token decimals.\n    /// This function call has bunch of inline vars to avoid \"Stack too deep\" error.\n    (_premiumAmountIn18Decimals, _isMinPremium) = premiumCalculator\n      .calculatePremium(\n        /// the protection duration in seconds\n        _protectionPurchaseParams.protectionDurationInSeconds,\n        /// the protection amount scaled to 18 decimals\n        scaleUnderlyingAmtTo18Decimals(\n          _protectionPurchaseParams.protectionAmount,\n          poolInfo.underlyingToken.decimals()\n        ),\n        /// the buyer's APR scaled to 18 decimals\n        poolInfo.referenceLendingPools.calculateProtectionBuyerAPR(\n          _protectionPurchaseParams.lendingPoolAddress\n        ),\n        _leverageRatio,\n        totalSTokenUnderlying,\n        poolInfo.params\n      );\n\n    _premiumAmount = scale18DecimalsAmtToUnderlyingDecimals(\n      _premiumAmountIn18Decimals,\n      poolInfo.underlyingToken.decimals()\n    );\n  }\n\n  /**\n   * @notice Calculates & tracks the premium amount for the protection purchase.\n   * @param premiumCalculator the premium calculator contract\n   * @param protectionBuyerAccounts storage pointer to the protection buyer accounts\n   * @param poolInfo storage pointer to the protection pool info\n   * @param lendingPoolDetail storage pointer to the lending pool detail\n   * @param _protectionPurchaseParams the protection purchase params\n   * @param _maxPremiumAmount the maximum premium amount\n   * @return _premiumAmountIn18Decimals The premium amount scaled to 18 decimals.\n   * @return _premiumAmount The premium amount in underlying token decimals.\n   * @return _isMinPremium True if the premium amount is equal to the minimum premium amount, false otherwise.\n   */\n  function calculateAndTrackPremium(\n    IPremiumCalculator premiumCalculator,\n    mapping(address => ProtectionBuyerAccount) storage protectionBuyerAccounts,\n    ProtectionPoolInfo storage poolInfo,\n    LendingPoolDetail storage lendingPoolDetail,\n    ProtectionPurchaseParams calldata _protectionPurchaseParams,\n    uint256 _maxPremiumAmount,\n    uint256 totalSTokenUnderlying,\n    uint256 _leverageRatio\n  )\n    external\n    returns (\n      uint256 _premiumAmountIn18Decimals,\n      uint256 _premiumAmount,\n      bool _isMinPremium\n    )\n  {\n    /// Calculate the protection premium\n    (\n      _premiumAmountIn18Decimals,\n      _premiumAmount,\n      _isMinPremium\n    ) = calculateProtectionPremium(\n      premiumCalculator,\n      poolInfo,\n      _protectionPurchaseParams,\n      totalSTokenUnderlying,\n      _leverageRatio\n    );\n\n    // If calculated premium amount is higher than the max premium amount, revert.\n    if (_premiumAmount > _maxPremiumAmount) {\n      revert IProtectionPool.PremiumExceedsMaxPremiumAmount(\n        _premiumAmount,\n        _maxPremiumAmount\n      );\n    }\n\n    /// Increase the premium amount in the protection buyer account for the given lending pool\n    protectionBuyerAccounts[msg.sender].lendingPoolToPremium[\n      _protectionPurchaseParams.lendingPoolAddress\n    ] += _premiumAmount;\n\n    /// Increase the total premium amount in the lending pool detail\n    lendingPoolDetail.totalPremium += _premiumAmount;\n  }\n\n  /**\n   * @dev Accrues premium for given loan protection from last premium accrual to the latest payment timestamp.\n   * @param protectionInfo The loan protection to accrue premium for.\n   * @param _lastPremiumAccrualTimestamp The timestamp of last premium accrual.\n   * @param _latestPaymentTimestamp The timestamp of latest payment made to the underlying lending pool.\n   * @return _accruedPremiumInUnderlying The premium accrued for the protection.\n   * @return _protectionExpired Whether the loan protection has expired or not.\n   */\n  function verifyAndAccruePremium(\n    ProtectionPoolInfo storage poolInfo,\n    ProtectionInfo storage protectionInfo,\n    uint256 _lastPremiumAccrualTimestamp,\n    uint256 _latestPaymentTimestamp\n  )\n    external\n    view\n    returns (uint256 _accruedPremiumInUnderlying, bool _protectionExpired)\n  {\n    uint256 _startTimestamp = protectionInfo.startTimestamp;\n\n    /// This means no payment has been made after the protection is bought or protection starts in the future.\n    /// so no premium needs to be accrued.\n    if (\n      _latestPaymentTimestamp < _startTimestamp ||\n      _startTimestamp > block.timestamp\n    ) {\n      return (0, false);\n    }\n\n    /// Calculate the protection expiration timestamp and\n    /// Check if the protection is expired or not.\n    uint256 _expirationTimestamp = protectionInfo.startTimestamp +\n      protectionInfo.purchaseParams.protectionDurationInSeconds;\n    _protectionExpired = block.timestamp > _expirationTimestamp;\n\n    /// Only accrue premium if the protection is expired\n    /// or latest payment is made after the protection start & last premium accrual\n    if (\n      _protectionExpired ||\n      (_latestPaymentTimestamp > _startTimestamp &&\n        _latestPaymentTimestamp > _lastPremiumAccrualTimestamp)\n    ) {\n      /**\n       * <-Protection Bought(second: 0) --- last accrual --- now(latestPaymentTimestamp) --- Expiration->\n       * The time line starts when protection is bought and ends when protection is expired.\n       * secondsUntilLastPremiumAccrual is the second elapsed since the last accrual timestamp.\n       * secondsUntilLatestPayment is the second elapsed until latest payment is made.\n       */\n\n      // When premium is accrued for the first time, the _secondsUntilLastPremiumAccrual is 0.\n      uint256 _secondsUntilLastPremiumAccrual;\n      if (_lastPremiumAccrualTimestamp > _startTimestamp) {\n        _secondsUntilLastPremiumAccrual =\n          _lastPremiumAccrualTimestamp -\n          _startTimestamp;\n      }\n\n      /// if loan protection is expired, then accrue premium till expiration and mark it for removal\n      uint256 _secondsUntilLatestPayment;\n      if (_protectionExpired) {\n        _secondsUntilLatestPayment = _expirationTimestamp - _startTimestamp;\n        console.log(\n          \"Protection expired for amt: %s\",\n          protectionInfo.purchaseParams.protectionAmount\n        );\n      } else {\n        _secondsUntilLatestPayment = _latestPaymentTimestamp - _startTimestamp;\n      }\n\n      /// Calculate the accrued premium amount scaled to 18 decimals\n      uint256 _accruedPremiumIn18Decimals = AccruedPremiumCalculator\n        .calculateAccruedPremium(\n          _secondsUntilLastPremiumAccrual,\n          _secondsUntilLatestPayment,\n          protectionInfo.K,\n          protectionInfo.lambda\n        );\n\n      console.log(\n        \"accruedPremium from second %s to %s: \",\n        _secondsUntilLastPremiumAccrual,\n        _secondsUntilLatestPayment,\n        _accruedPremiumIn18Decimals\n      );\n\n      /// Scale the premium amount to underlying decimals\n      _accruedPremiumInUnderlying = scale18DecimalsAmtToUnderlyingDecimals(\n        _accruedPremiumIn18Decimals,\n        poolInfo.underlyingToken.decimals()\n      );\n    }\n  }\n\n  /**\n   * @notice Marks the given protection as expired and moves it from active to expired protection indexes.\n   * @param protectionBuyerAccounts storage pointer to protection buyer accounts\n   * @param protectionInfo storage pointer to protection info\n   * @param lendingPoolDetail storage pointer to lending pool detail\n   * @param _protectionIndex The index of the protection to expire.\n   */\n  function expireProtection(\n    mapping(address => ProtectionBuyerAccount) storage protectionBuyerAccounts,\n    ProtectionInfo storage protectionInfo,\n    LendingPoolDetail storage lendingPoolDetail,\n    uint256 _protectionIndex\n  ) public {\n    /// Update protection info to mark it as expired\n    protectionInfo.expired = true;\n\n    /// remove expired protection index from activeProtectionIndexes of lendingPool & buyer account\n    address _buyer = protectionInfo.buyer;\n    lendingPoolDetail.activeProtectionIndexes.remove(_protectionIndex);\n    ProtectionBuyerAccount storage buyerAccount = protectionBuyerAccounts[\n      _buyer\n    ];\n    buyerAccount.activeProtectionIndexes.remove(_protectionIndex);\n\n    /// Update buyer account to add expired protection index to expiredProtectionIndexes of lendingPool\n    ProtectionPurchaseParams storage purchaseParams = protectionInfo\n      .purchaseParams;\n    buyerAccount.expiredProtectionIndexByLendingPool[\n      purchaseParams.lendingPoolAddress\n    ][purchaseParams.nftLpTokenId] = _protectionIndex;\n\n    /// update total protection amount of lending pool by subtracting the expired protection amount\n    lendingPoolDetail.totalProtection -= protectionInfo\n      .purchaseParams\n      .protectionAmount;\n  }\n\n  /**\n   * @notice Scales the given underlying token amount to the amount with 18 decimals.\n   * @param _underlyingAmt The amount to scale.\n   * @param _underlyingTokenDecimals The number of decimals of the underlying token.\n   * @return The scaled amount with 18 decimals.\n   */\n  function scaleUnderlyingAmtTo18Decimals(\n    uint256 _underlyingAmt,\n    uint256 _underlyingTokenDecimals\n  ) public pure returns (uint256) {\n    return\n      (_underlyingAmt * Constants.SCALE_18_DECIMALS) /\n      10**(_underlyingTokenDecimals);\n  }\n\n  /**\n   * @notice Scales the given amount from 18 decimals to specified number of decimals.\n   * @param amt The amount to scale.\n   * @param _targetDecimals The number of decimals to scale to.\n   * @return The scaled amount with target decimals.\n   */\n  function scale18DecimalsAmtToUnderlyingDecimals(\n    uint256 amt,\n    uint256 _targetDecimals\n  ) public pure returns (uint256) {\n    return (amt * 10**_targetDecimals) / Constants.SCALE_18_DECIMALS;\n  }\n\n  /**\n   * @notice Verifies whether a buyer can renew protection for same lending position\n   * in the same lending pool specified in the protection purchase params, otherwise reverts.\n   * Protection can be renewed only within grace period after the protection is expired.\n   * @param protectionBuyerAccounts storage pointer to protection buyer accounts\n   * @param protectionInfos storage pointer to protection infos\n   * @param _protectionPurchaseParams The protection purchase params.\n   * @param _renewalGracePeriodInSeconds The grace period in seconds for renewal.\n   */\n  function verifyBuyerCanRenewProtection(\n    mapping(address => ProtectionBuyerAccount) storage protectionBuyerAccounts,\n    ProtectionInfo[] storage protectionInfos,\n    ProtectionPurchaseParams calldata _protectionPurchaseParams,\n    uint256 _renewalGracePeriodInSeconds\n  ) external view {\n    uint256 _renewalProtectionIndex = protectionBuyerAccounts[msg.sender]\n      .expiredProtectionIndexByLendingPool[\n        _protectionPurchaseParams.lendingPoolAddress\n      ][_protectionPurchaseParams.nftLpTokenId];\n\n    if (_renewalProtectionIndex == 0) {\n      revert IProtectionPool.NoExpiredProtectionToRenew();\n    }\n\n    ProtectionInfo storage expiredProtectionInfo = protectionInfos[\n      _renewalProtectionIndex\n    ];\n    ProtectionPurchaseParams\n      storage expiredProtectionPurchaseParams = expiredProtectionInfo\n        .purchaseParams;\n\n    /// This means a buyer has expired protection for the same lending position\n    if (\n      expiredProtectionPurchaseParams.lendingPoolAddress ==\n      _protectionPurchaseParams.lendingPoolAddress &&\n      expiredProtectionPurchaseParams.nftLpTokenId ==\n      _protectionPurchaseParams.nftLpTokenId\n    ) {\n      /// If we are NOT within grace period after the protection is expired, then revert\n      if (\n        block.timestamp >\n        (expiredProtectionInfo.startTimestamp +\n          expiredProtectionPurchaseParams.protectionDurationInSeconds +\n          _renewalGracePeriodInSeconds)\n      ) {\n        revert IProtectionPool.CanNotRenewProtectionAfterGracePeriod();\n      }\n    }\n  }\n\n  /**\n   * @dev Verify that the lending pool is active, otherwise revert.\n   * @param defaultStateManager The default state manager contract.\n   * @param _protectionPoolAddress The address of the protection pool.\n   * @param _lendingPoolAddress The address of the lending pool.\n   */\n  function _verifyLendingPoolIsActive(\n    IDefaultStateManager defaultStateManager,\n    address _protectionPoolAddress,\n    address _lendingPoolAddress\n  ) internal view {\n    LendingPoolStatus poolStatus = defaultStateManager.getLendingPoolStatus(\n      _protectionPoolAddress,\n      _lendingPoolAddress\n    );\n\n    if (poolStatus == LendingPoolStatus.NotSupported) {\n      revert IProtectionPool.LendingPoolNotSupported(_lendingPoolAddress);\n    }\n\n    if (\n      poolStatus == LendingPoolStatus.LateWithinGracePeriod ||\n      poolStatus == LendingPoolStatus.Late\n    ) {\n      revert IProtectionPool.LendingPoolHasLatePayment(_lendingPoolAddress);\n    }\n\n    if (poolStatus == LendingPoolStatus.Expired) {\n      revert IProtectionPool.LendingPoolExpired(_lendingPoolAddress);\n    }\n\n    if (poolStatus == LendingPoolStatus.Defaulted) {\n      revert IProtectionPool.LendingPoolDefaulted(_lendingPoolAddress);\n    }\n  }\n\n  /**\n   * @dev Verify that the protection duration is valid, otherwise revert.\n   * @param poolCycleManager The pool cycle manager contract.\n   * @param _poolAddress The address of the protection pool.\n   * @param _protectionStartTimestamp The protection start timestamp.\n   * @param _protectionDurationInSeconds The protection duration in seconds.\n   * @param _minProtectionDurationInSeconds The minimum protection duration in seconds.\n   */\n  function _verifyProtectionDuration(\n    IProtectionPoolCycleManager poolCycleManager,\n    address _poolAddress,\n    uint256 _protectionStartTimestamp,\n    uint256 _protectionDurationInSeconds,\n    uint256 _minProtectionDurationInSeconds\n  ) internal {\n    uint256 _protectionExpirationTimestamp = _protectionStartTimestamp +\n      _protectionDurationInSeconds;\n    /// protection duration must be longer than specified minimum\n    if (_protectionDurationInSeconds < _minProtectionDurationInSeconds) {\n      revert IProtectionPool.ProtectionDurationTooShort(\n        _protectionDurationInSeconds\n      );\n    }\n\n    /// protection expiry can not be be after the next cycle end\n    poolCycleManager.calculateAndSetPoolCycleState(_poolAddress);\n    uint256 _nextCycleEndTimestamp = poolCycleManager.getNextCycleEndTimestamp(\n      _poolAddress\n    );\n\n    if (_protectionExpirationTimestamp > _nextCycleEndTimestamp) {\n      revert IProtectionPool.ProtectionDurationTooLong(\n        _protectionDurationInSeconds\n      );\n    }\n  }\n}"
    },
    {
      "filename": "contracts/core/pool/ProtectionPool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {EnumerableSetUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport {IERC20MetadataUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport {UUPSUpgradeableBase} from \"../../UUPSUpgradeableBase.sol\";\nimport {SToken} from \"./SToken.sol\";\nimport {IPremiumCalculator} from \"../../interfaces/IPremiumCalculator.sol\";\nimport {IReferenceLendingPools, LendingPoolStatus, ProtectionPurchaseParams} from \"../../interfaces/IReferenceLendingPools.sol\";\nimport {IProtectionPoolCycleManager, ProtectionPoolCycleState} from \"../../interfaces/IProtectionPoolCycleManager.sol\";\nimport {IProtectionPool, ProtectionPoolParams, ProtectionPoolInfo, ProtectionInfo, LendingPoolDetail, WithdrawalCycleDetail, ProtectionBuyerAccount, ProtectionPoolPhase} from \"../../interfaces/IProtectionPool.sol\";\nimport {IDefaultStateManager} from \"../../interfaces/IDefaultStateManager.sol\";\n\nimport \"../../libraries/AccruedPremiumCalculator.sol\";\nimport \"../../libraries/Constants.sol\";\nimport \"../../libraries/ProtectionPoolHelper.sol\";\n\nimport \"hardhat/console.sol\";\n\n/**\n * @title ProtectionPool\n * @author Carapace Finance\n * @notice ProtectionPool is the core contract of the protocol.\n * Each protection pool is a market where protection sellers\n * and buyers can swap credit default risks of designated/referenced underlying loans.\n * Protection buyers purchase protections by paying a premium in underlying tokens to the pool.\n * Protection sellers deposit underlying tokens into the pool and receives proportionate shares of STokens.\n * Protection sellers can withdraw their underlying tokens from the pool after requesting a withdrawal\n * and only during the open period following the next pool cycle's end.\n *\n * This contract is upgradeable using the UUPS pattern.\n */\ncontract ProtectionPool is\n  UUPSUpgradeableBase,\n  ReentrancyGuardUpgradeable,\n  IProtectionPool,\n  SToken\n{\n  /*** libraries ***/\n  using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n  using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\n\n  //////////////////////////////////////////////////////\n  ///             STORAGE- START                   ///\n  /////////////////////////////////////////////////////\n  /**\n   * @dev DO NOT CHANGE THE ORDER OF THESE VARIABLES ONCE DEPLOYED\n   */\n\n  /// @notice Reference to the PremiumPricing contract\n  IPremiumCalculator private premiumCalculator;\n\n  /// @notice Reference to the ProtectionPoolCycleManager contract\n  IProtectionPoolCycleManager private poolCycleManager;\n\n  /// @notice Reference to default state manager contract\n  IDefaultStateManager private defaultStateManager;\n\n  /// @notice information about this protection pool\n  ProtectionPoolInfo private poolInfo;\n\n  /// @notice The total underlying amount of premium paid to the pool by protection buyers\n  uint256 private totalPremium;\n\n  /// @notice The total underlying amount of protection bought from this pool by protection buyers\n  uint256 private totalProtection;\n\n  /// @notice The total premium accrued in underlying token up to the last premium accrual timestamp\n  uint256 private totalPremiumAccrued;\n\n  /**\n   * @notice The total underlying amount in the pool backing the value of STokens.\n   * @notice This is the total capital deposited by sellers + accrued premiums from buyers - locked capital - default payouts.\n   */\n  uint256 private totalSTokenUnderlying;\n\n  /// @notice The array to track all protections bought from this pool\n  /// @dev This array has dummy element at index 0 to validate the index of the protection\n  ProtectionInfo[] private protectionInfos;\n\n  /// @notice The mapping to track pool cycle index at which actual withdrawal will happen to withdrawal details\n  mapping(uint256 => WithdrawalCycleDetail) private withdrawalCycleDetails;\n\n  /// @notice The mapping to track all lending pool details by address\n  mapping(address => LendingPoolDetail) private lendingPoolDetails;\n\n  /// @notice The mapping to track all protection buyer accounts by address\n  mapping(address => ProtectionBuyerAccount) private protectionBuyerAccounts;\n\n  //////////////////////////////////////////////////////\n  ///             STORAGE - END                     ///\n  /////////////////////////////////////////////////////\n\n  /*** modifiers ***/\n\n  /// @notice Checks whether pool cycle is in open state. If not, reverts.\n  /// @dev This modifier is used to restrict certain functions to be called only during the open period of a pool cycle.\n  /// @dev This modifier also updates the pool cycle state before verifying the state.\n  modifier whenPoolIsOpen() {\n    /// Update the pool cycle state\n    ProtectionPoolCycleState cycleState = poolCycleManager\n      .calculateAndSetPoolCycleState(address(this));\n\n    if (cycleState != ProtectionPoolCycleState.Open) {\n      revert ProtectionPoolIsNotOpen();\n    }\n    _;\n  }\n\n  /// @notice Checks caller is DefaultStateManager contract. If not, reverts.\n  /// @dev This modifier is used to restrict certain functions to be called only by the DefaultStateManager contract.\n  modifier onlyDefaultStateManager() {\n    if (msg.sender != address(defaultStateManager)) {\n      revert OnlyDefaultStateManager(msg.sender);\n    }\n    _;\n  }\n\n  /*** initializer ***/\n\n  /// @inheritdoc IProtectionPool\n  function initialize(\n    address _owner,\n    ProtectionPoolInfo calldata _poolInfo,\n    IPremiumCalculator _premiumCalculator,\n    IProtectionPoolCycleManager _poolCycleManager,\n    IDefaultStateManager _defaultStateManager,\n    string calldata _name,\n    string calldata _symbol\n  ) external override initializer {\n    /// initialize parent contracts in same order as they are inherited to mimic the behavior of a constructor\n    __UUPSUpgradeableBase_init();\n    __ReentrancyGuard_init();\n    __sToken_init(_name, _symbol);\n\n    /// set the storage variables\n    poolInfo = _poolInfo;\n    premiumCalculator = _premiumCalculator;\n    poolCycleManager = _poolCycleManager;\n    defaultStateManager = _defaultStateManager;\n\n    emit ProtectionPoolInitialized(\n      _name,\n      _symbol,\n      poolInfo.underlyingToken,\n      poolInfo.referenceLendingPools\n    );\n\n    /// Transfer the ownership of this pool to the specified owner\n    _transferOwnership(_owner);\n\n    /// Add dummy protection info to make index 0 invalid\n    protectionInfos.push();\n  }\n\n  /*** state-changing functions ***/\n\n  /// @inheritdoc IProtectionPool\n  function buyProtection(\n    ProtectionPurchaseParams calldata _protectionPurchaseParams,\n    uint256 _maxPremiumAmount\n  ) external override whenNotPaused nonReentrant {\n    /// Verify that user can buy protection and then create protection\n    _verifyAndCreateProtection(\n      block.timestamp,\n      _protectionPurchaseParams,\n      _maxPremiumAmount,\n      false\n    );\n  }\n\n  /// @inheritdoc IProtectionPool\n  function renewProtection(\n    ProtectionPurchaseParams calldata _protectionPurchaseParams,\n    uint256 _maxPremiumAmount\n  ) external override whenNotPaused nonReentrant {\n    /// Verify that user can renew protection\n    ProtectionPoolHelper.verifyBuyerCanRenewProtection(\n      protectionBuyerAccounts,\n      protectionInfos,\n      _protectionPurchaseParams,\n      poolInfo.params.protectionRenewalGracePeriodInSeconds\n    );\n\n    /// Verify that user can buy protection and then create a new protection for renewal\n    _verifyAndCreateProtection(\n      block.timestamp,\n      _protectionPurchaseParams,\n      _maxPremiumAmount,\n      true\n    );\n  }\n\n  /// @inheritdoc IProtectionPool\n  function deposit(uint256 _underlyingAmount, address _receiver)\n    external\n    override\n    whenNotPaused\n    nonReentrant\n  {\n    _deposit(_underlyingAmount, _receiver);\n  }\n\n  /// @inheritdoc IProtectionPool\n  function requestWithdrawal(uint256 _sTokenAmount)\n    external\n    override\n    whenNotPaused\n  {\n    _requestWithdrawal(_sTokenAmount);\n  }\n\n  /// @inheritdoc IProtectionPool\n  function depositAndRequestWithdrawal(\n    uint256 _underlyingAmountToDeposit,\n    uint256 _sTokenAmountToWithdraw\n  ) external virtual override whenNotPaused nonReentrant {\n    _deposit(_underlyingAmountToDeposit, msg.sender);\n    _requestWithdrawal(_sTokenAmountToWithdraw);\n  }\n\n  /// @inheritdoc IProtectionPool\n  function withdraw(uint256 _sTokenWithdrawalAmount, address _receiver)\n    external\n    override\n    whenPoolIsOpen\n    whenNotPaused\n    nonReentrant\n  {\n    /// Step 1: Retrieve withdrawal details for current pool cycle index\n    uint256 _currentCycleIndex = poolCycleManager.getCurrentCycleIndex(\n      address(this)\n    );\n    WithdrawalCycleDetail storage withdrawalCycle = withdrawalCycleDetails[\n      _currentCycleIndex\n    ];\n\n    /// Step 2: Verify withdrawal request exists in this withdrawal cycle for the user\n    uint256 _sTokenRequested = withdrawalCycle.withdrawalRequests[msg.sender];\n    if (_sTokenRequested == 0) {\n      revert NoWithdrawalRequested(msg.sender, _currentCycleIndex);\n    }\n\n    /// Step 3: Verify that withdrawal amount is not more than the requested amount.\n    if (_sTokenWithdrawalAmount > _sTokenRequested) {\n      revert WithdrawalHigherThanRequested(msg.sender, _sTokenRequested);\n    }\n\n    /// Step 4: calculate underlying amount to transfer based on sToken withdrawal amount\n    uint256 _underlyingAmountToTransfer = convertToUnderlying(\n      _sTokenWithdrawalAmount\n    );\n\n    /// Step 5: burn sTokens shares.\n    /// This step must be done after calculating underlying amount to be transferred\n    _burn(msg.sender, _sTokenWithdrawalAmount);\n\n    /// Step 6: Update total sToken underlying amount\n    totalSTokenUnderlying -= _underlyingAmountToTransfer;\n\n    /// Step 7: update seller's withdrawal amount and total requested withdrawal amount\n    withdrawalCycle.withdrawalRequests[msg.sender] -= _sTokenWithdrawalAmount;\n    withdrawalCycle.totalSTokenRequested -= _sTokenWithdrawalAmount;\n\n    /// Step 8: transfer underlying token to receiver\n    poolInfo.underlyingToken.safeTransfer(\n      _receiver,\n      _underlyingAmountToTransfer\n    );\n\n    emit WithdrawalMade(msg.sender, _sTokenWithdrawalAmount, _receiver);\n  }\n\n  /// @inheritdoc IProtectionPool\n  /// @dev Can't use 'calldata` for _lendingPools parameter because of potential re-assignment in the function\n  function accruePremiumAndExpireProtections(address[] memory _lendingPools)\n    external\n    override\n  {\n    /// When no lending pools are passed, accrue premium for all lending pools\n    if (_lendingPools.length == 0) {\n      _lendingPools = poolInfo.referenceLendingPools.getLendingPools();\n    }\n\n    /// Track total premium accrued and protection removed for all lending pools\n    uint256 _totalPremiumAccrued;\n    uint256 _totalProtectionRemoved;\n\n    /// Iterate all lending pools of this protection pool to check if there is new payment after last premium accrual\n    uint256 length = _lendingPools.length;\n    for (uint256 _lendingPoolIndex; _lendingPoolIndex < length; ) {\n      /// Retrieve lending pool detail from the storage\n      address _lendingPool = _lendingPools[_lendingPoolIndex];\n      LendingPoolDetail storage lendingPoolDetail = lendingPoolDetails[\n        _lendingPool\n      ];\n\n      /// Get the latest payment timestamp for the lending pool\n      uint256 _latestPaymentTimestamp = poolInfo\n        .referenceLendingPools\n        .getLatestPaymentTimestamp(_lendingPool);\n\n      /// Get the last premium accrual timestamp for the lending pool from the storage\n      uint256 _lastPremiumAccrualTimestamp = lendingPoolDetail\n        .lastPremiumAccrualTimestamp;\n\n      console.log(\n        \"lendingPool: %s, lastPremiumAccrualTimestamp: %s, latestPaymentTimestamp: %s\",\n        _lendingPool,\n        _lastPremiumAccrualTimestamp,\n        _latestPaymentTimestamp\n      );\n\n      /// Iterate all active protections for this lending pool and\n      /// accrue premium and expire protections if there is new payment\n      (\n        uint256 _accruedPremiumForLendingPool,\n        uint256 _totalProtectionRemovedForLendingPool\n      ) = _accruePremiumAndExpireProtections(\n          lendingPoolDetail,\n          _lastPremiumAccrualTimestamp,\n          _latestPaymentTimestamp\n        );\n      _totalPremiumAccrued += _accruedPremiumForLendingPool;\n      _totalProtectionRemoved += _totalProtectionRemovedForLendingPool;\n\n      /// Persist the last premium accrual of the lending pool in the storage,\n      /// only if there was premium accrued\n      if (_accruedPremiumForLendingPool > 0) {\n        lendingPoolDetail.lastPremiumAccrualTimestamp = _latestPaymentTimestamp;\n\n        emit PremiumAccrued(_lendingPool, _latestPaymentTimestamp);\n      }\n\n      unchecked {\n        ++_lendingPoolIndex;\n      }\n    }\n\n    /// Gas optimization: only update storage vars if there was premium accrued\n    if (_totalPremiumAccrued > 0) {\n      totalPremiumAccrued += _totalPremiumAccrued;\n      totalSTokenUnderlying += _totalPremiumAccrued;\n    }\n\n    /// Reduce the total protection amount of this protection pool\n    /// by the total protection amount of the expired protections\n    if (_totalProtectionRemoved > 0) {\n      totalProtection -= _totalProtectionRemoved;\n    }\n  }\n\n  /// @inheritdoc IProtectionPool\n  function lockCapital(address _lendingPoolAddress)\n    external\n    payable\n    override\n    onlyDefaultStateManager\n    whenNotPaused\n    returns (uint256 _lockedAmount, uint256 _snapshotId)\n  {\n    /// step 1: Capture protection pool's current investors by creating a snapshot of the token balance by using ERC20Snapshot in SToken\n    _snapshotId = _snapshot();\n\n    /// step 2: calculate total"
    }
  ]
}