{
  "Title": "[L08] Insufficient inline documentation",
  "Content": "Although many functions in the codebase are well documented, there are plenty of other functions that are lacking sufficient inline documentation. For example:\n\n\n* [The initialization loop](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/blob/943df3a8fcd8dd128af3beb0c85a0480c0e95ead/contracts/oracle/YieldOracle.sol#L56) in the `YieldOracle` contract sets `i` to the length of an empty dynamic array rather than to `0` as one might expect. This is, ostensibly, to support an oracle being deployed with a pre-existing set of `yieldObservations`. Intent here should be clarified.\n* The comments above [`currentCumulatives`](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/blob/943df3a8fcd8dd128af3beb0c85a0480c0e95ead/contracts/providers/CompoundProvider.sol#L247) describe one of the functionâ€™s return values, but fail to mention anything about the other return value.\n* The internal [`_accountJuniorBond` function](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/blob/943df3a8fcd8dd128af3beb0c85a0480c0e95ead/contracts/SmartYield.sol#L577-L599) is critical to the system, yet it lacks even a single line of inline documentation.\n\n\nConsider adding additional inline documentation throughout the codebase to further clarify intent and improve overall code readability.\n\n\n**Update**: *The BarnBridge team did not address this issue.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/oracle/YieldOracle.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./IYieldOraclelizable.sol\";\nimport \"./IYieldOracle.sol\";\n\n// a modified version of https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/examples/ExampleSlidingWindowOracle.sol\n// sliding window oracle that uses observations collected over a window to provide moving yield averages in the past\n// `windowSize` with a precision of `windowSize / granularity`\ncontract YieldOracle is IYieldOracle {\n    using SafeMath for uint256;\n\n    IYieldOraclelizable public pool;\n\n    struct Observation {\n        uint256 timestamp;\n        uint256 yieldCumulative;\n    }\n\n    // the desired amount of time over which the moving average should be computed, e.g. 24 hours\n    uint256 public immutable windowSize;\n\n    // the number of observations stored for each pair, i.e. how many price observations are stored for the window.\n    // as granularity increases from 1, more frequent updates are needed, but moving averages become more precise.\n    // averages are computed over intervals with sizes in the range:\n    //   [windowSize - (windowSize / granularity) * 2, windowSize]\n    // e.g. if the window size is 24 hours, and the granularity is 24, the oracle will return the average price for\n    //   the period:\n    //   [now - [22 hours, 24 hours], now]\n    uint8 public immutable granularity;\n\n    // this is redundant with granularity and windowSize, but stored for gas savings & informational purposes.\n    uint256 public immutable periodSize;\n\n    // list of yield observations\n    Observation[] public yieldObservations;\n\n    constructor(\n        address pool_,\n        uint256 windowSize_,\n        uint8 granularity_\n    ) {\n        require(granularity_ > 1, \"YO: GRANULARITY\");\n        require(\n            (periodSize = windowSize_ / granularity_) * granularity_ ==\n                windowSize_,\n            \"YO: WINDOW_NOT_EVENLY_DIVISIBLE\"\n        );\n        windowSize = windowSize_;\n        granularity = granularity_;\n        pool = IYieldOraclelizable(pool_);\n\n        for (uint256 i = yieldObservations.length; i < granularity_; i++) {\n            yieldObservations.push();\n        }\n    }\n\n    // returns the index of the observation corresponding to the given timestamp\n    function observationIndexOf(uint256 timestamp_)\n        public\n        view\n        returns (uint8 index)\n    {\n        uint256 epochPeriod = timestamp_ / periodSize;\n        return uint8(epochPeriod % granularity);\n    }\n\n    // returns the observation from the oldest epoch (at the beginning of the window) relative to the current time\n    function getFirstObservationInWindow()\n        private\n        view\n        returns (Observation storage firstObservation)\n    {\n        uint8 observationIndex = observationIndexOf(pool.currentTime());\n        // no overflow issue. if observationIndex + 1 overflows, result is still zero.\n        uint8 firstObservationIndex = (observationIndex + 1) % granularity;\n        firstObservation = yieldObservations[firstObservationIndex];\n    }\n\n    // update the cumulative price for the observation at the current timestamp. each observation is updated at most\n    // once per epoch period.\n    function update() external virtual override {\n        // get the observation for the current period\n        uint8 observationIndex = observationIndexOf(pool.currentTime());\n        Observation storage observation = yieldObservations[observationIndex];\n\n        // we only want to commit updates once per period (i.e. windowSize / granularity)\n        uint256 timeElapsed = pool.currentTime() - observation.timestamp;\n        if (timeElapsed > periodSize) {\n            (uint256 yieldCumulative, ) = pool.cumulatives();\n            observation.timestamp = pool.currentTime();\n            observation.yieldCumulative = yieldCumulative;\n        }\n    }\n\n    // given the cumulative yields of the start and end of a period, and the length of the period (timeElapsed in seconds), compute the average\n    // yield and extrapolate it for forInterval (seconds) in terms of how much amount out is received for the amount in\n    function computeAmountOut(\n        uint256 yieldCumulativeStart_,\n        uint256 yieldCumulativeEnd_,\n        uint256 timeElapsed_,\n        uint256 forInterval_\n    ) private pure returns (uint256 yieldAverage) {\n        return\n            ((yieldCumulativeEnd_ - yieldCumulativeStart_) * forInterval_) / timeElapsed_;\n    }\n\n    // returns the amount out corresponding to the amount in for a given token using the moving average over the time\n    // range [now - [windowSize, windowSize - periodSize * 2], now]\n    // update must have been called for the bucket corresponding to timestamp `now - windowSize`\n    function consult(uint256 forInterval)\n        external\n        view\n        override\n        virtual\n        returns (uint256 yieldForInterval)\n    {\n        Observation storage firstObservation = getFirstObservationInWindow();\n\n        uint256 timeElapsed = pool.currentTime() - firstObservation.timestamp;\n\n        if (!(timeElapsed <= windowSize)) {\n            // originally:\n            // require(\n            //     timeElapsed <= windowSize,\n            //     \"YO: MISSING_HISTORICAL_OBSERVATION\"\n            // );\n            // if the oracle is falling behind, it reports 0 yield => there's no incentive to buy sBOND\n            return 0;\n        }\n\n        if (!(timeElapsed >= windowSize - periodSize * 2)) {\n            // originally:\n            // should never happen.\n            // require(\n            //     timeElapsed >= windowSize - periodSize * 2,\n            //     \"YO: UNEXPECTED_TIME_ELAPSED\"\n            // );\n            // if the oracle is in an odd state, it reports 0 yield => there's no incentive to buy sBOND\n            return 0;\n        }\n\n        (uint256 yieldCumulative, ) = pool.currentCumulatives();\n\n        return\n            computeAmountOut(\n                firstObservation.yieldCumulative,\n                yieldCumulative,\n                timeElapsed,\n                forInterval\n            );\n    }\n}"
    },
    {
      "filename": "contracts/providers/CompoundProvider.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./../external-interfaces/uniswap/IUniswapV2Router.sol\";\nimport \"./../external-interfaces/compound-finance/ICToken.sol\";\nimport \"./../external-interfaces/compound-finance/IComptroller.sol\";\n\nimport \"./../lib/math/MathUtils.sol\";\n\nimport \"./CompoundController.sol\";\nimport \"./../oracle/IYieldOracle.sol\";\nimport \"./../IProvider.sol\";\n\ncontract CompoundProvider is IProvider {\n    using SafeMath for uint256;\n\n    // underlying token (ie. DAI)\n    address public uToken; // IERC20\n\n    // claim token (ie. cDAI)\n    address public cToken;\n\n    // compound.finance Comptroller\n    address public comptroller; // IComptroller\n\n    // deposit reward token (ie. COMP)\n    address public rewardCToken; // IERC20\n\n    // cToken.balanceOf(this) measuring only deposits by users (excludes dirrect cToken transfers to pool)\n    uint256 public cTokenBalance;\n\n    // --- COMP reward checkpoint\n    // saved comptroller.compSupplyState(cToken) value @ the moment the pool harvested\n    uint256 public compSupplierIndexLast;\n\n    // cumulative balanceOf @ last harvest\n    uint256 public cumulativeUnderlyingBalanceHarvestedLast;\n\n    // when we last harvested\n    uint256 public harvestedLast;\n    // --- /COMP reward checkpoint\n\n    bool public _setup;\n\n    modifier accountYield {\n        _accountYieldInternal();\n        IYieldOracle(IController(this.controller()).oracle()).update();\n\n        _;\n\n        underlyingBalanceLast = this.underlyingBalance();\n    }\n\n    function setup(\n        address smartYield_,\n        address controller_,\n        address cToken_\n    )\n      external\n    {\n        require(\n          false == _setup,\n          \"PPC: already setup\"\n        );\n\n        smartYield = smartYield_;\n        controller = controller_;\n        cToken = cToken_;\n        uToken = ICToken(cToken_).underlying();\n        comptroller = ICToken(cToken_).comptroller();\n        rewardCToken = IComptroller(comptroller).getCompAddress();\n\n        _enterMarket();\n\n        _setup = true;\n    }\n\n  // externals\n\n    // take underlyingAmount_ from from_\n    function _takeUnderlying(address from_, uint256 underlyingAmount_)\n      external override\n      onlySmartYield\n    {\n        require(\n            underlyingAmount_ <= IERC20(uToken).allowance(from_, address(this)),\n            \"PPC: _takeUnderlying allowance\"\n        );\n        require(\n            IERC20(uToken).transferFrom(from_, address(this), underlyingAmount_),\n            \"PPC: _takeUnderlying transferFrom\"\n        );\n    }\n\n    // transfer away underlyingAmount_ to to_\n    function _sendUnderlying(address to_, uint256 underlyingAmount_)\n      external override\n      onlySmartYield\n      returns (bool)\n    {\n        return IERC20(uToken).transfer(to_, underlyingAmount_);\n    }\n\n    // deposit underlyingAmount_ with the liquidity provider adds resulting cTokens to cTokenBalance\n    // on the very first call enters the compound.finance market and saves the checkpoint needed for compRewardExpected\n    function _depositProvider(uint256 underlyingAmount_, uint256 takeFees_)\n      external override\n      onlySmartYield\n    {\n        _depositProviderInternal(underlyingAmount_, takeFees_);\n    }\n\n    // withdraw underlyingAmount_ from the liquidity provider, substract the lost cTokens from cTokenBalance\n    function _withdrawProvider(uint256 underlyingAmount_, uint256 takeFees_)\n      external override\n      onlySmartYield\n      accountYield\n    {\n        underlyingFees += takeFees_;\n\n        uint256 cTokensBefore = ICTokenErc20(cToken).balanceOf(address(this));\n        uint256 err = ICToken(cToken).redeemUnderlying(underlyingAmount_);\n        require(0 == err, \"PPC: _withdrawProvider redeemUnderlying\");\n        cTokenBalance -= cTokensBefore - ICTokenErc20(cToken).balanceOf(address(this));\n    }\n\n    // called by anyone to convert pool's COMP -> underlying and then deposit it. caller gets HARVEST_REWARD of the harvest\n    function harvest()\n      external override\n    {\n        require(\n          harvestedLast < this.currentTime(),\n          \"PPC: harvest later\"\n        );\n\n        // this is 0 unless someone transfers underlying to the contract\n        uint256 underlyingBefore = IERC20(uToken).balanceOf(address(this));\n\n        // COMP gets on the pool when:\n        // 1) pool calls comptroller.claimComp()\n        // 2) anyone calls comptroller.claimComp()\n        // 3) anyone transfers COMP to the pool\n        // we want to yield closest to 1+2 but not 3\n        uint256 rewardExpected = compRewardExpected(); // COMP\n\n        address[] memory holders = new address[](1);\n        holders[0] = address(this);\n        address[] memory markets = new address[](1);\n        markets[0] = cToken;\n\n        IComptroller(comptroller).claimComp(holders, markets, false, true);\n\n        _updateCompState();\n\n        uint256 rewardGot = IERC20(rewardCToken).balanceOf(address(this)); // COMP\n\n        if (rewardGot > 0) {\n            address uniswap = CompoundController(controller).uniswap();\n\n            // should be like:\n            // address[] memory path = new address[](3);\n            // path[0] = address(rewardCToken);\n            // path[1] = address(wethToken);\n            // path[2] = address(uToken);\n            address[] memory path = CompoundController(controller).getUniswapPath();\n\n            // TODO: optimize pre-approve uniswap, gas\n            IERC20(rewardCToken).approve(address(uniswap), rewardGot);\n\n            IUniswapV2Router(uniswap).swapExactTokensForTokens(\n                rewardGot,\n                uint256(0),\n                path,\n                address(this),\n                this.currentTime() + 1800\n            );\n        }\n\n        uint256 underlyingGot = IERC20(uToken).balanceOf(address(this));\n\n        if (underlyingGot == 0) {\n          // got no goodies :(\n          return;\n        }\n\n        uint256 extra;\n\n        if (underlyingBefore > 0) {\n          // someone sent us a present as underlying -> add it to the fees\n          extra = underlyingBefore;\n          underlyingGot -= extra;\n        }\n\n        if (rewardGot > rewardExpected) {\n          // moar present as COMP reward -> add it to the fees\n          // throw event\n          uint256 rExtra = MathUtils.fractionOf(underlyingGot, (rewardGot - rewardExpected) * 1e18 / rewardGot);\n          extra += rExtra;\n          underlyingGot -= rExtra;\n        }\n\n        uint256 toCaller = MathUtils.fractionOf(underlyingGot, CompoundController(controller).HARVEST_REWARD());\n\n        // deposit pool reward to compound - harvest reward + any goodies we received\n        // any extra goodies go to fees\n        _depositProviderInternal(underlyingGot - toCaller + extra, extra);\n\n        // pay this man\n        IERC20(uToken).transfer(msg.sender, IERC20(uToken).balanceOf(address(this)));\n    }\n\n    function transferFees()\n      external\n      override\n      accountYield\n    {\n      // cleanup any cTokens dust or cTokens that may have been dumped on the pool\n      if (ICTokenErc20(cToken).balanceOf(address(this)) > cTokenBalance) {\n        underlyingFees += ICToken(cToken).exchangeRateStored() * (ICTokenErc20(cToken).balanceOf(address(this)) - cTokenBalance) / 1e18;\n      }\n      uint256 ctokensToPay = underlyingFees * 1e18 / ICToken(cToken).exchangeRateStored();\n      uint256 err = ICToken(cToken).redeem(\n          MathUtils.min(ctokensToPay, ICTokenErc20(cToken).balanceOf(address(this)))\n      );\n      require(0 == err, \"PPC: transferFees redeem\");\n      underlyingFees = 0;\n      cTokenBalance = ICTokenErc20(cToken).balanceOf(address(this));\n      IERC20(uToken).transfer(IController(controller).feesOwner(), IERC20(uToken).balanceOf(address(this)));\n    }\n\n    // returns cumulatives and accumulates/updates internal state\n    // oracle should call this when updating\n    function cumulatives()\n      external override\n    returns(uint256 cumulativeSecondlyYield, uint256 cumulativeUnderlyingBalance) {\n        _accountYieldInternal();\n        underlyingBalanceLast = this.underlyingBalance();\n        return (cumulativeSecondlyYieldLast, cumulativeUnderlyingBalanceLast);\n    }\n\n    // returns cumulated yield per 1 underlying coin (ie 1 DAI, 1 ETH) times 1e18\n    // per https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/libraries/UniswapV2OracleLibrary.sol#L16\n    function currentCumulatives()\n      external view override\n    returns (uint256 cumulativeSecondlyYield, uint256 cumulativeUnderlyingBalance)\n    {\n        uint32 blockTimestamp = uint32(this.currentTime() % 2**32);\n        cumulativeSecondlyYield = cumulativeSecondlyYieldLast;\n        cumulativeUnderlyingBalance = cumulativeUnderlyingBalanceLast;\n\n        uint32 timeElapsed = blockTimestamp - cumulativeTimestampLast; // overflow is desired\n        if (timeElapsed > 0) {\n            if (underlyingBalanceLast > 0) {\n              // cumulativeSecondlyYield overflows eventually,\n              // due to the way it is used in the oracle that's ok,\n              // as long as it doesn't overflow twice during the windowSize\n              // see OraclelizedMock.cumulativeOverflowProof() for proof\n              cumulativeSecondlyYield +=\n                  // (this.underlyingBalance() - underlyingBalanceLast) * 1e18 -> overflows only if (this.underlyingBalance() - underlyingBalanceLast) >~ 10^41 ETH, DAI, USDC etc\n                  // (this.underlyingBalance() - underlyingBalanceLast) never underflows\n                  ((this.underlyingBalance() - underlyingBalanceLast) * 1e18) / underlyingBalanceLast;\n            }\n            cumulativeUnderlyingBalance += this.underlyingBalance() * timeElapsed;\n        }\n        return (cumulativeSecondlyYield, cumulativeUnderlyingBalance);\n    }\n\n    // current total underlying balance, as measured by pool\n    function underlyingBalance()\n      external view virtual override\n    returns (uint256)\n    {\n        // https://compound.finance/docs#protocol-math\n        return\n            cTokenBalance * ICToken(cToken).exchangeRateStored() / 1e18;\n    }\n\n  // /externals\n\n    function currentTime()\n      public view virtual override\n      returns (uint256)\n    {\n        // mockable\n        return block.timestamp;\n    }\n\n    // computes how much COMP tokens compound.finance will give us at comptroller.claimComp()\n    // note: have to do it because comptroller.claimComp() is callable by anyone\n    // source: https://github.com/compound-finance/compound-protocol/blob/master/contracts/Comptroller.sol#L1145\n    function compRewardExpected()\n      public view virtual\n      returns (uint256)\n    {\n        (uint224 supplyStateIndex, ) = IComptroller(comptroller).compSupplyState(cToken);\n        uint256 supplyIndex = uint256(supplyStateIndex);\n        uint256 supplierIndex = compSupplierIndexLast;\n\n        uint256 deltaIndex = (supplyIndex).sub(supplierIndex); // a - b\n        (, uint256 cumulativeUnderlyingBalanceNow) = this.currentCumulatives();\n        uint256 timeElapsed = this.currentTime() - harvestedLast; // harvest() has require\n\n        uint256 waUnderlyingTotal = ((cumulativeUnderlyingBalanceNow - cumulativeUnderlyingBalanceHarvestedLast) * 1e18 / timeElapsed);\n        // uint256 supplierTokens = ICTokenErc20(cToken).balanceOf(address(this))\n        uint256 supplierTokens = waUnderlyingTotal / ICToken(cToken).exchangeRateStored();\n        return (supplierTokens).mul(deltaIndex).div(1e36); // a * b / doubleScale => uint\n    }\n\n  // internals\n\n    function _depositProviderInternal(uint256 underlyingAmount_, uint256 takeFees_)\n      internal\n      accountYield\n    {\n        if (0 == cTokenBalance && 0 == compSupplierIndexLast) {\n          // this will be called once only for the first comp deposit after pool deploy\n          _updateCompState();\n        }\n        underlyingFees += takeFees_;\n\n        uint256 cTokensBefore = ICTokenErc20(cToken).balanceOf(address(this));\n        // TODO: optimization, pre-approve provider: gas\n        IERC20(uToken).approve(address(cToken), underlyingAmount_);\n        uint256 err = ICToken(cToken).mint(underlyingAmount_);\n        require(0 == err, \"PPC: _depositProvider mint\");\n        cTokenBalance += ICTokenErc20(cToken).balanceOf(address(this)) - cTokensBefore;\n    }\n\n    function _accountYieldInternal()\n      internal\n    {\n        uint32 blockTimestamp = uint32(this.currentTime() % 2**32);\n        uint32 timeElapsed = blockTimestamp - cumulativeTimestampLast; // overflow is desired\n        // only for the first time in the block\n        if (timeElapsed > 0) {\n            // if there's underlying\n            if (underlyingBalanceLast > 0) {\n              // cumulativeSecondlyYieldLast overflows eventually,\n              // due to the way it is used in the oracle that's ok,\n              // as long as it doesn't overflow twice during the windowSize\n              // see OraclelizedMock.cumulativeOverflowProof() for proof\n              cumulativeSecondlyYieldLast +=\n                  // (this.underlyingBalance() - underlyingBalanceLast) * 1e18 -> overflows only if (this.underlyingBalance() - underlyingBalanceLast) >~ 10^41 ETH, DAI, USDC etc\n                  // (this.underlyingBalance() - underlyingBalanceLast) never underflows\n                  ((this.underlyingBalance() - underlyingBalanceLast) * 1e18) / underlyingBalanceLast;\n            }\n\n            cumulativeUnderlyingBalanceLast += this.underlyingBalance() * timeElapsed;\n\n            cumulativeTimestampLast = blockTimestamp;\n        }\n    }\n\n    // call comptroller.enterMarkets()\n    // needs to be called only once BUT before any interactions with the provider\n    function _enterMarket()\n      internal\n    {\n        address[] memory markets = new address[](1);\n        markets[0] = cToken;\n        uint256[] memory err = IComptroller(comptroller).enterMarkets(markets);\n        require(err[0] == 0, \"PPC: _enterMarket\");\n    }\n\n\n    // creates checkpoint items needed to compute compRewardExpected()\n    // needs to be called right after each claimComp(), and just before the first ever deposit\n    function _updateCompState()\n      internal\n    {\n        (uint224 supplyStateIndex, ) = IComptroller(comptroller).compSupplyState(cToken);\n        compSupplierIndexLast = uint256(supplyStateIndex);\n        (, cumulativeUnderlyingBalanceHarvestedLast) = this.currentCumulatives();\n        harvestedLast = this.currentTime();\n    }\n\n    // /internals\n\n}"
    },
    {
      "filename": "contracts/SmartYield.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"hardhat/console.sol\";\n\n// TODO:\n// investigate comp value + spot price + rate = min(MAX, oracle, spot)\n// more tests\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./lib/math/MathUtils.sol\";\n\nimport \"./Governed.sol\";\nimport \"./IController.sol\";\nimport \"./oracle/IYieldOraclelizable.sol\";\nimport \"./ISmartYield.sol\";\n\nimport \"./IProvider.sol\";\n\nimport \"./model/IBondModel.sol\";\nimport \"./oracle/IYieldOracle.sol\";\nimport \"./IBond.sol\";\nimport \"./JuniorToken.sol\";\n\ncontract SmartYield is\n    JuniorToken,\n    ISmartYield\n{\n    using SafeMath for uint256;\n\n    // controller address\n    address public controller;\n\n    // address of IProviderPool\n    address public pool;\n\n    // senior BOND (NFT)\n    address public seniorBond; // IBond\n\n    // junior BOND (NFT)\n    address public juniorBond; // IBond\n\n    // underlying amount in matured and liquidated juniorBonds\n    uint256 public underlyingLiquidatedJuniors;\n\n    // tokens amount in unmatured juniorBonds or matured and unliquidated\n    uint256 public tokensInJuniorBonds;\n\n    // latest SeniorBond Id\n    uint256 public seniorBondId;\n\n    // latest JuniorBond Id\n    uint256 public juniorBondId;\n\n    // last index of juniorBondsMaturities that was liquidated\n    uint256 public juniorBondsMaturitiesPrev;\n    // list of junior bond maturities (timestamps)\n    uint256[] public juniorBondsMaturities;\n\n    // checkpoints for all JuniorBonds matureing at (timestamp) -> (JuniorBondsAt)\n    // timestamp -> JuniorBondsAt\n    mapping(uint256 => JuniorBondsAt) public juniorBondsMaturingAt;\n\n    // metadata for senior bonds\n    // bond id => bond (SeniorBond)\n    mapping(uint256 => SeniorBond) public seniorBonds;\n\n    // metadata for junior bonds\n    // bond id => bond (JuniorBond)\n    mapping(uint256 => JuniorBond) public juniorBonds;\n\n    // pool state / average bond\n    // holds rate of payment by juniors to seniors\n    SeniorBond public abond;\n\n    bool public _setup;\n\n    constructor(\n      string memory name_,\n      string memory symbol_\n    )\n      JuniorToken(name_, symbol_)\n    {}\n\n    function setup(\n      address controller_,\n      address pool_,\n      address seniorBond_,\n      address juniorBond_\n    )\n      external\n    {\n        require(\n          false == _setup,\n          \"SY: already setup\"\n        );\n\n        controller = controller_;\n        pool = pool_;\n        seniorBond = seniorBond_;\n        juniorBond = juniorBond_;\n\n        _setup = true;\n    }\n\n    // externals\n\n    // buy at least _minTokens with _underlyingAmount, before _deadline passes\n    function buyTokens(\n      uint256 underlyingAmount_,\n      uint256 minTokens_,\n      uint256 deadline_\n    )\n      external override\n    {\n        _beforeProviderOp();\n\n        require(\n          false == IController(controller).PAUSED_BUY_JUNIOR_TOKEN(),\n          \"SY: buyTokens paused\"\n        );\n\n        require(\n          this.currentTime() <= deadline_,\n          \"SY: buyTokens deadline\"\n        );\n\n        uint256 fee = MathUtils.fractionOf(underlyingAmount_, IController(controller).FEE_BUY_JUNIOR_TOKEN());\n        uint256 getsTokens = (underlyingAmount_ - fee) * 1e18 / this.price();\n\n        require(\n          getsTokens >= minTokens_,\n          \"SY: buyTokens minTokens\"\n        );\n\n        // ---\n\n        IProvider(pool)._takeUnderlying(msg.sender, underlyingAmount_);\n        IProvider(pool)._depositProvider(underlyingAmount_, fee);\n        _mint(msg.sender, getsTokens);\n    }\n\n    // sell _tokens for at least _minUnderlying, before _deadline and forfeit potential future gains\n    function sellTokens(\n      uint256 tokenAmount_,\n      uint256 minUnderlying_,\n      uint256 deadline_\n    )\n      external override\n    {\n        _beforeProviderOp();\n\n        require(\n          this.currentTime() <= deadline_,\n          \"SY: sellTokens deadline\"\n        );\n\n        // share of these tokens in the debt\n        uint256 debtShare = tokenAmount_ * 1e18 / totalSupply();\n        // debt share is forfeit, and only diff is returned to user\n        uint256 toPay = (tokenAmount_ * this.price() - this.abondDebt() * debtShare) / 1e18;\n\n        require(\n          toPay >= minUnderlying_,\n          \"SY: sellTokens minUnderlying\"\n        );\n\n        // ---\n\n        _burn(msg.sender, tokenAmount_);\n        IProvider(pool)._withdrawProvider(toPay, 0);\n        IProvider(pool)._sendUnderlying(msg.sender, toPay);\n    }\n\n    // Purchase a senior bond with principalAmount_ underlying for forDays_, buyer gets a bond with gain >= minGain_ or revert. deadline_ is timestamp before which tx is not rejected.\n    function buyBond(\n        uint256 principalAmount_,\n        uint256 minGain_,\n        uint256 deadline_,\n        uint16 forDays_\n    )\n      external override\n    {\n        _beforeProviderOp();\n\n        require(\n          false == IController(controller).PAUSED_BUY_SENIOR_BOND(),\n          \"SY: buyBond paused\"\n        );\n\n        require(\n          this.currentTime() <= deadline_,\n          \"SY: buyBond deadline\"\n        );\n\n        require(\n            0 < forDays_ && forDays_ <= IController(controller).BOND_LIFE_MAX(),\n            \"SY: buyBond forDays\"\n        );\n\n        uint256 gain = this.bondGain(principalAmount_, forDays_);\n\n        require(\n          gain >= minGain_,\n          \"SY: buyBond minGain\"\n        );\n\n        require(\n          gain > 0,\n          \"SY: buyBond gain 0\"\n        );\n\n        require(\n          gain < this.underlyingLoanable(),\n          \"SY: buyBond underlyingLoanable\"\n        );\n\n        uint256 issuedAt = this.currentTime();\n\n        // ---\n\n        IProvider(pool)._takeUnderlying(msg.sender, principalAmount_);\n        IProvider(pool)._depositProvider(principalAmount_, 0);\n\n        SeniorBond memory b =\n            SeniorBond(\n                principalAmount_,\n                gain,\n                issuedAt,\n                uint256(1 days) * uint256(forDays_) + issuedAt,\n                false\n            );\n\n        _mintBond(msg.sender, b);\n    }\n\n    // buy an nft with tokenAmount_ jTokens, that matures at abond maturesAt\n    function buyJuniorBond(\n      uint256 tokenAmount_,\n      uint256 maxMaturesAt_,\n      uint256 deadline_\n    )\n      external override\n    {\n        uint256 maturesAt = 1 + abond.maturesAt / 1e18;\n\n        require(\n          this.currentTime() <= deadline_,\n          \"SY: buyJuniorBond deadline\"\n        );\n\n        require(\n          maturesAt <= maxMaturesAt_,\n          \"SY: buyJuniorBond maxMaturesAt\"\n        );\n\n        JuniorBond memory jb = JuniorBond(\n          tokenAmount_,\n          maturesAt\n        );\n\n        // ---\n\n        _takeTokens(msg.sender, tokenAmount_);\n        _mintJuniorBond(msg.sender, jb);\n\n        // if abond.maturesAt is past we can liquidate, but juniorBondsMaturingAt might have already been liquidated\n        if (this.currentTime() >= maturesAt) {\n            JuniorBondsAt memory jBondsAt = juniorBondsMaturingAt[jb.maturesAt];\n\n            if (jBondsAt.price == 0) {\n                _liquidateJuniorsAt(jb.maturesAt);\n            } else {\n                // juniorBondsMaturingAt was previously liquidated,\n                _burn(address(this), jb.tokens); // burns user's locked tokens reducing the jToken supply\n                underlyingLiquidatedJuniors += jb.tokens * jBondsAt.price / 1e18;\n                _unaccountJuniorBond(jb);\n            }\n            return this.redeemJuniorBond(juniorBondId);\n        }\n    }\n\n    // Redeem a senior bond by it's id. Anyone can redeem but owner gets principal + gain\n    function redeemBond(\n      uint256 bondId_\n    )\n      external override\n    {\n        _beforeProviderOp();\n\n        require(\n            this.currentTime() >= seniorBonds[bondId_].maturesAt,\n            \"SY: redeemBond not matured\"\n        );\n\n        // bondToken.ownerOf will revert for burned tokens\n        address payTo = IBond(seniorBond).ownerOf(bondId_);\n        uint256 payAmnt = seniorBonds[bondId_].gain + seniorBonds[bondId_].principal;\n        uint256 fee = MathUtils.fractionOf(seniorBonds[bondId_].gain, IController(controller).FEE_REDEEM_SENIOR_BOND());\n        payAmnt -= fee;\n\n        // ---\n\n        if (seniorBonds[bondId_].liquidated == false) {\n            seniorBonds[bondId_].liquidated = true;\n            _unaccountBond(seniorBonds[bondId_]);\n        }\n\n        // bondToken.burn will revert for already burned tokens\n        IBond(seniorBond).burn(bondId_);\n        delete seniorBonds[bondId_];\n\n        IProvider(pool)._withdrawProvider(payAmnt, fee);\n        IProvider(pool)._sendUnderlying(payTo, payAmnt);\n    }\n\n    // once matured, redeem a jBond for underlying\n    function redeemJuniorBond(uint256 jBondId_)\n        external override\n    {\n        _beforeProviderOp();\n\n        JuniorBond memory jb = juniorBonds[jBondId_];\n        require(\n            jb.maturesAt <= this.currentTime(),\n            \"SY: redeemJuniorBond maturesAt\"\n        );\n\n        JuniorBondsAt memory jBondsAt = juniorBondsMaturingAt[jb.maturesAt];\n\n        // blows up if already burned\n        address payTo = IBond(juniorBond).ownerOf(jBondId_);\n        uint256 payAmnt = jBondsAt.price * jb.tokens / 1e18;\n\n        // ---\n\n        _burnJuniorBond(jBondId_);\n        IProvider(pool)._withdrawProvider(payAmnt, 0);\n        IProvider(pool)._sendUnderlying(payTo, payAmnt);\n        underlyingLiquidatedJuniors -= payAmnt;\n    }\n\n\n    function providerRatePerDay()\n      external view virtual override\n    returns (uint256)\n    {\n        return MathUtils.min(\n          IController(controller).BOND_MAX_RATE_PER_DAY(),\n          IYieldOracle(IController(controller).oracle()).consult(1 days)\n        );\n    }\n\n    // given a principal amount and a number of days, compute the guaranteed bond gain, excluding principal\n    function bondGain(uint256 principalAmount_, uint16 forDays_)\n      external view override\n    returns (uint256)\n    {\n        return IBondModel(IController(controller).bondModel()).gain(address(this), principalAmount_, forDays_);\n    }\n\n  // /externals\n\n  // publics\n\n    function currentTime()\n      public view virtual override\n    returns (uint256)\n    {\n        // mockable\n        return block.timestamp;\n    }\n\n    // jToken price * 1e18\n    function price()\n      public view override\n    returns (uint256)\n    {\n        uint256 ts = totalSupply();\n        return (ts == 0) ? 1e18 : (this.underlyingJuniors() * 1e18) / ts;\n    }\n\n    function underlyingTotal()\n      public view virtual override\n    returns(uint256)\n    {\n      return IProvider(pool).underlyingBalance() - IProvider(pool).underlyingFees() - underlyingLiquidatedJuniors;\n    }\n\n    function underlyingJuniors()\n      public view virtual override\n    returns (uint256)\n    {\n        return this.underlyingTotal() - abond.principal - this.abondPaid();\n    }\n\n    function underlyingLoanable()\n      public view virtual override\n    returns (uint256)\n    {\n        // underlyingTotal - abond.principal - abond.gain - queued withdrawls\n        return this.underlyingTotal() - abond.principal - abond.gain - (tokensInJuniorBonds * this.price() / 1e18);\n    }\n\n    function abondGain()\n      public view override\n    returns (uint256)\n    {\n        return abond.gain;\n    }\n\n    function abondPaid()\n      public view override\n    returns (uint256)\n    {\n        uint256 ts = this.currentTime() * 1e18;\n        if (ts <= abond.issuedAt || (abond.maturesAt <= abond.issuedAt)) {\n          return 0;\n        }\n\n        uint256 d = abond.maturesAt - abond.issuedAt;\n        return (this.abondGain() * MathUtils.min(ts - abond.issuedAt, d)) / d;\n    }\n\n    function abondDebt()\n      public view override\n    returns (uint256)\n    {\n        return this.abondGain() - this.abondPaid();\n    }\n\n  // /publics\n\n  // internals\n\n    function _beforeProviderOp"
    }
  ]
}