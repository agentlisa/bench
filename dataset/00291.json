{
  "Title": "[C-02] Attacker can drain Periphery by specifying big `socketPayloadSize`",
  "Content": "**Severity**\n\n**Impact:** High\n\n**Likelihood:** High\n\n**Description**\n\nWhen a user withdraws funds from protocol, tokens are bridged to another chain to address `receiver`. The fee to pay for bridging is based on `gasLimit` and `payloadSize`:\n\n```solidity\n    function getFees(...)\n        internal\n        view\n        returns (uint256 feeInToken, uint256 nativeFees)\n    {\n@>      nativeFees = controller.getMinFees(connector, gasLimit, payloadSize);\n        feeInToken = Configuration.getStaticWithdrawFee(token, connector);\n    }\n```\n\nUser can just set very high `payloadSize` and protocol will pay high fee:\n\n```solidity\n    function executeBridging(...)\n        internal\n    {\n        ISocketControllerWithPayload socketController =\n            ISocketControllerWithPayload(Configuration.getController(withdrawToken));\n\n        (uint256 tokenFees, uint256 nativeFees) =\n            getFees(withdrawToken, socketController, socketConnector, socketMsgGasLimit, socketPayloadSize);\n        if (tokenAmount > tokenFees) {\n            uint256 tokensToWithdraw = tokenAmount - tokenFees;\n@>          socketController.bridge{ value: nativeFees }({\n                receiver_: receiver,\n                amount_: tokensToWithdraw,\n                msgGasLimit_: socketMsgGasLimit,\n                connector_: socketConnector,\n                execPayload_: abi.encode(),\n                options_: abi.encode()\n            });\n            withdrawToken.safeTransfer(OwnableStorage.getOwner(), tokenFees);\n        } else {\n            revert Errors.NotEnoughFees(tokenAmount, tokenFees);\n        }\n    }\n```\n\nNote that Socket which is used for bridging doesn't send back excessive `msg.value`. It treats excessive `msg.value` as `executionFee`:\n[Link](https://github.com/SocketDotTech/socket-DL/blob/1766c10c0e4dee08db1dc24f0ca8a0b469232a57/contracts/ExecutionManager.sol#L246-L250)\n\nAnother note is that currently `payloadSize` is not used in fee calculation, but will be in a future version\n[link](https://github.com/SocketDotTech/socket-DL/blob/1766c10c0e4dee08db1dc24f0ca8a0b469232a57/contracts/ExecutionManager.sol#L275)\n\n**Recommendations**\n\nRemove argument `socketPayloadSize` and use 0 instead",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/ExecutionManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.19;\n\nimport \"./interfaces/ISwitchboard.sol\";\nimport \"./interfaces/ISocket.sol\";\nimport \"./interfaces/ISignatureVerifier.sol\";\nimport \"./libraries/RescueFundsLib.sol\";\nimport \"./utils/AccessControlExtended.sol\";\nimport {WITHDRAW_ROLE, RESCUE_ROLE, EXECUTOR_ROLE, FEES_UPDATER_ROLE} from \"./utils/AccessRoles.sol\";\nimport {FEES_UPDATE_SIG_IDENTIFIER, RELATIVE_NATIVE_TOKEN_PRICE_UPDATE_SIG_IDENTIFIER, MSG_VALUE_MAX_THRESHOLD_SIG_IDENTIFIER, MSG_VALUE_MIN_THRESHOLD_SIG_IDENTIFIER} from \"./utils/SigIdentifiers.sol\";\n\n/**\n * @title ExecutionManager\n * @dev Implementation of the IExecutionManager interface, providing functions for executing cross-chain transactions and\n * managing execution and other fees. This contract also implements the AccessControl interface, allowing for role-based\n * access control.\n */\ncontract ExecutionManager is IExecutionManager, AccessControlExtended {\n    ISignatureVerifier public immutable signatureVerifier__;\n    ISocket public immutable socket__;\n    uint32 public immutable chainSlug;\n\n    /**\n     * @notice Emitted when the executionFees is updated\n     * @param siblingChainSlug The destination chain slug for which the executionFees is updated\n     * @param executionFees The new executionFees\n     */\n    event ExecutionFeesSet(uint256 siblingChainSlug, uint128 executionFees);\n\n    /**\n     * @notice Emitted when the relativeNativeTokenPrice is updated\n     * @param siblingChainSlug The destination chain slug for which the relativeNativeTokenPrice is updated\n     * @param relativeNativeTokenPrice The new relativeNativeTokenPrice\n     */\n    event RelativeNativeTokenPriceSet(\n        uint256 siblingChainSlug,\n        uint256 relativeNativeTokenPrice\n    );\n\n    /**\n     * @notice Emitted when the msgValueMaxThresholdSet is updated\n     * @param siblingChainSlug The destination chain slug for which the msgValueMaxThresholdSet is updated\n     * @param msgValueMaxThresholdSet The new msgValueMaxThresholdSet\n     */\n    event MsgValueMaxThresholdSet(\n        uint256 siblingChainSlug,\n        uint256 msgValueMaxThresholdSet\n    );\n\n    /**\n     * @notice Emitted when the msgValueMinThresholdSet is updated\n     * @param siblingChainSlug The destination chain slug for which the msgValueMinThresholdSet is updated\n     * @param msgValueMinThresholdSet The new msgValueMinThresholdSet\n     */\n    event MsgValueMinThresholdSet(\n        uint256 siblingChainSlug,\n        uint256 msgValueMinThresholdSet\n    );\n\n    /**\n     * @notice Emitted when the execution fees is withdrawn\n     * @param account The address to which fees is transferred\n     * @param siblingChainSlug The destination chain slug for which the fees is withdrawn\n     * @param amount The amount withdrawn\n     */\n    event ExecutionFeesWithdrawn(\n        address account,\n        uint32 siblingChainSlug,\n        uint256 amount\n    );\n\n    /**\n     * @notice Emitted when the transmission fees is withdrawn\n     * @param transmitManager The address of transmit manager to which fees is transferred\n     * @param siblingChainSlug The destination chain slug for which the fees is withdrawn\n     * @param amount The amount withdrawn\n     */\n    event TransmissionFeesWithdrawn(\n        address transmitManager,\n        uint32 siblingChainSlug,\n        uint256 amount\n    );\n\n    /**\n     * @notice Emitted when the switchboard fees is withdrawn\n     * @param switchboard The address of switchboard for which fees is claimed\n     * @param siblingChainSlug The destination chain slug for which the fees is withdrawn\n     * @param amount The amount withdrawn\n     */\n    event SwitchboardFeesWithdrawn(\n        address switchboard,\n        uint32 siblingChainSlug,\n        uint256 amount\n    );\n\n    /**\n     * @notice packs the total execution and transmission fees received for a sibling slug\n     */\n    struct TotalExecutionAndTransmissionFees {\n        uint128 totalExecutionFees;\n        uint128 totalTransmissionFees;\n    }\n\n    // maps total fee collected with chain slug\n    mapping(uint32 => TotalExecutionAndTransmissionFees)\n        public totalExecutionAndTransmissionFees;\n\n    // switchboard => chain slug => switchboard fees collected\n    mapping(address => mapping(uint32 => uint128)) public totalSwitchboardFees;\n\n    // transmitter => nextNonce\n    mapping(address => uint256) public nextNonce;\n\n    // remoteChainSlug => executionFees\n    mapping(uint32 => uint128) public executionFees;\n\n    // transmit manager => chain slug => switchboard fees collected\n    mapping(address => mapping(uint32 => uint128)) public transmissionMinFees;\n\n    // relativeNativeTokenPrice is used to convert fees to destination terms when sending value along with message\n    // destSlug => relativeNativePrice (stores (destnativeTokenPriceUSD*(1e18)/srcNativeTokenPriceUSD))\n    mapping(uint32 => uint256) public relativeNativeTokenPrice;\n\n    // supported min amount of native value to send with message\n    // chain slug => min msg value threshold\n    mapping(uint32 => uint256) public msgValueMinThreshold;\n\n    // supported max amount of native value to send with message\n    // chain slug => max msg value threshold\n    mapping(uint32 => uint256) public msgValueMaxThreshold;\n\n    // triggered when nonce in signature is invalid\n    error InvalidNonce();\n\n    // triggered when msg value less than min threshold\n    error MsgValueTooLow();\n\n    // triggered when msg value more than max threshold\n    error MsgValueTooHigh();\n\n    // triggered when payload is larger than expected limit\n    error PayloadTooLarge();\n\n    // triggered when msg value is not enough\n    error InsufficientMsgValue();\n\n    // triggered when fees is not enough\n    error InsufficientFees();\n\n    // triggered when msg value exceeds uint128 max value\n    error InvalidMsgValue();\n\n    // triggered when fees exceeds uint128 max value\n    error FeesTooHigh();\n\n    error OnlySocket();\n\n    /**\n     * @dev Constructor for ExecutionManager contract\n     * @param owner_ address of the contract owner\n     * @param chainSlug_ chain slug, unique identifier of chain deployed on\n     * @param signatureVerifier_ the signature verifier contract\n     * @param socket_ the socket contract\n     */\n    constructor(\n        address owner_,\n        uint32 chainSlug_,\n        ISocket socket_,\n        ISignatureVerifier signatureVerifier_\n    ) AccessControlExtended(owner_) {\n        chainSlug = chainSlug_;\n        signatureVerifier__ = signatureVerifier_;\n        socket__ = ISocket(socket_);\n    }\n\n    /**\n     * @notice Checks whether the provided signer address is an executor for the given packed message and signature\n     * @param packedMessage Packed message to be executed\n     * @param sig Signature of the message\n     * @return executor Address of the executor\n     * @return isValidExecutor Boolean value indicating whether the executor is valid or not\n     */\n    function isExecutor(\n        bytes32 packedMessage,\n        bytes memory sig\n    )\n        external\n        view\n        virtual\n        override\n        returns (address executor, bool isValidExecutor)\n    {\n        executor = signatureVerifier__.recoverSigner(packedMessage, sig);\n        isValidExecutor = _hasRole(EXECUTOR_ROLE, executor);\n    }\n\n    /**\n     * @notice updates the total fee used by an executor to execute a message\n     * @dev to be used for accounting when onchain fee distribution for individual executors is implemented\n     * @dev this function should be called by socket only\n     * @inheritdoc IExecutionManager\n     */\n    function updateExecutionFees(\n        address,\n        uint128,\n        bytes32\n    ) external view override {\n        if (msg.sender != address(socket__)) revert OnlySocket();\n    }\n\n    /// @inheritdoc IExecutionManager\n    function payAndCheckFees(\n        uint256 minMsgGasLimit_,\n        uint256 payloadSize_,\n        bytes32 executionParams_,\n        bytes32,\n        uint32 siblingChainSlug_,\n        uint128 switchboardFees_,\n        uint128 verificationOverheadFees_,\n        address transmitManager_,\n        address switchboard_,\n        uint256 maxPacketLength_\n    )\n        external\n        payable\n        override\n        returns (uint128 executionFee, uint128 transmissionFees)\n    {\n        if (msg.value >= type(uint128).max) revert InvalidMsgValue();\n        uint128 msgValue = uint128(msg.value);\n\n        // transmission fees are per packet, so need to divide by number of messages per packet\n        transmissionFees =\n            transmissionMinFees[transmitManager_][siblingChainSlug_] /\n            uint128(maxPacketLength_);\n\n        uint128 minMsgExecutionFees = _getMinFees(\n            minMsgGasLimit_,\n            payloadSize_,\n            executionParams_,\n            siblingChainSlug_\n        );\n\n        uint128 minExecutionFees = minMsgExecutionFees +\n            verificationOverheadFees_;\n        if (msgValue < transmissionFees + switchboardFees_ + minExecutionFees)\n            revert InsufficientFees();\n\n        // any extra fee is considered as executionFee\n        executionFee = msgValue - transmissionFees - switchboardFees_;\n\n        TotalExecutionAndTransmissionFees\n            memory currentTotalFees = totalExecutionAndTransmissionFees[\n                siblingChainSlug_\n            ];\n\n        totalExecutionAndTransmissionFees[\n            siblingChainSlug_\n        ] = TotalExecutionAndTransmissionFees({\n            totalExecutionFees: currentTotalFees.totalExecutionFees +\n                executionFee,\n            totalTransmissionFees: currentTotalFees.totalTransmissionFees +\n                transmissionFees\n        });\n\n        totalSwitchboardFees[switchboard_][\n            siblingChainSlug_\n        ] += switchboardFees_;\n    }\n\n    /**\n     * @notice function for getting the minimum fees required for executing msg on destination\n     * @dev this function is called at source to calculate the execution cost.\n     * @param gasLimit_ the gas limit needed for execution at destination\n     * @param payloadSize_ byte length of payload. Currently only used to check max length, later on will be used for fees calculation.\n     * @param executionParams_ Can be used for providing extra information. Currently used for msgValue\n     * @param siblingChainSlug_ Sibling chain identifier\n     * @return minExecutionFee : Minimum fees required for executing the transaction\n     */\n    function getMinFees(\n        uint256 gasLimit_,\n        uint256 payloadSize_,\n        bytes32 executionParams_,\n        uint32 siblingChainSlug_\n    ) external view override returns (uint128 minExecutionFee) {\n        minExecutionFee = _getMinFees(\n            gasLimit_,\n            payloadSize_,\n            executionParams_,\n            siblingChainSlug_\n        );\n    }\n\n    /// @inheritdoc IExecutionManager\n    function getExecutionTransmissionMinFees(\n        uint256 minMsgGasLimit_,\n        uint256 payloadSize_,\n        bytes32 executionParams_,\n        bytes32,\n        uint32 siblingChainSlug_,\n        address transmitManager_\n    )\n        external\n        view\n        override\n        returns (uint128 minExecutionFee, uint128 transmissionFees)\n    {\n        minExecutionFee = _getMinFees(\n            minMsgGasLimit_,\n            payloadSize_,\n            executionParams_,\n            siblingChainSlug_\n        );\n        transmissionFees = transmissionMinFees[transmitManager_][\n            siblingChainSlug_\n        ];\n    }\n\n    // decodes and validates the msg value if it is under given transfer limits and calculates\n    // the total fees needed for execution for given payload size and msg value.\n    function _getMinFees(\n        uint256,\n        uint256 payloadSize_,\n        bytes32 executionParams_,\n        uint32 siblingChainSlug_\n    ) internal view returns (uint128) {\n        if (payloadSize_ > 3000) revert PayloadTooLarge();\n\n        uint256 params = uint256(executionParams_);\n        uint8 paramType = uint8(params >> 248);\n\n        if (paramType == 0) return executionFees[siblingChainSlug_];\n        uint256 msgValue = uint256(uint248(params));\n\n        if (msgValue < msgValueMinThreshold[siblingChainSlug_])\n            revert MsgValueTooLow();\n        if (msgValue > msgValueMaxThreshold[siblingChainSlug_])\n            revert MsgValueTooHigh();\n\n        uint256 msgValueRequiredOnSrcChain = (relativeNativeTokenPrice[\n            siblingChainSlug_\n        ] * msgValue) / 1e18;\n\n        uint256 totalNativeValue = msgValueRequiredOnSrcChain +\n            executionFees[siblingChainSlug_];\n\n        if (totalNativeValue >= type(uint128).max) revert FeesTooHigh();\n        return uint128(totalNativeValue);\n    }\n\n    /**\n     * @notice called by socket while executing message to validate if the msg value provided is enough\n     * @param executionParams_ a bytes32 string where first byte gives param type (if value is 0 or not)\n     * and remaining bytes give the msg value needed\n     * @param msgValue_ msg.value to be sent with inbound\n     */\n    function verifyParams(\n        bytes32 executionParams_,\n        uint256 msgValue_\n    ) external pure override {\n        uint256 params = uint256(executionParams_);\n        uint8 paramType = uint8(params >> 248);\n\n        if (paramType == 0) return;\n        uint256 expectedMsgValue = uint256(uint248(params));\n        if (msgValue_ < expectedMsgValue) revert InsufficientMsgValue();\n    }\n\n    /**\n     * @notice sets the minimum execution fees required for executing at `siblingChainSlug_`\n     * @dev this function currently sets the price for a constant msg gas limit and payload size but this will be\n     * updated in future to consider gas limit and payload size to return fees which will be close to\n     * actual execution cost.\n     * @param nonce_ incremental id to prevent signature replay\n     * @param siblingChainSlug_ sibling chain identifier\n     * @param executionFees_ total fees where price in destination native token is converted to source native tokens\n     * @param signature_ signature of fee updater\n     */\n    function setExecutionFees(\n        uint256 nonce_,\n        uint32 siblingChainSlug_,\n        uint128 executionFees_,\n        bytes calldata signature_\n    ) external override {\n        address feesUpdater = signatureVerifier__.recoverSigner(\n            keccak256(\n                abi.encode(\n                    FEES_UPDATE_SIG_IDENTIFIER,\n                    address(this),\n                    chainSlug,\n                    siblingChainSlug_,\n                    nonce_,\n                    executionFees_\n                )\n            ),\n            signature_\n        );\n\n        _checkRoleWithSlug(FEES_UPDATER_ROLE, siblingChainSlug_, feesUpdater);\n\n        // nonce is used by gated roles and we don't expect nonce to reach the max value of uint256\n        unchecked {\n            if (nonce_ != nextNonce[feesUpdater]++) revert InvalidNonce();\n        }\n\n        executionFees[siblingChainSlug_] = executionFees_;\n        emit ExecutionFeesSet(siblingChainSlug_, executionFees_);\n    }\n\n    /**\n     * @notice sets the relative token price for `siblingChainSlug_`\n     * @dev this function is expected to be called frequently to match the original prices\n     * @param nonce_ incremental id to prevent signature replay\n     * @param siblingChainSlug_ sibling chain identifier\n     * @param relativeNativeTokenPrice_ relative price\n     * @param signature_ signature of fee updater\n     */\n    function setRelativeNativeTokenPrice(\n        uint256 nonce_,\n        uint32 siblingChainSlug_,\n        uint256 relativeNativeTokenPrice_,\n        bytes calldata signature_\n    ) external override {\n        address feesUpdater = signatureVerifier__.recoverSigner(\n            keccak256(\n                abi.encode(\n                    RELATIVE_NATIVE_TOKEN_PRICE_UPDATE_SIG_IDENTIFIER,\n                    address(this),\n                    chainSlug,\n                    siblingChainSlug_,\n                    nonce_,\n                    relativeNativeTokenPrice_\n                )\n            ),\n            signature_\n        );\n\n        _checkRoleWithSlug(FEES_UPDATER_ROLE, siblingChainSlug_, feesUpdater);\n\n        // nonce is used by gated roles and we don't expect nonce to reach the max value of uint256\n        unchecked {\n            if (nonce_ != nextNonce[feesUpdater]++) revert InvalidNonce();\n        }\n\n        relativeNativeTokenPrice[siblingChainSlug_] = relativeNativeTokenPrice_;\n        emit RelativeNativeTokenPriceSet(\n            siblingChainSlug_,\n            relativeNativeTokenPrice_\n        );\n    }\n\n    /**\n     * @notice sets the min limit for msg value for `siblingChainSlug_`\n     * @param nonce_ incremental id to prevent signature replay\n     * @param siblingChainSlug_ sibling chain identifier\n     * @param msgValueMinThreshold_ min msg value\n     * @param signature_ signature of fee updater\n     */\n    function setMsgValueMinThreshold(\n        uint256 nonce_,\n        uint32 siblingChainSlug_,\n        uint256 msgValueMinThreshold_,\n        bytes calldata signature_\n    ) external override {\n        address feesUpdater = signatureVerifier__.recoverSigner(\n            keccak256(\n                abi.encode(\n                    MSG_VALUE_MIN_THRESHOLD_SIG_IDENTIFIER,\n                    address(this),\n                    chainSlug,\n                    siblingChainSlug_,\n                    nonce_,\n                    msgValueMinThreshold_\n                )\n            ),\n            signature_\n        );\n\n        _checkRoleWithSlug(FEES_UPDATER_ROLE, siblingChainSlug_, feesUpdater);\n\n        // nonce is used by gated roles and we don't expect nonce to reach the max value of uint256\n        unchecked {\n            if (nonce_ != nextNonce[feesUpdater]++) revert InvalidNonce();\n        }\n        msgValueMinThreshold[siblingChainSlug_] = msgValueMinThreshold_;\n        emit MsgValueMinThresholdSet(siblingChainSlug_, msgValueMinThreshold_);\n    }\n\n    /**\n     * @notice sets the max limit for msg value for `siblingChainSlug_`\n     * @param nonce_ incremental id to prevent signature replay\n     * @param siblingChainSlug_ sibling chain identifier\n     * @param msgValueMaxThreshold_ max msg value\n     * @param signature_ signature of fee updater\n     */\n    function setMsgValueMaxThreshold(\n        uint256 nonce_,\n        uint32 siblingChainSlug_,\n        uint256 msgValueMaxThreshold_,\n        bytes calldata signature_\n    ) external override {\n        address feesUpdater = signatureVerifier__.recoverSigner(\n            keccak256(\n                abi.encode(\n                    MSG_VALUE_MAX_THRESHOLD_SIG_IDENTIFIER,\n                    address(this),\n                    chainSlug,\n                    siblingChainSlug_,\n                    nonce_,\n                    msgValueMaxThreshold_\n                )\n            ),\n            signature_\n        );\n\n        _checkRoleWithSlug(FEES_UPDATER_ROLE, siblingChainSlug_, feesUpdater);\n\n        // nonce is used by gated roles and we don't expect nonce to reach the max value of uint256\n        unchecked {\n            if (nonce_ != nextNonce[feesUpdater]++) revert InvalidNonce();\n        }\n        msgValueMaxThreshold[siblingChainSlug_] = msgValueMaxThreshold_;\n        emit MsgValueMaxThresholdSet(siblingChainSlug_, msgValueMaxThreshold_);\n    }\n\n    /**\n     * @notice updates the transmission fee needed for transmission\n     * @dev this function stores value against msg.sender hence expected to be called by transmit manager\n     * @inheritdoc IExecutionManager\n     */\n    function setTransmissionMinFees(\n        uint32 remoteChainSlug_,\n        uint128 fees_\n    ) external override {\n        transmissionMinFees[msg.sender][remoteChainSlug_] = fees_;\n    }\n\n    /**\n     * @notice withdraws fees for execution from contract\n     * @param siblingChainSlug_ withdraw fees corresponding to this slug\n     * @param amount_ withdraw amount\n     * @param withdrawTo_ withdraw fees to the provided address\n     */\n    function withdrawExecutionFees(\n        uint32 siblingChainSlug_,\n        uint128 amount_,\n        address withdrawTo_\n    ) external onlyRole(WITHDRAW_ROLE) {\n        if (withdrawTo_ == address(0)) revert ZeroAddress();\n        if (\n            totalExecutionAndTransmissionFees[siblingChainSlug_]\n                .totalExecutionFees < amount_\n        ) revert InsufficientFees();\n\n        totalExecutionAndTransmissionFees[siblingChainSlug_]\n            .totalExecutionFees -= amount_;\n\n        SafeTransferLib.safeTransferETH(withdrawTo_, amount_);\n        emit ExecutionFeesWithdrawn(withdrawTo_, siblingChainSlug_, amount_);\n    }\n\n    /**\n     * @notice withdraws switchboard fees from contract\n     * @param siblingChainSlug_ withdraw fees corresponding to this slug\n     * @param amount_ withdraw amount\n     */\n    function withdrawSwitchboardFees(\n        uint32 siblingChainSlug_,\n        address switchboard_,\n        uint128 amount_\n    ) external override {\n        if (totalSwitchboardFees[switchboard_][siblingChainSlug_] < amount_)\n            revert InsufficientFees();\n\n        totalSwitchboardFees[switchboard_][siblingChainSlug_] -= amount_;\n        ISwitchboard(switchboard_).receiveFees{value: amount_}(\n            siblingChainSlug_\n        );\n\n        emit SwitchboardFeesWithdrawn(switchboard_, siblingChainSlug_, amount_);\n    }\n\n    /**\n     * @dev this function gets the transmitManager address from the socket contract. If it is ever upgraded in socket,\n     * @dev remove the fees from executionManager first, and then upgrade address at socket.\n     * @notice withdraws transmission fees from contract\n     * @param siblingChainSlug_ withdraw fees corresponding to this slug\n     * @param amount_ withdraw amount\n     */\n    function withdrawTransmissionFees(\n        uint32 siblingChainSlug_,\n        uint128 amount_\n    ) external override {\n        if (\n            totalExecutionAndTransmissionFees[siblingChainSlug_]\n                .totalTransmissionFees < amount_\n        ) revert InsufficientFees();\n\n        totalExecutionAndTransmissionFees[siblingChainSlug_]\n            .totalTransmissionFees -= amount_;\n\n        ITransmitManager tm = socket__.transmitManager__();\n        tm.receiveFees{value: amount_}(siblingChainSlug_);\n        emit TransmissionFeesWithdrawn(address(tm), siblingChainSlug_, amount_);\n    }\n\n    /**\n     * @notice Rescues funds from the contract if they are locked by mistake.\n     * @param token_ The address of the token contract.\n     * @param rescueTo_ The address where rescued tokens need to be sent.\n     * @param amount_ The amount of tokens to be rescued.\n     */\n    function rescueFunds(\n        address token_,\n        address rescueTo_,\n        uint256 amount_\n    ) external onlyRole(RESCUE_ROLE) {\n        RescueFundsLib.rescueFunds(token_, rescueTo_, amount_);\n    }\n}"
    },
    {
      "filename": "contracts/ExecutionManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.19;\n\nimport \"./interfaces/ISwitchboard.sol\";\nimport \"./interfaces/ISocket.sol\";\nimport \"./interfaces/ISignatureVerifier.sol\";\nimport \"./libraries/RescueFundsLib.sol\";\nimport \"./utils/AccessControlExtended.sol\";\nimport {WITHDRAW_ROLE, RESCUE_ROLE, EXECUTOR_ROLE, FEES_UPDATER_ROLE} from \"./utils/AccessRoles.sol\";\nimport {FEES_UPDATE_SIG_IDENTIFIER, RELATIVE_NATIVE_TOKEN_PRICE_UPDATE_SIG_IDENTIFIER, MSG_VALUE_MAX_THRESHOLD_SIG_IDENTIFIER, MSG_VALUE_MIN_THRESHOLD_SIG_IDENTIFIER} from \"./utils/SigIdentifiers.sol\";\n\n/**\n * @title ExecutionManager\n * @dev Implementation of the IExecutionManager interface, providing functions for executing cross-chain transactions and\n * managing execution and other fees. This contract also implements the AccessControl interface, allowing for role-based\n * access control.\n */\ncontract ExecutionManager is IExecutionManager, AccessControlExtended {\n    ISignatureVerifier public immutable signatureVerifier__;\n    ISocket public immutable socket__;\n    uint32 public immutable chainSlug;\n\n    /**\n     * @notice Emitted when the executionFees is updated\n     * @param siblingChainSlug The destination chain slug for which the executionFees is updated\n     * @param executionFees The new executionFees\n     */\n    event ExecutionFeesSet(uint256 siblingChainSlug, uint128 executionFees);\n\n    /**\n     * @notice Emitted when the relativeNativeTokenPrice is updated\n     * @param siblingChainSlug The destination chain slug for which the relativeNativeTokenPrice is updated\n     * @param relativeNativeTokenPrice The new relativeNativeTokenPrice\n     */\n    event RelativeNativeTokenPriceSet(\n        uint256 siblingChainSlug,\n        uint256 relativeNativeTokenPrice\n    );\n\n    /**\n     * @notice Emitted when the msgValueMaxThresholdSet is updated\n     * @param siblingChainSlug The destination chain slug for which the msgValueMaxThresholdSet is updated\n     * @param msgValueMaxThresholdSet The new msgValueMaxThresholdSet\n     */\n    event MsgValueMaxThresholdSet(\n        uint256 siblingChainSlug,\n        uint256 msgValueMaxThresholdSet\n    );\n\n    /**\n     * @notice Emitted when the msgValueMinThresholdSet is updated\n     * @param siblingChainSlug The destination chain slug for which the msgValueMinThresholdSet is updated\n     * @param msgValueMinThresholdSet The new msgValueMinThresholdSet\n     */\n    event MsgValueMinThresholdSet(\n        uint256 siblingChainSlug,\n        uint256 msgValueMinThresholdSet\n    );\n\n    /**\n     * @notice Emitted when the execution fees is withdrawn\n     * @param account The address to which fees is transferred\n     * @param siblingChainSlug The destination chain slug for which the fees is withdrawn\n     * @param amount The amount withdrawn\n     */\n    event ExecutionFeesWithdrawn(\n        address account,\n        uint32 siblingChainSlug,\n        uint256 amount\n    );\n\n    /**\n     * @notice Emitted when the transmission fees is withdrawn\n     * @param transmitManager The address of transmit manager to which fees is transferred\n     * @param siblingChainSlug The destination chain slug for which the fees is withdrawn\n     * @param amount The amount withdrawn\n     */\n    event TransmissionFeesWithdrawn(\n        address transmitManager,\n        uint32 siblingChainSlug,\n        uint256 amount\n    );\n\n    /**\n     * @notice Emitted when the switchboard fees is withdrawn\n     * @param switchboard The address of switchboard for which fees is claimed\n     * @param siblingChainSlug The destination chain slug for which the fees is withdrawn\n     * @param amount The amount withdrawn\n     */\n    event SwitchboardFeesWithdrawn(\n        address switchboard,\n        uint32 siblingChainSlug,\n        uint256 amount\n    );\n\n    /**\n     * @notice packs the total execution and transmission fees received for a sibling slug\n     */\n    struct TotalExecutionAndTransmissionFees {\n        uint128 totalExecutionFees;\n        uint128 totalTransmissionFees;\n    }\n\n    // maps total fee collected with chain slug\n    mapping(uint32 => TotalExecutionAndTransmissionFees)\n        public totalExecutionAndTransmissionFees;\n\n    // switchboard => chain slug => switchboard fees collected\n    mapping(address => mapping(uint32 => uint128)) public totalSwitchboardFees;\n\n    // transmitter => nextNonce\n    mapping(address => uint256) public nextNonce;\n\n    // remoteChainSlug => executionFees\n    mapping(uint32 => uint128) public executionFees;\n\n    // transmit manager => chain slug => switchboard fees collected\n    mapping(address => mapping(uint32 => uint128)) public transmissionMinFees;\n\n    // relativeNativeTokenPrice is used to convert fees to destination terms when sending value along with message\n    // destSlug => relativeNativePrice (stores (destnativeTokenPriceUSD*(1e18)/srcNativeTokenPriceUSD))\n    mapping(uint32 => uint256) public relativeNativeTokenPrice;\n\n    // supported min amount of native value to send with message\n    // chain slug => min msg value threshold\n    mapping(uint32 => uint256) public msgValueMinThreshold;\n\n    // supported max amount of native value to send with message\n    // chain slug => max msg value threshold\n    mapping(uint32 => uint256) public msgValueMaxThreshold;\n\n    // triggered when nonce in signature is invalid\n    error InvalidNonce();\n\n    // triggered when msg value less than min threshold\n    error MsgValueTooLow();\n\n    // triggered when msg value more than max threshold\n    error MsgValueTooHigh();\n\n    // triggered when payload is larger than expected limit\n    error PayloadTooLarge();\n\n    // triggered when msg value is not enough\n    error InsufficientMsgValue();\n\n    // triggered when fees is not enough\n    error InsufficientFees();\n\n    // triggered when msg value exceeds uint128 max value\n    error InvalidMsgValue();\n\n    // triggered when fees exceeds uint128 max value\n    error FeesTooHigh();\n\n    error OnlySocket();\n\n    /**\n     * @dev Constructor for ExecutionManager contract\n     * @param owner_ address of the contract owner\n     * @param chainSlug_ chain slug, unique identifier of chain deployed on\n     * @param signatureVerifier_ the signature verifier contract\n     * @param socket_ the socket contract\n     */\n    constructor(\n        address owner_,\n        uint32 chainSlug_,\n        ISocket socket_,\n        ISignatureVerifier signatureVerifier_\n    ) AccessControlExtended(owner_) {\n        chainSlug = chainSlug_;\n        signatureVerifier__ = signatureVerifier_;\n        socket__ = ISocket(socket_);\n    }\n\n    /**\n     * @notice Checks whether the provided signer address is an executor for the given packed message and signature\n     * @param packedMessage Packed message to be executed\n     * @param sig Signature of the message\n     * @return executor Address of the executor\n     * @return isValidExecutor Boolean value indicating whether the executor is valid or not\n     */\n    function isExecutor(\n        bytes32 packedMessage,\n        bytes memory sig\n    )\n        external\n        view\n        virtual\n        override\n        returns (address executor, bool isValidExecutor)\n    {\n        executor = signatureVerifier__.recoverSigner(packedMessage, sig);\n        isValidExecutor = _hasRole(EXECUTOR_ROLE, executor);\n    }\n\n    /**\n     * @notice updates the total fee used by an executor to execute a message\n     * @dev to be used for accounting when onchain fee distribution for individual executors is implemented\n     * @dev this function should be called by socket only\n     * @inheritdoc IExecutionManager\n     */\n    function updateExecutionFees(\n        address,\n        uint128,\n        bytes32\n    ) external view override {\n        if (msg.sender != address(socket__)) revert OnlySocket();\n    }\n\n    /// @inheritdoc IExecutionManager\n    function payAndCheckFees(\n        uint256 minMsgGasLimit_,\n        uint256 payloadSize_,\n        bytes32 executionParams_,\n        bytes32,\n        uint32 siblingChainSlug_,\n        uint128 switchboardFees_,\n        uint128 verificationOverheadFees_,\n        address transmitManager_,\n        address switchboard_,\n        uint256 maxPacketLength_\n    )\n        external\n        payable\n        override\n        returns (uint128 executionFee, uint128 transmissionFees)\n    {\n        if (msg.value >= type(uint128).max) revert InvalidMsgValue();\n        uint128 msgValue = uint128(msg.value);\n\n        // transmission fees are per packet, so need to divide by number of messages per packet\n        transmissionFees =\n            transmissionMinFees[transmitManager_][siblingChainSlug_] /\n            uint128(maxPacketLength_);\n\n        uint128 minMsgExecutionFees = _getMinFees(\n            minMsgGasLimit_,\n            payloadSize_,\n            executionParams_,\n            siblingChainSlug_\n        );\n\n        uint128 minExecutionFees = minMsgExecutionFees +\n            verificationOverheadFees_;\n        if (msgValue < transmissionFees + switchboardFees_ + minExecutionFees)\n            revert InsufficientFees();\n\n        // any extra fee is considered as executionFee\n        executionFee = msgValue - transmissionFees - switchboardFees_;\n\n        TotalExecutionAndTransmissionFees\n            memory currentTotalFees = totalExecutionAndTransmissionFees[\n                siblingChainSlug_\n            ];\n\n        totalExecutionAndTransmissionFees[\n            siblingChainSlug_\n        ] = TotalExecutionAndTransmissionFees({\n            totalExecutionFees: currentTotalFees.totalExecutionFees +\n                executionFee,\n            totalTransmissionFees: currentTotalFees.totalTransmissionFees +\n                transmissionFees\n        });\n\n        totalSwitchboardFees[switchboard_][\n            siblingChainSlug_\n        ] += switchboardFees_;\n    }\n\n    /**\n     * @notice function for getting the minimum fees requi"
    }
  ]
}