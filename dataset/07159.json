{
  "Title": "[02] `Error.checkEnough` function does not prevent user from sending too many tokens to relevant contract",
  "Content": "\nWhen calling functions like `TimeswapV2Option.mint` or `TimeswapV2Option.swap`, the user will use the callback function like `ITimeswapV2OptionMintCallback.timeswapV2OptionMintCallback` or `ITimeswapV2OptionSwapCallback.timeswapV2OptionSwapCallback` to send some of the corresponding tokens to the relevant contract, such as `TimeswapV2Option`. Calling functions like `TimeswapV2Option.mint` or `TimeswapV2Option.swap` will revert if its call to the following `Error.checkEnough` function reverts when the token amount transferred through the callback function is not enough. However, if user sends too many tokens through the callback function, the `Error.checkEnough` function does not revert; when this happens, the extra token amount after the corresponding token balance target is met will be locked in the relevant receiving contract like `TimeswapV2Option` so the user loses such extra amount.\n\nAs a mitigation, the `balance < balanceTarget` condition in the `Error.checkEnough` function can be updated to `balance != balanceTarget`. Alternatively, some logic can be added for returning the sent extra token amount back to the user.\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-library/src/Error.sol#L151-L153\n\n```solidity\n    function checkEnough(uint256 balance, uint256 balanceTarget) internal pure {\n        if (balance < balanceTarget) revert NotEnoughReceived(balance, balanceTarget);\n    }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-01-timeswap",
  "Code": [
    {
      "filename": "packages/v2-library/src/Error.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity =0.8.8;\n\n/// @dev Common error messages\nlibrary Error {\n    /// @dev Reverts when input is zero.\n    error ZeroInput();\n\n    /// @dev Reverts when output is zero.\n    error ZeroOutput();\n\n    /// @dev Reverts when a value cannot be zero.\n    error CannotBeZero();\n\n    /// @dev Reverts when a pool already have liquidity.\n    /// @param liquidity The liquidity amount that already existed in the pool.\n    error AlreadyHaveLiquidity(uint160 liquidity);\n\n    /// @dev Reverts when a pool requires liquidity.\n    error RequireLiquidity();\n\n    /// @dev Reverts when a given address is the zero address.\n    error ZeroAddress();\n\n    /// @dev Reverts when the maturity given is not withing uint96.\n    /// @param maturity The maturity being inquired.\n    error IncorrectMaturity(uint256 maturity);\n\n    /// @dev Reverts when an option of given strike and maturity is still inactive.\n    /// @param strike The chosen strike.\n    /// @param maturity The chosen maturity.\n    error InactiveOption(uint256 strike, uint256 maturity);\n\n    /// @dev Reverts when a pool of given strike and maturity is still inactive.\n    /// @param strike The chosen strike.\n    /// @param maturity The chosen maturity.\n    error InactivePool(uint256 strike, uint256 maturity);\n\n    /// @dev Reverts when a liquidity token is inactive.\n    error InactiveLiquidityTokenChoice();\n\n    /// @dev Reverts when the square root interest rate is zero.\n    /// @param strike The chosen strike.\n    /// @param maturity The chosen maturity.\n    error ZeroSqrtInterestRate(uint256 strike, uint256 maturity);\n\n    /// @dev Reverts when the maturity is already matured.\n    /// @param maturity The maturity.\n    /// @param blockTimestamp The current block timestamp.\n    error AlreadyMatured(uint256 maturity, uint96 blockTimestamp);\n\n    /// @dev Reverts when the maturity is still active.\n    /// @param maturity The maturity.\n    /// @param blockTimestamp The current block timestamp.\n    error StillActive(uint256 maturity, uint96 blockTimestamp);\n\n    /// @dev Token amount not received.\n    /// @param minuend The amount being subtracted.\n    /// @param subtrahend The amount subtracting.\n    error NotEnoughReceived(uint256 minuend, uint256 subtrahend);\n\n    /// @dev The deadline of a transaction has been reached.\n    /// @param deadline The deadline set.\n    error DeadlineReached(uint256 deadline);\n\n    /// @dev Reverts when input is zero.\n    function zeroInput() internal pure {\n        revert ZeroInput();\n    }\n\n    /// @dev Reverts when output is zero.\n    function zeroOutput() internal pure {\n        revert ZeroOutput();\n    }\n\n    /// @dev Reverts when a value cannot be zero.\n    function cannotBeZero() internal pure {\n        revert CannotBeZero();\n    }\n\n    /// @dev Reverts when a pool already have liquidity.\n    /// @param liquidity The liquidity amount that already existed in the pool.\n    function alreadyHaveLiquidity(uint160 liquidity) internal pure {\n        revert AlreadyHaveLiquidity(liquidity);\n    }\n\n    /// @dev Reverts when a pool requires liquidity.\n    function requireLiquidity() internal pure {\n        revert RequireLiquidity();\n    }\n\n    /// @dev Reverts when a given address is the zero address.\n    function zeroAddress() internal pure {\n        revert ZeroAddress();\n    }\n\n    /// @dev Reverts when the maturity given is not withing uint96.\n    /// @param maturity The maturity being inquired.\n    function incorrectMaturity(uint256 maturity) internal pure {\n        revert IncorrectMaturity(maturity);\n    }\n\n    /// @dev Reverts when the maturity is already matured.\n    /// @param maturity The maturity.\n    /// @param blockTimestamp The current block timestamp.\n    function alreadyMatured(uint256 maturity, uint96 blockTimestamp) internal pure {\n        revert AlreadyMatured(maturity, blockTimestamp);\n    }\n\n    /// @dev Reverts when the maturity is still active.\n    /// @param maturity The maturity.\n    /// @param blockTimestamp The current block timestamp.\n    function stillActive(uint256 maturity, uint96 blockTimestamp) internal pure {\n        revert StillActive(maturity, blockTimestamp);\n    }\n\n    /// @dev The deadline of a transaction has been reached.\n    /// @param deadline The deadline set.\n    function deadlineReached(uint256 deadline) internal pure {\n        revert DeadlineReached(deadline);\n    }\n\n    /// @dev Reverts when an option of given strike and maturity is still inactive.\n    /// @param strike The chosen strike.\n    function inactiveOptionChoice(uint256 strike, uint256 maturity) internal pure {\n        revert InactiveOption(strike, maturity);\n    }\n\n    /// @dev Reverts when a pool of given strike and maturity is still inactive.\n    /// @param strike The chosen strike.\n    /// @param maturity The chosen maturity.\n    function inactivePoolChoice(uint256 strike, uint256 maturity) internal pure {\n        revert InactivePool(strike, maturity);\n    }\n\n    /// @dev Reverts when the square root interest rate is zero.\n    /// @param strike The chosen strike.\n    /// @param maturity The chosen maturity.\n    function zeroSqrtInterestRate(uint256 strike, uint256 maturity) internal pure {\n        revert ZeroSqrtInterestRate(strike, maturity);\n    }\n\n    /// @dev Reverts when a liquidity token is inactive.\n    function inactiveLiquidityTokenChoice() internal pure {\n        revert InactiveLiquidityTokenChoice();\n    }\n\n    /// @dev Reverts when token amount not received.\n    /// @param balance The balance amount being subtracted.\n    /// @param balanceTarget The amount target.\n    function checkEnough(uint256 balance, uint256 balanceTarget) internal pure {\n        if (balance < balanceTarget) revert NotEnoughReceived(balance, balanceTarget);\n    }\n}"
    }
  ]
}