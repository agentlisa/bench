{
  "Title": "Incorrect comment in `FieldFacet::_sow` NatSpec",
  "Content": "The [comment](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/field/FieldFacet.sol#L131) explaining how `FundraiserFacet::fund` bypasses soil updates in the `FieldFacet::_sow` NatSpec incorrectly references `LibDibbler::sowWithMin` when this should in fact be `LibDibbler::sowNoSoil`, as below:\n\n```diff\n    /**\n     * @dev Burn Beans, Sows at the provided `_morningTemperature`, increments the total\n     * number of `beanSown`.\n     *\n     * NOTE: {FundraiserFacet} also burns Beans but bypasses the soil mechanism\n-    * by calling {LibDibbler.sowWithMin} which bypasses updates to `s.f.beanSown`\n+    * by calling {LibDibbler.sowNoSoil} which bypasses updates to `s.f.beanSown`\n     * and `s.f.soil`. This is by design, as the Fundraiser has no impact on peg\n     * maintenance and thus should not change the supply of Soil.\n     */\n```",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/beanstalk/field/FieldFacet.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {C} from \"contracts/C.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport {LibTransfer} from \"contracts/libraries/Token/LibTransfer.sol\";\nimport {LibDibbler} from \"contracts/libraries/LibDibbler.sol\";\nimport {LibPRBMath} from \"contracts/libraries/LibPRBMath.sol\";\nimport {LibSafeMath32} from \"contracts/libraries/LibSafeMath32.sol\";\nimport {LibSafeMath128} from \"contracts/libraries/LibSafeMath128.sol\";\nimport {ReentrancyGuard} from \"../ReentrancyGuard.sol\";\n\n/**\n * @title FieldFacet\n * @author Publius, Brean\n * @notice The Field is where Beans are Sown and Pods are Harvested.\n */\ncontract FieldFacet is ReentrancyGuard {\n    using SafeMath for uint256;\n    using LibPRBMath for uint256;\n    using LibSafeMath32 for uint32;\n    using LibSafeMath128 for uint128;\n\n    /**\n     * @notice Emitted from {LibDibbler.sowNoSoil} when an `account` creates a plot. \n     * A Plot is a set of Pods created in from a single {sow} or {fund} call. \n     * @param account The account that sowed Beans for Pods\n     * @param index The place in line of the Plot\n     * @param beans The amount of Beans burnt to create the Plot\n     * @param pods The amount of Pods assocated with the created Plot\n     */\n    event Sow(\n        address indexed account,\n        uint256 index,\n        uint256 beans,\n        uint256 pods\n    );\n\n    /**\n     * @notice Emitted when `account` claims the Beans associated with Harvestable Pods.\n     * @param account The account that owns the `plots`\n     * @param plots The indices of Plots that were harvested\n     * @param beans The amount of Beans transferred to `account`\n     */\n    event Harvest(address indexed account, uint256[] plots, uint256 beans);\n\n    /**\n     * @param account The account that created the Pod Listing\n     * @param index The index of the Plot listed\n     * @dev NOTE: must mirror {Listing.PodListingCancelled}\n     */\n    event PodListingCancelled(address indexed account, uint256 index);\n\n    //////////////////// SOW ////////////////////\n\n    /**\n     * @notice Sow Beans in exchange for Pods.\n     * @param beans The number of Beans to Sow\n     * @param minTemperature The minimum Temperature at which to Sow\n     * @param mode The balance to transfer Beans from; see {LibTransfer.From}\n     * @return pods The number of Pods received\n     * @dev \n     * \n     * `minTemperature` has precision of 1e6. Wraps {sowWithMin} with `minSoil = beans`.\n     * \n     * NOTE: previously minTemperature was measured to 1e2 (1% = 1)\n     * \n     * Rationale for {sow} accepting a `minTemperature` parameter:\n     * If someone sends a Sow transaction at the end of a Season, it could be \n     * executed early in the following Season, at which time the temperature may be\n     * significantly lower due to Morning Auction functionality.\n     */\n    function sow(\n        uint256 beans,\n        uint256 minTemperature,\n        LibTransfer.From mode\n    )\n        external\n        payable\n        returns (uint256 pods)\n    {\n        pods = sowWithMin(beans, minTemperature, beans, mode);\n    }\n\n    /**\n     * @notice Sow Beans in exchange for Pods. Use at least `minSoil`.\n     * @param beans The number of Beans to Sow\n     * @param minTemperature The minimum Temperature at which to Sow\n     * @param minSoil The minimum amount of Soil to use; reverts if there is \n     * less than this much Soil available upon execution\n     * @param mode The balance to transfer Beans from; see {LibTrasfer.From}\n     * @return pods The number of Pods received\n     */\n    function sowWithMin(\n        uint256 beans,\n        uint256 minTemperature,\n        uint256 minSoil,\n        LibTransfer.From mode\n    ) public payable returns (uint256 pods) {\n        // `soil` is the remaining Soil\n        (uint256 soil, uint256 _morningTemperature, bool abovePeg) = _totalSoilAndTemperature();\n\n        require(\n            soil >= minSoil && beans >= minSoil,\n            \"Field: Soil Slippage\"\n        );\n        require(\n            _morningTemperature >= minTemperature,\n            \"Field: Temperature Slippage\"\n        );\n\n        // If beans >= soil, Sow all of the remaining Soil\n        if (beans < soil) {\n            soil = beans; \n        }\n\n        // 1 Bean is Sown in 1 Soil, i.e. soil = beans\n        pods = _sow(soil, _morningTemperature, abovePeg, mode);\n    }\n\n    /**\n     * @dev Burn Beans, Sows at the provided `_morningTemperature`, increments the total\n     * number of `beanSown`.\n     * \n     * NOTE: {FundraiserFacet} also burns Beans but bypasses the soil mechanism\n     * by calling {LibDibbler.sowWithMin} which bypasses updates to `s.f.beanSown`\n     * and `s.f.soil`. This is by design, as the Fundraiser has no impact on peg\n     * maintenance and thus should not change the supply of Soil.\n     */\n    function _sow(uint256 beans, uint256 _morningTemperature, bool peg, LibTransfer.From mode)\n        internal\n        returns (uint256 pods)\n    {\n        beans = LibTransfer.burnToken(C.bean(), beans, msg.sender, mode);\n        pods = LibDibbler.sow(beans, _morningTemperature, msg.sender, peg);\n        s.f.beanSown = s.f.beanSown + SafeCast.toUint128(beans); // SafeMath not needed\n    }\n\n    //////////////////// HARVEST ////////////////////\n\n    /**\n     * @notice Harvest Pods from the Field.\n     * @param plots List of plot IDs to Harvest\n     * @param mode The balance to transfer Beans to; see {LibTrasfer.To}\n     * @dev Redeems Pods for Beans. When Pods become Harvestable, they are\n     * redeemable for 1 Bean each.\n     * \n     * The Beans used to pay Harvestable Pods are minted during {Sun.stepSun}.\n     * Beanstalk holds these Beans until `harvest()` is called.\n     *\n     * Pods are \"burned\" when the corresponding Plot is deleted from \n     * `s.a[account].field.plots`.\n     */\n    function harvest(uint256[] calldata plots, LibTransfer.To mode)\n        external\n        payable\n    {\n        uint256 beansHarvested = _harvest(plots);\n        LibTransfer.sendToken(C.bean(), beansHarvested, msg.sender, mode);\n    }\n\n    /**\n     * @dev Ensure that each Plot is at least partially harvestable, burn the Plot,\n     * update the total harvested, and emit a {Harvest} event.\n     */\n    function _harvest(uint256[] calldata plots)\n        internal\n        returns (uint256 beansHarvested)\n    {\n        for (uint256 i; i < plots.length; ++i) {\n            // The Plot is partially harvestable if its index is less than\n            // the current harvestable index.\n            require(plots[i] < s.f.harvestable, \"Field: Plot not Harvestable\");\n            uint256 harvested = _harvestPlot(msg.sender, plots[i]);\n            beansHarvested = beansHarvested.add(harvested);\n        }\n        s.f.harvested = s.f.harvested.add(beansHarvested);\n        emit Harvest(msg.sender, plots, beansHarvested);\n    }\n\n    /**\n     * @dev Check if a Plot is at least partially Harvestable; calculate how many\n     * Pods are Harvestable, create a new Plot if necessary.\n     */\n    function _harvestPlot(address account, uint256 index)\n        private\n        returns (uint256 harvestablePods)\n    {\n        // Check that `account` holds this Plot.\n        uint256 pods = s.a[account].field.plots[index];\n        require(pods > 0, \"Field: no plot\");\n\n        // Calculate how many Pods are harvestable. \n        // The upstream _harvest function checks that at least some Pods \n        // are harvestable.\n        harvestablePods = s.f.harvestable.sub(index);\n        delete s.a[account].field.plots[index];\n\n        // Cancel any active Pod Listings active for this Plot.\n        // Note: duplicate of {Listing._cancelPodListing} without the \n        // ownership check, which is done above.\n        if (s.podListings[index] > 0) {\n            delete s.podListings[index];\n            emit PodListingCancelled(msg.sender, index);\n        }\n\n        // If the entire Plot was harvested, exit.\n        if (harvestablePods >= pods) {\n            return pods;\n        }\n        \n        // Create a new Plot with remaining Pods.\n        s.a[account].field.plots[index.add(harvestablePods)] = pods.sub(\n            harvestablePods\n        );\n    }\n\n    //////////////////// GETTERS ////////////////////\n\n    /**\n     * @notice Returns the total number of Pods ever minted.\n     */\n    function podIndex() public view returns (uint256) {\n        return s.f.pods;\n    }\n\n    /**\n     * @notice Returns the index below which Pods are Harvestable.\n     */\n    function harvestableIndex() public view returns (uint256) {\n        return s.f.harvestable;\n    }\n\n    /**\n     * @notice Returns the number of outstanding Pods. Includes Pods that are\n     * currently Harvestable but have not yet been Harvested.\n     */\n    function totalPods() public view returns (uint256) {\n        return s.f.pods.sub(s.f.harvested);\n    }\n\n    /**\n     * @notice Returns the number of Pods that have ever been Harvested.\n     */\n    function totalHarvested() public view returns (uint256) {\n        return s.f.harvested;\n    }\n\n    /**\n     * @notice Returns the number of Pods that are currently Harvestable but\n     * have not yet been Harvested.\n     * @dev This is the number of Pods that Beanstalk is prepared to pay back,\n     * but that havenâ€™t yet been claimed via the `harvest()` function.\n     */\n    function totalHarvestable() public view returns (uint256) {\n        return s.f.harvestable.sub(s.f.harvested);\n    }\n\n    /**\n     * @notice Returns the number of Pods that are not yet Harvestable. Also known as the Pod Line.\n     */\n    function totalUnharvestable() public view returns (uint256) {\n        return s.f.pods.sub(s.f.harvestable);\n    }\n\n    /**\n     * @notice Returns the number of Pods remaining in a Plot.\n     * @dev Plots are only stored in the `s.a[account].field.plots` mapping.\n     */\n    function plot(address account, uint256 index)\n        public\n        view\n        returns (uint256)\n    {\n        return s.a[account].field.plots[index];\n    }\n\n    /**\n     * @dev Gets the current `soil`, `_morningTemperature` and `abovePeg`. Provided as a gas \n     * optimization to prevent recalculation of {LibDibbler.morningTemperature} for \n     * upstream functions.\n     * Note: the `soil` return value is symmetric with `totalSoil`.\n     */\n    function _totalSoilAndTemperature() private view returns (uint256 soil, uint256 _morningTemperature, bool abovePeg) {\n        _morningTemperature = LibDibbler.morningTemperature();\n        abovePeg = s.season.abovePeg;\n\n        // Below peg: Soil is fixed to the amount set during {stepWeather}.\n        // Morning Temperature is dynamic, starting small and logarithmically \n        // increasing to `s.w.t` across the first 25 blocks of the Season.\n        if (!abovePeg) {\n            soil = uint256(s.f.soil);\n        } \n        \n        // Above peg: the maximum amount of Pods that Beanstalk is willing to mint\n        // stays fixed; since {morningTemperature} is scaled down when `delta < 25`, we\n        // need to scale up the amount of Soil to hold Pods constant.\n        else {\n            soil = LibDibbler.scaleSoilUp(\n                uint256(s.f.soil), // max soil offered this Season, reached when `t >= 25`\n                uint256(s.w.t).mul(LibDibbler.TEMPERATURE_PRECISION), // max temperature\n                _morningTemperature // temperature adjusted by number of blocks since Sunrise\n            );\n        }\n    }\n\n    //////////////////// GETTERS: SOIL ////////////////////\n\n    /**\n     * @notice Returns the total amount of available Soil. 1 Bean can be Sown in\n     * 1 Soil for Pods.\n     * @dev When above peg, Soil is dynamic because the number of Pods that\n     * Beanstalk is willing to mint is fixed.\n     */\n    function totalSoil() external view returns (uint256) {\n        // Below peg: Soil is fixed to the amount set during {stepWeather}.\n        if (!s.season.abovePeg) {\n            return uint256(s.f.soil);\n        }\n\n        // Above peg: Soil is dynamic\n        return LibDibbler.scaleSoilUp(\n            uint256(s.f.soil), // min soil\n            uint256(s.w.t).mul(LibDibbler.TEMPERATURE_PRECISION), // max temperature\n            LibDibbler.morningTemperature() // temperature adjusted by number of blocks since Sunrise\n        );\n    }\n\n    //////////////////// GETTERS: TEMPERATURE ////////////////////\n\n    /**\n     * @notice DEPRECATED: Returns the current yield (aka \"Temperature\") offered \n     * by Beanstalk when burning Beans in exchange for Pods.\n     * @dev Left for backwards compatibility. Scales down the {morningTemperature}. \n     * There is a loss of precision (max 1%) during this operation.\n     */\n    function yield() external view returns (uint32) {\n        return SafeCast.toUint32(\n            LibDibbler.morningTemperature().div(LibDibbler.TEMPERATURE_PRECISION)\n        );\n    }\n\n    /**\n     * @notice Returns the current Temperature, the interest rate offered by Beanstalk.\n     * The Temperature scales up during the first 25 blocks after Sunrise.\n     */\n    function temperature() external view returns (uint256) {\n        return LibDibbler.morningTemperature();\n    }\n\n    /**\n     * @notice Returns the max Temperature that Beanstalk is willing to offer this Season.\n     * @dev For gas efficiency, Beanstalk stores `s.w.t` as a uint32 with precision of 1e2.\n     * Here we convert to uint256 and scale up by TEMPERATURE_PRECISION to match the \n     * precision needed for the Morning Auction functionality.\n     */\n    function maxTemperature() external view returns (uint256) {\n        return uint256(s.w.t).mul(LibDibbler.TEMPERATURE_PRECISION);\n    }\n\n    //////////////////// GETTERS: PODS ////////////////////\n    \n    /**\n     * @notice Returns the remaining Pods that could be issued this Season.\n     */\n    function remainingPods() external view returns (uint256) {\n        return uint256(LibDibbler.remainingPods());\n    }\n}"
    }
  ]
}