{
  "Title": "[N-17] Not using the named return variables anywhere in the function is confusing",
  "Content": "\nConsider changing the variable to be an unnamed one\n\n*There are 12 instances of this issue:*\n\n```solidity\nFile: contracts/contracts/Router.sol\n\n/// @audit amount\n71:       function getAmountOut(uint amountIn, address tokenIn, address tokenOut) external view returns (uint amount, bool stable) {\n\n/// @audit stable\n71:       function getAmountOut(uint amountIn, address tokenIn, address tokenOut) external view returns (uint amount, bool stable) {\n```\n\n<https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Router.sol#L71>\n\n```solidity\nFile: contracts/contracts/Gauge.sol\n\n/// @audit claimed0\n131:      function claimFees() external lock returns (uint claimed0, uint claimed1) {\n\n/// @audit claimed1\n131:      function claimFees() external lock returns (uint claimed0, uint claimed1) {\n```\n\n<https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Gauge.sol#L131>\n\n```solidity\nFile: contracts/contracts/Pair.sol\n\n/// @audit dec0\n125:      function metadata() external view returns (uint dec0, uint dec1, uint r0, uint r1, bool st, address t0, address t1) {\n\n/// @audit dec1\n125:      function metadata() external view returns (uint dec0, uint dec1, uint r0, uint r1, bool st, address t0, address t1) {\n\n/// @audit r0\n125:      function metadata() external view returns (uint dec0, uint dec1, uint r0, uint r1, bool st, address t0, address t1) {\n\n/// @audit r1\n125:      function metadata() external view returns (uint dec0, uint dec1, uint r0, uint r1, bool st, address t0, address t1) {\n\n/// @audit st\n125:      function metadata() external view returns (uint dec0, uint dec1, uint r0, uint r1, bool st, address t0, address t1) {\n\n/// @audit t0\n125:      function metadata() external view returns (uint dec0, uint dec1, uint r0, uint r1, bool st, address t0, address t1) {\n\n/// @audit t1\n125:      function metadata() external view returns (uint dec0, uint dec1, uint r0, uint r1, bool st, address t0, address t1) {\n\n/// @audit amountOut\n254:      function quote(address tokenIn, uint amountIn, uint granularity) external view returns (uint amountOut) {\n```\n\n<https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Pair.sol#L125>\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-05-velodrome-findings/issues/128#issuecomment-1174401727):**\n > All in all a really thorough report, which would benefit by mentioning a finding once, and then listing all other occurrences, especially when the code is pretty much the same.\n> \n> That said, one of the best reports.\n>\n> *(Note: See [original submission](https://github.com/code-423n4/2022-05-velodrome-findings/issues/128) for judge's full commentary.)*\n\n\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-05-velodrome",
  "Code": [
    {
      "filename": "contracts/contracts/Router.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport './libraries/Math.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IPair.sol';\nimport './interfaces/IPairFactory.sol';\nimport './interfaces/IWETH.sol';\n\ncontract Router {\n\n    struct route {\n        address from;\n        address to;\n        bool stable;\n    }\n\n    address public immutable factory;\n    IWETH public immutable weth;\n    uint internal constant MINIMUM_LIQUIDITY = 10**3;\n    bytes32 immutable pairCodeHash;\n\n    modifier ensure(uint deadline) {\n        require(deadline >= block.timestamp, 'Router: EXPIRED');\n        _;\n    }\n\n    constructor(address _factory, address _weth) {\n        factory = _factory;\n        pairCodeHash = IPairFactory(_factory).pairCodeHash();\n        weth = IWETH(_weth);\n    }\n\n    receive() external payable {\n        assert(msg.sender == address(weth)); // only accept ETH via fallback from the WETH contract\n    }\n\n    function sortTokens(address tokenA, address tokenB) public pure returns (address token0, address token1) {\n        require(tokenA != tokenB, 'Router: IDENTICAL_ADDRESSES');\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'Router: ZERO_ADDRESS');\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(address tokenA, address tokenB, bool stable) public view returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(uint160(uint256(keccak256(abi.encodePacked(\n            hex'ff',\n            factory,\n            keccak256(abi.encodePacked(token0, token1, stable)),\n            pairCodeHash // init code hash\n        )))));\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quoteLiquidity(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n        require(amountA > 0, 'Router: INSUFFICIENT_AMOUNT');\n        require(reserveA > 0 && reserveB > 0, 'Router: INSUFFICIENT_LIQUIDITY');\n        amountB = amountA * reserveB / reserveA;\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(address tokenA, address tokenB, bool stable) public view returns (uint reserveA, uint reserveB) {\n        (address token0,) = sortTokens(tokenA, tokenB);\n        (uint reserve0, uint reserve1,) = IPair(pairFor(tokenA, tokenB, stable)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountOut(uint amountIn, address tokenIn, address tokenOut) external view returns (uint amount, bool stable) {\n        address pair = pairFor(tokenIn, tokenOut, true);\n        uint amountStable;\n        uint amountVolatile;\n        if (IPairFactory(factory).isPair(pair)) {\n            amountStable = IPair(pair).getAmountOut(amountIn, tokenIn);\n        }\n        pair = pairFor(tokenIn, tokenOut, false);\n        if (IPairFactory(factory).isPair(pair)) {\n            amountVolatile = IPair(pair).getAmountOut(amountIn, tokenIn);\n        }\n        return amountStable > amountVolatile ? (amountStable, true) : (amountVolatile, false);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(uint amountIn, route[] memory routes) public view returns (uint[] memory amounts) {\n        require(routes.length >= 1, 'Router: INVALID_PATH');\n        amounts = new uint[](routes.length+1);\n        amounts[0] = amountIn;\n        for (uint i = 0; i < routes.length; i++) {\n            address pair = pairFor(routes[i].from, routes[i].to, routes[i].stable);\n            if (IPairFactory(factory).isPair(pair)) {\n                amounts[i+1] = IPair(pair).getAmountOut(amounts[i], routes[i].from);\n            }\n        }\n    }\n\n    function isPair(address pair) external view returns (bool) {\n        return IPairFactory(factory).isPair(pair);\n    }\n\n    function quoteAddLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint amountADesired,\n        uint amountBDesired\n    ) external view returns (uint amountA, uint amountB, uint liquidity) {\n        // create the pair if it doesn't exist yet\n        address _pair = IPairFactory(factory).getPair(tokenA, tokenB, stable);\n        (uint reserveA, uint reserveB) = (0,0);\n        uint _totalSupply = 0;\n        if (_pair != address(0)) {\n            _totalSupply = IERC20(_pair).totalSupply();\n            (reserveA, reserveB) = getReserves(tokenA, tokenB, stable);\n        }\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n            liquidity = Math.sqrt(amountA * amountB) - MINIMUM_LIQUIDITY;\n        } else {\n\n            uint amountBOptimal = quoteLiquidity(amountADesired, reserveA, reserveB);\n            if (amountBOptimal <= amountBDesired) {\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n                liquidity = Math.min(amountA * _totalSupply / reserveA, amountB * _totalSupply / reserveB);\n            } else {\n                uint amountAOptimal = quoteLiquidity(amountBDesired, reserveB, reserveA);\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n                liquidity = Math.min(amountA * _totalSupply / reserveA, amountB * _totalSupply / reserveB);\n            }\n        }\n    }\n\n    function quoteRemoveLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint liquidity\n    ) external view returns (uint amountA, uint amountB) {\n        // create the pair if it doesn't exist yet\n        address _pair = IPairFactory(factory).getPair(tokenA, tokenB, stable);\n\n        if (_pair == address(0)) {\n            return (0,0);\n        }\n\n        (uint reserveA, uint reserveB) = getReserves(tokenA, tokenB, stable);\n        uint _totalSupply = IERC20(_pair).totalSupply();\n\n        amountA = liquidity * reserveA / _totalSupply; // using balances ensures pro-rata distribution\n        amountB = liquidity * reserveB / _totalSupply; // using balances ensures pro-rata distribution\n\n    }\n\n    function _addLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin\n    ) internal returns (uint amountA, uint amountB) {\n        require(amountADesired >= amountAMin);\n        require(amountBDesired >= amountBMin);\n        // create the pair if it doesn't exist yet\n        address _pair = IPairFactory(factory).getPair(tokenA, tokenB, stable);\n        if (_pair == address(0)) {\n            _pair = IPairFactory(factory).createPair(tokenA, tokenB, stable);\n        }\n        (uint reserveA, uint reserveB) = getReserves(tokenA, tokenB, stable);\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n        } else {\n            uint amountBOptimal = quoteLiquidity(amountADesired, reserveA, reserveB);\n            if (amountBOptimal <= amountBDesired) {\n                require(amountBOptimal >= amountBMin, 'Router: INSUFFICIENT_B_AMOUNT');\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n            } else {\n                uint amountAOptimal = quoteLiquidity(amountBDesired, reserveB, reserveA);\n                assert(amountAOptimal <= amountADesired);\n                require(amountAOptimal >= amountAMin, 'Router: INSUFFICIENT_A_AMOUNT');\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n            }\n        }\n    }\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, stable, amountADesired, amountBDesired, amountAMin, amountBMin);\n        address pair = pairFor(tokenA, tokenB, stable);\n        _safeTransferFrom(tokenA, msg.sender, pair, amountA);\n        _safeTransferFrom(tokenB, msg.sender, pair, amountB);\n        liquidity = IPair(pair).mint(to);\n    }\n\n    function addLiquidityETH(\n        address token,\n        bool stable,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {\n        (amountToken, amountETH) = _addLiquidity(\n            token,\n            address(weth),\n            stable,\n            amountTokenDesired,\n            msg.value,\n            amountTokenMin,\n            amountETHMin\n        );\n        address pair = pairFor(token, address(weth), stable);\n        _safeTransferFrom(token, msg.sender, pair, amountToken);\n        weth.deposit{value: amountETH}();\n        assert(weth.transfer(pair, amountETH));\n        liquidity = IPair(pair).mint(to);\n        // refund dust eth, if any\n        if (msg.value > amountETH) _safeTransferETH(msg.sender, msg.value - amountETH);\n    }\n\n    // **** REMOVE LIQUIDITY ****\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) public ensure(deadline) returns (uint amountA, uint amountB) {\n        address pair = pairFor(tokenA, tokenB, stable);\n        require(IPair(pair).transferFrom(msg.sender, pair, liquidity)); // send liquidity to pair\n        (uint amount0, uint amount1) = IPair(pair).burn(to);\n        (address token0,) = sortTokens(tokenA, tokenB);\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\n        require(amountA >= amountAMin, 'Router: INSUFFICIENT_A_AMOUNT');\n        require(amountB >= amountBMin, 'Router: INSUFFICIENT_B_AMOUNT');\n    }\n\n    function removeLiquidityETH(\n        address token,\n        bool stable,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) public ensure(deadline) returns (uint amountToken, uint amountETH) {\n        (amountToken, amountETH) = removeLiquidity(\n            token,\n            address(weth),\n            stable,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            address(this),\n            deadline\n        );\n        _safeTransfer(token, to, amountToken);\n        weth.withdraw(amountETH);\n        _safeTransferETH(to, amountETH);\n    }\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB) {\n        address pair = pairFor(tokenA, tokenB, stable);\n        {\n            uint value = approveMax ? type(uint).max : liquidity;\n            IPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        }\n\n        (amountA, amountB) = removeLiquidity(tokenA, tokenB, stable, liquidity, amountAMin, amountBMin, to, deadline);\n    }\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        bool stable,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH) {\n        address pair = pairFor(token, address(weth), stable);\n        uint value = approveMax ? type(uint).max : liquidity;\n        IPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountToken, amountETH) = removeLiquidityETH(token, stable, liquidity, amountTokenMin, amountETHMin, to, deadline);\n    }\n\n    // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, route[] memory routes, address _to) internal virtual {\n        for (uint i = 0; i < routes.length; i++) {\n            (address token0,) = sortTokens(routes[i].from, routes[i].to);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = routes[i].from == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < routes.length - 1 ? pairFor(routes[i+1].from, routes[i+1].to, routes[i+1].stable) : _to;\n            IPair(pairFor(routes[i].from, routes[i].to, routes[i].stable)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n\n    function swapExactTokensForTokensSimple(\n        uint amountIn,\n        uint amountOutMin,\n        address tokenFrom,\n        address tokenTo,\n        bool stable,\n        address to,\n        uint deadline\n    ) external ensure(deadline) returns (uint[] memory amounts) {\n        route[] memory routes = new route[](1);\n        routes[0].from = tokenFrom;\n        routes[0].to = tokenTo;\n        routes[0].stable = stable;\n        amounts = getAmountsOut(amountIn, routes);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        _safeTransferFrom(\n            routes[0].from, msg.sender, pairFor(routes[0].from, routes[0].to, routes[0].stable), amounts[0]\n        );\n        _swap(amounts, routes, to);\n    }\n\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        route[] calldata routes,\n        address to,\n        uint deadline\n    ) external ensure(deadline) returns (uint[] memory amounts) {\n        amounts = getAmountsOut(amountIn, routes);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        _safeTransferFrom(\n            routes[0].from, msg.sender, pairFor(routes[0].from, routes[0].to, routes[0].stable), amounts[0]\n        );\n        _swap(amounts, routes, to);\n    }\n\n    function swapExactETHForTokens(uint amountOutMin, route[] calldata routes, address to, uint deadline)\n    external\n    payable\n    ensure(deadline)\n    returns (uint[] memory amounts)\n    {\n        require(routes[0].from == address(weth), 'Router: INVALID_PATH');\n        amounts = getAmountsOut(msg.value, routes);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        weth.deposit{value: amounts[0]}();\n        assert(weth.transfer(pairFor(routes[0].from, routes[0].to, routes[0].stable), amounts[0]));\n        _swap(amounts, routes, to);\n    }\n\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, route[] calldata routes, address to, uint deadline)\n    external\n    ensure(deadline)\n    returns (uint[] memory amounts)\n    {\n        require(routes[routes.length - 1].to == address(weth), 'Router: INVALID_PATH');\n        amounts = getAmountsOut(amountIn, routes);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        _safeTransferFrom(\n            routes[0].from, msg.sender, pairFor(routes[0].from, routes[0].to, routes[0].stable), amounts[0]\n        );\n        _swap(amounts, routes, address(this));\n        weth.withdraw(amounts[amounts.length - 1]);\n        _safeTransferETH(to, amounts[amounts.length - 1]);\n    }\n\n    function UNSAFE_swapExactTokensForTokens(\n        uint[] memory amounts,\n        route[] calldata routes,\n        address to,\n        uint deadline\n    ) external ensure(deadline) returns (uint[] memory) {\n        _safeTransferFrom(routes[0].from, msg.sender, pairFor(routes[0].from, routes[0].to, routes[0].stable), amounts[0]);\n        _swap(amounts, routes, to);\n        return amounts;\n    }\n\n    function _safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n\n    function _safeTransfer(address token, address to, uint256 value) internal {\n        require(token.code.length > 0);\n        (bool success, bytes memory data) =\n        token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n\n    function _safeTransferFrom(address token, address from, address to, uint256 value) internal {\n        require(token.code.length > 0);\n        (bool success, bytes memory data) =\n        token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n}"
    },
    {
      "filename": "contracts/contracts/Gauge.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport './libraries/Math.sol';\nimport './interfaces/IBribe.sol';\nimport './interfaces/IGaugeFactory.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IPair.sol';\nimport './interfaces/IVoter.sol';\nimport './interfaces/IVotingEscrow.sol';\n\n// Gauges are used to incentivize pools, they emit reward tokens every 7 days for staked LP tokens\ncontract Gauge {\n\n    address public immutable stake; // the LP token that needs to be staked for rewards\n    address public immutable _ve; // the ve token used for gauges\n    address public immutable bribe;\n    address public immutable voter;\n    address immutable factory;\n    bool public isForPair;\n\n    uint public derivedSupply;\n    mapping(address => uint) public derivedBalances;\n\n    uint internal constant DURATION = 5 days; // rewards are released over the voting period\n    uint internal constant BRIBE_LAG = 1 days;\n    uint internal constant MAX_REWARD_TOKENS = 16;\n\n    enum VotingStage\n    {\n        BribesPhase,\n        VotesPhase,\n        RewardsPhase\n    }\n\n    uint internal constant PRECISION = 10 ** 18;\n\n    // default snx staking contract implementation\n    mapping(address => uint) public rewardRate;\n    mapping(address => uint) public periodFinish;\n    mapping(address => uint) public lastUpdateTime;\n    mapping(address => uint) public rewardPerTokenStored;\n\n    mapping(address => mapping(address => uint)) public lastEarn;\n    mapping(address => mapping(address => uint)) public userRewardPerTokenStored;\n\n    mapping(address => uint) public tokenIds;\n\n    uint public totalSupply;\n    mapping(address => uint) public balanceOf;\n\n    address[] public rewards;\n    mapping(address => bool) public isReward;\n\n    /// @notice A checkpoint for marking balance\n    struct Checkpoint {\n        uint timestamp;\n        uint balanceOf;\n        bool voted;\n    }\n\n    /// @notice A checkpoint for marking reward rate\n    struct RewardPerTokenCheckpoint {\n        uint timestamp;\n        uint rewardPerToken;\n    }\n\n    /// @notice A checkpoint for marking supply\n    struct SupplyCheckpoint {\n        uint timestamp;\n        uint supply;\n    }\n\n    /// @notice A record of balance checkpoints for each account, by index\n    mapping (address => mapping (uint => Checkpoint)) public checkpoints;\n    /// @notice The number of checkpoints for each account\n    mapping (address => uint) public numCheckpoints;\n    /// @notice A record of balance checkpoints for each token, by index\n    mapping (uint => SupplyCheckpoint) public supplyCheckpoints;\n    /// @notice The number of checkpoints\n    uint public supplyNumCheckpoints;\n    /// @notice A record of balance checkpoints for each token, by index\n    mapping (address => mapping (uint => RewardPerTokenCheckpoint)) public rewardPerTokenCheckpoints;\n    /// @notice The number of checkpoints for each token\n    mapping (address => uint) public rewardPerTokenNumCheckpoints;\n\n    uint public fees0;\n    uint public fees1;\n\n    event Deposit(address indexed from, uint tokenId, uint amount);\n    event Withdraw(address indexed from, uint tokenId, uint amount);\n    event NotifyReward(address indexed from, address indexed reward, uint amount);\n    event ClaimFees(address indexed from, uint claimed0, uint claimed1);\n    event ClaimRewards(address indexed from, address indexed reward, uint amount);\n\n    constructor(address _stake, address _bribe, address  __ve, address _voter, bool _isForPair) {\n        stake = _stake;\n        bribe = _bribe;\n        _ve = __ve;\n        voter = _voter;\n\n        factory = msg.sender;\n\n        IBribe(bribe).setGauge(address(this));\n        address _token = IVotingEscrow(_ve).token();\n        IBribe(bribe).addRewardToken(_token);\n        isReward[_token] = true;\n        rewards.push(_token);\n\n        isForPair = _isForPair;\n        if (isForPair) {\n            (address _token0, address _token1) = IPair(stake).tokens();\n            IBribe(bribe).addRewardToken(_token0);\n            isReward[_token0] = true;\n            rewards.push(_token0);\n            IBribe(bribe).addRewardToken(_token1);\n            isReward[_token1] = true;\n            rewards.push(_token1);\n        }\n    }\n\n    // simple re-entrancy check\n    uint internal _unlocked = 1;\n    modifier lock() {\n        require(_unlocked == 1);\n        _unlocked = 2;\n        _;\n        _unlocked = 1;\n    }\n\n    function claimFees() external lock returns (uint claimed0, uint claimed1) {\n        return _claimFees();\n    }\n\n    function _claimFees() internal returns (uint claimed0, uint claimed1) {\n        if (!isForPair) {\n            return (0, 0);\n        }\n        (claimed0, claimed1) = IPair(stake).claimFees();\n        if (claimed0 > 0 || claimed1 > 0) {\n            uint _fees0 = fees0 + claimed0;\n            uint _fees1 = fees1 + claimed1;\n            (address _token0, address _token1) = IPair(stake).tokens();\n            if (_fees0 / DURATION > 0) {\n                fees0 = 0;\n                _safeApprove(_token0, bribe, _fees0);\n                IBribe(bribe).notifyRewardAmount(_token0, _fees0);\n            } else {\n                fees0 = _fees0;\n            }\n            if (_fees1 / DURATION > 0) {\n                fees1 = 0;\n                _safeApprove(_token1, bribe, _fees1);\n                IBribe(bribe).notifyRewardAmount(_token1, _fees1);\n            } else {\n                fees1 = _fees1;\n            }\n\n            emit ClaimFees(msg.sender, claimed0, claimed1);\n        }\n    }\n\n    function getVotingStage(uint timestamp) public pure returns (VotingStage) {\n        uint modTime = timestamp % (7 days);\n        if (modTime < BRIBE_LAG) {\n            return VotingStage.BribesPhase;\n        } else if (modTime > (BRIBE_LAG + DURATION)) {\n            return VotingStage.RewardsPhase;\n        }\n        return VotingStage.VotesPhase;\n    }\n\n    function deliverBribes() external lock {\n        require(msg.sender == voter);\n        IBribe sb = IBribe(bribe);\n        uint bribeStart = block.timestamp - (block.timestamp % (7 days)) + BRIBE_LAG;\n        uint numRewards = sb.rewardsListLength();\n\n        for (uint i = 0; i < numRewards; i++) {\n            address token = sb.rewards(i);\n            uint epochRewards = sb.deliverReward(token, bribeStart);\n            if (epochRewards > 0) {\n                _notifyBribeAmount(token, epochRewards, bribeStart);\n            }\n        }\n    }\n\n    function setVoteStatus(address account, bool voted) external {\n        require(msg.sender == voter);\n        uint nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            checkpoints[account][0] = Checkpoint(block.timestamp, 0, voted);\n            numCheckpoints[account] = 1;\n        } else {\n            checkpoints[account][nCheckpoints - 1].voted = voted;\n        }\n    }\n\n    /**\n    * @notice Determine the prior balance for an account as of a block number\n    * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n    * @param account The address of the account to check\n    * @param timestamp The timestamp to get the balance at\n    * @return The balance the account had as of the given block\n    */\n    function getPriorBalanceIndex(address account, uint timestamp) public view returns (uint) {\n        uint nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].timestamp <= timestamp) {\n            return (nCheckpoints - 1);\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].timestamp > timestamp) {\n            return 0;\n        }\n\n        uint lower = 0;\n        uint upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.timestamp == timestamp) {\n                return center;\n            } else if (cp.timestamp < timestamp) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return lower;\n    }\n\n    function getPriorSupplyIndex(uint timestamp) public view returns (uint) {\n        uint nCheckpoints = supplyNumCheckpoints;\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (supplyCheckpoints[nCheckpoints - 1].timestamp <= timestamp) {\n            return (nCheckpoints - 1);\n        }\n\n        // Next check implicit zero balance\n        if (supplyCheckpoints[0].timestamp > timestamp) {\n            return 0;\n        }\n\n        uint lower = 0;\n        uint upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            SupplyCheckpoint memory cp = supplyCheckpoints[center];\n            if (cp.timestamp == timestamp) {\n                return center;\n            } else if (cp.timestamp < timestamp) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return lower;\n    }\n\n    function getPriorRewardPerToken(address token, uint timestamp) public view returns (uint, uint) {\n        uint nCheckpoints = rewardPerTokenNumCheckpoints[token];\n        if (nCheckpoints == 0) {\n            return (0,0);\n        }\n\n        // First check most recent balance\n        if (rewardPerTokenCheckpoints[token][nCheckpoints - 1].timestamp <= timestamp) {\n            return (rewardPerTokenCheckpoints[token][nCheckpoints - 1].rewardPerToken, rewardPerTokenCheckpoints[token][nCheckpoints - 1].timestamp);\n        }\n\n        // Next check implicit zero balance\n        if (rewardPerTokenCheckpoints[token][0].timestamp > timestamp) {\n            return (0,0);\n        }\n\n        uint lower = 0;\n        uint upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            RewardPerTokenCheckpoint memory cp = rewardPerTokenCheckpoints[token][center];\n            if (cp.timestamp == timestamp) {\n                return (cp.rewardPerToken, cp.timestamp);\n            } else if (cp.timestamp < timestamp) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return (rewardPerTokenCheckpoints[token][lower].rewardPerToken, rewardPerTokenCheckpoints[token][lower].timestamp);\n    }\n\n    function _writeCheckpoint(address account, uint balance) internal {\n        uint _timestamp = block.timestamp;\n        uint _nCheckPoints = numCheckpoints[account];\n\n        if (_nCheckPoints > 0 && checkpoints[account][_nCheckPoints - 1].timestamp == _timestamp) {\n            checkpoints[account][_nCheckPoints - 1].balanceOf = balance;\n        } else {\n            bool prevVoteStatus = (_nCheckPoints > 0) ? checkpoints[account][_nCheckPoints].voted : false;\n            checkpoints[account][_nCheckPoints] = Checkpoint(_timestamp, balance, prevVoteStatus);\n            numCheckpoints[account] = _nCheckPoints + 1;\n        }\n    }\n\n    function _writeRewardPerTokenCheckpoint(address token, uint reward, uint timestamp) internal {\n        uint _nCheckPoints = rewardPerTokenNumCheckpoints[token];\n\n        if (_nCheckPoints > 0 && rewardPerTokenCheckpoints[token][_nCheckPoints - 1].timestamp == timestamp) {\n            rewardPerTokenCheckpoints[token][_nCheckPoints - 1].rewardPerToken = reward;\n        } else {\n            rewardPerTokenCheckpoints[token][_nCheckPoints] = RewardPerTokenCheckpoint(timestamp, reward);\n            rewardPerTokenNumCheckpoints[token] = _nCheckPoints + 1;\n        }\n    }\n\n    function _writeSupplyCheckpoint() internal {\n        uint _nCheckPoints = supplyNumCheckpoints;\n        uint _timestamp = block.timestamp;\n\n        if (_nCheckPoints > 0 && supplyCheckpoints[_nCheckPoints - 1].timestamp == _timestamp) {\n            supplyCheckpoints[_nCheckPoints - 1].supply = derivedSupply;\n        } else {\n            supplyCheckpoints[_nCheckPoints] = SupplyCheckpoint(_timestamp, derivedSupply);\n            supplyNumCheckpoints = _nCheckPoints + 1;\n        }\n    }\n\n    function rewardsListLength() external view returns (uint) {\n        return rewards.length;\n    }\n\n    // returns the last time the reward was modified or periodFinish if the reward has ended\n    function lastTimeRewardApplicable(address token) public view returns (uint) {\n        return Math.min(block.timestamp, periodFinish[token]);\n    }\n\n    function getReward(address account, address[] memory tokens) external lock {\n        require(msg.sender == account || msg.sender == voter);\n        _unlocked = 1;\n        IVoter(voter).distribute(address(this));\n        _unlocked = 2;\n\n        for (uint i = 0; i < tokens.length; i++) {\n            (rewardPerTokenStored[tokens[i]], lastUpdateTime[tokens[i]]) = _updateRewardPerToken(tokens[i]);\n\n            uint _reward = earned(tokens[i], account);\n            lastEarn[tokens[i]][account] = block.timestamp;\n            userRewardPerTokenStored[tokens[i]][account] = rewardPerTokenStored[tokens[i]];\n            if (_reward > 0) _safeTransfer(tokens[i], account, _reward);\n\n            emit ClaimRewards(msg.sender, tokens[i], _reward);\n        }\n\n        uint _derivedBalance = derivedBalances[account];\n        derivedSupply -= _derivedBalance;\n        _derivedBalance = derivedBalance(account);\n        derivedBalances[account] = _derivedBalance;\n        derivedSupply += _derivedBalance;\n\n        _writeCheckpoint(account, derivedBalances[account]);\n        _writeSupplyCheckpoint();\n    }\n\n\n    function rewardPerToken(address token) public view returns (uint) {\n        if (derivedSupply == 0) {\n            return rewardPerTokenStored[token];\n        }\n        return rewardPerTokenStored[token] + ((lastTimeRewardApplicable(token) - Math.min(lastUpdateTime[token], periodFinish[token])) * rewardRate[token] * PRECISION / derivedSupply);\n    }\n\n    function derivedBalance(address account) public view returns (uint) {\n        return balanceOf[account];\n    }\n\n    function batchRewardPerToken(address token, uint maxRuns) external {\n        (rewardPerTokenStored[token], lastUpdateTime[token])  = _batchRewardPerToken(token, maxRuns);\n    }\n\n    function _batchRewardPerToken(address token, uint maxRuns) internal returns (uint, uint) {\n        uint _startTimestamp = lastUpdateTime[token];\n        uint reward = rewardPerTokenStored[token];\n\n        if (supplyNumCheckpoints == 0) {\n            return (reward, _startTimestamp);\n        }\n\n        if (rewardRate[token] == 0) {\n            return (reward, block.timestamp);\n        }\n\n        uint _startIndex = getPriorSupplyIndex(_startTimestamp);\n        uint _endIndex = Math.min(supplyNumCheckpoints-1, maxRuns);\n\n        for (uint i = _startIndex; i < _endIndex; i++) {\n            SupplyCheckpoint memory sp0 = supplyCheckpoints[i];\n            if (sp0.supply > 0) {\n                SupplyCheckpoint memory sp1 = supplyCheckpoints[i+1];\n                (uint _reward, uint _endTime) = _calcRewardPerToken(token, sp1.timestamp, sp0.timestamp, sp0.supply, _startTimestamp);\n                reward += _reward;\n                _writeRewardPerTokenCheckpoint(token, reward, _endTime);\n                _startTimestamp = _endTime;\n            }\n        }\n\n        return (reward, _startTimestamp);\n    }\n\n    function _calcRewardPerToken(address token, uint timestamp1, uint timestamp0, uint supply, uint startTimestamp) internal view returns (uint, uint) {\n        uint endTime = Math.max(timestamp1, startTimestamp);"
    }
  ]
}