{
  "Title": "Malicious bundler can steal funds from SponsorPaymaster",
  "Content": "##### Description\n\n* https://github.com/KintoXYZ/kinto-core/blob/f7dd98f66b9dfba1f73758703b808051196e740b/src/paymasters/SponsorPaymaster.sol#L156\n\nA hacker can drain the SponsorPaymaster in just one transaction. This can be achieved by executing a userOp with an extremely high gas parameters.\n\nAs an example, we provided a test where a hacker sets `preVerificationGas` value to 99 ETH. This value is deducted from the SponsorPaymaster and sent to the hacker who runs `handleOps()`.\n\n##### Recommendation\n\nAlmost all gas parameters in userOp allow a hacker to set an arbitrarily high reward for themselves when calling `entryPoint.handleOps()`.\n\nWe recommend implementing one of the following solutions:\n\n**Method 1**: Restrict all gas parameters in userOp so that running `entryPoint.handleOps()` becomes unprofitable. Doing this reliably is challenging.\n\n**Method 2**: A better solution is for Kinto to be the sole userOp bundler. Add `require(msg.sender == KINTO_BUNDLER)` and `require(beneficiary == KINTO_WALLET)` to the functions `handleOps()` and `handleAggregatedOps()`.\n\n**Method 3**: Alter the architecture to charge compensation for executing userOp not from sponsors, but directly from the users. This implies deducting other types of cryptocurrencies that users hold in their wallets, such as USDT, for instance.\n\nIt's important to note that in the first and second methods, there is a risk of DOS for some users. If users cannot arbitrarily increase gas rewards, they cannot influence the priority of their transactions. Depending on how the bundler algorithm is implemented, this could result in some users' transactions constantly being stuck in the mempool and not getting executed.\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "src/paymasters/SponsorPaymaster.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\n/* solhint-disable reason-string */\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport '../interfaces/ISponsorPaymaster.sol';\n\nimport '@aa/core/BasePaymaster.sol';\nimport 'forge-std/console2.sol';\n\n/**\n * An ETH-based paymaster that accepts ETH deposits\n * The deposit is only a safeguard: the user pays with his ETH deposited in the entry point if any.\n * The deposit is locked for the current block: the user must issue unlockTokenDeposit() to be allowed to withdraw\n *  (but can't use the deposit for this or further operations)\n *\n * paymasterAndData holds the paymaster address followed by the token address to use.\n */\ncontract SponsorPaymaster is Initializable, BasePaymaster, UUPSUpgradeable, ReentrancyGuard, ISponsorPaymaster {\n\n    using UserOperationLib for UserOperation;\n    using SafeERC20 for IERC20;\n\n    //calculated cost of the postOp\n    uint256 constant public COST_OF_POST = 35000;\n\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public contractSpent; // keeps track of total gas consumption by contract\n    mapping(address => uint256) public unlockBlock;\n\n    constructor(IEntryPoint __entryPoint) BasePaymaster(__entryPoint) {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev The _entryPoint member is immutable, to reduce gas consumption.  To upgrade EntryPoint,\n     * a new implementation of SimpleAccount must be deployed with the new EntryPoint address, then upgrading\n     * the implementation by calling `upgradeTo()`\n     */\n    function initialize(address _owner) external virtual initializer {\n        __UUPSUpgradeable_init();\n        _transferOwnership(_owner);\n        // unlocks owner\n        unlockTokenDeposit();\n    }\n\n    /**\n     * @dev Authorize the upgrade. Only by an owner.\n     * @param newImplementation address of the new implementation\n     */\n    // This function is called by the proxy contract when the implementation is upgraded\n    function _authorizeUpgrade(address newImplementation) internal view override {\n        require(msg.sender == owner(), 'SponsorPaymaster: not owner');\n        (newImplementation);\n    }\n\n    /**\n     * ETH value that a specific account can use to pay for gas.\n     * Note depositing the tokens is equivalent to transferring them to the \"account\" - only the account can later\n     *  use them - either as gas, or using withdrawTo()\n     *\n     * @param account the account to deposit for.\n     * msg.value the amount of token to deposit.\n     */\n    function addDepositFor(address account) payable external override {\n        require(msg.value > 0, 'requires a deposit');\n        //(sender must have approval for the paymaster)\n        balances[account] += msg.value;\n        if (msg.sender == account) {\n            lockTokenDeposit();\n        }\n        this.deposit{value: msg.value}();\n    }\n\n    /**\n     * Unlocks deposit, so that it can be withdrawn.\n     * can't be called in the same block as withdrawTo()\n     */\n    function unlockTokenDeposit() public override {\n        unlockBlock[msg.sender] = block.number;\n    }\n\n    /**\n     * Lock the ETH deposited for this account so they can be used to pay for gas.\n     * after calling unlockTokenDeposit(), the account can't use this paymaster until the deposit is locked.\n     */\n    function lockTokenDeposit() public override {\n        unlockBlock[msg.sender] = 0;\n    }\n\n    /**\n     * Withdraw ETH\n     * can only be called after unlock() is called in a previous block.\n     * @param target address to send to\n     * @param amount amount to withdraw\n     */\n    function withdrawTokensTo(address target, uint256 amount) external override nonReentrant() {\n        require(\n            unlockBlock[msg.sender] != 0 && block.number > unlockBlock[msg.sender],\n            'DepositPaymaster: must unlockTokenDeposit'\n        );\n        withdrawTo(payable(target), amount);\n        balances[msg.sender] -= amount;\n    }\n\n    /*******************************\n      Viewers *********************\n    *******************************/\n\n    /**\n     * @return amount - the amount of given token deposited to the Paymaster.\n     * @return _unlockBlock - the block height at which the deposit can be withdrawn.\n     */\n    function depositInfo(address account) public view returns (uint256 amount, uint256 _unlockBlock) {\n        amount = balances[account];\n        _unlockBlock = unlockBlock[account];\n    }\n\n    /**\n     * Validate the request:\n     * The sender should have enough deposit to pay the max possible cost.\n     * Note that the sender's balance is not checked. If it fails to pay from its balance,\n     * this deposit will be used to compensate the paymaster for the transaction.\n     */\n    function _validatePaymasterUserOp(\n        UserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 maxCost\n    ) internal view override returns (bytes memory context, uint256 validationData) {\n        (userOpHash);\n        // verificationGasLimit is dual-purposed, as gas limit for postOp. make sure it is high enough\n        require(userOp.verificationGasLimit > COST_OF_POST, 'DepositPaymaster: gas too low for postOp');\n\n        bytes calldata paymasterAndData = userOp.paymasterAndData;\n        require(paymasterAndData.length == 20, 'DepositPaymaster: paymasterAndData must be empty');\n        // Get the contract deployed address from the first 20 bytes of the paymasterAndData\n        address targetAccount =  address(bytes20(userOp.callData[16:]));\n        uint256 gasPriceUserOp = userOp.gasPrice();\n        require(unlockBlock[targetAccount] == 0, 'DepositPaymaster: deposit not locked');\n        require(balances[targetAccount] >= maxCost, 'DepositPaymaster: deposit too low');\n        return (abi.encode(targetAccount, gasPriceUserOp), 0);\n    }\n\n    /**\n     * perform the post-operation to charge the sender for the gas.\n     * in normal mode, use transferFrom to withdraw enough tokens from the sender's balance.\n     * in case the transferFrom fails, the _postOp reverts and the entryPoint will call it again,\n     * this time in *postOpReverted* mode.\n     * In this mode, we use the deposit to pay (which we validated to be large enough)\n     */\n    function _postOp(PostOpMode /* mode */, bytes calldata context, uint256 actualGasCost) internal override {\n        (address account, uint256 gasPricePostOp) = abi.decode(context, (address, uint256));\n        //use same conversion rate as used for validation.\n        uint256 ethCost = (actualGasCost + COST_OF_POST * gasPricePostOp);\n        balances[account] -= ethCost;\n        contractSpent[account] += ethCost;\n        balances[owner()] += ethCost;\n    }\n    \n}"
    }
  ]
}