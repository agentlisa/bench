{
  "Title": "Becasue of devision before multiplication in `LibFertilizer:remainingRecapitalization()` less fertilizers is mintable than is needed to fully recapitalize the lost LP token value ",
  "Content": "# Becasue of devision before multiplication in `LibFertilizer:remainingRecapitalization()` less fertilizers is mintable than is needed to fully recapitalize the lost LP token value \n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-04-beanstalk-2/blob/27ff8c87c9164c1fbff054be5f22e56f86cdf127/protocol/contracts/libraries/LibFertilizer.sol#L182-L195\">https://github.com/Cyfrin/2024-04-beanstalk-2/blob/27ff8c87c9164c1fbff054be5f22e56f86cdf127/protocol/contracts/libraries/LibFertilizer.sol#L182-L195</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-04-beanstalk-2/blob/27ff8c87c9164c1fbff054be5f22e56f86cdf127/protocol/contracts/C.sol#L188-L190\">https://github.com/Cyfrin/2024-04-beanstalk-2/blob/27ff8c87c9164c1fbff054be5f22e56f86cdf127/protocol/contracts/C.sol#L188-L190</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-04-beanstalk-2/blob/27ff8c87c9164c1fbff054be5f22e56f86cdf127/protocol/contracts/beanstalk/barn/FertilizerFacet.sol#L64-L84\">https://github.com/Cyfrin/2024-04-beanstalk-2/blob/27ff8c87c9164c1fbff054be5f22e56f86cdf127/protocol/contracts/beanstalk/barn/FertilizerFacet.sol#L64-L84</a>\n\n\n## Summary\n\nThere is a division before multiplication at `LibFertilizer:remainingRecapitalisation()`, which will cause the protocol to enable the mint of less fertilizer than intended. This will result in less value recapitalized than lost and therefor loss of value for the holders of `UNRIPE_LP` tokens.\n\n## Vulnerability Details\nWhen calling `LibFertilizer::remainingRecapitalization()` the amount of `totalDollars` this calculated that still need to be recapitalized:\n``` \n     uint256 totalDollars = C.dollarPerUnripeLP().mul(C.unripeLP().totalSupply()).div(DECIMALS);\n```\n\nFor this the function `C.dollarPerUnripeLP` is used invoking a division operation before the following multiplication, leading to precision loss:\n\n```\n     function dollarPerUnripeLP() internal pure returns (uint256) {\n        return 1e12/UNRIPE_LP_PER_DOLLAR;\n    }\n```\n\n\n\n\n\n### POC\nAdd this file to test folder and run `forge test -vv --mt test_precision_loss`\n```java\n// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\nimport {SafeMath} from \"openzeppelin/utils/math/SafeMath.sol\";\nimport \"forge-std/Test.sol\";\nimport \"forge-std/console.sol\";\n\ncontract TestPrecisionLoss is Test {\n    using SafeMath for uint256;\n\n    function setUp() public {}\n\n    function test_precision_loss() external {\n        uint256 UNRIPE_LP_TOTAL_SUPPLY = 96033202232306;\n        uint128 DECIMALS = 1e6;\n        uint256 UNRIPE_LP_PER_DOLLAR = 1884592; // 145_113_507_403_282 / 77_000_000\n        uint256 dollarPerUnripeLP = 1e12 / UNRIPE_LP_TOTAL_SUPPLY;\n\n        uint256 totalDollars1 = (1e12 / UNRIPE_LP_PER_DOLLAR)\n            .mul(UNRIPE_LP_TOTAL_SUPPLY)\n            .div(DECIMALS);\n        console.log(\"totalDollars1: \", totalDollars1);\n        uint256 totalDollars2 = (1e12 * UNRIPE_LP_TOTAL_SUPPLY)\n            .div(UNRIPE_LP_PER_DOLLAR)\n            .div(DECIMALS);\n        console.log(\"totalDollars2: \", totalDollars2);\n        console.log(\"the diff: \", totalDollars2 - totalDollars1);\n    }\n}\n```\nThe output of the test is the following:\n```\nRunning 1 test for test/testPrecisionLoss.sol:TestPrecisionLoss\n[PASS] test_precision_loss() (gas: 5691)\nLogs:\n  totalDollars1:  50956945702101\n  totalDollars2:  50957025304313\n  the diff:  79602212\n```\n\n## Impact\n`remainingRecapitalization()` will always return lesser value than it should be. This will lead to less fertilizer available for mint and therefore less USD value that will get recapitalized for the `UNRIPE_LP` holders. Here is the related code in `FertilizerFacet::mintFertilizer()`:\n\n\n```java\n        uint128 remaining = uint128(LibFertilizer.remainingRecapitalization().div(1e6));// remaining <= 77_000_000 so downcasting is safe.\n        require(fertilizerAmountOut <= remaining, \"Fertilizer: Not enough remaining.\");\n```\n\n## Tools Used\nFoundry\n\n\n## Recommendations\n\n```diff\n--uint256 totalDollars = C.dollarPerUnripeLP().mul(C.unripeLP().totalSupply()).div(DECIMALS);\n++uint256 totalDollars = (1e12).mul(C.unripeLP().totalSupply()).div(C.unripeLPPerDollara()).div(DECIMALS);\n```",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clu7665bs0001fmt5yahc8tyh",
  "Code": [
    {
      "filename": "protocol/contracts/libraries/LibFertilizer.sol",
      "content": "/*\n SPDX-License-Identifier: MIT\n*/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport {AppStorage, LibAppStorage} from \"./LibAppStorage.sol\";\nimport {LibSafeMath128} from \"./LibSafeMath128.sol\";\nimport {C} from \"../C.sol\";\nimport {LibUnripe} from \"./LibUnripe.sol\";\nimport {IWell} from \"contracts/interfaces/basin/IWell.sol\";\nimport {LibBarnRaise} from \"./LibBarnRaise.sol\";\nimport {LibDiamond} from \"contracts/libraries/LibDiamond.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {LibWell} from \"contracts/libraries/Well/LibWell.sol\";\nimport {LibUsdOracle} from \"contracts/libraries/Oracle/LibUsdOracle.sol\";\n\n/**\n * @author Publius\n * @title Fertilizer\n **/\n\nlibrary LibFertilizer {\n    using SafeMath for uint256;\n    using LibSafeMath128 for uint128;\n    using SafeCast for uint256;\n    using SafeERC20 for IERC20;\n    using LibWell for address;\n\n    event SetFertilizer(uint128 id, uint128 bpf);\n\n    // 6 - 3\n    uint128 private constant PADDING = 1e3;\n    uint128 private constant DECIMALS = 1e6;\n    uint128 private constant REPLANT_SEASON = 6074;\n    uint128 private constant RESTART_HUMIDITY = 2500;\n    uint128 private constant END_DECREASE_SEASON = REPLANT_SEASON + 461;\n\n    function addFertilizer(\n        uint128 season,\n        uint256 tokenAmountIn,\n        uint256 fertilizerAmount,\n        uint256 minLP\n    ) internal returns (uint128 id) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\n        uint128 fertilizerAmount128 = fertilizerAmount.toUint128();\n\n        // Calculate Beans Per Fertilizer and add to total owed\n        uint128 bpf = getBpf(season);\n        s.unfertilizedIndex = s.unfertilizedIndex.add(\n            fertilizerAmount.mul(bpf)\n        );\n        // Get id\n        id = s.bpf.add(bpf);\n        // Update Total and Season supply\n        s.fertilizer[id] = s.fertilizer[id].add(fertilizerAmount128);\n        s.activeFertilizer = s.activeFertilizer.add(fertilizerAmount);\n        // Add underlying to Unripe Beans and Unripe LP\n        addUnderlying(tokenAmountIn, fertilizerAmount.mul(DECIMALS), minLP);\n        // If not first time adding Fertilizer with this id, return\n        if (s.fertilizer[id] > fertilizerAmount128) return id;\n        // If first time, log end Beans Per Fertilizer and add to Season queue.\n        push(id);\n        emit SetFertilizer(id, bpf);\n    }\n\n    function getBpf(uint128 id) internal pure returns (uint128 bpf) {\n        bpf = getHumidity(id).add(1000).mul(PADDING);\n    }\n\n    function getHumidity(uint128 id) internal pure returns (uint128 humidity) {\n        if (id == 0) return 5000;\n        if (id >= END_DECREASE_SEASON) return 200;\n        uint128 humidityDecrease = id.sub(REPLANT_SEASON).mul(5);\n        humidity = RESTART_HUMIDITY.sub(humidityDecrease);\n    }\n\n    /**\n     * @dev Any token contributions should already be transferred to the Barn Raise Well to allow for a gas efficient liquidity\n     * addition through the use of `sync`. See {FertilizerFacet.mintFertilizer} for an example.\n     */\n    function addUnderlying(uint256 tokenAmountIn, uint256 usdAmount, uint256 minAmountOut) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        // Calculate how many new Deposited Beans will be minted\n        uint256 percentToFill = usdAmount.mul(C.precision()).div(\n            remainingRecapitalization()\n        );\n\n        uint256 newDepositedBeans;\n        if (C.unripeBean().totalSupply() > s.u[C.UNRIPE_BEAN].balanceOfUnderlying) {\n            newDepositedBeans = (C.unripeBean().totalSupply()).sub(\n                s.u[C.UNRIPE_BEAN].balanceOfUnderlying\n            );\n            newDepositedBeans = newDepositedBeans.mul(percentToFill).div(\n                C.precision()\n            );\n        }\n\n        // Calculate how many Beans to add as LP\n        uint256 newDepositedLPBeans = usdAmount.mul(C.exploitAddLPRatio()).div(\n            DECIMALS\n        );\n\n        // Mint the Deposited Beans to Beanstalk.\n        C.bean().mint(\n            address(this),\n            newDepositedBeans\n        );\n\n        // Mint the LP Beans and add liquidity to the well.\n        address barnRaiseWell = LibBarnRaise.getBarnRaiseWell();\n        address barnRaiseToken = LibBarnRaise.getBarnRaiseToken();\n\n        C.bean().mint(\n            address(this),\n            newDepositedLPBeans\n        );\n\n        IERC20(barnRaiseToken).transferFrom(\n            msg.sender,\n            address(this),\n            uint256(tokenAmountIn)\n        );\n\n        IERC20(barnRaiseToken).approve(barnRaiseWell, uint256(tokenAmountIn));\n        C.bean().approve(barnRaiseWell, newDepositedLPBeans);\n\n        uint256[] memory tokenAmountsIn = new uint256[](2);\n        IERC20[] memory tokens = IWell(barnRaiseWell).tokens();\n        (tokenAmountsIn[0], tokenAmountsIn[1]) = tokens[0] == C.bean() ?\n            (newDepositedLPBeans, tokenAmountIn) :\n            (tokenAmountIn, newDepositedLPBeans);\n\n        uint256 newLP = IWell(barnRaiseWell).addLiquidity(\n            tokenAmountsIn,\n            minAmountOut,\n            address(this),\n            type(uint256).max\n        );\n\n        // Increment underlying balances of Unripe Tokens\n        LibUnripe.incrementUnderlying(C.UNRIPE_BEAN, newDepositedBeans);\n        LibUnripe.incrementUnderlying(C.UNRIPE_LP, newLP);\n\n        s.recapitalized = s.recapitalized.add(usdAmount);\n    }\n\n    function push(uint128 id) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        if (s.fFirst == 0) {\n            // Queue is empty\n            s.season.fertilizing = true;\n            s.fLast = id;\n            s.fFirst = id;\n        } else if (id <= s.fFirst) {\n            // Add to front of queue\n            setNext(id, s.fFirst);\n            s.fFirst = id;\n        } else if (id >= s.fLast) {\n            // Add to back of queue\n            setNext(s.fLast, id);\n            s.fLast = id;\n        } else {\n            // Add to middle of queue\n            uint128 prev = s.fFirst;\n            uint128 next = getNext(prev);\n            // Search for proper place in line\n            while (id > next) {\n                prev = next;\n                next = getNext(next);\n            }\n            setNext(prev, id);\n            setNext(id, next);\n        }\n    }\n\n    function remainingRecapitalization()\n        internal\n        view\n        returns (uint256 remaining)\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 totalDollars = C\n            .dollarPerUnripeLP()\n            .mul(C.unripeLP().totalSupply())\n            .div(DECIMALS);\n        totalDollars = totalDollars / 1e6 * 1e6; // round down to nearest USDC\n        if (s.recapitalized >= totalDollars) return 0;\n        return totalDollars.sub(s.recapitalized);\n    }\n\n    function pop() internal returns (bool) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint128 first = s.fFirst;\n        s.activeFertilizer = s.activeFertilizer.sub(getAmount(first));\n        uint128 next = getNext(first);\n        if (next == 0) {\n            // If all Unfertilized Beans have been fertilized, delete line.\n            require(s.activeFertilizer == 0, \"Still active fertilizer\");\n            s.fFirst = 0;\n            s.fLast = 0;\n            s.season.fertilizing = false;\n            return false;\n        }\n        s.fFirst = getNext(first);\n        return true;\n    }\n\n    function getAmount(uint128 id) internal view returns (uint256) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s.fertilizer[id];\n    }\n\n    function getNext(uint128 id) internal view returns (uint128) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s.nextFid[id];\n    }\n\n    function setNext(uint128 id, uint128 next) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.nextFid[id] = next;\n    }\n\n    function beginBarnRaiseMigration(address well) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        require(well.isWell(), \"Fertilizer: Not a Whitelisted Well.\");\n\n        // The Barn Raise only supports 2 token Wells where 1 token is Bean and the\n        // other is supported by the Lib Usd Oracle.\n        IERC20[] memory tokens = IWell(well).tokens();\n        require(tokens.length == 2, \"Fertilizer: Well must have 2 tokens.\");\n        require(\n            tokens[0] == C.bean() || tokens[1] == C.bean(),\n            \"Fertilizer: Well must have BEAN.\"\n        );\n        // Check that Lib Usd Oracle supports the non-Bean token in the Well.\n        LibUsdOracle.getTokenPrice(address(tokens[tokens[0] == C.bean() ? 1 : 0]));\n\n        uint256 balanceOfUnderlying = s.u[C.UNRIPE_LP].balanceOfUnderlying;\n        IERC20(s.u[C.UNRIPE_LP].underlyingToken).safeTransfer(\n            LibDiamond.diamondStorage().contractOwner,\n            balanceOfUnderlying\n        );\n        LibUnripe.decrementUnderlying(C.UNRIPE_LP, balanceOfUnderlying);\n        LibUnripe.switchUnderlyingToken(C.UNRIPE_LP, well);\n    }\n}"
    },
    {
      "filename": "protocol/contracts/C.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"./interfaces/IBean.sol\";\nimport \"./interfaces/ICurve.sol\";\nimport \"./interfaces/IFertilizer.sol\";\nimport \"./interfaces/IProxyAdmin.sol\";\nimport \"./libraries/Decimal.sol\";\n\n/**\n * @title C\n * @author Publius\n * @notice Contains constants used throughout Beanstalk.\n */\nlibrary C {\n    using Decimal for Decimal.D256;\n    using SafeMath for uint256;\n\n    //////////////////// Globals ////////////////////\n\n    uint256 internal constant PRECISION = 1e18;\n    uint256 private constant CHAIN_ID = 1;\n    bytes constant BYTES_ZERO = new bytes(0);\n\n    /// @dev The block time for the chain in seconds.\n    uint256 internal constant BLOCK_LENGTH_SECONDS = 12;\n\n    //////////////////// Season ////////////////////\n\n    /// @dev The length of a Season meaured in seconds.\n    uint256 private constant CURRENT_SEASON_PERIOD = 3600; // 1 hour\n    uint256 internal constant SOP_PRECISION = 1e24;\n\n    //////////////////// Silo ////////////////////\n\n    uint256 internal constant SEEDS_PER_BEAN = 2;\n    uint256 internal constant STALK_PER_BEAN = 10000;\n    uint256 private constant ROOTS_BASE = 1e12;\n\n    //////////////////// Exploit Migration ////////////////////\n\n    uint256 private constant UNRIPE_LP_PER_DOLLAR = 1884592; // 145_113_507_403_282 / 77_000_000\n    uint256 private constant ADD_LP_RATIO = 866616;\n    uint256 private constant INITIAL_HAIRCUT = 185564685220298701;\n\n    //////////////////// Contracts ////////////////////\n\n    address internal constant BEAN = 0xBEA0000029AD1c77D3d5D23Ba2D8893dB9d1Efab;\n    address internal constant CURVE_BEAN_METAPOOL = 0xc9C32cd16Bf7eFB85Ff14e0c8603cc90F6F2eE49;\n\n    address internal constant UNRIPE_BEAN = 0x1BEA0050E63e05FBb5D8BA2f10cf5800B6224449;\n    address internal constant UNRIPE_LP = 0x1BEA3CcD22F4EBd3d37d731BA31Eeca95713716D;\n\n    address private constant CURVE_3_POOL = 0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7;\n    address private constant THREE_CRV = 0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490;\n\n    address private constant FERTILIZER = 0x402c84De2Ce49aF88f5e2eF3710ff89bFED36cB6;\n    address private constant FERTILIZER_ADMIN = 0xfECB01359263C12Aa9eD838F878A596F0064aa6e;\n\n    address private constant TRI_CRYPTO = 0xc4AD29ba4B3c580e6D59105FFf484999997675Ff;\n    address private constant TRI_CRYPTO_POOL = 0xD51a44d3FaE010294C616388b506AcdA1bfAAE46;\n    address private constant CURVE_ZAP = 0xA79828DF1850E8a3A3064576f380D90aECDD3359;\n\n    address private constant UNRIPE_CURVE_BEAN_LUSD_POOL = 0xD652c40fBb3f06d6B58Cb9aa9CFF063eE63d465D;\n    address private constant UNRIPE_CURVE_BEAN_METAPOOL = 0x3a70DfA7d2262988064A2D051dd47521E43c9BdD;\n\n    address internal constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    address internal constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n    address internal constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address internal constant WSTETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;\n\n    // Use external contract for block.basefee as to avoid upgrading existing contracts to solidity v8\n    address private constant BASE_FEE_CONTRACT = 0x84292919cB64b590C0131550483707E43Ef223aC;\n\n    //////////////////// Well ////////////////////\n\n    uint256 internal constant WELL_MINIMUM_BEAN_BALANCE = 1000_000_000; // 1,000 Beans\n    address internal constant BEAN_ETH_WELL = 0xBEA0e11282e2bB5893bEcE110cF199501e872bAd;\n    address internal constant BEAN_WSTETH_WELL = 0xa61Ef2313C1eC9c8cf2E1cAC986539d136b1393E; // TODO: Set\n    // The index of the Bean and Weth token addresses in all BEAN/ETH Wells.\n    uint256 internal constant BEAN_INDEX = 0;\n    uint256 internal constant ETH_INDEX = 1;\n\n    function getSeasonPeriod() internal pure returns (uint256) {\n        return CURRENT_SEASON_PERIOD;\n    }\n\n    function getBlockLengthSeconds() internal pure returns (uint256) {\n        return BLOCK_LENGTH_SECONDS;\n    }\n\n    function getChainId() internal pure returns (uint256) {\n        return CHAIN_ID;\n    }\n\n    function getSeedsPerBean() internal pure returns (uint256) {\n        return SEEDS_PER_BEAN;\n    }\n\n    function getStalkPerBean() internal pure returns (uint256) {\n      return STALK_PER_BEAN;\n    }\n\n    function getRootsBase() internal pure returns (uint256) {\n        return ROOTS_BASE;\n    }\n\n    /**\n     * @dev The pre-exploit BEAN:3CRV Curve metapool address.\n     */\n    function unripeLPPool1() internal pure returns (address) {\n        return UNRIPE_CURVE_BEAN_METAPOOL;\n    }\n\n    /**\n     * @dev The pre-exploit BEAN:LUSD Curve plain pool address.\n     */\n    function unripeLPPool2() internal pure returns (address) {\n        return UNRIPE_CURVE_BEAN_LUSD_POOL;\n    }\n\n    function unripeBean() internal pure returns (IERC20) {\n        return IERC20(UNRIPE_BEAN);\n    }\n\n    function unripeLP() internal pure returns (IERC20) {\n        return IERC20(UNRIPE_LP);\n    }\n\n    function bean() internal pure returns (IBean) {\n        return IBean(BEAN);\n    }\n\n    function usdc() internal pure returns (IERC20) {\n        return IERC20(USDC);\n    }\n\n    function curveMetapool() internal pure returns (ICurvePool) {\n        return ICurvePool(CURVE_BEAN_METAPOOL);\n    }\n\n    function curve3Pool() internal pure returns (I3Curve) {\n        return I3Curve(CURVE_3_POOL);\n    }\n    \n    function curveZap() internal pure returns (ICurveZap) {\n        return ICurveZap(CURVE_ZAP);\n    }\n\n    function curveZapAddress() internal pure returns (address) {\n        return CURVE_ZAP;\n    }\n\n    function curve3PoolAddress() internal pure returns (address) {\n        return CURVE_3_POOL;\n    }\n\n    function threeCrv() internal pure returns (IERC20) {\n        return IERC20(THREE_CRV);\n    }\n\n    function fertilizer() internal pure returns (IFertilizer) {\n        return IFertilizer(FERTILIZER);\n    }\n\n    function fertilizerAddress() internal pure returns (address) {\n        return FERTILIZER;\n    }\n\n    function fertilizerAdmin() internal pure returns (IProxyAdmin) {\n        return IProxyAdmin(FERTILIZER_ADMIN);\n    }\n\n    function triCryptoPoolAddress() internal pure returns (address) {\n        return TRI_CRYPTO_POOL;\n    }\n\n    function triCrypto() internal pure returns (IERC20) {\n        return IERC20(TRI_CRYPTO);\n    }\n\n    function unripeLPPerDollar() internal pure returns (uint256) {\n        return UNRIPE_LP_PER_DOLLAR;\n    }\n\n    function dollarPerUnripeLP() internal pure returns (uint256) {\n        return 1e12/UNRIPE_LP_PER_DOLLAR;\n    }\n\n    function exploitAddLPRatio() internal pure returns (uint256) {\n        return ADD_LP_RATIO;\n    }\n\n    function precision() internal pure returns (uint256) {\n        return PRECISION;\n    }\n\n    function initialRecap() internal pure returns (uint256) {\n        return INITIAL_HAIRCUT;\n    }\n\n}"
    },
    {
      "filename": "protocol/contracts/beanstalk/barn/FertilizerFacet.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IFertilizer} from \"contracts/interfaces/IFertilizer.sol\";\nimport {AppStorage} from \"../AppStorage.sol\";\nimport {LibTransfer} from \"contracts/libraries/Token/LibTransfer.sol\";\nimport {LibUsdOracle} from \"contracts/libraries/Oracle/LibUsdOracle.sol\";\nimport {LibFertilizer} from \"contracts/libraries/LibFertilizer.sol\";\nimport {LibSafeMath128} from \"contracts/libraries/LibSafeMath128.sol\";\nimport {C} from \"contracts/C.sol\";\nimport {LibDiamond} from \"contracts/libraries/LibDiamond.sol\";\nimport {IWell} from \"contracts/interfaces/basin/IWell.sol\";\nimport {LibBarnRaise} from \"contracts/libraries/LibBarnRaise.sol\";\n\n/**\n * @author Publius\n * @title FertilizerFacet handles Minting Fertilizer and Rinsing Sprouts earned from Fertilizer.\n **/\n\ncontract FertilizerFacet {\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n    using LibSafeMath128 for uint128;\n\n    event SetFertilizer(uint128 id, uint128 bpf);\n\n    uint256 private constant FERTILIZER_AMOUNT_PRECISION = 1e24;\n\n    AppStorage internal s;\n\n    struct Supply {\n        uint128 endBpf;\n        uint256 supply;\n    }\n\n\n    /**\n     * @notice Rinses Rinsable Sprouts earned from Fertilizer.\n     * @param ids The ids of the Fertilizer to rinse.\n     * @param mode The balance to transfer Beans to; see {LibTrasfer.To}\n     */\n    function claimFertilized(uint256[] calldata ids, LibTransfer.To mode)\n        external\n        payable\n    {\n        uint256 amount = C.fertilizer().beanstalkUpdate(msg.sender, ids, s.bpf);\n        LibTransfer.sendToken(C.bean(), amount, msg.sender, mode);\n    }\n\n    /**\n     * @notice Purchase Fertilizer from the Barn Raise with the Barn Raise token.\n     * @param tokenAmountIn Amount of tokens to buy Fertilizer with 18 decimal precision.\n     * @param minFertilizerOut The minimum amount of Fertilizer to purchase. Protects against a significant Barn Raise Token/USD price decrease.\n     * @param minLPTokensOut The minimum amount of LP tokens to receive after adding liquidity with Barn Raise tokens.\n     * @dev The # of Fertilizer minted is equal to the value of the Ether paid in USD.\n     */\n    function mintFertilizer(\n        uint256 tokenAmountIn,\n        uint256 minFertilizerOut,\n        uint256 minLPTokensOut\n    ) external payable returns (uint256 fertilizerAmountOut) {\n        fertilizerAmountOut = _getMintFertilizerOut(tokenAmountIn, LibBarnRaise.getBarnRaiseToken());\n\n        require(fertilizerAmountOut >= minFertilizerOut, \"Fertilizer: Not enough bought.\");\n        require(fertilizerAmountOut > 0, \"Fertilizer: None bought.\");\n\n        uint128 remaining = uint128(LibFertilizer.remainingRecapitalization().div(1e6)); // remaining <= 77_000_000 so downcasting is safe.\n        require(fertilizerAmountOut <= remaining, \"Fertilizer: Not enough remaining.\");\n\n        uint128 id = LibFertilizer.addFertilizer(\n            uint128(s.season.current),\n            tokenAmountIn,\n            fertilizerAmountOut,\n            minLPTokensOut\n        );\n        C.fertilizer().beanstalkMint(msg.sender, uint256(id), (fertilizerAmountOut).toUint128(), s.bpf);\n    }\n\n    /**\n     * @dev Callback from Fertilizer contract in `claimFertilized` function.\n     */\n    function payFertilizer(address account, uint256 amount) external payable {\n        require(msg.sender == C.fertilizerAddress());\n        LibTransfer.sendToken(\n            C.bean(),\n            amount,\n            account,\n            LibTransfer.To.INTERNAL\n        );\n    }\n\n    /**\n     * @dev Returns the amount of Fertilizer that can be purchased with `tokenAmountIn` Barn Raise tokens.\n     * Can be used to help calculate `minFertilizerOut` in `mintFertilizer`.\n     * `tokenAmountIn` has 18 decimals, `getEthUsdPrice()` has 6 decimals and `fertilizerAmountOut` has 0 decimals.\n     */\n    function getMintFertilizerOut(uint256 tokenAmountIn)\n        external\n        view\n        returns (uint256 fertilizerAmountOut)\n    {\n        address barnRaiseToken = LibBarnRaise.getBarnRaiseToken();\n        return _getMintFertilizerOut(tokenAmountIn, barnRaiseToken);\n    }\n\n    function _getMintFertilizerOut(\n        uint256 tokenAmountIn,\n        address barnRaiseToken\n    ) public view returns (uint256 fertilizerAmountOut) {\n        fertilizerAmountOut = tokenAmountIn.div(\n            LibUsdOracle.getUsdPrice(barnRaiseToken)\n        );\n    }\n\n    function totalFertilizedBeans() external view returns (uint256 beans) {\n        return s.fertilizedIndex;\n    }\n\n    function totalUnfertilizedBeans() external view returns (uint256 beans) {\n        return s.unfertilizedIndex - s.fertilizedIndex;\n    }\n\n    function totalFertilizerBeans() external view returns (uint256 beans) {\n        return s.unfertilizedIndex;\n    }\n\n    function getFertilizer(uint128 id) external view returns (uint256) {\n        return s.fertilizer[id];\n    }\n\n    function getNext(uint128 id) external view returns (uint128) {\n        return LibFertilizer.getNext(id);\n    }\n\n    function getFirst() external view returns (uint128) {\n        return s.fFirst;\n    }\n\n    function getLast() external view returns (uint128) {\n        return s.fLast;\n    }\n\n    function getActiveFertilizer() external view returns (uint256) {\n        return s.activeFertilizer;\n    }\n\n    function isFertilizing() external view returns (bool) {\n        return s.season.fertilizing;\n    }\n\n    function beansPerFertilizer() external view returns (uint128 bpf) {\n        return s.bpf;\n    }\n\n    function getHumidity(uint128 _s) external pure returns (uint128 humidity) {\n        humidity = LibFertilizer.getHumidity(_s);\n    }\n\n    function getCurrentHumidity() external view returns (uint128 humidity) {\n        humidity = LibFertilizer.getHumidity(s.season.current);\n    }\n\n    function getEndBpf() external view returns (uint128 endBpf) {\n        endBpf = s.bpf.add(LibFertilizer.getBpf(uint128(s.season.current)));\n    }\n\n    function remainingRecapitalization() external view returns (uint256) {\n        return LibFertilizer.remainingRecapitalization();\n    }\n\n    function balanceOfUnfertilized(address account, uint256[] memory ids)\n        external\n        view\n        returns (uint256 beans)\n    {\n        return C.fertilizer().balanceOfUnfertilized(account, ids);\n    }\n\n    function balanceOfFertilized(address account, uint256[] memory ids)\n        external\n        view\n        returns (uint256 beans)\n    {\n        return C.fertilizer().balanceOfFertilized(account, ids);\n    }\n\n    function balanceOfFertilizer(address account, uint256 id)\n        external\n        view\n        returns (IFertilizer.Balance memory)\n    {\n        return C.fertilizer().lastBalanceOf(account, id);\n    }\n\n    function balanceOfBatchFertilizer(\n        address[] memory accounts,\n        uint256[] memory ids\n    ) external view returns (IFertilizer.Balance[] memory) {\n        return C.fertilizer().lastBalanceOfBatch(accounts, ids);\n    }\n\n    function getFertilizers()\n        external\n        view\n        returns (Supply[] memory fertilizers)\n    {\n        uint256 numFerts = 0;\n        uint128 idx = s.fFirst;\n        while (idx > 0) {\n            numFerts = numFerts.add(1);\n            idx = LibFertilizer.getNext(idx);\n        }\n        fertilizers = new Supply[](numFerts);\n        numFerts = 0;\n        idx = s.fFirst;\n        while (idx > 0) {\n            fertilizers[numFerts].endBpf = idx;\n            fertilizers[numFerts].supply = LibFertilizer.getAmount(idx);\n            numFerts = numFerts.add(1);\n            idx = LibFertilizer.getNext(idx);\n        }\n    }\n\n    function getBarnRaiseWell() external view returns (address) {\n        return LibBarnRaise.getBarnRaiseWell();\n    }\n\n    function getBarnRaiseToken() external view returns (address) {\n        return LibBarnRaise.getBarnRaiseToken();\n    }\n\n    /**\n     * @notice Begins the process of Migration the Barn Raise to a new Well.\n     * @param well The address of the Well to migrate to.\n     * @dev\n     * Withdraws all underlying Unripe LP tokens to the owner contract.\n     * Converting, chopping and purchasing Fertilizer will be disabled until the migration is complete.\n     * The migration process is completed by calling {UnripeFacet.addMigratedUnderlying}.\n     * After migration, Unripe liquidity will be added into `well`. and Fertilizer purchases can only happen\n     * with the non-Bean token in `well`.\n     *\n     */\n    function beginBarnRaiseMigration(address well) external {\n        LibDiamond.enforceIsOwnerOrContract();\n        LibFertilizer.beginBarnRaiseMigration(well);\n    }\n}"
    }
  ]
}