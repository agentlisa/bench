{
  "Title": "[H-03] The creation of bad debt (`mark-down` of Credit) can force other loans in auction to also create bad debt",
  "Content": "\nThe creation of bad debt results in the `mark down` of `Credit`, i.e. `Credit` experiences inflation. This is done so that the protocol can adjust to the bad debt that was produced. It follows that when `Credit` is marked down all active loans can be considered `marked up`; meaning, the borrowers will be expected to repay with more `Credit`, since `Credit` is now worthless. We can observe how this is done by examining the `LendingTerm::getLoanDebt` function:\n\n[LendingTerm::getLoanDebt#L216-L230](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L216-L230)\n\n```solidity\n216:        // compute interest owed\n217:        uint256 borrowAmount = loan.borrowAmount;\n218:        uint256 interest = (borrowAmount *\n219:            params.interestRate *\n220:            (block.timestamp - borrowTime)) /\n221:            YEAR /\n222:            1e18;\n223:        uint256 loanDebt = borrowAmount + interest;\n224:        uint256 _openingFee = params.openingFee;\n225:        if (_openingFee != 0) {\n226:            loanDebt += (borrowAmount * _openingFee) / 1e18;\n227:        }\n228:        uint256 creditMultiplier = ProfitManager(refs.profitManager)\n229:            .creditMultiplier();\n230:        loanDebt = (loanDebt * loan.borrowCreditMultiplier) / creditMultiplier;\n```\n\nAs we can see above, the debt of a borrower (principle + interests) is adjusted by the `creditMultiplier`. This `creditMultiplier` starts at `1e18` and gets `marked down` when bad debt is produced in the system. The `loan.borrowCreditMultiplier` is the `creditMultiplier` value at the time that the user took out the loan. Therefore, this function calculates the adjusted debt of a borrower with respect to the amount of bad debt that was produced (inflation of `Credit`) since the borrower took out the loan. This function is called every time a borrower makes a payment for their loan, ensuring that the appropriate debt is always considered. However, this function is only called once during the entire auction process:\n\n[LendingTerm::\\_call#L664-L668](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L664-L668)\n\n```solidity\n664:        // update loan in state\n665:        uint256 loanDebt = getLoanDebt(loanId);\n666:        loans[loanId].callTime = block.timestamp;\n667:        loans[loanId].callDebt = loanDebt;\n668:        loans[loanId].caller = caller;\n```\n\nThe above code is taken from the `_call` function, which is the starting point for an auction. When a loan misses a *required* `partialPayment` or the term is offboarded, this function can be permissionlessly called. As we can see, the debt of the loan is read from the `getLoanDebt` function and then stored in the `loan` struct in the `callDebt` field. This means that the `callDebt` represents a snapshot of the debt at `block.timestamp`. Therefore, the `callDebt` is the loan debt with respect to the `creditMultiplier` valued at the time that the loan was called. What if the `creditMultiplier` gets updated after the auction process begins? This would result in the `callDebt` of the loan being less than what the actual debt of the loan should be (`Credit` is worth less, but the collateral is worth the same). We can understand the true magnitude of this discrepancy by observing the `LendingTerm::onBid` function:\n\n[LendingTerm::onBid#L750-L768](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L750-L768)\n\n```solidity\n750:        // compute pnl\n751:        uint256 creditMultiplier = ProfitManager(refs.profitManager)\n752:            .creditMultiplier();\n753:        uint256 borrowAmount = loans[loanId].borrowAmount;\n754:        uint256 principal = (borrowAmount *\n755:            loans[loanId].borrowCreditMultiplier) / creditMultiplier;\n756:        int256 pnl;\n757:        uint256 interest;\n758:        if (creditFromBidder >= principal) {\n759:            interest = creditFromBidder - principal;\n760:            pnl = int256(interest);\n761:        } else {\n762:            pnl = int256(creditFromBidder) - int256(principal);\n763:            principal = creditFromBidder;\n764:            require(\n765:                collateralToBorrower == 0,\n766:                \"LendingTerm: invalid collateral movement\"\n767:            );\n768:        }\n```\n\nAs we can see above, the `principle` of the loan is calculated with respect to the current `creditMultiplier`. The `creditFromBidder` is the `callDebt` when the auction is in its first phase:\n\n[AuctionHouse::getBidDetail#L133-L136](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L133-L136)\n\n```solidity\n133:        // first phase of the auction, where more and more collateral is offered\n134:        if (block.timestamp < _startTime + midPoint) {\n135:            // ask for the full debt\n136:            creditAsked = auctions[loanId].callDebt;\n```\n\nThis is where the issue lies. Remember, the `callDebt` represents a snapshot of the loan debt at the time which the loan was called. The `callDebt` does not consider a potential updated `creditMultiplier`. Therefore, if a `mark down` is generated that results in `principle > creditFromBidder`, then execution of the `onBid` function would continue on line 762. This will result in a negative `pnl` being calculated, which ultimately means that this gauge will experience a loss. However, if the `collateralToBorrower` is *not* `0`, the function will revert. Therefore, when the `principle` is greater than the `callDebt`, due to the `mark down` of `Credit`, the auction can only receive a bid if the `collateralToBorrower` is `0`. Let us observe the `AuctionHouse::bid` and `AuctionHouse::getBidDetail` functions in order to understand what scenario would result in `collateralToBorrower == 0`:\n\n[AuctionHouse::bid#L169-L186](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L169-L186)\n\n```solidity\n169:        (uint256 collateralReceived, uint256 creditAsked) = getBidDetail(\n170:            loanId\n171:        );\n172:        require(creditAsked != 0, \"AuctionHouse: cannot bid 0\");\n...\n180:        LendingTerm(_lendingTerm).onBid(\n181:            loanId,\n182:            msg.sender,\n183:            auctions[loanId].collateralAmount - collateralReceived, // collateralToBorrower\n184:            collateralReceived, // collateralToBidder\n185:            creditAsked // creditFromBidder\n186:        );\n```\n\nAs seen above, the `onBidDetail` function is invoked to retrieve the necessary `collateralReceived` and `creditAsked` values. The `onBid` function is then invoked and the `collateralToBorrower` is equal to the `collateralAmount - collateralReceived`. The `collateralAmount` is the full collateral of the loan. Therefore, if the `collateralReceived == collateralAmount`, we will have satisfied the following condition: `collateralToBorrower == 0`. This is exactly what occurs during the second phase of an auction:\n\n[AuctionHouse::getBidDetail#L143-L146](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L143-L146)\n\n```solidity\n143:        // second phase of the auction, where less and less CREDIT is asked\n144:        else if (block.timestamp < _startTime + auctionDuration) {\n145:            // receive the full collateral\n146:            collateralReceived = auctions[loanId].collateralAmount;\n```\n\nTherefore, given the situation where a loan is placed in auction and then a large enough `mark down` of `Credit` occurs, such that `principle > creditFromBidder`, only bids occurring during the second phase of the auction will be allowed. In addition, given that `principle > creditFromBidder`, bad debt will also be produced in this auction.\n\nLet's briefly discuss what scenarios would result in `principle > callDebt`. Reminder: The `callDebt` represents the maximum value that `creditFromBidder` can be. The `callDebt` is a snapshot of the full debt of a borrower (principle + interests). Therefore, if the `mark down` results in a percent decrease of `Credit` greater than the interest of the borrower's loan, then the adjusted `principle` will be greater than the `callDebt`. Consider the following situation:\n\nA term has an interest rate of 4%. The term has multiple loans opened and the term is being off-boarded after half a year. Let's assume no loans have been paid off during this time. Therefore, the interest for all loans is \\~2%. Suppose a loan undergoes auction before other loans are called and this loan results in the creation of bad debt (worst case scenario), which results in a `mark down` > 2%. All other loans that are in auction during this `mark down` will be forced to create bad debt since the adjusted `principle` for all loans in auction will be greater than the loans' `callDebt`.\n\n### Impact\n\nThe creation of bad debt has the potential to force other loans to create additional bad debt if the following conditions are met:\n\n1.  The other loans were in auction during the `mark down`.\n2.  The `mark down` is greater than the interest owed for the loans.\n3.  The global surplus buffer is not manually replenished before each additional bad debt creation (funds essentially sacrificed).\n\nThis can greatly impact the health of the protocol as the `Credit` token is used for all core functionalities. A `mark down` is a mechanism to allow the system to properly adjust to the creation of bad debt; however, I would argue that the creation of bad debt should not result in other loans being forced to produce losses which can ultimately produce more bad debt.\n\nThis has the ability to affect loans in other terms as well. All loans in auction during the `mark down`, originating from any term in the market, can potentially be forced to produce a loss/bad debt. The magnitude of this additional `mark down` of `Credit` will be greater if the affected loans have relatively low interest accrued and a large borrow amount.\n\nSecondary effects are that no user's will be able to bid during the first phase of the auction. This first phase is meant to be an opportunity for the borrower to properly repay their full debt before the second phase begins, where the borrower can potentially be out-bid by another liquidator and lose the opportunity to receive their collateral.\n\n### Proof of Concept\n\nThe following test demonstrates the scenario described above in which a `mark down` of `Credit` results in other loans in auction being forced to create additional bad debt.\n\nPlace the test inside of the `test/unit/loan/` directory:\n\n<details>\n\n```solidity\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\n\nimport {Test} from \"@forge-std/Test.sol\";\nimport {Core} from \"@src/core/Core.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {MockERC20} from \"@test/mock/MockERC20.sol\";\nimport {SimplePSM} from \"@src/loan/SimplePSM.sol\";\nimport {GuildToken} from \"@src/tokens/GuildToken.sol\";\nimport {CreditToken} from \"@src/tokens/CreditToken.sol\";\nimport {LendingTerm} from \"@src/loan/LendingTerm.sol\";\nimport {AuctionHouse} from \"@src/loan/AuctionHouse.sol\";\nimport {ProfitManager} from \"@src/governance/ProfitManager.sol\";\nimport {RateLimitedMinter} from \"@src/rate-limits/RateLimitedMinter.sol\";\n\ncontract BadDebtCreatesBadDebt is Test {\n    address private governor = address(1);\n    address private guardian = address(2);\n    address staker = address(0x01010101);\n    address borrower = address(0x02020202);\n    address lender = address(0x03030303);\n    Core private core;\n    ProfitManager private profitManager;\n    CreditToken credit;\n    GuildToken guild;\n    MockERC20 collateral;\n    MockERC20 pegToken;\n    SimplePSM private psm;\n    RateLimitedMinter rlcm;\n    AuctionHouse auctionHouse;\n    LendingTerm term;\n\n    // LendingTerm params (same as deployment script)\n    uint256 constant _CREDIT_PER_COLLATERAL_TOKEN = 1e18; // 1:1\n    uint256 constant _INTEREST_RATE = 0.04e18; // 4% APR\n    uint256 constant _MAX_DELAY_BETWEEN_PARTIAL_REPAY = 0; \n    uint256 constant _MIN_PARTIAL_REPAY_PERCENT = 0; \n    uint256 constant _HARDCAP = 2_000_000e18; // 2 million\n\n    uint256 public issuance = 0;\n\n    function setUp() public {\n        vm.warp(1679067867);\n        vm.roll(16848497);\n        core = new Core();\n\n        profitManager = new ProfitManager(address(core));\n        collateral = new MockERC20();\n        pegToken = new MockERC20(); // 18 decimals for easy calculations (deployment script uses USDC which has 6 decimals)\n        credit = new CreditToken(address(core), \"name\", \"symbol\");\n        guild = new GuildToken(\n            address(core),\n            address(profitManager)\n        );\n        rlcm = new RateLimitedMinter(\n            address(core) /*_core*/,\n            address(credit) /*_token*/,\n            CoreRoles.RATE_LIMITED_CREDIT_MINTER /*_role*/,\n            0 /*_maxRateLimitPerSecond*/,\n            0 /*_rateLimitPerSecond*/,\n            uint128(_HARDCAP) /*_bufferCap*/\n        );\n        auctionHouse = new AuctionHouse(address(core), 650, 1800);\n        term = LendingTerm(Clones.clone(address(new LendingTerm())));\n        term.initialize(\n            address(core),\n            LendingTerm.LendingTermReferences({\n                profitManager: address(profitManager),\n                guildToken: address(guild),\n                auctionHouse: address(auctionHouse),\n                creditMinter: address(rlcm),\n                creditToken: address(credit)\n            }),\n            LendingTerm.LendingTermParams({\n                collateralToken: address(collateral),\n                maxDebtPerCollateralToken: _CREDIT_PER_COLLATERAL_TOKEN,\n                interestRate: _INTEREST_RATE,\n                maxDelayBetweenPartialRepay: _MAX_DELAY_BETWEEN_PARTIAL_REPAY,\n                minPartialRepayPercent: _MIN_PARTIAL_REPAY_PERCENT,\n                openingFee: 0,\n                hardCap: _HARDCAP\n            })\n        );\n        psm = new SimplePSM(\n            address(core),\n            address(profitManager),\n            address(credit),\n            address(pegToken)\n        );\n        profitManager.initializeReferences(address(credit), address(guild), address(psm));\n\n        // roles\n        core.grantRole(CoreRoles.GOVERNOR, governor);\n        core.grantRole(CoreRoles.GUARDIAN, guardian);\n        core.grantRole(CoreRoles.CREDIT_MINTER, address(this));\n        core.grantRole(CoreRoles.GUILD_MINTER, address(this));\n        core.grantRole(CoreRoles.GAUGE_ADD, address(this));\n        core.grantRole(CoreRoles.GAUGE_REMOVE, address(this));\n        core.grantRole(CoreRoles.GAUGE_PARAMETERS, address(this));\n        core.grantRole(CoreRoles.CREDIT_MINTER, address(rlcm));\n        core.grantRole(CoreRoles.RATE_LIMITED_CREDIT_MINTER, address(term));\n        core.grantRole(CoreRoles.GAUGE_PNL_NOTIFIER, address(term));\n        core.grantRole(CoreRoles.CREDIT_MINTER, address(psm));\n        core.grantRole(CoreRoles.CREDIT_REBASE_PARAMETERS, address(psm));\n        core.renounceRole(CoreRoles.GOVERNOR, address(this));\n\n        // add gauge \n        guild.setMaxGauges(10);\n        guild.addGauge(1, address(term));\n    }\n\n    function testBadDebtCreatesBadDebt() public {\n        // staker increases term debtCeiling\n        guild.mint(staker, 1000e18);\n        vm.startPrank(staker);\n        guild.incrementGauge(address(term), 1000e18);\n        vm.stopPrank();\n\n        assertEq(guild.getGaugeWeight(address(term)), 1000e18);\n\n        // term has 12 active loans all with various borrow sizes (1_000_000 in total loans)\n        // 1st loan = 80_000e18\n        collateral.mint(borrower, 1_000_000e18);\n        uint256[] memory borrowAmounts = new uint256[](11);\n        bytes32[] memory loanIds = new bytes32[](11);\n        borrowAmounts[0] = 1_000e18;\n        borrowAmounts[1] = 5_000e18;\n        borrowAmounts[2] = 10_000e18;\n        borrowAmounts[3] = 25_000e18;\n        borrowAmounts[4] = 100_000e18;\n        borrowAmounts[5] = 50_000e18;\n        borrowAmounts[6] = 300_000e18;\n        borrowAmounts[7] = 18_000e18;\n        borrowAmounts[8] = 90_000e18;\n        borrowAmounts[9] = 250_000e18;\n        borrowAmounts[10] = 71_000e18;\n\n        vm.prank(borrower);\n        collateral.approve(address(term), 1_000_000e18);\n\n        // create 1st loan (loan that will create bad debt)\n        bytes32 loanId;\n        vm.startPrank(borrower);\n        loanId = term.borrow(80_000e18, 80_000e18);\n        vm.roll(block.number + 1);\n        vm.warp(block.timestamp + 13);\n        vm.stopPrank();\n\n        // create the rest of the loans (loans that will be forced to create bad debt)\n        for (uint256 i; i < borrowAmounts.length; i++) {\n            vm.startPrank(borrower);\n            loanIds[i] = term.borrow(borrowAmounts[i], borrowAmounts[i]);\n            vm.roll(block.number + 1);\n            vm.warp(block.timestamp + 13);\n            vm.stopPrank();\n        }\n        \n        assertEq(term.issuance(), 1_000_000e18);\n        assertEq(credit.balanceOf(borrower), 1_000_000e18);\n        assertEq(credit.totalSupply(), 1_000_000e18);\n\n        // lenders supply 1_000_000 pegToken in psm (credit.totalSupply == 2_000_000)\n        pegToken.mint(lender, 1_000_000e18);\n        vm.startPrank(lender);\n        pegToken.approve(address(psm), 1_000_000e18);\n        psm.mintAndEnterRebase(1_000_000e18);\n        vm.stopPrank();\n\n        assertEq(credit.totalSupply(), 2_000_000e18);\n\n        // half a year later all loans accrued ~2% interest\n        vm.warp(block.timestamp + (term.YEAR() / 2));\n        \n        // term is offboarded \n        guild.removeGauge(address(term));\n        assertEq(guild.isGauge(address(term)), false);\n\n        // one loan is called before the others and it creates bad debt (markdown > % interest owed by other loans)\n        term.call(loanId);\n\n        // no ones bids and loan creates bad debt (worse case scenario)\n        vm.warp(block.timestamp + auctionHouse.auctionDuration());\n        (, uint256 creditAsked) = auctionHouse.getBidDetail(loanId); \n        assertEq(creditAsked, 0); // phase 2 ended\n\n        // all loans called via callMany right before bad debt + markdown occurs \n        // to demonstrate that any auctions live while markdown occurred would be affected (including auctions in diff terms)\n        term.callMany(loanIds);\n\n        // bad debt created, i.e. markdown of 4%\n        // note that for demonstration purposes there are no surplus buffers\n        auctionHouse.forgive(loanId);\n\n        assertEq(term.issuance(), 1_000_000e18 - 80_000e18);\n        assertEq(credit.totalSupply(), 2_000_000e18);\n        assertEq(profitManager.creditMultiplier(), 0.96e18); // credit marked down\n\n        // no one can bid during phase 1 of any other loans that were in auction when the markdown occurred\n        // due to principle > creditFromBidder, therefore collateral to borrower must be 0, i.e. all collateral is offered, i.e. must be phase 2\n        for (uint256 i; i < loanIds.length; i++) {\n            ( , creditAsked) = auctionHouse.getBidDetail(loanIds[i]);\n            // verify we are in phase 1 (creditAsked == callDebt)\n            assertEq(auctionHouse.getAuction(loanIds[i]).callDebt, creditAsked);\n            // attempt to bid during phase 1\n            credit.mint(address(this), creditAsked);\n            credit.approve(address(term), creditAsked);\n            vm.expectRevert(\"LendingTerm: invalid collateral movement\");\n            auctionHouse.bid(loanIds[i]);\n        }\n\n        // fast forward to the beginning of phase 2\n        vm.warp(block.timestamp + auctionHouse.midPoint());\n        vm.roll(block.number + 1);\n\n        // all other loans that are in auction will be forced to only receive bids in phase 2\n        // bad debt is gauranteed to be created for all these loans, so user's are incentivized to \n        // bid at the top of phase 2. This would result in the liquidator receiving the collateral at a discount. \n        // The loans with less accrued interest and a bigger principle/borrow amount will result in a bigger loss, i.e. greater markdown\n\n        emit log_named_uint(\"creditMultiplier before updates\", profitManager.creditMultiplier());\n        \n        uint256 collateralReceived;\n        for (uint256 i; i < loanIds.length; i++) {\n            (collateralReceived, creditAsked) = auctionHouse.getBidDetail(loanIds[i]);\n            // verify we are at the top of phase 2 (collateralReceived == collateralAmount | creditAsked == callDebt)\n            assertEq(auctionHouse.getAuction(loanIds[i]).callDebt, creditAsked);\n            assertEq(auctionHouse.getAuction(loanIds[i]).collateralAmount, collateralReceived);\n            // bid at top of phase two (bidder receives collateral at a discount & protocol incurs more bad debt)\n            credit.mint(address(this), creditAsked);\n            credit.approve(address(term), creditAsked);\n            auctionHouse.bid(loanIds[i]);\n            multiplierUpdated();\n        }\n    }\n\n    function multiplierUpdated() internal {\n        // credit multiiplier decreases which each auction\n        uint256 multiiplier = profitManager.creditMultiplier();\n\n        emit log_named_uint(\"creditMultiplier updated\", multiiplier);\n    }\n}\n```\n\n</details>\n\n### Recommended Mitigation Steps\n\n`Credit` debt is calculated in most areas of the system with respect to the current multiplier, except for during the auction process. I would suggest calculating the `callDebt` dynamically with respect to the current `creditMultiplier` during the auction process instead of having it represent a 'snapshot' of the borrower's debt.\n\n**[TrungOre (judge) increased severity to High](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/476#issuecomment-1919130899)**\n\n**[eswak (Ethereum Credit Guild) confirmed via duplicate issue #1069](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/1069#issuecomment-1896024582):**\n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/476).*\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-12-ethereumcreditguild",
  "Code": [
    {
      "filename": "src/loan/LendingTerm.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {GuildToken} from \"@src/tokens/GuildToken.sol\";\nimport {CreditToken} from \"@src/tokens/CreditToken.sol\";\nimport {AuctionHouse} from \"@src/loan/AuctionHouse.sol\";\nimport {ProfitManager} from \"@src/governance/ProfitManager.sol\";\nimport {RateLimitedMinter} from \"@src/rate-limits/RateLimitedMinter.sol\";\n\n/// @notice Lending Term contract of the Ethereum Credit Guild, a base implementation of\n/// smart contract issuing CREDIT debt and escrowing collateral assets.\n/// Note that interest rate is non-compounding and the percentage is expressed per\n/// period of `YEAR` seconds.\ncontract LendingTerm is CoreRef {\n    using SafeERC20 for IERC20;\n\n    // events for the lifecycle of loans that happen in the lending term\n    /// @notice emitted when new loans are opened (mint debt to borrower, pull collateral from borrower).\n    event LoanOpen(\n        uint256 indexed when,\n        bytes32 indexed loanId,\n        address indexed borrower,\n        uint256 collateralAmount,\n        uint256 borrowAmount\n    );\n    /// @notice emitted when a loan is called.\n    event LoanCall(uint256 indexed when, bytes32 indexed loanId);\n    /// @notice emitted when a loan is closed (repay, onBid after a call, forgive).\n    enum LoanCloseType {\n        Repay,\n        Call,\n        Forgive\n    }\n    event LoanClose(\n        uint256 indexed when,\n        bytes32 indexed loanId,\n        LoanCloseType indexed closeType,\n        uint256 debtRepaid\n    );\n    /// @notice emitted when someone adds collateral to a loan\n    event LoanAddCollateral(\n        uint256 indexed when,\n        bytes32 indexed loanId,\n        address indexed borrower,\n        uint256 collateralAmount\n    );\n    /// @notice emitted when someone partially repays a loan\n    event LoanPartialRepay(\n        uint256 indexed when,\n        bytes32 indexed loanId,\n        address indexed repayer,\n        uint256 repayAmount\n    );\n\n    struct Signature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    /// @notice reference number of seconds in 1 year\n    uint256 public constant YEAR = 31557600;\n\n    /// @notice timestamp of last partial repayment for a given loanId.\n    /// during borrow(), this is initialized to the borrow timestamp, if\n    /// maxDelayBetweenPartialRepay is != 0\n    mapping(bytes32 => uint256) public lastPartialRepay;\n\n    struct Loan {\n        address borrower; // address of a loan's borrower\n        uint256 borrowTime; // the time the loan was initiated\n        uint256 borrowAmount; // initial CREDIT debt of a loan\n        uint256 borrowCreditMultiplier; // creditMultiplier when loan was opened\n        uint256 collateralAmount; // balance of collateral token provided by the borrower\n        address caller; // a caller of 0 indicates that the loan has not been called\n        uint256 callTime; // a call time of 0 indicates that the loan has not been called\n        uint256 callDebt; // the CREDIT debt when the loan was called\n        uint256 closeTime; // the time the loan was closed (repaid or call+bid or forgive)\n    }\n\n    /// @notice the list of all loans that existed or are still active.\n    /// @dev see public getLoan(loanId) getter.\n    mapping(bytes32 => Loan) internal loans;\n\n    /// @notice current number of CREDIT issued in active loans on this term\n    /// @dev this can be lower than the sum of all loan's CREDIT debts because\n    /// interests accrue and some loans might have been opened before the creditMultiplier\n    /// was last updated, resulting in higher CREDIT debt than what was originally borrowed.\n    uint256 public issuance;\n\n    struct LendingTermReferences {\n        /// @notice reference to the ProfitManager\n        address profitManager;\n        /// @notice reference to the GUILD token\n        address guildToken;\n        /// @notice reference to the auction house contract used to\n        /// sell loan collateral for CREDIT if loans are called.\n        address auctionHouse;\n        /// @notice reference to the credit minter contract\n        address creditMinter;\n        /// @notice reference to the CREDIT token\n        address creditToken;\n    }\n\n    /// @notice References to other protocol contracts (see struct for more details)\n    LendingTermReferences internal refs;\n\n    struct LendingTermParams {\n        /// @notice reference to the collateral token\n        address collateralToken;\n        /// @notice max number of debt tokens issued per collateral token.\n        /// @dev be mindful of the decimals here, because if collateral\n        /// token doesn't have 18 decimals, this variable is used to scale\n        /// the decimals.\n        /// For example, for USDC collateral, this variable should be around\n        /// ~1e30, to allow 1e6 * 1e30 / 1e18 ~= 1e18 CREDIT to be borrowed for\n        /// each 1e6 units (1 USDC) of collateral, if CREDIT is targeted to be\n        /// worth around 1 USDC.\n        uint256 maxDebtPerCollateralToken;\n        /// @notice interest rate paid by the borrower, expressed as an APR\n        /// with 18 decimals (0.01e18 = 1% APR). The base for 1 year is the YEAR constant.\n        uint256 interestRate;\n        /// @notice maximum delay, in seconds, between partial debt repayments.\n        /// if set to 0, no periodic partial repayments are expected.\n        /// if a partial repayment is missed (delay has passed), the loan\n        /// can be called.\n        uint256 maxDelayBetweenPartialRepay;\n        /// @notice minimum percent of the total debt (principal + interests) to\n        /// repay during partial debt repayments.\n        /// percentage is expressed with 18 decimals, e.g. 0.05e18 = 5% debt.\n        uint256 minPartialRepayPercent;\n        /// @notice the opening fee is a percent of interest that instantly accrues\n        /// when the loan is opened.\n        /// The opening fee is expressed as a percentage of the borrowAmount, with 18\n        /// decimals, e.g. 0.05e18 = 5% of the borrowed amount.\n        /// A loan with 2% openingFee and 3% interestRate will owe 102% of the borrowed\n        /// amount just after being open, and after 1 year will owe 105%.\n        uint256 openingFee;\n        /// @notice the absolute maximum amount of debt this lending term can issue\n        /// at any given time, regardless of the gauge allocations.\n        uint256 hardCap;\n    }\n\n    /// @notice Params of the LendingTerm (see struct for more details)\n    LendingTermParams internal params;\n\n    constructor() CoreRef(address(1)) {\n        // core is set to address(1) to prevent implementation from being initialized,\n        // only proxies on the implementation can be initialized.\n    }\n\n    /// @notice initialize storage with references to other protocol contracts\n    /// and the lending term parameters for this instance.\n    function initialize(\n        address _core,\n        LendingTermReferences calldata _refs,\n        LendingTermParams calldata _params\n    ) external {\n        // can initialize only once\n        assert(address(core()) == address(0));\n        assert(_core != address(0));\n\n        // initialize storage\n        _setCore(_core);\n        refs = _refs;\n        params = _params;\n    }\n\n    /// @notice get references of this term to other protocol contracts\n    function getReferences()\n        external\n        view\n        returns (LendingTermReferences memory)\n    {\n        return refs;\n    }\n\n    /// @notice get parameters of this term\n    function getParameters() external view returns (LendingTermParams memory) {\n        return params;\n    }\n\n    /// @notice get parameter 'collateralToken' of this term\n    function collateralToken() external view returns (address) {\n        return params.collateralToken;\n    }\n\n    /// @notice get a loan\n    function getLoan(bytes32 loanId) external view returns (Loan memory) {\n        return loans[loanId];\n    }\n\n    /// @notice outstanding borrowed amount of a loan, including interests\n    function getLoanDebt(bytes32 loanId) public view returns (uint256) {\n        Loan storage loan = loans[loanId];\n        uint256 borrowTime = loan.borrowTime;\n\n        if (borrowTime == 0) {\n            return 0;\n        }\n\n        if (loan.closeTime != 0) {\n            return 0;\n        }\n\n        if (loan.callTime != 0) {\n            return loan.callDebt;\n        }\n\n        // compute interest owed\n        uint256 borrowAmount = loan.borrowAmount;\n        uint256 interest = (borrowAmount *\n            params.interestRate *\n            (block.timestamp - borrowTime)) /\n            YEAR /\n            1e18;\n        uint256 loanDebt = borrowAmount + interest;\n        uint256 _openingFee = params.openingFee;\n        if (_openingFee != 0) {\n            loanDebt += (borrowAmount * _openingFee) / 1e18;\n        }\n        uint256 creditMultiplier = ProfitManager(refs.profitManager)\n            .creditMultiplier();\n        loanDebt = (loanDebt * loan.borrowCreditMultiplier) / creditMultiplier;\n\n        return loanDebt;\n    }\n\n    /// @notice returns true if the term has a maximum delay between partial repays\n    /// and the loan has passed the delay for partial repayments.\n    function partialRepayDelayPassed(\n        bytes32 loanId\n    ) public view returns (bool) {\n        // if no periodic partial repays are expected, always return false\n        if (params.maxDelayBetweenPartialRepay == 0) return false;\n\n        // if loan doesn't exist, return false\n        if (loans[loanId].borrowTime == 0) return false;\n\n        // if loan is closed, return false\n        if (loans[loanId].closeTime != 0) return false;\n\n        // return true if delay is passed\n        return\n            lastPartialRepay[loanId] <\n            block.timestamp - params.maxDelayBetweenPartialRepay;\n    }\n\n    /// @notice returns the maximum amount of debt that can be issued by this term\n    /// according to the current gauge allocations.\n    /// Note that the debt ceiling can be lower than the current issuance under 4 conditions :\n    /// - params.hardCap is lower than since last borrow happened\n    /// - gauge votes are fewer than when last borrow happened\n    /// - profitManager.totalBorrowedCredit() decreased since last borrow\n    /// - creditMinter.buffer() is close to being depleted\n    /// @dev this solves the following equation :\n    /// borrowAmount + issuance <=\n    /// (totalBorrowedCredit + borrowAmount) * gaugeWeight * gaugeWeightTolerance / totalWeight / 1e18\n    /// which is the formula to check debt ceiling in the borrow function.\n    /// This gives the maximum borrowable amount to achieve 100% utilization of the debt\n    /// ceiling, and if we add the current issuance to it, we get the current debt ceiling.\n    /// @param gaugeWeightDelta an hypothetical change in gauge weight\n    /// @return the maximum amount of debt that can be issued by this term\n    function debtCeiling(\n        int256 gaugeWeightDelta\n    ) public view returns (uint256) {\n        address _guildToken = refs.guildToken; // cached SLOAD\n        uint256 gaugeWeight = GuildToken(_guildToken).getGaugeWeight(\n            address(this)\n        );\n        gaugeWeight = uint256(int256(gaugeWeight) + gaugeWeightDelta);\n        uint256 gaugeType = GuildToken(_guildToken).gaugeType(address(this));\n        uint256 totalWeight = GuildToken(_guildToken).totalTypeWeight(\n            gaugeType\n        );\n        uint256 creditMinterBuffer = RateLimitedMinter(refs.creditMinter)\n            .buffer();\n        uint256 _hardCap = params.hardCap; // cached SLOAD\n        if (gaugeWeight == 0) {\n            return 0; // no gauge vote, 0 debt ceiling\n        } else if (gaugeWeight == totalWeight) {\n            // one gauge, unlimited debt ceiling\n            // returns min(hardCap, creditMinterBuffer)\n            return\n                _hardCap < creditMinterBuffer ? _hardCap : creditMinterBuffer;\n        }\n        uint256 _issuance = issuance; // cached SLOAD\n        uint256 totalBorrowedCredit = ProfitManager(refs.profitManager)\n            .totalBorrowedCredit();\n        uint256 gaugeWeightTolerance = ProfitManager(refs.profitManager)\n            .gaugeWeightTolerance();\n        if (totalBorrowedCredit == 0 && gaugeWeight != 0) {\n            // first-ever CREDIT mint on a non-zero gauge weight term\n            // does not check the relative debt ceilings\n            // returns min(hardCap, creditMinterBuffer)\n            return\n                _hardCap < creditMinterBuffer ? _hardCap : creditMinterBuffer;\n        }\n        uint256 toleratedGaugeWeight = (gaugeWeight * gaugeWeightTolerance) /\n            1e18;\n        uint256 debtCeilingBefore = (totalBorrowedCredit *\n            toleratedGaugeWeight) / totalWeight;\n        if (_issuance >= debtCeilingBefore) {\n            return debtCeilingBefore; // no more borrows allowed\n        }\n        uint256 remainingDebtCeiling = debtCeilingBefore - _issuance; // always >0\n        if (toleratedGaugeWeight >= totalWeight) {\n            // if the gauge weight is above 100% when we include tolerance,\n            // the gauge relative debt ceilings are not constraining.\n            return\n                _hardCap < creditMinterBuffer ? _hardCap : creditMinterBuffer;\n        }\n        uint256 otherGaugesWeight = totalWeight - toleratedGaugeWeight; // always >0\n        uint256 maxBorrow = (remainingDebtCeiling * totalWeight) /\n            otherGaugesWeight;\n        uint256 _debtCeiling = _issuance + maxBorrow;\n        // return min(creditMinterBuffer, hardCap, debtCeiling)\n        if (creditMinterBuffer < _debtCeiling) {\n            return creditMinterBuffer;\n        }\n        if (_hardCap < _debtCeiling) {\n            return _hardCap;\n        }\n        return _debtCeiling;\n    }\n\n    /// @notice returns the debt ceiling without change to gauge weight\n    function debtCeiling() external view returns (uint256) {\n        return debtCeiling(0);\n    }\n\n    /// @notice initiate a new loan\n    function _borrow(\n        address borrower,\n        uint256 borrowAmount,\n        uint256 collateralAmount\n    ) internal returns (bytes32 loanId) {\n        require(borrowAmount != 0, \"LendingTerm: cannot borrow 0\");\n        require(collateralAmount != 0, \"LendingTerm: cannot stake 0\");\n\n        loanId = keccak256(\n            abi.encode(borrower, address(this), block.timestamp)\n        );\n\n        // check that the loan doesn't already exist\n        require(loans[loanId].borrowTime == 0, \"LendingTerm: loan exists\");\n\n        // check that enough collateral is provided\n        uint256 creditMultiplier = ProfitManager(refs.profitManager)\n            .creditMultiplier();\n        uint256 maxBorrow = (collateralAmount *\n            params.maxDebtPerCollateralToken) / creditMultiplier;\n        require(\n            borrowAmount <= maxBorrow,\n            \"LendingTerm: not enough collateral\"\n        );\n\n        // check that enough CREDIT is borrowed\n        require(\n            borrowAmount >= ProfitManager(refs.profitManager).minBorrow(),\n            \"LendingTerm: borrow amount too low\"\n        );\n\n        // check the hardcap\n        uint256 _issuance = issuance;\n        uint256 _postBorrowIssuance = _issuance + borrowAmount;\n        require(\n            _postBorrowIssuance <= params.hardCap,\n            \"LendingTerm: hardcap reached\"\n        );\n\n        // check the debt ceiling\n        uint256 totalBorrowedCredit = ProfitManager(refs.profitManager)\n            .totalBorrowedCredit();\n        uint256 gaugeWeightTolerance = ProfitManager(refs.profitManager)\n            .gaugeWeightTolerance();\n        uint256 _debtCeiling = (GuildToken(refs.guildToken)\n            .calculateGaugeAllocation(\n                address(this),\n                totalBorrowedCredit + borrowAmount\n            ) * gaugeWeightTolerance) / 1e18;\n        if (totalBorrowedCredit == 0) {\n            // if the lending term is deprecated, `calculateGaugeAllocation` will return 0, and the borrow\n            // should revert because the debt ceiling is reached (no borrows should be allowed anymore).\n            // first borrow in the system does not check proportions of issuance, just that the term is not deprecated.\n            require(_debtCeiling != 0, \"LendingTerm: debt ceiling reached\");\n        } else {\n            require(\n                _postBorrowIssuance <= _debtCeiling,\n                \"LendingTerm: debt ceiling reached\"\n            );\n        }\n\n        // save loan in state\n        loans[loanId] = Loan({\n            borrower: borrower,\n            borrowTime: block.timestamp,\n            borrowAmount: borrowAmount,\n            borrowCreditMultiplier: creditMultiplier,\n            collateralAmount: collateralAmount,\n            caller: address(0),\n            callTime: 0,\n            callDebt: 0,\n            closeTime: 0\n        });\n        issuance = _postBorrowIssuance;\n        if (params.maxDelayBetweenPartialRepay != 0) {\n            lastPartialRepay[loanId] = block.timestamp;\n        }\n\n        // mint debt to the borrower\n        RateLimitedMinter(refs.creditMinter).mint(borrower, borrowAmount);\n\n        // pull the collateral from the borrower\n        IERC20(params.collateralToken).safeTransferFrom(\n            borrower,\n            address(this),\n            collateralAmount\n        );\n\n        // emit event\n        emit LoanOpen(\n            block.timestamp,\n            loanId,\n            borrower,\n            collateralAmount,\n            borrowAmount\n        );\n    }\n\n    /// @notice initiate a new loan\n    function borrow(\n        uint256 borrowAmount,\n        uint256 collateralAmount\n    ) external whenNotPaused returns (bytes32 loanId) {\n        loanId = _borrow(msg.sender, borrowAmount, collateralAmount);\n    }\n\n    /// @notice add collateral on an open loan.\n    /// a borrower might want to add collateral so that his position does not go underwater due to\n    /// interests growing up over time.\n    function _addCollateral(\n        address borrower,\n        bytes32 loanId,\n        uint256 collateralToAdd\n    ) internal {\n        require(collateralToAdd != 0, \"LendingTerm: cannot add 0\");\n\n        Loan storage loan = loans[loanId];\n\n        // check the loan is open\n        require(loan.borrowTime != 0, \"LendingTerm: loan not found\");\n        require(loan.closeTime == 0, \"LendingTerm: loan closed\");\n        require(loan.callTime == 0, \"LendingTerm: loan called\");\n\n        // update loan in state\n        loans[loanId].collateralAmount += collateralToAdd;\n\n        // pull the collateral from the borrower\n        IERC20(params.collateralToken).safeTransferFrom(\n            borrower,\n            address(this),\n            collateralToAdd\n        );\n\n        // emit event\n        emit LoanAddCollateral(\n            block.timestamp,\n            loanId,\n            borrower,\n            collateralToAdd\n        );\n    }\n\n    /// @notice add collateral on an open loan.\n    function addCollateral(bytes32 loanId, uint256 collateralToAdd) external {\n        _addCollateral(msg.sender, loanId, collateralToAdd);\n    }\n\n    /// @notice partially repay an open loan.\n    /// a borrower might want to partially repay debt so that his position does not go underwater\n    /// due to interests building up.\n    /// some lending terms might also impose periodic partial repayments.\n    function _partialRepay(\n        address repayer,\n        bytes32 loanId,\n        uint256 debtToRepay\n    ) internal {\n        Loan storage loan = loans[loanId];\n\n        // check the loan is open\n        uint256 borrowTime = loan.borrowTime;\n        require(borrowTime != 0, \"LendingTerm: loan not found\");\n        require(\n            borrowTime < block.timestamp,\n            \"LendingTerm: loan opened in same block\"\n        );\n        require(loan.closeTime == 0, \"LendingTerm: loan closed\");\n        require(loan.callTime == 0, \"LendingTerm: loan called\");\n\n        // compute partial repayment\n        uint256 loanDebt = getLoanDebt(loanId);\n        require(debtToRepay < loanDebt, \"LendingTerm: full repayment\");\n        uint256 percentRepaid = (debtToRepay * 1e18) / loanDebt; // [0, 1e18[\n        uint256 borrowAmount = loan.borrowAmount;\n        uint256 creditMultiplier = ProfitManager(refs.profitManager)\n            .creditMultiplier();\n        uint256 principal = (borrowAmount * loan.borrowCreditMultiplier) /\n            creditMultiplier;\n        uint256 principalRepaid = (principal * percentRepaid) / 1e18;\n        uint256 interestRepaid = debtToRepay - principalRepaid;\n        uint256 issuanceDecrease = (borrowAmount * percentRepaid) / 1e18;\n        require(\n            principalRepaid != 0 && interestRepaid != 0,\n            \"LendingTerm: repay too small\"\n        );\n        require(\n            debtToRepay >= (loanDebt * params.minPartialRepayPercent) / 1e18,\n            \"LendingTerm: repay below min\"\n        );\n        require(\n            borrowAmount - issuanceDecrease >\n                ProfitManager(refs.profitManager).minBorrow(),\n            \"LendingTerm: below min borrow\"\n        );\n\n        // update loan in state\n        loans[loanId].borrowAmount -= issuanceDecrease;\n        lastPartialRepay[loanId] = block.timestamp;\n        issuance -= issuanceDecrease;\n\n        // pull the debt from the borrower\n        CreditToken(refs.creditToken).transferFrom(\n            repayer,\n            address(this),\n            debtToRepay\n        );\n\n        // forward profit portion to the ProfitManager, burn the rest\n        CreditToken(refs.creditToken).transfer(\n            refs.profitManager,\n            interestRepaid\n        );\n        ProfitManager(refs.profitManager).notifyPnL(\n            address(this),\n            int256(interestRepaid)\n        );\n        CreditToken(refs.creditToken).burn(principalRepaid);\n        RateLimitedMinter(refs.creditMinter).replenishBuffer(principalRepaid);\n\n        // emit event\n        emit LoanPartialRepay(block.timestamp, loanId, repayer, debtToRepay);\n    }\n\n    /// @notice partially repay an open loan.\n    function partialRepay(bytes32 loanId, uint256 debtToRepay) external {\n        _partialRepay(msg.sender, loanId, debtToRepay);\n    }\n\n    /// @notice repay an open loan\n    function _repay(address repayer, bytes32 loanId) internal {\n        Loan storage loan = loans[loanId];\n\n        // check the loan is open\n        uint256 borrowTime = loan.borrowTime;\n        require(borrowTime != 0, \"LendingTerm: loan not found\");\n        require(\n            borrowTime < block.timestamp,\n            \"LendingTerm: loan opened in same block\"\n        );\n        require(loan.closeTime == 0, \"LendingTerm: loan closed\");\n        require(loan.callTime == 0, \"LendingTerm: loan called\");\n\n        // compute interest owed\n        uint256 loanDebt = getLoanDebt(loanId);\n        uint256 borrowAmount = loan.borrowAmount;\n        uint256 creditMultiplier = ProfitManager(refs.profitManager)\n            .creditMultiplier();\n        uint256 principal = (borrowAmount * loan.borrowCreditMultiplier) /\n            creditMultiplier;\n        uint256 interest = loanDebt - principal;\n\n        /// pull debt from the borrower and replenish the buffer of available debt that can be minted.\n        CreditToken(refs.creditToken).transferFrom(\n            repayer,\n            address(this),\n            loanDebt\n        );\n        if (interest != 0) {\n            // forward profit portion to the ProfitManager\n            CreditToken(refs.creditToken).transfer(\n                refs.profitManager,\n                interest\n            );\n\n            // report profit\n            ProfitManager(refs.profitManager).notifyPnL(\n                address(this),\n                int256(interest)\n            );\n        }\n\n        // burn loan principal\n        CreditToken(refs.creditToken).burn(principal);\n        RateLimitedMinter(refs.creditMinter).replenishBuffer(principal);\n\n        // close the loan\n        loan.closeTime = block.timestamp;\n        issuance -= borrowAmount;\n\n        // return the collateral to the borrower\n        IERC20(params.collateralToken).safeTransfer(\n            loan.borrower,\n            loan.collateralAmount\n        );\n\n        // emit event\n        emit LoanClose(block.timestamp, loanId, LoanCloseType.Repay, loanDebt);\n    }\n\n    /// @notice repay an open loan\n    function repay(bytes32 loanId) external {\n        _repay(msg.sender, loanId);\n    }\n\n    /// @notice call a loan, the collateral will be auctioned to repay outstanding debt.\n    /// Loans can be called only if the term has been offboarded or if a loan missed a periodic partialRepay.\n    function _call(\n        address caller,\n        bytes32 loanId,\n        address _auctionHouse\n    ) internal {\n        Loan storage loan = loans[loanId];\n\n        // check that the loan exists\n        uint256 borrowTime = loan.borrowTime;\n        require(loan.borrowTime != 0, \"LendingTerm: loan not found\");\n\n        // check that the loan is not already closed\n        require(loan.closeTime == 0, \"LendingTerm: loan closed\");\n\n        // check that the loan is not already called\n        require(loan.callTime == 0, \"LendingTerm: loan called\");\n\n        // check that the loan can be called\n        require(\n            GuildToken(refs.guildToken).isDeprecatedGauge(address(this)) ||\n                partialRepayDelayPassed(loanId),\n            \"LendingTerm: cannot call\"\n        );\n\n        // check that the loan has been running for at least 1 block\n        require(\n            borrowTime < block.timestamp,\n            \"LendingTerm: loan opened in same block\"\n        );\n\n        // update loan in state\n        uint256 loanDebt = getLoanDebt(loanId);\n        loans[loanId].callTime = block.timestamp;\n        loans[loanId].callDebt = loanDebt;\n        loans[loanId].caller = caller;\n\n        // auction the loan collateral\n        AuctionHouse(_auctionHouse).startAuction(loanId, loanDebt);\n\n        // emit event\n        emit LoanCall(block.timestamp, loanId);\n    }\n\n    /// @notice call a single loan\n    function call(bytes32 loanId) external {\n        _call(msg.sender, loanId, refs.auctionHouse);\n    }\n\n    /// @notice call a list of loans\n    function callMany(bytes32[] memory loanIds) public {\n        address _auctionHouse = refs.auctionHouse;\n        for (uint256 i = 0; i < loanIds.length; i++) {\n            _call(msg.sender, loanIds[i], _auctionHouse);\n        }\n    }\n\n    /// @notice forgive a loan, marking its debt as a total loss to the system.\n    /// The loan is closed (borrower keeps the CREDIT), and the collateral stays on the LendingTerm.\n    /// Governance can later unstuck the collateral through `emergencyAction`.\n    /// This function is made for emergencies where collateral is frozen or other reverting\n    /// conditions on collateral transfers that prevent regular repay() or call() loan closing.\n    function forgive(bytes32 loanId) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        Loan storage loan = loans[loanId];\n\n        // check that the loan exists\n        require(loan.borrowTime != 0, \"LendingTerm: loan not found\");\n\n        // check that the loan is not already closed\n        require(loan.closeTime == 0, \"LendingTerm: loan closed\");\n\n        // close the loan\n        loans[loanId].closeTime = block.timestamp;\n        issuance -= loan.borrowAmount;\n\n        // mark loan as a total loss\n        uint256 creditMultiplier = ProfitManager(refs.profitManager)\n            .creditMultiplier();\n        uint256 borrowAmount = loans[loanId].borrowAmount;\n        uint256 principal = (borrowAmount *\n            loans[loanId].borrowCreditMultiplier) / creditMultiplier;\n        int256 pnl = -int256(principal);\n        ProfitManager(refs.profitManager).notifyPnL(address(this), pnl);\n\n        // set hardcap to 0 to prevent new borrows\n        params.hardCap = 0;\n\n        // emit event\n        emit LoanClose(block.timestamp, loanId, LoanCloseType.Forgive, 0);\n    }\n\n    /// @notice callback from the auctionHouse when au auction concludes\n    function onBid(\n        bytes32 loanId,\n        address bidder,\n        uint256 collateralToBorrower,\n        uint256 collateralToBidder,\n        uint256 creditFromBidder\n    ) external {\n        // preliminary checks\n        require(msg.sender == refs.auctionHouse, \"LendingTerm: invalid caller\");\n        require(\n            loans[loanId].callTime != 0 && loans[loanId].callDebt != 0,\n            \"LendingTerm: loan not called\"\n        );\n        require(loans[loanId].closeTime == 0, \"LendingTerm: loan closed\");\n\n        // sanity check on collateral movement\n        // these should never fail for a properly implemented AuctionHouse contract\n        // collateralOut == 0 if forgive() while in auctionHouse\n        uint256 collateralOut = collateralToBorrower + collateralToBidder;\n        require(\n            collateralOut == loans[loanId].collateralAmount ||\n                collateralOut == 0,\n            \"LendingTerm: invalid collateral movements\"\n        );\n\n        // compute pnl\n        uint256 creditMultiplier = ProfitManager(refs.profitManager)\n            .creditMultiplier();\n        uint256 borrowAmount = loans[loanId].borrowAmount;\n        uint256 principal = (borrowAmount *\n            loans[loanId].borrowCreditMultiplier) / creditMultiplier;\n        int256 pnl;\n        uint256 interest;\n        if (creditFromBidder >= principal) {\n            interest = creditFromBidder - principal;\n            pnl = int256(interest);\n        } else {\n            pnl = int256(creditFromBidder) - int256(principal);\n            principal = creditFromBidder;\n            require(\n                collateralToBorrower == 0,\n                \"LendingTerm: invalid collateral movement\"\n            );\n        }\n\n        // save loan state\n        loans[loanId].closeTime = block.timestamp;\n\n        // pull credit from bidder\n        if (creditFromBidder != 0) {\n            CreditToken(refs.creditToken).transferFrom(\n                bidder,\n                address(this),\n                creditFromBidder\n            );\n        }\n\n        // burn credit principal, replenish buffer\n        if (principal != 0) {\n            CreditToken(refs.creditToken).burn(principal);\n            RateLimitedMinter(refs.creditMinter).replenishBuffer(principal);\n        }\n\n        // handle profit & losses\n        if (pnl != 0) {\n            // forward profit, if any\n            if (interest != 0) {\n                CreditToken(refs.creditToken).transfer(\n                    refs.profitManager,\n                    interest\n                );\n            }\n            ProfitManager(refs.profitManager).notifyPnL(address(this), pnl);\n        }\n\n        // decrease issuance\n        issuance -= borrowAmount;\n\n        // send collateral to borrower\n        if (collateralToBorrower != 0) {\n            IERC20(params.collateralToken).safeTransfer(\n                loans[loanId].borrower,\n                collateralToBorrower\n            );\n        }\n\n        // send collateral to bidder\n        if (collateralToBidder != 0) {\n            IERC20(params.collateralToken).safeTransfer(\n                bidder,\n                collateralToBidder\n            );\n        }\n\n        emit LoanClose(\n            block.timestamp,\n            loanId,\n            LoanCloseType.Call,\n            creditFromBidder\n        );\n    }\n\n    /// @notice set the address of the auction house.\n    /// governor-only, to allow full governance to update the auction mechanisms.\n    function setAuctionHouse(\n        address _newValue\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        // allow configuration changes only when there are no auctions in progress.\n        // updating the auction house while auctions are in progress could break the loan\n        // lifecycle, as it would prevent the former auctionHouse (that have active auctions)\n        // from reporting the result to the lending term.\n        require(\n            AuctionHouse(refs.auctionHouse).nAuctionsInProgress() == 0,\n            \"LendingTerm: auctions in progress\"\n        );\n\n        refs.auctionHouse = _newValue;\n    }\n\n    /// @notice set the hardcap of CREDIT mintable in this term.\n    /// allows to update a term's arbitrary hardcap without doing a gauge & loans migration.\n    function setHardCap(\n        uint256 _newValue\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        params.hardCap = _newValue;\n    }\n}"
    },
    {
      "filename": "src/loan/LendingTerm.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8"
    }
  ]
}