{
  "Title": "M-11: Arbitrum sequencer downtime lasting before and beyond epoch expiry prevents triggering depeg",
  "Content": "# Issue M-11: Arbitrum sequencer downtime lasting before and beyond epoch expiry prevents triggering depeg \n\nSource: https://github.com/sherlock-audit/2023-03-Y2K-judging/issues/422 \n\n## Found by \nDug, Respx, ShadowForce, berndartmueller, holyhansss, libratus, ltyu, spyrosonic10\n\n## Summary\n\nA depeg event can not be triggered if the Arbitrum sequencer went down before the epoch ends and remains down beyond the epoch expiry. Instead, the collateral vault users can unfairly end the epoch without a depeg and claim the premium payments.\n\n## Vulnerability Detail\n\nA depeg event can be triggered during an ongoing epoch by calling the `ControllerPeggedAssetV2.triggerDepeg` function. This function retrieves the latest price of the pegged asset via the `getLatestPrice` function.\n\nIf the Arbitrum sequencer is down or the grace period has not passed after the sequencer is back up, the `getLatestPrice` function reverts and the depeg event can not be triggered.\n\nIn case the sequencer went down before the epoch expired and remained down well after the epoch expired, a depeg can not be triggered, and instead, the epoch can be incorrectly ended without a depeg by calling the `ControllerPeggedAssetV2.triggerEndEpoch` function. Incorrectly, because at the time of the epoch expiry, it was not possible to trigger a depeg and hence it would be unfair to end the epoch without a depeg.\n\n## Impact\n\nA depeg event can not be triggered, and premium vault users lose out on their insurance payout, while collateral vault users can wrongfully end the epoch and claim the premium.\n\n## Code Snippet\n\n[v2/Controllers/ControllerPeggedAssetV2.sol - triggerDepeg()](https://github.com/sherlock-audit/2023-03-Y2K/blob/main/Earthquake/src/v2/Controllers/ControllerPeggedAssetV2.sol#L62)\n\n```solidity\n051: function triggerDepeg(uint256 _marketId, uint256 _epochId) public {\n052:     address[2] memory vaults = vaultFactory.getVaults(_marketId);\n053:\n054:     if (vaults[0] == address(0) || vaults[1] == address(0))\n055:         revert MarketDoesNotExist(_marketId);\n056:\n057:     IVaultV2 premiumVault = IVaultV2(vaults[0]);\n058:     IVaultV2 collateralVault = IVaultV2(vaults[1]);\n059:\n060:     if (premiumVault.epochExists(_epochId) == false) revert EpochNotExist();\n061:\n062:     int256 price = getLatestPrice(premiumVault.token());\n063:\n064:     if (int256(premiumVault.strike()) <= price)\n065:         revert PriceNotAtStrikePrice(price);\n066:\n...      // [...]\n138: }\n```\n\n[v2/Controllers/ControllerPeggedAssetV2.sol - getLatestPrice()](https://github.com/sherlock-audit/2023-03-Y2K/blob/main/Earthquake/src/v2/Controllers/ControllerPeggedAssetV2.sol#L287)\n\n```solidity\n273: function getLatestPrice(address _token) public view returns (int256) {\n274:     (\n275:         ,\n276:         /*uint80 roundId*/\n277:         int256 answer,\n278:         uint256 startedAt, /*uint256 updatedAt*/ /*uint80 answeredInRound*/\n279:         ,\n280:\n281:     ) = sequencerUptimeFeed.latestRoundData();\n282:\n283:     // Answer == 0: Sequencer is up\n284:     // Answer == 1: Sequencer is down\n285:     bool isSequencerUp = answer == 0;\n286:     if (!isSequencerUp) {\n287:         revert SequencerDown();\n288:     }\n289:\n290:     // Make sure the grace period has passed after the sequencer is back up.\n291:     uint256 timeSinceUp = block.timestamp - startedAt;\n292:     if (timeSinceUp <= GRACE_PERIOD_TIME) {\n293:         revert GracePeriodNotOver();\n294:     }\n295:\n...      // [...]\n318: }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adding an additional \"challenge\" period (with reasonable length of time) after the epoch has expired and before the epoch end can be triggered without a depeg.\n\nWithin this challenge period, anyone can claim a depeg has happened during the epoch's expiry and trigger the epoch end. By providing the Chainlink round id's for both feeds (sequencer and price) at the time of the epoch expiry (`epochEnd`), the claim can be verified to assert that the sequencer was down and the strike price was reached.\n\n\n\n## Discussion\n\n**3xHarry**\n\nWe are aware of this mechanic, however, users prefer to have the atomicity of instant settlement, this is so that users can utilize farming y2k tokens most effectively by rotating from one epoch to the next. Users are made aware of the risks when using chainlink oracles as well as the execution environment being on Arbitrum. \n\n**pauliax**\n\nEscalate for 10 USDC.\n\nI believe this should be low severity because it falls under the misbehaving of infrastructure and integrations:\n\n_**Q: In case of external protocol integrations, are the risks of an external protocol pausing or executing an emergency withdrawal acceptable? If not, Watsons will submit issues related to these situations that can harm your protocol's functionality.**\nA: [NOT ACCEPTABLE]_\n\n**sherlock-admin**\n\n > Escalate for 10 USDC.\n> \n> I believe this should be low severity because it falls under the misbehaving of infrastructure and integrations:\n> \n> _**Q: In case of external protocol integrations, are the risks of an external protocol pausing or executing an emergency withdrawal acceptable? If not, Watsons will submit issues related to these situations that can harm your protocol's functionality.**\n> A: [NOT ACCEPTABLE]_\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation rejected\n\nValid medium\nThis is a valid issue as the readme indicates that risks associated with external integrations are not acceptable. That means issues are acceptable. \n\nHowever, Sherlock acknowledges the escalator's concern about some of these issues and will consider addressing them in the next update of the judging guidelines. \n\n**sherlock-admin**\n\n> Escalation rejected\n> \n> Valid medium\n> This is a valid issue as the readme indicates that risks associated with external integrations are not acceptable. That means issues are acceptable. \n> \n> However, Sherlock acknowledges the escalator's concern about some of these issues and will consider addressing them in the next update of the judging guidelines. \n\nThis issue's escalations have been rejected!\n\nWatsons who escalated this issue will have their escalation amount deducted from their next payout.\n\n**IAm0x52**\n\nIssue has been acknowledged by sponsor\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/57",
  "Code": [
    {
      "filename": "Earthquake/src/v2/Controllers/ControllerPeggedAssetV2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {IVaultFactoryV2} from \"../interfaces/IVaultFactoryV2.sol\";\nimport {IVaultV2} from \"../interfaces/IVaultV2.sol\";\nimport \"@chainlink/interfaces/AggregatorV3Interface.sol\";\nimport \"@chainlink/interfaces/AggregatorV2V3Interface.sol\";\nimport {FixedPointMathLib} from \"@solmate/utils/FixedPointMathLib.sol\";\n\n/// @author Y2K Finance Team\n\ncontract ControllerPeggedAssetV2 {\n    using FixedPointMathLib for uint256;\n    IVaultFactoryV2 public immutable vaultFactory;\n    AggregatorV2V3Interface internal sequencerUptimeFeed;\n\n    uint16 private constant GRACE_PERIOD_TIME = 3600;\n    address public immutable treasury;\n\n    /*//////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Contract constructor\n     * @param _factory VaultFactory address\n     * @param _l2Sequencer Arbitrum sequencer address\n     * @param _treasury Treasury address\n     */\n    constructor(\n        address _factory,\n        address _l2Sequencer,\n        address _treasury\n    ) {\n        if (_factory == address(0)) revert ZeroAddress();\n\n        if (_l2Sequencer == address(0)) revert ZeroAddress();\n\n        vaultFactory = IVaultFactoryV2(_factory);\n        sequencerUptimeFeed = AggregatorV2V3Interface(_l2Sequencer);\n        treasury = _treasury;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Trigger depeg event\n     * @param _marketId Target market index\n     * @param _epochId End of epoch set for market\n     */\n    function triggerDepeg(uint256 _marketId, uint256 _epochId) public {\n        address[2] memory vaults = vaultFactory.getVaults(_marketId);\n\n        if (vaults[0] == address(0) || vaults[1] == address(0))\n            revert MarketDoesNotExist(_marketId);\n\n        IVaultV2 premiumVault = IVaultV2(vaults[0]);\n        IVaultV2 collateralVault = IVaultV2(vaults[1]);\n\n        if (premiumVault.epochExists(_epochId) == false) revert EpochNotExist();\n\n        int256 price = getLatestPrice(premiumVault.token());\n\n        if (int256(premiumVault.strike()) <= price)\n            revert PriceNotAtStrikePrice(price);\n\n        (uint40 epochStart, uint40 epochEnd, ) = premiumVault.getEpochConfig(\n            _epochId\n        );\n\n        if (uint256(epochStart) > block.timestamp) revert EpochNotStarted();\n\n        if (block.timestamp > uint256(epochEnd)) revert EpochExpired();\n\n        //require this function cannot be called twice in the same epoch for the same vault\n        if (premiumVault.epochResolved(_epochId)) revert EpochFinishedAlready();\n        if (collateralVault.epochResolved(_epochId))\n            revert EpochFinishedAlready();\n\n        // check if epoch qualifies for null epoch\n        if (\n            premiumVault.totalAssets(_epochId) == 0 ||\n            collateralVault.totalAssets(_epochId) == 0\n        ) {\n            revert VaultZeroTVL();\n        }\n\n        premiumVault.resolveEpoch(_epochId);\n        collateralVault.resolveEpoch(_epochId);\n\n        uint256 epochFee = vaultFactory.getEpochFee(_epochId);\n\n        uint256 premiumTVL = premiumVault.finalTVL(_epochId);\n        uint256 collateralTVL = collateralVault.finalTVL(_epochId);\n\n        uint256 premiumFee = calculateWithdrawalFeeValue(premiumTVL, epochFee);\n        uint256 collateralFee = calculateWithdrawalFeeValue(\n            collateralTVL,\n            epochFee\n        );\n\n        // avoid stack too deep error by avoiding local variables\n        // uint256 premiumTVLAfterFee = premiumTVL - premiumFee;\n        // uint256 collateralTVLAfterFee = collateralTVL - collateralFee;\n\n        premiumVault.setClaimTVL(_epochId, collateralTVL - collateralFee);\n        collateralVault.setClaimTVL(_epochId, premiumTVL - premiumFee);\n\n        // send fees to treasury and remaining TVL to respective counterparty vault\n        // strike price reached so premium is entitled to collateralTVL - collateralFee\n        premiumVault.sendTokens(_epochId, premiumFee, treasury);\n        premiumVault.sendTokens(\n            _epochId,\n            premiumTVL - premiumFee,\n            address(collateralVault)\n        );\n        // strike price is reached so collateral is still entitled to premiumTVL - premiumFee but looses collateralTVL\n        collateralVault.sendTokens(_epochId, collateralFee, treasury);\n        collateralVault.sendTokens(\n            _epochId,\n            collateralTVL - collateralFee,\n            address(premiumVault)\n        );\n\n        emit EpochResolved(\n            _epochId,\n            _marketId,\n            VaultTVL(\n                premiumTVL - premiumFee,\n                collateralTVL,\n                collateralTVL - collateralFee,\n                premiumTVL\n            ),\n            true,\n            block.timestamp,\n            price\n        );\n    }\n\n    /** @notice Trigger epoch end without depeg event\n     * @param _marketId Target market index\n     * @param _epochId End of epoch set for market\n     */\n    function triggerEndEpoch(uint256 _marketId, uint256 _epochId) public {\n        address[2] memory vaults = vaultFactory.getVaults(_marketId);\n\n        if (vaults[0] == address(0) || vaults[1] == address(0))\n            revert MarketDoesNotExist(_marketId);\n\n        IVaultV2 premiumVault = IVaultV2(vaults[0]);\n        IVaultV2 collateralVault = IVaultV2(vaults[1]);\n\n        if (\n            premiumVault.epochExists(_epochId) == false ||\n            collateralVault.epochExists(_epochId) == false\n        ) revert EpochNotExist();\n\n        (, uint40 epochEnd, ) = premiumVault.getEpochConfig(_epochId);\n\n        if (block.timestamp <= uint256(epochEnd)) revert EpochNotExpired();\n\n        //require this function cannot be called twice in the same epoch for the same vault\n        if (premiumVault.epochResolved(_epochId)) revert EpochFinishedAlready();\n        if (collateralVault.epochResolved(_epochId))\n            revert EpochFinishedAlready();\n\n        premiumVault.resolveEpoch(_epochId);\n        collateralVault.resolveEpoch(_epochId);\n\n        uint256 epochFee = vaultFactory.getEpochFee(_epochId);\n\n        uint256 premiumTVL = premiumVault.finalTVL(_epochId);\n        uint256 collateralTVL = collateralVault.finalTVL(_epochId);\n\n        uint256 premiumFee = calculateWithdrawalFeeValue(premiumTVL, epochFee);\n\n        uint256 premiumTVLAfterFee = premiumTVL - premiumFee;\n        uint256 collateralTVLAfterFee = collateralTVL + premiumTVLAfterFee;\n\n        // strike price is not reached so premium is entiled to 0\n        premiumVault.setClaimTVL(_epochId, 0);\n        // strike price is not reached so collateral is entitled to collateralTVL + premiumTVLAfterFee\n        collateralVault.setClaimTVL(_epochId, collateralTVLAfterFee);\n\n        // send premium fees to treasury and remaining TVL to collateral vault\n        premiumVault.sendTokens(_epochId, premiumFee, treasury);\n        // strike price reached so collateral is entitled to collateralTVLAfterFee\n        premiumVault.sendTokens(\n            _epochId,\n            premiumTVLAfterFee,\n            address(collateralVault)\n        );\n\n        emit EpochResolved(\n            _epochId,\n            _marketId,\n            VaultTVL(collateralTVLAfterFee, collateralTVL, 0, premiumTVL),\n            false,\n            block.timestamp,\n            0\n        );\n    }\n\n    /** @notice Trigger epoch invalid when one vault has 0 TVL\n     * @param _marketId Target market index\n     * @param _epochId End of epoch set for market\n     */\n    function triggerNullEpoch(uint256 _marketId, uint256 _epochId) public {\n        address[2] memory vaults = vaultFactory.getVaults(_marketId);\n\n        if (vaults[0] == address(0) || vaults[1] == address(0))\n            revert MarketDoesNotExist(_marketId);\n\n        IVaultV2 premiumVault = IVaultV2(vaults[0]);\n        IVaultV2 collateralVault = IVaultV2(vaults[1]);\n\n        if (\n            premiumVault.epochExists(_epochId) == false ||\n            collateralVault.epochExists(_epochId) == false\n        ) revert EpochNotExist();\n\n        (uint40 epochStart, , ) = premiumVault.getEpochConfig(_epochId);\n\n        if (block.timestamp < uint256(epochStart)) revert EpochNotStarted();\n\n        //require this function cannot be called twice in the same epoch for the same vault\n        if (premiumVault.epochResolved(_epochId)) revert EpochFinishedAlready();\n        if (collateralVault.epochResolved(_epochId))\n            revert EpochFinishedAlready();\n\n        //set claim TVL to final TVL if total assets are 0\n        if (premiumVault.totalAssets(_epochId) == 0) {\n            premiumVault.resolveEpoch(_epochId);\n            collateralVault.resolveEpoch(_epochId);\n\n            premiumVault.setClaimTVL(_epochId, 0);\n            collateralVault.setClaimTVL(\n                _epochId,\n                collateralVault.finalTVL(_epochId)\n            );\n\n            collateralVault.setEpochNull(_epochId);\n        } else if (collateralVault.totalAssets(_epochId) == 0) {\n            premiumVault.resolveEpoch(_epochId);\n            collateralVault.resolveEpoch(_epochId);\n\n            premiumVault.setClaimTVL(_epochId, premiumVault.finalTVL(_epochId));\n            collateralVault.setClaimTVL(_epochId, 0);\n\n            premiumVault.setEpochNull(_epochId);\n        } else revert VaultNotZeroTVL();\n\n        emit NullEpoch(\n            _epochId,\n            _marketId,\n            VaultTVL(\n                collateralVault.claimTVL(_epochId),\n                collateralVault.finalTVL(_epochId),\n                premiumVault.claimTVL(_epochId),\n                premiumVault.finalTVL(_epochId)\n            ),\n            block.timestamp\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                GETTERS\n    //////////////////////////////////////////////////////////////*/\n    /** @notice Lookup token price\n     * @param _token Target token address\n     * @return nowPrice Current token price\n     */\n    function getLatestPrice(address _token) public view returns (int256) {\n        (\n            ,\n            /*uint80 roundId*/\n            int256 answer,\n            uint256 startedAt, /*uint256 updatedAt*/ /*uint80 answeredInRound*/\n            ,\n\n        ) = sequencerUptimeFeed.latestRoundData();\n\n        // Answer == 0: Sequencer is up\n        // Answer == 1: Sequencer is down\n        bool isSequencerUp = answer == 0;\n        if (!isSequencerUp) {\n            revert SequencerDown();\n        }\n\n        // Make sure the grace period has passed after the sequencer is back up.\n        uint256 timeSinceUp = block.timestamp - startedAt;\n        if (timeSinceUp <= GRACE_PERIOD_TIME) {\n            revert GracePeriodNotOver();\n        }\n\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(\n            vaultFactory.tokenToOracle(_token)\n        );\n        (uint80 roundID, int256 price, , , uint80 answeredInRound) = priceFeed\n            .latestRoundData();\n        uint256 decimals = priceFeed.decimals();\n\n        if (decimals < 18) {\n            decimals = 10**(18 - (decimals));\n            price = price * int256(decimals);\n        } else if (decimals == 18) {\n            price = price;\n        } else {\n            decimals = 10**((decimals - 18));\n            price = price / int256(decimals);\n        }\n\n        if (price <= 0) revert OraclePriceZero();\n\n        if (answeredInRound < roundID) revert RoundIDOutdated();\n\n        return price;\n    }\n\n    /** @notice Lookup target VaultFactory address\n     * @dev need to find way to express typecasts in NatSpec\n     */\n    function getVaultFactory() external view returns (address) {\n        return address(vaultFactory);\n    }\n\n    /** @notice Calculate amount to withdraw after subtracting protocol fee\n     * @param amount Amount of tokens to withdraw\n     * @param fee Fee to be applied\n     */\n    function calculateWithdrawalFeeValue(uint256 amount, uint256 fee)\n        public\n        pure\n        returns (uint256 feeValue)\n    {\n        // 0.5% = multiply by 10000 then divide by 50\n        return amount.mulDivDown(fee, 10000);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error MarketDoesNotExist(uint256 marketId);\n    error SequencerDown();\n    error GracePeriodNotOver();\n    error ZeroAddress();\n    error EpochFinishedAlready();\n    error PriceNotAtStrikePrice(int256 price);\n    error EpochNotStarted();\n    error EpochExpired();\n    error OraclePriceZero();\n    error RoundIDOutdated();\n    error EpochNotExist();\n    error EpochNotExpired();\n    error VaultNotZeroTVL();\n    error VaultZeroTVL();\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Resolves epoch when event is emitted\n     * @param epochId market epoch ID\n     * @param marketId market ID\n     * @param tvl TVL\n     * @param strikeMet Flag if event isDisaster\n     * @param time time\n     * @param depegPrice Price that triggered depeg\n     */\n    event EpochResolved(\n        uint256 indexed epochId,\n        uint256 indexed marketId,\n        VaultTVL tvl,\n        bool strikeMet,\n        uint256 time,\n        int256 depegPrice\n    );\n\n    /** @notice Sets epoch to null when event is emitted\n     * @param epochId market epoch ID\n     * @param marketId market ID\n     * @param tvl TVL\n     * @param time timestamp\n     */\n    event NullEpoch(\n        uint256 indexed epochId,\n        uint256 indexed marketId,\n        VaultTVL tvl,\n        uint256 time\n    );\n\n    struct VaultTVL {\n        uint256 COLLAT_claimTVL;\n        uint256 COLLAT_finalTVL;\n        uint256 PREM_claimTVL;\n        uint256 PREM_finalTVL;\n    }\n}"
    },
    {
      "filename": "Earthquake/src/v2/Controllers/ControllerPeggedAssetV2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {IVaultFactoryV2} from \"../interfaces/IVaultFactoryV2.sol\";\nimport {IVaultV2} from \"../interfaces/IVaultV2.sol\";\nimport \"@chainlink/interfaces/AggregatorV3Interface.sol\";\nimport \"@chainlink/interfaces/AggregatorV2V3Interface.sol\";\nimport {FixedPointMathLib} from \"@solmate/utils/FixedPointMathLib.sol\";\n\n/// @author Y2K Finance Team\n\ncontract ControllerPeggedAssetV2 {\n    using FixedPointMathLib for uint256;\n    IVaultFactoryV2 public immutable vaultFactory;\n    AggregatorV2V3Interface internal sequencerUptimeFeed;\n\n    uint16 private constant GRACE_PERIOD_TIME = 3600;\n    address public immutable treasury;\n\n    /*//////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Contract constructor\n     * @param _factory VaultFactory address\n     * @param _l2Sequencer Arbitrum sequencer address\n     * @param _treasury Treasury address\n     */\n    constructor(\n        address _factory,\n        address _l2Sequencer,\n        address _treasury\n    ) {\n        if (_factory == address(0)) revert ZeroAddress();\n\n        if (_l2Sequencer == address(0)) revert ZeroAddress();\n\n        vaultFactory = IVaultFactoryV2(_factory);\n        sequencerUptimeFeed = AggregatorV2V3Interface(_l2Sequencer);\n        treasury = _treasury;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Trigger depeg event\n     * @param _marketId Target market index\n     * @param _epochId End of epoch set for market\n     */\n    function triggerDepeg(uint256 _marketId, uint256 _epochId) public {\n        address[2] memory vaults = vaultFactory.getVaults(_marketId);\n\n        if (vaults[0] == address(0) || vaults[1] == address(0))\n            revert MarketDoesNotExist(_marketId);\n\n        IVaultV2 premiumVault = IVaultV2(vaults[0]);\n        IVaultV2 collateralVault = IVaultV2(vaults[1]);\n\n        if (premiumVault.epochExists(_epochId) == false) revert EpochNotExist();\n\n        int256 price = getLatestPrice(premiumVault.token());\n\n        if (int256(premiumVault.strike()) <= price)\n            revert PriceNotAtStrikePrice(price);\n\n        (uint40 epochStart, uint40 epochEnd, ) = premiumVault.getEpochConfig(\n            _epochId\n        );\n\n        if (uint256(epochStart) > block.timestamp) revert EpochNotStarted();\n\n        if (block.timestamp > uint256(epochEnd)) revert EpochExpired();\n\n        //require this function cannot be called twice in the same epoch for the same vault\n        if (premiumVault.epochResolved(_epochId)) revert EpochFinishedAlready();\n        if (collateralVault.epochResolved(_epochId))\n            revert EpochFinishedAlready();\n\n        // check if epoch qualifies for null epoch\n        if (\n            premiumVault.totalAssets(_epochId) == 0 ||\n            collateralVault.totalAssets(_epochId) == 0\n        ) {\n            revert VaultZeroTVL();\n        }\n\n        premiumVault.resolveEpoch(_epochId);\n        collateralVault.resolveEpoch(_epochId);\n\n        uint256 epochFee = vaultFactory.getEpochFee(_epochId);\n\n        uint256 premiumTVL = premiumVault.finalTVL(_epochId);\n        uint256 collateralTVL = collateralVault.finalTVL(_epochId);\n\n        uint256 premiumFee = calculateWithdrawalFeeValue(premiumTVL, epochFee);\n        uint256 collateralFee = calculateWithdrawalFeeValue(\n            collateralTVL,\n            epochFee\n        );\n\n        // avoid stack too deep error by avoiding local variables\n        // uint256 premiumTVLAfterFee = premiumTVL - premiumFee;\n        // uint256 collateralTVLAfterFee = collateralTVL - collateralFee;\n\n        premiumVault.setClaimTVL(_epochId, collateralTVL - collateralFee);\n        collateralVault.setClaimTVL(_epochId, premiumTVL - premiumFee);\n\n        // send fees to treasury and remaining TVL to respective counterparty vault\n        // strike price reached so premium is entitled to collateralTVL - collateralFee\n        premiumVault.sendTokens(_epochId, premiumFee, treasury);\n        premiumVault.sendTokens(\n            _epochId,\n            premiumTVL - premiumFee,\n            address(collateralVault)\n        );\n        // strike price is reached so collateral is still entitled to premiumTVL - premiumFee but looses collateralTVL\n        collateralVault.sendTokens(_epochId, collateralFee, treasury);\n        collateralVault.sendTokens(\n            _epochId,\n            collateralTVL - collateralFee,\n            address(premiumVault)\n        );\n\n        emit EpochResolved(\n            _epochId,\n            _marketId,\n            VaultTVL(\n                premiumTVL - premiumFee,\n                collateralTVL,\n                collateralTVL - collateralFee,\n                premiumTVL\n            ),\n            true,\n            block.timestamp,\n            price\n        );\n    }\n\n    /** @notice Trigger epoch end without depeg event\n     * @param _marketId Target market index\n     * @param _epochId End of epoch set for market\n     */\n    function triggerEndEpoch(uint256 _marketId, uint256 _epochId) public {\n        address[2] memory vaults = vaultFactory.getVaults(_marketId);\n\n        if (vaults[0] == address(0) || vaults[1] == address(0))\n            revert MarketDoesNotExist(_marketId);\n\n        IVaultV2 premiumVault = IVaultV2(vaults[0]);\n        IVaultV2 collateralVault = IVaultV2(vaults[1]);\n\n        if (\n            premiumVault.epochExists(_epochId) == false ||\n            collateralVault.epochExists(_epochId) == false\n        ) revert EpochNotExist();\n\n        (, uint40 epochEnd, ) = premiumVault.getEpochConfig(_epochId);\n\n        if (block.timestamp <= uint256(epochEnd)) revert EpochNotExpired();\n\n        //require this function cannot be called twice in the same epoch for the same vault\n        if (premiumVault.epochResolved(_epochId)) revert EpochFinishedAlready();\n        if (collateralVault.epochResolved(_epochId))\n            revert EpochFinishedAlready();\n\n        premiumVault.resolveEpoch(_epochId);\n        collateralVault.resolveEpoch(_epochId);\n\n        uint256 epochFee = vaultFactory.getEpochFee(_epochId);\n\n        uint256 premiumTVL = premiumVault.finalTVL(_epochId);\n        uint256 collateralTVL = collateralVault.finalTVL(_epochId);\n\n        uint256 premiumFee = calculateWithdrawalFeeValue(premiumTVL, epochFee);\n\n        uint256 premiumTVLAfterFee = premiumTVL - premiumFee;\n        uint256 collateralTVLAfterFee = collateralTVL + premiumTVLAfterFee;\n\n        // strike price is not reached so premium is entiled to 0\n        premiumVault.setClaimTVL(_epochId, 0);\n        // strike price is not reached so collateral is entitled to collateralTVL + premiumTVLAfterFee\n        collateralVault.setClaimTVL(_epochId, collateralTVLAfterFee);\n\n        // send premium fees to treasury and remaining TVL to collateral vault\n        premiumVault.sendTokens(_epochId, premiumFee, treasury);\n        // strike price reached so collateral is entitled to collateralTVLAfterFee\n        premiumVault.sendTokens(\n            _epochId,\n            premiumTVLAfterFee,\n            address(collateralVault)\n        );\n\n        emit EpochResolved(\n            _epochId,\n            _marketId,\n            VaultTVL(collateralTVLAfterFee, collateralTVL, 0, premiumTVL),\n            false,\n            block.timestamp,\n            0\n        );\n    }\n\n    /** @notice Trigger epoch invalid when one vault has 0 TVL\n     * @param _marketId Target market index\n     * @param _epochId End of epoch set for market\n     */\n    function triggerNullEpoch(uint256 _marketId, uint256 _epochId) public {\n        address[2] memory vaults = vaultFactory.getVaults(_marketId);\n\n        if (vaults[0] == address(0) || vaults[1] == address(0))\n            revert MarketDoesNotExist(_marketId);\n\n        IVaultV2 premiumVault = IVaultV2(vaults[0]);\n        IVaultV2 collateralVault = IVaultV2(vaults[1]);\n\n        if (\n            premiumVault.epochExists(_epochId) == false ||\n            collateralVault.epochExists(_epochId) == false\n        ) revert EpochNotExist();\n\n        (uint40 epochStart, , ) = premiumVault.getEpochConfig(_epochId);\n\n        if (block.timestamp < uint256(epochStart)) revert EpochNotStarted();\n\n        //require this function cannot be called twice in the same epoch for the same vault\n        if (premiumVault.epochResolved(_epochId)) revert EpochFinishedAlready();\n        if (collateralVault.epochResolved(_epochId))\n            revert EpochFinishedAlready();\n\n        //set claim TVL to final TVL if total assets are 0\n        if (premiumVault.totalAssets(_epochId) == 0) {\n            premiumVault.resolveEpoch(_epochId);\n            collateralVault.resolveEpoch(_epochId);\n\n            premiumVault.setClaimTVL(_epochId, 0);\n            collateralVault.setClaimTVL(\n                _epochId,\n                collateralVault.finalTVL(_epochId)\n            );\n\n            collateralVault.setEpochNull(_epochId);\n        } else if (collateralVault.totalAssets(_epochId) == 0) {\n            premiumVault.resolveEpoch(_epochId);\n            collateralVault.resolveEpoch(_epochId);\n\n            premiumVault.setClaimTVL(_epochId, premiumVault.finalTVL(_epochId));\n            collateralVault.setClaimTVL(_epochId, 0);\n\n            premiumVault.setEpochNull(_epochId);\n        } else revert VaultNotZeroTVL();\n\n        emit NullEpoch(\n            _epochId,\n            _marketId,\n            VaultTVL(\n                collateralVault.claimTVL(_epochId),\n                collateralVault.finalTVL(_epochId),\n                premiumVault.claimTVL(_epochId),\n                premiumVault.finalTVL(_epochId)\n            ),\n            block.timestamp\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                GETTERS\n    //////////////////////////////////////////////////////////////*/\n    /** @notice Lookup token price\n     * @param _token Target token address\n     * @return nowPrice Current token price\n     */\n    function getLatestPrice(address _token) public view returns (int256) {\n        (\n            ,\n            /*uint80 roundId*/\n            int256 answer,\n            uint256 startedAt, /*uint256 updatedAt*/ /*uint80 answeredInRound*/\n            ,\n\n        ) = sequencerUptimeFeed.latestRoundData();\n\n        // Answer == 0: Sequencer is up\n        // Answer == 1: Sequencer is down\n        bool isSequencerUp = answer == 0;\n        if (!isSequencerUp) {\n            revert SequencerDown();\n        }\n\n        // Make sure the grace period has passed after the sequencer is back up.\n        uint256 timeSinceUp = block.timestamp - startedAt;\n        if (timeSinceUp <= GRACE_PERIOD_TIME) {\n            revert GracePeriodNotOver();\n        }\n\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(\n            vaultFactory.tokenToOracle(_token)\n        );\n        (uint80 roundID, int256 price, , , uint80 answeredInRound) = priceFeed\n            .latestRoundData();\n        uint256 decimals = priceFeed.decimals();\n\n        if (decimals < 18) {\n            decimals = 10**(18 - (decimals));\n            price = price * int256(decimals);\n        } else if (decimals == 18) {\n            price = price;\n        } else {\n            decimals = 10**((decimals - 18));\n            price = price / int256(decimals);\n        }\n\n        if (price <= 0) revert OraclePriceZero();\n\n        if (answeredInRound < roundID) revert RoundIDOutdated();\n\n        return price;\n    }\n\n    /** @notice Lookup target VaultFactory address\n     * @dev need to find way to express typecasts in NatSpec\n     */\n    function getVaultFactory() external view returns (address) {\n        return address(vaultFactory);\n    }\n\n    /** @notice Calculate amount to withdraw after subtracting protocol fee\n     * @param amount Amount of tokens to withdraw\n     * @param fee Fee to be applied\n     */\n    function calculateWithdrawalFeeValue(uint256 amount, uint256 fee)\n        public\n        pure\n        returns (uint256 feeValue)\n    {\n        // 0.5% = multiply by 10000 then divide by 50\n        return amount.mulDivDown(fee, 10000);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error MarketDoesNotExist(uint256 marketId);\n    error SequencerDown();\n    error GracePeriodNotOver();\n    error ZeroAddress();\n    error EpochFinishedAlready();\n    error PriceNotAtStrikePrice(int256 price);\n    error EpochNotStarted();\n    error EpochExpired();\n    error OraclePriceZero();\n    error RoundIDOutdated();\n    error EpochNotExist();\n    error EpochNotExpired();\n    error VaultNotZeroTVL();\n    error VaultZeroTVL();\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Resolves epoch when event is emitted\n     * @param epochId market epoch ID\n     * @param marketId market ID\n     * @param tvl TVL\n     * @param strikeMet Flag if event isDisaster\n     * @param time time\n     * @param depegPrice Price that triggered depeg\n     */\n    event EpochResolved(\n        uint256 indexed epochId,\n        uint256 indexed marketId,\n        VaultTVL tvl,\n        bool strikeMet,\n        uint256 time,\n        int256 depegPrice\n    );\n\n    /** @notice Sets epoch to null when event is emitted\n     * @param epochId market epoch ID\n     * @param marketId market ID\n     * @param tvl TVL\n     * @param time timestamp\n     */\n    event NullEpoch(\n        uint256 indexed epochId,\n        uint256 indexed marketId,\n        VaultTVL tvl,\n        uint256 time\n    );\n\n    struct VaultTVL {\n        uint256 COLLAT_claimTVL;\n        uint256 COLLAT_finalTVL;\n        uint256 PREM_claimTVL;\n        uint256 PREM_finalTVL;\n    }\n}"
    }
  ]
}