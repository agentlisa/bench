{
  "Title": "M-2: Currently auctioned NFTs can be transferred to a different address in a specific edge case",
  "Content": "# Issue M-2: Currently auctioned NFTs can be transferred to a different address in a specific edge case \n\nSource: https://github.com/sherlock-audit/2024-02-radicalxchange-judging/issues/33 \n\n## Found by \nzzykxx\n## Summary\nCurrently auctioned NFTs can be transferred to a different address in a specific edge case, leading to theft of funds.\n\n## Vulnerability Detail\nThe protocol assumes that an NFT cannot change owner while it's being auctioned, this is generally the case but there is an exception, an NFT can change owner via [mintToken()](https://github.com/sherlock-audit/2024-02-radicalxchange/blob/main/pco-art/contracts/license/StewardLicenseBase.sol#L31) while an auction is ongoing when all the following conditions apply:\n1. An NFT is added to the collection without being minted (ie. `to` set to `address(0)`).\n2. The NFT is added to the collection with the parameter `tokenInitialPeriodStartTime[]` set to a timestamp lower than `l.initialPeriodStartTime` but bigger than `0`(ie. `0 < tokenInitialPeriodStartTime[] < l.initialPeriodStartTime`).\n3. The current `block.timestamp` is in-between `tokenInitialPeriodStartTime[]` and `l.initialPeriodStartTime`.\n\nA malicious `initialBidder` can take advantage of this by:\n1. Bidding on the new added NFT via [placeBid()](https://github.com/sherlock-audit/2024-02-radicalxchange/blob/main/pco-art/contracts/auction/EnglishPeriodicAuctionInternal.sol#L286).\n2. Calling [mintToken()](https://github.com/sherlock-audit/2024-02-radicalxchange/blob/main/pco-art/contracts/license/StewardLicenseBase.sol#L31) to transfer the NFT to a different address he controls.\n3. Closing the auction via [closeAuction()](https://github.com/sherlock-audit/2024-02-radicalxchange/blob/main/pco-art/contracts/auction/EnglishPeriodicAuctionInternal.sol#L465)\n\nAt point `3.`, because the NFT owner changed, the winning bidder (ie. `initialBidder`) is not the current NFT owner anymore. This will trigger the [following line of code](https://github.com/sherlock-audit/2024-02-radicalxchange/blob/main/pco-art/contracts/auction/EnglishPeriodicAuctionInternal.sol#L499-L506):\n```solidity\nl.availableCollateral[oldBidder] += l.highestBids[tokenId][currentAuctionRound].bidAmount;\n```\n\nWhich increases the `availableCollateral` of the `oldBidder` (ie. the address that owns the NFT after point `2.`) by `bidAmount` of the highest bid. But because at the moment the highest bid was placed `initialBidder` was also the NFT owner, he only needed to transfer the `ETH` fee to the protocol instead of the whole bid amount. \n\nThe `initialBidder` is now able to extract ETH from the protocol via the address used in point `2.` by calling [withdrawCollateral()](https://github.com/sherlock-audit/2024-02-radicalxchange/blob/main/pco-art/contracts/auction/EnglishPeriodicAuctionInternal.sol#L439) while also retaining the NFT license.\n\n## Impact\nMalicious initial bidder can potentially steal ETH from the protocol in an edge case. If the `ADD_TOKEN_TO_COLLECTION_ROLE` is also malicious, it's possible to drain the protocol.\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\nDon't allow `tokenInitialPeriodStartTime[]` to be set at a timestamp before`l.initialPeriodStartTime`.\n\n\n\n## Discussion\n\n**zzykxx**\n\nEscalate\n\nNot a duplicate of #9. This issue describes a correct edge case in which a currently auctioned NFT can be transferred.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> Not a duplicate of #9. This issue describes a correct edge case in which a currently auctioned NFT can be transferred.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Hash01011122**\n\nEven I considered it unique medium as it was edge case but sponsors viewed it as duplicate of #9 as it has same root cause @gravenp anything which you would like to add?\n \n\n**St4rgarden**\n\nNot a duplicate because #9 is a non-issue.\n\n**gravenp**\n\n@Hash01011122 after @St4rgarden took another look at #33 and #9, we determined that these should NOT be duplicates. I was mistaken. Sorry. We've marked #9 invalid and @St4rgarden is working on a hardhat test to reproduce this one.\n\n**Czar102**\n\nPlanning to consider this a separate issue.\n\n@zzykxx why do you think High severity is appropriate? I'd like to know more about the likelihood of this exploit.\n\n**zzykxx**\n\n> Planning to consider this a separate issue.\n> \n> @zzykxx why do you think High severity is appropriate? I'd like to know more about the likelihood of this exploit.\n\nI submitted as high severity because a combination of malicious `initialBidder` and `ADD_TOKEN_TO_COLLECTION_ROLE` can steal funds currently in the contract. \n\nThe sponsor is stating somewhere else that `initialBidder` is a trusted role, which would make the issue invalid.\n\nHowever, the fact that the `initalBidder` or `ADD_TOKEN_TO_COLLECTION_ROLE` is a trusted role was not mentioned anywhere during the time of the audit. \nOne argument on why `initialBidder` should be considered trusted is that it has the power to mint NFTs (and to mint them to himself), and this power is given to them by the owner which is trusted according to the README. I'm not sure this implies that the `initialBidder` (and `ADD_TOKEN_TO_COLLECTION_ROLE`) are trusted to not steal funds in the contract. To me having the power of minting/wrapping NFTs (which will then be auctioned) and the power to steal funds in the contract are two different levels of trust.\n\nThis being said, I'll leave this to you and the judges as the decision on the severity mainly revolves around judging technicalities. Feel free to tag me if you need more information.\n\n\n\n\n**gravenp**\n\nWe agree that this is valid. I'm not steeped in the judging technicalities on severity either.\n\nTo attempt to clarify a bit, we're not trying to imply elsewhere that the address in `initialBidder` is trusted (just that this field is *by default* set to the artist, who is trusted, at initialization/the first auction). The `ADD_TOKEN_TO_COLLECTION_ROLE` and other admin roles are also trusted with their defined scope, but stealing funds auction funds wouldn't be in that role scope. I don't know where that nets out on likelihood so am ok ceding that determination to the judges and their experience with the contest rules.\n\n**Czar102**\n\nThis issue is certainly valid, and I would place it on the borderline Med/High, but I think Medium is appropriate given that not everyone is able to exploit this vulnerability, only few whitelisted parties.\n\n**Evert0x**\n\nPlanning to remove duplication state and assign Medium severity\n\n**Evert0x**\n\nResult:\nMedium\nUnique\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [zzykxx](https://github.com/sherlock-audit/2024-02-radicalxchange-judging/issues/33/#issuecomment-2028592239): accepted\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/191",
  "Code": [
    {
      "filename": "pco-art/contracts/license/StewardLicenseBase.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { StewardLicenseInternal } from './StewardLicenseInternal.sol';\nimport { IERC721 } from '@solidstate/contracts/interfaces/IERC721.sol';\nimport { IPeriodicAuctionReadable } from '../auction/IPeriodicAuctionReadable.sol';\n\n/**\n * @title StewardLicenseBase\n */\nabstract contract StewardLicenseBase is IERC721, StewardLicenseInternal {\n    /**\n     * @notice Trigger transfer of license\n     */\n    function triggerTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external {\n        require(\n            msg.sender == address(this),\n            'NativeStewardLicense: Trigger transfer can only be called from another facet'\n        );\n\n        _triggerTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @notice Initial bidder can mint token if it doesn't exist\n     */\n    function mintToken(address to, uint256 tokenId) external {\n        require(\n            msg.sender ==\n                IPeriodicAuctionReadable(address(this)).initialBidder(),\n            'StewardLicenseFacet: only initial bidder can mint token'\n        );\n        //slither-disable-next-line timestamp\n        require(\n            block.timestamp <\n                IPeriodicAuctionReadable(address(this))\n                    .initialPeriodStartTime(),\n            'StewardLicenseFacet: cannot mint after initial period start time'\n        );\n        require(!_exists(tokenId), 'StewardLicenseFacet: Token already exists');\n\n        _triggerTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @notice Add token to collection\n     */\n    function addTokenToCollection(\n        address to,\n        string memory tokenURI,\n        uint256 tokenInitialPeriodStartTime\n    ) external onlyRole(ADD_TOKEN_TO_COLLECTION_ROLE) {\n        _addTokenToCollection(to, tokenURI, tokenInitialPeriodStartTime);\n    }\n\n    /**\n     * @notice Add tokens to collection with to\n     */\n    function addTokensToCollection(\n        address[] memory to,\n        string[] memory tokenURIs,\n        uint256[] memory tokenInitialPeriodStartTimes\n    ) external onlyRole(ADD_TOKEN_TO_COLLECTION_ROLE) {\n        require(\n            to.length == tokenURIs.length &&\n                to.length == tokenInitialPeriodStartTimes.length,\n            'StewardLicenseFacet: input array length mismatch'\n        );\n\n        for (uint256 i = 0; i < tokenURIs.length; i++) {\n            _addTokenToCollection(\n                to[i],\n                tokenURIs[i],\n                tokenInitialPeriodStartTimes[i]\n            );\n        }\n    }\n\n    /**\n     * @notice Add tokens to collection\n     */\n    function addTokensToCollection(\n        string[] memory tokenURIs,\n        uint256[] memory tokenInitialPeriodStartTimes,\n        bool shouldMint\n    ) external onlyRole(ADD_TOKEN_TO_COLLECTION_ROLE) {\n        for (uint256 i = 0; i < tokenURIs.length; i++) {\n            address to;\n            if (shouldMint) {\n                to = _initialSteward();\n            } else {\n                to = address(0);\n            }\n            _addTokenToCollection(\n                to,\n                tokenURIs[i],\n                tokenInitialPeriodStartTimes[i]\n            );\n        }\n    }\n\n    /**\n     * @notice Add tokens to collection with baseURI\n     */\n    function addTokensWithBaseURIToCollection(\n        uint32 amount,\n        uint256 initialPeriodStartTime,\n        uint256 initialPeriodStartTimeOffset,\n        string memory baseURI,\n        bool shouldMint\n    ) external onlyRole(ADD_TOKEN_TO_COLLECTION_ROLE) {\n        for (uint32 i = 0; i < amount; i++) {\n            _addTokenWithBaseURIToCollection(\n                baseURI,\n                shouldMint,\n                initialPeriodStartTime + (initialPeriodStartTimeOffset * i)\n            );\n        }\n    }\n\n    /**\n     * @notice Get max token count\n     */\n    function maxTokenCount() external view returns (uint256) {\n        return _maxTokenCount();\n    }\n\n    /**\n     * @notice Check if token exists\n     */\n    function exists(uint256 tokenId) external view returns (bool) {\n        return _exists(tokenId);\n    }\n}"
    },
    {
      "filename": "pco-art/contracts/auction/EnglishPeriodicAuctionInternal.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { EnglishPeriodicAuctionStorage } from './EnglishPeriodicAuctionStorage.sol';\nimport { IPeriodicPCOParamsReadable } from '../pco/IPeriodicPCOParamsReadable.sol';\nimport { IStewardLicense } from '../license/IStewardLicense.sol';\nimport { IBeneficiary } from '../beneficiary/IBeneficiary.sol';\nimport { IEnglishPeriodicAuctionInternal } from './IEnglishPeriodicAuctionInternal.sol';\n\n/**\n * @title EnglishPeriodicAuctionInternal\n */\nabstract contract EnglishPeriodicAuctionInternal is\n    IEnglishPeriodicAuctionInternal\n{\n    /**\n     * @notice Initialize parameters\n     */\n    function _initializeAuction(\n        address repossessor,\n        address initialBidder,\n        uint256 initialPeriodStartTime,\n        uint256 initialPeriodStartTimeOffset,\n        uint256 startingBid,\n        uint256 auctionLengthSeconds,\n        uint256 minBidIncrement,\n        uint256 bidExtensionWindowLengthSeconds,\n        uint256 bidExtensionSeconds\n    ) internal {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        l.isInitialized = true;\n        l.initialBidder = initialBidder;\n        l.initialPeriodStartTimeOffset = initialPeriodStartTimeOffset;\n        l.initialPeriodStartTime = initialPeriodStartTime;\n        _setStartingBid(startingBid);\n        _setRepossessor(repossessor);\n        _setAuctionLengthSeconds(auctionLengthSeconds);\n        _setMinBidIncrement(minBidIncrement);\n        _setBidExtensionWindowLengthSeconds(bidExtensionWindowLengthSeconds);\n        _setBidExtensionSeconds(bidExtensionSeconds);\n    }\n\n    /**\n     * @notice Set auction parameters\n     */\n    function _setAuctionParameters(\n        address repossessor,\n        uint256 auctionLengthSeconds,\n        uint256 minBidIncrement,\n        uint256 bidExtensionWindowLengthSeconds,\n        uint256 bidExtensionSeconds,\n        uint256 startingBid\n    ) internal {\n        _setRepossessor(repossessor);\n        _setAuctionLengthSeconds(auctionLengthSeconds);\n        _setMinBidIncrement(minBidIncrement);\n        _setBidExtensionWindowLengthSeconds(bidExtensionWindowLengthSeconds);\n        _setBidExtensionSeconds(bidExtensionSeconds);\n        _setStartingBid(startingBid);\n    }\n\n    /**\n     * @notice Check if initialized\n     */\n    function _isInitialized() internal view returns (bool) {\n        return EnglishPeriodicAuctionStorage.layout().isInitialized;\n    }\n\n    /**\n     * @notice Get starting bid\n     */\n    function _startingBid() internal view returns (uint256) {\n        return EnglishPeriodicAuctionStorage.layout().startingBid;\n    }\n\n    /**\n     * @notice Get repossessor\n     */\n    function _repossessor() internal view returns (address) {\n        return EnglishPeriodicAuctionStorage.layout().repossessor;\n    }\n\n    /**\n     * @notice Set repossessor\n     */\n    function _setRepossessor(address repossessor) internal {\n        EnglishPeriodicAuctionStorage.layout().repossessor = repossessor;\n\n        emit RepossessorSet(repossessor);\n    }\n\n    /**\n     * @notice Get initial period start time\n     */\n    function _initialPeriodStartTime() internal view returns (uint256) {\n        return EnglishPeriodicAuctionStorage.layout().initialPeriodStartTime;\n    }\n\n    /**\n     * @notice Get auction length\n     */\n    function _auctionLengthSeconds() internal view returns (uint256) {\n        return EnglishPeriodicAuctionStorage.layout().auctionLengthSeconds;\n    }\n\n    /**\n     * @notice Set starting bid\n     */\n    function _setStartingBid(uint256 startingBid) internal {\n        EnglishPeriodicAuctionStorage.layout().startingBid = startingBid;\n\n        emit StartingBidSet(startingBid);\n    }\n\n    /**\n     * @notice Set auction length\n     */\n    function _setAuctionLengthSeconds(uint256 auctionLengthSeconds) internal {\n        EnglishPeriodicAuctionStorage\n            .layout()\n            .auctionLengthSeconds = auctionLengthSeconds;\n\n        emit AuctionLengthSet(auctionLengthSeconds);\n    }\n\n    /**\n     * @notice Get minimum bid increment\n     */\n    function _minBidIncrement() internal view returns (uint256) {\n        return EnglishPeriodicAuctionStorage.layout().minBidIncrement;\n    }\n\n    /**\n     * @notice Set minimum bid increment\n     */\n    function _setMinBidIncrement(uint256 minBidIncrement) internal {\n        EnglishPeriodicAuctionStorage\n            .layout()\n            .minBidIncrement = minBidIncrement;\n\n        emit MinBidIncrementSet(minBidIncrement);\n    }\n\n    /**\n     * @notice Get bid extension window length\n     */\n    function _bidExtensionWindowLengthSeconds()\n        internal\n        view\n        returns (uint256)\n    {\n        return\n            EnglishPeriodicAuctionStorage\n                .layout()\n                .bidExtensionWindowLengthSeconds;\n    }\n\n    /**\n     * @notice Set bid extension window length\n     */\n    function _setBidExtensionWindowLengthSeconds(\n        uint256 bidExtensionWindowLengthSeconds\n    ) internal {\n        EnglishPeriodicAuctionStorage\n            .layout()\n            .bidExtensionWindowLengthSeconds = bidExtensionWindowLengthSeconds;\n\n        emit BidExtensionWindowLengthSet(bidExtensionWindowLengthSeconds);\n    }\n\n    /**\n     * @notice Get bid extension\n     */\n    function _bidExtensionSeconds() internal view returns (uint256) {\n        return EnglishPeriodicAuctionStorage.layout().bidExtensionSeconds;\n    }\n\n    /**\n     * @notice Set bid extension\n     */\n    function _setBidExtensionSeconds(uint256 bidExtensionSeconds) internal {\n        EnglishPeriodicAuctionStorage\n            .layout()\n            .bidExtensionSeconds = bidExtensionSeconds;\n\n        emit BidExtensionSet(bidExtensionSeconds);\n    }\n\n    /**\n     * @notice Get initial bidder\n     */\n    function _initialBidder() internal view returns (address) {\n        return EnglishPeriodicAuctionStorage.layout().initialBidder;\n    }\n\n    /**\n     * @notice Get highest outstanding bid\n     */\n    function _highestBid(\n        uint256 tokenId,\n        uint256 round\n    ) internal view returns (Bid storage) {\n        return\n            EnglishPeriodicAuctionStorage.layout().highestBids[tokenId][round];\n    }\n\n    /**\n     * @notice Get bid for address\n     */\n    function _bidOf(\n        uint256 tokenId,\n        uint256 round,\n        address bidder\n    ) internal view returns (Bid storage) {\n        return\n            EnglishPeriodicAuctionStorage.layout().bids[tokenId][round][bidder];\n    }\n\n    /**\n     * @notice Get is auction period\n     */\n    function _isAuctionPeriod(uint256 tokenId) internal view returns (bool) {\n        if (tokenId >= IStewardLicense(address(this)).maxTokenCount()) {\n            return false;\n        }\n        //slither-disable-next-line timestamp\n        return block.timestamp >= _auctionStartTime(tokenId);\n    }\n\n    /**\n     * @notice Is token ready for transfer\n     */\n    function _isReadyForTransfer(uint256 tokenId) internal view returns (bool) {\n        if (tokenId >= IStewardLicense(address(this)).maxTokenCount()) {\n            return false;\n        }\n        //slither-disable-next-line timestamp\n        return block.timestamp >= _auctionEndTime(tokenId);\n    }\n\n    /**\n     * @notice Get current auction round\n     */\n    function _currentAuctionRound(\n        uint256 tokenId\n    ) internal view returns (uint256) {\n        return\n            EnglishPeriodicAuctionStorage.layout().currentAuctionRound[tokenId];\n    }\n\n    /**\n     * @notice Get locked collateral from all bids\n     */\n    function _lockedCollateral(\n        uint256 tokenId,\n        address bidder\n    ) internal view returns (uint256) {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        uint256 currentAuctionRound = l.currentAuctionRound[tokenId];\n        uint256 lockedCollateral = 0;\n        for (uint256 i = 0; i <= currentAuctionRound; i++) {\n            Bid storage bid = l.bids[tokenId][i][bidder];\n            lockedCollateral += bid.collateralAmount;\n        }\n\n        return lockedCollateral;\n    }\n\n    /**\n     * @notice Get available collateral\n     */\n    function _availableCollateral(\n        address bidder\n    ) internal view returns (uint256) {\n        return\n            EnglishPeriodicAuctionStorage.layout().availableCollateral[bidder];\n    }\n\n    /**\n     * @notice Place a bid\n     */\n    function _placeBid(\n        uint256 tokenId,\n        address bidder,\n        uint256 bidAmount,\n        uint256 collateralAmount\n    ) internal {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        uint256 currentAuctionRound = l.currentAuctionRound[tokenId];\n\n        Bid storage bid = l.bids[tokenId][currentAuctionRound][bidder];\n\n        // Check if higher than starting bid\n        require(\n            bidAmount >= l.startingBid,\n            'EnglishPeriodicAuction: Bid amount must be greater than or equal to starting bid'\n        );\n\n        // Check if highest bid\n        if (l.highestBids[tokenId][currentAuctionRound].bidAmount > 0) {\n            require(\n                bidAmount >=\n                    l.highestBids[tokenId][currentAuctionRound].bidAmount +\n                        l.minBidIncrement,\n                'EnglishPeriodicAuction: Bid amount must be greater than highest outstanding bid'\n            );\n        }\n\n        uint256 totalCollateralAmount = bid.collateralAmount + collateralAmount;\n\n        uint256 feeAmount;\n        address currentBidder;\n        if (IStewardLicense(address(this)).exists(tokenId)) {\n            currentBidder = IStewardLicense(address(this)).ownerOf(tokenId);\n        } else {\n            currentBidder = l.initialBidder;\n        }\n\n        if (bidder == currentBidder) {\n            // If current bidder, collateral is entire fee amount\n            feeAmount = totalCollateralAmount;\n        } else {\n            require(\n                totalCollateralAmount > bidAmount,\n                'EnglishPeriodicAuction: Collateral must be greater than current bid'\n            );\n            // If new bidder, collateral is bidAmount + fee\n            feeAmount = totalCollateralAmount - bidAmount;\n        }\n\n        require(\n            _checkBidAmount(bidAmount, feeAmount),\n            'EnglishPeriodicAuction: Incorrect bid amount'\n        );\n\n        // Save bid\n        bid.bidder = bidder;\n        bid.bidAmount = bidAmount;\n        bid.feeAmount = feeAmount;\n        bid.collateralAmount = totalCollateralAmount;\n\n        l.highestBids[tokenId][currentAuctionRound] = bid;\n\n        emit BidPlaced(tokenId, currentAuctionRound, bid.bidder, bid.bidAmount);\n\n        // Check if auction should extend\n        uint256 auctionEndTime = _auctionEndTime(tokenId);\n\n        // slither-disable-start timestamp\n        if (\n            auctionEndTime >= block.timestamp &&\n            auctionEndTime - block.timestamp <\n            _bidExtensionWindowLengthSeconds()\n        ) {\n            uint256 auctionLengthSeconds;\n            if (l.currentAuctionLength[tokenId] == 0) {\n                auctionLengthSeconds = _auctionLengthSeconds();\n            } else {\n                auctionLengthSeconds = l.currentAuctionLength[tokenId];\n            }\n            // Extend auction\n            l.currentAuctionLength[tokenId] =\n                auctionLengthSeconds +\n                _bidExtensionSeconds();\n        }\n        // slither-disable-end timestamp\n    }\n\n    /**\n     * @notice Cancel bid for current round if not highest bidder\n     */\n    function _cancelBid(\n        uint256 tokenId,\n        uint256 round,\n        address bidder\n    ) internal {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        address currentBidder;\n        if (IStewardLicense(address(this)).exists(tokenId)) {\n            currentBidder = IStewardLicense(address(this)).ownerOf(tokenId);\n        } else {\n            currentBidder = l.initialBidder;\n        }\n\n        require(\n            bidder != l.highestBids[tokenId][round].bidder,\n            'EnglishPeriodicAuction: Cannot cancel bid if highest bidder'\n        );\n\n        Bid storage bid = l.bids[tokenId][round][bidder];\n\n        require(\n            bid.collateralAmount > 0,\n            'EnglishPeriodicAuction: No bid to cancel'\n        );\n\n        // Make collateral available to withdraw\n        l.availableCollateral[bidder] += bid.collateralAmount;\n\n        // Reset collateral and bid\n        bid.collateralAmount = 0;\n        bid.bidAmount = 0;\n    }\n\n    /**\n     * @notice Cancel bids for all rounds\n     */\n    function _cancelAllBids(uint256 tokenId, address bidder) internal {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        uint256 currentAuctionRound = l.currentAuctionRound[tokenId];\n\n        for (uint256 i = 0; i <= currentAuctionRound; i++) {\n            Bid storage bid = l.bids[tokenId][i][bidder];\n\n            if (bid.collateralAmount > 0) {\n                // Make collateral available to withdraw\n                l.availableCollateral[bidder] += bid.collateralAmount;\n\n                // Reset collateral and bid\n                bid.collateralAmount = 0;\n                bid.bidAmount = 0;\n            }\n        }\n    }\n\n    /**\n     * @notice Withdraw collateral\n     */\n    function _withdrawCollateral(address bidder) internal {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        uint256 collateralAmount = l.availableCollateral[bidder];\n\n        require(\n            collateralAmount > 0,\n            'EnglishPeriodicAuction: No collateral to withdraw'\n        );\n\n        // Make collateral unavailable to withdraw\n        l.availableCollateral[bidder] = 0;\n\n        // Transfer collateral back to bidder\n        //slither-disable-next-line low-level-calls\n        (bool success, ) = bidder.call{ value: collateralAmount }('');\n        require(\n            success,\n            'EnglishPeriodicAuction: Failed to withdraw collateral'\n        );\n    }\n\n    /**\n     * @notice Close auction and trigger a transfer to the highest bidder\n     */\n    function _closeAuction(uint256 tokenId) internal {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        uint256 currentAuctionRound = l.currentAuctionRound[tokenId];\n\n        address oldBidder;\n        if (IStewardLicense(address(this)).exists(tokenId)) {\n            oldBidder = IStewardLicense(address(this)).ownerOf(tokenId);\n        } else {\n            oldBidder = l.initialBidder;\n        }\n\n        // Set lastPeriodEndTime to the end of the current auction period\n        uint256 licensePeriod = IPeriodicPCOParamsReadable(address(this))\n            .licensePeriod();\n\n        l.lastPeriodEndTime[tokenId] = block.timestamp;\n        l.currentLicensePeriod[tokenId] = licensePeriod;\n\n        if (l.highestBids[tokenId][currentAuctionRound].bidder == address(0)) {\n            // No bids were placed, transfer to repossessor\n            Bid storage repossessorBid = l.bids[tokenId][currentAuctionRound][\n                l.repossessor\n            ];\n            repossessorBid.bidAmount = 0;\n            repossessorBid.feeAmount = 0;\n            repossessorBid.collateralAmount = 0;\n            repossessorBid.bidder = l.repossessor;\n\n            l.highestBids[tokenId][currentAuctionRound] = repossessorBid;\n        } else if (\n            l.highestBids[tokenId][currentAuctionRound].bidder != oldBidder\n        ) {\n            // Transfer bid to previous bidder's collateral\n            l.availableCollateral[oldBidder] += l\n            .highestBids[tokenId][currentAuctionRound].bidAmount;\n            l.highestBids[tokenId][currentAuctionRound].collateralAmount = 0;\n            l\n            .bids[tokenId][currentAuctionRound][\n                l.highestBids[tokenId][currentAuctionRound].bidder\n            ].collateralAmount = 0;\n        } else {\n            l.highestBids[tokenId][currentAuctionRound].collateralAmount = 0;\n            l\n            .bids[tokenId][currentAuctionRound][oldBidder].collateralAmount = 0;\n        }\n\n        emit AuctionClosed(\n            tokenId,\n            currentAuctionRound,\n            l.highestBids[tokenId][currentAuctionRound].bidder,\n            oldBidder,\n            l.highestBids[tokenId][currentAuctionRound].bidAmount\n        );\n\n        // Reset auction\n        l.currentAuctionLength[tokenId] = 0;\n        l.currentAuctionRound[tokenId] = l.currentAuctionRound[tokenId] + 1;\n\n        // Transfer to highest bidder\n        IStewardLicense(address(this)).triggerTransfer(\n            oldBidder,\n            l.highestBids[tokenId][currentAuctionRound].bidder,\n            tokenId\n        );\n\n        // Distribute fee to beneficiary\n        if (l.highestBids[tokenId][currentAuctionRound].feeAmount > 0) {\n            IBeneficiary(address(this)).distribute{\n                value: l.highestBids[tokenId][currentAuctionRound].feeAmount\n            }();\n        }\n    }\n\n    /**\n     * @notice Get auction start time\n     */\n    function _auctionStartTime(\n        uint256 tokenId\n    ) internal view returns (uint256 auctionStartTime) {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        uint256 initialPeriodStartTime;\n        uint256 initialPeriodStartTimeOffset;\n        if (l.tokenInitialPeriodStartTime[tokenId] > 0) {\n            initialPeriodStartTime = l.tokenInitialPeriodStartTime[tokenId];\n            initialPeriodStartTimeOffset = 0;\n        } else {\n            initialPeriodStartTime = l.initialPeriodStartTime;\n            initialPeriodStartTimeOffset = l.initialPeriodStartTimeOffset;\n        }\n\n        if (l.lastPeriodEndTime[tokenId] > initialPeriodStartTime) {\n            // Auction starts after licensePeriod has elapsed\n            auctionStartTime =\n                l.lastPeriodEndTime[tokenId] +\n                l.currentLicensePeriod[tokenId];\n        } else {\n            // Auction starts at initial time\n            auctionStartTime =\n                initialPeriodStartTime +\n                (tokenId * initialPeriodStartTimeOffset);\n        }\n    }\n\n    /**\n     * @notice Get auction end time\n     */\n    function _auctionEndTime(\n        uint256 tokenId\n    ) internal view returns (uint256 auctionEndTime) {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        uint256 auctionLengthSeconds;\n        if (l.currentAuctionLength[tokenId] == 0) {\n            auctionLengthSeconds = _auctionLengthSeconds();\n        } else {\n            auctionLengthSeconds = l.currentAuctionLength[tokenId];\n        }\n\n        auctionEndTime = _auctionStartTime(tokenId) + auctionLengthSeconds;\n    }\n\n    /**\n     * @notice Calculate fee from bid\n     */\n    function _calculateFeeFromBid(\n        uint256 bidAmount\n    ) internal view returns (uint256) {\n        uint256 feeNumerator = IPeriodicPCOParamsReadable(address(this))\n            .feeNumerator();\n        uint256 feeDenominator = IPeriodicPCOParamsReadable(address(this))\n            .feeDenominator();\n\n        return (bidAmount * feeNumerator) / feeDenominator;\n    }\n\n    /**\n     * @notice Check that fee is within rounding error of bid amount\n     */\n    function _checkBidAmount(\n        uint256 bidAmount,\n        uint256 feeAmount\n    ) internal view returns (bool) {\n        uint256 calculatedFeeAmount = _calculateFeeFromBid(bidAmount);\n\n        return calculatedFeeAmount == feeAmount;\n    }\n}"
    },
    {
      "filename": "pco-art/contracts/license/StewardLicenseBase.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { StewardLicenseInternal } from './StewardLicenseInternal.sol';\nimport { IERC721 } from '@solidstate/contracts/interfaces/IERC721.sol';\nimport { IPeriodicAuctionReadable } from '../auction/IPeriodicAuctionReadable.sol';\n\n/**\n * @title StewardLicenseBase\n */\nabstract contract StewardLicenseBase is IERC721, StewardLicenseInternal {\n    /**\n     * @notice Trigger transfer of license\n     */\n    function triggerTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external {\n        require(\n            msg.sender == address(this),\n            'NativeStewardLicense: Trigger transfer can only be called from another facet'\n        );\n\n        _triggerTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @notice Initial bidder can mint token if it doesn't exist\n     */\n    function mintToken(address to, uint256 tokenId) external {\n        require(\n            msg.sender ==\n                IPeriodicAuctionReadable(address(this)).initialBidder(),\n            'StewardLicenseFacet: only initial bidder can mint token'\n        );\n        //slither-disable-next-line timestamp\n        require(\n            block.timestamp <\n                IPeriodicAuctionReadable(address(this))\n                    .initialPeriodStartTime(),\n            'StewardLicenseFacet: cannot mint after initial period start time'\n        );\n        require(!_exists(tokenId), 'StewardLicenseFacet: Token already exists');\n\n        _triggerTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @notice Add token to collection\n     */\n    function addTokenToCollection(\n        address to,\n        string memory tokenURI,\n        uint256 tokenInitialPeriodStartTime\n    ) external onlyRole(ADD_TOKEN_TO_COLLECTION_ROLE) {\n        _addTokenToCollection(to, tokenURI, tokenInitialPeriodStartTime);\n    }\n\n    /**\n     * @notice Add tokens to collection with to\n     */\n    function addTokensToCollection(\n        address[] memory to,\n        string[] memory tokenURIs,\n        uint256[] memory tokenInitialPeriodStartTimes\n    ) external onlyRole(ADD_TOKEN_TO_COLLECTION_ROLE) {\n        require(\n            to.length == tokenURIs.length &&\n                to.length == tokenInitialPeriodStartTimes.length,\n            'StewardLicenseFacet: input array length mismatch'\n        );\n\n        for (uint256 i = 0; i < tokenURIs.length; i++) {\n            _addTokenToCollection(\n                to[i],\n                tokenURIs[i],\n                tokenInitialPeriodStartTimes[i]\n            );\n        }\n    }\n\n    /**\n     * @notice Add tokens to collection\n     */\n    function addTokensToCollection(\n        string[] memory tokenURIs,\n        uint256[] memory tokenInitialPeriodStartTimes,\n        bool shouldMint\n    ) external onlyRole(ADD_TOKEN_TO_COLLECTION_ROLE) {\n        for (uint256 i = 0; i < tokenURIs.length; i++) {\n            address to;\n            if (shouldMint) {\n                to = _initialSteward();\n            } else {\n                to = address(0);\n            }\n            _addTokenToCollection(\n                to,\n                tokenURIs[i],\n                tokenInitialPeriodStartTimes[i]\n            );\n        }\n    }\n\n    /**\n     * @notice Add tokens to collection with baseURI\n     */\n    function addTokensWithBaseURIToCollection(\n        uint32 amount,\n        uint256 initialPeriodStartTime,\n        uint256 initialPeriodStartTimeOffset,\n        string memory baseURI,\n        bool shouldMint\n    ) external onlyRole(ADD_TOKEN_TO_COLLECTION_ROLE) {\n        for (uint32 i = 0; i < amount; i++) {\n            _addTokenWithBaseURIToCollection(\n                baseURI,\n                shouldMint,\n                initialPeriodStartTime + (initialPeriodStartTimeOffset * i)\n            );\n        }\n    }\n\n    /**\n     * @notice Get max token count\n     */\n    function maxTokenCount() external view returns (uint256) {\n        return _maxTokenCount();\n    }\n\n    /**\n     * @notice Check if token exists\n     */\n    function exists(uint256 tokenId) external view returns (bool) {\n        return _exists(tokenId);\n    }\n}"
    },
    {
      "filename": "pco-art/contracts/auction/EnglishPeriodicAuctionInternal.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { EnglishPeriodicAuctionStorage } from './EnglishPeriodicAuctionStorage.sol';\nimport { IPeriodicPCOParamsReadable } from '../pco/IPeriodicPCOParamsReadable.sol';\nimport { IStewardLicense } from '../license/IStewardLicense.sol';\nimport { IBeneficiary } from '../beneficiary/IBeneficiary.sol';\nimport { IEnglishPeriodicAuctionInternal } from './IEnglishPeriodicAuctionInternal.sol';\n\n/**\n * @title EnglishPeriodicAuctionInternal\n */\nabstract contract EnglishPeriodicAuctionInternal is\n    IEnglishPeriodicAuctionInternal\n{\n    /**\n     * @notice Initialize parameters\n     */\n    function _initializeAuction(\n        address repossessor,\n        address initialBidder,\n        uint256 initialPeriodStartTime,\n        uint256 initialPeriodStartTimeOffset,\n        uint256 startingBid,\n        uint256 auctionLengthSeconds,\n        uint256 minBidIncrement,\n        uint256 bidExtensionWindowLengthSeconds,\n        uint256 bidExtensionSeconds\n    ) internal {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        l.isInitialized = true;\n        l.initialBidder = initialBidder;\n        l.initialPeriodStartTimeOffset = initialPeriodStartTimeOffset;\n        l.initialPeriodStartTime = initialPeriodStartTime;\n        _setStartingBid(startingBid);\n        _setRepossessor(repossessor);\n        _setAuctionLengthSeconds(auctionLengthSeconds);\n        _setMinBidIncrement(minBidIncrement);\n        _setBidExtensionWindowLengthSeconds(bidExtensionWindowLengthSeconds);\n        _setBidExtensionSeconds(bidExtensionSeconds);\n    }\n\n    /**\n     * @notice Set auction parameters\n     */\n    function _setAuctionParameters(\n        address repossessor,\n        uint256 auctionLengthSeconds,\n        uint256 minBidIncrement,\n        uint256 bidExtensionWindowLengthSeconds,\n        uint256 bidExtensionSeconds,\n        uint256 startingBid\n    ) internal {\n        _setRepossessor(repossessor);\n        _setAuctionLengthSeconds(auctionLengthSeconds);\n        _setMinBidIncrement(minBidIncrement);\n        _setBidExtensionWindowLengthSeconds(bidExtensionWindowLengthSeconds);\n        _setBidExtensionSeconds(bidExtensionSeconds);\n        _setStartingBid(startingBid);\n    }\n\n    /**\n     * @notice Check if initialized\n     */\n    function _isInitialized() internal view returns (bool) {\n        return EnglishPeriodicAuctionStorage.layout().isInitialized;\n    }\n\n    /**\n     * @notice Get starting bid\n     */\n    function _startingBid() internal view returns (uint256) {\n        return EnglishPeriodicAuctionStorage.layout().startingBid;\n    }\n\n    /**\n     * @notice Get repossessor\n     */\n    function _repossessor() internal view returns (address) {\n        return EnglishPeriodicAuctionStorage.layout().repossessor;\n    }\n\n    /**\n     * @notice Set repossessor\n     */\n    function _setRepossessor(address repossessor) internal {\n        EnglishPeriodicAuctionStorage.layout().repossessor = repossessor;\n\n        emit RepossessorSet(repossessor);\n    }\n\n    /**\n     * @notice Get initial period start time\n     */\n    function _initialPeriodStartTime() internal view returns (uint256) {\n        return EnglishPeriodicAuctionStorage.layout().initialPeriodStartTime;\n    }\n\n    /**\n     * @notice Get auction length\n     */\n    function _auctionLengthSeconds() internal view returns (uint256) {\n        return EnglishPeriodicAuctionStorage.layout().auctionLengthSeconds;\n    }\n\n    /**\n     * @notice Set starting bid\n     */\n    function _setStartingBid(uint256 startingBid) internal {\n        EnglishPeriodicAuctionStorage.layout().startingBid = startingBid;\n\n        emit StartingBidSet(startingBid);\n    }\n\n    /**\n     * @notice Set auction length\n     */\n    function _setAuctionLengthSeconds(uint256 auctionLengthSeconds) internal {\n        EnglishPeriodicAuctionStorage\n            .layout()\n            .auctionLengthSeconds = auctionLengthSeconds;\n\n        emit AuctionLengthSet(auctionLengthSeconds);\n    }\n\n    /**\n     * @notice Get minimum bid increment\n     */\n    function _minBidIncrement() internal view returns (uint256) {\n        return EnglishPeriodicAuctionStorage.layout().minBidIncrement;\n    }\n\n    /**\n     * @notice Set minimum bid increment\n     */\n    function _setMinBidIncrement(uint256 minBidIncrement) internal {\n        EnglishPeriodicAuctionStorage\n            .layout()\n            .minBidIncrement = minBidIncrement;\n\n        emit MinBidIncrementSet(minBidIncrement);\n    }\n\n    /**\n     * @notice Get bid extension"
    }
  ]
}