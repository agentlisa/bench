{
  "Title": "[M-06] RabbitHoleReceiptâ€™s address might be changed therefore only manual mint will be available",
  "Content": "# Lines of code\n\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Quest.sol#L13\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Quest.sol#L44\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Quest.sol#L96-L118\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleReceipt.sol#L95-L104\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/QuestFactory.sol#L215-L229\n\n\n# Vulnerability details\n\n## Impact\nMight be impossible to claim rewards by users. And admins must distribute tokens manually and pay fee for this. On a huge amount of participants this leads to huge amount of fees. \n\n\n## Proof of Concept\n\nLet's consider ```QuestFactory```. It has:\n```solidity\n    RabbitHoleReceipt public rabbitholeReceiptContract;\n```\nWhich responsible for mint tokens for users.\n\nThen consider ```createQuest``` function. Here we pass ```rabbitholeReceiptContract``` into ```Quest```. \n\nIn ```Quest``` this field is immutable.\n\nNow lets consider next case:\n\n1) We initialized whole contracts.\n2) We created new Quest.  \n3) Next we decided to change ```rabbitholeReceiptContract``` in ```QuestFactory``` for another. To do this we call: ```setRabbitHoleReceiptContract```. And successfully changing address.\n4) Next we distribute signatures to our participants.\n5) Users starts to mint tokens. But here is a bug ```QuestFactory``` storages new  address of ```rabbitholeReceiptContract```, but ```Quest``` initialized with older one. So users successfully minted their tokens, but can't exchange them for tokens because the Quest's receipt contract know nothing about minted tokens.\n\nPossible solution here is change ```minterAddress``` in the original ```RabbitHoleReceipt``` contract and manually mint tokens by admin, but it will be too expensive and the company may lost a lot of money.\n \n\n## Tools Used\n\nManual audit\n\n## Recommended Mitigation Steps\n\nIn ```QuestFactory``` contract in the function ```mintReceipt```  the rabbitholeReceiptContract must be fetched from the quest directly.\nTo ```Quest``` Add:\n```solidity\nfunction getRabbitholeReceiptContract() public view returns(RabbitHoleReceipt) {\n    return rabbitHoleReceiptContract;\n}\n```\n\nModify ```mintReceipt``` function in ```QuestFactory``` like:\n```solidity\nfunction mintReceipt(string memory questId_, bytes32 hash_, bytes memory signature_) public {\n    ...\n    RabbitHoleReceipt rabbitholeReceiptContract = Quest(quests[questId_].questAddress).getRabbitholeReceiptContract();\n    rabbitholeReceiptContract.mint(msg.sender, questId_);\n    ...\n}\n```",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-01-rabbithole-quest-protocol-contest",
  "Code": [
    {
      "filename": "contracts/Quest.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.15;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {IQuest} from './interfaces/IQuest.sol';\nimport {RabbitHoleReceipt} from './RabbitHoleReceipt.sol';\nimport {ECDSA} from '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';\n\n/// @title Quest\n/// @author RabbitHole.gg\n/// @notice This contract is the base contract for all Quests. The Erc20Quest and Erc1155Quest contracts inherit from this contract.\ncontract Quest is Ownable, IQuest {\n    RabbitHoleReceipt public immutable rabbitHoleReceiptContract;\n    address public immutable rewardToken;\n    uint256 public immutable endTime;\n    uint256 public immutable startTime;\n    uint256 public immutable totalParticipants;\n    uint256 public immutable rewardAmountInWeiOrTokenId;\n    bool public hasStarted;\n    bool public isPaused;\n    string public questId;\n    uint256 public redeemedTokens;\n\n    mapping(uint256 => bool) private claimedList;\n\n    constructor(\n        address rewardTokenAddress_,\n        uint256 endTime_,\n        uint256 startTime_,\n        uint256 totalParticipants_,\n        uint256 rewardAmountInWeiOrTokenId_,\n        string memory questId_,\n        address receiptContractAddress_\n    ) {\n        if (endTime_ <= block.timestamp) revert EndTimeInPast();\n        if (startTime_ <= block.timestamp) revert StartTimeInPast();\n        if (endTime_ <= startTime_) revert EndTimeLessThanOrEqualToStartTime();\n        endTime = endTime_;\n        startTime = startTime_;\n        rewardToken = rewardTokenAddress_;\n        totalParticipants = totalParticipants_;\n        rewardAmountInWeiOrTokenId = rewardAmountInWeiOrTokenId_;\n        questId = questId_;\n        rabbitHoleReceiptContract = RabbitHoleReceipt(receiptContractAddress_);\n        redeemedTokens = 0;\n    }\n\n    /// @notice Starts the Quest\n    /// @dev Only the owner of the Quest can call this function\n    function start() public virtual onlyOwner {\n        isPaused = false;\n        hasStarted = true;\n    }\n\n    /// @notice Pauses the Quest\n    /// @dev Only the owner of the Quest can call this function. Also requires that the Quest has started (not by date, but by calling the start function)\n    function pause() public onlyOwner onlyStarted {\n        isPaused = true;\n    }\n\n    /// @notice Unpauses the Quest\n    /// @dev Only the owner of the Quest can call this function. Also requires that the Quest has started (not by date, but by calling the start function)\n    function unPause() public onlyOwner onlyStarted {\n        isPaused = false;\n    }\n\n    /// @notice Marks token ids as claimed\n    /// @param tokenIds_ The token ids to mark as claimed\n    function _setClaimed(uint256[] memory tokenIds_) private {\n        for (uint i = 0; i < tokenIds_.length; i++) {\n            claimedList[tokenIds_[i]] = true;\n        }\n    }\n\n    /// @notice Prevents reward withdrawal until the Quest has ended\n    modifier onlyAdminWithdrawAfterEnd() {\n        if (block.timestamp < endTime) revert NoWithdrawDuringClaim();\n        _;\n    }\n\n    /// @notice Checks if the Quest has started at the function level\n    modifier onlyStarted() {\n        if (!hasStarted) revert NotStarted();\n        _;\n    }\n\n    /// @notice Checks if quest has started both at the function level and at the start time\n    modifier onlyQuestActive() {\n        if (!hasStarted) revert NotStarted();\n        if (block.timestamp < startTime) revert ClaimWindowNotStarted();\n        _;\n    }\n\n    /// @notice Allows user to claim the rewards entitled to them\n    /// @dev User can claim based on the (unclaimed) number of tokens they own of the Quest\n    function claim() public virtual onlyQuestActive {\n        if (isPaused) revert QuestPaused();\n\n        uint[] memory tokens = rabbitHoleReceiptContract.getOwnedTokenIdsOfQuest(questId, msg.sender);\n\n        if (tokens.length == 0) revert NoTokensToClaim();\n\n        uint256 redeemableTokenCount = 0;\n        for (uint i = 0; i < tokens.length; i++) {\n            if (!isClaimed(tokens[i])) {\n                redeemableTokenCount++;\n            }\n        }\n\n        if (redeemableTokenCount == 0) revert AlreadyClaimed();\n\n        uint256 totalRedeemableRewards = _calculateRewards(redeemableTokenCount);\n        _setClaimed(tokens);\n        _transferRewards(totalRedeemableRewards);\n        redeemedTokens += redeemableTokenCount;\n\n        emit Claimed(msg.sender, totalRedeemableRewards);\n    }\n\n    /// @notice Calculate the amount of rewards\n    /// @dev This function must be implemented in the child contracts\n    function _calculateRewards(uint256 redeemableTokenCount_) internal virtual returns (uint256) {\n        revert MustImplementInChild();\n    }\n\n    /// @notice Transfer the rewards to the user\n    /// @dev This function must be implemented in the child contracts\n    /// @param amount_ The amount of rewards to transfer\n    function _transferRewards(uint256 amount_) internal virtual {\n        revert MustImplementInChild();\n    }\n\n    /// @notice Checks if a Receipt token id has been used to claim a reward\n    /// @param tokenId_ The token id to check\n    function isClaimed(uint256 tokenId_) public view returns (bool) {\n        return claimedList[tokenId_] == true;\n    }\n\n    /// @dev Returns the reward amount\n    function getRewardAmount() public view returns (uint256) {\n        return rewardAmountInWeiOrTokenId;\n    }\n\n    /// @dev Returns the reward token address\n    function getRewardToken() public view returns (address) {\n        return rewardToken;\n    }\n\n    /// @notice Allows the owner of the Quest to withdraw any remaining rewards after the Quest has ended\n    function withdrawRemainingTokens(address to_) public virtual onlyOwner onlyAdminWithdrawAfterEnd {}\n}"
    },
    {
      "filename": "contracts/Quest.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.15;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {IQuest} from './interfaces/IQuest.sol';\nimport {RabbitHoleReceipt} from './RabbitHoleReceipt.sol';\nimport {ECDSA} from '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';\n\n/// @title Quest\n/// @author RabbitHole.gg\n/// @notice This contract is the base contract for all Quests. The Erc20Quest and Erc1155Quest contracts inherit from this contract.\ncontract Quest is Ownable, IQuest {\n    RabbitHoleReceipt public immutable rabbitHoleReceiptContract;\n    address public immutable rewardToken;\n    uint256 public immutable endTime;\n    uint256 public immutable startTime;\n    uint256 public immutable totalParticipants;\n    uint256 public immutable rewardAmountInWeiOrTokenId;\n    bool public hasStarted;\n    bool public isPaused;\n    string public questId;\n    uint256 public redeemedTokens;\n\n    mapping(uint256 => bool) private claimedList;\n\n    constructor(\n        address rewardTokenAddress_,\n        uint256 endTime_,\n        uint256 startTime_,\n        uint256 totalParticipants_,\n        uint256 rewardAmountInWeiOrTokenId_,\n        string memory questId_,\n        address receiptContractAddress_\n    ) {\n        if (endTime_ <= block.timestamp) revert EndTimeInPast();\n        if (startTime_ <= block.timestamp) revert StartTimeInPast();\n        if (endTime_ <= startTime_) revert EndTimeLessThanOrEqualToStartTime();\n        endTime = endTime_;\n        startTime = startTime_;\n        rewardToken = rewardTokenAddress_;\n        totalParticipants = totalParticipants_;\n        rewardAmountInWeiOrTokenId = rewardAmountInWeiOrTokenId_;\n        questId = questId_;\n        rabbitHoleReceiptContract = RabbitHoleReceipt(receiptContractAddress_);\n        redeemedTokens = 0;\n    }\n\n    /// @notice Starts the Quest\n    /// @dev Only the owner of the Quest can call this function\n    function start() public virtual onlyOwner {\n        isPaused = false;\n        hasStarted = true;\n    }\n\n    /// @notice Pauses the Quest\n    /// @dev Only the owner of the Quest can call this function. Also requires that the Quest has started (not by date, but by calling the start function)\n    function pause() public onlyOwner onlyStarted {\n        isPaused = true;\n    }\n\n    /// @notice Unpauses the Quest\n    /// @dev Only the owner of the Quest can call this function. Also requires that the Quest has started (not by date, but by calling the start function)\n    function unPause() public onlyOwner onlyStarted {\n        isPaused = false;\n    }\n\n    /// @notice Marks token ids as claimed\n    /// @param tokenIds_ The token ids to mark as claimed\n    function _setClaimed(uint256[] memory tokenIds_) private {\n        for (uint i = 0; i < tokenIds_.length; i++) {\n            claimedList[tokenIds_[i]] = true;\n        }\n    }\n\n    /// @notice Prevents reward withdrawal until the Quest has ended\n    modifier onlyAdminWithdrawAfterEnd() {\n        if (block.timestamp < endTime) revert NoWithdrawDuringClaim();\n        _;\n    }\n\n    /// @notice Checks if the Quest has started at the function level\n    modifier onlyStarted() {\n        if (!hasStarted) revert NotStarted();\n        _;\n    }\n\n    /// @notice Checks if quest has started both at the function level and at the start time\n    modifier onlyQuestActive() {\n        if (!hasStarted) revert NotStarted();\n        if (block.timestamp < startTime) revert ClaimWindowNotStarted();\n        _;\n    }\n\n    /// @notice Allows user to claim the rewards entitled to them\n    /// @dev User can claim based on the (unclaimed) number of tokens they own of the Quest\n    function claim() public virtual onlyQuestActive {\n        if (isPaused) revert QuestPaused();\n\n        uint[] memory tokens = rabbitHoleReceiptContract.getOwnedTokenIdsOfQuest(questId, msg.sender);\n\n        if (tokens.length == 0) revert NoTokensToClaim();\n\n        uint256 redeemableTokenCount = 0;\n        for (uint i = 0; i < tokens.length; i++) {\n            if (!isClaimed(tokens[i])) {\n                redeemableTokenCount++;\n            }\n        }\n\n        if (redeemableTokenCount == 0) revert AlreadyClaimed();\n\n        uint256 totalRedeemableRewards = _calculateRewards(redeemableTokenCount);\n        _setClaimed(tokens);\n        _transferRewards(totalRedeemableRewards);\n        redeemedTokens += redeemableTokenCount;\n\n        emit Claimed(msg.sender, totalRedeemableRewards);\n    }\n\n    /// @notice Calculate the amount of rewards\n    /// @dev This function must be implemented in the child contracts\n    function _calculateRewards(uint256 redeemableTokenCount_) internal virtual returns (uint256) {\n        revert MustImplementInChild();\n    }\n\n    /// @notice Transfer the rewards to the user\n    /// @dev This function must be implemented in the child contracts\n    /// @param amount_ The amount of rewards to transfer\n    function _transferRewards(uint256 amount_) internal virtual {\n        revert MustImplementInChild();\n    }\n\n    /// @notice Checks if a Receipt token id has been used to claim a reward\n    /// @param tokenId_ The token id to check\n    function isClaimed(uint256 tokenId_) public view returns (bool) {\n        return claimedList[tokenId_] == true;\n    }\n\n    /// @dev Returns the reward amount\n    function getRewardAmount() public view returns (uint256) {\n        return rewardAmountInWeiOrTokenId;\n    }\n\n    /// @dev Returns the reward token address\n    function getRewardToken() public view returns (address) {\n        return rewardToken;\n    }\n\n    /// @notice Allows the owner of the Quest to withdraw any remaining rewards after the Quest has ended\n    function withdrawRemainingTokens(address to_) public virtual onlyOwner onlyAdminWithdrawAfterEnd {}\n}"
    },
    {
      "filename": "contracts/Quest.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.15;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {IQuest} from './interfaces/IQuest.sol';\nimport {RabbitHoleReceipt} from './RabbitHoleReceipt.sol';\nimport {ECDSA} from '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';\n\n/// @title Quest\n/// @author RabbitHole.gg\n/// @notice This contract is the base contract for all Quests. The Erc20Quest and Erc1155Quest contracts inherit from this contract.\ncontract Quest is Ownable, IQuest {\n    RabbitHoleReceipt public immutable rabbitHoleReceiptContract;\n    address public immutable rewardToken;\n    uint256 public immutable endTime;\n    uint256 public immutable startTime;\n    uint256 public immutable totalParticipants;\n    uint256 public immutable rewardAmountInWeiOrTokenId;\n    bool public hasStarted;\n    bool public isPaused;\n    string public questId;\n    uint256 public redeemedTokens;\n\n    mapping(uint256 => bool) private claimedList;\n\n    constructor(\n        address rewardTokenAddress_,\n        uint256 endTime_,\n        uint256 startTime_,\n        uint256 totalParticipants_,\n        uint256 rewardAmountInWeiOrTokenId_,\n        string memory questId_,\n        address receiptContractAddress_\n    ) {\n        if (endTime_ <= block.timestamp) revert EndTimeInPast();\n        if (startTime_ <= block.timestamp) revert StartTimeInPast();\n        if (endTime_ <= startTime_) revert EndTimeLessThanOrEqualToStartTime();\n        endTime = endTime_;\n        startTime = startTime_;\n        rewardToken = rewardTokenAddress_;\n        totalParticipants = totalParticipants_;\n        rewardAmountInWeiOrTokenId = rewardAmountInWeiOrTokenId_;\n        questId = questId_;\n        rabbitHoleReceiptContract = RabbitHoleReceipt(receiptContractAddress_);\n        redeemedTokens = 0;\n    }\n\n    /// @notice Starts the Quest\n    /// @dev Only the owner of the Quest can call this function\n    function start() public virtual onlyOwner {\n        isPaused = false;\n        hasStarted = true;\n    }\n\n    /// @notice Pauses the Quest\n    /// @dev Only the owner of the Quest can call this function. Also requires that the Quest has started (not by date, but by calling the start function)\n    function pause() public onlyOwner onlyStarted {\n        isPaused = true;\n    }\n\n    /// @notice Unpauses the Quest\n    /// @dev Only the owner of the Quest can call this function. Also requires that the Quest has started (not by date, but by calling the start function)\n    function unPause() public onlyOwner onlyStarted {\n        isPaused = false;\n    }\n\n    /// @notice Marks token ids as claimed\n    /// @param tokenIds_ The token ids to mark as claimed\n    function _setClaimed(uint256[] memory tokenIds_) private {\n        for (uint i = 0; i < tokenIds_.length; i++) {\n            claimedList[tokenIds_[i]] = true;\n        }\n    }\n\n    /// @notice Prevents reward withdrawal until the Quest has ended\n    modifier onlyAdminWithdrawAfterEnd() {\n        if (block.timestamp < endTime) revert NoWithdrawDuringClaim();\n        _;\n    }\n\n    /// @notice Checks if the Quest has started at the function level\n    modifier onlyStarted() {\n        if (!hasStarted) revert NotStarted();\n        _;\n    }\n\n    /// @notice Checks if quest has started both at the function level and at the start time\n    modifier onlyQuestActive() {\n        if (!hasStarted) revert NotStarted();\n        if (block.timestamp < startTime) revert ClaimWindowNotStarted();\n        _;\n    }\n\n    /// @notice Allows user to claim the rewards entitled to them\n    /// @dev User can claim based on the (unclaimed) number of tokens they own of the Quest\n    function claim() public virtual onlyQuestActive {\n        if (isPaused) revert QuestPaused();\n\n        uint[] memory tokens = rabbitHoleReceiptContract.getOwnedTokenIdsOfQuest(questId, msg.sender);\n\n        if (tokens.length == 0) revert NoTokensToClaim();\n\n        uint256 redeemableTokenCount = 0;\n        for (uint i = 0; i < tokens.length; i++) {\n            if (!isClaimed(tokens[i])) {\n                redeemableTokenCount++;\n            }\n        }\n\n        if (redeemableTokenCount == 0) revert AlreadyClaimed();\n\n        uint256 totalRedeemableRewards = _calculateRewards(redeemableTokenCount);\n        _setClaimed(tokens);\n        _transferRewards(totalRedeemableRewards);\n        redeemedTokens += redeemableTokenCount;\n\n        emit Claimed(msg.sender, totalRedeemableRewards);\n    }\n\n    /// @notice Calculate the amount of rewards\n    /// @dev This function must be implemented in the child contracts\n    function _calculateRewards(uint256 redeemableTokenCount_) internal virtual returns (uint256) {\n        revert MustImplementInChild();\n    }\n\n    /// @notice Transfer the rewards to the user\n    /// @dev This function must be implemented in the child contracts\n    /// @param amount_ The amount of rewards to transfer\n    function _transferRewards(uint256 amount_) internal virtual {\n        revert MustImplementInChild();\n    }\n\n    /// @notice Checks if a Receipt token id has been used to claim a reward\n    /// @param tokenId_ The token id to check\n    function isClaimed(uint256 tokenId_) public view returns (bool) {\n        return claimedList[tokenId_] == true;\n    }\n\n    /// @dev Returns the reward amount\n    function getRewardAmount() public view returns (uint256) {\n        return rewardAmountInWeiOrTokenId;\n    }\n\n    /// @dev Returns the reward token address\n    function getRewardToken() public view returns (address) {\n        return rewardToken;\n    }\n\n    /// @notice Allows the owner of the Quest to withdraw any remaining rewards after the Quest has ended\n    function withdrawRemainingTokens(address to_) public virtual onlyOwner onlyAdminWithdrawAfterEnd {}\n}"
    },
    {
      "filename": "contracts/RabbitHoleReceipt.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/interfaces/IERC2981Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol';\nimport './ReceiptRenderer.sol';\nimport './interfaces/IQuestFactory.sol';\nimport './interfaces/IQuest.sol';\n\ncontract RabbitHoleReceipt is\n    Initializable,\n    ERC721Upgradeable,\n    ERC721EnumerableUpgradeable,\n    ERC721URIStorageUpgradeable,\n    OwnableUpgradeable,\n    IERC2981Upgradeable\n{\n    event RoyaltyFeeSet(uint256 indexed royaltyFee);\n    event MinterAddressSet(address indexed minterAddress);\n\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n    CountersUpgradeable.Counter private _tokenIds;\n\n    // storage\n    mapping(uint => string) public questIdForTokenId;\n    address public royaltyRecipient;\n    address public minterAddress;\n    uint public royaltyFee;\n    mapping(uint => uint) public timestampForTokenId;\n    ReceiptRenderer public ReceiptRendererContract;\n    IQuestFactory public QuestFactoryContract;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address receiptRenderer_,\n        address royaltyRecipient_,\n        address minterAddress_,\n        uint royaltyFee_\n    ) public initializer {\n        __ERC721_init('RabbitHoleReceipt', 'RHR');\n        __ERC721URIStorage_init();\n        __Ownable_init();\n        royaltyRecipient = royaltyRecipient_;\n        minterAddress = minterAddress_;\n        royaltyFee = royaltyFee_;\n        ReceiptRendererContract = ReceiptRenderer(receiptRenderer_);\n    }\n\n    modifier onlyMinter() {\n        msg.sender == minterAddress;\n        _;\n    }\n\n    /// @dev set the receipt renderer contract\n    /// @param receiptRenderer_ the address of the receipt renderer contract\n    function setReceiptRenderer(address receiptRenderer_) public onlyOwner {\n        ReceiptRendererContract = ReceiptRenderer(receiptRenderer_);\n    }\n\n    /// @dev set the royalty recipient\n    /// @param royaltyRecipient_ the address of the royalty recipient\n    function setRoyaltyRecipient(address royaltyRecipient_) public onlyOwner {\n        royaltyRecipient = royaltyRecipient_;\n    }\n\n    /// @dev set the quest factory contract\n    /// @param questFactory_ the address of the quest factory contract\n    function setQuestFactory(address questFactory_) public onlyOwner {\n        QuestFactoryContract = IQuestFactory(questFactory_);\n    }\n\n    /// @dev set the minter address\n    /// @param minterAddress_ the address of the minter\n    function setMinterAddress(address minterAddress_) public onlyOwner {\n        minterAddress = minterAddress_;\n        emit MinterAddressSet(minterAddress_);\n    }\n\n    /// @dev set the royalty fee\n    /// @param royaltyFee_ the royalty fee\n    function setRoyaltyFee(uint256 royaltyFee_) public onlyOwner {\n        royaltyFee = royaltyFee_;\n        emit RoyaltyFeeSet(royaltyFee_);\n    }\n\n    /// @dev mint a receipt\n    /// @param to_ the address to mint to\n    /// @param questId_ the quest id\n    function mint(address to_, string memory questId_) public onlyMinter {\n        _tokenIds.increment();\n        uint newTokenID = _tokenIds.current();\n        questIdForTokenId[newTokenID] = questId_;\n        timestampForTokenId[newTokenID] = block.timestamp;\n        _safeMint(to_, newTokenID);\n    }\n\n    /// @dev get the token ids for a quest owned by an address\n    /// @param questId_ the quest id\n    /// @param claimingAddress_ the address claiming to own the tokens\n    function getOwnedTokenIdsOfQuest(\n        string memory questId_,\n        address claimingAddress_\n    ) public view returns (uint[] memory) {\n        uint msgSenderBalance = balanceOf(claimingAddress_);\n        uint[] memory tokenIdsForQuest = new uint[](msgSenderBalance);\n        uint foundTokens = 0;\n\n        for (uint i = 0; i < msgSenderBalance; i++) {\n            uint tokenId = tokenOfOwnerByIndex(claimingAddress_, i);\n            if (keccak256(bytes(questIdForTokenId[tokenId])) == keccak256(bytes(questId_))) {\n                tokenIdsForQuest[i] = tokenId;\n                foundTokens++;\n            }\n        }\n\n        uint[] memory filteredTokens = new uint[](foundTokens);\n        uint filterTokensIndexTracker = 0;\n\n        for (uint i = 0; i < msgSenderBalance; i++) {\n            if (tokenIdsForQuest[i] > 0) {\n                filteredTokens[filterTokensIndexTracker] = tokenIdsForQuest[i];\n                filterTokensIndexTracker++;\n            }\n        }\n        return filteredTokens;\n    }\n\n    /// @dev burn a receipt\n    /// @param tokenId_ the token id\n    function _burn(uint256 tokenId_) internal override(ERC721Upgradeable, ERC721URIStorageUpgradeable) {\n        super._burn(tokenId_);\n    }\n\n    /// @dev before token transfer hook, called before any token transfer\n    /// @param from_ the address from\n    /// @param to_ the address to\n    /// @param tokenId_ the token id\n    /// @param batchSize_ the batch size\n    function _beforeTokenTransfer(\n        address from_,\n        address to_,\n        uint256 tokenId_,\n        uint256 batchSize_\n    ) internal override(ERC721Upgradeable, ERC721EnumerableUpgradeable) {\n        super._beforeTokenTransfer(from_, to_, tokenId_, batchSize_);\n    }\n\n    /// @dev return the token uri, this delegates to the receipt renderer contract\n    function tokenURI(\n        uint tokenId_\n    ) public view virtual override(ERC721Upgradeable, ERC721URIStorageUpgradeable) returns (string memory) {\n        require(_exists(tokenId_), 'ERC721URIStorage: URI query for nonexistent token');\n        require(QuestFactoryContract != IQuestFactory(address(0)), 'QuestFactory not set');\n\n        string memory questId = questIdForTokenId[tokenId_];\n        (address questAddress, uint totalParticipants, ) = QuestFactoryContract.questInfo(questId);\n        IQuest questContract = IQuest(questAddress);\n\n        bool claimed = questContract.isClaimed(tokenId_);\n        uint rewardAmount = questContract.getRewardAmount();\n        address rewardAddress = questContract.getRewardToken();\n\n        return ReceiptRendererContract.generateTokenURI(tokenId_, questId, totalParticipants, claimed, rewardAmount, rewardAddress);\n    }\n\n    /// @dev See {IERC165-royaltyInfo}\n    /// @param tokenId_ the token id\n    /// @param salePrice_ the sale price\n    function royaltyInfo(\n        uint256 tokenId_,\n        uint256 salePrice_\n    ) external view override returns (address receiver, uint256 royaltyAmount) {\n        require(_exists(tokenId_), 'Nonexistent token');\n\n        uint256 royaltyPayment = (salePrice_ * royaltyFee) / 10_000;\n        return (royaltyRecipient, royaltyPayment);\n    }\n\n    /// @dev returns true if the supplied interface id is supported\n    /// @param interfaceId_ the interface id\n    function supportsInterface(\n        bytes4 interfaceId_\n    ) public view virtual override(ERC721Upgradeable, ERC721EnumerableUpgradeable, IERC165Upgradeable) returns (bool) {\n        return interfaceId_ == type(IERC2981Upgradeable).interfaceId || super.supportsInterface(interfaceId_);\n    }\n}"
    },
    {
      "filename": "contracts/QuestFactory.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.15;\n\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport {Erc20Quest} from './Erc20Quest.sol';\nimport {IQuestFactory} from './interfaces/IQuestFactory.sol';\nimport {Erc1155Quest} from './Erc1155Quest.sol';\nimport {RabbitHoleReceipt} from './RabbitHoleReceipt.sol';\nimport {OwnableUpgradeable} from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\n\n/// @title QuestFactory\n/// @author RabbitHole.gg\n/// @dev This contract is used to create quests and mint receipts\ncontract QuestFactory is Initializable, OwnableUpgradeable, AccessControlUpgradeable, IQuestFactory {\n    bytes32 public constant CREATE_QUEST_ROLE = keccak256('CREATE_QUEST_ROLE');\n    // storage vars. Insert new vars at the end to keep the storage layout the same.\n    struct Quest {\n        mapping(address => bool) addressMinted;\n        address questAddress;\n        uint totalParticipants;\n        uint numberMinted;\n    }\n\n    address public claimSignerAddress;\n    address public protocolFeeRecipient;\n    mapping(string => Quest) public quests;\n    RabbitHoleReceipt public rabbitholeReceiptContract;\n    mapping(address => bool) public rewardAllowlist;\n    uint public questFee;\n    uint public questIdCount;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    function initialize(\n        address claimSignerAddress_,\n        address rabbitholeReceiptContract_,\n        address protocolFeeRecipient_\n    ) public initializer {\n        __Ownable_init();\n        __AccessControl_init();\n        grantDefaultAdminAndCreateQuestRole(msg.sender);\n        claimSignerAddress = claimSignerAddress_;\n        rabbitholeReceiptContract = RabbitHoleReceipt(rabbitholeReceiptContract_);\n        setProtocolFeeRecipient(protocolFeeRecipient_);\n        setQuestFee(2_000);\n        questIdCount = 1;\n    }\n\n    /// @dev Create either an erc20 or erc1155 quest, only accounts with the CREATE_QUEST_ROLE can create quests\n    /// @param rewardTokenAddress_ The contract address of the reward token\n    /// @param endTime_ The end time of the quest\n    /// @param startTime_ The start time of the quest\n    /// @param totalParticipants_ The total amount of participants (accounts) the quest will have\n    /// @param rewardAmountOrTokenId_ The reward amount for an erc20 quest or the token id for an erc1155 quest\n    /// @param contractType_ The type of quest, either erc20 or erc1155\n    /// @param questId_ The id of the quest\n    /// @return address the quest contract address\n    function createQuest(\n        address rewardTokenAddress_,\n        uint256 endTime_,\n        uint256 startTime_,\n        uint256 totalParticipants_,\n        uint256 rewardAmountOrTokenId_,\n        string memory contractType_,\n        string memory questId_\n    ) public onlyRole(CREATE_QUEST_ROLE) returns (address) {\n        if (quests[questId_].questAddress != address(0)) revert QuestIdUsed();\n\n        if (keccak256(abi.encodePacked(contractType_)) == keccak256(abi.encodePacked('erc20'))) {\n            if (rewardAllowlist[rewardTokenAddress_] == false) revert RewardNotAllowed();\n\n            Erc20Quest newQuest = new Erc20Quest(\n                rewardTokenAddress_,\n                endTime_,\n                startTime_,\n                totalParticipants_,\n                rewardAmountOrTokenId_,\n                questId_,\n                address(rabbitholeReceiptContract),\n                questFee,\n                protocolFeeRecipient\n            );\n\n            emit QuestCreated(\n                msg.sender,\n                address(newQuest),\n                questId_,\n                contractType_,\n                rewardTokenAddress_,\n                endTime_,\n                startTime_,\n                totalParticipants_,\n                rewardAmountOrTokenId_\n            );\n            quests[questId_].questAddress = address(newQuest);\n            quests[questId_].totalParticipants = totalParticipants_;\n            newQuest.transferOwnership(msg.sender);\n            ++questIdCount;\n            return address(newQuest);\n        }\n\n        if (keccak256(abi.encodePacked(contractType_)) == keccak256(abi.encodePacked('erc1155'))) {\n            if (msg.sender != owner()) revert OnlyOwnerCanCreate1155Quest();\n\n            Erc1155Quest newQuest = new Erc1155Quest(\n                rewardTokenAddress_,\n                endTime_,\n                startTime_,\n                totalParticipants_,\n                rewardAmountOrTokenId_,\n                questId_,\n                address(rabbitholeReceiptContract)\n            );\n\n            emit QuestCreated(\n                msg.sender,\n                address(newQuest),\n                questId_,\n                contractType_,\n                rewardTokenAddress_,\n                endTime_,\n                startTime_,\n                totalParticipants_,\n                rewardAmountOrTokenId_\n            );\n            quests[questId_].questAddress = address(newQuest);\n            quests[questId_].totalParticipants = totalParticipants_;\n            newQuest.transferOwnership(msg.sender);\n            ++questIdCount;\n            return address(newQuest);\n        }\n\n        revert QuestTypeInvalid();\n    }\n\n    /// @dev grant the create quest role to an account\n    /// @param account_ The account to grant or revoke the create quest role to\n    /// @param canCreateQuest_ Boolean to grant or revoke the create quest role. True grants access\n    function changeCreateQuestRole(address account_, bool canCreateQuest_) public onlyOwner {\n        if (canCreateQuest_) {\n            _grantRole(CREATE_QUEST_ROLE, account_);\n        } else {\n            _revokeRole(CREATE_QUEST_ROLE, account_);\n        }\n    }\n\n    /// @dev grant the default admin role and the create quest role to the owner\n    /// @param account_ The account to grant admin and create quest roles\n    function grantDefaultAdminAndCreateQuestRole(address account_) internal {\n        _grantRole(DEFAULT_ADMIN_ROLE, account_);\n        _grantRole(CREATE_QUEST_ROLE, account_);\n    }\n\n    /// @dev set the claim signer address\n    /// @param claimSignerAddress_ The address of the claim signer\n    function setClaimSignerAddress(address claimSignerAddress_) public onlyOwner {\n        claimSignerAddress = claimSignerAddress_;\n    }\n\n    /// @dev set the protocol fee recipient\n    /// @param protocolFeeRecipient_ The address of the protocol fee recipient\n    function setProtocolFeeRecipient(address protocolFeeRecipient_) public onlyOwner {\n        if (protocolFeeRecipient_ == address(0)) revert AddressZeroNotAllowed();\n        protocolFeeRecipient = protocolFeeRecipient_;\n    }\n\n    /// @dev set the rabbithole receipt contract\n    /// @param rabbitholeReceiptContract_ The address of the rabbithole receipt contract\n    function setRabbitHoleReceiptContract(address rabbitholeReceiptContract_) public onlyOwner {\n        rabbitholeReceiptContract = RabbitHoleReceipt(rabbitholeReceiptContract_);\n    }\n\n    /// @dev set or remave a contract address to be used as a reward\n    /// @param rewardAddress_ The contract address to set\n    /// @param allowed_ Whether the contract address is allowed or not\n    function setRewardAllowlistAddress(address rewardAddress_, bool allowed_) public onlyOwner {\n        rewardAllowlist[rewardAddress_] = allowed_;\n    }\n\n    /// @dev set the quest fee\n    /// @notice the quest fee should be in Basis Point units: https://www.investopedia.com/terms/b/basispoint.asp\n    /// @param questFee_ The quest fee value"
    }
  ]
}