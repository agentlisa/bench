{
  "Title": "Missing Gap Between Borrow LTV and Liquidation Threshold",
  "Content": "The protocol does not implement a gap between the LTV ratio at which borrowers are allowed to borrow and the liquidation threshold at which liquidation can be executed. This means that it is possible to borrow at the very edge of liquidation and be liquidated with a slight price change.\n\n\nThis opens the surface for an attack that could drain the vault of available assets by monitoring price updates. In case the price change is significant enough, the attacker could profit from the change by socializing the debt. When a user becomes eligible for liquidation, a third-party liquidator is rewarded for processing the repayment of their debt with a bonus. This bonus depends on the user’s health score, and as the user’s health score declines, the bonus grows.\n\n\nThis means that a user’s health score is lowered after liquidation if the bonus exceeds the relative over-collateralization of the position. For instance, if a user's position is 10% over-collateralized but the bonus is 11%, then the user’s health score declines after liquidation. This scenario allows an attacker, in case of a market stress situation where the price changes significantly, to front run the price change either by monitoring the mempool or through compatible oracles where prices can be updated by anyone like [Pyth](https://docs.pyth.network/price-feeds/api-reference/evm/update-price-feeds) or [Redstone](https://github.com/euler-xyz/euler-price-oracle/blob/master/src/adapter/redstone/RedstoneCoreOracle.sol#L70). The attacker could borrow assets, allow the price change, and then liquidate themselves, retrieving all the collateral and profiting by creating bad debt for the protocol. This [Proof of Concept](https://gist.github.com/lucyoa/8b684a3a5d54e6d12f6141d0a7abd4db) was created to illustrate the attack.\n\n\nConsider introducing a gap between the borrow LTV ratio and the liquidation threshold to prevent borrowers from borrowing assets at an LTV ratio close to liquidation. This gap should be flexible enough to accommodate both highly volatile and barely volatile assets. Specifically, the gap should be wider for high-volatility assets and narrower for low-volatility assets.\n\n\n***Update:** Resolved in [pull request #191](https://github.com/euler-xyz/euler-vault-kit/pull/191) of the [euler-vault-kit](https://github.com/euler-xyz/euler-vault-kit/) repository and [pull request #157](https://github.com/euler-xyz/ethereum-vault-connector/pull/157) of the [ethereum-vault-connector](https://github.com/euler-xyz/ethereum-vault-connector/) repository. The Euler team stated:*\n\n\n\n> *We have made a set of 3 changes to the liquidation system in order to mitigate the issues discovered by our auditors.*\n> \n> \n> *The first issue raised is related to the \"Counterproductive Incentives\" issue described by OpenZeppelin in their [2019 Compound audit](https://blog.openzeppelin.com/compound-audit). Liquidation systems that incentivise liquidators with extra collateral value as a bonus (or discount) can, in some circumstances, leave violators *more* unhealthy than they were pre-liquidation. In the Euler system, the discount is proportional to how unhealthy the user is, which means that in these cases, a liquidator may improve their total yield by performing many small liquidations, rather than one large liquidation. Each smaller liquidation will decrease the user's health and therefore increase their discount for subsequent liquidations, up until the maximum liquidation discount is reached. As described in our [Dutch Liquidation Analysis](https://docs.euler.finance/Dutch_Liquidation_Analysis.pdf) research paper, this scenario can be avoided by selecting an appropriately low maximum discount factor.*\n> \n> \n> *Change 1: With this in mind, we have added EVK functionality that allows governors to configure the vault's maximum discount factor. In many cases, governors will compute an appropriate maximum discount based on the highest configured LTV for the vault, although there may be other considerations involved. A governor must specify a value for this parameter, otherwise the liquidation system will not function properly.*\n> \n> \n> *The second issue raised is a general observation that price manipulation can be used to attack lending markets, and that some of the oracles we would like to support have special challenges. In particular, pull-based oracles like Pyth and Redstone provide more flexibility to attackers because they can typically choose to use any published prices within an N-minute window. For example, an attacker may be monitoring prices off-chain, waiting for a large decline in the price of a vault's collateral asset (or, equivalently, a large increase in the price of the liability asset). If the decline is sufficiently large, the attacker will search the previous N-minutes of prices and select the pair with the largest difference. The attacker will then submit a transaction that performs the following attack:*\n> \n> \n> * *Updates the oracle with the old price*\n> * *Deposits collateral and borrows as much as possible*\n> * *Updates the oracle with the new price, causing the position to become very unhealthy*\n> * *Liquidates the position from another separate account, leaving bad debt. This bad debt corresponds to profit from the attack at the expense of the vault's depositors*\n> \n> \n> *Although impossible to solve in the general case, to reduce the impact of this issue we have have made two modifications to the EVK:*\n> \n> \n> *Change 2: We now allow the governor to configure separate borrowing and liquidation LTVs. This requires the attacker to find correspondingly larger price jumps.*\n> \n> \n> *Change 3: We have added a \"cool-off period\" wherein an account cannot be liquidated. Cool-off periods begin once an account has successfully passed an account status check, and last a governor-configurable number of seconds. By setting a non-zero cool-off period, accounts cannot be liquidated inside a block where they were previously healthy.*\n> \n> \n> *The consequence of this is that the attack described above can no longer be done in an entirely risk-free manner. The position needs to be set up in one block but liquidated in a following block, potentially opening up the opportunity for other unrelated parties to perform the liquidation instead of the attacker. Additionally, such attacks cannot be financed with flash loans. As well as price-oracle related attacks, this protection may also reduce the impact of future unknown protocol attacks.*\n> \n> \n> *More generally, the cool-off period allows a vault creator to express a minimum-expected liveness period for a particular chain. If the maximum possible censorship time can be estimated, the cool-off period can be configured larger than this, with the trade-off being that legitimate liquidations of new positions may be delayed by this period of time.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "src/adapter/redstone/RedstoneCoreOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {RedstoneDefaultsLib} from \"@redstone/evm-connector/core/RedstoneDefaultsLib.sol\";\nimport {PrimaryProdDataServiceConsumerBase} from\n    \"@redstone/evm-connector/data-services/PrimaryProdDataServiceConsumerBase.sol\";\nimport {BaseAdapter, Errors, IPriceOracle} from \"src/adapter/BaseAdapter.sol\";\nimport {ScaleUtils, Scale} from \"src/lib/ScaleUtils.sol\";\n\n/// @title RedstoneCoreOracle\n/// @custom:security-contact security@euler.xyz\n/// @author Euler Labs (https://www.eulerlabs.com/)\n/// @notice Adapter for Redstone pull-based price feeds.\ncontract RedstoneCoreOracle is PrimaryProdDataServiceConsumerBase, BaseAdapter {\n    /// @notice Struct holding information about the latest price.\n    struct Cache {\n        /// @notice The Redstone price.\n        uint208 price;\n        /// @notice The timestamp contained within the price data packages.\n        uint48 priceTimestamp;\n    }\n\n    /// @notice The maximum permitted value for `maxStaleness`.\n    uint256 internal constant MAX_STALENESS_UPPER_BOUND = 5 minutes;\n    /// @inheritdoc IPriceOracle\n    string public constant name = \"RedstoneCoreOracle\";\n    /// @notice The address of the base asset corresponding to the feed.\n    address public immutable base;\n    /// @notice The address of the quote asset corresponding to the feed.\n    address public immutable quote;\n    /// @notice The identifier of the price feed.\n    /// @dev See https://app.redstone.finance/#/app/data-services/redstone-primary-prod\n    bytes32 public immutable feedId;\n    /// @notice The decimals of the Redstone price feed.\n    /// @dev Redstone price feeds have 8 decimals by default, however certain exceptions exist.\n    uint8 public immutable feedDecimals;\n    /// @notice The maximum allowed age of the Redstone price.\n    /// @dev Compares `block.timestamp` against the timestamp of the Redstone data package.\n    uint256 public immutable maxStaleness;\n    /// @notice The scale factors used for decimal conversions.\n    Scale internal immutable scale;\n    /// @notice The last updated Redstone price and its timestamp.\n    /// @dev The cache is updated in `updatePrice`.\n    Cache public cache;\n\n    /// @notice The cache timestamp was updated.\n    /// @param price The Redstone price.\n    /// @param priceTimestamp The timestamp contained within the price data packages.\n    event CacheUpdated(uint256 price, uint256 priceTimestamp);\n\n    /// @notice Deploy a RedstoneCoreOracle.\n    /// @param _base The address of the base asset corresponding to the feed.\n    /// @param _quote The address of the quote asset corresponding to the feed.\n    /// @param _feedId The identifier of the price feed.\n    /// @param _feedDecimals The decimals of the price feed.\n    /// @param _maxStaleness The maximum allowed age of the Redstone price in `updatePrice`.\n    /// @dev Since Redstone prices are verified locally, callers can pass data up to `maxStaleness` seconds old.\n    /// If `maxStaleness` is too short, the update transaction may revert.\n    constructor(address _base, address _quote, bytes32 _feedId, uint8 _feedDecimals, uint256 _maxStaleness) {\n        if (_maxStaleness > MAX_STALENESS_UPPER_BOUND) revert Errors.PriceOracle_InvalidConfiguration();\n\n        base = _base;\n        quote = _quote;\n        feedId = _feedId;\n        feedDecimals = _feedDecimals;\n        maxStaleness = _maxStaleness;\n        uint8 baseDecimals = _getDecimals(base);\n        uint8 quoteDecimals = _getDecimals(quote);\n        scale = ScaleUtils.calcScale(baseDecimals, quoteDecimals, _feedDecimals);\n    }\n\n    /// @notice Ingest a Redstone payload, decode and verify it, and cache the price in storage.\n    /// @param timestamp The expected timestamp of the Redstone payload. All data packages must have this timestamp.\n    /// @dev Redstone payload must be appended at the end of the abi-encoded calldata to this function.\n    /// Decoding and validation inherited from `PrimaryProdDataServiceConsumerBase`.\n    /// The price timestamp must lie in the defined acceptance range relative to `block.timestamp`.\n    /// Note: The Redstone SDK allows the price timestamp to be up to 1 minute in the future.\n    function updatePrice(uint48 timestamp) external {\n        // The cache can only be updated if it has a more recent timestamp.\n        Cache memory _cache = cache;\n        if (timestamp <= _cache.priceTimestamp) return; // Do not revert to avoid DoS attacks.\n\n        if (block.timestamp > timestamp) {\n            // Verify that the timestamp is not too stale.\n            uint256 staleness = block.timestamp - timestamp;\n            if (staleness > maxStaleness) {\n                revert Errors.PriceOracle_TooStale(staleness, maxStaleness);\n            }\n        } else if (timestamp - block.timestamp > RedstoneDefaultsLib.DEFAULT_MAX_DATA_TIMESTAMP_AHEAD_SECONDS) {\n            // Verify that the timestamp is not too long in the future (1 min). Redstone SDK explicitly allows this.\n            revert Errors.PriceOracle_InvalidAnswer();\n        }\n\n        // Optimistically update the price timestamp.\n        cache = Cache({price: _cache.price, priceTimestamp: timestamp});\n\n        // Calls `validateTimestamp` for every package, comparing the extracted timestamp against the price timestamp.\n        uint256 price = getOracleNumericValueFromTxMsg(feedId);\n        if (price == 0) revert Errors.PriceOracle_InvalidAnswer();\n        if (price > type(uint208).max) revert Errors.PriceOracle_Overflow();\n        cache = Cache({price: uint208(price), priceTimestamp: timestamp});\n        emit CacheUpdated(price, timestamp);\n    }\n\n    /// @notice Validate the timestamp of a Redstone signed price data package.\n    /// @param timestampMillis Data package timestamp in milliseconds.\n    /// @dev Internally called in `updatePrice` for every signed data package in the payload.\n    function validateTimestamp(uint256 timestampMillis) public view virtual override {\n        uint256 timestamp = timestampMillis / 1000;\n        if (timestamp != cache.priceTimestamp) revert Errors.PriceOracle_InvalidAnswer();\n    }\n\n    /// @notice Get the quote from the Redstone feed.\n    /// @param inAmount The amount of `base` to convert.\n    /// @param _base The token that is being priced.\n    /// @param _quote The token that is the unit of account.\n    /// @return The converted amount using the Redstone feed.\n    function _getQuote(uint256 inAmount, address _base, address _quote) internal view override returns (uint256) {\n        bool inverse = ScaleUtils.getDirectionOrRevert(_base, base, _quote, quote);\n\n        Cache memory _cache = cache;\n        if (block.timestamp > _cache.priceTimestamp) {\n            // No need to check price timestamps in the future as they can only get more recent with time.\n            uint256 priceStaleness = block.timestamp - _cache.priceTimestamp;\n            if (priceStaleness > maxStaleness) {\n                revert Errors.PriceOracle_TooStale(priceStaleness, maxStaleness);\n            }\n        }\n        return ScaleUtils.calcOutAmount(inAmount, _cache.price, scale, inverse);\n    }\n}"
    }
  ]
}