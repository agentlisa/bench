{
  "Title": "[Nâ€‘01]  Missing `initializer` modifier on constructor",
  "Content": "\nOpenZeppelin [recommends](https://forum.openzeppelin.com/t/uupsupgradeable-vulnerability-post-mortem/15680/5) that the `initializer` modifier be applied to constructors in order to avoid potential griefs, [social engineering](https://forum.openzeppelin.com/t/uupsupgradeable-vulnerability-post-mortem/15680/4), or exploits. Ensure that the modifier is applied to the implementation contract. If the default constructor is currently being used, it should be changed to be an explicit one with the modifier applied.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/proxy/MIMOProxy.sol\n\n12:   contract MIMOProxy is IMIMOProxy, Initializable, BoringBatchable {\n\n```\n\n<https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/proxy/MIMOProxy.sol#L12>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-08-mimo",
  "Code": [
    {
      "filename": "contracts/proxy/MIMOProxy.sol",
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport \"../libraries/BoringBatchable.sol\";\nimport \"./interfaces/IMIMOProxy.sol\";\nimport { CustomErrors } from \"../libraries/CustomErrors.sol\";\n\n/// @title MIMOProxy\n/// @notice Used as a proxy to access VaultsCore from a user or a rebalancer\ncontract MIMOProxy is IMIMOProxy, Initializable, BoringBatchable {\n  /// PUBLIC STORAGE ///\n\n  /// @inheritdoc IMIMOProxy\n  address public override owner;\n\n  /// @inheritdoc IMIMOProxy\n  uint256 public override minGasReserve;\n\n  /// INTERNAL STORAGE ///\n\n  /// @notice Maps envoys to target contracts to function selectors to boolean flags.\n  mapping(address => mapping(address => mapping(bytes4 => bool))) internal _permissions;\n\n  /// CONSTRUCTOR ///\n\n  /// @inheritdoc IMIMOProxy\n  function initialize() external initializer {\n    minGasReserve = 5_000;\n    owner = msg.sender;\n    emit TransferOwnership(address(0), msg.sender);\n  }\n\n  /// FALLBACK FUNCTION ///\n\n  /// @dev Called when Ether is sent and the call data is empty.\n  receive() external payable {}\n\n  /// PUBLIC CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxy\n  function getPermission(\n    address envoy,\n    address target,\n    bytes4 selector\n  ) external view override returns (bool) {\n    return _permissions[envoy][target][selector];\n  }\n\n  /// PUBLIC NON-CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxy\n  function execute(address target, bytes calldata data) public payable override returns (bytes memory response) {\n    // Check that the caller is either the owner or an envoy.\n    if (owner != msg.sender) {\n      bytes4 selector;\n      assembly {\n        selector := calldataload(data.offset)\n      }\n      if (!_permissions[msg.sender][target][selector]) {\n        revert CustomErrors.EXECUTION_NOT_AUTHORIZED(owner, msg.sender, target, selector);\n      }\n    }\n\n    // Check that the target is a valid contract.\n    if (target.code.length == 0) {\n      revert CustomErrors.TARGET_INVALID(target);\n    }\n\n    // Save the owner address in memory. This local variable cannot be modified during the DELEGATECALL.\n    address owner_ = owner;\n\n    // Reserve some gas to ensure that the function has enough to finish the execution.\n    uint256 stipend = gasleft() - minGasReserve;\n\n    // Delegate call to the target contract.\n    bool success;\n    (success, response) = target.delegatecall{ gas: stipend }(data);\n\n    // Check that the owner has not been changed.\n    if (owner_ != owner) {\n      revert CustomErrors.OWNER_CHANGED(owner_, owner);\n    }\n\n    // Log the execution.\n    emit Execute(target, data, response);\n\n    // Check if the call was successful or not.\n    if (!success) {\n      // If there is return data, the call reverted with a reason or a custom error.\n      if (response.length > 0) {\n        assembly {\n          let returndata_size := mload(response)\n          revert(add(32, response), returndata_size)\n        }\n      } else {\n        revert CustomErrors.EXECUTION_REVERTED();\n      }\n    }\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function setPermission(\n    address envoy,\n    address target,\n    bytes4 selector,\n    bool permission\n  ) public override {\n    if (owner != msg.sender) {\n      revert CustomErrors.NOT_OWNER(owner, msg.sender);\n    }\n    _permissions[envoy][target][selector] = permission;\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function transferOwnership(address newOwner) external override {\n    address oldOwner = owner;\n    if (oldOwner != msg.sender) {\n      revert CustomErrors.NOT_OWNER(oldOwner, msg.sender);\n    }\n    owner = newOwner;\n    emit TransferOwnership(oldOwner, newOwner);\n  }\n\n  /// @inheritdoc IMIMOProxy\n  function multicall(address[] calldata targets, bytes[] calldata data) external override returns (bytes[] memory) {\n    if (msg.sender != owner) {\n      revert CustomErrors.NOT_OWNER(owner, msg.sender);\n    }\n    bytes[] memory results = new bytes[](data.length);\n    for (uint256 i = 0; i < targets.length; i++) {\n      (bool success, bytes memory response) = targets[i].call(data[i]);\n      if (!success) {\n        if (response.length > 0) {\n          assembly {\n            let returndata_size := mload(response)\n            revert(add(32, response), returndata_size)\n          }\n        } else {\n          revert CustomErrors.LOW_LEVEL_CALL_FAILED();\n        }\n      }\n      results[i] = response;\n    }\n    return results;\n  }\n}"
    }
  ]
}