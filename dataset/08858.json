{
  "Title": "[16] Using `private` rather than `public` for constants, saves gas",
  "Content": "\nIf needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non-payable getter functions for deployment calldata, and not adding another entry to the method ID table\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: notional-wrapped-fcash/contracts/proxy/WrappedfCashFactory.sol   #1\n\n12:       bytes32 public constant SALT = 0;\n```\n\n<https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/proxy/WrappedfCashFactory.sol#L12>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-06-notional-coop",
  "Code": [
    {
      "filename": "notional-wrapped-fcash/contracts/proxy/WrappedfCashFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\nimport \"./nBeaconProxy.sol\";\n\ncontract WrappedfCashFactory {\n\n    /// @dev the Beacon contract here is an UpgradeableBeacon proxy, the contract\n    /// at this address can be upgraded which will upgrade all deployed wrappers.\n    address public immutable BEACON;\n    bytes32 public constant SALT = 0;\n\n    /// @notice Emitted when a new fCash wrapper has been deployed\n    event WrapperDeployed(uint16 currencyId, uint40 maturity, address wrapper);\n\n    constructor(address _beacon) {\n        BEACON = _beacon;\n    }\n\n    function _getByteCode(uint16 currencyId, uint40 maturity) internal view returns (bytes memory) {\n        bytes memory initCallData = abi.encodeWithSignature(\"initialize(uint16,uint40)\", currencyId, maturity);\n        return abi.encodePacked(type(nBeaconProxy).creationCode, abi.encode(BEACON, initCallData));\n    }\n\n    function deployWrapper(uint16 currencyId, uint40 maturity) external returns (address) {\n        address _computedWrapper = computeAddress(currencyId, maturity);\n\n        if (Address.isContract(_computedWrapper)) {\n            // If wrapper has already been deployed then just return it's address\n            return _computedWrapper;\n        } else {\n            address wrapper = Create2.deploy(0, SALT, _getByteCode(currencyId, maturity));\n            emit WrapperDeployed(currencyId, maturity, wrapper);\n            return wrapper;\n        }\n    }\n\n    function computeAddress(uint16 currencyId, uint40 maturity) public view returns (address) {\n        return Create2.computeAddress(SALT, keccak256(_getByteCode(currencyId, maturity)));\n    }\n}"
    }
  ]
}