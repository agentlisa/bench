{
  "Title": "M-4: Frontrun `deposit()` can cause the depositor to lose all the funds",
  "Content": "# Issue M-4: Frontrun `deposit()` can cause the depositor to lose all the funds \n\nSource: https://github.com/sherlock-audit/2022-10-mycelium-judging/tree/main/029-M \n\n## Found by \nctf\\_sec, Lambda, CRYP70, 8olidity, bin2chen, hansfriese, innertia, dipp, rbserver, CodingNameKiki, WATCHPUG\n\n## Summary\n\nThe attacker can frontrun the first depositor's `deposit()` transaction and transfer LINK tokens to the Vault contract directly and cause the depositor (and all the future depositors) to lose all the funds.\n\n## Vulnerability Detail\n\nIn `onTokenTransfer()`, if there are some existing balance in the Vault contract, say 1 wei of LINK token, `supplyBeforeTransfer` will be `1`, since `totalShares == 0`, `newShares` will always be `0`.\n\nThe same applies for `deposit()`.\n\n## Impact\n\nThe depositor who got frontrun by the attacker will lose all their funds. And all the future depositors.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-mycelium/blob/main/mylink-contracts/src/Vault.sol#L252-L276\n\nhttps://github.com/sherlock-audit/2022-10-mycelium/blob/main/mylink-contracts/src/Vault.sol#L131-L142\n\nhttps://github.com/sherlock-audit/2022-10-mycelium/blob/main/mylink-contracts/src/Vault.sol#L614-L620\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIt should check if `totalShares == 0` to decide whether this is the first mint.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/7",
  "Code": [
    {
      "filename": "mylink-contracts/src/Vault.sol",
      "content": "// SPDX-License-Identifier: CC-BY-NC-ND-4.0\npragma solidity ^0.8.9;\n\nimport \"openzeppelin/token/ERC20/IERC20.sol\";\nimport \"openzeppelin/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"openzeppelin/proxy/utils/UUPSUpgradeable.sol\";\nimport \"openzeppelin/proxy/utils/Initializable.sol\";\nimport \"./plugins/IPlugin.sol\";\nimport \"solmate/utils/FixedPointMathLib.sol\";\nimport \"./interfaces/IERC677.sol\";\n\n/**\n * @title Interest bearing ERC20 token for LINK staked to Mycelium's node\n *\n * myLINK balances are dynamic. They represent the holder's share in the total amount of\n * LINK controlled by the Vault. An account's balance is calculated as:\n *\n *      shares[account] * totalSupply() / totalShares()\n *\n * Mints, transfers, and burns operate on the equivalent number of shares, rather than the balance\n * directly. This allows the balance to change over time without requiring an infeasible number of\n * storage updates.\n *\n * Conversions between myLINK and shares will not always be exact due to rounding errors. For example,\n * if there are 100 shares and 200 myLINK in the Vault, the smallest possible transfer is 2 myLINK.\n */\n\ncontract Vault is IERC20, IERC20Metadata, IERC677Receiver, UUPSUpgradeable, Initializable {\n    using FixedPointMathLib for uint256;\n\n    /**\n     * @notice Address with owner privileges\n     * @dev Set in the initializer\n     */\n    address public owner;\n\n    /// @notice The number of decimals the token uses\n    /// @dev This should be the same as the LINK token\n    uint8 public decimals;\n\n    /// @notice The address of the LINK token\n    address public LINK;\n\n    /// @notice The maximum amount of LINK that can be deposited into the Vault\n    /// @dev This is required to prevent integer overflow errors in the myLINK balance calculations\n    uint256 public MAX_CAPACITY;\n\n    /// @notice The initial number of shares per LINK deposited\n    uint256 public STARTING_SHARES_PER_LINK;\n\n    /**\n     * @dev myLINK balances are dynamic and are determined by the total amount of LINK controlled by\n     * the Vault and the user's portion of the total shares\n     */\n    uint256 public totalShares;\n    mapping(address => uint256) public shares;\n\n    /**\n     * @dev Plugins earn yield for the LINK in the vault. They have a capacity limit and are indexed by priority.\n     * LINK is allocated to plugins with lower priority number first, and removed in reverse order.\n     * So plugins[0] should fill up first and plugins[pluginCount - 1] should be emptied first.\n     */\n    uint256 public pluginCount;\n    mapping(uint256 => address) public plugins;\n\n    /// @notice The allowed amount of myLINK a spender can transfer on behalf of the owner\n    /// @dev allowances are denoted in tokens, not shares\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /**\n     * @notice A deposit to the vault\n     *\n     * @param from The account that deposited the LINK\n     * @param amount The amount of LINK deposited\n     */\n    event Deposit(address indexed from, uint256 amount);\n\n    /**\n     * @notice A withdrawal from the vault\n     *\n     * @param to The account that received the LINK\n     * @param amount The amount of LINK withdrawn\n     */\n    event Withdraw(address indexed to, uint256 amount);\n\n    /**\n     * @notice A plugin was added to the vault\n     *\n     * @param plugin The address of the plugin contract\n     * @param index The priority index of the plugin\n     */\n    event PluginAdded(address indexed plugin, uint256 index);\n\n    /**\n     * @notice A plugin was removed from the vault\n     *\n     * @param plugin The address of the plugin contract\n     */\n    event PluginRemoved(address indexed plugin);\n\n    /**\n     * @notice The owner of the vault was changed\n     *\n     * @param previousOwner The previous owner of the vault\n     * @param newOwner The new owner of the vault\n     */\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function initialize(\n        address _LINK,\n        address _owner,\n        uint256 _capacity,\n        uint256 _startingSharesPerLink\n    ) public initializer {\n        LINK = _LINK;\n        decimals = IERC20Metadata(_LINK).decimals();\n        owner = _owner;\n        MAX_CAPACITY = _capacity;\n        STARTING_SHARES_PER_LINK = _startingSharesPerLink;\n    }\n\n    /****************************************** USER METHODS ******************************************/\n\n    /**\n     * @notice Deposits LINK into the vault and mints shares of myLINK of the same value\n     *\n     * @param _amount The amount of LINK to deposit\n     *\n     * Emits a {Deposit} event.\n     */\n    function deposit(uint256 _amount) external {\n        require(_amount > 0, \"Amount must be greater than 0\");\n        require(_amount <= availableForDeposit(), \"Amount exceeds available capacity\");\n\n        uint256 newShares = convertToShares(_amount);\n        _mintShares(msg.sender, newShares);\n\n        IERC20(LINK).transferFrom(msg.sender, address(this), _amount);\n        _distributeToPlugins();\n\n        emit Deposit(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Redeems shares of myLINK for LINK\n     * @dev Pulls the LINK from the plugins before burning the shares\n     *\n     * @param _amount The amount of myLINK to redeem (denominated in tokens, not shares)\n     *\n     * Emits a {Withdraw} event.\n     */\n\n    function withdraw(uint256 _amount) external {\n        require(_amount > 0, \"Amount must be greater than 0\");\n        require(_amount <= balanceOf(msg.sender), \"Amount exceeds balance\");\n\n        _ensureLinkAmount(_amount);\n\n        _burnShares(msg.sender, convertToShares(_amount));\n\n        IERC20(LINK).transfer(msg.sender, _amount);\n\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Redeems all shares of myLINK for LINK\n     * @dev There is often a small amount of shares remainining when using the `withdraw` method\n     * This method is provided to allow users to completely withdraw from the vault\n     *\n     * Emits a {Withdraw} event.\n     */\n\n    function withdrawAll() external {\n        uint256 amount = balanceOf(msg.sender);\n        require(amount > 0, \"Amount must be greater than 0\");\n\n        _ensureLinkAmount(amount);\n\n        _burnShares(msg.sender, shares[msg.sender]);\n\n        IERC20(LINK).transfer(msg.sender, amount);\n\n        emit Withdraw(msg.sender, amount);\n    }\n\n    /**\n     * @notice Moves `_amount` myLINK from the caller's account to `_to`\n     *\n     * @param _to The account to transfer to\n     * @param _amount The amount to transfer\n     * @return true if the transfer succeeded\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address _to, uint256 _amount) public returns (bool) {\n        _transfer(msg.sender, _to, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Moves `_amount` myLINK from `_from` to `_to` using the allowance mechanism\n     * @dev `_amount` is then deducted from the caller's allowance\n     *\n     * @param _from The account to transfer from\n     * @param _to The account to transfer to\n     * @param _amount The amount to transfer\n     * @return true if the transfer succeeded\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) public returns (bool) {\n        require(_amount <= allowance[_from][msg.sender], \"Amount exceeds allowance\");\n\n        _transfer(_from, _to, _amount);\n        allowance[_from][msg.sender] -= _amount;\n\n        return true;\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller's myLINK\n     *\n     * @param _spender The account to be given an allowance\n     * @param _amount The allowance amount\n     * @return true if the approval succeeded\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address _spender, uint256 _amount) public returns (bool) {\n        require(_spender != address(0), \"Cannot approve zero address\");\n        allowance[msg.sender][_spender] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Mints shares of myLINK according to the amount of LINK deposited\n     * @dev ERC677 callback after LINK is transferred to the vault\n     * @dev Can only be called by the LINK token contract\n     *\n     * @param _from The account that deposited the LINK\n     * @param _amount The amount of LINK deposited\n     * @param _data The data passed to the transferAndCall method, which must be \"deposit\"\n     *\n     * Emits a {Deposit} event.\n     */\n    function onTokenTransfer(\n        address _from,\n        uint256 _amount,\n        bytes memory _data\n    ) external override returns (bool) {\n        require(msg.sender == LINK, \"Must use LINK token\");\n        require(keccak256(_data) == keccak256(abi.encodePacked(\"deposit\")), \"Data must be 'deposit'\");\n\n        require(_amount > 0, \"Amount must be greater than 0\");\n        require(totalSupply() <= MAX_CAPACITY, \"Amount exceeds available capacity\");\n\n        // We must calculate the shares based on the supply before the transfer\n        uint256 supplyBeforeTransfer = totalSupply() - _amount;\n        uint256 newShares = supplyBeforeTransfer == 0\n            ? _amount * STARTING_SHARES_PER_LINK\n            : _amount.mulDivDown(totalShares, supplyBeforeTransfer);\n\n        _mintShares(_from, newShares);\n\n        _distributeToPlugins();\n\n        emit Deposit(_from, _amount);\n\n        return true;\n    }\n\n    /****************************************** OWNER METHODS ******************************************/\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only callable by owner\");\n        _;\n    }\n\n    /**\n     * @notice Sets a new owner of the smart contract\n     * @dev Only callable by the current owner\n     *\n     * @param _newOwner The address of the new owner\n     *\n     * Emits an {OwnershipTransferred} event.\n     */\n    function transferOwnership(address _newOwner) external onlyOwner {\n        owner = _newOwner;\n        emit OwnershipTransferred(msg.sender, _newOwner);\n    }\n\n    /**\n     * @dev ensures only the owner can upgrade the contract\n     */\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n\n    /**\n     * @notice Adds a plugin to the vault\n     * @dev Only callable by the owner\n     * @dev Approves the plugin to transfer LINK from the vault\n     * @dev Will shift all plugins with a greater priority index up by 1\n     *\n     * @param _plugin The address of the plugin contract\n     * @param _index The priority index of the plugin\n     *\n     * Emits a {PluginAdded} event.\n     */\n    function addPlugin(address _plugin, uint256 _index) external onlyOwner {\n        require(_plugin != address(0), \"Cannot add zero address\");\n        require(_index <= pluginCount, \"Index must be less than or equal to plugin count\");\n\n        uint256 pointer = pluginCount;\n        while (pointer > _index) {\n            plugins[pointer] = plugins[pointer - 1];\n            pointer--;\n        }\n        plugins[pointer] = _plugin;\n        pluginCount++;\n\n        IERC20(LINK).approve(_plugin, type(uint256).max);\n\n        emit PluginAdded(_plugin, _index);\n    }\n\n    /**\n     * @notice Removes a plugin from the vault\n     * @dev Only callable by the owner\n     * @dev Removes the plugin's allowance to transfer LINK from the vault\n     * @dev Will shift all plugins with a greater priority index down by 1\n     *\n     * @param _index The index of the plugin to remove\n     *\n     * Emits a {PluginRemoved} event.\n     */\n    function removePlugin(uint256 _index) external onlyOwner {\n        require(_index < pluginCount, \"Index out of bounds\");\n        address pluginAddr = plugins[_index];\n\n        _withdrawFromPlugin(pluginAddr, IPlugin(pluginAddr).balance());\n\n        uint256 pointer = _index;\n        while (pointer < pluginCount - 1) {\n            plugins[pointer] = plugins[pointer + 1];\n            pointer++;\n        }\n        delete plugins[pluginCount - 1];\n        pluginCount--;\n\n        IERC20(LINK).approve(pluginAddr, 0);\n\n        emit PluginRemoved(pluginAddr);\n    }\n\n    /**\n     * @notice Withdraws LINK from plugins and redistributes it\n     * @dev Only callable by the owner\n     * @dev Useful for when the plugin configuration changes\n     *\n     * @param _withdrawalValues The amount of LINK to withdraw from each plugin\n     */\n    function rebalancePlugins(uint256[] memory _withdrawalValues) external onlyOwner {\n        require(_withdrawalValues.length == pluginCount, \"Invalid withdrawal values\");\n        for (uint256 i = 0; i < pluginCount; i++) {\n            _withdrawFromPlugin(plugins[i], _withdrawalValues[i]);\n        }\n        _distributeToPlugins();\n    }\n\n    /**\n     * @notice Sets the vault capacity\n     * @dev Only callable by the owner\n     *\n     * @param _maxCapacity The new capacity\n     */\n    function setMaxCapacity(uint256 _maxCapacity) external onlyOwner {\n        MAX_CAPACITY = _maxCapacity;\n    }\n\n    /****************************************** INTERNAL METHODS ******************************************/\n\n    /**\n     * @notice Mints shares of myLINK to `_to`\n     *\n     * @param _to The account to mint to\n     * @param _shares The number of shares to mint\n     */\n    function _mintShares(address _to, uint256 _shares) internal {\n        require(_to != address(0), \"Cannot mint to address 0\");\n\n        totalShares += _shares;\n        unchecked {\n            // Overflow is impossible, because totalShares would overflow first\n            shares[_to] += _shares;\n        }\n    }\n\n    /**\n     * @notice Burns shares of myLINK from `_from`\n     *\n     * @param _from The account to burn from\n     * @param _shares The number of shares to burn\n     */\n    function _burnShares(address _from, uint256 _shares) internal {\n        require(_from != address(0), \"Cannot burn from address 0\");\n\n        require(shares[_from] >= _shares, \"Cannot burn more shares than owned\");\n        unchecked {\n            // Underflow is impossible, because of above require statement\n            shares[_from] -= _shares;\n            totalShares -= _shares;\n        }\n    }\n\n    /**\n     * @notice Transfers `_amount` myLINK from `_from` to `_to`\n     * @dev Converts `_amount` to an equivalent number of shares, and transfers those shares\n     *\n     * @param _from The account to transfer from\n     * @param _to The account to transfer to\n     * @param _amount The amount to transfer\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        require(_from != address(0), \"Cannot transfer from zero address\");\n        require(_to != address(0), \"Cannot transfer to zero address\");\n\n        uint256 sharesToTransfer = convertToShares(_amount);\n        require(sharesToTransfer <= shares[_from], \"Amount exceeds balance\");\n\n        unchecked {\n            // Underflow is impossible, because of above require statement\n            shares[_from] -= sharesToTransfer;\n            // Overflow is impossible because sharesToTransfer will always be less than totalShares\n            // which is checked when new shares are minteds\n            shares[_to] += sharesToTransfer;\n        }\n\n        emit Transfer(_from, _to, _amount);\n    }\n\n    /**\n     * @notice Distributes all LINK in the vault to the plugins\n     * @dev Distributes LINK to the plugin with the lowest priority index that still has capacity first\n     */\n    function _distributeToPlugins() internal {\n        uint256 remaining = IERC20(LINK).balanceOf(address(this));\n\n        // Plugins are ordered by priority. Fill the first one first, then the second, etc.\n        for (uint256 i = 0; i < pluginCount; i++) {\n            if (remaining == 0) {\n                break;\n            }\n\n            address plugin = plugins[i];\n            uint256 available = IPlugin(plugin).availableForDeposit();\n            if (available > 0) {\n                uint256 amount = available > remaining ? remaining : available;\n                _depositToPlugin(plugin, amount);\n                remaining -= amount;\n            }\n        }\n    }\n\n    /**\n     * @notice Deposits `_amount` LINK to `_plugin`\n     *\n     * @param _plugin The address of the plugin contract\n     * @param _amount The amount to deposit\n     */\n    function _depositToPlugin(address _plugin, uint256 _amount) internal {\n        IPlugin(_plugin).deposit(_amount);\n    }\n\n    /**\n     * @notice Ensures the vault has enough LINK to cover the withdrawal\n     * @dev Withdraws from the plugin with the highest priority index first\n     * @dev Reverts if it cannot withdraw enough LINK to satisfy the request\n     *\n     * @param _requested The amount of LINK to ensure the vault has\n     */\n    function _ensureLinkAmount(uint256 _requested) internal {\n        require(_requested <= availableForWithdrawal(), \"Amount exceeds available balance\");\n\n        uint256 currentBalance = IERC20(LINK).balanceOf(address(this));\n        if (currentBalance >= _requested) {\n            return;\n        }\n\n        uint256 remaining = _requested - currentBalance;\n        // Withdraw in reverse order of deposit\n        for (uint256 i = 0; i < pluginCount; i++) {\n            if (remaining == 0) {\n                break;\n            }\n\n            address plugin = plugins[pluginCount - i - 1];\n            uint256 available = IPlugin(plugin).availableForWithdrawal();\n            if (available > 0) {\n                uint256 amount = available > remaining ? remaining : available;\n                _withdrawFromPlugin(plugin, amount);\n                remaining -= amount;\n            }\n        }\n\n        if (remaining > 0) {\n            revert(\"Unable to withdraw enough LINK from plugins\");\n        }\n    }\n\n    /**\n     * @notice Withdraws `_amount` LINK from `_plugin`\n     *\n     * @param _plugin The address of the plugin contract\n     * @param _amount The amount to withdraw\n     */\n    function _withdrawFromPlugin(address _plugin, uint256 _amount) internal {\n        IPlugin(_plugin).withdraw(_amount);\n    }\n\n    /****************************************** VIEWS ******************************************/\n\n    /**\n     * @return The name of the token\n     */\n    function name() external pure returns (string memory) {\n        return \"Mycelium LINK\";\n    }\n\n    /**\n     * @return The symbol of the token\n     */\n    function symbol() external pure returns (string memory) {\n        return \"myLINK\";\n    }\n\n    /**\n     * @return The total amount of tokens in existence\n     *\n     * @dev Equal to the number of LINK in the vault and all plugins\n     */\n    function totalSupply() public view override returns (uint256) {\n        uint256 supply = IERC20(LINK).balanceOf(address(this));\n        for (uint256 i = 0; i < pluginCount; i++) {\n            supply += IPlugin(plugins[i]).balance();\n        }\n        return supply;\n    }\n\n    /**\n     * @return The amount of LINK the vault can receive\n     */\n    function availableForDeposit() public view returns (uint256) {\n        uint256 supply = totalSupply();\n        if (supply >= MAX_CAPACITY) {\n            return 0;\n        }\n        return MAX_CAPACITY - supply;\n    }\n\n    /**\n     * @return The amount of LINK that can be withdrawn from the vault\n     *\n     * @dev The LINK in the vault, plus what can be withdrawn from the plugins\n     */\n    function availableForWithdrawal() public view returns (uint256) {\n        uint256 available = IERC20(LINK).balanceOf(address(this));\n        for (uint256 i = 0; i < pluginCount; i++) {\n            available += IPlugin(plugins[i]).availableForWithdrawal();\n        }\n        return available;\n    }\n\n    /**\n     * @return The number of tokens owned by `_account`\n     * @param _account The account to query\n     */\n    function balanceOf(address _account) public view override returns (uint256) {\n        return convertToTokens(shares[_account]);\n    }\n\n    /**\n     * @notice Converts `_shares` to an equivalent number of tokens\n     * @dev Rounds down\n     *\n     * @return The number of tokens equivalent to `_shares`\n     * @param _shares The number of shares to convert\n     */\n    function convertToTokens(uint256 _shares) public view returns (uint256) {\n        uint256 shareSupply = totalShares; // saves one SLOAD\n        if (shareSupply == 0) {\n            return _shares / STARTING_SHARES_PER_LINK;\n        }\n        return _shares.mulDivDown(totalSupply(), shareSupply);\n    }\n\n    /**\n     * @notice Converts `_tokens` to an equivalent number of shares\n     * @dev Rounds down\n     *\n     * @return The number of shares equivalent to `_tokens`\n     * @param _tokens The number of tokens to convert\n     */\n    function convertToShares(uint256 _tokens) public view returns (uint256) {\n        uint256 tokenSupply = totalSupply(); // saves one SLOAD\n        if (tokenSupply == 0) {\n            return _tokens * STARTING_SHARES_PER_LINK;\n        }\n        return _tokens.mulDivDown(totalShares, tokenSupply);\n    }\n}"
    },
    {
      "filename": "mylink-contracts/src/Vault.sol",
      "content": "// SPDX-License-Identifier: CC-BY-NC-ND-4.0\npragma solidity ^0.8.9;\n\nimport \"openzeppelin/token/ERC20/IERC20.sol\";\nimport \"openzeppelin/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"openzeppelin/proxy/utils/UUPSUpgradeable.sol\";\nimport \"openzeppelin/proxy/utils/Initializable.sol\";\nimport \"./plugins/IPlugin.sol\";\nimport \"solmate/utils/FixedPointMathLib.sol\";\nimport \"./interfaces/IERC677.sol\";\n\n/**\n * @title Interest bearing ERC20 token for LINK staked to Mycelium's node\n *\n * myLINK balances are dynamic. They represent the holder's share in the total amount of\n * LINK controlled by the Vault. An account's balance is calculated as:\n *\n *      shares[account] * totalSupply() / totalShares()\n *\n * Mints, transfers, and burns operate on the equivalent number of shares, rather than the balance\n * directly. This allows the balance to change over time without requiring an infeasible number of\n * storage updates.\n *\n * Conversions between myLINK and shares will not always be exact due to rounding errors. For example,\n * if there are 100 shares and 200 myLINK in the Vault, the smallest possible transfer is 2 myLINK.\n */\n\ncontract Vault is IERC20, IERC20Metadata, IERC677Receiver, UUPSUpgradeable, Initializable {\n    using FixedPointMathLib for uint256;\n\n    /**\n     * @notice Address with owner privileges\n     * @dev Set in the initializer\n     */\n    address public owner;\n\n    /// @notice The number of decimals the token uses\n    /// @dev This should be the same as the LINK token\n    uint8 public decimals;\n\n    /// @notice The address of the LINK token\n    address public LINK;\n\n    /// @notice The maximum amount of LINK that can be deposited into the Vault\n    /// @dev This is required to prevent integer overflow errors in the myLINK balance calculations\n    uint256 public MAX_CAPACITY;\n\n    /// @notice The initial number of shares per LINK deposited\n    uint256 public STARTING_SHARES_PER_LINK;\n\n    /**\n     * @dev myLINK balances are dynamic and are determined by the total amount of LINK controlled by\n     * the Vault and the user's portion of the total shares\n     */\n    uint256 public totalShares;\n    mapping(address => uint256) public shares;\n\n    /**\n     * @dev Plugins earn yield for the LINK in the vault. They have a capacity limit and are indexed by priority.\n     * LINK is allocated to plugins with lower priority number first, and removed in reverse order.\n     * So plugins[0] should fill up first and plugins[pluginCount - 1] should be emptied first.\n     */\n    uint256 public pluginCount;\n    mapping(uint256 => address) public plugins;\n\n    /// @notice The allowed amount of myLINK a spender can transfer on behalf of the owner\n    /// @dev allowances are denoted in tokens, not shares\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /**\n     * @notice A deposit to the vault\n     *\n     * @param from The account that deposited the LINK\n     * @param amount The amount of LINK deposited\n     */\n    event Deposit(address indexed from, uint256 amount);\n\n    /**\n     * @notice A withdrawal from the vault\n     *\n     * @param to The account that received the LINK\n     * @param amount The amount of LINK withdrawn\n     */\n    event Withdraw(address indexed to, uint256 amount);\n\n    /**\n     * @notice A plugin was added to the vault\n     *\n     * @param plugin The address of the plugin contract\n     * @param index The priority index of the plugin\n     */\n    event PluginAdded(address indexed plugin, uint256 index);\n\n    /**\n     * @notice A plugin was removed from the vault\n     *\n     * @param plugin The address of the plugin contract\n     */\n    event PluginRemoved(address indexed plugin);\n\n    /**\n     * @notice The owner of the vault was changed\n     *\n     * @param previousOwner The previous owner of the vault\n     * @param newOwner The new owner of the vault\n     */\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function initialize(\n        address _LINK,\n        address _owner,\n        uint256 _capacity,\n        uint256 _startingSharesPerLink\n    ) public initializer {\n        LINK = _LINK;\n        decimals = IERC20Metadata(_LINK).decimals();\n        owner = _owner;\n        MAX_CAPACITY = _capacity;\n        STARTING_SHARES_PER_LINK = _startingSharesPerLink;\n    }\n\n    /****************************************** USER METHODS ******************************************/\n\n    /**\n     * @notice Deposits LINK into the vault and mints shares of myLINK of the same value\n     *\n     * @param _amount The amount of LINK to deposit\n     *\n     * Emits a {Deposit} event.\n     */\n    function deposit(uint256 _amount) external {\n        require(_amount > 0, \"Amount must be greater than 0\");\n        require(_amount <= availableForDeposit(), \"Amount exceeds available capacity\");\n\n        uint256 newShares = convertToShares(_amount);\n        _mintShares(msg.sender, newShares);\n\n        IERC20(LINK).transferFrom(msg.sender, address(this), _amount);\n        _distributeToPlugins();\n\n        emit Deposit(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Redeems shares of myLINK for LINK\n     * @dev Pulls the LINK from the plugins before burning the shares\n     *\n     * @param _amount The amount of myLINK to redeem (denominated in tokens, not shares)\n     *\n     * Emits a {Withdraw} event.\n     */\n\n    function withdraw(uint256 _amount) external {\n        require(_amount > 0, \"Amount must be greater than 0\");\n        require(_amount <= balanceOf(msg.sender), \"Amount exceeds balance\");\n\n        _ensureLinkAmount(_amount);\n\n        _burnShares(msg.sender, convertToShares(_amount));\n\n        IERC20(LINK).transfer(msg.sender, _amount);\n\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Redeems all shares of myLINK for LINK\n     * @dev There is often a small amount of shares remainining when using the `withdraw` method\n     * This method is provided to allow users to completely withdraw from the vault\n     *\n     * Emits a {Withdraw} event.\n     */\n\n    function withdrawAll() external {\n        uint256 amount = balanceOf(msg.sender);\n        require(amount > 0, \"Amount must be greater than 0\");\n\n        _ensureLinkAmount(amount);\n\n        _burnShares(msg.sender, shares[msg.sender]);\n\n        IERC20(LINK).transfer(msg.sender, amount);\n\n        emit Withdraw(msg.sender, amount);\n    }\n\n    /**\n     * @notice Moves `_amount` myLINK from the caller's account to `_to`\n     *\n     * @param _to The account to transfer to\n     * @param _amount The amount to transfer\n     * @return true if the transfer succeeded\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address _to, uint256 _amount) public returns (bool) {\n        _transfer(msg.sender, _to, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Moves `_amount` myLINK from `_from` to `_to` using the allowance mechanism\n     * @dev `_amount` is then deducted from the caller's allowance\n     *\n     * @param _from The account to transfer from\n     * @param _to The account to transfer to\n     * @param _amount The amount to transfer\n     * @return true if the transfer succeeded\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) public returns (bool) {\n        require(_amount <= allowance[_from][msg.sender], \"Amount exceeds allowance\");\n\n        _transfer(_from, _to, _amount);\n        allowance[_from][msg.sender] -= _amount;\n\n        return true;\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller's myLINK\n     *\n     * @param _spender The account to be given an allowance\n     * @param _amount The allowance amount\n     * @return true if the approval succeeded\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address _spender, uint256 _amount) public returns (bool) {\n        require(_spender != address(0), \"Cannot approve zero address\");\n        allowance[msg.sender][_spender] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Mints shares of myLINK according to the amount of LINK deposited\n     * @dev ERC677 callback after LINK is transferred to the vault\n     * @dev Can only be called by the LINK token contract\n     *\n     * @param _from The account that deposited the LINK\n     * @param _amount The amount of LINK deposited\n     * @param _data The data passed to the transferAndCall method, which must be \"deposit\"\n     *\n     * Emits a {Deposit} event.\n     */\n    function onTokenTransfer(\n        address _from,\n        uint256 _amount,\n        bytes memory _data\n    ) external override returns (bool) {\n        require(msg.sender == LINK, \"Must use LINK token\");\n        require(keccak256(_data) == keccak256(abi.encodePacked(\"deposit\")), \"Data must be 'deposit'\");\n\n        require(_amount > 0, \"Amount must be greater than 0\");\n        require(totalSupply() <= MAX_CAPACITY, \"Amount exceeds available capacity\");\n\n        // We must calculate the shares based on the supply before the transfer\n        uint256 supplyBeforeTransfer = totalSupply() - _amount;\n        uint256 newShares = supplyBeforeTransfer == 0\n            ? _amount * STARTING_SHARES_PER_LINK\n            : _amount.mulDivDown(totalShares, supplyBeforeTransfer);\n\n        _mintShares(_from, newShares);\n\n        _distributeToPlugins();\n\n        emit Deposit(_from, _amount);\n\n        return true;\n    }\n\n    /****************************************** OWNER METHODS ******************************************/\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only callable by owner\");\n        _;\n    }\n\n    /**\n     * @notice Sets a new owner of the smart contract\n     * @dev Only callable by the current owner\n     *\n     * @param _newOwner The address of the new owner\n     *\n     * Emits an {OwnershipTransferred} event.\n     */\n    function transferOwnership(address _newOwner) external onlyOwner {\n        owner = _newOwner;\n        emit OwnershipTransferred(msg.sender, _newOwner);\n    }\n\n    /**\n     * @dev ensures only the owner can upgrade the contract\n     */\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n\n    /**\n     * @notice Adds a plugin to the vault\n     * @dev Only callable by the owner\n     * @dev Approves the plugin to transfer LINK from the vault\n     * @dev Will shift all plugins with a greater priority index up by 1\n     *\n     * @param _plugin The address of the plugin contract\n     * @param _index The priority index of the plugin\n     *\n     * Emits a {PluginAdded} event.\n     */\n    function addPlugin(address _plugin, uint256 _index) external onlyOwner {\n        require(_plugin != address(0), \"Cannot add zero address\");\n        require(_index <= pluginCount, \"Index must be less than or equal to plugin count\");\n\n        uint256 pointer = pluginCount;\n        while (pointer > _index) {\n            plugins[pointer] = plugins[pointer - 1];\n            pointer--;\n        }\n        plugins[pointer] = _plugin;\n        pluginCount++;\n\n        IERC20(LINK).approve(_plugin, type(uint256).max);\n\n        emit PluginAdded(_plugin, _index);\n    }\n\n    /**\n     * @notice Removes a plugin from the vault\n     * @dev Only callable by the owner\n     * @dev Removes the plugin's allowance to transfer LINK from the vault\n     * @dev Will shift all plugins with a greater priority index down by 1\n     *\n     * @param _index The index of the plugin to remove\n     *\n     * Emits a {PluginRemoved} event.\n     */\n    function removePlugin(uint256 _index) external onlyOwner {"
    }
  ]
}