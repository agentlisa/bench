{
  "Title": "[L-02] `DRAWS_PER_YEAR` assumes one draw per week",
  "Content": "\nhttps://github.com/code-423n4/2023-03-wenwin/blob/main/src/LotteryMath.sol#L24\n\nThe `DRAWS_PER_YEAR` constant is fixed at 52 assuming one draw lasts one week, while the lottery can be configured with an arbitrary draw period.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2023-03-wenwin-contest",
  "Code": [
    {
      "filename": "src/LotteryMath.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// slither-disable-next-line solc-version\npragma solidity 0.8.19;\n\nimport \"src/interfaces/ILottery.sol\";\nimport \"src/PercentageMath.sol\";\n\n/// @dev Implementation of lottery jackpot and fees calculations\nlibrary LotteryMath {\n    using PercentageMath for uint256;\n    using PercentageMath for int256;\n\n    /// @dev percentage of ticket price being paid for staking reward\n    uint256 public constant STAKING_REWARD = 20 * PercentageMath.ONE_PERCENT;\n    /// @dev percentage of ticket price being paid to frontend operator\n    uint256 public constant FRONTEND_REWARD = 10 * PercentageMath.ONE_PERCENT;\n    /// @dev Percentage of the ticket price that goes to the pot\n    uint256 public constant TICKET_PRICE_TO_POT = PercentageMath.PERCENTAGE_BASE - STAKING_REWARD - FRONTEND_REWARD;\n    /// @dev safety margin used to calculate excess pot, in percentage\n    uint256 public constant SAFETY_MARGIN = 67 * PercentageMath.ONE_PERCENT;\n    /// @dev Percentage of excess pot reserved for bonus\n    uint256 public constant EXCESS_BONUS_ALLOCATION = 50 * PercentageMath.ONE_PERCENT;\n    /// @dev Number of lottery draws per year\n    uint128 public constant DRAWS_PER_YEAR = 52;\n\n    /// @dev Calculates new cumulative net profit and excess pot\n    /// To be called when the draw is finalized\n    /// @param oldProfit Current cumulative net profit, calculated when previous draw was finalized\n    /// @param ticketsSold Number of tickets sold for the draw that is currently finalized\n    /// @param ticketPrice One ticket price expressed in reward token\n    /// @param jackpotWon True if jackpot is won in this round\n    /// @param fixedJackpotSize Fixed jackpot price\n    /// @param expectedPayout Expected payout to players per ticket, expressed in `rewardToken`\n    /// @return newProfit New value for the cumulative net profit after the draw is finalised\n    function calculateNewProfit(\n        int256 oldProfit,\n        uint256 ticketsSold,\n        uint256 ticketPrice,\n        bool jackpotWon,\n        uint256 fixedJackpotSize,\n        uint256 expectedPayout\n    )\n        internal\n        pure\n        returns (int256 newProfit)\n    {\n        uint256 ticketsSalesToPot = (ticketsSold * ticketPrice).getPercentage(TICKET_PRICE_TO_POT);\n        newProfit = oldProfit + int256(ticketsSalesToPot);\n\n        uint256 expectedRewardsOut = jackpotWon\n            ? calculateReward(oldProfit, fixedJackpotSize, fixedJackpotSize, ticketsSold, true, expectedPayout)\n            : calculateMultiplier(calculateExcessPot(oldProfit, fixedJackpotSize), ticketsSold, expectedPayout)\n                * ticketsSold * expectedPayout;\n\n        newProfit -= int256(expectedRewardsOut);\n    }\n\n    /// @dev Calculates excess pot based on netProfit\n    /// @param netProfit Current net profit of the lottery\n    /// @param fixedJackpotSize Fixed portion of the jackpot\n    /// @return excessPot Resulting excess pot\n    function calculateExcessPot(int256 netProfit, uint256 fixedJackpotSize) internal pure returns (uint256 excessPot) {\n        int256 excessPotInt = netProfit.getPercentageInt(SAFETY_MARGIN);\n        excessPotInt -= int256(fixedJackpotSize);\n        excessPot = excessPotInt > 0 ? uint256(excessPotInt) : 0;\n    }\n\n    /// @dev Calculates multiplier to be used when calculating non jackpot rewards\n    /// @param excessPot Excess pot, calculated when previous draw was finalized\n    /// @param ticketsSold Number of tickets sold in the current draw\n    /// @param expectedPayout Expected payout to players per ticket, expressed in `rewardToken`\n    /// @return bonusMulti Multiplier to be used when calculating rewards, with `PERCENTAGE_BASE` precision\n    function calculateMultiplier(\n        uint256 excessPot,\n        uint256 ticketsSold,\n        uint256 expectedPayout\n    )\n        internal\n        pure\n        returns (uint256 bonusMulti)\n    {\n        bonusMulti = PercentageMath.PERCENTAGE_BASE;\n        if (excessPot > 0 && ticketsSold > 0) {\n            bonusMulti += (excessPot * EXCESS_BONUS_ALLOCATION) / (ticketsSold * expectedPayout);\n        }\n    }\n\n    /// @dev Calculates reward for the winning ticket\n    /// @param netProfit Current cumulative net profit, calculated when previous draw was finalized\n    /// @param fixedReward Fixed reward for particular tier of the winning ticket\n    /// @param fixedJackpot Fixed portion of the jackpot\n    /// @param ticketsSold Number of tickets sold in the current draw\n    /// @param isJackpot If it is jackpot reward\n    /// @param expectedPayout Expected payout to players per ticket, expressed in `rewardToken`\n    /// @return reward Reward size for the winning ticket\n    function calculateReward(\n        int256 netProfit,\n        uint256 fixedReward,\n        uint256 fixedJackpot,\n        uint256 ticketsSold,\n        bool isJackpot,\n        uint256 expectedPayout\n    )\n        internal\n        pure\n        returns (uint256 reward)\n    {\n        uint256 excess = calculateExcessPot(netProfit, fixedJackpot);\n        reward = isJackpot\n            ? fixedReward + excess.getPercentage(EXCESS_BONUS_ALLOCATION)\n            : fixedReward.getPercentage(calculateMultiplier(excess, ticketsSold, expectedPayout));\n    }\n\n    /// @dev Calculate frontend rewards amount for specific tickets sold\n    /// @param ticketPrice One lottery ticket price\n    /// @param ticketsSold Amount of tickets sold since last fee payout\n    /// @param rewardType Type of the reward we are calculating\n    /// @return dueRewards Total due rewards for the particular reward\n    function calculateRewards(\n        uint256 ticketPrice,\n        uint256 ticketsSold,\n        LotteryRewardType rewardType\n    )\n        internal\n        pure\n        returns (uint256 dueRewards)\n    {\n        uint256 rewardPercentage = (rewardType == LotteryRewardType.FRONTEND) ? FRONTEND_REWARD : STAKING_REWARD;\n        dueRewards = (ticketsSold * ticketPrice).getPercentage(rewardPercentage);\n    }\n}"
    }
  ]
}