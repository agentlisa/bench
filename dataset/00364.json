{
  "Title": "[M] DOS in LibChainlinkOracle when not considering phaseId",
  "Content": "# [M] DOS in LibChainlinkOracle when not considering phaseId\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-02-Beanstalk-1/blob/a3658861af8f5126224718af494d02352fbb3ea5/protocol/contracts/libraries/Oracle/LibChainlinkOracle.sol#L18\">https://github.com/Cyfrin/2024-02-Beanstalk-1/blob/a3658861af8f5126224718af494d02352fbb3ea5/protocol/contracts/libraries/Oracle/LibChainlinkOracle.sol#L18</a>\n\n\n## Summary\n```LibChainlinkOracle``` is not fully compatible with Chainlink's data model due to the lack of support for ```phaseId and aggregatorRoundId```. Chainlink's ```roundID``` is a composite number combining a ```phaseID and an aggregatorRoundID```. \n\nThe ```phaseID``` changes whenever there is an upgrade to the underlying aggregator, and this change causes \na significant jump in the ```roundID``` values due to the bit-shifting operation described in the documentation.\n\nref here: https://docs.chain.link/data-feeds/historical-data#solidity\n\n## Vulnerability Details\nThe Beanstalk ```LibChainlinkOracle``` misinterprets the progression of ```roundID``` as sequential, overlooking Chainlink's unique bundling of ```phaseId``` and ```aggregatorRoundId```. With the advancement of ```phaseID```, there's an exponential increase in ```roundID by 2^64,``` leading to a temporal suspension until a new interval commences. This will instigate a denial-of-service scenario. The ```getEthUsdTwap and getEthUsdPrice``` functions are particularly susceptible to this vulnerability, as they rely on accurate TWAP values for their computations, which effects for example any calls reliant on Oracle data.\n\n```\nfunction getRoundData(uint80 _roundId)\n    public\n    view\n    virtual\n    override\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    (uint16 phaseId, uint64 aggregatorRoundId) = parseIds(_roundId);\n\n    (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 ansIn\n    ) = phaseAggregators[phaseId].getRoundData(aggregatorRoundId);\n\n    return addPhaseIds(roundId, answer, startedAt, updatedAt, ansIn, phaseId);\n  }\n```\n\n```\n function latestRoundData()\n    public\n    view\n    virtual\n    override\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    Phase memory current = currentPhase; // cache storage reads\n\n    (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 ansIn\n    ) = current.aggregator.latestRoundData();\n\n    return addPhaseIds(roundId, answer, startedAt, updatedAt, ansIn, current.id);\n  }\n```\n\nhttps://etherscan.io/address/0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419#code\n\nThe code segment extracted from the ETH/USD Chainlink aggregator above highlights the composite structure of ```roundId```, \nintegrating both ```phaseId and aggregatorRoundId```. As highlighted, an increment in ```phaseId``` leads to a substantial \nleap in ```roundId by 2^64```, thereby bypassing a number of \"rounds.\" Consequently, any attempt to query \ncurrentRound - 1 post-upgrade encounters a non-existent round, triggering a revert. This condition could persist up to 24 hours based on configuration, impacting the timely execution of getEthUsdTwap and getEthUsdPrice. \n\nThese functions, once operational again, might utilize altered TWAP values for computations, diverging from \nexpected outcomes\n\n## Impact\n\nIf a ```phaseID``` increment occurs, it results in a jump in ``````roundID values, creating a gap in the sequence. \nWhen there are attempts to access round data for ```roundIDs``` within this gap, it will encounter inaccurate \nrounds, potentially causing the function to fail or return incorrect data, considering when the ```phaseID``` is incremented the ```roundID increases by 2 ** 64.``` This discrepancy can lead to a denial-of-servicein any calls to the oracle.\n\n## Tools Used\nManual Review\n\n## Recommendations\nCheck return values of roundId. If the ```roundID``` is a nonzero value and is reverting then the oracle needs to try again with a lower ```phaseId.```\n",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clsxlpte900074r5et7x6kh96",
  "Code": [
    {
      "filename": "protocol/contracts/libraries/Oracle/LibChainlinkOracle.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {C} from \"contracts/C.sol\";\nimport {IChainlinkAggregator} from \"contracts/interfaces/chainlink/IChainlinkAggregator.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n/**\n * @title Chainlink Oracle Library\n * @notice Contains functionalty to fetch prices from Chainlink price feeds.\n * @dev currently supports:\n * - ETH/USD price feed\n **/\nlibrary LibChainlinkOracle {\n    using SafeMath for uint256;\n\n    // Uses the same timeout as Liquity's Chainlink timeout.\n    uint256 public constant CHAINLINK_TIMEOUT = 14400; // 4 hours: 60 * 60 * 4\n\n    IChainlinkAggregator constant priceAggregator =\n        IChainlinkAggregator(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n    uint256 constant PRECISION = 1e6; // use 6 decimal precision.\n\n    /**\n     * @dev Returns the most recently reported ETH/USD price from the Chainlink Oracle.\n     * Return value has 6 decimal precision.\n     * Returns 0 if Chainlink's price feed is broken or frozen.\n     **/\n    function getEthUsdPrice() internal view returns (uint256 price) {\n        // First, try to get current decimal precision:\n        uint8 decimals;\n        try priceAggregator.decimals() returns (uint8 _decimals) {\n            // If call to Chainlink succeeds, record the current decimal precision\n            decimals = _decimals;\n        } catch {\n            // If call to Chainlink aggregator reverts, return a price of 0 indicating failure\n            return 0;\n        }\n\n        // Secondly, try to get latest price data:\n        try priceAggregator.latestRoundData() returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 /* startedAt */,\n            uint256 timestamp,\n            uint80 /* answeredInRound */\n        ) {\n            // Check for an invalid roundId that is 0\n            if (roundId == 0) return 0;\n            if (checkForInvalidTimestampOrAnswer(timestamp, answer, block.timestamp)) {\n                return 0;\n            }\n            // Adjust to 6 decimal precision.\n            return uint256(answer).mul(PRECISION).div(10 ** decimals);\n        } catch {\n            // If call to Chainlink aggregator reverts, return a price of 0 indicating failure\n            return 0;\n        }\n    }\n\n    /**\n     * @dev Returns the TWAP ETH/USD price from the Chainlink Oracle over the past `lookback` seconds.\n     * Return value has 6 decimal precision.\n     * Returns 0 if Chainlink's price feed is broken or frozen.\n     **/\n    function getEthUsdTwap(uint256 lookback) internal view returns (uint256 price) {\n        // First, try to get current decimal precision:\n        uint8 decimals;\n        try priceAggregator.decimals() returns (uint8 _decimals) {\n            // If call to Chainlink succeeds, record the current decimal precision\n            decimals = _decimals;\n        } catch {\n            // If call to Chainlink aggregator reverts, return a price of 0 indicating failure\n            return 0;\n        }\n\n        // Secondly, try to get latest price data:\n        try priceAggregator.latestRoundData() returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 /* startedAt */,\n            uint256 timestamp,\n            uint80 /* answeredInRound */\n        ) {\n            // Check for an invalid roundId that is 0\n            if (roundId == 0) return 0;\n            if (checkForInvalidTimestampOrAnswer(timestamp, answer, block.timestamp)) {\n                return 0;\n            }\n\n            uint256 endTimestamp = block.timestamp.sub(lookback);\n            // Check if last round was more than `lookback` ago.\n            if (timestamp <= endTimestamp) {\n                return uint256(answer).mul(PRECISION).div(10 ** decimals);\n            } else {\n                uint256 cumulativePrice;\n                uint256 lastTimestamp = block.timestamp;\n                // Loop through previous rounds and compute cumulative sum until\n                // a round at least `lookback` seconds ago is reached.\n                while (timestamp > endTimestamp) {\n                    cumulativePrice = cumulativePrice.add(\n                        uint256(answer).mul(lastTimestamp.sub(timestamp))\n                    );\n                    roundId -= 1;\n                    try priceAggregator.getRoundData(roundId) returns (\n                        uint80 /* roundId */,\n                        int256 _answer,\n                        uint256 /* startedAt */,\n                        uint256 _timestamp,\n                        uint80 /* answeredInRound */\n                    ) {\n                        if (checkForInvalidTimestampOrAnswer(_timestamp, _answer, timestamp)) {\n                            return 0;\n                        }\n                        lastTimestamp = timestamp;\n                        timestamp = _timestamp;\n                        answer = _answer;\n                    } catch {\n                        // If call to Chainlink aggregator reverts, return a price of 0 indicating failure\n                        return 0;\n                    }\n                }\n                cumulativePrice = cumulativePrice.add(\n                    uint256(answer).mul(lastTimestamp.sub(endTimestamp))\n                );\n                return cumulativePrice.mul(PRECISION).div(10 ** decimals).div(lookback);\n            }\n        } catch {\n            // If call to Chainlink aggregator reverts, return a price of 0 indicating failure\n            return 0;\n        }\n    }\n\n    function checkForInvalidTimestampOrAnswer(\n        uint256 timestamp,\n        int256 answer,\n        uint256 currentTimestamp\n    ) private pure returns (bool) {\n        // Check for an invalid timeStamp that is 0, or in the future\n        if (timestamp == 0 || timestamp > currentTimestamp) return true;\n        // Check if Chainlink's price feed has timed out\n        if (currentTimestamp.sub(timestamp) > CHAINLINK_TIMEOUT) return true;\n        // Check for non-positive price\n        if (answer <= 0) return true;\n    }\n}"
    }
  ]
}