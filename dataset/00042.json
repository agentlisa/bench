{
  "Title": "H-2: Users can frontrun LSTs/LRTs tokens prices decrease in order to avoid losses",
  "Content": "# Issue H-2: Users can frontrun LSTs/LRTs tokens prices decrease in order to avoid losses \n\nSource: https://github.com/sherlock-audit/2024-05-napier-update-judging/issues/65 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nzzykxx\n## Summary\n\nUsers can redeem their `PT`/`YT` tokens before a price decrease of a supported LST/LRT token in order to avoid losses.\n\n## Vulnerability Detail\n\nNapier allows users to redeem their `PT`/`YT` tokens for `ETH` via [BaseLSTAdapter::prefundedRedeem()](https://github.com/sherlock-audit/2024-05-napier-update/blob/main/napier-v1/src/adapters/BaseLSTAdapter.sol#L168) instantly if the amount to be withdrawn is lower or equal than the available `ETH` buffer. The in-scope adapters that allow this are:\n\n- [EETHAdapter](https://github.com/sherlock-audit/2024-05-napier-update/blob/main/napier-v1/src/adapters/etherfi/EETHAdapter.sol)\n- [UniEthAdapter](https://github.com/sherlock-audit/2024-05-napier-update/blob/main/napier-v1/src/adapters/bedrock/UniETHAdapter.sol)\n\nA Napier user that staked in one of these adapters can:\n\n1. Monitor the mempool and the beacon chain to know in advance if either the `eETH` or `uniETH` tokens will lose value.\n2. Frontrun the value loss by redeeming their `PT` and `YT`tokens via [Tranche::redeemWithYT()](https://github.com/sherlock-audit/2024-05-napier-update/blob/main/napier-v1/src/Tranche.sol#L231), which will call [BaseLSTAdapter::prefundedRedeem()](https://github.com/sherlock-audit/2024-05-napier-update/blob/main/napier-v1/src/adapters/BaseLSTAdapter.sol#L168), in exchange for `ETH`.\n\nBecause the value drop is still not reflected in the Napier protocol the staker will be able to withdraw his funds without being affected by the losses.\n\nIn the case of `eETH`, a rebase token, an attacker can know if a balance drop will happen by monitoring the mempool for calls to `rebase()` in the EtherFi [LiquidityPool](https://etherscan.io/address/0x308861A430be4cce5502d0A12724771Fc6DaF216#writeProxyContract) contract.\n\nIn the case of `uniEth` an attacker can know if the token will lose value by monitoring the protocol validators for penalties and slashing events. Bedrock (`uniEth`) is built on top of Eigenlayer, which can be notified of balance drops due to penalties or slashings via two permissionless functions: [EigenPod::verifyBalanceUpdates()](https://github.com/Layr-Labs/eigenlayer-contracts/blob/v0.2.1-goerli-m2/src/contracts/pods/EigenPod.sol#L185) and [EigenPod::verifyAndProcessWithdrawals()](https://github.com/Layr-Labs/eigenlayer-contracts/blob/v0.2.1-goerli-m2/src/contracts/pods/EigenPod.sol#L232). This allows an attacker to perform the following series of calls atomically to avoid losses:\n\n1. Monitor the Bedrock validators on the beacon chain for penalties and slashings.\n2. Call [Tranche::redeemWithYT()](https://github.com/sherlock-audit/2024-05-napier-update/blob/main/napier-v1/src/Tranche.sol#L231) to redeem `PT`/`YT` in exchange of `ETH`.\n3. Call [EigenPod::verifyBalanceUpdates()](https://github.com/Layr-Labs/eigenlayer-contracts/blob/v0.2.1-goerli-m2/src/contracts/pods/EigenPod.sol#L185)/[EigenPod::verifyAndProcessWithdrawals()](https://github.com/Layr-Labs/eigenlayer-contracts/blob/v0.2.1-goerli-m2/src/contracts/pods/EigenPod.sol#L232) to notify Eigenlayer of the balance drop.\n4. The value of `uniETH` will instantly drop.\n5. Deposit the previously withdrawn `ETH` for more `YT`/`PT` tokens than the initial amount.\n\nAnother instance that instantly lowers the value held by the `UniEthAdapter` adapter is the call to [UniETHAdapter::swapUniETHForETH()](https://github.com/sherlock-audit/2024-05-napier-update/blob/main/napier-v1/src/adapters/bedrock/UniETHAdapter.sol#L185) because a `0.05%` fee is paid to UniswapV3, this can also be front run by stakers to avoid bearing the losses of the fee.\n\n## Impact\n\nStakers can avoid losses, which implies honest stakers will lose more than they should.\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIntroduce a withdraw queue, this will prevent this kind of frontrunning attacks.\n\n\n\n\n## Discussion\n\n**massun-onibakuchi**\n\nIt is known behavior seen in many LST/LRT integrations like DEX \n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/369",
  "Code": [
    {
      "filename": "napier-v1/src/adapters/BaseLSTAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.19;\n\nimport {IWETH9} from \"../interfaces/IWETH9.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts@4.9.3/security/ReentrancyGuard.sol\";\n\nimport {StakeLimitTypes, StakeLimitUtils} from \"../utils/StakeLimitUtils.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts@4.9.3/utils/math/SafeCast.sol\";\nimport {WETH} from \"../Constants.sol\";\n\nimport {BaseAdapter} from \"../BaseAdapter.sol\";\nimport {BaseLSTVault} from \"./BaseLSTVault.sol\";\n\n/// @notice Adapter for Liquid Staking Token (LST)\n/// @dev This adapter facilitates immediate ETH withdrawals without a waiting period.\n/// It maintains an ETH buffer to enable these withdrawals. The size of this buffer is determined\n/// by a specified desired buffer percentage. The maintenance of the buffer\n/// are handled by a designated account.\n/// @dev LST Adapter is NOT compatible with EIP4626 standard. We don't expect it to be used by other contracts other than Tranche.\nabstract contract BaseLSTAdapter is BaseLSTVault, ReentrancyGuard {\n    using SafeCast for uint256;\n    using StakeLimitTypes for StakeLimitTypes.Uint256Data;\n    using StakeLimitTypes for StakeLimitTypes.Data;\n    using StakeLimitUtils for StakeLimitTypes.Data;\n\n    uint256 constant DEFAULT_MAX_STAKE_LIMIT = 10_000 ether;\n    uint256 constant DEFAULT_STAKE_LIMIT_INCREASE_PER_BLOCK = 0.00015 ether; // About 1 ether recovery per 1 day\n\n    /// @notice Total of ETH pending withdrawal request\n    uint128 public totalQueueEth;\n\n    /// @notice Amount of ETH available (Buffer), does not include pending withdrawal. Internal accounting of ETH\n    uint128 public bufferEth;\n\n    /// @notice Mapping of the withdrawal request ID to the amount of ETH\n    mapping(uint256 requestId => uint256 queueEth) public queueWithdrawal;\n\n    /// @notice Packed data for the stake limit state\n    StakeLimitTypes.Uint256Data internal packedStakeLimitData;\n\n    error WithdrawalPending();\n    error InvalidWithdrawalAmount();\n    error NoPendingWithdrawal();\n\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    event StakingPaused();\n    event StakingUnpaused();\n    event ClaimWithdrawal(uint256 requestId, uint256 queueAmount);\n    event RequestWithdrawal(uint256 requestId, uint256 queueAmount);\n\n    /// @dev Adapter itself is the target token\n    constructor(\n        address _rebalancer,\n        uint256 _maxStakeLimit,\n        uint256 _stakeLimitIncreasePerBlock\n    ) BaseLSTVault(_rebalancer) {\n        rebalancer = _rebalancer;\n        // Set the initial stake limit state\n        StakeLimitTypes.Data memory data = StakeLimitTypes.Data({\n            prevStakeBlockNumber: uint32(block.number),\n            prevStakeLimit: 0,\n            maxStakeLimitGrowthBlocks: 0,\n            maxStakeLimit: 0\n        });\n        packedStakeLimitData.setStorageStakeLimitStruct(\n            data.setStakingLimit(\n                _maxStakeLimit == 0 ? DEFAULT_MAX_STAKE_LIMIT : _maxStakeLimit,\n                _stakeLimitIncreasePerBlock == 0 ? DEFAULT_STAKE_LIMIT_INCREASE_PER_BLOCK : _stakeLimitIncreasePerBlock\n            )\n        );\n    }\n\n    ////////////////////////////////////////////////////////\n    /// ADAPTER METHOD\n    ////////////////////////////////////////////////////////\n\n    /// @notice Handles prefunded deposits\n    /// @return The amount of staked ETH\n    /// @return The amount of shares minted\n    function prefundedDeposit() external nonReentrant onlyTranche returns (uint256, uint256) {\n        uint256 bufferEthCache = bufferEth; // cache storage reads\n        uint256 queueEthCache = totalQueueEth; // cache storage reads\n        uint256 assets = IWETH9(WETH).balanceOf(address(this)) - bufferEthCache; // amount of WETH deposited at this time\n        uint256 shares = previewDeposit(assets);\n\n        if (assets == 0) return (0, 0);\n        if (shares == 0) revert ZeroShares();\n\n        // Calculate the target buffer amount considering the user's deposit.\n        // bufferRatio is defined as the ratio of ETH balance to the total assets in the adapter in ETH.\n        // Formula:\n        // desiredBufferRatio = (totalQueueEth + bufferEth + assets - s) / (totalQueueEth + bufferEth + stakedEth + assets)\n        // Where:\n        // assets := Amount of ETH the user is depositing\n        // s := Amount of ETH to stake at this time, s <= bufferEth + assets.\n        //\n        // Thus, the formula can be simplified to:\n        // s = (totalQueueEth + bufferEth + assets) - (totalQueueEth + bufferEth + stakedEth + assets) * desiredBufferRatio\n        //   = (totalQueueEth + bufferEth + assets) - targetBufferEth\n        //\n        // Flow:\n        // If `s` <= 0, don't stake any ETH.\n        // If `s` < bufferEth + assets, stake `s` amount of ETH.\n        // If `s` >= bufferEth + assets, all available ETH can be staked in theory.\n        // However, we cap the stake amount. This is to prevent the buffer from being completely drained.\n        //\n        // Let `a` be the available amount of ETH in the buffer after the deposit. `a` is calculated as:\n        // a = (bufferEth + assets) - s\n        uint256 targetBufferEth = ((totalAssets() + assets) * targetBufferPercentage) / BUFFER_PERCENTAGE_PRECISION;\n\n        /// WRITE ///\n        _mint(msg.sender, shares);\n\n        uint256 availableEth = bufferEthCache + assets; // non-zero\n\n        // If the buffer is insufficient or staking is paused, doesn't stake any of the deposit\n        StakeLimitTypes.Data memory data = packedStakeLimitData.getStorageStakeLimitStruct();\n        if (targetBufferEth >= availableEth + queueEthCache || data.isStakingPaused()) {\n            /// WRITE ///\n            bufferEth = availableEth.toUint128();\n            return (assets, shares);\n        }\n\n        // Calculate the amount of ETH to stake\n        uint256 stakeAmount; // can be 0\n        unchecked {\n            stakeAmount = availableEth + queueEthCache - targetBufferEth; // non-zero, no underflow\n        }\n        // If the calculated stake amount exceeds the available ETH, simply assign the available ETH to the stake amount.\n        // Possible scenarios:\n        // - Target buffer percentage was changed to a lower value and there is a large withdrawal request pending.\n        // - There is a pending withdrawal request and the available ETH are not left in the buffer.\n        // - There is no pending withdrawal request and the available ETH are not left in the buffer.\n        if (stakeAmount > availableEth) {\n            // Note: Admins should be aware of this situation and take action to refill the buffer.\n            // - Pause staking to prevent further staking until the buffer is refilled\n            // - Update stake limit to a lower value\n            // - Increase the target buffer percentage\n            stakeAmount = availableEth; // All available ETH\n        }\n\n        // If the amount of ETH to stake exceeds the current stake limit, cap the stake amount.\n        // This is to prevent the buffer from being completely drained. This is not a complete solution.\n        uint256 currentStakeLimit = StakeLimitUtils.calculateCurrentStakeLimit(data); // can be 0 if the stake limit is exhausted\n        if (stakeAmount > currentStakeLimit) {\n            stakeAmount = currentStakeLimit;\n        }\n        /// WRITE ///\n        // Update the stake limit state in the storage\n        packedStakeLimitData.setStorageStakeLimitStruct(data.updatePrevStakeLimit(currentStakeLimit - stakeAmount));\n\n        /// INTERACT ///\n        // Deposit into the yield source\n        // Actual amount of ETH spent may be less than the requested amount.\n        stakeAmount = _stake(stakeAmount); // stake amount can be 0\n\n        /// WRITE ///\n        bufferEth = (availableEth - stakeAmount).toUint128(); // no underflow theoretically\n\n        return (assets, shares);\n    }\n\n    /// @notice Handles prefunded redemptions\n    /// @dev Withdraw from the buffer. If the buffer is insufficient, revert with an error\n    /// @param recipient The address to receive the redeemed WETH\n    /// @return The amount of redeemed WETH\n    /// @return The amount of shares burned\n    function prefundedRedeem(address recipient) external virtual onlyTranche returns (uint256, uint256) {\n        uint256 shares = balanceOf(address(this));\n        uint256 assets = previewRedeem(shares);\n\n        if (shares == 0) return (0, 0);\n        if (assets == 0) revert ZeroAssets();\n\n        uint256 bufferEthCache = bufferEth;\n        // If the buffer is insufficient, shares cannot be redeemed immediately\n        // Need to wait for the withdrawal to be completed and the buffer to be refilled.\n        if (assets > bufferEthCache) revert InsufficientBuffer();\n\n        unchecked {\n            /// WRITE ///\n            // Reduce the buffer and burn the shares\n            bufferEth = (bufferEthCache - assets).toUint128(); // no underflow\n            _burn(address(this), shares);\n        }\n\n        /// INTERACT ///\n        IWETH9(WETH).transfer(recipient, assets);\n\n        return (assets, shares);\n    }\n\n    ////////////////////////////////////////////////////////\n    /// VIRTUAL METHOD\n    ////////////////////////////////////////////////////////\n\n    /// @notice Request a withdrawal of ETH\n    /// @dev This function is called by only the rebalancer\n    /// @dev Reverts if there is a pending withdrawal request\n    /// @dev Reverts if the buffer is sufficient to cover the desired buffer percentage of the total assets\n    function requestWithdrawal() external virtual nonReentrant onlyRebalancer {\n        uint256 targetBufferEth = (totalAssets() * targetBufferPercentage) / BUFFER_PERCENTAGE_PRECISION;\n\n        // If the buffer exceeds the target buffer, revert.\n        // If the buffer is insufficient, request a withdrawal to refill the buffer.\n        // note: use `>=` instead of `>` to prevent amount of ETH to withdraw to be 0\n        uint256 sum = bufferEth + totalQueueEth;\n        if (sum >= targetBufferEth) revert BufferTooLarge();\n\n        unchecked {\n            uint256 withdrawAmount = targetBufferEth - sum; // no underflow\n\n            /// WRITE & INTERACT ///\n            // Record the pending withdrawal request\n            // Request a withdrawal\n            (uint256 queueAmount, uint256 _requestId) = _requestWithdrawal(withdrawAmount);\n\n            if (queueWithdrawal[_requestId] != 0) revert WithdrawalPending();\n            totalQueueEth += queueAmount.toUint128();\n            queueWithdrawal[_requestId] = queueAmount;\n        }\n    }\n\n    /// @notice Request a withdrawal of all staked ETH\n    /// @dev This function is called by only the rebalancer\n    /// @dev Reverts if there is a pending withdrawal request\n    function requestWithdrawalAll() external virtual;\n\n    /// @notice Claim the finized withdrawal request\n    /// @param _requestId The request Id of the withdrawal request\n    /// @dev This function is called by anyone\n    /// @dev Reverts if there is no pending withdrawal request\n    function claimWithdrawal(uint256 _requestId) external virtual;\n\n    /// @notice Request a withdrawal of the given amount of ETH from the yield source\n    /// @param withdrawAmount The amount of ETH to withdraw\n    /// @return queueAmount The amount of ETH withdrawn\n    /// @return requestId The request Id of the withdrawal request\n    function _requestWithdrawal(\n        uint256 withdrawAmount\n    ) internal virtual returns (uint256 queueAmount, uint256 requestId);\n\n    ////////////////////////////////////////////////////////\n    /// VIEW METHOD\n    ////////////////////////////////////////////////////////\n\n    /// @notice Returns the present buffer percentage in WAD. e.g) 10% => 0.1 * 1e18\n    function bufferPresentPercentage() external view override returns (uint256) {\n        return ((bufferEth + totalQueueEth) * BUFFER_PERCENTAGE_PRECISION) / totalAssets();\n    }\n\n    /// @notice Check staking state: whether it's paused or not\n    function isStakingPaused() external view returns (bool) {\n        return packedStakeLimitData.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n    /// @notice Returns how much Ether can be staked into a yield source (Lido, RocketPool, etc.)\n    /// @dev Special return values:\n    /// - 0 if staking is paused or if limit is exhausted.\n    function getCurrentStakeLimit() external view returns (uint256) {\n        StakeLimitTypes.Data memory data = packedStakeLimitData.getStorageStakeLimitStruct();\n        if (data.isStakingPaused()) {\n            return 0;\n        }\n        return data.calculateCurrentStakeLimit();\n    }\n\n    ////////////////////////////////////////////////////////\n    /// ADMIN METHOD\n    ////////////////////////////////////////////////////////\n\n    /// @notice Sets the staking rate limit\n    ///\n    /// ▲ Stake limit\n    /// │.....  .....   ........ ...            ....     ... Stake limit = max\n    /// │      .       .        .   .   .      .    . . .\n    /// │     .       .              . .  . . .      . .\n    /// │            .                .  . . .\n    /// │──────────────────────────────────────────────────> Time\n    /// │     ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n    ///\n    /// @dev Reverts if:\n    /// - `_maxStakeLimit` == 0\n    /// - `_maxStakeLimit` >= 2^96\n    /// - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n    /// - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n    ///\n    /// Emits `StakingLimitSet` event\n    ///\n    /// @param _maxStakeLimit max stake limit value\n    /// @param _stakeLimitIncreasePerBlock stake limit increase per single block\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external onlyOwner {\n        StakeLimitTypes.Data memory data = packedStakeLimitData.getStorageStakeLimitStruct();\n        /// WRITE ///\n        packedStakeLimitData.setStorageStakeLimitStruct(\n            data.setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    function pauseStaking() external onlyOwner {\n        StakeLimitTypes.Data memory data = packedStakeLimitData.getStorageStakeLimitStruct();\n        /// WRITE ///\n        packedStakeLimitData.setStorageStakeLimitStruct(data.setStakeLimitPauseState(true));\n        emit StakingPaused();\n    }\n\n    function unpauseStaking() external onlyOwner {\n        StakeLimitTypes.Data memory data = packedStakeLimitData.getStorageStakeLimitStruct();\n        /// WRITE ///\n        packedStakeLimitData.setStorageStakeLimitStruct(data.setStakeLimitPauseState(false));\n        emit StakingUnpaused();\n    }\n}"
    },
    {
      "filename": "napier-v1/src/Tranche.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.19;\n\n// interfaces\nimport {IERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/IERC20.sol\";\nimport {IERC5095} from \"./interfaces/IERC5095.sol\";\nimport {ITranche} from \"./interfaces/ITranche.sol\";\nimport {IYieldToken} from \"./interfaces/IYieldToken.sol\";\nimport {ITrancheFactory} from \"./interfaces/ITrancheFactory.sol\";\nimport {IBaseAdapter} from \"./interfaces/IBaseAdapter.sol\";\n// libs\nimport {Math} from \"@openzeppelin/contracts@4.9.3/utils/math/Math.sol\";\nimport {FixedPointMathLib} from \"./utils/FixedPointMathLib.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts@4.9.3/utils/math/SafeCast.sol\";\nimport {SafeERC20Namer} from \"./utils/SafeERC20Namer.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/utils/SafeERC20.sol\";\nimport {MAX_BPS} from \"./Constants.sol\";\n// inheriting\nimport {ERC20Permit, ERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/extensions/ERC20Permit.sol\";\nimport {Pausable} from \"@openzeppelin/contracts@4.9.3/security/Pausable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts@4.9.3/security/ReentrancyGuard.sol\";\nimport {BaseToken} from \"./BaseToken.sol\";\n\n/// @title Tranche\n/// @author Napier Labs\n/// @author 0xbakuchi\n/// @notice Tranche divides a yield-bearing token into two tokens: principal token and yield token.\n/// This contract itself is a principal token.\n/// Users can interact with this contract to issue, redeem tokens, and gather yield.\n/// Both the Principal and Yield tokens share the same decimal notation as the underlying token.\n/// Math:\n/// - Yield Stripping Math paper: https://github.com/Napier-Lab/napier-v1/blob/main/assets/Yield_Stripping_Math__1_.pdf\n/// - Hackmd: https://hackmd.io/W2mPhP7YRjGxqnAc93omLg?both\n/// PT/YT and Target token conversion is defined as:\n/// P = T * scale / 1e18\n///   = T * price * 10^(18 + uDecimals - tDecimals) / 1e18\n/// Where P is amount of PT and T is amount of Target.\n/// @dev Supported Tokens:\n/// - Underlying token can be rebased token.\n/// - Underlying must not be ERC777 token.\n/// - Target token can not be rebased token.\ncontract Tranche is BaseToken, ReentrancyGuard, Pausable, ITranche {\n    using SafeERC20 for IERC20;\n    using FixedPointMathLib for uint256;\n    using SafeCast for uint256;\n\n    uint8 internal immutable uDecimals;\n\n    /// @notice Represents the underlying token where users deposit (e.g. DAI)\n    IERC20 internal immutable _underlying;\n\n    /// @notice Represents the yield-bearing token (e.g. cDAI)\n    IERC20 internal immutable _target;\n\n    /// @notice Represents the Yield token that represents the right to claim the yield\n    IYieldToken internal immutable _yt;\n\n    /// @notice An adapter that interacts with the yield source (e.g. Compound)\n    IBaseAdapter public immutable adapter;\n\n    /// @notice Address of the management account\n    address public immutable management;\n\n    // Principal token Parameters\n\n    /// @inheritdoc IERC5095\n    /// @notice The timestamp of maturity in unix seconds\n    uint256 public immutable override(BaseToken, IERC5095) maturity;\n\n    /// @notice The fee for issuing new tokens (10000 = 100%)\n    uint256 internal immutable issuanceFeeBps;\n\n    //////////////////////////////////////////////////\n    // State Variables\n    //////////////////////////////////////////////////\n\n    /// @notice Variables tracking the yield-bearing token's scales\n    /// @dev This is used to calculate the claimable yield and is updated on every issue, collect, and redeemYT action.\n    ///  - `mscale` represents the scale of the yield-bearing token at or after maturity,\n    /// it is set only at the time of users redeeming, redeemingYT and collecting at/after maturity.\n    ///  - `maxscale` represents the maximum scale of the yield-bearing token since the Tranche's creation till now.\n    GlobalScales internal gscales;\n\n    /// @dev The address that receives the issuance fees. This address can be changed by the `management`.\n    address public feeRecipient;\n\n    /// @notice Keeps track of the scale of the target token at the last user action.\n    /// @dev It is used for calculating the yield that can be claimed. It gets updated on every user action.\n    /// user -> lscale (last scale)\n    /// See \"Yield Stripping Math\" for more details.\n    mapping(address => uint256) public lscales;\n\n    /// @notice Keeps track of the yield not claimed by each user in units of the target token.\n    /// @dev This value is reset to 0 on every issue, collect and redeemYT action. Every YT transfer also increases this value.\n    mapping(address => uint256) public unclaimedYields;\n\n    /* ================== MODIFIERS =================== */\n\n    /// @notice Revert if timestamp is before maturity\n    modifier expired() {\n        if (block.timestamp < maturity) revert TimestampBeforeMaturity();\n        _;\n    }\n\n    /// @notice Revert if timestamp is at or after maturity\n    modifier notExpired() {\n        if (block.timestamp >= maturity) revert TimestampAfterMaturity();\n        _;\n    }\n\n    /// @notice Revert if reentrancy guard is already set to `entered`\n    modifier notEntered() {\n        if (_reentrancyGuardEntered()) revert ReentrancyGuarded();\n        _;\n    }\n\n    /// @notice Revert if msg sender is not management address\n    modifier onlyManagement() {\n        if (msg.sender != management) revert Unauthorized();\n        _;\n    }\n\n    /// @dev Assume Tranche is deployed from a factory.\n    /// Doesn't take constructor arguments directly so that CREATE2 address is independent of the constructor arguments.\n    /// The arguments are fetched through a callback to the factory.\n    /// @custom:param _args The arguments for the Tranche contract.\n    ///\n    /// The constructor is `payable` to remove msg.value check and reduce about 198 gas cost at deployment time.\n    /// This is acceptable because the factory contract doesn't deploy Tranche with ETH.\n    constructor() payable ERC20(\"Napier Principal Token\", \"ePT\") ERC20Permit(\"Napier Principal Token\") {\n        // Retrieve constructor arguments from the factory\n        ITrancheFactory.TrancheInitArgs memory args = ITrancheFactory(msg.sender).args();\n        address underlying_ = IBaseAdapter(args.adapter).underlying();\n        address target_ = IBaseAdapter(args.adapter).target();\n\n        // Initialize immutable and state variables\n        feeRecipient = args.management;\n        management = args.management;\n\n        _underlying = IERC20(underlying_);\n        _target = IERC20(target_);\n        _yt = IYieldToken(args.yt);\n        adapter = IBaseAdapter(args.adapter);\n        issuanceFeeBps = args.issuanceFee;\n        maturity = args.maturity;\n        uDecimals = ERC20(underlying_).decimals();\n        // Set maxscale to the current scale\n        gscales.maxscale = IBaseAdapter(args.adapter).scale().toUint128();\n\n        emit SeriesCreated(args.adapter, args.maturity, args.issuanceFee);\n    }\n\n    /* ================== MUTATIVE METHODS =================== */\n\n    /// @inheritdoc ITranche\n    /// @notice This function issues Principal Token (PT) and Yield Token (YT) to `to` in exchange for `underlyingAmount` of underlying token.\n    /// Issuance Fee is charged on the amount of underlying token used to issue PT and YT.\n    /// If `to` has accrued some yield, it will be added to the user's unclaimed yield and can be claimed later.\n    /// @dev The function will be reverted if the maturity has passed.\n    /// @param to The recipient of PT and YT\n    /// @param underlyingAmount The amount of underlying token to be deposited. (in units of underlying token)\n    /// @return issued The amount of PT and YT minted\n    function issue(\n        address to,\n        uint256 underlyingAmount\n    ) external nonReentrant whenNotPaused notExpired returns (uint256 issued) {\n        uint256 _lscale = lscales[to];\n        uint256 _maxscale = gscales.maxscale;\n\n        // NOTE: Updating mscale/maxscale in the cache before the issue to determine the accrued yield.\n        uint256 cscale = adapter.scale();\n\n        if (cscale > _maxscale) {\n            // If the current scale is greater than the maxscale, update scales\n            _maxscale = cscale;\n            gscales.maxscale = cscale.toUint128();\n        }\n\n        // Deduct the issuance fee from the amount of underlying token deposited by the user\n        // Fee should be rounded up towards the protocol (against the user) so that issued principal is rounded down\n        // ```\n        // fee = u * feeBps\n        // shares = (u - fee) / s\n        // ptIssued = shares * S\n        // ```\n        // where u = underlyingAmount, s = current scale and S = maxscale\n        uint256 fee = underlyingAmount.mulDivUp(issuanceFeeBps, MAX_BPS);\n\n        // Updating user's last scale to the latest maxscale\n        lscales[to] = _maxscale;\n\n        // If recipient has unclaimed interest, add it to the user's unclaimed yield.\n        // Reminder: lscale is the last scale when the YT balance of the user was updated.\n        if (_lscale != 0) {\n            uint256 yBal = _yt.balanceOf(to);\n            unclaimedYields[to] += _computeAccruedInterestInTarget(_maxscale, _lscale, yBal);\n        }\n\n        // Transfer fee to `feeRecipient` and the remaining underlying to the adapter\n        _underlying.safeTransferFrom(msg.sender, feeRecipient, fee);\n        _underlying.safeTransferFrom(msg.sender, address(adapter), underlyingAmount - fee);\n        (, uint256 sharesMinted) = adapter.prefundedDeposit();\n\n        // Compute the amount of PT and YT to be minted\n        // See above for the formula\n        issued = sharesMinted.mulWadDown(_maxscale);\n\n        // Mint PT and YT to user\n        _mint(to, issued);\n        _yt.mint(to, issued);\n\n        emit Issue(msg.sender, to, issued, sharesMinted);\n    }\n\n    /// @inheritdoc ITranche\n    /// @notice Withdraws underlying tokens from the caller in exchange for `amount` of PT and YT.\n    /// 1 PT + 1 YT = 1 Target token (e.g. 1 wstETH). This equation is always true\n    /// because PT represents the principal amount of the Target token and YT represents the yield of the Target token.\n    /// Basically, anyone can burn `x` PT and `x` YT to withdraw `x` Target tokens anytime.\n    ///\n    /// Withdrawn amount will be the sum of the following:\n    /// - amount derived from PT + YT burn\n    /// - amount of unclaimed yield\n    /// - amount of accrued yield from the last time when the YT balance was updated to now\n    /// @notice If the caller is not `from`, `from` must have approved the caller to spend `pyAmount` for PT and YT prior to calling this function.\n    /// @dev Reverts if the caller does not have enough PT and YT.\n    /// @param from The owner of PT and YT.\n    /// @param to The recipient of the redeemed underlying tokens.\n    /// @param pyAmount The amount of principal token (and yield token) to redeem in units of underlying tokens.\n    /// @return (uint256) The amount of underlying tokens redeemed.\n    function redeemWithYT(address from, address to, uint256 pyAmount) external nonReentrant returns (uint256) {\n        uint256 _lscale = lscales[from];\n        uint256 accruedInTarget = unclaimedYields[from];\n\n        // Calculate the accrued interest in Target token\n        // The lscale should not be 0 because the user should have some YT balance\n        if (_lscale == 0) revert NoAccruedYield();\n\n        GlobalScales memory _gscales = gscales;\n        _updateGlobalScalesCache(_gscales);\n\n        uint256 ytBal = _yt.balanceOf(from);\n        // Compute the accrued yield from the time when the YT balance is updated last to now\n        // The accrued yield in units of target is computed as:\n        // Formula: yield = ytBalance * (1/lscale - 1/maxscale)\n        // Sum up the accrued yield, plus the unclaimed yield from the last time to now\n        accruedInTarget += _computeAccruedInterestInTarget(\n            _gscales.maxscale,\n            _lscale,\n            // Use yt balance instead of `pyAmount`\n            // because we'll update the user's lscale to the current maxscale after this line\n            // regardless of whether the user redeems all of their yt or not.\n            // Otherwise, the user will lose some accrued yield from the last time to now.\n            ytBal\n        );\n        // Compute shares equivalent to the amount of principal token to redeem\n        uint256 sharesRedeemed = pyAmount.divWadDown(_gscales.maxscale);\n\n        // Update the local scale and accrued yield of `from`\n        lscales[from] = _gscales.maxscale;\n        gscales = _gscales;\n        uint256 accruedProportional = (accruedInTarget * pyAmount) / ytBal;\n        unclaimedYields[from] = accruedInTarget - accruedProportional;\n\n        // Burn PT and YT tokens from `from`\n        _burnFrom(from, pyAmount);\n        _yt.burnFrom(from, msg.sender, pyAmount);\n\n        // Withdraw underlying tokens from the adapter and transfer them to the user\n        _target.safeTransfer(address(adapter), sharesRedeemed + accruedProportional);\n        (uint256 amountWithdrawn, ) = adapter.prefundedRedeem(to);\n\n        emit RedeemWithYT(from, to, amountWithdrawn);\n        return amountWithdrawn;\n    }\n\n    /// @inheritdoc IERC5095\n    /// @notice If the sender is not `from`, it must have approval from `from` to redeem `principalAmount` PT.\n    /// Redeems `principalAmount` PT from `from` and transfers underlying tokens to `to`.\n    /// @dev Reverts if maturity has not passed.\n    /// @param principalAmount The amount of principal tokens to redeem in units of underlying tokens.\n    /// @param to The recipient of the redeemed underlying tokens.\n    /// @param from The owner of the PT.\n    /// @return (uint256) The amount of underlying tokens redeemed.\n    function redeem(\n        uint256 principalAmount,\n        address to,\n        address from\n    ) external override nonReentrant expired returns (uint256) {\n        GlobalScales memory _gscales = gscales;\n        _updateGlobalScalesCache(_gscales);\n\n        // Compute the shares to be redeemed\n        uint256 shares = _computeSharesRedeemed(_gscales, principalAmount);\n\n        gscales = _gscales;\n        // Burn PT tokens from `from`\n        _burnFrom(from, principalAmount);\n        // Withdraw underlying tokens from the adapter and transfer them to `to`\n        _target.safeTransfer(address(adapter), shares);\n        (uint256 underlyingWithdrawn, ) = adapter.prefundedRedeem(to);\n\n        emit Redeem(from, to, underlyingWithdrawn);\n        return underlyingWithdrawn;\n    }\n\n    /// @inheritdoc IERC5095\n    /// @notice If the sender is not `from`, it must have approval from `from` to redeem an equivalent amount of principal tokens.\n    /// Redeems PT equivalent to `underlyingAmount` underlying tokens from `from` and transfers underlying tokens to `to`.\n    /// @notice Note: The function doesn't comply with EIP-5095. `to` may receive an amount of underlying tokens not exactly equal to the input parameter `underlyingAmount`\n    /// @dev Reverts if maturity has not passed.\n    /// @param underlyingAmount The amount of underlying tokens to redeem in units of underlying tokens.\n    /// @param to The recipient of the redeemed underlying tokens.\n    /// @param from The owner of the PT.\n    /// @return (uint256) The amount of principal tokens redeemed.\n    function withdraw(\n        uint256 underlyingAmount,\n        address to,\n        address from\n    ) external override nonReentrant expired returns (uint256) {\n        GlobalScales memory _gscales = gscales;\n        uint256 cscale = _updateGlobalScalesCache(_gscales);\n\n        // Compute the shares to be redeemed\n        uint256 sharesRedeem = underlyingAmount.divWadDown(cscale);\n        uint256 principalAmount = _computePrincipalTokenRedeemed(_gscales, sharesRedeem);\n\n        // Update the global scales\n        gscales = _gscales;\n        // Burn PT tokens from `from`\n        _burnFrom(from, principalAmount);\n        // Withdraw underlying tokens from the adapter and transfer them to `to`\n        _target.safeTransfer(address(adapter), sharesRedeem);\n        (uint256 underlyingWithdrawn, ) = adapter.prefundedRedeem(to);\n\n        emit Redeem(from, to, underlyingWithdrawn);\n        return principalAmount;\n    }\n\n    /// @notice Before transferring YT, update the accrued yield for the sender and receiver.\n    /// NOTE: Every YT transfer will trigger this function to track accrued yield for each user.\n    /// @dev This function is only callable by the Yield Token contract when the user transfers YT to another user.\n    /// NOTE: YT is not burned in this function even if the maturity has passed.\n    /// @param from The address to transfer the Yield Token from.\n    /// @param to The address to transfer the Yield Token to (CAN be the same as `from`).\n    /// NOTE: `from` and `to` SHOULD NOT be zero addresses.\n    /// @param value The amount of Yield Token transferred to `to` (CAN be 0).\n    function updateUnclaimedYield(address from, address to, uint256 value) external nonReentrant whenNotPaused {\n        if (msg.sender != address(_yt)) revert OnlyYT();\n        if (from == address(0) || to == address(0)) revert ZeroAddress();\n        if (value == 0) return;\n\n        GlobalScales memory _gscales = gscales;\n        uint256 _lscaleFrom = lscales[from];\n\n        // If the lscale is 0, it means the user have never hold any YT before\n        // because the lscale is always set to maxscale when the YT is transferrred or minted.\n        // This doesn't mean current YT balance is 0 because the user could have transferred all YT out or burned YT.\n        // Thus there is no accrued interest for the user.\n        if (_lscaleFrom == 0) revert NoAccruedYield();\n\n        _updateGlobalScalesCache(_gscales);\n\n        // Calculate the accrued interest in Target token for `from`\n        unclaimedYields[from] += _computeAccruedInterestInTarget(_gscales.maxscale, _lscaleFrom, _yt.balanceOf(from));\n        lscales[fr"
    }
  ]
}