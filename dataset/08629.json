{
  "Title": "[M-09] NibblVault buyout duration longer than update timelock",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/NibblVaultFactoryData.sol#L6\nhttps://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L158-L169\nhttps://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L37\n\n\n# Vulnerability details\n\n## Impact\nUser can buy out NFT by initiating the process through `initiateBuyout`, then he has to wait `BUYOUT_DURATION` which is 5 days and if the buyout will not get rejected he can claim the NFT. During that period bidder cannot cancel the process. The issue is that since `NibblVault` is used through proxy it is possible to change its implementation through administrative functionality in `NibblVaultFactory` and the timelock for update'ing implementation is only 2 days.\n\nAttack Scenario:\n1. Bidder initiates buyout through `initiateBuyout`\n2. Administrator of the protocol updates the `vaultImplementation` through `proposeNewVaultImplementation`\n3. Bidder really does not like new implementation but cannot cancel buyout process\n4. Administrator waits 2 days (the `UPDATE_TIME`) uses `updateVaultImplementation` and changes the implementation\n5. Bidder loses funds/fait in the protocol\n\n## Proof of Concept\n* https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/NibblVaultFactoryData.sol#L6\n* https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L158-L169\n* https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L37\n\n## Tools Used\nManual Review / VSCode\n\n## Recommended Mitigation Steps\nIt is recommended to either implement functionality for bidder to cancel the bid or increase/decrease the `UPDATE_TIME`/`BUYOUT_DURATION` so the invariant `BUYOUT_DURATION < UPDATE_TIME` holds.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-06-nibbl-contest",
  "Code": [
    {
      "filename": "contracts/Utilities/NibblVaultFactoryData.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.10;\n\ncontract NibblVaultFactoryData {\n    uint256 public UPDATE_TIME = 2 days;\n    uint256 public constant MAX_ADMIN_FEE = 10_000; //1%\n\n    address public vaultImplementation;\n    address public pendingVaultImplementation;\n    uint256 public vaultUpdateTime; //Cooldown period\n\n    address public feeTo;\n    address public pendingFeeTo;\n    uint256 public feeToUpdateTime; //Cooldown period  \n\n    uint256 public feeAdmin = 2_000;\n    uint256 public pendingFeeAdmin;\n    uint256 public feeAdminUpdateTime; //Cooldown period\n\n    address public basketImplementation;\n    address public pendingBasketImplementation;\n    uint256 public basketUpdateTime; //Cooldown period    \n\n}"
    },
    {
      "filename": "contracts/NibblVaultFactory.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.10;\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport { Pausable } from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport { NibblVault } from \"./NibblVault.sol\";\nimport { SafeMath } from  \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { ProxyVault } from \"./Proxy/ProxyVault.sol\";\nimport { ProxyBasket } from \"./Proxy/ProxyBasket.sol\";\nimport { NibblVaultFactoryData } from \"./Utilities/NibblVaultFactoryData.sol\";\nimport { AccessControlMechanism } from \"./Utilities/AccessControlMechanism.sol\";\nimport { INibblVaultFactory } from \"./Interfaces/INibblVaultFactory.sol\";\nimport { Basket } from \"./Basket.sol\";\n\ncontract NibblVaultFactory is INibblVaultFactory, AccessControlMechanism, Pausable, NibblVaultFactoryData {\n    /// @notice Minimum initial reserve balance a user has to deposit to create a new vault\n    uint256 private constant MIN_INITIAL_RESERVE_BALANCE = 1e9;\n\n    /// @notice array containing the addresses of all the vaults\n    ProxyVault[] public nibbledTokens;\n    constructor (address _vaultImplementation, address _feeTo, address _admin, address _basketImplementation) AccessControlMechanism(_admin) {\n        vaultImplementation = _vaultImplementation;\n        feeTo = _feeTo;\n        basketImplementation = _basketImplementation;\n    }\n\n    /// @notice mints a new vault\n    /// @param _assetAddress address of the NFT contract which is being fractionalized\n    /// @param _curator address of the vault curator\n    /// @param _name name of the fractional token to be created\n    /// @param _symbol symbol of the fractional token\n    /// @param _assetTokenID tokenId of the NFT being fractionalized\n    /// @param _initialSupply desired initial token supply\n    /// @param _initialTokenPrice desired initial token price\n    /// @param _minBuyoutTime minimum time after which buyout can be triggered\n    function createVault(\n        address _assetAddress,\n        address _curator,\n        string memory _name,\n        string memory _symbol,\n        uint256 _assetTokenID,\n        uint256 _initialSupply,\n        uint256 _initialTokenPrice,\n        uint256 _minBuyoutTime\n        ) external payable override whenNotPaused returns(address payable _proxyVault) {\n        require(msg.value >= MIN_INITIAL_RESERVE_BALANCE, \"NibblVaultFactory: Initial reserve balance too low\");\n        require(IERC721(_assetAddress).ownerOf(_assetTokenID) == msg.sender, \"NibblVaultFactory: Invalid sender\");\n        _proxyVault = payable(new ProxyVault{salt: keccak256(abi.encodePacked(_curator, _assetAddress, _assetTokenID, _initialSupply, _initialTokenPrice))}(payable(address(this))));\n        NibblVault _vault = NibblVault(payable(_proxyVault));\n        _vault.initialize{value: msg.value}(_name, _symbol, _assetAddress, _assetTokenID, _curator, _initialSupply,_initialTokenPrice, _minBuyoutTime);\n        IERC721(_assetAddress).safeTransferFrom(msg.sender, address(_vault), _assetTokenID);\n        nibbledTokens.push(ProxyVault(_proxyVault));\n        emit Fractionalise(_assetAddress, _assetTokenID, _proxyVault);\n    }\n\n    /// @notice get address of vault to be deployed\n    /// @param _curator address of curator\n    /// @param _assetAddress address of the NFT contract which is being fractionalized\n    /// @param _assetTokenID tokenId of the NFT being fractionalized\n    /// @param _initialSupply desired initial token supply\n    /// @param _initialTokenPrice desired initial token price    \n    function getVaultAddress(\n        address _curator,\n        address _assetAddress,\n        uint256 _assetTokenID,\n        uint256 _initialSupply,\n        uint256 _initialTokenPrice) public view returns(address _vault) {\n        bytes32 newsalt = keccak256(abi.encodePacked(_curator, _assetAddress, _assetTokenID,  _initialSupply, _initialTokenPrice));\n        bytes memory code = abi.encodePacked(type(ProxyVault).creationCode, uint256(uint160(address(this))));\n        bytes32 _hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code)));\n        _vault = address(uint160(uint256(_hash)));     \n    }\n\n    function getVaults() public view returns(ProxyVault[] memory ) {\n        return nibbledTokens;\n    }\n\n    function createBasket(address _curator, string memory _mix) public override returns(address)  {\n        address payable _basketAddress = payable(new ProxyBasket{salt: keccak256(abi.encodePacked(_curator, _mix))}(basketImplementation));\n        Basket _basket = Basket(_basketAddress);\n        _basket.initialise(_curator);\n        emit BasketCreated(_curator, _basketAddress);\n        return _basketAddress;\n    }\n\n    function getBasketAddress(address _curator, string memory _mix) public override view returns(address _basket) {\n        bytes32 newsalt = keccak256(abi.encodePacked(_curator, _mix));\n        bytes memory code = abi.encodePacked(type(ProxyBasket).creationCode, uint256(uint160(basketImplementation)));\n        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code)));\n        _basket = address(uint160(uint256(hash)));     \n    }\n\n    /// @notice proposes new Basket implementation\n    /// @dev new implementation can be updated only after timelock\n    /// @dev can only be called by IMPLEMENTER_ROLE\n    /// @param _newBasketImplementation new implementation basket address\n    function proposeNewBasketImplementation(address _newBasketImplementation) external override onlyRole(IMPLEMENTER_ROLE) {\n        pendingBasketImplementation = _newBasketImplementation;\n        basketUpdateTime = block.timestamp + UPDATE_TIME;\n    }\n\n    /// @notice updates new basket implementation\n    /// @dev new vault implementation can be updated only after timelock\n    function updateBasketImplementation() external override {\n        require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n        basketImplementation = pendingBasketImplementation;\n        delete basketUpdateTime;\n    }\n\n    function withdrawAdminFee() external override {\n        (bool _success, ) = payable(feeTo).call{value: address(this).balance}(\"\");\n        require(_success);\n    }\n\n    // Cancellation functions aren't required as we can call propose function again with different parameters\n\n    /// @notice proposes new admin fee address\n    /// @dev new address can be updated only after timelock\n    /// @dev can only be called by FEE_ROLE\n    /// @param _newFeeAddress new address to receive admin fee on address\n    function proposeNewAdminFeeAddress(address _newFeeAddress) external override onlyRole(FEE_ROLE) {\n        pendingFeeTo = _newFeeAddress;\n        feeToUpdateTime = block.timestamp + UPDATE_TIME;\n    }\n\n    /// @notice updates new admin fee address\n    /// @dev can only be updated after timelock\n    function updateNewAdminFeeAddress() external override {\n        require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n        feeTo = pendingFeeTo;\n        delete feeToUpdateTime;\n    }\n\n    /// @notice proposes new admin fee\n    /// @dev new fee can be updated only after timelock\n    /// @dev can only be called by FEE_ROLE\n    /// @param _newFee new admin fee \n    function proposeNewAdminFee(uint256 _newFee) external override onlyRole(FEE_ROLE) {\n        require(_newFee <= MAX_ADMIN_FEE, \"NibblVaultFactory: Fee value greater than MAX_ADMIN_FEE\");\n        pendingFeeAdmin = _newFee;\n        feeAdminUpdateTime = block.timestamp + UPDATE_TIME;\n    }\n\n    /// @notice updates new admin fee\n    /// @dev new fee can be updated only after timelock\n    function updateNewAdminFee() external override {\n        require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n        feeAdmin = pendingFeeAdmin;\n        delete feeAdminUpdateTime;\n    }\n\n    /// @notice proposes new vault implementation\n    /// @dev new implementation can be updated only after timelock\n    /// @dev can only be called by FEE_ROLE\n    /// @param _newVaultImplementation new implementation vault address\n    function proposeNewVaultImplementation(address _newVaultImplementation) external override onlyRole(IMPLEMENTER_ROLE) {\n        pendingVaultImplementation = _newVaultImplementation;\n        vaultUpdateTime = block.timestamp + UPDATE_TIME;\n    }\n\n    /// @notice updates new vault implementation\n    /// @dev new vault implementation can be updated only after timelock\n    function updateVaultImplementation() external override {\n        require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n        vaultImplementation = pendingVaultImplementation;\n        delete vaultUpdateTime;\n    }\n\n    /// @notice pauses the system\n    /// @dev can only be called by PAUSER_ROLE\n    function pause() external onlyRole(PAUSER_ROLE) override {\n        _pause();\n    }\n\n    /// @notice unpauses the system\n    /// @dev can only be called by PAUSER_ROLE\n    function unPause() external onlyRole(PAUSER_ROLE) override {\n        _unpause();\n    }\n\n    receive() payable external {    }\n\n}"
    },
    {
      "filename": "contracts/NibblVault.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.10;\n\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { BancorFormula } from \"./Bancor/BancorFormula.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { NibblVaultFactory } from \"./NibblVaultFactory.sol\";\nimport { Twav } from \"./Twav/Twav.sol\";\nimport { EIP712Base } from \"./Utilities/EIP712Base.sol\";\nimport { INibblVault } from \"./Interfaces/INibblVault.sol\";\n\n/// @title Vault to lock NFTs and fractionalize ERC721 to ERC20.\n/// @dev This contract uses Bancor Formula to create an automated market for fractionalized ERC20s.\n/// @dev This contract creates 2 bonding curves, referred to as primary curve and secondary curve.\n/// @dev The primary curve has fixed specifications and reserveRatio.\n/// @dev The secondary curve is dynamic and has a variable reserveRatio, which depends on initial conditions given by the curator and the fee accumulated by the curve.\ncontract NibblVault is INibblVault, BancorFormula, ERC20Upgradeable, Twav, EIP712Base {\n\n    /// @notice Scale for calculations to avoid rounding errors\n    uint256 private constant SCALE = 1_000_000; \n\n    /// @notice Reserve ratio of primary curve \n    /// @dev primaryReserveRatio has been multiplied with SCALE\n    /// @dev primaryReserveRatio lies between 0 and 1_000_000, 500_000 is equivalent to 50% reserve ratio\n    uint32 private constant primaryReserveRatio = 200_000; //20%\n    \n    /// @notice The premium percentage above the buyoutBid at which the buyout is rejected\n    /// @dev REJECTION_PREMIUM has been multiplied with SCALE\n    /// @dev REJECTION_PREMIUM lies between 0 and 1_000_000, i.e. 100_000 means 10%\n    /// @dev if REJECTION_PREMIUM is 15% and the buyoutBid is 100, then the buyout is rejected when the valuation reaches 115\n    uint256 private constant REJECTION_PREMIUM = 150_000; //15%\n\n    /// @notice The days until which a buyout bid is valid, if the bid isn't rejected in buyout duration time, its automatically considered boughtOut\n    uint256 private constant BUYOUT_DURATION = 5 days; \n\n    /// @notice The percentage of fee that goes for liquidity in lower curve until its reserve ratio becomes equal to primaryReserveRatio\n    uint256 private constant CURVE_FEE = 4_000;\n\n    /// @notice minimum reserve ratio that the secondary curve can have initially \n    uint256 private constant MIN_SECONDARY_RESERVE_RATIO = 50_000;\n\n    /// @notice minimum curator fee that the curator will get on adding minimal liquidity to the secondary curve\n    uint256 private constant MIN_CURATOR_FEE = 5_000; //0.5%\n\n    /// @notice minimum reserve balance that the secondary curve can have initially \n    uint256 private constant MIN_SECONDARY_RESERVE_BALANCE = 1e9;\n\n    bytes32 private constant PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n\n    /// @notice The reserve ratio of the secondary curve.\n    /// @dev secondaryReserveRatio has been multiplied with SCALE\n    /// @dev secondary reserve ratio is dynamic and it can be <= primaryReserveRatio\n    uint32 public secondaryReserveRatio;\n\n    /// @notice address of the factory contract\n    address payable public factory;\n\n    /// @notice address of the original NFT owner\n    address public curator; \n\n    /// @notice token address of the NFT being deposited in the vault\n    address public assetAddress;\n\n    /// @notice token ID of the NFT being deposited in the vault  \n    uint256 public assetID;\n\n    /// @notice address which triggered the buyout\n    address public bidder; \n\n    /// @notice initial price of the fractional ERC20 Token set by the curator\n    uint256 public initialTokenPrice;\n\n    /// @notice fictitious primary reserve balance, this is used for calculation purposes of trading on primary bonding curve.\n    /// @dev This variable defines the amount of reserve token that should be in the secondary curve if secondaryReserveRatio == primaryReserveRatio\n    /// @dev This variable also defines the amount of reserve token that should be in the primary curve if the primary curve started from 0 and went till initialTokenSupply \n    uint256 public fictitiousPrimaryReserveBalance;\n\n    /// @notice the valuation at which the buyout is rejected.\n    uint256 public buyoutRejectionValuation; \n    \n    /// @notice deposit made by bidder to initiate buyout \n    /// @dev buyoutValuationDeposit = currentValuation - ((reserveTokens in primary curve) + (reserveTokens in secondary curve))\n    uint256 public buyoutValuationDeposit; \n    \n    /// @notice initial token supply minted by curator\n    uint256 public initialTokenSupply; \n    \n    /// @notice reserve balance of the primary curve\n    uint256 public primaryReserveBalance;\n    \n    /// @notice reserve balance of the secondary curve\n    uint256 public secondaryReserveBalance;\n    \n    /// @notice total value of unclaimed fees accrued to the curator via trading on the bonding curve\n    uint256 public feeAccruedCurator; \n    \n    /// @notice the time at which the current buyout ends\n    uint256 public buyoutEndTime; \n    \n    /// @notice valuation at which the buyout was triggered\n    uint256 public buyoutBid;\n\n    /// @notice percentage of trading fee on the bonding curve that goes to the curator\n    uint256 public curatorFee;\n\n    /// @notice total value of unclaimed buyout bids\n    uint256 public totalUnsettledBids; \n\n    /// @notice minimum time after which buyout can be triggered\n    uint256 public minBuyoutTime;\n\n    /// @notice mapping of buyout bidders and their respective unsettled bids\n    mapping(address => uint256) public unsettledBids; \n    mapping(address => uint256) public nonces; \n    \n    enum Status {initialized, buyout}\n\n    ///@notice current status of vault\n    Status public status;\n\n    ///@notice reenterancy guard\n    uint256 private unlocked = 2;\n\n    modifier lock() {\n        require(unlocked == 1, 'NibblVault: LOCKED');\n        unlocked = 2;\n        _;\n        unlocked = 1;\n    }\n\n\n    /// @notice To check if buyout hasn't succeeded\n    /// @dev Check for the case when buyoutTime has not passed or buyout has been rejected\n    modifier notBoughtOut() {\n        require(buyoutEndTime > block.timestamp || buyoutEndTime == 0,'NibblVault: Bought Out');\n        _;\n    }\n\n    /// @notice To check if buyout has succeeded\n    /// @dev For the case when buyoutTime has passed and buyout has not been rejected\n    modifier boughtOut() {\n        require(status == Status.buyout, \"NibblVault: status != buyout\");\n        require(buyoutEndTime <= block.timestamp, \"NibblVault: buyoutEndTime <= now\");\n        _;\n    }\n\n    /// @notice To check if system isn't paused\n    /// @dev pausablity implemented in factory\n    modifier whenNotPaused() {\n        require(!NibblVaultFactory(factory).paused(), 'NibblVault: Paused');\n        _;\n    }\n\n    /// @notice the function to initialize proxy vault parameters\n    /// @param _tokenName name of the fractionalized ERC20 token to be created\n    /// @param _tokenSymbol symbol of the fractionalized ERC20 token\n    /// @param _assetAddress address of the ERC721 being fractionalized\n    /// @param _assetID tokenId of the ERC721 being fractionalized\n    /// @param _curator owner of the asset getting fractionalized\n    /// @param _initialTokenSupply desired initial supply to be minted to curator\n    /// @param _initialTokenPrice desired initial token price set by curator \n    /// @param  _minBuyoutTime minimum time after which buyout can be triggered \n    /// @dev valuation = price * supply\n    /// @dev reserveBalance = valuation * reserveRatio\n    /// @dev Reserve Ratio = Reserve Token Balance / (Continuous Token Supply x Continuous Token Price)\n    /// @dev curatorFee is proportional to initialLiquidity added by user. \n    /// @dev curatorFee can be maximum of 2 * MinimumCuratorFee.\n\n    function initialize(\n        string memory _tokenName, \n        string memory _tokenSymbol, \n        address _assetAddress,\n        uint256 _assetID,\n        address _curator,\n        uint256 _initialTokenSupply,\n        uint256 _initialTokenPrice,\n        uint256 _minBuyoutTime\n    ) external override initializer payable {\n        uint32 _secondaryReserveRatio = uint32((msg.value * SCALE * 1e18) / (_initialTokenSupply * _initialTokenPrice));\n        require(_secondaryReserveRatio <= primaryReserveRatio, \"NibblVault: Excess initial funds\");\n        require(_secondaryReserveRatio >= MIN_SECONDARY_RESERVE_RATIO, \"NibblVault: secResRatio too low\");\n        INIT_EIP712(\"NibblVault\", \"1\");\n        __ERC20_init(_tokenName, _tokenSymbol);\n        unlocked = 1;\n        initialTokenPrice=_initialTokenPrice;\n        factory = payable(msg.sender);\n        assetAddress = _assetAddress;\n        assetID = _assetID;\n        curator = _curator;\n        initialTokenSupply = _initialTokenSupply;\n        uint _primaryReserveBalance = (primaryReserveRatio * _initialTokenSupply * _initialTokenPrice) / (SCALE * 1e18);\n        primaryReserveBalance = _primaryReserveBalance;\n        fictitiousPrimaryReserveBalance = _primaryReserveBalance;\n        secondaryReserveBalance = msg.value;\n        secondaryReserveRatio = _secondaryReserveRatio;\n        //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n        curatorFee = (((_secondaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n        minBuyoutTime = _minBuyoutTime;\n        _mint(_curator, _initialTokenSupply);\n    }\n\n    /// @notice Function used to charge fee on trades\n    /// @dev There are 3 different fees charged - admin, curator and curve\n    /// @dev Admin fee percentage is fetched from the factory contract and the fee charged is transferred to factory contract\n    /// @dev Curator fee is fetched from curatorFee variable and total fee accrued is stored in feeAccruedCurator variable\n    /// @dev Curve fee is fetched from the CURVE_FEE variable and is added to the secondaryReserveBalance variable\n    /// @param _amount amount to charge fee on either a buy or sell order, fee is charged in reserve token\n    /// @return the amount after fee is deducted\n    function _chargeFee(uint256 _amount) private returns(uint256) {\n        address payable _factory = factory;\n        uint256 _adminFeeAmt = NibblVaultFactory(_factory).feeAdmin();\n        uint256 _feeAdmin = (_amount * _adminFeeAmt) / SCALE ;\n        uint256 _feeCurator = (_amount * curatorFee) / SCALE ;\n        uint256 _feeCurve = (_amount * CURVE_FEE) / SCALE ;\n        feeAccruedCurator += _feeCurator;\n        //_maxSecondaryBalanceIncrease: is the max amount of secondary reserve balance that can be added to the vault\n        //_maxSecondaryBalanceIncrease cannot be more than fictitiousPrimaryReserveBalance\n        uint256 _maxSecondaryBalanceIncrease = fictitiousPrimaryReserveBalance - secondaryReserveBalance;\n        // _feeCurve can't be higher than _maxSecondaryBalanceIncrease\n        _feeCurve = _maxSecondaryBalanceIncrease > _feeCurve ? _feeCurve : _maxSecondaryBalanceIncrease; // the curve fee is capped so that secondaryReserveBalance <= fictitiousPrimaryReserveBalance\n        secondaryReserveBalance += _feeCurve;\n        secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade \n        if(_adminFeeAmt > 0) {\n            safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract\n        }\n        return _amount - (_feeAdmin + _feeCurator + _feeCurve);\n    }\n\n    /// @notice Function to charge fee in secondary curve\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @param _amount amount to charge fee on trade order, fee is charged in reserve token\n    /// @return amount of tokens after fee is deducted\n    function _chargeFeeSecondaryCurve(uint256 _amount) private returns(uint256) {\n       address payable _factory = factory;\n        uint256 _adminFeeAmt = NibblVaultFactory(_factory).feeAdmin();\n        uint256 _feeAdmin = (_amount * _adminFeeAmt) / SCALE ;\n        uint256 _feeCurator = (_amount * curatorFee) / SCALE ;\n        feeAccruedCurator += _feeCurator;\n        if(_adminFeeAmt > 0) {\n            safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract\n        }\n        return _amount - (_feeAdmin + _feeCurator);\n    }\n\n    /// @notice Maximum number of reserve tokens that can be held on SecondaryCurve at current secondary reserve ratio\n    /// @dev The max continous tokens on SecondaryCurve is equal to initialTokenSupply\n    /// @dev Reserve Token Balance = Reserve Ratio * (Continuous Token Supply x Continuous Token Price)\n    function getMaxSecondaryCurveBalance() private view returns(uint256){\n            return ((secondaryReserveRatio * initialTokenSupply * initialTokenPrice) / (1e18 * SCALE));\n    }\n\n    /// @notice gives current valuation of the system\n    /// @dev valuation = price * supply\n    /// @dev fictitiousPrimaryReserveBalance doesn't denote any actual reserve balance its just for calculation purpose\n    /// @dev Actual reserve balance in primary curve = primaryReserveBalance - fictitiousPrimaryReserveBalance\n    /// @dev Total reserve balance = Actual reserve balance in primary curve + secondaryReserveBalance\n    /// @dev Total reserve balance = (primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance\n    /// @dev Valuation = (Continuous Token Supply x Continuous Token Price) = Reserve Token Balance / Reserve Ratio\n    /// @dev Valuation = If current supply is on seconday curve we use secondaryReserveBalance and secondaryReserveRatio to calculate valuation else we use primary reserve ratio and balance\n    /// @return Current valuation of the system\n    function getCurrentValuation() private view returns(uint256) {\n            return totalSupply() < initialTokenSupply ? (secondaryReserveBalance * SCALE /secondaryReserveRatio) : ((primaryReserveBalance) * SCALE  / primaryReserveRatio);\n    }\n\n    /// @notice function to buy tokens on the primary curve\n    /// @param _amount amount of reserve tokens to buy continous tokens\n    /// @dev This is executed when current supply >= initial supply\n    /// @dev _amount is charged with fee\n    /// @dev _purchaseReturn is minted to _to\n    /// @return _purchaseReturn Purchase return\n    function _buyPrimaryCurve(uint256 _amount, uint256 _totalSupply) private returns (uint256 _purchaseReturn) {\n        uint256 _amountIn = _chargeFee(_amount);\n        uint256 _primaryReserveBalance = primaryReserveBalance;\n        _purchaseReturn = _calculatePurchaseReturn(_totalSupply, _primaryReserveBalance, primaryReserveRatio, _amountIn);\n        primaryReserveBalance = _primaryReserveBalance + _amountIn;\n    }\n    /// @notice function to buy tokens on secondary curve\n    /// @param _amount amount of reserve tokens to buy continous tokens\n    /// @dev This is executed when current supply < initial supply\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @dev _purchaseReturn is minted to _to\n    /// @return _purchaseReturn Purchase return\n    function _buySecondaryCurve(uint256 _amount, uint256 _totalSupply) private returns (uint256 _purchaseReturn) {\n        uint256 _amountIn = _chargeFeeSecondaryCurve(_amount);\n        uint _secondaryReserveBalance = secondaryReserveBalance;\n        _purchaseReturn = _calculatePurchaseReturn(_totalSupply, _secondaryReserveBalance, secondaryReserveRatio, _amountIn);\n        secondaryReserveBalance = _secondaryReserveBalance + _amountIn;\n    }\n\n    /// @notice The function to buy fractional tokens for reserveTokens\n    /// @dev TWAV is updated only if buyout is active and only on first buy or sell txs of block.\n    /// @dev It internally calls _buyPrimaryCurve or _buySecondaryCurve or both depending on the buyAmount and current supply\n    /// @dev if current totalSupply < initialTokenSupply AND _amount to buy tokens for is greater than (maxSecondaryCurveBalance - currentSecondaryCurveBalance) then buy happens on secondary curve and primary curve both\n    /// @param _minAmtOut Minimum amount of continuous token user receives, else the tx fails.\n    /// @param _to Address to mint the purchase return to\n    function buy(uint256 _minAmtOut, address _to) external override payable notBoughtOut lock whenNotPaused returns(uint256 _purchaseReturn) {\n        //Make update on the first tx of the block\n        if (status == Status.buyout) {\n            uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n            if (_blockTimestamp != lastBlockTimeStamp) {\n                _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n                _rejectBuyout();\n            }\n        }\n        uint256 _initialTokenSupply = initialTokenSupply;\n        uint256 _totalSupply = totalSupply();\n        if (_totalSupply >= _initialTokenSupply) {\n            _purchaseReturn = _buyPrimaryCurve(msg.value, _totalSupply);\n        } else {\n            uint256 _lowerCurveDiff = getMaxSecondaryCurveBalance() - secondaryReserveBalance;\n            if (_lowerCurveDiff >= msg.value) {\n                _purchaseReturn = _buySecondaryCurve(msg.value, _totalSupply);\n            } else {\n                //Gas Optimization\n                _purchaseReturn = _initialTokenSupply - _totalSupply;\n                secondaryReserveBalance += _lowerCurveDiff;\n                // _purchaseReturn = _buySecondaryCurve(_to, _lowerCurveDiff);\n                _purchaseReturn += _buyPrimaryCurve(msg.value - _lowerCurveDiff, _totalSupply + _purchaseReturn);\n            } \n        }\n        require(_minAmtOut <= _purchaseReturn, \"NibblVault: Return too low\");\n        _mint(_to, _purchaseReturn);\n        emit Buy(msg.sender, _purchaseReturn, msg.value);\n    }\n\n    /// @notice The function to sell fractional tokens on primary curve\n    /// @dev Executed when currentSupply > initialSupply\n    /// @dev _amount is charged with fee\n    /// @param _amount Amount of tokens to be sold on primary curve\n    /// @return _saleReturn Sale Return\n    function _sellPrimaryCurve(uint256 _amount, uint256 _totalSupply) private returns(uint256 _saleReturn) {\n        uint _primaryReserveBalance = primaryReserveBalance;\n        _saleReturn = _calculateSaleReturn(_totalSupply, _primaryReserveBalance, primaryReserveRatio, _amount);\n        primaryReserveBalance = _primaryReserveBalance - _saleReturn;\n        _saleReturn = _chargeFee(_saleReturn);\n    }\n\n    /// @notice The function to sell fractional tokens on secondary curve\n    /// @dev Executed when current supply <= initial supply\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @param _amount Amount of tokens to be sold on SecondaryCurve\n    ///  @return _saleReturn Sale Return\n    function _sellSecondaryCurve(uint256 _amount, uint256 _totalSupply) private returns(uint256 _saleReturn){\n        uint _secondaryReserveBalance = secondaryReserveBalance;\n        _saleReturn = _calculateSaleReturn(_totalSupply, _secondaryReserveBalance, secondaryReserveRatio, _amount);\n        secondaryReserveBalance = _secondaryReserveBalance - _saleReturn;\n        require(_secondaryReserveBalance - _saleReturn >= MIN_SECONDARY_RESERVE_BALANCE, \"NibblVault: Excess sell\");\n        _saleReturn = _chargeFeeSecondaryCurve(_saleReturn);\n    }\n\n    /// @notice The function to sell fractional tokens for reserve token\n    /// @dev TWAV is updated only if buyout is active and only on first buy or sell txs of block.\n    /// @dev internally calls _sellPrimaryCurve or _sellSecondaryCurve or both depending on the sellAmount and current supply\n    /// @dev if totalSupply > initialTokenSupply AND _amount to sell is greater than (_amtIn > totalSupply - initialTokenSupply) then sell happens on primary curve and secondary curve both\n    /// @param _amtIn Continous Tokens to be sold\n    /// @param _minAmtOut Minimum amount of reserve token user receives, else the tx fails.\n    /// @param _to Address to recieve the reserve token to\n    function sell(uint256 _amtIn, uint256 _minAmtOut, address payable _to) external override notBoughtOut whenNotPaused returns(uint256 _saleReturn) {\n        //Make update on the first tx of the block\n        if (status == Status.buyout) {\n            uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n            if (_blockTimestamp != lastBlockTimeStamp) {\n                _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n                _rejectBuyout(); //For the case when TWAV goes up when updated on sell\n            }\n        }\n        uint256 _initialTokenSupply = initialTokenSupply;\n        uint256 _totalSupply = totalSupply();\n        if(_totalSupply > _initialTokenSupply) {\n            if ((_initialTokenSupply + _amtIn) <= _totalSupply) {\n                _saleReturn = _sellPrimaryCurve(_amtIn, _totalSupply);\n            } else {\n                //Gas Optimization\n                uint256 _tokensPrimaryCurve = _totalSupply - _initialTokenSupply;\n                _saleReturn = primaryReserveBalance - fictitiousPrimaryReserveBalance;\n                primaryReserveBalance -= _saleReturn;\n                _saleReturn = _chargeFee(_saleReturn);\n                // _saleReturn = _sellPrimaryCurve(_tokensPrimaryCurve);\n                _saleReturn += _sellSecondaryCurve(_amtIn - _tokensPrimaryCurve, _initialTokenSupply);\n            } } else {\n                _saleReturn = _sellSecondaryCurve(_amtIn,_totalSupply);\n        }\n        require(_saleReturn >= _minAmtOut, \"NibblVault: Return too low\");\n        _burn(msg.sender, _amtIn);\n        safeTransferETH(_to, _saleReturn); //send _saleReturn to _to\n        emit Sell(msg.sender, _amtIn, _saleReturn);\n    }\n\n    /// @notice Function to initiate buyout of ERC721\n    /// @dev buyoutBid is set to current valuation\n    /// @dev bidder needs to send funds equal to current valuation - ((primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance) to initiate buyout\n    /// This ensures that the original bidder doesn't need t"
    }
  ]
}