{
  "Title": "Unused variable",
  "Content": "##### Description\nFollowing smart contract contains unused variable:\nhttps://github.com/lidofinance/curve-merkle-oracle/blob/ae093b308999a564ed3f23d52c6c5dce946dbfa7/contracts/MerklePatriciaProofVerifier.sol#L37\n##### Recommendation\nWe recommend to remove unused variable.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/MerklePatriciaProofVerifier.sol",
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * Copied from https://github.com/lorenzb/proveth/blob/c74b20e/onchain/ProvethVerifier.sol\n * with minor performance and code style-related modifications.\n */\npragma solidity 0.6.12;\n\nimport {RLPReader} from \"hamdiallam/Solidity-RLP@2.0.4/contracts/RLPReader.sol\";\n\n\nlibrary MerklePatriciaProofVerifier {\n    using RLPReader for RLPReader.RLPItem;\n    using RLPReader for bytes;\n\n    /// @dev Validates a Merkle-Patricia-Trie proof.\n    ///      If the proof proves the inclusion of some key-value pair in the\n    ///      trie, the value is returned. Otherwise, i.e. if the proof proves\n    ///      the exclusion of a key from the trie, an empty byte array is\n    ///      returned.\n    /// @param rootHash is the Keccak-256 hash of the root node of the MPT.\n    /// @param path is the key of the node whose inclusion/exclusion we are\n    ///        proving.\n    /// @param stack is the stack of MPT nodes (starting with the root) that\n    ///        need to be traversed during verification.\n    /// @return value whose inclusion is proved or an empty byte array for\n    ///         a proof of exclusion\n    function extractProofValue(\n        bytes32 rootHash,\n        bytes memory path,\n        RLPReader.RLPItem[] memory stack\n    ) internal pure returns (bytes memory value) {\n        bytes memory mptKey = _decodeNibbles(path, 0);\n        uint256 mptKeyOffset = 0;\n\n        bytes32 nodeHashHash;\n        bytes memory rlpNode;\n        RLPReader.RLPItem[] memory node;\n\n        RLPReader.RLPItem memory rlpValue;\n\n        if (stack.length == 0) {\n            // Root hash of empty Merkle-Patricia-Trie\n            require(rootHash == 0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421);\n            return new bytes(0);\n        }\n\n        // Traverse stack of nodes starting at root.\n        for (uint256 i = 0; i < stack.length; i++) {\n\n            // We use the fact that an rlp encoded list consists of some\n            // encoding of its length plus the concatenation of its\n            // *rlp-encoded* items.\n\n            // The root node is hashed with Keccak-256 ...\n            if (i == 0 && rootHash != stack[i].rlpBytesKeccak256()) {\n                revert();\n            }\n            // ... whereas all other nodes are hashed with the MPT\n            // hash function.\n            if (i != 0 && nodeHashHash != _mptHashHash(stack[i])) {\n                revert();\n            }\n            // We verified that stack[i] has the correct hash, so we\n            // may safely decode it.\n            node = stack[i].toList();\n\n            if (node.length == 2) {\n                // Extension or Leaf node\n\n                bool isLeaf;\n                bytes memory nodeKey;\n                (isLeaf, nodeKey) = _merklePatriciaCompactDecode(node[0].toBytes());\n\n                uint256 prefixLength = _sharedPrefixLength(mptKeyOffset, mptKey, nodeKey);\n                mptKeyOffset += prefixLength;\n\n                if (prefixLength < nodeKey.length) {\n                    // Proof claims divergent extension or leaf. (Only\n                    // relevant for proofs of exclusion.)\n                    // An Extension/Leaf node is divergent iff it \"skips\" over\n                    // the point at which a Branch node should have been had the\n                    // excluded key been included in the trie.\n                    // Example: Imagine a proof of exclusion for path [1, 4],\n                    // where the current node is a Leaf node with\n                    // path [1, 3, 3, 7]. For [1, 4] to be included, there\n                    // should have been a Branch node at [1] with a child\n                    // at 3 and a child at 4.\n\n                    // Sanity check\n                    if (i < stack.length - 1) {\n                        // divergent node must come last in proof\n                        revert();\n                    }\n\n                    return new bytes(0);\n                }\n\n                if (isLeaf) {\n                    // Sanity check\n                    if (i < stack.length - 1) {\n                        // leaf node must come last in proof\n                        revert();\n                    }\n\n                    if (mptKeyOffset < mptKey.length) {\n                        return new bytes(0);\n                    }\n\n                    rlpValue = node[1];\n                    return rlpValue.toBytes();\n                } else { // extension\n                    // Sanity check\n                    if (i == stack.length - 1) {\n                        // shouldn't be at last level\n                        revert();\n                    }\n\n                    if (!node[1].isList()) {\n                        // rlp(child) was at least 32 bytes. node[1] contains\n                        // Keccak256(rlp(child)).\n                        nodeHashHash = node[1].payloadKeccak256();\n                    } else {\n                        // rlp(child) was less than 32 bytes. node[1] contains\n                        // rlp(child).\n                        nodeHashHash = node[1].rlpBytesKeccak256();\n                    }\n                }\n            } else if (node.length == 17) {\n                // Branch node\n\n                if (mptKeyOffset != mptKey.length) {\n                    // we haven't consumed the entire path, so we need to look at a child\n                    uint8 nibble = uint8(mptKey[mptKeyOffset]);\n                    mptKeyOffset += 1;\n                    if (nibble >= 16) {\n                        // each element of the path has to be a nibble\n                        revert();\n                    }\n\n                    if (_isEmptyBytesequence(node[nibble])) {\n                        // Sanity\n                        if (i != stack.length - 1) {\n                            // leaf node should be at last level\n                            revert();\n                        }\n\n                        return new bytes(0);\n                    } else if (!node[nibble].isList()) {\n                        nodeHashHash = node[nibble].payloadKeccak256();\n                    } else {\n                        nodeHashHash = node[nibble].rlpBytesKeccak256();\n                    }\n                } else {\n                    // we have consumed the entire mptKey, so we need to look at what's contained in this node.\n\n                    // Sanity\n                    if (i != stack.length - 1) {\n                        // should be at last level\n                        revert();\n                    }\n\n                    return node[16].toBytes();\n                }\n            }\n        }\n    }\n\n\n    /// @dev Computes the hash of the Merkle-Patricia-Trie hash of the RLP item.\n    ///      Merkle-Patricia-Tries use a weird \"hash function\" that outputs\n    ///      *variable-length* hashes: If the item is shorter than 32 bytes,\n    ///      the MPT hash is the item. Otherwise, the MPT hash is the\n    ///      Keccak-256 hash of the item.\n    ///      The easiest way to compare variable-length byte sequences is\n    ///      to compare their Keccak-256 hashes.\n    /// @param item The RLP item to be hashed.\n    /// @return Keccak-256(MPT-hash(item))\n    function _mptHashHash(RLPReader.RLPItem memory item) private pure returns (bytes32) {\n        if (item.len < 32) {\n            return item.rlpBytesKeccak256();\n        } else {\n            return keccak256(abi.encodePacked(item.rlpBytesKeccak256()));\n        }\n    }\n\n    function _isEmptyBytesequence(RLPReader.RLPItem memory item) private pure returns (bool) {\n        if (item.len != 1) {\n            return false;\n        }\n        uint8 b;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            b := byte(0, mload(memPtr))\n        }\n        return b == 0x80 /* empty byte string */;\n    }\n\n\n    function _merklePatriciaCompactDecode(bytes memory compact) private pure returns (bool isLeaf, bytes memory nibbles) {\n        require(compact.length > 0);\n        uint256 first_nibble = uint8(compact[0]) >> 4 & 0xF;\n        uint256 skipNibbles;\n        if (first_nibble == 0) {\n            skipNibbles = 2;\n            isLeaf = false;\n        } else if (first_nibble == 1) {\n            skipNibbles = 1;\n            isLeaf = false;\n        } else if (first_nibble == 2) {\n            skipNibbles = 2;\n            isLeaf = true;\n        } else if (first_nibble == 3) {\n            skipNibbles = 1;\n            isLeaf = true;\n        } else {\n            // Not supposed to happen!\n            revert();\n        }\n        return (isLeaf, _decodeNibbles(compact, skipNibbles));\n    }\n\n\n    function _decodeNibbles(bytes memory compact, uint256 skipNibbles) private pure returns (bytes memory nibbles) {\n        require(compact.length > 0);\n\n        uint256 length = compact.length * 2;\n        require(skipNibbles <= length);\n        length -= skipNibbles;\n\n        nibbles = new bytes(length);\n        uint256 nibblesLength = 0;\n\n        for (uint256 i = skipNibbles; i < skipNibbles + length; i += 1) {\n            if (i % 2 == 0) {\n                nibbles[nibblesLength] = bytes1((uint8(compact[i/2]) >> 4) & 0xF);\n            } else {\n                nibbles[nibblesLength] = bytes1((uint8(compact[i/2]) >> 0) & 0xF);\n            }\n            nibblesLength += 1;\n        }\n\n        assert(nibblesLength == nibbles.length);\n    }\n\n\n    function _sharedPrefixLength(uint256 xsOffset, bytes memory xs, bytes memory ys) private pure returns (uint256) {\n        uint256 i;\n        for (i = 0; i + xsOffset < xs.length && i < ys.length; i++) {\n            if (xs[i + xsOffset] != ys[i]) {\n                return i;\n            }\n        }\n        return i;\n    }\n}"
    }
  ]
}