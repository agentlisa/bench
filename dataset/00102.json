{
  "Title": "M-7: Rewards can disappear when new rewards are distributed in the RewardsController.",
  "Content": "# Issue M-7: Rewards can disappear when new rewards are distributed in the RewardsController. \n\nSource: https://github.com/sherlock-audit/2024-04-interest-rate-model-judging/issues/95 \n\n## Found by \n0x73696d616f, Trumpero, ether\\_sky\n## Summary\nThe `RewardsController` distributes `rewards` to both `depositors` and `borrowers`.\nWhen new `rewards` are available, the `admin` assigns them using the `config` function.\nHowever, there is a logic error in this function, causing unclaimed `rewards` for users to disappear entirely.\n## Vulnerability Detail\nThe `rewards distribution config` includes a `start time` and `duration`.\n```solidity\nstruct Config {\n  Market market;\n  ERC20 reward;\n  IPriceFeed priceFeed;\n  uint32 start;   // @audit, here\n  uint256 distributionPeriod;   // @audit, here\n  uint256 targetDebt;\n  uint256 totalDistribution;\n  uint256 undistributedFactor;\n  int128 flipSpeed;\n  uint64 compensationFactor;\n  uint64 transitionFactor;\n  uint64 borrowAllocationWeightFactor;\n  uint64 depositAllocationWeightAddend;\n  uint64 depositAllocationWeightFactor;\n}\n```\nWhenever a `borrower` changes his `balance`, we update the `rewards index` for that `borrower` and calculate the `unclaimed rewards`.\n```solidity\nfunction handleBorrow(address account) external {\n  Market market = Market(msg.sender);\n  AccountOperation[] memory ops = new AccountOperation[](1);\n  (, , uint256 accountFloatingBorrowShares) = market.accounts(account);\n\n  Distribution storage dist = distribution[market];\n  uint256 available = dist.availableRewardsCount;\n  for (uint128 r = 0; r < available; ) {\n    ERC20 reward = dist.availableRewards[r];\n    ops[0] = AccountOperation({\n      operation: true,\n      balance: accountFloatingBorrowShares + accountFixedBorrowShares(market, account, dist.rewards[reward].start)\n    });\n    update(account, Market(msg.sender), reward, ops);  // @audit, here\n    unchecked {\n      ++r;\n    }\n  }\n}\n```\nThere are two types of `borrow shares`: `floating shares` and `fixed shares`.\nThe calculation for `fixed shares` is based on the `rewards distribution start time`.\n```solidity\nfunction previewAllocation(\n  RewardData storage rewardData,\n  Market market,\n  uint256 deltaTime\n) internal view returns (uint256 borrowIndex, uint256 depositIndex, uint256 newUndistributed) {\n  TotalMarketBalance memory m;\n  m.floatingDebt = market.floatingDebt();\n  m.floatingAssets = market.floatingAssets();\n  TimeVars memory t;\n  t.start = rewardData.start;\n  t.end = rewardData.end;\n  {\n    uint256 firstMaturity = t.start - (t.start % FixedLib.INTERVAL) + FixedLib.INTERVAL;  // @audit, here\n    uint256 maxMaturity = block.timestamp -\n      (block.timestamp % FixedLib.INTERVAL) +\n      (FixedLib.INTERVAL * market.maxFuturePools());\n    uint256 fixedDebt;\n    for (uint256 maturity = firstMaturity; maturity <= maxMaturity; ) {  // @audit, here\n      (uint256 borrowed, ) = market.fixedPoolBalance(maturity);\n      fixedDebt += borrowed;\n      unchecked {\n        maturity += FixedLib.INTERVAL;\n      }\n    }\n    m.debt = m.floatingDebt + fixedDebt;\n    m.fixedBorrowShares = market.previewRepay(fixedDebt);\n  }\n}\n```\n\nNow, suppose there are new upcoming `rewards`, and the `rewards distribution` is scheduled for the future.\nIn this case, the `start time` will be updated with the new value,\n```solidity\nfunction config(Config[] memory configs) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (block.timestamp < end) {\n      uint256 released = 0;\n      uint256 elapsed = 0;\n      if (block.timestamp > start) {\n        released =\n          rewardData.lastConfigReleased +\n          rewardData.releaseRate *\n          (block.timestamp - rewardData.lastConfig);\n        elapsed = block.timestamp - start;\n        if (configs[i].totalDistribution <= released || configs[i].distributionPeriod <= elapsed) {\n          revert InvalidConfig();\n        }\n        rewardData.lastConfigReleased = released;\n      }\n\n      rewardData.releaseRate =\n        (configs[i].totalDistribution - released) /\n        (configs[i].distributionPeriod - elapsed);\n    } else if (rewardData.start != configs[i].start) {\n      rewardData.start = configs[i].start;  // @audit, here\n      rewardData.lastUpdate = configs[i].start;\n      rewardData.releaseRate = configs[i].totalDistribution / configs[i].distributionPeriod;\n      rewardData.lastConfigReleased = 0;\n    }\n  }\n}\n```\nThe issue is that the `fixed borrow shares` from the `old start time` to the `new start time` are removed in the `rewards calculation`.\n```solidity\nfunction accountFixedBorrowShares(\n  Market market,\n  address account,\n  uint32 start\n) internal view returns (uint256 fixedDebt) {\n  uint256 firstMaturity = start - (start % FixedLib.INTERVAL) + FixedLib.INTERVAL;  // @audit, here\n  uint256 maxMaturity = block.timestamp -\n    (block.timestamp % FixedLib.INTERVAL) +\n    (FixedLib.INTERVAL * market.maxFuturePools());\n\n  for (uint256 maturity = firstMaturity; maturity <= maxMaturity; ) {  // @audit, here\n    (uint256 principal, ) = market.fixedBorrowPositions(maturity, account);\n    fixedDebt += principal;\n    unchecked {\n      maturity += FixedLib.INTERVAL;\n    }\n  }\n  fixedDebt = market.previewRepay(fixedDebt);\n}\n```\nIt's important to note that these `shares` are actually part of the previous `rewards distribution`, but `borrowers` may not have updated their `rewards` in time.\n\nLet's consider an example.\nTwo `borrowers`, `BOB` and `ALICE`, engage in borrowing operations.\nThey `borrow` funds at `maturity` periods of `4 weeks`, `12 weeks` and `16 weeks`.\nThe current `rewards distribution` starts at time `0` and lasts for `12 weeks`.\n\nBoth `borrowers` have the same `claimable rewards` amount obviously.\n`BOB` `claims` his `rewards` after `18 weeks` pass, but `ALICE` delays `claiming`.\nMeanwhile, the `admin` sets a new `start date` for upcoming `rewards`.\n\nWhen `ALICE` finally claims her `rewards`, the `fixed borrow shares` before this `new start date` are removed from the calculation.\nConsequently, she loses a significant portion of her `rewards`.\nSpecific values can be described in the below `log`.\n```solidity\nblock.timestamp                ==>   0\nusdcConfig.start               ==>   0\nusdcConfig.distributionPeriod  ==>   12 weeks\n*******************\nblock.timestamp                ==>   4838400\n*******************\nblock.timestamp                ==>   10886400\nClaimable for ALICE            ==>   999999975000000000000\nClaimable for BOB              ==>   999999975000000000000\n*******************\nReward Balance for BOB         ==>   999999975000000000000\nReward Balance for ALICE       ==>   734619963000000000000\n```\n\nPlease add below test to the `RewardsController.t.sol`.\n```solidity\nfunction testResetConfig () external {\n  vm.prank(ALICE);\n  marketUSDC.approve(address(this), 100 ether);\n\n  vm.prank(BOB);\n  marketUSDC.approve(address(this), 100 ether);\n\n  vm.prank(ALICE);\n  auditor.enterMarket(marketUSDC);\n\n  vm.prank(BOB);\n  auditor.enterMarket(marketUSDC);\n\n  marketUSDC.deposit(50 ether, ALICE);\n  marketUSDC.deposit(50 ether, BOB);\n  \n  RewardsController.Config memory usdcConfig = rewardsController.rewardConfig(marketUSDC, opRewardAsset);\n\n  console2.log(\"block.timestamp                ==>  \", block.timestamp);\n  console2.log(\"usdcConfig.start               ==>  \", usdcConfig.start);\n  console2.log(\"usdcConfig.distributionPeriod  ==>  \", usdcConfig.distributionPeriod / 1 weeks, \"weeks\");\n  assertEq(usdcConfig.distributionPeriod, 12 weeks);\n\n  marketUSDC.borrowAtMaturity(4 weeks, 1 ether, 20 ether, ALICE, ALICE);\n  marketUSDC.borrowAtMaturity(4 weeks, 1 ether, 20 ether, BOB, BOB);\n\n  console2.log(\"*******************\");\n  vm.warp(8 weeks);\n  console2.log(\"block.timestamp                ==>  \", block.timestamp);\n  marketUSDC.borrowAtMaturity(12 weeks, 1 ether, 20 ether, ALICE, ALICE);\n  marketUSDC.borrowAtMaturity(12 weeks, 1 ether, 20 ether, BOB, BOB);\n  marketUSDC.borrowAtMaturity(16 weeks, 2 ether, 20 ether, ALICE, ALICE);\n  marketUSDC.borrowAtMaturity(16 weeks, 2 ether, 20 ether, BOB, BOB);\n\n  console2.log(\"*******************\");\n  vm.warp(18 weeks);\n  console2.log(\"block.timestamp                ==>  \", block.timestamp);\n  console2.log(\"Claimable for ALICE            ==>  \", rewardsController.allClaimable(ALICE, opRewardAsset));\n  console2.log(\"Claimable for BOB              ==>  \", rewardsController.allClaimable(BOB, opRewardAsset));\n\n  vm.prank(BOB);\n  rewardsController.claimAll(BOB);\n\n  opRewardAsset.mint(address(rewardsController), 4_000 ether);\n  RewardsController.Config[] memory configs = new RewardsController.Config[](1);\n  configs[0] = RewardsController.Config({\n    market: marketUSDC,\n    reward: opRewardAsset,\n    priceFeed: MockPriceFeed(address(0)),\n    targetDebt: 20_000e6,\n    totalDistribution: 2_000 ether,\n    start: uint32(block.timestamp),\n    distributionPeriod: 12 weeks,\n    undistributedFactor: 0.5e18,\n    flipSpeed: 2e18,\n    compensationFactor: 0.85e18,\n    transitionFactor: 0.64e18,\n    borrowAllocationWeightFactor: 0,\n    depositAllocationWeightAddend: 0.02e18,\n    depositAllocationWeightFactor: 0.01e18\n  });\n  rewardsController.config(configs);\n\n  vm.prank(ALICE);\n  rewardsController.claimAll(ALICE);\n\n  console2.log(\"*******************\");\n  console2.log(\"Reward Balance for BOB         ==>  \", opRewardAsset.balanceOf(BOB));\n  console2.log(\"Reward Balance for ALICE       ==>  \", opRewardAsset.balanceOf(ALICE));\n}\n```\n## Impact\nThe `admin` can not consider whether all `borrowers` have already `claimed` their `rewards` before setting a `new rewards start time` so this can happen easily.\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-04-interest-rate-model/blob/8f6ef1b0868d3ea3a98a5ab7e8b3a164857681d7/protocol/contracts/RewardsController.sol#L826-L827\nhttps://github.com/sherlock-audit/2024-04-interest-rate-model/blob/8f6ef1b0868d3ea3a98a5ab7e8b3a164857681d7/protocol/contracts/RewardsController.sol#L78\nhttps://github.com/sherlock-audit/2024-04-interest-rate-model/blob/8f6ef1b0868d3ea3a98a5ab7e8b3a164857681d7/protocol/contracts/RewardsController.sol#L481-L495\nhttps://github.com/sherlock-audit/2024-04-interest-rate-model/blob/8f6ef1b0868d3ea3a98a5ab7e8b3a164857681d7/protocol/contracts/RewardsController.sol#L693-L694\nhttps://github.com/sherlock-audit/2024-04-interest-rate-model/blob/8f6ef1b0868d3ea3a98a5ab7e8b3a164857681d7/protocol/contracts/RewardsController.sol#L367\n## Tool used\n\nManual Review\n\n## Recommendation\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/247",
  "Code": [
    {
      "filename": "protocol/contracts/RewardsController.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.17;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { MathUpgradeable as Math } from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport { AccessControlUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport { SafeTransferLib } from \"solmate/src/utils/SafeTransferLib.sol\";\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { IPriceFeed } from \"./utils/IPriceFeed.sol\";\nimport { FixedLib } from \"./utils/FixedLib.sol\";\nimport { Market } from \"./Market.sol\";\n\ncontract RewardsController is Initializable, AccessControlUpgradeable {\n  using FixedPointMathLib for uint256;\n  using FixedPointMathLib for uint64;\n  using FixedPointMathLib for int256;\n  using SafeTransferLib for ERC20;\n\n  /// @notice Max utilization supported by the sigmoid function not to cause a division by zero (1e18 = WAD).\n  uint256 public constant UTILIZATION_CAP = 1e18 - 1;\n  /// @notice Tracks the reward distribution data for a given market.\n  mapping(Market => Distribution) public distribution;\n  /// @notice Tracks enabled asset rewards.\n  mapping(ERC20 => bool) public rewardEnabled;\n  /// @notice Stores registered asset rewards.\n  ERC20[] public rewardList;\n  /// @notice Stores Markets with distributions set.\n  Market[] public marketList;\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /// @notice Initializes the contract.\n  /// @dev Can only be called once.\n  function initialize() external initializer {\n    __AccessControl_init();\n\n    _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n  }\n\n  /// @notice Hook to be called by the Market to update the index of the account that made a rewarded deposit.\n  /// @dev There's no need to check that `msg.sender` is a valid Market as it won't have available rewards if it's not.\n  /// @param account The account to which the index is updated.\n  function handleDeposit(address account) external {\n    Market market = Market(msg.sender);\n    AccountOperation[] memory ops = new AccountOperation[](1);\n    ops[0] = AccountOperation({ operation: false, balance: market.balanceOf(account) });\n\n    Distribution storage dist = distribution[market];\n    uint256 available = dist.availableRewardsCount;\n    for (uint128 r = 0; r < available; ) {\n      update(account, market, dist.availableRewards[r], ops);\n      unchecked {\n        ++r;\n      }\n    }\n  }\n\n  /// @notice Hook to be called by the Market to update the index of the account that made a rewarded borrow.\n  /// @dev There's no need to check that `msg.sender` is a valid Market as it won't have available rewards if it's not.\n  /// @param account The account to which the index is updated.\n  function handleBorrow(address account) external {\n    Market market = Market(msg.sender);\n    AccountOperation[] memory ops = new AccountOperation[](1);\n    (, , uint256 accountFloatingBorrowShares) = market.accounts(account);\n\n    Distribution storage dist = distribution[market];\n    uint256 available = dist.availableRewardsCount;\n    for (uint128 r = 0; r < available; ) {\n      ERC20 reward = dist.availableRewards[r];\n      ops[0] = AccountOperation({\n        operation: true,\n        balance: accountFloatingBorrowShares + accountFixedBorrowShares(market, account, dist.rewards[reward].start)\n      });\n      update(account, Market(msg.sender), reward, ops);\n      unchecked {\n        ++r;\n      }\n    }\n  }\n\n  /// @notice Claims all `msg.sender` rewards to the given account.\n  /// @param to The address to send the rewards to.\n  /// @return rewardsList The list of rewards assets.\n  /// @return claimedAmounts The list of claimed amounts.\n  function claimAll(address to) external returns (ERC20[] memory rewardsList, uint256[] memory claimedAmounts) {\n    return claim(allMarketsOperations(), to, rewardList);\n  }\n\n  /// @notice Claims `msg.sender` rewards for the given operations and reward assets to the given account.\n  /// @param marketOps The operations to claim rewards for.\n  /// @param to The address to send the rewards to.\n  /// @param rewardsList The list of rewards assets to claim.\n  /// @return rewardsList The list of rewards assets.\n  /// @return claimedAmounts The list of claimed amounts.\n  function claim(\n    MarketOperation[] memory marketOps,\n    address to,\n    ERC20[] memory rewardsList\n  ) public claimSender returns (ERC20[] memory, uint256[] memory claimedAmounts) {\n    uint256 rewardsCount = rewardsList.length;\n    claimedAmounts = new uint256[](rewardsCount);\n    address sender = _claimSender;\n    for (uint256 i = 0; i < marketOps.length; ) {\n      MarketOperation memory marketOperation = marketOps[i];\n      Distribution storage dist = distribution[marketOperation.market];\n      uint256 availableRewards = dist.availableRewardsCount;\n      for (uint128 r = 0; r < availableRewards; ) {\n        update(\n          sender,\n          marketOperation.market,\n          dist.availableRewards[r],\n          accountBalanceOperations(\n            marketOperation.market,\n            marketOperation.operations,\n            sender,\n            dist.rewards[dist.availableRewards[r]].start\n          )\n        );\n        unchecked {\n          ++r;\n        }\n      }\n      for (uint256 r = 0; r < rewardsCount; ) {\n        RewardData storage rewardData = dist.rewards[rewardsList[r]];\n        for (uint256 o = 0; o < marketOperation.operations.length; ) {\n          uint256 rewardAmount = rewardData.accounts[sender][marketOperation.operations[o]].accrued;\n          if (rewardAmount != 0) {\n            claimedAmounts[r] += rewardAmount;\n            rewardData.accounts[sender][marketOperation.operations[o]].accrued = 0;\n          }\n          unchecked {\n            ++o;\n          }\n        }\n        unchecked {\n          ++r;\n        }\n      }\n      unchecked {\n        ++i;\n      }\n    }\n    for (uint256 r = 0; r < rewardsList.length; ) {\n      uint256 claimedAmount = claimedAmounts[r];\n      if (claimedAmount > 0) {\n        rewardsList[r].safeTransfer(to, claimedAmount);\n        emit Claim(sender, rewardsList[r], to, claimedAmount);\n      }\n      unchecked {\n        ++r;\n      }\n    }\n    return (rewardsList, claimedAmounts);\n  }\n\n  /// @notice Claims `permit.owner` rewards for the given operations and reward assets to the given account.\n  /// @param marketOps The operations to claim rewards for.\n  /// @param permit Arguments and signature from `permit.owner`.\n  /// @return rewardsList The list of rewards assets.\n  /// @return claimedAmounts The list of claimed amounts.\n  function claim(\n    MarketOperation[] memory marketOps,\n    ClaimPermit calldata permit\n  ) external permitSender(permit) returns (ERC20[] memory, uint256[] memory claimedAmounts) {\n    return claim(marketOps, msg.sender, permit.assets);\n  }\n\n  /// @notice Gets the configuration of a given distribution.\n  /// @param market The market to get the distribution configuration for.\n  /// @param reward The reward asset.\n  /// @return The distribution configuration.\n  function rewardConfig(Market market, ERC20 reward) external view returns (Config memory) {\n    RewardData storage rewardData = distribution[market].rewards[reward];\n    return\n      Config({\n        market: market,\n        reward: reward,\n        priceFeed: rewardData.priceFeed,\n        start: rewardData.start,\n        distributionPeriod: rewardData.end - rewardData.start,\n        targetDebt: rewardData.targetDebt,\n        totalDistribution: rewardData.totalDistribution,\n        undistributedFactor: rewardData.undistributedFactor,\n        flipSpeed: rewardData.flipSpeed,\n        compensationFactor: rewardData.compensationFactor,\n        transitionFactor: rewardData.transitionFactor,\n        borrowAllocationWeightFactor: rewardData.borrowAllocationWeightFactor,\n        depositAllocationWeightAddend: rewardData.depositAllocationWeightAddend,\n        depositAllocationWeightFactor: rewardData.depositAllocationWeightFactor\n      });\n  }\n\n  /// @notice Gets the amount of reward assets that are being distributed for a Market.\n  /// @param market Market to get the number of available rewards to distribute.\n  /// @return The amount reward assets set to a Market.\n  function availableRewardsCount(Market market) external view returns (uint256) {\n    return distribution[market].availableRewardsCount;\n  }\n\n  /// @notice Gets the account data of a given account, Market, operation and reward asset.\n  /// @param account The account to get the operation data from.\n  /// @param market The market in which the operation was made.\n  /// @param operation True if the operation was a borrow, false if it was a deposit.\n  /// @param reward The reward asset.\n  /// @return accrued The accrued amount.\n  /// @return index The account index.\n  function accountOperation(\n    address account,\n    Market market,\n    bool operation,\n    ERC20 reward\n  ) external view returns (uint256, uint256) {\n    Account storage operationAccount = distribution[market].rewards[reward].accounts[account][operation];\n    return (operationAccount.accrued, operationAccount.index);\n  }\n\n  /// @notice Gets the distribution `start`, `end` and `lastUpdate` value of a given market and reward.\n  /// @param market The market to get the distribution times.\n  /// @param reward The reward asset.\n  /// @return The distribution `start`, `end` and `lastUpdate` time.\n  function distributionTime(Market market, ERC20 reward) external view returns (uint32, uint32, uint32) {\n    RewardData storage rewardData = distribution[market].rewards[reward];\n    return (rewardData.start, rewardData.end, rewardData.lastUpdate);\n  }\n\n  /// @notice Retrieves all rewards addresses.\n  function allRewards() external view returns (ERC20[] memory) {\n    return rewardList;\n  }\n\n  /// @notice Gets all market and operations.\n  /// @return marketOps The list of market operations.\n  function allMarketsOperations() public view returns (MarketOperation[] memory marketOps) {\n    Market[] memory markets = marketList;\n    marketOps = new MarketOperation[](markets.length);\n    for (uint256 m = 0; m < markets.length; ) {\n      bool[] memory ops = new bool[](2);\n      ops[0] = true;\n      ops[1] = false;\n      marketOps[m] = MarketOperation({ market: markets[m], operations: ops });\n      unchecked {\n        ++m;\n      }\n    }\n  }\n\n  /// @notice Gets the claimable amount of rewards for a given account and reward asset.\n  /// @param account The account to get the claimable amount for.\n  /// @param reward The reward asset.\n  /// @return unclaimedRewards The claimable amount for the given account.\n  function allClaimable(address account, ERC20 reward) external view returns (uint256 unclaimedRewards) {\n    return claimable(allMarketsOperations(), account, reward);\n  }\n\n  /// @notice Gets the claimable amount of rewards for a given account, Market operations and reward asset.\n  /// @param marketOps The list of Market operations to get the accrued and pending rewards from.\n  /// @param account The account to get the claimable amount for.\n  /// @param reward The reward asset.\n  /// @return unclaimedRewards The claimable amount for the given account.\n  function claimable(\n    MarketOperation[] memory marketOps,\n    address account,\n    ERC20 reward\n  ) public view returns (uint256 unclaimedRewards) {\n    for (uint256 i = 0; i < marketOps.length; ) {\n      MarketOperation memory marketOperation = marketOps[i];\n      Distribution storage dist = distribution[marketOperation.market];\n      RewardData storage rewardData = dist.rewards[reward];\n      if (dist.availableRewardsCount == 0) {\n        unchecked {\n          ++i;\n        }\n        continue;\n      }\n\n      AccountOperation[] memory ops = accountBalanceOperations(\n        marketOperation.market,\n        marketOperation.operations,\n        account,\n        rewardData.start\n      );\n      uint256 balance;\n      for (uint256 o = 0; o < ops.length; ) {\n        unclaimedRewards += rewardData.accounts[account][ops[o].operation].accrued;\n        balance += ops[o].balance;\n        unchecked {\n          ++o;\n        }\n      }\n      if (balance > 0) {\n        unclaimedRewards += pendingRewards(\n          account,\n          reward,\n          AccountMarketOperation({ market: marketOperation.market, accountOperations: ops })\n        );\n      }\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /// @notice Iterates and accrues all rewards for the operations of the given account in the given market.\n  /// @param account The account to accrue the rewards for.\n  /// @param market The Market in which the operations where made.\n  /// @param reward The reward asset.\n  /// @param ops The operations to accrue the rewards for.\n  function update(address account, Market market, ERC20 reward, AccountOperation[] memory ops) internal {\n    uint256 baseUnit = distribution[market].baseUnit;\n    RewardData storage rewardData = distribution[market].rewards[reward];\n    {\n      uint256 lastUpdate = rewardData.lastUpdate;\n      // `lastUpdate` can be greater than `block.timestamp` if distribution is set to start on a future date\n      if (block.timestamp > lastUpdate) {\n        (uint256 borrowIndex, uint256 depositIndex, uint256 newUndistributed) = previewAllocation(\n          rewardData,\n          market,\n          block.timestamp - lastUpdate\n        );\n        if (borrowIndex > type(uint128).max || depositIndex > type(uint128).max) revert IndexOverflow();\n        rewardData.borrowIndex = uint128(borrowIndex);\n        rewardData.depositIndex = uint128(depositIndex);\n        rewardData.lastUpdate = uint32(block.timestamp);\n        rewardData.lastUndistributed = newUndistributed;\n        emit IndexUpdate(market, reward, borrowIndex, depositIndex, newUndistributed, block.timestamp);\n      }\n    }\n\n    mapping(bool => Account) storage operationAccount = rewardData.accounts[account];\n    for (uint256 i = 0; i < ops.length; ) {\n      AccountOperation memory op = ops[i];\n      Account storage accountData = operationAccount[op.operation];\n      uint256 accountIndex = accountData.index;\n      uint256 newAccountIndex;\n      if (op.operation) {\n        newAccountIndex = rewardData.borrowIndex;\n      } else {\n        newAccountIndex = rewardData.depositIndex;\n      }\n      if (accountIndex != newAccountIndex) {\n        accountData.index = uint128(newAccountIndex);\n        if (op.balance != 0) {\n          uint256 rewardsAccrued = accountRewards(op.balance, newAccountIndex, accountIndex, baseUnit);\n          accountData.accrued += uint128(rewardsAccrued);\n          emit Accrue(market, reward, account, op.operation, accountIndex, newAccountIndex, rewardsAccrued);\n        }\n      }\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /// @notice Gets the equivalent of borrow shares from fixed pool principal borrows of an account.\n  /// @param market The Market to get the fixed borrows from.\n  /// @param account The account that borrowed from fixed pools.\n  /// @return fixedDebt The fixed borrow shares.\n  function accountFixedBorrowShares(\n    Market market,\n    address account,\n    uint32 start\n  ) internal view returns (uint256 fixedDebt) {\n    uint256 firstMaturity = start - (start % FixedLib.INTERVAL) + FixedLib.INTERVAL;\n    uint256 maxMaturity = block.timestamp -\n      (block.timestamp % FixedLib.INTERVAL) +\n      (FixedLib.INTERVAL * market.maxFuturePools());\n\n    for (uint256 maturity = firstMaturity; maturity <= maxMaturity; ) {\n      (uint256 principal, ) = market.fixedBorrowPositions(maturity, account);\n      fixedDebt += principal;\n      unchecked {\n        maturity += FixedLib.INTERVAL;\n      }\n    }\n    fixedDebt = market.previewRepay(fixedDebt);\n  }\n\n  /// @notice Gets the reward indexes and last amount of undistributed rewards for a given market and reward asset.\n  /// @param market The market to get the reward indexes for.\n  /// @param reward The reward asset to get the reward indexes for.\n  /// @return borrowIndex The index for the floating and fixed borrow operation.\n  /// @return depositIndex The index for the floating deposit operation.\n  /// @return lastUndistributed The last amount of undistributed rewards.\n  function rewardIndexes(Market market, ERC20 reward) external view returns (uint256, uint256, uint256) {\n    RewardData storage rewardData = distribution[market].rewards[reward];\n    return (rewardData.borrowIndex, rewardData.depositIndex, rewardData.lastUndistributed);\n  }\n\n  /// @notice Calculates the rewards not accrued yet for the given operations of a given account and reward asset.\n  /// @param account The account to get the pending rewards for.\n  /// @param reward The reward asset to get the pending rewards for.\n  /// @param ops The operations to get the pending rewards for.\n  /// @return rewards The pending rewards for the given operations.\n  function pendingRewards(\n    address account,\n    ERC20 reward,\n    AccountMarketOperation memory ops\n  ) internal view returns (uint256 rewards) {\n    RewardData storage rewardData = distribution[ops.market].rewards[reward];\n    uint256 baseUnit = distribution[ops.market].baseUnit;\n    uint256 lastUpdate = rewardData.lastUpdate;\n    (uint256 borrowIndex, uint256 depositIndex, ) = previewAllocation(\n      rewardData,\n      ops.market,\n      block.timestamp > lastUpdate ? block.timestamp - lastUpdate : 0\n    );\n    mapping(bool => Account) storage operationAccount = rewardData.accounts[account];\n    for (uint256 o = 0; o < ops.accountOperations.length; ) {\n      uint256 nextIndex;\n      if (ops.accountOperations[o].operation) {\n        nextIndex = borrowIndex;\n      } else {\n        nextIndex = depositIndex;\n      }\n\n      rewards += accountRewards(\n        ops.accountOperations[o].balance,\n        nextIndex,\n        operationAccount[ops.accountOperations[o].operation].index,\n        baseUnit\n      );\n      unchecked {\n        ++o;\n      }\n    }\n  }\n\n  /// @notice Calculates and returns the new amount of rewards given by the difference between the `accountIndex` and\n  /// the `globalIndex`.\n  /// @param balance The account's balance in the operation's pool.\n  /// @param globalIndex Current index of the distribution.\n  /// @param accountIndex Last index stored for the account.\n  /// @param baseUnit One unit of the Market's asset (10**decimals).\n  /// @return The amount of new rewards to be accrued by the account.\n  function accountRewards(\n    uint256 balance,\n    uint256 globalIndex,\n    uint256 accountIndex,\n    uint256 baseUnit\n  ) internal pure returns (uint256) {\n    return balance.mulDivDown(globalIndex - accountIndex, baseUnit);\n  }\n\n  /// @notice Retrieves projected distribution indexes and new undistributed amount for a given `deltaTime`.\n  /// @param market The market to calculate the indexes for.\n  /// @param reward The reward asset to calculate the indexes for.\n  /// @param deltaTime The elapsed time since the last update.\n  /// @return borrowIndex The index for the borrow operation.\n  /// @return depositIndex The index for the deposit operation.\n  /// @return newUndistributed The new undistributed rewards of the distribution.\n  function previewAllocation(\n    Market market,\n    ERC20 reward,\n    uint256 deltaTime\n  ) external view returns (uint256 borrowIndex, uint256 depositIndex, uint256 newUndistributed) {\n    return previewAllocation(distribution[market].rewards[reward], market, deltaTime);\n  }\n\n  /// @notice Calculates and returns the distribution indexes and new undistributed tokens for a given `rewardData`.\n  /// @param rewardData The distribution's data.\n  /// @param market The market to calculate the indexes for.\n  /// @param deltaTime The elapsed time since the last update.\n  /// @return borrowIndex The index for the borrow operation.\n  /// @return depositIndex The index for the deposit operation.\n  /// @return newUndistributed The new undistributed rewards of the distribution.\n  function previewAllocation(\n    RewardData storage rewardData,\n    Market market,\n    uint256 deltaTime\n  ) internal view returns (uint256 borrowIndex, uint256 depositIndex, uint256 newUndistributed) {\n    TotalMarketBalance memory m;\n    m.floatingDebt = market.floatingDebt();\n    m.floatingAssets = market.floatingAssets();\n    TimeVars memory t;\n    t.start = rewardData.start;\n    t.end = rewardData.end;\n    {\n      uint256 firstMaturity = t.start - (t.start % FixedLib.INTERVAL) + FixedLib.INTERVAL;\n      uint256 maxMaturity = block.timestamp -\n        (block.timestamp % FixedLib.INTERVAL) +\n        (FixedLib.INTERVAL * market.maxFuturePools());\n      uint256 fixedDebt;\n      for (uint256 maturity = firstMaturity; maturity <= maxMaturity; ) {\n        (uint256 borrowed, ) = market.fixedPoolBalance(maturity);\n        fixedDebt += borrowed;\n        unchecked {\n          maturity += FixedLib.INTERVAL;\n        }\n      }\n      m.debt = m.floatingDebt + fixedDebt;\n      m.fixedBorrowShares = market.previewRepay(fixedDebt);\n    }\n    uint256 target;\n    {\n      uint256 targetDebt = rewardData.targetDebt;\n      target = m.debt < targetDebt ? m.debt.divWadDown(targetDebt) : 1e18;\n    }\n    uint256 rewards;\n    {\n      uint256 releaseRate = rewardData.releaseRate;\n      uint256 lastUndistributed = rewardData.lastUndistributed;\n      t.period = t.end - t.start;\n      uint256 distributionFactor = t.period > 0\n        ? rewardData.undistributedFactor.mulDivDown(target, t.period * 1e18)\n        : 0;\n      if (block.timestamp <= t.end) {\n        if (distributionFactor > 0) {\n          uint256 exponential = uint256((-int256(distributionFactor * deltaTime)).expWad());\n          newUndistributed =\n            lastUndistributed.mulWadDown(exponential) +\n            releaseRate.mulDivDown(1e18 - target, distributionFactor).mulWadUp(1e18 - exponential);\n        } else {\n          newUndistributed = lastUndistributed + releaseRate.mulWadDown(1e18 - target) * deltaTime;\n        }\n        rewards = uint256(int256(releaseRate * deltaTime) - (int256(newUndistributed) - int256(lastUndistributed)));\n      } else if (rewardData.lastUpdate > t.end) {\n        newUndistributed =\n          lastUndistributed -\n          lastUndistributed.mulWadUp(1e18 - uint256((-int256(distributionFactor * deltaTime)).expWad()));\n        rewards = uint256(-(int256(newUndistributed) - int256(lastUndistributed)));\n      } else {\n        uint256 exponential;\n        deltaTime = t.end - rewardData.lastUpdate;\n        if (distributionFactor > 0) {\n          exponential = uint256((-int256(distributionFactor * deltaTime)).expWad());\n          newUndistributed =\n            lastUndistributed.mulWadDown(exponential) +\n            releaseRate.mulDivDown(1e18 - target, distributionFactor).mulWadUp(1e18 - exponential);\n        } else {\n          newUndistributed = lastUndistributed + releaseRate.mulWadDown(1e18 - target) * deltaTime;\n        }\n        exponential = uint256((-int256(distributionFactor * (block.timestamp - t.end))).expWad());\n        newUndistributed = newUndistributed - newUndistributed.mulWadUp(1e18 - exponential);\n        rewards = uint256(int256(releaseRate * deltaTime) - (int256(newUndistributed) - int256(lastUndistributed)));\n      }\n      if (rewards == 0) return (rewardData.borrowIndex, rewardData.depositIndex, newUndistributed);\n    }\n    {\n      AllocationVars memory v;\n      v.globalUtilization = Math.min(\n        m.floatingAssets != 0\n          ? 1e18 - (m.floatingAssets - m.floatingDebt - market.floatingBackupBorrowed()).divWadDown(m.floatingAssets)\n          : 0,\n        UTILIZATION_CAP\n      );\n      v.transitionFactor = rewardData.transitionFactor;\n      v.flipSpeed = rewardData.flipSpeed;\n      v.borrowAllocationWeightFactor = rewardData.borrowAllocationWeightFactor;\n      v.sigmoid = v.globalUtilization > 0\n        ? uint256(1e18).divWadDown(\n          1e18 +\n            uint256(\n              (-(v.flipSpeed *\n                (int256(v.globalUtilization.divWadDown(1e18 - v.globalUtilization)).lnWad() -\n                  int256(v.transitionFactor.divWadDown(1e18 - v.transitionFactor)).lnWad())) / 1e18).expWad()\n            )\n        )\n        : 0;\n      v.borrowRewardRule = rewardData\n        .compensationFactor\n        .mulWadDown(\n          market\n            .interestRateModel()\n            .floatingRate(m.floatingAssets != 0 ? m.floatingDebt.divWadDown(m.floatingAssets) : 0, v.globalUtilization)\n            .mulWadDown(1e18 - v.globalUtilization.mulWadUp(1e18 - market.treasuryFeeRate())) +\n            v.borrowAllocationWeightFactor\n        )\n        .mulWadDown(1e18 - v.sigmoid);\n      v.depositRewardRule =\n        rewardData.depositAllocationWeightAddend.mulWadDown(1e18 - v.sigmoid) +\n        rewardData.depositAllocationWeightFactor.mulWadDown(v.sigmoid);\n      v.borrowAllocation = v.borrowRewardRule.divWadDown(v.borrowRewardRule + v.depositRewardRule);\n      v.depositAllocation = 1e18 - v.borrowAllocation;\n      {\n        uint256 totalDepositSupply = market.totalSupply();\n        uint256 totalBorrowSupply = market.totalFloatingBorrowShares() + m.fixedBorrowShares;\n        uint256 baseUnit = distribution[market].baseUnit;\n        borrowIndex =\n          rewardData.borrowIndex +\n          (totalBorrowSupply > 0 ? rewards.mulWadDown(v.borrowAllocation).mulDivDown(baseUnit, totalBorrowSupply) : 0);\n        depositIndex =\n          rewardData.depositIndex +\n          (\n            totalDepositSupply > 0\n              ? rewards.mulWadDown(v.depositAllocation).mulDivDown(baseUnit, totalDepositSupply)\n              : 0\n          );\n      }\n    }\n  }\n\n  /// @notice Get account balances of the given Market operations.\n  /// @param market The address of the Market.\n  /// @param ops List of operations to retrieve account balance.\n  /// @param account Account to get the balance from.\n  /// @param distributionStart Timestamp of the start of the distribution to correctly get the rewarded fixed pools.\n  /// @return accountBalanceOps contains a list with account balance per each operation.\n  function accountBalanceOperations(\n    Market market,\n    bool[] memory ops,\n    address account,\n    uint32 distributionStart\n  ) internal view returns (AccountOperation[] memory accountBalanceOps) {\n    accountBalanceOps = new AccountOperation[](ops.length);\n    for (uint256 i = 0; i < ops.length; ) {\n      if (ops[i]) {\n        (, , uint256 floatingBorrowShares) = market.accounts(account);\n        accountBalanceOps[i] = AccountOperation({\n          operation: true,\n          balance: floatingBorrowShares + accountFixedBorrowShares(market, account, distributionStart)\n        });\n      } else {\n        accountBalanceOps[i] = AccountOperation({ operation: false, balance: market.balanceOf(account) });\n      }\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /// @notice Withdraws the contract's balance of the given asset to the given address.\n  /// @param asset The asset to withdraw.\n  /// @param to The address to withdraw the asset to.\n  function withdraw(ERC20 asset, address to) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    asset.safeTransfer(to, asset.balanceOf(address(this)));\n  }\n\n  /// @notice Enables or updates the reward distribution for the given markets and rewards.\n  /// @param configs The configurations to update each RewardData with.\n  function config(Config[] memory configs) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint256 i = 0; i < configs.length; ) {\n      // transitionFactor cannot be eq or higher than 1e18 to avoid division by zero or underflow\n      if (configs[i].transitionFactor >= 1e18) revert InvalidConfig();\n      // depositAllocationWeightFactor cannot be zero to avoid division by zero when sigmoid equals 1e18\n      if (configs[i].depositAllocationWeightFactor == 0) revert InvalidConfig();\n\n      Distribution storage dist = distribution[configs[i].market];\n      RewardData storage rewardData = dist.rewards[configs[i].reward];\n\n      if (dist.baseUnit == 0) {\n        // never initialized before, adding to the list of markets\n        marketList.push(configs[i].market);\n      }\n      if (!rewardEnabled[configs[i].reward]) {\n        // add reward address to global rewards list if still not enabled\n        rewardEnabled[configs[i].reward] = true;\n        rewardList.push(configs[i].reward);\n      }\n      if (rewardData.lastUpdate == 0) {\n        // add reward address to distribution data's available rewards if distribution is new\n        dist.availableRewards[dist.availableRewardsCount++] = configs[i].reward;\n        dist.baseUnit = 10 ** configs[i].market.decimals();\n        // set initial parameters if distribution is new\n        rewardData.start = configs[i].start;\n        rewardData.lastUpdate = configs[i].start;\n        rewardData.releaseRate = configs[i].totalDistribution / configs[i].distributionPeriod;\n      } else {\n        uint32 start = rewardData.start;\n        uint32 end = rewardData.end;\n        // update global indexes before updating distribution values\n        bool[] memory ops = new bool[](1);\n        ops[0] = true;\n        update(\n          address(0),\n          configs[i].market,\n          configs[i].reward,\n          accountBalanceOperations(configs[i].market, ops, address(0), start)\n        );\n        // properly update release rate\n        if (block.timestamp < end) {\n          uint256 released = 0;\n          uint256 elapsed = 0;\n          if (block.timestamp > start) {\n            released =\n              rewardData.lastConfigReleased +\n              rewardData.releaseRate *\n              (block.timestamp - rewardData.lastConfig);\n            elapsed = block.timestamp - start;\n            if (configs[i].totalDistribution <= released || configs[i].distributionPeriod <= elapsed) {\n              revert InvalidConfig();\n            }\n            rewardData.lastConfigReleased = released;\n          }\n\n          rewardData.releaseRate =\n            (configs[i].totalDistribution - released) /\n            (configs[i].distributionPeriod - elapsed);\n        } else if (rewardData.start != configs[i].start) {\n          rewardData.start = configs[i].start;\n          rewardData.lastUpdate = configs[i].start;\n          rewardData.releaseRate = configs[i].totalDistribution / configs[i].distributionPeriod;\n          rewardData.lastConfigReleased = 0;\n        }\n      }\n      rewardData.lastConfig = uint32(block.timestamp);\n      rewardData.end = rewardData.start + uint32(configs[i].distributionPeriod);\n      rewardData.priceFeed = configs[i].priceFeed;\n      // set emission and distribution parameters\n      rewardData.totalDistribution = configs[i].totalDistribution;\n      rewardData.targetDebt = configs[i].targetDebt;\n      rewardData.undistributedFactor = configs[i].undistributedFactor;\n      rewardData.flipSpeed = configs[i].flipSpeed;\n      rewardData.compensationFactor = configs[i].compensationFactor;\n      rewardData.borrowAllocationWeightFactor = configs[i].borrowAllocationWeightFactor;\n      rewardData.depositAllocationWeightAddend = configs[i].depositAllocationWeightAddend;\n      rewardData.transitionFactor = configs[i].transitionFactor;\n      rewardData.depositAllocationWeightFactor = configs[i].depositAllocationWeightFactor;\n\n      emit DistributionSet(configs[i].market, configs[i].reward, configs[i]);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  mapping(address => uint256) public nonces;\n\n  // solhint-disable-next-line func-name-mixedcase\n  function DOMAIN_SEPARATOR() public view returns (bytes32) {\n    return\n      keccak256(\n        abi.encode(\n          keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n          keccak256(\"RewardsController\"),\n          keccak256(\"1\"),\n          block.chainid,\n          address(this)\n        )\n      );\n  }\n\n  address private _claimSender;\n  modifier claimSender() {\n    if (_claimSender == address(0)) _claimSender = msg.sender;\n    _;\n    delete _claimSender;\n  }\n\n  modifier permitSender(ClaimPermit calldata permit) {\n    assert(_claimSender == address(0));\n    assert(permit.deadline >= block.timestamp);\n    unchecked {\n      address recoveredAddress = ecrecover(\n        keccak256(\n          abi.encodePacked(\n            \"\\x19\\x01\",\n            DOMAIN_SEPARATOR(),\n            keccak256(\n              abi.encode(\n                keccak256(\"ClaimPermit(address owner,address spender,address[] assets,uint256 deadline)\"),\n                permit.owner,\n                msg.sender,\n                permit.assets,\n                nonces[permit.owner]++,\n                permit.deadline\n              )\n            )\n          )\n        ),\n        permit.v,\n        permit.r,\n        permit.s\n      );"
    }
  ]
}