{
  "Title": "Lack of Validation When Updating Maximum Failed Execution Tries",
  "Content": "The [`L2ScrollMessenger contract`](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/L2ScrollMessenger.sol) provides a mechanism to limit the number of failed execution tries that a transaction may have. This limit can be changed with the [function `updateMaxFailedExecutionTimes`](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/L2ScrollMessenger.sol#L270). However, it is possible to set `maxFailedExecutionTimes` to zero, which could lead to a situation where no transactions can ever succeed, as they would immediately fail [this requirement](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/L2ScrollMessenger.sol#L337).\n\n\nConsider enforcing that `maxFailedExecutionTimes` cannot be set to zero in the [`updateMaxFailedExecutionTimes` function](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/L2ScrollMessenger.sol#L270).\n\n\n***Update:** Resolved in [pull request #649](https://github.com/scroll-tech/scroll/pull/649) at commit [58ee807](https://github.com/scroll-tech/scroll/pull/649/commits/58ee807c3ab96bd9325d997ce9e79b86f42ca3a8).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/L2/L2ScrollMessenger.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport {IL2ScrollMessenger} from \"./IL2ScrollMessenger.sol\";\nimport {L2MessageQueue} from \"./predeploys/L2MessageQueue.sol\";\nimport {IL1BlockContainer} from \"./predeploys/IL1BlockContainer.sol\";\nimport {IL1GasPriceOracle} from \"./predeploys/IL1GasPriceOracle.sol\";\n\nimport {PatriciaMerkleTrieVerifier} from \"../libraries/verifier/PatriciaMerkleTrieVerifier.sol\";\nimport {ScrollConstants} from \"../libraries/constants/ScrollConstants.sol\";\nimport {AddressAliasHelper} from \"../libraries/common/AddressAliasHelper.sol\";\nimport {IScrollMessenger} from \"../libraries/IScrollMessenger.sol\";\nimport {ScrollMessengerBase} from \"../libraries/ScrollMessengerBase.sol\";\n\n/// @title L2ScrollMessenger\n/// @notice The `L2ScrollMessenger` contract can:\n///\n/// 1. send messages from layer 2 to layer 1;\n/// 2. relay messages from layer 1 layer 2;\n/// 3. drop expired message due to sequencer problems.\n///\n/// @dev It should be a predeployed contract in layer 2 and should hold infinite amount\n/// of Ether (Specifically, `uint256(-1)`), which can be initialized in Genesis Block.\ncontract L2ScrollMessenger is ScrollMessengerBase, PausableUpgradeable, IL2ScrollMessenger {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when the maximum number of times each message can fail in L2 is updated.\n    /// @param maxFailedExecutionTimes The new maximum number of times each message can fail in L2.\n    event UpdateMaxFailedExecutionTimes(uint256 maxFailedExecutionTimes);\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The contract contains the list of L1 blocks.\n    address public immutable blockContainer;\n\n    /// @notice The address of L2MessageQueue.\n    address public immutable gasOracle;\n\n    /// @notice The address of L2MessageQueue.\n    address public immutable messageQueue;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from L2 message hash to sent status.\n    mapping(bytes32 => bool) public isL2MessageSent;\n\n    /// @notice Mapping from L1 message hash to a boolean value indicating if the message has been successfully executed.\n    mapping(bytes32 => bool) public isL1MessageExecuted;\n\n    /// @notice Mapping from L1 message hash to the number of failure times.\n    mapping(bytes32 => uint256) public l1MessageFailedTimes;\n\n    /// @notice The maximum number of times each L1 message can fail on L2.\n    uint256 public maxFailedExecutionTimes;\n\n    // @note move to ScrollMessengerBase in next big refactor\n    /// @dev The status of for non-reentrant check.\n    uint256 private _lock_status;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_lock_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _lock_status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _lock_status = _NOT_ENTERED;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(\n        address _blockContainer,\n        address _gasOracle,\n        address _messageQueue\n    ) {\n        blockContainer = _blockContainer;\n        gasOracle = _gasOracle;\n        messageQueue = _messageQueue;\n    }\n\n    function initialize(address _counterpart, address _feeVault) external initializer {\n        PausableUpgradeable.__Pausable_init();\n        ScrollMessengerBase._initialize(_counterpart, _feeVault);\n\n        maxFailedExecutionTimes = 3;\n\n        // initialize to a nonzero value\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Check whether the l1 message is included in the corresponding L1 block.\n    /// @param _blockHash The block hash where the message should in.\n    /// @param _msgHash The hash of the message to check.\n    /// @param _proof The encoded storage proof from eth_getProof.\n    /// @return bool Return true is the message is included in L1, otherwise return false.\n    function verifyMessageInclusionStatus(\n        bytes32 _blockHash,\n        bytes32 _msgHash,\n        bytes calldata _proof\n    ) public view returns (bool) {\n        bytes32 _expectedStateRoot = IL1BlockContainer(blockContainer).getStateRoot(_blockHash);\n        require(_expectedStateRoot != bytes32(0), \"Block is not imported\");\n\n        bytes32 _storageKey;\n        // `mapping(bytes32 => bool) public isL1MessageSent` is the 105-nd slot of contract `L1ScrollMessenger`.\n        // + 50 from `OwnableUpgradeable`\n        // + 4 from `ScrollMessengerBase`\n        // + 50 from `PausableUpgradeable`\n        // + 2-nd in `L1ScrollMessenger`\n        assembly {\n            mstore(0x00, _msgHash)\n            mstore(0x20, 105)\n            _storageKey := keccak256(0x00, 0x40)\n        }\n\n        (bytes32 _computedStateRoot, bytes32 _storageValue) = PatriciaMerkleTrieVerifier.verifyPatriciaProof(\n            counterpart,\n            _storageKey,\n            _proof\n        );\n        require(_computedStateRoot == _expectedStateRoot, \"State roots mismatch\");\n\n        return uint256(_storageValue) == 1;\n    }\n\n    /// @notice Check whether the message is executed in the corresponding L1 block.\n    /// @param _blockHash The block hash where the message should in.\n    /// @param _msgHash The hash of the message to check.\n    /// @param _proof The encoded storage proof from eth_getProof.\n    /// @return bool Return true is the message is executed in L1, otherwise return false.\n    function verifyMessageExecutionStatus(\n        bytes32 _blockHash,\n        bytes32 _msgHash,\n        bytes calldata _proof\n    ) external view returns (bool) {\n        bytes32 _expectedStateRoot = IL1BlockContainer(blockContainer).getStateRoot(_blockHash);\n        require(_expectedStateRoot != bytes32(0), \"Block not imported\");\n\n        bytes32 _storageKey;\n        // `mapping(bytes32 => bool) public isL2MessageExecuted` is the 106-th slot of contract `L1ScrollMessenger`.\n        // + 50 from `OwnableUpgradeable`\n        // + 4 from `ScrollMessengerBase`\n        // + 50 from `PausableUpgradeable`\n        // + 3-rd in `L1ScrollMessenger`\n        assembly {\n            mstore(0x00, _msgHash)\n            mstore(0x20, 106)\n            _storageKey := keccak256(0x00, 0x40)\n        }\n\n        (bytes32 _computedStateRoot, bytes32 _storageValue) = PatriciaMerkleTrieVerifier.verifyPatriciaProof(\n            counterpart,\n            _storageKey,\n            _proof\n        );\n        require(_computedStateRoot == _expectedStateRoot, \"State root mismatch\");\n\n        return uint256(_storageValue) == 1;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit);\n    }\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes calldata _message,\n        uint256 _gasLimit,\n        address\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit);\n    }\n\n    /// @inheritdoc IL2ScrollMessenger\n    function relayMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _nonce,\n        bytes memory _message\n    ) external override whenNotPaused {\n        // It is impossible to deploy a contract with the same address, reentrance is prevented in nature.\n        require(AddressAliasHelper.undoL1ToL2Alias(msg.sender) == counterpart, \"Caller is not L1ScrollMessenger\");\n\n        bytes32 _xDomainCalldataHash = keccak256(_encodeXDomainCalldata(_from, _to, _value, _nonce, _message));\n\n        require(!isL1MessageExecuted[_xDomainCalldataHash], \"Message was already successfully executed\");\n\n        _executeMessage(_from, _to, _value, _message, _xDomainCalldataHash);\n    }\n\n    /// @inheritdoc IL2ScrollMessenger\n    function retryMessageWithProof(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _nonce,\n        bytes memory _message,\n        L1MessageProof calldata _proof\n    ) external override whenNotPaused {\n        // anti reentrance\n        require(xDomainMessageSender == ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER, \"Already in execution\");\n\n        // check message status\n        bytes32 _xDomainCalldataHash = keccak256(_encodeXDomainCalldata(_from, _to, _value, _nonce, _message));\n        require(!isL1MessageExecuted[_xDomainCalldataHash], \"Message successfully executed\");\n        require(l1MessageFailedTimes[_xDomainCalldataHash] > 0, \"Message not relayed before\");\n\n        require(\n            verifyMessageInclusionStatus(_proof.blockHash, _xDomainCalldataHash, _proof.stateRootProof),\n            \"Message not included\"\n        );\n\n        _executeMessage(_from, _to, _value, _message, _xDomainCalldataHash);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Pause the contract\n    /// @dev This function can only called by contract owner.\n    /// @param _status The pause status to update.\n    function setPause(bool _status) external onlyOwner {\n        if (_status) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    /// @notice Update max failed execution times.\n    /// @dev This function can only called by contract owner.\n    /// @param _maxFailedExecutionTimes The new max failed execution times.\n    function updateMaxFailedExecutionTimes(uint256 _maxFailedExecutionTimes) external onlyOwner {\n        maxFailedExecutionTimes = _maxFailedExecutionTimes;\n\n        emit UpdateMaxFailedExecutionTimes(_maxFailedExecutionTimes);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to send cross domain message.\n    /// @param _to The address of account who receive the message.\n    /// @param _value The amount of ether passed when call target contract.\n    /// @param _message The content of the message.\n    /// @param _gasLimit Optional gas limit to complete the message relay on corresponding chain.\n    function _sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit\n    ) internal nonReentrant {\n        require(msg.value == _value, \"msg.value mismatch\");\n\n        uint256 _nonce = L2MessageQueue(messageQueue).nextMessageIndex();\n        bytes32 _xDomainCalldataHash = keccak256(_encodeXDomainCalldata(msg.sender, _to, _value, _nonce, _message));\n\n        // normally this won't happen, since each message has different nonce, but just in case.\n        require(!isL2MessageSent[_xDomainCalldataHash], \"Duplicated message\");\n        isL2MessageSent[_xDomainCalldataHash] = true;\n\n        L2MessageQueue(messageQueue).appendMessage(_xDomainCalldataHash);\n\n        emit SentMessage(msg.sender, _to, _value, _nonce, _gasLimit, _message);\n    }\n\n    /// @dev Internal function to execute a L1 => L2 message.\n    /// @param _from The address of the sender of the message.\n    /// @param _to The address of the recipient of the message.\n    /// @param _value The msg.value passed to the message call.\n    /// @param _message The content of the message.\n    /// @param _xDomainCalldataHash The hash of the message.\n    function _executeMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        bytes32 _xDomainCalldataHash\n    ) internal {\n        // @note check more `_to` address to avoid attack in the future when we add more gateways.\n        require(_to != messageQueue, \"Forbid to call message queue\");\n        require(_to != address(this), \"Forbid to call self\");\n\n        // @note This usually will never happen, just in case.\n        require(_from != xDomainMessageSender, \"Invalid message sender\");\n\n        xDomainMessageSender = _from;\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = _to.call{value: _value}(_message);\n        // reset value to refund gas.\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n\n        if (success) {\n            isL1MessageExecuted[_xDomainCalldataHash] = true;\n            emit RelayedMessage(_xDomainCalldataHash);\n        } else {\n            unchecked {\n                uint256 _failedTimes = l1MessageFailedTimes[_xDomainCalldataHash] + 1;\n                require(_failedTimes <= maxFailedExecutionTimes, \"Exceed maximum failure times\");\n                l1MessageFailedTimes[_xDomainCalldataHash] = _failedTimes;\n            }\n            emit FailedRelayedMessage(_xDomainCalldataHash);\n        }\n    }\n}"
    }
  ]
}