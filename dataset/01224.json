{
  "Title": "ETH cannot always be unstaked using Rocket Pool",
  "Content": "# ETH cannot always be unstaked using Rocket Pool\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/bridges/BridgeReth.sol#L98-L107\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/bridges/BridgeReth.sol#L98-L107</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/BridgeRouterFacet.sol#L88-L114\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/BridgeRouterFacet.sol#L88-L114</a>\n\n\n## Summary\nThe protocol lets users unstake Ethereum using any bridge they want. Rocket Pool may not have enough ETH to satisfy unstake transactions, this will cause the transaction to revert.\n\n## Vulnerability Details\nWhen users try to unstake ETH using Rocket Pool, the transaction may revert because Rocket Pool may not have enough ETH in its deposit pool and rEth contract to satisfy the unstake request. Rocket pool sources ETH for unstaking from the rEth contract and deposit pool. When they are empty it cannot satisfy unstake requests. More information can be found in the [Unstake](https://docs.rocketpool.net/guides/staking/via-rp.html#unstaking) section of the rocketPool documentation.\n\nThe pools have been empty before. Here's a proof of concept of failed withdrawals when Rocket Pool's rEth contract and deposit pool were empty at block 15361748.\n\n```\n   function testWithdrawETHfromRocketPool() public{\n    string memory MAINNET_RPC_URL = vm.envString(\"MAINNET_RPC_URL\");\n    uint256 mainnetFork = vm.createFork(MAINNET_RPC_URL, 15361748);\n\n    RocketTokenRETHInterface rEth = RocketTokenRETHInterface(0xae78736Cd615f374D3085123A210448E74Fc6393);\n    vm.selectFork(mainnetFork);\n    uint totalCollateral = rEth.getTotalCollateral();\n    assertEq(totalCollateral, 0); // pools are empty\n\n    address owner = 0x50A78DFb9F5CC22ac8ffA90FA2B6C595881CCb97; // has rEth at block 15361748\n    uint rEthBalance = rEth.balanceOf(owner);\n    assertGt(rEthBalance, 0);\n    \n    vm.expectRevert(\"Insufficient ETH balance for exchange\");\n    vm.prank(owner); \n    rEth.burn(rEthBalance);\n  }\n```\n\n## Impact\nIf Rocket Pool's rEth contract and deposit Pool do not have enough ETH to satisfy an unstake transaction the transaction will revert.\n\n## Tools Used\nVscode\n\n## Recommendations\nCheck if Rocket Pool has enough ETH and if it doesn't, rEth can be exchanged for ETH on a DEX and sent to the user. ",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clm871gl00001mp081mzjdlwc",
  "Code": [
    {
      "filename": "contracts/bridges/BridgeReth.sol",
      "content": "// https://docs.rocketpool.net/developers/usage/contracts/contracts.html#implementation\n// https://github.com/rocket-pool/rocketpool/blob/master/contracts/contract/token/RocketTokenRETH.sol\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {IRocketStorage} from \"interfaces/IRocketStorage.sol\";\nimport {IRocketTokenRETH} from \"interfaces/IRocketTokenRETH.sol\";\nimport {IRocketDepositPool} from \"interfaces/IRocketDepositPool.sol\";\nimport {IBridge} from \"contracts/interfaces/IBridge.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract BridgeReth is IBridge {\n    bytes32 private immutable RETH_TYPEHASH;\n    bytes32 private immutable ROCKET_DEPOSIT_POOL_TYPEHASH;\n    IRocketStorage private immutable rocketStorage;\n    address private immutable diamond;\n\n    constructor(IRocketStorage rocketStorageAddress, address diamondAddr) {\n        rocketStorage = IRocketStorage(rocketStorageAddress);\n        diamond = diamondAddr;\n        // @dev (gas) use immutable instead of constant\n        // See https://github.com/ethereum/solidity/issues/9232#issuecomment-646131646\n        RETH_TYPEHASH = keccak256(abi.encodePacked(\"contract.address\", \"rocketTokenRETH\"));\n        ROCKET_DEPOSIT_POOL_TYPEHASH =\n            keccak256(abi.encodePacked(\"contract.address\", \"rocketDepositPool\"));\n    }\n\n    modifier onlyDiamond() {\n        if (msg.sender != diamond) {\n            revert NotDiamond();\n        }\n        _;\n    }\n\n    receive() external payable {}\n\n    function _getRethContract() private view returns (IRocketTokenRETH) {\n        return IRocketTokenRETH(rocketStorage.getAddress(RETH_TYPEHASH));\n    }\n\n    //@dev does not need read only re-entrancy\n    function getBaseCollateral() external view returns (address) {\n        return rocketStorage.getAddress(RETH_TYPEHASH);\n    }\n\n    //@dev does not need read only re-entrancy\n    function getZethValue() external view returns (uint256) {\n        IRocketTokenRETH rocketETHToken = _getRethContract();\n        return rocketETHToken.getEthValue(rocketETHToken.balanceOf(address(this)));\n    }\n\n    // @dev ERC20 success https://ethereum.stackexchange.com/questions/148216/when-would-an-erc20-return-false\n    // Bring rETH to system and credit zETH to user\n    function deposit(address from, uint256 amount)\n        external\n        onlyDiamond\n        returns (uint256)\n    {\n        IRocketTokenRETH rocketETHToken = _getRethContract();\n        // Transfer rETH to this bridge contract\n        // @dev RETH uses OZ ERC-20, don't need to check success bool\n        rocketETHToken.transferFrom(from, address(this), amount);\n        // Calculate rETH equivalent value in ETH\n        return rocketETHToken.getEthValue(amount);\n    }\n\n    // Deposit ETH and mint rETH (to system) and credit zETH to user\n    function depositEth() external payable onlyDiamond returns (uint256) {\n        IRocketDepositPool rocketDepositPool =\n            IRocketDepositPool(rocketStorage.getAddress(ROCKET_DEPOSIT_POOL_TYPEHASH));\n        IRocketTokenRETH rocketETHToken = _getRethContract();\n\n        uint256 originalBalance = rocketETHToken.balanceOf(address(this));\n        rocketDepositPool.deposit{value: msg.value}();\n        uint256 netBalance = rocketETHToken.balanceOf(address(this)) - originalBalance;\n        if (netBalance == 0) revert NetBalanceZero();\n\n        return rocketETHToken.getEthValue(netBalance);\n    }\n\n    // Exchange system rETH to fulfill zETH obligation to user\n    function withdraw(address to, uint256 amount)\n        external\n        onlyDiamond\n        returns (uint256)\n    {\n        IRocketTokenRETH rocketETHToken = _getRethContract();\n        // Calculate zETH equivalent value in rETH\n        uint256 rethValue = rocketETHToken.getRethValue(amount);\n        // Transfer rETH from this bridge contract\n        // @dev RETH uses OZ ERC-20, don't need to check success bool\n        rocketETHToken.transfer(to, rethValue);\n        return rethValue;\n    }\n\n    function unstake(address to, uint256 amount) external onlyDiamond {\n        IRocketTokenRETH rocketETHToken = _getRethContract();\n        uint256 rethValue = rocketETHToken.getRethValue(amount);\n        uint256 originalBalance = address(this).balance;\n        rocketETHToken.burn(rethValue);\n        uint256 netBalance = address(this).balance - originalBalance;\n        if (netBalance == 0) revert NetBalanceZero();\n        (bool sent,) = to.call{value: netBalance}(\"\");\n        assert(sent);\n    }\n}"
    },
    {
      "filename": "contracts/facets/BridgeRouterFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U88} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {IBridge} from \"contracts/interfaces/IBridge.sol\";\n\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {LibBridge} from \"contracts/libraries/LibBridge.sol\";\nimport {LibVault} from \"contracts/libraries/LibVault.sol\";\nimport {Constants, Vault} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract BridgeRouterFacet is Modifiers {\n    using U256 for uint256;\n    using U88 for uint88;\n    using LibBridge for uint256;\n    using LibBridge for address;\n    using LibVault for uint256;\n\n    address private immutable rethBridge;\n    address private immutable stethBridge;\n\n    constructor(address _rethBridge, address _stethBridge) {\n        rethBridge = _rethBridge;\n        stethBridge = _stethBridge;\n    }\n\n    function getZethTotal(uint256 vault)\n        external\n        view\n        nonReentrantView\n        returns (uint256)\n    {\n        return vault.getZethTotal();\n    }\n\n    //@dev does not need read only re-entrancy\n    function getBridges(uint256 vault) external view returns (address[] memory) {\n        return s.vaultBridges[vault];\n    }\n\n    function deposit(address bridge, uint88 amount)\n        external\n        nonReentrant\n        onlyValidBridge(bridge)\n    {\n        if (amount < Constants.MIN_DEPOSIT) revert Errors.UnderMinimumDeposit();\n        // @dev amount after deposit might be less, if bridge takes a fee\n        uint88 zethAmount = uint88(IBridge(bridge).deposit(msg.sender, amount)); // @dev(safe-cast)\n\n        uint256 vault;\n        if (bridge == rethBridge || bridge == stethBridge) {\n            vault = Vault.CARBON;\n        } else {\n            vault = s.bridge[bridge].vault;\n        }\n\n        vault.addZeth(zethAmount);\n        maybeUpdateYield(vault, zethAmount);\n        emit Events.Deposit(bridge, msg.sender, zethAmount);\n    }\n\n    function depositEth(address bridge)\n        external\n        payable\n        nonReentrant\n        onlyValidBridge(bridge)\n    {\n        if (msg.value < Constants.MIN_DEPOSIT) revert Errors.UnderMinimumDeposit();\n\n        uint256 vault;\n        if (bridge == rethBridge || bridge == stethBridge) {\n            vault = Vault.CARBON;\n        } else {\n            vault = s.bridge[bridge].vault;\n        }\n\n        uint88 zethAmount = uint88(IBridge(bridge).depositEth{value: msg.value}()); // Assumes 1 ETH = 1 ZETH\n        vault.addZeth(zethAmount);\n        maybeUpdateYield(vault, zethAmount);\n        emit Events.DepositEth(bridge, msg.sender, zethAmount);\n    }\n\n    function withdraw(address bridge, uint88 zethAmount)\n        external\n        nonReentrant\n        onlyValidBridge(bridge)\n    {\n        if (zethAmount == 0) revert Errors.ParameterIsZero();\n\n        uint88 fee;\n        uint256 withdrawalFee = bridge.withdrawalFee();\n        uint256 vault;\n        if (bridge == rethBridge || bridge == stethBridge) {\n            vault = Vault.CARBON;\n        } else {\n            vault = s.bridge[bridge].vault;\n        }\n\n        if (withdrawalFee > 0) {\n            fee = zethAmount.mulU88(withdrawalFee);\n            zethAmount -= fee;\n            s.vaultUser[vault][address(this)].ethEscrowed += fee;\n        }\n\n        uint88 ethAmount = _ethConversion(vault, zethAmount);\n        vault.removeZeth(zethAmount, fee);\n        IBridge(bridge).withdraw(msg.sender, ethAmount);\n        emit Events.Withdraw(bridge, msg.sender, zethAmount, fee);\n    }\n\n    function unstakeEth(address bridge, uint88 zethAmount)\n        external\n        nonReentrant\n        onlyValidBridge(bridge)\n    {\n        if (zethAmount == 0) revert Errors.ParameterIsZero();\n\n        uint88 fee = zethAmount.mulU88(bridge.unstakeFee());\n\n        uint256 vault;\n        if (bridge == rethBridge || bridge == stethBridge) {\n            vault = Vault.CARBON;\n        } else {\n            vault = s.bridge[bridge].vault;\n        }\n\n        if (fee > 0) {\n            zethAmount -= fee;\n            s.vaultUser[vault][address(this)].ethEscrowed += fee;\n        }\n        uint88 ethAmount = _ethConversion(vault, zethAmount);\n        vault.removeZeth(zethAmount, fee);\n        IBridge(bridge).unstake(msg.sender, ethAmount);\n        emit Events.UnstakeEth(bridge, msg.sender, zethAmount, fee);\n    }\n\n    function withdrawTapp(address bridge, uint88 zethAmount)\n        external\n        onlyDAO\n        onlyValidBridge(bridge)\n    {\n        if (zethAmount == 0) revert Errors.ParameterIsZero();\n\n        uint256 vault;\n        if (bridge == rethBridge || bridge == stethBridge) {\n            vault = Vault.CARBON;\n        } else {\n            vault = s.bridge[bridge].vault;\n        }\n        uint88 ethAmount = _ethConversion(vault, zethAmount);\n\n        s.vaultUser[vault][address(this)].ethEscrowed -= zethAmount;\n        s.vault[vault].zethTotal -= zethAmount;\n\n        IBridge(bridge).withdraw(msg.sender, ethAmount);\n        emit Events.WithdrawTapp(bridge, msg.sender, zethAmount);\n    }\n\n    function maybeUpdateYield(uint256 vault, uint88 amount) private {\n        uint88 zethTotal = s.vault[vault].zethTotal;\n        if (\n            zethTotal > Constants.BRIDGE_YIELD_UPDATE_THRESHOLD\n                && amount.div(zethTotal) > Constants.BRIDGE_YIELD_PERCENT_THRESHOLD\n        ) {\n            // Update yield for \"large\" bridge deposits\n            vault.updateYield();\n        }\n    }\n\n    function _ethConversion(uint256 vault, uint88 amount) private view returns (uint88) {\n        uint256 zethTotalNew = vault.getZethTotal();\n        uint88 zethTotal = s.vault[vault].zethTotal;\n\n        if (zethTotalNew >= zethTotal) {\n            // when yield is positive 1 zeth = 1 eth\n            return amount;\n        } else {\n            // negative yield means 1 zeth < 1 eth\n            return amount.mulU88(zethTotalNew).divU88(zethTotal);\n        }\n    }\n}"
    }
  ]
}