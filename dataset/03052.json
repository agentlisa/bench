{
  "Title": "weightedAverage calculation might overflow",
  "Content": "In the [`MathEx`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/utility/MathEx.sol) library the function [`weightedAverage`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/utility/MathEx.sol#L123) performs a multiplication of up to three `uint256` input variables without any prior validation. As the resulting number can have up to `768` bits, it is very likely to lead to an overflow during `uint256`-multiplication.\n\n\nCurrently, the function `weightedAverage` is only used in the [`_calcAverageRate`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/pools/PoolCollection.sol#L1611) function in the `PoolCollection` contract. Further, the `_calcAverageRate` function is currently used in a way that ensures a maximum size of `128`, `112` and `3` bits for the three operands passed to `weightedAverage`.\n\n\nWhile the current usage of `weightedAverage` within the codebase appears to be safe from `uint256` overflows, consider adding input validation to `weightedAverage` and including explicit preconditions in the function documentation to ensure that future versions of the codebase remain free from overflows.\n\n\n**Update:** *Acknowledged without code changes. In an effort to keep library functions lean, the client generally prefers panics over explicit error messages. Note that the function documentation continues to omit any description about preconditions.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/pools/PoolCollection.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { Token } from \"../token/Token.sol\";\nimport { TokenLibrary } from \"../token/TokenLibrary.sol\";\n\nimport { IMasterVault } from \"../vaults/interfaces/IMasterVault.sol\";\nimport { IExternalProtectionVault } from \"../vaults/interfaces/IExternalProtectionVault.sol\";\n\nimport { IVersioned } from \"../utility/interfaces/IVersioned.sol\";\n\nimport { PPM_RESOLUTION } from \"../utility/Constants.sol\";\nimport { Owned } from \"../utility/Owned.sol\";\nimport { BlockNumber } from \"../utility/BlockNumber.sol\";\nimport { Fraction, Fraction112, FractionLibrary, zeroFraction, zeroFraction112 } from \"../utility/FractionLibrary.sol\";\nimport { Sint256, MathEx } from \"../utility/MathEx.sol\";\n\n// prettier-ignore\nimport {\n    Utils,\n    AlreadyExists,\n    DoesNotExist,\n    InvalidParam,\n    InvalidPoolCollection,\n    InvalidStakedBalance\n} from \"../utility/Utils.sol\";\n\nimport { INetworkSettings, NotWhitelisted } from \"../network/interfaces/INetworkSettings.sol\";\nimport { IBancorNetwork } from \"../network/interfaces/IBancorNetwork.sol\";\n\nimport { IPoolToken } from \"./interfaces/IPoolToken.sol\";\nimport { IPoolTokenFactory } from \"./interfaces/IPoolTokenFactory.sol\";\nimport { IPoolMigrator } from \"./interfaces/IPoolMigrator.sol\";\n\n// prettier-ignore\nimport {\n    AverageRates,\n    IPoolCollection,\n    PoolLiquidity,\n    Pool,\n    TRADING_STATUS_UPDATE_DEFAULT,\n    TRADING_STATUS_UPDATE_ADMIN,\n    TRADING_STATUS_UPDATE_MIN_LIQUIDITY,\n    TradeAmountAndFee,\n    WithdrawalAmounts\n} from \"./interfaces/IPoolCollection.sol\";\n\nimport { IBNTPool } from \"./interfaces/IBNTPool.sol\";\n\nimport { PoolCollectionWithdrawal } from \"./PoolCollectionWithdrawal.sol\";\n\n// base token withdrawal output amounts\nstruct InternalWithdrawalAmounts {\n    uint256 baseTokensToTransferFromMasterVault; // base token amount to transfer from the master vault to the provider\n    uint256 bntToMintForProvider; // BNT amount to mint directly for the provider\n    uint256 baseTokensToTransferFromEPV; // base token amount to transfer from the external protection vault to the provider\n    Sint256 baseTokensTradingLiquidityDelta; // base token amount to add to the trading liquidity\n    Sint256 bntTradingLiquidityDelta; // BNT amount to add to the trading liquidity and to the master vault\n    Sint256 bntProtocolHoldingsDelta; // BNT amount add to the protocol equity\n    uint256 baseTokensWithdrawalFee; // base token amount to keep in the pool as a withdrawal fee\n    uint256 baseTokensWithdrawalAmount; // base token amount equivalent to the base pool token's withdrawal amount\n    uint256 poolTokenAmount; // base pool token\n    uint256 poolTokenTotalSupply; // base pool token's total supply\n    uint256 newBaseTokenTradingLiquidity; // new base token trading liquidity\n    uint256 newBNTTradingLiquidity; // new BNT trading liquidity\n}\n\nstruct TradingLiquidityAction {\n    bool update;\n    uint256 newAmount;\n}\n\nenum PoolRateState {\n    Uninitialized,\n    Unstable,\n    Stable\n}\n\n/**\n * @dev Pool Collection contract\n *\n * notes:\n *\n * - the address of reserve token serves as the pool unique ID in both contract functions and events\n */\ncontract PoolCollection is IPoolCollection, Owned, BlockNumber, Utils {\n    using TokenLibrary for Token;\n    using FractionLibrary for Fraction;\n    using FractionLibrary for Fraction112;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    error AlreadyEnabled();\n    error DepositingDisabled();\n    error InsufficientLiquidity();\n    error InsufficientSourceAmount();\n    error InsufficientTargetAmount();\n    error InvalidRate();\n    error RateUnstable();\n    error TradingDisabled();\n    error FundingLimitTooHigh();\n\n    uint16 private constant POOL_TYPE = 1;\n    uint256 private constant LIQUIDITY_GROWTH_FACTOR = 2;\n    uint256 private constant BOOTSTRAPPING_LIQUIDITY_BUFFER_FACTOR = 2;\n    uint32 private constant DEFAULT_TRADING_FEE_PPM = 2_000; // 0.2%\n    uint32 private constant RATE_MAX_DEVIATION_PPM = 10_000; // %1\n\n    // the average rate is recalculated based on the ratio between the weights of the rates the smaller the weights are,\n    // the larger the supported range of each one of the rates is\n    uint256 private constant EMA_AVERAGE_RATE_WEIGHT = 4;\n    uint256 private constant EMA_SPOT_RATE_WEIGHT = 1;\n\n    struct TradeIntermediateResult {\n        uint256 sourceAmount;\n        uint256 targetAmount;\n        uint256 limit;\n        uint256 tradingFeeAmount;\n        uint256 networkFeeAmount;\n        uint256 sourceBalance;\n        uint256 targetBalance;\n        uint256 stakedBalance;\n        Token pool;\n        bool isSourceBNT;\n        bool bySourceAmount;\n        uint32 tradingFeePPM;\n        bytes32 contextId;\n    }\n\n    struct TradeAmountAndTradingFee {\n        uint256 amount;\n        uint256 tradingFeeAmount;\n    }\n\n    // the network contract\n    IBancorNetwork private immutable _network;\n\n    // the address of the BNT token\n    IERC20 private immutable _bnt;\n\n    // the network settings contract\n    INetworkSettings private immutable _networkSettings;\n\n    // the master vault contract\n    IMasterVault private immutable _masterVault;\n\n    // the BNT pool contract\n    IBNTPool internal immutable _bntPool;\n\n    // the address of the external protection vault\n    IExternalProtectionVault private immutable _externalProtectionVault;\n\n    // the pool token factory contract\n    IPoolTokenFactory private immutable _poolTokenFactory;\n\n    // the pool migrator contract\n    IPoolMigrator private immutable _poolMigrator;\n\n    // a mapping between tokens and their pools\n    mapping(Token => Pool) internal _poolData;\n\n    // the set of all pools which are managed by this pool collection\n    EnumerableSet.AddressSet private _pools;\n\n    // the default trading fee (in units of PPM)\n    uint32 private _defaultTradingFeePPM;\n\n    /**\n     * @dev triggered when the default trading fee is updated\n     */\n    event DefaultTradingFeePPMUpdated(uint32 prevFeePPM, uint32 newFeePPM);\n\n    /**\n     * @dev triggered when a specific pool's trading fee is updated\n     */\n    event TradingFeePPMUpdated(Token indexed pool, uint32 prevFeePPM, uint32 newFeePPM);\n\n    /**\n     * @dev triggered when trading in a specific pool is enabled/disabled\n     */\n    event TradingEnabled(Token indexed pool, bool indexed newStatus, uint8 indexed reason);\n\n    /**\n     * @dev triggered when depositing into a specific pool is enabled/disabled\n     */\n    event DepositingEnabled(Token indexed pool, bool indexed newStatus);\n\n    /**\n     * @dev triggered when new liquidity is deposited into a pool\n     */\n    event TokensDeposited(\n        bytes32 indexed contextId,\n        address indexed provider,\n        Token indexed token,\n        uint256 tokenAmount,\n        uint256 poolTokenAmount\n    );\n\n    /**\n     * @dev triggered when existing liquidity is withdrawn from a pool\n     */\n    event TokensWithdrawn(\n        bytes32 indexed contextId,\n        address indexed provider,\n        Token indexed token,\n        uint256 tokenAmount,\n        uint256 poolTokenAmount,\n        uint256 externalProtectionBaseTokenAmount,\n        uint256 bntAmount,\n        uint256 withdrawalFeeAmount\n    );\n\n    /**\n     * @dev triggered when the trading liquidity in a pool is updated\n     */\n    event TradingLiquidityUpdated(\n        bytes32 indexed contextId,\n        Token indexed pool,\n        Token indexed token,\n        uint256 prevLiquidity,\n        uint256 newLiquidity\n    );\n\n    /**\n     * @dev triggered when the total liquidity in a pool is updated\n     */\n    event TotalLiquidityUpdated(\n        bytes32 indexed contextId,\n        Token indexed pool,\n        uint256 liquidity,\n        uint256 stakedBalance,\n        uint256 poolTokenSupply\n    );\n\n    /**\n     * @dev initializes a new PoolCollection contract\n     */\n    constructor(\n        IBancorNetwork initNetwork,\n        IERC20 initBNT,\n        INetworkSettings initNetworkSettings,\n        IMasterVault initMasterVault,\n        IBNTPool initBNTPool,\n        IExternalProtectionVault initExternalProtectionVault,\n        IPoolTokenFactory initPoolTokenFactory,\n        IPoolMigrator initPoolMigrator\n    )\n        validAddress(address(initNetwork))\n        validAddress(address(initBNT))\n        validAddress(address(initNetworkSettings))\n        validAddress(address(initMasterVault))\n        validAddress(address(initBNTPool))\n        validAddress(address(initExternalProtectionVault))\n        validAddress(address(initPoolTokenFactory))\n        validAddress(address(initPoolMigrator))\n    {\n        _network = initNetwork;\n        _bnt = initBNT;\n        _networkSettings = initNetworkSettings;\n        _masterVault = initMasterVault;\n        _bntPool = initBNTPool;\n        _externalProtectionVault = initExternalProtectionVault;\n        _poolTokenFactory = initPoolTokenFactory;\n        _poolMigrator = initPoolMigrator;\n\n        _setDefaultTradingFeePPM(DEFAULT_TRADING_FEE_PPM);\n    }\n\n    /**\n     * @inheritdoc IVersioned\n     */\n    function version() external view virtual returns (uint16) {\n        return 5;\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function poolType() external view virtual returns (uint16) {\n        return POOL_TYPE;\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function defaultTradingFeePPM() external view returns (uint32) {\n        return _defaultTradingFeePPM;\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function pools() external view returns (Token[] memory) {\n        uint256 length = _pools.length();\n        Token[] memory list = new Token[](length);\n        for (uint256 i = 0; i < length; i++) {\n            list[i] = Token(_pools.at(i));\n        }\n        return list;\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function poolCount() external view returns (uint256) {\n        return _pools.length();\n    }\n\n    /**\n     * @dev sets the default trading fee (in units of PPM)\n     *\n     * requirements:\n     *\n     * - the caller must be the owner of the contract\n     */\n    function setDefaultTradingFeePPM(uint32 newDefaultTradingFeePPM)\n        external\n        onlyOwner\n        validFee(newDefaultTradingFeePPM)\n    {\n        _setDefaultTradingFeePPM(newDefaultTradingFeePPM);\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function createPool(Token token) external only(address(_network)) {\n        if (!_networkSettings.isTokenWhitelisted(token)) {\n            revert NotWhitelisted();\n        }\n\n        IPoolToken newPoolToken = IPoolToken(_poolTokenFactory.createPoolToken(token));\n\n        newPoolToken.acceptOwnership();\n\n        Pool memory newPool = Pool({\n            poolToken: newPoolToken,\n            tradingFeePPM: _defaultTradingFeePPM,\n            tradingEnabled: false,\n            depositingEnabled: true,\n            averageRates: AverageRates({ blockNumber: 0, rate: zeroFraction112(), invRate: zeroFraction112() }),\n            liquidity: PoolLiquidity({ bntTradingLiquidity: 0, baseTokenTradingLiquidity: 0, stakedBalance: 0 })\n        });\n\n        _addPool(token, newPool);\n\n        emit TradingEnabled({ pool: token, newStatus: newPool.tradingEnabled, reason: TRADING_STATUS_UPDATE_DEFAULT });\n        emit TradingFeePPMUpdated({ pool: token, prevFeePPM: 0, newFeePPM: newPool.tradingFeePPM });\n        emit DepositingEnabled({ pool: token, newStatus: newPool.depositingEnabled });\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function isPoolValid(Token pool) external view returns (bool) {\n        return address(_poolData[pool].poolToken) != address(0);\n    }\n\n    /**\n     * @dev returns specific pool's data\n     *\n     * notes:\n     *\n     * - there is no guarantee that this function will remains forward compatible, so please avoid relying on it and\n     *   rely on specific getters from the IPoolCollection interface instead\n     */\n    function poolData(Token pool) external view returns (Pool memory) {\n        return _poolData[pool];\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function poolLiquidity(Token pool) external view returns (PoolLiquidity memory) {\n        return _poolData[pool].liquidity;\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function poolToken(Token pool) external view returns (IPoolToken) {\n        return _poolData[pool].poolToken;\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function tradingFeePPM(Token pool) external view returns (uint32) {\n        return _poolData[pool].tradingFeePPM;\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function tradingEnabled(Token pool) external view returns (bool) {\n        return _poolData[pool].tradingEnabled;\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function depositingEnabled(Token pool) external view returns (bool) {\n        return _poolData[pool].depositingEnabled;\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function poolTokenToUnderlying(Token pool, uint256 poolTokenAmount) external view returns (uint256) {\n        Pool storage data = _poolData[pool];\n\n        return _poolTokenToUnderlying(poolTokenAmount, data.poolToken.totalSupply(), data.liquidity.stakedBalance);\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function underlyingToPoolToken(Token pool, uint256 tokenAmount) external view returns (uint256) {\n        Pool storage data = _poolData[pool];\n\n        return _underlyingToPoolToken(tokenAmount, data.poolToken.totalSupply(), data.liquidity.stakedBalance);\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function poolTokenAmountToBurn(\n        Token pool,\n        uint256 tokenAmountToDistribute,\n        uint256 protocolPoolTokenAmount\n    ) external view returns (uint256) {\n        if (tokenAmountToDistribute == 0) {\n            return 0;\n        }\n\n        Pool storage data = _poolData[pool];\n\n        uint256 poolTokenSupply = data.poolToken.totalSupply();\n        uint256 val = tokenAmountToDistribute * poolTokenSupply;\n\n        return\n            MathEx.mulDivF(\n                val,\n                poolTokenSupply,\n                val + data.liquidity.stakedBalance * (poolTokenSupply - protocolPoolTokenAmount)\n            );\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function isPoolStable(Token pool) external view returns (bool) {\n        Pool storage data = _poolData[pool];\n\n        return _poolRateState(data.liquidity, data.averageRates) == PoolRateState.Stable;\n    }\n\n    /**\n     * @dev sets the trading fee of a given pool\n     *\n     * requirements:\n     *\n     * - the caller must be the owner of the contract\n     */\n    function setTradingFeePPM(Token pool, uint32 newTradingFeePPM) external onlyOwner validFee(newTradingFeePPM) {\n        Pool storage data = _poolStorage(pool);\n\n        uint32 prevTradingFeePPM = data.tradingFeePPM;\n        if (prevTradingFeePPM == newTradingFeePPM) {\n            return;\n        }\n\n        data.tradingFeePPM = newTradingFeePPM;\n\n        emit TradingFeePPMUpdated({ pool: pool, prevFeePPM: prevTradingFeePPM, newFeePPM: newTradingFeePPM });\n    }\n\n    /**\n     * @dev enables trading in a given pool, by providing the funding rate as two virtual balances, and updates its\n     * trading liquidity\n     *\n     * please note that the virtual balances should be derived from token prices, normalized to the smallest unit of\n     * tokens. For example:\n     *\n     * - if the price of one (10**18 wei) BNT is $X and the price of one (10**18 wei) TKN is $Y, then the virtual balances\n     *   should represent a ratio of X to Y\n     * - if the price of one (10**18 wei) BNT is $X and the price of one (10**6 wei) USDC is $Y, then the virtual balances\n     *   should represent a ratio of X to Y*10**12\n     *\n     * requirements:\n     *\n     * - the caller must be the owner of the contract\n     */\n    function enableTrading(\n        Token pool,\n        uint256 bntVirtualBalance,\n        uint256 baseTokenVirtualBalance\n    ) external onlyOwner {\n        Fraction memory fundingRate = Fraction({ n: bntVirtualBalance, d: baseTokenVirtualBalance });\n        _validRate(fundingRate);\n\n        Pool storage data = _poolStorage(pool);\n\n        if (data.tradingEnabled) {\n            revert AlreadyEnabled();\n        }\n\n        // adjust the trading liquidity based on the base token vault balance and funding limits\n        uint256 minLiquidityForTrading = _networkSettings.minLiquidityForTrading();\n        _updateTradingLiquidity(bytes32(0), pool, data, data.liquidity, fundingRate, minLiquidityForTrading);\n\n        // verify that the BNT trading liquidity is equal or greater than the minimum liquidity for trading\n        if (data.liquidity.bntTradingLiquidity < minLiquidityForTrading) {\n            revert InsufficientLiquidity();\n        }\n\n        Fraction112 memory fundingRate112 = fundingRate.toFraction112();\n        data.averageRates = AverageRates({\n            blockNumber: _blockNumber(),\n            rate: fundingRate112,\n            invRate: fundingRate112.inverse()\n        });\n\n        data.tradingEnabled = true;\n\n        emit TradingEnabled({ pool: pool, newStatus: true, reason: TRADING_STATUS_UPDATE_ADMIN });\n    }\n\n    /**\n     * @dev disables trading in a given pool\n     *\n     * requirements:\n     *\n     * - the caller must be the owner of the contract\n     */\n    function disableTrading(Token pool) external onlyOwner {\n        Pool storage data = _poolStorage(pool);\n\n        _resetTradingLiquidity(bytes32(0), pool, data, TRADING_STATUS_UPDATE_ADMIN);\n    }\n\n    /**\n     * @dev enables/disables depositing into a given pool\n     *\n     * requirements:\n     *\n     * - the caller must be the owner of the contract\n     */\n    function enableDepositing(Token pool, bool status) external onlyOwner {\n        Pool storage data = _poolStorage(pool);\n\n        if (data.depositingEnabled == status) {\n            return;\n        }\n\n        data.depositingEnabled = status;\n\n        emit DepositingEnabled({ pool: pool, newStatus: status });\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function depositFor(\n        bytes32 contextId,\n        address provider,\n        Token pool,\n        uint256 tokenAmount\n    ) external only(address(_network)) validAddress(provider) greaterThanZero(tokenAmount) returns (uint256) {\n        Pool storage data = _poolStorage(pool);\n\n        if (!data.depositingEnabled) {\n            revert DepositingDisabled();\n        }\n\n        // calculate the pool token amount to mint\n        uint256 currentStakedBalance = data.liquidity.stakedBalance;\n        uint256 prevPoolTokenTotalSupply = data.poolToken.totalSupply();\n        uint256 poolTokenAmount = _underlyingToPoolToken(tokenAmount, prevPoolTokenTotalSupply, currentStakedBalance);\n\n        PoolLiquidity memory prevLiquidity = data.liquidity;\n\n        // update the staked balance with the full base token amount\n        data.liquidity.stakedBalance = currentStakedBalance + tokenAmount;\n\n        // mint pool tokens to the provider\n        data.poolToken.mint(provider, poolTokenAmount);\n\n        // adjust the trading liquidity based on the base token vault balance and funding limits\n        _updateTradingLiquidity(\n            contextId,\n            pool,\n            data,\n            data.liquidity,\n            data.averageRates.rate.fromFraction112(),\n            _networkSettings.minLiquidityForTrading()\n        );\n\n        // if trading is enabled, then update the recent average rates\n        if (data.tradingEnabled) {\n            _updateAverageRates(\n                data,\n                Fraction({ n: data.liquidity.bntTradingLiquidity, d: data.liquidity.baseTokenTradingLiquidity })\n            );\n        }\n\n        emit TokensDeposited({\n            contextId: contextId,\n            provider: provider,\n            token: pool,\n            tokenAmount: tokenAmount,\n            poolTokenAmount: poolTokenAmount\n        });\n\n        _dispatchTradingLiquidityEvents(\n            contextId,\n            pool,\n            prevPoolTokenTotalSupply + poolTokenAmount,\n            prevLiquidity,\n            data.liquidity\n        );\n\n        return poolTokenAmount;\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function withdraw(\n        bytes32 contextId,\n        address provider,\n        Token pool,\n        uint256 poolTokenAmount,\n        uint256 baseTokenAmount\n    )\n        external\n        only(address(_network))\n        validAddress(provider)\n        greaterThanZero(poolTokenAmount)\n        greaterThanZero(baseTokenAmount)\n        returns (uint256)\n    {\n        Pool storage data = _poolStorage(pool);\n        PoolLiquidity memory liquidity = data.liquidity;\n\n        uint256 poolTokenTotalSupply = data.poolToken.totalSupply();\n        uint256 underlyingAmount = _poolTokenToUnderlying(\n            poolTokenAmount,\n            poolTokenTotalSupply,\n            liquidity.stakedBalance\n        );\n\n        if (baseTokenAmount > underlyingAmount) {\n            revert InvalidParam();\n        }\n\n        // obtain the withdrawal amounts\n        InternalWithdrawalAmounts memory amounts = _poolWithdrawalAmounts(\n            pool,\n            poolTokenAmount,\n            baseTokenAmount,\n            liquidity,\n            data.tradingFeePPM,\n            poolTokenTotalSupply\n        );\n\n        // execute the actual withdrawal\n        _executeWithdrawal(contextId, provider, pool, data, amounts);\n\n        // if trading is enabled, then update the recent average rates\n        if (data.tradingEnabled) {\n            _updateAverageRates(\n                data,\n                Fraction({ n: data.liquidity.bntTradingLiquidity, d: data.liquidity.baseTokenTradingLiquidity })\n            );\n        }\n\n        return amounts.baseTokensToTransferFromMasterVault;\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function withdrawalAmounts(Token pool, uint256 poolTokenAmount)\n        external\n        view\n        validAddress(address(pool))\n        greaterThanZero(poolTokenAmount)\n        returns (WithdrawalAmounts memory)\n    {\n        Pool storage data = _poolData[pool];\n        PoolLiquidity memory liquidity = data.liquidity;\n\n        uint256 poolTokenTotalSupply = data.poolToken.totalSupply();\n        uint256 underlyingAmount = _poolTokenToUnderlying(\n            poolTokenAmount,\n            poolTokenTotalSupply,\n            liquidity.stakedBalance\n        );\n\n        InternalWithdrawalAmounts memory amounts = _poolWithdrawalAmounts(\n            pool,\n            poolTokenAmount,\n            underlyingAmount,\n            liquidity,\n            data.tradingFeePPM,\n            poolTokenTotalSupply\n        );\n\n        return\n            WithdrawalAmounts({\n                totalAmount: amounts.baseTokensWithdrawalAmount - amounts.baseTokensWithdrawalFee,\n                baseTokenAmount: amounts.baseTokensToTransferFromMasterVault + amounts.baseTokensToTransferFromEPV,\n                bntAmount: amounts.bntToMintForProvider\n            });\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function tradeBySourceAmount(\n        bytes32 contextId,\n        Token sourceToken,\n        Token targetToken,\n        uint256 sourceAmount,\n        uint256 minReturnAmount\n    )\n        external\n        only(address(_network))\n        greaterThanZero(sourceAmount)\n        greaterThanZero(minReturnAmount)\n        returns (TradeAmountAndFee memory)\n    {\n        TradeIntermediateResult memory result = _initTrade(\n            contextId,\n            sourceToken,\n            targetToken,\n            sourceAmount,\n            minReturnAmount,\n            true\n        );\n\n        _performTrade(result);\n\n        return\n            TradeAmountAndFee({\n                amount: result.targetAmount,\n                tradingFeeAmount: result.tradingFeeAmount,\n                networkFeeAmount: result.networkFeeAmount\n            });\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function tradeByTargetAmount(\n        bytes32 contextId,\n        Token sourceToken,\n        Token targetToken,\n        uint256 targetAmount,\n        uint256 maxSourceAmount\n    )\n        external\n        only(address(_network))\n        greaterThanZero(targetAmount)\n        greaterThanZero(maxSourceAmount)\n        returns (TradeAmountAndFee memory)\n    {\n        TradeIntermediateResult memory result = _initTrade(\n            contextId,\n            sourceToken,\n            targetToken,\n            targetAmount,\n            maxSourceAmount,\n            false\n        );\n\n        _performTrade(result);\n\n        return\n            TradeAmountAndFee({\n                amount: result.sourceAmount,\n                tradingFeeAmount: result.tradingFeeAmount,\n                networkFeeAmount: result.networkFeeAmount\n            });\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function tradeOutputAndFeeBySourceAmount(\n        Token sourceToken,\n        Token targetToken,\n        uint256 sourceAmount\n    ) external view greaterThanZero(sourceAmount) returns (TradeAmountAndFee memory) {\n        TradeIntermediateResult memory result = _initTrade(bytes32(0), sourceToken, targetToken, sourceAmount, 1, true);\n\n        _processTrade(result);\n\n        return\n            TradeAmountAndFee({\n                amount: result.targetAmount,\n                tradingFeeAmount: result.tradingFeeAmount,\n                networkFeeAmount: result.networkFeeAmount\n            });\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function tradeInputAndFeeByTargetAmount(\n        Token sourceToken,\n        Token targetToken,\n        uint256 targetAmount\n    ) external view greaterThanZero(targetAmount) returns (TradeAmountAndFee memory) {\n        TradeIntermediateResult memory result = _initTrade(\n            bytes32(0),\n            sourceToken,\n            targetToken,\n            targetAmount,\n            type(uint256).max,\n            false\n        );\n\n        _processTrade(result);\n\n        return\n            TradeAmountAndFee({\n                amount: result.sourceAmount,\n                tradingFeeAmount: result.tradingFeeAmount,\n                networkFeeAmount: result.networkFeeAmount\n            });\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function onFeesCollected(Token pool, uint256 feeAmount) external only(address(_network)) {\n        if (feeAmount == 0) {\n            return;\n        }\n\n        Pool storage data = _poolStorage(pool);\n\n        // increase the staked balance by the given amount\n        data.liquidity.stakedBalance += feeAmount;\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function migratePoolIn(Token pool, Pool calldata data)\n        external\n        validAddress(address(pool))\n        only(address(_poolMigrator))\n    {\n        _addPool(pool, data);\n\n        data.poolToken.acceptOwnership();\n    }\n\n    /**\n     * @inheritdoc IPoolCollection\n     */\n    function migratePoolOut(Token pool, IPoolCollection targetPoolCollection)\n        external\n        validAddress(address(targetPoolCollection))\n        only(address(_poolMigrator))\n    {\n        IPoolToken cachedPoolToken = _poolData[pool].poolToken;\n\n        _removePool(pool);\n\n        cachedPoolToken.transferOwnership(address(targetPoolCollection));\n    }\n\n    /**\n     * @dev adds a pool\n     */\n    function _addPool(Token pool, Pool memory data) private {\n        if (!_pools.add(address(pool))) {\n            revert AlreadyExists();\n        }\n\n        _poolData[pool] = data;\n    }\n\n    /**\n     * @dev removes a pool\n     */\n    function _removePool(Token pool) private {\n        if (!_pools.remove(address(pool))) {\n            revert DoesNotExist();\n        }\n\n        delete _poolData[pool];\n    }\n\n    /**\n     * @dev returns withdrawal amounts\n     */\n    function _poolWithdrawalAmounts(\n        Token pool,\n        uint256 poolTokenAmount,\n        uint256 baseTokensWithdrawalAmount,\n        PoolLiquidity memory liquidity,\n        uint32 poolTradingFeePPM,\n        uint256 poolTokenTotalSupply\n    ) internal view returns (InternalWithdrawalAmounts memory) {\n        // the base token trading liquidity of a given pool can never be higher than the base token balance of the vault\n        // whenever the base token trading liquidity is updated, it is set to at most the base token balance of the vault\n        uint256 baseTokenExcessAmount = pool.balanceOf(address(_masterVault)) - liquidity.baseTokenTradingLiquidity;\n\n        PoolCollectionWithdrawal.Output memory output = PoolCollectionWithdrawal.calculateWithdrawalAmounts(\n            liquidity.bntTradingLiquidity,\n            liquidity.baseTokenTradingLiquidity,\n            baseTokenExcessAmount,\n            liquidity.stakedBalance,\n            pool.balanceOf(address(_externalProtectionVault)),\n            poolTradingFeePPM,\n            _networkSettings.withdrawalFeePPM(),\n            baseTokensWithdrawalAmount\n        );\n\n        return\n            InternalWithdrawalAmounts({\n                baseTokensToTransferFromMasterVault: output.s,\n                bntToMintForProvider: output.t,\n                baseTokensToTransferFromEPV: output.u,\n                baseTokensTradingLiquidityDelta: output.r,\n                bntTradingLiquidityDelta: output.p,\n                bntProtocolHoldingsDelta: output.q,\n                baseTokensWithdrawalFee: output.v,\n                baseTokensWithdrawalAmount: baseTokensWithdrawalAmount,\n                poolTokenAmount: poolTokenAmount,\n                poolTokenTotalSupply: poolTokenTotalSupply,\n                newBaseTokenTradingLiquidity: output.r.isNeg\n                    ? liquidity.baseTokenTradingLiquidity - output.r.value\n                    : liquidity.baseTokenTradingLiquidity + output.r.value,\n                newBNTTradingLiquidity: output.p.isNeg\n                    ? liquidity.bntTradingLiquidity - output.p.value\n                    : liquidity.bntTradingLiquidity + output.p.value\n            });\n    }\n\n    /**\n     * @dev executes the following actions:\n     *\n     * - burn the network's base pool tokens\n     * - update the pool's base token staked balance\n     * - update the pool's base token trading liquidity\n     * - update the pool's BNT trading liquidity\n     * - update the pool's trading liquidity product\n     * - emit an event if the pool's BNT trading liquidity has crossed the minimum threshold\n     *   (either above the threshold or below the threshold)\n     */\n    function _executeWithdrawal(\n        bytes32 contextId,\n        address provider,\n        Token pool,\n        Pool storage data,\n        InternalWithdrawalAmounts memory amounts\n    ) private {\n        PoolLiquidity storage liquidity = data.liquidity;\n        PoolLiquidity memory prevLiquidity = liquidity;\n        AverageRates memory averageRates = data.averageRates;\n\n        if (_poolRateState(prevLiquidity, averageRates) == PoolRateState.Unstable) {\n            revert RateUnstable();\n        }\n\n        data.poolToken.burn(amounts.poolTokenAmount);\n\n        uint256 newPoolTokenTotalSupply = amounts.poolTokenTotalSupply - amounts.poolTokenAmount;\n\n        liquidity.stakedBalance = MathEx.mulDivF(\n            liquidity.stakedBalance,\n            newPoolTokenTotalSupply,\n            amounts.poolTokenTotalSupply\n        );\n\n        // trading liquidity is assumed to never exceed 128 bits (the cast below will revert otherwise)\n        liquidity.baseTokenTradingLiquidity = SafeCast.toUint128(amounts.newBaseTokenTradingLiquidity);\n        liquidity.bntTradingLiquidity = SafeCast.toUint128(amounts.newBNTTradingLiquidity);\n\n        if (amounts.bntProtocolHoldingsDelta.value > 0) {\n            assert(amounts.bntProtocolHoldingsDelta.isNeg); // currently no support for requesting funding here\n\n            _bntPool.renounceFunding(contextId, pool, amounts.bntProtocolHoldingsDelta.value);\n        } else if (amounts.bntTradingLiquidityDelta.value > 0) {\n            if (amounts.bntTradingLiquidityDelta.isNeg) {\n                _bntPool.burnFromVault(amounts.bntTradingLiquidityDelta.value);\n            } else {\n                _bntPool.mint(address(_masterVault), amounts.bntTradingLiquidityDelta.value);\n            }\n        }\n\n        // if the provider should receive some BNT - ask the BNT pool to mint BNT to the provider\n        if (amounts.bntToMintForProvider > 0) {\n            _bntPool.mint(address(provider), amounts.bntToM"
    }
  ]
}