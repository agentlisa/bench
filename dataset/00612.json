{
  "Title": "Incomplete Table Validation",
  "Content": "There are [several consistency checks](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/store/src/StoreCore.sol#L187-L192) when registering a new table, but they are incomplete. In particular:\n\n\n* The [field layout validation](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/store/src/FieldLayout.sol#L150) does not confirm whether the [total static field length](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/store/src/FieldLayout.sol#L10) is the sum of all the individual static field lengths, or that the unused length fields (if the [maximum number of fields](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/store/src/constants.sol#L21) is not reached) are all zero.\n* The [schema validations](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/store/src/Schema.sol#L158) for the key and value schemas do not confirm whether the [total static field length](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/store/src/Schema.sol#L11) is consistent with the static schema types.\n* The field layout and value schema are not confirmed to be consistent with each other, except for [having the same total number of fields](https://github.com/latticexyz/mud/blob/12a9eb1afb18a7f7cb43d774cabb2d5af7c74e6b/packages/store/src/StoreCore.sol#L205). This means that the number of static fields is not necessarily the same, and the length of a static field in the field layout does not necessarily match the type of the static field in the value schema.\n\n\nInconsistent table specifications may interfere with saving, retrieving and interpreting the database records. Consider including these additional validations.\n\n\n***Update:** Resolved in [pull request #2046](https://github.com/latticexyz/mud/pull/2046).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/store/src/StoreCore.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\nimport { STORE_VERSION } from \"./version.sol\";\nimport { Bytes } from \"./Bytes.sol\";\nimport { Storage } from \"./Storage.sol\";\nimport { Memory } from \"./Memory.sol\";\nimport { FieldLayout, FieldLayoutLib } from \"./FieldLayout.sol\";\nimport { Schema, SchemaLib } from \"./Schema.sol\";\nimport { PackedCounter } from \"./PackedCounter.sol\";\nimport { Slice, SliceLib } from \"./Slice.sol\";\nimport { StoreHooks, Tables, TablesTableId, ResourceIds, StoreHooksTableId } from \"./codegen/index.sol\";\nimport { _fieldLayout as TablesTableFieldLayout } from \"./codegen/tables/Tables.sol\";\nimport { IStoreErrors } from \"./IStoreErrors.sol\";\nimport { IStoreHook } from \"./IStoreHook.sol\";\nimport { StoreSwitch } from \"./StoreSwitch.sol\";\nimport { Hook, HookLib } from \"./Hook.sol\";\nimport { BEFORE_SET_RECORD, AFTER_SET_RECORD, BEFORE_SPLICE_STATIC_DATA, AFTER_SPLICE_STATIC_DATA, BEFORE_SPLICE_DYNAMIC_DATA, AFTER_SPLICE_DYNAMIC_DATA, BEFORE_DELETE_RECORD, AFTER_DELETE_RECORD } from \"./storeHookTypes.sol\";\nimport { ResourceId, ResourceIdInstance } from \"./ResourceId.sol\";\nimport { RESOURCE_TABLE, RESOURCE_OFFCHAIN_TABLE } from \"./storeResourceTypes.sol\";\n\n/**\n * @title StoreCore Library\n * @notice This library includes implementations for all IStore methods and events related to the store actions.\n */\nlibrary StoreCore {\n  using ResourceIdInstance for ResourceId;\n  /**\n   * @notice Emitted when a new record is set in the store.\n   * @param tableId The ID of the table where the record is set.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param staticData The static data of the record.\n   * @param encodedLengths The encoded lengths of the dynamic data of the record.\n   * @param dynamicData The dynamic data of the record.\n   */\n  event Store_SetRecord(\n    ResourceId indexed tableId,\n    bytes32[] keyTuple,\n    bytes staticData,\n    PackedCounter encodedLengths,\n    bytes dynamicData\n  );\n\n  /**\n   * @notice Emitted when static data in the store is spliced.\n   * @dev In static data, data is always overwritten starting at the start position,\n   * so the total length of the data remains the same and no data is shifted.\n   * @param tableId The ID of the table where the data is spliced.\n   * @param keyTuple An array representing the key for the record.\n   * @param start The start position in bytes for the splice operation.\n   * @param data The data to write to the static data of the record at the start byte.\n   */\n  event Store_SpliceStaticData(ResourceId indexed tableId, bytes32[] keyTuple, uint48 start, bytes data);\n\n  /**\n   * @notice Emitted when dynamic data in the store is spliced.\n   * @param tableId The ID of the table where the data is spliced.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param start The start position in bytes for the splice operation.\n   * @param deleteCount The number of bytes to delete in the splice operation.\n   * @param encodedLengths The encoded lengths of the dynamic data of the record.\n   * @param data The data to insert into the dynamic data of the record at the start byte.\n   */\n  event Store_SpliceDynamicData(\n    ResourceId indexed tableId,\n    bytes32[] keyTuple,\n    uint48 start,\n    uint40 deleteCount,\n    PackedCounter encodedLengths,\n    bytes data\n  );\n\n  /**\n   * @notice Emitted when a record is deleted from the store.\n   * @param tableId The ID of the table where the record is deleted.\n   * @param keyTuple An array representing the composite key for the record.\n   */\n  event Store_DeleteRecord(ResourceId indexed tableId, bytes32[] keyTuple);\n\n  /**\n   * @notice Initialize the store address in StoreSwitch.\n   * @dev Consumers must call this function in their constructor.\n   * StoreSwitch uses the storeAddress to decide where to write data to.\n   * If StoreSwitch is called in the context of a Store contract (storeAddress == address(this)),\n   * StoreSwitch uses internal methods to write data instead of external calls.\n   */\n  function initialize() internal {\n    StoreSwitch.setStoreAddress(address(this));\n  }\n\n  /**\n   * @notice Register core tables in the store.\n   * @dev Consumers must call this function in their constructor before setting\n   * any table data to allow indexers to decode table events.\n   */\n  function registerCoreTables() internal {\n    // Register core tables\n    Tables.register();\n    StoreHooks.register();\n    ResourceIds.register();\n  }\n\n  /************************************************************************\n   *\n   *    SCHEMA\n   *\n   ************************************************************************/\n\n  /**\n   * @notice Get the field layout for the given table ID.\n   * @param tableId The ID of the table for which to get the field layout.\n   * @return The field layout for the given table ID.\n   */\n  function getFieldLayout(ResourceId tableId) internal view returns (FieldLayout) {\n    // Explicit check for the Tables table to solve the bootstraping issue\n    // of the Tables table not having a field layout before it is registered\n    // since the field layout is stored in the Tables table.\n    if (ResourceId.unwrap(tableId) == ResourceId.unwrap(TablesTableId)) {\n      return TablesTableFieldLayout;\n    }\n    return\n      FieldLayout.wrap(\n        Storage.loadField({\n          storagePointer: StoreCoreInternal._getStaticDataLocation(TablesTableId, ResourceId.unwrap(tableId)),\n          length: 32,\n          offset: 0\n        })\n      );\n  }\n\n  /**\n   * @notice Get the key schema for the given table ID.\n   * @dev Reverts if the table ID is not registered.\n   * @param tableId The ID of the table for which to get the key schema.\n   * @return keySchema The key schema for the given table ID.\n   */\n  function getKeySchema(ResourceId tableId) internal view returns (Schema keySchema) {\n    keySchema = Tables._getKeySchema(tableId);\n    // key schemas can be empty for singleton tables, so we can't depend on key schema for table check\n    if (!ResourceIds._getExists(tableId)) {\n      revert IStoreErrors.Store_TableNotFound(tableId, string(abi.encodePacked(tableId)));\n    }\n  }\n\n  /**\n   * @notice Get the value schema for the given table ID.\n   * @dev Reverts if the table ID is not registered.\n   * @param tableId The ID of the table for which to get the value schema.\n   * @return valueSchema The value schema for the given table ID.\n   */\n  function getValueSchema(ResourceId tableId) internal view returns (Schema valueSchema) {\n    valueSchema = Tables._getValueSchema(tableId);\n    if (valueSchema.isEmpty()) {\n      revert IStoreErrors.Store_TableNotFound(tableId, string(abi.encodePacked(tableId)));\n    }\n  }\n\n  /**\n   * @notice Register a new table with the given configuration.\n   * @dev This method reverts if\n   * - The table ID is not of type RESOURCE_TABLE or RESOURCE_OFFCHAIN_TABLE.\n   * - The field layout is invalid.\n   * - The key schema is invalid.\n   * - The value schema is invalid.\n   * - The number of key names does not match the number of key schema types.\n   * - The number of field names does not match the number of field layout fields.\n   * @param tableId The ID of the table to register.\n   * @param fieldLayout The field layout of the table.\n   * @param keySchema The key schema of the table.\n   * @param valueSchema The value schema of the table.\n   * @param keyNames The names of the keys in the table.\n   * @param fieldNames The names of the fields in the table.\n   */\n  function registerTable(\n    ResourceId tableId,\n    FieldLayout fieldLayout,\n    Schema keySchema,\n    Schema valueSchema,\n    string[] memory keyNames,\n    string[] memory fieldNames\n  ) internal {\n    // Verify the table ID is of type RESOURCE_TABLE\n    if (tableId.getType() != RESOURCE_TABLE && tableId.getType() != RESOURCE_OFFCHAIN_TABLE) {\n      revert IStoreErrors.Store_InvalidResourceType(RESOURCE_TABLE, tableId, string(abi.encodePacked(tableId)));\n    }\n\n    // Verify the field layout is valid\n    fieldLayout.validate({ allowEmpty: false });\n\n    // Verify the schema is valid\n    keySchema.validate({ allowEmpty: true });\n    valueSchema.validate({ allowEmpty: false });\n\n    // Verify the number of key names matches the number of key schema types\n    if (keyNames.length != keySchema.numFields()) {\n      revert IStoreErrors.Store_InvalidKeyNamesLength(keySchema.numFields(), keyNames.length);\n    }\n\n    // Verify the number of value names\n    if (fieldNames.length != fieldLayout.numFields()) {\n      revert IStoreErrors.Store_InvalidFieldNamesLength(fieldLayout.numFields(), fieldNames.length);\n    }\n\n    // Verify the number of value schema types\n    if (valueSchema.numFields() != fieldLayout.numFields()) {\n      revert IStoreErrors.Store_InvalidValueSchemaLength(fieldLayout.numFields(), valueSchema.numFields());\n    }\n\n    // Verify there is no resource with this ID yet\n    if (ResourceIds._getExists(tableId)) {\n      revert IStoreErrors.Store_TableAlreadyExists(tableId, string(abi.encodePacked(tableId)));\n    }\n\n    // Register the table metadata\n    Tables._set(tableId, fieldLayout, keySchema, valueSchema, abi.encode(keyNames), abi.encode(fieldNames));\n\n    // Register the table ID\n    ResourceIds._setExists(tableId, true);\n  }\n\n  /************************************************************************\n   *\n   *    REGISTER HOOKS\n   *\n   ************************************************************************/\n\n  /**\n   * @notice Register hooks to be called when a record or field is set or deleted.\n   * @dev This method reverts for all resource IDs other than tables.\n   * Hooks are not supported for offchain tables.\n   * @param tableId The ID of the table to register the hook for.\n   * @param hookAddress The address of the hook contract to register.\n   * @param enabledHooksBitmap The bitmap of enabled hooks.\n   */\n  function registerStoreHook(ResourceId tableId, IStoreHook hookAddress, uint8 enabledHooksBitmap) internal {\n    // Hooks are only supported for tables, not for offchain tables\n    if (tableId.getType() != RESOURCE_TABLE) {\n      revert IStoreErrors.Store_InvalidResourceType(RESOURCE_TABLE, tableId, string(abi.encodePacked(tableId)));\n    }\n\n    StoreHooks.push(tableId, Hook.unwrap(HookLib.encode(address(hookAddress), enabledHooksBitmap)));\n  }\n\n  /**\n   * @notice Unregister a hook from the given table ID.\n   * @param tableId The ID of the table to unregister the hook from.\n   * @param hookAddress The address of the hook to unregister.\n   */\n  function unregisterStoreHook(ResourceId tableId, IStoreHook hookAddress) internal {\n    HookLib.filterListByAddress(StoreHooksTableId, tableId, address(hookAddress));\n  }\n\n  /************************************************************************\n   *\n   *    SET DATA\n   *\n   ************************************************************************/\n\n  /**\n   * @notice Set a full record for the given table ID and key tuple.\n   * @dev Calling this method emits a Store_SetRecord event.\n   * This method internally calls another overload of setRecord by fetching the field layout for the given table ID.\n   * If the field layout is available to the caller, it is recommended to use the other overload to avoid an additional storage read.\n   * @param tableId The ID of the table to set the record for.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param staticData The static data of the record.\n   * @param encodedLengths The encoded lengths of the dynamic data of the record.\n   * @param dynamicData The dynamic data of the record.\n   */\n  function setRecord(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    bytes memory staticData,\n    PackedCounter encodedLengths,\n    bytes memory dynamicData\n  ) internal {\n    setRecord(tableId, keyTuple, staticData, encodedLengths, dynamicData, getFieldLayout(tableId));\n  }\n\n  /**\n   * @notice Set a full data record for the given table ID, key tuple, and field layout.\n   * @dev For onchain tables, the method emits a `Store_SetRecord` event, updates the data in storage,\n   * calls `onBeforeSetRecord` hooks before actually modifying the state, and calls `onAfterSetRecord`\n   * hooks after modifying the state. For offchain tables, the method returns early after emitting the\n   * event without calling hooks or modifying the state.\n   * @param tableId The ID of the table to set the record for.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param staticData The static data of the record.\n   * @param encodedLengths The encoded lengths of the dynamic data of the record.\n   * @param dynamicData The dynamic data of the record.\n   * @param fieldLayout The field layout for the record.\n   */\n  function setRecord(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    bytes memory staticData,\n    PackedCounter encodedLengths,\n    bytes memory dynamicData,\n    FieldLayout fieldLayout\n  ) internal {\n    // Emit event to notify indexers\n    emit Store_SetRecord(tableId, keyTuple, staticData, encodedLengths, dynamicData);\n\n    // Early return if the table is an offchain table\n    if (tableId.getType() != RESOURCE_TABLE) {\n      return;\n    }\n\n    // Call onBeforeSetRecord hooks (before actually modifying the state, so observers have access to the previous state if needed)\n    bytes21[] memory hooks = StoreHooks._get(tableId);\n    for (uint256 i; i < hooks.length; i++) {\n      Hook hook = Hook.wrap(hooks[i]);\n      if (hook.isEnabled(BEFORE_SET_RECORD)) {\n        IStoreHook(hook.getAddress()).onBeforeSetRecord(\n          tableId,\n          keyTuple,\n          staticData,\n          encodedLengths,\n          dynamicData,\n          fieldLayout\n        );\n      }\n    }\n\n    // Store the static data at the static data location\n    uint256 staticDataLocation = StoreCoreInternal._getStaticDataLocation(tableId, keyTuple);\n    uint256 memoryPointer = Memory.dataPointer(staticData);\n    Storage.store({\n      storagePointer: staticDataLocation,\n      offset: 0,\n      memoryPointer: memoryPointer,\n      length: staticData.length\n    });\n\n    // Set the dynamic data if there are dynamic fields\n    if (fieldLayout.numDynamicFields() > 0) {\n      // Store the dynamic data length at the dynamic data length location\n      uint256 dynamicDataLengthLocation = StoreCoreInternal._getDynamicDataLengthLocation(tableId, keyTuple);\n      Storage.store({ storagePointer: dynamicDataLengthLocation, data: encodedLengths.unwrap() });\n\n      // Move the memory pointer to the start of the dynamic data\n      memoryPointer = Memory.dataPointer(dynamicData);\n\n      // For every dynamic element, slice off the dynamic data and store it at the dynamic location\n      uint256 dynamicDataLocation;\n      uint256 dynamicDataLength;\n      for (uint8 i; i < fieldLayout.numDynamicFields(); ) {\n        dynamicDataLocation = StoreCoreInternal._getDynamicDataLocation(tableId, keyTuple, i);\n        dynamicDataLength = encodedLengths.atIndex(i);\n        Storage.store({\n          storagePointer: dynamicDataLocation,\n          offset: 0,\n          memoryPointer: memoryPointer,\n          length: dynamicDataLength\n        });\n        memoryPointer += dynamicDataLength; // move the memory pointer to the start of the next dynamic data\n        unchecked {\n          i++;\n        }\n      }\n    }\n\n    // Call onAfterSetRecord hooks (after modifying the state)\n    for (uint256 i; i < hooks.length; i++) {\n      Hook hook = Hook.wrap(hooks[i]);\n      if (hook.isEnabled(AFTER_SET_RECORD)) {\n        IStoreHook(hook.getAddress()).onAfterSetRecord(\n          tableId,\n          keyTuple,\n          staticData,\n          encodedLengths,\n          dynamicData,\n          fieldLayout\n        );\n      }\n    }\n  }\n\n  /**\n   * @notice Splice the static data for the given table ID and key tuple.\n   * @dev This method emits a `Store_SpliceStaticData` event, updates the data in storage, and calls\n   * `onBeforeSpliceStaticData` and `onAfterSpliceStaticData` hooks.\n   * For offchain tables, it returns early after emitting the event.\n   * @param tableId The ID of the table to splice the static data for.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param start The start position in bytes for the splice operation.\n   * @param data The data to write to the static data of the record at the start byte.\n   */\n  function spliceStaticData(ResourceId tableId, bytes32[] memory keyTuple, uint48 start, bytes memory data) internal {\n    uint256 location = StoreCoreInternal._getStaticDataLocation(tableId, keyTuple);\n\n    // Emit event to notify offchain indexers\n    emit StoreCore.Store_SpliceStaticData({ tableId: tableId, keyTuple: keyTuple, start: start, data: data });\n\n    // Early return if the table is an offchain table\n    if (tableId.getType() != RESOURCE_TABLE) {\n      return;\n    }\n\n    // Call onBeforeSpliceStaticData hooks (before actually modifying the state, so observers have access to the previous state if needed)\n    bytes21[] memory hooks = StoreHooks._get(tableId);\n    for (uint256 i; i < hooks.length; i++) {\n      Hook hook = Hook.wrap(hooks[i]);\n      if (hook.isEnabled(BEFORE_SPLICE_STATIC_DATA)) {\n        IStoreHook(hook.getAddress()).onBeforeSpliceStaticData({\n          tableId: tableId,\n          keyTuple: keyTuple,\n          start: start,\n          data: data\n        });\n      }\n    }\n\n    // Store the provided value in storage\n    Storage.store({ storagePointer: location, offset: start, data: data });\n\n    // Call onAfterSpliceStaticData hooks\n    for (uint256 i; i < hooks.length; i++) {\n      Hook hook = Hook.wrap(hooks[i]);\n      if (hook.isEnabled(AFTER_SPLICE_STATIC_DATA)) {\n        IStoreHook(hook.getAddress()).onAfterSpliceStaticData({\n          tableId: tableId,\n          keyTuple: keyTuple,\n          start: start,\n          data: data\n        });\n      }\n    }\n  }\n\n  /**\n   * @notice Splice the dynamic data for the given table ID, key tuple, and dynamic field index.\n   * @dev This method emits a `Store_SpliceDynamicData` event, updates the data in storage, and calls\n   * `onBeforeSpliceDynamicData` and `onAfterSpliceDynamicData` hooks.\n   * For offchain tables, it returns early after emitting the event.\n   * @param tableId The ID of the table to splice the dynamic data for.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param dynamicFieldIndex The index of the dynamic field to splice. (Dynamic field index = field index - number of static fields)\n   * @param startWithinField The start position within the field for the splice operation.\n   * @param deleteCount The number of bytes to delete in the splice operation.\n   * @param data The data to insert into the dynamic data of the record at the start byte.\n   */\n  function spliceDynamicData(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    uint40 startWithinField,\n    uint40 deleteCount,\n    bytes memory data\n  ) internal {\n    StoreCoreInternal._spliceDynamicData({\n      tableId: tableId,\n      keyTuple: keyTuple,\n      dynamicFieldIndex: dynamicFieldIndex,\n      startWithinField: startWithinField,\n      deleteCount: deleteCount,\n      data: data,\n      previousEncodedLengths: StoreCoreInternal._loadEncodedDynamicDataLength(tableId, keyTuple)\n    });\n  }\n\n  /**\n   * @notice Set data for a field at the given index in a table with the given tableId, key tuple, and value field layout.\n   * @dev This method internally calls another overload of setField by fetching the field layout for the given table ID.\n   * If the field layout is available to the caller, it is recommended to use the other overload to avoid an additional storage read.\n   * This function emits a `Store_SpliceStaticData` or `Store_SpliceDynamicData` event and calls the corresponding hooks.\n   * For offchain tables, it returns early after emitting the event.\n   * @param tableId The ID of the table to set the field for.\n   * @param keyTuple An array representing the key for the record.\n   * @param fieldIndex The index of the field to set.\n   * @param data The data to set for the field.\n   */\n  function setField(ResourceId tableId, bytes32[] memory keyTuple, uint8 fieldIndex, bytes memory data) internal {\n    setField(tableId, keyTuple, fieldIndex, data, getFieldLayout(tableId));\n  }\n\n  /**\n   * @notice Set data for a field at the given index in a table with the given tableId, key tuple, and value field layout.\n   * @dev This method internally calls to `setStaticField` or `setDynamicField` based on the field index and layout.\n   * Calling `setStaticField` or `setDynamicField` directly is recommended if the caller is aware of the field layout.\n   * This function emits a `Store_SpliceStaticData` or `Store_SpliceDynamicData` event, updates the data in storage,\n   * and calls the corresponding hooks.\n   * For offchain tables, it returns early after emitting the event.\n   * @param tableId The ID of the table to set the field for.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param fieldIndex The index of the field to set.\n   * @param data The data to set for the field.\n   * @param fieldLayout The field layout for the record.\n   */\n  function setField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex,\n    bytes memory data,\n    FieldLayout fieldLayout\n  ) internal {\n    if (fieldIndex < fieldLayout.numStaticFields()) {\n      setStaticField(tableId, keyTuple, fieldIndex, data, fieldLayout);\n    } else {\n      setDynamicField(tableId, keyTuple, fieldIndex - uint8(fieldLayout.numStaticFields()), data);\n    }\n  }\n\n  /**\n   * @notice Set a static field for the given table ID, key tuple, field index, and field layout.\n   * @dev This method emits a `Store_SpliceStaticData` event, updates the data in storage and calls the\n   * `onBeforeSpliceStaticData` and `onAfterSpliceStaticData` hooks.\n   * For offchain tables, it returns early after emitting the event.\n   * @param tableId The ID of the table to set the static field for.\n   * @param keyTuple An array representing the key for the record.\n   * @param fieldIndex The index of the field to set.\n   * @param data The data to set for the static field.\n   * @param fieldLayout The field layout for the record.\n   */\n  function setStaticField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 fieldIndex,\n    bytes memory data,\n    FieldLayout fieldLayout\n  ) internal {\n    spliceStaticData({\n      tableId: tableId,\n      keyTuple: keyTuple,\n      start: uint48(StoreCoreInternal._getStaticDataOffset(fieldLayout, fieldIndex)),\n      data: data\n    });\n  }\n\n  /**\n   * @notice Set a dynamic field for the given table ID, key tuple, and dynamic field index.\n   * @dev This method emits a `Store_SpliceDynamicData` event, updates the data in storage and calls the\n   * `onBeforeSpliceDynamicaData` and `onAfterSpliceDynamicData` hooks.\n   * For offchain tables, it returns early after emitting the event.\n   * @param tableId The ID of the table to set the dynamic field for.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param dynamicFieldIndex The index of the dynamic field to set. (Dynamic field index = field index - number of static fields).\n   * @param data The data to set for the dynamic field.\n   */\n  function setDynamicField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    bytes memory data\n  ) internal {\n    // Load the previous length of the field to set from storage to compute how much data to delete\n    PackedCounter previousEncodedLengths = StoreCoreInternal._loadEncodedDynamicDataLength(tableId, keyTuple);\n    uint40 previousFieldLength = uint40(previousEncodedLengths.atIndex(dynamicFieldIndex));\n\n    StoreCoreInternal._spliceDynamicData({\n      tableId: tableId,\n      keyTuple: keyTuple,\n      dynamicFieldIndex: dynamicFieldIndex,\n      startWithinField: 0,\n      deleteCount: previousFieldLength,\n      data: data,\n      previousEncodedLengths: previousEncodedLengths\n    });\n  }\n\n  /**\n   * @notice Delete a record for the given table ID and key tuple.\n   * @dev This method internally calls another overload of deleteRecord by fetching the field layout for the given table ID.\n   * This method deletes static data and sets the dynamic data length to 0, but does not\n   * actually modify the dynamic data. It emits a `Store_DeleteRecord` event and emits the\n   * `onBeforeDeleteRecord` and `onAfterDeleteRecord` hooks.\n   * For offchain tables, it returns early after emitting the event.\n   * @param tableId The ID of the table to delete the record from.\n   * @param keyTuple An array representing the composite key for the record.\n   */\n  function deleteRecord(ResourceId tableId, bytes32[] memory keyTuple) internal {\n    deleteRecord(tableId, keyTuple, getFieldLayout(tableId));\n  }\n\n  /**\n   * @notice Delete a record for the given table ID and key tuple.\n   * @dev This method deletes static data and sets the dynamic data length to 0, but does not\n   * actually modify the dynamic data. It emits a `Store_DeleteRecord` event and emits the\n   * `onBeforeDeleteRecord` and `onAfterDeleteRecord` hooks.\n   * For offchain tables, it returns early after emitting the event.\n   * @param tableId The ID of the table to delete the record from.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param fieldLayout The field layout for the record.\n   */\n  function deleteRecord(ResourceId tableId, bytes32[] memory keyTuple, FieldLayout fieldLayout) internal {\n    // Emit event to notify indexers\n    emit Store_DeleteRecord(tableId, keyTuple);\n\n    // Early return if the table is an offchain table\n    if (tableId.getType() != RESOURCE_TABLE) {\n      return;\n    }\n\n    // Call onBeforeDeleteRecord hooks (before actually modifying the state, so observers have access to the previous state if needed)\n    bytes21[] memory hooks = StoreHooks._get(tableId);\n    for (uint256 i; i < hooks.length; i++) {\n      Hook hook = Hook.wrap(hooks[i]);\n      if (hook.isEnabled(BEFORE_DELETE_RECORD)) {\n        IStoreHook(hook.getAddress()).onBeforeDeleteRecord(tableId, keyTuple, fieldLayout);\n      }\n    }\n\n    // Delete static data\n    uint256 staticDataLocation = StoreCoreInternal._getStaticDataLocation(tableId, keyTuple);\n    Storage.store({ storagePointer: staticDataLocation, offset: 0, data: new bytes(fieldLayout.staticDataLength()) });\n\n    // If there are dynamic fields, set the dynamic data length to 0.\n    // We don't need to delete the dynamic data because it will be overwritten when a new record is set.\n    if (fieldLayout.numDynamicFields() > 0) {\n      uint256 dynamicDataLengthLocation = StoreCoreInternal._getDynamicDataLengthLocation(tableId, keyTuple);\n      Storage.zero({ storagePointer: dynamicDataLengthLocation, length: 32 });\n    }\n\n    // Call onAfterDeleteRecord hooks\n    for (uint256 i; i < hooks.length; i++) {\n      Hook hook = Hook.wrap(hooks[i]);\n      if (hook.isEnabled(AFTER_DELETE_RECORD)) {\n        IStoreHook(hook.getAddress()).onAfterDeleteRecord(tableId, keyTuple, fieldLayout);\n      }\n    }\n  }\n\n  /**\n   * @notice Push data to a field at the dynamic field index in a table with the given table ID and key tuple.\n   * @dev This method emits a `Store_SpliceDynamicData` event, updates the data in storage and calls the\n   * `onBeforeSpliceDynamicData` and `onAfterSpliceDynamicData` hooks.\n   * For offchain tables, it returns early after emitting the event.\n   * @param tableId The ID of the table to push data to the dynamic field.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param dynamicFieldIndex The index of the dynamic field to push data to.\n   * @param dataToPush The data to push to the dynamic field.\n   */\n  function pushToDynamicField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    bytes memory dataToPush\n  ) internal {\n    // Load the previous length of the field to set from storage to compute where to start to push\n    PackedCounter previousEncodedLengths = StoreCoreInternal._loadEncodedDynamicDataLength(tableId, keyTuple);\n    uint40 previousFieldLength = uint40(previousEncodedLengths.atIndex(dynamicFieldIndex));\n\n    // Splice the dynamic data\n    StoreCoreInternal._spliceDynamicData({\n      tableId: tableId,\n      keyTuple: keyTuple,\n      dynamicFieldIndex: dynamicFieldIndex,\n      startWithinField: uint40(previousFieldLength),\n      deleteCount: 0,\n      data: dataToPush,\n      previousEncodedLengths: previousEncodedLengths\n    });\n  }\n\n  /**\n   * @notice Pop data from a field at the dynamic field index in a table with the given table ID and key tuple.\n   * @dev This method emits a `Store_SpliceDynamicData` event, updates the data in storage and calls the\n   * `onBeforeSpliceDynamicData` and `onAfterSpliceDynamicData` hooks.\n   * For offchain tables, it returns early after emitting the event.\n   * @param tableId The ID of the table to pop data from the dynamic field.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param dynamicFieldIndex The index of the dynamic field to pop data from.\n   * @param byteLengthToPop The byte length to pop from the dynamic field.\n   */\n  function popFromDynamicField(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    uint8 dynamicFieldIndex,\n    uint256 byteLengthToPop\n  ) internal {\n    // Load the previous length of the field to set from storage to compute where to start to push\n    PackedCounter previousEncodedLengths = StoreCoreInternal._loadEncodedDynamicDataLength(tableId, keyTuple);\n    uint40 previousFieldLength = uint40(previousEncodedLengths.atIndex(dynamicFieldIndex));\n\n    // Splice the dynamic data\n    StoreCoreInternal._spliceDynamicData({\n      tableId: tableId,\n      keyTuple: keyTuple,\n      dynamicFieldIndex: dynamicFieldIndex,\n      startWithinField: uint40(previousFieldLength - byteLengthToPop),\n      deleteCount: uint40(byteLengthToPop),\n      data: new bytes(0),\n      previousEncodedLengths: previousEncodedLengths\n    });\n  }\n\n  /************************************************************************\n   *\n   *    GET DATA\n   *\n   ************************************************************************/\n\n  /**\n   * @notice Get the full record (all fields, static and dynamic data) for the given table ID and key tuple.\n   * @dev This function internally calls another overload of `getRecord`, loading the field layout from storage.\n   * If the field layout is available to the caller, it is recommended to use the other overload to avoid an additional storage read.\n   * @param tableId The ID of the table to get the record from.\n   * @param keyTuple An array representing the composite key for the record.\n   * @return staticData The static data of the record.\n   * @return encodedLengths The encoded lengths of the dynamic data of the record.\n   * @return dynamicData The dynamic data of the record.\n   */\n  function getRecord(\n    ResourceId tableId,\n    bytes32[] memory keyTuple\n  ) internal view returns (bytes memory staticData, PackedCounter encodedLengths, bytes memory dynamicData) {\n    return getRecord(tableId, keyTuple, getFieldLayout(tableId));\n  }\n\n  /**\n   * @notice Get the full record (all fields, static and dynamic data) for the given table ID and key tuple, with the given field layout.\n   * @param tableId The ID of the table to get the record from.\n   * @param keyTuple An array representing the composite key for the record.\n   * @param fieldLayout The field layout for the record.\n   * @return staticData The static data of the record.\n   * @return encodedLengths The encoded lengths of the dynamic data of the record.\n   * @return dynamicData The dynamic data of the record.\n   */\n  function getRecord(\n    ResourceId tableId,\n    bytes32[] memory keyTuple,\n    FieldLayout fieldLayout\n  ) internal view returns (bytes memory staticData, PackedCounter encodedLengths, bytes memory dynamicData) {\n    // Get the static data length\n    uint256 staticLength = fieldLayout.staticDataLength();\n\n    // Load the static data from storage\n    staticData = StoreCoreInternal._getStaticData(tableId, keyTuple, staticLength);\n\n    // Load the dynamic data if there are dynamic fields\n    uint256 numDynamicFields = fieldLayout.numDynamicFields();\n    if (numDynamicFields > 0) {\n      // Load the encoded dynamic data length\n      encodedLengths = StoreCoreInternal._loadEncodedDynamicDataLength(tableId, keyTuple);\n\n      // Append dynamic data\n      dynamicData = new bytes(encodedLengths.total());\n      uint256 memoryPointer = Memory.dataPointer(dynamicData);\n\n      for (uint8 i; i < numDynamicFields; i++) {"
    }
  ]
}