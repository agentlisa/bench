{
  "Title": "H-1: Two token vault will be broken if it comprises tokens with different decimals",
  "Content": "# Issue H-1: Two token vault will be broken if it comprises tokens with different decimals \n\nSource: https://github.com/sherlock-audit/2022-12-notional-judging/issues/18 \n\n## Found by \nxiaoming90\n\n## Summary\n\nA two token vault that comprises tokens with different decimals will have many of its key functions broken. For instance, rewards cannot be reinvested and vault cannot be settled.\n\n## Vulnerability Detail\n\nThe `Stable2TokenOracleMath._getSpotPrice` function is used to compute the spot price of two tokens.\n\nhttps://github.com/sherlock-audit/2022-12-notional/blob/main/contracts/vaults/balancer/internal/math/Stable2TokenOracleMath.sol#L15\n\n```solidity\nFile: Stable2TokenOracleMath.sol\n11: library Stable2TokenOracleMath {\n12:     using TypeConvert for int256;\n13:     using Stable2TokenOracleMath for StableOracleContext;\n14: \n15:     function _getSpotPrice(\n16:         StableOracleContext memory oracleContext, \n17:         TwoTokenPoolContext memory poolContext, \n18:         uint256 primaryBalance,\n19:         uint256 secondaryBalance,\n20:         uint256 tokenIndex\n21:     ) internal view returns (uint256 spotPrice) {\n22:         require(tokenIndex < 2); /// @dev invalid token index\n23: \n24:         /// Apply scale factors\n25:         uint256 scaledPrimaryBalance = primaryBalance * poolContext.primaryScaleFactor \n26:             / BalancerConstants.BALANCER_PRECISION;\n27:         uint256 scaledSecondaryBalance = secondaryBalance * poolContext.secondaryScaleFactor \n28:             / BalancerConstants.BALANCER_PRECISION;\n29: \n30:         /// @notice poolContext balances are always in BALANCER_PRECISION (1e18)\n31:         (uint256 balanceX, uint256 balanceY) = tokenIndex == 0 ?\n32:             (scaledPrimaryBalance, scaledSecondaryBalance) :\n33:             (scaledSecondaryBalance, scaledPrimaryBalance);\n34: \n35:         uint256 invariant = StableMath._calculateInvariant(\n36:             oracleContext.ampParam, StableMath._balances(balanceX, balanceY), true // round up\n37:         );\n38: \n39:         spotPrice = StableMath._calcSpotPrice({\n40:             amplificationParameter: oracleContext.ampParam,\n41:             invariant: invariant,\n42:             balanceX: balanceX, \n43:             balanceY: balanceY\n44:         });\n45: \n46:         /// Apply secondary scale factor in reverse\n47:         uint256 scaleFactor = tokenIndex == 0 ?\n48:             poolContext.secondaryScaleFactor * BalancerConstants.BALANCER_PRECISION / poolContext.primaryScaleFactor :\n49:             poolContext.primaryScaleFactor * BalancerConstants.BALANCER_PRECISION / poolContext.secondaryScaleFactor;\n50:         spotPrice = spotPrice * BalancerConstants.BALANCER_PRECISION / scaleFactor;\n51:     }\n```\n\nTwo tokens (USDC and DAI) with different decimals will be used below to illustrate the issue:\n\n#### USDC/DAI Spot Price\n\nAssume that the primary token is DAI (18 decimals) and the secondary token is USDC (6 decimals). As such, the scaling factors would be as follows. The token rate is ignored and set to 1 for simplicity.\n\n- Primary Token (DAI)'s scaling factor = 1e18\n\n  ```solidity\n  scaling factor = FixedPoint.ONE (1e18) * decimals difference to reach 18 decimals (1e0) * token rate (1)\n  scaling factor = 1e18\n  ```\n\n- Secondary Token (USDC)'s scaling factor = 1e30\n\n  ```solidity\n  scaling factor = FixedPoint.ONE (1e18) * decimals difference to reach 18 decimals (1e12) * token rate (1)\n  scaling factor = 1e18 * 1e12 = 1e30\n  ```\n\nAssume that the `primaryBalance` is 100 DAI (100e18), and the `secondaryBalance` is 100 USDC (100e6). Line 25 - 28 of the `_getSpotPrice` function will normalize the tokens balances to 18 decimals as follows:\n\n- `scaledPrimaryBalance` will be 100e18 (It remains the same as no scaling is needed because DAI is already denominated in 18 decimals)\n\n  ```solidity\n  scaledPrimaryBalance = primaryBalance * poolContext.primaryScaleFactor / BalancerConstants.BALANCER_PRECISION;\n  scaledPrimaryBalance = 100e18 * 1e18 / 1e18\n  scaledPrimaryBalance = 100e18\n  ```\n\n- `scaledSecondaryBalance` will upscale to 100e18\n\n  ```solidity\n  scaledSecondaryBalance = scaledSecondaryBalance * poolContext.primaryScaleFactor / BalancerConstants.BALANCER_PRECISION;\n  scaledSecondaryBalance = 100e6 * 1e30 / 1e18\n  scaledSecondaryBalance = 100e18\n  ```\n\nThe `StableMath._calcSpotPrice` function at Line 39 returns the spot price of Y/X. In this example, `balanceX` is DAI, and `balanceY` is USDC. Thus, the spot price will be USDC/DAI. This means the amount of USDC I will get for each DAI.\n\nWithin Balancer, all stable math calculations within the Balancer's pools are performed in 1e18. With both the primary and secondary balances normalized to 18 decimals, they can be safely passed to the `StableMath._calculateInvariant` and `StableMath._calcSpotPrice` functions to compute the spot price. Assuming that the price of USDC and DAI is perfectly symmetric (1 DAI can be exchanged for exactly 1 USDC, and vice versa), the spot price returned from the `StableMath._calcSpotPrice` will be `1e18`. Note that the spot price returned by the `StableMath._calcSpotPrice` function will be denominated in 18 decimals.\n\nIn Line 47-50 within the `Stable2TokenOracleMath._getSpotPrice` function, it attempts to downscale the spot price to normalize it back to the original decimals and token rate (e.g. stETH back to wstETH) of the token.\n\nThe `scaleFactor` at Line 47 will be evaluated as follows:\n\n```solidity\nscaleFactor = poolContext.secondaryScaleFactor * BalancerConstants.BALANCER_PRECISION / poolContext.primaryScaleFactor\nscaleFactor = 1e30 * 1e18 / 1e18\nscaleFactor = 1e30\n```\n\nFinally, the spot price will be scaled in reverse order and it will be evaluated to `1e6` as shown below:\n\n```solidity\nspotPrice = spotPrice * BalancerConstants.BALANCER_PRECISION / scaleFactor;\nspotPrice = 1e18 * 1e18 / 1e30\nspotPrice = 1e6\n```\n\n#### DAI/USDC Spot Price\n\nIf it is the opposite where the primary token is USDC (6 decimals) and the secondary token is DAI (18 decimals), the calculation of the spot price will be as follows:\n\nThe `scaleFactor` at Line 47 will be evaluated to as follows:\n\n```\nscaleFactor = poolContext.secondaryScaleFactor * BalancerConstants.BALANCER_PRECISION / poolContext.primaryScaleFactor\nscaleFactor = 1e18 * 1e18 / 1e30\nscaleFactor = 1e6\n```\n\nFinally, the spot price will be scaled in reverse order and it will be evaluated to `1e30` as shown below:\n\n```\nspotPrice = spotPrice * BalancerConstants.BALANCER_PRECISION / scaleFactor;\nspotPrice = 1e18 * 1e18 / 1e6\nspotPrice = 1e30\n```\n\n#### Note about the spot price\n\nAssuming that the spot price of USDC and DAI is 1:1. As shown above, if the decimals of two tokens are not the same, the final spot price will end up either 1e6 (USDC/DAI) or 1e30 (DAI/USDC). However, if the decimals of two tokens (e.g. wstETH and WETH) are the same, this issue stays hidden as the `scaleFactor` in Line 47 will always be 1e18 as both `secondaryScaleFactor` and `primaryScaleFactor` cancel out each other.\n\nIt was observed that the spot price returned from the `Stable2TokenOracleMath._getSpotPrice` function is being compared with the oracle price from the `TwoTokenPoolUtils._getOraclePairPrice` function to determine if the pool has been manipulated within many functions.\n\n```solidity\nuint256 oraclePrice = poolContext._getOraclePairPrice(strategyContext.tradingModule);\n```\n\nBased on the implementation of the `TwoTokenPoolUtils._getOraclePairPrice` function , the `oraclePrice` returned by this function is always denominated in 18 decimals regardless of the decimals of the underlying tokens. For instance, assume the spot price of USDC (6 decimals) and DAI (18 decimals) is 1:1. The spot price returned by this oracle function for USDC/DAI will be `1e18` and DAI/USDC will be `1e18`.\n\nIn many functions, the spot price returned from the `Stable2TokenOracleMath._getSpotPrice` function is compared with the oracle price via the `Stable2TokenOracleMath._checkPriceLimit`. Following is one such example. The `oraclePrice` will be `1e18`, while the `spotPrice` will be either `1e6` or `1e30` in our example. This will cause the `_checkPriceLimit` to always revert because of the large discrepancy between the two prices.\n\nhttps://github.com/sherlock-audit/2022-12-notional/blob/main/contracts/vaults/balancer/internal/math/Stable2TokenOracleMath.sol#L71\n\n```solidity\nFile: Stable2TokenOracleMath.sol\n71:     function _getMinExitAmounts(\n72:         StableOracleContext calldata oracleContext,\n73:         TwoTokenPoolContext calldata poolContext,\n74:         StrategyContext calldata strategyContext,\n75:         uint256 oraclePrice,\n76:         uint256 bptAmount\n77:     ) internal view returns (uint256 minPrimary, uint256 minSecondary) {\n78:         // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n79:         // Validate the spot price to make sure the pool is not being manipulated\n80:         uint256 spotPrice = _getSpotPrice({\n81:             oracleContext: oracleContext,\n82:             poolContext: poolContext,\n83:             primaryBalance: poolContext.primaryBalance,\n84:             secondaryBalance: poolContext.secondaryBalance,\n85:             tokenIndex: 0\n86:         });\n87:         _checkPriceLimit(strategyContext, oraclePrice, spotPrice);\n```\n\nOther affected functions include the following:\n\n- Stable2TokenOracleMath._validateSpotPriceAndPairPrice\n- Stable2TokenOracleMath._getTimeWeightedPrimaryBalance\n\n## Impact\n\nA vault supporting tokens with two different decimals will have many of its key functions will be broken as the `_checkPriceLimit` will always revert.  For instance, rewards cannot be reinvested and vaults cannot be settled since they rely on the `_checkPriceLimit` function.\n\nIf the reward cannot be reinvested, the strategy tokens held by the users will not appreciate. If the vault cannot be settled, the vault debt cannot be repaid to Notional and the gain cannot be realized. Loss of assets for both users and Notional\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-12-notional/blob/main/contracts/vaults/balancer/internal/math/Stable2TokenOracleMath.sol#L15\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWithin the `Stable2TokenOracleMath._getSpotPrice`, normalize the spot price back to 1e18 before returning the result. This ensures that it can be compared with the oracle price, which is denominated in 1e18 precision.\n\nThis has been implemented in the spot price function (`Boosted3TokenPoolUtils._getSpotPriceWithInvariant`) of another pool (`Boosted3Token`). However, it was not consistently applied in `TwoTokenPool`.\n\n## Discussion\n\n**weitianjie2000**\n\nvalid, will fix\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/31",
  "Code": [
    {
      "filename": "contracts/vaults/balancer/internal/math/Stable2TokenOracleMath.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {StableOracleContext, TwoTokenPoolContext, StrategyContext} from \"../../BalancerVaultTypes.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {StableMath} from \"./StableMath.sol\";\nimport {ITradingModule} from \"../../../../../interfaces/trading/ITradingModule.sol\";\n\nlibrary Stable2TokenOracleMath {\n    using TypeConvert for int256;\n    using Stable2TokenOracleMath for StableOracleContext;\n\n    function _getSpotPrice(\n        StableOracleContext memory oracleContext, \n        TwoTokenPoolContext memory poolContext, \n        uint256 primaryBalance,\n        uint256 secondaryBalance,\n        uint256 tokenIndex\n    ) internal view returns (uint256 spotPrice) {\n        require(tokenIndex < 2); /// @dev invalid token index\n\n        /// Apply scale factors\n        uint256 scaledPrimaryBalance = primaryBalance * poolContext.primaryScaleFactor \n            / BalancerConstants.BALANCER_PRECISION;\n        uint256 scaledSecondaryBalance = secondaryBalance * poolContext.secondaryScaleFactor \n            / BalancerConstants.BALANCER_PRECISION;\n\n        /// @notice poolContext balances are always in BALANCER_PRECISION (1e18)\n        (uint256 balanceX, uint256 balanceY) = tokenIndex == 0 ?\n            (scaledPrimaryBalance, scaledSecondaryBalance) :\n            (scaledSecondaryBalance, scaledPrimaryBalance);\n\n        uint256 invariant = StableMath._calculateInvariant(\n            oracleContext.ampParam, StableMath._balances(balanceX, balanceY), true // round up\n        );\n\n        spotPrice = StableMath._calcSpotPrice({\n            amplificationParameter: oracleContext.ampParam,\n            invariant: invariant,\n            balanceX: balanceX,\n            balanceY: balanceY\n        });\n\n        /// Apply secondary scale factor in reverse\n        uint256 scaleFactor = tokenIndex == 0 ?\n            poolContext.secondaryScaleFactor * BalancerConstants.BALANCER_PRECISION / poolContext.primaryScaleFactor :\n            poolContext.primaryScaleFactor * BalancerConstants.BALANCER_PRECISION / poolContext.secondaryScaleFactor;\n        spotPrice = spotPrice * BalancerConstants.BALANCER_PRECISION / scaleFactor;\n    }\n\n    function _checkPriceLimit(\n        StrategyContext memory strategyContext,\n        uint256 oraclePrice,\n        uint256 poolPrice\n    ) internal view {\n        uint256 lowerLimit = (oraclePrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS - strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n        uint256 upperLimit = (oraclePrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS + strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n\n        if (poolPrice < lowerLimit || upperLimit < poolPrice) {\n            revert Errors.InvalidPrice(oraclePrice, poolPrice);\n        }\n    }\n\n    /// @notice calculates the expected min exit amounts for a given BPT amount\n    function _getMinExitAmounts(\n        StableOracleContext calldata oracleContext,\n        TwoTokenPoolContext calldata poolContext,\n        StrategyContext calldata strategyContext,\n        uint256 oraclePrice,\n        uint256 bptAmount\n    ) internal view returns (uint256 minPrimary, uint256 minSecondary) {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        // Validate the spot price to make sure the pool is not being manipulated\n        uint256 spotPrice = _getSpotPrice({\n            oracleContext: oracleContext,\n            poolContext: poolContext,\n            primaryBalance: poolContext.primaryBalance,\n            secondaryBalance: poolContext.secondaryBalance,\n            tokenIndex: 0\n        });\n        _checkPriceLimit(strategyContext, oraclePrice, spotPrice);\n\n        // min amounts are calculated based on the share of the Balancer pool with a small discount applied\n        uint256 totalBPTSupply = poolContext.basePool.pool.totalSupply();\n        minPrimary = (poolContext.primaryBalance * bptAmount * \n            strategyContext.vaultSettings.balancerPoolSlippageLimitPercent) / \n            (totalBPTSupply * uint256(BalancerConstants.VAULT_PERCENT_BASIS));\n        minSecondary = (poolContext.secondaryBalance * bptAmount * \n            strategyContext.vaultSettings.balancerPoolSlippageLimitPercent) / \n            (totalBPTSupply * uint256(BalancerConstants.VAULT_PERCENT_BASIS));\n    }\n\n    function _validateSpotPriceAndPairPrice(\n        StableOracleContext calldata oracleContext,\n        TwoTokenPoolContext calldata poolContext,\n        StrategyContext memory strategyContext,\n        uint256 oraclePrice,\n        uint256 primaryAmount, \n        uint256 secondaryAmount\n    ) internal view {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        uint256 spotPrice = _getSpotPrice({\n            oracleContext: oracleContext,\n            poolContext: poolContext,\n            primaryBalance: poolContext.primaryBalance,\n            secondaryBalance: poolContext.secondaryBalance,\n            tokenIndex: 0\n        });\n\n        /// @notice Check spotPrice against oracle price to make sure that \n        /// the pool is not being manipulated\n        _checkPriceLimit(strategyContext, oraclePrice, spotPrice);\n\n        /// @notice Balancer math functions expect all amounts to be in BALANCER_PRECISION\n        uint256 primaryPrecision = 10 ** poolContext.primaryDecimals;\n        uint256 secondaryPrecision = 10 ** poolContext.secondaryDecimals;\n        primaryAmount = primaryAmount * BalancerConstants.BALANCER_PRECISION / primaryPrecision;\n        secondaryAmount = secondaryAmount * BalancerConstants.BALANCER_PRECISION / secondaryPrecision;\n\n        uint256 calculatedPairPrice = _getSpotPrice({\n            oracleContext: oracleContext,\n            poolContext: poolContext,\n            primaryBalance: primaryAmount,\n            secondaryBalance: secondaryAmount,\n            tokenIndex: 0\n        });\n\n        /// @notice Check the calculated primary/secondary price against the oracle price\n        /// to make sure that we are joining the pool proportionally\n        _checkPriceLimit(strategyContext, oraclePrice, calculatedPairPrice);\n    }\n}"
    },
    {
      "filename": "contracts/vaults/balancer/internal/math/Stable2TokenOracleMath.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {StableOracleContext, TwoTokenPoolContext, StrategyContext} from \"../../BalancerVaultTypes.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {StableMath} from \"./StableMath.sol\";\nimport {ITradingModule} from \"../../../../../interfaces/trading/ITradingModule.sol\";\n\nlibrary Stable2TokenOracleMath {\n    using TypeConvert for int256;\n    using Stable2TokenOracleMath for StableOracleContext;\n\n    function _getSpotPrice(\n        StableOracleContext memory oracleContext, \n        TwoTokenPoolContext memory poolContext, \n        uint256 primaryBalance,\n        uint256 secondaryBalance,\n        uint256 tokenIndex\n    ) internal view returns (uint256 spotPrice) {\n        require(tokenIndex < 2); /// @dev invalid token index\n\n        /// Apply scale factors\n        uint256 scaledPrimaryBalance = primaryBalance * poolContext.primaryScaleFactor \n            / BalancerConstants.BALANCER_PRECISION;\n        uint256 scaledSecondaryBalance = secondaryBalance * poolContext.secondaryScaleFactor \n            / BalancerConstants.BALANCER_PRECISION;\n\n        /// @notice poolContext balances are always in BALANCER_PRECISION (1e18)\n        (uint256 balanceX, uint256 balanceY) = tokenIndex == 0 ?\n            (scaledPrimaryBalance, scaledSecondaryBalance) :\n            (scaledSecondaryBalance, scaledPrimaryBalance);\n\n        uint256 invariant = StableMath._calculateInvariant(\n            oracleContext.ampParam, StableMath._balances(balanceX, balanceY), true // round up\n        );\n\n        spotPrice = StableMath._calcSpotPrice({\n            amplificationParameter: oracleContext.ampParam,\n            invariant: invariant,\n            balanceX: balanceX,\n            balanceY: balanceY\n        });\n\n        /// Apply secondary scale factor in reverse\n        uint256 scaleFactor = tokenIndex == 0 ?\n            poolContext.secondaryScaleFactor * BalancerConstants.BALANCER_PRECISION / poolContext.primaryScaleFactor :\n            poolContext.primaryScaleFactor * BalancerConstants.BALANCER_PRECISION / poolContext.secondaryScaleFactor;\n        spotPrice = spotPrice * BalancerConstants.BALANCER_PRECISION / scaleFactor;\n    }\n\n    function _checkPriceLimit(\n        StrategyContext memory strategyContext,\n        uint256 oraclePrice,\n        uint256 poolPrice\n    ) internal view {\n        uint256 lowerLimit = (oraclePrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS - strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n        uint256 upperLimit = (oraclePrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS + strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n\n        if (poolPrice < lowerLimit || upperLimit < poolPrice) {\n            revert Errors.InvalidPrice(oraclePrice, poolPrice);\n        }\n    }\n\n    /// @notice calculates the expected min exit amounts for a given BPT amount\n    function _getMinExitAmounts(\n        StableOracleContext calldata oracleContext,\n        TwoTokenPoolContext calldata poolContext,\n        StrategyContext calldata strategyContext,\n        uint256 oraclePrice,\n        uint256 bptAmount\n    ) internal view returns (uint256 minPrimary, uint256 minSecondary) {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        // Validate the spot price to make sure the pool is not being manipulated\n        uint256 spotPrice = _getSpotPrice({\n            oracleContext: oracleContext,\n            poolContext: poolContext,\n            primaryBalance: poolContext.primaryBalance,\n            secondaryBalance: poolContext.secondaryBalance,\n            tokenIndex: 0\n        });\n        _checkPriceLimit(strategyContext, oraclePrice, spotPrice);\n\n        // min amounts are calculated based on the share of the Balancer pool with a small discount applied\n        uint256 totalBPTSupply = poolContext.basePool.pool.totalSupply();\n        minPrimary = (poolContext.primaryBalance * bptAmount * \n            strategyContext.vaultSettings.balancerPoolSlippageLimitPercent) / \n            (totalBPTSupply * uint256(BalancerConstants.VAULT_PERCENT_BASIS));\n        minSecondary = (poolContext.secondaryBalance * bptAmount * \n            strategyContext.vaultSettings.balancerPoolSlippageLimitPercent) / \n            (totalBPTSupply * uint256(BalancerConstants.VAULT_PERCENT_BASIS));\n    }\n\n    function _validateSpotPriceAndPairPrice(\n        StableOracleContext calldata oracleContext,\n        TwoTokenPoolContext calldata poolContext,\n        StrategyContext memory strategyContext,\n        uint256 oraclePrice,\n        uint256 primaryAmount, \n        uint256 secondaryAmount\n    ) internal view {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        uint256 spotPrice = _getSpotPrice({\n            oracleContext: oracleContext,\n            poolContext: poolContext,\n            primaryBalance: poolContext.primaryBalance,\n            secondaryBalance: poolContext.secondaryBalance,\n            tokenIndex: 0\n        });\n\n        /// @notice Check spotPrice against oracle price to make sure that \n        /// the pool is not being manipulated\n        _checkPriceLimit(strategyContext, oraclePrice, spotPrice);\n\n        /// @notice Balancer math functions expect all amounts to be in BALANCER_PRECISION\n        uint256 primaryPrecision = 10 ** poolContext.primaryDecimals;\n        uint256 secondaryPrecision = 10 ** poolContext.secondaryDecimals;\n        primaryAmount = primaryAmount * BalancerConstants.BALANCER_PRECISION / primaryPrecision;\n        secondaryAmount = secondaryAmount * BalancerConstants.BALANCER_PRECISION / secondaryPrecision;\n\n        uint256 calculatedPairPrice = _getSpotPrice({\n            oracleContext: oracleContext,\n            poolContext: poolContext,\n            primaryBalance: primaryAmount,\n            secondaryBalance: secondaryAmount,\n            tokenIndex: 0\n        });\n\n        /// @notice Check the calculated primary/secondary price against the oracle price\n        /// to make sure that we are joining the pool proportionally\n        _checkPriceLimit(strategyContext, oraclePrice, calculatedPairPrice);\n    }\n}"
    },
    {
      "filename": "contracts/vaults/balancer/internal/math/Stable2TokenOracleMath.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {StableOracleContext, TwoTokenPoolContext, StrategyContext} from \"../../BalancerVaultTypes.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {StableMath} from \"./StableMath.sol\";\nimport {ITradingModule} from \"../../../../../interfaces/trading/ITradingModule.sol\";\n\nlibrary Stable2TokenOracleMath {\n    using TypeConvert for int256;\n    using Stable2TokenOracleMath for StableOracleContext;\n\n    function _getSpotPrice(\n        StableOracleContext memory oracleContext, \n        TwoTokenPoolContext memory poolContext, \n        uint256 primaryBalance,\n        uint256 secondaryBalance,\n        uint256 tokenIndex\n    ) internal view returns (uint256 spotPrice) {\n        require(tokenIndex < 2); /// @dev invalid token index\n\n        /// Apply scale factors\n        uint256 scaledPrimaryBalance = primaryBalance * poolContext.primaryScaleFactor \n            / BalancerConstants.BALANCER_PRECISION;\n        uint256 scaledSecondaryBalance = secondaryBalance * poolContext.secondaryScaleFactor \n            / BalancerConstants.BALANCER_PRECISION;\n\n        /// @notice poolContext balances are always in BALANCER_PRECISION (1e18)\n        (uint256 balanceX, uint256 balanceY) = tokenIndex == 0 ?\n            (scaledPrimaryBalance, scaledSecondaryBalance) :\n            (scaledSecondaryBalance, scaledPrimaryBalance);\n\n        uint256 invariant = StableMath._calculateInvariant(\n            oracleContext.ampParam, StableMath._balances(balanceX, balanceY), true // round up\n        );\n\n        spotPrice = StableMath._calcSpotPrice({\n            amplificationParameter: oracleContext.ampParam,\n            invariant: invariant,\n            balanceX: balanceX,\n            balanceY: balanceY\n        });\n\n        /// Apply secondary scale factor in reverse\n        uint256 scaleFactor = tokenIndex == 0 ?\n            poolContext.secondaryScaleFactor * BalancerConstants.BALANCER_PRECISION / poolContext.primaryScaleFactor :\n            poolContext.primaryScaleFactor * BalancerConstants.BALANCER_PRECISION / poolContext.secondaryScaleFactor;\n        spotPrice = spotPrice * BalancerConstants.BALANCER_PRECISION / scaleFactor;\n    }\n\n    function _checkPriceLimit(\n        StrategyContext memory strategyContext,\n        uint256 oraclePrice,\n        uint256 poolPrice\n    ) internal view {\n        uint256 lowerLimit = (oraclePrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS - strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n        uint256 upperLimit = (oraclePrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS + strategyContext.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n\n        if (poolPrice < lowerLimit || upperLimit < poolPrice) {\n            revert Errors.InvalidPrice(oraclePrice, poolPrice);\n        }\n    }\n\n    /// @notice calculates the expected min exit amounts for a given BPT amount\n    function _getMinExitAmounts(\n        StableOracleContext calldata oracleContext,\n        TwoTokenPoolContext calldata poolContext,\n        StrategyContext calldata strategyContext,\n        uint256 oraclePrice,\n        uint256 bptAmount\n    ) internal view returns (uint256 minPrimary, uint256 minSecondary) {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        // Validate the spot price to make sure the pool is not being manipulated\n        uint256 spotPrice = _getSpotPrice({\n            oracleContext: oracleContext,\n            poolContext: poolContext,\n            primaryBalance: poolContext.primaryBalance,\n            secondaryBalance: poolContext.secondaryBalance,\n            tokenIndex: 0\n        });\n        _checkPriceLimit(strategyContext, oraclePrice, spotPrice);\n\n        // min amounts are calculated based on the share of the Balancer pool with a small discount applied\n        uint256 totalBPTSupply = poolContext.basePool.pool.totalSupply();\n        minPrimary = (poolContext.primaryBalance * bptAmount * \n            strategyContext.vaultSettings.balancerPoolSlippageLimitPercent) / \n            (totalBPTSupply * uint256(BalancerConstants.VAULT_PERCENT_BASIS));\n        minSecondary = (poolContext.secondaryBalance * bptAmount * \n            strategyContext.vaultSettings.balancerPoolSlippageLimitPercent) / \n            (totalBPTSupply * uint256(BalancerConstants.VAULT_PERCENT_BASIS));\n    }\n\n    function _validateSpotPriceAndPairPrice(\n        StableOracleContext calldata oracleContext,\n        TwoTokenPoolContext calldata poolContext,\n        StrategyContext memory strategyContext,\n        uint256 oraclePrice,\n        uint256 primaryAmount, \n        uint256 secondaryAmount\n    ) internal view {\n        // Oracle price is always specified in terms of primary, so tokenIndex == 0 for primary\n        uint256 spotPrice = _getSpotPrice({\n            oracleContext: oracleContext,\n            poolContext: poolContext,\n            primaryBalance: poolContext.primaryBalance,\n            secondaryBalance: poolContext.secondaryBalance,\n            tokenIndex: 0\n        });\n\n        /// @notice Check spotPrice against oracle price to make sure that \n        /// the pool is not being manipulated\n        _checkPriceLimit(strategyContext, oraclePrice, spotPrice);\n\n        /// @notice Balancer math functions expect all amounts to be in BALANCER_PRECISION\n        uint256 primaryPrecision = 10 ** poolContext.primaryDecimals;\n        uint256 secondaryPrecision = 10 ** poolContext.secondaryDecimals;\n        primaryAmount = primaryAmount * BalancerConstants.BALANCER_PRECISION / primaryPrecision;\n        secondaryAmount = secondaryAmount * BalancerConstants.BALANCER_PRECISION / secondaryPrecision;\n\n        uint256 calculatedPairPrice = _getSpotPrice({\n            oracleContext: oracleContext,\n            poolContext: poolContext,\n            primaryBalance: primaryAmount,\n            secondaryBalance: secondaryAmount,\n            tokenIndex: 0\n        });\n\n        /// @notice Check the calculated primary/secondary price against the oracle price\n        /// to make sure that we are joining the pool proportionally\n        _checkPriceLimit(strategyContext, oraclePrice, calculatedPairPrice);\n    }\n}"
    }
  ]
}