{
  "Title": "[L-05] Possible deployment and functional failure of Contracts on L2s due to Dencun Opcodes",
  "Content": "With the protocol intending to operate on various L2 chains as is inferred from [executeWithoutChainIdValidation()](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol#L170-L187), it may encounter deployment and operational challenges if utilizing any of the new opcodes that enhance Ethereum's functionality, such as those related to shard blob transactions (EIP-4844) and others as described in the link below:\n\nhttps://www.coinlive.com/news/ethereum-dencun-hard-fork-content-introduction\n\nDevoid of `Dencun upgrade`, contracts relying on the new opcodes will likely fail because the Ethereum Virtual Machine (EVM) on these L2s would not recognize or know how to execute the new instructions, leading to reverts or other unexpected behaviors.  \n\nAs of todate, Optimism, Arbitrum, and Base have implemented the Dencun upgrade. Consider implementing conditional logic in contracts or hold off deploying to L2 that hasn't had the upgrade updated.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-coinbase",
  "Code": [
    {
      "filename": "src/SmartWallet/CoinbaseSmartWallet.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {Receiver} from \"solady/accounts/Receiver.sol\";\nimport {UUPSUpgradeable} from \"solady/utils/UUPSUpgradeable.sol\";\nimport {SignatureCheckerLib} from \"solady/utils/SignatureCheckerLib.sol\";\nimport {UserOperation, UserOperationLib} from \"account-abstraction/interfaces/UserOperation.sol\";\nimport {WebAuthn} from \"../WebAuthnSol/WebAuthn.sol\";\n\nimport {ERC1271} from \"./ERC1271.sol\";\nimport {MultiOwnable} from \"./MultiOwnable.sol\";\n\n/// @title Coinbase Smart Wallet\n///\n/// @notice ERC4337-compatible smart contract wallet, based on Solady ERC4337 account implementation\n///         with inspiration from Alchemy's LightAccount and Daimo's DaimoAccount.\n///\n/// @author Coinbase (https://github.com/coinbase/smart-wallet)\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/accounts/ERC4337.sol)\ncontract CoinbaseSmartWallet is MultiOwnable, UUPSUpgradeable, Receiver, ERC1271 {\n    /// @notice Wrapper struct, used during signature validation, tie a signature with its signer.\n    struct SignatureWrapper {\n        /// @dev The index indentifying owner (see MultiOwnable) who signed.\n        uint256 ownerIndex;\n        /// @dev An ABI encoded ECDSA signature (r, s, v) or WebAuthnAuth struct.\n        bytes signatureData;\n    }\n\n    /// @notice Wrapper struct, used in `executeBatch`, describing a raw call to execute.\n    struct Call {\n        /// @dev The target address to call.\n        address target;\n        /// @dev The value to associate with the call.\n        uint256 value;\n        /// @dev The raw call data.\n        bytes data;\n    }\n\n    /// @notice Reserved nonce key (upper 192 bits of `UserOperation.nonce`) for cross-chain replayable\n    ///         transactions.\n    ///\n    /// @dev Helps enforce sequential sequencing of replayable transactions.\n    uint256 public constant REPLAYABLE_NONCE_KEY = 8453;\n\n    /// @notice Thrown when trying to re-initialize an account.\n    error Initialized();\n\n    /// @notice Thrown when executing a `UserOperation` that requires the chain ID to be validated\n    ///         but this validation has been omitted.\n    ///\n    /// @dev Whitelisting of `UserOperation`s that are allowed to skip the chain ID validation is\n    ///      based on their call selectors (see `canSkipChainIdValidation()`).\n    ///\n    /// @param selector The user operation call selector that raised the error.\n    error SelectorNotAllowed(bytes4 selector);\n\n    /// @notice Thrown during a `UserOperation` validation when its key is invalid.\n    ///\n    /// @dev The `UserOperation` key validation is based on the `UserOperation` call selector.\n    ///\n    /// @param key The invalid `UserOperation` key.\n    error InvalidNonceKey(uint256 key);\n\n    /// @notice Reverts if the caller is not the EntryPoint.\n    modifier onlyEntryPoint() virtual {\n        if (msg.sender != entryPoint()) {\n            revert Unauthorized();\n        }\n\n        _;\n    }\n\n    /// @notice Reverts if the caller is neither the EntryPoint, the owner, nor the account itself.\n    modifier onlyEntryPointOrOwner() virtual {\n        if (msg.sender != entryPoint()) {\n            _checkOwner();\n        }\n\n        _;\n    }\n\n    /// @notice Sends to the EntryPoint (i.e. `msg.sender`) the missing funds for this transaction.\n    ///\n    /// @dev Subclass MAY override this modifier for better funds management (e.g. send to the\n    ///      EntryPoint more than the minimum required, so that in future transactions it will not\n    ///      be required to send again).\n    ///\n    /// @param missingAccountFunds The minimum value this modifier should send the EntryPoint which\n    ///                            MAY be zero, in case there is enough deposit, or the userOp has a\n    ///                            paymaster.\n    modifier payPrefund(uint256 missingAccountFunds) virtual {\n        _;\n\n        assembly (\"memory-safe\") {\n            if missingAccountFunds {\n                // Ignore failure (it's EntryPoint's job to verify, not the account's).\n                pop(call(gas(), caller(), missingAccountFunds, codesize(), 0x00, codesize(), 0x00))\n            }\n        }\n    }\n\n    constructor() {\n        // Implementation should not be initializable (does not affect proxies which use their own storage).\n        bytes[] memory owners = new bytes[](1);\n        owners[0] = abi.encode(address(0));\n        _initializeOwners(owners);\n    }\n\n    /// @notice Initializes the account with the the given owners.\n    ///\n    /// @dev Reverts if the account has already been initialized.\n    ///\n    /// @param owners The initial array of owners to initialize this account with.\n    function initialize(bytes[] calldata owners) public payable virtual {\n        if (nextOwnerIndex() != 0) {\n            revert Initialized();\n        }\n\n        _initializeOwners(owners);\n    }\n\n    /// @notice Custom implemenentation of the ERC-4337 `validateUserOp` method. The EntryPoint will\n    ///         make the call to the recipient only if this validation call returns successfully.\n    ///         See `IAccount.validateUserOp()`.\n    ///\n    /// @dev Signature failure should be reported by returning 1 (see: `_validateSignature()`). This\n    ///      allows making a \"simulation call\" without a valid signature. Other failures (e.g. nonce\n    ///      mismatch, or invalid signature format) should still revert to signal failure.\n    /// @dev Reverts if the `UserOperation` key is invalid.\n    /// @dev Reverts if the signature verification fails (except for the case mentionned earlier).\n    ///\n    /// @param userOp              The `UserOperation` to validate.\n    /// @param userOpHash          The `UserOperation` hash (including the chain ID).\n    /// @param missingAccountFunds The missing account funds that must be deposited on the Entrypoint.\n    ///\n    /// @return validationData The encoded `ValidationData` structure.\n    function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash, uint256 missingAccountFunds)\n        public\n        payable\n        virtual\n        onlyEntryPoint\n        payPrefund(missingAccountFunds)\n        returns (uint256 validationData)\n    {\n        uint256 key = userOp.nonce >> 64;\n\n        // 0xbf6ba1fc = bytes4(keccak256(\"executeWithoutChainIdValidation(bytes)\"))\n        if (userOp.callData.length >= 4 && bytes4(userOp.callData[0:4]) == 0xbf6ba1fc) {\n            userOpHash = getUserOpHashWithoutChainId(userOp);\n            if (key != REPLAYABLE_NONCE_KEY) {\n                revert InvalidNonceKey(key);\n            }\n        } else {\n            if (key == REPLAYABLE_NONCE_KEY) {\n                revert InvalidNonceKey(key);\n            }\n        }\n\n        // Return 0 if the recovered address matches the owner.\n        if (_validateSignature(userOpHash, userOp.signature)) {\n            return 0;\n        }\n\n        // Else return 1, which is equivalent to:\n        // `(uint256(validAfter) << (160 + 48)) | (uint256(validUntil) << 160) | (success ? 0 : 1)`\n        // where `validUntil` is 0 (indefinite) and `validAfter` is 0.\n        return 1;\n    }\n\n    /// @notice Execute the given call from this account to this account (i.e., self call).\n    ///\n    /// @dev Can only be called by the Entrypoint.\n    /// @dev Reverts if the given call is not authorized to skip the chain ID validtion.\n    /// @dev `validateUserOp()` will recompute the `userOpHash` without the chain ID befor validatin\n    ///      it if the `UserOperation` aims at executing this function. This allows certain operations\n    ///      to be replayed for all accounts sharing the same address across chains. E.g. This may be\n    ///      useful for syncing owner changes.\n    ///\n    /// @param data The `UserOperation` raw call data of the  execute.\n    function executeWithoutChainIdValidation(bytes calldata data) public payable virtual onlyEntryPoint {\n        bytes4 selector = bytes4(data[0:4]);\n        if (!canSkipChainIdValidation(selector)) {\n            revert SelectorNotAllowed(selector);\n        }\n\n        _call(address(this), 0, data);\n    }\n\n    /// @notice Execute the given call from this account.\n    ///\n    /// @dev Can only be called by the Entrypoint or an owner of this account (including itself).\n    ///\n    /// @param target The target call address.\n    /// @param value  The call value to user.\n    /// @param data   The raw call data.\n    function execute(address target, uint256 value, bytes calldata data) public payable virtual onlyEntryPointOrOwner {\n        _call(target, value, data);\n    }\n\n    /// @notice Execute the given list of calls from this account.\n    ///\n    /// @dev Can only be called by the Entrypoint or an owner of this account (including itself).\n    ///\n    /// @param calls The list of `Call`s to execute.\n    function executeBatch(Call[] calldata calls) public payable virtual onlyEntryPointOrOwner {\n        for (uint256 i; i < calls.length;) {\n            _call(calls[i].target, calls[i].value, calls[i].data);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Returns the address of the EntryPoint v0.6.\n    ///\n    /// @return The address of the EntryPoint v0.6\n    function entryPoint() public view virtual returns (address) {\n        return 0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789;\n    }\n\n    /// @notice Computes the hash of the `UserOperation` in the same way as EntryPoint v0.6, but\n    ///         leaves out the chain ID.\n    ///\n    /// @dev This allows accounts to sign a hash that can be used on many chains.\n    ///\n    /// @param userOp The `UserOperation` to compute the hash for.\n    ///\n    /// @return userOpHash The `UserOperation` hash, not including the chain ID.\n    function getUserOpHashWithoutChainId(UserOperation calldata userOp)\n        public\n        view\n        virtual\n        returns (bytes32 userOpHash)\n    {\n        return keccak256(abi.encode(UserOperationLib.hash(userOp), entryPoint()));\n    }\n\n    /// @notice Returns the implementation of the ERC1967 proxy.\n    ///\n    /// @return $ The address of implementation contract.\n    function implementation() public view returns (address $) {\n        assembly {\n            $ := sload(_ERC1967_IMPLEMENTATION_SLOT)\n        }\n    }\n\n    /// @notice Check if the given function selector is whitelisted to skip the chain ID validation.\n    ///\n    /// @param functionSelector The function selector to check.\n    ////\n    /// @return `true` is the function selector is whitelisted to skip the chain ID validation, else `false`.\n    function canSkipChainIdValidation(bytes4 functionSelector) public pure returns (bool) {\n        if (\n            functionSelector == MultiOwnable.addOwnerPublicKey.selector\n                || functionSelector == MultiOwnable.addOwnerAddress.selector\n                || functionSelector == MultiOwnable.removeOwnerAtIndex.selector\n                || functionSelector == UUPSUpgradeable.upgradeToAndCall.selector\n        ) {\n            return true;\n        }\n        return false;\n    }\n\n    /// @notice Execute the given call from this account.\n    ///\n    /// @dev Reverts if the call reverted.\n    /// @dev Impl taken from https://github.com/alchemyplatform/light-account/blob/main/src/LightAccount.sol#L347\n    ///\n    /// @param target The target call address.\n    /// @param value  The call value to user.\n    /// @param data   The raw call data.\n    function _call(address target, uint256 value, bytes memory data) internal {\n        (bool success, bytes memory result) = target.call{value: value}(data);\n        if (!success) {\n            assembly (\"memory-safe\") {\n                revert(add(result, 32), mload(result))\n            }\n        }\n    }\n\n    /// @inheritdoc ERC1271\n    ///\n    /// @dev Used both for classic ERC-1271 signature AND `UserOperation` validations.\n    /// @dev Reverts if the signer (based on the `ownerIndex`) is not compatible with the signature.\n    /// @dev Reverts if the signature does not correspond to an ERC-1271 signature or to the abi\n    ///      encoded version of a `WebAuthnAuth` struct.\n    /// @dev Does NOT revert if the signature verification fails to allow making a \"simulation call\"\n    ///      without a valid signature.\n    ///\n    /// @param signature The abi encoded `SignatureWrapper` struct.\n    function _validateSignature(bytes32 message, bytes calldata signature)\n        internal\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        SignatureWrapper memory sigWrapper = abi.decode(signature, (SignatureWrapper));\n        bytes memory ownerBytes = ownerAtIndex(sigWrapper.ownerIndex);\n\n        if (ownerBytes.length == 32) {\n            if (uint256(bytes32(ownerBytes)) > type(uint160).max) {\n                // technically should be impossible given owners can only be added with\n                // addOwnerAddress and addOwnerPublicKey, but we leave incase of future changes.\n                revert InvalidEthereumAddressOwner(ownerBytes);\n            }\n\n            address owner;\n            assembly (\"memory-safe\") {\n                owner := mload(add(ownerBytes, 32))\n            }\n\n            return SignatureCheckerLib.isValidSignatureNow(owner, message, sigWrapper.signatureData);\n        }\n\n        if (ownerBytes.length == 64) {\n            (uint256 x, uint256 y) = abi.decode(ownerBytes, (uint256, uint256));\n\n            WebAuthn.WebAuthnAuth memory auth = abi.decode(sigWrapper.signatureData, (WebAuthn.WebAuthnAuth));\n\n            return WebAuthn.verify({challenge: abi.encode(message), requireUV: false, webAuthnAuth: auth, x: x, y: y});\n        }\n\n        revert InvalidOwnerBytesLength(ownerBytes);\n    }\n\n    /// @inheritdoc UUPSUpgradeable\n    ///\n    /// @dev Authorization logic is only based on the sender being an owner of this account.\n    function _authorizeUpgrade(address) internal view virtual override(UUPSUpgradeable) onlyOwner {}\n\n    /// @inheritdoc ERC1271\n    function _domainNameAndVersion() internal pure override(ERC1271) returns (string memory, string memory) {\n        return (\"Coinbase Smart Wallet\", \"1\");\n    }\n}"
    }
  ]
}