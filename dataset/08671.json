{
  "Title": "[H-08] ERC5095 redeem/withdraw does not update allowances",
  "Content": "_Submitted by kenzo, also found by 0x29A, cccz, csanuragjain, GimelSec, kirk-baird, Lambda, sashik_eth, shenwilly, and StErMi_\n\nERC5095's `redeem`/`withdraw` allows an ERC20-approved account to redeem user's tokens, but does not update the allowance after burning.\n\n### Impact\n\nUser Mal can burn more tokens than Alice allowed him to.\nHe can set himself to be the receiver of the underlying, therefore Alice will lose funds.\n\n### Proof of Concept\n\n[`withdraw`](https://github.com/code-423n4/2022-06-illuminate/blob/main/marketplace/ERC5095.sol#L100) and [`redeem`](https://github.com/code-423n4/2022-06-illuminate/blob/main/marketplace/ERC5095.sol#L116) functions check that the msg.sender has enough approvals to redeem the tokens:\n\n                require(_allowance[holder][msg.sender] >= underlyingAmount, 'not enough approvals');\n\nBut they do not update the allowances.\nThey then call `authRedeem`, which also does not update the allowances.\nTherefore, an approved user could \"re-use his approval\" again and again and redeem whole of approver's funds to himself.\n\n### Recommended Mitigation Steps\n\nUpdate the allowances upon spending.\n\n**[sourabhmarathe (Illuminate) confirmed and commented](https://github.com/code-423n4/2022-06-illuminate-findings/issues/245#issuecomment-1169166982):**\n > While we did not actually intend to audit the 5095 itself, as 5095 itself is not yet final, we did describe its purpose in our codebase in the initial readme, and didn't specify that it was not in scope.\n> \n> With that context, we will leave it up to the judges whether or not to accept issues related to the ERC5095 token.\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2022-06-illuminate",
  "Code": [
    {
      "filename": "marketplace/ERC5095.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./Interfaces.sol\";\nimport \"./ERC20Permit.sol\";\n\ncontract ERC5095 is ERC20Permit, IERC5095 {\n    /// @dev unix timestamp when the ERC5095 token can be redeemed\n    uint256 public override immutable maturity;\n    /// @dev address of the ERC20 token that is returned on ERC5095 redemption\n    address public override immutable underlying;\n    /// @dev address of the minting authority\n    address public immutable lender;\n    \n    /////////////OPTIONAL///////////////// (Allows the calculation and distribution of yield post maturity)\n    /// @dev address and interface for an external custody contract (necessary for some project's backwards compatability)\n    address public immutable redeemer;\n\n    error Maturity(uint256 timestamp);  \n\n    constructor(address _underlying, uint256 _maturity, address _redeemer, address l, string memory name_, string memory symbol_, uint8 decimals_) ERC20Permit(name_, symbol_, decimals_) {\n        underlying = _underlying;\n        maturity = _maturity;\n        redeemer = _redeemer;\n        lender = l;\n    }\n\n    /// @notice Post maturity converts an amount of principal tokens to an amount of underlying that would be returned. Returns 0 pre-maturity.\n    /// @param principalAmount The amount of principal tokens to convert\n    /// @return underlyingAmount The amount of underlying tokens returned by the conversion\n    function convertToUnderlying(uint256 principalAmount) external override view returns (uint256 underlyingAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (principalAmount);\n    }\n\n    /// @notice Post maturity converts a desired amount of underlying tokens returned to principal tokens needed. Returns 0 pre-maturity.\n    /// @param underlyingAmount The amount of underlying tokens to convert\n    /// @return principalAmount The amount of principal tokens returned by the conversion\n    function convertToPrincipal(uint256 underlyingAmount) external override view returns (uint256 principalAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (underlyingAmount);\n    }\n\n    /// @notice Post maturity calculates the amount of principal tokens that `owner` can redeem. Returns 0 pre-maturity.\n    /// @param owner The address of the owner for which redemption is calculated\n    /// @return maxPrincipalAmount The maximum amount of principal tokens that `owner` can redeem.\n    function maxRedeem(address owner) external override view returns (uint256 maxPrincipalAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (_balanceOf[owner]);\n    }\n\n    /// @notice Post maturity simulates the effects of redeemption at the current block. Returns 0 pre-maturity.\n    /// @param principalAmount the amount of principal tokens redeemed in the simulation\n    /// @return underlyingAmount The maximum amount of underlying returned by `principalAmount` of PT redemption\n    function previewRedeem(uint256 principalAmount) external override view returns (uint256 underlyingAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (principalAmount);\n    }\n\n    /// @notice Post maturity calculates the amount of underlying tokens that `owner` can withdraw. Returns 0 pre-maturity.\n    /// @param  owner The address of the owner for which withdrawal is calculated\n    /// @return maxUnderlyingAmount The maximum amount of underlying tokens that `owner` can withdraw.\n    function maxWithdraw(address owner) external override view returns (uint256 maxUnderlyingAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (_balanceOf[owner]);\n    }\n\n    /// @notice Post maturity simulates the effects of withdrawal at the current block. Returns 0 pre-maturity.\n    /// @param underlyingAmount the amount of underlying tokens withdrawn in the simulation\n    /// @return principalAmount The amount of principal tokens required for the withdrawal of `underlyingAmount`\n    function previewWithdraw(uint256 underlyingAmount) external override view returns (uint256 principalAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (underlyingAmount);\n    }\n\n    /// @notice At or after maturity, Burns principalAmount from `owner` and sends exactly `underlyingAmount` of underlying tokens to `receiver`.\n    /// @param underlyingAmount The amount of underlying tokens withdrawn\n    /// @param receiver The receiver of the underlying tokens being withdrawn\n    /// @return principalAmount The amount of principal tokens burnt by the withdrawal\n    function withdraw(uint256 underlyingAmount, address receiver, address holder) external override returns (uint256 principalAmount){\n        if (block.timestamp < maturity) {\n            revert Maturity(maturity);\n        }\n        if (holder == msg.sender) {\n            return IRedeemer(redeemer).authRedeem(underlying, maturity, msg.sender, receiver, underlyingAmount);\n        }\n        else {\n            require(_allowance[holder][msg.sender] >= underlyingAmount, 'not enough approvals');\n            return IRedeemer(redeemer).authRedeem(underlying, maturity, holder, receiver, underlyingAmount);     \n        }\n    }\n\n    /// @notice At or after maturity, burns exactly `principalAmount` of Principal Tokens from `owner` and sends underlyingAmount of underlying tokens to `receiver`.\n    /// @param receiver The receiver of the underlying tokens being withdrawn\n    /// @return underlyingAmount The amount of underlying tokens distributed by the redemption\n    function redeem(uint256 principalAmount, address receiver, address holder) external override returns (uint256 underlyingAmount){\n        if (block.timestamp < maturity) {\n            revert Maturity(maturity);\n        }\n        if (holder == msg.sender) {\n            return IRedeemer(redeemer).authRedeem(underlying, maturity, msg.sender, receiver, principalAmount);\n        }\n        else {\n            require(_allowance[holder][msg.sender] >= underlyingAmount, 'not enough approvals');\n            return IRedeemer(redeemer).authRedeem(underlying, maturity, holder, receiver, principalAmount);     \n        }\n    }\n\n    /// @param f Address to burn from\n    /// @param a Amount to burn\n    /// @return bool true if successful\n    function burn(address f, uint256 a) external onlyAdmin(redeemer) returns (bool) {\n        _burn(f, a);\n        return true;\n    }\n\n    /// @param t Address recieving the minted amount\n    /// @param a The amount to mint\n    /// @return bool true if successful\n    function mint(address t, uint256 a) external onlyAdmin(lender) returns (bool) {\n        _mint(t, a);\n        return true;\n    }\n\n    /// @param a Admin address\n    modifier onlyAdmin(address a) {\n    require(msg.sender == a, 'sender must be admin');\n    _;\n    }\n}"
    }
  ]
}