{
  "Title": "Unsafe call to decimals()",
  "Content": "# Unsafe call to decimals()\n\n### Severity\nLow Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/oracles/GMXOracle.sol#L314\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/oracles/GMXOracle.sol#L314</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXManager.sol#L80\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXManager.sol#L80</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXManager.sol#L81\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXManager.sol#L81</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXManager.sol#L196\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXManager.sol#L196</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXManager.sol#L198\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXManager.sol#L198</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXManager.sol#L206\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXManager.sol#L206</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXManager.sol#L208\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXManager.sol#L208</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXReader.sol#L67\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXReader.sol#L67</a>\n\n\n## Summary\nThe `decimals` function is optional in the initial ERC20 and might fail for old tokens that do not implement it.\n\n## Tools Used\nManual Review\n\n## Recommendations\nHere is an example of how to fix the issue:\n\nhttps://github.com/boringcrypto/BoringSolidity/blob/c73ed73afa9273fbce93095ef177513191782254/contracts/libraries/BoringERC20.sol#L49-L55",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clo38mm260001la08daw5cbuf",
  "Code": [
    {
      "filename": "contracts/oracles/GMXOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { ISyntheticReader } from \"../interfaces/protocols/gmx/ISyntheticReader.sol\";\nimport { IChainlinkOracle } from \"../interfaces/oracles/IChainlinkOracle.sol\";\nimport { Errors } from \"../utils/Errors.sol\";\n\nimport { console } from \"forge-std/console.sol\";\n\ncontract GMXOracle {\n\n  /* ==================== STATE VARIABLES ==================== */\n\n  // GMX DataStore\n  address public immutable dataStore;\n  // GMX Synthetic Reader\n  ISyntheticReader public immutable syntheticReader;\n  // Chainlink oracle\n  IChainlinkOracle public immutable chainlinkOracle;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ====================== CONSTRUCTOR ====================== */\n\n  /**\n    * @param _DataStore Address of GMX DataStore\n    * @param _syntheticReader Address of GMX Synthetic Reader\n    * @param _chainlinkOracle Address of Chainlink oracle\n  */\n  constructor(\n    address _DataStore,\n    ISyntheticReader _syntheticReader,\n    IChainlinkOracle _chainlinkOracle\n  ) {\n    if (_DataStore == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (address(_syntheticReader) == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (address(_chainlinkOracle) == address(0)) revert Errors.ZeroAddressNotAllowed();\n\n    dataStore = _DataStore;\n    syntheticReader = _syntheticReader;\n    chainlinkOracle = _chainlinkOracle;\n  }\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice Get amountsOut of either the long or short token based on the amountsIn\n    * of either long or short token in the market\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param tokenIn TokenIn address\n    * @param amountIn Amount of tokenIn, expressed in tokenIn's decimals\n    * @return amountsOut Amount of tokenOut within LP (market) to be received, expressed in tokenOut's decimals\n  */\n  function getAmountsOut(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    address tokenIn,\n    uint256 amountIn\n  ) public view returns (uint256) {\n    ISyntheticReader.MarketProps memory _market;\n    _market.marketToken = marketToken;\n    _market.indexToken = indexToken;\n    _market.longToken = longToken;\n    _market.shortToken = shortToken;\n\n    ISyntheticReader.PriceProps memory _indexTokenPrice;\n    _indexTokenPrice.min = _getTokenPriceMinMaxFormatted(indexToken);\n    _indexTokenPrice.max = _getTokenPriceMinMaxFormatted(indexToken);\n\n    ISyntheticReader.PriceProps memory _longTokenPrice;\n    _longTokenPrice.min = _getTokenPriceMinMaxFormatted(longToken);\n    _longTokenPrice.max = _getTokenPriceMinMaxFormatted(longToken);\n\n    ISyntheticReader.PriceProps memory _shortTokenPrice;\n    _shortTokenPrice.min = _getTokenPriceMinMaxFormatted(shortToken);\n    _shortTokenPrice.max = _getTokenPriceMinMaxFormatted(shortToken);\n\n    ISyntheticReader.MarketPrices memory _prices;\n    _prices.indexTokenPrice = _indexTokenPrice;\n    _prices.longTokenPrice = _longTokenPrice;\n    _prices.shortTokenPrice = _shortTokenPrice;\n\n    address _uiFeeReceiver = address(0);\n\n    (uint256 _amountsOut,,) = syntheticReader.getSwapAmountOut(\n      dataStore,\n      _market,\n      _prices,\n      tokenIn,\n      amountIn,\n      _uiFeeReceiver\n    );\n\n    return _amountsOut;\n  }\n\n  /**\n    * @notice Helper function to calculate amountIn of either long or short token for swapping for\n    * desired amountsOut of long or short token\n    * @notice We utilise GMX's getSwapAmountOut() with tokenOut being tokenIn, multiplying\n    * the amountsOut value by 1.0015x to account for fees and normal chainlink price feed differential\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param tokenOut TokenIn address\n    * @param amountsOut Amount of tokenIn, expressed in tokenIn's decimals\n    * @return amountsOut Amount of tokenOut within LP (market) to be received, expressed in tokenOut's decimals\n  */\n  function getAmountsIn(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    address tokenOut,\n    uint256 amountsOut\n  ) public view returns (uint256) {\n    return getAmountsOut(\n      marketToken,\n      indexToken,\n      longToken,\n      shortToken,\n      tokenOut,\n      amountsOut\n    ) * (1e18 + 15e14) / SAFE_MULTIPLIER;\n  }\n\n  /**\n    * @notice Get LP (market) token info\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param pnlFactorType P&L Factory type in bytes32 hashed string\n    * @param maximize Min/max price boolean\n    * @return (marketTokenPrice, MarketPoolValueInfoProps MarketInfo)\n  */\n  function getMarketTokenInfo(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    bytes32 pnlFactorType,\n    bool maximize\n  ) public view returns (int256, ISyntheticReader.MarketPoolValueInfoProps memory) {\n    if (address(marketToken) == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (address(indexToken) == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (address(longToken) == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (address(shortToken) == address(0)) revert Errors.ZeroAddressNotAllowed();\n\n    ISyntheticReader.MarketProps memory _market;\n    _market.marketToken = marketToken;\n    _market.indexToken = indexToken;\n    _market.longToken = longToken;\n    _market.shortToken = shortToken;\n\n    ISyntheticReader.PriceProps memory _indexTokenPrice;\n    _indexTokenPrice.min = _getTokenPriceMinMaxFormatted(indexToken);\n    _indexTokenPrice.max = _getTokenPriceMinMaxFormatted(indexToken);\n\n    ISyntheticReader.PriceProps memory _longTokenPrice;\n    _longTokenPrice.min = _getTokenPriceMinMaxFormatted(longToken);\n    _longTokenPrice.max = _getTokenPriceMinMaxFormatted(longToken);\n\n    ISyntheticReader.PriceProps memory _shortTokenPrice;\n    _shortTokenPrice.min = _getTokenPriceMinMaxFormatted(shortToken);\n    _shortTokenPrice.max = _getTokenPriceMinMaxFormatted(shortToken);\n\n    return syntheticReader.getMarketTokenPrice(\n      dataStore,\n      _market,\n      _indexTokenPrice,\n      _longTokenPrice,\n      _shortTokenPrice,\n      pnlFactorType,\n      maximize\n    );\n  }\n\n  /**\n    * @notice Get LP (market) token reserves\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @return (reserveA, reserveB) Reserve amount of longToken and shortToken respectively\n  */\n  function getLpTokenReserves(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken\n  ) public view returns (uint256, uint256) {\n    // _pnlFactorType value does not matter in getting token reserves\n    bytes32 _pnlFactorType = keccak256(abi.encode(\"MAX_PNL_FACTOR_FOR_DEPOSITS\"));\n\n    // _maximize value does not matter in getting token reserves\n    bool _maximize = false;\n\n    (, ISyntheticReader.MarketPoolValueInfoProps memory _marketInfo) = getMarketTokenInfo(\n      marketToken,\n      indexToken,\n      longToken,\n      shortToken,\n      _pnlFactorType,\n      _maximize\n    );\n\n    return (\n      _marketInfo.longTokenAmount,\n      _marketInfo.shortTokenAmount\n    );\n  }\n\n  /**\n    * @notice Get LP (market) token reserves\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param isDeposit Boolean for deposit or withdrawal\n    * @param maximize Boolean for minimum or maximum price\n    * @return marketTokenPrice in 1e18\n  */\n  function getLpTokenValue(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    bool isDeposit,\n    bool maximize\n  ) public view returns (uint256) {\n    bytes32 _pnlFactorType;\n\n    if (isDeposit) {\n      _pnlFactorType = keccak256(abi.encode(\"MAX_PNL_FACTOR_FOR_DEPOSITS\"));\n    } else {\n      _pnlFactorType = keccak256(abi.encode(\"MAX_PNL_FACTOR_FOR_WITHDRAWALS\"));\n    }\n\n    (int256 _marketTokenPrice,) = getMarketTokenInfo(\n      marketToken,\n      indexToken,\n      longToken,\n      shortToken,\n      _pnlFactorType,\n      maximize\n    );\n\n    // If LP token value is negative, return 0\n    if (_marketTokenPrice < 0) {\n      return 0;\n    } else {\n      // Price returned in 1e30, we normalize it to 1e18\n      return uint256(_marketTokenPrice) / 1e12;\n    }\n  }\n\n\n  /**\n    * @notice Get token A and token B's LP token amount required for a given value\n    * @param givenValue Given value needed, expressed in 1e30\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param isDeposit Boolean for deposit or withdrawal\n    * @param maximize Boolean for minimum or maximum price\n    * @return lpTokenAmount Amount of LP tokens; expressed in 1e18\n  */\n  function getLpTokenAmount(\n    uint256 givenValue,\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    bool isDeposit,\n    bool maximize\n  ) public view returns (uint256) {\n    uint256 _lpTokenValue = getLpTokenValue(\n      marketToken,\n      indexToken,\n      longToken,\n      shortToken,\n      isDeposit,\n      maximize\n    );\n\n    return givenValue * SAFE_MULTIPLIER / _lpTokenValue;\n  }\n\n  /* ================== INTERNAL FUNCTIONS =================== */\n\n  /**\n    * @notice Get token price formatted for GMX mix/max decimals for 1e30 normalization\n    * @dev E.g. if token decimals is 18, to normalize to 1e30, we need to return 30-18 = 1e12\n    * consult() usually returns asset price in 8 decimals, so 30 - tokenDecimals - priceDecimals\n    * should format the decimals correctly for 1e30\n    * @param token Token address\n    * @return tokenPriceMinMaxFormatted\n  */\n  function _getTokenPriceMinMaxFormatted(address token) internal view returns (uint256) {\n    (int256 _price, uint8 _priceDecimals) = chainlinkOracle.consult(token);\n\n    return uint256(_price) * 10 ** (30 - IERC20Metadata(token).decimals() - _priceDecimals);\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\nimport { GMXWorker } from \"./GMXWorker.sol\";\n\n/**\n  * @title GMXManager\n  * @author Steadefi\n  * @notice Re-usable library functions for calculations and operations of borrows, repays, swaps\n  * adding and removal of liquidity to yield source\n*/\nlibrary GMXManager {\n  using SafeERC20 for IERC20;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice Calculate if token swap is needed to ensure enough repayment for both tokenA and tokenB\n    * @notice Assume that after swapping one token for the other, there is still enough to repay both tokens\n    * @param self GMXTypes.Store\n    * @param rp GMXTypes.RepayParams\n    * @return swapNeeded boolean if swap is needed\n    * @return tokenFrom address of token to swap from\n    * @return tokenTo address of token to swap to\n    * @return tokenToAmt amount of tokenFrom to swap in token decimals\n  */\n  function calcSwapForRepay(\n    GMXTypes.Store storage self,\n    GMXTypes.RepayParams memory rp\n  ) external view returns (bool, address, address, uint256) {\n    address _tokenFrom;\n    address _tokenTo;\n    uint256 _tokenToAmt;\n\n    if (rp.repayTokenAAmt > self.tokenA.balanceOf(address(this))) {\n      // If more tokenA is needed for repayment\n      _tokenToAmt = rp.repayTokenAAmt - self.tokenA.balanceOf(address(this));\n      _tokenFrom = address(self.tokenB);\n      _tokenTo = address(self.tokenA);\n\n      return (true, _tokenFrom, _tokenTo, _tokenToAmt);\n    } else if (rp.repayTokenBAmt > self.tokenB.balanceOf(address(this))) {\n      // If more tokenB is needed for repayment\n      _tokenToAmt = rp.repayTokenBAmt - self.tokenB.balanceOf(address(this));\n      _tokenFrom = address(self.tokenA);\n      _tokenTo = address(self.tokenB);\n\n      return (true, _tokenFrom, _tokenTo, _tokenToAmt);\n    } else {\n      // If more there is enough to repay both tokens\n      return (false, address(0), address(0), 0);\n    }\n  }\n\n  /**\n    * @notice Calculate amount of tokenA and tokenB to borrow\n    * @param self GMXTypes.Store\n    * @param depositValue USD value in 1e18\n  */\n  function calcBorrow(\n    GMXTypes.Store storage self,\n    uint256 depositValue\n  ) external view returns (uint256, uint256) {\n    // Calculate final position value based on deposit value\n    uint256 _positionValue = depositValue * self.leverage / SAFE_MULTIPLIER;\n\n    // Obtain the value to borrow\n    uint256 _borrowValue = _positionValue - depositValue;\n\n    uint256 _tokenADecimals = IERC20Metadata(address(self.tokenA)).decimals();\n    uint256 _tokenBDecimals = IERC20Metadata(address(self.tokenB)).decimals();\n    uint256 _borrowLongTokenAmt;\n    uint256 _borrowShortTokenAmt;\n\n    // If delta is long, borrow all in short token\n    if (self.delta == GMXTypes.Delta.Long) {\n      _borrowShortTokenAmt = _borrowValue * SAFE_MULTIPLIER\n                             / GMXReader.convertToUsdValue(self, address(self.tokenB), 10**(_tokenBDecimals))\n                             / (10 ** (18 - _tokenBDecimals));\n    }\n\n    // If delta is neutral, borrow appropriate amount in long token to hedge, and the rest in short token\n    if (self.delta == GMXTypes.Delta.Neutral) {\n      // Get token weights in LP, e.g. 50% = 5e17\n      (uint256 _tokenAWeight,) = GMXReader.tokenWeights(self);\n\n      // Get value of long token (typically tokenA)\n      uint256 _longTokenWeightedValue = _tokenAWeight * _positionValue / SAFE_MULTIPLIER;\n\n      // Borrow appropriate amount in long token to hedge\n      _borrowLongTokenAmt = _longTokenWeightedValue * SAFE_MULTIPLIER\n                            / GMXReader.convertToUsdValue(self, address(self.tokenA), 10**(_tokenADecimals))\n                            / (10 ** (18 - _tokenADecimals));\n\n      // Borrow the shortfall value in short token\n      _borrowShortTokenAmt = (_borrowValue - _longTokenWeightedValue) * SAFE_MULTIPLIER\n                             / GMXReader.convertToUsdValue(self, address(self.tokenB), 10**(_tokenBDecimals))\n                             / (10 ** (18 - _tokenBDecimals));\n    }\n\n    return (_borrowLongTokenAmt, _borrowShortTokenAmt);\n  }\n\n  /**\n    * @notice Calculate amount of tokenA and tokenB to repay based on token shares ratio being withdrawn\n    * @param self GMXTypes.Store\n    * @param shareRatio Amount of vault token shares relative to total supply in 1e18\n  */\n  function calcRepay(\n    GMXTypes.Store storage self,\n    uint256 shareRatio\n  ) external view returns (uint256, uint256) {\n    (uint256 tokenADebtAmt, uint256 tokenBDebtAmt) = GMXReader.debtAmt(self);\n\n    uint256 _repayTokenAAmt = shareRatio * tokenADebtAmt / SAFE_MULTIPLIER;\n    uint256 _repayTokenBAmt = shareRatio * tokenBDebtAmt / SAFE_MULTIPLIER;\n\n    return (_repayTokenAAmt, _repayTokenBAmt);\n  }\n\n  /**\n    * @notice Calculate minimum market (GM LP) tokens to receive when adding liquidity\n    * @param self GMXTypes.Store\n    * @param depositValue USD value in 1e18\n    * @param slippage Slippage value in 1e4\n    * @return minMarketTokenAmt in 1e18\n  */\n  function calcMinMarketSlippageAmt(\n    GMXTypes.Store storage self,\n    uint256 depositValue,\n    uint256 slippage\n  ) external view returns (uint256) {\n    uint256 _lpTokenValue = self.gmxOracle.getLpTokenValue(\n      address(self.lpToken),\n      address(self.tokenA),\n      address(self.tokenA),\n      address(self.tokenB),\n      false,\n      false\n    );\n\n    return depositValue\n      * SAFE_MULTIPLIER\n      / _lpTokenValue\n      * (10000 - slippage) / 10000;\n  }\n\n  /**\n    * @notice Calculate minimum tokens to receive when removing liquidity\n    * @dev minLongToken and minShortToken should be the token which we want to receive\n    * after liquidity withdrawal and swap\n    * @param self GMXTypes.Store\n    * @param lpAmt Amt of lp tokens to remove liquidity in 1e18\n    * @param minLongToken Address of token to receive longToken in\n    * @param minShortToken Address of token to receive shortToken in\n    * @param slippage Slippage value in 1e4\n    * @return minTokenAAmt in 1e18\n    * @return minTokenBAmt in 1e18\n  */\n  function calcMinTokensSlippageAmt(\n    GMXTypes.Store storage self,\n    uint256 lpAmt,\n    address minLongToken,\n    address minShortToken,\n    uint256 slippage\n  ) external view returns (uint256, uint256) {\n    uint256 _withdrawValue = lpAmt\n      * self.gmxOracle.getLpTokenValue(\n        address(self.lpToken),\n        address(self.tokenA),\n        address(self.tokenA),\n        address(self.tokenB),\n        false,\n        false\n      )\n      / SAFE_MULTIPLIER;\n\n    (uint256 _tokenAWeight, uint256 _tokenBWeight) = GMXReader.tokenWeights(self);\n\n    uint256 _minLongTokenAmt = _withdrawValue\n      * _tokenAWeight / SAFE_MULTIPLIER\n      * SAFE_MULTIPLIER\n      / GMXReader.convertToUsdValue(\n        self,\n        minLongToken,\n        10**(IERC20Metadata(minLongToken).decimals())\n      )\n      / (10 ** (18 - IERC20Metadata(minLongToken).decimals()));\n\n    uint256 _minShortTokenAmt = _withdrawValue\n      * _tokenBWeight / SAFE_MULTIPLIER\n      * SAFE_MULTIPLIER\n      / GMXReader.convertToUsdValue(\n        self,\n        minShortToken,\n        10**(IERC20Metadata(minShortToken).decimals())\n      )\n      / (10 ** (18 - IERC20Metadata(minShortToken).decimals()));\n\n    return (\n      _minLongTokenAmt * (10000 - slippage) / 10000,\n      _minShortTokenAmt * (10000 - slippage) / 10000\n    );\n  }\n\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice Borrow tokens from lending vaults\n    * @param self GMXTypes.Store\n    * @param borrowTokenAAmt Amount of tokenA to borrow in token decimals\n    * @param borrowTokenBAmt Amount of tokenB to borrow in token decimals\n  */\n  function borrow(\n    GMXTypes.Store storage self,\n    uint256 borrowTokenAAmt,\n    uint256 borrowTokenBAmt\n  ) public {\n    if (borrowTokenAAmt > 0) {\n      self.tokenALendingVault.borrow(borrowTokenAAmt);\n    }\n    if (borrowTokenBAmt > 0) {\n      self.tokenBLendingVault.borrow(borrowTokenBAmt);\n    }\n  }\n\n  /**\n    * @notice Repay tokens to lending vaults\n    * @param self GMXTypes.Store\n    * @param repayTokenAAmt Amount of tokenA to repay in token decimals\n    * @param repayTokenBAmt Amount of tokenB to repay in token decimals\n  */\n  function repay(\n    GMXTypes.Store storage self,\n    uint256 repayTokenAAmt,\n    uint256 repayTokenBAmt\n  ) public {\n    if (repayTokenAAmt > 0) {\n      self.tokenALendingVault.repay(repayTokenAAmt);\n    }\n    if (repayTokenBAmt > 0) {\n      self.tokenBLendingVault.repay(repayTokenBAmt);\n    }\n  }\n\n  /**\n    * @notice Add liquidity to yield source\n    * @param self GMXTypes.Store\n    * @param alp GMXTypes.AddLiquidityParams\n    * @return depositKey\n  */\n  function addLiquidity(\n    GMXTypes.Store storage self,\n    GMXTypes.AddLiquidityParams memory alp\n  ) public returns (bytes32) {\n    return GMXWorker.addLiquidity(self, alp);\n  }\n\n  /**\n    * @notice Remove liquidity from yield source\n    * @param self GMXTypes.Store\n    * @param rlp GMXTypes.RemoveLiquidityParams\n    * @return withdrawKey\n  */\n  function removeLiquidity(\n    GMXTypes.Store storage self,\n    GMXTypes.RemoveLiquidityParams memory rlp\n  ) public returns (bytes32) {\n    return GMXWorker.removeLiquidity(self, rlp);\n  }\n\n  /**\n    * @notice Swap exact amount of tokenIn for as many possible amount of tokenOut\n    * @param self GMXTypes.Store\n    * @param sp ISwap.SwapParams\n    * @return amountOut in token decimals\n  */\n  function swapExactTokensForTokens(\n    GMXTypes.Store storage self,\n    ISwap.SwapParams memory sp\n  ) external returns (uint256) {\n    if (sp.amountIn > 0) {\n      return GMXWorker.swapExactTokensForTokens(self, sp);\n    } else {\n      return 0;\n    }\n  }\n\n  /**\n    * @notice Swap as little posible tokenIn for exact amount of tokenOut\n    * @param self GMXTypes.Store\n    * @param sp ISwap.SwapParams\n    * @return amountIn in token decimals\n  */\n  function swapTokensForExactTokens(\n    GMXTypes.Store storage self,\n    ISwap.SwapParams memory sp\n  ) external returns (uint256) {\n    if (sp.amountIn > 0) {\n      return GMXWorker.swapTokensForExactTokens(self, sp);\n    } else {\n      return 0;\n    }\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\nimport { GMXWorker } from \"./GMXWorker.sol\";\n\n/**\n  * @title GMXManager\n  * @author Steadefi\n  * @notice Re-usable library functions for calculations and operations of borrows, repays, swaps\n  * adding and removal of liquidity to yield source\n*/\nlibrary GMXManager {\n  using SafeERC20 for IERC20;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice Calculate if token swap is needed to ensure enough repayment for both tokenA and tokenB\n    * @notice Assume that after swapping one token for the other, there is still enough to repay both tokens\n    * @param self GMXTypes.Store\n    * @param rp GMXTypes.RepayParams\n    * @return swapNeeded boolean if swap is needed\n    * @return tokenFrom address of token to swap from\n    * @return tokenTo address of token to swap to\n    * @return tokenToAmt amount of tokenFrom to swap in token decimals\n  */\n  function calcSwapForRepay(\n    GMXTypes.Store storage self,\n    GMXTypes.RepayParams memory rp\n  ) external view returns (bool, address, address, uint256) {\n    address _tokenFrom;\n    address _tokenTo;\n    uint256 _tokenToAmt;\n\n    if (rp.repayTokenAAmt > self.tokenA.balanceOf(address(this))) {\n      // If more tokenA is needed for repayment\n      _tokenToAmt = rp.repayTokenAAmt - self.tokenA.balanceOf(address(this));\n      _tokenFrom = address(self.tokenB);\n      _tokenTo = address(self.tokenA);\n\n      return (true, _tokenFrom, _tokenTo, _tokenToAmt);\n    } else if (rp.repayTokenBAmt > self.tokenB.balanceOf(address(this))) {\n      // If more tokenB is needed for repayment\n      _tokenToAmt = rp.repayTokenBAmt - self.tokenB.balanceOf(address(this));\n      _tokenFrom = address(self.tokenA);\n      _tokenTo = address(self.tokenB);\n\n      return (true, _tokenFrom, _tokenTo, _tokenToAmt);\n    } else {\n      // If more there is enough to repay both tokens\n      return (false, address(0), address(0), 0);\n    }\n  }\n\n  /**\n    * @notice Calculate amount of tokenA and tokenB to borrow\n    * @param self GMXTypes.Store\n    * @param depositValue USD value in 1e18\n  */\n  function calcBorrow(\n    GMXTypes.Store storage self,\n    uint256 depositValue\n  ) external view returns (uint256, uint256) {\n    // Calculate final position value based on deposit value\n    uint256 _positionValue = depositValue * self.leverage / SAFE_MULTIPLIER;\n\n    // Obtain the value to borrow\n    uint256 _borrowValue = _positionValue - depositValue;\n\n    uint256 _tokenADecimals = IERC20Metadata(address(self.tokenA)).decimals();\n    uint256 _tokenBDecimals = IERC20Metadata(address(self.tokenB)).decimals();\n    uint256 _borrowLongTokenAmt;\n    uint256 _borrowShortTokenAmt;\n\n    // If delta is long, borrow all in short token\n    if (self.delta == GMXTypes.Delta.Long) {\n      _borrowShortTokenAmt = _borrowValue * SAFE_MULTIPLIER\n                             / GMXReader.convertToUsdValue(self, address(self.tokenB), 10**(_tokenBDecimals))\n                             / (10 ** (18 - _tokenBDecimals));\n    }\n\n    // If delta is neutral, borrow appropriate amount in long token to hedge, and the rest in short token\n    if (self.delta == GMXTypes.Delta.Neutral) {\n      // Get token weights in LP, e.g. 50% = 5e17\n      (uint256 _tokenAWeight,) = GMXReader.tokenWeights(self);\n\n      // Get value of long token (typically tokenA)\n      uint256 _longTokenWeightedValue = _tokenAWeight * _positionValue / SAFE_MULTIPLIER;\n\n      // Borrow appropriate amount in long token to hedge\n      _borrowLongTokenAmt = _longTokenWeightedValue * SAFE_MULTIPLIER\n                            / GMXReader.convertToUsdValue(self, address(self.tokenA), 10**(_tokenADecimals))\n                            / (10 ** (18 - _tokenADecimals));\n\n      // Borrow the shortfall value in short token\n      _borrowShortTokenAmt = (_borrowValue - _longTokenWeightedValue) * SAFE_MULTIPLIER\n                             / GMXReader.convertToUsdValue(self, address(self.tokenB), 10**(_tokenBDecimals))\n                             / (10 ** (18 - _tokenBDecimals));\n    }\n\n    return (_borrowLongTokenAmt, _borrowShortTokenAmt);\n  }\n\n  /**\n    * @notice Calculate amount of tokenA and tokenB to repay based on token shares ratio being withdrawn\n    * @param self GMXTypes.Store\n    * @param shareRatio Amount of vault token shares relative to total supply in 1e18\n  */\n  function calcRepay(\n    GMXTypes.Store storage self,\n    uint256 shareRatio\n  ) external view returns (uint256, uint256) {\n    (uint256 tokenADebtAmt, uint256 tokenBDebtAmt) = GMXReader.debtAmt(self);\n\n    uint256 _repayTokenAAmt = shareRatio * tokenADebtAmt / SAFE_MULTIPLIER;\n    uint256 _repayTokenBAmt = shareRatio * tokenBDebtAmt / SAFE_MULTIPLIER;\n\n    return (_repayTokenAAmt, _repayTokenBAmt);\n  }\n\n  /**\n    * @notice Calculate minimum market (GM LP) tokens to receive when adding liquidity\n    * @param self GMXTypes.Store\n    * @param depositValue USD value in 1e18\n    * @param slippage Slippage value in 1e4\n    * @return minMarketTokenAmt in 1e18\n  */\n  function calcMinMarketSlippageAmt(\n    GMXTypes.Store storage self,\n    uint256 depositValue,\n    uint256 slippage\n  ) external view returns (uint256) {\n    uint256 _lpTokenValue = self.gmxOracle.getLpTokenValue(\n      address(self.lpToken),\n      address(self.tokenA),\n      address(self.tokenA),\n      address(self.tokenB),\n      false,\n      false\n    );\n\n    return depositValue\n      * SAFE_MULTIPLIER\n      / _lpTokenValue\n      * (10000 - slippage) / 10000;\n  }\n\n  /**\n    * @notice Calculate minimum tokens to receive when removing liquidity\n    * @dev minLongToken and minShortToken should be the token which we want to receive\n    * after liquidity withdrawal and swap\n    * @param self GMXTypes.Store\n    * @param lpAmt Amt of lp tokens to remove liquidity in 1e18\n    * @param minLongToken Address of token to receive longToken in\n    * @param minShortToken Address of token to receive shortToken in\n    * @param slippage Slippage value in 1e4\n    * @return minTokenAAmt in 1e18\n    * @return minTokenBAmt in 1e18\n  */\n  function calcMinTokensSlippageAmt(\n    GMXTypes.Store storage self,\n    uint256 lpAmt,\n    address minLongToken,\n    address minShortToken,\n    uint256 slippage\n  ) external view returns (uint256, uint256) {\n    uint256 _withdrawValue = lpAmt\n      * self.gmxOracle.getLpTokenValue(\n        address(self.lpToken),\n        address(self.tokenA),\n        address(self.tokenA),\n        address(self.tokenB),\n        false,\n        false\n      )\n      / SAFE_MULTIPLIER;\n\n    (uint256 _tokenAWeight, uint256 _tokenBWeight) = GMXReader.tokenWeights(self);\n\n    uint256 _minLongTokenAmt = _withdrawValue\n      * _tokenAWeight / SAFE_MULTIPLIER\n      * SAFE_MULTIPLIER\n      / GMXReader.convertToUsdValue(\n        self,\n        minLongToken,\n        10**(IERC20Metadata(minLongToken).decimals())\n      )\n      / (10 ** (18 - IERC20Metadata(minLongToken).decimals()));\n\n    uint256 _minShortTokenAmt = _withdrawValue\n      * _tokenBWeight / SAFE_MULTIPLIER\n      * SAFE_MULTIPLIER\n      / GMXReader.convertToUsdValue(\n        self,\n        minShortToken,\n        10**(IERC20Metadata(minShortToken).decimals())\n      )\n      / (10 ** (18 - IERC20Metadata(minShortToken).decimals()));\n\n    return (\n      _minLongTokenAmt * (10000 - slippage) / 10000,\n      _minShortTokenAmt * (10000 - slippage) / 10000\n    );\n  }\n\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice Borrow tokens from lending vaults\n    * @param self GMXTypes.Store\n    * @param borrowTokenAAmt Amount of tokenA to borrow in token decimals\n    * @param borrowTokenBAmt Amount of tokenB to borrow in token decimals\n  */\n  function borrow(\n    GMXTypes.Store storage self,\n    uint256 borrowTokenAAmt,\n    uint256 borrowTokenBAmt\n  ) public {\n    if (borrowTokenAAmt > 0) {\n      self.tokenALendingVault.borrow(borrowTokenAAmt);\n    }\n    if (borrowTokenBAmt > 0) {\n      self.tokenBLendingVault.borrow(borrowTokenBAmt);\n    }\n  }\n\n  /**\n    * @notice Repay tokens to lending vaults\n    * @param self GMXTypes.Store\n    * @param repayTokenAAmt Amount of tokenA to repay in token decimals\n    * @param repayTokenBAmt Amount of tokenB to repay in token decimals\n  */\n  function repay(\n    GMXTypes.Store storage self,\n    uint256 repayTokenAAmt,\n    uint256 repayTokenBAmt\n  ) public {\n    if (repayTokenAAmt > 0) {\n      self.tokenALendingVault.repay(repayTokenAAmt);\n    }\n    if (repayTokenBAmt > 0) {\n      self.tokenBLendingVault.repay(repayTokenBAmt);\n    }\n  }\n\n  /**\n    * @notice Add liquidity to yield source\n    * @param self GMXTypes.Store\n    * @param alp GMXTypes.AddLiquidityParams\n    * @return depositKey\n  */\n  function addLiquidity(\n    GMXTypes.Store storage self,\n    GMXTypes.AddLiquidityParams memory alp\n  ) public returns (bytes32) {\n    return GMXWorker.addLiquidity(self, alp);\n  }\n\n  /**\n    * @notice Remove liquidity from yield source\n    * @param self GMXTypes.Store\n    * @param rlp GMXTypes.RemoveLiquidityParams\n    * @return withdrawKey\n  */\n  function removeLiquidity(\n    GMXTypes.Store storage self,\n    GMXTypes.RemoveLiquidityParams memory rlp\n  ) public returns (bytes32) {\n    return GMXWorker.removeLiquidity(self, rlp);\n  }\n\n  /**\n    * @notice Swap exact amount of tokenIn for as many possible amount of tokenOut\n    * @param self GMXTypes.Store\n    * @param sp ISwap.SwapParams\n    * @return amountOut in token decimals\n  */\n  function swapExactTokensForTokens(\n    GMXTypes.Store storage self,\n    ISwap.SwapParams memory sp\n  ) external returns (uint256) {\n    if (sp.amountIn > 0) {\n      return GMXWorker.swapExactTokensForTokens(self, sp);\n    } else {\n      return 0;\n    }\n  }\n\n  /**\n    * @notice Swap as little posible tokenIn for exact amount of tokenOut\n    * @param self GMXTypes.Store\n    * @param sp ISwap.SwapParams\n    * @return amountIn in token decimals\n  */\n  function swapTokensForExactTokens(\n    GMXTypes.Store storage self,\n    ISwap.SwapParams memory sp\n  ) external returns (uint256) {\n    if (sp.amountIn > 0) {\n      return GMXWorker.swapTokensForExactTokens(self, sp);\n    } else {\n      return 0;\n    }\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\nimport { GMXWorker } from \"./GMXWorker.sol\";\n\n/**\n  * @title GMXManager"
    }
  ]
}