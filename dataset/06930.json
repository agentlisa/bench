{
  "Title": "[4]",
  "Content": "Function `BytecodeCompressor.publishCompressedBytecode()` shouldn't be payable as it doesn't have any logic for transferred ETH. If users send eth by mistake their funds would be lost.\n```solidity\n    function publishCompressedBytecode(\n        bytes calldata _bytecode,\n        bytes calldata _rawCompressedData\n    ) external payable returns (bytes32 bytecodeHash) {\n```\nhttps://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/BytecodeCompressor.sol#L35-L38\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-03-zksync",
  "Code": [
    {
      "filename": "contracts/BytecodeCompressor.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IBytecodeCompressor.sol\";\nimport \"./Constants.sol\";\nimport \"./libraries/Utils.sol\";\nimport \"./libraries/UnsafeBytesCalldata.sol\";\n\n/**\n * @author Matter Labs\n * @notice Simple implementation of the compression algorithm specialized for zkEVM bytecode.\n * @dev Every deployed bytecode in zkEVM should be publicly restorable from the L1 data availability.\n * For this reason, the user may request the sequencer to publish the original bytecode and mark it as known.\n * Or the user may compress the bytecode and publish it instead (fewer data onchain!).\n */\ncontract BytecodeCompressor is IBytecodeCompressor {\n    using UnsafeBytesCalldata for bytes;\n\n    /// @notice Verify the compressed bytecode and publish it on the L1.\n    /// @param _bytecode The original bytecode to be verified against.\n    /// @param _rawCompressedData The compressed bytecode in a format of:\n    ///    - 2 bytes: the length of the dictionary\n    ///    - N bytes: the dictionary\n    ///    - M bytes: the encoded data\n    /// @dev The dictionary is a sequence of 8-byte chunks, each of them has the associated index.\n    /// @dev The encoded data is a sequence of 2-byte chunks, each of them is an index of the dictionary.\n    /// @dev The compression algorithm works as follows:\n    ///     1. The original bytecode is split into 8-byte chunks.\n    ///     Since the bytecode size is always a multiple of 32, this is always possible.\n    ///     2. For each 8-byte chunk in the original bytecode:\n    ///         * If the chunk is not already in the dictionary, it is added to the dictionary array.\n    ///         * If the dictionary becomes overcrowded (2^16 + 1 elements), the compression process will fail.\n    ///         * The 2-byte index of the chunk in the dictionary is added to the encoded data.\n    function publishCompressedBytecode(\n        bytes calldata _bytecode,\n        bytes calldata _rawCompressedData\n    ) external payable returns (bytes32 bytecodeHash) {\n        unchecked {\n            (bytes calldata dictionary, bytes calldata encodedData) = _decodeRawBytecode(_rawCompressedData);\n\n            require(dictionary.length % 8 == 0, \"Dictionary length should be a multiple of 8\");\n            require(dictionary.length <= 2 ** 16 * 8, \"Dictionary is too big\");\n            require(\n                encodedData.length * 4 == _bytecode.length,\n                \"Encoded data length should be 4 times shorter than the original bytecode\"\n            );\n\n            for (uint256 encodedDataPointer = 0; encodedDataPointer < encodedData.length; encodedDataPointer += 2) {\n                uint256 indexOfEncodedChunk = uint256(encodedData.readUint16(encodedDataPointer)) * 8;\n                require(indexOfEncodedChunk < dictionary.length, \"Encoded chunk index is out of bounds\");\n\n                uint64 encodedChunk = dictionary.readUint64(indexOfEncodedChunk);\n                uint64 realChunk = _bytecode.readUint64(encodedDataPointer * 4);\n\n                require(encodedChunk == realChunk, \"Encoded chunk does not match the original bytecode\");\n            }\n        }\n\n        bytecodeHash = Utils.hashL2Bytecode(_bytecode);\n\n        bytes32 rawCompressedDataHash = L1_MESSENGER_CONTRACT.sendToL1(_rawCompressedData);\n        KNOWN_CODE_STORAGE_CONTRACT.markBytecodeAsPublished(\n            bytecodeHash,\n            rawCompressedDataHash,\n            _rawCompressedData.length\n        );\n    }\n\n    /// @notice Decode the raw compressed data into the dictionary and the encoded data.\n    /// @param _rawCompressedData The compressed bytecode in a format of:\n    ///    - 2 bytes: the bytes length of the dictionary\n    ///    - N bytes: the dictionary\n    ///    - M bytes: the encoded data\n    function _decodeRawBytecode(\n        bytes calldata _rawCompressedData\n    ) internal pure returns (bytes calldata dictionary, bytes calldata encodedData) {\n        unchecked {\n            // The dictionary length can't be more than 2^16, so it fits into 2 bytes.\n            uint256 dictionaryLen = uint256(_rawCompressedData.readUint16(0));\n            dictionary = _rawCompressedData[2:2 + dictionaryLen * 8];\n            encodedData = _rawCompressedData[2 + dictionaryLen * 8:];\n        }\n    }\n}"
    }
  ]
}