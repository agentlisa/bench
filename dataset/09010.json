{
  "Title": "[M-05] `Bribe.sol` is not meant to handle fee-on-transfer tokens",
  "Content": "_Submitted by MiloTruck, also found by 0x52, Dravee, IllIllI, MaratCerby, unforgiven, and WatchPug_\n\n[Bribe.sol#L50-L51](https://github.com/code-423n4/2022-05-velodrome/blob/main/contracts/contracts/Bribe.sol#L50-L51)<br>\n[Bribe.sol#L83-L90](https://github.com/code-423n4/2022-05-velodrome/blob/main/contracts/contracts/Bribe.sol#L83-L90)<br>\n\nShould a fee-on-transfer token be added as a reward token and deposited, the tokens will be locked in the `Bribe` contract. Voters will be unable to withdraw their rewards.\n\n### Proof of Concept\n\nTokens are deposited into the `Bribe` contract using `notifyRewardAmount()`, where `amount` of tokens are transferred, then added directly to `tokenRewardsPerEpoch[token][adjustedTstamp]`:\n\n```js\n    _safeTransferFrom(token, msg.sender, address(this), amount);\n    tokenRewardsPerEpoch[token][adjustedTstamp] = epochRewards + amount;\n```\n\nTokens are transferred out of the `Bribe` contract using `deliverReward()`, which attempts to transfer `tokenRewardsPerEpoch[token][epochStart]` amount of tokens out.\n\n```js\nfunction deliverReward(address token, uint epochStart) external lock returns (uint) {\n    require(msg.sender == gauge);\n    uint rewardPerEpoch = tokenRewardsPerEpoch[token][epochStart];\n    if (rewardPerEpoch > 0) {\n        _safeTransfer(token, address(gauge), rewardPerEpoch);\n    }\n    return rewardPerEpoch;\n}\n```\n\nIf `token` happens to be a fee-on-transfer token, `deliverReward()` will always fail. For example:\n\n*   User calls `notifyRewardAmount()`, with `token` as token that charges a 2% fee upon any transfer, and `amount = 100`:\n    *   `_safeTransferFrom()` only transfers 98 tokens to the contract due to the 2% fee\n    *   Assuming `epochRewards = 0`, `tokenRewardsPerEpoch[token][adjustedTstamp]` becomes `100`\n*   Later on, when `deliverReward()` is called with the same `token` and `epochStart`:\n    *   `rewardPerEpoch = tokenRewardsPerEpoch[token][epochStart] = 100`\n    *   `_safeTransfer` attempts to transfer 100 tokens out of the contract\n    *   However, the contract only contains 98 tokens\n    *   `deliverReward()` reverts\n\nThe following test, which implements a [MockERC20 with fee-on-transfer](https://gist.github.com/MiloTruck/6fe0a13c4d08689b8be8a55b9b14e7e1), demonstrates this:\n\n```js\n// Note that the following test was adapted from Bribes.t.sol\nfunction testFailFeeOnTransferToken() public {\n    // Deploy ERC20 token with fee-on-transfer\n    MockERC20Fee FEE_TOKEN = new MockERC20Fee(\"FEE\", \"FEE\", 18);\n\n    // Mint FEE token for address(this)\n    FEE_TOKEN.mint(address(this), 1e25);\n    \n    // vote\n    VELO.approve(address(escrow), TOKEN_1);\n    escrow.create_lock(TOKEN_1, 4 * 365 * 86400);\n    vm.warp(block.timestamp + 1);\n\n    address[] memory pools = new address[](1);\n    pools[0] = address(pair);\n    uint256[] memory weights = new uint256[](1);\n    weights[0] = 10000;\n    voter.vote(1, pools, weights);\n\n    // and deposit into the gauge!\n    pair.approve(address(gauge), 1e9);\n    gauge.deposit(1e9, 1);\n\n    vm.warp(block.timestamp + 12 hours); // still prior to epoch start\n    vm.roll(block.number + 1);\n    assertEq(uint(gauge.getVotingStage(block.timestamp)), uint(Gauge.VotingStage.BribesPhase));\n\n    vm.warp(block.timestamp + 12 hours); // start of epoch\n    vm.roll(block.number + 1);\n    assertEq(uint(gauge.getVotingStage(block.timestamp)), uint(Gauge.VotingStage.VotesPhase));\n\n    vm.warp(block.timestamp + 5 days); // votes period over\n    vm.roll(block.number + 1);\n\n    vm.warp(2 weeks + 1); // emissions start\n    vm.roll(block.number + 1);\n\n    minter.update_period();\n    distributor.claim(1); // yay this works\n\n    vm.warp(block.timestamp + 1 days); // next votes period start\n    vm.roll(block.number + 1);\n\n    // get a bribe\n    owner.approve(address(FEE_TOKEN), address(bribe), TOKEN_1);\n    bribe.notifyRewardAmount(address(FEE_TOKEN), TOKEN_1);\n\n    vm.warp(block.timestamp + 5 days); // votes period over\n    vm.roll(block.number + 1);\n\n    // Atttempt to claim tokens will revert\n    voter.distro(); // bribe gets deposited in the gauge\n}\n```\n\n### Additional Impact\n\nOn a larger scale, a malicious attacker could temporarily DOS any `Gauge` contract. This can be done by:\n\n1.  Depositing a fee-on-transfer token into its respective `Bribe` contract, using `notifyRewardAmount()`, and adding it as a reward token.\n2.  This would cause `deliverBribes()` to fail whenever it is called, thus no one would be able to withdraw any reward tokens from the `Gauge` contract.\n\nThe only way to undo the DOS would be to call `swapOutBribeRewardToken()` and swap out the fee-on-transfer token for another valid token.\n\n### Recommended Mitigation\n\n*   The amount of tokens received should be added to `epochRewards` and stored in `tokenRewardsPerEpoch[token][adjustedTstamp]`, instead of the amount stated for transfer. For example:\n\n```js\n    uint256 _before = IERC20(token).balanceOf(address(this));\n    _safeTransferFrom(token, msg.sender, address(this), amount);\n    uint256 _after = IERC20(token).balanceOf(address(this));\n\n    tokenRewardsPerEpoch[token][adjustedTstamp] = epochRewards + (_after - _before);\n```\n\n*   Alternatively, disallow tokens with fee-on-transfer mechanics to be added as reward tokens.\n\n**[pooltypes (Velodrome) acknowledged and commented](https://github.com/code-423n4/2022-05-velodrome-findings/issues/222#issuecomment-1154094534):**\n > Reward tokens are now whitelisted in our mainnet deployment.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-05-velodrome-findings/issues/222#issuecomment-1169358825):**\n > The warden has shown how a feeOnTransfer token can cause accounting issues and cause a loss of rewards for end users.\n> \n> Because of the open-ended nature of the bribes contract, as well as the real risk of loss of promised rewards, I believe the finding to be valid and of Medium Severity.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-05-velodrome",
  "Code": [
    {
      "filename": "contracts/contracts/Bribe.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport './interfaces/IERC20.sol';\nimport './interfaces/IBribe.sol';\nimport './interfaces/IGauge.sol';\n\ncontract Bribe is IBribe {\n  uint internal constant DURATION = 5 days; // rewards are released over the voting period\n  uint internal constant BRIBE_LAG = 1 days;\n  uint internal constant COOLDOWN = 12 hours;\n  uint internal constant MAX_REWARD_TOKENS = 16;\n\n  address public gauge;\n  mapping(address => mapping(uint => uint)) public tokenRewardsPerEpoch;\n  address[] public rewards;\n  mapping(address => bool) public isReward;\n\n  event NotifyReward(address indexed from, address indexed reward, uint epoch, uint amount);\n\n  // simple re-entrancy check\n  uint internal _unlocked = 1;\n  modifier lock() {\n      require(_unlocked == 1);\n      _unlocked = 2;\n      _;\n      _unlocked = 1;\n  }\n\n  function setGauge(address _gauge) external {\n    require(gauge == address(0), \"gauge already set\");\n    gauge = _gauge;\n  }\n\n  function getEpochStart(uint timestamp) public view returns (uint) {\n    uint bribeStart = timestamp - (timestamp % (7 days)) + BRIBE_LAG;\n    uint bribeEnd = bribeStart + DURATION - COOLDOWN;\n    return timestamp < bribeEnd ? bribeStart : bribeStart + 7 days;\n  }\n\n  function notifyRewardAmount(address token, uint amount) external lock {\n      require(amount > 0);\n      if (!isReward[token]) {\n        require(rewards.length < MAX_REWARD_TOKENS, \"too many rewards tokens\");\n      }\n      // bribes kick in at the start of next bribe period\n      uint adjustedTstamp = getEpochStart(block.timestamp);\n      uint epochRewards = tokenRewardsPerEpoch[token][adjustedTstamp];\n\n      _safeTransferFrom(token, msg.sender, address(this), amount);\n      tokenRewardsPerEpoch[token][adjustedTstamp] = epochRewards + amount;\n\n      if (!isReward[token]) {\n          isReward[token] = true;\n          rewards.push(token);\n          IGauge(gauge).addBribeRewardToken(token);\n      }\n\n      emit NotifyReward(msg.sender, token, adjustedTstamp, amount);\n  }\n\n  function rewardsListLength() external view returns (uint) {\n      return rewards.length;\n  }\n\n  function addRewardToken(address token) external {\n    require(msg.sender == gauge);\n    if (!isReward[token]) {\n      require(rewards.length < MAX_REWARD_TOKENS, \"too many rewards tokens\");\n      isReward[token] = true;\n      rewards.push(token);\n    }\n  }\n\n  function swapOutRewardToken(uint i, address oldToken, address newToken) external {\n    require(msg.sender == gauge);\n    require(rewards[i] == oldToken);\n    isReward[oldToken] = false;\n    isReward[newToken] = true;\n    rewards[i] = newToken;\n  }\n\n  function deliverReward(address token, uint epochStart) external lock returns (uint) {\n    require(msg.sender == gauge);\n    uint rewardPerEpoch = tokenRewardsPerEpoch[token][epochStart];\n    if (rewardPerEpoch > 0) {\n      _safeTransfer(token, address(gauge), rewardPerEpoch);\n    }\n    return rewardPerEpoch;\n  }\n\n  function _safeTransfer(address token, address to, uint256 value) internal {\n      require(token.code.length > 0);\n      (bool success, bytes memory data) =\n      token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n      require(success && (data.length == 0 || abi.decode(data, (bool))));\n  }\n\n  function _safeTransferFrom(address token, address from, address to, uint256 value) internal {\n      require(token.code.length > 0);\n      (bool success, bytes memory data) =\n      token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n      require(success && (data.length == 0 || abi.decode(data, (bool))));\n  }\n}"
    },
    {
      "filename": "contracts/contracts/Bribe.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport './interfaces/IERC20.sol';\nimport './interfaces/IBribe.sol';\nimport './interfaces/IGauge.sol';\n\ncontract Bribe is IBribe {\n  uint internal constant DURATION = 5 days; // rewards are released over the voting period\n  uint internal constant BRIBE_LAG = 1 days;\n  uint internal constant COOLDOWN = 12 hours;\n  uint internal constant MAX_REWARD_TOKENS = 16;\n\n  address public gauge;\n  mapping(address => mapping(uint => uint)) public tokenRewardsPerEpoch;\n  address[] public rewards;\n  mapping(address => bool) public isReward;\n\n  event NotifyReward(address indexed from, address indexed reward, uint epoch, uint amount);\n\n  // simple re-entrancy check\n  uint internal _unlocked = 1;\n  modifier lock() {\n      require(_unlocked == 1);\n      _unlocked = 2;\n      _;\n      _unlocked = 1;\n  }\n\n  function setGauge(address _gauge) external {\n    require(gauge == address(0), \"gauge already set\");\n    gauge = _gauge;\n  }\n\n  function getEpochStart(uint timestamp) public view returns (uint) {\n    uint bribeStart = timestamp - (timestamp % (7 days)) + BRIBE_LAG;\n    uint bribeEnd = bribeStart + DURATION - COOLDOWN;\n    return timestamp < bribeEnd ? bribeStart : bribeStart + 7 days;\n  }\n\n  function notifyRewardAmount(address token, uint amount) external lock {\n      require(amount > 0);\n      if (!isReward[token]) {\n        require(rewards.length < MAX_REWARD_TOKENS, \"too many rewards tokens\");\n      }\n      // bribes kick in at the start of next bribe period\n      uint adjustedTstamp = getEpochStart(block.timestamp);\n      uint epochRewards = tokenRewardsPerEpoch[token][adjustedTstamp];\n\n      _safeTransferFrom(token, msg.sender, address(this), amount);\n      tokenRewardsPerEpoch[token][adjustedTstamp] = epochRewards + amount;\n\n      if (!isReward[token]) {\n          isReward[token] = true;\n          rewards.push(token);\n          IGauge(gauge).addBribeRewardToken(token);\n      }\n\n      emit NotifyReward(msg.sender, token, adjustedTstamp, amount);\n  }\n\n  function rewardsListLength() external view returns (uint) {\n      return rewards.length;\n  }\n\n  function addRewardToken(address token) external {\n    require(msg.sender == gauge);\n    if (!isReward[token]) {\n      require(rewards.length < MAX_REWARD_TOKENS, \"too many rewards tokens\");\n      isReward[token] = true;\n      rewards.push(token);\n    }\n  }\n\n  function swapOutRewardToken(uint i, address oldToken, address newToken) external {\n    require(msg.sender == gauge);\n    require(rewards[i] == oldToken);\n    isReward[oldToken] = false;\n    isReward[newToken] = true;\n    rewards[i] = newToken;\n  }\n\n  function deliverReward(address token, uint epochStart) external lock returns (uint) {\n    require(msg.sender == gauge);\n    uint rewardPerEpoch = tokenRewardsPerEpoch[token][epochStart];\n    if (rewardPerEpoch > 0) {\n      _safeTransfer(token, address(gauge), rewardPerEpoch);\n    }\n    return rewardPerEpoch;\n  }\n\n  function _safeTransfer(address token, address to, uint256 value) internal {\n      require(token.code.length > 0);\n      (bool success, bytes memory data) =\n      token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n      require(success && (data.length == 0 || abi.decode(data, (bool))));\n  }\n\n  function _safeTransferFrom(address token, address from, address to, uint256 value) internal {\n      require(token.code.length > 0);\n      (bool success, bytes memory data) =\n      token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n      require(success && (data.length == 0 || abi.decode(data, (bool))));\n  }\n}"
    }
  ]
}