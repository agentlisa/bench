{
  "Title": "[M-16] Suboptimal arbitrage implementation",
  "Content": "\nThe `bestArbAmountIn` estimated in [\\_bisectionSearch()](https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/arbitrage/ArbitrageSearch.sol#L101-L136) can be calculated with a simple formula. Roughly estimating `bestArbAmountIn` instead of deriving its exact value has the following consequences:\n\n1.  In some scenarios, arbitrage profits are missed completely.\n2.  In most cases, arbitrage profits are not optimal.\n3.  It could be profitable to sandwich-attack certain swaps. The pre-transaction would push the pools into scenario 1., then the post-transaction would recover the investment + arbitrage, capturing the arbitrage profits that were meant for the DAO.\n\nThis issue may look like a mere optimization. However, if the math presented next is correct, I'd argue that this is a medium issue. Built-in arbitrage is the main feature and competitive advantage of Salty.IO. Missing arbitrage profits due to a flawed implementation should not happen.\n\n### Proof of Concept\n\n**Notation**\n\nThe notation used is equal to the one found in the Salty.IO smart contracts, in particular in [ArbitrageSearch.sol](https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/arbitrage/ArbitrageSearch.sol). For convenience, $$reservesXN$$ is replaced with just $$XN$$. For example, $$A1$$ should be read as $$reservesA1$$.\n\nSome of the math steps were omitted to simplify this submission, but I invite you to verify the derivation of the formulas.\n\n**Max arbitrage profit formula**\n\nThe arbitrage function is given by $$f(a) = \\frac{n\\_1a}{n\\_2 + ma} - a$$, where:\n\n*   $$a$$ (a.k.a. `bestArbAmountIn`) is the amount of WETH to be \"sold\" for arbToken2 in the first step of the arbitrage path weth -> arbToken2 -> arbToken3 -> weth.\n*   $$n\\_1 = C1 \\* B1 \\* A1$$\n*   $$n\\_2 = C0 \\* B0 \\* A0$$\n*   $$m = C0 \\* B0 + C0 \\* A1 + B1 \\* A1$$\n\nNote that:\n\n1.  $$f(0) = 0$$\n2.  $$f(\\inf) = -\\inf$$\n3.  $$max{f(a)}\\_{a>0} > 0$$ only if $$n\\_1 > n\\_2$$. If this is not obvious at first sight, derive $$f$$ and find its roots for $$a>0$$.\n\nSo, when $$n\\_1 > n\\_2$$, we know there is an arbitrage opportunity which maximizes at:\n\n$$a = \\frac{\\sqrt{A0*A1*B0*B1*C0\\*C1} - n\\_2}{m}$$\n\nUsing similar methods as currently in PoolMath.sol, overflow can be avoided and the formula above can be used to execute the arbitrage feature optimally.\n\n**Missing arbitrage profits completely**\n\nSo far we've seen how to improve the arbitrage calculation to properly maximize profits. What's more interesting is that certain pools could get into states in which arbitrage opportunities are missed entirely. This should be concerning taking into account that built-in arbitrage is the main feature of the protocol and thus should always be available.\n\nLet $$a\\_0>0$$ be a root of the arbitrage function such that $$f(a\\_0)=0$$ and $$f(a>a\\_0)<0$$. The solution is given by $$a\\_0=\\frac{n\\_1-n\\_2}{m}$$. For simplicity, now assume that (i) the pools in the arbitrage path are balanced and (ii) a user wants to swap weth (let's call this amount $$x$$) for arbToken3. We are interested in finding a pool structure such that 1/128th of $$x$$ is greater than $$a\\_0$$. This would mean that the protocol's bisection search will test a range of $$f$$ which is not profitable, when there are actually values that are profitable.\n\nThe formula we get from the mentioned assumptions is:\n\n$$0\\<x<\\frac{C1}{127B1*A1}(C0*B0 + C0*A1 - 255B1*A1)$$\n\nwhich means that:\n\n$$C0>255\\frac{B1\\*A1}{A1+B0}$$\n\nThese conditions are a bit restrictive, but we can still find realistic scenarios in which they hold. To test the idea, add [these](https://gist.github.com/fnanni-0/6d0050cd00cd08194d714fe13c4443cb) functions to TestArbitrageSearch.sol and then add the [this](https://gist.github.com/fnanni-0/eef46ebd5f82c05291a5a55916bd9b90) test to TestArbitrageSearch.t.sol. In the tested example, the protocol misses profits at least in the range of 2-2000 ETH<>BTC swaps for the given pools state.\n\n### Recommended Mitigation Steps\n\nConsider replacing \\_bisectionSearch() with something similar to [computeBestArbitrage()](https://gist.github.com/fnanni-0/6d0050cd00cd08194d714fe13c4443cb). Beware that computeBestArbitrage() is not overflow-proof.\n\n**[othernet-global (Salty.IO) confirmed and commented](https://github.com/code-423n4/2024-01-salty-findings/issues/419#issuecomment-1935238212):**\n > Works great! Thank you!\n> \n> I modified the calculations to reduce overflow risk:\n> \n> \t\t\tuint256 n0 = A0 * B0 * C0;\n> \t\t\tuint256 n1 = A1 * B1 * C1;\n> \t\t\tif (n1 <= n0)\n> \t\t\t\treturn 0;\n> \n> \t\t\tuint256 m = A1 * ( B1 + C0 ) + C0 * B0;\n> \t\t\tuint256 z = PoolMath._sqrt( (n0 / m) * (n1 / m) );\n> \n> \t\t\tbestArbAmountIn = z - n0 / m;\n\n > Added an MSB shift to prevent overflow:\n> https://github.com/othernet-global/salty-io/commit/a54656dd18135ca57eef7c4bf615b7cdff2613a7\n> https://github.com/othernet-global/salty-io/commit/53feaeb0d335bd33803f98db022871b48b3f2454\n> \n> \n> \n> \t\tuint256 maximumMSB = _maximumReservesMSB( A0, A1, B0, B1, C0, C1 );\n> \n> \t\t\t// Assumes the largest number should use no more than 80 bits.\n> \t\t\t// Multiplying three 80 bit numbers will yield 240 bits - within the 256 bit limit.\n> \t\t\tuint256 shift = 0;\n> \t\t\tif ( maximumMSB > 80 )\n> \t\t\t\t{\n> \t\t\t\tshift = maximumMSB - 80;\n> \n> \t\t\t\tA0 = A0 >> shift;\n> \t\t\t\tA1 = A1 >> shift;\n> \t\t\t\tB0 = B0 >> shift;\n> \t\t\t\tB1 = B1 >> shift;\n> \t\t\t\tC0 = C0 >> shift;\n> \t\t\t\tC1 = C1 >> shift;\n> \t\t\t\t}\n> \n> \t\t\t// Each variable will use less than 80 bits\n> \t\t\tuint256 n0 = A0 * B0 * C0;\n> \t\t\tuint256 n1 = A1 * B1 * C1;\n> \n> \t\t\tif (n1 <= n0)\n> \t\t\t\treturn 0;\n> \n> \t\t\tuint256 m = A1 *  B1 + C0 * ( B0 + A1 );\n> \n> \t\t\t// Calculating n0 * n1 directly would overflow under some situations.\n> \t\t\t// Multiply the sqrt's instead - effectively keeping the max size the same\n> \t\t\tuint256 z = Math.sqrt(n0) * Math.sqrt(n1);\n> \n> \t\t\tbestArbAmountIn = ( z - n0 ) / m;\n> \t\t\t\n> \t\t\t\n\n**[Picodes (Judge) commented](https://github.com/code-423n4/2024-01-salty-findings/issues/419#issuecomment-1952924257):**\n > Considering the value-added for the sponsor and the fact that this report:\n>  - Is actually saving funds for the protocol\n>  - Shows that a functionality is in some specific case broken (which we know as the bisection search isn't exact) could be fixed relatively easily\n> \n> I think Med severity is appropriate.\n\n**Status:** Mitigated with an Error. Full details in report from [zzebra83](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/101), and also included in the [Mitigation Review](#mitigation-review) section below.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-01-salty",
  "Code": [
    {
      "filename": "src/arbitrage/ArbitrageSearch.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"../interfaces/IExchangeConfig.sol\";\nimport \"../pools/PoolUtils.sol\";\n\n\n// Finds a circular path after a user's swap has occurred (from WETH to WETH in this case) that results in an arbitrage profit.\nabstract contract ArbitrageSearch\n    {\n\tIERC20 immutable public wbtc;\n\tIERC20 immutable public weth;\n\tISalt immutable public salt;\n\n\t// Used to estimate the point just to the right of the midpoint\n   \tuint256 constant public MIDPOINT_PRECISION = 0.001e18; // .001 ETH precision for arb search\n\n\n    constructor( IExchangeConfig _exchangeConfig )\n    \t{\n\t\t// Cached for efficiency\n\t\twbtc = _exchangeConfig.wbtc();\n\t\tweth = _exchangeConfig.weth();\n\t\tsalt = _exchangeConfig.salt();\n    \t}\n\n\n\t// Returns the middle two tokens in an arbitrage path that starts and ends with WETH.\n\t// The WETH tokens at the beginning and end of the path are not returned as they are always the same.\n\t// Full arbitrage cycle is: WETH->arbToken2->arbToken3->WETH\n\tfunction _arbitragePath( IERC20 swapTokenIn, IERC20 swapTokenOut ) internal view returns (IERC20 arbToken2, IERC20 arbToken3)\n\t\t{\n\t\t// swap: WBTC->WETH\n        // arb: WETH->WBTC->SALT->WETH\n\t\tif ( address(swapTokenIn) == address(wbtc))\n\t\tif ( address(swapTokenOut) == address(weth))\n\t\t\treturn (wbtc, salt);\n\n\t\t// swap: WETH->WBTC\n        // arb: WETH->SALT->WBTC->WETH\n\t\tif ( address(swapTokenIn) == address(weth))\n\t\tif ( address(swapTokenOut) == address(wbtc))\n\t\t\treturn (salt, wbtc);\n\n\t\t// swap: WETH->swapTokenOut\n        // arb: WETH->WBTC->swapTokenOut->WETH\n\t\tif ( address(swapTokenIn) == address(weth))\n\t\t\treturn (wbtc, swapTokenOut);\n\n\t\t// swap: swapTokenIn->WETH\n        // arb: WETH->swapTokenIn->WBTC->WETH\n\t\tif ( address(swapTokenOut) == address(weth))\n\t\t\treturn (swapTokenIn, wbtc);\n\n\t\t// swap: swapTokenIn->swapTokenOut\n        // arb: WETH->swapTokenOut->swapTokenIn->WETH\n\t\treturn (swapTokenOut, swapTokenIn);\n\t\t}\n\n\n\t// Given the reserves for the arbitrage swap, determine if right of the midpoint looks to be more profitable than the midpoint itself.\n\t// Used as a substitution for the overly complex derivative in order to determine which direction the optimal arbitrage amountIn is more likely to be.\n\tfunction _rightMoreProfitable( uint256 midpoint, uint256 reservesA0, uint256 reservesA1, uint256 reservesB0, uint256 reservesB1, uint256 reservesC0, uint256 reservesC1 ) internal pure returns (bool rightMoreProfitable)\n\t\t{\n\t\tunchecked\n\t\t\t{\n\t\t\t// Calculate the AMM output of the midpoint\n\t\t\tuint256 amountOut = (reservesA1 * midpoint) / (reservesA0 + midpoint);\n\t\t\tamountOut = (reservesB1 * amountOut) / (reservesB0 + amountOut);\n\t\t\tamountOut = (reservesC1 * amountOut) / (reservesC0 + amountOut);\n\n\t\t\tint256 profitMidpoint = int256(amountOut) - int256(midpoint);\n\n\t\t\t// If the midpoint isn't profitable then we can remove the right half the range as nothing there will be profitable there either.\n\t\t\tif ( profitMidpoint < int256(PoolUtils.DUST) )\n\t\t\t\treturn false;\n\n\n\t\t\t// Calculate the AMM output of a point just to the right of the midpoint\n\t\t\tmidpoint += MIDPOINT_PRECISION;\n\n\t\t\tamountOut = (reservesA1 * midpoint) / (reservesA0 + midpoint);\n\t\t\tamountOut = (reservesB1 * amountOut) / (reservesB0 + amountOut);\n\t\t\tamountOut = (reservesC1 * amountOut) / (reservesC0 + amountOut);\n\n\t\t\tint256 profitRightOfMidpoint = int256(amountOut) - int256(midpoint);\n\n\t\t\treturn profitRightOfMidpoint > profitMidpoint;\n\t\t\t}\n\t\t}\n\n\n\t// Perform iterative bisection to search for the bestArbAmountIn in a range of 1/128th to 125% of swapAmountInValueInETH.\n\t// The search loop determines profits at the midpoint of the current range, and also just to the right of the midpoint.\n\t// Assuming that the profit function is unimodal (has only one peak), the two profit calculations can show us which half of the range the maximum profit is in (where to keep looking).\n\t//\n\t// The unimodal assumption has been tested with fuzzing (see ArbitrageSearch.t.sol) and looks to return optimum bestArbAmountIn within 1% of a brute force search method for fuzzed uint112 size reserves.\n\t// Additionally, fuzzing and testing reveal that the non-overflow assumptions are valid if the assumption is made that reserves do not exceed uint112.max.\n   \t// The uint112 size would allow tokens with 18 decimals of precision and a 5 quadrillion max supply - which is excluded from the whitelist process.\n   \t// Additionally, for tokens that may increase total supply over time, these calculations are duplicated with overflow checking intact within Pools._arbitrage() when arbitrage actually occurs.\n\tfunction _bisectionSearch( uint256 swapAmountInValueInETH, uint256 reservesA0, uint256 reservesA1, uint256 reservesB0, uint256 reservesB1, uint256 reservesC0, uint256 reservesC1 ) internal pure returns (uint256 bestArbAmountIn)\n\t\t{\n\t\t// This code can safely be made unchecked as the functionality for the found bestArbAmountIn is duplicated exactly in Pools._arbitrage with overflow checks kept in place.\n\t\t// If any overflows occur as a result of the calculations here they will happen in the Pools._arbitrage code.\n\t\tunchecked\n\t\t\t{\n\t\t\tif ( reservesA0 <= PoolUtils.DUST || reservesA1 <= PoolUtils.DUST || reservesB0 <= PoolUtils.DUST || reservesB1 <= PoolUtils.DUST || reservesC0 <= PoolUtils.DUST || reservesC1 <= PoolUtils.DUST )\n\t\t\t\treturn 0;\n\n\t\t\t// Search bestArbAmountIn in a range from 1/128th to 125% of swapAmountInValueInETH.\n\t\t\tuint256 leftPoint = swapAmountInValueInETH >> 7;\n\t\t\tuint256 rightPoint = swapAmountInValueInETH + (swapAmountInValueInETH >> 2); // 100% + 25% of swapAmountInValueInETH\n\n\t\t\t// Cost is about 492 gas per loop iteration\n\t\t\tfor( uint256 i = 0; i < 8; i++ )\n\t\t\t\t{\n\t\t\t\tuint256 midpoint = (leftPoint + rightPoint) >> 1;\n\n\t\t\t\t// Right of midpoint is more profitable?\n\t\t\t\tif ( _rightMoreProfitable( midpoint, reservesA0, reservesA1, reservesB0, reservesB1, reservesC0, reservesC1 ) )\n\t\t\t\t\tleftPoint = midpoint;\n\t\t\t\telse\n\t\t\t\t\trightPoint = midpoint;\n\t\t\t\t}\n\n\t\t\tbestArbAmountIn = (leftPoint + rightPoint) >> 1;\n\n\t\t\t// Make sure bestArbAmountIn is actually profitable (taking into account precision errors)\n\t\t\tuint256 amountOut = (reservesA1 * bestArbAmountIn) / (reservesA0 + bestArbAmountIn);\n\t\t\tamountOut = (reservesB1 * amountOut) / (reservesB0 + amountOut);\n\t\t\tamountOut = (reservesC1 * amountOut) / (reservesC0 + amountOut);\n\n\t\t\tif ( ( int256(amountOut) - int256(bestArbAmountIn) ) < int256(PoolUtils.DUST) )\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}"
    }
  ]
}