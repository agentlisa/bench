{
  "Title": "[H-19] Migration can permanently fail if user specifies different lengths for `selectors` and `plugins`",
  "Content": "_Submitted by scaraven, also found by berndartmueller_\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L73-L82>\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L72-L99>\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L174>\n\n### Impact\n\nIn `propose()` in Migration.sol, there is no check that the lengths of the `selectors` and `plugins` arrays are the same. This means that if a migration is successful, the `install()` function in Vault.sol could revert beacuse we access an array out of bounds. This prevents a new vault being created thereby permanently locking assets inside the vault.\n\n### Proof of Concept\n\n1.  User starts a new migration proposal where `selectors.length != plugins.length`\n2.  Enough users join proposal and the buyout bid starts\n3.  Buyout bid is successful and migration starts with `settleVault()`\n4.  A new vault is cloned with `create()` -> `registry.deployFor()` -> `vault.install(selectors, plugins)`\n5.  a. If `selectors.length > plugins.length` then we get an out of bounds error and transaction reverts\\\n    b. If `selectors.length < plugins.length` then the excess values in `plugins` is ignored which is tolerable\n6.  In scenario a., the migration fails and a new migration cannot start so assets in the vault are permanently locked\n\nThis may seem quite circumstantial as this problem only occurs if a user specifies `selectors` and `plugins` wrongly however it is very easy for an attacker to perform this maliciously with no cost on their behalf, it is highly unlikely that users will be able to spot a malicious migration.\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nConsider adding a check in `propose()` to make sure that the lengths match i.e.\n\n```solidity\nfunction propose(\n        address _vault,\n        address[] calldata _modules,\n        address[] calldata _plugins,\n        bytes4[] calldata _selectors,\n        uint256 _newFractionSupply,\n        uint256 _targetPrice\n    ) external {\n        // @Audit Make sure that selectors and plugins match\n        require(_selectors.length == _plugins.length, \"Plugin lengths do not match\");\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not inactive\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n\n        // Initializes migration proposal info\n        Proposal storage proposal = migrationInfo[_vault][++nextId];\n        proposal.startTime = block.timestamp;\n        proposal.targetPrice = _targetPrice;\n        proposal.modules = _modules;\n        proposal.plugins = _plugins;\n        proposal.selectors = _selectors;\n        proposal.oldFractionSupply = IVaultRegistry(registry).totalSupply(\n            _vault\n        );\n        proposal.newFractionSupply = _newFractionSupply;\n    }\n```\n\nAdditionally, I would suggest adding such a check in the `install()` function as this may prevent similiar problems if new modules are added.\n\n**[stevennevins (Fractional) confirmed](https://github.com/code-423n4/2022-07-fractional-findings/issues/115)**\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-07-fractional-findings/issues/115#issuecomment-1214467110):**\n > A misconfiguration of a migration can result in permanently locked up funds. Agree with High risk here.\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-07-fractional-v2-contest",
  "Code": [
    {
      "filename": "src/Vault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {MerkleProof} from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport {NFTReceiver} from \"./utils/NFTReceiver.sol\";\n\n/// @title Vault\n/// @author Fractional Art\n/// @notice Proxy contract for storing fractionalized assets\ncontract Vault is IVault, NFTReceiver {\n    /// @notice Address of vault owner\n    address public owner;\n    /// @notice Merkle root hash of vault permissions\n    bytes32 public merkleRoot;\n    /// @notice Initializer value\n    uint256 public nonce;\n    /// @dev Minimum reserve of gas units\n    uint256 private constant MIN_GAS_RESERVE = 5_000;\n    /// @notice Mapping of function selector to plugin address\n    mapping(bytes4 => address) public methods;\n\n    /// @dev Initializes nonce and proxy owner\n    function init() external {\n        if (nonce != 0) revert Initialized(owner, msg.sender, nonce);\n        nonce = 1;\n        owner = msg.sender;\n        emit TransferOwnership(address(0), msg.sender);\n    }\n\n    /// @dev Callback for receiving Ether when the calldata is empty\n    receive() external payable {}\n\n    /// @dev Callback for handling plugin transactions\n    /// @param _data Transaction data\n    /// @return response Return data from executing plugin\n    // prettier-ignore\n    fallback(bytes calldata _data) external payable returns (bytes memory response) {\n        address plugin = methods[msg.sig];\n        (,response) = _execute(plugin, _data);\n    }\n\n    /// @notice Executes vault transactions through delegatecall\n    /// @param _target Target address\n    /// @param _data Transaction data\n    /// @param _proof Merkle proof of permission hash\n    /// @return success Result status of delegatecall\n    /// @return response Return data of delegatecall\n    function execute(\n        address _target,\n        bytes calldata _data,\n        bytes32[] calldata _proof\n    ) external payable returns (bool success, bytes memory response) {\n        bytes4 selector;\n        assembly {\n            selector := calldataload(_data.offset)\n        }\n\n        // Generate leaf node by hashing module, target and function selector.\n        bytes32 leaf = keccak256(abi.encode(msg.sender, _target, selector));\n        // Check that the caller is either a module with permission to call or the owner.\n        if (!MerkleProof.verify(_proof, merkleRoot, leaf)) {\n            if (msg.sender != owner)\n                revert NotAuthorized(msg.sender, _target, selector);\n        }\n\n        (success, response) = _execute(_target, _data);\n    }\n\n    /// @notice Installs plugin by setting function selector to contract address\n    /// @param _selectors List of function selectors\n    /// @param _plugins Addresses of plugin contracts\n    function install(bytes4[] memory _selectors, address[] memory _plugins)\n        external\n    {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        uint256 length = _selectors.length;\n        for (uint256 i = 0; i < length; i++) {\n            methods[_selectors[i]] = _plugins[i];\n        }\n        emit InstallPlugin(_selectors, _plugins);\n    }\n\n    /// @notice Sets merkle root of vault permissions\n    /// @param _rootHash Hash of merkle root\n    function setMerkleRoot(bytes32 _rootHash) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        merkleRoot = _rootHash;\n    }\n\n    /// @notice Transfers ownership to given account\n    /// @param _newOwner Address of new owner\n    function transferOwnership(address _newOwner) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        owner = _newOwner;\n        emit TransferOwnership(msg.sender, _newOwner);\n    }\n\n    /// @notice Uninstalls plugin by setting function selector to zero address\n    /// @param _selectors List of function selectors\n    function uninstall(bytes4[] memory _selectors) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        uint256 length = _selectors.length;\n        for (uint256 i = 0; i < length; i++) {\n            methods[_selectors[i]] = address(0);\n        }\n        emit UninstallPlugin(_selectors);\n    }\n\n    /// @notice Executes plugin transactions through delegatecall\n    /// @param _target Target address\n    /// @param _data Transaction data\n    /// @return success Result status of delegatecall\n    /// @return response Return data of delegatecall\n    function _execute(address _target, bytes calldata _data)\n        internal\n        returns (bool success, bytes memory response)\n    {\n        // Check that the target is a valid contract\n        uint256 codeSize;\n        assembly {\n            codeSize := extcodesize(_target)\n        }\n        if (codeSize == 0) revert TargetInvalid(_target);\n        // Save the owner address in memory to ensure that it cannot be modified during the DELEGATECALL\n        address owner_ = owner;\n        // Reserve some gas to ensure that the function has enough to finish the execution\n        uint256 stipend = gasleft() - MIN_GAS_RESERVE;\n\n        // Delegate call to the target contract\n        (success, response) = _target.delegatecall{gas: stipend}(_data);\n        if (owner_ != owner) revert OwnerChanged(owner_, owner);\n\n        // Revert if execution was unsuccessful\n        if (!success) {\n            if (response.length == 0) revert ExecutionReverted();\n            _revertedWithReason(response);\n        }\n    }\n\n    /// @notice Reverts transaction with reason\n    function _revertedWithReason(bytes memory _response) internal pure {\n        assembly {\n            let returndata_size := mload(_response)\n            revert(add(32, _response), returndata_size)\n        }\n    }\n}"
    },
    {
      "filename": "src/modules/Migration.sol",
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.13;\n\nimport {IBuyout, Auction, State} from \"../interfaces/IBuyout.sol\";\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport {IERC721} from \"../interfaces/IERC721.sol\";\nimport {IERC1155} from \"../interfaces/IERC1155.sol\";\nimport {IFERC1155} from \"../interfaces/IFERC1155.sol\";\nimport {IMigration, Proposal} from \"../interfaces/IMigration.sol\";\nimport {IModule} from \"../interfaces/IModule.sol\";\nimport {IVault} from \"../interfaces/IVault.sol\";\nimport {IVaultRegistry, Permission} from \"../interfaces/IVaultRegistry.sol\";\nimport {MerkleBase} from \"../utils/MerkleBase.sol\";\nimport {Minter} from \"./Minter.sol\";\nimport {Multicall} from \"../utils/Multicall.sol\";\nimport {NFTReceiver} from \"../utils/NFTReceiver.sol\";\nimport {ReentrancyGuard} from \"@rari-capital/solmate/src/utils/ReentrancyGuard.sol\";\n\n/// @title Migration\n/// @author Fractional Art\n/// @notice Module contract for vaults to migrate to a new set of permissions\n/// - A fractional holder creates a proposal with a target price and list of modules\n/// - For 7 days, users can contribute their fractions / ether to signal support\n/// - If the target price is reached then a buyout can be triggered and trading\n///   against the proposed buyout price can take place to resolve the outcome\n/// - If a proposal holds more than 51% of the total supply, the buyout succeeds, a new vault can\n///   be created and the underlying assets (ERC-20, ERC-721 and ERC-1155 tokens) can be migrated\ncontract Migration is\n    IMigration,\n    MerkleBase,\n    Minter,\n    Multicall,\n    NFTReceiver,\n    ReentrancyGuard\n{\n    /// @notice Address of Buyout module contract\n    address payable public buyout;\n    /// @notice Address of VaultRegistry contract\n    address public registry;\n    /// @notice Counter used to assign IDs to new proposals\n    uint256 public nextId;\n    /// @notice The length for the migration proposal period\n    uint256 public constant PROPOSAL_PERIOD = 7 days;\n    /// @notice Mapping of a vault to it's proposal migration information\n    mapping(address => mapping(uint256 => Proposal)) public migrationInfo;\n    /// @notice Mapping of a proposal ID to a user's ether contribution\n    mapping(uint256 => mapping(address => uint256)) private userProposalEth;\n    /// @notice Mapping of a proposal ID to a user's fractions contribution\n    mapping(uint256 => mapping(address => uint256))\n        private userProposalFractions;\n\n    /// @notice Initializes buyout, registry, and supply contracts\n    constructor(\n        address _buyout,\n        address _registry,\n        address _supply\n    ) Minter(_supply) {\n        buyout = payable(_buyout);\n        registry = _registry;\n    }\n\n    /// @dev Callback for receiving ether when the calldata is empty\n    receive() external payable {}\n\n    /// @notice Proposes a set of modules and plugins to migrate a vault to\n    /// @param _vault Address of the vault\n    /// @param _modules Addresses of module contracts\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of plugin function selectors\n    /// @param _newFractionSupply New supply of fractional tokens\n    /// @param _targetPrice Target price of the buyout\n    function propose(\n        address _vault,\n        address[] calldata _modules,\n        address[] calldata _plugins,\n        bytes4[] calldata _selectors,\n        uint256 _newFractionSupply,\n        uint256 _targetPrice\n    ) external {\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not inactive\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n\n        // Initializes migration proposal info\n        Proposal storage proposal = migrationInfo[_vault][++nextId];\n        proposal.startTime = block.timestamp;\n        proposal.targetPrice = _targetPrice;\n        proposal.modules = _modules;\n        proposal.plugins = _plugins;\n        proposal.selectors = _selectors;\n        proposal.oldFractionSupply = IVaultRegistry(registry).totalSupply(\n            _vault\n        );\n        proposal.newFractionSupply = _newFractionSupply;\n    }\n\n    /// @notice Joins a migration proposal by contributing ether and fractional tokens\n    /// @param _vault The address of the vault\n    /// @param _proposalId ID of the proposal being contributed to\n    /// @param _amount Number of fractions being contributed\n    function join(\n        address _vault,\n        uint256 _proposalId,\n        uint256 _amount\n    ) external payable nonReentrant {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not inactive\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n\n        // Gets the migration proposal for the given ID\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        // Updates ether balances of the proposal and caller\n        proposal.totalEth += msg.value;\n        userProposalEth[_proposalId][msg.sender] += msg.value;\n        // Deposits fractional tokens into contract\n        IFERC1155(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            id,\n            _amount,\n            \"\"\n        );\n        // Updates fraction balances of the proposal and caller\n        proposal.totalFractions += _amount;\n        userProposalFractions[_proposalId][msg.sender] += _amount;\n    }\n\n    /// @notice Leaves a proposed migration with contribution amount\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal being left\n    function leave(address _vault, uint256 _proposalId) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not inactive\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n\n        // Gets the migration proposal for the given ID\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        // Updates fraction balances of the proposal and caller\n        uint256 amount = userProposalFractions[_proposalId][msg.sender];\n        proposal.totalFractions -= amount;\n        userProposalFractions[_proposalId][msg.sender] = 0;\n        // Updates ether balances of the proposal and caller\n        uint256 ethAmount = userProposalEth[_proposalId][msg.sender];\n        proposal.totalEth -= ethAmount;\n        userProposalEth[_proposalId][msg.sender] = 0;\n\n        // Withdraws fractions from contract back to caller\n        IFERC1155(token).safeTransferFrom(\n            address(this),\n            msg.sender,\n            id,\n            amount,\n            \"\"\n        );\n        // Withdraws ether from contract back to caller\n        payable(msg.sender).transfer(ethAmount);\n    }\n\n    /// @notice Kicks off the buyout process for a migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal being committed to\n    /// @return started Bool status of starting the buyout process\n    function commit(address _vault, uint256 _proposalId)\n        external\n        returns (bool started)\n    {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not inactive\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n        // Reverts if migration is passed proposal period\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        if (block.timestamp > proposal.startTime + PROPOSAL_PERIOD)\n            revert ProposalOver();\n\n        // Calculates current price of the proposal based on total supply\n        uint256 currentPrice = _calculateTotal(\n            100,\n            IVaultRegistry(registry).totalSupply(_vault),\n            proposal.totalEth,\n            proposal.totalFractions\n        );\n\n        // Checks if the current price is greater than target price of the proposal\n        if (currentPrice > proposal.targetPrice) {\n            // Sets token approval to the buyout contract\n            IFERC1155(token).setApprovalFor(address(buyout), id, true);\n            // Starts the buyout process\n            IBuyout(buyout).start{value: proposal.totalEth}(_vault);\n            proposal.isCommited = true;\n            started = true;\n        }\n    }\n\n    /// @notice Settles a migration by ending the buyout\n    /// @dev Succeeds if buyout goes through, fails otherwise\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal being settled\n    function settleVault(address _vault, uint256 _proposalId) external {\n        // Reverts if the migration was not proposed\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        if (!(proposal.isCommited)) revert NotProposed();\n        // Reverts if the migration was unsuccessful\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        if (current != State.SUCCESS) revert UnsuccessfulMigration();\n        // Reverts if the new vault has already been deployed\n        if (proposal.newVault != address(0))\n            revert NewVaultAlreadyDeployed(proposal.newVault);\n\n        // Gets the merkle root for the vault and given proposal ID\n        bytes32[] memory merkleTree = generateMerkleTree(proposal.modules);\n        bytes32 merkleRoot = getRoot(merkleTree);\n        // Deploys a new vault with set permissions and plugins\n        address newVault = IVaultRegistry(registry).create(\n            merkleRoot,\n            proposal.plugins,\n            proposal.selectors\n        );\n        // Sets address of the newly deployed vault\n        proposal.newVault = newVault;\n        // Emits event for settling the new vault\n        emit VaultMigrated(\n            _vault,\n            newVault,\n            _proposalId,\n            proposal.modules,\n            proposal.plugins,\n            proposal.selectors\n        );\n    }\n\n    /// @notice Mints the fractional tokens for a new vault\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _mintProof Merkle proof for minting fractional tokens\n    function settleFractions(\n        address _vault,\n        uint256 _proposalId,\n        bytes32[] calldata _mintProof\n    ) external {\n        // Reverts if the migration was unsuccessful\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        if (current != State.SUCCESS) revert UnsuccessfulMigration();\n        // Reverts if there is no new vault to migrate to\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        if (proposal.newVault == address(0)) revert NoVaultToMigrateTo();\n        // Reverts if fractions of the new vault have already been minted\n        if (proposal.fractionsMigrated) revert NewFractionsAlreadyMinted();\n\n        // Mints initial supply of fractions for the new vault\n        _mintFractions(\n            proposal.newVault,\n            address(this),\n            proposal.newFractionSupply,\n            _mintProof\n        );\n\n        migrationInfo[_vault][_proposalId].fractionsMigrated = true;\n        // Emits event for minting fractional tokens for the new vault\n        emit FractionsMigrated(\n            _vault,\n            proposal.newVault,\n            _proposalId,\n            proposal.newFractionSupply\n        );\n    }\n\n    /// @notice Retrieves ether and fractions deposited from an unsuccessful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the failed proposal\n    function withdrawContribution(address _vault, uint256 _proposalId)\n        external\n    {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if caller has no fractional balance to withdraw\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        if (\n            current != State.INACTIVE ||\n            migrationInfo[_vault][_proposalId].newVault != address(0)\n        ) revert NoContributionToWithdraw();\n\n        // Temporarily store user's fractions for the transfer\n        uint256 userFractions = userProposalFractions[_proposalId][msg.sender];\n        // Updates fractional balance of caller\n        userProposalFractions[_proposalId][msg.sender] = 0;\n        // Withdraws fractional tokens from contract back to caller\n        IFERC1155(token).safeTransferFrom(\n            address(this),\n            msg.sender,\n            id,\n            userFractions,\n            \"\"\n        );\n\n        // Temporarily store user's eth for the transfer\n        uint256 userEth = userProposalEth[_proposalId][msg.sender];\n        // Udpates ether balance of caller\n        userProposalEth[_proposalId][msg.sender] = 0;\n        // Withdraws ether from contract back to caller\n        payable(msg.sender).transfer(userEth);\n    }\n\n    /// @notice Migrates an ERC-20 token to the new vault after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _token Address of the ERC-20 token\n    /// @param _amount Transfer amount\n    /// @param _erc20TransferProof Merkle proof for transferring an ERC-20 token\n    function migrateVaultERC20(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256 _amount,\n        bytes32[] calldata _erc20TransferProof\n    ) external {\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        // Withdraws an ERC-20 token from the old vault and transfers to the new vault\n        IBuyout(buyout).withdrawERC20(\n            _vault,\n            _token,\n            newVault,\n            _amount,\n            _erc20TransferProof\n        );\n    }\n\n    /// @notice Migrates an ERC-721 token to the new vault after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _token Address of the ERC-721 token\n    /// @param _tokenId ID of the token\n    /// @param _erc721TransferProof Merkle proof for transferring an ERC-721 token\n    function migrateVaultERC721(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256 _tokenId,\n        bytes32[] calldata _erc721TransferProof\n    ) external {\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        // Withdraws an ERC-721 token from the old vault and transfers to the new vault\n        IBuyout(buyout).withdrawERC721(\n            _vault,\n            _token,\n            newVault,\n            _tokenId,\n            _erc721TransferProof\n        );\n    }\n\n    /// @notice Migrates an ERC-1155 token to the new vault after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _token Address of the ERC-1155 token\n    /// @param _id ID of the token\n    /// @param _amount amount to be transferred\n    /// @param _erc1155TransferProof Merkle proof for transferring an ERC-1155 token\n    function migrateVaultERC1155(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256 _id,\n        uint256 _amount,\n        bytes32[] calldata _erc1155TransferProof\n    ) external {\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        // Withdraws an ERC-1155 token from the old vault and transfers to the new vault\n        IBuyout(buyout).withdrawERC1155(\n            _vault,\n            _token,\n            newVault,\n            _id,\n            _amount,\n            _erc1155TransferProof\n        );\n    }\n\n    /// @notice Batch migrates multiple ERC-1155 tokens to the new vault after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _token Address of the ERC-1155 token\n    /// @param _ids IDs of each token type\n    /// @param _amounts Transfer amounts per token type\n    /// @param _erc1155BatchTransferProof Merkle proof for batch transferring multiple ERC-1155 tokens\n    function batchMigrateVaultERC1155(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256[] calldata _ids,\n        uint256[] calldata _amounts,\n        bytes32[] calldata _erc1155BatchTransferProof\n    ) external {\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        // Batch withdraws multiple ERC-1155 tokens from the old vault and transfers to the new vault\n        IBuyout(buyout).batchWithdrawERC1155(\n            _vault,\n            _token,\n            newVault,\n            _ids,\n            _amounts,\n            _erc1155BatchTransferProof\n        );\n    }\n\n    /// @notice Migrates the caller's fractions from an old vault to a new one after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    function migrateFractions(address _vault, uint256 _proposalId) external {\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not successful\n        (, address proposer, State current, , , ) = IBuyout(buyout).buyoutInfo(\n            _vault\n        );\n        State required = State.SUCCESS;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n        // Reverts if proposer of buyout is not this contract\n        if (proposer != address(this)) revert NotProposalBuyout();\n\n        // Gets the last total supply of fractions for the vault\n        (, , , , , uint256 lastTotalSupply) = IBuyout(buyout).buyoutInfo(\n            _vault\n        );\n        // Calculates the total ether amount of a successful proposal\n        uint256 totalInEth = _calculateTotal(\n            1 ether,\n            lastTotalSupply,\n            migrationInfo[_vault][_proposalId].totalEth,\n            migrationInfo[_vault][_proposalId].totalFractions\n        );\n        // Calculates balance of caller based on ether contribution\n        uint256 balanceContributedInEth = _calculateContribution(\n            totalInEth,\n            lastTotalSupply,\n            userProposalEth[_proposalId][msg.sender],\n            userProposalFractions[_proposalId][msg.sender]\n        );\n\n        // Gets the token and fraction ID of the new vault\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        (address token, uint256 newFractionId) = IVaultRegistry(registry)\n            .vaultToToken(newVault);\n        // Calculates share amount of fractions for the new vault based on the new total supply\n        uint256 newTotalSupply = IVaultRegistry(registry).totalSupply(newVault);\n        uint256 shareAmount = (balanceContributedInEth * newTotalSupply) /\n            totalInEth;\n\n        // Transfers fractional tokens to caller based on share amount\n        IFERC1155(token).safeTransferFrom(\n            address(this),\n            msg.sender,\n            newFractionId,\n            shareAmount,\n            \"\"\n        );\n    }\n\n    /// @notice Generates the merkle tree of a given proposal\n    /// @param _modules List of module contracts\n    /// @return hashes Combined list of leaf nodes\n    function generateMerkleTree(address[] memory _modules)\n        public\n        view\n        returns (bytes32[] memory hashes)\n    {\n        uint256 treeLength;\n        uint256 modulesLength = _modules.length;\n\n        unchecked {\n            for (uint256 i; i < modulesLength; ++i) {\n                treeLength += IModule(_modules[i]).getLeafNodes().length;\n            }\n        }\n\n        uint256 counter;\n        hashes = new bytes32[](treeLength);\n        unchecked {\n            for (uint256 i; i < modulesLength; ++i) {\n                bytes32[] memory leaves = IModule(_modules[i]).getLeafNodes();\n                uint256 leavesLength = leaves.length;\n                for (uint256 j; j < leavesLength; ++j) {\n                    hashes[counter++] = leaves[j];\n                }\n            }\n        }\n    }\n\n    /// @notice Calculates the total amount of ether\n    /// @param _scalar Scalar used for multiplication\n    /// @param _lastTotalSupply Previous total fractional supply of the vault\n    /// @param _totalEth Total ether balance of the proposal\n    /// @param _totalFractions Total fractional balance of the proposal\n    /// @return Total amount of ether\n    function _calculateTotal(\n        uint256 _scalar,\n        uint256 _lastTotalSupply,\n        uint256 _totalEth,\n        uint256 _totalFractions\n    ) private pure returns (uint256) {\n        return\n            (_totalEth * _scalar) /\n            (_scalar - ((_totalFractions * _scalar) / _lastTotalSupply));\n    }\n\n    /// @notice Calculates the amount of ether contributed by the user\n    /// @param _totalInEth Total amount of ether\n    /// @param _lastTotalSupply Previous total fractional supply of the vault\n    /// @param _userProposalEth User balance of ether for the proposal\n    /// @param _userProposalFractions User balance of fractions for the proposal\n    /// @return Total contribution amount\n    function _calculateContribution(\n        uint256 _totalInEth,\n        uint256 _lastTotalSupply,\n        uint256 _userProposalEth,\n        uint256 _userProposalFractions\n    ) private pure returns (uint256) {\n        return\n            _userProposalEth +\n            (_userProposalFractions * _totalInEth) /\n            _lastTotalSupply;\n    }\n}"
    },
    {
      "filename": "src/VaultRegistry.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {ClonesWithImmutableArgs} from \"clones-with-immutable-args/src/ClonesWithImmutableArgs.sol\";\nimport {FERC1155} from \"./FERC1155.sol\";\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {IVaultRegistry, VaultInfo} from \"./interfaces/IVaultRegistry.sol\";\nimport {VaultFactory} from \"./VaultFactory.sol\";\n\n/// @title Vault Registry\n/// @author Fractional Art\n/// @notice Registry contract for tracking all fractional vaults\ncontract VaultRegistry is IVaultRegistry {\n    /// @dev Use clones library with address types\n    using ClonesWithImmutableArgs for address;\n    /// @notice Address of VaultFactory contract\n    address public immutable factory;\n    /// @notice Address of FERC1155 token contract\n    address public immutable fNFT;\n    /// @notice Address of Implementation for FERC1155 token contract\n    address public immutable fNFTImplementation;\n    /// @notice Mapping of collection address to next token ID type\n    mapping(address => uint256) public nextId;\n    /// @notice Mapping of vault address to vault information\n    mapping(address => VaultInfo) public vaultToToken;\n\n    /// @notice Initializes factory, implementation, and token contracts\n    constructor() {\n        factory = address(new VaultFactory());\n        fNFTImplementation = address(new FERC1155());\n        fNFT = fNFTImplementation.clone(\n            abi.encodePacked(msg.sender, address(this))\n        );\n    }\n\n    /// @notice Burns vault tokens\n    /// @param _from Source address\n    /// @param _value Amount of tokens\n    function burn(address _from, uint256 _value) external {\n        VaultInfo memory info = vaultToToken[msg.sender];\n        uint256 id = info.id;\n        if (id == 0) revert UnregisteredVault(msg.sender);\n        FERC1155(info.token).burn(_from, id, _value);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    function create(\n        bytes32 _merkleRoot,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault) {\n        vault = _deployVault(_merkleRoot, address(fNFT), _plugins, _selectors);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins, and transfers ownership to a given owner\n    /// @dev This should only be done in limited cases i.e. if you're okay with a trusted individual(s)\n    /// having control over the vault. Ideally, execution would be locked behind a Multisig wallet.\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _owner Address of the vault owner\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    function createFor(\n        bytes32 _merkleRoot,\n        address _owner,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault) {\n        vault = _deployVault(_merkleRoot, address(fNFT), _plugins, _selectors);\n        IVault(vault).transferOwnership(_owner);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins for the message sender\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    /// @return token Address of FERC1155 contract\n    function createCollection(\n        bytes32 _merkleRoot,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault, address token) {\n        (vault, token) = createCollectionFor(\n            _merkleRoot,\n            msg.sender,\n            _plugins,\n            _selectors\n        );\n    }\n\n    /// @notice Creates a new vault with permissions and plugins for an existing collection\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _token Address of FERC1155 contract\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    functi"
    }
  ]
}