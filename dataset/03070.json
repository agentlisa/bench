{
  "Title": "Loose restriction on fees",
  "Content": "Currently, fees on buys and won auctions are not restricted and can be arbitrarily set for up to 100% via the `assertBidInputsOK` function in the [`BuyNowBase`](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/buyNow/base/BuyNowBase.sol#L395) and [`AuctionBase`](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/auction/base/AuctionBase.sol#L245-L248) contracts. Such `feeBPS` value is given through the input data that is signed by the operator.\n\n\nDespite the trust assumption towards the operator, consider limiting the fee to a lower percentage or setting it on a contract level similar to the `_paymentWindow`. By doing so it is less likely that the seller gets less funds than intended due to an unexpectedly high fee.\n\n\n***Update**: Fixed with commit `bfa52af` of [PR#13](https://github.com/freeverseio/crypto-payments/pull/13).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/buyNow/base/BuyNowBase.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.14;\n\nimport \"./IBuyNowBase.sol\";\nimport \"../../roles/Operators.sol\";\nimport \"../../roles/FeesCollectors.sol\";\nimport \"./IEIP712VerifierBuyNow.sol\";\n\n/**\n * @title Base Escrow Contract for Payments in BuyNow mode.\n * @author Freeverse.io, www.freeverse.io\n * @notice Full contract documentation in IBuyNowBase\n */\n\nabstract contract BuyNowBase is IBuyNowBase, FeesCollectors, Operators {\n    // the address of the deployed EIP712 verifier contract\n    address internal _eip712;\n\n    // a descriptor of the accepted currency (be it native or ERC20)\n    string private _acceptedCurrency;\n\n    //  the amount of seconds that a payment can remain\n    //  in ASSET_TRANSFERRING state without positive\n    //  or negative confirmation by the operator\n    uint256 internal _paymentWindow;\n\n    // whether sellers need to be registered to be able to accept payments\n    bool internal _isSellerRegistrationRequired;\n\n    // mapping from seller address to whether seller is registered\n    mapping(address => bool) internal _isRegisteredSeller;\n\n    // mapping from user address to a bool:\n    // - if true: only the user can execute withdrawals of his/her local balance\n    // - if false: any address can help and execute the withdrawals on behalf of the user\n    //   (the funds still go straight to the user, but the helper address covers gas costs\n    //    and the hassle of executing the transaction)\n    mapping(address => bool) internal _onlyUserCanWithdraw;\n\n    // mapping from paymentId to payment struct describing the entire payment process\n    mapping(bytes32 => Payment) internal _payments;\n\n    // mapping from user address to local balance in this contract\n    mapping(address => uint256) internal _balanceOf;\n\n    constructor(string memory currencyDescriptor, address eip712) {\n        _eip712 = eip712;\n        _acceptedCurrency = currencyDescriptor;\n        _paymentWindow = 30 days;\n        _isSellerRegistrationRequired = false;\n    }\n\n    /**\n     * @notice Sets the address of the EIP712 verifier contract.\n     * @dev This upgradable pattern is required in case that the\n     *  EIP712 spec/code changes in the future\n     * @param eip712address The address of the new EIP712 contract.\n     */\n    function setEIP712(address eip712address) external onlyOwner {\n        _eip712 = eip712address;\n        emit EIP712(eip712address);\n    }\n\n    /**\n     * @notice Sets the amount of time available to the operator, after the payment starts,\n     *  to confirm either the success or the failure of the asset transfer.\n     *  After this time, the payment moves to FAILED, allowing buyer to withdraw.\n     * @param window The amount of time available, in seconds.\n     */\n    function setPaymentWindow(uint256 window) external onlyOwner {\n        require(\n            (window < 60 days) && (window > 3 hours),\n            \"payment window outside limits\"\n        );\n        _paymentWindow = window;\n        emit PaymentWindow(window);\n    }\n\n    /**\n     * @notice Sets whether sellers are required to register in this contract before being\n     *  able to accept payments.\n     * @param isRequired (bool) if true, registration is required.\n     */\n    function setIsSellerRegistrationRequired(bool isRequired)\n        external\n        onlyOwner\n    {\n        _isSellerRegistrationRequired = isRequired;\n    }\n\n    /// @inheritdoc IBuyNowBase\n    function registerAsSeller() external {\n        require(!_isRegisteredSeller[msg.sender], \"seller already registered\");\n        _isRegisteredSeller[msg.sender] = true;\n        emit NewSeller(msg.sender);\n    }\n\n    /// @inheritdoc IBuyNowBase\n    function setOnlyUserCanWithdraw(bool onlyUserCan) external {\n        _onlyUserCanWithdraw[msg.sender] = onlyUserCan;\n        emit OnlyUserCanWithdraw(msg.sender, onlyUserCan);\n    }\n\n    /// @inheritdoc IBuyNowBase\n    function finalize(\n        AssetTransferResult calldata transferResult,\n        bytes calldata operatorSignature\n    ) external {\n        _finalize(transferResult, operatorSignature);\n    }\n\n    /// @inheritdoc IBuyNowBase\n    function finalizeAndWithdraw(\n        AssetTransferResult calldata transferResult,\n        bytes calldata operatorSignature\n    ) external {\n        address recipient = transferResult.wasSuccessful\n            ? _payments[transferResult.paymentId].seller\n            : _payments[transferResult.paymentId].buyer;\n        if (_onlyUserCanWithdraw[recipient]) require(\n            msg.sender == recipient,\n            \"tx sender not authorized to withdraw on recipients behalf\"\n        );\n        _finalize(transferResult, operatorSignature);\n        // withdrawal cannot fail due to zero balance, since\n        // balance has just been increased when finalizing the payment:\n        _withdrawAmount(recipient, _balanceOf[recipient], 0);\n    }\n\n    /// @inheritdoc IBuyNowBase\n    function refund(bytes32 paymentId) public {\n        _refund(paymentId);\n    }\n\n    /// @inheritdoc IBuyNowBase\n    function refundAndWithdraw(bytes32 paymentId) external {\n        address recipient = _payments[paymentId].buyer;\n        if (_onlyUserCanWithdraw[recipient]) require(\n            msg.sender == recipient,\n            \"tx sender not authorized to withdraw on recipients behalf\"\n        );\n        _refund(paymentId);\n        // withdrawal cannot fail due to zero balance, since\n        // balance has just been increased when refunding:\n        _withdrawAmount(recipient, _balanceOf[recipient], 0);\n    }\n\n    /// @inheritdoc IBuyNowBase\n    function withdraw() external {\n        _withdraw();\n    }\n\n    /// @inheritdoc IBuyNowBase\n    function withdrawTo(address recipient) external {\n        require(\n            !_onlyUserCanWithdraw[recipient],\n            \"tx sender not authorized to withdraw on recipients behalf\"\n        );\n        _withdrawAmount(recipient, _balanceOf[recipient], 0);\n    }\n\n    /// @inheritdoc IBuyNowBase\n    function withdrawAmount(uint256 amount) external {\n        uint256 balance = _balanceOf[msg.sender];\n        require(balance >= amount, \"not enough balance to withdraw specified amount\");\n        _withdrawAmount(msg.sender, amount, balance - amount);\n    }\n\n    // PRIVATE & INTERNAL FUNCTIONS\n\n    /**\n     * @dev Interface to method that must update payer's local balance on arrival of a payment,\n     *  re-using local balance if available. In ERC20 payments, it transfers to this contract\n     *  the required amount; in case of native crypto, it must add excess of provided funds, if any, to local balance.\n     * @param payer The address of the payer\n     * @param newFundsNeeded The elsewhere computed minimum amount of funds required to be provided by the payer,\n     *  having possible re-use of local funds into account\n     * @param localFunds The elsewhere computed amount of funds available to the payer in this contract, that will be\n     *  re-used in the payment\n     */\n    function _updatePayerBalanceOnPaymentReceived(\n        address payer,\n        uint256 newFundsNeeded,\n        uint256 localFunds\n    ) internal virtual;\n\n    /**\n     * @dev Asserts correcteness of buyNow input parameters,\n     *  transfers required funds from external contract (in case of ERC20 Payments),\n     *  reuses buyer's local balance (if any),\n     *  and stores the payment data in contract's storage.\n     *  Moves the payment to AssetTransferring state\n     * @param buyNowInp The BuyNowInput struct\n     * @param operator The address of the operator of this payment.\n     */\n    function _processBuyNow(BuyNowInput calldata buyNowInp, address operator)\n        internal\n    {\n        assertBuyNowInputsOK(buyNowInp);\n        assertSeparateRoles(operator, buyNowInp.buyer, buyNowInp.seller);\n        (uint256 newFundsNeeded, uint256 localFunds) = splitFundingSources(\n            buyNowInp.buyer,\n            buyNowInp.amount\n        );\n        _updatePayerBalanceOnPaymentReceived(buyNowInp.buyer, newFundsNeeded, localFunds);\n        _payments[buyNowInp.paymentId] = Payment(\n            State.AssetTransferring,\n            buyNowInp.buyer,\n            buyNowInp.seller,\n            operator,\n            universeFeesCollector(buyNowInp.universeId),\n            block.timestamp + _paymentWindow,\n            buyNowInp.feeBPS,\n            buyNowInp.amount\n        );\n        emit BuyNow(buyNowInp.paymentId, buyNowInp.buyer, buyNowInp.seller);\n    }\n\n    /**\n     * @dev (private) Moves the payment funds to the buyer's local balance\n     *  The buyer still needs to withdraw afterwards.\n     *  Moves the payment to REFUNDED state\n     * @param paymentId The unique ID that identifies the payment.\n     */\n    function _refund(bytes32 paymentId) private {\n        require(\n            acceptsRefunds(paymentId),\n            \"payment does not accept refunds at this stage\"\n        );\n        _refundToLocalBalance(paymentId);\n    }\n\n    /**\n     * @dev (private) Uses the operator signed msg regarding asset transfer success to update\n     *  the balances of seller (on success) or buyer (on failure).\n     *  They still need to withdraw afterwards.\n     *  Moves the payment to either PAID (on success) or REFUNDED (on failure) state\n     * @param transferResult The asset transferResult struct signed by the operator.\n     * @param operatorSignature The operator signature of transferResult\n     */\n    function _finalize(\n        AssetTransferResult calldata transferResult,\n        bytes calldata operatorSignature\n    ) private {\n        Payment memory payment = _payments[transferResult.paymentId];\n        require(\n            paymentState(transferResult.paymentId) == State.AssetTransferring,\n            \"payment not initially in asset transferring state\"\n        );\n        require(\n            IEIP712VerifierBuyNow(_eip712).verifyAssetTransferResult(\n                transferResult,\n                operatorSignature,\n                payment.operator\n            ),\n            \"only the operator can sign an assetTransferResult\"\n        );\n        if (transferResult.wasSuccessful) {\n            _finalizeSuccess(transferResult.paymentId, payment);\n        } else {\n            _finalizeFailed(transferResult.paymentId);\n        }\n    }\n\n    /**\n     * @dev (private) Updates the balance of the seller on successful asset transfer\n     *  Moves the payment to PAID\n     * @param paymentId The unique ID that identifies the payment.\n     * @param payment The payment struct corresponding to paymentId\n     */\n    function _finalizeSuccess(bytes32 paymentId, Payment memory payment) private {\n        _payments[paymentId].state = State.Paid;\n        uint256 feeAmount = computeFeeAmount(payment.amount, payment.feeBPS);\n        _balanceOf[payment.seller] += (payment.amount - feeAmount);\n        _balanceOf[payment.feesCollector] += feeAmount;\n        emit Paid(paymentId);\n    }\n\n    /**\n     * @dev (private) Updates the balance of the buyer on failed asset transfer\n     *  Moves the payment to REFUNDED\n     * @param paymentId The unique ID that identifies the payment.\n     */\n    function _finalizeFailed(bytes32 paymentId) private {\n        _refundToLocalBalance(paymentId);\n    }\n\n    /**\n     * @dev (private) Executes refund, moves to REFUNDED state\n     * @param paymentId The unique ID that identifies the payment.\n     */\n    function _refundToLocalBalance(bytes32 paymentId) private {\n        _payments[paymentId].state = State.Refunded;\n        Payment memory payment = _payments[paymentId];\n        _balanceOf[payment.buyer] += payment.amount;\n        emit BuyerRefunded(paymentId, payment.buyer);\n    }\n\n    /**\n     * @dev (private) Transfers funds available in this\n     *  contract's balanceOf[msg.sender] to msg.sender\n     *  Follows standard Checks-Effects-Interactions pattern\n     *  to protect against re-entrancy attacks.\n     */\n    function _withdraw() private {\n        _withdrawAmount(msg.sender, _balanceOf[msg.sender], 0);\n    }\n\n    /**\n     * @dev (private) Transfers the specified amount of \n     *  funds in this contract's balanceOf[recipient] to the recipient address.\n     *  The checks that enough amount is available, and the computation\n     *  of the final balance need to be done before calling this function.\n     *  Follows standard Checks-Effects-Interactions pattern\n     *  to protect against re-entrancy attacks.\n     * @param recipient The address of to transfer funds from the local contract\n     * @param amount The amount to withdraw.\n     * @param finalBalance The final balance of msg.sender after withdrawal.\n    */\n    function _withdrawAmount(address recipient, uint256 amount, uint256 finalBalance) private {\n        // requirement:\n        require(amount > 0, \"cannot withdraw zero amount\");\n        // effect:\n        _balanceOf[recipient] = finalBalance;\n        // interaction:\n        _transfer(recipient, amount);\n        emit Withdraw(recipient, amount);\n    }\n\n    /**\n     * @dev Interface to method that transfers the specified amount to the specified address.\n     *  Requirements and effects are checked before calling this function.\n     *  Implementations can deal with native crypto transfers, with ERC20 token transfers, etc.\n     * @param to The address that must receive the funds.\n     * @param amount The amount to transfer.\n    */\n    function _transfer(address to, uint256 amount) internal virtual;\n\n    // VIEW FUNCTIONS\n\n    /// @inheritdoc IBuyNowBase\n    function isSellerRegistrationRequired() external view returns (bool) {\n        return _isSellerRegistrationRequired;\n    }\n\n    /// @inheritdoc IBuyNowBase\n    function isRegisteredSeller(address addr) external view returns (bool) {\n        return _isRegisteredSeller[addr];\n    }\n\n    /// @inheritdoc IBuyNowBase\n    function balanceOf(address addr) external view returns (uint256) {\n        return _balanceOf[addr];\n    }\n\n    /// @inheritdoc IBuyNowBase\n    function paymentInfo(bytes32 paymentId)\n        external\n        view\n        returns (Payment memory)\n    {\n        return _payments[paymentId];\n    }\n\n    /// @inheritdoc IBuyNowBase\n    function paymentState(bytes32 paymentId) public view virtual returns (State) {\n        return _payments[paymentId].state;\n    }\n\n    /// @inheritdoc IBuyNowBase\n    function acceptsRefunds(bytes32 paymentId) public view returns (bool) {\n        return\n            (paymentState(paymentId) == State.AssetTransferring) &&\n            (block.timestamp > _payments[paymentId].expirationTime);\n    }\n\n    /// @inheritdoc IBuyNowBase\n    function EIP712Address() external view returns (address) {\n        return _eip712;\n    }\n\n    /// @inheritdoc IBuyNowBase\n    function paymentWindow() external view returns (uint256) {\n        return _paymentWindow;\n    }\n\n    /// @inheritdoc IBuyNowBase\n    function acceptedCurrency() external view returns (string memory) {\n        return _acceptedCurrency;\n    }\n\n    /// @inheritdoc IBuyNowBase\n    function assertBuyNowInputsOK(BuyNowInput calldata buyNowInp) public view {\n        require(buyNowInp.amount > 0, \"payment amount cannot be zero\");\n        require(buyNowInp.feeBPS <= 10000, \"fee cannot be larger than 100 percent\");\n        require(\n            paymentState(buyNowInp.paymentId) == State.NotStarted,\n            \"payment in incorrect current state\"\n        );\n        require(block.timestamp <= buyNowInp.deadline, \"payment deadline expired\");\n        if (_isSellerRegistrationRequired)\n            require(_isRegisteredSeller[buyNowInp.seller], \"seller not registered\");\n    }\n\n    /// @inheritdoc IBuyNowBase\n    function enoughFundsAvailable(address buyer, uint256 amount)\n        public\n        view\n        returns (bool)\n    {\n        return maxFundsAvailable(buyer) >= amount;\n    }\n\n    /// @inheritdoc IBuyNowBase\n    function maxFundsAvailable(address buyer) public view returns (uint256) {\n        return _balanceOf[buyer] + externalBalance(buyer);\n    }\n\n    /**\n     * @notice Interface to method that must return the amount available to a buyer outside this contract\n     * @dev If the contract that implements this interface deals with native crypto, then it must return buyer.balance;\n     *  if dealing with ERC20, it must return the available balance in the external ERC20 contract.\n     * @param buyer The address for which funds are queried\n     * @return the external funds available\n     */\n    function externalBalance(address buyer) public view virtual returns (uint256);\n\n    /// @inheritdoc IBuyNowBase\n    function splitFundingSources(address buyer, uint256 amount)\n        public\n        view\n        returns (uint256 externalFunds, uint256 localFunds)\n    {\n        uint256 localBalance = _balanceOf[buyer];\n        localFunds = (amount > localBalance) ? localBalance : amount;\n        externalFunds = (amount > localBalance) ? amount - localBalance : 0;\n    }\n\n    /// @inheritdoc IBuyNowBase\n    function onlyUserCanWithdraw(address user) public view returns (bool) {\n        return _onlyUserCanWithdraw[user];\n    }\n\n    // PURE FUNCTIONS\n\n    /**\n     * @dev Reverts if either of the following addresses coincide: operator, payer, seller\n     *  On the one hand, the operator must be an observer.\n     *  On the other hand, the seller cannot act on his/her already owned assets.\n     * @param operator The address of the operator\n     * @param payer The address of the payer\n     * @param seller The address of the seller\n    */\n    function assertSeparateRoles(address operator, address payer, address seller)\n        internal pure {\n        require(\n            (operator != payer) && (operator != seller),\n            \"operator must be an observer\"\n        );\n        require((payer != seller), \"payer and seller cannot coincide\");\n    }\n\n    /// @inheritdoc IBuyNowBase\n    function computeFeeAmount(uint256 amount, uint256 feeBPS)\n        public\n        pure\n        returns (uint256)\n    {\n        uint256 feeAmount = (amount * feeBPS) / 10000;\n        return (feeAmount <= amount) ? feeAmount : amount;\n    }\n}"
    }
  ]
}