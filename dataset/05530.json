{
  "Title": "[M-11] Unchecked return value of low-level `call()/delegatecall()`",
  "Content": "\n\n*Note: this finding was reported via the winning [Automated Findings report](https://gist.github.com/code423n4/b979a00ee3ea3f7d36ee39e2a536ba8a). It was declared out of scope for the audit, but is being included here for completeness.*\n\nThe `call/delegatecall` function returns a boolean value indicating whether the call was successful. However, it is important to note that this return value is not being checked in the current implementation.\n\nAs a result, there is a possibility that the call wasn't successful, while the transaction continues without reverting.\n\n*There are 11 instances of this issue.*\n\n```solidity\nFile: smart-contracts/AuctionDemo.sol\n\n113: \t\t                (bool success, ) = payable(owner()).call{value: highestBid}(\"\");\n\n116: \t\t                (bool success, ) = payable(auctionInfoData[_tokenid][i].bidder).call{value: auctionInfoData[_tokenid][i].bid}(\"\");\n\n128: \t\t        (bool success, ) = payable(auctionInfoData[_tokenid][index].bidder).call{value: auctionInfoData[_tokenid][index].bid}(\"\");\n\n139: \t\t                (bool success, ) = payable(auctionInfoData[_tokenid][i].bidder).call{value: auctionInfoData[_tokenid][i].bid}(\"\");\n```\n[[113](https://github.com/code-423n4/2023-10-nextgen/blob/08a56bacd286ee52433670f3bb73a0e4a4525dd4/smart-contracts/AuctionDemo.sol#L113), [116](https://github.com/code-423n4/2023-10-nextgen/blob/08a56bacd286ee52433670f3bb73a0e4a4525dd4/smart-contracts/AuctionDemo.sol#L116), [128](https://github.com/code-423n4/2023-10-nextgen/blob/08a56bacd286ee52433670f3bb73a0e4a4525dd4/smart-contracts/AuctionDemo.sol#L128), [139](https://github.com/code-423n4/2023-10-nextgen/blob/08a56bacd286ee52433670f3bb73a0e4a4525dd4/smart-contracts/AuctionDemo.sol#L139)]\n\n```solidity\nFile: smart-contracts/MinterContract.sol\n\n434: \t\t        (bool success1, ) = payable(collectionArtistPrimaryAddresses[colId].primaryAdd1).call{value: artistRoyalties1}(\"\");\n\n435: \t\t        (bool success2, ) = payable(collectionArtistPrimaryAddresses[colId].primaryAdd2).call{value: artistRoyalties2}(\"\");\n\n436: \t\t        (bool success3, ) = payable(collectionArtistPrimaryAddresses[colId].primaryAdd3).call{value: artistRoyalties3}(\"\");\n\n437: \t\t        (bool success4, ) = payable(tm1).call{value: teamRoyalties1}(\"\");\n\n438: \t\t        (bool success5, ) = payable(tm2).call{value: teamRoyalties2}(\"\");\n\n464: \t\t        (bool success, ) = payable(admin).call{value: balance}(\"\");\n```\n[[434](https://github.com/code-423n4/2023-10-nextgen/blob/08a56bacd286ee52433670f3bb73a0e4a4525dd4/smart-contracts/MinterContract.sol#L434), [435](https://github.com/code-423n4/2023-10-nextgen/blob/08a56bacd286ee52433670f3bb73a0e4a4525dd4/smart-contracts/MinterContract.sol#L435), [436](https://github.com/code-423n4/2023-10-nextgen/blob/08a56bacd286ee52433670f3bb73a0e4a4525dd4/smart-contracts/MinterContract.sol#L436), [437](https://github.com/code-423n4/2023-10-nextgen/blob/08a56bacd286ee52433670f3bb73a0e4a4525dd4/smart-contracts/MinterContract.sol#L437), [438](https://github.com/code-423n4/2023-10-nextgen/blob/08a56bacd286ee52433670f3bb73a0e4a4525dd4/smart-contracts/MinterContract.sol#L438), [464](https://github.com/code-423n4/2023-10-nextgen/blob/08a56bacd286ee52433670f3bb73a0e4a4525dd4/smart-contracts/MinterContract.sol#L464)]\n\n```solidity\nFile: smart-contracts/RandomizerRNG.sol\n\n82: \t\t        (bool success, ) = payable(admin).call{value: balance}(\"\");\n```\n[[82](https://github.com/code-423n4/2023-10-nextgen/blob/08a56bacd286ee52433670f3bb73a0e4a4525dd4/smart-contracts/RandomizerRNG.sol#L82)]\n\n**[a2rocket (NextGen) confirmed](https://gist.github.com/code423n4/b979a00ee3ea3f7d36ee39e2a536ba8a?permalink_comment_id=4797585#gistcomment-4797585)**\n\n**[0xsomeone (judge) commented](https://gist.github.com/code423n4/b979a00ee3ea3f7d36ee39e2a536ba8a?permalink_comment_id=4797627#gistcomment-4797627):**\n> Important and valid.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-nextgen",
  "Code": [
    {
      "filename": "smart-contracts/AuctionDemo.sol",
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n *\n *  @title: Auction Demo Contract\n *  @date: 26-October-2023 \n *  @version: 1.2\n *  @author: 6529 team\n */\n\npragma solidity ^0.8.19;\n\nimport \"./IMinterContract.sol\";\nimport \"./IERC721.sol\";\nimport \"./Ownable.sol\";\nimport \"./INextGenAdmins.sol\";\n\ncontract auctionDemo is Ownable {\n\n    //events \n\n    event ClaimAuction(address indexed _add, uint256 indexed tokenid, bool status, uint256 indexed funds);\n    event Refund(address indexed _add, uint256 indexed tokenid, bool status, uint256 indexed funds);\n    event CancelBid(address indexed _add, uint256 indexed tokenid, uint256 index, bool status, uint256 indexed funds);\n\n    IMinterContract public minter;\n    INextGenAdmins public adminsContract;\n    address gencore;\n\n    // certain functions can only be called by auction winner or admin\n    modifier WinnerOrAdminRequired(uint256 _tokenId, bytes4 _selector) {\n      require(msg.sender == returnHighestBidder(_tokenId) || adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true, \"Not allowed\");\n      _;\n    }\n\n    constructor (address _minter, address _gencore, address _adminsContract) public {\n        minter = IMinterContract(_minter);\n        gencore = _gencore;\n        adminsContract = INextGenAdmins(_adminsContract);\n    }\n\n    // auction Bidders\n    struct auctionInfoStru {\n        address bidder;\n        uint256 bid;\n        bool status;\n    }\n\n    // mapping of collectionSecondaryAddresses struct\n    mapping (uint256 => auctionInfoStru[]) public auctionInfoData;\n\n    // claim auctioned\n    mapping (uint256 => bool) public auctionClaim;\n\n    // participate to auction\n\n    function participateToAuction(uint256 _tokenid) public payable {\n        require(msg.value > returnHighestBid(_tokenid) && block.timestamp <= minter.getAuctionEndTime(_tokenid) && minter.getAuctionStatus(_tokenid) == true);\n        auctionInfoStru memory newBid = auctionInfoStru(msg.sender, msg.value, true);\n        auctionInfoData[_tokenid].push(newBid);\n    }\n\n    // get highest bid\n\n    function returnHighestBid(uint256 _tokenid) public view returns (uint256) {\n        uint256 index;\n        if (auctionInfoData[_tokenid].length > 0) {\n            uint256 highBid = 0;\n            for (uint256 i=0; i< auctionInfoData[_tokenid].length; i++) {\n                if (auctionInfoData[_tokenid][i].bid > highBid && auctionInfoData[_tokenid][i].status == true) {\n                    highBid = auctionInfoData[_tokenid][i].bid;\n                    index = i;\n                }\n            }\n            if (auctionInfoData[_tokenid][index].status == true) {\n                return highBid;\n            } else {\n                return 0;\n            }\n        } else {\n            return 0;\n        }\n    }\n\n    // get highest bidder\n\n    function returnHighestBidder(uint256 _tokenid) public view returns (address) {\n        uint256 highBid = 0;\n        uint256 index;\n        for (uint256 i=0; i< auctionInfoData[_tokenid].length; i++) {\n            if (auctionInfoData[_tokenid][i].bid > highBid && auctionInfoData[_tokenid][i].status == true) {\n                index = i;\n            }\n        }\n        if (auctionInfoData[_tokenid][index].status == true) {\n                return auctionInfoData[_tokenid][index].bidder;\n            } else {\n                revert(\"No Active Bidder\");\n        }\n    }\n\n    // claim Token After Auction\n\n    function claimAuction(uint256 _tokenid) public WinnerOrAdminRequired(_tokenid,this.claimAuction.selector){\n        require(block.timestamp >= minter.getAuctionEndTime(_tokenid) && auctionClaim[_tokenid] == false && minter.getAuctionStatus(_tokenid) == true);\n        auctionClaim[_tokenid] = true;\n        uint256 highestBid = returnHighestBid(_tokenid);\n        address ownerOfToken = IERC721(gencore).ownerOf(_tokenid);\n        address highestBidder = returnHighestBidder(_tokenid);\n        for (uint256 i=0; i< auctionInfoData[_tokenid].length; i ++) {\n            if (auctionInfoData[_tokenid][i].bidder == highestBidder && auctionInfoData[_tokenid][i].bid == highestBid && auctionInfoData[_tokenid][i].status == true) {\n                IERC721(gencore).safeTransferFrom(ownerOfToken, highestBidder, _tokenid);\n                (bool success, ) = payable(owner()).call{value: highestBid}(\"\");\n                emit ClaimAuction(owner(), _tokenid, success, highestBid);\n            } else if (auctionInfoData[_tokenid][i].status == true) {\n                (bool success, ) = payable(auctionInfoData[_tokenid][i].bidder).call{value: auctionInfoData[_tokenid][i].bid}(\"\");\n                emit Refund(auctionInfoData[_tokenid][i].bidder, _tokenid, success, highestBid);\n            } else {}\n        }\n    }\n\n    // cancel a single Bid\n\n    function cancelBid(uint256 _tokenid, uint256 index) public {\n        require(block.timestamp <= minter.getAuctionEndTime(_tokenid), \"Auction ended\");\n        require(auctionInfoData[_tokenid][index].bidder == msg.sender && auctionInfoData[_tokenid][index].status == true);\n        auctionInfoData[_tokenid][index].status = false;\n        (bool success, ) = payable(auctionInfoData[_tokenid][index].bidder).call{value: auctionInfoData[_tokenid][index].bid}(\"\");\n        emit CancelBid(msg.sender, _tokenid, index, success, auctionInfoData[_tokenid][index].bid);\n    }\n\n    // cancel All Bids\n\n    function cancelAllBids(uint256 _tokenid) public {\n        require(block.timestamp <= minter.getAuctionEndTime(_tokenid), \"Auction ended\");\n        for (uint256 i=0; i<auctionInfoData[_tokenid].length; i++) {\n            if (auctionInfoData[_tokenid][i].bidder == msg.sender && auctionInfoData[_tokenid][i].status == true) {\n                auctionInfoData[_tokenid][i].status = false;\n                (bool success, ) = payable(auctionInfoData[_tokenid][i].bidder).call{value: auctionInfoData[_tokenid][i].bid}(\"\");\n                emit CancelBid(msg.sender, _tokenid, i, success, auctionInfoData[_tokenid][i].bid);\n            } else {}\n        }\n    }\n\n    // return Bids\n\n    function returnBids(uint256 _tokenid) public view returns(auctionInfoStru[] memory) {\n        return auctionInfoData[_tokenid];\n    }\n\n}"
    },
    {
      "filename": "smart-contracts/MinterContract.sol",
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n *\n *  @title: NextGen Minter Contract\n *  @date: 18-October-2023 \n *  @version: 1.8\n *  @author: 6529 team\n */\n\npragma solidity ^0.8.19;\n\nimport \"./INextGenCore.sol\";\nimport \"./Ownable.sol\";\nimport \"./IDelegationManagementContract.sol\";\nimport \"./MerkleProof.sol\";\nimport \"./INextGenAdmins.sol\";\nimport \"./IERC721.sol\";\n\ncontract NextGenMinterContract is Ownable {\n\n    // total amount collected during minting from collections\n    mapping (uint256 => uint256) public collectionTotalAmount;\n\n    // sales Option3 timestamp of last mint\n    mapping (uint256 => uint) public lastMintDate;\n\n    // burn or swap address for external collections\n    mapping (bytes32 => address) public burnOrSwapAddress;\n\n    // burn or swap external collection ids\n    mapping (bytes32 => uint256[2]) private burnOrSwapIds;\n\n    // mint tokens on a specific collection after burning a token on a NextGen collection\n    mapping (uint256 => mapping (uint256 => bool)) public burnToMintCollections;\n\n    // mint tokens on a specific collection after burning a token on an external collection\n    mapping (bytes32 => mapping (uint256 => bool)) public burnExternalToMintCollections;\n\n    // check if minting costs were set\n    mapping (uint256 => bool) private setMintingCosts;\n\n    // collectionPhasesData struct declaration\n    struct collectionPhasesDataStructure {\n        uint allowlistStartTime;\n        uint allowlistEndTime;\n        uint publicStartTime;\n        uint publicEndTime;\n        bytes32 merkleRoot;\n        uint256 collectionMintCost;\n        uint256 collectionEndMintCost;\n        uint256 timePeriod;\n        uint256 rate;\n        uint8 salesOption;\n        address delAddress;\n    }\n\n    // mapping of collectionPhasesData struct\n    mapping (uint256 => collectionPhasesDataStructure) private collectionPhases;\n\n    // royalties primary splits structure\n\n    struct royaltiesPrimarySplits {\n        uint256 artistPercentage;\n        uint256 teamPercentage;\n    }\n\n    // mapping of royaltiesPrimarySplits struct\n\n    mapping (uint256 => royaltiesPrimarySplits) private collectionRoyaltiesPrimarySplits;\n\n    // artists primary Addresses\n    struct collectionPrimaryAddresses {\n        address primaryAdd1;\n        address primaryAdd2;\n        address primaryAdd3;\n        uint256 add1Percentage;\n        uint256 add2Percentage;\n        uint256 add3Percentage;\n        bool status;\n    }\n\n    // mapping of collectionPrimaryAndSecondaryAddresses struct\n    mapping (uint256 => collectionPrimaryAddresses) private collectionArtistPrimaryAddresses;\n\n    // royalties secondary splits structure\n\n    struct royaltiesSecondarySplits {\n        uint256 artistPercentage;\n        uint256 teamPercentage;\n    }\n\n    // mapping of royaltiesSecondarySplits struct\n\n    mapping (uint256 => royaltiesSecondarySplits) private collectionRoyaltiesSecondarySplits;\n\n    // artists secondary Addresses\n    struct collectionSecondaryAddresses {\n        address secondaryAdd1;\n        address secondaryAdd2;\n        address secondaryAdd3;\n        uint256 add1Percentage;\n        uint256 add2Percentage;\n        uint256 add3Percentage;\n        bool status;\n    }\n\n    // mapping of collectionSecondaryAddresses struct\n    mapping (uint256 => collectionSecondaryAddresses) private collectionArtistSecondaryAddresses;\n\n    // mapping of token id and auction end time\n    mapping (uint256 => uint) private mintToAuctionData;\n\n    // mapping of token id and status\n    mapping (uint256 => bool) private mintToAuctionStatus;\n\n    //external contracts declaration\n    INextGenCore public gencore;\n    IDelegationManagementContract private dmc;\n    INextGenAdmins private adminsContract;\n\n    // events\n\n    event PayArtist(address indexed _add, bool status, uint256 indexed funds);\n    event PayTeam(address indexed _add, bool status, uint256 indexed funds);\n    event Withdraw(address indexed _add, bool status, uint256 indexed funds);\n\n    // constructor\n    constructor (address _gencore, address _del, address _adminsContract) {\n        gencore = INextGenCore(_gencore);\n        dmc = IDelegationManagementContract(_del);\n        adminsContract = INextGenAdmins(_adminsContract);\n    }\n\n    // certain functions can only be called by an admin or the artist\n    modifier ArtistOrAdminRequired(uint256 _collectionID, bytes4 _selector) {\n      require(msg.sender == gencore.retrieveArtistAddress(_collectionID) || adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true, \"Not allowed\");\n      _;\n    }\n\n    // certain functions can only be called by a global or function admin\n\n    modifier FunctionAdminRequired(bytes4 _selector) {\n      require(adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true , \"Not allowed\");\n      _;\n    }\n\n    // certain functions can only be called by a collection, global or function admin\n\n    modifier CollectionAdminRequired(uint256 _collectionID, bytes4 _selector) {\n      require(adminsContract.retrieveCollectionAdmin(msg.sender,_collectionID) == true || adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true, \"Not allowed\");\n      _;\n    }\n\n    // function to add a collection's minting costs\n\n    function setCollectionCosts(uint256 _collectionID, uint256 _collectionMintCost, uint256 _collectionEndMintCost, uint256 _rate, uint256 _timePeriod, uint8 _salesOption, address _delAddress) public CollectionAdminRequired(_collectionID, this.setCollectionCosts.selector) {\n        require(gencore.retrievewereDataAdded(_collectionID) == true, \"Add data\");\n        collectionPhases[_collectionID].collectionMintCost = _collectionMintCost;\n        collectionPhases[_collectionID].collectionEndMintCost = _collectionEndMintCost;\n        collectionPhases[_collectionID].rate = _rate;\n        collectionPhases[_collectionID].timePeriod = _timePeriod;\n        collectionPhases[_collectionID].salesOption = _salesOption;\n        collectionPhases[_collectionID].delAddress = _delAddress;\n        setMintingCosts[_collectionID] = true;\n    }\n\n    // function to add a collection's start/end times and merkleroot\n\n    function setCollectionPhases(uint256 _collectionID, uint _allowlistStartTime, uint _allowlistEndTime, uint _publicStartTime, uint _publicEndTime, bytes32 _merkleRoot) public CollectionAdminRequired(_collectionID, this.setCollectionPhases.selector) {\n        require(setMintingCosts[_collectionID] == true, \"Set Minting Costs\");\n        collectionPhases[_collectionID].allowlistStartTime = _allowlistStartTime;\n        collectionPhases[_collectionID].allowlistEndTime = _allowlistEndTime;\n        collectionPhases[_collectionID].merkleRoot = _merkleRoot;\n        collectionPhases[_collectionID].publicStartTime = _publicStartTime;\n        collectionPhases[_collectionID].publicEndTime = _publicEndTime;\n    }\n\n    // airdrop function\n    \n    function airDropTokens(address[] memory _recipients, string[] memory _tokenData, uint256[] memory _saltfun_o, uint256 _collectionID, uint256[] memory _numberOfTokens) public FunctionAdminRequired(this.airDropTokens.selector) {\n        require(gencore.retrievewereDataAdded(_collectionID) == true, \"Add data\");\n        uint256 collectionTokenMintIndex;\n        for (uint256 y=0; y< _recipients.length; y++) {\n            collectionTokenMintIndex = gencore.viewTokensIndexMin(_collectionID) + gencore.viewCirSupply(_collectionID) + _numberOfTokens[y] - 1;\n            require(collectionTokenMintIndex <= gencore.viewTokensIndexMax(_collectionID), \"No supply\");\n            for(uint256 i = 0; i < _numberOfTokens[y]; i++) {\n                uint256 mintIndex = gencore.viewTokensIndexMin(_collectionID) + gencore.viewCirSupply(_collectionID);\n                gencore.airDropTokens(mintIndex, _recipients[y], _tokenData[y], _saltfun_o[y], _collectionID);\n            }\n        }\n    }\n\n    // mint function\n\n    function mint(uint256 _collectionID, uint256 _numberOfTokens, uint256 _maxAllowance, string memory _tokenData, address _mintTo, bytes32[] calldata merkleProof, address _delegator, uint256 _saltfun_o) public payable {\n        require(setMintingCosts[_collectionID] == true, \"Set Minting Costs\");\n        uint256 col = _collectionID;\n        address mintingAddress;\n        uint256 phase;\n        string memory tokData = _tokenData;\n        if (block.timestamp >= collectionPhases[col].allowlistStartTime && block.timestamp <= collectionPhases[col].allowlistEndTime) {\n            phase = 1;\n            bytes32 node;\n            if (_delegator != 0x0000000000000000000000000000000000000000) {\n                bool isAllowedToMint;\n                isAllowedToMint = dmc.retrieveGlobalStatusOfDelegation(_delegator, 0x8888888888888888888888888888888888888888, msg.sender, 1) || dmc.retrieveGlobalStatusOfDelegation(_delegator, 0x8888888888888888888888888888888888888888, msg.sender, 2);\n                if (isAllowedToMint == false) {\n                isAllowedToMint = dmc.retrieveGlobalStatusOfDelegation(_delegator, collectionPhases[col].delAddress, msg.sender, 1) || dmc.retrieveGlobalStatusOfDelegation(_delegator, collectionPhases[col].delAddress, msg.sender, 2);    \n                }\n                require(isAllowedToMint == true, \"No delegation\");\n                node = keccak256(abi.encodePacked(_delegator, _maxAllowance, tokData));\n                require(_maxAllowance >= gencore.retrieveTokensMintedALPerAddress(col, _delegator) + _numberOfTokens, \"AL limit\");\n                mintingAddress = _delegator;\n            } else {\n                node = keccak256(abi.encodePacked(msg.sender, _maxAllowance, tokData));\n                require(_maxAllowance >= gencore.retrieveTokensMintedALPerAddress(col, msg.sender) + _numberOfTokens, \"AL limit\");\n                mintingAddress = msg.sender;\n            }\n            require(MerkleProof.verifyCalldata(merkleProof, collectionPhases[col].merkleRoot, node), 'invalid proof');\n        } else if (block.timestamp >= collectionPhases[col].publicStartTime && block.timestamp <= collectionPhases[col].publicEndTime) {\n            phase = 2;\n            require(_numberOfTokens <= gencore.viewMaxAllowance(col), \"Change no of tokens\");\n            require(gencore.retrieveTokensMintedPublicPerAddress(col, msg.sender) + _numberOfTokens <= gencore.viewMaxAllowance(col), \"Max\");\n            mintingAddress = msg.sender;\n            tokData = '\"public\"';\n        } else {\n            revert(\"No minting\");\n        }\n        uint256 collectionTokenMintIndex;\n        collectionTokenMintIndex = gencore.viewTokensIndexMin(col) + gencore.viewCirSupply(col) + _numberOfTokens - 1;\n        require(collectionTokenMintIndex <= gencore.viewTokensIndexMax(col), \"No supply\");\n        require(msg.value >= (getPrice(col) * _numberOfTokens), \"Wrong ETH\");\n        for(uint256 i = 0; i < _numberOfTokens; i++) {\n            uint256 mintIndex = gencore.viewTokensIndexMin(col) + gencore.viewCirSupply(col);\n            gencore.mint(mintIndex, mintingAddress, _mintTo, tokData, _saltfun_o, col, phase);\n        }\n        collectionTotalAmount[col] = collectionTotalAmount[col] + msg.value;\n        // control mechanism for sale option 3\n        if (collectionPhases[col].salesOption == 3) {\n            uint timeOfLastMint;\n            if (lastMintDate[col] == 0) {\n                // for public sale set the allowlist the same time as publicsale\n                timeOfLastMint = collectionPhases[col].allowlistStartTime - collectionPhases[col].timePeriod;\n            } else {\n                timeOfLastMint =  lastMintDate[col];\n            }\n            // uint calculates if period has passed in order to allow minting\n            uint tDiff = (block.timestamp - timeOfLastMint) / collectionPhases[col].timePeriod;\n            // users are able to mint after a day passes\n            require(tDiff>=1 && _numberOfTokens == 1, \"1 mint/period\");\n            lastMintDate[col] = collectionPhases[col].allowlistStartTime + (collectionPhases[col].timePeriod * (gencore.viewCirSupply(col) - 1));\n        }\n    }\n\n    // burn to mint function (does not require contract approval)\n\n    function burnToMint(uint256 _burnCollectionID, uint256 _tokenId, uint256 _mintCollectionID, uint256 _saltfun_o) public payable {\n        require(burnToMintCollections[_burnCollectionID][_mintCollectionID] == true, \"Initialize burn\");\n        require(block.timestamp >= collectionPhases[_mintCollectionID].publicStartTime && block.timestamp<=collectionPhases[_mintCollectionID].publicEndTime,\"No minting\");\n        require ((_tokenId >= gencore.viewTokensIndexMin(_burnCollectionID)) && (_tokenId <= gencore.viewTokensIndexMax(_burnCollectionID)), \"col/token id error\");\n        // minting new token\n        uint256 collectionTokenMintIndex;\n        collectionTokenMintIndex = gencore.viewTokensIndexMin(_mintCollectionID) + gencore.viewCirSupply(_mintCollectionID);\n        require(collectionTokenMintIndex <= gencore.viewTokensIndexMax(_mintCollectionID), \"No supply\");\n        require(msg.value >= getPrice(_mintCollectionID), \"Wrong ETH\");\n        uint256 mintIndex = gencore.viewTokensIndexMin(_mintCollectionID) + gencore.viewCirSupply(_mintCollectionID);\n        // burn and mint token\n        address burner = msg.sender;\n        gencore.burnToMint(mintIndex, _burnCollectionID, _tokenId, _mintCollectionID, _saltfun_o, burner);\n        collectionTotalAmount[_mintCollectionID] = collectionTotalAmount[_mintCollectionID] + msg.value;\n    }\n\n    // mint and auction\n    \n    function mintAndAuction(address _recipient, string memory _tokenData, uint256 _saltfun_o, uint256 _collectionID, uint _auctionEndTime) public FunctionAdminRequired(this.mintAndAuction.selector) {\n        require(gencore.retrievewereDataAdded(_collectionID) == true, \"Add data\");\n        uint256 collectionTokenMintIndex;\n        collectionTokenMintIndex = gencore.viewTokensIndexMin(_collectionID) + gencore.viewCirSupply(_collectionID);\n        require(collectionTokenMintIndex <= gencore.viewTokensIndexMax(_collectionID), \"No supply\");\n        uint256 mintIndex = gencore.viewTokensIndexMin(_collectionID) + gencore.viewCirSupply(_collectionID);\n        gencore.airDropTokens(mintIndex, _recipient, _tokenData, _saltfun_o, _collectionID);\n        uint timeOfLastMint;\n        // check 1 per period\n        if (lastMintDate[_collectionID] == 0) {\n        // for public sale set the allowlist the same time as publicsale\n            timeOfLastMint = collectionPhases[_collectionID].allowlistStartTime - collectionPhases[_collectionID].timePeriod;\n        } else {\n            timeOfLastMint =  lastMintDate[_collectionID];\n        }\n        // uint calculates if period has passed in order to allow minting\n        uint tDiff = (block.timestamp - timeOfLastMint) / collectionPhases[_collectionID].timePeriod;\n        // users are able to mint after a day passes\n        require(tDiff>=1, \"1 mint/period\");\n        lastMintDate[_collectionID] = collectionPhases[_collectionID].allowlistStartTime + (collectionPhases[_collectionID].timePeriod * (gencore.viewCirSupply(_collectionID) - 1));\n        mintToAuctionData[mintIndex] = _auctionEndTime;\n        mintToAuctionStatus[mintIndex] = true;\n    }\n\n    // function to update allowlist mint delegation collection\n\n    function updateDelegationCollection(uint256 _collectionID, address _collectionAddress) public FunctionAdminRequired(this.updateDelegationCollection.selector) { \n        collectionPhases[_collectionID].delAddress = _collectionAddress;\n    }\n\n    // function to initialize burn to mint for NextGen collections\n\n    function initializeBurn(uint256 _burnCollectionID, uint256 _mintCollectionID, bool _status) public FunctionAdminRequired(this.initializeBurn.selector) { \n        require((gencore.retrievewereDataAdded(_burnCollectionID) == true) && (gencore.retrievewereDataAdded(_mintCollectionID) == true), \"No data\");\n        burnToMintCollections[_burnCollectionID][_mintCollectionID] = _status;\n    }\n\n    // function to initialize external burn or swap to mint (requires contract approval)\n\n    function initializeExternalBurnOrSwap(address _erc721Collection, uint256 _burnCollectionID, uint256 _mintCollectionID, uint256 _tokmin, uint256 _tokmax, address _burnOrSwapAddress, bool _status) public FunctionAdminRequired(this.initializeExternalBurnOrSwap.selector) { \n        bytes32 externalCol = keccak256(abi.encodePacked(_erc721Collection,_burnCollectionID));\n        require((gencore.retrievewereDataAdded(_mintCollectionID) == true), \"No data\");\n        burnExternalToMintCollections[externalCol][_mintCollectionID] = _status;\n        burnOrSwapAddress[externalCol] = _burnOrSwapAddress;\n        burnOrSwapIds[externalCol][0] = _tokmin;\n        burnOrSwapIds[externalCol][1] = _tokmax;\n    }\n\n    // burn or swap to mint (requires contract approval)\n\n    function burnOrSwapExternalToMint(address _erc721Collection, uint256 _burnCollectionID, uint256 _tokenId, uint256 _mintCollectionID, string memory _tokenData, bytes32[] calldata merkleProof, uint256 _saltfun_o) public payable {\n        bytes32 externalCol = keccak256(abi.encodePacked(_erc721Collection,_burnCollectionID));\n        require(burnExternalToMintCollections[externalCol][_mintCollectionID] == true, \"Initialize external burn\");\n        require(setMintingCosts[_mintCollectionID] == true, \"Set Minting Costs\");\n        address ownerOfToken = IERC721(_erc721Collection).ownerOf(_tokenId);\n        if (msg.sender != ownerOfToken) {\n            bool isAllowedToMint;\n            isAllowedToMint = dmc.retrieveGlobalStatusOfDelegation(ownerOfToken, 0x8888888888888888888888888888888888888888, msg.sender, 1) || dmc.retrieveGlobalStatusOfDelegation(ownerOfToken, 0x8888888888888888888888888888888888888888, msg.sender, 2);\n            if (isAllowedToMint == false) {\n            isAllowedToMint = dmc.retrieveGlobalStatusOfDelegation(ownerOfToken, _erc721Collection, msg.sender, 1) || dmc.retrieveGlobalStatusOfDelegation(ownerOfToken, _erc721Collection, msg.sender, 2);    \n            }\n            require(isAllowedToMint == true, \"No delegation\");\n        }\n        require(_tokenId >= burnOrSwapIds[externalCol][0] && _tokenId <= burnOrSwapIds[externalCol][1], \"Token id does not match\");\n        IERC721(_erc721Collection).safeTransferFrom(ownerOfToken, burnOrSwapAddress[externalCol], _tokenId);\n        uint256 col = _mintCollectionID;\n        address mintingAddress;\n        uint256 phase;\n        string memory tokData = _tokenData;\n        if (block.timestamp >= collectionPhases[col].allowlistStartTime && block.timestamp <= collectionPhases[col].allowlistEndTime) {\n            phase = 1;\n            bytes32 node;\n            node = keccak256(abi.encodePacked(_tokenId, tokData));\n            mintingAddress = ownerOfToken;\n            require(MerkleProof.verifyCalldata(merkleProof, collectionPhases[col].merkleRoot, node), 'invalid proof');            \n        } else if (block.timestamp >= collectionPhases[col].publicStartTime && block.timestamp <= collectionPhases[col].publicEndTime) {\n            phase = 2;\n            mintingAddress = ownerOfToken;\n            tokData = '\"public\"';\n        } else {\n            revert(\"No minting\");\n        }\n        uint256 collectionTokenMintIndex;\n        collectionTokenMintIndex = gencore.viewTokensIndexMin(col) + gencore.viewCirSupply(col);\n        require(collectionTokenMintIndex <= gencore.viewTokensIndexMax(col), \"No supply\");\n        require(msg.value >= (getPrice(col) * 1), \"Wrong ETH\");\n        uint256 mintIndex = gencore.viewTokensIndexMin(col) + gencore.viewCirSupply(col);\n        gencore.mint(mintIndex, mintingAddress, ownerOfToken, tokData, _saltfun_o, col, phase);\n        collectionTotalAmount[col] = collectionTotalAmount[col] + msg.value;\n    }\n\n    // function to set primary splits\n\n    function setPrimaryAndSecondarySplits(uint256 _collectionID, uint256 _artistPrSplit, uint256 _teamPrSplit, uint256 _artistSecSplit, uint256 _teamSecSplit) public FunctionAdminRequired(this.setPrimaryAndSecondarySplits.selector) {\n        require(_artistPrSplit + _teamPrSplit == 100, \"splits need to be 100%\");\n        require(_artistSecSplit + _teamSecSplit == 100, \"splits need to be 100%\");\n        collectionRoyaltiesPrimarySplits[_collectionID].artistPercentage = _artistPrSplit;\n        collectionRoyaltiesPrimarySplits[_collectionID].teamPercentage = _teamPrSplit;\n        collectionRoyaltiesSecondarySplits[_collectionID].artistPercentage = _artistSecSplit;\n        collectionRoyaltiesSecondarySplits[_collectionID].teamPercentage = _teamSecSplit;\n    }\n\n    // function to propose primary addresses and percentages for each address\n\n    function proposePrimaryAddressesAndPercentages(uint256 _collectionID, address _primaryAdd1, address _primaryAdd2, address _primaryAdd3, uint256 _add1Percentage, uint256 _add2Percentage, uint256 _add3Percentage) public ArtistOrAdminRequired(_collectionID, this.proposePrimaryAddressesAndPercentages.selector) {\n        require (collectionArtistPrimaryAddresses[_collectionID].status == false, \"Already approved\");\n        require (_add1Percentage + _add2Percentage + _add3Percentage == collectionRoyaltiesPrimarySplits[_collectionID].artistPercentage, \"Check %\");\n        collectionArtistPrimaryAddresses[_collectionID].primaryAdd1 = _primaryAdd1;\n        collectionArtistPrimaryAddresses[_collectionID].primaryAdd2 = _primaryAdd2;\n        collectionArtistPrimaryAddresses[_collectionID].primaryAdd3 = _primaryAdd3;\n        collectionArtistPrimaryAddresses[_collectionID].add1Percentage = _add1Percentage;\n        collectionArtistPrimaryAddresses[_collectionID].add2Percentage = _add2Percentage;\n        collectionArtistPrimaryAddresses[_collectionID].add3Percentage = _add3Percentage;\n        collectionArtistPrimaryAddresses[_collectionID].status = false;\n    }\n\n    // function to propose secondary addresses and percentages for each address\n\n    function proposeSecondaryAddressesAndPercentages(uint256 _collectionID, address _secondaryAdd1, address _secondaryAdd2, address _secondaryAdd3, uint256 _add1Percentage, uint256 _add2Percentage, uint256 _add3Percentage) public ArtistOrAdminRequired(_collectionID, this.proposeSecondaryAddressesAndPercentages.selector) {\n        require (collectionArtistSecondaryAddresses[_collectionID].status == false, \"Already approved\");\n        require (_add1Percentage + _add2Percentage + _add3Percentage == collectionRoyaltiesSecondarySplits[_collectionID].artistPercentage, \"Check %\");\n        collectionArtistSecondaryAddresses[_collectionID].secondaryAdd1 = _secondaryAdd1;\n        collectionArtistSecondaryAddresses[_collectionID].secondaryAdd2 = _secondaryAdd2;\n        collectionArtistSecondaryAddresses[_collectionID].secondaryAdd3 = _secondaryAdd3;\n        collectionArtistSecondaryAddresses[_collectionID].add1Percentage = _add1Percentage;\n        collectionArtistSecondaryAddresses[_collectionID].add2Percentage = _add2Percentage;\n        collectionArtistSecondaryAddresses[_collectionID].add3Percentage = _add3Percentage;\n        collectionArtistSecondaryAddresses[_collectionID].status = false;\n    }\n\n    // function to accept primary addresses and percentages\n\n    function acceptAddressesAndPercentages(uint256 _collectionID, bool _statusPrimary, bool _statusSecondary) public FunctionAdminRequired(this.acceptAddressesAndPercentages.selector) {\n        collectionArtistPrimaryAddresses[_collectionID].status = _statusPrimary;\n        collectionArtistSecondaryAddresses[_collectionID].status = _statusSecondary;\n    }\n\n    // function to pay the artist\n\n    function payArtist(uint256 _collectionID, address _team1, address _team2, uint256 _teamperc1, uint256 _teamperc2) public FunctionAdminRequired(this.payArtist.selector) {\n        require(collectionArtistPrimaryAddresses[_collectionID].status == true, \"Accept Royalties\");\n        require(collectionTotalAmount[_collectionID] > 0, \"Collection Balance must be grater than 0\");\n        require(collectionRoyaltiesPrimarySplits[_collectionID].artistPercentage + _teamperc1 + _teamperc2 == 100, \"Change percentages\");\n        uint256 royalties = collectionTotalAmount[_collectionID];\n        collectionTotalAmount[_collectionID] = 0;\n        address tm1 = _team1;\n        address tm2 = _team2;\n        uint256 colId = _collectionID;\n        uint256 artistRoyalties1;\n        uint256 artistRoyalties2;\n        uint256 artistRoyalties3;\n        uint256 teamRoyalties1;\n        uint256 teamRoyalties2;\n        artistRoyalties1 = royalties * collectionArtistPrimaryAddresses[colId].add1Percentage / 100;\n        artistRoyalties2 = royalties * collectionArtistPrimaryAddresses[colId].add2Percentage / 100;\n        artistRoyalties3 = royalties * collectionArtistPrimaryAddresses[colId].add3Percentage / 100;\n        teamRoyalties1 = royalties * _teamperc1 / 100;\n        teamRoyalties2 = royalties * _teamperc2 / 100;\n        (bool success1, ) = payable(collectionArtistPrimaryAddresses[colId].primaryAdd1).call{value: artistRoyalties1}(\"\");\n        (bool success2, ) = payable(collectionArtistPrimaryAddresses[colId].primaryAdd2).call{value: artistRoyalties2}(\"\");\n        (bool success3, ) = payable(collectionArtistPrimaryAddresses[colId].primaryAdd3).call{value: artistRoyalties3}(\"\");\n        (bool success4, ) = payable(tm1).call{value: teamRoyalties1}(\"\");\n        (bool success5, ) = payable(tm2).call{value: teamRoyalties2}(\"\");\n        emit PayArtist(collectionArtistPrimaryAddresses[colId].primaryAdd1, success1, artistRoyalties1);\n        emit PayArtist(collectionArtistPrimaryAddresses[colId].primaryAdd2, success2, artistRoyalties2);\n        emit PayArtist(collectionArtistPrimaryAddresses[colId].primaryAdd3, success3, artistRoyalties3);\n        emit PayTeam(tm1, success4, teamRoyalties1);\n        emit PayTeam(tm2, success5, teamRoyalties2);\n    }\n\n    // function to update core contract\n\n    function updateCoreContract(address _gencore) public FunctionAdminRequired(this.updateCoreContract.selector) { \n        gencore = INextGenCore(_gencore);\n    }\n\n    // function to update admin contract\n\n    function updateAdminContract(address _newadminsContract) public FunctionAdminRequired(this.updateAdminContract.selector) {\n        require(INextGenAdmins(_newadminsContract).isAdminContract() == true, \"Contract is not Admin\");\n        adminsContract = INextGenAdmins(_newadminsContract);"
    }
  ]
}