{
  "Title": "H-1: Rounding differences when computing the invariant",
  "Content": "# Issue H-1: Rounding differences when computing the invariant \n\nSource: https://github.com/sherlock-audit/2023-10-notional-judging/issues/77 \n\n## Found by \nTri-pathi, lemonmon, shealtielanz, xiaoming90\n## Summary\n\nThe invariant is used to compute the spot price to verify if the pool has been manipulated before executing certain key vault actions (e.g. reinvest rewards). If the inputted invariant is inaccurate, the spot price computed might not be accurate and might not match the actual spot price of the Balancer Pool. In the worst-case scenario, it might potentially fail to detect the pool has been manipulated, and the trade proceeds to execute against the manipulated pool, leading to a loss of assets.\n\n## Vulnerability Detail\n\nThe Balancer's Composable Pool codebase relies on the old version of the `StableMath._calculateInvariant` that allows the caller to specify if the computation should round up or down via the `roundUp` parameter.\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/math/StableMath.sol#L28\n\n```python\nFile: StableMath.sol\n28:     function _calculateInvariant(\n29:         uint256 amplificationParameter,\n30:         uint256[] memory balances,\n31:         bool roundUp\n32:     ) internal pure returns (uint256) {\n33:         /**********************************************************************************************\n34:         // invariant                                                                                 //\n35:         // D = invariant                                                  D^(n+1)                    //\n36:         // A = amplification coefficient      A  n^n S + D = A D n^n + -----------                   //\n37:         // S = sum of balances                                             n^n P                     //\n38:         // P = product of balances                                                                   //\n39:         // n = number of tokens                                                                      //\n40:         *********x************************************************************************************/\n41: \n42:         unchecked {\n43:             // We support rounding up or down.\n44:             uint256 sum = 0;\n45:             uint256 numTokens = balances.length;\n46:             for (uint256 i = 0; i < numTokens; i++) {\n47:                 sum = sum.add(balances[i]);\n48:             }\n49:             if (sum == 0) {\n50:                 return 0;\n51:             }\n52: \n53:             uint256 prevInvariant = 0;\n54:             uint256 invariant = sum;\n55:             uint256 ampTimesTotal = amplificationParameter * numTokens;\n56: \n57:             for (uint256 i = 0; i < 255; i++) {\n58:                 uint256 P_D = balances[0] * numTokens;\n59:                 for (uint256 j = 1; j < numTokens; j++) {\n60:                     P_D = Math.div(Math.mul(Math.mul(P_D, balances[j]), numTokens), invariant, roundUp);\n61:                 }\n62:                 prevInvariant = invariant;\n63:                 invariant = Math.div(\n64:                     Math.mul(Math.mul(numTokens, invariant), invariant).add(\n65:                         Math.div(Math.mul(Math.mul(ampTimesTotal, sum), P_D), _AMP_PRECISION, roundUp)\n66:                     ),\n67:                     Math.mul(numTokens + 1, invariant).add(\n68:                         // No need to use checked arithmetic for the amp precision, the amp is guaranteed to be at least 1\n69:                         Math.div(Math.mul(ampTimesTotal - _AMP_PRECISION, P_D), _AMP_PRECISION, !roundUp)\n70:                     ),\n71:                     roundUp\n72:                 );\n73: \n74:                 if (invariant > prevInvariant) {\n75:                     if (invariant - prevInvariant <= 1) {\n76:                         return invariant;\n77:                     }\n78:                 } else if (prevInvariant - invariant <= 1) {\n79:                     return invariant;\n80:                 }\n81:             }\n82:         }\n83: \n84:         revert CalculationDidNotConverge();\n85:     }\n```\n\nWithin the `BalancerSpotPrice._calculateStableMathSpotPrice` function, the `StableMath._calculateInvariant` is computed rounding up per Line 90 below\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/BalancerSpotPrice.sol#L90\n\n```solidity\nFile: BalancerSpotPrice.sol\n78:     function _calculateStableMathSpotPrice(\n79:         uint256 ampParam,\n80:         uint256[] memory scalingFactors,\n81:         uint256[] memory balances,\n82:         uint256 scaledPrimary,\n83:         uint256 primaryIndex,\n84:         uint256 index2\n85:     ) internal pure returns (uint256 spotPrice) {\n86:         // Apply scale factors\n87:         uint256 secondary = balances[index2] * scalingFactors[index2] / BALANCER_PRECISION;\n88: \n89:         uint256 invariant = StableMath._calculateInvariant(\n90:             ampParam, StableMath._balances(scaledPrimary, secondary), true // round up\n91:         );\n```\n\nThe new Composable Pool contract uses a newer version of the StableMath library where the `StableMath._calculateInvariant` function always rounds down. Following is the StableMath.sol of one of the popular composable pools in Arbitrum that uses the new StableMath library\n\nhttps://arbiscan.io/address/0xade4a71bb62bec25154cfc7e6ff49a513b491e81#code#F28#L57 (Balancer rETH-WETH Stable Pool - Arbitrum)\n\n```solidity\nfunction _calculateInvariant(uint256 amplificationParameter, uint256[] memory balances)\n    internal\n    pure\n    returns (uint256)\n{\n    /**********************************************************************************************\n    // invariant                                                                                 //\n    // D = invariant                                                  D^(n+1)                    //\n    // A = amplification coefficient      A  n^n S + D = A D n^n + -----------                   //\n    // S = sum of balances                                             n^n P                     //\n    // P = product of balances                                                                   //\n    // n = number of tokens                                                                      //\n    **********************************************************************************************/\n\n    // Always round down, to match Vyper's arithmetic (which always truncates).\n    ..SNIP..\n```\n\nThus, Notional rounds up when calculating the invariant, while Balancer's Composable Pool rounds down when calculating the invariant. This inconsistency will result in a different invariant\n\n## Impact\n\nHigh, as per past contest's risk rating - https://github.com/sherlock-audit/2022-12-notional-judging/issues/17\n\nThe invariant is used to compute the spot price to verify if the pool has been manipulated before executing certain key vault actions (e.g. reinvest rewards). If the inputted invariant is inaccurate, the spot price computed might not be accurate and might not match the actual spot price of the Balancer Pool. In the worst-case scenario, it might potentially fail to detect the pool has been manipulated, and the trade proceeds to execute against the manipulated pool, leading to a loss of assets.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/math/StableMath.sol#L28\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/BalancerSpotPrice.sol#L90\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nTo avoid any discrepancy in the result, ensure that the StableMath library used by Balancer's Composable Pool and Notional's leverage vault are aligned, and the implementation of the StableMath functions is the same between them.\n\n\n\n## Discussion\n\n**jeffywu**\n\nValid issue\n\n**jeffywu**\n\nTo some extent this is a duplicate of #83  which is a more complete description of the problem, but will leave that to the judges. It appears that Balancer has tweaked their `_calculateInvariant` implementation in the ComposableStablePool rewrite which included this rounding difference as well as other differences.\n\n**jeffywu**\n\nhttps://github.com/notional-finance/leveraged-vaults/pull/63\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/119",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/math/StableMath.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {Math} from \"./Math.sol\";\nimport {FixedPoint} from \"./FixedPoint.sol\";\n\nlibrary StableMath {\n    using FixedPoint for uint256;\n    \n    uint256 internal constant _AMP_PRECISION = 1e3;\n\n    error CalculationDidNotConverge();\n\n    // Note on unchecked arithmetic:\n    // This contract performs a large number of additions, subtractions, multiplications and divisions, often inside\n    // loops. Since many of these operations are gas-sensitive (as they happen e.g. during a swap), it is important to\n    // not make any unnecessary checks. We rely on a set of invariants to avoid having to use checked arithmetic (the\n    // Math library), including:\n    //  - the number of tokens is bounded by _MAX_STABLE_TOKENS\n    //  - the amplification parameter is bounded by _MAX_AMP * _AMP_PRECISION, which fits in 23 bits\n    //  - the token balances are bounded by 2^112 (guaranteed by the Vault) times 1e18 (the maximum scaling factor),\n    //    which fits in 172 bits\n    //\n    // This means e.g. we can safely multiply a balance by the amplification parameter without worrying about overflow.\n\n    // Computes the invariant given the current balances, using the Newton-Raphson approximation.\n    // The amplification parameter equals: A n^(n-1)\n    function _calculateInvariant(\n        uint256 amplificationParameter,\n        uint256[] memory balances,\n        bool roundUp\n    ) internal pure returns (uint256) {\n        /**********************************************************************************************\n        // invariant                                                                                 //\n        // D = invariant                                                  D^(n+1)                    //\n        // A = amplification coefficient      A  n^n S + D = A D n^n + -----------                   //\n        // S = sum of balances                                             n^n P                     //\n        // P = product of balances                                                                   //\n        // n = number of tokens                                                                      //\n        *********x************************************************************************************/\n\n        unchecked {\n            // We support rounding up or down.\n            uint256 sum = 0;\n            uint256 numTokens = balances.length;\n            for (uint256 i = 0; i < numTokens; i++) {\n                sum = sum.add(balances[i]);\n            }\n            if (sum == 0) {\n                return 0;\n            }\n\n            uint256 prevInvariant = 0;\n            uint256 invariant = sum;\n            uint256 ampTimesTotal = amplificationParameter * numTokens;\n\n            for (uint256 i = 0; i < 255; i++) {\n                uint256 P_D = balances[0] * numTokens;\n                for (uint256 j = 1; j < numTokens; j++) {\n                    P_D = Math.div(Math.mul(Math.mul(P_D, balances[j]), numTokens), invariant, roundUp);\n                }\n                prevInvariant = invariant;\n                invariant = Math.div(\n                    Math.mul(Math.mul(numTokens, invariant), invariant).add(\n                        Math.div(Math.mul(Math.mul(ampTimesTotal, sum), P_D), _AMP_PRECISION, roundUp)\n                    ),\n                    Math.mul(numTokens + 1, invariant).add(\n                        // No need to use checked arithmetic for the amp precision, the amp is guaranteed to be at least 1\n                        Math.div(Math.mul(ampTimesTotal - _AMP_PRECISION, P_D), _AMP_PRECISION, !roundUp)\n                    ),\n                    roundUp\n                );\n\n                if (invariant > prevInvariant) {\n                    if (invariant - prevInvariant <= 1) {\n                        return invariant;\n                    }\n                } else if (prevInvariant - invariant <= 1) {\n                    return invariant;\n                }\n            }\n        }\n\n        revert CalculationDidNotConverge();\n    }\n\n    /**\n     * @dev Calculates the spot price of token Y in token X.\n     */\n    function _calcSpotPrice(\n        uint256 amplificationParameter,\n        uint256 invariant, \n        uint256 balanceX,\n        uint256 balanceY\n    ) internal pure returns (uint256) {\n        /**************************************************************************************************************\n        //                                                                                                           //\n        //                             2.a.x.y + a.y^2 + b.y                                                         //\n        // spot price Y/X = - dx/dy = -----------------------                                                        //\n        //                             2.a.x.y + a.x^2 + b.x                                                         //\n        //                                                                                                           //\n        // n = 2                                                                                                     //\n        // a = amp param * n                                                                                         //\n        // b = D + a.(S - D)                                                                                         //\n        // D = invariant                                                                                             //\n        // S = sum of balances but x,y = 0 since x  and y are the only tokens                                        //\n        **************************************************************************************************************/\n\n        unchecked {\n            uint256 a = (amplificationParameter * 2) / _AMP_PRECISION;\n            uint256 b = Math.mul(invariant, a).sub(invariant);\n\n            uint256 axy2 = Math.mul(a * 2, balanceX).mulDown(balanceY); // n = 2\n\n            // dx = a.x.y.2 + a.y^2 - b.y\n            uint256 derivativeX = axy2.add(Math.mul(a, balanceY).mulDown(balanceY)).sub(b.mulDown(balanceY));\n\n            // dy = a.x.y.2 + a.x^2 - b.x\n            uint256 derivativeY = axy2.add(Math.mul(a, balanceX).mulDown(balanceX)).sub(b.mulDown(balanceX));\n\n            // The rounding direction is irrelevant as we're about to introduce a much larger error when converting to log\n            // space. We use `divUp` as it prevents the result from being zero, which would make the logarithm revert. A\n            // result of zero is therefore only possible with zero balances, which are prevented via other means.\n            return derivativeX.divUp(derivativeY);\n        }\n    }\n\n    function _balances(uint256 balanceX, uint256 balanceY) internal pure returns (uint256[] memory balances) {\n        balances = new uint256[](2);\n        balances[0] = balanceX;\n        balances[1] = balanceY;\n    }\n\n    // This function calculates the balance of a given token (tokenIndex)\n    // given all the other balances and the invariant\n    function _getTokenBalanceGivenInvariantAndAllOtherBalances(\n        uint256 amplificationParameter,\n        uint256[] memory balances,\n        uint256 invariant,\n        uint256 tokenIndex\n    ) internal pure returns (uint256) {\n        // Rounds result up overall\n        unchecked {\n            uint256 ampTimesTotal = amplificationParameter * balances.length;\n            uint256 sum = balances[0];\n            uint256 P_D = balances[0] * balances.length;\n            for (uint256 j = 1; j < balances.length; j++) {\n                P_D = Math.divDown(Math.mul(Math.mul(P_D, balances[j]), balances.length), invariant);\n                sum = sum.add(balances[j]);\n            }\n            // No need to use safe math, based on the loop above `sum` is greater than or equal to `balances[tokenIndex]`\n            sum = sum - balances[tokenIndex];\n\n            uint256 inv2 = Math.mul(invariant, invariant);\n            // We remove the balance fromm c by multiplying it\n            uint256 c = Math.mul(\n                Math.mul(Math.divUp(inv2, Math.mul(ampTimesTotal, P_D)), _AMP_PRECISION),\n                balances[tokenIndex]\n            );\n            uint256 b = sum.add(Math.mul(Math.divDown(invariant, ampTimesTotal), _AMP_PRECISION));\n\n            // We iterate to find the balance\n            uint256 prevTokenBalance = 0;\n            // We multiply the first iteration outside the loop with the invariant to set the value of the\n            // initial approximation.\n            uint256 tokenBalance = Math.divUp(inv2.add(c), invariant.add(b));\n\n            for (uint256 i = 0; i < 255; i++) {\n                prevTokenBalance = tokenBalance;\n\n                tokenBalance = Math.divUp(\n                    Math.mul(tokenBalance, tokenBalance).add(c),\n                    Math.mul(tokenBalance, 2).add(b).sub(invariant)\n                );\n\n                if (tokenBalance > prevTokenBalance) {\n                    if (tokenBalance - prevTokenBalance <= 1) {\n                        return tokenBalance;\n                    }\n                } else if (prevTokenBalance - tokenBalance <= 1) {\n                    return tokenBalance;\n                }\n            }\n        }\n\n        revert CalculationDidNotConverge();\n    }\n\n    function _calcTokenOutGivenExactBptIn(\n        uint256 amp,\n        uint256[] memory balances,\n        uint256 tokenIndex,\n        uint256 bptAmountIn,\n        uint256 bptTotalSupply,\n        uint256 swapFeePercentage,\n        uint256 currentInvariant\n    ) internal pure returns (uint256) {\n        // Token out, so we round down overall.\n\n        unchecked {\n            uint256 newInvariant = bptTotalSupply.sub(bptAmountIn).divUp(bptTotalSupply).mulUp(currentInvariant);\n\n            // Calculate amount out without fee\n            uint256 newBalanceTokenIndex = _getTokenBalanceGivenInvariantAndAllOtherBalances(\n                amp,\n                balances,\n                newInvariant,\n                tokenIndex\n            );\n            uint256 amountOutWithoutFee = balances[tokenIndex].sub(newBalanceTokenIndex);\n\n            // First calculate the sum of all token balances, which will be used to calculate\n            // the current weight of each token\n            uint256 sumBalances = 0;\n            for (uint256 i = 0; i < balances.length; i++) {\n                sumBalances = sumBalances.add(balances[i]);\n            }\n\n            // We can now compute how much excess balance is being withdrawn as a result of the virtual swaps, which result\n            // in swap fees.\n            uint256 currentWeight = balances[tokenIndex].divDown(sumBalances);\n            uint256 taxablePercentage = currentWeight.complement();\n\n            // Swap fees are typically charged on 'token in', but there is no 'token in' here, so we apply it\n            // to 'token out'. This results in slightly larger price impact. Fees are rounded up.\n            uint256 taxableAmount = amountOutWithoutFee.mulUp(taxablePercentage);\n            uint256 nonTaxableAmount = amountOutWithoutFee.sub(taxableAmount);\n\n            // No need to use checked arithmetic for the swap fee, it is guaranteed to be lower than 50%\n            return nonTaxableAmount.add(taxableAmount.mulDown(FixedPoint.ONE - swapFeePercentage));\n        }\n    }\n\n    // Computes how many tokens can be taken out of a pool if `tokenAmountIn` are sent, given the current balances.\n    // The amplification parameter equals: A n^(n-1)\n    function _calcOutGivenIn(\n        uint256 amplificationParameter,\n        uint256[] memory balances,\n        uint256 tokenIndexIn,\n        uint256 tokenIndexOut,\n        uint256 tokenAmountIn,\n        uint256 invariant\n    ) internal pure returns (uint256) {\n        /**************************************************************************************************************\n        // outGivenIn token x for y - polynomial equation to solve                                                   //\n        // ay = amount out to calculate                                                                              //\n        // by = balance token out                                                                                    //\n        // y = by - ay (finalBalanceOut)                                                                             //\n        // D = invariant                                               D                     D^(n+1)                 //\n        // A = amplification coefficient               y^2 + ( S - ----------  - D) * y -  ------------- = 0         //\n        // n = number of tokens                                    (A * n^n)               A * n^2n * P              //\n        // S = sum of final balances but y                                                                           //\n        // P = product of final balances but y                                                                       //\n        **************************************************************************************************************/\n\n        // Amount out, so we round down overall.\n        unchecked {\n            balances[tokenIndexIn] = balances[tokenIndexIn].add(tokenAmountIn);\n\n            uint256 finalBalanceOut = _getTokenBalanceGivenInvariantAndAllOtherBalances(\n                amplificationParameter,\n                balances,\n                invariant,\n                tokenIndexOut\n            );\n\n            // No need to use checked arithmetic since `tokenAmountIn` was actually added to the same balance right before\n            // calling `_getTokenBalanceGivenInvariantAndAllOtherBalances` which doesn't alter the balances array.\n            balances[tokenIndexIn] = balances[tokenIndexIn] - tokenAmountIn;\n\n            return balances[tokenIndexOut].sub(finalBalanceOut).sub(1);\n        }\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/BalancerSpotPrice.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport \"forge-std/console.sol\";\nimport {Deployments} from \"../../global/Deployments.sol\";\nimport {StableMath} from \"./math/StableMath.sol\";\nimport {IComposablePool, IWeightedPool} from \"../../../interfaces/balancer/IBalancerPool.sol\";\nimport {IBalancerVault} from \"../../../interfaces/balancer/IBalancerVault.sol\";\n\n/**\n * @notice External, singleton helper contract deployed to calculate spot prices for Balancer pools.\n * Currently supports Composable pools with any number of tokens and Weighted2Token pools.\n */\ncontract BalancerSpotPrice {\n    uint256 internal constant BALANCER_PRECISION = 1e18;\n\n    /// @notice Returns the weighted pool spot price and balances. Only the spot price on the\n    /// secondary token is returned.\n    function getWeightedSpotPrices(\n        bytes32 poolId,\n        address poolAddress,\n        uint256 primaryIndex,\n        uint8 primaryDecimals\n    ) external view returns (uint256[] memory balances, uint256[] memory spotPrices) {\n        (/* */, balances, /* */) = Deployments.BALANCER_VAULT.getPoolTokens(poolId);\n        // Only two token pools are supported\n        require(balances.length == 2);\n        spotPrices = new uint256[](2);\n\n        uint256[] memory weights = IWeightedPool(poolAddress).getNormalizedWeights();\n\n        // Spot price calculation is specified at the link below. Do not account for swap fees\n        // because we're using this price to compare to the oracle price and adding swap fees\n        // would unnecessarily increase the price deviation.\n        // https://docs.balancer.fi/reference/math/weighted-math.html#typescript\n        // secondaryBalance * primaryWeight * primaryDecimals \n        // --------------------------------------------------- \n        //          primaryBalance * secondaryWeight\n        uint256 secondaryIndex = 1 - primaryIndex;\n\n        // There is a chance of a uint256 overflow if the balances[secondaryIndex] > 10**36\n        uint256 numerator = balances[secondaryIndex] * weights[primaryIndex] * (10 ** primaryDecimals);\n        uint256 denominator = balances[primaryIndex] * weights[secondaryIndex];\n        spotPrices[secondaryIndex] = numerator / denominator;\n    }\n\n    /// @notice Returns the composable pool spot price and balances. Pool token spot\n    /// prices are not returned, pool token balance is returned.\n    function getComposableSpotPrices(\n        bytes32 poolId,\n        address poolAddress,\n        uint256 primaryIndex\n    ) external view returns (uint256[] memory balances, uint256[] memory spotPrices) {\n        address[] memory tokens;\n        (tokens, balances, /* */) = Deployments.BALANCER_VAULT.getPoolTokens(poolId);\n        uint256[] memory scalingFactors = IComposablePool(poolAddress).getScalingFactors();\n\n        (\n            uint256 ampParam,\n            /* bool isUpdating */,\n            uint256 precision\n        ) = IComposablePool(poolAddress).getAmplificationParameter();\n        require(precision == StableMath._AMP_PRECISION);\n\n        // The primary index spot price is left as zero.\n        spotPrices = new uint256[](tokens.length);\n        uint256 scaledPrimary = balances[primaryIndex] * scalingFactors[primaryIndex] / BALANCER_PRECISION;\n        for (uint256 i; i < tokens.length; i++) {\n            if (i == primaryIndex) continue;\n            if (tokens[i] == poolAddress) continue;\n\n            spotPrices[i] = _calculateStableMathSpotPrice(\n                ampParam, scalingFactors, balances, scaledPrimary, primaryIndex, i\n            );\n        }\n    }\n\n    function _calculateStableMathSpotPrice(\n        uint256 ampParam,\n        uint256[] memory scalingFactors,\n        uint256[] memory balances,\n        uint256 scaledPrimary,\n        uint256 primaryIndex,\n        uint256 index2\n    ) internal pure returns (uint256 spotPrice) {\n        // Apply scale factors\n        uint256 secondary = balances[index2] * scalingFactors[index2] / BALANCER_PRECISION;\n\n        uint256 invariant = StableMath._calculateInvariant(\n            ampParam, StableMath._balances(scaledPrimary, secondary), true // round up\n        );\n\n        spotPrice = StableMath._calcSpotPrice(ampParam, invariant, scaledPrimary, secondary);\n\n        // Remove scaling factors from spot price\n        spotPrice = spotPrice * scalingFactors[primaryIndex] / scalingFactors[index2];\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/math/StableMath.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {Math} from \"./Math.sol\";\nimport {FixedPoint} from \"./FixedPoint.sol\";\n\nlibrary StableMath {\n    using FixedPoint for uint256;\n    \n    uint256 internal constant _AMP_PRECISION = 1e3;\n\n    error CalculationDidNotConverge();\n\n    // Note on unchecked arithmetic:\n    // This contract performs a large number of additions, subtractions, multiplications and divisions, often inside\n    // loops. Since many of these operations are gas-sensitive (as they happen e.g. during a swap), it is important to\n    // not make any unnecessary checks. We rely on a set of invariants to avoid having to use checked arithmetic (the\n    // Math library), including:\n    //  - the number of tokens is bounded by _MAX_STABLE_TOKENS\n    //  - the amplification parameter is bounded by _MAX_AMP * _AMP_PRECISION, which fits in 23 bits\n    //  - the token balances are bounded by 2^112 (guaranteed by the Vault) times 1e18 (the maximum scaling factor),\n    //    which fits in 172 bits\n    //\n    // This means e.g. we can safely multiply a balance by the amplification parameter without worrying about overflow.\n\n    // Computes the invariant given the current balances, using the Newton-Raphson approximation.\n    // The amplification parameter equals: A n^(n-1)\n    function _calculateInvariant(\n        uint256 amplificationParameter,\n        uint256[] memory balances,\n        bool roundUp\n    ) internal pure returns (uint256) {\n        /**********************************************************************************************\n        // invariant                                                                                 //\n        // D = invariant                                                  D^(n+1)                    //\n        // A = amplification coefficient      A  n^n S + D = A D n^n + -----------                   //\n        // S = sum of balances                                             n^n P                     //\n        // P = product of balances                                                                   //\n        // n = number of tokens                                                                      //\n        *********x************************************************************************************/\n\n        unchecked {\n            // We support rounding up or down.\n            uint256 sum = 0;\n            uint256 numTokens = balances.length;\n            for (uint256 i = 0; i < numTokens; i++) {\n                sum = sum.add(balances[i]);\n            }\n            if (sum == 0) {\n                return 0;\n            }\n\n            uint256 prevInvariant = 0;\n            uint256 invariant = sum;\n            uint256 ampTimesTotal = amplificationParameter * numTokens;\n\n            for (uint256 i = 0; i < 255; i++) {\n                uint256 P_D = balances[0] * numTokens;\n                for (uint256 j = 1; j < numTokens; j++) {\n                    P_D = Math.div(Math.mul(Math.mul(P_D, balances[j]), numTokens), invariant, roundUp);\n                }\n                prevInvariant = invariant;\n                invariant = Math.div(\n                    Math.mul(Math.mul(numTokens, invariant), invariant).add(\n                        Math.div(Math.mul(Math.mul(ampTimesTotal, sum), P_D), _AMP_PRECISION, roundUp)\n                    ),\n                    Math.mul(numTokens + 1, invariant).add(\n                        // No need to use checked arithmetic for the amp precision, the amp is guaranteed to be at least 1\n                        Math.div(Math.mul(ampTimesTotal - _AMP_PRECISION, P_D), _AMP_PRECISION, !roundUp)\n                    ),\n                    roundUp\n                );\n\n                if (invariant > prevInvariant) {\n                    if (invariant - prevInvariant <= 1) {\n                        return invariant;\n                    }\n                } else if (prevInvariant - invariant <= 1) {\n                    return invariant;\n                }\n            }\n        }\n\n        revert CalculationDidNotConverge();\n    }\n\n    /**\n     * @dev Calculates the spot price of token Y in token X.\n     */\n    function _calcSpotPrice(\n        uint256 amplificationParameter,\n        uint256 invariant, \n        uint256 balanceX,\n        uint256 balanceY\n    ) internal pure returns (uint256) {\n        /**************************************************************************************************************\n        //                                                                                                           //\n        //                             2.a.x.y + a.y^2 + b.y                                                         //\n        // spot price Y/X = - dx/dy = -----------------------                                                        //\n        //                             2.a.x.y + a.x^2 + b.x                                                         //\n        //                                                                                                           //\n        // n = 2                                                                                                     //\n        // a = amp param * n                                                                                         //\n        // b = D + a.(S - D)                                                                                         //\n        // D = invariant                                                                                             //\n        // S = sum of balances but x,y = 0 since x  and y are the only tokens                                        //\n        **************************************************************************************************************/\n\n        unchecked {\n            uint256 a = (amplificationParameter * 2) / _AMP_PRECISION;\n            uint256 b = Math.mul(invariant, a).sub(invariant);\n\n            uint256 axy2 = Math.mul(a * 2, balanceX).mulDown(balanceY); // n = 2\n\n            // dx = a.x.y.2 + a.y^2 - b.y\n            uint256 derivativeX = axy2.add(Math.mul(a, balanceY).mulDown(balanceY)).sub(b.mulDown(balanceY));\n\n            // dy = a.x.y.2 + a.x^2 - b.x\n            uint256 derivativeY = axy2.add(Math.mul(a, balanceX).mulDown(balanceX)).sub(b.mulDown(balanceX));\n\n            // The rounding direction is irrelevant as we're about to introduce a much larger error when converting to log\n            // space. We use `divUp` as it prevents the result from being zero, which would make the logarithm revert. A\n            // result of zero is therefore only possible with zero balances, which are prevented via other means.\n            return derivativeX.divUp(derivativeY);\n        }\n    }\n\n    function _balances(uint256 balanceX, uint256 balanceY) internal pure returns (uint256[] memory balances) {\n        balances = new uint256[](2);\n        balances[0] = balanceX;\n        balances[1] = balanceY;\n    }\n\n    // This function calculates the balance of a given token (tokenIndex)\n    // given all the other balances and the invariant\n    function _getTokenBalanceGivenInvariantAndAllOtherBalances(\n        uint256 amplificationParameter,\n        uint256[] memory balances,\n        uint256 invariant,\n        uint256 tokenIndex\n    ) internal pure returns (uint256) {\n        // Rounds result up overall\n        unchecked {\n            uint256 ampTimesTotal = amplificationParameter * balances.length;\n            uint256 sum = balances[0];\n            uint256 P_D = balances[0] * balances.length;\n            for (uint256 j = 1; j < balances.length; j++) {\n                P_D = Math.divDown(Math.mul(Math.mul(P_D, balances[j]), balances.length), invariant);\n                sum = sum.add(balances[j]);\n            }\n            // No need to use safe math, based on the loop above `sum` is greater than or equal to `balances[tokenIndex]`\n            sum = sum - balances[tokenIndex];\n\n            uint256 inv2 = Math.mul(invariant, invariant);\n            // We remove the balance fromm c by multiplying it\n            uint256 c = Math.mul(\n                Math.mul(Math.divUp(inv2, Math.mul(ampTimesTotal, P_D)), _AMP_PRECISION),\n                balances[tokenIndex]\n            );\n            uint256 b = sum.add(Math.mul(Math.divDown(invariant, ampTimesTotal), _AMP_PRECISION));\n\n            // We iterate to find the balance\n            uint256 prevTokenBalance = 0;\n            // We multiply the first iteration outside the loop with the invariant to set the value of the\n            // initial approximation.\n            uint256 tokenBalance = Math.divUp(inv2.add(c), invariant.add(b));\n\n            for (uint256 i = 0; i < 255; i++) {\n                prevTokenBalance = tokenBalance;\n\n                tokenBalance = Math.divUp(\n                    Math.mul(tokenBalance, tokenBalance).add(c),\n                    Math.mul(tokenBalance, 2).add(b).sub(invariant)\n                );\n\n                if (tokenBalance > prevTokenBalance) {\n                    if (tokenBalance - prevTokenBalance <= 1) {\n                        return tokenBalance;\n                    }\n                } else if (prevTokenBalance - tokenBalance <= 1) {\n                    return tokenBalance;\n                }\n            }\n        }\n\n        revert CalculationDidNotConverge();\n    }\n\n    function _calcTokenOutGivenExactBptIn(\n        uint256 amp,\n        uint256[] memory balances,\n        uint256 tokenIndex,\n        uint256 bptAmountIn,\n        uint256 bptTotalSupply,\n        uint256 swapFeePercentage,\n        uint256 currentInvariant\n    ) internal pure returns (uint256) {\n        // Token out, so we round down overall.\n\n        unchecked {\n            uint256 newInvariant = bptTotalSupply.sub(bptAmountIn).divUp(bptTotalSupply).mulUp(currentInvariant);\n\n            // Calculate amount out without fee\n            uint256 newBalanceTokenIndex = _getTokenBalanceGivenInvariantAndAllOtherBalances(\n                amp,\n                balances,\n                newInvariant,\n                tokenIndex\n            );\n            uint256 amountOutWithoutFee = balances[tokenIndex].sub(newBalanceTokenIndex);\n\n            // First calculate the sum of all token balances, which will be used to calculate\n            // the current weight of each token\n            uint256 sumBalances = 0;\n            for (uint256 i = 0; i < balances.length; i++) {\n                sumBalances = sumBalances.add(balances[i]);\n            }\n\n            // We can now compute how much excess balance is being withdrawn as a result of the virtual swaps, which result\n            // in swap fees.\n            uint256 currentWeight = balances[tokenIndex].divDown(sumBalances);\n            uint256 taxablePercentage = currentWeight.complement();\n\n            // Swap fees are typically charged on 'token in', but there is no 'token in' here, so we apply it\n            // to 'token out'. This results in slightly larger price impact. Fees are rounded up.\n            uint256 taxableAmount = amountOutWithoutFee.mulUp(taxablePercentage);\n            uint256 nonTaxableAmount = amountOutWithoutFee.sub(taxableAmount);\n\n            // No need to use checked arithmetic for the swap fee, it is guaranteed to be lower than 50%\n            return nonTaxableAmount.add(taxableAmount.mulDown(FixedPoint.ONE - swapFeePercentage));\n        }\n    }\n\n    // Computes how many tokens can be taken out of a pool if `tokenAmountIn` are sent, given the current balances.\n    // The amplification parameter equals: A n^(n-1)\n    function _calcOutGivenIn(\n        uint256 amplificationParameter,\n        uint256[] memory balances,\n        uint256 tokenIndexIn,\n        uint256 tokenIndexOut,\n        uint256 tokenAmountIn,\n        uint256 invariant\n    ) internal pure returns (uint256) {\n        /**************************************************************************************************************\n        // outGivenIn token x for y - polynomial equation to solve                                                   //\n        // ay = amount out to calculate                                                                              //\n        // by = balance token out                                                                                    //\n        // y = by - ay (finalBalanceOut)                                                                             //\n        // D = invariant                                               D                     D^(n+1)                 //\n        // A = amplification coefficient               y^2 + ( S - ----------  - D) * y -  ------------- = 0         //\n        // n = number of tokens                                    (A * n^n)               A * n^2n * P              //\n        // S = sum of final balances but y                                                                           //\n        // P = product of final balances but y                                                                       //\n        **************************************************************************************************************/\n\n        // Amount out, so we round down overall.\n        unchecked {\n            balances[tokenIndexIn] = balances[tokenIndexIn].add(tokenAmountIn);\n\n            uint256 finalBalanceOut = _getTokenBalanceGivenInvariantAndAllOtherBalances(\n                amplificationParameter,\n                balances,\n                invariant,\n                tokenIndexOut\n            );\n\n            // No need to use checked arithmetic since `tokenAmountIn` was actually added to the same balance right before\n            // calling `_getTokenBalanceGivenInvariantAndAllOtherBalances` which doesn't alter the balances array.\n            balances[tokenIndexIn] = balances[tokenIndexIn] - tokenAmountIn;\n\n            return balances[tokenIndexOut].sub(finalBalanceOut).sub(1);\n        }\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/BalancerSpotPrice.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport \"forge-std/console.sol\";\nimport {Deployments} from \"../../global/Deployments.sol\";\nimport {StableMath} from \"./math/StableMath.sol\";\nimport {IComposablePool, IWeig"
    }
  ]
}