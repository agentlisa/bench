{
  "Title": "[H-03] Wrong invocation of Whirpools's updateFeesAndRewards will cause it to always revert",
  "Content": "\nDeposits will be unwithdrawable from the lockbox.\n\n### Proof of Concept\n\nIf the entire liquidity of a position has been removed, the withdraw function calls the `updateFeesAndRewards` function on the Orca pool before attempting to close the position.\n\n<https://github.com/code-423n4/2023-12-autonolas/blob/2a095eb1f8359be349d23af67089795fb0be4ed1/lockbox-solana/solidity/liquidity_lockbox.sol#L277-L293>\n\n```solidity\n    function withdraw(uint64 amount) external {\n        address positionAddress = positionAccounts[firstAvailablePositionAccountIndex];\n      \n        ......\n\n        uint64 positionLiquidity = mapPositionAccountLiquidity[positionAddress];\n        \n        ......\n\n        uint64 remainder = positionLiquidity - amount;\n\n        ......\n\n        if (remainder == 0) {\n            // Update fees for the position\n            AccountMeta[4] metasUpdateFees = [\n                AccountMeta({pubkey: pool, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: positionAddress, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.tickArrayLower.key, is_writable: false, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.tickArrayUpper.key, is_writable: false, is_signer: false})\n            ];\n            whirlpool.updateFeesAndRewards{accounts: metasUpdateFees, seeds: [[pdaProgramSeed, pdaBump]]}();\n```\n\nThis is faulty as the `updateFeesAndRewards` function will always revert if the position's liquidity is 0.\n\n<https://github.com/code-423n4/2023-12-autonolas/blob/2a095eb1f8359be349d23af67089795fb0be4ed1/lockbox-solana/solidity/interfaces/whirlpool.sol#L198>\n\n### Whirlpool source code:\n\n[update_fees_and_rewards](https://github.com/orca-so/whirlpools/blob/3206c9cdfbf27c73c30cbcf5b6df2929cbf87618/programs/whirlpool/src/instructions/update_fees_and_rewards.rs#L27) -> [calculate_fee_and_reward_growths](https://github.com/orca-so/whirlpools/blob/3206c9cdfbf27c73c30cbcf5b6df2929cbf87618/programs/whirlpool/src/manager/liquidity_manager.rs#L72) -> [\\_calculate_modify_liquidity](https://github.com/orca-so/whirlpools/blob/3206c9cdfbf27c73c30cbcf5b6df2929cbf87618/programs/whirlpool/src/manager/liquidity_manager.rs#L97-L99)\n\n<https://github.com/orca-so/whirlpools/blob/3206c9cdfbf27c73c30cbcf5b6df2929cbf87618/programs/whirlpool/src/manager/liquidity_manager.rs#L97-L99>\n\n```rs\nfn _calculate_modify_liquidity(\n    whirlpool: &Whirlpool,\n    position: &Position,\n    tick_lower: &Tick,\n    tick_upper: &Tick,\n    tick_lower_index: i32,\n    tick_upper_index: i32,\n    liquidity_delta: i128,\n    timestamp: u64,\n) -> Result<ModifyLiquidityUpdate> {\n    // Disallow only updating position fee and reward growth when position has zero liquidity\n    if liquidity_delta == 0 && position.liquidity == 0 {\n        return Err(ErrorCode::LiquidityZero.into());\n    }\n```\n\nSince the withdrawal positions are chosen sequentially, only a maximum of (first position's liquidity - 1) amount of liquidity can be withdrawn.\n\n### POC Test\n\n<https://gist.github.com/10xhash/a687ef66de8210444a41360b86ed4bca>\n\n### Recommended Mitigation Steps\n\nAvoid the `update_fees_and_rewards` call completely since fees and rewards would be updated in the `decreaseLiquidity` call.\n\n**[kupermind commented](https://github.com/code-423n4/2023-12-autonolas-findings/issues/386#issuecomment-1906925501):**\n > We have changed the order of operations in our rust program indeed, and it works there. Verified the order of instructions provided here and it fails if the remainder is zero.\n\n_Note: See full discussion [here](https://github.com/code-423n4/2023-12-autonolas-findings/issues/386)._\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-12-autonolas",
  "Code": [
    {
      "filename": "lockbox-solana/solidity/liquidity_lockbox.sol",
      "content": "import \"./library/spl_token.sol\";\nimport \"./interfaces/whirlpool.sol\";\n\n// Position struct\nstruct Position {\n    // Whirlpool (LP pool) address, 32 bytes\n    address whirlpool;\n    // Position mint (liquidity NFT) address, 32 bytes\n    address positionMint;\n    // Position liquidity, 16 bytes\n    uint128 liquidity;\n    // Tick lower index, 4 bytes\n    int32 tickLowerIndex;\n    /// Tick upper index, 4 bytes\n    int32 tickUpperIndex;\n}\n\n/// @dev The liquidity in the position cannot be practically bigger than the max of uint64 since\n///      spl token functions are limited by the uint64 value.\n\n@program_id(\"GUGGHzwC8wEKY3g7QS38YmoS8t5Q2faWAGAfxDK2bXbb\")\ncontract liquidity_lockbox {\n    // Orca whirlpool program address\n    address public constant orca = address\"whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc\";\n    // Whirlpool (LP) pool address\n    address public pool;\n    // Current program owned PDA account address\n    address public pdaProgram;\n    // Bridged token mint address\n    address public bridgedTokenMint;\n    // PDA bridged token account address\n    address public pdaBridgedTokenAccount;\n    // PDA header for position account\n    uint64 public pdaHeader = 0xd0f7407ae48fbcaa;\n    // Program PDA seed\n    bytes public constant pdaProgramSeed = \"pdaProgram\";\n    // Program PDA bump\n    bytes1 public pdaBump;\n    int32 public constant minTickLowerIndex = -443632;\n    int32 public constant maxTickLowerIndex = 443632;\n\n    // Total number of token accounts (even those that hold no positions anymore)\n    uint32 public numPositionAccounts;\n    // First available account index in the set of accounts;\n    uint32 public firstAvailablePositionAccountIndex;\n    // Total liquidity in a lockbox\n    uint64 public totalLiquidity;\n\n    //\n    mapping(address => uint64) public mapPositionAccountLiquidity;\n    mapping(address => address) public mapPositionAccountPdaAta;\n    address[type(uint32).max] public positionAccounts;\n\n    @space(10000)\n    @payer(payer)\n    @seed(\"pdaProgram\")\n    constructor(\n        address _pool,\n        address _bridgedTokenMint,\n        address _pdaBridgedTokenAccount,\n        @bump bytes1 _bump\n    ) {\n        pool = _pool;\n        bridgedTokenMint = _bridgedTokenMint;\n        pdaBridgedTokenAccount = _pdaBridgedTokenAccount;\n\n        // Independently derive the PDA address from the seeds, bump, and programId\n        (address pda, bytes1 bump) = try_find_program_address([\"pdaProgram\"], type(liquidity_lockbox).program_id);\n\n        // Verify that the bump passed to the constructor matches the bump derived from the seeds and programId\n        if (bump != _bump) {\n            revert(\"Invalid bump\");\n        }\n\n        // Assign pda and bump\n        pdaProgram = pda;\n        pdaBump = bump;\n    }\n\n    /// @dev Gets the position data.\n    /// @param position Position account.\n    /// @param positionMint Position mint (NFT).\n    /// @return positionData Position data.\n    function _getPositionData(AccountInfo position, address positionMint) internal view returns (Position positionData) {\n        // Extract the position data\n        positionData = Position({\n            whirlpool: position.data.readAddress(8),\n            positionMint: position.data.readAddress(40),\n            liquidity: position.data.readUint128LE(72),\n            tickLowerIndex: position.data.readInt32LE(88),\n            tickUpperIndex: position.data.readInt32LE(92)\n        });\n\n        // Check that the liquidity is within uint64 bounds\n        if (positionData.liquidity > type(uint64).max) {\n            revert(\"Liquidity overflow\");\n        }\n\n        // Check the whirlpool\n        if (positionData.whirlpool != pool) {\n            revert(\"Wrong pool address\");\n        }\n\n        // Check the NFT address\n        if (positionData.positionMint != positionMint) {\n            revert(\"Wrong NFT address\");\n        }\n\n        // Check tick values\n        if (positionData.tickLowerIndex != minTickLowerIndex || positionData.tickUpperIndex != maxTickLowerIndex) {\n            revert(\"Wrong ticks\");\n        }\n\n        // Check the PDA ownership\n        if (position.owner != orca) {\n            revert(\"Wrong PDA owner\");\n        }\n\n        // Check the PDA header data\n        uint64 header = position.data.readUint64LE(0);\n        if (header != pdaHeader) {\n            revert(\"Wrong PDA header\");\n        }\n\n        // Check the PDA address correctness\n        (address pdaPosition, ) = try_find_program_address([\"position\", positionData.positionMint], orca);\n        if (pdaPosition != position.key) {\n            revert(\"Wrong position PDA\");\n        }\n    }\n\n    /// @dev Deposits the position mint (NFT) in order to get a corresponding liquidity amount of bridged tokens\n    @mutableAccount(userPositionAccount)\n    @mutableAccount(pdaPositionAccount)\n    @mutableAccount(userBridgedTokenAccount)\n    @mutableAccount(bridgedTokenMint)\n    @account(position)\n    @account(positionMint)\n    @signer(userWallet)\n    function deposit() external {\n        // Get the position data based on provided accounts\n        Position positionData = _getPositionData(tx.accounts.position, tx.accounts.positionMint.key);\n\n        uint64 positionLiquidity = uint64(positionData.liquidity);\n\n        // Check that the mint of the user position ATA matches the position mint\n        address positionMint = tx.accounts.userPositionAccount.data.readAddress(0);\n        if (positionMint != tx.accounts.positionMint.key) {\n            revert(\"Wrong user position ATA\");\n        }\n\n        // Check that the bridged token mint account is correct\n        if (tx.accounts.bridgedTokenMint.key != bridgedTokenMint) {\n            revert(\"Wrong bridged token mint account\");\n        }\n\n        // PDA position account owner must be the PDA program account\n        address pdaPositionOwner = tx.accounts.pdaPositionAccount.data.readAddress(32);\n        if (pdaPositionOwner != pdaProgram) {\n            revert(\"Wrong PDA position owner\");\n        }\n\n        // Transfer the position NFT to the pdaPositionAccount address of this program\n        SplToken.transfer(\n            tx.accounts.userPositionAccount.key,\n            tx.accounts.pdaPositionAccount.key,\n            tx.accounts.userWallet.key,\n            1);\n\n        // Mint bridged tokens to the user\n        SplToken.pda_mint_to(\n            bridgedTokenMint,\n            tx.accounts.userBridgedTokenAccount.key,\n            pdaProgram,\n            positionLiquidity,\n            pdaProgramSeed,\n            pdaBump);\n\n        // Record position liquidity amount and its correspondent account address\n        address positionAddress = tx.accounts.position.key;\n        mapPositionAccountLiquidity[positionAddress] = positionLiquidity;\n        address pdaPositionAta = tx.accounts.pdaPositionAccount.key;\n        mapPositionAccountPdaAta[positionAddress] = pdaPositionAta;\n        positionAccounts[numPositionAccounts] = positionAddress;\n\n        // Increase the total number of positions\n        numPositionAccounts++;\n        // Increase the amount of total liquidity\n        totalLiquidity += positionLiquidity;\n    }\n\n    /// @dev Withdraws LP tokens separately to each token ATA and burns provided bridge tokens.\n    /// @param amount Bridged token amount.\n    @mutableAccount(pool)\n    @account(tokenProgramId)\n    @mutableAccount(position)\n    @mutableAccount(userBridgedTokenAccount)\n    @mutableAccount(pdaBridgedTokenAccount)\n    @mutableAccount(userWallet)\n    @mutableAccount(bridgedTokenMint)\n    @mutableAccount(pdaPositionAccount)\n    @mutableAccount(userTokenAccountA)\n    @mutableAccount(userTokenAccountB)\n    @mutableAccount(tokenVaultA)\n    @mutableAccount(tokenVaultB)\n    @mutableAccount(tickArrayLower)\n    @mutableAccount(tickArrayUpper)\n    @mutableAccount(positionMint)\n    @signer(sig)\n    function withdraw(uint64 amount) external {\n        address positionAddress = positionAccounts[firstAvailablePositionAccountIndex];\n        if (positionAddress != tx.accounts.position.key) {\n            revert(\"Wrong liquidity token account\");\n        }\n\n        address pdaPositionAta = tx.accounts.pdaPositionAccount.key;\n        if (mapPositionAccountPdaAta[positionAddress] != pdaPositionAta) {\n            revert(\"Wrong position ATA\");\n        }\n\n        uint64 positionLiquidity = mapPositionAccountLiquidity[positionAddress];\n        // Check that the token account exists\n        if (positionLiquidity == 0) {\n            revert(\"No liquidity on a provided token account\");\n        }\n\n        // Check the requested amount to be smaller or equal than the position liquidity\n        if (amount > positionLiquidity) {\n            revert(\"Amount exceeds a position liquidity\");\n        }\n\n        // Check the pdaBridgedTokenAccount address\n        if (tx.accounts.pdaBridgedTokenAccount.key != pdaBridgedTokenAccount) {\n            revert(\"Wrong PDA bridged token ATA\");\n        }\n\n        // Check that the pool is correct\n        if (tx.accounts.pool.key != pool) {\n            revert(\"Pool address is incorrect\");\n        }\n\n        // Check that the bridged token mint account is correct\n        if (tx.accounts.bridgedTokenMint.key != bridgedTokenMint) {\n            revert(\"Wrong bridged token mint account\");\n        }\n\n        // Transfer bridged tokens to the pdaBridgedTokenAccount address of this program\n        SplToken.transfer(\n            tx.accounts.userBridgedTokenAccount.key,\n            pdaBridgedTokenAccount,\n            tx.accounts.userWallet.key,\n            amount);\n\n        // Decrease the total liquidity amount\n        totalLiquidity -= amount;\n\n        // Burn acquired bridged tokens\n        SplToken.pda_burn(pdaBridgedTokenAccount, bridgedTokenMint, pdaProgram, amount, pdaProgramSeed, pdaBump);\n\n        // Decrease the position liquidity\n        AccountMeta[11] metasDecreaseLiquidity = [\n            AccountMeta({pubkey: pool, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: SplToken.tokenProgramId, is_writable: false, is_signer: false}),\n            AccountMeta({pubkey: pdaProgram, is_writable: false, is_signer: true}),\n            AccountMeta({pubkey: positionAddress, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: pdaPositionAta, is_writable: false, is_signer: false}),\n            AccountMeta({pubkey: tx.accounts.userTokenAccountA.key, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: tx.accounts.userTokenAccountB.key, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: tx.accounts.tokenVaultA.key, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: tx.accounts.tokenVaultB.key, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: tx.accounts.tickArrayLower.key, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: tx.accounts.tickArrayUpper.key, is_writable: true, is_signer: false})\n        ];\n        // a026d06f685b2c01 - decreaseLiquidity, eff0ae00000000000000000000000000 - amount, aaf1950200000000 - minA, b8522d0000000000 - minB\n        // bytes bincode = \"0xa026d06f685b2c01eff0ae00000000000000000000000000aaf1950200000000b8522d0000000000\";\n        // orca.call{accounts: metasDecreaseLiquidity, seeds: [[pdaProgramSeed, pdaBump]]}(bincode);\n        whirlpool.decreaseLiquidity{accounts: metasDecreaseLiquidity, seeds: [[pdaProgramSeed, pdaBump]]}(amount, 0, 0);\n\n        // Update the token remainder\n        uint64 remainder = positionLiquidity - amount;\n        // Update liquidity and its associated position account\n        mapPositionAccountLiquidity[positionAddress] = remainder;\n\n        // If requested amount can be fully covered by the current position liquidity, close the position\n        if (remainder == 0) {\n            // Update fees for the position\n            AccountMeta[4] metasUpdateFees = [\n                AccountMeta({pubkey: pool, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: positionAddress, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.tickArrayLower.key, is_writable: false, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.tickArrayUpper.key, is_writable: false, is_signer: false})\n            ];\n            whirlpool.updateFeesAndRewards{accounts: metasUpdateFees, seeds: [[pdaProgramSeed, pdaBump]]}();\n\n            // Collect fees from the position\n            AccountMeta[9] metasCollectFees = [\n                AccountMeta({pubkey: pool, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: pdaProgram, is_writable: false, is_signer: true}),\n                AccountMeta({pubkey: positionAddress, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: pdaPositionAta, is_writable: false, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.userTokenAccountA.key, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.tokenVaultA.key, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.userTokenAccountB.key, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.tokenVaultB.key, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: SplToken.tokenProgramId, is_writable: false, is_signer: false})\n            ];\n            whirlpool.collectFees{accounts: metasCollectFees, seeds: [[pdaProgramSeed, pdaBump]]}();\n\n            // Close the position\n            AccountMeta[6] metasClosePosition = [\n                AccountMeta({pubkey: pdaProgram, is_writable: false, is_signer: true}),\n                AccountMeta({pubkey: tx.accounts.userWallet.key, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: positionAddress, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.positionMint.key, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: pdaPositionAta, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: SplToken.tokenProgramId, is_writable: false, is_signer: false})\n            ];\n            whirlpool.closePosition{accounts: metasClosePosition, seeds: [[pdaProgramSeed, pdaBump]]}();\n\n            // Increase the first available position account index\n            firstAvailablePositionAccountIndex++;\n        }\n    }\n\n    /// @dev Gets the position data.\n    /// @return Position data.\n    @account(position)\n    @account(positionMint)\n    function getPositionData() external view returns (Position) {\n        return _getPositionData(tx.accounts.position, tx.accounts.positionMint.key);\n    }\n\n    /// @dev Gets liquidity amounts and position accounts in order to correctly withdraw a specified liquidity amount.\n    /// @param amount Liquidity amount to withdraw.\n    /// @return positionAmounts Position amounts.\n    /// @return positionAddresses Position mint addresses.\n    /// @return positionPdaAtas Position PDA ATA-s controlled by the program.\n    function getLiquidityAmountsAndPositions(uint64 amount)\n        external view returns (uint64[] positionAmounts, address[] positionAddresses, address[] positionPdaAtas)\n    {\n        if (amount > totalLiquidity) {\n            revert (\"Requested amount is too big for the total available liquidity\");\n        }\n\n        uint64 liquiditySum = 0;\n        uint32 numPositions = 0;\n        uint64 amountLeft = 0;\n\n        // Get the number of allocated positions\n        for (uint32 i = firstAvailablePositionAccountIndex; i < numPositionAccounts; ++i) {\n            address positionAddress = positionAccounts[i];\n            uint64 positionLiquidity = mapPositionAccountLiquidity[positionAddress];\n\n            // Increase a total calculated liquidity and a number of positions to return\n            liquiditySum += positionLiquidity;\n            numPositions++;\n\n            // Check if the accumulated liquidity is enough to cover the requested amount\n            if (liquiditySum >= amount) {\n                amountLeft = liquiditySum - amount;\n                break;\n            }\n        }\n\n        // Allocate the necessary arrays and fill the values\n        positionAddresses = new address[](numPositions);\n        positionAmounts = new uint64[](numPositions);\n        positionPdaAtas = new address[](numPositions);\n        for (uint32 i = 0; i < numPositions; ++i) {\n            positionAddresses[i] = positionAccounts[firstAvailablePositionAccountIndex + i];\n            positionAmounts[i] = mapPositionAccountLiquidity[positionAddresses[i]];\n            positionPdaAtas[i] = mapPositionAccountPdaAta[positionAddresses[i]];\n        }\n\n        // Adjust the last position, if it was not fully allocated\n        if (numPositions > 0 && amountLeft > 0) {\n            positionAmounts[numPositions - 1] = amountLeft;\n        }\n    }\n\n    /// @dev Gets token account balance.\n    @account(account)\n    function getBalance() external view returns (uint64) {\n        return SplToken.get_balance(tx.accounts.account);\n    }\n\n    /// @dev Gets total supply of a provided token account.\n    @account(account)\n    function totalSupply() external view returns (uint64) {\n        return SplToken.total_supply(tx.accounts.account);\n    }\n}"
    },
    {
      "filename": "lockbox-solana/solidity/interfaces/whirlpool.sol",
      "content": "enum CurrIndex {\n\tBelow,\n\tInside,\n\tAbove\n}\nenum TickLabel {\n\tUpper,\n\tLower\n}\nenum Direction {\n\tLeft,\n\tRight\n}\nstruct OpenPositionBumps {\n\tuint8\tpositionBump;\n}\nstruct OpenPositionWithMetadataBumps {\n\tuint8\tpositionBump;\n\tuint8\tmetadataBump;\n}\nstruct PositionRewardInfo {\n\tuint128\tgrowthInsideCheckpoint;\n\tuint64\tamountOwed;\n}\nstruct Tick {\n\tbool\tinitialized;\n\tint128\tliquidityNet;\n\tuint128\tliquidityGross;\n\tuint128\tfeeGrowthOutsideA;\n\tuint128\tfeeGrowthOutsideB;\n\tuint128[3]\trewardGrowthsOutside;\n}\n/// Stores the state relevant for tracking liquidity mining rewards at the `Whirlpool` level.\n/// These values are used in conjunction with `PositionRewardInfo`, `Tick.reward_growths_outside`,\n/// and `Whirlpool.reward_last_updated_timestamp` to determine how many rewards are earned by open\n/// positions.\nstruct WhirlpoolRewardInfo {\n\t/// Reward token mint.\n\taddress\tmint;\n\t/// Reward vault token account.\n\taddress\tvault;\n\t/// Authority account that has permission to initialize the reward and set emissions.\n\taddress\tauthority;\n\t/// Q64.64 number that indicates how many tokens per second are earned per unit of liquidity.\n\tuint128\temissionsPerSecondX64;\n\t/// Q64.64 number that tracks the total tokens earned per unit of liquidity since the reward\n\t/// emissions were turned on.\n\tuint128\tgrowthGlobalX64;\n}\nstruct WhirlpoolBumps {\n\tuint8\twhirlpoolBump;\n}\n@program_id(\"whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc\")\ninterface whirlpool {\n\t/// Initializes a WhirlpoolsConfig account that hosts info & authorities\n\t/// required to govern a set of Whirlpools.\n\t/// \n\t/// ### Parameters\n\t/// - `fee_authority` - Authority authorized to initialize fee-tiers and set customs fees.\n\t/// - `collect_protocol_fees_authority` - Authority authorized to collect protocol fees.\n\t/// - `reward_emissions_super_authority` - Authority authorized to set reward authorities in pools.\n\t@selector([0xd0,0x7f,0x15,0x01,0xc2,0xbe,0xc4,0x46])\n\tfunction initializeConfig(address feeAuthority,address collectProtocolFeesAuthority,address rewardEmissionsSuperAuthority,uint16 defaultProtocolFeeRate) external;\n\t/// Initializes a Whirlpool account.\n\t/// Fee rate is set to the default values on the config and supplied fee_tier.\n\t/// \n\t/// ### Parameters\n\t/// - `bumps` - The bump value when deriving the PDA of the Whirlpool address.\n\t/// - `tick_spacing` - The desired tick spacing for this pool.\n\t/// - `initial_sqrt_price` - The desired initial sqrt-price for this pool\n\t/// \n\t/// #### Special Errors\n\t/// `InvalidTokenMintOrder` - The order of mints have to be ordered by\n\t/// `SqrtPriceOutOfBounds` - provided initial_sqrt_price is not between 2^-64 to 2^64\n\t/// \n\t@selector([0x5f,0xb4,0x0a,0xac,0x54,0xae,0xe8,0x28])\n\tfunction initializePool(WhirlpoolBumps bumps,uint16 tickSpacing,uint128 initialSqrtPrice) external;\n\t/// Initializes a tick_array account to represent a tick-range in a Whirlpool.\n\t/// \n\t/// ### Parameters\n\t/// - `start_tick_index` - The starting tick index for this tick-array.\n\t/// Has to be a multiple of TickArray size & the tick spacing of this pool.\n\t/// \n\t/// #### Special Errors\n\t/// - `InvalidStartTick` - if the provided start tick is out of bounds or is not a multiple of\n\t/// TICK_ARRAY_SIZE * tick spacing.\n\t@selector([0x0b,0xbc,0xc1,0xd6,0x8d,0x5b,0x95,0xb8])\n\tfunction initializeTickArray(int32 startTickIndex) external;\n\t/// Initializes a fee_tier account usable by Whirlpools in a WhirlpoolConfig space.\n\t/// \n\t/// ### Authority\n\t/// - \"fee_authority\" - Set authority in the WhirlpoolConfig\n\t/// \n\t/// ### Parameters\n\t/// - `tick_spacing` - The tick-spacing that this fee-tier suggests the default_fee_rate for.\n\t/// - `default_fee_rate` - The default fee rate that a pool will use if the pool uses this\n\t/// fee tier during initialization.\n\t/// \n\t/// #### Special Errors\n\t/// - `FeeRateMaxExceeded` - If the provided default_fee_rate exceeds MAX_FEE_RATE.\n\t@selector([0xb7,0x4a,0x9c,0xa0,0x70,0x02,0x2a,0x1e])\n\tfunction initializeFeeTier(uint16 tickSpacing,uint16 defaultFeeRate) external;\n\t/// Initialize reward for a Whirlpool. A pool can only support up to a set number of rewards.\n\t/// \n\t/// ### Authority\n\t/// - \"reward_authority\" - assigned authority by the reward_super_authority for the specified\n\t/// reward-index in this Whirlpool\n\t/// \n\t/// ### Parameters\n\t/// - `reward_index` - The reward index that we'd like to initialize. (0 <= index <= NUM_REWARDS)\n\t/// \n\t/// #### Special Errors\n\t/// - `InvalidRewardIndex` - If the provided reward index doesn't match the lowest uninitialized\n\t/// index in this pool, or exceeds NUM_REWARDS, or\n\t/// all reward slots for this pool has been initialized.\n\t@selector([0x5f,0x87,0xc0,0xc4,0xf2,0x81,0xe6,0x44])\n\tfunction initializeReward(uint8 rewardIndex) external;\n\t/// Set the reward emissions for a reward in a Whirlpool.\n\t/// \n\t/// ### Authority\n\t/// - \"reward_authority\" - assigned authority by the reward_super_authority for the specified\n\t/// reward-index in this Whirlpool\n\t/// \n\t/// ### Parameters\n\t/// - `reward_index` - The reward index (0 <= index <= NUM_REWARDS) that we'd like to modify.\n\t/// - `emissions_per_second_x64` - The amount of rewards emitted in this pool.\n\t/// \n\t/// #### Special Errors\n\t/// - `RewardVaultAmountInsufficient` - The amount of rewards in the reward vault cannot emit\n\t/// more than a day of desired emissions.\n\t/// - `InvalidTimestamp` - Provided timestamp is not in order with the previous timestamp.\n\t/// - `InvalidRewardIndex` - If the provided reward index doesn't match the lowest uninitialized\n\t/// index in this pool, or exceeds NUM_REWARDS, or\n\t/// all reward slots for this pool has been initialized.\n\t@selector([0x0d,0xc5,0x56,0xa8,0x6d,0xb0,0x1b,0xf4])\n\tfunction setRewardEmissions(uint8 rewardIndex,uint128 emissionsPerSecondX64) external;\n\t/// Open a position in a Whirlpool. A unique token will be minted to represent the position\n\t/// in the users wallet. The position will start off with 0 liquidity.\n\t/// \n\t/// ### Parameters\n\t/// - `tick_lower_index` - The tick specifying the lower end of the position range.\n\t/// - `tick_upper_index` - The tick specifying the upper end of the position range.\n\t/// \n\t/// #### Special Errors\n\t/// - `InvalidTickIndex` - If a provided tick is out of bounds, out of order or not a multiple of\n\t/// the tick-spacing in this pool.\n\t@selector([0x87,0x80,0x2f,0x4d,0x0f,0x98,0xf0,0x31])\n\tfunction openPosition(OpenPositionBumps bumps,int32 tickLowerIndex,int32 tickUpperIndex) external;\n\t/// Open a position in a Whirlpool. A unique token will be minted to represent the position\n\t/// in the users wallet. Additional Metaplex metadata is appended to identify the token.\n\t/// The position will start off with 0 liquidity.\n\t/// \n\t/// ### Parameters\n\t/// - `tick_lower_index` - The tick specifying the lower end of the position range.\n\t/// - `tick_upper_index` - The tick specifying the upper end of the position range.\n\t/// \n\t/// #### Special Errors\n\t/// - `InvalidTickIndex` - If a provided tick is out of bounds, out of order or not a multiple of\n\t/// the tick-spacing in this pool.\n\t@selector([0xf2,0x1d,0x86,0x30,0x3a,0x6e,0x0e,0x3c])\n\tfunction openPositionWithMetadata(OpenPositionWithMetadataBumps bumps,int32 tickLowerIndex,int32 tickUpperIndex) external;\n\t/// Add liquidity to a position in the Whirlpool. This call also updates the position's accrued fees and rewards.\n\t/// \n\t/// ### Authority\n\t/// - `position_authority` - authority that owns the token corresponding to this desired position.\n\t/// \n\t/// ### Parameters\n\t/// - `liquidity_amount` - The total amount of Liquidity the user is willing to deposit.\n\t/// - `token_max_a` - The maximum amount of tokenA the user is willing to deposit.\n\t/// - `token_max_b` - The maximum amount of tokenB the user is willing to deposit.\n\t/// \n\t/// #### Special Errors\n\t/// - `LiquidityZero` - Provided liquidity amount is zero.\n\t/// - `LiquidityTooHigh` - Provided liquidity exceeds u128::max.\n\t/// - `TokenMaxExceeded` - The required token to perform this operation exceeds the user defined amount.\n\t@selector([0x2e,0x9c,0xf3,0x76,0x0d,0xcd,0xfb,0xb2])\n\tfunction increaseLiquidity(uint128 liquidityAmount,uint64 tokenMaxA,uint64 tokenMaxB) external;\n\t/// Withdraw liquidity from a position in the Whirlpool. This call also updates the position's accrued fees and rewards.\n\t/// \n\t/// ### Authority\n\t/// - `position_authority` - authority that owns the token corresponding to this desired position.\n\t/// \n\t/// ### Parameters\n\t/// - `liquidity_amount` - The total amount of Liquidity the user desires to withdraw.\n\t/// - `token_min_a` - The minimum amount of tokenA the user is willing to withdraw.\n\t/// - `token_min_b` - The minimum amount of tokenB the user is willing to withdraw.\n\t/// \n\t/// #### Special Errors\n\t/// - `LiquidityZero` - Provided liquidity amount is zero.\n\t/// - `LiquidityTooHigh` - Provided liquidity exceeds u128::max.\n\t/// - `TokenMinSubceeded` - The required token to perform this operation subceeds the user defined amount.\n\t@selector([0xa0,0x26,0xd0,0x6f,0x68,0x5b,0x2c,0x01])\n\tfunction decreaseLiquidity(uint128 liquidityAmount,uint64 tokenMinA,uint64 tokenMinB) external;\n\t/// Update the accrued fees and rewards for a position.\n\t/// \n\t/// #### Special Errors\n\t/// - `TickNotFound` - Provided tick array account does not contain the tick for this position.\n\t/// - `LiquidityZero` - Position has zero liquidity and therefore already has the most updated fees and reward values.\n\t@selector([0x9a,0xe6,0xfa,0x0d,0xec,0xd1,0x4b,0xdf])\n\tfunction updateFeesAndRewards() external;\n\t/// Collect fees accrued for this position.\n\t/// \n\t/// ### Authority\n\t/// - `position_authority` - authority that owns the token corresponding to this desired position.\n\t@selector([0xa4,0x98,0xcf,0x63,0x1e,0xba,0x13,0xb6])\n\tfunction collectFees() external;\n\t/// Collect rewards accrued for this position.\n\t/// \n\t/// ### Authority\n\t/// - `position_authority` - authority that owns the token corresponding to this desired position.\n\t@selector([0x46,0x05,0x84,0x57,0x56,0xeb,0xb1,0x22])\n\tfunction collectReward(uint8 rewardIndex) external;\n\t/// Collect the protocol fees accrued in this Whirlpool\n\t/// \n\t/// ### Authority\n\t/// - `collect_protocol_fees_authority` - assigned authority in the WhirlpoolConfig that can collect protocol fees\n\t@selector([0x16,0x43,0x17,0x62,0x96,0xb2,0x46,0xdc])\n\tfunction collectProtocolFees() external;\n\t/// Perform a swap in this Whirlpool\n\t/// \n\t/// ### Authority\n\t/// - \"token_authority\" - The authority to withdraw tokens from the input token account.\n\t/// \n\t/// ### Parameters\n\t/// - `amount` - The amount of input or output token to swap from (depending on amount_specified_is_input).\n\t/// - `other_amount_threshold` - The maximum/minimum of input/output token to swap into (depending on amount_specified_is_input).\n\t/// - `sqrt_price_limit` - The maximum/minimum price the swap will swap to.\n\t/// - `amount_specified_is_input` - Specifies the token the parameter `amount`represents. If true, the amount represents the input token of the swap.\n\t/// - `a_to_b` - The direction of the swap. True if swapping from A to B. False if swapping from B to A.\n\t/// \n\t/// #### Special Errors\n\t/// - `ZeroTradableAmount` - User provided parameter `amount` is 0.\n\t/// - `InvalidSqrtPriceLimitDirection` - User provided parameter `sqrt_price_limit` does not match the direction of the trade.\n\t/// - `SqrtPriceOutOfBounds` - User provided parameter `sqrt_price_limit` is over Whirlppool's max/min bounds for sqrt-price.\n\t/// - `InvalidTickArraySequence` - User provided tick-arrays are not in sequential order required to proceed in this trade direction.\n\t/// - `TickArraySequenceInvalidIndex` - The swap loop attempted to access an invalid array index during the query of the next initialized tick.\n\t/// - `TickArrayIndexOutofBounds` - The swap loop attempted to access an invalid array index during tick crossing.\n\t/// - `LiquidityOverflow` - Liquidity value overflowed 128bits during tick crossing.\n\t/// - `InvalidTickSpacing` - The swap pool was initialized with tick-spacing of 0.\n\t@selector([0xf8,0xc6,0x9e,0x91,0xe1,0x75,0x87,0xc8])\n\tfunction swap(uint64 amount,uint64 otherAmountThreshold,uint128 sqrtPriceLimit,bool amountSpecifiedIsInput,bool aToB) external;\n\t/// Close a position in a Whirlpool. Burns the position token in the owner's wallet.\n\t/// \n\t/// ### Authority\n\t/// - \"position_authority\" - The authority that owns the position token.\n\t/// \n\t/// #### Special Errors\n\t/// - `ClosePositionNotEmpty` - The provided position account is not empty.\n\t@selector([0x7b,0x86,0x51,0x00,0x31,0x44,0x62,0x62])\n\tfunction closePosition() external;\n\t/// Set the default_fee_rate for a FeeTier\n\t/// Only the current fee authority has permission to invoke this instruction.\n\t/// \n\t/// ### Authority\n\t/// - \"fee_authority\" - Set authority in the WhirlpoolConfig\n\t/// \n\t/// ### Parameters\n\t/// - `default_fee_rate` - The default fee rate that a pool will use if the pool uses this\n\t/// fee tier during initialization.\n\t/// \n\t/// #### Special Errors\n\t/// - `FeeRateMaxExceeded` - If the provided default_fee_rate exceeds MAX_FEE_RATE.\n\t@selector([0x76,0xd7,0xd6,0x9d,0xb6,0xe5,0xd0,0xe4])\n\tfunction setDefaultFeeRate(uint16 defaultFeeRate) external;\n\t/// Sets the default protocol fee rate for a WhirlpoolConfig\n\t/// Protocol fee rate is represented as a basis point.\n\t/// Only the current fee authority has permission to invoke this instruction.\n\t/// \n\t/// ### Authority\n\t/// - \"fee_authority\" - Set authority that can modify pool fees in the WhirlpoolConfig\n\t/// \n\t/// ### Parameters\n\t/// - `default_protocol_fee_rate` - Rate that is referenced during the initialization of a Whirlpool using this config.\n\t/// \n\t/// #### Special Errors\n\t/// - `ProtocolFeeRateMaxExceeded` - If the provided default_protocol_fee_rate exceeds MAX_PROTOCOL_FEE_RATE.\n\t@selector([0x6b,0xcd,0xf9,0xe2,0x97,0x23,0x56,0x00])\n\tfunction setDefaultProtocolFeeRate(uint16 defaultProtocolFeeRate) external;\n\t/// Sets the fee rate for a Whirlpool.\n\t/// Fee rate is represented as hundredths of a basis point.\n\t/// Only the current fee authority has permission to invoke this instruction.\n\t/// \n\t/// ### Authority\n\t/// - \"fee_authority\" - Set authority that can modify pool fees in the WhirlpoolConfig\n\t/// \n\t/// ### Parameters\n\t/// - `fee_rate` - The rate that the pool will use to calculate fees going onwards.\n\t/// \n\t/// #### Special Errors\n\t/// - `FeeRateMaxExceeded` - If the provided fee_rate exceeds MAX_FEE_RATE.\n\t@selector([0x35,0xf3,0x89,0x41,0x08,0x8c,0x9e,0x06])\n\tfunction setFeeRate(uint16 feeRate) external;\n\t/// Sets the protocol fee rate for a Whirlpool.\n\t/// Protocol fee rate is represented as a basis point.\n\t/// Only the current fee authority has permission to invoke this instruction.\n\t/// \n\t/// ### Authority\n\t/// - \"fee_authority\" - Set authority that can modify pool fees in the WhirlpoolConfig\n\t/// \n\t/// ### Parameters\n\t/// - `protocol_fee_rate` - The rate that the pool will use to calculate protocol fees going onwards.\n\t/// \n\t/// #### Special Errors\n\t/// - `ProtocolFeeRateMaxExceeded` - If the provided default_protocol_fee_rate exceeds MAX_PROTOCOL_FEE_RATE.\n\t@selector([0x5f,0x07,0x04,0x32,0x9a,0x4f,0x9c,0x83])\n\tfunction setProtocolFeeRate(uint16 protocolFeeRate) external;\n\t/// Sets the fee authority for a WhirlpoolConfig.\n\t/// The fee authority can set the fee & protocol fee rate for individual pools or\n\t/// set the default fee rate for newly minted pools.\n\t/// Only the current fee authority ha"
    }
  ]
}