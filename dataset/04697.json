{
  "Title": "[03] `vault.getUsdValue()` should be wrapped in a try catch",
  "Content": "\nhttps://github.com/code-423n4/2024-04-dyad/blob/4a987e536576139793a1c04690336d06c93fca90/src/core/Vault.kerosine.unbounded.sol#L50-L68\n\n```solidity\n  function assetPrice()\n    public\n    view\n    override\n    returns (uint) {\n      uint tvl;\n      //@audit\n      address[] memory vaults = kerosineManager.getVaults();\n      uint numberOfVaults = vaults.length;\n      for (uint i = 0; i < numberOfVaults; i++) {\n        Vault vault = Vault(vaults[i]);\n        tvl += vault.asset().balanceOf(address(vault))\n                * vault.assetPrice() * 1e18\n                / (10**vault.asset().decimals())\n                / (10**vault.oracle().decimals());\n      }\n      uint numerator   = tvl - dyad.totalSupply();\n      uint denominator = kerosineDenominator.denominator();\n      return numerator * 1e8 / denominator;\n  }\n```\n\nThis function is used to get the price of an asset, and it gets that by querying the specific vault of that asset for its balance and price. Keep in mind that this function is also used whenever getting price from the bounded vault as shown [here](https://github.com/code-423n4/2024-04-dyad/blob/4a987e536576139793a1c04690336d06c93fca90/src/core/Vault.kerosine.bounded.sol#L44-L50).\n\n```solidity\n\n  function assetPrice()\n    public\n    view\n    override\n    returns (uint) {\n      return unboundedKerosineVault.assetPrice() * 2;\n        }\n```\n\nGoing back to the `VaultManager`, we can see that the line `usdValue = vault.getUsdValue(id);  ` is queried whenever there is a need to get the prices as confirmed by [this search command](https://github.com/search?q=repo%3Acode-423n4%2F2024-04-dyad+usdValue+%3D+vault.getUsdValue%28id%29%3B+++NOT+language%3AMarkdown&type=code) and queries the two aforementioned functions as shown [here](https://github.com/code-423n4/2024-04-dyad/blob/4a987e536576139793a1c04690336d06c93fca90/src/core/Vault.sol#L79-L104).\n\n```solidity\n  function getUsdValue(\n    uint id\n  )\n    external\n    view\n    returns (uint) {\n      return id2asset[id] * assetPrice()\n              * 1e18\n              / 10**oracle.decimals()\n              / 10**asset.decimals();\n  }\n\n\n\n  function assetPrice()\n    public\n    view\n    returns (uint) {\n      (\n        ,\n        int256 answer,\n        ,\n        uint256 updatedAt,\n      ) = oracle.latestRoundData();\n      if (block.timestamp > updatedAt + STALE_DATA_TIMEOUT) revert StaleData();\n      return answer.toUint256();\n  }\n```\n\nThat is to say that the pricing logic requires us to query chainlink at the end of the calls, but evidently, we can see that this call lacks error handling for the potential failure of `vault.getUsdValue` which could fail due to the call to `oracle.latestRoundData()` via `assetPrice()`. Note that Chainlink pricefeeds could revert due to whatever reason, i.e. say maintenance or maybe the Chainlink team decide to change the underlying address. Now this omission of not considering this call failing would lead to systemic issues, since calls to this would now revert halting any action that requires this call to succeed.\n\n### Impact\n\nBorderline medium/low, as this essentially breaks core functionalities like liquidating and whatever requires for the usd value of an asset to be queried since there would be a complete revert.\n\n### Recommended Mitigation Steps\n\nWrap the `vault.getUsdValue()` call in a try-catch block, then handle the error (e.g., revert with a specific message or use an alternative pricing method); the latter is a better fix as it ensures the protocol still functions as expected on the fallback oracle.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-04-dyad",
  "Code": [
    {
      "filename": "src/core/Vault.kerosine.unbounded.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.17;\n\nimport {KerosineVault}        from \"./Vault.kerosine.sol\";\nimport {IVaultManager}        from \"../interfaces/IVaultManager.sol\";\nimport {Vault}                from \"./Vault.sol\";\nimport {Dyad}                 from \"./Dyad.sol\";\nimport {KerosineManager}      from \"./KerosineManager.sol\";\nimport {BoundedKerosineVault} from \"./Vault.kerosine.bounded.sol\";\nimport {KerosineDenominator}  from \"../staking/KerosineDenominator.sol\";\n\nimport {ERC20}           from \"@solmate/src/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"@solmate/src/utils/SafeTransferLib.sol\";\n\ncontract UnboundedKerosineVault is KerosineVault {\n  using SafeTransferLib for ERC20;\n\n  Dyad                 public immutable dyad;\n  KerosineDenominator  public kerosineDenominator;\n\n  constructor(\n      IVaultManager   _vaultManager,\n      ERC20           _asset, \n      Dyad            _dyad, \n      KerosineManager _kerosineManager\n  ) KerosineVault(_vaultManager, _asset, _kerosineManager) {\n      dyad = _dyad;\n  }\n\n  function withdraw(\n    uint    id,\n    address to,\n    uint    amount\n  ) \n    external \n      onlyVaultManager\n  {\n    id2asset[id] -= amount;\n    asset.safeTransfer(to, amount); \n    emit Withdraw(id, to, amount);\n  }\n\n  function setDenominator(KerosineDenominator _kerosineDenominator) \n    external \n      onlyOwner\n  {\n    kerosineDenominator = _kerosineDenominator;\n  }\n\n  function assetPrice() \n    public \n    view \n    override\n    returns (uint) {\n      uint tvl;\n      address[] memory vaults = kerosineManager.getVaults();\n      uint numberOfVaults = vaults.length;\n      for (uint i = 0; i < numberOfVaults; i++) {\n        Vault vault = Vault(vaults[i]);\n        tvl += vault.asset().balanceOf(address(vault)) \n                * vault.assetPrice() * 1e18\n                / (10**vault.asset().decimals()) \n                / (10**vault.oracle().decimals());\n      }\n      uint numerator   = tvl - dyad.totalSupply();\n      uint denominator = kerosineDenominator.denominator();\n      return numerator * 1e8 / denominator;\n  }\n}"
    },
    {
      "filename": "src/core/Vault.kerosine.bounded.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.17;\n\nimport {KerosineVault}          from \"./Vault.kerosine.sol\";\nimport {IVaultManager}          from \"../interfaces/IVaultManager.sol\";\nimport {Dyad}                   from \"./Dyad.sol\";\nimport {KerosineManager}        from \"./KerosineManager.sol\";\nimport {UnboundedKerosineVault} from \"./Vault.kerosine.unbounded.sol\";\n\nimport {ERC20} from \"@solmate/src/tokens/ERC20.sol\";\n\ncontract BoundedKerosineVault is KerosineVault {\n  error NotWithdrawable(uint id, address to, uint amount);\n\n  UnboundedKerosineVault public unboundedKerosineVault;\n\n  constructor(\n    IVaultManager   _vaultManager,\n    ERC20           _asset, \n    KerosineManager _kerosineManager\n  ) KerosineVault(_vaultManager, _asset, _kerosineManager) {}\n\n  function setUnboundedKerosineVault(\n    UnboundedKerosineVault _unboundedKerosineVault\n  )\n    external\n    onlyOwner\n  {\n    unboundedKerosineVault = _unboundedKerosineVault;\n  }\n\n  function withdraw(\n    uint    id,\n    address to,\n    uint    amount\n  ) \n    external \n    view\n      onlyVaultManager\n  {\n    revert NotWithdrawable(id, to, amount);\n  }\n\n  function assetPrice() \n    public \n    view \n    override\n    returns (uint) {\n      return unboundedKerosineVault.assetPrice() * 2;\n  }\n}"
    }
  ]
}