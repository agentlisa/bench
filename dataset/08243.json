{
  "Title": "[M-08] `mintFromFixedPriceSale` for a custom contract can lead to users losing funds",
  "Content": "_Submitted by joestakey_\n\n`NFTDropMarketFixedPriceSale.createFixedPriceSale` allows creators to create a sale drop.\nA creator can create a drop sale for their custom NFT Contract that adheres to `INFTDropCollectionMint`.\n\n`INFTDropCollectionMint.mintCountTo` must return the `firstTokenId` being minted, but it is not clear as to what should be returned upon all tokens being minted. A valid implementation could for instance return `0` if called after the last token has been minted.\n\nBut the drop market [expects the call to mintCountTo](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/nftDropMarket/NFTDropMarketFixedPriceSale.sol#L207) to revert upon the last token being minted, meaning a user calling it afterwards would lose the ETH they sent.\n\n### Proof Of Concept\n\n*   Alice creates a `customERC721` contract adhering to `INFTDropCollectionMint`. She writes `mintCountTo()` so that it returns `0` if called when all the tokens have been minted.\n*   The sale happens and collectors call `mintFromFixedPriceSale` until all the tokens have been minted.\n*   Bob now calls `mintFromFixedPriceSale`. Because all the tokens have been minted, the [call to mintCountTo](https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/nftDropMarket/NFTDropMarketFixedPriceSale.sol#L207) does not revert but returns `0`.\n*   The function call then proceeds to distribute the funds.\n*   Bob have lost `mintCost` ETH, while not receiving any NFT.\n\nYou can find this [Foundry test](https://gist.github.com/joestakey/5dc8839c7622bdb9467d743924f072b6) reproducing the issue.\n\nNote that this is not an issue of a malicious creator rugging collectors with a malicious implementation: they have implemented their contract to adhere to `INFTDropCollectionMint`, and the sale went as expected.\n\nIt is not unrealistic to imagine collectors monitoring `CreateFixedPriceSale` and calling `mintFromFixedPriceSale` based on it. In this case, all the `mintFromFixedPriceSale` processed after the last token being minted would lead to loss of funds.\n\n### Tools Used\n\nFoundry\n\n### Recommend Mitigation Steps\n\nYou can add an additional check in `NFTDropMarketFixedPriceSale.mintCountTo()` using `ERC721(nftContract).balanceOf()`.\n\n```diff\n+ uint256 balanceBefore = IERC721(nftContract).balanceOf(msg.sender);\n207:     firstTokenId = INFTDropCollectionMint(nftContract).mintCountTo(count, msg.sender);\n+ uint256 balanceAfter = IERC721(nftContract).balanceOf(msg.sender);\n+ require(balanceAfter == balanceBefore + count, \"minting failed\")\n```\n\nYou can also specify in `INFTDropCollectionMint` that `mintCountTo` must revert if called after all tokens have been minted.\n\n**[HardlyDifficult (Foundation) marked as duplicate and commented](https://github.com/code-423n4/2022-08-foundation-findings/issues/279#issuecomment-1220574136):**\n > Although this submission uses a different POC, we believe it's the same issue & root cause as [#211](https://github.com/code-423n4/2022-08-foundation-findings/issues/211).\n> \n> Dupe of [#211](https://github.com/code-423n4/2022-08-foundation-findings/issues/211).\n\n**[joestakey (warden) commented](https://github.com/code-423n4/2022-08-foundation-findings/issues/279#issuecomment-1229461934):**\n > I will argue this issue is actually different than [#211](https://github.com/code-423n4/2022-08-foundation-findings/issues/211), although they both come from the same function call:\n> \n> - In [#211](https://github.com/code-423n4/2022-08-foundation-findings/issues/211), the issue lies in the logic performed in `INFTDropCollectionMint.mintCountTo()`, more precisely the fact that a malicious implementation can perform incorrect state logic, which results in any collector calling `NFTDropMarketFixedPriceSale.mintFromFixedPriceSale` losing funds without receiving the expected amount of NFTs.\n> - Here, the issue lies in the return value of `INFTDropCollectionMint.mintCountTo()` in an edge case - when all the tokens have been minted. There is no malicious implementation or wrong state logic: users calling `NFTDropMarketFixedPriceSale.mintFromFixedPriceSale` will receive the expected amount of NFTs. The problem is when the minting is done: the `DropMarket` expect subsequent calls to `mintCountTo()` to fail. While you can argue not reverting after the final token has been minted is breaking a semantic requirement, it still complies with the interface `INFTDropCollectionMint`. Not reverting on failure is a behavior that exists in other standards, such as some ERC20 tokens for instance, like [ZRX](https://etherscan.io/address/0xe41d2489571d322189246dafa5ebde1f4699f498#code).\n> \n> To illustrate the difference between the two issues, take the NFT contract used in the PoC for this issue: users calling `NFTDropMarketFixedPriceSale.mintFromFixedPriceSale` will receive the expected amount of NFTs - i.e. it is not affected by the issue #211. The problem arises only upon the final token being minted.\n> \n> In summary, [#211](https://github.com/code-423n4/2022-08-foundation-findings/issues/211) is about malicious implementations that users should be made aware of (docs or UI warnings) while this issue has to do with the fact `INFTDropCollectionMint.mintCountTo()` should define a stricter behavior when the last token has been minted, perhaps by adding a comment such as:\n> ```\n> /// if the minting fails it MUST result in the transaction being reverted.\n> ```\n> \n> @HickupHH3 thoughts?\n> \n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-08-foundation-findings/issues/279#issuecomment-1240810016):**\n> The root cause for both issues is about the \"potential errors in the implementation or misunderstanding of the interface requirements\". Simply put, the ambiguity regarding the specification of `mintCountTo()` allows for it to be exploited. As you pointed out, #211 is exploited by malicious implementations while this issue happens even if the implementation is seemingly compliant to the interface because of the ambiguity.\n> \n> It's a tough decision because while the methods are different, the root cause and consequence (users losing funds) are the same.\n> \n> I'll side with you on this one, because the attack vectors are quite distinct. It's similar to how I separated the strategist rug vectors for the Rubicon contest.\n\n\n\n***\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-08-foundation-drop-contest",
  "Code": [
    {
      "filename": "contracts/mixins/nftDropMarket/NFTDropMarketFixedPriceSale.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport \"../../interfaces/INFTDropCollectionMint.sol\";\n\nimport \"../shared/Constants.sol\";\nimport \"../shared/MarketFees.sol\";\n\n/// @param limitPerAccount The limit of tokens an account can purchase.\nerror NFTDropMarketFixedPriceSale_Cannot_Buy_More_Than_Limit(uint256 limitPerAccount);\nerror NFTDropMarketFixedPriceSale_Limit_Per_Account_Must_Be_Set();\nerror NFTDropMarketFixedPriceSale_Mint_Permission_Required();\nerror NFTDropMarketFixedPriceSale_Must_Buy_At_Least_One_Token();\nerror NFTDropMarketFixedPriceSale_Must_Have_Sale_In_Progress();\nerror NFTDropMarketFixedPriceSale_Must_Not_Be_Sold_Out();\nerror NFTDropMarketFixedPriceSale_Must_Not_Have_Pending_Sale();\nerror NFTDropMarketFixedPriceSale_Must_Support_Collection_Mint_Interface();\nerror NFTDropMarketFixedPriceSale_Only_Callable_By_Collection_Owner();\n/// @param mintCost The total cost for this purchase.\nerror NFTDropMarketFixedPriceSale_Too_Much_Value_Provided(uint256 mintCost);\n\n/**\n * @title Allows creators to list a drop collection for sale at a fixed price point.\n * @dev Listing a collection for sale in this market requires the collection to implement\n * the functions in `INFTDropCollectionMint` and to register that interface with ERC165.\n * Additionally the collection must implement access control, or more specifically:\n * `hasRole(bytes32(0), msg.sender)` must return true when called from the creator or admin's account\n * and `hasRole(keccak256(\"MINTER_ROLE\", address(this)))` must return true for this market's address.\n */\nabstract contract NFTDropMarketFixedPriceSale is MarketFees {\n  using AddressUpgradeable for address;\n  using AddressUpgradeable for address payable;\n  using ERC165Checker for address;\n\n  /**\n   * @notice Configuration for the terms of the sale.\n   * @dev This structure is packed in order to consume just a single slot.\n   */\n  struct FixedPriceSaleConfig {\n    /**\n     * @notice The seller for the drop.\n     */\n    address payable seller;\n    /**\n     * @notice The fixed price per NFT in the collection.\n     * @dev The maximum price that can be set on an NFT is ~1.2M (2^80/10^18) ETH.\n     */\n    uint80 price;\n    /**\n     * @notice The max number of NFTs an account may have while minting.\n     */\n    uint16 limitPerAccount;\n  }\n\n  /**\n   * @notice Stores the current sale information for all drop contracts.\n   */\n  mapping(address => FixedPriceSaleConfig) private nftContractToFixedPriceSaleConfig;\n\n  /**\n   * @notice The `role` type used to validate drop collections have granted this market access to mint.\n   * @return `keccak256(\"MINTER_ROLE\")`\n   */\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n  /**\n   * @notice Emitted when a collection is listed for sale.\n   * @param nftContract The address of the NFT drop collection.\n   * @param seller The address for the seller which listed this for sale.\n   * @param price The price per NFT minted.\n   * @param limitPerAccount The max number of NFTs an account may have while minting.\n   */\n  event CreateFixedPriceSale(\n    address indexed nftContract,\n    address indexed seller,\n    uint256 price,\n    uint256 limitPerAccount\n  );\n\n  /**\n   * @notice Emitted when NFTs are minted from the drop.\n   * @dev The total price paid by the buyer is `totalFees + creatorRev`.\n   * @param nftContract The address of the NFT drop collection.\n   * @param buyer The address of the buyer.\n   * @param firstTokenId The tokenId for the first NFT minted.\n   * The other minted tokens are assigned sequentially, so `firstTokenId` - `firstTokenId + count - 1` were minted.\n   * @param count The number of NFTs minted.\n   * @param totalFees The amount of ETH that was sent to Foundation & referrals for this sale.\n   * @param creatorRev The amount of ETH that was sent to the creator for this sale.\n   */\n  event MintFromFixedPriceDrop(\n    address indexed nftContract,\n    address indexed buyer,\n    uint256 indexed firstTokenId,\n    uint256 count,\n    uint256 totalFees,\n    uint256 creatorRev\n  );\n\n  /**\n   * @notice Create a fixed price sale drop.\n   * @param nftContract The address of the NFT drop collection.\n   * @param price The price per NFT minted.\n   * Set price to 0 for a first come first serve airdrop-like drop.\n   * @param limitPerAccount The max number of NFTs an account may have while minting.\n   * @dev Notes:\n   *   a) The sale is final and can not be updated or canceled.\n   *   b) The sale is immediately kicked off.\n   *   c) Any collection that abides by `INFTDropCollectionMint` and `IAccessControl` is supported.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function createFixedPriceSale(\n    address nftContract,\n    uint80 price,\n    uint16 limitPerAccount\n  ) external {\n    // Confirm the drop collection is supported\n    if (!nftContract.supportsInterface(type(INFTDropCollectionMint).interfaceId)) {\n      revert NFTDropMarketFixedPriceSale_Must_Support_Collection_Mint_Interface();\n    }\n    if (INFTDropCollectionMint(nftContract).numberOfTokensAvailableToMint() == 0) {\n      revert NFTDropMarketFixedPriceSale_Must_Not_Be_Sold_Out();\n    }\n\n    // Use the AccessControl interface to confirm the msg.sender has permissions to list.\n    if (!IAccessControl(nftContract).hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n      revert NFTDropMarketFixedPriceSale_Only_Callable_By_Collection_Owner();\n    }\n    // And that this contract has permission to mint.\n    if (!IAccessControl(nftContract).hasRole(MINTER_ROLE, address(this))) {\n      revert NFTDropMarketFixedPriceSale_Mint_Permission_Required();\n    }\n\n    // Validate input params.\n    if (limitPerAccount == 0) {\n      revert NFTDropMarketFixedPriceSale_Limit_Per_Account_Must_Be_Set();\n    }\n    // Any price is supported, including 0.\n\n    // Confirm this collection has not already been listed.\n    FixedPriceSaleConfig storage saleConfig = nftContractToFixedPriceSaleConfig[nftContract];\n    if (saleConfig.seller != payable(0)) {\n      revert NFTDropMarketFixedPriceSale_Must_Not_Have_Pending_Sale();\n    }\n\n    // Save the sale details.\n    saleConfig.seller = payable(msg.sender);\n    saleConfig.price = price;\n    saleConfig.limitPerAccount = limitPerAccount;\n    emit CreateFixedPriceSale(nftContract, saleConfig.seller, saleConfig.price, saleConfig.limitPerAccount);\n  }\n\n  /**\n   * @notice Used to mint `count` number of NFTs from the collection.\n   * @param nftContract The address of the NFT drop collection.\n   * @param count The number of NFTs to mint.\n   * @param buyReferrer The address which referred this purchase, or address(0) if n/a.\n   * @return firstTokenId The tokenId for the first NFT minted.\n   * The other minted tokens are assigned sequentially, so `firstTokenId` - `firstTokenId + count - 1` were minted.\n   * @dev This call may revert if the collection has sold out, has an insufficient number of tokens available,\n   * or if the market's minter permissions were removed.\n   * If insufficient msg.value is included, the msg.sender's available FETH token balance will be used.\n   */\n  function mintFromFixedPriceSale(\n    address nftContract,\n    uint16 count,\n    address payable buyReferrer\n  ) external payable returns (uint256 firstTokenId) {\n    // Validate input params.\n    if (count == 0) {\n      revert NFTDropMarketFixedPriceSale_Must_Buy_At_Least_One_Token();\n    }\n\n    FixedPriceSaleConfig memory saleConfig = nftContractToFixedPriceSaleConfig[nftContract];\n\n    // Confirm that the buyer will not exceed the limit specified after minting.\n    if (IERC721(nftContract).balanceOf(msg.sender) + count > saleConfig.limitPerAccount) {\n      if (saleConfig.limitPerAccount == 0) {\n        // Provide a more targeted error if the collection has not been listed.\n        revert NFTDropMarketFixedPriceSale_Must_Have_Sale_In_Progress();\n      }\n      revert NFTDropMarketFixedPriceSale_Cannot_Buy_More_Than_Limit(saleConfig.limitPerAccount);\n    }\n\n    // Calculate the total cost, considering the `count` requested.\n    uint256 mintCost;\n    unchecked {\n      // Can not overflow as 2^80 * 2^16 == 2^96 max which fits in 256 bits.\n      mintCost = uint256(saleConfig.price) * count;\n    }\n\n    // The sale price is immutable so the buyer is aware of how much they will be paying when their tx is broadcasted.\n    if (msg.value > mintCost) {\n      // Since price is known ahead of time, if too much ETH is sent then something went wrong.\n      revert NFTDropMarketFixedPriceSale_Too_Much_Value_Provided(mintCost);\n    }\n    // Withdraw from the user's available FETH balance if insufficient msg.value was included.\n    _tryUseFETHBalance(mintCost, false);\n\n    // Mint the NFTs.\n    firstTokenId = INFTDropCollectionMint(nftContract).mintCountTo(count, msg.sender);\n\n    // Distribute revenue from this sale.\n    (uint256 totalFees, uint256 creatorRev, ) = _distributeFunds(\n      nftContract,\n      firstTokenId,\n      saleConfig.seller,\n      mintCost,\n      buyReferrer\n    );\n\n    emit MintFromFixedPriceDrop(nftContract, msg.sender, firstTokenId, count, totalFees, creatorRev);\n  }\n\n  /**\n   * @notice Returns the max number of NFTs a given account may mint.\n   * @param nftContract The address of the NFT drop collection.\n   * @param user The address of the user which will be minting.\n   * @return numberThatCanBeMinted How many NFTs the user can mint.\n   */\n  function getAvailableCountFromFixedPriceSale(address nftContract, address user)\n    external\n    view\n    returns (uint256 numberThatCanBeMinted)\n  {\n    (, , uint256 limitPerAccount, uint256 numberOfTokensAvailableToMint, bool marketCanMint) = getFixedPriceSale(\n      nftContract\n    );\n    if (!marketCanMint) {\n      // No one can mint in the current state.\n      return 0;\n    }\n    uint256 currentBalance = IERC721(nftContract).balanceOf(user);\n    if (currentBalance >= limitPerAccount) {\n      // User has exhausted their limit.\n      return 0;\n    }\n\n    uint256 availableToMint = limitPerAccount - currentBalance;\n    if (availableToMint > numberOfTokensAvailableToMint) {\n      // User has more tokens available than the collection has available.\n      return numberOfTokensAvailableToMint;\n    }\n\n    return availableToMint;\n  }\n\n  /**\n   * @notice Returns details for a drop collection's fixed price sale.\n   * @param nftContract The address of the NFT drop collection.\n   * @return seller The address of the seller which listed this drop for sale.\n   * This value will be address(0) if the collection is not listed or has sold out.\n   * @return price The price per NFT minted.\n   * @return limitPerAccount The max number of NFTs an account may have while minting.\n   * @return numberOfTokensAvailableToMint The total number of NFTs that may still be minted.\n   * @return marketCanMint True if this contract has permissions to mint from the given collection.\n   */\n  function getFixedPriceSale(address nftContract)\n    public\n    view\n    returns (\n      address payable seller,\n      uint256 price,\n      uint256 limitPerAccount,\n      uint256 numberOfTokensAvailableToMint,\n      bool marketCanMint\n    )\n  {\n    try INFTDropCollectionMint(nftContract).numberOfTokensAvailableToMint() returns (uint256 count) {\n      if (count != 0) {\n        try IAccessControl(nftContract).hasRole(MINTER_ROLE, address(this)) returns (bool hasRole) {\n          marketCanMint = hasRole;\n        } catch {\n          // The contract is not supported - return default values.\n          return (payable(0), 0, 0, 0, false);\n        }\n\n        FixedPriceSaleConfig memory saleConfig = nftContractToFixedPriceSaleConfig[nftContract];\n        seller = saleConfig.seller;\n        price = saleConfig.price;\n        limitPerAccount = saleConfig.limitPerAccount;\n        numberOfTokensAvailableToMint = count;\n      }\n      // Else minted completed -- return default values.\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Contract not supported or self destructed - return default values\n    }\n  }\n\n  /**\n   * @inheritdoc MarketSharedCore\n   * @dev Returns the seller for a collection if listed and not already sold out.\n   */\n  function _getSellerOf(\n    address nftContract,\n    uint256 /* tokenId */\n  ) internal view virtual override returns (address payable seller) {\n    (seller, , , , ) = getFixedPriceSale(nftContract);\n  }\n\n  /**\n   * @notice This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[1000] private __gap;\n}"
    },
    {
      "filename": "contracts/mixins/nftDropMarket/NFTDropMarketFixedPriceSale.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport \"../../interfaces/INFTDropCollectionMint.sol\";\n\nimport \"../shared/Constants.sol\";\nimport \"../shared/MarketFees.sol\";\n\n/// @param limitPerAccount The limit of tokens an account can purchase.\nerror NFTDropMarketFixedPriceSale_Cannot_Buy_More_Than_Limit(uint256 limitPerAccount);\nerror NFTDropMarketFixedPriceSale_Limit_Per_Account_Must_Be_Set();\nerror NFTDropMarketFixedPriceSale_Mint_Permission_Required();\nerror NFTDropMarketFixedPriceSale_Must_Buy_At_Least_One_Token();\nerror NFTDropMarketFixedPriceSale_Must_Have_Sale_In_Progress();\nerror NFTDropMarketFixedPriceSale_Must_Not_Be_Sold_Out();\nerror NFTDropMarketFixedPriceSale_Must_Not_Have_Pending_Sale();\nerror NFTDropMarketFixedPriceSale_Must_Support_Collection_Mint_Interface();\nerror NFTDropMarketFixedPriceSale_Only_Callable_By_Collection_Owner();\n/// @param mintCost The total cost for this purchase.\nerror NFTDropMarketFixedPriceSale_Too_Much_Value_Provided(uint256 mintCost);\n\n/**\n * @title Allows creators to list a drop collection for sale at a fixed price point.\n * @dev Listing a collection for sale in this market requires the collection to implement\n * the functions in `INFTDropCollectionMint` and to register that interface with ERC165.\n * Additionally the collection must implement access control, or more specifically:\n * `hasRole(bytes32(0), msg.sender)` must return true when called from the creator or admin's account\n * and `hasRole(keccak256(\"MINTER_ROLE\", address(this)))` must return true for this market's address.\n */\nabstract contract NFTDropMarketFixedPriceSale is MarketFees {\n  using AddressUpgradeable for address;\n  using AddressUpgradeable for address payable;\n  using ERC165Checker for address;\n\n  /**\n   * @notice Configuration for the terms of the sale.\n   * @dev This structure is packed in order to consume just a single slot.\n   */\n  struct FixedPriceSaleConfig {\n    /**\n     * @notice The seller for the drop.\n     */\n    address payable seller;\n    /**\n     * @notice The fixed price per NFT in the collection.\n     * @dev The maximum price that can be set on an NFT is ~1.2M (2^80/10^18) ETH.\n     */\n    uint80 price;\n    /**\n     * @notice The max number of NFTs an account may have while minting.\n     */\n    uint16 limitPerAccount;\n  }\n\n  /**\n   * @notice Stores the current sale information for all drop contracts.\n   */\n  mapping(address => FixedPriceSaleConfig) private nftContractToFixedPriceSaleConfig;\n\n  /**\n   * @notice The `role` type used to validate drop collections have granted this market access to mint.\n   * @return `keccak256(\"MINTER_ROLE\")`\n   */\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n  /**\n   * @notice Emitted when a collection is listed for sale.\n   * @param nftContract The address of the NFT drop collection.\n   * @param seller The address for the seller which listed this for sale.\n   * @param price The price per NFT minted.\n   * @param limitPerAccount The max number of NFTs an account may have while minting.\n   */\n  event CreateFixedPriceSale(\n    address indexed nftContract,\n    address indexed seller,\n    uint256 price,\n    uint256 limitPerAccount\n  );\n\n  /**\n   * @notice Emitted when NFTs are minted from the drop.\n   * @dev The total price paid by the buyer is `totalFees + creatorRev`.\n   * @param nftContract The address of the NFT drop collection.\n   * @param buyer The address of the buyer.\n   * @param firstTokenId The tokenId for the first NFT minted.\n   * The other minted tokens are assigned sequentially, so `firstTokenId` - `firstTokenId + count - 1` were minted.\n   * @param count The number of NFTs minted.\n   * @param totalFees The amount of ETH that was sent to Foundation & referrals for this sale.\n   * @param creatorRev The amount of ETH that was sent to the creator for this sale.\n   */\n  event MintFromFixedPriceDrop(\n    address indexed nftContract,\n    address indexed buyer,\n    uint256 indexed firstTokenId,\n    uint256 count,\n    uint256 totalFees,\n    uint256 creatorRev\n  );\n\n  /**\n   * @notice Create a fixed price sale drop.\n   * @param nftContract The address of the NFT drop collection.\n   * @param price The price per NFT minted.\n   * Set price to 0 for a first come first serve airdrop-like drop.\n   * @param limitPerAccount The max number of NFTs an account may have while minting.\n   * @dev Notes:\n   *   a) The sale is final and can not be updated or canceled.\n   *   b) The sale is immediately kicked off.\n   *   c) Any collection that abides by `INFTDropCollectionMint` and `IAccessControl` is supported.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function createFixedPriceSale(\n    address nftContract,\n    uint80 price,\n    uint16 limitPerAccount\n  ) external {\n    // Confirm the drop collection is supported\n    if (!nftContract.supportsInterface(type(INFTDropCollectionMint).interfaceId)) {\n      revert NFTDropMarketFixedPriceSale_Must_Support_Collection_Mint_Interface();\n    }\n    if (INFTDropCollectionMint(nftContract).numberOfTokensAvailableToMint() == 0) {\n      revert NFTDropMarketFixedPriceSale_Must_Not_Be_Sold_Out();\n    }\n\n    // Use the AccessControl interface to confirm the msg.sender has permissions to list.\n    if (!IAccessControl(nftContract).hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n      revert NFTDropMarketFixedPriceSale_Only_Callable_By_Collection_Owner();\n    }\n    // And that this contract has permission to mint.\n    if (!IAccessControl(nftContract).hasRole(MINTER_ROLE, address(this))) {\n      revert NFTDropMarketFixedPriceSale_Mint_Permission_Required();\n    }\n\n    // Validate input params.\n    if (limitPerAccount == 0) {\n      revert NFTDropMarketFixedPriceSale_Limit_Per_Account_Must_Be_Set();\n    }\n    // Any price is supported, including 0.\n\n    // Confirm this collection has not already been listed.\n    FixedPriceSaleConfig storage saleConfig = nftContractToFixedPriceSaleConfig[nftContract];\n    if (saleConfig.seller != payable(0)) {\n      revert NFTDropMarketFixedPriceSale_Must_Not_Have_Pending_Sale();\n    }\n\n    // Save the sale details.\n    saleConfig.seller = payable(msg.sender);\n    saleConfig.price = price;\n    saleConfig.limitPerAccount = limitPerAccount;\n    emit CreateFixedPriceSale(nftContract, saleConfig.seller, saleConfig.price, saleConfig.limitPerAccount);\n  }\n\n  /**\n   * @notice Used to mint `count` number of NFTs from the collection.\n   * @param nftContract The address of the NFT drop collection.\n   * @param count The number of NFTs to mint.\n   * @param buyReferrer The address which referred this purchase, or address(0) if n/a.\n   * @return firstTokenId The tokenId for the first NFT minted.\n   * The other minted tokens are assigned sequentially, so `firstTokenId` - `firstTokenId + count - 1` were minted.\n   * @dev This call may revert if the collection has sold out, has an insufficient number of tokens available,\n   * or if the market's minter permissions were removed.\n   * If insufficient msg.value is included, the msg.sender's available FETH token balance will be used.\n   */\n  function mintFromFixedPriceSale(\n    address nftContract,\n    uint16 count,\n    address payable buyReferrer\n  ) external payable returns (uint256 firstTokenId) {\n    // Validate input params.\n    if (count == 0) {\n      revert NFTDropMarketFixedPriceSale_Must_Buy_At_Least_One_Token();\n    }\n\n    FixedPriceSaleConfig memory saleConfig = nftContractToFixedPriceSaleConfig[nftContract];\n\n    // Confirm that the buyer will not exceed the limit specified after minting.\n    if (IERC721(nftContract).balanceOf(msg.sender) + count > saleConfig.limitPerAccount) {\n      if (saleConfig.limitPerAccount == 0) {\n        // Provide a more targeted error if the collection has not been listed.\n        revert NFTDropMarketFixedPriceSale_Must_Have_Sale_In_Progress();\n      }\n      revert NFTDropMarketFixedPriceSale_Cannot_Buy_More_Than_Limit(saleConfig.limitPerAccount);\n    }\n\n    // Calculate the total cost, considering the `count` requested.\n    uint256 mintCost;\n    unchecked {\n      // Can not overflow as 2^80 * 2^16 == 2^96 max which fits in 256 bits.\n      mintCost = uint256(saleConfig.price) * count;\n    }\n\n    // The sale price is immutable so the buyer is aware of how much they will be paying when their tx is broadcasted.\n    if (msg.value > mintCost) {\n      // Since price is known ahead of time, if too much ETH is sent then something went wrong.\n      revert NFTDropMarketFixedPriceSale_Too_Much_Value_Provided(mintCost);\n    }\n    // Withdraw from the user's available FETH balance if insufficient msg.value was included.\n    _tryUseFETHBalance(mintCost, false);\n\n    // Mint the NFTs.\n    firstTokenId = INFTDropCollectionMint(nftContract).mintCountTo(count, msg.sender);\n\n    // Distribute revenue from this sale.\n    (uint256 totalFees, uint256 creatorRev, ) = _distributeFunds(\n      nftContract,\n      firstTokenId,\n      saleConfig.seller,\n      mintCost,\n      buyReferrer\n    );\n\n    emit MintFromFixedPriceDrop(nftContract, msg.sender, firstTokenId, count, totalFees, creatorRev);\n  }\n\n  /**\n   * @notice Returns the max number of NFTs a given account may mint.\n   * @param nftContract The address of the NFT drop collection.\n   * @param user The address of the user which will be minting.\n   * @return numberThatCanBeMinted How many NFTs the user can mint.\n   */\n  function getAvailableCountFromFixedPriceSale(address nftContract, address user)\n    external\n    view\n    returns (uint256 numberThatCanBeMinted)\n  {\n    (, , uint256 limitPerAccount, uint256 numberOfTokensAvailableToMint, bool marketCanMint) = getFixedPriceSale(\n      nftContract\n    );\n    if (!marketCanMint) {\n      // No one can mint in the current state.\n      return 0;\n    }\n    uint256 currentBalance = IERC721(nftContract).balanceOf(user);\n    if (currentBalance >= limitPerAccount) {\n      // User has exhausted their limit.\n      return 0;\n    }\n\n    uint256 availableToMint = limitPerAccount - currentBalance;\n    if (availableToMint > numberOfTokensAvailableToMint) {\n      // User has more tokens available than the collection has available.\n      return numberOfTokensAvailableToMint;\n    }\n\n    return availableToMint;\n  }\n\n  /**\n   * @notice Returns details for a drop collection's fixed price sale.\n   * @param nftContract The address of the NFT drop collection.\n   * @return seller The address of the seller which listed this drop for sale.\n   * This value will be address(0) if the collection is not listed or has sold out.\n   * @return price The price per NFT minted.\n   * @return limitPerAccount The max number of NFTs an account may have while minting.\n   * @return numberOfTokensAvailableToMint The total number of NFTs that may still be minted.\n   * @return marketCanMint True if this contract has permissions to mint from the given collection.\n   */\n  function getFixedPriceSale(address nftContract)\n    public\n    view\n    returns (\n      address payable seller,\n      uint256 price,\n      uint256 limitPerAccount,\n      uint256 numberOfTokensAvailableToMint,\n      bool marketCanMint\n    )\n  {\n    try INFTDropCollectionMint(nftContract).numberOfTokensAvailableToMint() returns (uint256 count) {\n      if (count != 0) {\n        try IAccessControl(nftContract).hasRole(MINTER_ROLE, address(this)) returns (bool hasRole) {\n          marketCanMint = hasRole;\n        } catch {\n          // The contract is not supported - return default values.\n          return (payable(0), 0, 0, 0, false);\n        }\n\n        FixedPriceSaleConfig memory saleConfig = nftContractToFixedPriceSaleConfig[nftContract];\n        seller = saleConfig.seller;\n        price = saleConfig.price;\n        limitPerAccount = saleConfig.limitPerAccount;\n        numberOfTokensAvailableToMint = count;\n      }\n      // Else minted completed -- return default values.\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Contract not supported or self destructed - return default values\n    }\n  }\n\n  /**\n   * @inheritdoc MarketSharedCore\n   * @dev Returns the seller for a collection if listed and not already sold out.\n   */\n  function _getSellerOf(\n    address nftContract,\n    uint256 /* tokenId */\n  ) internal view virtual override returns (address payable seller) {\n    (seller, , , , ) = getFixedPriceSale(nftContract);\n  }\n\n  /**\n   * @notice This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[1000] private __gap;\n}"
    }
  ]
}