{
  "Title": "[M-19] Using `block.timestamp` as the deadline/expiry invites MEV",
  "Content": "\n\n_Note: this finding was reported via the winning [Automated Findings report](https://gist.github.com/code423n4/3c6507b76ca940e11c287862cb4a1fd3). It was declared out of scope for the audit, but is being included here for completeness._\n\nPassing `block.timestamp` as the expiry/deadline of an operation does not mean \"require immediate execution\" - it means \"whatever block this transaction appears in, I'm comfortable with that block's timestamp\". Providing this value means that a malicious miner can hold the transaction for as long as they like (think the flashbots mempool for bundling transactions), which may be until they are able to cause the transaction to incur the maximum amount of slippage allowed by the slippage parameter, or until conditions become unfavorable enough that other orders, e.g. liquidations, are triggered. Timestamps should be chosen off-chain, and should be specified by the caller to avoid unnecessary MEV.\n\n*There is one instance of this issue:*\n\n```solidity\nFile: contracts/amo/UniV2LiquidityAmo.sol\n\n337        .swapExactTokensForTokens(\n338          token1Amount,\n339          token2AmountOutMin,\n340          path,\n341          address(this),\n342          block.timestamp + 1\n343        )[path.length - 1];\n344  \n345:     // send tokens back to rdpxV2Core\n\n```\n*GitHub*: [337](https://github.com/code-423n4/2023-08-dopex/blob/0ea4387a4851cd6c8811dfb61da95a677f3f63ae/contracts/amo/UniV2LiquidityAmo.sol#L337-L345)\n\n**[psytama (Dopex) confirmed](https://gist.github.com/code423n4/3c6507b76ca940e11c287862cb4a1fd3?permalink_comment_id=4779111#gistcomment-4779111)**\n\n**[Alex the Entreprenerd (Judge) commented](https://gist.github.com/code423n4/3c6507b76ca940e11c287862cb4a1fd3?permalink_comment_id=4779121#gistcomment-4779121)**\n >This I agree with the sponsor that could be considered Medium as it allows MEV to be extracted by delaying tx inclusion.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-08-dopex",
  "Code": [
    {
      "filename": "contracts/amo/UniV2LiquidityAmo.sol",
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// Contracts\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// Interfaces\nimport { IERC20WithBurn } from \"../interfaces/IERC20WithBurn.sol\";\nimport { IUniswapV2Router } from \"../uniswap_V2/IUniswapV2Router.sol\";\nimport { IUniswapV2Pair } from \"../uniswap_V2/IUniswapV2Pair.sol\";\nimport { IRdpxEthOracle } from \"../interfaces/IRdpxEthOracle.sol\";\nimport { IRdpxV2Core } from \"../core/IRdpxV2Core.sol\";\n\n// Libraries\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/// @title UniswapV2LiquidityAmo contract\n/// @author Dopex\n/// @notice The uniswap v2 liquidity amo contract\ncontract UniV2LiquidityAMO is AccessControl {\n  using SafeERC20 for IERC20WithBurn;\n  using SafeMath for uint256;\n\n  // ================================ STATE VARIABLES ================================ //\n  struct Addresses {\n    // token A address\n    address tokenA; // rdpx\n    // token B address\n    address tokenB; // weth\n    // pair address\n    address pair;\n    // rdpxV2Core address\n    address rdpxV2Core;\n    // rdpx price oracle\n    address rdpxOracle;\n    // AMM Factory\n    address ammFactory;\n    // AMM Router\n    address ammRouter;\n  }\n\n  /// @notice  addresses of the contracts\n  Addresses public addresses;\n\n  /// @notice Precision used for prices, percentages and other calculations\n  uint256 public constant DEFAULT_PRECISION = 1e8;\n\n  /// @notice The slippage tolernce in swaps in 1e8 precision\n  uint256 public slippageTolerance = 5e5; // 0.5%\n\n  /// @notice LP token Balance\n  uint256 public lpTokenBalance;\n\n  // ================================ CONSTRUCTOR ================================ //\n  constructor() {\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n  }\n\n  // ================================ ADMIN FUNCTIONS ================================ //\n\n  /**\n   * @notice Set the addresses of the contracts\n   * @dev    Can only be called by admin\n   * @param  _tokenA the token A address\n   * @param  _tokenB the token B address\n   * @param _pair the pair address\n   * @param _rdpxV2Core the rdpxV2Core address\n   * @param _rdpxOracle the rdpx price oracle\n   * @param _ammFactory the AMM Factory\n   * @param _ammRouter the AMM Router\n   **/\n  function setAddresses(\n    address _tokenA,\n    address _tokenB,\n    address _pair,\n    address _rdpxV2Core,\n    address _rdpxOracle,\n    address _ammFactory,\n    address _ammRouter\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    require(\n      _tokenA != address(0) &&\n        _tokenB != address(0) &&\n        _pair != address(0) &&\n        _rdpxV2Core != address(0) &&\n        _rdpxOracle != address(0) &&\n        _ammFactory != address(0) &&\n        _ammRouter != address(0),\n      \"reLPContract: address cannot be 0\"\n    );\n    addresses = Addresses({\n      tokenA: _tokenA,\n      tokenB: _tokenB,\n      pair: _pair,\n      rdpxV2Core: _rdpxV2Core,\n      rdpxOracle: _rdpxOracle,\n      ammFactory: _ammFactory,\n      ammRouter: _ammRouter\n    });\n  }\n\n  /**\n   * @notice sets the slippage tolerance\n   * @dev    Can only be called by admin\n   * @param  _slippageTolerance the slippage tolerance\n   */\n  function setSlippageTolerance(\n    uint256 _slippageTolerance\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    require(\n      _slippageTolerance > 0,\n      \"reLPContract: slippage tolerance must be greater than 0\"\n    );\n    slippageTolerance = _slippageTolerance;\n  }\n\n  /**\n   * @notice Approve a contract to spend a certain amount of tokens\n   * @dev    Can only be called by admin\n   * @param  _token the address of the token to approve\n   * @param  _spender the address of the contract to approve\n   * @param  _amount the amount to approve\n   */\n  function approveContractToSpend(\n    address _token,\n    address _spender,\n    uint256 _amount\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    require(_token != address(0), \"reLPContract: token cannot be 0\");\n    require(_spender != address(0), \"reLPContract: spender cannot be 0\");\n    require(_amount > 0, \"reLPContract: amount must be greater than 0\");\n    IERC20WithBurn(_token).approve(_spender, _amount);\n  }\n\n  /**\n   * @notice Transfers all funds to msg.sender\n   * @dev    Can only be called by the owner\n   * @param  tokens The list of erc20 tokens to withdraw\n   **/\n  function emergencyWithdraw(\n    address[] calldata tokens\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    IERC20WithBurn token;\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      token = IERC20WithBurn(tokens[i]);\n      token.safeTransfer(msg.sender, token.balanceOf(address(this)));\n    }\n\n    emit LogEmergencyWithdraw(msg.sender, tokens);\n  }\n\n  // ================================ INTERNAL FUNCTIONS ================================ //\n\n  /**\n   * @dev sends token A and B to the rdpxV2Core\n   */\n  function _sendTokensToRdpxV2Core() internal {\n    uint256 tokenABalance = IERC20WithBurn(addresses.tokenA).balanceOf(\n      address(this)\n    );\n    uint256 tokenBBalance = IERC20WithBurn(addresses.tokenB).balanceOf(\n      address(this)\n    );\n    // transfer token A and B from this contract to the rdpxV2Core\n    IERC20WithBurn(addresses.tokenA).safeTransfer(\n      addresses.rdpxV2Core,\n      tokenABalance\n    );\n    IERC20WithBurn(addresses.tokenB).safeTransfer(\n      addresses.rdpxV2Core,\n      tokenBBalance\n    );\n\n    emit LogAssetsTransfered(msg.sender, tokenABalance, tokenBBalance);\n  }\n\n  // ================================ AMO FUNCTIONS ================================ //\n\n  /**\n   * @dev adds liquidity to the uni v2 pool\n   * @param tokenAAmount the amount of token A to add\n   * @param tokenBAmount the amount of token B to add\n   * @param tokenAAmountMin the minimum amount of token A to add\n   * @param tokenBAmountMin the minimum amount of token B to add\n   */\n  function addLiquidity(\n    uint256 tokenAAmount,\n    uint256 tokenBAmount,\n    uint256 tokenAAmountMin,\n    uint256 tokenBAmountMin\n  )\n    external\n    onlyRole(DEFAULT_ADMIN_ROLE)\n    returns (uint256 tokenAUsed, uint256 tokenBUsed, uint256 lpReceived)\n  {\n    // approve the AMM Router\n    IERC20WithBurn(addresses.tokenA).safeApprove(\n      addresses.ammRouter,\n      tokenAAmount\n    );\n    IERC20WithBurn(addresses.tokenB).safeApprove(\n      addresses.ammRouter,\n      tokenBAmount\n    );\n\n    // transfer token A and B from the rdpxV2Core to this contract\n    IERC20WithBurn(addresses.tokenA).safeTransferFrom(\n      addresses.rdpxV2Core,\n      address(this),\n      tokenAAmount\n    );\n    IERC20WithBurn(addresses.tokenB).safeTransferFrom(\n      addresses.rdpxV2Core,\n      address(this),\n      tokenBAmount\n    );\n\n    // add Liquidity\n    (tokenAUsed, tokenBUsed, lpReceived) = IUniswapV2Router(addresses.ammRouter)\n      .addLiquidity(\n        addresses.tokenA,\n        addresses.tokenB,\n        tokenAAmount,\n        tokenBAmount,\n        tokenAAmountMin,\n        tokenBAmountMin,\n        address(this),\n        block.timestamp + 1\n      );\n\n    // update LP token Balance\n    lpTokenBalance += lpReceived;\n\n    // send unused token A and token B back to rdpxV2Core\n    _sendTokensToRdpxV2Core();\n\n    emit LogAddLiquidity(\n      msg.sender,\n      tokenAAmount,\n      tokenBAmount,\n      tokenAAmountMin,\n      tokenBAmountMin,\n      tokenAUsed,\n      tokenBUsed,\n      lpReceived\n    );\n  }\n\n  /**\n   * @dev removes liquidity from the uni v2 pool\n   * @param lpAmount the amount of LP tokens to remove\n   * @param tokenAAmountMin the minimum amount of token A to receive\n   * @param tokenBAmountMin the minimum amount of token B to receive\n   */\n  function removeLiquidity(\n    uint256 lpAmount,\n    uint256 tokenAAmountMin,\n    uint256 tokenBAmountMin\n  )\n    external\n    onlyRole(DEFAULT_ADMIN_ROLE)\n    returns (uint256 tokenAReceived, uint256 tokenBReceived)\n  {\n    // approve the AMM Router\n    IERC20WithBurn(addresses.pair).safeApprove(addresses.ammRouter, lpAmount);\n\n    // remove liquidity\n    (tokenAReceived, tokenBReceived) = IUniswapV2Router(addresses.ammRouter)\n      .removeLiquidity(\n        addresses.tokenA,\n        addresses.tokenB,\n        lpAmount,\n        tokenAAmountMin,\n        tokenBAmountMin,\n        address(this),\n        block.timestamp + 1\n      );\n\n    // update LP token Balance\n    lpTokenBalance -= lpAmount;\n\n    // send unused token A and token B back to rdpxV2Core\n    _sendTokensToRdpxV2Core();\n\n    emit LogRemoveLiquidity(\n      msg.sender,\n      lpAmount,\n      tokenAAmountMin,\n      tokenBAmountMin,\n      tokenAReceived,\n      tokenBReceived\n    );\n  }\n\n  /**\n   * @dev swaps token 1 for token 2\n   * @param token1Amount the amount of token A to swap\n   * @param token2AmountOutMin the minimum amount of token B to receive\n   * @param swapTokenAForTokenB whether to swap token A for token B\n   */\n  function swap(\n    uint256 token1Amount,\n    uint256 token2AmountOutMin,\n    bool swapTokenAForTokenB\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) returns (uint256 token2Amount) {\n    address token1;\n    address token2;\n\n    // check to see if we are swapping token A for token B\n    if (swapTokenAForTokenB) {\n      token1 = addresses.tokenA;\n      token2 = addresses.tokenB;\n    } else {\n      token1 = addresses.tokenB;\n      token2 = addresses.tokenA;\n    }\n    // transfer token A from the rdpxV2Core to this contract\n    IERC20WithBurn(token1).safeTransferFrom(\n      addresses.rdpxV2Core,\n      address(this),\n      token1Amount\n    );\n\n    // approve the AMM Router\n    IERC20WithBurn(token1).safeApprove(addresses.ammRouter, token1Amount);\n\n    address[] memory path;\n    path = new address[](2);\n    path[0] = token1;\n    path[1] = token2;\n\n    // swap token A for token B\n    token2Amount = IUniswapV2Router(addresses.ammRouter)\n      .swapExactTokensForTokens(\n        token1Amount,\n        token2AmountOutMin,\n        path,\n        address(this),\n        block.timestamp + 1\n      )[path.length - 1];\n\n    // send tokens back to rdpxV2Core\n    _sendTokensToRdpxV2Core();\n\n    emit LogSwap(\n      msg.sender,\n      token1Amount,\n      token2AmountOutMin,\n      swapTokenAForTokenB,\n      token2Amount\n    );\n  }\n\n  // ================================ EXTERNAL FUNCTIONS ================================ //\n\n  /**\n   * @notice Syncs asset reserves with contract balances\n   **/\n  function sync() external {\n    lpTokenBalance = IERC20WithBurn(addresses.pair).balanceOf(address(this));\n  }\n\n  // ================================ VIEW FUNCTIONS ================================ //\n  /**\n   * @notice Returns the LP token balance in weth\n   * @dev returns LP token balance\n   * @return lpTokenBalanceInWeth the LP token balance in weth\n   */\n  function getLpTokenBalanceInWeth() external view returns (uint256) {\n    return (lpTokenBalance * getLpPrice()) / 1e8;\n  }\n\n  /**\n   * @notice Returns the price of a rDPX/ETH Lp token against the alpha token\n   * @dev    Price is in 1e8 Precision\n   * @return uint256 LP price\n   **/\n  function getLpPrice() public view returns (uint256) {\n    return IRdpxEthOracle(addresses.rdpxOracle).getLpPriceInEth();\n  }\n\n  // ================================ Events FUNCTIONS ================================ //\n\n  event LogAddLiquidity(\n    address indexed sender,\n    uint256 tokenAAmount,\n    uint256 tokenBAmount,\n    uint256 tokenAAmountMin,\n    uint256 tokenBAmountMin,\n    uint256 tokenAUsed,\n    uint256 tokenBUsed,\n    uint256 lpReceived\n  );\n\n  event LogRemoveLiquidity(\n    address indexed sender,\n    uint256 lpAmount,\n    uint256 tokenAAmountMin,\n    uint256 tokenBAmountMin,\n    uint256 tokenAReceived,\n    uint256 tokenBReceived\n  );\n\n  event LogSwap(\n    address indexed sender,\n    uint256 token1Amount,\n    uint256 token2AmountOutMin,\n    bool swapTokenAForTokenB,\n    uint256 token2Amount\n  );\n\n  event LogAssetsTransfered(\n    address indexed sender,\n    uint256 tokenAAmount,\n    uint256 tokenBAmount\n  );\n\n  event LogEmergencyWithdraw(address sender, address[] tokens);\n}"
    }
  ]
}