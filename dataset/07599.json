{
  "Title": "[H-02] Users Receive Less Rewards Due To Miscalculations",
  "Content": "\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L305>\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L281>\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L373>\n\n### Background\n\nThe amount of rewards accrued by global and user states is computed by the following steps:\n\n1.  Calculate seconds elapsed since the last update (`block.timestamp - lastUpdate`)\n2.  Calculate the new rewards by multiplying seconds elapsed by the last supply (`(block.timestamp - lastUpdate) * lastSupply`)\n3.  Append the new rewards to the existing rewards (`rewards = rewards + (block.timestamp - lastUpdate) * lastSupply`)\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L305>\n\n```solidity\n/**\n    @notice Update global accrual state\n    @param  globalState    GlobalState  Global state of the producer token\n    @param  producerToken  ERC20        Producer token contract\n*/\nfunction _globalAccrue(GlobalState storage globalState, ERC20 producerToken)\n\tinternal\n{\n    uint256 totalSupply = producerToken.totalSupply();\n    uint256 lastUpdate = globalState.lastUpdate;\n    uint256 lastSupply = globalState.lastSupply;\n\n    // Calculate rewards, the product of seconds elapsed and last supply\n    // Only calculate and update states when needed\n    if (block.timestamp != lastUpdate || totalSupply != lastSupply) {\n        uint256 rewards = globalState.rewards +\n            (block.timestamp - lastUpdate) *\n            lastSupply;\n            \n            globalState.lastUpdate = block.timestamp.safeCastTo32();\n            globalState.lastSupply = totalSupply.safeCastTo224();\n            globalState.rewards = rewards;\n   \t..SNIP..\n}\n```\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L281>\n\n```solidity\n/**\n    @notice Update user rewards accrual state\n    @param  producerToken  ERC20    Rewards-producing token\n    @param  user           address  User address\n*/\nfunction userAccrue(ERC20 producerToken, address user) public {\n    if (address(producerToken) == address(0)) revert ZeroAddress();\n    if (user == address(0)) revert ZeroAddress();\n\n    UserState storage u = producerTokens[producerToken].userStates[user];\n    uint256 balance = producerToken.balanceOf(user);\n\n    // Calculate the amount of rewards accrued by the user up to this call\n    uint256 rewards = u.rewards +\n    u.lastBalance *\n    (block.timestamp - u.lastUpdate);\n    \n    u.lastUpdate = block.timestamp.safeCastTo32();\n    u.lastBalance = balance.safeCastTo224();\n    u.rewards = rewards;\n    ..SNIP..\n}\n```\n\nWhen a user claims the rewards, the number of reward tokens the user is entitled to is equal to the `rewardState` scaled by the ratio of the `userRewards` to the `globalRewards`. Refer to Line 403 below.\n\nThe `rewardState` represents the total number of a specific ERC20 reward token (e.g. WETH or esGMX) held by a producer (e.g. pxGMX or pxGPL).\n\nThe `rewardState` of each reward token (e.g. WETH or esGMX) will increase whenever the rewards are harvested by the producer (e.g. `PirexRewards.harvest` is called). On the other hand, the `rewardState` will decrease if the users claim the rewards.\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L373>\n\n```solidity\nFile: PirexRewards.sol\n373:     function claim(ERC20 producerToken, address user) external {\n..SNIP..\n395:             // Transfer the proportionate reward token amounts to the recipient\n396:             for (uint256 i; i < rLen; ++i) {\n397:                 ERC20 rewardToken = rewardTokens[i];\n398:                 address rewardRecipient = p.rewardRecipients[user][rewardToken];\n399:                 address recipient = rewardRecipient != address(0)\n400:                     ? rewardRecipient\n401:                     : user;\n402:                 uint256 rewardState = p.rewardStates[rewardToken];\n403:                 uint256 amount = (rewardState * userRewards) / globalRewards;\n..SNIP..\n417:     }\n```\n\n#### How reward tokens are distributed\n\nThe Multiplier Point (MP) effect will be ignored for simplicity. Assume that the emission rate is constant throughout the entire period (from T80 to T84) and the emission rate is 1 esGMX per 1 GMX staked per second.\n\nThe graph below represents the amount of GMX tokens Alice and Bob staked for each second during the period.\n\nA = Alice and B = Bob; each block represents 1 GMX token staked.\n\n![](https://user-images.githubusercontent.com/102820284/204132445-50422095-c02c-4f45-95d6-575667211092.png)\n\nBased on the above graph:\n\n*   Alice staked 1 GMX token from T80 to T84. Alice will earn five (5) esGMX tokens at the end of T84.\n*   Bob staked 4 GMX tokens from T83 to T84. Bob will earn eight (8) esGMX tokens at the end of T84.\n*   A total of 13 esGMX will be harvested by `PirexRewards` contract at the end of T84\n\nThe existing reward distribution design in the `PirexRewards` contract will work perfectly if the emission rate is constant, similar to the example above.\n\nIn this case, the state variable will be as follows at the end of T84, assuming both the global and all user states have been updated and rewards have been harvested.\n\n*   rewardState = 13 esGMX tokens (5 + 8)\n*   globalRewards = 13\n*   Accrued `userRewards` of Alice = 5\n*   Accrued `userRewards` of Bob = 8\n\nWhen Alice calls the `PirexRewards.claim` function to claim her rewards at the end of T84, she will get back five (5) esGMX tokens, which is correct.\n\n```solidity\n(rewardState * userRewards) / globalRewards\n(13 * 5) / 13 = 5\n```\n\n### Proof of Concept\n\nHowever, the fact is that the emission rate of reward tokens (e.g. esGMX or WETH) is not constant. Instead, the emission rate is dynamic and depends on various factors, such as the following:\n\n*   The number of rewards tokens allocated by GMX governance for each month. Refer to <https://gov.gmx.io/t/esgmx-emissions/272>. In some months, the number of esGMX emissions will be higher.\n*   The number of GMX/GLP tokens staked by the community. The more tokens being staked by the community users, the more diluted the rewards will be.\n\nThe graph below represents the amount of GMX tokens Alice and Bob staked for each second during the period.\n\nA = Alice and B = Bob; each block represents 1 GMX token staked.\n\n![](https://user-images.githubusercontent.com/102820284/204132445-50422095-c02c-4f45-95d6-575667211092.png)\n\nThe Multiplier Point (MP) effect will be ignored for simplicity. Assume that the emission rate is as follows:\n\n*   From T80 to 82: 2 esGMX per 1 GMX staked per second (Higher emission rate)\n*   From T83 to 84: 1 esGMX per 1 GMX staked per second (Lower emission rate)\n\nBy manually computing the amount of esGMX reward tokens that Alice is entitled to at the end of T84:\n\n```solidity\n[1 staked GMX * (T82 - T80) * 2esGMX/sec] + [1 staked GMX * (T84 - T83) * 1esGMX/sec]\n[1 staked GMX * 3 secs * 2esGMX/sec] + [1 staked GMX * 2secs * 1esGMX/sec]\n6 + 2 = 8\n```\n\nAlice will be entitled to 8 esGMX reward tokens at the end of T84.\n\nBy manually computing the amount of esGMX reward tokens that Bob is entitled to at the end of T84:\n\n```solidity\n[4 staked GMX * 2secs * 1esGMX/sec] = 8\n```\n\nBob will be entitled to 8 esGMX reward tokens at the end of T84.\n\nHowever, the existing reward distribution design in the `PirexRewards` contract will cause Alice to get fewer reward tokens than she is entitled to and cause Bob to get more rewards than he is entitled to.\n\nThe state variable will be as follows at the end of T84, assuming both the global and all user states have been updated and rewards have been harvested.\n\n*   rewardState = 16 esGMX tokens (8 + 8)\n*   globalRewards = 13\n*   Accrued `userRewards` of Alice = 5\n*   Accrued `userRewards` of Bob = 8\n\nWhen Alice calls the `PirexRewards.claim` function to claim her rewards at the end of T84, she will only get back six (6) esGMX tokens, which is less than eight (8) esGMX tokens she is entitled to or earned.\n\n```solidity\n(rewardState * userRewards) / globalRewards\n(16 * 5) / 13 = 6.15 = 6\n```\n\nWhen Bob calls the `PirexRewards.claim` function to claim his rewards at the end of T84, he will get back nine (9) esGMX tokens, which is more than eight (8) esGMX tokens he is entitled to or earned.\n\n```solidity\n(rewardState * userRewards) / globalRewards\n(16 * 8) / 13 = 9.85 = 9\n```\n\n### Impact\n\nAs shown in the PoC, some users will lose their reward tokens due to the miscalculation within the existing reward distribution design.\n\n### Recommended Mitigation Steps\n\nUpdate the existing reward distribution design to handle the dynamic emission rate. Implement the RewardPerToken for users and global, as seen in many of the well-established reward contracts below, which are not vulnerable to this issue:\n\n*   <https://github.com/fei-protocol/flywheel-v2/blob/dbe3cb81a3dc2e46536bb8af9c2bdc585f63425e/src/FlywheelCore.sol#L226>\n*   <https://github.com/Synthetixio/synthetix/blob/2cb4b23fe409af526de67dfbb84aae84b2b13747/contracts/StakingRewards.sol#L61>\n\n**[kphed (Redacted Cartel) confirmed](https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/177)** \n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-11-redacted-cartel-contest",
  "Code": [
    {
      "filename": "src/PirexRewards.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {OwnableUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {SafeCastLib} from \"solmate/utils/SafeCastLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {IProducer} from \"src/interfaces/IProducer.sol\";\nimport {GlobalState, UserState} from \"src/Common.sol\";\n\n/**\n    Originally inspired by Flywheel V2 (thank you Tribe team):\n    https://github.com/fei-protocol/flywheel-v2/blob/dbe3cb8/src/FlywheelCore.sol\n*/\ncontract PirexRewards is OwnableUpgradeable {\n    using SafeTransferLib for ERC20;\n    using SafeCastLib for uint256;\n\n    struct ProducerToken {\n        ERC20[] rewardTokens;\n        GlobalState globalState;\n        mapping(address => UserState) userStates;\n        mapping(ERC20 => uint256) rewardStates;\n        mapping(address => mapping(ERC20 => address)) rewardRecipients;\n    }\n\n    // Pirex contract which produces rewards\n    IProducer public producer;\n\n    // Producer tokens mapped to their data\n    mapping(ERC20 => ProducerToken) public producerTokens;\n\n    event SetProducer(address producer);\n    event SetRewardRecipient(\n        address indexed user,\n        ERC20 indexed producerToken,\n        ERC20 indexed rewardToken,\n        address recipient\n    );\n    event UnsetRewardRecipient(\n        address indexed user,\n        ERC20 indexed producerToken,\n        ERC20 indexed rewardToken\n    );\n    event AddRewardToken(\n        ERC20 indexed producerToken,\n        ERC20 indexed rewardToken\n    );\n    event RemoveRewardToken(ERC20 indexed producerToken, uint256 removalIndex);\n    event GlobalAccrue(\n        ERC20 indexed producerToken,\n        uint256 lastUpdate,\n        uint256 lastSupply,\n        uint256 rewards\n    );\n    event UserAccrue(\n        ERC20 indexed producerToken,\n        address indexed user,\n        uint256 lastUpdate,\n        uint256 lastBalance,\n        uint256 rewards\n    );\n    event Harvest(\n        ERC20[] producerTokens,\n        ERC20[] rewardTokens,\n        uint256[] rewardAmounts\n    );\n    event Claim(ERC20 indexed producerToken, address indexed user);\n    event SetRewardRecipientPrivileged(\n        address indexed lpContract,\n        ERC20 indexed producerToken,\n        ERC20 indexed rewardToken,\n        address recipient\n    );\n    event UnsetRewardRecipientPrivileged(\n        address indexed lpContract,\n        ERC20 indexed producerToken,\n        ERC20 indexed rewardToken\n    );\n\n    error ZeroAddress();\n    error NotContract();\n    error TokenAlreadyAdded();\n\n    function initialize() public initializer {\n        __Ownable_init();\n    }\n\n    /**\n        @notice Set producer\n        @param  _producer  address  Producer contract address\n     */\n    function setProducer(address _producer) external onlyOwner {\n        if (_producer == address(0)) revert ZeroAddress();\n\n        producer = IProducer(_producer);\n\n        emit SetProducer(_producer);\n    }\n\n    /**\n        @notice Set reward recipient for a reward token\n        @param  producerToken  ERC20    Producer token contract\n        @param  rewardToken    ERC20    Reward token contract\n        @param  recipient      address  Rewards recipient\n    */\n    function setRewardRecipient(\n        ERC20 producerToken,\n        ERC20 rewardToken,\n        address recipient\n    ) external {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (address(rewardToken) == address(0)) revert ZeroAddress();\n        if (recipient == address(0)) revert ZeroAddress();\n\n        producerTokens[producerToken].rewardRecipients[msg.sender][\n            rewardToken\n        ] = recipient;\n\n        emit SetRewardRecipient(\n            msg.sender,\n            producerToken,\n            rewardToken,\n            recipient\n        );\n    }\n\n    /**\n        @notice Unset reward recipient for a reward token\n        @param  producerToken  ERC20  Producer token contract\n        @param  rewardToken    ERC20  Reward token contract\n    */\n    function unsetRewardRecipient(ERC20 producerToken, ERC20 rewardToken)\n        external\n    {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (address(rewardToken) == address(0)) revert ZeroAddress();\n\n        delete producerTokens[producerToken].rewardRecipients[msg.sender][\n            rewardToken\n        ];\n\n        emit UnsetRewardRecipient(msg.sender, producerToken, rewardToken);\n    }\n\n    /**\n        @notice Add a reward token to a producer token's rewardTokens array\n        @param  producerToken  ERC20  Producer token contract\n        @param  rewardToken    ERC20  Reward token contract\n    */\n    function addRewardToken(ERC20 producerToken, ERC20 rewardToken)\n        external\n        onlyOwner\n    {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (address(rewardToken) == address(0)) revert ZeroAddress();\n\n        // Check if the token has been added previously for the specified producer\n        ProducerToken storage p = producerTokens[producerToken];\n        ERC20[] memory rewardTokens = p.rewardTokens;\n        uint256 len = rewardTokens.length;\n\n        for (uint256 i; i < len; ++i) {\n            if (address(rewardTokens[i]) == address(rewardToken)) {\n                revert TokenAlreadyAdded();\n            }\n        }\n\n        p.rewardTokens.push(rewardToken);\n\n        emit AddRewardToken(producerToken, rewardToken);\n    }\n\n    /**\n        @notice Remove a reward token from a producer token's rewardTokens array\n        @param  producerToken  ERC20    Producer token contract\n        @param  removalIndex   uint256  Index of the element to be removed\n    */\n    function removeRewardToken(ERC20 producerToken, uint256 removalIndex)\n        external\n        onlyOwner\n    {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n\n        ERC20[] storage rewardTokens = producerTokens[producerToken]\n            .rewardTokens;\n        uint256 lastIndex = rewardTokens.length - 1;\n\n        if (removalIndex != lastIndex) {\n            // Set the element at removalIndex to the last element\n            rewardTokens[removalIndex] = rewardTokens[lastIndex];\n        }\n\n        rewardTokens.pop();\n\n        emit RemoveRewardToken(producerToken, removalIndex);\n    }\n\n    /**\n        @notice Getter for a producer token's UserState struct member values\n        @param  producerToken  ERC20    Producer token contract\n        @param  user           address  User\n        @return lastUpdate     uint256  Last update\n        @return lastBalance    uint256  Last balance\n        @return rewards        uint256  Rewards\n    */\n    function getUserState(ERC20 producerToken, address user)\n        external\n        view\n        returns (\n            uint256 lastUpdate,\n            uint256 lastBalance,\n            uint256 rewards\n        )\n    {\n        UserState memory userState = producerTokens[producerToken].userStates[\n            user\n        ];\n\n        return (userState.lastUpdate, userState.lastBalance, userState.rewards);\n    }\n\n    /**\n        @notice Getter for a producer token's accrued amount for a reward token\n        @param  producerToken  ERC20    Producer token contract\n        @param  rewardToken    ERC20    Reward token contract\n        @return                uint256  Reward state\n    */\n    function getRewardState(ERC20 producerToken, ERC20 rewardToken)\n        external\n        view\n        returns (uint256)\n    {\n        return producerTokens[producerToken].rewardStates[rewardToken];\n    }\n\n    /**\n        @notice Getter for a producer token's reward tokens\n        @param  producerToken  ERC20    Producer token contract\n        @return                ERC20[]  Reward token contracts\n    */\n    function getRewardTokens(ERC20 producerToken)\n        external\n        view\n        returns (ERC20[] memory)\n    {\n        return producerTokens[producerToken].rewardTokens;\n    }\n\n    /**\n        @notice Get the reward recipient for a user by producer and reward token\n        @param  user           address  User\n        @param  producerToken  ERC20    Producer token contract\n        @param  rewardToken    ERC20    Reward token contract\n        @return                address  Reward recipient\n    */\n    function getRewardRecipient(\n        address user,\n        ERC20 producerToken,\n        ERC20 rewardToken\n    ) external view returns (address) {\n        return\n            producerTokens[producerToken].rewardRecipients[user][rewardToken];\n    }\n\n    /**\n        @notice Update global rewards accrual state\n        @param  producerToken  ERC20  Rewards-producing token\n    */\n    function globalAccrue(ERC20 producerToken) external {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n\n        _globalAccrue(producerTokens[producerToken].globalState, producerToken);\n    }\n\n    /**\n        @notice Update user rewards accrual state\n        @param  producerToken  ERC20    Rewards-producing token\n        @param  user           address  User address\n    */\n    function userAccrue(ERC20 producerToken, address user) public {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (user == address(0)) revert ZeroAddress();\n\n        UserState storage u = producerTokens[producerToken].userStates[user];\n        uint256 balance = producerToken.balanceOf(user);\n\n        // Calculate the amount of rewards accrued by the user up to this call\n        uint256 rewards = u.rewards +\n            u.lastBalance *\n            (block.timestamp - u.lastUpdate);\n\n        u.lastUpdate = block.timestamp.safeCastTo32();\n        u.lastBalance = balance.safeCastTo224();\n        u.rewards = rewards;\n\n        emit UserAccrue(producerToken, user, block.timestamp, balance, rewards);\n    }\n\n    /**\n        @notice Update global accrual state\n        @param  globalState    GlobalState  Global state of the producer token\n        @param  producerToken  ERC20        Producer token contract\n    */\n    function _globalAccrue(GlobalState storage globalState, ERC20 producerToken)\n        internal\n    {\n        uint256 totalSupply = producerToken.totalSupply();\n        uint256 lastUpdate = globalState.lastUpdate;\n        uint256 lastSupply = globalState.lastSupply;\n\n        // Calculate rewards, the product of seconds elapsed and last supply\n        // Only calculate and update states when needed\n        if (block.timestamp != lastUpdate || totalSupply != lastSupply) {\n            uint256 rewards = globalState.rewards +\n                (block.timestamp - lastUpdate) *\n                lastSupply;\n\n            globalState.lastUpdate = block.timestamp.safeCastTo32();\n            globalState.lastSupply = totalSupply.safeCastTo224();\n            globalState.rewards = rewards;\n\n            emit GlobalAccrue(\n                producerToken,\n                block.timestamp,\n                totalSupply,\n                rewards\n            );\n        }\n    }\n\n    /**\n        @notice Harvest rewards\n        @return _producerTokens  ERC20[]  Producer token contracts\n        @return rewardTokens     ERC20[]  Reward token contracts\n        @return rewardAmounts    ERC20[]  Reward token amounts\n    */\n    function harvest()\n        public\n        returns (\n            ERC20[] memory _producerTokens,\n            ERC20[] memory rewardTokens,\n            uint256[] memory rewardAmounts\n        )\n    {\n        (_producerTokens, rewardTokens, rewardAmounts) = producer\n            .claimRewards();\n        uint256 pLen = _producerTokens.length;\n\n        // Iterate over the producer tokens and update reward state\n        for (uint256 i; i < pLen; ++i) {\n            ERC20 p = _producerTokens[i];\n            uint256 r = rewardAmounts[i];\n\n            // Update global reward accrual state and associate with the update of reward state\n            ProducerToken storage producerState = producerTokens[p];\n\n            _globalAccrue(producerState.globalState, p);\n\n            if (r != 0) {\n                producerState.rewardStates[rewardTokens[i]] += r;\n            }\n        }\n\n        emit Harvest(_producerTokens, rewardTokens, rewardAmounts);\n    }\n\n    /**\n        @notice Claim rewards\n        @param  producerToken  ERC20    Producer token contract\n        @param  user           address  User\n    */\n    function claim(ERC20 producerToken, address user) external {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (user == address(0)) revert ZeroAddress();\n\n        harvest();\n        userAccrue(producerToken, user);\n\n        ProducerToken storage p = producerTokens[producerToken];\n        uint256 globalRewards = p.globalState.rewards;\n        uint256 userRewards = p.userStates[user].rewards;\n\n        // Claim should be skipped and not reverted on zero global/user reward\n        if (globalRewards != 0 && userRewards != 0) {\n            ERC20[] memory rewardTokens = p.rewardTokens;\n            uint256 rLen = rewardTokens.length;\n\n            // Update global and user reward states to reflect the claim\n            p.globalState.rewards = globalRewards - userRewards;\n            p.userStates[user].rewards = 0;\n\n            emit Claim(producerToken, user);\n\n            // Transfer the proportionate reward token amounts to the recipient\n            for (uint256 i; i < rLen; ++i) {\n                ERC20 rewardToken = rewardTokens[i];\n                address rewardRecipient = p.rewardRecipients[user][rewardToken];\n                address recipient = rewardRecipient != address(0)\n                    ? rewardRecipient\n                    : user;\n                uint256 rewardState = p.rewardStates[rewardToken];\n                uint256 amount = (rewardState * userRewards) / globalRewards;\n\n                if (amount != 0) {\n                    // Update reward state (i.e. amount) to reflect reward tokens transferred out\n                    p.rewardStates[rewardToken] = rewardState - amount;\n\n                    producer.claimUserReward(\n                        address(rewardToken),\n                        amount,\n                        recipient\n                    );\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    ⚠️ NOTABLE PRIVILEGED METHODS ⚠️\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Privileged method for setting the reward recipient of a contract\n        @notice This should ONLY be used to forward rewards for Pirex-GMX LP contracts\n        @notice In production, we will have a 2nd multisig which reduces risk of abuse\n        @param  lpContract     address  Pirex-GMX LP contract\n        @param  producerToken  ERC20    Producer token contract\n        @param  rewardToken    ERC20    Reward token contract\n        @param  recipient      address  Rewards recipient\n    */\n    function setRewardRecipientPrivileged(\n        address lpContract,\n        ERC20 producerToken,\n        ERC20 rewardToken,\n        address recipient\n    ) external onlyOwner {\n        if (lpContract.code.length == 0) revert NotContract();\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (address(rewardToken) == address(0)) revert ZeroAddress();\n        if (recipient == address(0)) revert ZeroAddress();\n\n        producerTokens[producerToken].rewardRecipients[lpContract][\n            rewardToken\n        ] = recipient;\n\n        emit SetRewardRecipientPrivileged(\n            lpContract,\n            producerToken,\n            rewardToken,\n            recipient\n        );\n    }\n\n    /**\n        @notice Privileged method for unsetting the reward recipient of a contract\n        @param  lpContract     address  Pirex-GMX LP contract\n        @param  producerToken  ERC20    Producer token contract\n        @param  rewardToken    ERC20    Reward token contract\n    */\n    function unsetRewardRecipientPrivileged(\n        address lpContract,\n        ERC20 producerToken,\n        ERC20 rewardToken\n    ) external onlyOwner {\n        if (lpContract.code.length == 0) revert NotContract();\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (address(rewardToken) == address(0)) revert ZeroAddress();\n\n        delete producerTokens[producerToken].rewardRecipients[lpContract][\n            rewardToken\n        ];\n\n        emit UnsetRewardRecipientPrivileged(\n            lpContract,\n            producerToken,\n            rewardToken\n        );\n    }\n}"
    },
    {
      "filename": "src/PirexRewards.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {OwnableUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {SafeCastLib} from \"solmate/utils/SafeCastLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {IProducer} from \"src/interfaces/IProducer.sol\";\nimport {GlobalState, UserState} from \"src/Common.sol\";\n\n/**\n    Originally inspired by Flywheel V2 (thank you Tribe team):\n    https://github.com/fei-protocol/flywheel-v2/blob/dbe3cb8/src/FlywheelCore.sol\n*/\ncontract PirexRewards is OwnableUpgradeable {\n    using SafeTransferLib for ERC20;\n    using SafeCastLib for uint256;\n\n    struct ProducerToken {\n        ERC20[] rewardTokens;\n        GlobalState globalState;\n        mapping(address => UserState) userStates;\n        mapping(ERC20 => uint256) rewardStates;\n        mapping(address => mapping(ERC20 => address)) rewardRecipients;\n    }\n\n    // Pirex contract which produces rewards\n    IProducer public producer;\n\n    // Producer tokens mapped to their data\n    mapping(ERC20 => ProducerToken) public producerTokens;\n\n    event SetProducer(address producer);\n    event SetRewardRecipient(\n        address indexed user,\n        ERC20 indexed producerToken,\n        ERC20 indexed rewardToken,\n        address recipient\n    );\n    event UnsetRewardRecipient(\n        address indexed user,\n        ERC20 indexed producerToken,\n        ERC20 indexed rewardToken\n    );\n    event AddRewardToken(\n        ERC20 indexed producerToken,\n        ERC20 indexed rewardToken\n    );\n    event RemoveRewardToken(ERC20 indexed producerToken, uint256 removalIndex);\n    event GlobalAccrue(\n        ERC20 indexed producerToken,\n        uint256 lastUpdate,\n        uint256 lastSupply,\n        uint256 rewards\n    );\n    event UserAccrue(\n        ERC20 indexed producerToken,\n        address indexed user,\n        uint256 lastUpdate,\n        uint256 lastBalance,\n        uint256 rewards\n    );\n    event Harvest(\n        ERC20[] producerTokens,\n        ERC20[] rewardTokens,\n        uint256[] rewardAmounts\n    );\n    event Claim(ERC20 indexed producerToken, address indexed user);\n    event SetRewardRecipientPrivileged(\n        address indexed lpContract,\n        ERC20 indexed producerToken,\n        ERC20 indexed rewardToken,\n        address recipient\n    );\n    event UnsetRewardRecipientPrivileged(\n        address indexed lpContract,\n        ERC20 indexed producerToken,\n        ERC20 indexed rewardToken\n    );\n\n    error ZeroAddress();\n    error NotContract();\n    error TokenAlreadyAdded();\n\n    function initialize() public initializer {\n        __Ownable_init();\n    }\n\n    /**\n        @notice Set producer\n        @param  _producer  address  Producer contract address\n     */\n    function setProducer(address _producer) external onlyOwner {\n        if (_producer == address(0)) revert ZeroAddress();\n\n        producer = IProducer(_producer);\n\n        emit SetProducer(_producer);\n    }\n\n    /**\n        @notice Set reward recipient for a reward token\n        @param  producerToken  ERC20    Producer token contract\n        @param  rewardToken    ERC20    Reward token contract\n        @param  recipient      address  Rewards recipient\n    */\n    function setRewardRecipient(\n        ERC20 producerToken,\n        ERC20 rewardToken,\n        address recipient\n    ) external {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (address(rewardToken) == address(0)) revert ZeroAddress();\n        if (recipient == address(0)) revert ZeroAddress();\n\n        producerTokens[producerToken].rewardRecipients[msg.sender][\n            rewardToken\n        ] = recipient;\n\n        emit SetRewardRecipient(\n            msg.sender,\n            producerToken,\n            rewardToken,\n            recipient\n        );\n    }\n\n    /**\n        @notice Unset reward recipient for a reward token\n        @param  producerToken  ERC20  Producer token contract\n        @param  rewardToken    ERC20  Reward token contract\n    */\n    function unsetRewardRecipient(ERC20 producerToken, ERC20 rewardToken)\n        external\n    {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (address(rewardToken) == address(0)) revert ZeroAddress();\n\n        delete producerTokens[producerToken].rewardRecipients[msg.sender][\n            rewardToken\n        ];\n\n        emit UnsetRewardRecipient(msg.sender, producerToken, rewardToken);\n    }\n\n    /**\n        @notice Add a reward token to a producer token's rewardTokens array\n        @param  producerToken  ERC20  Producer token contract\n        @param  rewardToken    ERC20  Reward token contract\n    */\n    function addRewardToken(ERC20 producerToken, ERC20 rewardToken)\n        external\n        onlyOwner\n    {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (address(rewardToken) == address(0)) revert ZeroAddress();\n\n        // Check if the token has been added previously for the specified producer\n        ProducerToken storage p = producerTokens[producerToken];\n        ERC20[] memory rewardTokens = p.rewardTokens;\n        uint256 len = rewardTokens.length;\n\n        for (uint256 i; i < len; ++i) {\n            if (address(rewardTokens[i]) == address(rewardToken)) {\n                revert TokenAlreadyAdded();\n            }\n        }\n\n        p.rewardTokens.push(rewardToken);\n\n        emit AddRewardToken(producerToken, rewardToken);\n    }\n\n    /**\n        @notice Remove a reward token from a producer token's rewardTokens array\n        @param  producerToken  ERC20    Producer token contract\n        @param  removalIndex   uint256  Index of the element to be removed\n    */\n    function removeRewardToken(ERC20 producerToken, uint256 removalIndex)\n        external\n        onlyOwner\n    {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n\n        ERC20[] storage rewardTokens = producerTokens[producerToken]\n            .rewardTokens;\n        uint256 lastIndex = rewardTokens.length - 1;\n\n        if (removalIndex != lastIndex) {\n            // Set the element at removalIndex to the last element\n            rewardTokens[removalIndex] = rewardTokens[lastIndex];\n        }\n\n        rewardTokens.pop();\n\n        emit RemoveRewardToken(producerToken, removalIndex);\n    }\n\n    /**\n        @notice Getter for a producer token's UserState struct member values\n        @param  producerToken  ERC20    Producer token contract\n        @param  user           address  User\n        @return lastUpdate     uint256  Last update\n        @return lastBalance    uint256  Last balance\n        @return rewards        uint256  Rewards\n    */\n    function getUserState(ERC20 producerToken, address user)\n        external\n        view\n        returns (\n            uint256 lastUpdate,\n            uint256 lastBalance,\n            uint256 rewards\n        )\n    {\n        UserState memory userState = producerTokens[producerToken].userStates[\n            user\n        ];\n\n        return (userState.lastUpdate, userState.lastBalance, userState.rewards);\n    }\n\n    /**\n        @notice Getter for a producer token's accrued amount for a reward token\n        @param  producerToken  ERC20    Producer token contract\n        @param  rewardToken    ERC20    Reward token contract\n        @return                uint256  Reward state\n    */\n    function getRewardState(ERC20 producerToken, ERC20 rewardToken)\n        external\n        view\n        returns (uint256)\n    {\n        return producerTokens[producerToken].rewardStates[rewardToken];\n    }\n\n    /**\n        @notice Getter for a producer token's reward tokens\n        @param  producerToken  ERC20    Producer token contract\n        @return                ERC20[]  Reward token contracts\n    */\n    function getRewardTokens(ERC20 producerToken)\n        external\n        view\n        returns (ERC20[] memory)\n    {\n        return producerTokens[producerToken].rewardTokens;\n    }\n\n    /**\n        @notice Get the reward recipient for a user by producer and reward token\n        @param  user           address  User\n        @param  producerToken  ERC20    Producer token contract\n        @param  rewardToken    ERC20    Reward token contract\n        @return                address  Reward recipient\n    */\n    function getRewardRecipient(\n        address user,\n        ERC20 producerToken,\n        ERC20 rewardToken\n    ) external view returns (address) {\n        return\n            producerTokens[producerToken].rewardRecipients[user][rewardToken];\n    }\n\n    /**\n        @notice Update global rewards accrual state\n        @param  producerToken  ERC20  Rewards-producing token\n    */\n    function globalAccrue(ERC20 producerToken) external {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n\n        _globalAccrue(producerTokens[producerToken].globalState, producerToken);\n    }\n\n    /**\n        @notice Update user rewards accrual state\n        @param  producerToken  ERC20    Rewards-producing token\n        @param  user           address  User address\n    */\n    function userAccrue(ERC20 producerToken, address user) public {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (user == address(0)) revert ZeroAddress();\n\n        UserState storage u = producerTokens[producerToken].userStates[user];\n        uint256 balance = producerToken.balanceOf(user);\n\n        // Calculate the amount of rewards accrued by the user up to this call\n        uint256 rewards = u.rewards +\n            u.lastBalance *\n            (block.timestamp - u.lastUpdate);\n\n        u.lastUpdate = block.timestamp.safeCastTo32();\n        u.lastBalance = balance.safeCastTo224();\n        u.rewards = rewards;\n\n        emit UserAccrue(producerToken, user, block.timestamp, balance, rewards);\n    }\n\n    /**\n        @notice Update global accrual state\n        @param  globalState    GlobalState  Global state of the producer token\n        @param  producerToken  ERC20        Producer token contract\n    */\n    function _globalAccrue(GlobalState storage globalState, ERC20 producerToken)\n        internal\n    {\n        uint256 totalSupply = producerToken.totalSupply();\n        uint256 lastUpdate = globalState.lastUpdate;\n        uint256 lastSupply = globalState.lastSupply;\n\n        // Calculate rewards, the product of seconds elapsed and last supply\n        // Only calculate and update states when needed\n        if (block.timestamp != lastUpdate || totalSupply != lastSupply) {\n            uint256 rewards = globalState.rewards +\n                (block.timestamp - lastUpdate) *\n                lastSupply;\n\n            globalState.lastUpdate = block.timestamp.safeCastTo32();\n            globalState.lastSupply = totalSupply.safeCastTo224();\n            globalState.rewards = rewards;\n\n            emit GlobalAccrue(\n                producerToken,\n                block.timestamp,\n                totalSupply,\n                rewards\n            );\n        }\n    }\n\n    /**\n        @notice Harvest rewards\n        @return _producerTokens  ERC20[]  Producer token contracts\n        @return rewardTokens     ERC20[]  Reward token contracts\n        @return rewardAmounts    ERC20[]  Reward token amounts\n    */\n    function harvest()\n        public\n        returns (\n            ERC20[] memory _producerTokens,\n            ERC20[] memory rewardTokens,\n            uint256[] memory rewardAmounts\n        )\n    {\n        (_producerTokens, rewardTokens, rewardAmounts) = producer\n            .claimRewards();\n        uint256 pLen = _producerTokens.length;\n\n        // Iterate over the producer tokens and update reward state\n        for (uint256 i; i < pLen; ++i) {\n            ERC20 p = _producerTokens[i];\n            uint256 r = rewardAmounts[i];\n\n            // Update global reward accrual state and associate with the update of reward state\n            ProducerToken storage producerState = producerTokens[p];\n\n            _globalAccrue(producerState.globalState, p);\n\n            if (r != 0) {\n                producerState.rewardStates[rewardTokens[i]] += r;\n            }\n        }\n\n        emit Harvest(_producerTokens, rewardTokens, rewardAmounts);\n    }\n\n    /**\n        @notice Claim rewards\n        @param  producerToken  ERC20    Producer token contract\n        @param  user           address  User\n    */\n    function claim(ERC20 producerToken, address user) external {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (user == address(0)) revert ZeroAddress();\n\n        harvest();\n        userAccrue(producerToken, user);\n\n        ProducerToken storage p = producerTokens[producerToken];\n        uint256 globalRewards = p.globalState.rewards;\n        uint256 userRewards = p.userStates[user].rewards;\n\n        // Claim should be skipped and not reverted on zero global/user reward\n        if (globalRewards != 0 && userRewards != 0) {\n            ERC20[] memory rewardTokens = p.rewardTokens;\n            uint256 rLen = rewardTokens.length;\n\n            // Update global and user reward states to reflect the claim\n            p.globalState.rewards = globalRewards - userRewards;\n            p.userStates[user].rewards = 0;\n\n            emit Claim(producerToken, user);\n\n            // Transfer the proportionate reward token amounts to the recipient\n            for (uint256 i; i < rLen; ++i) {\n                ERC20 rewardToken = rewardTokens[i];\n                address rewardRecipient = p.rewardRecipients[user][rewardToken];\n                address recipient = rewardRecipient != address(0)\n                    ? rewardRecipient\n                    : user;\n                uint256 rewardState = p.rewardStates[rewardToken];\n                uint256 amount = (rewardState * userRewards) / globalRewards;\n\n                if (amount != 0) {\n                    // Update reward state (i.e. amount) to reflect reward tokens transferred out\n                    p.rewardStates[rewardToken] = rewardState - amount;\n\n                    producer.claimUserReward(\n                        address(rewardToken),\n                        amount,\n                        recipient\n                    );\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    ⚠️ NOTABLE PRIVILEGED METHODS ⚠️\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Privileged method for setting the reward recipient of a contract\n        @notice This should ONLY be used to forward rewards for Pirex-GMX LP contracts\n        @notice In production, we will have a 2nd multisig which reduces risk of abuse\n        @param  lpContract     address  Pirex-GMX LP contract\n        @param  producerToken  ERC20    Producer token contract\n        @param  rewardToken    ERC20    Reward token contract\n        @param  recipient      address  Rewards recipient\n    */\n    function setRewardRecipientPrivileged(\n        address lpContract,\n        ERC20 producerToken,\n        ERC20 rewardToken,\n        address recipient\n    ) external onlyOwner {\n        if (lpContract.code.length == 0) revert NotContract();\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (address(rewardToken) == address(0)) revert ZeroAddress();\n        if (recipient == address(0)) revert ZeroAddress();\n\n        producerTokens[producerToken].rewardRecipients[lpContract][\n            rewardToken\n        ] = recipient;\n\n        emit SetRewardRecipientPrivileged(\n            lpContract,\n            producerToken,\n            rewardToken,\n            recipient\n        );\n    }\n\n    /**\n        @notice Privileged method for unsetting the reward recipient of a contract\n        @param  lpContract     address  Pirex-GMX LP contract\n        @param  producerToken  ERC20    Producer token contract\n        @param  rewardToken    ERC20    Reward token contract\n    */\n    function unsetRewardRecipientPrivileged(\n        address lpContract,\n        ERC20 producerToken,\n        ERC20 rewardToken\n    ) external onlyOwner {\n        if (lpCon"
    }
  ]
}