{
  "Title": "[H-06] `EUSD.mint` function wrong assumption of cases when calculated sharesAmount = 0",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/token/EUSD.sol#L299-#L306> <br><https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/token/EUSD.sol#L414-#L418>\n\n### Impact\n\n*   `Mint` function might calculate the `sharesAmount` incorrectly.\n*   User can profit by manipulating the protocol to enjoy 1-1 share-eUSD ratio even when share prices is super high.\n\n### Proof of Concept\n\nCurrently, the function `EUSD.mint` calls function `EUSD.getSharesByMintedEUSD` to calculate the shares corresponding to the input eUSD amount:\n\n```solidity\nfunction mint(address _recipient, uint256 _mintAmount) external onlyMintVault MintPaused returns (uint256 newTotalShares) {\n        require(_recipient != address(0), \"MINT_TO_THE_ZERO_ADDRESS\");\n\n        uint256 sharesAmount = getSharesByMintedEUSD(_mintAmount);\n        if (sharesAmount == 0) {\n            //EUSD totalSupply is 0: assume that shares correspond to EUSD 1-to-1\n            sharesAmount = _mintAmount;\n        }\n        ...\n}\nfunction getSharesByMintedEUSD(uint256 _EUSDAmount) public view returns (uint256) {\n        uint256 totalMintedEUSD = _totalSupply;\n        if (totalMintedEUSD == 0) {\n            return 0;\n        } else {\n            return _EUSDAmount.mul(_totalShares).div(totalMintedEUSD);\n        }\n}\n```\n\nAs you can see in the comment after `sharesAmount` is checked, `//EUSD totalSupply is 0: assume that shares correspond to EUSD 1-to-1`. The code assumes that if `sharesAmount = 0`, then `totalSupply` must be 0 and the minted share should equal to input eUSD. However, that's not always the case.\n\nVariable `sharesAmount` could be 0 if `totalShares *_EUSDAmount` < `totalMintedEUSD` because this is integer division. If that happens, the user will profit by calling mint with a small EUSD amount and enjoys 1-1 minting proportion (1 share for each eUSD). The reason this can happen is because `EUSD` support `burnShares` feature, which remove the share of a users but keep the `totalSupply` value.\n\nFor example:\n1.  At the start, Bob is minted 1e18 eUSD, they receive 1e18 shares.\n2.  Bob call `burnShares` by `1e18-1`. After this, contract contains 1e18 eUSD and 1 share, which mean 1 share now worth 1e18 eUSD.\n3.  If Alice calls `mint` with 1e18 eUSD, then they receive 1 share (since 1 share worth 1e18 eUSD).\n4.  However, if they then call `mint` with 1e17 eUSD, they will receive 1e17 shares although 1 share is now worth 1e18 eUSD. This happens because `1e17 * (totalShares = 2) / (totalMintedEUSD = 2e18)` = 0.\n\nBelow is POC for the above example. I use foundry to run tests; create a folder named `test` and save this to a file named `eUSD.t.sol`, then run it using command:\n\n`forge test --match-path test/eUSD.t.sol -vvvv`\n\n```solidity\npragma solidity ^0.8.17;\n\nimport {Test, console2} from \"forge-std/Test.sol\";\nimport {Iconfigurator} from \"contracts/lybra/interfaces/Iconfigurator.sol\";\nimport {Configurator} from \"contracts/lybra/configuration/LybraConfigurator.sol\";\nimport {GovernanceTimelock} from \"contracts/lybra/governance/GovernanceTimeLock.sol\";\nimport {mockCurve} from \"contracts/mocks/mockCurve.sol\";\nimport {EUSD} from \"contracts/lybra/token/EUSD.sol\";\n\ncontract TestEUSD is Test {\n    address admin = address(0x1111);\n    address user1 = address(0x1);\n    address user2 = address(0x2);\n    address pool = address(0x3);\n\n    Configurator configurator;\n    GovernanceTimelock governanceTimeLock;\n    mockCurve curve;\n    EUSD eUSD;\n\n\n\n    function setUp() public{\n        // deploy curve\n        curve = new mockCurve();\n        // deploy governance time lock\n        address[] memory proposers = new address[](1);\n        proposers[0] = admin;\n\n        address[] memory executors = new address[](1);\n        executors[0] = admin;\n\n        governanceTimeLock = new GovernanceTimelock(1, proposers, executors, admin);\n        configurator = new Configurator(address(governanceTimeLock), address(curve));\n\n        eUSD = new EUSD(address(configurator));\n        // set mintVault to this address\n        vm.prank(admin);\n        configurator.setMintVault(address(this), true);\n    }\n\n    function testRoundingNotCheck() public {\n        // Mint some tokens for user1\n        eUSD.mint(user1, 1e18);\n\n        assertEq(eUSD.balanceOf(user1), 1e18);\n        assertEq(eUSD.totalSupply(), 1e18);\n\n        //\n        eUSD.burnShares(user1, 1e18-1);\n\n        assertEq(eUSD.getTotalShares(),1);\n        assertEq(eUSD.sharesOf(user1), 1);\n        assertEq(eUSD.totalSupply(), 1e18);\n\n        // After this, 1 shares worth 1e18 eUSDs\n        // If mintAmount = 1e18 -> receive  1 shares\n\n        eUSD.mint(user2, 1e18);\n        assertEq(eUSD.getTotalShares(), 2);\n        assertEq(eUSD.sharesOf(user2), 1);\n        assertEq(eUSD.totalSupply(), 2e18);\n\n        // However, if mintAmount = 1e17 -> receive 1e17 shares\n\n        eUSD.mint(user2, 1e17);\n\n        assertEq(eUSD.sharesOf(user2), 1 + 1e17);\n\n\n    }\n\n}\n```\n\n### Tools Used\n\nManual Review\n\n### Recommended Mitigation Steps\n\nI recommend checking again in `EUSD.mint` function if `sharesAmount` is 0 and `totalSupply` is not 0, then exit the function without minting anything.\n\n**[LybraFinance confirmed](https://github.com/code-423n4/2023-06-lybra-findings/issues/106#issuecomment-1635617210)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-06-lybra",
  "Code": [
    {
      "filename": "contracts/lybra/token/EUSD.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"../interfaces/Iconfigurator.sol\";\n\n/**\n * @title Interest-bearing ERC20-like token for Lybra protocol.\n *\n * EUSD balances are dynamic and represent the holder's share in the total amount\n * of Ether controlled by the protocol. Account shares aren't normalized, so the\n * contract also stores the sum of all shares to calculate each account's token balance\n * which equals to:\n *\n *   shares[account] * totalSupply / _totalShares\n *\n * For example, assume that we have:\n *\n *   _getTotalMintedEUSD() -> 1000 EUSD\n *   sharesOf(user1) -> 100\n *   sharesOf(user2) -> 400\n *\n * Therefore:\n *\n *   balanceOf(user1) -> 2 tokens which corresponds 200 EUSD\n *   balanceOf(user2) -> 8 tokens which corresponds 800 EUSD\n *\n * Since balances of all token holders change when the amount of total shares\n * changes, this token cannot fully implement ERC20 standard: it only emits `Transfer`\n * events upon explicit transfer between holders. In contrast, when total amount of\n * pooled Ether increases, no `Transfer` events are generated: doing so would require\n * emitting an event for each token holder and thus running an unbounded loop.\n */\ncontract EUSD is IERC20, Context {\n    using SafeMath for uint256;\n    Iconfigurator public immutable configurator;\n    uint256 private _totalShares;\n    uint256 private _totalSupply;\n\n    /**\n     * @dev EUSD balances are dynamic and are calculated based on the accounts' shares\n     * and the total supply by the protocol. Account shares aren't\n     * normalized, so the contract also stores the sum of all shares to calculate\n     * each account's token balance which equals to:\n     *\n     *   shares[account] * _getTotalMintedEUSD() / _getTotalShares()\n     */\n    mapping(address => uint256) private shares;\n\n    /**\n     * @dev Allowances are nominated in tokens, not token shares.\n     */\n    mapping(address => mapping(address => uint256)) private allowances;\n\n    /**\n     * @notice An executed shares transfer from `sender` to `recipient`.\n     *\n     * @dev emitted in pair with an ERC20-defined `Transfer` event.\n     */\n    event TransferShares(address indexed from, address indexed to, uint256 sharesValue);\n\n    /**\n     * @notice An executed `burnShares` request\n     *\n     * @dev Reports simultaneously burnt shares amount\n     * and corresponding EUSD amount.\n     * The EUSD amount is calculated twice: before and after the burning incurred rebase.\n     *\n     * @param account holder of the burnt shares\n     * @param preRebaseTokenAmount amount of EUSD the burnt shares corresponded to before the burn\n     * @param postRebaseTokenAmount amount of EUSD the burnt shares corresponded to after the burn\n     * @param sharesAmount amount of burnt shares\n     */\n    event SharesBurnt(address indexed account, uint256 preRebaseTokenAmount, uint256 postRebaseTokenAmount, uint256 sharesAmount);\n\n    modifier onlyMintVault() {\n        require(configurator.mintVault(msg.sender), \"RCP\");\n        _;\n    }\n    modifier MintPaused() {\n        require(!configurator.vaultMintPaused(msg.sender), \"MPP\");\n        _;\n    }\n    modifier BurnPaused() {\n        require(!configurator.vaultBurnPaused(msg.sender), \"BPP\");\n        _;\n    }\n\n    constructor(address _config) {\n        configurator = Iconfigurator(_config);\n    }\n\n    /**\n     * @return the name of the token.\n     */\n    function name() public pure returns (string memory) {\n        return \"eUSD\";\n    }\n\n    /**\n     * @return the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public pure returns (string memory) {\n        return \"eUSD\";\n    }\n\n    /**\n     * @return the number of decimals for getting user representation of a token amount.\n     */\n    function decimals() public pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @return the amount of EUSD in existence.\n     *\n     * @dev Always equals to `_getTotalMintedEUSD()` since token amount\n     * is pegged to the total amount of EUSD controlled by the protocol.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @return the amount of tokens owned by the `_account`.\n     *\n     * @dev Balances are dynamic and equal the `_account`'s share in the amount of the\n     * total Ether controlled by the protocol. See `sharesOf`.\n     */\n    function balanceOf(address _account) public view returns (uint256) {\n        return getMintedEUSDByShares(_sharesOf(_account));\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from the caller's account to the `_recipient` account.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transfer(address _recipient, uint256 _amount) public returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @return the remaining number of tokens that `_spender` is allowed to spend\n     * on behalf of `_owner` through `transferFrom`. This is zero by default.\n     *\n     * @dev This value changes when `approve` or `transferFrom` is called.\n     */\n    function allowance(address _owner, address _spender) public view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller's tokens.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function approve(address _spender, uint256 _amount) public returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n     * allowance mechanism. `_amount` is then deducted from the caller's\n     * allowance.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have a balance of at least `_amount`.\n     * - the caller must have allowance for `_sender`'s tokens of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transferFrom(address from, address to, uint256 amount) public returns (bool) {\n        address spender = _msgSender();\n        if (!configurator.mintVault(spender)) {\n            _spendAllowance(from, spender, amount);\n        }\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol#L42\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the the zero address.\n     * - the contract must not be paused.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) public returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, _spender, allowances[owner][_spender].add(_addedValue));\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol#L42\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n     * - the contract must not be paused.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     *\n     * @dev The sum of all accounts' shares can be an arbitrary number, therefore\n     * it is necessary to store it in order to calculate each account's relative share.\n     */\n    function getTotalShares() public view returns (uint256) {\n        return _totalShares;\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function sharesOf(address _account) public view returns (uint256) {\n        return _sharesOf(_account);\n    }\n\n    /**\n     * @return the amount of shares that corresponds to `_EUSDAmount` protocol-supplied EUSD.\n     */\n    function getSharesByMintedEUSD(uint256 _EUSDAmount) public view returns (uint256) {\n        uint256 totalMintedEUSD = _totalSupply;\n        if (totalMintedEUSD == 0) {\n            return 0;\n        } else {\n            return _EUSDAmount.mul(_totalShares).div(totalMintedEUSD);\n        }\n    }\n\n    /**\n     * @return the amount of EUSD that corresponds to `_sharesAmount` token shares.\n     */\n    function getMintedEUSDByShares(uint256 _sharesAmount) public view returns (uint256) {\n        if (_totalShares == 0) {\n            return 0;\n        } else {\n            return _sharesAmount.mul(_totalSupply).div(_totalShares);\n        }\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the caller's account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferShares(address _recipient, uint256 _sharesAmount) public returns (uint256) {\n        address owner = _msgSender();\n        _transferShares(owner, _recipient, _sharesAmount);\n        emit TransferShares(owner, _recipient, _sharesAmount);\n        uint256 tokensAmount = getMintedEUSDByShares(_sharesAmount);\n        emit Transfer(owner, _recipient, tokensAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     */\n    function _transfer(address _sender, address _recipient, uint256 _amount) internal {\n        uint256 _sharesToTransfer = getSharesByMintedEUSD(_amount);\n        _transferShares(_sender, _recipient, _sharesToTransfer);\n        emit Transfer(_sender, _recipient, _amount);\n        emit TransferShares(_sender, _recipient, _sharesToTransfer);\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n     *\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `_owner` cannot be the zero address.\n     * - `_spender` cannot be the zero address.\n     * - the contract must not be paused.\n     */\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0), \"APPROVE_FROM_ZERO_ADDRESS\");\n        require(_spender != address(0), \"APPROVE_TO_ZERO_ADDRESS\");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function _sharesOf(address _account) internal view returns (uint256) {\n        return shares[_account];\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n     *\n     * Requirements:\n     *\n     * - `_sender` cannot be the zero address.\n     * - `_recipient` cannot be the zero address.\n     * - `_sender` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal {\n        require(_sender != address(0), \"TRANSFER_FROM_THE_ZERO_ADDRESS\");\n        require(_recipient != address(0), \"TRANSFER_TO_THE_ZERO_ADDRESS\");\n\n        uint256 currentSenderShares = shares[_sender];\n        require(_sharesAmount <= currentSenderShares, \"TRANSFER_AMOUNT_EXCEEDS_BALANCE\");\n\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n    }\n\n    /**\n     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n     * @dev This operation also increases the total supply of tokens.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the contract must not be paused.\n     */\n    function mint(address _recipient, uint256 _mintAmount) external onlyMintVault MintPaused returns (uint256 newTotalShares) {\n        require(_recipient != address(0), \"MINT_TO_THE_ZERO_ADDRESS\");\n\n        uint256 sharesAmount = getSharesByMintedEUSD(_mintAmount);\n        if (sharesAmount == 0) {\n            //EUSD totalSupply is 0: assume that shares correspond to EUSD 1-to-1\n            sharesAmount = _mintAmount;\n        }\n\n        newTotalShares = _totalShares.add(sharesAmount);\n        _totalShares = newTotalShares;\n\n        shares[_recipient] = shares[_recipient].add(sharesAmount);\n\n        _totalSupply += _mintAmount;\n\n        emit Transfer(address(0), _recipient, _mintAmount);\n    }\n\n    /**\n     * @notice Destroys `sharesAmount` shares from `_account`'s holdings, decreasing the total amount of shares.\n     * @dev This operation also decrease the total supply of tokens.\n     *\n     * Requirements:\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must hold at least `sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function burn(address _account, uint256 _burnAmount) external onlyMintVault BurnPaused returns (uint256 newTotalShares) {\n        require(_account != address(0), \"BURN_FROM_THE_ZERO_ADDRESS\");\n        uint256 sharesAmount = getSharesByMintedEUSD(_burnAmount);\n        newTotalShares = _onlyBurnShares(_account, sharesAmount);\n        _totalSupply -= _burnAmount;\n\n        emit Transfer(_account, address(0), _burnAmount);\n    }\n\n    /**\n     * @notice Destroys `sharesAmount` shares from `_account`'s holdings, decreasing the total amount of shares.\n     * @dev This doesn't decrease the token total supply.\n     *\n     * Requirements:\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must hold at least `sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function burnShares(address _account, uint256 _sharesAmount) external onlyMintVault BurnPaused returns (uint256 newTotalShares) {\n        require(_account != address(0), \"BURN_FROM_THE_ZERO_ADDRESS\");\n        newTotalShares = _onlyBurnShares(_account, _sharesAmount);\n    }\n\n    function _onlyBurnShares(address _account, uint256 _sharesAmount) private returns (uint256 newTotalShares) {\n        uint256 accountShares = shares[_account];\n        require(_sharesAmount <= accountShares, \"BURN_AMOUNT_EXCEEDS_BALANCE\");\n\n        uint256 preRebaseTokenAmount = getMintedEUSDByShares(_sharesAmount);\n\n        newTotalShares = _totalShares.sub(_sharesAmount);\n        _totalShares = newTotalShares;\n\n        shares[_account] = accountShares.sub(_sharesAmount);\n\n        uint256 postRebaseTokenAmount = getMintedEUSDByShares(_sharesAmount);\n\n        emit SharesBurnt(_account, preRebaseTokenAmount, postRebaseTokenAmount, _sharesAmount);\n\n        // Notice: we're not emitting a Transfer event to the zero address here since shares burn\n        // works by redistributing the amount of tokens corresponding to the burned shares between\n        // all other token holders. The total supply of the token doesn't change as the result.\n        // This is equivalent to performing a send from `address` to each other token holder address,\n        // but we cannot reflect this as it would require sending an unbounded number of events.\n\n        // We're emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\n    }\n}"
    }
  ]
}