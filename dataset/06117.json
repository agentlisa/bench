{
  "Title": "[G-06] Cache External Calls in Loops",
  "Content": "- Severity: Gas Optimization\n- Confidence: High\n- Total Gas Saved: 200\n\n### Description\nThis detector identifies instances of repeated external calls within loops. By moving the first external call outside of the loop and using low-level calls inside the loop, it is possible to save gas by avoiding repeated EXTCODESIZE opcodes, as there is no need to check again if the contract exists. \n\nNote: This detector only triggers if the function call does not return any value.\n\nPrior to 0.8.10, the compiler inserted extra code, including EXTCODESIZE (100 gas), to check for contract existence for external function calls. In more recent Solidity versions the compiler will not insert these checks if the external call has a return value. Similar behavior can be achieved in earlier versions by using low-level calls, since low-level calls never check for contract existence. \n\n<details>\n\n<summary>\nThere are 2 instances of this issue:\n\n</summary>\n\n###\n- File: solidity/contracts/core/Vault.sol\n```\n \nLine: 193          _virtualReward.getReward()\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/Vault.sol#L193](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/Vault.sol#L193)\n\n- File: solidity/contracts/governance/GovernorCharlie.sol\n```\n \nLine: 314          this.executeTransaction{value: _proposal.values[_i]}(\n        _proposal.targets[_i], _proposal.values[_i], _proposal.signatures[_i], _proposal.calldatas[_i], _proposal.eta\n      )\n```\n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L314-L316](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L314-L316)\n\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-07-amphora",
  "Code": [
    {
      "filename": "core/solidity/contracts/core/Vault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {IUSDA} from '@interfaces/core/IUSDA.sol';\nimport {IVault} from '@interfaces/core/IVault.sol';\nimport {IVaultController} from '@interfaces/core/IVaultController.sol';\nimport {IAMPHClaimer} from '@interfaces/core/IAMPHClaimer.sol';\nimport {IBooster} from '@interfaces/utils/IBooster.sol';\nimport {IBaseRewardPool} from '@interfaces/utils/IBaseRewardPool.sol';\nimport {IVirtualBalanceRewardPool} from '@interfaces/utils/IVirtualBalanceRewardPool.sol';\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {Context} from '@openzeppelin/contracts/utils/Context.sol';\nimport {SafeERC20Upgradeable} from '@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol';\nimport {IERC20Upgradeable} from '@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol';\nimport {ICVX} from '@interfaces/utils/ICVX.sol';\n\n/// @notice Vault contract, our implementation of maker-vault like vault\n/// @dev Major differences:\n/// 1. multi-collateral\n/// 2. generate interest in USDA\ncontract Vault is IVault, Context {\n  using SafeERC20Upgradeable for IERC20;\n\n  /// @dev The CVX token\n  ICVX public immutable CVX;\n\n  /// @dev The CRV token\n  IERC20 public immutable CRV;\n\n  /// @dev The vault controller\n  IVaultController public immutable CONTROLLER;\n\n  /// @dev Metadata of vault, aka the id & the minter's address\n  VaultInfo public vaultInfo;\n\n  /// @dev This is the unscaled liability of the vault.\n  /// The number is meaningless on its own, and must be combined with the factor taken from\n  /// the vaultController in order to find the true liabilitiy\n  uint256 public baseLiability;\n\n  /// @dev Keeps track of the accounting of the collateral deposited\n  mapping(address => uint256) public balances;\n\n  /// @dev Keeps track of the tokens that are staked on convex\n  mapping(address => bool) public isTokenStaked;\n\n  /// @notice Checks if _msgSender is the controller of the vault\n  modifier onlyVaultController() {\n    if (_msgSender() != address(CONTROLLER)) revert Vault_NotVaultController();\n    _;\n  }\n\n  /// @notice Checks if _msgSender is the minter of the vault\n  modifier onlyMinter() {\n    if (_msgSender() != vaultInfo.minter) revert Vault_NotMinter();\n    _;\n  }\n\n  /// @dev Must be called by VaultController, else it will not be registered as a vault in system\n  /// @param _id Unique id of the vault, ever increasing and tracked by VaultController\n  /// @param _minter Address of the person who created this vault\n  /// @param _controllerAddress Address of the VaultController\n  /// @param _cvx Address of CVX token\n  /// @param _crv Address of CRV token\n  constructor(uint96 _id, address _minter, address _controllerAddress, IERC20 _cvx, IERC20 _crv) {\n    vaultInfo = VaultInfo(_id, _minter);\n    CONTROLLER = IVaultController(_controllerAddress);\n    CVX = ICVX(address(_cvx));\n    CRV = _crv;\n  }\n\n  /// @notice Returns the minter of the vault\n  /// @return _minter The address of minter\n  function minter() external view override returns (address _minter) {\n    _minter = vaultInfo.minter;\n  }\n\n  /// @notice Returns the id of the vault\n  /// @return _id The id of the vault\n  function id() external view override returns (uint96 _id) {\n    _id = vaultInfo.id;\n  }\n\n  /// @notice Used to deposit a token to the vault\n  /// @dev    Deposits and stakes on convex if token is of type CurveLPStakedOnConvex\n  /// @param _token The address of the token to deposit\n  /// @param _amount The amount of the token to deposit\n  function depositERC20(address _token, uint256 _amount) external override onlyMinter {\n    if (CONTROLLER.tokenId(_token) == 0) revert Vault_TokenNotRegistered();\n    if (_amount == 0) revert Vault_AmountZero();\n    SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(_token), _msgSender(), address(this), _amount);\n    if (CONTROLLER.tokenCollateralType(_token) == IVaultController.CollateralType.CurveLPStakedOnConvex) {\n      uint256 _poolId = CONTROLLER.tokenPoolId(_token);\n      /// If it's type CurveLPStakedOnConvex then pool id can't be 0\n      IBooster _booster = CONTROLLER.BOOSTER();\n      if (isTokenStaked[_token]) {\n        /// In this case the user's balance is already staked so we only stake the newly deposited amount\n        _depositAndStakeOnConvex(_token, _booster, _amount, _poolId);\n      } else {\n        /// In this case the user's balance isn't staked so we stake the amount + his balance for the specific tokenv\n        isTokenStaked[_token] = true;\n        _depositAndStakeOnConvex(_token, _booster, balances[_token] + _amount, _poolId);\n      }\n    }\n    balances[_token] += _amount;\n    CONTROLLER.modifyTotalDeposited(vaultInfo.id, _amount, _token, true);\n    emit Deposit(_token, _amount);\n  }\n\n  /// @notice Withdraws an erc20 token from the vault\n  /// @dev    This can only be called by the minter\n  ///         The withdraw will be denied if ones vault would become insolvent\n  ///         If the withdraw token is of CurveLPStakedOnConvex then unstake and withdraw directly to user\n  /// @param _tokenAddress The address of erc20 token\n  /// @param _amount The amount of erc20 token to withdraw\n  function withdrawERC20(address _tokenAddress, uint256 _amount) external override onlyMinter {\n    if (CONTROLLER.tokenId(_tokenAddress) == 0) revert Vault_TokenNotRegistered();\n    if (isTokenStaked[_tokenAddress]) {\n      if (!CONTROLLER.tokenCrvRewardsContract(_tokenAddress).withdrawAndUnwrap(_amount, false)) {\n        revert Vault_WithdrawAndUnstakeOnConvexFailed();\n      }\n    }\n    // reduce balance\n    balances[_tokenAddress] -= _amount;\n    // check if the account is solvent\n    if (!CONTROLLER.checkVault(vaultInfo.id)) revert Vault_OverWithdrawal();\n    // transfer the token to the owner\n    SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(_tokenAddress), _msgSender(), _amount);\n    // modify total deposited\n    CONTROLLER.modifyTotalDeposited(vaultInfo.id, _amount, _tokenAddress, false);\n    emit Withdraw(_tokenAddress, _amount);\n  }\n\n  /// @notice Let's the user manually stake their crvLP\n  /// @dev    This can be called if the convex pool didn't exist when the token was registered\n  ///         and was later updated\n  /// @param _tokenAddress The address of erc20 crvLP token\n  function stakeCrvLPCollateral(address _tokenAddress) external override onlyMinter {\n    uint256 _poolId = CONTROLLER.tokenPoolId(_tokenAddress);\n    if (_poolId == 0) revert Vault_TokenCanNotBeStaked();\n    if (balances[_tokenAddress] == 0) revert Vault_TokenZeroBalance();\n    if (isTokenStaked[_tokenAddress]) revert Vault_TokenAlreadyStaked();\n\n    isTokenStaked[_tokenAddress] = true;\n\n    IBooster _booster = CONTROLLER.BOOSTER();\n    _depositAndStakeOnConvex(_tokenAddress, _booster, balances[_tokenAddress], _poolId);\n\n    emit Staked(_tokenAddress, balances[_tokenAddress]);\n  }\n\n  /// @notice Returns true when user can manually stake their token balance\n  /// @param _token The address of the token to check\n  /// @return _canStake Returns true if the token can be staked manually\n  function canStake(address _token) external view override returns (bool _canStake) {\n    uint256 _poolId = CONTROLLER.tokenPoolId(_token);\n    if (_poolId != 0 && balances[_token] != 0 && !isTokenStaked[_token]) _canStake = true;\n  }\n\n  /// @notice Claims available rewards from multiple tokens\n  /// @dev    Transfers a percentage of the crv and cvx rewards to claim AMPH tokens\n  /// @param _tokenAddresses The addresses of the erc20 tokens\n  function claimRewards(address[] memory _tokenAddresses) external override onlyMinter {\n    uint256 _totalCrvReward;\n    uint256 _totalCvxReward;\n\n    IAMPHClaimer _amphClaimer = CONTROLLER.claimerContract();\n    for (uint256 _i; _i < _tokenAddresses.length;) {\n      IVaultController.CollateralInfo memory _collateralInfo = CONTROLLER.tokenCollateralInfo(_tokenAddresses[_i]);\n      if (_collateralInfo.tokenId == 0) revert Vault_TokenNotRegistered();\n      if (_collateralInfo.collateralType != IVaultController.CollateralType.CurveLPStakedOnConvex) {\n        revert Vault_TokenNotCurveLP();\n      }\n\n      IBaseRewardPool _rewardsContract = _collateralInfo.crvRewardsContract;\n      uint256 _crvReward = _rewardsContract.earned(address(this));\n\n      if (_crvReward != 0) {\n        // Claim the CRV reward\n        _totalCrvReward += _crvReward;\n        _rewardsContract.getReward(address(this), false);\n        _totalCvxReward += _calculateCVXReward(_crvReward);\n      }\n\n      // Loop and claim all virtual rewards\n      uint256 _extraRewards = _rewardsContract.extraRewardsLength();\n      for (uint256 _j; _j < _extraRewards;) {\n        IVirtualBalanceRewardPool _virtualReward = _rewardsContract.extraRewards(_j);\n        IERC20 _rewardToken = _virtualReward.rewardToken();\n        uint256 _earnedReward = _virtualReward.earned(address(this));\n        if (_earnedReward != 0) {\n          _virtualReward.getReward();\n          _rewardToken.transfer(_msgSender(), _earnedReward);\n          emit ClaimedReward(address(_rewardToken), _earnedReward);\n        }\n        unchecked {\n          ++_j;\n        }\n      }\n      unchecked {\n        ++_i;\n      }\n    }\n\n    if (_totalCrvReward > 0 || _totalCvxReward > 0) {\n      if (address(_amphClaimer) != address(0)) {\n        // Approve amounts for it to be taken\n        (uint256 _takenCVX, uint256 _takenCRV, uint256 _claimableAmph) =\n          _amphClaimer.claimable(address(this), this.id(), _totalCvxReward, _totalCrvReward);\n        if (_claimableAmph != 0) {\n          CRV.approve(address(_amphClaimer), _takenCRV);\n          CVX.approve(address(_amphClaimer), _takenCVX);\n\n          // Claim AMPH tokens depending on how much CRV and CVX was claimed\n          _amphClaimer.claimAmph(this.id(), _totalCvxReward, _totalCrvReward, _msgSender());\n\n          _totalCvxReward -= _takenCVX;\n          _totalCrvReward -= _takenCRV;\n        }\n      }\n\n      if (_totalCvxReward > 0) CVX.transfer(_msgSender(), _totalCvxReward);\n      if (_totalCrvReward > 0) CRV.transfer(_msgSender(), _totalCrvReward);\n\n      emit ClaimedReward(address(CRV), _totalCrvReward);\n      emit ClaimedReward(address(CVX), _totalCvxReward);\n    }\n  }\n\n  /// @notice Returns an array of all the available rewards the user can claim\n  /// @param _tokenAddress The address of the token collateral to check rewards for\n  /// @return _rewards The array of all the available rewards\n  function claimableRewards(address _tokenAddress) external view override returns (Reward[] memory _rewards) {\n    if (CONTROLLER.tokenId(_tokenAddress) == 0) revert Vault_TokenNotRegistered();\n    if (CONTROLLER.tokenCollateralType(_tokenAddress) != IVaultController.CollateralType.CurveLPStakedOnConvex) {\n      revert Vault_TokenNotCurveLP();\n    }\n\n    IBaseRewardPool _rewardsContract = CONTROLLER.tokenCrvRewardsContract(_tokenAddress);\n    IAMPHClaimer _amphClaimer = CONTROLLER.claimerContract();\n\n    uint256 _rewardsAmount = _rewardsContract.extraRewardsLength();\n\n    uint256 _crvReward = _rewardsContract.earned(address(this));\n    uint256 _cvxReward = _calculateCVXReward(_crvReward);\n\n    // +3 for CRV, CVX and AMPH\n    _rewards = new Reward[](_rewardsAmount+3);\n    _rewards[0] = Reward(CRV, _crvReward);\n    _rewards[1] = Reward(CVX, _cvxReward);\n\n    uint256 _i;\n    for (_i; _i < _rewardsAmount;) {\n      IVirtualBalanceRewardPool _virtualReward = _rewardsContract.extraRewards(_i);\n      IERC20 _rewardToken = _virtualReward.rewardToken();\n      uint256 _earnedReward = _virtualReward.earned(address(this));\n      _rewards[_i + 2] = Reward(_rewardToken, _earnedReward);\n\n      unchecked {\n        ++_i;\n      }\n    }\n\n    uint256 _takenCVX;\n    uint256 _takenCRV;\n    uint256 _claimableAmph;\n    // if claimer is not set, nothing will happen (and variables are already in zero)\n    if (address(_amphClaimer) != address(0)) {\n      // claimer is set, proceed\n      (_takenCVX, _takenCRV, _claimableAmph) = _amphClaimer.claimable(address(this), this.id(), _cvxReward, _crvReward);\n      _rewards[_i + 2] = Reward(_amphClaimer.AMPH(), _claimableAmph);\n    }\n\n    _rewards[0].amount = _crvReward - _takenCRV;\n    if (_cvxReward > 0) _rewards[1].amount = _cvxReward - _takenCVX;\n  }\n\n  /// @notice Function used by the VaultController to transfer tokens\n  /// @dev Callable by the VaultController only\n  /// @param _token The token to transfer\n  /// @param _to The address to send the tokens to\n  /// @param _amount The amount of tokens to move\n  function controllerTransfer(address _token, address _to, uint256 _amount) external override onlyVaultController {\n    SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(_token), _to, _amount);\n    balances[_token] -= _amount;\n  }\n\n  /// @notice Function used by the VaultController to withdraw from convex\n  /// @dev Callable by the VaultController only\n  /// @param _rewardPool The pool to withdraw\n  /// @param _amount The amount of tokens to withdraw\n  function controllerWithdrawAndUnwrap(\n    IBaseRewardPool _rewardPool,\n    uint256 _amount\n  ) external override onlyVaultController {\n    if (!_rewardPool.withdrawAndUnwrap(_amount, false)) revert Vault_WithdrawAndUnstakeOnConvexFailed();\n  }\n\n  /// @notice Function used by the VaultController to reduce a vault's liability\n  /// @dev Callable by the VaultController only\n  /// @param _increase True to increase, false to decrease\n  /// @param _baseAmount The change in base liability\n  /// @return _newLiability The new liability\n  function modifyLiability(\n    bool _increase,\n    uint256 _baseAmount\n  ) external override onlyVaultController returns (uint256 _newLiability) {\n    if (_increase) {\n      baseLiability += _baseAmount;\n    } else {\n      // require statement only valid for repayment\n      if (baseLiability < _baseAmount) revert Vault_RepayTooMuch();\n      baseLiability -= _baseAmount;\n    }\n    _newLiability = baseLiability;\n  }\n\n  /// @dev Internal function for depositing and staking on convex\n  function _depositAndStakeOnConvex(address _token, IBooster _booster, uint256 _amount, uint256 _poolId) internal {\n    IERC20(_token).approve(address(_booster), _amount);\n    if (!_booster.deposit(_poolId, _amount, true)) revert Vault_DepositAndStakeOnConvexFailed();\n  }\n\n  /// @notice Used to calculate the CVX reward for a given CRV amount\n  /// @dev This is copied from the CVX mint function\n  /// @param _crv The amount of CRV to calculate the CVX reward for\n  /// @return _cvxAmount The amount of CVX to get\n  function _calculateCVXReward(uint256 _crv) internal view returns (uint256 _cvxAmount) {\n    uint256 _supply = CVX.totalSupply();\n    uint256 _totalCliffs = CVX.totalCliffs();\n\n    //use current supply to gauge cliff\n    //this will cause a bit of overflow into the next cliff range\n    //but should be within reasonable levels.\n    //requires a max supply check though\n    uint256 _cliff = _supply / CVX.reductionPerCliff();\n    //mint if below total cliffs\n    if (_cliff < _totalCliffs) {\n      //for reduction% take inverse of current cliff\n      uint256 _reduction = _totalCliffs - _cliff;\n      //reduce\n      _cvxAmount = (_crv * _reduction) / _totalCliffs;\n\n      //supply cap check\n      uint256 _amtTillMax = CVX.maxSupply() - _supply;\n      if (_cvxAmount > _amtTillMax) _cvxAmount = _amtTillMax;\n    }\n  }\n}"
    },
    {
      "filename": "core/solidity/contracts/governance/GovernorCharlie.sol",
      "content": "// solhint-disable max-states-count\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\npragma experimental ABIEncoderV2;\n\nimport {IAMPH} from '@interfaces/governance/IAMPH.sol';\nimport {IGovernorCharlie} from '@interfaces/governance/IGovernorCharlie.sol';\n\nimport {Receipt, ProposalState, Proposal} from '@contracts/utils/GovernanceStructs.sol';\n\ncontract GovernorCharlie is IGovernorCharlie {\n  /// @notice The name of this contract\n  string public constant NAME = 'Amphora Protocol Governor';\n\n  /// @notice The maximum number of actions that can be included in a proposal\n  uint256 public constant PROPOSAL_MAX_OPERATIONS = 10;\n\n  /// @notice The EIP-712 typehash for the contract's domain\n  bytes32 public constant DOMAIN_TYPEHASH =\n    keccak256('EIP712Domain(string name,uint256 chainId,address verifyingContract)');\n\n  /// @notice The EIP-712 typehash for the ballot struct used by the contract\n  bytes32 public constant BALLOT_TYPEHASH = keccak256('Ballot(uint256 proposalId,uint8 support)');\n\n  /// @notice The time for a proposal to be executed after passing\n  uint256 public constant GRACE_PERIOD = 14 days;\n\n  /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n  uint256 public quorumVotes;\n\n  /// @notice The number of votes in support of a proposal required in order for an emergency quorum to be reached and for a vote to succeed\n  uint256 public emergencyQuorumVotes;\n\n  /// @notice The delay before voting on a proposal may take place, once proposed, in blocks\n  uint256 public votingDelay;\n\n  /// @notice The duration of voting on a proposal, in blocks\n  uint256 public votingPeriod;\n\n  /// @notice The number of votes required in order for a voter to become a proposer\n  uint256 public proposalThreshold;\n\n  /// @notice Initial proposal id set at become\n  uint256 public initialProposalId;\n\n  /// @notice The total number of proposals\n  uint256 public proposalCount;\n\n  /// @notice The address of the Amphora Protocol governance token\n  IAMPH public amph;\n\n  /// @notice The official record of all proposals ever proposed\n  mapping(uint256 => Proposal) public proposals;\n\n  /// @notice The latest proposal for each proposer\n  mapping(address => uint256) public latestProposalIds;\n\n  /// @notice The mapping that saves queued transactions\n  mapping(bytes32 => bool) public queuedTransactions;\n\n  /// @notice The proposal holding period\n  uint256 public proposalTimelockDelay;\n\n  /// @notice Stores the expiration of account whitelist status as a timestamp\n  mapping(address => uint256) public whitelistAccountExpirations;\n\n  /// @notice Address which manages whitelisted proposals and whitelist accounts\n  address public whitelistGuardian;\n\n  /// @notice The duration of the voting on a emergency proposal, in blocks\n  uint256 public emergencyVotingPeriod;\n\n  /// @notice The emergency proposal holding period\n  uint256 public emergencyTimelockDelay;\n\n  /// @notice all receipts for proposal\n  mapping(uint256 => mapping(address => Receipt)) public proposalReceipts;\n\n  /// @notice The number of votes to reject an optimistic proposal\n  uint256 public optimisticQuorumVotes;\n\n  /// @notice The delay period before voting begins\n  uint256 public optimisticVotingDelay;\n\n  /// @notice The maximum number of seconds an address can be whitelisted for\n  uint256 public maxWhitelistPeriod;\n\n  constructor(address _amph) {\n    amph = IAMPH(_amph);\n    votingPeriod = 40_320;\n    votingDelay = 13_140;\n    proposalThreshold = 1_000_000_000_000_000_000_000_000;\n    proposalTimelockDelay = 172_800;\n    proposalCount = 0;\n    quorumVotes = 10_000_000_000_000_000_000_000_000;\n    emergencyQuorumVotes = 40_000_000_000_000_000_000_000_000;\n    emergencyVotingPeriod = 6570;\n    emergencyTimelockDelay = 43_200;\n\n    optimisticQuorumVotes = 2_000_000_000_000_000_000_000_000;\n    optimisticVotingDelay = 25_600;\n    maxWhitelistPeriod = 31_536_000;\n  }\n\n  /// @notice any function with this modifier can only be called by governance\n  modifier onlyGov() {\n    if (msg.sender != address(this)) revert GovernorCharlie_NotGovernorCharlie();\n    _;\n  }\n\n  /**\n   * @notice Function used to propose a new proposal. Sender must have delegates above the proposal threshold\n   * @param _targets Target addresses for proposal calls\n   * @param _values Eth values for proposal calls\n   * @param _signatures Function signatures for proposal calls\n   * @param _calldatas Calldatas for proposal calls\n   * @param _description String description of the proposal\n   * @return _proposalId Proposal id of new proposal\n   */\n  function propose(\n    address[] memory _targets,\n    uint256[] memory _values,\n    string[] memory _signatures,\n    bytes[] memory _calldatas,\n    string memory _description\n  ) public override returns (uint256 _proposalId) {\n    _proposalId = _propose(_targets, _values, _signatures, _calldatas, _description, false);\n  }\n\n  /**\n   * @notice Function used to propose a new emergency proposal. Sender must have delegates above the proposal threshold\n   * @param _targets Target addresses for proposal calls\n   * @param _values Eth values for proposal calls\n   * @param _signatures Function signatures for proposal calls\n   * @param _calldatas Calldatas for proposal calls\n   * @param _description String description of the proposal\n   * @return _proposalId Proposal id of new proposal\n   */\n  function proposeEmergency(\n    address[] memory _targets,\n    uint256[] memory _values,\n    string[] memory _signatures,\n    bytes[] memory _calldatas,\n    string memory _description\n  ) public override returns (uint256 _proposalId) {\n    _proposalId = _propose(_targets, _values, _signatures, _calldatas, _description, true);\n  }\n\n  /**\n   * @notice Function used to propose a new proposal. Sender must have delegates above the proposal threshold\n   * @param _targets Target addresses for proposal calls\n   * @param _values Eth values for proposal calls\n   * @param _signatures Function signatures for proposal calls\n   * @param _calldatas Calldatas for proposal calls\n   * @param _description String description of the proposal\n   * @param _emergency Bool to determine if proposal an emergency proposal\n   * @return _proposalId Proposal id of new proposal\n   */\n  function _propose(\n    address[] memory _targets,\n    uint256[] memory _values,\n    string[] memory _signatures,\n    bytes[] memory _calldatas,\n    string memory _description,\n    bool _emergency\n  ) internal returns (uint256 _proposalId) {\n    // Reject proposals before initiating as Governor\n    if (quorumVotes == 0) revert GovernorCharlie_NotActive();\n    // Allow addresses above proposal threshold and whitelisted addresses to propose\n    if (amph.getPriorVotes(msg.sender, (block.number - 1)) < proposalThreshold && !isWhitelisted(msg.sender)) {\n      revert GovernorCharlie_VotesBelowThreshold();\n    }\n    if (\n      _targets.length != _values.length || _targets.length != _signatures.length || _targets.length != _calldatas.length\n    ) revert GovernorCharlie_ArityMismatch();\n    if (_targets.length == 0) revert GovernorCharlie_NoActions();\n    if (_targets.length > PROPOSAL_MAX_OPERATIONS) revert GovernorCharlie_TooManyActions();\n\n    uint256 _latestProposalId = latestProposalIds[msg.sender];\n    if (_latestProposalId != 0) {\n      ProposalState _proposersLatestProposalState = state(_latestProposalId);\n      if (_proposersLatestProposalState == ProposalState.Active) revert GovernorCharlie_MultipleActiveProposals();\n      if (_proposersLatestProposalState == ProposalState.Pending) revert GovernorCharlie_MultiplePendingProposals();\n    }\n\n    proposalCount++;\n    Proposal memory _newProposal = Proposal({\n      id: proposalCount,\n      proposer: msg.sender,\n      eta: 0,\n      targets: _targets,\n      values: _values,\n      signatures: _signatures,\n      calldatas: _calldatas,\n      startBlock: block.number + votingDelay,\n      endBlock: block.number + votingDelay + votingPeriod,\n      forVotes: 0,\n      againstVotes: 0,\n      abstainVotes: 0,\n      canceled: false,\n      executed: false,\n      emergency: _emergency,\n      quorumVotes: quorumVotes,\n      delay: proposalTimelockDelay\n    });\n\n    //whitelist can't make emergency\n    if (_emergency && !isWhitelisted(msg.sender)) {\n      _newProposal.startBlock = block.number;\n      _newProposal.endBlock = block.number + emergencyVotingPeriod;\n      _newProposal.quorumVotes = emergencyQuorumVotes;\n      _newProposal.delay = emergencyTimelockDelay;\n    }\n\n    //whitelist can only make optimistic proposals\n    if (isWhitelisted(msg.sender)) {\n      _newProposal.quorumVotes = optimisticQuorumVotes;\n      _newProposal.startBlock = block.number + optimisticVotingDelay;\n      _newProposal.endBlock = block.number + optimisticVotingDelay + votingPeriod;\n    }\n\n    proposals[_newProposal.id] = _newProposal;\n    latestProposalIds[_newProposal.proposer] = _newProposal.id;\n\n    emit ProposalCreatedIndexed(\n      _newProposal.id,\n      msg.sender,\n      _targets,\n      _values,\n      _signatures,\n      _calldatas,\n      _newProposal.startBlock,\n      _newProposal.endBlock,\n      _description\n    );\n\n    emit ProposalCreated(\n      _newProposal.id,\n      msg.sender,\n      _targets,\n      _values,\n      _signatures,\n      _calldatas,\n      _newProposal.startBlock,\n      _newProposal.endBlock,\n      _description\n    );\n    _proposalId = _newProposal.id;\n  }\n\n  /**\n   * @notice Queues a proposal of state succeeded\n   * @param _proposalId The id of the proposal to queue\n   */\n  function queue(uint256 _proposalId) external override {\n    if (state(_proposalId) != ProposalState.Succeeded) revert GovernorCharlie_ProposalNotSucceeded();\n    Proposal storage _proposal = proposals[_proposalId];\n    uint256 _eta = block.timestamp + _proposal.delay;\n    for (uint256 _i = 0; _i < _proposal.targets.length; _i++) {\n      if (\n        queuedTransactions[keccak256(\n          abi.encode(\n            _proposal.targets[_i], _proposal.values[_i], _proposal.signatures[_i], _proposal.calldatas[_i], _eta\n          )\n        )]\n      ) revert GovernorCharlie_ProposalAlreadyQueued();\n      _queueTransaction(\n        _proposal.targets[_i],\n        _proposal.values[_i],\n        _proposal.signatures[_i],\n        _proposal.calldatas[_i],\n        _eta,\n        _proposal.delay\n      );\n    }\n    _proposal.eta = _eta;\n    emit ProposalQueuedIndexed(_proposalId, _eta);\n    emit ProposalQueued(_proposalId, _eta);\n  }\n\n  /// @notice Queues a transaction\n  /// @param _target Target address for transaction\n  /// @param _value Eth value for transaction\n  /// @param _signature Function signature for transaction\n  /// @param _data Calldata for transaction\n  /// @param _eta Timestamp for transaction\n  /// @param _delay Delay for transaction\n  /// @return _txHash Transaction hash\n  function _queueTransaction(\n    address _target,\n    uint256 _value,\n    string memory _signature,\n    bytes memory _data,\n    uint256 _eta,\n    uint256 _delay\n  ) internal returns (bytes32 _txHash) {\n    if (_eta < (_getBlockTimestamp() + _delay)) revert GovernorCharlie_DelayNotReached();\n\n    _txHash = keccak256(abi.encode(_target, _value, _signature, _data, _eta));\n    queuedTransactions[_txHash] = true;\n\n    emit QueueTransaction(_txHash, _target, _value, _signature, _data, _eta);\n  }\n\n  /**\n   * @notice Executes a queued proposal if eta has passed\n   * @param _proposalId The id of the proposal to execute\n   */\n  function execute(uint256 _proposalId) external payable override {\n    if (state(_proposalId) != ProposalState.Queued) revert GovernorCharlie_ProposalNotQueued();\n    Proposal storage _proposal = proposals[_proposalId];\n    _proposal.executed = true;\n    for (uint256 _i = 0; _i < _proposal.targets.length; _i++) {\n      this.executeTransaction{value: _proposal.values[_i]}(\n        _proposal.targets[_i], _proposal.values[_i], _proposal.signatures[_i], _proposal.calldatas[_i], _proposal.eta\n      );\n    }\n    emit ProposalExecutedIndexed(_proposalId);\n    emit ProposalExecuted(_proposalId);\n  }\n\n  /// @notice Executes a transaction\n  /// @param _target Target address for transaction\n  /// @param _value Eth value for transaction\n  /// @param _signature Function signature for transaction\n  /// @param _data Calldata for transaction\n  /// @param _eta Timestamp for transaction\n  function executeTransaction(\n    address _target,\n    uint256 _value,\n    string memory _signature,\n    bytes memory _data,\n    uint256 _eta\n  ) external payable override {\n    if (msg.sender != address(this)) revert GovernorCharlie_NotGovernorCharlie();\n\n    bytes32 _txHash = keccak256(abi.encode(_target, _value, _signature, _data, _eta));\n    if (!queuedTransactions[_txHash]) revert GovernorCharlie_ProposalNotQueued();\n    if (_getBlockTimestamp() < _eta) revert GovernorCharlie_TimelockNotReached();\n    if (_getBlockTimestamp() > _eta + GRACE_PERIOD) revert GovernorCharlie_TransactionStale();\n\n    queuedTransactions[_txHash] = false;\n\n    bytes memory _callData;\n\n    if (bytes(_signature).length == 0) _callData = _data;\n    else _callData = abi.encodePacked(bytes4(keccak256(bytes(_signature))), _data);\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool _success, /*bytes memory returnData*/ ) = _target.call{value: _value}(_callData);\n    if (!_success) revert GovernorCharlie_TransactionReverted();\n\n    emit ExecuteTransaction(_txHash, _target, _value, _signature, _data, _eta);\n  }\n\n  /**\n   * @notice Cancels a proposal only if sender is the proposer, or proposer delegates dropped below proposal threshold\n   * @notice whitelistGuardian can cancel proposals from whitelisted addresses\n   * @param _proposalId The id of the proposal to cancel\n   */\n  function cancel(uint256 _proposalId) external override {\n    if (state(_proposalId) == ProposalState.Executed) revert GovernorCharlie_ProposalAlreadyExecuted();\n\n    Proposal storage _proposal = proposals[_proposalId];\n\n    // Proposer can cancel\n    if (msg.sender != _proposal.proposer) {\n      // Whitelisted proposers can't be canceled for falling below proposal threshold\n      if (isWhitelisted(_proposal.proposer)) {\n        if (\n          (amph.getPriorVotes(_proposal.proposer, (block.number - 1)) >= proposalThreshold)\n            || msg.sender != whitelistGuardian\n        ) revert GovernorCharlie_WhitelistedProposer();\n      } else {\n        if ((amph.getPriorVotes(_proposal.proposer, (block.number - 1)) >= proposalThreshold)) {\n          revert GovernorCharlie_ProposalAboveThreshold();\n        }\n      }\n    }\n\n    _proposal.canceled = true;\n    for (uint256 _i = 0; _i < _proposal.targets.length; _i++) {\n      _cancelTransaction(\n        _proposal.targets[_i], _proposal.values[_i], _proposal.signatures[_i], _proposal.calldatas[_i], _proposal.eta\n      );\n    }\n\n    emit ProposalCanceledIndexed(_proposalId);\n    emit ProposalCanceled(_proposalId);\n  }\n\n  /// @notice Cancels a transaction\n  /// @param _target Target address for transaction\n  /// @param _value Eth value for transaction\n  /// @param _signature Function signature for transaction\n  /// @param _data Calldata for transaction\n  /// @param _eta Timestamp for transaction\n  function _cancelTransaction(\n    address _target,\n    uint256 _value,\n    string memory _signature,\n    bytes memory _data,\n    uint256 _eta\n  ) internal {\n    bytes32 _txHash = keccak256(abi.encode(_target, _value, _signature, _data, _eta));\n    queuedTransactions[_txHash] = false;\n\n    emit CancelTransaction(_txHash, _target, _value, _signature, _data, _eta);\n  }\n\n  /**\n   * @notice Gets actions of a proposal\n   * @param _proposalId The id of the proposal\n   * @return _targets The proposal targets\n   * @return _values The proposal values\n   * @return _signatures The proposal signatures\n   * @return _calldatas The proposal calldata\n   */\n  function getActions(uint256 _proposalId)\n    external\n    view\n    override\n    returns (\n      address[] memory _targets,\n      uint256[] memory _values,\n      string[] memory _signatures,\n      bytes[] memory _calldatas\n    )\n  {\n    Proposal storage _proposal = proposals[_proposalId];\n    return (_proposal.targets, _proposal.values, _proposal.signatures, _proposal.calldatas);\n  }\n\n  /**\n   * @notice Returns the proposal\n   * @param _proposalId The id of proposal\n   * @return _proposal The proposal\n   */\n  function getProposal(uint256 _proposalId) external view returns (Proposal memory _proposal) {\n    _proposal = proposals[_proposalId];\n  }\n\n  /**\n   * @notice Gets the receipt for a voter on a given proposal\n   * @param _proposalId The id of proposal\n   * @param _voter The address of the voter\n   * @return _votingReceipt The voting receipt\n   */\n  function getReceipt(\n    uint256 _proposalId,\n    address _voter\n  ) external view override returns (Receipt memory _votingReceipt) {\n    _votingReceipt = proposalReceipts[_proposalId][_voter];\n  }\n\n  /**\n   * @notice Gets the state of a proposal\n   * @param _proposalId The id of the proposal\n   * @return _state Proposal state\n   */\n  // solhint-disable-next-line code-complexity\n  function state(uint256 _proposalId) public view override returns (ProposalState _state) {\n    if (proposalCount < _proposalId || _proposalId <= initialProposalId) revert GovernorCharlie_InvalidProposalId();\n    Proposal storage _proposal = proposals[_proposalId];\n    bool _whitelisted = isWhite"
    }
  ]
}