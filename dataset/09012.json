{
  "Title": "[M-07] `RedemptionSender` should estimate fees to prevent failed transactions",
  "Content": "_Submitted by Ruhum_\n\n[RedemptionSender.sol#L43](https://github.com/code-423n4/2022-05-velodrome/blob/main/contracts/contracts/redeem/RedemptionSender.sol#L43)<br>\n\nWhen sending a msg to the layer zero endpoint you include enough gas for the transaction. If you don't include enough tokens for the gas, the transaction will fail. The RedemptionSender contract allows the user to pass any value they want which might result in them sending not enough. Their transaction will fail.\n\nTo know how much you have to send there's the `estimateFees()` function as described [here](https://layerzero.gitbook.io/docs/guides/code-examples/estimating-message-fees).\n\n### Proof of Concept\n\n```sol\n    function redeemWEVE(\n        uint256 amount,\n        address zroPaymentAddress,\n        bytes memory zroTransactionParams\n    ) public payable {\n        require(amount != 0, \"AMOUNT_ZERO\");\n        require(\n            IERC20(weve).transferFrom(\n                msg.sender,\n                0x000000000000000000000000000000000000dEaD,\n                amount\n            ),\n            \"WEVE: TRANSFER_FAILED\"\n        );\n\n        ILayerZeroEndpoint(endpoint).send{value: msg.value}(\n            optimismChainId,\n            abi.encodePacked(optimismReceiver),\n            abi.encode(msg.sender, amount),\n            payable(msg.sender),\n            zroPaymentAddress,\n            zroTransactionParams\n        );\n    }\n```\n\n### Recommended Mitigation Steps\n\nUse the `estimateFees()` endpoint.\n\n**[pooltypes (Velodrome) acknowledged](https://github.com/code-423n4/2022-05-velodrome-findings/issues/80)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-05-velodrome-findings/issues/80#issuecomment-1169370002):**\n > The transaction shown has a case in which it could succeed but the message wouldn't be forwarded.\n> \n> That is because any estimate_gas will make the tx work but the gas payment may not be sufficient to fund the message fees.\n> \n> Because this can cause burned tokens, I believe a check should be added and since the tx must originate from the `fantomSender`  there would be no way of forwarding the message on the behalf of the sender.\n> \n> For those reasons I believe the finding is of Medium Severity.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-05-velodrome",
  "Code": [
    {
      "filename": "contracts/contracts/redeem/RedemptionSender.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"LayerZero/interfaces/ILayerZeroEndpoint.sol\";\nimport \"../interfaces/IERC20.sol\";\n\n/// @notice Part 1 of 2 in the WeVE (FTM) -> USDC + VELO (OP) redemption process\n/// This contract is responsible for burning WeVE and sending the LZ message\ncontract RedemptionSender {\n    address public immutable weve;\n    uint16 public immutable optimismChainId; // 11 for OP, 10011 for OP Kovan\n    address public immutable endpoint;\n    address public immutable optimismReceiver;\n\n    constructor(\n        address _weve,\n        uint16 _optimismChainId,\n        address _endpoint,\n        address _optimismReceiver\n    ) {\n        require(_optimismChainId == 11 || _optimismChainId == 10011, \"CHAIN_ID_NOT_OP\");\n        weve = _weve;\n        optimismChainId = _optimismChainId;\n        endpoint = _endpoint;\n        optimismReceiver = _optimismReceiver;\n    }\n\n    function redeemWEVE(\n        uint256 amount,\n        address zroPaymentAddress,\n        bytes memory zroTransactionParams\n    ) public payable {\n        require(amount != 0, \"AMOUNT_ZERO\");\n        require(\n            IERC20(weve).transferFrom(\n                msg.sender,\n                0x000000000000000000000000000000000000dEaD,\n                amount\n            ),\n            \"WEVE: TRANSFER_FAILED\"\n        );\n\n        ILayerZeroEndpoint(endpoint).send{value: msg.value}(\n            optimismChainId,\n            abi.encodePacked(optimismReceiver),\n            abi.encode(msg.sender, amount),\n            payable(msg.sender),\n            zroPaymentAddress,\n            zroTransactionParams\n        );\n    }\n}"
    }
  ]
}