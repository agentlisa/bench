{
  "Title": "M-23: Missing checks for whether a position is still an ADL candidate",
  "Content": "# Issue M-23: Missing checks for whether a position is still an ADL candidate \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/153 \n\n## Found by \nIllIllI\n\n## Summary\n\nThere are no checks for whether a position is still an ADL candidate or not\n\n\n## Vulnerability Detail\n\nAll checks during `AdlHandler.executeAdl()` are global checks about exchange-wide PnL levels, and there are no checks for whether the specific position is a valid ADL candidate or not.\n\n## Impact\n\nBetween the time when the ADL keeper chooses its list of ADL candidates and when the transaction gets confirmed (e.g. if the keeper has a sudden CPU spike, or the connection to the sequencer has to be retried), the user may have already reduced their position, and it would be incorrect to further reduce their position.\n\n\n## Code Snippet\n\nAll checks are global:\n```solidity\n// File: gmx-synthetics/contracts/exchange/AdlHandler.sol : AdlHandler.executeAdl()   #1\n\n119 @>         (cache.shouldAllowAdl, cache.pnlToPoolFactor, cache.maxPnlFactorForAdl) = MarketUtils.isPnlFactorExceeded(\n120                dataStore,\n121                oracle,\n122                market,\n123                isLong,\n124                Keys.MAX_PNL_FACTOR_FOR_ADL\n125            );\n126    \n127            if (!cache.shouldAllowAdl) {\n128                revert AdlNotRequired(cache.pnlToPoolFactor, cache.maxPnlFactorForAdl);\n129:           }\n```\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/exchange/AdlHandler.sol#L119-L129\n\n```solidity\n// File: gmx-synthetics/contracts/exchange/AdlHandler.sol : AdlHandler.executeAdl()   #2\n\n150            // validate that the ratio of pending pnl to pool value was decreased\n151 @>         cache.nextPnlToPoolFactor = MarketUtils.getPnlToPoolFactor(dataStore, oracle, market, isLong, true);\n152            if (cache.nextPnlToPoolFactor >= cache.pnlToPoolFactor) {\n153                revert InvalidAdl(cache.nextPnlToPoolFactor, cache.pnlToPoolFactor);\n154            }\n155    \n156            cache.minPnlFactorForAdl = MarketUtils.getMinPnlFactorAfterAdl(dataStore, market, isLong);\n157    \n158            if (cache.nextPnlToPoolFactor < cache.minPnlFactorForAdl.toInt256()) {\n159                revert PnlOvercorrected(cache.nextPnlToPoolFactor, cache.minPnlFactorForAdl);\n160            }\n161:       }\n```\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/exchange/AdlHandler.sol#L150-161\n\nThe order only gets canceled if the order would cause the position size to go [negative](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/adl/AdlUtils.sol#L129-L131)\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nCreate a view function for whether the position is eligible for ADL, and revert if the user is not eligible when the order executes\n\n\n\n\n## Discussion\n\n**xvi10**\n\nthe ADL transaction should revert if it does not reduce the pnl value to pool value ratio\n\n**IllIllI000**\n\n@xvi10 if there are 100 ADL-eligible accounts and you pick the largest one, if that largest one becomes the smallest by the time the keeper executes, shouldnâ€™t one of the larger other 99 be chosen instead?\n\n**xvi10**\n\npreferably it should be the largest ADL candidate but we don't enforce this on-chain because I think it is difficult to maintain an ordering or orders by PnL\n\nthis behaviour could be incentivised off-chain through rewarding keepers proportional to the PnL of the position ADLed, could be done on the contract level as well, but we do not think this feature is worth the complexity to add for now\n\n**IllIllI000**\n\nI'm Keeping this open since the argument is complexity rather than optimal behavior\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/exchange/AdlHandler.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./BaseOrderHandler.sol\";\n\n// @title AdlHandler\n// @dev Contract to handle adls\ncontract AdlHandler is BaseOrderHandler {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using Order for Order.Props;\n    using Array for uint256[];\n\n    error AdlNotRequired(int256 pnlToPoolFactor, uint256 maxPnlFactorForAdl);\n    error InvalidAdl(int256 nextPnlToPoolFactor, int256 pnlToPoolFactor);\n    error PnlOvercorrected(int256 nextPnlToPoolFactor, uint256 minPnlFactorForAdl);\n\n    // @dev ExecuteAdlCache struct used in executeAdl to avoid\n    // stack too deep errors\n    struct ExecuteAdlCache {\n        uint256 startingGas;\n        uint256[] minOracleBlockNumbers;\n        uint256[] maxOracleBlockNumbers;\n        bytes32 key;\n        bool shouldAllowAdl;\n        uint256 maxPnlFactorForAdl;\n        int256 pnlToPoolFactor;\n        int256 nextPnlToPoolFactor;\n        uint256 minPnlFactorForAdl;\n    }\n\n    constructor(\n        RoleStore _roleStore,\n        DataStore _dataStore,\n        EventEmitter _eventEmitter,\n        OrderVault _orderVault,\n        Oracle _oracle,\n        SwapHandler _swapHandler,\n        IReferralStorage _referralStorage\n    ) BaseOrderHandler(\n        _roleStore,\n        _dataStore,\n        _eventEmitter,\n        _orderVault,\n        _oracle,\n        _swapHandler,\n        _referralStorage\n    ) {}\n\n    // @dev checks the ADL state to update the isAdlEnabled flag\n    // @param market the market to check\n    // @param isLong whether to check the long or short side\n    // @param oracleParams OracleUtils.SetPricesParams\n    function updateAdlState(\n        address market,\n        bool isLong,\n        OracleUtils.SetPricesParams calldata oracleParams\n    ) external\n        globalNonReentrant\n        onlyAdlKeeper\n        withOraclePrices(oracle, dataStore, eventEmitter, oracleParams)\n    {\n        uint256[] memory maxOracleBlockNumbers = OracleUtils.getUncompactedOracleBlockNumbers(\n            oracleParams.compactedMaxOracleBlockNumbers,\n            oracleParams.tokens.length\n        );\n\n        AdlUtils.updateAdlState(\n            dataStore,\n            eventEmitter,\n            oracle,\n            market,\n            isLong,\n            maxOracleBlockNumbers\n        );\n    }\n\n    // @dev auto-deleverages a position\n    // @param account the position's account\n    // @param market the position's market\n    // @param collateralToken the position's collateralToken\n    // @param isLong whether the position is long or short\n    // @param sizeDeltaUsd the size to reduce the position by\n    // @param oracleParams OracleUtils.SetPricesParams\n    function executeAdl(\n        address account,\n        address market,\n        address collateralToken,\n        bool isLong,\n        uint256 sizeDeltaUsd,\n        OracleUtils.SetPricesParams calldata oracleParams\n    ) external\n        globalNonReentrant\n        onlyAdlKeeper\n        withOraclePrices(oracle, dataStore, eventEmitter, oracleParams)\n    {\n        ExecuteAdlCache memory cache;\n\n        cache.startingGas = gasleft();\n\n        cache.minOracleBlockNumbers = OracleUtils.getUncompactedOracleBlockNumbers(\n            oracleParams.compactedMinOracleBlockNumbers,\n            oracleParams.tokens.length\n        );\n\n        cache.maxOracleBlockNumbers = OracleUtils.getUncompactedOracleBlockNumbers(\n            oracleParams.compactedMaxOracleBlockNumbers,\n            oracleParams.tokens.length\n        );\n\n        AdlUtils.validateAdl(\n            dataStore,\n            market,\n            isLong,\n            cache.maxOracleBlockNumbers\n        );\n\n        (cache.shouldAllowAdl, cache.pnlToPoolFactor, cache.maxPnlFactorForAdl) = MarketUtils.isPnlFactorExceeded(\n            dataStore,\n            oracle,\n            market,\n            isLong,\n            Keys.MAX_PNL_FACTOR_FOR_ADL\n        );\n\n        if (!cache.shouldAllowAdl) {\n            revert AdlNotRequired(cache.pnlToPoolFactor, cache.maxPnlFactorForAdl);\n        }\n\n        cache.key = AdlUtils.createAdlOrder(\n            AdlUtils.CreateAdlOrderParams(\n                dataStore,\n                eventEmitter,\n                account,\n                market,\n                collateralToken,\n                isLong,\n                sizeDeltaUsd,\n                cache.minOracleBlockNumbers[0]\n            )\n        );\n\n        BaseOrderUtils.ExecuteOrderParams memory params = _getExecuteOrderParams(cache.key, oracleParams, msg.sender, cache.startingGas);\n\n        FeatureUtils.validateFeature(params.contracts.dataStore, Keys.executeAdlFeatureDisabledKey(address(this), uint256(params.order.orderType())));\n\n        OrderUtils.executeOrder(params);\n\n        // validate that the ratio of pending pnl to pool value was decreased\n        cache.nextPnlToPoolFactor = MarketUtils.getPnlToPoolFactor(dataStore, oracle, market, isLong, true);\n        if (cache.nextPnlToPoolFactor >= cache.pnlToPoolFactor) {\n            revert InvalidAdl(cache.nextPnlToPoolFactor, cache.pnlToPoolFactor);\n        }\n\n        cache.minPnlFactorForAdl = MarketUtils.getMinPnlFactorAfterAdl(dataStore, market, isLong);\n\n        if (cache.nextPnlToPoolFactor < cache.minPnlFactorForAdl.toInt256()) {\n            revert PnlOvercorrected(cache.nextPnlToPoolFactor, cache.minPnlFactorForAdl);\n        }\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/exchange/AdlHandler.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./BaseOrderHandler.sol\";\n\n// @title AdlHandler\n// @dev Contract to handle adls\ncontract AdlHandler is BaseOrderHandler {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using Order for Order.Props;\n    using Array for uint256[];\n\n    error AdlNotRequired(int256 pnlToPoolFactor, uint256 maxPnlFactorForAdl);\n    error InvalidAdl(int256 nextPnlToPoolFactor, int256 pnlToPoolFactor);\n    error PnlOvercorrected(int256 nextPnlToPoolFactor, uint256 minPnlFactorForAdl);\n\n    // @dev ExecuteAdlCache struct used in executeAdl to avoid\n    // stack too deep errors\n    struct ExecuteAdlCache {\n        uint256 startingGas;\n        uint256[] minOracleBlockNumbers;\n        uint256[] maxOracleBlockNumbers;\n        bytes32 key;\n        bool shouldAllowAdl;\n        uint256 maxPnlFactorForAdl;\n        int256 pnlToPoolFactor;\n        int256 nextPnlToPoolFactor;\n        uint256 minPnlFactorForAdl;\n    }\n\n    constructor(\n        RoleStore _roleStore,\n        DataStore _dataStore,\n        EventEmitter _eventEmitter,\n        OrderVault _orderVault,\n        Oracle _oracle,\n        SwapHandler _swapHandler,\n        IReferralStorage _referralStorage\n    ) BaseOrderHandler(\n        _roleStore,\n        _dataStore,\n        _eventEmitter,\n        _orderVault,\n        _oracle,\n        _swapHandler,\n        _referralStorage\n    ) {}\n\n    // @dev checks the ADL state to update the isAdlEnabled flag\n    // @param market the market to check\n    // @param isLong whether to check the long or short side\n    // @param oracleParams OracleUtils.SetPricesParams\n    function updateAdlState(\n        address market,\n        bool isLong,\n        OracleUtils.SetPricesParams calldata oracleParams\n    ) external\n        globalNonReentrant\n        onlyAdlKeeper\n        withOraclePrices(oracle, dataStore, eventEmitter, oracleParams)\n    {\n        uint256[] memory maxOracleBlockNumbers = OracleUtils.getUncompactedOracleBlockNumbers(\n            oracleParams.compactedMaxOracleBlockNumbers,\n            oracleParams.tokens.length\n        );\n\n        AdlUtils.updateAdlState(\n            dataStore,\n            eventEmitter,\n            oracle,\n            market,\n            isLong,\n            maxOracleBlockNumbers\n        );\n    }\n\n    // @dev auto-deleverages a position\n    // @param account the position's account\n    // @param market the position's market\n    // @param collateralToken the position's collateralToken\n    // @param isLong whether the position is long or short\n    // @param sizeDeltaUsd the size to reduce the position by\n    // @param oracleParams OracleUtils.SetPricesParams\n    function executeAdl(\n        address account,\n        address market,\n        address collateralToken,\n        bool isLong,\n        uint256 sizeDeltaUsd,\n        OracleUtils.SetPricesParams calldata oracleParams\n    ) external\n        globalNonReentrant\n        onlyAdlKeeper\n        withOraclePrices(oracle, dataStore, eventEmitter, oracleParams)\n    {\n        ExecuteAdlCache memory cache;\n\n        cache.startingGas = gasleft();\n\n        cache.minOracleBlockNumbers = OracleUtils.getUncompactedOracleBlockNumbers(\n            oracleParams.compactedMinOracleBlockNumbers,\n            oracleParams.tokens.length\n        );\n\n        cache.maxOracleBlockNumbers = OracleUtils.getUncompactedOracleBlockNumbers(\n            oracleParams.compactedMaxOracleBlockNumbers,\n            oracleParams.tokens.length\n        );\n\n        AdlUtils.validateAdl(\n            dataStore,\n            market,\n            isLong,\n            cache.maxOracleBlockNumbers\n        );\n\n        (cache.shouldAllowAdl, cache.pnlToPoolFactor, cache.maxPnlFactorForAdl) = MarketUtils.isPnlFactorExceeded(\n            dataStore,\n            oracle,\n            market,\n            isLong,\n            Keys.MAX_PNL_FACTOR_FOR_ADL\n        );\n\n        if (!cache.shouldAllowAdl) {\n            revert AdlNotRequired(cache.pnlToPoolFactor, cache.maxPnlFactorForAdl);\n        }\n\n        cache.key = AdlUtils.createAdlOrder(\n            AdlUtils.CreateAdlOrderParams(\n                dataStore,\n                eventEmitter,\n                account,\n                market,\n                collateralToken,\n                isLong,\n                sizeDeltaUsd,\n                cache.minOracleBlockNumbers[0]\n            )\n        );\n\n        BaseOrderUtils.ExecuteOrderParams memory params = _getExecuteOrderParams(cache.key, oracleParams, msg.sender, cache.startingGas);\n\n        FeatureUtils.validateFeature(params.contracts.dataStore, Keys.executeAdlFeatureDisabledKey(address(this), uint256(params.order.orderType())));\n\n        OrderUtils.executeOrder(params);\n\n        // validate that the ratio of pending pnl to pool value was decreased\n        cache.nextPnlToPoolFactor = MarketUtils.getPnlToPoolFactor(dataStore, oracle, market, isLong, true);\n        if (cache.nextPnlToPoolFactor >= cache.pnlToPoolFactor) {\n            revert InvalidAdl(cache.nextPnlToPoolFactor, cache.pnlToPoolFactor);\n        }\n\n        cache.minPnlFactorForAdl = MarketUtils.getMinPnlFactorAfterAdl(dataStore, market, isLong);\n\n        if (cache.nextPnlToPoolFactor < cache.minPnlFactorForAdl.toInt256()) {\n            revert PnlOvercorrected(cache.nextPnlToPoolFactor, cache.minPnlFactorForAdl);\n        }\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/adl/AdlUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../data/DataStore.sol\";\nimport \"../event/EventEmitter.sol\";\n\nimport \"../order/OrderStoreUtils.sol\";\nimport \"../order/OrderEventUtils.sol\";\nimport \"../position/PositionUtils.sol\";\nimport \"../position/PositionStoreUtils.sol\";\nimport \"../nonce/NonceUtils.sol\";\n\n// @title AdlUtils\n// @dev Library to help with auto-deleveraging\n// This is particularly for markets with an index token that is different from\n// the long token\n//\n// For example, if there is a DOGE / USD perp market with ETH as the long token\n// it would be possible for the price of DOGE to increase faster than the price of\n// ETH\n//\n// In this scenario, profitable positions should be closed through ADL to ensure\n// that the system remains fully solvent\nlibrary AdlUtils {\n    using SafeCast for int256;\n    using Array for uint256[];\n    using Market for Market.Props;\n    using Position for Position.Props;\n\n    using EventUtils for EventUtils.AddressItems;\n    using EventUtils for EventUtils.UintItems;\n    using EventUtils for EventUtils.IntItems;\n    using EventUtils for EventUtils.BoolItems;\n    using EventUtils for EventUtils.Bytes32Items;\n    using EventUtils for EventUtils.BytesItems;\n    using EventUtils for EventUtils.StringItems;\n\n    // @dev CreateAdlOrderParams struct used in createAdlOrder to avoid stack\n    // too deep errors\n    //\n    // @param dataStore DataStore\n    // @param orderStore OrderStore\n    // @param account the account to reduce the position for\n    // @param market the position's market\n    // @param collateralToken the position's collateralToken\n    // @param isLong whether the position is long or short\n    // @param sizeDeltaUsd the size to reduce the position by\n    // @param updatedAtBlock the block to set the order's updatedAtBlock to\n    struct CreateAdlOrderParams {\n        DataStore dataStore;\n        EventEmitter eventEmitter;\n        address account;\n        address market;\n        address collateralToken;\n        bool isLong;\n        uint256 sizeDeltaUsd;\n        uint256 updatedAtBlock;\n    }\n\n    error InvalidSizeDeltaForAdl(uint256 sizeDeltaUsd, uint256 positionSizeInUsd);\n    error AdlNotEnabled();\n\n    // @dev Multiple positions may need to be reduced to ensure that the pending\n    // profits does not exceed the allowed thresholds\n    //\n    // This automatic reduction of positions can only be done if the pool is in a state\n    // where auto-deleveraging is required\n    //\n    // This function checks the pending profit state and updates an isAdlEnabled\n    // flag to avoid having to repeatedly validate whether auto-deleveraging is required\n    //\n    // Once the pending profit has been reduced below the threshold this function can\n    // be called again to clear the flag\n    //\n    // The ADL check would be possible to do in AdlHandler.executeAdl as well\n    // but with that order keepers could use stale oracle prices to prove that\n    // an ADL state is possible\n    //\n    // Having this function allows any order keeper to disable ADL if prices\n    // have updated such that ADL is no longer needed\n    //\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param oracle Oracle\n    // @param market address of the market to check\n    // @param isLong indicates whether to check the long or short side of the market\n    // @param maxOracleBlockNumbers the oracle block numbers for the prices stored in the oracle\n    function updateAdlState(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        Oracle oracle,\n        address market,\n        bool isLong,\n        uint256[] memory maxOracleBlockNumbers\n    ) external {\n        uint256 latestAdlBlock = getLatestAdlBlock(dataStore, market, isLong);\n\n        if (!maxOracleBlockNumbers.areGreaterThanOrEqualTo(latestAdlBlock)) {\n            OracleUtils.revertOracleBlockNumbersAreSmallerThanRequired(maxOracleBlockNumbers, latestAdlBlock);\n        }\n\n        Market.Props memory _market = MarketUtils.getEnabledMarket(dataStore, market);\n        MarketUtils.MarketPrices memory prices = MarketUtils.getMarketPrices(oracle, _market);\n        (bool shouldEnableAdl, int256 pnlToPoolFactor, uint256 maxPnlFactor) = MarketUtils.isPnlFactorExceeded(\n            dataStore,\n            _market,\n            prices,\n            isLong,\n            Keys.MAX_PNL_FACTOR\n        );\n\n        setIsAdlEnabled(dataStore, market, isLong, shouldEnableAdl);\n        setLatestAdlBlock(dataStore, market, isLong, block.number);\n\n        emitAdlStateUpdated(eventEmitter, market, isLong, pnlToPoolFactor, maxPnlFactor, shouldEnableAdl);\n    }\n\n    // @dev Construct an ADL order\n    //\n    // A decrease order is used to reduce a profitable position\n    //\n    // @param params CreateAdlOrderParams\n    // @return the key of the created order\n    function createAdlOrder(CreateAdlOrderParams memory params) external returns (bytes32) {\n        bytes32 positionKey = PositionUtils.getPositionKey(params.account, params.market, params.collateralToken, params.isLong);\n        Position.Props memory position = PositionStoreUtils.get(params.dataStore, positionKey);\n\n        if (params.sizeDeltaUsd > position.sizeInUsd()) {\n            revert InvalidSizeDeltaForAdl(params.sizeDeltaUsd, position.sizeInUsd());\n        }\n\n        Order.Addresses memory addresses = Order.Addresses(\n            params.account, // account\n            params.account, // receiver\n            address(0), // callbackContract\n            params.market, // market\n            position.collateralToken(), // initialCollateralToken\n            new address[](0) // swapPath\n        );\n\n        Order.Numbers memory numbers = Order.Numbers(\n            Order.OrderType.MarketDecrease, // orderType\n            Order.DecreasePositionSwapType.NoSwap, // decreasePositionSwapType\n            params.sizeDeltaUsd, // sizeDeltaUsd\n            0, // initialCollateralDeltaAmount\n            0, // triggerPrice\n            position.isLong() ? 0 : type(uint256).max, // acceptablePrice\n            0, // executionFee\n            0, // callbackGasLimit\n            0, // minOutputAmount\n            params.updatedAtBlock // updatedAtBlock\n        );\n\n        Order.Flags memory flags = Order.Flags(\n            position.isLong(), // isLong\n            true, // shouldUnwrapNativeToken\n            false // isFrozen\n        );\n\n        Order.Props memory order = Order.Props(\n            addresses,\n            numbers,\n            flags\n        );\n\n        bytes32 key = NonceUtils.getNextKey(params.dataStore);\n        OrderStoreUtils.set(params.dataStore, key, order);\n\n        OrderEventUtils.emitOrderCreated(params.eventEmitter, key, order);\n\n        return key;\n    }\n\n    // @dev validate if the requested ADL can be executed\n    //\n    // @param dataStore DataStore\n    // @param market address of the market to check\n    // @param isLong indicates whether to check the long or short side of the market\n    // @param maxOracleBlockNumbers the oracle block numbers for the prices stored in the oracle\n    function validateAdl(\n        DataStore dataStore,\n        address market,\n        bool isLong,\n        uint256[] memory maxOracleBlockNumbers\n    ) external view {\n        bool isAdlEnabled = AdlUtils.getIsAdlEnabled(dataStore, market, isLong);\n        if (!isAdlEnabled) {\n            revert AdlNotEnabled();\n        }\n\n        uint256 latestAdlBlock = AdlUtils.getLatestAdlBlock(dataStore, market, isLong);\n        if (!maxOracleBlockNumbers.areGreaterThanOrEqualTo(latestAdlBlock)) {\n            OracleUtils.revertOracleBlockNumbersAreSmallerThanRequired(maxOracleBlockNumbers, latestAdlBlock);\n        }\n    }\n\n    // @dev get the latest block at which the ADL flag was updated\n    //\n    // @param dataStore DataStore\n    // @param market address of the market to check\n    // @param isLong indicates whether to check the long or short side of the market\n    //\n    // @return the latest block at which the ADL flag was updated\n    function getLatestAdlBlock(DataStore dataStore, address market, bool isLong) internal view returns (uint256) {\n        return dataStore.getUint(Keys.latestAdlBlockKey(market, isLong));\n    }\n\n    // @dev set the latest block at which the ADL flag was updated\n    //\n    // @param dataStore DataStore\n    // @param market address of the market to check\n    // @param isLong indicates whether to check the long or short side of the market\n    // @param value the latest block value\n    //\n    // @return the latest block value\n    function setLatestAdlBlock(DataStore dataStore, address market, bool isLong, uint256 value) internal returns (uint256) {\n        return dataStore.setUint(Keys.latestAdlBlockKey(market, isLong), value);\n    }\n\n    // @dev get whether ADL is enabled\n    //\n    // @param dataStore DataStore\n    // @param market address of the market to check\n    // @param isLong indicates whether to check the long or short side of the market\n    //\n    // @return whether ADL is enabled\n    function getIsAdlEnabled(DataStore dataStore, address market, bool isLong) internal view returns (bool) {\n        return dataStore.getBool(Keys.isAdlEnabledKey(market, isLong));\n    }\n\n    // @dev set whether ADL is enabled\n    //\n    // @param dataStore DataStore\n    // @param market address of the market to check\n    // @param isLong indicates whether to check the long or short side of the market\n    // @param value whether ADL is enabled\n    //\n    // @return whether ADL is enabled\n    function setIsAdlEnabled(DataStore dataStore, address market, bool isLong, bool value) internal returns (bool) {\n        return dataStore.setBool(Keys.isAdlEnabledKey(market, isLong), value);\n    }\n\n    // @dev emit ADL state update events\n    //\n    // @param eventEmitter EventEmitter\n    // @param market address of the market for the ADL state update\n    // @param isLong indicates the ADL state update is for the long or short side of the market\n    // @param pnlToPoolFactor the ratio of PnL to pool value\n    // @param maxPnlFactor the max PnL factor\n    // @param shouldEnableAdl whether ADL was enabled or disabled\n    function emitAdlStateUpdated(\n        EventEmitter eventEmitter,\n        address market,\n        bool isLong,\n        int256 pnlToPoolFactor,\n        uint256 maxPnlFactor,\n        bool shouldEnableAdl\n    ) internal {\n        EventUtils.EventLogData memory eventData;\n\n        eventData.intItems.initItems(1);\n        eventData.intItems.setItem(0, \"pnlToPoolFactor\", pnlToPoolFactor);\n\n        eventData.uintItems.initItems(1);\n        eventData.uintItems.setItem(0, \"maxPnlFactor\", maxPnlFactor);\n\n        eventData.boolItems.initItems(2);\n        eventData.boolItems.setItem(0, \"isLong\", isLong);\n        eventData.boolItems.setItem(1, \"shouldEnableAdl\", shouldEnableAdl);\n\n        eventEmitter.emitEventLog1(\n            \"AdlStateUpdated\",\n            Cast.toBytes32(market),\n            eventData\n        );\n    }\n}"
    }
  ]
}