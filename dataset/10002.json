{
  "Title": "[G-06] Using immutable variable can save gas",
  "Content": "*Note: Suggested optimation, save a decent amount of gas without compromising readability.*\r\n\r\n[MasterChef.sol#L52-L71](https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/MasterChef.sol#L52-L71)<br>\r\n\r\n```solidity\r\nuint public startBlock;\r\nuint public endBlock; // The block number when mining starts.\r\nIERC20 public concur;\r\n\r\nuint private _concurShareMultiplier = 1e18;\r\nuint private _perMille = 1000; // 100%\r\n\r\nconstructor(IERC20 _concur, uint _startBlock, uint _endBlock) Ownable() {\r\n    startBlock = _startBlock;\r\n    endBlock = _endBlock;\r\n    concur = _concur;\r\n    // ...\r\n}\r\n```\r\n\r\nConsidering that `startBlock`, `endBlock` and `concur` will never change, changing them to immutable variables instead of storages variable can save gas.\r\n\r\n[StakingRewards.sol#L19-L20](https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L19-L20)<br>\r\n\r\n```solidity\r\n    IERC20 public rewardsToken;\r\n    IERC20 public stakingToken;\r\n```\r\n\r\n[StakingRewards.sol#L37-L47](https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L37-L47)<br>\r\n\r\n```solidity\r\n    constructor(\r\n        address _rewardsDistribution,\r\n        address _rewardsToken,\r\n        address _stakingToken,\r\n        MasterChef _masterChef\r\n    ) {\r\n        rewardsToken = IERC20(_rewardsToken);\r\n        stakingToken = IERC20(_stakingToken);\r\n        rewardsDistribution = _rewardsDistribution;\r\n        masterChef = _masterChef;\r\n    }\r\n```\r\n\r\nConsidering that `rewardsToken` and `stakingToken` will never change, changing them to immutable variables instead of storages variable can save gas.",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-02-concur-finance-contest",
  "Code": [
    {
      "filename": "contracts/MasterChef.sol",
      "content": "// SPDX-License-Identifier: MIT\n\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\ncontract MasterChef is Ownable, ReentrancyGuard {\n    using SafeMath for uint;\n    using SafeERC20 for IERC20;\n\n    event Deposit(address indexed _user, uint indexed _pid, uint _amount);\n    event Withdraw(address indexed _user, uint indexed _pid, uint _amount);\n    event EmergencyWithdraw(address indexed user, uint indexed _pid, uint _amount);\n\n    struct UserInfo {\n        uint128 amount; // How many tokens the user has provided.\n        uint128 rewardDebt; // Reward debt. See explanation below.\n        //\n        // We do some fancy math here. Basically, any point in time, the amount of RADSs\n        // entitled to a user but is pending to be distributed is:\n        //\n        //   pending reward = (user.amount * pool.accumlatedConcurPerShare) - user.rewardDebt\n        //\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\n        //   1. The pool's `accumlatedConcurPerShare` (and `lastRewardBlock`) gets updated.\n        //   2. User receives the pending reward sent to his/her address.\n        //   3. User's `amount` gets updated.\n        //   4. User's `rewardDebt` gets updated.\n    }\n\n    // Info of each pool.\n    struct PoolInfo {\n        IERC20 depositToken; // Address of LP token contract.\n        uint allocPoint; // How many allocation points assigned to this pool. to distribute per block.\n        uint lastRewardBlock; // Last block number that distribution occurs.\n        uint accConcurPerShare; // Accumulated per share, times multiplier. See below.\n        uint16 depositFeeBP; // Deposit fee in basis points\n    }\n\n    PoolInfo[] public poolInfo;\n    mapping(uint => mapping(address => UserInfo)) public userInfo; // Info of each user that stakes LP tokens.\n    mapping(address => bool) public isDepositor;\n    mapping(address => uint256) public pid; // pid mapped to token\n    uint public concurPerBlock = 100000 gwei; // concur tokens transferred per block\n    uint public totalAllocPoint = 0; // Total allocation points. Must be the sum of all allocation points in all pools.\n    uint public startBlock;\n    uint public endBlock; // The block number when mining starts.\n    IERC20 public concur;\n\n    uint private _concurShareMultiplier = 1e18;\n    uint private _perMille = 1000; // 100%\n\n    constructor(IERC20 _concur, uint _startBlock, uint _endBlock) Ownable() {\n        startBlock = _startBlock;\n        endBlock = _endBlock;\n        concur = _concur;\n        poolInfo.push(\n            PoolInfo({\n            depositToken: IERC20(address(0)),\n            allocPoint : 0,\n            lastRewardBlock : _startBlock,\n            accConcurPerShare : 0,\n            depositFeeBP : 0\n        }));\n    }\n\n    modifier onlyDepositor() {\n        require(isDepositor[msg.sender], \"!depositor\");\n        _;\n    }\n\n    function addDepositor(address _depositor) external onlyOwner {\n        isDepositor[_depositor] = true;\n    }\n\n    function removeDepositor(address _depositor) external onlyOwner {\n        isDepositor[_depositor] = false;\n    }\n\n    function add(address _token, uint _allocationPoints, uint16 _depositFee, uint _startBlock) public onlyOwner {\n        require(_token != address(0), \"zero address\");\n        uint lastRewardBlock = block.number > _startBlock ? block.number : _startBlock;\n        totalAllocPoint = totalAllocPoint.add(_allocationPoints);\n        require(pid[_token] == 0, \"already registered\"); // pid starts from 0\n        poolInfo.push(\n            PoolInfo({\n                depositToken: IERC20(_token),\n                allocPoint: _allocationPoints,\n                lastRewardBlock: lastRewardBlock,\n                accConcurPerShare: 0,\n                depositFeeBP: _depositFee\n            })\n        );\n        pid[_token] = poolInfo.length - 1;\n    }\n\n    function poolLength() external view returns (uint) {\n        return poolInfo.length;\n    }\n\n    // Return reward multiplier over the given _from to _to block.\n    function getMultiplier(uint _from, uint _to) public pure returns (uint) {\n        return _to.sub(_from);\n    }\n\n    // View function to see pending [concur] on frontend.\n    function pendingConcur(uint _pid, address _user) external view returns (uint) {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_user];\n        uint accConcurPerShare = pool.accConcurPerShare;\n        uint lpSupply = pool.depositToken.balanceOf(address(this));\n        if (block.number > pool.lastRewardBlock && lpSupply != 0) {\n            uint multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n            uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\n            accConcurPerShare = accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply));\n        }\n        return user.amount * accConcurPerShare / _concurShareMultiplier - user.rewardDebt;\n    }\n\n    // Update reward variables for all pools. Be careful of gas spending!\n    function massUpdatePools() public {\n        uint length = poolInfo.length;\n        for (uint _pid = 0; _pid < length; ++_pid) {\n            updatePool(_pid);\n        }\n    }\n\n    // Update reward variables of the given pool to be up-to-date.\n    function updatePool(uint _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        if (block.number <= pool.lastRewardBlock) {\n            return;\n        }\n        uint lpSupply = pool.depositToken.balanceOf(address(this));\n        if (lpSupply == 0 || pool.allocPoint == 0) {\n            pool.lastRewardBlock = block.number;\n            return;\n        }\n        if(block.number >= endBlock) {\n            pool.lastRewardBlock = block.number;\n            return;\n        }        \n\n        uint multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n        uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\n        pool.accConcurPerShare = pool.accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply));\n        pool.lastRewardBlock = block.number;\n    }\n\n    // Deposit tokens for [concur] allocation.  \n    function deposit(address _recipient, uint _pid, uint _amount) external nonReentrant onlyDepositor {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_msgSender()];\n        updatePool(_pid);\n       \n        if(user.amount > 0) {  \n            uint pending = user.amount * pool.accConcurPerShare / _concurShareMultiplier - user.rewardDebt;\n            if (pending > 0) {\n                safeConcurTransfer(_recipient, pending);\n            }\n        }\n\n        if (_amount > 0) {\n            if (pool.depositFeeBP > 0) {\n                uint depositFee = _amount.mul(pool.depositFeeBP).div(_perMille);\n                user.amount = SafeCast.toUint128(user.amount + _amount - depositFee);\n            } else {\n                user.amount = SafeCast.toUint128(user.amount + _amount);\n            }\n        }     \n\n        user.rewardDebt = SafeCast.toUint128(user.amount * pool.accConcurPerShare / _concurShareMultiplier);\n        emit Deposit(_recipient, _pid, _amount);\n    }\n\n    // Withdraw tokens\n    function withdraw(address _recipient, uint _pid, uint _amount) external nonReentrant onlyDepositor {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_msgSender()];\n        require(user.amount > 0, \"MasterChef: nothing to withdraw\");\n        require(user.amount >= _amount, \"MasterChef: withdraw not allowed\");\n        updatePool(_pid);\n\n        uint pending = user.amount * pool.accConcurPerShare / _concurShareMultiplier - user.rewardDebt;\n        if(pending > 0) {\n            safeConcurTransfer(_recipient, pending);\n        }\n        if (_amount > 0) {\n            user.amount = SafeCast.toUint128(user.amount - _amount);\n        }\n        user.rewardDebt = SafeCast.toUint128(user.amount * pool.accConcurPerShare / _concurShareMultiplier);\n        emit Withdraw(_recipient, _pid, _amount);\n    }\n\n    // Safe [concur] transfer function, just in case if rounding error causes pool to not have enough\n    function safeConcurTransfer(address _to, uint _amount) private {\n        uint concurBalance = concur.balanceOf(address(this));\n        bool transferSuccess = false;\n        if (_amount > concurBalance) {\n            transferSuccess = concur.transfer(_to, concurBalance);\n        } else {\n            transferSuccess = concur.transfer(_to, _amount);\n        }\n        require(transferSuccess, \"safeConcurTransfer: transfer failed\");\n    }\n}"
    },
    {
      "filename": "contracts/StakingRewards.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./MasterChef.sol\";\n\ncontract StakingRewards is Ownable, ReentrancyGuard, Pausable {\n    using SafeERC20 for IERC20;\n\n    MasterChef public immutable masterChef;\n\n    /* ========== STATE VARIABLES ========== */\n\n    IERC20 public rewardsToken;\n    IERC20 public stakingToken;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public rewardsDuration = 7 days;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    address public rewardsDistribution;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _rewardsDistribution,\n        address _rewardsToken,\n        address _stakingToken,\n        MasterChef _masterChef\n    ) {\n        rewardsToken = IERC20(_rewardsToken);\n        stakingToken = IERC20(_stakingToken);\n        rewardsDistribution = _rewardsDistribution;\n        masterChef = _masterChef;\n    }\n\n    /* ========== VIEWS ========== */\n\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return block.timestamp < periodFinish ? block.timestamp : periodFinish;\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored +\n            (((lastTimeRewardApplicable() - lastUpdateTime) *\n                rewardRate *\n                1e18) / _totalSupply);\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            (_balances[account] *\n                (rewardPerToken() - userRewardPerTokenPaid[account])) /\n            1e18 +\n            rewards[account];\n    }\n\n    function getRewardForDuration() external view returns (uint256) {\n        return rewardRate * rewardsDuration;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function stake(uint256 amount)\n        external\n        nonReentrant\n        whenNotPaused\n        updateReward(msg.sender)\n    {\n        require(amount > 0, \"Cannot stake 0\");\n        _totalSupply += amount;\n        _balances[msg.sender] += amount;\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\n        uint256 pid = masterChef.pid(address(stakingToken));\n        masterChef.deposit(msg.sender, pid, amount);\n        emit Staked(msg.sender, amount);\n    }\n\n    function withdraw(uint256 amount)\n        public\n        nonReentrant\n        updateReward(msg.sender)\n    {\n        require(amount > 0, \"Cannot withdraw 0\");\n        _totalSupply -= amount;\n        _balances[msg.sender] -= amount;\n        stakingToken.safeTransfer(msg.sender, amount);\n        uint256 pid = masterChef.pid(address(stakingToken));\n        masterChef.withdraw(msg.sender, pid, amount);\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    function getReward() public nonReentrant updateReward(msg.sender) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            rewardsToken.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n\n    function exit() external {\n        withdraw(_balances[msg.sender]);\n        getReward();\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function notifyRewardAmount(uint256 reward)\n        external\n        updateReward(address(0))\n    {\n        require(\n            msg.sender == rewardsDistribution,\n            \"Caller is not RewardsDistribution contract\"\n        );\n\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward / rewardsDuration;\n        } else {\n            uint256 remaining = periodFinish - block.timestamp;\n            uint256 leftover = remaining * rewardRate;\n            rewardRate = (reward + leftover) / rewardsDuration;\n        }\n\n        // Ensure the provided reward amount is not more than the balance in the contract.\n        // This keeps the reward rate in the right range, preventing overflows due to\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n        uint256 balance = rewardsToken.balanceOf(address(this));\n        require(\n            rewardRate <= balance / rewardsDuration,\n            \"Provided reward too high\"\n        );\n\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp + rewardsDuration;\n        emit RewardAdded(reward);\n    }\n\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n    function recoverERC20(address tokenAddress, uint256 tokenAmount)\n        external\n        onlyOwner\n    {\n        require(\n            tokenAddress != address(stakingToken),\n            \"Cannot withdraw the staking token\"\n        );\n        IERC20(tokenAddress).safeTransfer(owner(), tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }\n\n    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n        require(\n            block.timestamp > periodFinish,\n            \"Previous rewards period must be complete before changing the duration for the new period\"\n        );\n        rewardsDuration = _rewardsDuration;\n        emit RewardsDurationUpdated(rewardsDuration);\n    }\n\n    function setRewardsDistribution(address _rewardsDistribution)\n        external\n        onlyOwner\n    {\n        require(\n            block.timestamp > periodFinish,\n            \"Previous rewards period must be complete before changing the duration for the new period\"\n        );\n        rewardsDistribution = _rewardsDistribution;\n        emit RewardsDistributionUpdated(rewardsDistribution);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event RewardsDurationUpdated(uint256 newDuration);\n    event RewardsDistributionUpdated(address indexed newDistribution);\n    event Recovered(address token, uint256 amount);\n}"
    },
    {
      "filename": "contracts/StakingRewards.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./MasterChef.sol\";\n\ncontract StakingRewards is Ownable, ReentrancyGuard, Pausable {\n    using SafeERC20 for IERC20;\n\n    MasterChef public immutable masterChef;\n\n    /* ========== STATE VARIABLES ========== */\n\n    IERC20 public rewardsToken;\n    IERC20 public stakingToken;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public rewardsDuration = 7 days;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    address public rewardsDistribution;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _rewardsDistribution,\n        address _rewardsToken,\n        address _stakingToken,\n        MasterChef _masterChef\n    ) {\n        rewardsToken = IERC20(_rewardsToken);\n        stakingToken = IERC20(_stakingToken);\n        rewardsDistribution = _rewardsDistribution;\n        masterChef = _masterChef;\n    }\n\n    /* ========== VIEWS ========== */\n\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return block.timestamp < periodFinish ? block.timestamp : periodFinish;\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored +\n            (((lastTimeRewardApplicable() - lastUpdateTime) *\n                rewardRate *\n                1e18) / _totalSupply);\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            (_balances[account] *\n                (rewardPerToken() - userRewardPerTokenPaid[account])) /\n            1e18 +\n            rewards[account];\n    }\n\n    function getRewardForDuration() external view returns (uint256) {\n        return rewardRate * rewardsDuration;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function stake(uint256 amount)\n        external\n        nonReentrant\n        whenNotPaused\n        updateReward(msg.sender)\n    {\n        require(amount > 0, \"Cannot stake 0\");\n        _totalSupply += amount;\n        _balances[msg.sender] += amount;\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\n        uint256 pid = masterChef.pid(address(stakingToken));\n        masterChef.deposit(msg.sender, pid, amount);\n        emit Staked(msg.sender, amount);\n    }\n\n    function withdraw(uint256 amount)\n        public\n        nonReentrant\n        updateReward(msg.sender)\n    {\n        require(amount > 0, \"Cannot withdraw 0\");\n        _totalSupply -= amount;\n        _balances[msg.sender] -= amount;\n        stakingToken.safeTransfer(msg.sender, amount);\n        uint256 pid = masterChef.pid(address(stakingToken));\n        masterChef.withdraw(msg.sender, pid, amount);\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    function getReward() public nonReentrant updateReward(msg.sender) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            rewardsToken.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n\n    function exit() external {\n        withdraw(_balances[msg.sender]);\n        getReward();\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function notifyRewardAmount(uint256 reward)\n        external\n        updateReward(address(0))\n    {\n        require(\n            msg.sender == rewardsDistribution,\n            \"Caller is not RewardsDistribution contract\"\n        );\n\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward / rewardsDuration;\n        } else {\n            uint256 remaining = periodFinish - block.timestamp;\n            uint256 leftover = remaining * rewardRate;\n            rewardRate = (reward + leftover) / rewardsDuration;\n        }\n\n        // Ensure the provided reward amount is not more than the balance in the contract.\n        // This keeps the reward rate in the right range, preventing overflows due to\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n        uint256 balance = rewardsToken.balanceOf(address(this));\n        require(\n            rewardRate <= balance / rewardsDuration,\n            \"Provided reward too high\"\n        );\n\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp + rewardsDuration;\n        emit RewardAdded(reward);\n    }\n\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n    function recoverERC20(address tokenAddress, uint256 tokenAmount)\n        external\n        onlyOwner\n    {\n        require(\n            tokenAddress != address(stakingToken),\n            \"Cannot withdraw the staking token\"\n        );\n        IERC20(tokenAddress).safeTransfer(owner(), tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }\n\n    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n        require(\n            block.timestamp > periodFinish,\n            \"Previous rewards period must be complete before changing the duration for the new period\"\n        );\n        rewardsDuration = _rewardsDuration;\n        emit RewardsDurationUpdated(rewardsDuration);\n    }\n\n    function setRewardsDistribution(address _rewardsDistribution)\n        external\n        onlyOwner\n    {\n        require(\n            block.timestamp > periodFinish,\n            \"Previous rewards period must be complete before changing the duration for the new period\"\n        );\n        rewardsDistribution = _rewardsDistribution;\n        emit RewardsDistributionUpdated(rewardsDistribution);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event RewardsDurationUpdated(uint256 newDuration);\n    event RewardsDistributionUpdated(address indexed newDistribution);\n    event Recovered(address token, uint256 amount);\n}"
    }
  ]
}