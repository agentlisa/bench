{
  "Title": "Attacker Can Get Infinite BVM_ETH Tokens to Drain the Protocol",
  "Content": "The process of depositing MNT and ETH from L1 to L2 starts in the [`depositTransaction` function](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/packages/contracts-bedrock/contracts/L1/OptimismPortal.sol#L451) of the `OptimismPortal` contract. While this contract is used by the `L1CrossDomainMessenger` contract, it can also be called by users directly. It allows anyone to specify the values to mint and/or transfer MNT and/or ETH on L2. The values of minted MNT and minted ETH are determined by [pulling the MNT token](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/packages/contracts-bedrock/contracts/L1/OptimismPortal.sol#L482-L484) from the user and [`msg.value`](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/packages/contracts-bedrock/contracts/L1/OptimismPortal.sol#L498). However, the transaction values of MNT and ETH are just forwarded from the user input to the `TransactionDeposited` event. The node listens to this event, [parses it](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/op-node/rollup/derive/deposit_log.go#L100), and includes it in a block to execute it in the client.\n\n\nWhen the client processes the deposit transaction, it is checked that the L2 user has [enough balance available](https://github.com/mantlenetworkio/op-geth/blob/4d05b2cd9a2b8096680eb9b2e87e473a44a43922/core/state_transition.go#L548-L550) for the given MNT transfer value. If not, the execution reverts. However, this check is never performed for the ETH transaction value. In fact, the [ETH balance transfer](https://github.com/mantlenetworkio/op-geth/blob/4d05b2cd9a2b8096680eb9b2e87e473a44a43922/core/state_transition.go#L716) is performed by reading the `from` and `to` balance from their contract storage slot, [applying the difference](https://github.com/mantlenetworkio/op-geth/blob/4d05b2cd9a2b8096680eb9b2e87e473a44a43922/core/state_transition.go#L739-L740) in value, and setting the new state for these slots. **This happens without any over-/underflow check.** Furthermore, the `common.BigToHash` function that is used to set the state, changes a **negative** `big.Int` value to a **positive** hexadecimal representation.\n\n\nThis means that an attacker with zero ETH balance on L2 can initiate a deposit transaction to transfer 100 ETH to their second controlled address. Then, in the `transferBVMETH` function, their `from` balance is calculated as -100 ETH but written to state as +100 ETH, while their second account also gets another +100 ETH, totaling a gain of 200 ETH on L2 without any L1 investment (besides gas). This ETH value could simply be withdrawn to L1 to drain all of the locked ETH.\n\n\nConsider applying stronger balance and overflow checks when directly manipulating the state of an asset.\n\n\n***Update:** Resolved in [pull request #42](https://github.com/mantlenetworkio/op-geth/pull/42) at commit [0cf00ba](https://github.com/mantlenetworkio/op-geth/pull/42/commits/0cf00ba8bc26c27f433c1fa61bdf7d2750933544).*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "packages/contracts-bedrock/contracts/L1/OptimismPortal.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport { SafeCall } from \"../libraries/SafeCall.sol\";\nimport { L2OutputOracle } from \"./L2OutputOracle.sol\";\nimport { SystemConfig } from \"./SystemConfig.sol\";\nimport { Constants } from \"../libraries/Constants.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { SecureMerkleTrie } from \"../libraries/trie/SecureMerkleTrie.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { ResourceMetering } from \"./ResourceMetering.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @custom:proxied\n * @title OptimismPortal\n * @notice The OptimismPortal is a low-level contract responsible for passing messages between L1\n *         and L2. Messages sent directly to the OptimismPortal have no form of replayability.\n *         Users are encouraged to use the L1CrossDomainMessenger for a higher-level interface.\n */\ncontract OptimismPortal is Initializable, ResourceMetering, Semver {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Represents a proven withdrawal.\n     *\n     * @custom:field outputRoot    Root of the L2 output this was proven against.\n     * @custom:field timestamp     Timestamp at whcih the withdrawal was proven.\n     * @custom:field l2OutputIndex Index of the output this was proven against.\n     */\n    struct ProvenWithdrawal {\n        bytes32 outputRoot;\n        uint128 timestamp;\n        uint128 l2OutputIndex;\n    }\n\n    /**\n     * @notice Version of the deposit event.\n     */\n    uint256 internal constant DEPOSIT_VERSION = 1;\n\n    /**\n     * @notice The L2 gas limit set when eth is deposited using the receive() function.\n     */\n    uint64 internal constant RECEIVE_DEFAULT_GAS_LIMIT = 100_000;\n\n    /**\n     * @notice Address of the L2OutputOracle contract.\n     */\n    L2OutputOracle public immutable L2_ORACLE;\n\n    /**\n     * @notice Address of the SystemConfig contract.\n     */\n    SystemConfig public immutable SYSTEM_CONFIG;\n\n    /**\n     * @notice Address that has the ability to pause and unpause withdrawals.\n     */\n    address public immutable GUARDIAN;\n\n    /**\n     * @notice Address of  the L1 Mantle Token .\n     */\n    address public immutable L1_MNT_ADDRESS;\n\n    /**\n     * @notice Address of the L2 account which initiated a withdrawal in this transaction. If the\n     *         of this variable is the default L2 sender address, then we are NOT inside of a call\n     *         to finalizeWithdrawalTransaction.\n     */\n    address public l2Sender;\n\n    /**\n     * @notice A list of withdrawal hashes which have been successfully finalized.\n     */\n    mapping(bytes32 => bool) public finalizedWithdrawals;\n\n    /**\n     * @notice A mapping of withdrawal hashes to `ProvenWithdrawal` data.\n     */\n    mapping(bytes32 => ProvenWithdrawal) public provenWithdrawals;\n\n    /**\n     * @notice Determines if cross domain messaging is paused. When set to true,\n     *         withdrawals are paused. This may be removed in the future.\n     */\n    bool public paused;\n\n    /**\n     * @notice Emitted when a transaction is deposited from L1 to L2. The parameters of this event\n     *         are read by the rollup node and used to derive deposit transactions on L2.\n     *\n     * @param from       Address that triggered the deposit transaction.\n     * @param to         Address that the deposit transaction is directed to.\n     * @param version    Version of this deposit transaction event.\n     * @param opaqueData ABI encoded deposit data to be parsed off-chain.\n     */\n    event TransactionDeposited(\n        address indexed from,\n        address indexed to,\n        uint256 indexed version,\n        bytes opaqueData\n    );\n\n    /**\n     * @notice Emitted when a withdrawal transaction is proven.\n     *\n     * @param withdrawalHash Hash of the withdrawal transaction.\n     */\n    event WithdrawalProven(\n        bytes32 indexed withdrawalHash,\n        address indexed from,\n        address indexed to\n    );\n\n    /**\n     * @notice Emitted when a withdrawal transaction is finalized.\n     *\n     * @param withdrawalHash Hash of the withdrawal transaction.\n     * @param success        Whether the withdrawal transaction was successful.\n     */\n    event WithdrawalFinalized(bytes32 indexed withdrawalHash, bool success);\n\n    /**\n     * @notice Emitted when the pause is triggered.\n     *\n     * @param account Address of the account triggering the pause.\n     */\n    event Paused(address account);\n\n    /**\n     * @notice Emitted when the pause is lifted.\n     *\n     * @param account Address of the account triggering the unpause.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @notice Reverts when paused.\n     */\n    modifier whenNotPaused() {\n        require(paused == false, \"OptimismPortal: paused\");\n        _;\n    }\n\n    /**\n     * @custom:semver 1.6.0\n     *\n     * @param _l2Oracle                  Address of the L2OutputOracle contract.\n     * @param _guardian                  Address that can pause deposits and withdrawals.\n     * @param _paused                    Sets the contract's pausability state.\n     * @param _config                    Address of the SystemConfig contract.\n     */\n    constructor(\n        L2OutputOracle _l2Oracle,\n        address _guardian,\n        bool _paused,\n        SystemConfig _config,\n        address _l1MNT\n    ) Semver(1, 6, 0) {\n        L2_ORACLE = _l2Oracle;\n        GUARDIAN = _guardian;\n        SYSTEM_CONFIG = _config;\n        L1_MNT_ADDRESS = _l1MNT;\n        initialize(_paused);\n    }\n\n    /**\n     * @notice Initializer.\n     */\n    function initialize(bool _paused) public initializer {\n        l2Sender = Constants.DEFAULT_L2_SENDER;\n        paused = _paused;\n        __ResourceMetering_init();\n    }\n\n    /**\n     * @notice Pause deposits and withdrawals.\n     */\n    function pause() external {\n        require(msg.sender == GUARDIAN, \"OptimismPortal: only guardian can pause\");\n        paused = true;\n        emit Paused(msg.sender);\n    }\n\n    /**\n     * @notice Unpause deposits and withdrawals.\n     */\n    function unpause() external {\n        require(msg.sender == GUARDIAN, \"OptimismPortal: only guardian can unpause\");\n        paused = false;\n        emit Unpaused(msg.sender);\n    }\n\n    /**\n     * @notice Computes the minimum gas limit for a deposit. The minimum gas limit\n     *         linearly increases based on the size of the calldata. This is to prevent\n     *         users from creating L2 resource usage without paying for it. This function\n     *         can be used when interacting with the portal to ensure forwards compatibility.\n     *\n     */\n    function minimumGasLimit(uint64 _byteCount) public pure returns (uint64) {\n        return _byteCount * 16 + 21000;\n    }\n\n    /**\n     * @notice Accepts value so that users can send ETH directly to this contract and have the\n     *         funds be deposited to their address on L2. This is intended as a convenience\n     *         function for EOAs. Contracts should call the depositTransaction() function directly\n     *         otherwise any deposited funds will be lost due to address aliasing.\n     */\n    // solhint-disable-next-line ordering\n    receive() external payable {\n        depositTransaction(msg.value, 0, msg.sender, 0, RECEIVE_DEFAULT_GAS_LIMIT, false, bytes(\"\"));\n    }\n\n    /**\n     * @notice Accepts ETH value without triggering a deposit to L2. This function mainly exists\n     *         for the sake of the migration between the legacy Optimism system and Bedrock.\n     */\n    function donateETH() external payable {\n        // Intentionally empty.\n    }\n\n    /**\n     * @notice Getter for the resource config. Used internally by the ResourceMetering\n     *         contract. The SystemConfig is the source of truth for the resource config.\n     *\n     * @return ResourceMetering.ResourceConfig\n     */\n    function _resourceConfig()\n        internal\n        view\n        override\n        returns (ResourceMetering.ResourceConfig memory)\n    {\n        return SYSTEM_CONFIG.resourceConfig();\n    }\n\n    /**\n     * @notice Proves a withdrawal transaction.\n     *\n     * @param _tx              Withdrawal transaction to finalize.\n     * @param _l2OutputIndex   L2 output index to prove against.\n     * @param _outputRootProof Inclusion proof of the L2ToL1MessagePasser contract's storage root.\n     * @param _withdrawalProof Inclusion proof of the withdrawal in L2ToL1MessagePasser contract.\n     */\n    function proveWithdrawalTransaction(\n        Types.WithdrawalTransaction memory _tx,\n        uint256 _l2OutputIndex,\n        Types.OutputRootProof calldata _outputRootProof,\n        bytes[] calldata _withdrawalProof\n    ) external whenNotPaused {\n        // Prevent users from creating a deposit transaction where this address is the message\n        // sender on L2. Because this is checked here, we do not need to check again in\n        // `finalizeWithdrawalTransaction`.\n        require(\n            _tx.target != address(this),\n            \"OptimismPortal: you cannot send messages to the portal contract\"\n        );\n\n        // Get the output root and load onto the stack to prevent multiple mloads. This will\n        // revert if there is no output root for the given block number.\n        bytes32 outputRoot = L2_ORACLE.getL2Output(_l2OutputIndex).outputRoot;\n\n        // Verify that the output root can be generated with the elements in the proof.\n        require(\n            outputRoot == Hashing.hashOutputRootProof(_outputRootProof),\n            \"OptimismPortal: invalid output root proof\"\n        );\n\n        // Load the ProvenWithdrawal into memory, using the withdrawal hash as a unique identifier.\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(_tx);\n        ProvenWithdrawal memory provenWithdrawal = provenWithdrawals[withdrawalHash];\n\n        // We generally want to prevent users from proving the same withdrawal multiple times\n        // because each successive proof will update the timestamp. A malicious user can take\n        // advantage of this to prevent other users from finalizing their withdrawal. However,\n        // since withdrawals are proven before an output root is finalized, we need to allow users\n        // to re-prove their withdrawal only in the case that the output root for their specified\n        // output index has been updated.\n        require(\n            provenWithdrawal.timestamp == 0 ||\n                L2_ORACLE.getL2Output(provenWithdrawal.l2OutputIndex).outputRoot !=\n                provenWithdrawal.outputRoot,\n            \"OptimismPortal: withdrawal hash has already been proven\"\n        );\n\n        // Compute the storage slot of the withdrawal hash in the L2ToL1MessagePasser contract.\n        // Refer to the Solidity documentation for more information on how storage layouts are\n        // computed for mappings.\n        bytes32 storageKey = keccak256(\n            abi.encode(\n                withdrawalHash,\n                uint256(0) // The withdrawals mapping is at the first slot in the layout.\n            )\n        );\n\n        // Verify that the hash of this withdrawal was stored in the L2toL1MessagePasser contract\n        // on L2. If this is true, under the assumption that the SecureMerkleTrie does not have\n        // bugs, then we know that this withdrawal was actually triggered on L2 and can therefore\n        // be relayed on L1.\n        require(\n            SecureMerkleTrie.verifyInclusionProof(\n                abi.encode(storageKey),\n                hex\"01\",\n                _withdrawalProof,\n                _outputRootProof.messagePasserStorageRoot\n            ),\n            \"OptimismPortal: invalid withdrawal inclusion proof\"\n        );\n\n        // Designate the withdrawalHash as proven by storing the `outputRoot`, `timestamp`, and\n        // `l2BlockNumber` in the `provenWithdrawals` mapping. A `withdrawalHash` can only be\n        // proven once unless it is submitted again with a different outputRoot.\n        provenWithdrawals[withdrawalHash] = ProvenWithdrawal({\n            outputRoot: outputRoot,\n            timestamp: uint128(block.timestamp),\n            l2OutputIndex: uint128(_l2OutputIndex)\n        });\n\n        // Emit a `WithdrawalProven` event.\n        emit WithdrawalProven(withdrawalHash, _tx.sender, _tx.target);\n    }\n\n    /**\n     * @notice Finalizes a withdrawal transaction.\n     *\n     * @param _tx Withdrawal transaction to finalize.\n     */\n    function finalizeWithdrawalTransaction(Types.WithdrawalTransaction memory _tx)\n        external\n        whenNotPaused\n    {\n        // Make sure that the l2Sender has not yet been set. The l2Sender is set to a value other\n        // than the default value when a withdrawal transaction is being finalized. This check is\n        // a defacto reentrancy guard.\n        require(\n            l2Sender == Constants.DEFAULT_L2_SENDER,\n            \"OptimismPortal: can only trigger one withdrawal per transaction\"\n        );\n\n        // Grab the proven withdrawal from the `provenWithdrawals` map.\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(_tx);\n        ProvenWithdrawal memory provenWithdrawal = provenWithdrawals[withdrawalHash];\n\n        // A withdrawal can only be finalized if it has been proven. We know that a withdrawal has\n        // been proven at least once when its timestamp is non-zero. Unproven withdrawals will have\n        // a timestamp of zero.\n        require(\n            provenWithdrawal.timestamp != 0,\n            \"OptimismPortal: withdrawal has not been proven yet\"\n        );\n\n        // As a sanity check, we make sure that the proven withdrawal's timestamp is greater than\n        // starting timestamp inside the L2OutputOracle. Not strictly necessary but extra layer of\n        // safety against weird bugs in the proving step.\n        require(\n            provenWithdrawal.timestamp >= L2_ORACLE.startingTimestamp(),\n            \"OptimismPortal: withdrawal timestamp less than L2 Oracle starting timestamp\"\n        );\n\n        // A proven withdrawal must wait at least the finalization period before it can be\n        // finalized. This waiting period can elapse in parallel with the waiting period for the\n        // output the withdrawal was proven against. In effect, this means that the minimum\n        // withdrawal time is proposal submission time + finalization period.\n        require(\n            _isFinalizationPeriodElapsed(provenWithdrawal.timestamp),\n            \"OptimismPortal: proven withdrawal finalization period has not elapsed\"\n        );\n\n        // Grab the OutputProposal from the L2OutputOracle, will revert if the output that\n        // corresponds to the given index has not been proposed yet.\n        Types.OutputProposal memory proposal = L2_ORACLE.getL2Output(\n            provenWithdrawal.l2OutputIndex\n        );\n\n        // Check that the output root that was used to prove the withdrawal is the same as the\n        // current output root for the given output index. An output root may change if it is\n        // deleted by the challenger address and then re-proposed.\n        require(\n            proposal.outputRoot == provenWithdrawal.outputRoot,\n            \"OptimismPortal: output root proven is not the same as current output root\"\n        );\n\n        // Check that the output proposal has also been finalized.\n        require(\n            _isFinalizationPeriodElapsed(proposal.timestamp),\n            \"OptimismPortal: output proposal finalization period has not elapsed\"\n        );\n\n        // Check that this withdrawal has not already been finalized, this is replay protection.\n        require(\n            finalizedWithdrawals[withdrawalHash] == false,\n            \"OptimismPortal: withdrawal has already been finalized\"\n        );\n\n        // Mark the withdrawal as finalized so it can't be replayed.\n        finalizedWithdrawals[withdrawalHash] = true;\n\n        // Set the l2Sender so contracts know who triggered this withdrawal on L2.\n        l2Sender = _tx.sender;\n\n        // Trigger the call to the target contract. We use a custom low level method\n        // SafeCall.callWithMinGas to ensure two key properties\n        //   1. Target contracts cannot force this call to run out of gas by returning a very large\n        //      amount of data (and this is OK because we don't care about the returndata here).\n        //   2. The amount of gas provided to the execution context of the target is at least the\n        //      gas limit specified by the user. If there is not enough gas in the current context\n        //      to accomplish this, `callWithMinGas` will revert.\n        bool l1mntSuccess = false;\n        if (_tx.mntValue>0){\n            l1mntSuccess = IERC20(L1_MNT_ADDRESS).transfer(_tx.target, _tx.mntValue);\n        }\n        require(_tx.target != L1_MNT_ADDRESS, \"Directly calling MNT Token is forbidden\");\n        bool success = SafeCall.callWithMinGas(_tx.target, _tx.gasLimit, _tx.ethValue, _tx.data);\n        // Reset the l2Sender back to the default value.\n        l2Sender = Constants.DEFAULT_L2_SENDER;\n\n        // All withdrawals are immediately finalized. Replayability can\n        // be achieved through contracts built on top of this contract\n        emit WithdrawalFinalized(withdrawalHash, success && l1mntSuccess);\n\n        // Reverting here is useful for determining the exact gas cost to successfully execute the\n        // sub call to the target contract if the minimum gas limit specified by the user would not\n        // be sufficient to execute the sub call.\n        if ((success == false || l1mntSuccess == false) && tx.origin == Constants.ESTIMATION_ADDRESS) {\n            revert(\"OptimismPortal: withdrawal failed\");\n        }\n    }\n\n    /**\n     * @notice Accepts deposits of ETH and data, and emits a TransactionDeposited event for use in\n     *         deriving deposit transactions. Note that if a deposit is made by a contract, its\n     *         address will be aliased when retrieved using `tx.origin` or `msg.sender`. Consider\n     *         using the CrossDomainMessenger contracts for a simpler developer experience.\n     *\n     * @param _ethTxValue BVM_ETH value to send to the recipient.\n     * @param _mntValue   Mint MNT amount to from address on L2\n     * @param _to         Target address on L2.\n     * @param _mntTxValue MNT value to send to the recipient.\n     * @param _gasLimit   Minimum L2 gas limit (can be greater than or equal to this value).\n     * @param _isCreation Whether or not the transaction is a contract creation.\n     * @param _data       Data to trigger the recipient with.\n     */\n    function depositTransaction(\n        uint256 _ethTxValue,\n        uint256 _mntValue,\n        address _to,\n        uint256 _mntTxValue,\n        uint64 _gasLimit,\n        bool _isCreation,\n        bytes memory _data\n    ) public payable metered(_gasLimit) {\n        // Just to be safe, make sure that people specify address(0) as the target when doing\n        // contract creations.\n        if (_isCreation) {\n            require(\n                _to == address(0),\n                \"OptimismPortal: must send to address(0) when creating a contract\"\n            );\n        }\n\n        // Prevent depositing transactions that have too small of a gas limit. Users should pay\n        // more for more resource usage.\n        require(\n            _gasLimit >= minimumGasLimit(uint64(_data.length)),\n            \"OptimismPortal: gas limit too small\"\n        );\n\n        // Prevent the creation of deposit transactions that have too much calldata. This gives an\n        // upper limit on the size of unsafe blocks over the p2p network. 120kb is chosen to ensure\n        // that the transaction can fit into the p2p network policy of 128kb even though deposit\n        // transactions are not gossipped over the p2p network.\n        require(_data.length <= 120_000, \"OptimismPortal: data too large\");\n\n        if (_mntValue != 0) {\n            IERC20(L1_MNT_ADDRESS).safeTransferFrom(msg.sender, address(this), _mntValue);\n        }\n\n        // Transform the from-address to its alias if the caller is a contract.\n        address from = msg.sender;\n        if (msg.sender != tx.origin) {\n            from = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n        }\n\n        // Compute the opaque data that will be emitted as part of the TransactionDeposited event.\n        // We use opaque data so that we can update the TransactionDeposited event in the future\n        // without breaking the current interface.\n        bytes memory opaqueData = abi.encodePacked(\n            _mntValue,\n            _mntTxValue,\n            msg.value,\n            _ethTxValue,\n            _gasLimit,\n            _isCreation,\n            _data\n        );\n\n        // Emit a TransactionDeposited event so that the rollup node can derive a deposit\n        // transaction for this deposit.\n        emit TransactionDeposited(from, _to, DEPOSIT_VERSION, opaqueData);\n    }\n\n    /**\n     * @notice Determine if a given output is finalized. Reverts if the call to\n     *         L2_ORACLE.getL2Output reverts. Returns a boolean otherwise.\n     *\n     * @param _l2OutputIndex Index of the L2 output to check.\n     *\n     * @return Whether or not the output is finalized.\n     */\n    function isOutputFinalized(uint256 _l2OutputIndex) external view returns (bool) {\n        return _isFinalizationPeriodElapsed(L2_ORACLE.getL2Output(_l2OutputIndex).timestamp);\n    }\n\n    /**\n     * @notice Determines whether the finalization period has elapsed w/r/t a given timestamp.\n     *\n     * @param _timestamp Timestamp to check.\n     *\n     * @return Whether or not the finalization period has elapsed.\n     */\n    function _isFinalizationPeriodElapsed(uint256 _timestamp) internal view returns (bool) {\n        return block.timestamp > _timestamp + L2_ORACLE.FINALIZATION_PERIOD_SECONDS();\n    }\n}"
    },
    {
      "filename": "core/state_transition.go",
      "content": "// Copyright 2014 The go-ethereum Authors\n// This file is part of the go-ethereum library.\n//\n// The go-ethereum library is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// The go-ethereum library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.\n\npackage core\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"math/big\"\n\n\t\"github.com/ethereum/go-ethereum/common\"\n\tcmath \"github.com/ethereum/go-ethereum/common/math\"\n\t\"github.com/ethereum/go-ethereum/core/types\"\n\t\"github.com/ethereum/go-ethereum/core/vm\"\n\t\"github.com/ethereum/go-ethereum/crypto\"\n\t\"github.com/ethereum/go-ethereum/log\"\n\t\"github.com/ethereum/go-ethereum/params\"\n\t\"golang.org/x/crypto/sha3\"\n)\n\nvar (\n\tBVM_ETH_ADDR = common.HexToAddress(\"0xdEAddEaDdeadDEadDEADDEAddEADDEAddead1111\")\n)\n\n// ExecutionResult includes all output after executing given evm\n// message no matter the execution itself is successful or not.\ntype ExecutionResult struct {\n\tUsedGas    uint64 // Total used gas but include the refunded gas\n\tErr        error  // Any error encountered during the execution(listed in core/vm/errors.go)\n\tReturnData []byte // Returned data from evm(function result or data supplied with revert opcode)\n}\n\n// Unwrap returns the internal evm error which allows us for further\n// analysis outside.\nfunc (result *ExecutionResult) Unwrap() error {\n\treturn result.Err\n}\n\n// Failed returns the indicator whether the execution is successful or not\nfunc (result *ExecutionResult) Failed() bool { return result.Err != nil }\n\n// Return is a helper function to help caller distinguish between revert reason\n// and function return. Return returns the data after execution if no error occurs.\nfunc (result *ExecutionResult) Return() []byte {\n\tif result.Err != nil {\n\t\treturn nil\n\t}\n\treturn common.CopyBytes(result.ReturnData)\n}\n\n// Revert returns the concrete revert reason if the execution is aborted by `REVERT`\n// opcode. Note the reason can be nil if no data supplied with revert opcode.\nfunc (result *ExecutionResult) Revert() []byte {\n\tif result.Err != vm.ErrExecutionReverted {\n\t\treturn nil\n\t}\n\treturn common.CopyBytes(result.ReturnData)\n}\n\n// IntrinsicGas computes the 'intrinsic gas' for a message with the given data.\nfunc IntrinsicGas(data []byte, accessList types.AccessList, isContractCreation bool, isHomestead, isEIP2028 bool, isEIP3860 bool) (uint64, error) {\n\t// Set the starting gas for the raw transaction\n\tvar gas uint64\n\tif isContractCreation && isHomestead {\n\t\tgas = params.TxGasContractCreation\n\t} else {\n\t\tgas = params.TxGas\n\t}\n\tdataLen := uint64(len(data))\n\t// Bump the required gas by the amount of transactional data\n\tif dataLen > 0 {\n\t\t// Zero and non-zero bytes are priced differently\n\t\tvar nz uint64\n\t\tfor _, byt := range data {\n\t\t\tif byt != 0 {\n\t\t\t\tnz++\n\t\t\t}\n\t\t}\n\t\t// Make sure we don't exceed uint64 for all data combinations\n\t\tnonZeroGas := params.TxDataNonZeroGasFrontier\n\t\tif isEIP2028 {\n\t\t\tnonZeroGas = params.TxDataNonZeroGasEIP2028\n\t\t}\n\t\tif (math.MaxUint64-gas)/nonZeroGas < nz {\n\t\t\treturn 0, ErrGasUintOverflow\n\t\t}\n\t\tgas += nz * nonZeroGas\n\n\t\tz := dataLen - nz\n\t\tif (math.MaxUint64-gas)/params.TxDataZeroGas < z {\n\t\t\treturn 0, ErrGasUintOverflow\n\t\t}\n\t\tgas += z * params.TxDataZeroGas\n\n\t\tif isContractCreation && isEIP3860 {\n\t\t\tlenWords := toWordSize(dataLen)\n\t\t\tif (math.MaxUint64-gas)/params.InitCodeWordGas < lenWords {\n\t\t\t\treturn 0, ErrGasUintOverflow\n\t\t\t}\n\t\t\tgas += lenWords * params.InitCodeWordGas\n\t\t}\n\t}\n\tif accessList != nil {\n\t\tgas += uint64(len(accessList)) * params.TxAccessListAddressGas\n\t\tgas += uint64(accessList.StorageKeys()) * params.TxAccessListStorageKeyGas\n\t}\n\treturn gas, nil\n}\n\n// toWordSize returns the ceiled word size required for init code payment calculation.\nfunc toWordSize(size uint64) uint64 {\n\tif size > math.MaxUint64-31 {\n\t\treturn math.MaxUint64/32 + 1\n\t}\n\n\treturn (size + 31) / 32\n}\n\ntype RunMode uint8\n\nconst (\n\tCommitMode RunMode = iota\n\tGasEstimationMode\n\tGasEstimationWithSkipCheckBalanceMode\n\tEthcallMode\n)\n\n// A Message contains the data derived from a single transaction that is relevant to state\n// processing.\ntype Message struct {\n\tTo         *common.Address\n\tFrom       common.Address\n\tNonce      uint64\n\tValue      *big.Int\n\tGasLimit   uint64\n\tGasPrice   *big.Int\n\tGasFeeCap  *big.Int\n\tGasTipCap  *big.Int\n\tData       []byte\n\tAccessList types.AccessList\n\n\t// When SkipAccountCheckss is true, the message nonce is not checked against the\n\t// account nonce in state. It also disables checking that the sender is an EOA.\n\t// This field will be set to true for operations like RPC eth_call.\n\tSkipAccountChecks bool\n\n\tIsSystemTx    bool                // IsSystemTx indicates the message, if also a deposit, does not emit gas usage.\n\tIsDepositTx   bool                // IsDepositTx indicates the message is force-included and can persist a mint.\n\tMint          *big.Int            // Mint is the amount to mint before EVM processing, or nil if there is no minting.\n\tETHValue      *big.Int            // ETHValue is the amount to mint BVM_ETH before EVM processing, or nil if there is no minting.\n\tETHTxValue    *big.Int            // ETHTxValue is the amount to be transferred to msg.To before EVM processing, and the transfer will be reverted if EVM failed\n\tMetaTxParams  *types.MetaTxParams // MetaTxParams contains necessary parameter to sponsor gas fee for msg.From.\n\tRollupDataGas types.RollupGasData // RollupDataGas indicates the rollup cost of the message, 0 if not a rollup or no cost.\n\n\t// runMode\n\tRunMode RunMode\n}\n\n// TransactionToMessage converts a transaction into a Message.\nfunc TransactionToMessage(tx *types.Transaction, s types.Signer, baseFee *big.Int, rules *params.Rules) (*Message, error) {\n\tif rules == nil {\n\t\treturn nil, errors.New(\"param rules is nil pointer\")\n\t}\n\tmetaTxParams, err := types.DecodeAndVerifyMetaTxParams(tx, rules.IsMetaTxV2)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tmsg := &Message{\n\t\tNonce:             tx.Nonce(),\n\t\tGasLimit:          tx.Gas(),\n\t\tGasPrice:          new(big.Int).Set(tx.GasPrice()),\n\t\tGasFeeCap:         new(big.Int).Set(tx.GasFeeCap()),\n\t\tGasTipCap:         new(big.Int).Set(tx.GasTipCap()),\n\t\tTo:                tx.To(),\n\t\tValue:             tx.Value(),\n\t\tData:              tx.Data(),\n\t\tAccessList:        tx.AccessList(),\n\t\tIsSystemTx:        tx.IsSystemTx(),\n\t\tIsDepositTx:       tx.IsDepositTx(),\n\t\tMint:              tx.Mint(),\n\t\tRollupDataGas:     tx.RollupDataGas(),\n\t\tETHValue:          tx.ETHValue(),\n\t\tETHTxValue:        tx.ETHTxValue(),\n\t\tMetaTxParams:      metaTxParams,\n\t\tSkipAccountChecks: false,\n\t\tRunMode:           CommitMode,\n\t}\n\t// If baseFee provided, set gasPrice to effectiveGasPrice.\n\tif baseFee != nil {\n\t\tmsg.GasPrice = cmath.BigMin(msg.GasPrice.Add(msg.GasTipCap, baseFee), msg.GasFeeCap)\n\t}\n\tmsg.From, err = types.Sender(s, tx)\n\treturn msg, err\n}\n\n// CalculateRollupGasDataFromMessage calculate RollupGasData from message.\nfunc (st *StateTransition) CalculateRollupGasDataFromMessage() {\n\ttx := types.NewTx(&types.DynamicFeeTx{\n\t\tNonce:     st.msg.Nonce,\n\t\tValue:     st.msg.Value,\n\t\tGas:       st.msg.GasLimit,\n\t\tGasTipCap: st.msg.GasTipCap,\n\t\tGasFeeCap: st.msg.GasFeeCap,\n\t\tData:      st.msg.Data,\n\t})\n\n\tst.msg.RollupDataGas = tx.RollupDataGas()\n\n\t// add a constant to cover sigs(V,R,S) and other data to make sure that the gasLimit from eth_estimateGas can cover L1 cost\n\t// just used for estimateGas and the actual L1 cost depends on users' tx when executing\n\tst.msg.RollupDataGas.Ones += 80\n}\n\n// ApplyMessage computes the new state by applying the given message\n// against the old state within the environment.\n//\n// ApplyMessage returns the bytes returned by any EVM execution (if it took place),\n// the gas used (which includes gas refunds) and an error if it failed. An error always\n// indicates a core error meaning that the message would always fail for that particular\n// state and would never be accepted within a block.\nfunc ApplyMessage(evm *vm.EVM, msg *Message, gp *GasPool) (*ExecutionResult, error) {\n\treturn NewStateTransition(evm, msg, gp).TransitionDb()\n}\n\n// StateTransition represents a state transition.\n//\n// == The State Transitioning Model\n//\n// A state transition is a change made when a transaction is applied to the current world\n// state. The state transitioning model does all the necessary work to work out a valid new\n// state root.\n//\n//  1. Nonce handling\n//  2. Pre pay gas\n//  3. Create a new state object if the recipient is nil\n//  4. Value transfer\n//\n// == If contract creation ==\n//\n//\t4a. Attempt to run transaction data\n//\t4b. If valid, use result as code for the new state object\n//\n// == end ==\n//\n//  5. Run Script section\n//  6. Derive new state root\ntype StateTransition struct {\n\tgp           *GasPool\n\tmsg          *Message\n\tgasRemaining uint64\n\tinitialGas   uint64\n\tstate        vm.StateDB\n\tevm          *vm.EVM\n}\n\n// NewStateTransition initialises and returns a new state transition object.\nfunc NewStateTransition(evm *vm.EVM, msg *Message, gp *GasPool) *StateTransition {\n\treturn &StateTransition{\n\t\tgp:    gp,\n\t\tevm:   evm,\n\t\tmsg:   msg,\n\t\tstate: evm.StateDB,\n\t}\n}\n\n// to returns the recipient of the message.\nfunc (st *StateTransition) to() common.Address {\n\tif st.msg == nil || st.msg.To == nil /* contract creation */ {\n\t\treturn common.Address{}\n\t}\n\treturn *st.msg.To\n}\n\nfunc (st *StateTransition) buyGas() (*big.Int, error) {\n\tif err := st.applyMetaTransaction(); err != nil {\n\t\treturn nil, err\n\t}\n\tmgval := new(big.Int).SetUint64(st.msg.GasLimit)\n\tmgval = mgval.Mul(mgval, st.msg.GasPrice)\n\tvar l1Cost *big.Int\n\tif st.msg.RunMode == GasEstimationMode || st.msg.RunMode == GasEstimationWithSkipCheckBalanceMode {\n\t\tst.CalculateRollupGasDataFromMessage()\n\t}\n\tif st.evm.Context.L1CostFunc != nil && st.msg.RunMode != EthcallMode {\n\t\tl1Cost = st.evm.Context.L1CostFunc(st.evm.Context.BlockNumber.Uint64(), st.evm.Context.Time, st.msg.RollupDataGas, st.msg.IsDepositTx, st.msg.To)\n\t}\n\tif l1Cost != nil && (st.msg.RunMode == GasEstimationMode || st.msg.RunMode == GasEstimationWithSkipCheckBalanceMode) {\n\t\tmgval = mgval.Add(mgval, l1Cos"
    }
  ]
}